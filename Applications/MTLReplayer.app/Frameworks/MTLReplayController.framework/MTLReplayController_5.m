uint64_t GetDeviceObjectStreamRef(uint64_t a1, uint64_t a2)
{
  _QWORD *entry;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;

  v7 = a2;
  entry = find_entry(*(_QWORD *)(a1 + 24), &v7, 8uLL, 0);
  if (*entry
    && (v4 = *(_QWORD *)(*entry + 32)) != 0
    && (v5 = atomic_load((unint64_t *)(*(_QWORD *)(a1 + 16) + 72)), v5 < *(_QWORD *)(v4 + 24)))
  {
    return **(_QWORD **)(v4 + 8);
  }
  else
  {
    return 0;
  }
}

_OWORD *PushSparseDownloadRequests(_OWORD *result, apr_array_header_t *a2, uint64_t a3)
{
  _OWORD *v5;
  uint64_t v6;
  uint64_t v7;
  __int128 *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;

  if (*((int *)result + 3) >= 1)
  {
    v5 = result;
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = (__int128 *)(*((_QWORD *)v5 + 3) + v6);
      if (*(_QWORD *)v8 == 80)
      {
        result = find_entry(a3, (_BYTE *)v8 + 8, 8uLL, 0);
        if (*(_QWORD *)result)
        {
          if (*(_QWORD *)(*(_QWORD *)result + 32))
          {
            result = apr_array_push(a2);
            v9 = v8[3];
            v11 = *v8;
            v10 = v8[1];
            result[2] = v8[2];
            result[3] = v9;
            *result = v11;
            result[1] = v10;
          }
        }
      }
      ++v7;
      v6 += 64;
    }
    while (v7 < *((int *)v5 + 3));
  }
  return result;
}

uint64_t CompareRequestByTextureLevel(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unsigned int v4;
  unsigned int v5;
  BOOL v6;
  _BOOL4 v7;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
  {
    v4 = *(unsigned __int16 *)(a1 + 34);
    v5 = *(unsigned __int16 *)(a2 + 34);
    v6 = v4 >= v5;
    v7 = v4 != v5;
    if (v6)
      return v7;
    else
      return 0xFFFFFFFFLL;
  }
  else if (v2 < v3)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 1;
  }
}

id GTMTLReplayController_dumpLibrary(uint64_t a1, char *a2, char *a3)
{
  void *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  void *v9;
  unsigned int v10;
  id v11;
  _QWORD *v12;
  size_t FileWithFilename;
  unsigned int *v14;
  void *v15;
  void *v16;
  unsigned __int8 v17;
  id v18;
  uint64_t v19;
  id v20;
  unsigned __int8 v21;
  id v22;
  void *v23;
  id v24;
  id v25;
  id NSError;
  id v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  unsigned __int8 v32;
  void *v33;
  void *v34;
  unsigned __int8 v35;
  id v36;
  id v37;
  void *v38;
  id v39;
  id v40;
  id v42;
  id v43;
  id v44;
  id v45;
  NSErrorUserInfoKey v46;
  id v47;
  NSErrorUserInfoKey v48;
  id v49;
  NSErrorUserInfoKey v50;
  id v51;
  NSErrorUserInfoKey v52;
  id v53;

  if (!a3)
    a3 = a2;
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a3));
  if (objc_msgSend(v5, "hasPrefix:", CFSTR("/")))
  {
    v6 = objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "substringFromIndex:", 1));

    v5 = (void *)v6;
  }
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 22568), "URLByAppendingPathComponent:", v5));
  v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "path"));
  v10 = objc_msgSend(v8, "fileExistsAtPath:", v9);

  if (!v10)
  {
    v12 = **(_QWORD ***)a1;
    FileWithFilename = GTCaptureArchive_getFileWithFilename((uint64_t)v12, a2);
    if (!FileWithFilename)
    {
      NSError = MakeNSError(101, &__NSDictionary0__struct);
      v27 = (id)objc_claimAutoreleasedReturnValue(NSError);
      GTMTLReplay_handleNSError(v27);

      goto LABEL_21;
    }
    v14 = (unsigned int *)FileWithFilename;
    if ((*(_BYTE *)(FileWithFilename + 16) & 2) != 0)
    {
      v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", *v12));
      v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a2));
      v20 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "stringByAppendingPathComponent:", v29));

      v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
      v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "URLByDeletingLastPathComponent"));
      v45 = 0;
      v32 = objc_msgSend(v30, "createDirectoryAtURL:withIntermediateDirectories:attributes:error:", v31, 1, 0, &v45);
      v18 = v45;

      if ((v32 & 1) != 0)
      {
        v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
        v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "path"));
        v44 = v18;
        v35 = objc_msgSend(v33, "copyItemAtPath:toPath:error:", v20, v34, &v44);
        v22 = v44;

        if ((v35 & 1) != 0)
          goto LABEL_15;
        v50 = NSUnderlyingErrorKey;
        v51 = v22;
        v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v51, &v50, 1));
        v18 = v22;
      }
      else
      {
        v52 = NSUnderlyingErrorKey;
        v53 = v18;
        v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v53, &v52, 1));
      }
      v39 = MakeNSError(101, v38);
      v40 = (id)objc_claimAutoreleasedReturnValue(v39);
      GTMTLReplay_handleNSError(v40);

    }
    else
    {
      v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "URLByDeletingLastPathComponent"));
      v43 = 0;
      v17 = objc_msgSend(v15, "createDirectoryAtURL:withIntermediateDirectories:attributes:error:", v16, 1, 0, &v43);
      v18 = v43;

      if ((v17 & 1) != 0)
      {
        v19 = *(_QWORD *)(a1 + 152);
        v20 = objc_retainAutorelease(objc_msgSend(objc_alloc((Class)NSMutableData), "initWithLength:", *v14));
        GTCaptureArchive_fillBufferCompressedDeflate((uint64_t)v12, v19, (uint64_t)v14, objc_msgSend(v20, "mutableBytes"), *v14, 0);
        v42 = v18;
        v21 = objc_msgSend(v20, "writeToURL:options:error:", v7, 1, &v42);
        v22 = v42;

        if ((v21 & 1) == 0)
        {
          v46 = NSUnderlyingErrorKey;
          v47 = v22;
          v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v47, &v46, 1));
          v24 = MakeNSError(101, v23);
          v25 = (id)objc_claimAutoreleasedReturnValue(v24);
          GTMTLReplay_handleNSError(v25);

LABEL_21:
          v11 = 0;
          goto LABEL_22;
        }
LABEL_15:

        v11 = v7;
        goto LABEL_22;
      }
      v48 = NSUnderlyingErrorKey;
      v49 = v18;
      v20 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v49, &v48, 1));
      v36 = MakeNSError(101, v20);
      v37 = (id)objc_claimAutoreleasedReturnValue(v36);
      GTMTLReplay_handleNSError(v37);

    }
    goto LABEL_21;
  }
  v11 = v7;
LABEL_22:

  return v11;
}

id GTMTLReplayController_dumpPipelineLibrary(uint64_t a1, char *a2, char *a3)
{
  const CATransform3D **v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  unsigned int v11;
  apr_allocator_t *v12;
  id v13;
  uint64_t v14;
  uint64_t v15;
  apr_pool_t *v16;
  unsigned int *v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  NSSet *v24;
  void *v25;
  void *v26;
  id NSError;
  id v28;
  id v29;
  id v30;
  id *v31;
  NSErrorUserInfoKey *v32;
  uint64_t v33;
  void *v34;
  id v35;
  id v36;
  id v38;
  uint64_t v39;
  void *i;
  uint64_t v41;
  uint64_t v42;
  id v43;
  uint64_t v44;
  uint64_t v45;
  const CATransform3D **v46;
  void *v47;
  const CATransform3D *v48;
  void *v49;
  void *v50;
  CATransform3D *v51;
  void *v52;
  id v53;
  void *v54;
  id v55;
  uint64_t v56;
  void *v57;
  id v58;
  uint64_t v59;
  id obj;
  id v61;
  id v62;
  id v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  id v68;
  id v69;
  char v70;
  apr_pool_t *newpool;
  NSErrorUserInfoKey v72;
  const __CFString *v73;
  _QWORD v74[2];
  _BYTE v75[128];
  NSErrorUserInfoKey v76;
  id v77;
  _QWORD v78[2];
  _QWORD v79[2];
  NSErrorUserInfoKey v80;
  const __CFString *v81;

  if (!a3)
    a3 = a2;
  v5 = &CATransform3DIdentity_ptr;
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a3));
  if (objc_msgSend(v6, "hasPrefix:", CFSTR("/")))
  {
    v7 = objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "substringFromIndex:", 1));

    v6 = (void *)v7;
  }
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 22568), "URLByAppendingPathComponent:", v6));
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
  v70 = 0;
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "path"));
  v11 = objc_msgSend(v9, "fileExistsAtPath:isDirectory:", v10, &v70);

  if (v11)
  {
    if (v70)
    {
      v13 = v8;
    }
    else
    {
      NSError = MakeNSError(101, &__NSDictionary0__struct);
      v28 = (id)objc_claimAutoreleasedReturnValue(NSError);
      GTMTLReplay_handleNSError(v28);

      v13 = 0;
    }
    goto LABEL_16;
  }
  v14 = **(_QWORD **)a1;
  v15 = *(_QWORD *)(a1 + 152);
  v69 = 0;
  newpool = 0;
  apr_pool_create_ex(&newpool, 0, 0, v12);
  v16 = newpool;
  v17 = GTCaptureArchive_mapData(v14, v15, a2, newpool);
  if (v17)
  {
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytesNoCopy:length:freeWhenDone:](NSData, "dataWithBytesNoCopy:length:freeWhenDone:", v17, v18, 0));
    v21 = objc_opt_class(NSDictionary, v20);
    v56 = objc_opt_class(NSData, v22);
    v24 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v21, v56, objc_opt_class(NSString, v23), 0);
    v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
    v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:](NSKeyedUnarchiver, "unarchivedObjectOfClasses:fromData:error:", v25, v19, &v69));

    apr_pool_destroy(v16);
  }
  else
  {
    apr_pool_destroy(v16);
    v80 = NSLocalizedDescriptionKey;
    v81 = CFSTR("File not found in archive");
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v81, &v80, 1));
    v29 = MakeNSError(101, v19);
    v69 = (id)objc_claimAutoreleasedReturnValue(v29);
    GTMTLReplay_handleNSError(v69);
    v26 = 0;
  }

  v30 = v69;
  if (v30 || !objc_msgSend(v26, "count"))
  {
    v78[0] = NSLocalizedDescriptionKey;
    v78[1] = NSUnderlyingErrorKey;
    v79[0] = CFSTR("Failed to decode pipeline library data");
    v79[1] = v30;
    v31 = (id *)v79;
    v32 = (NSErrorUserInfoKey *)v78;
    v33 = 2;
LABEL_14:
    v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v31, v32, v33));
    v35 = MakeNSError(101, v34);
    v36 = (id)objc_claimAutoreleasedReturnValue(v35);
    GTMTLReplay_handleNSError(v36);

    v13 = 0;
    goto LABEL_15;
  }
  v68 = 0;
  objc_msgSend(v9, "createDirectoryAtURL:withIntermediateDirectories:attributes:error:", v8, 1, 0, &v68);
  v38 = v68;
  if (v38)
  {
    v30 = v38;
    v76 = NSUnderlyingErrorKey;
    v77 = v38;
    v31 = &v77;
    v32 = &v76;
    v33 = 1;
    goto LABEL_14;
  }
  v66 = 0u;
  v67 = 0u;
  v64 = 0u;
  v65 = 0u;
  obj = v26;
  v58 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v64, v75, 16);
  if (!v58)
    goto LABEL_30;
  v59 = *(_QWORD *)v65;
  v57 = v26;
  while (2)
  {
    for (i = 0; i != v58; i = (char *)i + 1)
    {
      if (*(_QWORD *)v65 != v59)
        objc_enumerationMutation(obj);
      v41 = *(_QWORD *)(*((_QWORD *)&v64 + 1) + 8 * (_QWORD)i);
      v42 = objc_opt_class(v5[296], v39);
      if ((objc_opt_isKindOfClass(v41, v42) & 1) == 0)
      {
        v63 = 0;
        GTMTLReplay_fillError(&v63, 101, &__NSDictionary0__struct);
        v43 = v63;
        GTMTLReplay_handleNSError(v43);
LABEL_34:

        v13 = 0;
        v26 = v57;
        goto LABEL_15;
      }
      v43 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(obj, "objectForKeyedSubscript:", v41));
      v45 = objc_opt_class(NSData, v44);
      if ((objc_opt_isKindOfClass(v43, v45) & 1) == 0)
      {
        v62 = 0;
        GTMTLReplay_fillError(&v62, 101, &__NSDictionary0__struct);
        v53 = v62;
        GTMTLReplay_handleNSError(v53);

        goto LABEL_34;
      }
      v46 = v5;
      v47 = v9;
      v48 = v5[296];
      v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "path"));
      v74[0] = v49;
      v74[1] = v41;
      v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v74, 2));
      v51 = (CATransform3D *)v48;
      v9 = v47;
      v52 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D pathWithComponents:](v51, "pathWithComponents:", v50));

      if ((objc_msgSend(v47, "createFileAtPath:contents:attributes:", v52, v43, 0) & 1) == 0)
      {
        v72 = NSLocalizedDescriptionKey;
        v73 = CFSTR("Failed to create temporary pipeline library file");
        v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v73, &v72, 1));
        v61 = 0;
        GTMTLReplay_fillError(&v61, 101, v54);
        v55 = v61;
        GTMTLReplay_handleNSError(v55);

        goto LABEL_34;
      }

      v5 = v46;
    }
    v26 = v57;
    v58 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v64, v75, 16);
    if (v58)
      continue;
    break;
  }
LABEL_30:

  v13 = v8;
LABEL_15:

LABEL_16:
  return v13;
}

uint64_t GTMTLReplayController_makeController(uint64_t a1, apr_pool_t *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11;
  apr_allocator_t *v12;
  uint64_t v13;
  unint64_t v14;
  apr_pool_t **v15;
  apr_allocator_t *v16;
  uint64_t v17;
  apr_pool_t *v18;
  apr_allocator_t *v19;
  apr_array_header_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  apr_array_header_t *v24;
  uint64_t v25;
  id v26;
  void *v27;
  void *v28;
  void *v29;
  id v30;
  id v31;
  id v32;
  char *v33;
  uint64_t v34;
  char *i;
  id v36;
  id v37;
  id v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  id v46;
  id v47;
  id v48;
  uint64_t v49;
  void *v50;
  apr_status_t (__cdecl *v51)(void *);
  uint64_t v52;
  GTMTLReplaySharedResourcePool *v53;
  void *v54;
  GTMTLReplaySharedBlitBuffer *v55;
  void *v56;
  GTMTLReplaySharedBlitBuffer *v57;
  void *v58;
  void *v59;
  uint64_t v60;
  NSBundle *v61;
  void *v62;
  void *v63;
  id v64;
  id v65;
  id v66;
  void *v67;
  id v68;
  id v69;
  void *v70;
  NSString *v71;
  void *v72;
  uint64_t v73;
  void *v74;
  void *v75;
  uint64_t v76;
  id v77;
  uint64_t v78;
  void *v79;
  _QWORD *v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  uint64_t j;
  uint64_t v85;
  unint64_t v86;
  unint64_t v87;
  uint64_t v89;
  unint64_t v90;
  id v91;
  uint64_t v92;
  int v93;
  uint64_t k;
  uint64_t v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t v99;
  unint64_t v100;
  id v101;
  dispatch_semaphore_t v102;
  void *v103;
  dispatch_group_t v104;
  void *v105;
  uint64_t v106;
  void *v107;
  void *v108;
  void *v109;
  _DWORD **v110;
  uint64_t v111;
  apr_allocator_t *v112;
  apr_pool_t *v113;
  apr_array_header_t *v114;
  apr_array_header_t *v115;
  uint64_t v116;
  int nelts;
  uint64_t m;
  _QWORD *v119;
  int v120;
  uint64_t n;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  unsigned int v125;
  unsigned int v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  int v130;
  uint64_t v131;
  unint64_t *v132;
  void *v133;
  unsigned int v134;
  int v135;
  uint64_t v136;
  apr_pool_t *ii;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  int v141;
  uint64_t v143;
  uint64_t v144;
  apr_pool_t *v145;
  uint64_t v146;
  uint64_t v147;
  void *v148;
  void *v149;
  void *v150;
  id v151;
  void *v152;
  void *v153;
  apr_pool_t *v154;
  uint64_t v155;
  uint64_t v156;
  apr_allocator_t *v157;
  uint64_t v158;
  apr_hash_index_t *v159;
  apr_hash_index_t *v160;
  apr_array_header_t *v161;
  uint64_t v162;
  uint64_t v163;
  apr_allocator_t *v164;
  os_signpost_id_t v165;
  apr_array_header_t *v166;
  void *v167;
  NSObject *v168;
  unint64_t v169;
  int v170;
  uint64_t v171;
  apr_pool_t *v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  void *v176;
  NSObject *v177;
  void *v178;
  NSObject *v179;
  int v180;
  uint64_t v181;
  apr_pool_t *v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  void *v186;
  NSObject *v187;
  GTMTLReplayActivityLog *v188;
  GTMTLReplayActivityLog *v189;
  unsigned int *v190;
  signed int v191;
  uint64_t v192;
  uint64_t v193;
  void *v194;
  signed int v195;
  uint64_t v196;
  id v197;
  void *v198;
  dispatch_semaphore_t v199;
  void *v200;
  uint64_t v201;
  void *v202;
  id v203;
  void *v204;
  uint64_t v206;
  void **v207;
  id v208;
  id v209;
  id context;
  id contexta;
  id v212;
  id v213;
  id obj;
  id obja;
  apr_pool_t *pool;
  id v217;
  uint64_t v218;
  unint64_t v219;
  apr_hash_t *ht;
  apr_hash_t *hta;
  id v222;
  id v223;
  id v224;
  apr_pool_t *newpool;
  uint64_t v226;
  apr_pool_t *v227[2];
  __int128 v228;
  __int128 v229;
  __int128 v230;
  apr_pool_t *p[16];

  v11 = a3;
  obj = a4;
  v217 = a4;
  v212 = a5;
  v208 = a5;
  context = a6;
  v209 = a6;
  newpool = 0;
  pool = a2;
  apr_pool_create_ex(&newpool, a2, 0, v12);
  v13 = 80;
  if ((dword_75313C & 0x400) == 0)
    v13 = 64;
  v14 = *(_QWORD *)(a1 + v13);
  v15 = (apr_pool_t **)apr_hash_make(newpool);
  GTMTLSMContext_buildResourceChildrenMap(*(uint64_t **)(a1 + 40), v14, (uint64_t)v15, v16);
  v218 = a1;
  v17 = *(_QWORD *)(a1 + 40);
  p[0] = 0;
  ht = (apr_hash_t *)v15;
  v18 = *v15;
  apr_pool_create_ex(p, *v15, 0, v19);
  v20 = apr_array_make(p[0], *(_DWORD *)(*(_QWORD *)(v17 + 224) + 12), 8);
  GTMTLSMContext_getObjects(*(_DWORD **)(v17 + 224), v14, v20);
  if (v20->nelts >= 1)
  {
    v21 = 0;
    do
    {
      v22 = *(_QWORD *)&v20->elts[8 * v21];
      v23 = *find_entry((uint64_t)ht, (_BYTE *)(v22 + 40), 8uLL, 0);
      if (!v23 || (v24 = *(apr_array_header_t **)(v23 + 32)) == 0)
      {
        v24 = apr_array_make(v18, 1, 8);
        apr_hash_set(ht, (const void *)(v22 + 40), 8, v24);
      }
      *(_QWORD *)apr_array_push(v24) = v22;
      ++v21;
    }
    while (v21 < v20->nelts);
  }
  v219 = v14;
  v25 = GT_ENV;
  v26 = v11;
  v27 = (void *)insertBinaryArchives;
  insertBinaryArchives = 0;

  if (v25)
  {
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v25));
    v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "componentsSeparatedByString:", CFSTR(":")));
    v30 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", objc_msgSend(v29, "count"));
    v31 = objc_alloc_init((Class)MTLBinaryArchiveDescriptor);
    *(_OWORD *)v227 = 0u;
    v228 = 0u;
    v229 = 0u;
    v230 = 0u;
    v32 = v29;
    v33 = (char *)objc_msgSend(v32, "countByEnumeratingWithState:objects:count:", v227, p, 16);
    if (v33)
    {
      v34 = *(_QWORD *)v228;
      do
      {
        for (i = 0; i != v33; ++i)
        {
          if (*(_QWORD *)v228 != v34)
            objc_enumerationMutation(v32);
          v36 = objc_msgSend(objc_alloc((Class)NSURL), "initFileURLWithPath:isDirectory:", *((_QWORD *)v227[1] + (_QWORD)i), 0);
          objc_msgSend(v31, "setUrl:", v36);

          v226 = 0;
          v37 = objc_msgSend(v26, "newBinaryArchiveWithDescriptor:error:", v31, &v226);
          objc_msgSend(v30, "addObject:", v37);

        }
        v33 = (char *)objc_msgSend(v32, "countByEnumeratingWithState:objects:count:", v227, p, 16);
      }
      while (v33);
    }

    v38 = objc_msgSend(v30, "copy");
    v39 = (void *)insertBinaryArchives;
    insertBinaryArchives = (uint64_t)v38;

  }
  v41 = *(_QWORD *)(*(_QWORD *)(v218 + 40) + 184);
  v42 = *(unsigned int *)(v41 + 12);
  if ((int)v42 < 1)
  {
    v44 = 64;
  }
  else
  {
    v43 = *(uint64_t **)(v41 + 24);
    v44 = 64;
    do
    {
      v45 = *v43++;
      v44 += *(unsigned int *)(v45 + 64);
      --v42;
    }
    while (v42);
  }
  if ((dword_75313C & 0x10000000) != 0)
  {
    v46 = (id)objc_opt_new(MTLCommandQueueDescriptor, v40);
    objc_msgSend(v46, "setMaxCommandBufferCount:", v44);
    objc_msgSend(v46, "setLockParameterBufferSizeToMax:", 1);
    v47 = v26;
    v48 = objc_msgSend(v47, "newCommandQueueWithDescriptor:", v46);
    objc_msgSend(v217, "setDefaultCommandQueue:", v48);

  }
  else
  {
    v46 = objc_msgSend(v26, "newCommandQueueWithMaxCommandBufferCount:", v44);
    objc_msgSend(v217, "setDefaultCommandQueue:", v46);
  }

  if (byte_75313B >= 7u)
    v49 = 7;
  else
    v49 = byte_75313B;
  v50 = apr_palloc(pool, (24 * v49) + 22584);
  v52 = (uint64_t)v50;
  if (v50)
    bzero(v50, (24 * v49) + 22584);
  apr_pool_cleanup_register(pool, (const void *)v52, (apr_status_t (__cdecl *)(void *))GTMTLReplayController_cleanup, v51);
  *(_QWORD *)v52 = v218;
  v206 = v52 + 8;
  objc_storeStrong((id *)(v52 + 8), obj);
  v53 = -[GTMTLReplaySharedResourcePool initWithDevice:bufferCapacity:]([GTMTLReplaySharedResourcePool alloc], "initWithDevice:bufferCapacity:", v26, 0x2000000);
  v54 = *(void **)(v52 + 16);
  *(_QWORD *)(v52 + 16) = v53;

  objc_msgSend(*(id *)(v52 + 16), "setMaxPooledBuffers:", (v49 + 2));
  v55 = [GTMTLReplaySharedBlitBuffer alloc];
  v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v217, "defaultCommandQueue"));
  v57 = -[GTMTLReplaySharedBlitBuffer initWithCommandQueue:resourcePool:](v55, "initWithCommandQueue:resourcePool:", v56, *(_QWORD *)(v52 + 16));
  v58 = *(void **)(v52 + 24);
  *(_QWORD *)(v52 + 24) = v57;

  *(_QWORD *)(v52 + 152) = GTCaptureArchiveDecompressor_create(pool);
  objc_storeStrong((id *)(v52 + 136), v212);
  objc_storeStrong((id *)(v52 + 128), context);
  v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v217, "defaultDevice"));
  LODWORD(v55) = objc_msgSend(v59, "supportsRaytracing");

  if ((_DWORD)v55)
  {
    v61 = +[NSBundle bundleForClass:](NSBundle, "bundleForClass:", objc_opt_class(GTMTLReplayObjectMap, v60), v206, v208, v209);
    v62 = (void *)objc_claimAutoreleasedReturnValue(v61);
    v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v217, "defaultDevice"));
    v224 = 0;
    v64 = objc_msgSend(v63, "newDefaultLibraryWithBundle:error:", v62, &v224);
    v65 = v224;

    v66 = objc_msgSend(v64, "newFunctionWithName:", CFSTR("RestoreMTLIntersectionFunctionTable"));
    if (v66)
    {
      v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v217, "defaultDevice"));
      v223 = v65;
      v68 = objc_msgSend(v67, "newComputePipelineStateWithFunction:error:", v66, &v223);
      v69 = v223;

      if (v68)
        objc_storeStrong((id *)(v52 + 120), v68);
      else
        GTMTLReplay_handleUnderlyingNSError(CFSTR("Failed to create IFT restore pipeline"), v69);

    }
    else
    {
      v69 = v65;
    }

  }
  contexta = objc_autoreleasePoolPush();
  v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSProcessInfo processInfo](NSProcessInfo, "processInfo"));
  obja = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v70, "globallyUniqueString"));

  v71 = NSTemporaryDirectory();
  v72 = (void *)objc_claimAutoreleasedReturnValue(v71);
  v213 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "stringByAppendingPathComponent:", obja));

  v73 = objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:](NSURL, "fileURLWithPath:isDirectory:", v213, 1));
  v74 = *(void **)(v52 + 22560);
  *(_QWORD *)(v52 + 22560) = v73;

  v75 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
  v76 = *(_QWORD *)(v52 + 22560);
  v222 = 0;
  LODWORD(v72) = objc_msgSend(v75, "createDirectoryAtURL:withIntermediateDirectories:attributes:error:", v76, 1, 0, &v222);
  v77 = v222;

  if ((_DWORD)v72)
  {
    v78 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v52 + 22560), "URLByAppendingPathComponent:isDirectory:", CFSTR("lib_root"), 1));
    v79 = *(void **)(v52 + 22568);
    *(_QWORD *)(v52 + 22568) = v78;

    v80 = *(_QWORD **)v52;
    v81 = *(_QWORD *)(*(_QWORD *)v52 + 40);
    v82 = *(_QWORD *)(v81 + 40);
    v83 = *(_DWORD *)(v82 + 12);
    if (v83 >= 1)
    {
      for (j = 0; j < v83; ++j)
      {
        v85 = *(_QWORD *)(*(_QWORD *)(v82 + 24) + 8 * j);
        if ((dword_75313C & 0x400) == 0)
        {
          v86 = *(_QWORD *)(v85 + 16);
          v87 = v80[8];
          if (v87 <= v86 && v80[9] + v87 > v86)
            continue;
        }
        v89 = *(_QWORD *)(v85 + 64);
        if (*(_WORD *)(v89 + 96))
        {
          v90 = 0;
          do
          {
            v91 = GTMTLReplayController_dumpLibrary(v52, *(char **)(*(_QWORD *)(v89 + 40) + 8 * v90), *(char **)(*(_QWORD *)(v89 + 48) + 8 * v90));
            ++v90;
          }
          while (v90 < *(unsigned __int16 *)(v89 + 96));
          v83 = *(_DWORD *)(v82 + 12);
        }
      }
      v81 = v80[5];
    }
    v92 = *(_QWORD *)(v81 + 32);
    v93 = *(_DWORD *)(v92 + 12);
    if (v93 >= 1)
    {
      for (k = 0; k < v93; ++k)
      {
        v95 = *(_QWORD *)(*(_QWORD *)(v92 + 24) + 8 * k);
        if ((dword_75313C & 0x400) == 0)
        {
          v96 = *(_QWORD *)(v95 + 16);
          v97 = v80[8];
          if (v97 <= v96 && v80[9] + v97 > v96)
            continue;
        }
        v99 = *(_QWORD *)(v95 + 56);
        if (*(_WORD *)(v99 + 214))
        {
          v100 = 0;
          do
          {
            v101 = GTMTLReplayController_dumpLibrary(v52, *(char **)(*(_QWORD *)(v99 + 96) + 8 * v100), *(char **)(*(_QWORD *)(v99 + 104) + 8 * v100));
            ++v100;
          }
          while (v100 < *(unsigned __int16 *)(v99 + 214));
          v93 = *(_DWORD *)(v92 + 12);
        }
      }
    }
  }
  else
  {
    GTMTLReplay_handleUnderlyingNSError(CFSTR("Failed to create replay controller temporary directory"), v77);
  }

  objc_autoreleasePoolPop(contexta);
  *(_QWORD *)(v52 + 22504) = apr_array_make(pool, 128, 16);
  v102 = dispatch_semaphore_create(0);
  v103 = *(void **)(v52 + 22520);
  *(_QWORD *)(v52 + 22520) = v102;

  v104 = dispatch_group_create();
  v105 = *(void **)(v52 + 22528);
  *(_QWORD *)(v52 + 22528) = v104;

  *(_DWORD *)(v52 + 22576) = v49;
  if ((_DWORD)v49)
  {
    v106 = v52 + 22584;
    do
    {
      *(_QWORD *)(v106 + 8) = v52;
      pthread_create((pthread_t *)v106, 0, (void *(__cdecl *)(void *))StartLoadingThread, (void *)v106);
      v106 += 24;
      --v49;
    }
    while (v49);
  }
  v107 = (void *)g_activityLog;
  v108 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", **(_QWORD **)v218, v206));
  objc_msgSend(v107, "enterLoadArchiveWithPath:", v108);

  v109 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v109))
  {
    LOWORD(p[0]) = 0;
    _os_signpost_emit_with_name_impl(&dword_0, (os_log_t)v109, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "Replayer-1-serial", "CreateDeviceResources", (uint8_t *)p, 2u);
  }

  v110 = *(_DWORD ***)(v218 + 40);
  v111 = *(_QWORD *)v52;
  v227[0] = 0;
  apr_pool_create_ex(v227, 0, 0, v112);
  v113 = v227[0];
  v114 = apr_array_make(v227[0], 128, 8);
  v115 = apr_array_make(v113, 128, 8);
  GTMTLSMContext_getObjects(v110[10], v219, v115);
  if (v115->nelts >= 1)
  {
    v116 = 0;
    do
      ExpandChildren(v114, *(_QWORD *)&v115->elts[8 * v116++], (uint64_t)ht);
    while (v116 < v115->nelts);
  }
  v115->nelts = 0;
  GTMTLSMContext_getObjects(v110[2], v219, v115);
  nelts = v115->nelts;
  if (nelts >= 1)
  {
    for (m = 0; m < nelts; ++m)
    {
      v119 = *(_QWORD **)&v115->elts[8 * m];
      if (!v119[6] && !v119[17] && !v119[18])
      {
        ExpandChildren(v114, (uint64_t)v119, (uint64_t)ht);
        nelts = v115->nelts;
      }
    }
  }
  v115->nelts = 0;
  GTMTLSMContext_getObjects(v110[1], v219, v115);
  v120 = v115->nelts;
  if (v120 >= 1)
  {
    for (n = 0; n < v120; ++n)
    {
      v122 = *(_QWORD *)&v115->elts[8 * n];
      if (!*(_QWORD *)(v122 + 48))
      {
        ExpandChildren(v114, v122, (uint64_t)ht);
        v120 = v115->nelts;
      }
    }
  }
  GTMTLSMContext_getObjects(v110[9], v219, v114);
  hta = *(apr_hash_t **)(v111 + 8);
  v123 = *(_QWORD *)(*(_QWORD *)v52 + 8);
  p[0] = 0;
  v124 = *(_QWORD *)(*(_QWORD *)(*find_entry(v123, p, 8uLL, 0) + 32) + 32);
  if (v124)
  {
    v125 = 0;
    while (1)
    {
      v126 = atomic_load((unsigned int *)(v124 + 4));
      v127 = v125 + (v126 >> 6) - 1;
      if ((int)v127 > 0)
        break;
      v124 = *(_QWORD *)(v124 + 40);
      v125 = v127;
      if (!v124)
      {
        v125 = v127;
        goto LABEL_94;
      }
    }
  }
  else
  {
    v125 = 0;
  }
  v127 = 0;
LABEL_94:
  v128 = v125 | (unint64_t)(v127 << 32);
LABEL_95:
  v129 = v124 + 64;
  while (v124)
  {
    v130 = HIDWORD(v128) - v128;
    if ((*(_BYTE *)(v129 + ((uint64_t)(HIDWORD(v128) - (int)v128) << 6) + 15) & 8) == 0)
      break;
    v131 = v130;
    v132 = (unint64_t *)(v129 + ((uint64_t)v130 << 6));
    if (*v132 >= v219)
      break;
    v133 = objc_autoreleasePoolPush();
    if (*(_DWORD *)(v129 + (v131 << 6) + 8) == -7155)
      GTMTLReplayController_defaultDispatchFunction(v52, (uint64_t)v132);
    objc_autoreleasePoolPop(v133);
    v134 = atomic_load((unsigned int *)(v124 + 4));
    v135 = v128 + (v134 >> 6);
    v136 = (HIDWORD(v128) + 1);
    v128 = (v136 << 32) | v128;
    if ((_DWORD)v136 == v135 - 1)
    {
      v128 = (v136 << 32) | v136;
      v124 = *(_QWORD *)(v124 + 40);
      goto LABEL_95;
    }
  }
  for (ii = (apr_pool_t *)(&dword_0 + 1); ; ii = (apr_pool_t *)((char *)ii + 1))
  {
    p[0] = ii;
    v138 = *find_entry((uint64_t)hta, p, 8uLL, 0);
    if (!v138)
      break;
    v139 = *(_QWORD *)(v138 + 32);
    if (!v139)
      break;
    v140 = *(_QWORD *)(v139 + 32);
    if (!v140 || (*(_BYTE *)(v140 + 79) & 8) == 0)
      break;
    v141 = *(_DWORD *)(v140 + 72);
    if (v141 != -7163 && v141 != -10239)
      break;
    CreateResourceFromStream((id *)v52, v139, v219);
  }
  LODWORD(v143) = v114->nelts;
  if ((int)v143 >= 1)
  {
    v144 = 0;
    do
    {
      v145 = *(apr_pool_t **)&v114->elts[8 * v144];
      if (v145)
        v145 = (apr_pool_t *)*((_QWORD *)v145 + 1);
      p[0] = v145;
      v146 = *find_entry((uint64_t)hta, p, 8uLL, 0);
      if (v146)
        v147 = *(_QWORD *)(v146 + 32);
      else
        v147 = 0;
      CreateResourceFromStream((id *)v52, v147, v219);
      ++v144;
      v143 = v114->nelts;
    }
    while (v144 < v143);
  }
  apr_pool_destroy(v227[0]);
  v148 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v148))
  {
    LODWORD(p[0]) = 67109120;
    HIDWORD(p[0]) = v143;
    _os_signpost_emit_with_name_impl(&dword_0, (os_log_t)v148, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "Replayer-1-serial", "%d", (uint8_t *)p, 8u);
  }

  if ((GT_SUPPORT_0 & 0x800) != 0
    && (*(_DWORD *)(*(_QWORD *)(v218 + 232) + 12) || *(_DWORD *)(*(_QWORD *)(v218 + 224) + 12)))
  {
    v149 = objc_autoreleasePoolPush();
    v150 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v217, "defaultCommandQueue"));
    v151 = InternalCommandBuffer(v150, CFSTR("MapSparseTextureRegions"));
    v152 = (void *)objc_claimAutoreleasedReturnValue(v151);

    v153 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v152, "resourceStateCommandEncoder"));
    v154 = **(apr_pool_t ***)(v52 + 152);
    MapSparseTextureRegions(v153, *(void **)(v52 + 8), *(_QWORD *)(v218 + 232), v154);
    MapSparseTextureRegions(v153, *v207, *(_QWORD *)(v218 + 224), v154);
    apr_pool_clear(v154);
    objc_msgSend(v153, "endEncoding");
    GTMTLReplay_commitCommandBuffer(v152);

    objc_autoreleasePoolPop(v149);
  }
  FillRequestsAlignment(*(_QWORD *)(v218 + 216), *(uint64_t **)(v218 + 40), v26);
  GroupRequestsByCapacity(*(apr_array_header_t **)(v218 + 216), v155, v156, v157);
  v158 = *(_QWORD *)(v218 + 136);
  v159 = (apr_hash_index_t *)(v158 + 16);
  *(_QWORD *)(v158 + 24) = 0;
  *(_QWORD *)(v158 + 32) = 0;
  *(_QWORD *)(v158 + 16) = v158;
  *(_DWORD *)(v158 + 40) = 0;
  while (1)
  {
    v160 = apr_hash_next(v159);
    if (!v160)
      break;
    v159 = v160;
    v161 = *(apr_array_header_t **)(*((_QWORD *)v160 + 1) + 32);
    FillRequestsAlignment((uint64_t)v161, *(uint64_t **)(v218 + 40), v26);
    GroupRequestsByCapacity(v161, v162, v163, v164);
  }
  AppendRestoreJobsToLoadQueue(v52, *(_QWORD *)(v218 + 216));
  AppendRestoreJobsToLoadQueue(v52, *(_QWORD *)(v218 + 208));
  SignalLoadQueueThreads(v52, *(_DWORD *)(*(_QWORD *)(v52 + 22504) + 12));
  v165 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, (const void *)v52);
  v166 = apr_array_make(newpool, 128, 8);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 96), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 88), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 224), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 104), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 32), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 40), v219, v166);
  qsort(v166->elts, v166->nelts, 8uLL, (int (__cdecl *)(const void *, const void *))GTMTLSMObject_compare);
  v167 = g_signpostLog;
  v168 = v167;
  v169 = v165 - 1;
  if (v165 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v167))
  {
    v170 = v166->nelts;
    LODWORD(p[0]) = 67109120;
    HIDWORD(p[0]) = v170;
    _os_signpost_emit_with_name_impl(&dword_0, v168, OS_SIGNPOST_INTERVAL_BEGIN, v165, "Replayer-1-serial", "CreatePipelineStates %d", (uint8_t *)p, 8u);
  }

  if (v166->nelts >= 1)
  {
    v171 = 0;
    do
    {
      v172 = *(apr_pool_t **)&v166->elts[8 * v171];
      if (v172)
        v172 = (apr_pool_t *)*((_QWORD *)v172 + 1);
      v173 = *(_QWORD *)(v218 + 8);
      p[0] = v172;
      v174 = *find_entry(v173, p, 8uLL, 0);
      if (v174)
        v175 = *(_QWORD *)(v174 + 32);
      else
        v175 = 0;
      CreateResourceFromStream((id *)v52, v175, v219);
      ++v171;
    }
    while (v171 < v166->nelts);
  }
  v176 = g_signpostLog;
  v177 = v176;
  if (v169 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v176))
  {
    LOWORD(p[0]) = 0;
    _os_signpost_emit_with_name_impl(&dword_0, v177, OS_SIGNPOST_INTERVAL_END, v165, "Replayer-1-serial", (const char *)&unk_4AAB5F, (uint8_t *)p, 2u);
  }

  v166->nelts = 0;
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 152), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 120), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 112), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 216), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 48), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 200), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 24), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 136), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 128), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 256), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 56), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 64), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 264), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 272), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 280), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 184), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v218 + 40) + 192), v219, v166);
  v178 = g_signpostLog;
  v179 = v178;
  if (v169 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v178))
  {
    v180 = v166->nelts;
    LODWORD(p[0]) = 67109120;
    HIDWORD(p[0]) = v180;
    _os_signpost_emit_with_name_impl(&dword_0, v179, OS_SIGNPOST_INTERVAL_BEGIN, v165, "Replayer-1-serial", "CreateOtherStates %d", (uint8_t *)p, 8u);
  }

  if (v166->nelts >= 1)
  {
    v181 = 0;
    do
    {
      v182 = *(apr_pool_t **)&v166->elts[8 * v181];
      if (v182)
        v182 = (apr_pool_t *)*((_QWORD *)v182 + 1);
      v183 = *(_QWORD *)(v218 + 8);
      p[0] = v182;
      v184 = *find_entry(v183, p, 8uLL, 0);
      if (v184)
        v185 = *(_QWORD *)(v184 + 32);
      else
        v185 = 0;
      CreateResourceFromStream((id *)v52, v185, v219);
      ++v181;
    }
    while (v181 < v166->nelts);
  }
  v186 = g_signpostLog;
  v187 = v186;
  if (v169 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v186))
  {
    LOWORD(p[0]) = 0;
    _os_signpost_emit_with_name_impl(&dword_0, v187, OS_SIGNPOST_INTERVAL_END, v165, "Replayer-1-serial", (const char *)&unk_4AAB5F, (uint8_t *)p, 2u);
  }

  v188 = [GTMTLReplayActivityLog alloc];
  v189 = -[GTMTLReplayActivityLog initWithLog:](v188, "initWithLog:", g_activityLog);
  RestoreOrderedResourcesFromArchive((id *)v52, *(_QWORD *)(*(_QWORD *)(v218 + 240) + 24), *(unsigned int *)(*(_QWORD *)(v218 + 240) + 12), v189);
  RestoreVisibleFunctionTablesForFunctionIndex((id *)v52, v219 - 1);
  RestoreIntersectionFunctionTablesForFunctionIndex((uint64_t *)v52, v219 - 1);
  v190 = (unsigned int *)(v52 + 22512);
  do
    v191 = __ldaxr(v190);
  while (__stlxr(v191 + 1, v190));
  v192 = *(_QWORD *)(v52 + 22504);
  if (v191 >= *(_DWORD *)(v192 + 12))
    v193 = 0;
  else
    v193 = *(_QWORD *)(v192 + 24) + 16 * v191;
  while (v193)
  {
    v194 = objc_autoreleasePoolPush();
    DoLoadJob((uint64_t **)v52, v193, v189, 0);
    do
      v195 = __ldaxr(v190);
    while (__stlxr(v195 + 1, v190));
    v196 = *(_QWORD *)(v52 + 22504);
    if (v195 >= *(_DWORD *)(v196 + 12))
      v193 = 0;
    else
      v193 = *(_QWORD *)(v196 + 24) + 16 * v195;
    objc_autoreleasePoolPop(v194);
  }

  dispatch_group_wait(*(dispatch_group_t *)(v52 + 22528), 0xFFFFFFFFFFFFFFFFLL);
  *(_DWORD *)(*(_QWORD *)(v52 + 22504) + 12) = 0;
  apr_pool_destroy(newpool);
  v197 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", 8);
  v198 = *(void **)(v52 + 40);
  *(_QWORD *)(v52 + 40) = v197;

  v199 = dispatch_semaphore_create(1);
  v200 = *(void **)(v52 + 48);
  *(_QWORD *)(v52 + 48) = v199;

  v201 = objc_claimAutoreleasedReturnValue(+[NSMapTable strongToStrongObjectsMapTable](NSMapTable, "strongToStrongObjectsMapTable"));
  v202 = *(void **)(v52 + 56);
  *(_QWORD *)(v52 + 56) = v201;

  v203 = objc_alloc_init((Class)NSMutableDictionary);
  v204 = *(void **)(v52 + 144);
  *(_QWORD *)(v52 + 144) = v203;

  *(_QWORD *)(v52 + 22496) = apr_hash_make(pool);
  *(_QWORD *)(v52 + 22544) = apr_hash_make(pool);
  *(_QWORD *)(v52 + 22552) = *(_QWORD *)(v218 + 136);
  objc_msgSend((id)g_activityLog, "leaveActivity");

  return v52;
}

void sub_28F660(_Unwind_Exception *a1)
{
  objc_msgSend((id)g_activityLog, "leaveActivity");
  _Unwind_Resume(a1);
}

uint64_t GTMTLReplayController_cleanup(intptr_t a1)
{
  intptr_t v2;
  uint64_t v3;
  _opaque_pthread_t **v4;
  _opaque_pthread_t *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  v2 = a1 + 22516;
  atomic_store(1u, (unsigned int *)(a1 + 22516));
  SignalLoadQueueThreads(a1, *(_DWORD *)(a1 + 22576));
  if (*(int *)(v2 + 60) >= 1)
  {
    v3 = 0;
    v4 = (_opaque_pthread_t **)(a1 + 22584);
    do
    {
      v5 = *v4;
      v4 += 3;
      pthread_join(v5, 0);
      ++v3;
    }
    while (v3 < *(int *)(v2 + 60));
  }
  v6 = *(void **)(a1 + 22520);
  *(_QWORD *)(a1 + 22520) = 0;

  v7 = *(void **)(a1 + 22528);
  *(_QWORD *)(a1 + 22528) = 0;

  v8 = *(void **)(a1 + 22536);
  *(_QWORD *)(a1 + 22536) = 0;

  v9 = *(void **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = 0;

  v10 = *(void **)(a1 + 24);
  *(_QWORD *)(a1 + 24) = 0;

  v11 = *(void **)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;

  v12 = *(void **)(a1 + 40);
  *(_QWORD *)(a1 + 40) = 0;

  v13 = *(void **)(a1 + 48);
  *(_QWORD *)(a1 + 48) = 0;

  v14 = *(void **)(a1 + 56);
  *(_QWORD *)(a1 + 56) = 0;

  v15 = *(void **)(a1 + 144);
  *(_QWORD *)(a1 + 144) = 0;

  v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
  objc_msgSend(v16, "removeItemAtURL:error:", *(_QWORD *)(a1 + 22560), 0);

  v17 = *(void **)(a1 + 22560);
  *(_QWORD *)(a1 + 22560) = 0;

  v18 = *(void **)(a1 + 22568);
  *(_QWORD *)(a1 + 22568) = 0;

  v19 = *(void **)(a1 + 128);
  *(_QWORD *)(a1 + 128) = 0;

  v20 = *(void **)(a1 + 136);
  *(_QWORD *)(a1 + 136) = 0;

  GTMTLReplayController_tileMemoryFree(a1);
  return 0;
}

uint64_t StartLoadingThread(uint64_t a1)
{
  apr_allocator_t *v2;
  uint64_t v3;
  id v4;
  apr_pool_t *v5;
  apr_allocator_t *v6;
  GTMTLReplaySharedBlitBuffer *v7;
  void *v8;
  unsigned int *v9;
  _opaque_pthread_t *v11;
  GTMTLReplayActivityLog *v12;
  GTMTLReplayActivityLog *v13;
  uint64_t v14;
  pthread_t *v15;
  uint64_t v16;
  uint64_t *v17;
  void **v18;
  GTMTLReplayActivityLog *v19;
  uint64_t *v20;
  GTMTLReplayActivityLog *v21;
  void *v22;
  signed int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  signed int v28;
  uint64_t v29;
  uint64_t v30;
  id v32;
  void *context;
  uint64_t *v34;
  id v35;
  uint64_t v36;
  GTMTLReplaySharedBlitBuffer *v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  apr_pool_t *v48;
  apr_pool_t *newpool;

  context = objc_autoreleasePoolPush();
  v48 = 0;
  newpool = 0;
  apr_pool_create_ex(&newpool, 0, 0, v2);
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(id *)(v3 + 8);
  v5 = newpool;
  apr_pool_create_ex(&v48, newpool, 0, v6);
  *(_QWORD *)(a1 + 16) = apr_hash_make(v48);
  v34 = *(uint64_t **)v3;
  v35 = v4;
  v36 = 0;
  v7 = [GTMTLReplaySharedBlitBuffer alloc];
  v32 = v35;
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "defaultCommandQueue"));
  v37 = -[GTMTLReplaySharedBlitBuffer initWithCommandQueue:resourcePool:](v7, "initWithCommandQueue:resourcePool:", v8, *(_QWORD *)(v3 + 16));
  v38 = 0u;
  v39 = 0u;
  v40 = 0u;
  v41 = 0u;
  v42 = 0u;
  v43 = 0u;
  v44 = 0u;
  v45 = 0;
  v46 = GTCaptureArchiveDecompressor_create(v5);
  bzero(&v47, 0x5798uLL);

  v9 = (unsigned int *)(v3 + 22512);
  while (1)
  {
    dispatch_semaphore_wait(*(dispatch_semaphore_t *)(v3 + 22520), 0xFFFFFFFFFFFFFFFFLL);
    if (atomic_load((unsigned int *)(v3 + 22516)))
      break;
    v11 = pthread_self();
    v12 = [GTMTLReplayActivityLog alloc];
    v13 = -[GTMTLReplayActivityLog initWithLog:](v12, "initWithLog:", g_activityLog);
    pthread_rwlock_wrlock(&rwlock);
    v14 = 0;
    v15 = (pthread_t *)threadLocalLogs;
    do
    {
      if (pthread_equal(v11, *v15))
      {
        v18 = (void **)&threadLocalLogs[2 * v14 + 1];
        v19 = v13;
        goto LABEL_12;
      }
      ++v14;
      v15 += 2;
    }
    while (v14 != 7);
    v16 = 0;
    v17 = &qword_752D30;
    while (*v17)
    {
      ++v16;
      v17 += 2;
      if (v16 == 7)
        goto LABEL_13;
    }
    v20 = &threadLocalLogs[2 * v16];
    v21 = v13;
    *v20 = (uint64_t)v11;
    v18 = (void **)(v20 + 1);
LABEL_12:
    v22 = *v18;
    *v18 = v13;

LABEL_13:
    pthread_rwlock_unlock(&rwlock);

    do
      v23 = __ldaxr(v9);
    while (__stlxr(v23 + 1, v9));
    v24 = *(_QWORD *)(v3 + 22504);
    if (v23 < *(_DWORD *)(v24 + 12))
    {
      v25 = *(_QWORD *)(v24 + 24);
      if (v25)
      {
        v26 = v25 + 16 * v23;
        do
        {
          v27 = objc_autoreleasePoolPush();
          DoLoadJob(&v34, v26, v13, *(apr_hash_t **)(a1 + 16));
          objc_autoreleasePoolPop(v27);
          do
            v28 = __ldaxr(v9);
          while (__stlxr(v28 + 1, v9));
          v29 = *(_QWORD *)(v3 + 22504);
          if (v28 >= *(_DWORD *)(v29 + 12))
            break;
          v30 = *(_QWORD *)(v29 + 24);
          v26 = v30 + 16 * v28;
        }
        while (v30);
      }
    }
    -[GTMTLReplaySharedBlitBuffer releaseBuffer](v37, "releaseBuffer");
    dispatch_group_leave(*(dispatch_group_t *)(v3 + 22528));

  }
  apr_pool_destroy(newpool);
  __destructor_8_s8_s16_s24_s40_s48_s56_s64_s72_s80_s88_s96_s104_s112_s120_s128_s136_S_s144_S_s22520_s22528_S_s22536_s22560_s22568((id *)&v34);

  objc_autoreleasePoolPop(context);
  return 0;
}

void sub_28FAD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  __destructor_8_s8_s16_s24_s40_s48_s56_s64_s72_s80_s88_s96_s104_s112_s120_s128_s136_S_s144_S_s22520_s22528_S_s22536_s22560_s22568((id *)va);
  _Unwind_Resume(a1);
}

_QWORD *ExpandChildren(apr_array_header_t *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)apr_array_push(a1) = a2;
  result = find_entry(a3, (_BYTE *)(a2 + 8), 8uLL, 0);
  if (*result)
  {
    v7 = *(_QWORD *)(*result + 32);
    if (v7)
    {
      if (*(int *)(v7 + 12) >= 1)
      {
        v8 = 0;
        do
          result = (_QWORD *)ExpandChildren(a1, *(_QWORD *)(*(_QWORD *)(v7 + 24) + 8 * v8++), a3);
        while (v8 < *(int *)(v7 + 12));
      }
    }
  }
  return result;
}

void CreateResourceFromStream(id *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  int v15;
  uint64_t v16;
  char *v17;
  void *v18;
  void *v19;
  unint64_t v20;
  id v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  id v27;

  v25 = *((_QWORD *)*a1 + 2);
  v27 = a1[1];
  v5 = *(_QWORD *)(a2 + 32);
  if (v5)
  {
    v6 = 0;
    while (1)
    {
      v7 = atomic_load((unsigned int *)(v5 + 4));
      v8 = v6 + (v7 >> 6) - 1;
      if ((int)v8 > 0)
        break;
      v5 = *(_QWORD *)(v5 + 40);
      v6 = v8;
      if (!v5)
      {
        v6 = v8;
        goto LABEL_8;
      }
    }
  }
  else
  {
    v6 = 0;
  }
  v8 = 0;
LABEL_8:
  v9 = v6 | (unint64_t)(v8 << 32);
LABEL_9:
  v10 = v5 + 64;
  while (v5)
  {
    v11 = HIDWORD(v9) - v9;
    if ((*(_BYTE *)(v10 + ((uint64_t)(HIDWORD(v9) - (int)v9) << 6) + 15) & 8) == 0)
      break;
    v12 = v11;
    v13 = v10 + ((uint64_t)v11 << 6);
    if (*(_QWORD *)v13 >= a3)
      break;
    v14 = objc_autoreleasePoolPush();
    v15 = *(_DWORD *)(v13 + 8);
    v16 = (v15 + 10238);
    if (v16 <= 0x30)
    {
      if (((1 << (v15 - 2)) & 0x1100000000005) != 0)
        goto LABEL_26;
      if (v16 == 1)
        goto LABEL_18;
    }
    if (v15 != -16236)
    {
      if (v15 == -16313)
      {
LABEL_18:
        if ((GT_SUPPORT_0 & 0x80000) == 0)
        {
          v17 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v13, *(unsigned __int8 *)(v10 + (v12 << 6) + 13), v25);
          v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v27, "deviceForKey:", *(_QWORD *)v17));
          v19 = v18;
          if ((dword_75313C & 4) != 0)
            v20 = 32;
          else
            v20 = *((_QWORD *)v17 + 3) & 0xFFFFFFFFFFEFFFFFLL;
          v21 = objc_msgSend(v18, "newBufferWithLength:options:", *((_QWORD *)v17 + 2), v20);
          if (v21)
            objc_msgSend(v27, "setBuffer:forKey:", v21, *((_QWORD *)v17 + 1));

        }
        goto LABEL_26;
      }
      GTMTLReplayController_defaultDispatchFunction((uint64_t)a1, v13);
    }
LABEL_26:
    objc_autoreleasePoolPop(v14);
    v22 = atomic_load((unsigned int *)(v5 + 4));
    v23 = v9 + (v22 >> 6);
    v24 = (HIDWORD(v9) + 1);
    v9 = (v24 << 32) | v9;
    if ((_DWORD)v24 == v23 - 1)
    {
      v9 = (v24 << 32) | v24;
      v5 = *(_QWORD *)(v5 + 40);
      goto LABEL_9;
    }
  }

}

void MapSparseTextureRegions(void *a1, void *a2, uint64_t a3, apr_pool_t *a4)
{
  id v7;
  apr_array_header_t *v8;
  uint64_t v9;
  void *v10;
  id v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  id v17;
  id v18;
  id v19;
  char *elts;
  char *v21;
  uint64_t nelts;
  void *v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  id v33;
  id v34;
  id v35;
  char *v36;
  char *v37;
  uint64_t v38;
  void *v39;
  void *v40;
  id v41;
  apr_array_header_t *v42;
  apr_array_header_t *v43;
  apr_array_header_t *arr;
  __int128 v45;
  uint64_t v46;
  __int128 v47;
  uint64_t v48;

  v7 = a1;
  v41 = a2;
  v8 = apr_array_make(a4, 8, 48);
  arr = apr_array_make(a4, 8, 48);
  v43 = apr_array_make(a4, 8, 8);
  v42 = apr_array_make(a4, 8, 8);
  v40 = v7;
  v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "device"));
  if (*(int *)(a3 + 12) < 1)
  {
    v10 = 0;
  }
  else
  {
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 32;
    do
    {
      v14 = *(_QWORD *)(a3 + 24);
      v15 = v14 + v13;
      v16 = *(_QWORD *)(v14 + v13 - 24);
      if (v16 != v12)
      {
        if (v8->nelts >= 1)
        {
          v47 = 0uLL;
          v48 = 0;
          v17 = objc_msgSend(v10, "textureType");
          v18 = objc_msgSend(v10, "pixelFormat");
          v19 = objc_msgSend(v10, "sampleCount");
          if (v39)
          {
            objc_msgSend(v39, "sparseTileSizeWithTextureType:pixelFormat:sampleCount:", v17, v18, v19);
          }
          else
          {
            v47 = 0uLL;
            v48 = 0;
          }
          elts = v8->elts;
          v21 = arr->elts;
          nelts = v8->nelts;
          v45 = v47;
          v46 = v48;
          objc_msgSend(v39, "convertSparsePixelRegions:toTileRegions:withTileSize:alignmentMode:numRegions:", elts, v21, &v45, 0, nelts, v39);
          objc_msgSend(v40, "updateTextureMappings:mode:regions:mipLevels:slices:numRegions:", v10, 0, arr->elts, v43->elts, v42->elts, v8->nelts);
          arr->nelts = 0;
          v8->nelts = 0;
          v43->nelts = 0;
          v42->nelts = 0;
          v16 = *(_QWORD *)(v15 - 24);
        }
        v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "textureForKey:", v16, v39));

        v11 = objc_msgSend(v23, "firstMipmapInTail");
        v12 = *(_QWORD *)(v15 - 24);
        v10 = v23;
      }
      if ((unint64_t)v11 >= *(unsigned __int16 *)(v15 + 2))
      {
        apr_array_push(arr);
        v24 = apr_array_push(v8);
        v25 = *(unsigned __int16 *)(v14 + v13 + 6);
        v26 = *(unsigned __int16 *)(v14 + v13 + 8);
        v27 = *(unsigned __int16 *)(v14 + v13 + 10);
        v28 = *(unsigned __int16 *)(v14 + v13 + 12);
        v29 = *(unsigned __int16 *)(v14 + v13 + 14);
        *v24 = *(unsigned __int16 *)(v14 + v13 + 4);
        v24[1] = v25;
        v24[2] = v26;
        v24[3] = v27;
        v24[4] = v28;
        v24[5] = v29;
        v30 = *(unsigned __int16 *)(v15 + 2);
        *(_QWORD *)apr_array_push(v43) = v30;
        v31 = *(unsigned __int16 *)(v14 + v13);
        *(_QWORD *)apr_array_push(v42) = v31;
      }
      ++v9;
      v13 += 64;
    }
    while (v9 < *(int *)(a3 + 12));
  }
  v32 = v39;
  if (v8->nelts > 0)
  {
    v47 = 0uLL;
    v48 = 0;
    v33 = objc_msgSend(v10, "textureType");
    v34 = objc_msgSend(v10, "pixelFormat");
    v35 = objc_msgSend(v10, "sampleCount");
    if (v39)
    {
      objc_msgSend(v39, "sparseTileSizeWithTextureType:pixelFormat:sampleCount:", v33, v34, v35);
    }
    else
    {
      v47 = 0uLL;
      v48 = 0;
    }
    v36 = v8->elts;
    v37 = arr->elts;
    v38 = v8->nelts;
    v45 = v47;
    v46 = v48;
    objc_msgSend(v39, "convertSparsePixelRegions:toTileRegions:withTileSize:alignmentMode:numRegions:", v36, v37, &v45, 0, v38, v39);
    objc_msgSend(v40, "updateTextureMappings:mode:regions:mipLevels:slices:numRegions:", v10, 0, arr->elts, v43->elts, v42->elts, v8->nelts);
  }

}

void FillRequestsAlignment(uint64_t a1, uint64_t *a2, void *a3)
{
  id v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  char v14;
  uint64_t v15;
  _OWORD v16[4];
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  _OWORD v20[3];
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v5 = a3;
  v6 = *(_DWORD *)(a1 + 12);
  if (v6 >= 1)
  {
    v7 = 0;
    v8 = 0;
    v9 = 0uLL;
    do
    {
      v10 = *(_QWORD *)(a1 + 24);
      if (*(_QWORD *)(v10 + v7) == 80)
      {
        v25 = 0;
        v23 = v9;
        v24 = v9;
        v22 = v9;
        v11 = v10 + v7;
        GTMTLSMContext_getTextureDescriptor(a2, *(_QWORD *)(v10 + v7 + 8), *(_QWORD *)(v10 + v7 + 16), (uint64_t)&v22);
        v12 = WORD1(v24);
        v21 = 0;
        memset(v20, 0, sizeof(v20));
        GTMTLPixelFormatGetInfoForDevice((uint64_t)v20, (uint64_t)v5, WORD1(v24));
        v13 = xmmword_4AA550;
        if ((~DWORD2(v20[0]) & 0x60) != 0)
        {
          *((_QWORD *)&v13 + 1) = v15;
          *(_QWORD *)&v13 = 0;
          if ((WORD4(v20[0]) & 0x2000) != 0)
            *(_QWORD *)&v13 = 4;
        }
        v15 = *((_QWORD *)&v13 + 1);
        memset(v16, 0, sizeof(v16));
        v19 = 0;
        v17 = 0uLL;
        v18 = 0uLL;
        v14 = v13;
        GTMTLGetTextureLevelInfoForDeviceWithOptions((uint64_t)v16, (uint64_t)v5, v12, DWORD2(v23), (unsigned __int16)v24, HIWORD(v23), HIBYTE(v24), *(unsigned __int16 *)(v11 + 34), v13);
        *(_WORD *)(v11 + 60) = WORD4(v17);
        *(_BYTE *)(v11 + 62) = v14;
        v6 = *(_DWORD *)(a1 + 12);
        v9 = 0uLL;
      }
      ++v8;
      v7 += 64;
    }
    while (v8 < v6);
  }

}

void GroupRequestsByCapacity(apr_array_header_t *a1, uint64_t a2, uint64_t a3, apr_allocator_t *a4)
{
  apr_array_header_t *v5;
  char *elts;
  _OWORD *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t nelts;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  apr_array_header_t *v26;
  _OWORD *v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  apr_pool_t *p;
  apr_pool_t *newpool;

  newpool = 0;
  apr_pool_create_ex(&newpool, a1->pool, 0, a4);
  p = newpool;
  v5 = apr_array_copy(newpool, a1);
  qsort(v5->elts, v5->nelts, v5->elt_size, (int (__cdecl *)(const void *, const void *))CompareRequestsBySize);
  a1->nelts = 0;
  while (v5->nelts)
  {
    elts = v5->elts;
    v7 = apr_array_push(a1);
    v8 = *((_OWORD *)elts + 3);
    v10 = *(_OWORD *)elts;
    v9 = *((_OWORD *)elts + 1);
    v7[2] = *((_OWORD *)elts + 2);
    v7[3] = v8;
    *v7 = v10;
    v7[1] = v9;
    v11 = RequestSize((uint64_t)elts);
    nelts = v5->nelts;
    v5->nelts = 0;
    if ((int)nelts < 2)
      break;
    v13 = v11;
    v14 = 0;
    v15 = (nelts << 6) - 64;
    do
    {
      v16 = 0;
      v17 = v5->elts;
      v18 = *(_QWORD *)&v17[v14 + 64];
      if (v18 <= 56)
      {
        if (v18 == 16)
        {
          v20 = v13 + 31;
          v19 = 32;
          goto LABEL_20;
        }
        if (v18 != 22)
          goto LABEL_11;
      }
      else if (v18 != 57)
      {
        if (v18 == 86)
        {
          v20 = v13 + 255;
          v19 = 256;
          goto LABEL_20;
        }
        if (v18 == 80)
        {
          v19 = *(unsigned __int16 *)&v17[v14 + 124];
          v20 = v13 + v19 - 1;
          goto LABEL_20;
        }
LABEL_11:
        v16 = -1;
      }
      v20 = v16 + v13;
      v19 = v18 <= 79 && (v18 == 22 || v18 == 57);
LABEL_20:
      v21 = v20 & -v19;
      v22 = RequestSize((uint64_t)&v17[v14 + 64]);
      if ((unint64_t)(v21 + v22) > 0x2000000)
      {
        v26 = v5;
        goto LABEL_39;
      }
      v23 = 0;
      if (v18 <= 56)
      {
        if (v18 != 16)
        {
          if (v18 != 22)
LABEL_29:
            v23 = -1;
LABEL_30:
          v25 = v23 + v13;
          v24 = v18 <= 79 && (v18 == 22 || v18 == 57);
          goto LABEL_38;
        }
        v25 = v13 + 31;
        v24 = 32;
      }
      else
      {
        switch(v18)
        {
          case '9':
            goto LABEL_30;
          case 'V':
            v25 = v13 + 255;
            v24 = 256;
            break;
          case 'P':
            v24 = *(unsigned __int16 *)&v17[v14 + 124];
            v25 = v13 + v24 - 1;
            break;
          default:
            goto LABEL_29;
        }
      }
LABEL_38:
      v13 = (v25 & -v24) + v22;
      v26 = a1;
LABEL_39:
      v27 = apr_array_push(v26);
      v28 = *(_OWORD *)&v17[v14 + 112];
      v30 = *(_OWORD *)&v17[v14 + 64];
      v29 = *(_OWORD *)&v17[v14 + 80];
      v27[2] = *(_OWORD *)&v17[v14 + 96];
      v27[3] = v28;
      *v27 = v30;
      v27[1] = v29;
      v14 += 64;
    }
    while (v15 != v14);
  }
  apr_pool_destroy(p);
}

uint64_t AppendRestoreJobsToLoadQueue(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  int v4;
  _QWORD *v5;
  uint64_t v6;
  int v7;

  if (a2 && *(int *)(a2 + 12) >= 1)
  {
    v3 = result;
    v4 = 0;
    do
    {
      v5 = apr_array_push(*(apr_array_header_t **)(v3 + 22504));
      *(_DWORD *)v5 = 0;
      v6 = *(_QWORD *)(a2 + 24) + ((uint64_t)v4 << 6);
      v5[1] = v6;
      v7 = *(_DWORD *)(a2 + 12);
      result = CountRequestsWithinCapacity(v6, (v7 - v4));
      *((_DWORD *)v5 + 1) = result;
      v4 += result;
    }
    while (v4 < v7);
  }
  return result;
}

intptr_t SignalLoadQueueThreads(intptr_t result, int a2)
{
  int v2;
  intptr_t v3;
  int v4;

  atomic_store(0, (unsigned int *)(result + 22512));
  v2 = *(_DWORD *)(result + 22576);
  if (v2 >= a2)
    v2 = a2;
  if (v2 >= 1)
  {
    v3 = result;
    v4 = v2 & ~(v2 >> 31);
    do
    {
      dispatch_group_enter(*(dispatch_group_t *)(v3 + 22528));
      result = dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v3 + 22520));
      --v4;
    }
    while (v4);
  }
  return result;
}

void RestoreOrderedResourcesFromArchive(id *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7;
  os_signpost_id_t v8;
  id v9;
  void *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  void *v15;
  _QWORD *v16;
  uint64_t v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  _QWORD *Object;
  uint64_t v25;
  uint64_t v26;
  id MTLIndirectCommandBufferDescriptorWithoutResourceIndex;
  void *v28;
  void *v29;
  id v30;
  apr_pool_t **v31;
  apr_pool_t *v32;
  char *Data;
  id v34;
  void *v35;
  void *v36;
  void *v37;
  apr_pool_t *v38;
  uint64_t v39;
  apr_pool_t **v40;
  id v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  id v47;
  void *v48;
  void *v49;
  void *v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  id v55;
  _DWORD *v56;
  unsigned int v57;
  id v58;
  unint64_t v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  NSObject *v66;
  void *v67;
  void *v68;
  void *v69;
  void *v70;
  void *v71;
  NSObject *v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  os_signpost_id_t spid;
  id v80;
  apr_pool_t **v81;
  uint64_t v82;
  id v83;
  id *v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  void *v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  _OWORD buf[5];
  uint64_t v94;

  v7 = a4;
  v8 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, a1);
  v78 = v7;
  objc_msgSend(v7, "enterRestoreResources:count:", a2, a3);
  v80 = a1[3];
  v84 = a1;
  v77 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[1], "defaultDevice"));
  v9 = objc_msgSend(v77, "sharedMemorySize");
  v10 = g_signpostLog;
  v11 = v10;
  spid = v8;
  v92 = v8 - 1;
  if (v8 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v10))
  {
    LODWORD(buf[0]) = 67109120;
    DWORD1(buf[0]) = a3;
    _os_signpost_emit_with_name_impl(&dword_0, v11, OS_SIGNPOST_INTERVAL_BEGIN, v8, "Replayer-2-restore", "RestoreOrderedResourcesFromArchive x%d", (uint8_t *)buf, 8u);
  }

  if ((int)a3 >= 1)
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v87 = 4 * (uint64_t)v9 / 0xAuLL;
    v86 = a3;
    v85 = a2;
    while (1)
    {
      v15 = objc_autoreleasePoolPush();
      v16 = (_QWORD *)(a2 + (v12 << 6));
      v17 = RequestSize((uint64_t)v16);
      v18 = &_os_log_disabled;
      if (v92 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)&_os_log_disabled))
      {
        v19 = a2 + (v12 << 6);
        v20 = *(_QWORD *)(v19 + 8);
        v21 = *(_QWORD *)(v19 + 24);
        LODWORD(buf[0]) = 134218498;
        *(_QWORD *)((char *)buf + 4) = v20;
        WORD6(buf[0]) = 2048;
        *(_QWORD *)((char *)buf + 14) = v17;
        WORD3(buf[1]) = 2082;
        *((_QWORD *)&buf[1] + 1) = v21;
        _os_signpost_emit_with_name_impl(&dword_0, (os_log_t)&_os_log_disabled, OS_SIGNPOST_INTERVAL_BEGIN, spid, "Replayer-6-high", "%llu. %{xcode:size-in-bytes}zu %{public}s", (uint8_t *)buf, 0x20u);
      }

      if (*v16 == 16)
      {
        v88 = v17;
        v89 = v15;
        v91 = v14;
        v39 = *(_QWORD *)*v84;
        v40 = (apr_pool_t **)v84[19];
        v41 = v84[1];
        v42 = a2 + (v12 << 6);
        v44 = *(_QWORD *)(v42 + 8);
        v43 = (_QWORD *)(v42 + 8);
        v45 = (char *)v43[2];
        v83 = v41;
        v46 = objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "accelerationStructureForKey:", v44));
        v47 = v84[3];
        v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "bufferWithLength:alignment:", v43[3], 32));
        v81 = v40;
        GTCaptureArchive_fillBuffer(v39, v40, v45, (char *)objc_msgSend(v48, "contents"), v43[3], 0);
        v49 = (void *)v46;
        v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v84[1], "defaultDevice"));
        v51 = objc_msgSend(v48, "contents");
        if ((unint64_t)objc_msgSend(v48, "length") >= 0x18
          && objc_msgSend(v50, "isCompatibleWithAccelerationStructure:", *v51)
          && (unint64_t)objc_msgSend(v49, "size") >= v51[2])
        {
          v52 = objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "accelerationStructureCommandEncoder"));
          v53 = v85 + (v12 << 6);
          v54 = (_QWORD *)(v53 + 40);
          if (*(_QWORD *)(v53 + 40))
          {
            v73 = (void *)v52;
            v74 = v50;
            v75 = v48;
            v76 = v49;
            v55 = objc_alloc((Class)NSMutableArray);
            v57 = *(_DWORD *)(v53 + 48);
            v56 = (_DWORD *)(v53 + 48);
            v58 = objc_msgSend(v55, "initWithCapacity:", v57);
            if (*v56)
            {
              v59 = 0;
              do
              {
                v60 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v83, "accelerationStructureForKey:", *(_QWORD *)(*v54 + 8 * v59)));
                objc_msgSend(v58, "addObject:", v60);

                ++v59;
              }
              while (v59 < *v56);
            }
            v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("deserializeInstanceAccelerationStructure %llu"), *v43));
            v62 = v73;
            objc_msgSend(v73, "insertDebugSignpost:", v61);

            v48 = v75;
            v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v75, "heapBuffer"));
            v49 = v76;
            objc_msgSend(v73, "deserializeInstanceAccelerationStructure:primitiveAccelerationStructures:fromBuffer:serializedBufferOffset:", v76, v58, v63, objc_msgSend(v75, "heapLocation"));

            v50 = v74;
          }
          else
          {
            v62 = (void *)v52;
            v64 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("deserializePrimitiveAccelerationStructure %llu"), *v43));
            objc_msgSend(v62, "insertDebugSignpost:", v64);

            v58 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v48, "heapBuffer"));
            objc_msgSend(v62, "deserializePrimitiveAccelerationStructure:fromBuffer:serializedBufferOffset:", v49, v58, objc_msgSend(v48, "heapLocation"));
          }

        }
        apr_pool_clear(*v81);

        v14 = v91;
        v30 = v83;
      }
      else
      {
        if (*v16 != 57)
          goto LABEL_24;
        v88 = v17;
        v89 = v15;
        v22 = (uint64_t *)*v84;
        v23 = a2 + (v12 << 6);
        Object = GTMTLSMContext_getObject(**((_QWORD **)*v84 + 5), *(_QWORD *)(v23 + 8), *(_QWORD *)(v23 + 16));
        v25 = *((unsigned int *)Object + 34);
        v82 = v25;
        v26 = Object[13];
        MTLIndirectCommandBufferDescriptorWithoutResourceIndex = MakeMTLIndirectCommandBufferDescriptorWithoutResourceIndex(v26);
        v90 = v14;
        v28 = (void *)objc_claimAutoreleasedReturnValue(MTLIndirectCommandBufferDescriptorWithoutResourceIndex);
        v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v84[1], "defaultDevice"));
        v30 = objc_msgSend(v29, "newIndirectCommandBufferWithDescriptor:maxCommandCount:options:", v28, v25, 256);

        v31 = (apr_pool_t **)v84[19];
        v32 = *v31;
        Data = GTCaptureArchive_readData((const char **)*v22, v31, *(char **)(v23 + 24), *v31, 0);
        v94 = 0;
        memset(buf, 0, sizeof(buf));
        GTMTLSMContext_indirectCommandBufferResources((uint64_t)buf, (_DWORD **)v22[5], v22[10], v32);
        v34 = objc_msgSend(v30, "size");
        v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v84[1], "restoreIndirectCommandBufferDataMap"));
        GTMTLEncodeIndirectCommandBufferWithRange(v30, 0, (uint64_t)v34, v26, (uint64_t)Data, (uint64_t *)buf, v35);

        v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v84[1], "indirectCommandBufferForKey:", *(_QWORD *)(v23 + 8)));
        v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v84[3], "blitCommandEncoder"));
        objc_msgSend(v37, "copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:", v30, 0, v82, v36, 0);

        v38 = v32;
        v14 = v90;
        apr_pool_clear(v38);

      }
      a2 = v85;
      v17 = v88;
      v15 = v89;
LABEL_24:
      v65 = g_signpostLog;
      v66 = v65;
      if (v92 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v65))
      {
        LOWORD(buf[0]) = 0;
        _os_signpost_emit_with_name_impl(&dword_0, v66, OS_SIGNPOST_INTERVAL_END, spid, "Replayer-6-high", (const char *)&unk_4AAB5F, (uint8_t *)buf, 2u);
      }
      v14 += v17;

      if (v14 >= v87)
      {
        v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@.%@"), CFSTR("com.apple.gputools.replay"), CFSTR("RestoreOrderedResourcesFromArchive")));
        v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v80, "commandBuffer"));
        objc_msgSend(v68, "setLabel:", v67);

        objc_msgSend(v80, "commitCommandBuffer");
        v14 = 0;
      }
      v13 += v17;
      objc_autoreleasePoolPop(v15);
      if (++v12 == v86)
        goto LABEL_32;
    }
  }
  v13 = 0;
LABEL_32:
  v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@.%@"), CFSTR("com.apple.gputools.replay"), CFSTR("RestoreOrderedResourcesFromArchive")));
  v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v80, "commandBuffer"));
  objc_msgSend(v70, "setLabel:", v69);

  objc_msgSend(v80, "commitCommandBuffer");
  v71 = g_signpostLog;
  v72 = v71;
  if (v92 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v71))
  {
    LODWORD(buf[0]) = 134217984;
    *(_QWORD *)((char *)buf + 4) = v13;
    _os_signpost_emit_with_name_impl(&dword_0, v72, OS_SIGNPOST_INTERVAL_END, spid, "Replayer-2-restore", "%{xcode:size-in-bytes}zu", (uint8_t *)buf, 0xCu);
  }

  objc_msgSend(v78, "leaveActivity");
}

apr_hash_index_t *RestoreVisibleFunctionTablesForFunctionIndex(id *a1, unint64_t a2)
{
  id *v3;
  uint64_t v4;
  apr_hash_index_t *result;
  apr_hash_index_t *v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *Object;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  os_signpost_id_t v22;
  void *v23;
  NSObject *v24;
  void *v25;
  void *v26;
  NSObject *v27;
  id v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  unint64_t v38;
  int v40;
  char *v41;
  void *v42;
  void *v43;
  char *v44;
  _QWORD *v45;
  char *v46;
  char *v47;
  unint64_t v48;
  unint64_t v49;
  unsigned int v50;
  int v51;
  uint64_t v52;
  unint64_t v53;
  id *v54;
  apr_pool_t *p;
  void *v56;
  void *v57;
  uint64_t v58;
  uint8_t v59[16];
  uint8_t buf[8];
  uint64_t v61;

  v3 = a1;
  v4 = *((_QWORD *)*a1 + 21);
  *(_QWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 32) = 0;
  *(_QWORD *)(v4 + 16) = v4;
  *(_DWORD *)(v4 + 40) = 0;
  result = apr_hash_next((apr_hash_index_t *)(v4 + 16));
  if (result)
  {
    v6 = result;
    v7 = 1;
    v53 = a2;
    v54 = v3;
    do
    {
      v8 = *((_QWORD *)v6 + 1);
      v9 = *(_QWORD *)(v8 + 32);
      if (*(int *)(v9 + 12) < 1)
        goto LABEL_52;
      v10 = 0;
      v11 = 0;
      v12 = **(_QWORD **)(v8 + 16);
      do
      {
        Object = GTMTLSMContext_getObject(**((_QWORD **)*v3 + 5), v12, a2);
        if (Object)
        {
          v14 = Object[2];
          v15 = *v3;
          v16 = *((_QWORD *)*v3 + 8);
          if (v16 > v14 || *((_QWORD *)*v3 + 9) + v16 <= v14)
          {
            v18 = (unint64_t *)(*(_QWORD *)(v9 + 24) + v10);
            v19 = *v18;
            v20 = v18[1] + *v18;
            if (*v18 <= a2 && v20 > a2)
            {
              if ((v7 & 1) != 0)
              {
                v22 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, v3);
                v23 = g_signpostLog;
                v24 = v23;
                if (v22 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v23))
                {
                  *(_WORD *)buf = 0;
                  _os_signpost_emit_with_name_impl(&dword_0, v24, OS_SIGNPOST_INTERVAL_BEGIN, v22, "Replayer-2-restore", "RestoreVisibleFunctionTablesFlush", buf, 2u);
                }

                v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3[1], "defaultCommandQueue"));
                objc_msgSend(v25, "finish");
                v26 = g_signpostLog;
                v27 = v26;
                if (v22 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v26))
                {
                  *(_WORD *)v59 = 0;
                  _os_signpost_emit_with_name_impl(&dword_0, v27, OS_SIGNPOST_INTERVAL_END, v22, "Replayer-2-restore", (const char *)&unk_4AAB5F, v59, 2u);
                }

                v15 = *v3;
              }
              v58 = v15[2];
              v28 = v3[1];
              v29 = *((_QWORD *)*v3 + 1);
              v61 = v12;
              v30 = *(_QWORD *)(*(_QWORD *)(*find_entry(v29, &v61, 8uLL, 0) + 32) + 32);
              v31 = 0;
              if (v30)
              {
                do
                {
                  v32 = atomic_load((unsigned int *)(v30 + 4));
                  v33 = v31 + (v32 >> 6) - 1;
                  if ((int)v33 > 0)
                    goto LABEL_28;
                  v30 = *(_QWORD *)(v30 + 40);
                  v31 = v33;
                }
                while (v30);
                v31 = v33;
              }
              else
              {
LABEL_28:
                v33 = 0;
              }
              v34 = v31 | (unint64_t)(v33 << 32);
              v57 = v28;
LABEL_30:
              v35 = v30 + 64;
LABEL_31:
              if (!v30
                || (v36 = HIDWORD(v34) - v34, (*(_BYTE *)(v35 + ((uint64_t)(HIDWORD(v34) - (int)v34) << 6) + 15) & 8) == 0))
              {
LABEL_51:

                v7 = 0;
                a2 = v53;
                break;
              }
              v37 = v35 + ((uint64_t)v36 << 6);
              v38 = *(_QWORD *)v37;
              if (v19 <= *(_QWORD *)v37 && v20 > v38)
              {
                v40 = *(_DWORD *)(v37 + 8);
                if (v40 == -15597)
                {
                  v44 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v37, *(unsigned __int8 *)(v35 + ((uint64_t)v36 << 6) + 13), v58);
                  v3 = v54;
                  v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "visibleFunctionTableForKey:", *(_QWORD *)v44));
                  p = *(apr_pool_t **)v54[19];
                  v45 = apr_palloc(p, 8 * *((_QWORD *)v44 + 2));
                  v46 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v37, v44[24], v58);
                  if (*((_QWORD *)v44 + 2))
                  {
                    v47 = v46;
                    v48 = 0;
                    do
                    {
                      v45[v48] = objc_msgSend(v57, "functionHandleForKey:", *(_QWORD *)&v47[8 * v48], v53);
                      ++v48;
                      v49 = *((_QWORD *)v44 + 2);
                    }
                    while (v49 > v48);
                    v3 = v54;
                  }
                  else
                  {
                    v49 = 0;
                  }
                  v42 = v56;
                  objc_msgSend(v56, "setFunctions:withRange:", v45, *((_QWORD *)v44 + 1), v49, v53);
                  apr_pool_clear(p);
                  v28 = v57;
                }
                else
                {
                  if (v40 != -15598)
                    goto LABEL_49;
                  v41 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v37, *(unsigned __int8 *)(v35 + ((uint64_t)v36 << 6) + 13), v58);
                  v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "visibleFunctionTableForKey:", *(_QWORD *)v41));
                  v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "functionHandleForKey:", *((_QWORD *)v41 + 1)));
                  objc_msgSend(v42, "setFunction:atIndex:", v43, *((_QWORD *)v41 + 2));

                }
                v35 = v30 + 64;
              }
              else if (v38 > v20)
              {
                goto LABEL_51;
              }
LABEL_49:
              v50 = atomic_load((unsigned int *)(v30 + 4));
              v51 = v34 + (v50 >> 6);
              v52 = (HIDWORD(v34) + 1);
              v34 = (v52 << 32) | v34;
              if ((_DWORD)v52 == v51 - 1)
              {
                v34 = (v52 << 32) | v52;
                v30 = *(_QWORD *)(v30 + 40);
                goto LABEL_30;
              }
              goto LABEL_31;
            }
          }
        }
        ++v11;
        v10 += 16;
      }
      while (v11 < *(int *)(v9 + 12));
LABEL_52:
      result = apr_hash_next(v6);
      v6 = result;
    }
    while (result);
  }
  return result;
}

apr_hash_index_t *RestoreIntersectionFunctionTablesForFunctionIndex(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  apr_hash_index_t *result;
  apr_hash_index_t *v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *Object;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  os_signpost_id_t v22;
  void *v23;
  NSObject *v24;
  void *v25;
  void *v26;
  NSObject *v27;
  id v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  int v37;
  uint64_t v38;
  unint64_t v39;
  int v41;
  char *v42;
  char *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  apr_pool_t *v48;
  char *v49;
  _QWORD *v50;
  char *v51;
  char *v52;
  unint64_t v53;
  unint64_t v54;
  char *v55;
  void *v56;
  char *v57;
  char *v58;
  char *v59;
  void *v60;
  unint64_t v61;
  uint64_t v62;
  void *v63;
  unint64_t v64;
  char *v65;
  char *v66;
  char *v67;
  void *v68;
  char *v69;
  char *v70;
  id NSError;
  id v72;
  uint64_t v73;
  unsigned int v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  int64x2_t v78;
  apr_pool_t *p;
  apr_pool_t *pa;
  apr_pool_t *pb;
  apr_hash_index_t *v82;
  void *v83;
  void *v84;
  void *v85;
  int v86;
  int v87;
  void *v88;
  uint64_t v89;
  unint64_t v90;
  id v91;
  int64x2_t v92;
  uint64_t v93;
  int64x2_t v94;
  uint8_t buf[16];
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  uint64_t v110;

  v4 = *(_QWORD *)(*a1 + 176);
  *(_QWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 32) = 0;
  *(_QWORD *)(v4 + 16) = v4;
  *(_DWORD *)(v4 + 40) = 0;
  result = apr_hash_next((apr_hash_index_t *)(v4 + 16));
  if (result)
  {
    v6 = result;
    v7 = 1;
    do
    {
      v8 = *((_QWORD *)v6 + 1);
      v9 = *(_QWORD *)(v8 + 32);
      if (*(int *)(v9 + 12) < 1)
        goto LABEL_82;
      v10 = 0;
      v11 = 0;
      v12 = **(_QWORD **)(v8 + 16);
      do
      {
        Object = GTMTLSMContext_getObject(**(_QWORD **)(*a1 + 40), v12, a2);
        if (Object)
        {
          v14 = Object[2];
          v15 = *a1;
          v16 = *(_QWORD *)(*a1 + 64);
          if (v16 > v14 || *(_QWORD *)(*a1 + 72) + v16 <= v14)
          {
            v18 = (unint64_t *)(*(_QWORD *)(v9 + 24) + v10);
            v19 = *v18;
            v20 = v18[1] + *v18;
            if (*v18 <= a2 && v20 > a2)
            {
              if ((v7 & 1) != 0)
              {
                v22 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, a1);
                v23 = g_signpostLog;
                v24 = v23;
                if (v22 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v23))
                {
                  *(_WORD *)buf = 0;
                  _os_signpost_emit_with_name_impl(&dword_0, v24, OS_SIGNPOST_INTERVAL_BEGIN, v22, "Replayer-2-restore", "RestoreIntersectionFunctionTablesFlush", buf, 2u);
                }

                v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1[1], "defaultCommandQueue"));
                objc_msgSend(v25, "finish");
                v26 = g_signpostLog;
                v27 = v26;
                if (v22 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v26))
                {
                  *(_WORD *)buf = 0;
                  _os_signpost_emit_with_name_impl(&dword_0, v27, OS_SIGNPOST_INTERVAL_END, v22, "Replayer-2-restore", (const char *)&unk_4AAB5F, buf, 2u);
                }

                v15 = *a1;
              }
              v89 = *(_QWORD *)(v15 + 16);
              v28 = (id)a1[1];
              v29 = *(_QWORD *)(*a1 + 8);
              *(_QWORD *)buf = v12;
              v30 = *(_QWORD *)(*(_QWORD *)(*find_entry(v29, buf, 8uLL, 0) + 32) + 32);
              v82 = v6;
              v31 = 0;
              if (v30)
              {
                do
                {
                  v32 = atomic_load((unsigned int *)(v30 + 4));
                  v33 = v31 + (v32 >> 6) - 1;
                  if ((int)v33 > 0)
                  {
                    v33 = 0;
                    goto LABEL_30;
                  }
                  v30 = *(_QWORD *)(v30 + 40);
                  v31 = v33;
                }
                while (v30);
                v31 = v33;
              }
              else
              {
                v33 = 0;
              }
LABEL_30:
              v34 = v31 | (unint64_t)(v33 << 32);
              v88 = v28;
LABEL_31:
              v35 = v30 + 64;
LABEL_32:
              if (!v30
                || (v36 = HIDWORD(v34),
                    v37 = HIDWORD(v34) - v34,
                    (*(_BYTE *)(v35 + ((uint64_t)(HIDWORD(v34) - (int)v34) << 6) + 15) & 8) == 0))
              {
LABEL_81:

                v7 = 0;
                v6 = v82;
                break;
              }
              v38 = v35 + ((uint64_t)v37 << 6);
              v39 = *(_QWORD *)v38;
              if (v19 > *(_QWORD *)v38 || v20 <= v39)
              {
                if (v39 > v20)
                  goto LABEL_81;
                goto LABEL_79;
              }
              v41 = *(_DWORD *)(v38 + 8);
              v90 = HIDWORD(v34);
              if (v41 > -15531)
              {
                if (v41 <= -15259)
                {
                  if (v41 == -15530)
                  {
                    v69 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v38, *(unsigned __int8 *)(v35 + ((uint64_t)v37 << 6) + 13), v89);
                    v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "intersectionFunctionTableForKey:", *(_QWORD *)v69));
                    objc_msgSend(v56, "setOpaqueTriangleIntersectionFunctionWithSignature:atIndex:", *((_QWORD *)v69 + 1), *((_QWORD *)v69 + 2));
                  }
                  else
                  {
                    if (v41 != -15529)
                      goto LABEL_79;
                    v55 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v38, *(unsigned __int8 *)(v35 + ((uint64_t)v37 << 6) + 13), v89);
                    v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "intersectionFunctionTableForKey:", *(_QWORD *)v55));
                    objc_msgSend(v56, "setOpaqueTriangleIntersectionFunctionWithSignature:withRange:", *((_QWORD *)v55 + 1), *((_QWORD *)v55 + 2), *((_QWORD *)v55 + 3));
                  }
                }
                else if (v41 == -15258)
                {
                  v65 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v38, *(unsigned __int8 *)(v35 + ((uint64_t)v37 << 6) + 13), v89);
                  v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "intersectionFunctionTableForKey:", *(_QWORD *)v65));
                  objc_msgSend(v56, "setOpaqueCurveIntersectionFunctionWithSignature:atIndex:", *((_QWORD *)v65 + 1), *((_QWORD *)v65 + 2));
                }
                else
                {
                  if (v41 != -15257)
                  {
                    if (v41 == -10152)
                    {
                      v86 = v34;
                      v42 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v38, *(unsigned __int8 *)(v35 + ((uint64_t)v37 << 6) + 13), v89);
                      v34 = objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "intersectionFunctionTableForKey:", *(_QWORD *)v42));
                      v43 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v38, v42[8], v89);
                      v77 = *(_QWORD *)v43;
                      v83 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1[1], "defaultCommandQueue"));
                      v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v83, "commandBuffer"));
                      v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@.%@"), CFSTR("com.apple.gputools.replay"), CFSTR("RestoreIFT")));
                      objc_msgSend(v44, "setLabel:", v45);

                      v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v44, "computeCommandEncoder"));
                      v47 = v46;
                      v48 = (apr_pool_t *)a1[15];
                      p = v48;
                      if (v48)
                      {
                        objc_msgSend(v46, "setComputePipelineState:", v48);
                        objc_msgSend(v47, "setIntersectionFunctionTable:atBufferIndex:", v34, 0);
                        objc_msgSend(v47, "setBytes:length:atIndex:", v43 + 8, 8 * (int)v77, 1);
                        objc_msgSend(v47, "setBytes:length:atIndex:", v43, 8, 2);
                        v93 = *(_QWORD *)v43;
                        v78 = vdupq_n_s64(1uLL);
                        v94 = v78;
                        v91 = objc_msgSend((id)a1[15], "threadExecutionWidth");
                        v92 = v78;
                        objc_msgSend(v47, "dispatchThreads:threadsPerThreadgroup:", &v93, &v91);
                        objc_msgSend(v47, "endEncoding");
                        objc_msgSend(v44, "addCompletedHandler:", &__block_literal_global_100);
                        GTMTLReplay_commitCommandBuffer(v44);
                      }
                      else
                      {
                        NSError = MakeNSError(101, &__NSDictionary0__struct);
                        v72 = (id)objc_claimAutoreleasedReturnValue(NSError);
                        GTMTLReplay_handleNSError(v72);

                      }
                      LODWORD(v34) = v86;
                      v28 = v88;
                      v35 = v30 + 64;
                      LODWORD(v36) = v90;
                      if (!p)
                        goto LABEL_81;
                    }
LABEL_79:
                    v74 = atomic_load((unsigned int *)(v30 + 4));
                    v75 = v34 + (v74 >> 6);
                    v76 = (v36 + 1);
                    v34 = (v76 << 32) | v34;
                    if ((_DWORD)v76 == v75 - 1)
                    {
                      v34 = (v76 << 32) | v76;
                      v30 = *(_QWORD *)(v30 + 40);
                      goto LABEL_31;
                    }
                    goto LABEL_32;
                  }
                  v66 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v38, *(unsigned __int8 *)(v35 + ((uint64_t)v37 << 6) + 13), v89);
                  v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "intersectionFunctionTableForKey:", *(_QWORD *)v66));
                  objc_msgSend(v56, "setOpaqueCurveIntersectionFunctionWithSignature:withRange:", *((_QWORD *)v66 + 1), *((_QWORD *)v66 + 2), *((_QWORD *)v66 + 3));
                }
LABEL_78:

                v35 = v30 + 64;
                LODWORD(v36) = v90;
                goto LABEL_79;
              }
              if (v41 > -15546)
              {
                if (v41 != -15545)
                {
                  if (v41 != -15544)
                    goto LABEL_79;
                  v57 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v38, *(unsigned __int8 *)(v35 + ((uint64_t)v37 << 6) + 13), v89);
                  v85 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "intersectionFunctionTableForKey:", *(_QWORD *)v57));
                  v110 = 0;
                  v108 = 0u;
                  v109 = 0u;
                  v106 = 0u;
                  v107 = 0u;
                  v104 = 0u;
                  v105 = 0u;
                  v102 = 0u;
                  v103 = 0u;
                  v100 = 0u;
                  v101 = 0u;
                  v98 = 0u;
                  v99 = 0u;
                  v96 = 0u;
                  v97 = 0u;
                  *(_OWORD *)buf = 0u;
                  v58 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v38, v57[24], v89);
                  v59 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v38, v57[25], v89);
                  v60 = v59;
                  if (*((_QWORD *)v57 + 2))
                  {
                    pb = (apr_pool_t *)v59;
                    v61 = 0;
                    do
                    {
                      v62 = objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "bufferForKey:", *(_QWORD *)&v58[8 * v61], v60));
                      v63 = *(void **)&buf[8 * v61];
                      *(_QWORD *)&buf[8 * v61] = v62;

                      ++v61;
                      v64 = *((_QWORD *)v57 + 2);
                    }
                    while (v64 > v61);
                    v60 = pb;
                  }
                  else
                  {
                    v64 = 0;
                  }
                  v56 = v85;
                  objc_msgSend(v85, "setBuffers:offsets:withRange:", buf, v60, *((_QWORD *)v57 + 1), v64);
                  v73 = 240;
                  v28 = v88;
                  do
                  {

                    v73 -= 8;
                  }
                  while (v73 != -8);
                  goto LABEL_78;
                }
                v70 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v38, *(unsigned __int8 *)(v35 + ((uint64_t)v37 << 6) + 13), v89);
                v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "intersectionFunctionTableForKey:", *(_QWORD *)v70));
                v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "bufferForKey:", *((_QWORD *)v70 + 1)));
                objc_msgSend(v56, "setBuffer:offset:atIndex:", v68, *((_QWORD *)v70 + 2), *((_QWORD *)v70 + 3));
              }
              else
              {
                if (v41 != -15559)
                {
                  if (v41 != -15558)
                    goto LABEL_79;
                  v49 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v38, *(unsigned __int8 *)(v35 + ((uint64_t)v37 << 6) + 13), v89);
                  v84 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "intersectionFunctionTableForKey:", *(_QWORD *)v49));
                  pa = *(apr_pool_t **)a1[19];
                  v50 = apr_palloc(pa, 8 * *((_QWORD *)v49 + 2));
                  v51 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v38, v49[24], v89);
                  if (*((_QWORD *)v49 + 2))
                  {
                    v52 = v51;
                    v87 = v34;
                    v53 = 0;
                    do
                    {
                      v50[v53] = objc_msgSend(v88, "functionHandleForKey:", *(_QWORD *)&v52[8 * v53]);
                      ++v53;
                      v54 = *((_QWORD *)v49 + 2);
                    }
                    while (v54 > v53);
                    LODWORD(v34) = v87;
                  }
                  else
                  {
                    v54 = 0;
                  }
                  v56 = v84;
                  objc_msgSend(v84, "setFunctions:withRange:", v50, *((_QWORD *)v49 + 1), v54);
                  apr_pool_clear(pa);
                  goto LABEL_74;
                }
                v67 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v38, *(unsigned __int8 *)(v35 + ((uint64_t)v37 << 6) + 13), v89);
                v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "intersectionFunctionTableForKey:", *(_QWORD *)v67));
                v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "functionHandleForKey:", *((_QWORD *)v67 + 1)));
                objc_msgSend(v56, "setFunction:atIndex:", v68, *((_QWORD *)v67 + 2));
              }

LABEL_74:
              v28 = v88;
              goto LABEL_78;
            }
          }
        }
        ++v11;
        v10 += 16;
      }
      while (v11 < *(int *)(v9 + 12));
LABEL_82:
      result = apr_hash_next(v6);
      v6 = result;
    }
    while (result);
  }
  return result;
}

void DoLoadJob(uint64_t **a1, uint64_t a2, void *a3, apr_hash_t *a4)
{
  id v6;
  void *v7;
  uint64_t *v8;
  uint64_t v9;
  id v10;
  os_signpost_id_t v11;
  uint64_t *v12;
  void *v13;
  NSObject *v14;
  unint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  id v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  id v27;
  os_signpost_id_t v28;
  uint64_t *v29;
  void *v30;
  NSObject *v31;
  uint64_t v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  void *v36;
  uint64_t v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  __objc2_class_ro **p_info;
  void *v43;
  NSObject *v44;
  unint64_t v45;
  apr_pool_t **v46;
  void *v47;
  NSObject *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t *v53;
  id v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void *v60;
  apr_array_header_t *v61;
  void *v62;
  id v63;
  char *v64;
  char *v65;
  char *v66;
  char *v67;
  BOOL v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  size_t v73;
  int v74;
  _QWORD *v75;
  _QWORD *v76;
  _QWORD *v77;
  void *v78;
  void *v79;
  void *v80;
  NSObject *v81;
  NSObject *v82;
  void *v83;
  void *v84;
  void *v85;
  NSObject *v86;
  void *v87;
  void *v88;
  NSObject *v89;
  NSObject *v90;
  void *v91;
  void *v92;
  apr_pool_t **v93;
  uint64_t v94;
  unint64_t v95;
  apr_hash_t *ht;
  uint64_t v97;
  uint64_t v98;
  uint64_t *v99;
  uint64_t *v100;
  void *v101;
  void *v102;
  void *v103;
  _QWORD *v104;
  apr_pool_t *p;
  os_signpost_id_t spid;
  id v107;
  uint64_t *v108;
  void *v110;
  void *v111;
  uint64_t v112;
  uint8_t buf[4];
  uint64_t v114;
  __int16 v115;
  uint64_t v116;
  __int16 v117;
  uint64_t v118;

  v6 = a3;
  v7 = v6;
  if (*(_DWORD *)a2 == 1)
  {
    ht = a4;
    v25 = *(_QWORD *)(a2 + 8);
    v26 = *(unsigned int *)(a2 + 4);
    v27 = v6;
    v28 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, a1);
    v91 = v27;
    v98 = v25;
    objc_msgSend(v27, "enterRestoreResources:count:", v25, v26);
    v29 = a1[3];
    v108 = a1[1];
    v107 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", (int)v26);
    v30 = g_signpostLog;
    v31 = v30;
    spid = v28;
    v95 = v28 - 1;
    if (v28 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v30))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_0, v31, OS_SIGNPOST_INTERVAL_BEGIN, v28, "Replayer-2-restore", "DownloadBufferContent", buf, 2u);
    }

    v97 = v26;
    if ((int)v26 >= 1)
    {
      v32 = v26;
      v33 = (_QWORD *)(v25 + 40);
      do
      {
        if (*(v33 - 5) == 22)
        {
          v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v108, "bufferForKey:", *(v33 - 4)));
          v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v29, "bufferWithLength:alignment:", *v33, 1));
          v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v29, "blitCommandEncoder"));
          v37 = *(v33 - 1);
          v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "heapBuffer"));
          objc_msgSend(v36, "copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:", v34, v37, v38, objc_msgSend(v35, "heapLocation"), *v33);

          v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(v33 - 4)));
          objc_msgSend(v107, "setObject:forKey:", v35, v39);

        }
        v33 += 8;
        --v32;
      }
      while (v32);
    }
    v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v29, "commandBuffer"));
    v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@.%@"), CFSTR("com.apple.gputools.replay"), CFSTR("DownloadBufferContent")));
    objc_msgSend(v40, "setLabel:", v41);

    objc_msgSend(v29, "commitCommandBuffer");
    objc_msgSend(v40, "waitUntilCompleted");

    p_info = &OBJC_METACLASS___GTShaderProfilerBinaryAnalysisResult.info;
    v43 = g_signpostLog;
    v44 = v43;
    v45 = v95;
    if (v95 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v43))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_0, v44, OS_SIGNPOST_INTERVAL_END, spid, "Replayer-2-restore", (const char *)&unk_4AAB5F, buf, 2u);
    }

    v94 = **a1;
    v46 = (apr_pool_t **)a1[19];
    p = *(apr_pool_t **)ht;
    v47 = g_signpostLog;
    v48 = v47;
    v50 = v97;
    v49 = v98;
    if (v95 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v47))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v114) = v97;
      _os_signpost_emit_with_name_impl(&dword_0, v48, OS_SIGNPOST_INTERVAL_BEGIN, spid, "Replayer-2-restore", "CompareAndRestoreResourcesFromArchive x%d", buf, 8u);
    }
    v92 = v7;

    if ((int)v97 < 1)
    {
      v52 = 0;
    }
    else
    {
      v51 = 0;
      v52 = 0;
      v100 = v29;
      v93 = v46;
      do
      {
        v111 = objc_autoreleasePoolPush();
        v53 = (uint64_t *)(v49 + (v51 << 6));
        v112 = RequestSize((uint64_t)v53);
        v54 = &_os_log_disabled;
        if (v45 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)&_os_log_disabled))
        {
          v55 = v49 + (v51 << 6);
          v56 = *(_QWORD *)(v55 + 8);
          v57 = *(_QWORD *)(v55 + 24);
          *(_DWORD *)buf = 134218498;
          v114 = v56;
          v115 = 2048;
          v116 = v112;
          v117 = 2082;
          v118 = v57;
          _os_signpost_emit_with_name_impl(&dword_0, (os_log_t)&_os_log_disabled, OS_SIGNPOST_INTERVAL_BEGIN, spid, "Replayer-6-high", "%llu. %{xcode:size-in-bytes}zu %{public}s", buf, 0x20u);
        }

        v58 = *v53;
        if (*v53 == 86)
        {
          GTMTLReplayController_restoreIOSurfaceData_length_forPlane((uint64_t)a1, v49 + (v51 << 6));
        }
        else if (v58 == 80)
        {
          GTMTLReplayController_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage((uint64_t)a1, v49 + (v51 << 6));
        }
        else if (v58 == 22)
        {
          v59 = v49 + (v51 << 6);
          v60 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v29, "bufferWithLength:alignment:", *(_QWORD *)(v59 + 40), 1));
          GTCaptureArchive_fillBuffer(v94, v46, *(char **)(v59 + 24), (char *)objc_msgSend(v60, "contents"), *(_QWORD *)(v59 + 40), 0);
          v61 = apr_array_make(p, 0, 16);
          v104 = (_QWORD *)(v59 + 8);
          v102 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v59 + 8)));
          v62 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v107, "objectForKeyedSubscript:"));
          v63 = v60;
          v64 = (char *)objc_msgSend(v62, "length");
          v101 = v62;
          v65 = (char *)objc_msgSend(v62, "contents");
          v103 = v63;
          v66 = (char *)objc_msgSend(v63, "contents");
          if (v64)
          {
            v67 = v66;
            v68 = 0;
            v69 = 0;
            v70 = 0;
            do
            {
              v71 = (unint64_t)&v64[-v69];
              while (1)
              {
                v72 = v71 - 0x10000;
                v73 = v71 >= 0x10000 ? 0x10000 : v71;
                v74 = memcmp(&v65[v69], &v67[v69], v73);
                if (v74 || !v68)
                  break;
                v75 = apr_array_push(v61);
                v68 = 0;
                *v75 = v70;
                v75[1] = v69 - v70;
                v69 += 0x10000;
                v71 = v72;
                if (v69 >= (unint64_t)v64)
                  goto LABEL_59;
              }
              if (((v68 ^ (v74 != 0)) & 1) != 0)
              {
                v70 = v69;
                v68 = v74 != 0;
              }
              v69 += 0x10000;
            }
            while (v69 < (unint64_t)v64);
            if (v68)
            {
              v76 = apr_array_push(v61);
              *v76 = v70;
              v76[1] = &v64[-v70];
            }
          }
LABEL_59:

          v77 = apr_palloc(p, 8uLL);
          *v77 = *v104;
          apr_hash_set(ht, v77, 8, v61);
          v78 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v108, "bufferForKey:", *v104));
          v29 = v100;
          v79 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v100, "blitCommandEncoder"));
          v80 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v103, "heapBuffer"));
          objc_msgSend(v79, "copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:", v80, objc_msgSend(v103, "heapLocation"), v78, v104[3], v104[4]);

          v46 = v93;
          apr_pool_clear(*v93);

          p_info = (__objc2_class_ro **)(&OBJC_METACLASS___GTShaderProfilerBinaryAnalysisResult + 32);
          v50 = v97;
          v49 = v98;
          v45 = v95;
        }
        v81 = p_info[424];
        v82 = v81;
        if (v45 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v81))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl(&dword_0, v82, OS_SIGNPOST_INTERVAL_END, spid, "Replayer-6-high", (const char *)&unk_4AAB5F, buf, 2u);
        }
        v52 += v112;

        objc_autoreleasePoolPop(v111);
        ++v51;
      }
      while (v51 != v50);
    }
    v87 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@.%@"), CFSTR("com.apple.gputools.replay"), CFSTR("CompareAndRestoreResourcesFromArchive")));
    v88 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v29, "commandBuffer"));
    objc_msgSend(v88, "setLabel:", v87);

    objc_msgSend(v29, "commitCommandBufferWithLog:", v91);
    v89 = p_info[424];
    v90 = v89;
    if (v45 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled(v89))
    {
      *(_DWORD *)buf = 134217984;
      v114 = v52;
      _os_signpost_emit_with_name_impl(&dword_0, v90, OS_SIGNPOST_INTERVAL_END, spid, "Replayer-2-restore", "%{xcode:size-in-bytes}zu", buf, 0xCu);
    }

    objc_msgSend(v91, "leaveActivity");
    goto LABEL_77;
  }
  if (!*(_DWORD *)a2)
  {
    v8 = *(uint64_t **)(a2 + 8);
    v9 = *(unsigned int *)(a2 + 4);
    v10 = v6;
    v11 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, a1);
    v110 = v10;
    objc_msgSend(v10, "enterRestoreResources:count:", v8, v9);
    v12 = a1[3];
    v13 = g_signpostLog;
    v14 = v13;
    v15 = v11 - 1;
    if (v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v13))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v114) = v9;
      _os_signpost_emit_with_name_impl(&dword_0, v14, OS_SIGNPOST_INTERVAL_BEGIN, v11, "Replayer-2-restore", "RestoreResourceFromArchive x%d", buf, 8u);
    }
    v99 = v12;
    v92 = v7;

    if ((int)v9 < 1)
    {
      v16 = 0;
    }
    else
    {
      v16 = 0;
      do
      {
        v17 = objc_autoreleasePoolPush();
        v18 = RequestSize((uint64_t)v8);
        v19 = &_os_log_disabled;
        if (v15 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)&_os_log_disabled))
        {
          v20 = v8[1];
          v21 = v8[3];
          *(_DWORD *)buf = 134218498;
          v114 = v20;
          v115 = 2048;
          v116 = v18;
          v117 = 2082;
          v118 = v21;
          _os_signpost_emit_with_name_impl(&dword_0, (os_log_t)&_os_log_disabled, OS_SIGNPOST_INTERVAL_BEGIN, v11, "Replayer-6-high", "%llu. %{xcode:size-in-bytes}zu %{public}s", buf, 0x20u);
        }

        v22 = *v8;
        if (*v8 == 86)
        {
          GTMTLReplayController_restoreIOSurfaceData_length_forPlane((uint64_t)a1, (uint64_t)v8);
        }
        else if (v22 == 80)
        {
          GTMTLReplayController_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage((uint64_t)a1, (uint64_t)v8);
        }
        else if (v22 == 22)
        {
          GTMTLReplayController_restoreMTLBufferContents((uint64_t)a1, v8);
        }
        v23 = g_signpostLog;
        v24 = v23;
        if (v15 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v23))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl(&dword_0, v24, OS_SIGNPOST_INTERVAL_END, v11, "Replayer-6-high", (const char *)&unk_4AAB5F, buf, 2u);
        }
        v16 += v18;

        objc_autoreleasePoolPop(v17);
        v8 += 8;
        --v9;
      }
      while (v9);
    }
    v83 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@.%@"), CFSTR("com.apple.gputools.replay"), CFSTR("RestoreResourcesFromArchive")));
    v29 = v99;
    v84 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v99, "commandBuffer"));
    objc_msgSend(v84, "setLabel:", v83);

    objc_msgSend(v99, "commitCommandBufferWithLog:", v110);
    v85 = g_signpostLog;
    v86 = v85;
    if (v15 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v85))
    {
      *(_DWORD *)buf = 134217984;
      v114 = v16;
      _os_signpost_emit_with_name_impl(&dword_0, v86, OS_SIGNPOST_INTERVAL_END, v11, "Replayer-2-restore", "%{xcode:size-in-bytes}zu", buf, 0xCu);
    }

    objc_msgSend(v110, "leaveActivity");
LABEL_77:
    v7 = v92;

  }
}

uint64_t RequestSize(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = 0;
  v3 = *(_QWORD *)a1;
  if (*(uint64_t *)a1 > 49)
  {
    if (v3 == 86)
      return *(unsigned int *)(a1 + 32);
    if (v3 == 80)
      return *(unsigned int *)(a1 + 56);
    if (v3 != 50)
      return result;
    return *(_QWORD *)(a1 + 40);
  }
  if (v3 == 16)
    return *(_QWORD *)(a1 + 32);
  if (v3 == 22)
    return *(_QWORD *)(a1 + 40);
  return result;
}

void GTMTLReplayController_restoreIOSurfaceData_length_forPlane(uint64_t a1, uint64_t a2)
{
  apr_pool_t **v4;
  apr_pool_t *v5;
  char *Data;
  unint64_t v7;
  unint64_t v8;
  void *v9;
  __IOSurface *v10;
  __IOSurface *v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  size_t PlaneCount;
  size_t v16;
  size_t v17;
  uint64_t v18;
  size_t HeightOfPlane;
  size_t WidthOfPlane;
  size_t BytesPerRowOfPlane;
  size_t BytesPerElementOfPlane;
  char *v23;
  char *v24;
  size_t v25;
  void *v26;
  size_t v27;
  size_t AllocSize;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  size_t *v32;
  void *BaseAddressOfPlane;
  size_t v34;
  void *v35;
  apr_pool_t *v36;
  id v37;

  v4 = *(apr_pool_t ***)(a1 + 152);
  v5 = *v4;
  Data = GTCaptureArchive_readData(**(const char ****)a1, v4, *(char **)(a2 + 24), *v4, 0);
  v8 = v7;
  v37 = *(id *)(a1 + 8);
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v37, "textureForKey:", *(_QWORD *)(a2 + 8)));
  v10 = (__IOSurface *)objc_msgSend(v9, "iosurface");
  v11 = v10;
  if (Data)
    v12 = v8 >= 0x10;
  else
    v12 = 0;
  if (v12 && *(_QWORD *)Data == 0x63617074757265)
  {
    IOSurfaceLock(v10, 0, 0);
    if (!IOSurfaceGetPlaneCount(v11))
      IOSurfaceGetAllocSize(v11);
    v13 = *((_QWORD *)Data + 2);
    if (v13 <= 1)
    {
      if (v13 != 1)
        goto LABEL_31;
      v14 = *(int *)(a2 + 36);
    }
    else
    {
      v14 = 0;
    }
    v29 = Data;
    if (*(_QWORD *)Data == 0x63617074757265)
    {
      v30 = *((int *)Data + 3);
      if (*((_WORD *)Data + 4) == 1)
        v30 += 16;
      v29 = &Data[v30];
    }
    v31 = 0;
    v32 = (size_t *)(Data + 64);
    do
    {
      IOSurfaceGetHeightOfPlane(v11, v14 + v31);
      IOSurfaceGetWidthOfPlane(v11, v14 + v31);
      IOSurfaceGetBytesPerRowOfPlane(v11, v14 + v31);
      BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(v11, v14 + v31);
      memcpy(BaseAddressOfPlane, v29, *v32);
      v34 = *v32;
      v32 += 6;
      v29 += v34;
      ++v31;
    }
    while (*((_QWORD *)Data + 2) > v31);
  }
  else if (((unint64_t)objc_msgSend(v9, "pixelFormat") & 0xFFFFFFFFFFFFFFFELL) == 0x226)
  {
    v11 = (__IOSurface *)objc_msgSend(v9, "iosurface");
    IOSurfaceLock(v11, 0, 0);
    PlaneCount = IOSurfaceGetPlaneCount(v11);
    if (PlaneCount)
    {
      v16 = PlaneCount;
      v35 = v9;
      v36 = v5;
      v17 = 0;
      v18 = 0;
      do
      {
        HeightOfPlane = IOSurfaceGetHeightOfPlane(v11, v17);
        WidthOfPlane = IOSurfaceGetWidthOfPlane(v11, v17);
        BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(v11, v17);
        BytesPerElementOfPlane = IOSurfaceGetBytesPerElementOfPlane(v11, v17);
        v23 = (char *)IOSurfaceGetBaseAddressOfPlane(v11, v17);
        if (HeightOfPlane)
        {
          v24 = v23;
          v25 = BytesPerElementOfPlane * WidthOfPlane;
          do
          {
            memcpy(v24, &Data[v18], v25);
            v18 += v25;
            v24 += BytesPerRowOfPlane;
            --HeightOfPlane;
          }
          while (HeightOfPlane);
        }
        ++v17;
      }
      while (v17 != v16);
      v9 = v35;
      v5 = v36;
    }
  }
  else
  {
    IOSurfaceLock(v11, 0, 0);
    v26 = IOSurfaceGetBaseAddressOfPlane(v11, *(unsigned int *)(a2 + 36));
    v27 = *(unsigned int *)(a2 + 32);
    if (IOSurfaceGetAllocSize(v11) <= v27)
      AllocSize = IOSurfaceGetAllocSize(v11);
    else
      AllocSize = *(unsigned int *)(a2 + 32);
    memcpy(v26, Data, AllocSize);
  }
LABEL_31:
  IOSurfaceUnlock(v11, 0, 0);
  apr_pool_clear(v5);

}

uint64_t CountRequestsWithinCapacity(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if ((int)a2 >= 2)
  {
    v2 = a2;
    v4 = RequestSize(a1);
    v5 = a1 + 64;
    v6 = 1;
    while (1)
    {
      v7 = 0;
      v8 = *(_QWORD *)v5;
      if (*(uint64_t *)v5 <= 56)
      {
        if (v8 == 16)
        {
          v10 = v4 + 31;
          v9 = 32;
          goto LABEL_22;
        }
        if (v8 != 22)
          goto LABEL_10;
      }
      else if (v8 != 57)
      {
        if (v8 == 86)
        {
          v10 = v4 + 255;
LABEL_19:
          v9 = 256;
          goto LABEL_22;
        }
        if (v8 == 80)
        {
          v9 = *(unsigned __int16 *)(v5 + 60);
          v10 = v4 + v9 - 1;
          goto LABEL_22;
        }
LABEL_10:
        v7 = -1;
      }
      v10 = v7 + v4;
      if (v8 > 79)
      {
        if (v8 == 86)
          goto LABEL_19;
        if (v8 == 80)
        {
          v9 = *(unsigned __int16 *)(v5 + 60);
          goto LABEL_22;
        }
      }
      else if (v8 == 22 || v8 == 57)
      {
        v9 = 1;
        goto LABEL_22;
      }
      v9 = 0;
LABEL_22:
      v4 = (v10 & -v9) + RequestSize(v5);
      if (v4 > 0x2000000)
        return v6;
      ++v6;
      v5 += 64;
      if (v2 == v6)
        return v2;
    }
  }
  return 1;
}

uint64_t CompareRequestsBySize(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v7;
  unint64_t v8;
  BOOL v9;
  _BOOL4 v10;

  v4 = RequestSize(a2);
  v5 = RequestSize(a1);
  if (v4 < v5)
    return 0xFFFFFFFFLL;
  if (v4 != v5)
    return 1;
  v7 = *(_QWORD *)(a1 + 8);
  v8 = *(_QWORD *)(a2 + 8);
  v9 = v7 >= v8;
  v10 = v7 != v8;
  if (v9)
    return v10;
  else
    return 0xFFFFFFFFLL;
}

void __destructor_8_s8_s16_s24_s40_s48_s56_s64_s72_s80_s88_s96_s104_s112_s120_s128_s136_S_s144_S_s22520_s22528_S_s22536_s22560_s22568(id *a1)
{

}

void GTMTLReplayController_optimizeRestores(uint64_t a1, unint64_t a2)
{
  void *v4;
  os_signpost_id_t v5;
  void *v6;
  NSObject *v7;
  apr_allocator_t *v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int i;
  void *v12;
  uint64_t v13;
  int v14;
  void *v15;
  NSObject *v16;
  void *v17;
  uint64_t v18;
  apr_hash_index_t *v19;
  apr_hash_index_t *v20;
  uint64_t v21;
  int nelts;
  char *elts;
  void *v24;
  NSObject *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  apr_array_header_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const apr_array_header_t *v33;
  apr_array_header_t *v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  char *v57;
  char *v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  char *v62;
  int v63;
  apr_array_header_t *v64;
  int elt_size;
  uint64_t v66;
  uint64_t v67;
  apr_allocator_t *v68;
  apr_hash_t *v69;
  _QWORD *v70;
  void *v71;
  NSObject *v72;
  void *v73;
  unsigned int *v74;
  apr_array_header_t *v75;
  id v76;
  void *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  apr_array_header_t *v82;
  apr_hash_t *v83;
  _QWORD *v84;
  uint64_t v85;
  uint64_t v86;
  _QWORD *entry;
  uint64_t v88;
  uint64_t v89;
  apr_pool_t **v90;
  uint64_t v91;
  unsigned int *FileWithFilename;
  void *v93;
  int *v94;
  id v95;
  BOOL v96;
  uint64_t v97;
  unsigned int *v98;
  size_t *v99;
  size_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  unsigned int v112;
  __int128 *v113;
  __int128 v114;
  __int128 v115;
  unint64_t v116;
  uint64_t v117;
  int v118;
  int v119;
  void *v120;
  void *v121;
  char *v122;
  uint64_t v123;
  _DWORD *v124;
  int v125;
  int v126;
  uint64_t v127;
  int v128;
  int v129;
  __int16 v130;
  char v131;
  void *v132;
  NSObject *v133;
  void *v134;
  os_signpost_id_t spid;
  unint64_t v136;
  apr_pool_t *p;
  uint64_t v138;
  apr_hash_t *ht;
  apr_pool_t **v140;
  apr_pool_t *v141;
  apr_array_header_t *arr;
  uint64_t v143;
  id v144;
  uint64_t v145;
  id v146;
  uint64_t v147;
  apr_pool_t **v148;
  unsigned int *v149;
  void *context;
  uint64_t v151;
  id v152;
  uint64_t v153;
  _QWORD *v154;
  unsigned int v155;
  __int16 *v156;
  uint64_t v157;
  uint64_t *v158;
  int *v159;
  uint64_t v160;
  uint64_t v161;
  void *v162;
  id v163;
  apr_array_header_t *v164;
  id v165;
  void *v166;
  __int128 v167;
  void *v168;
  uint64_t v169;
  uint64_t v170;
  apr_pool_t *newpool;
  _OWORD v172[3];
  uint64_t v173;
  _OWORD v174[2];
  __int128 v175;
  uint64_t v176;
  uint8_t buf[16];
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  uint64_t v183;
  __int128 v184;

  v4 = *(void **)(a1 + 22536);
  *(_QWORD *)(a1 + 22536) = 0;

  apr_hash_clear(*(apr_hash_t **)(a1 + 22544));
  v149 = (unsigned int *)a1;
  *(_QWORD *)(a1 + 22552) = *(_QWORD *)(*(_QWORD *)a1 + 136);
  if (a2 && (dword_75313C & 0x10) == 0)
  {
    objc_msgSend(*(id *)(a1 + 24), "releaseBuffer");
    objc_msgSend(*(id *)(a1 + 16), "waitUntilCapacity");
    objc_msgSend((id)g_activityLog, "enterOptimizeRestores");
    v5 = os_signpost_id_generate((os_log_t)g_signpostLog);
    v6 = g_signpostLog;
    v7 = v6;
    spid = v5;
    v136 = v5 - 1;
    if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v6))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_0, v7, OS_SIGNPOST_INTERVAL_BEGIN, v5, "Replayer-1-serial", "PlayCaptureAndRewind", buf, 2u);
    }

    newpool = 0;
    apr_pool_create_ex(&newpool, 0, 0, v8);
    p = newpool;
    v140 = (apr_pool_t **)apr_hash_make(newpool);
    GTMTLReplayController_rewind((uint64_t)v149);
    v9 = *(_QWORD *)(*(_QWORD *)v149 + 120);
    v10 = v149 + 5620;
    for (i = v149[5620]; i < *(_DWORD *)(v9 + 12); *v10 = i)
    {
      v12 = objc_autoreleasePoolPush();
      v13 = *(_QWORD *)(v9 + 24) + ((unint64_t)*v10 << 6);
      v14 = *(_DWORD *)(v13 + 8);
      if (GetFuncEnumConstructorType(v14) == 25)
      {
        CompareCommandBufferRestore((apr_array_header_t **)v149, v13, v140);
        v14 = *(_DWORD *)(v13 + 8);
      }
      if (GetFuncEnumConstructorType(v14) == 51)
        CompareCommandBufferRestore((apr_array_header_t **)v149, v13, v140);
      GTMTLReplayController_updateCommandEncoder((uint64_t)v149, v13);
      GTMTLReplayController_defaultDispatchFunction((uint64_t)v149, v13);
      objc_autoreleasePoolPop(v12);
      i = *v10 + 1;
    }
    RewindWithoutRestore((uint64_t)v149);
    RestoreCommandBuffer((apr_array_header_t **)v149, 0, p, (apr_hash_t *)v140);
    v15 = g_signpostLog;
    v16 = v15;
    if (v136 > 0xFFFFFFFFFFFFFFFDLL)
    {

      v17 = g_signpostLog;
    }
    else
    {
      if (os_signpost_enabled((os_log_t)v15))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_0, v16, OS_SIGNPOST_INTERVAL_END, spid, "Replayer-1-serial", (const char *)&unk_4AAB5F, buf, 2u);
      }

      v17 = g_signpostLog;
      if (os_signpost_enabled((os_log_t)v17))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_0, (os_log_t)v17, OS_SIGNPOST_INTERVAL_BEGIN, spid, "Replayer-1-serial", "SortCommandBufferKeys", buf, 2u);
      }
    }

    v18 = *(_QWORD *)(*(_QWORD *)v149 + 136);
    arr = apr_array_make(p, *(_DWORD *)(v18 + 48), 8);
    *(_QWORD *)(v18 + 24) = 0;
    *(_QWORD *)(v18 + 32) = 0;
    v19 = (apr_hash_index_t *)(v18 + 16);
    *(_QWORD *)(v18 + 16) = v18;
    *(_DWORD *)(v18 + 40) = 0;
    while (1)
    {
      v20 = apr_hash_next(v19);
      if (!v20)
        break;
      v19 = v20;
      v21 = **(_QWORD **)(*((_QWORD *)v20 + 1) + 16);
      *(_QWORD *)apr_array_push(arr) = v21;
    }
    qsort(arr->elts, arr->nelts, arr->elt_size, (int (__cdecl *)(const void *, const void *))CompareU64Pointer);
    nelts = arr->nelts;
    if (nelts)
    {
      elts = arr->elts;
      if (!*(_QWORD *)elts)
      {
        memmove(elts, elts + 8, 8 * (nelts - 1));
        *(_QWORD *)&arr->elts[8 * arr->nelts - 8] = 0;
      }
    }
    v24 = g_signpostLog;
    v25 = v24;
    if (v136 > 0xFFFFFFFFFFFFFFFDLL)
    {

      v26 = g_signpostLog;
    }
    else
    {
      if (os_signpost_enabled((os_log_t)v24))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_0, v25, OS_SIGNPOST_INTERVAL_END, spid, "Replayer-1-serial", (const char *)&unk_4AAB5F, buf, 2u);
      }

      v26 = g_signpostLog;
      if (os_signpost_enabled((os_log_t)v26))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_0, (os_log_t)v26, OS_SIGNPOST_INTERVAL_BEGIN, spid, "Replayer-1-serial", "FitResourcesInOptimizedBuffer", buf, 2u);
      }
    }

    v141 = (apr_pool_t *)**((_QWORD **)v149 + 2819);
    ht = apr_hash_make(p);
    if (arr->nelts >= 1)
    {
      v27 = 0;
      v28 = 0;
      v29 = arr;
      while (1)
      {
        *(_QWORD *)&v174[0] = 0;
        *(_QWORD *)&v174[0] = *(_QWORD *)&v29->elts[8 * v27];
        v30 = *find_entry((uint64_t)v140, v174, 8uLL, 0);
        v31 = v30 ? *(_QWORD *)(v30 + 32) : 0;
        v32 = *find_entry(v18, v174, 8uLL, 0);
        v33 = v32 ? *(const apr_array_header_t **)(v32 + 32) : 0;
        v34 = apr_array_copy(v141, v33);
        qsort(v34->elts, v34->nelts, v34->elt_size, (int (__cdecl *)(const void *, const void *))CompareRequestsBySize);
        v35 = v34->nelts;
        v34->nelts = 0;
        if ((int)v35 >= 1)
          break;
LABEL_97:
        v29 = arr;
        apr_hash_set(ht, &arr->elts[8 * v27], 8, v34);
        v63 = v34->nelts;
        v64 = (apr_array_header_t *)apr_palloc(v141, 0x20uLL);
        v64->pool = v141;
        elt_size = v34->elt_size;
        v64->nelts = v35 - v63;
        v64->nalloc = v35 - v63;
        v64->elt_size = elt_size;
        v64->elts = &v34->elts[v34->elt_size * (uint64_t)v63];
        GroupRequestsByCapacity(v64, v66, v67, v68);
        v69 = (apr_hash_t *)*((_QWORD *)v149 + 2819);
        v70 = apr_palloc(v141, 8uLL);
        *v70 = *(_QWORD *)&v174[0];
        apr_hash_set(v69, v70, 8, v64);
        if (++v27 >= arr->nelts)
          goto LABEL_100;
      }
      v36 = 0;
      while (1)
      {
        v37 = v34->elts;
        v38 = &v37[64 * v36];
        if (*(_QWORD *)v38 != 22)
        {
          if (*(_QWORD *)v38 != 80)
            goto LABEL_96;
          *(_QWORD *)&v180 = 0;
          v178 = 0u;
          v179 = 0u;
          *(_OWORD *)buf = 0u;
          GTMTLSMContext_getTextureDescriptor(*(uint64_t **)(*(_QWORD *)v149 + 40), *(_QWORD *)&v37[64 * v36 + 8], *(_QWORD *)&v37[64 * v36 + 16], (uint64_t)buf);
          if (GetPlanePixelFormat(WORD1(v179), 0))
            goto LABEL_96;
        }
        v39 = *find_entry(v31, v38 + 8, 8uLL, 0);
        if (!v39 || (v40 = *(_QWORD *)(v39 + 32)) == 0)
        {
          v43 = RequestSize((uint64_t)&v37[64 * v36]);
          v41 = *(_QWORD *)v38;
          goto LABEL_62;
        }
        v41 = *(_QWORD *)v38;
        if (*(uint64_t *)v38 <= 56)
        {
          if (v41 != 16)
          {
            v42 = 1;
            if (v41 == 22)
              goto LABEL_57;
            goto LABEL_54;
          }
          v42 = 32;
        }
        else
        {
          v42 = 1;
          if (v41 == 57)
            goto LABEL_57;
          if (v41 != 86)
          {
            if (v41 == 80)
            {
              v42 = *(unsigned __int16 *)&v37[64 * v36 + 60];
              goto LABEL_57;
            }
LABEL_54:
            v42 = 0;
            goto LABEL_57;
          }
          v42 = 256;
        }
LABEL_57:
        v44 = *(unsigned int *)(v40 + 12);
        if ((int)v44 < 1)
        {
          v43 = 0;
        }
        else
        {
          v43 = 0;
          v45 = v42 - 1;
          v46 = -v42;
          v47 = (uint64_t *)(*(_QWORD *)(v40 + 24) + 8);
          do
          {
            v48 = *v47;
            v47 += 2;
            v43 = ((v45 + v43) & v46) + v48;
            --v44;
          }
          while (v44);
        }
LABEL_62:
        v49 = 0;
        if (v41 <= 56)
        {
          if (v41 == 16)
          {
            v51 = v28 + 31;
            v50 = 32;
            goto LABEL_78;
          }
          if (v41 != 22)
            goto LABEL_69;
        }
        else if (v41 != 57)
        {
          if (v41 == 86)
          {
            v51 = v28 + 255;
            v50 = 256;
            goto LABEL_78;
          }
          if (v41 == 80)
          {
            v50 = *(unsigned __int16 *)&v37[64 * v36 + 60];
            v51 = v28 + v50 - 1;
            goto LABEL_78;
          }
LABEL_69:
          v49 = -1;
        }
        v51 = v49 + v28;
        v50 = v41 <= 79 && (v41 == 22 || v41 == 57);
LABEL_78:
        if ((v51 & (unint64_t)-v50) + v43 <= a2)
        {
          v52 = 0;
          if (v41 <= 56)
          {
            if (v41 == 16)
            {
              v54 = v28 + 31;
              v53 = 32;
              goto LABEL_95;
            }
            if (v41 != 22)
              goto LABEL_86;
          }
          else if (v41 != 57)
          {
            if (v41 == 86)
            {
              v54 = v28 + 255;
              v53 = 256;
              goto LABEL_95;
            }
            if (v41 == 80)
            {
              v53 = *(unsigned __int16 *)&v37[64 * v36 + 60];
              v54 = v28 + v53 - 1;
LABEL_95:
              v28 = (v54 & -v53) + v43;
              v55 = v34->nelts;
              v34->nelts = v55 + 1;
              v56 = v34->elts;
              v57 = &v56[64 * v36];
              *(_OWORD *)buf = *(_OWORD *)v57;
              v178 = *((_OWORD *)v57 + 1);
              v179 = *((_OWORD *)v57 + 2);
              v180 = *((_OWORD *)v57 + 3);
              v58 = &v56[64 * v55];
              v59 = *((_OWORD *)v58 + 3);
              v61 = *(_OWORD *)v58;
              v60 = *((_OWORD *)v58 + 1);
              *((_OWORD *)v57 + 2) = *((_OWORD *)v58 + 2);
              *((_OWORD *)v57 + 3) = v59;
              *(_OWORD *)v57 = v61;
              *((_OWORD *)v57 + 1) = v60;
              v62 = &v34->elts[64 * v55];
              *(_OWORD *)v62 = *(_OWORD *)buf;
              *((_OWORD *)v62 + 1) = v178;
              *((_OWORD *)v62 + 2) = v179;
              *((_OWORD *)v62 + 3) = v180;
              goto LABEL_96;
            }
LABEL_86:
            v52 = -1;
          }
          v54 = v52 + v28;
          v53 = v41 <= 79 && (v41 == 22 || v41 == 57);
          goto LABEL_95;
        }
LABEL_96:
        if (++v36 == v35)
          goto LABEL_97;
      }
    }
    v28 = 0;
LABEL_100:
    v71 = g_signpostLog;
    v72 = v71;
    if (v136 >= 0xFFFFFFFFFFFFFFFELL)
    {

      v73 = g_signpostLog;
    }
    else
    {
      if (os_signpost_enabled((os_log_t)v71))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_0, v72, OS_SIGNPOST_INTERVAL_END, spid, "Replayer-1-serial", (const char *)&unk_4AAB5F, buf, 2u);
      }

      v73 = g_signpostLog;
      if (os_signpost_enabled((os_log_t)v73))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_0, (os_log_t)v73, OS_SIGNPOST_INTERVAL_BEGIN, spid, "Replayer-1-serial", "FillDirtyRangesInOptimizedBuffer", buf, 2u);
      }
    }

    v74 = v149;
    v134 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*((id *)v149 + 1), "defaultDevice"));
    v75 = arr;
    if (v28)
    {
      v76 = objc_msgSend(v134, "newBufferWithLength:options:", v28, 288);
      v77 = (void *)*((_QWORD *)v149 + 2817);
      *((_QWORD *)v149 + 2817) = v76;

      v74 = v149;
      v75 = arr;
    }
    if (v75->nelts >= 1)
    {
      v78 = 0;
      v169 = 0;
      while (1)
      {
        v170 = 0;
        v138 = v78;
        v170 = *(_QWORD *)&v75->elts[8 * v78];
        v79 = *find_entry((uint64_t)v140, &v170, 8uLL, 0);
        v145 = v79 ? *(_QWORD *)(v79 + 32) : 0;
        v80 = *find_entry((uint64_t)ht, &v170, 8uLL, 0);
        v81 = v80 ? *(_QWORD *)(v80 + 32) : 0;
        v82 = apr_array_make(v141, *(_DWORD *)(v81 + 12), 48);
        v83 = (apr_hash_t *)*((_QWORD *)v74 + 2818);
        v84 = apr_palloc(v141, 8uLL);
        *v84 = v170;
        v164 = v82;
        apr_hash_set(v83, v84, 8, v82);
        v151 = *(_QWORD *)(v81 + 24);
        v85 = *(unsigned int *)(v81 + 12);
        v152 = *((id *)v74 + 2817);
        v143 = **(_QWORD **)v74;
        v148 = (apr_pool_t **)*((_QWORD *)v74 + 19);
        v144 = *((id *)v74 + 3);
        v147 = v85;
        if ((int)v85 >= 1)
          break;
LABEL_184:

        v74 = v149;
        objc_msgSend(*((id *)v149 + 3), "commitCommandBuffer");
        v78 = v138 + 1;
        v75 = arr;
        if (v138 + 1 >= arr->nelts)
          goto LABEL_185;
      }
      v153 = 0;
      while (1)
      {
        context = objc_autoreleasePoolPush();
        v86 = v151 + (v153 << 6);
        if (*(_QWORD *)v86 == 80)
          break;
        if (*(_QWORD *)v86 == 22)
        {
          if (v145)
          {
            entry = find_entry(v145, (_BYTE *)(v151 + (v153 << 6) + 8), 8uLL, 0);
            if (*entry)
              v88 = *(_QWORD *)(*entry + 32);
            else
              v88 = 0;
            if (*(_DWORD *)(v88 + 12))
            {
              v105 = v151 + (v153 << 6);
              v165 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v144, "bufferWithLength:alignment:", *(_QWORD *)(v105 + 40), 1));
              GTCaptureArchive_fillBuffer(v143, v148, *(char **)(v105 + 24), (char *)objc_msgSend(v165, "contents"), *(_QWORD *)(v105 + 40), 0);
              if (*(int *)(v88 + 12) >= 1)
              {
                v106 = 0;
                v107 = 0;
                do
                {
                  v169 = FillBufferWithBufferBlitOperation((uint64_t)v149, v86, v165, *(_QWORD *)(*(_QWORD *)(v88 + 24) + v106), *(_QWORD *)(*(_QWORD *)(v88 + 24) + v106 + 8), v152, v169, v164);
                  ++v107;
                  v106 += 16;
                }
                while (v107 < *(int *)(v88 + 12));
              }
LABEL_182:

            }
          }
          else
          {
            v99 = (size_t *)(v151 + (v153 << 6));
            v100 = v99[5];
            v99 += 5;
            v166 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v144, "bufferWithLength:alignment:", v100, 1));
            GTCaptureArchive_fillBuffer(v143, v148, *(char **)(v151 + (v153 << 6) + 24), (char *)objc_msgSend(v166, "contents"), *v99, 0);
            v169 = FillBufferWithBufferBlitOperation((uint64_t)v149, v86, v166, 0, *v99, v152, v169, v164);

          }
        }
        apr_pool_clear(*v148);
        objc_autoreleasePoolPop(context);
        if (++v153 == v147)
          goto LABEL_184;
      }
      v165 = v152;
      v89 = **(_QWORD **)v149;
      v90 = (apr_pool_t **)*((_QWORD *)v149 + 19);
      v163 = *((id *)v149 + 3);
      v146 = *((id *)v149 + 1);
      v162 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v146, "defaultDevice"));
      v91 = v151 + (v153 << 6);
      FileWithFilename = (unsigned int *)GTCaptureArchive_getFileWithFilename(v89, *(char **)(v91 + 24));
      v93 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v163, "bufferWithLength:alignment:", *FileWithFilename, 1));
      GTCaptureArchive_fillBuffer(v89, v90, *(char **)(v91 + 24), (char *)objc_msgSend(v93, "contents"), *FileWithFilename, 0);
      v94 = (int *)objc_msgSend(v93, "contents");
      v95 = objc_msgSend(v93, "length");
      if (v94)
        v96 = (unint64_t)v95 >= 0x10;
      else
        v96 = 0;
      if (v96)
      {
        v98 = v149;
        if (*(_QWORD *)v94 == 0x63617074757265)
        {
          if (*((_WORD *)v94 + 4) == 1)
            v97 = v94[3] + 16;
          else
            v97 = v94[3];
        }
        else
        {
          v94 = 0;
          v97 = 0;
        }
      }
      else
      {
        v94 = 0;
        v97 = 0;
        v98 = v149;
      }
      v101 = 0;
      v102 = *(_QWORD *)v86;
      v168 = v93;
      if (*(uint64_t *)v86 <= 56)
      {
        if (v102 == 16)
        {
          v104 = v169 + 31;
          v103 = 32;
          goto LABEL_159;
        }
        if (v102 == 22)
          goto LABEL_142;
      }
      else
      {
        switch(v102)
        {
          case '9':
LABEL_142:
            v104 = v101 + v169;
            if (v102 <= 79)
            {
              if (v102 == 22 || v102 == 57)
              {
                v103 = 1;
                goto LABEL_159;
              }
LABEL_158:
              v103 = 0;
              goto LABEL_159;
            }
            if (v102 != 86)
            {
              if (v102 == 80)
              {
                v103 = *(unsigned __int16 *)(v151 + (v153 << 6) + 60);
                goto LABEL_159;
              }
              goto LABEL_158;
            }
LABEL_156:
            v103 = 256;
            goto LABEL_159;
          case 'V':
            v104 = v169 + 255;
            goto LABEL_156;
          case 'P':
            v103 = *(unsigned __int16 *)(v151 + (v153 << 6) + 60);
            v104 = v169 + v103 - 1;
LABEL_159:
            v176 = 0;
            v175 = 0u;
            memset(v174, 0, sizeof(v174));
            v108 = v151 + (v153 << 6);
            v158 = (uint64_t *)(v108 + 8);
            GTMTLSMContext_getTextureDescriptor(*(uint64_t **)(*(_QWORD *)v98 + 40), *(_QWORD *)(v108 + 8), *(_QWORD *)(v108 + 16), (uint64_t)v174);
            v173 = 0;
            memset(v172, 0, sizeof(v172));
            v161 = WORD1(v175);
            GTMTLPixelFormatGetInfoForDevice((uint64_t)v172, (uint64_t)v162, WORD1(v175));
            *(_QWORD *)&v184 = 0;
            if ((~DWORD2(v172[0]) & 0x60) != 0)
            {
              if ((WORD4(v172[0]) & 0x2000) != 0)
                *(_QWORD *)&v184 = 4;
              v109 = 1;
            }
            else
            {
              v184 = xmmword_4AA550;
              v109 = 2;
            }
            v157 = v109;
            v110 = 0;
            v169 = v104 & -v103;
            v111 = v151 + (v153 << 6);
            v154 = (_QWORD *)(v111 + 48);
            v156 = (__int16 *)(v111 + 32);
            v112 = BYTE1(v176);
            v159 = v94;
            v160 = HIBYTE(v175);
            v113 = (__int128 *)(v94 + 14);
            v155 = BYTE1(v176);
            while (1)
            {
              if (v94 && *((_WORD *)v94 + 5) == 1 && *((_QWORD *)v94 + 2) >= v110)
              {
                v115 = *v113;
              }
              else
              {
                *(_QWORD *)&v114 = *v154;
                *((_QWORD *)&v114 + 1) = HIDWORD(*v154);
                v115 = v114;
              }
              if (v112 < 2)
                break;
              v116 = v115;
              if (v112 != 7)
                goto LABEL_172;
LABEL_173:
              v167 = v115;
              v183 = 0;
              v181 = 0u;
              v182 = 0u;
              v179 = 0u;
              v180 = 0u;
              *(_OWORD *)buf = 0u;
              v178 = 0u;
              v117 = *((_QWORD *)&v184 + v110);
              GTMTLGetTextureLevelInfoForDeviceWithOptions((uint64_t)buf, (uint64_t)v162, v161, *(unsigned __int16 *)(v86 + 42), *(unsigned __int16 *)(v86 + 44), *(unsigned __int16 *)(v86 + 46), v160, 0, v117);
              if ((_QWORD)v167)
                v118 = v167;
              else
                v118 = v182;
              if (*((_QWORD *)&v167 + 1))
                v119 = DWORD2(v167);
              else
                v119 = v118 * v179;
              v120 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v163, "blitCommandEncoder"));
              v121 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v168, "heapBuffer"));
              v122 = (char *)objc_msgSend(v168, "heapLocation");
              v123 = v183;
              objc_msgSend(v120, "copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:", v121, &v122[v97], v165, v169, v183);

              v124 = apr_array_push(v164);
              v125 = *(unsigned __int16 *)(v86 + 42);
              v126 = *(_DWORD *)(v86 + 44);
              v127 = *v158;
              v128 = *(unsigned __int16 *)(v86 + 36);
              v129 = *(_DWORD *)(v86 + 38);
              v130 = *v156;
              v131 = *(_BYTE *)(v86 + 34);
              *v124 = v169;
              v124[1] = 80;
              v124[2] = v118;
              v124[3] = v119;
              v124[4] = v125;
              v124[5] = v126;
              *((_QWORD *)v124 + 3) = v127;
              v124[8] = v128;
              v124[9] = v129;
              *((_WORD *)v124 + 20) = v130;
              *((_BYTE *)v124 + 42) = v131;
              v169 += v123;
              v97 += v123;
              *((_BYTE *)v124 + 43) = v117;
              ++v110;
              v113 += 3;
              v124[11] = 0;
              v94 = v159;
              v112 = v155;
              if (v157 == v110)
              {

                goto LABEL_182;
              }
            }
            v116 = 0;
LABEL_172:
            v115 = v116;
            goto LABEL_173;
        }
      }
      v101 = -1;
      goto LABEL_142;
    }
LABEL_185:
    apr_pool_destroy(p);
    v132 = g_signpostLog;
    v133 = v132;
    if (v136 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v132))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_0, v133, OS_SIGNPOST_INTERVAL_END, spid, "Replayer-1-serial", (const char *)&unk_4AAB5F, buf, 2u);
    }

    objc_msgSend((id)g_activityLog, "leaveActivity");
  }
}

void sub_293D6C(_Unwind_Exception *a1)
{
  objc_msgSend((id)g_activityLog, "leaveActivity");
  _Unwind_Resume(a1);
}

id GTMTLReplayController_rewind(uint64_t a1)
{
  id v2;
  NSObject *v3;
  FILE *v4;
  id v5;
  uint64_t v6;
  uint8_t buf[16];

  if (s_logUsingOsLog)
  {
    v2 = gt_default_log();
    v3 = objc_claimAutoreleasedReturnValue(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_INFO, "Rewinding", buf, 2u);
    }

  }
  else
  {
    v4 = __stdoutp;
    v5 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Rewinding"))));
    fprintf(v4, "%s\n", (const char *)objc_msgSend(v5, "UTF8String"));

  }
  Rewind((_DWORD *)a1);
  return objc_msgSend(*(id *)(a1 + 8), "setLayerClass:", objc_opt_class(DYMetalLayer, v6));
}

id CompareCommandBufferRestore(apr_array_header_t **a1, uint64_t a2, apr_pool_t **a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  objc_msgSend((id)g_activityLog, "enterRestoreCommandBufferAtIndex:", *((unsigned int *)a1 + 5620));
  v9 = *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), *(_QWORD *)&(*a1)->nalloc)+ 1);
  -[apr_array_header_t commitCommandBuffer](a1[3], "commitCommandBuffer");
  RestoreCommandBuffer(a1, v9, *a3, (apr_hash_t *)a3);
  v6 = *find_entry(*(_QWORD *)&(*a1)[4].nalloc, &v9, 8uLL, 0);
  if (v6)
    v7 = *(_QWORD *)(v6 + 32);
  else
    v7 = 0;
  DYMTLIndirectArgumentBufferManager_processCommandBuffer((uint64_t)a1, v7);
  return objc_msgSend((id)g_activityLog, "leaveActivity");
}

void sub_293F6C(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_msgSend(*(id *)(v1 + 56), "leaveActivity");
  _Unwind_Resume(a1);
}

void RewindWithoutRestore(uint64_t a1)
{
  id *v1;
  id v2;
  id v3;
  uint64_t v4;
  id v5;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  id v17;
  void *v18;
  void *v19;
  apr_pool_t *v20;
  uint64_t v21;
  id v22;
  apr_array_header_t *v23;
  apr_array_header_t *v24;
  apr_array_header_t *v25;
  apr_array_header_t *v26;
  uint64_t v27;
  void *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  void *v35;
  char *v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t i;
  _QWORD *v44;
  id v45;
  id v46;
  char *elts;
  char *v48;
  uint64_t nelts;
  apr_pool_t *v50;
  void *v51;
  void *context;
  _QWORD *v53;
  id v54;
  id *v55;
  uint64_t v56;
  void *v57;
  id v58;
  void *v59;
  char *v60;
  uint64_t *v61;
  uint64_t v62;
  void *v63;
  id v64;
  __int128 v65;
  uint64_t v66;
  __int128 v67;
  uint64_t v68;

  v1 = (id *)a1;
  GTMTLReplayController_tileMemoryFree(a1);
  v2 = v1[1];
  v3 = *v1;
  v4 = *((_QWORD *)*v1 + 24);
  v5 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", *(int *)(v4 + 12));
  if (*(int *)(v4 + 12) >= 1)
  {
    v6 = 0;
    do
    {
      v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 24) + 8 * v6) + 8)));
      objc_msgSend(v5, "addObject:", v7);

      ++v6;
    }
    while (v6 < *(int *)(v4 + 12));
  }
  objc_msgSend(v2, "removeResourcesForKeys:", v5);

  if ((dword_75313C & 0x8000) != 0 || (*((_BYTE *)v3 + 272) & 4) != 0)
  {
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1[1], "defaultCommandQueue"));
    objc_msgSend(v8, "finish");

  }
  v9 = *((_QWORD *)v3 + 25);
  if (*(int *)(v9 + 12) >= 1)
  {
    v10 = 0;
    v11 = *((_QWORD *)v3 + 10);
    do
    {
      v12 = *(_QWORD *)(*(_QWORD *)(v9 + 24) + 8 * v10);
      if (v12)
        v12 = *(_QWORD *)(v12 + 8);
      v13 = *((_QWORD *)v3 + 1);
      *(_QWORD *)&v67 = v12;
      v14 = *find_entry(v13, &v67, 8uLL, 0);
      if (v14)
        v15 = *(_QWORD *)(v14 + 32);
      else
        v15 = 0;
      CreateResourceFromStream(v1, v15, v11);
      ++v10;
    }
    while (v10 < *(int *)(v9 + 12));
  }
  if ((GT_SUPPORT_0 & 0x800) != 0 && *(_DWORD *)(*((_QWORD *)v3 + 28) + 12))
  {
    context = objc_autoreleasePoolPush();
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "defaultCommandQueue"));
    v17 = InternalCommandBuffer(v16, CFSTR("MapSparseTextureRegions"));
    v18 = (void *)objc_claimAutoreleasedReturnValue(v17);

    v51 = v18;
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "resourceStateCommandEncoder"));
    v55 = v1;
    v20 = *(apr_pool_t **)v1[19];
    v53 = v3;
    v21 = *((_QWORD *)v3 + 28);
    v22 = v19;
    v54 = v2;
    v58 = v2;
    v23 = apr_array_make(v20, 8, 48);
    v24 = apr_array_make(v20, 8, 48);
    v25 = apr_array_make(v20, 8, 8);
    v50 = v20;
    v26 = apr_array_make(v20, 8, 8);
    v59 = v22;
    v27 = objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "device"));
    v28 = (void *)v27;
    v29 = *(_DWORD *)(v21 + 12);
    if (v29 >= 1)
    {
      v30 = 0;
      v31 = 0;
      v56 = v21;
      v57 = (void *)v27;
      do
      {
        v32 = *(_QWORD *)(v21 + 24) + (v30 << 6);
        v34 = *(_QWORD *)(v32 + 8);
        v33 = (uint64_t *)(v32 + 8);
        if (v34 != v31)
        {
          v61 = v33;
          v62 = v30;
          v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v58, "textureForKey:"));
          v36 = (char *)objc_msgSend(v35, "textureType");
          v37 = (unint64_t)objc_msgSend(v35, "width");
          v38 = (unint64_t)objc_msgSend(v35, "height");
          v39 = (unint64_t)objc_msgSend(v35, "depth");
          v63 = v35;
          v64 = objc_msgSend(v35, "firstMipmapInTail");
          v60 = v36;
          v40 = (uint64_t)objc_msgSend(v35, "arrayLength");
          v41 = 0;
          if ((unint64_t)(v36 - 5) >= 2)
            v42 = v40;
          else
            v42 = 6 * v40;
          do
          {
            if (v42)
            {
              for (i = 0; i != v42; ++i)
              {
                apr_array_push(v24);
                v44 = apr_array_push(v23);
                *v44 = 0;
                v44[1] = 0;
                v44[2] = 0;
                v44[3] = v37;
                v44[4] = v38;
                v44[5] = v39;
                *(_QWORD *)apr_array_push(v25) = v41;
                *(_QWORD *)apr_array_push(v26) = i;
              }
            }
            if (v37 <= 1)
              v37 = 1;
            else
              v37 >>= 1;
            if (v38 <= 1)
              v38 = 1;
            else
              v38 >>= 1;
            if (v39 <= 1)
              v39 = 1;
            else
              v39 >>= 1;
            ++v41;
          }
          while (v41 <= (unint64_t)v64);
          v67 = 0uLL;
          v68 = 0;
          v45 = objc_msgSend(v63, "pixelFormat");
          v46 = objc_msgSend(v63, "sampleCount");
          v28 = v57;
          if (v57)
          {
            objc_msgSend(v57, "sparseTileSizeWithTextureType:pixelFormat:sampleCount:", v60, v45, v46);
          }
          else
          {
            v67 = 0uLL;
            v68 = 0;
          }
          v21 = v56;
          v30 = v62;
          elts = v23->elts;
          v48 = v24->elts;
          nelts = v23->nelts;
          v65 = v67;
          v66 = v68;
          objc_msgSend(v57, "convertSparsePixelRegions:toTileRegions:withTileSize:alignmentMode:numRegions:", elts, v48, &v65, 0, nelts);
          objc_msgSend(v59, "updateTextureMappings:mode:regions:mipLevels:slices:numRegions:", v63, 1, v24->elts, v25->elts, v26->elts, v23->nelts);
          v23->nelts = 0;
          v24->nelts = 0;
          v25->nelts = 0;
          v26->nelts = 0;
          v31 = *v61;

          v29 = *(_DWORD *)(v56 + 12);
        }
        ++v30;
      }
      while (v30 < v29);
    }

    MapSparseTextureRegions(v59, v58, v53[28], v50);
    apr_pool_clear(v50);
    objc_msgSend(v59, "endEncoding");
    GTMTLReplay_commitCommandBuffer(v51);

    objc_autoreleasePoolPop(context);
    v2 = v54;
    v1 = v55;
  }
  v1[2810] = 0;
  bzero(v1 + 20, 0x5720uLL);

}

apr_array_header_t *RestoreCommandBuffer(apr_array_header_t **a1, uint64_t a2, apr_pool_t *pool, apr_hash_t *a4)
{
  apr_hash_t *v8;
  _QWORD *v9;
  apr_array_header_t *result;
  uint64_t v11;
  int v12;
  int v13;
  _QWORD *v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  _QWORD *entry;
  unint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  GTMTLReplayActivityLog *v24;
  GTMTLReplayActivityLog *v25;
  unsigned int *v26;
  signed int v27;
  apr_array_header_t *v28;
  char *elts;
  uint64_t v30;
  void *v31;
  signed int v32;
  apr_array_header_t *v33;
  char *v34;
  uint64_t v35;
  apr_pool_t *v36;
  apr_array_header_t **v37;
  apr_array_header_t *v38;
  apr_hash_index_t *p_nalloc;
  apr_hash_index_t *v40;
  apr_hash_index_t *v41;
  uint64_t v42;
  size_t v43;
  const void *v44;
  void *v45;
  apr_array_header_t *v46;
  apr_pool_t *v47;
  uint64_t v48;
  uint64_t v49;

  v48 = a2;
  v8 = apr_hash_make(pool);
  v9 = apr_palloc(pool, 8uLL);
  *v9 = a2;
  apr_hash_set(a4, v9, 8, v8);
  result = (apr_array_header_t *)find_entry(*(_QWORD *)&(*a1)[4].elt_size, &v48, 8uLL, 0);
  if (result->pool)
  {
    v11 = *((_QWORD *)result->pool + 4);
    if (v11)
    {
      v12 = *(_DWORD *)(v11 + 12);
      if (v12)
      {
        if (v12 >= 1)
        {
          v13 = 0;
          do
          {
            v14 = apr_array_push(a1[2813]);
            *(_DWORD *)v14 = 1;
            v15 = *(_QWORD *)(v11 + 24) + ((uint64_t)v13 << 6);
            v14[1] = v15;
            v16 = *(_DWORD *)(v11 + 12);
            v17 = CountRequestsWithinCapacity(v15, (v16 - v13));
            *((_DWORD *)v14 + 1) = v17;
            v13 += v17;
          }
          while (v13 < v16);
        }
        SignalLoadQueueThreads((intptr_t)a1, a1[2813]->nelts - 1);
        v18 = *(_QWORD *)&(*a1)->elt_size;
        v49 = v48;
        entry = find_entry(v18, &v49, 8uLL, 0);
        v20 = CommandBufferCommitIndex(*(_QWORD *)(*(_QWORD *)(*entry + 32) + 32));
        RestoreVisibleFunctionTablesForFunctionIndex((id *)a1, v20);
        v21 = *(_QWORD *)&(*a1)->elt_size;
        v49 = v48;
        v22 = find_entry(v21, &v49, 8uLL, 0);
        v23 = CommandBufferCommitIndex(*(_QWORD *)(*(_QWORD *)(*v22 + 32) + 32));
        RestoreIntersectionFunctionTablesForFunctionIndex((uint64_t *)a1, v23);
        v24 = [GTMTLReplayActivityLog alloc];
        v25 = -[GTMTLReplayActivityLog initWithLog:](v24, "initWithLog:", g_activityLog);
        v26 = (unsigned int *)(a1 + 2814);
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 + 1, v26));
        v28 = a1[2813];
        if (v27 < v28->nelts)
        {
          elts = v28->elts;
          if (elts)
          {
            v30 = (uint64_t)&elts[16 * v27];
            while (1)
            {
              v31 = objc_autoreleasePoolPush();
              DoLoadJob((uint64_t **)a1, v30, v25, v8);
              do
                v32 = __ldaxr(v26);
              while (__stlxr(v32 + 1, v26));
              v33 = a1[2813];
              if (v32 >= v33->nelts)
                break;
              v34 = v33->elts;
              v30 = (uint64_t)&v34[16 * v32];
              objc_autoreleasePoolPop(v31);
              if (!v34)
                goto LABEL_18;
            }
            objc_autoreleasePoolPop(v31);
          }
        }
LABEL_18:

        result = (apr_array_header_t *)dispatch_group_wait((dispatch_group_t)a1[2816], 0xFFFFFFFFFFFFFFFFLL);
        a1[2813]->nelts = 0;
        if (*((int *)a1 + 5644) >= 1)
        {
          v35 = 0;
          v36 = *(apr_pool_t **)v8;
          do
          {
            v37 = &a1[3 * v35];
            v38 = v37[2825];
            v38->elts = 0;
            v38[1].pool = 0;
            p_nalloc = (apr_hash_index_t *)&v38->nalloc;
            *(_QWORD *)&v38->nalloc = v38;
            v38[1].elt_size = 0;
            while (1)
            {
              v40 = apr_hash_next(p_nalloc);
              v41 = v40;
              if (!v40)
                break;
              v42 = *((_QWORD *)v40 + 1);
              v44 = *(const void **)(v42 + 16);
              v43 = *(_QWORD *)(v42 + 24);
              if (v44)
              {
                v45 = apr_palloc(v36, *(_QWORD *)(v42 + 24));
                memcpy(v45, v44, v43);
                v42 = *((_QWORD *)v41 + 1);
              }
              else
              {
                v45 = 0;
              }
              v46 = apr_array_copy(v36, *(const apr_array_header_t **)(v42 + 32));
              apr_hash_set(v8, v45, v43, v46);
              p_nalloc = v41;
            }
            v47 = v38->pool;
            apr_pool_clear(v38->pool);
            result = (apr_array_header_t *)apr_hash_make(v47);
            v37[2825] = result;
            ++v35;
          }
          while (v35 < *((int *)a1 + 5644));
        }
      }
    }
  }
  return result;
}

uint64_t CompareU64Pointer(_QWORD *a1, _QWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a1 != *a2;
}

uint64_t FillBufferWithBufferBlitOperation(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, apr_array_header_t *a8)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  id v19;
  id v20;
  void *v21;
  void *v22;
  char *v23;
  _DWORD *v24;
  uint64_t v25;
  int v26;

  v13 = 0;
  v14 = *(_QWORD *)a2;
  if (*(uint64_t *)a2 > 56)
  {
    switch(v14)
    {
      case '9':
        goto LABEL_9;
      case 'V':
        v16 = a7 + 255;
        goto LABEL_17;
      case 'P':
        v15 = *(unsigned __int16 *)(a2 + 60);
        v16 = a7 + v15 - 1;
        goto LABEL_20;
    }
    goto LABEL_8;
  }
  if (v14 == 16)
  {
    v16 = a7 + 31;
    v15 = 32;
    goto LABEL_20;
  }
  if (v14 != 22)
LABEL_8:
    v13 = -1;
LABEL_9:
  v16 = v13 + a7;
  if (v14 > 79)
  {
    if (v14 != 86)
    {
      if (v14 == 80)
      {
        v15 = *(unsigned __int16 *)(a2 + 60);
        goto LABEL_20;
      }
LABEL_19:
      v15 = 0;
      goto LABEL_20;
    }
LABEL_17:
    v15 = 256;
    goto LABEL_20;
  }
  v15 = 1;
  if (v14 != 22 && v14 != 57)
    goto LABEL_19;
LABEL_20:
  v17 = v16 & -v15;
  v18 = *(void **)(a1 + 24);
  v19 = a6;
  v20 = a3;
  v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "blitCommandEncoder"));
  v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "heapBuffer"));
  v23 = (char *)objc_msgSend(v20, "heapLocation");

  objc_msgSend(v21, "copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:", v22, &v23[a4], v19, v17, a5);
  v24 = apr_array_push(a8);
  v25 = *(_QWORD *)(a2 + 8);
  v26 = *(_DWORD *)(a2 + 32) + a4;
  *v24 = v17;
  v24[1] = 22;
  *((_QWORD *)v24 + 1) = v25;
  v24[4] = v26;
  v24[5] = a5;
  return v17 + a5;
}

_DWORD *Rewind(_DWORD *result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  GTMTLReplayActivityLog *v4;
  GTMTLReplayActivityLog *v5;
  _QWORD *entry;
  uint64_t v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  signed int v13;
  uint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  apr_pool_t *v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t v33;
  int v34;
  uint64_t i;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;

  if (result[5620])
  {
    v1 = (uint64_t)result;
    objc_msgSend((id)g_activityLog, "enterRewind");
    RewindWithoutRestore(v1);
    v43 = 0;
    v2 = *find_entry(*(_QWORD *)(v1 + 22552), &v43, 8uLL, 0);
    if (v2)
      v3 = *(_QWORD *)(v2 + 32);
    else
      v3 = 0;
    AppendRestoreJobsToLoadQueue(v1, v3);
    SignalLoadQueueThreads(v1, *(_DWORD *)(*(_QWORD *)(v1 + 22504) + 12));
    v4 = [GTMTLReplayActivityLog alloc];
    v5 = -[GTMTLReplayActivityLog initWithLog:](v4, "initWithLog:", g_activityLog);
    entry = find_entry(*(_QWORD *)(v1 + 22544), &v43, 8uLL, 0);
    if (*entry)
    {
      v7 = *(_QWORD *)(*entry + 32);
      if (v7)
        RestoreResourcesFromBuffer((id *)v1, *(void **)(v1 + 22536), *(_QWORD *)(v7 + 24), *(_DWORD *)(v7 + 12), v5);
    }
    RestoreOrderedResourcesFromArchive((id *)v1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v1 + 240) + 24), *(unsigned int *)(*(_QWORD *)(*(_QWORD *)v1 + 240) + 12), v5);
    RestoreVisibleFunctionTablesForFunctionIndex((id *)v1, *(_QWORD *)(*(_QWORD *)v1 + 80) - 1);
    RestoreIntersectionFunctionTablesForFunctionIndex((uint64_t *)v1, *(_QWORD *)(*(_QWORD *)v1 + 80) - 1);
    v8 = (unsigned int *)(v1 + 22512);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 + 1, v8));
    v10 = *(_QWORD *)(v1 + 22504);
    if (v9 >= *(_DWORD *)(v10 + 12))
      v11 = 0;
    else
      v11 = *(_QWORD *)(v10 + 24) + 16 * v9;
    while (v11)
    {
      v12 = objc_autoreleasePoolPush();
      DoLoadJob((uint64_t **)v1, v11, v5, 0);
      do
        v13 = __ldaxr(v8);
      while (__stlxr(v13 + 1, v8));
      v14 = *(_QWORD *)(v1 + 22504);
      if (v13 >= *(_DWORD *)(v14 + 12))
        v11 = 0;
      else
        v11 = *(_QWORD *)(v14 + 24) + 16 * v13;
      objc_autoreleasePoolPop(v12);
    }

    dispatch_group_wait(*(dispatch_group_t *)(v1 + 22528), 0xFFFFFFFFFFFFFFFFLL);
    *(_DWORD *)(*(_QWORD *)(v1 + 22504) + 12) = 0;
    v15 = *(_QWORD **)v1;
    v16 = *(_QWORD *)(*(_QWORD *)v1 + 80);
    v17 = *(_QWORD *)(*(_QWORD *)v1 + 256);
    if (*(int *)(v17 + 12) >= 1)
    {
      v18 = 0;
      do
      {
        v19 = *(_QWORD *)(*(_QWORD *)(v17 + 24) + 8 * v18);
        v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 8), "residencySetForKey:", *(_QWORD *)(v19 + 8)));
        objc_msgSend(v20, "removeAllAllocations");
        v21 = v15[1];
        v44 = *(_QWORD *)(v19 + 8);
        v22 = *find_entry(v21, &v44, 8uLL, 0);
        if (v22)
          v23 = *(_QWORD *)(v22 + 32);
        else
          v23 = 0;
        RestoreResourceFromStream(v1, v23, v16);

        ++v18;
        v17 = v15[32];
      }
      while (v18 < *(int *)(v17 + 12));
    }
    v24 = *(int *)(v15[33] + 12);
    if ((_DWORD)v24)
    {
      v25 = **(apr_pool_t ***)(v1 + 152);
      v26 = apr_palloc(v25, 8 * v24);
      v27 = v26;
      if (v26)
        bzero(v26, 8 * v24);
      if ((int)v24 >= 1)
      {
        v28 = 0;
        v29 = 0;
        v30 = 8 * v24;
        do
        {
          v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 8), "residencySetForKey:", *(_QWORD *)(*(_QWORD *)(v15[33] + 24) + v28)));
          if (v31)
            v27[v29++] = v31;

          v28 += 8;
        }
        while (v30 != v28);
        if (v29)
        {
          v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 8), "defaultCommandQueue"));
          objc_msgSend(v32, "removeResidencySets:count:", v27, v29);

        }
      }
      apr_pool_clear(v25);
    }
    v33 = *(_QWORD *)(v15[5] + 184);
    v34 = *(_DWORD *)(v33 + 12);
    if (v34 >= 1)
    {
      for (i = 0; i < v34; ++i)
      {
        v36 = *(_QWORD *)(*(_QWORD *)(v33 + 24) + 8 * i);
        v37 = *(_QWORD *)(v36 + 16);
        v38 = v15[8];
        if (v38 > v37 || v15[9] + v38 <= v37)
        {
          v40 = v15[1];
          v44 = *(_QWORD *)(v36 + 8);
          v41 = *find_entry(v40, &v44, 8uLL, 0);
          if (v41)
            v42 = *(_QWORD *)(v41 + 32);
          else
            v42 = 0;
          RestoreResourceFromStream(v1, v42, v16);
          v34 = *(_DWORD *)(v33 + 12);
        }
      }
    }
    return objc_msgSend((id)g_activityLog, "leaveActivity");
  }
  return result;
}

void sub_294CC8(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_msgSend(*(id *)(v1 + 56), "leaveActivity");
  _Unwind_Resume(a1);
}

id RestoreResourcesFromBuffer(id *a1, void *a2, uint64_t a3, int a4, void *a5)
{
  id v9;
  id v10;
  os_signpost_id_t v11;
  id v12;
  void *v13;
  NSObject *v14;
  uint64_t v15;
  unsigned __int16 *v16;
  uint64_t v17;
  void *v18;
  int v19;
  void *v20;
  void *v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  id v32;
  void *v33;
  NSObject *v34;
  os_signpost_id_t spid;
  unint64_t v37;
  void *v38;
  id v39;
  id v40;
  uint64_t v41;
  uint64_t v42;
  id v43;
  _QWORD v44[3];
  __int128 buf;
  uint64_t v46;

  v9 = a2;
  v10 = a5;
  v11 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, a1);
  v43 = a1[3];
  v12 = a1[1];
  v13 = g_signpostLog;
  v14 = v13;
  v37 = v11 - 1;
  if (v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v13))
  {
    LODWORD(buf) = 67109120;
    DWORD1(buf) = a4;
    _os_signpost_emit_with_name_impl(&dword_0, v14, OS_SIGNPOST_INTERVAL_BEGIN, v11, "Replayer-2-restore", "RestoreResourcesFromBuffer x%d", (uint8_t *)&buf, 8u);
  }
  spid = v11;
  v38 = v10;

  if (a4 >= 1)
  {
    v15 = 0;
    v16 = (unsigned __int16 *)(a3 + 22);
    v17 = a4;
    v39 = v12;
    v40 = v9;
    while (1)
    {
      v18 = objc_autoreleasePoolPush();
      v19 = *(_DWORD *)(v16 - 9);
      if (v19 == 80)
        break;
      if (v19 == 22)
      {
        v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "bufferForKey:", *(_QWORD *)(v16 - 7)));
        v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v43, "blitCommandEncoder"));
        objc_msgSend(v21, "copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:", v9, *(unsigned int *)(v16 - 11), v20, *(unsigned int *)(v16 - 3), *(unsigned int *)(v16 - 1));

        v22 = *(_DWORD *)(v16 - 1);
LABEL_10:
        v15 += v22;

      }
      objc_autoreleasePoolPop(v18);
      v16 += 24;
      if (!--v17)
        goto LABEL_14;
    }
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "textureForKey:", *(_QWORD *)(v16 + 1)));
    v42 = *(unsigned int *)(v16 - 3);
    v41 = *(v16 - 1);
    v23 = *v16;
    v24 = v15;
    v25 = *(unsigned int *)(v16 + 5);
    v26 = v16[7];
    v27 = v16[8];
    v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v43, "blitCommandEncoder"));
    v29 = v16[9];
    v30 = *((unsigned __int8 *)v16 + 20);
    v31 = *((unsigned __int8 *)v16 + 21);
    v44[2] = v27;
    *(_QWORD *)&buf = v42;
    *((_QWORD *)&buf + 1) = v41;
    v46 = v23;
    v12 = v39;
    v44[0] = v25;
    v44[1] = v26;
    v15 = v24;
    v9 = v40;
    objc_msgSend(v28, "copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:", v29, v30, v44, v31);

    v22 = *(_DWORD *)(v16 - 5) * *v16;
    goto LABEL_10;
  }
  v15 = 0;
LABEL_14:
  v32 = objc_msgSend(v43, "commitCommandBufferWithLog:", v38);
  v33 = g_signpostLog;
  v34 = v33;
  if (v37 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v33))
  {
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = v15;
    _os_signpost_emit_with_name_impl(&dword_0, v34, OS_SIGNPOST_INTERVAL_END, spid, "Replayer-2-restore", "%{xcode:size-in-bytes}zu", (uint8_t *)&buf, 0xCu);
  }

  return v32;
}

void RestoreResourceFromStream(uint64_t a1, uint64_t a2, unint64_t a3)
{
  id v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  id v18;

  v6 = *(id *)(a1 + 8);
  v7 = *(_QWORD *)(a2 + 32);
  v18 = v6;
  v8 = 0;
  if (v7)
  {
    while (1)
    {
      v9 = atomic_load((unsigned int *)(v7 + 4));
      v10 = v8 + (v9 >> 6) - 1;
      if ((int)v10 > 0)
        break;
      v7 = *(_QWORD *)(v7 + 40);
      v8 = v10;
      if (!v7)
      {
        v8 = v10;
        goto LABEL_6;
      }
    }
  }
  v10 = 0;
LABEL_6:
  v11 = v8 | (unint64_t)(v10 << 32);
LABEL_7:
  v12 = v7 + 64;
  while (v7)
  {
    if ((*(_BYTE *)(v12 + ((uint64_t)(HIDWORD(v11) - (int)v11) << 6) + 15) & 8) == 0)
      break;
    v13 = v12 + ((uint64_t)(HIDWORD(v11) - (int)v11) << 6);
    if (*(_QWORD *)v13 >= a3)
      break;
    if (!GetFuncEnumConstructorType(*(_DWORD *)(v13 + 8)))
    {
      v14 = objc_autoreleasePoolPush();
      GTMTLReplayController_defaultDispatchFunction(a1, v13);
      objc_autoreleasePoolPop(v14);
    }
    v15 = atomic_load((unsigned int *)(v7 + 4));
    v16 = v11 + (v15 >> 6);
    v17 = (HIDWORD(v11) + 1);
    v11 = (v17 << 32) | v11;
    if ((_DWORD)v17 == v16 - 1)
    {
      v11 = (v17 << 32) | v17;
      v7 = *(_QWORD *)(v7 + 40);
      goto LABEL_7;
    }
  }

}

uint64_t GTMTLReplayController_restoreCommandBuffer(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  void *v10;
  unint64_t v11;
  _QWORD *v12;
  GTMTLReplayActivityLog *v13;
  GTMTLReplayActivityLog *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  id MTLRasterizationRateMapDescriptor;
  void *v19;
  uint64_t v20;
  _QWORD *entry;
  unint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned int *v28;
  signed int v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  signed int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;

  objc_msgSend((id)g_activityLog, "enterRestoreCommandBufferAtIndex:", *(unsigned int *)(a1 + 22480));
  v42 = *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), *(_QWORD *)(*(_QWORD *)a1 + 16))+ 1);
  v4 = objc_msgSend(*(id *)(a1 + 24), "commitCommandBuffer");
  v5 = *find_entry(*(_QWORD *)(*(_QWORD *)a1 + 184), &v42, 8uLL, 0);
  if (v5)
    v6 = *(_QWORD *)(v5 + 32);
  else
    v6 = 0;
  v7 = *find_entry(*(_QWORD *)(a1 + 22552), &v42, 8uLL, 0);
  if (!v7)
  {
    if (v6)
    {
      v9 = 0;
      v8 = 0;
      goto LABEL_9;
    }
LABEL_16:
    v9 = 1;
    goto LABEL_17;
  }
  v8 = *(_QWORD *)(v7 + 32);
  if (v6)
  {
    v9 = 0;
LABEL_9:
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 8), "defaultCommandQueue"));
    objc_msgSend(v10, "finish");

    goto LABEL_10;
  }
  if (!v8)
    goto LABEL_16;
  v11 = *(unsigned int *)(v8 + 12);
  if ((int)v11 < 1)
  {
    v9 = 1;
    goto LABEL_11;
  }
  v12 = *(_QWORD **)(v8 + 24);
  if (*v12 == 86)
  {
    v9 = 1;
    goto LABEL_9;
  }
  v39 = 0;
  v40 = v12 + 8;
  do
  {
    if (v11 - 1 == v39)
    {
      v9 = 1;
      goto LABEL_10;
    }
    v41 = *v40;
    v40 += 8;
    ++v39;
  }
  while (v41 != 86);
  v9 = 1;
  if (v39 < v11)
    goto LABEL_9;
LABEL_10:
  if (v8)
  {
LABEL_11:
    AppendRestoreJobsToLoadQueue(a1, v8);
    SignalLoadQueueThreads(a1, *(_DWORD *)(*(_QWORD *)(a1 + 22504) + 12));
  }
LABEL_17:
  v13 = [GTMTLReplayActivityLog alloc];
  v14 = -[GTMTLReplayActivityLog initWithLog:](v13, "initWithLog:", g_activityLog);
  if ((v9 & 1) == 0 && *(int *)(v6 + 12) >= 1)
  {
    v15 = 0;
    do
    {
      v16 = *(_QWORD *)(*(_QWORD *)(v6 + 24) + 8 * v15);
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 8), "rasterizationRateMapForKey:", *(_QWORD *)(v16 + 8)));
      MTLRasterizationRateMapDescriptor = MakeMTLRasterizationRateMapDescriptor(*(_QWORD *)(v16 + 48));
      v19 = (void *)objc_claimAutoreleasedReturnValue(MTLRasterizationRateMapDescriptor);
      objc_msgSend(v17, "resetUsingDescriptor:", v19);

      ++v15;
    }
    while (v15 < *(int *)(v6 + 12));
  }
  v20 = *(_QWORD *)(*(_QWORD *)a1 + 8);
  v43 = v42;
  entry = find_entry(v20, &v43, 8uLL, 0);
  v22 = CommandBufferCommitIndex(*(_QWORD *)(*(_QWORD *)(*entry + 32) + 32));
  RestoreVisibleFunctionTablesForFunctionIndex((id *)a1, v22);
  v23 = *(_QWORD *)(*(_QWORD *)a1 + 8);
  v43 = v42;
  v24 = find_entry(v23, &v43, 8uLL, 0);
  v25 = CommandBufferCommitIndex(*(_QWORD *)(*(_QWORD *)(*v24 + 32) + 32));
  RestoreIntersectionFunctionTablesForFunctionIndex((uint64_t *)a1, v25);
  v26 = find_entry(*(_QWORD *)(a1 + 22544), &v42, 8uLL, 0);
  if (*v26)
  {
    v27 = *(_QWORD *)(*v26 + 32);
    if (v27)
      v4 |= RestoreResourcesFromBuffer((id *)a1, *(void **)(a1 + 22536), *(_QWORD *)(v27 + 24), *(_DWORD *)(v27 + 12), v14);
  }
  v28 = (unsigned int *)(a1 + 22512);
  do
    v29 = __ldaxr(v28);
  while (__stlxr(v29 + 1, v28));
  v30 = *(_QWORD *)(a1 + 22504);
  if (v29 >= *(_DWORD *)(v30 + 12))
    v31 = 0;
  else
    v31 = *(_QWORD *)(v30 + 24) + 16 * v29;
  while (v31)
  {
    v32 = objc_autoreleasePoolPush();
    DoLoadJob((uint64_t **)a1, v31, v14, 0);
    do
      v33 = __ldaxr(v28);
    while (__stlxr(v33 + 1, v28));
    v34 = *(_QWORD *)(a1 + 22504);
    if (v33 >= *(_DWORD *)(v34 + 12))
      v31 = 0;
    else
      v31 = *(_QWORD *)(v34 + 24) + 16 * v33;
    objc_autoreleasePoolPop(v32);
  }

  dispatch_group_wait(*(dispatch_group_t *)(a1 + 22528), 0xFFFFFFFFFFFFFFFFLL);
  *(_DWORD *)(*(_QWORD *)(a1 + 22504) + 12) = 0;
  if (byte_75313A)
    sleep(byte_75313A);
  v35 = *find_entry(*(_QWORD *)(*(_QWORD *)a1 + 144), &v42, 8uLL, 0);
  if (v35)
    v36 = *(_QWORD *)(v35 + 32);
  else
    v36 = 0;
  v37 = v4 | DYMTLIndirectArgumentBufferManager_processCommandBuffer(a1, v36);
  objc_msgSend((id)g_activityLog, "leaveActivity");
  return v37;
}

void sub_295500(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_msgSend(*(id *)(v1 + 56), "leaveActivity");
  _Unwind_Resume(a1);
}

uint64_t GTMTLReplayController_init(uint64_t a1)
{
  void *v1;
  void *v2;
  id v3;
  NSObject *v4;
  os_log_t v5;
  void *v6;
  char *v7;
  char **v8;
  uint64_t i;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  void *v18;
  id v19;
  NSObject *v20;
  os_log_t v21;
  void *v22;
  FILE *v23;
  void *v24;
  unsigned __int8 v25;
  os_log_t v26;
  void *v27;
  FILE *v28;
  id v29;
  int v30;
  id v31;
  void *v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  objc_class *v36;
  id v37;
  void *v38;
  id v39;
  uint64_t v40;
  uint64_t j;
  id v42;
  void *v43;
  id v44;
  void *v45;
  _BYTE buf[18];

  if (a1 && !initialized)
  {
    shared_initialized = 1;
    apr_pools_initialized = 1;
    apr_pools_shared_initialized = 1;
    global_pool = a1;
    global_allocator = *(_QWORD *)(a1 + 48);
  }
  qword_753118 = GetEnvDefault("MTLREPLAYER_ABORT_ON_ERROR_CODE", -1);
  qword_753120 = GetEnvDefault("MTLREPLAYER_ABORT_ON_FAILURE_TYPE", 1);
  qword_753128 = GetEnvDefault("MTLREPLAYER_FORCE_PATCHING_TYPE_REPLACE_MASK", 0);
  word_753138 = GetEnvDefault("MTLREPLAYER_SHARED_RESOURCE_POOL_MAX_SIZE", 128);
  v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSProcessInfo processInfo](NSProcessInfo, "processInfo"));
  byte_75313B = GetEnvDefault("MTLREPLAYER_RESTORE_THREAD_COUNT", (uint64_t)objc_msgSend(v1, "activeProcessorCount") - 1);

  byte_75313A = GetEnvDefault("MTLREPLAYER_SLEEP_AFTER_RESTORE", 0);
  dword_75313C = dword_75313C & 0xFFFFFFFE | GetEnvDefault("MTLREPLAYER_VALIDATE_LOAD_ACTIONS", 0) & 1;
  dword_75313C = dword_75313C & 0xFFFFFFFD | (2 * (GetEnvDefault("MTLREPLAYER_FORCE_WAIT_UNTIL_COMPLETED", 0) & 1));
  dword_75313C = dword_75313C & 0xFFFFFFFB | (4
                                            * (GetEnvDefault("MTLREPLAYER_FORCE_BUFFER_STORAGE_MODE_PRIVATE", 0) & 1));
  dword_75313C = dword_75313C & 0xFFFFFFF7 | (8 * (GetEnvDefault("MTLREPLAYER_ENHANCED_COMMAND_BUFFER_ERRORS", 0) & 1));
  dword_75313C = dword_75313C & 0xFFFFFFEF | (16 * (GetEnvDefault("MTLREPLAYER_DISABLE_OPTIMIZE_RESTORES", 0) & 1));
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSProcessInfo processInfo](NSProcessInfo, "processInfo"));
  dword_75313C = dword_75313C & 0xFFFFFFDF | (32
                                            * (GetEnvDefault("METAL_FRAME_DEBUGGER_DISABLE_DISPLAY_ON_DEVICE", objc_msgSend(v2, "isiOSAppOnMac")) & 1));

  dword_75313C = dword_75313C & 0xFFFFFFBF | ((GetEnvDefault("MTLREPLAYER_DISABLE_PATCHING_ARRAYS", 0) & 1) << 6);
  dword_75313C = dword_75313C & 0xFFFFFF7F | ((GetEnvDefault("MTLREPLAYER_PATCH_USING_ALL_RESOURCES", 0) & 1) << 7);
  dword_75313C = dword_75313C & 0xFFFFFEFF | ((GetEnvDefault("MTLREPLAYER_ALLOW_BUFFER_PINNING", 1) & 1) << 8);
  dword_75313C = dword_75313C & 0xFFFEFFFF | ((GetEnvDefault("MTLREPLAYER_BUFFER_PINNING_REQUIRES_AB", 1) & 1) << 16);
  dword_75313C = dword_75313C & 0xFFFFFDFF | ((GetEnvDefault("MTLREPLAYER_ALLOW_PROGRAM_ADDRESS_TABLES", 1) & 1) << 9);
  dword_75313C = dword_75313C & 0xFFFFF7FF | ((GetEnvDefault("MTLREPLAYER_IGNORE_UNUSED_RESOURCE", 0) & 1) << 11);
  dword_75313C = dword_75313C & 0xFFFFFBFF | ((GetEnvDefault("MTLREPLAYER_FORCE_LOAD_UNUSED_RESOURCE", 0) & 1) << 10);
  dword_75313C = dword_75313C & 0xFFFFEFFF | ((GetEnvDefault("MTLREPLAYER_DISABLE_COMMAND_ENCODER_RESUME", 0) & 1) << 12);
  dword_75313C = dword_75313C & 0xFFFFDFFF | ((GetEnvDefault("MTLREPLAYER_DISABLE_HEAP_TEXTURE_COMPRESSION", 0) & 1) << 13);
  dword_75313C = dword_75313C & 0xFFFFBFFF | ((GetEnvDefault("MTLREPLAYER_DISABLE_SHADER_DEBUGGER_DRIVER_COMPILER_OPTIONS", 0) & 1) << 14);
  dword_75313C = dword_75313C & 0xFFFF7FFF | ((GetEnvDefault("MTLREPLAYER_FORCE_FINISH_ON_REWIND", 0) & 1) << 15);
  dword_75313C = dword_75313C & 0xFFFDFFFF | ((GetEnvDefault("MTLREPLAYER_DISABLE_MEMORY_BARRIER_RENDER_TARGETS", 0) & 1) << 17);
  GT_ENV = (uint64_t)getenv("MTLREPLAYER_INSERT_BINARY_ARCHIVES");
  dword_75313C = dword_75313C & 0xFFFBFFFF | ((GetEnvDefault("MTLREPLAYER_FORCE_DEFAULT_HAZARD_TRACKING", 0) & 1) << 18);
  dword_75313C = dword_75313C & 0xFFF7FFFF | ((GetEnvDefault("MTLREPLAYER_ALLOW_OTHER_PLATFORMS", 0) & 1) << 19);
  dword_75313C = dword_75313C & 0xFFEFFFFF | ((GetEnvDefault("MTLREPLAYER_DRAWABLE_RESOURCE_INDEX_WORKAROUND", 0) & 1) << 20);
  dword_75313C = dword_75313C & 0xFFBFFFFF | ((GetEnvDefault("MTLREPLAYER_GPURESOURCEID_SCAN_AND_PATCH", 1) & 1) << 22);
  qword_753130 = GetEnvDefault("MTLREPLAYER_ERROR_FILTERING", -1);
  dword_75313C = dword_75313C & 0xFFDFFFFF | ((GetEnvDefault("MTLREPLAYER_ALLOW_ALIAS_IOSURFACE_BACKED_BUFFERS", 1) & 1) << 21);
  dword_75313C = dword_75313C & 0xFF7FFFFF | ((GetEnvDefault("MTLREPLAYER_LOAD_VALIDATION", 0) & 1) << 23);
  dword_75313C = dword_75313C & 0xFEFFFFFF | ((GetEnvDefault("MTLREPLAYER_LOAD_CAPTURE", 0) & 1) << 24);
  dword_75313C = dword_75313C & 0xFDFFFFFF | ((GetEnvDefault("MTLREPLAYER_LOAD_HUD", 0) & 1) << 25);
  dword_75313C = dword_75313C & 0xFBFFFFFF | ((GetEnvDefault("MTLREPLAYER_STOP_ON_COMMIT_ERROR", 0) & 1) << 26);
  dword_75313C = dword_75313C & 0xF7FFFFFF | ((GetEnvDefault("MTLREPLAYER_REDIRECT_LOGGING_TO_STREAMS", 0) & 1) << 27);
  dword_75313C = dword_75313C & 0xEFFFFFFF | ((GetEnvDefault("MTLREPLAYER_LOCK_PARAM_BUFFER_SIZE_TO_MAX", 1) & 1) << 28);
  if (s_defaultLog == &_os_log_default)
  {
    v5 = os_log_create("com.apple.gputools.MTLReplayController", "");
    v6 = s_defaultLog;
    s_defaultLog = v5;

    v7 = 0;
    s_logs = (uint64_t)malloc_type_calloc(3uLL, 0x20uLL, 0x8004018A671A6uLL);
    s_logCount = 1;
    v8 = &off_725D78;
    for (i = 24; i != 120; i += 32)
    {
      v10 = *v8;
      if (v7 == *(v8 - 1))
      {
        v11 = s_logs;
        v12 = s_logs + i;
        v13 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "com.apple.gputools.MTLReplayController"));
        v14 = *(void **)(v12 - 24);
        *(_QWORD *)(v12 - 24) = v13;

        v15 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v10));
        v16 = *(void **)(v12 - 16);
        *(_QWORD *)(v12 - 16) = v15;

        if (*((_BYTE *)v8 + 8))
        {
          v17 = objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@.%@.enableLog"), *(_QWORD *)(v12 - 24), *(_QWORD *)(v12 - 16)));
          v18 = *(void **)(v12 - 8);
          *(_QWORD *)(v12 - 8) = v17;
        }
        else
        {
          v18 = *(void **)(v12 - 8);
          *(_QWORD *)(v12 - 8) = 0;
        }

        v21 = os_log_create("com.apple.gputools.MTLReplayController", v10);
        v22 = *(void **)(v11 + i);
        *(_QWORD *)(v11 + i) = v21;

        GTCoreLog_enabled(v12 - 24);
      }
      else
      {
        if (s_logUsingOsLog)
        {
          v19 = gt_default_log();
          v20 = objc_claimAutoreleasedReturnValue(v19);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = v10;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = (_DWORD)v7;
            _os_log_error_impl(&dword_0, v20, OS_LOG_TYPE_ERROR, "warning: Invalid tag ID for %s, %d expected. Falling back to OS_LOG_DEFAULT", buf, 0x12u);
          }
        }
        else
        {
          v23 = __stderrp;
          v20 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("warning: Invalid tag ID for %s, %d expected. Falling back to OS_LOG_DEFAULT"), *v8, v7)));
          fprintf(v23, "%s\n", (const char *)-[NSObject UTF8String](v20, "UTF8String"));
        }

        objc_storeStrong((id *)(s_logs + i), &_os_log_default);
      }
      ++v7;
      v8 += 3;
    }
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"));
    v25 = objc_msgSend(v24, "BOOLForKey:", CFSTR("GPUToolsPerfLogging"));

    if ((v25 & 1) != 0)
    {
      v26 = os_log_create("com.apple.gputools.MTLReplayController", "");
      v27 = g_signpostLog;
      g_signpostLog = v26;

    }
  }
  else if (s_logUsingOsLog)
  {
    v3 = gt_default_log();
    v4 = objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "Log already initialized, did you call GTCoreLogInit twice?";
      _os_log_error_impl(&dword_0, v4, OS_LOG_TYPE_ERROR, "warning: %s", buf, 0xCu);
    }

  }
  else
  {
    v28 = __stderrp;
    v29 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("warning: %s"), "Log already initialized, did you call GTCoreLogInit twice?")));
    fprintf(v28, "%s\n", (const char *)objc_msgSend(v29, "UTF8String"));

  }
  v30 = dword_75313C;
  s_logUsingOsLog = (dword_75313C & 0x8000000) == 0;
  if ((dword_75313C & 0x800000) == 0)
  {
    if ((dword_75313C & 0x1000000) == 0)
      goto LABEL_26;
LABEL_39:
    setenv("METAL_CAPTURE_ENABLED", "1", 1);
    if ((dword_75313C & 0x2000000) == 0)
      goto LABEL_28;
    goto LABEL_27;
  }
  setenv("MTL_DEBUG_LAYER", "1", 1);
  v30 = dword_75313C;
  if ((dword_75313C & 0x1000000) != 0)
    goto LABEL_39;
LABEL_26:
  if ((v30 & 0x2000000) != 0)
LABEL_27:
    setenv("MTL_HUD_ENABLED", "1", 1);
LABEL_28:
  setenv("AGX_SUPPORT_D24_S8", "1", 1);
  v31 = -[GTMTLReplayActivityLog init:]([GTMTLReplayActivityLog alloc], "init:", 0);
  v32 = (void *)g_activityLog;
  g_activityLog = (uint64_t)v31;

  *(_QWORD *)buf = 0;
  mach_timebase_info((mach_timebase_info_t)buf);
  LODWORD(v34) = *(_DWORD *)&buf[4];
  LODWORD(v33) = *(_DWORD *)buf;
  *(double *)&time_scale = (double)v33 / (double)v34 * 0.000000001;
  v35 = dword_75313C;
  v36 = NSClassFromString(CFSTR("_MTLCommandBufferDescriptor"));
  if (v36 || (v36 = NSClassFromString(CFSTR("MTLCommandBufferDescriptor"))) != 0)
  {
    v37 = objc_alloc_init(v36);
    v38 = (void *)g_commandBufferDescriptor;
    g_commandBufferDescriptor = (uint64_t)v37;

    objc_msgSend((id)g_commandBufferDescriptor, "setRetainedReferences:", 1);
    objc_msgSend((id)g_commandBufferDescriptor, "setErrorOptions:", (v35 >> 3) & 1);
    v39 = (id)g_commandBufferDescriptor;
    if ((objc_opt_respondsToSelector(v39, "captureProgramAddressTable") & 1) != 0)
      objc_msgSend(v39, "setCaptureProgramAddressTable:", (v35 >> 9) & 1);

  }
  v40 = 0;
  newHandler = (uint64_t)HandleCrashSignal;
  *(_QWORD *)algn_752DF8 = 0;
  do
  {
    oldHandlers[v40] = 0;
    v40 += 2;
  }
  while (v40 != 64);
  for (j = 0; j != 5; ++j)
    sigaction(GTMTLReplay_registerSignalHandlers_signals[j], (const sigaction *)&newHandler, (sigaction *)&oldHandlers[2 * GTMTLReplay_registerSignalHandlers_signals[j]]);
  v42 = objc_alloc_init((Class)NSMutableDictionary);
  v43 = (void *)funcMap;
  funcMap = (uint64_t)v42;

  v44 = objc_alloc_init((Class)NSMutableDictionary);
  v45 = (void *)failureMap;
  failureMap = (uint64_t)v44;

  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  getrlimit(8, (rlimit *)buf);
  *(_QWORD *)buf = 10000;
  setrlimit(8, (const rlimit *)buf);
  return MTLSetReportFailureBlock(&__block_literal_global_3962);
}

void sub_296148(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_2961D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_2962C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_296330(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_2963E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_296478(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t *v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD *v11;
  _QWORD *i;
  unint64_t v13;
  _QWORD *v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  v5 = *(uint64_t **)(a2 + 16);
  if (v5)
  {
    v6 = (_QWORD *)(a1 + 16);
    do
    {
      v7 = v5 + 2;
      v8 = v5[3] ^ (v5[2] << 32);
      v9 = *(_QWORD *)(a1 + 8);
      if (v9)
      {
        v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
        v10.i16[0] = vaddlv_u8(v10);
        if (v10.u32[0] > 1uLL)
        {
          v2 = v5[3] ^ (v5[2] << 32);
          if (v8 >= v9)
            v2 = v8 % v9;
        }
        else
        {
          v2 = (v9 - 1) & v8;
        }
        v11 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v2);
        if (v11)
        {
          for (i = (_QWORD *)*v11; i; i = (_QWORD *)*i)
          {
            v13 = i[1];
            if (v13 == v8)
            {
              if (i[2] == *v7 && i[3] == v5[3])
                goto LABEL_45;
            }
            else
            {
              if (v10.u32[0] > 1uLL)
              {
                if (v13 >= v9)
                  v13 %= v9;
              }
              else
              {
                v13 &= v9 - 1;
              }
              if (v13 != v2)
                break;
            }
          }
        }
      }
      v15 = operator new(0x28uLL);
      *v15 = 0;
      v15[1] = v8;
      *((_OWORD *)v15 + 1) = *(_OWORD *)v7;
      v15[4] = (id)v5[4];
      v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
      v17 = *(float *)(a1 + 32);
      if (!v9 || (float)(v17 * (float)v9) < v16)
      {
        v18 = (v9 & (v9 - 1)) != 0;
        if (v9 < 3)
          v18 = 1;
        v19 = v18 | (2 * v9);
        v20 = vcvtps_u32_f32(v16 / v17);
        if (v19 <= v20)
          v21 = v20;
        else
          v21 = v19;
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v21);
        v9 = *(_QWORD *)(a1 + 8);
        if ((v9 & (v9 - 1)) != 0)
        {
          if (v8 >= v9)
            v2 = v8 % v9;
          else
            v2 = v8;
        }
        else
        {
          v2 = (v9 - 1) & v8;
        }
      }
      v22 = *(_QWORD *)a1;
      v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v2);
      if (v23)
      {
        *v15 = *v23;
      }
      else
      {
        *v15 = *v6;
        *v6 = v15;
        *(_QWORD *)(v22 + 8 * v2) = v6;
        if (!*v15)
          goto LABEL_44;
        v24 = *(_QWORD *)(*v15 + 8);
        if ((v9 & (v9 - 1)) != 0)
        {
          if (v24 >= v9)
            v24 %= v9;
        }
        else
        {
          v24 &= v9 - 1;
        }
        v23 = (_QWORD *)(*(_QWORD *)a1 + 8 * v24);
      }
      *v23 = v15;
LABEL_44:
      ++*(_QWORD *)(a1 + 24);
LABEL_45:
      v5 = (uint64_t *)*v5;
    }
    while (v5);
  }
  return a1;
}

void sub_2966F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t *v5;
  unint64_t *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD *v11;
  _QWORD *i;
  unint64_t v13;
  _QWORD *v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[2];
  char v26;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    v5 = a2;
    v6 = &a2[6 * a3];
    v7 = (_QWORD *)(a1 + 16);
    do
    {
      v8 = *v5;
      v9 = *(_QWORD *)(a1 + 8);
      if (v9)
      {
        v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
        v10.i16[0] = vaddlv_u8(v10);
        if (v10.u32[0] > 1uLL)
        {
          v3 = *v5;
          if (v8 >= v9)
            v3 = v8 % v9;
        }
        else
        {
          v3 = (v9 - 1) & v8;
        }
        v11 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
        if (v11)
        {
          for (i = (_QWORD *)*v11; i; i = (_QWORD *)*i)
          {
            v13 = i[1];
            if (v13 == v8)
            {
              if (i[2] == v8)
                goto LABEL_41;
            }
            else
            {
              if (v10.u32[0] > 1uLL)
              {
                if (v13 >= v9)
                  v13 %= v9;
              }
              else
              {
                v13 &= v9 - 1;
              }
              if (v13 != v3)
                break;
            }
          }
        }
      }
      v14 = operator new(0x40uLL);
      v25[0] = v14;
      v25[1] = a1 + 16;
      v26 = 0;
      *v14 = 0;
      v14[1] = v8;
      v14[2] = v8;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)(v14 + 3), (uint64_t)(v5 + 1));
      v26 = 1;
      v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
      v16 = *(float *)(a1 + 32);
      if (!v9 || (float)(v16 * (float)v9) < v15)
      {
        v17 = (v9 & (v9 - 1)) != 0;
        if (v9 < 3)
          v17 = 1;
        v18 = v17 | (2 * v9);
        v19 = vcvtps_u32_f32(v15 / v16);
        if (v18 <= v19)
          v20 = v19;
        else
          v20 = v18;
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v20);
        v9 = *(_QWORD *)(a1 + 8);
        if ((v9 & (v9 - 1)) != 0)
        {
          if (v8 >= v9)
            v3 = v8 % v9;
          else
            v3 = v8;
        }
        else
        {
          v3 = (v9 - 1) & v8;
        }
      }
      v21 = *(_QWORD *)a1;
      v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
      if (v22)
      {
        *v14 = *v22;
      }
      else
      {
        *v14 = *v7;
        *v7 = v14;
        *(_QWORD *)(v21 + 8 * v3) = v7;
        if (!*v14)
          goto LABEL_40;
        v23 = *(_QWORD *)(*v14 + 8);
        if ((v9 & (v9 - 1)) != 0)
        {
          if (v23 >= v9)
            v23 %= v9;
        }
        else
        {
          v23 &= v9 - 1;
        }
        v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
      }
      *v22 = v14;
LABEL_40:
      v25[0] = 0;
      ++*(_QWORD *)(a1 + 24);
      std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,void *>,std::__hash_node_destructor<std::equal_to<FunctionHandleKey><void *>>>::reset[abi:nn180100]((uint64_t)v25);
LABEL_41:
      v5 += 6;
    }
    while (v5 != v6);
  }
  return a1;
}

void sub_296974(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,void *>,std::__hash_node_destructor<std::equal_to<FunctionHandleKey><void *>>>::reset[abi:nn180100]((uint64_t)va);
  std::__hash_table<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,std::__unordered_map_hasher<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,std::hash,true>,std::equal_to<FunctionHandleKey><std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table(uint64_t a1)
{
  id *v2;
  id *v3;
  void *v4;

  v2 = *(id **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (id *)*v2;

      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table(uint64_t a1)
{
  id *v2;
  id *v3;
  void *v4;

  v2 = *(id **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (id *)*v2;

      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

void GTMTLReplayAccessTracking::~GTMTLReplayAccessTracking(id *this)
{

  std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)(this + 25));
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)(this + 20));
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)(this + 15));
  std::__hash_table<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,std::__unordered_map_hasher<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,std::hash,true>,std::equal_to<FunctionHandleKey><std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>>::~__hash_table((uint64_t)(this + 10));
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)(this + 5));
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)this);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,std::__unordered_map_hasher<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,std::hash,true>,std::equal_to<FunctionHandleKey><std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)(v2 + 3));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

BOOL InstrumentRenderSubCommand(uint64_t a1, unint64_t *a2, unint64_t a3, _QWORD *a4, uint64_t *a5, _QWORD *a6, uint64_t a7, apr_pool_t *a8)
{
  unint64_t v8;
  _BOOL8 v11;
  uint64_t v18;
  id v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  void *v23;
  void *v24;
  uint64_t v25;
  _QWORD *Object;
  _QWORD *v27;
  id v28;
  void *v29;
  void *v30;
  int v31;
  id v33;
  void *v34;
  _BYTE __dst[11096];
  _BYTE v36[40];
  uint64_t v37;

  v8 = a6[1];
  if (v8 <= a3 && a6[2] + v8 >= a3)
  {
    v18 = *(_QWORD *)a1;
    v19 = *(id *)(a1 + 8);
    GTMTLReplayController_debugSubCommandResume((unsigned int *)a1, *(_DWORD *)a2 - *(_DWORD *)(v18 + 80) + 1, a3 + 1);
    v20 = a6[3];
    if (v20)
    {
      v21 = v20 + a4[13] * a3;
      v22 = *(_QWORD *)(v21 + a4[1]);
      if (v22 <= 8)
      {
        if (((1 << v22) & 0x116) != 0)
          goto LABEL_11;
        if (!v22)
        {
          v11 = 1;
LABEL_30:

          return v11;
        }
      }
      if (v22 == 256 || v22 == 128)
      {
LABEL_11:
        v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "renderCommandEncoderForKey:", *(_QWORD *)(a1 + 11320)));
        v24 = v23;
        if (v23)
        {
          objc_msgSend(v23, "useResource:usage:", *(_QWORD *)(a7 + 240), 3);
          if (*(_BYTE *)(*a4 + 11))
          {
            v25 = *(_QWORD *)(a1 + 19912);
            if (v25)
              goto LABEL_14;
          }
          else
          {
            v25 = GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier(a5[3], *(_QWORD *)(v21 + a4[2]));
            if (v25)
            {
LABEL_14:
              v34 = v19;
              Object = GTMTLSMContext_getObject(**(_QWORD **)(v18 + 40), v25, *a2);
              if (!Object)
              {
                v31 = 1;
LABEL_28:
                v19 = v34;
                goto LABEL_29;
              }
              v27 = Object;
              v28 = ObtainTracingRenderPipelineState(*(uint64_t **)(v18 + 40), v34, Object, a7, *a2, a8);
              v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
              if (!v29)
              {
                v31 = 1;
LABEL_27:

                goto LABEL_28;
              }
              v33 = v29;
              ReplaceFunctionTablesWithInstrumented((uint64_t)v36, a1, a7, *a2, v27, a5, a8);
              std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v37);
              std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v36);
              if (*(_BYTE *)(*a4 + 10))
              {
                objc_msgSend(v24, "setRenderPipelineState:", v33);
                v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v34, "executeIndirectCommandBufferMap"));
                DYMTLDrawRenderCommandEncoder(v24, (uint64_t)a4, v21, (uint64_t)a5, v30);
              }
              else
              {
                memcpy(__dst, (const void *)(a1 + 11368), sizeof(__dst));
                if (!GTMTLSMRenderCommandEncoder_loadIndirectCommand((uint64_t)__dst, a4, v21, a5))
                {
                  v31 = 1;
                  goto LABEL_26;
                }
                GTMTLReplayController_restoreRenderCommandEncoder(v24, a1 + 11368, (uint64_t)__dst, v34);
                objc_msgSend(v24, "setRenderPipelineState:", v33);
                v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v34, "executeIndirectCommandBufferMap"));
                DYMTLDrawRenderCommandEncoder(v24, (uint64_t)a4, v21, (uint64_t)a5, v30);
              }

              v31 = 2;
LABEL_26:
              v29 = v33;
              goto LABEL_27;
            }
          }
        }
        v31 = 1;
LABEL_29:

        v11 = v31 == 2;
        goto LABEL_30;
      }
    }
    v11 = 0;
    goto LABEL_30;
  }
  return 0;
}

void sub_296DEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

id ObtainTracingRenderPipelineState(uint64_t *a1, void *a2, _QWORD *a3, uint64_t a4, unint64_t a5, apr_pool_t *a6)
{
  id v11;
  void *v12;
  id v13;
  uint64_t v14;
  unint64_t v15;
  BOOL v16;
  uint64_t v17;
  int v18;
  const void *v19;
  uint64_t (*v20)(void);
  void *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  id v28;
  void *v29;
  id v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  id v34;
  uint64_t v35;
  void *v36;
  id MTLTileRenderPipelineDescriptor;
  void *v38;
  id v39;
  void *v40;
  id v41;
  id v42;
  uint64_t Object;
  uint64_t v45;
  uint64_t (*v46)(void);
  void *v47;
  uint64_t v48;
  int v49;
  void *v50;
  id v51;
  void *v52;
  id v53;
  void *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  id v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  void *v63;
  id v64;
  void *v65;
  id v66;
  unsigned int v67;
  uint64_t v68;
  id v69;
  void *v70;
  unsigned int v71;
  void *v72;
  unsigned int v73;
  id *v74;
  int v75;
  uint64_t **v76;
  unint64_t v77;
  uint64_t v78;
  void *v79;
  id v80;
  id v81;
  id v82;
  id v83;
  void *v84;
  id v85;
  id v86;
  unsigned int v87;
  uint64_t v88;
  unsigned int v89;
  void *v90;
  void *v91;
  void *v92;
  void *v93;
  uint64_t v94;
  id v95;
  id v96;
  id v97;
  id v98;
  id v99;
  id v100;
  id v101;
  id v102;
  id v103;
  id v104;
  unint64_t v105;
  id v106;
  id v107;
  id v108;
  id v109;
  id v110;
  id v111;
  int v112;
  uint64_t *v113[109];
  _BYTE v114[192];
  _BYTE v115[112];
  uint64_t v116;
  uint64_t v117;
  unint64_t v118[2];

  v11 = a2;
  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "defaultDevice"));
  if (a3[11])
    goto LABEL_2;
  v118[0] = a3[1];
  v13 = (id)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>((uint64_t *)(a4 + 40), v118[0], v118)[3];
  if (v13)
    goto LABEL_33;
  v14 = *(_QWORD *)(a4 + 248);
  v15 = (unint64_t)(v14 == 2) << 31;
  v16 = v14 == 1;
  v17 = 0x40000000;
  if (!v16)
    v17 = v15;
  v94 = v17;
  v18 = GTMTLSMRenderPipelineState_renderPipelineDescriptorType(a1, a3);
  v112 = v18;
  switch(v18)
  {
    case 3:
      v19 = (const void *)a3[9];
      if (!v19)
        goto LABEL_16;
      memcpy(v113, v19, 0x200uLL);
      break;
    case 2:
      GTMTLSMRenderPipelineState_tilePipelineDescriptor(a1, a3, v113, a6);
      break;
    case 1:
      GTMTLSMRenderPipelineState_renderPipelineDescriptor(a1, a3, (uint64_t)v113, a6);
      break;
    default:
      goto LABEL_30;
  }
  if (v112 == 1)
  {
    Object = GTMTLSMContext_lastObject(*a1, v117, a5);
    if (!Object)
      goto LABEL_2;
    v45 = Object;
    if (*(_BYTE *)(Object + 132))
      goto LABEL_2;
    v46 = MakeMTLRenderPipelineDescriptor;
    v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "renderPipelineDescriptorMap"));
    v48 = ((uint64_t (*)(uint64_t **, void *))v46)(v113, v47);
    v93 = (void *)objc_claimAutoreleasedReturnValue(v48);

    v49 = *(_DWORD *)(a4 + 256);
    if (v49 == 2)
    {
      if (!v116)
        goto LABEL_78;
      v78 = GTMTLSMContext_lastObject(*a1, v116, a5);
      v30 = (id)v78;
      if (!v78)
      {
LABEL_80:

        goto LABEL_2;
      }
      v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "libraryForKey:", *(_QWORD *)(v78 + 40)));
      v79 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "functionMap"));
      v110 = 0;
      v80 = ObtainTracingFunction(v12, v92, a4, (uint64_t)v30, v79, (uint64_t)&v110);
      v52 = (void *)objc_claimAutoreleasedReturnValue(v80);
      v30 = v110;

      if (!v52)
        goto LABEL_79;
      objc_msgSend(v93, "setFragmentFunction:", v52);
      v81 = ObtainTracingLinkedFunctions((const GTMTLSMContext *)a1, v11, (GTMTLReplayAccessTracking *)a4, (uint64_t)v114, a5);
      v54 = (void *)objc_claimAutoreleasedReturnValue(v81);
      objc_msgSend(v93, "setFragmentLinkedFunctions:", v54);
    }
    else
    {
      if (v49 != 1)
      {
        v30 = 0;
LABEL_82:
        if (!SupportsGlobalRelocation(v12, a4))
          goto LABEL_80;
        v109 = v30;
        v82 = objc_msgSend(v12, "newRenderPipelineStateWithDescriptor:options:reflection:error:", v93, v94, 0, &v109);
        v83 = v109;

        v84 = v82;
        if (SupportsGlobalRelocation(v12, a4))
        {
          v108 = v83;
          v85 = objc_msgSend(v12, "newRenderPipelineStateWithDescriptor:options:reflection:error:", v93, v94, 0, &v108);
          v42 = v108;
          v13 = v85;
LABEL_94:

          v65 = v84;
          goto LABEL_65;
        }
        v106 = v83;
        v107 = 0;
        v13 = objc_msgSend(v12, "newRenderPipelineStateWithDescriptor:options:reflection:error:", v93, v94 | 1, &v107, &v106);
        v86 = v107;
        v42 = v106;

        v87 = *(_DWORD *)(a4 + 256);
        if (v87 == 2)
        {
          v88 = objc_claimAutoreleasedReturnValue(objc_msgSend(v86, "fragmentBindings"));
        }
        else
        {
          if (v87 != 1)
          {
            v83 = 0;
            goto LABEL_93;
          }
          v88 = objc_claimAutoreleasedReturnValue(objc_msgSend(v86, "vertexBindings"));
        }
        v83 = (id)v88;
        v87 = *(_DWORD *)(a4 + 256);
LABEL_93:
        v89 = TraceBufferBindingIndex(v83, v87);
        v105 = a3[1];
        *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(a4, v105, &v105)+ 6) = v89;
        v84 = v86;
        goto LABEL_94;
      }
      v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "libraryForKey:", *(_QWORD *)(v45 + 40)));
      v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "functionMap"));
      v111 = 0;
      v51 = ObtainTracingFunction(v12, v92, a4, v45, v50, (uint64_t)&v111);
      v52 = (void *)objc_claimAutoreleasedReturnValue(v51);
      v30 = v111;

      if (!v52)
        goto LABEL_79;
      objc_msgSend(v93, "setVertexFunction:", v52);
      v53 = ObtainTracingLinkedFunctions((const GTMTLSMContext *)a1, v11, (GTMTLReplayAccessTracking *)a4, (uint64_t)v115, a5);
      v54 = (void *)objc_claimAutoreleasedReturnValue(v53);
      objc_msgSend(v93, "setVertexLinkedFunctions:", v54);
    }

    goto LABEL_82;
  }
  if (v112 != 2)
  {
    if (v112 == 3)
    {
LABEL_16:
      v20 = MakeMTLMeshRenderPipelineDescriptor;
      v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "renderPipelineDescriptorMap"));
      v22 = ((uint64_t (*)(uint64_t **, void *))v20)(v113, v21);
      v93 = (void *)objc_claimAutoreleasedReturnValue(v22);

      v23 = *(_DWORD *)(a4 + 256);
      switch(v23)
      {
        case 2:
          v55 = *(_QWORD *)(a3[9] + 344);
          if (v55)
          {
            v56 = GTMTLSMContext_lastObject(*a1, v55, a5);
            if (v56)
            {
              v57 = v56;
              v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "libraryForKey:", *(_QWORD *)(v56 + 40)));
              v58 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "functionMap"));
              v98 = 0;
              v59 = ObtainTracingFunction(v12, v92, a4, v57, v58, (uint64_t)&v98);
              v29 = (void *)objc_claimAutoreleasedReturnValue(v59);
              v30 = v98;

              if (v29)
              {
                objc_msgSend(v93, "setFragmentFunction:", v29);
                goto LABEL_48;
              }
              goto LABEL_79;
            }
          }
          break;
        case 32:
          v60 = *(_QWORD *)(a3[9] + 360);
          if (v60)
          {
            v61 = GTMTLSMContext_lastObject(*a1, v60, a5);
            if (v61)
            {
              v62 = v61;
              v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "libraryForKey:", *(_QWORD *)(v61 + 40)));
              v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "functionMap"));
              v99 = 0;
              v64 = ObtainTracingFunction(v12, v92, a4, v62, v63, (uint64_t)&v99);
              v29 = (void *)objc_claimAutoreleasedReturnValue(v64);
              v30 = v99;

              if (v29)
              {
                objc_msgSend(v93, "setMeshFunction:", v29);
                goto LABEL_48;
              }
              goto LABEL_79;
            }
          }
          break;
        case 16:
          v24 = *(_QWORD *)(a3[9] + 368);
          if (v24)
          {
            v25 = GTMTLSMContext_lastObject(*a1, v24, a5);
            if (v25)
            {
              v26 = v25;
              v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "libraryForKey:", *(_QWORD *)(v25 + 40)));
              v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "functionMap"));
              v100 = 0;
              v28 = ObtainTracingFunction(v12, v92, a4, v26, v27, (uint64_t)&v100);
              v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
              v30 = v100;

              if (v29)
              {
                objc_msgSend(v93, "setObjectFunction:", v29);
LABEL_48:

                v65 = v30;
                goto LABEL_50;
              }
              goto LABEL_79;
            }
          }
          break;
        default:
          v65 = 0;
LABEL_50:
          if (SupportsGlobalRelocation(v12, a4))
          {
            v97 = v65;
            v13 = objc_msgSend(v12, "newRenderPipelineStateWithMeshDescriptor:options:reflection:error:", v93, v94, 0, &v97);
            v42 = v97;
            goto LABEL_65;
          }
          if ((objc_opt_respondsToSelector(v93, "setGpuCompilerSPIOptions:") & 1) != 0)
            objc_msgSend(v93, "setGpuCompilerSPIOptions:", &off_739220);
          v95 = v65;
          v96 = 0;
          v13 = objc_msgSend(v12, "newRenderPipelineStateWithMeshDescriptor:options:reflection:error:", v93, v94 | 1, &v96, &v95);
          v66 = v96;
          v42 = v95;

          v67 = *(_DWORD *)(a4 + 256);
          switch(v67)
          {
            case 2u:
              v68 = objc_claimAutoreleasedReturnValue(objc_msgSend(v66, "fragmentBindings"));
              break;
            case 0x20u:
              v68 = objc_claimAutoreleasedReturnValue(objc_msgSend(v66, "meshBindings"));
              break;
            case 0x10u:
              v68 = objc_claimAutoreleasedReturnValue(objc_msgSend(v66, "objectBindings"));
              break;
            default:
              v72 = 0;
              goto LABEL_64;
          }
          v72 = (void *)v68;
          v67 = *(_DWORD *)(a4 + 256);
LABEL_64:
          v73 = TraceBufferBindingIndex(v72, v67);
          v105 = a3[1];
          *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(a4, v105, &v105)+ 6) = v73;

          v65 = v66;
          goto LABEL_65;
      }
LABEL_78:
      v30 = 0;
      goto LABEL_80;
    }
LABEL_30:
    v42 = 0;
    goto LABEL_31;
  }
  if (*(_DWORD *)(a4 + 256) != 4)
    goto LABEL_30;
  v31 = GTMTLSMContext_lastObject(*a1, (uint64_t)v113[15], a5);
  if (v31)
  {
    v32 = v31;
    v93 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "renderPipelineStateForKey:", a3[1]));
    v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "libraryForKey:", *(_QWORD *)(v32 + 40)));
    v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "functionMap"));
    v104 = 0;
    v34 = ObtainTracingFunction(v12, v92, a4, v32, v33, (uint64_t)&v104);
    v35 = objc_claimAutoreleasedReturnValue(v34);
    v30 = v104;

    v90 = (void *)v35;
    if (v35)
    {
      v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "renderPipelineDescriptorMap"));
      MTLTileRenderPipelineDescriptor = MakeMTLTileRenderPipelineDescriptor((uint64_t)v113, v36);
      v38 = (void *)objc_claimAutoreleasedReturnValue(MTLTileRenderPipelineDescriptor);

      v91 = v38;
      objc_msgSend(v38, "setTileFunction:", v90);
      v39 = ObtainTracingLinkedFunctions((const GTMTLSMContext *)a1, v11, (GTMTLReplayAccessTracking *)a4, (uint64_t)v113, a5);
      v40 = (void *)objc_claimAutoreleasedReturnValue(v39);
      objc_msgSend(v38, "setLinkedFunctions:", v40);

      if (v93)
        objc_msgSend(v38, "setMaxTotalThreadsPerThreadgroup:", objc_msgSend(v93, "maxTotalThreadsPerThreadgroup"));
      if (SupportsGlobalRelocation(v12, a4))
      {
        v103 = v30;
        v13 = objc_msgSend(v12, "newRenderPipelineStateWithTileDescriptor:options:reflection:error:", v38, v94, 0, &v103);
        v41 = v103;
      }
      else
      {
        v101 = v30;
        v102 = 0;
        v13 = objc_msgSend(v12, "newRenderPipelineStateWithTileDescriptor:options:reflection:error:", v38, v94 | 1, &v102, &v101);
        v69 = v102;
        v41 = v101;

        v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v69, "tileBindings"));
        v71 = TraceBufferBindingIndex(v70, 4u);

        v105 = a3[1];
        *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(a4, v105, &v105)+ 6) = v71;
        v30 = v69;
      }

      v42 = v41;
      v65 = v92;
LABEL_65:

      if (v13)
      {
        v74 = (id *)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>((uint64_t *)(a4 + 40), v118[0], v118);
        objc_storeStrong(v74 + 3, v13);
        if (v112 == 2)
        {
          if (*(_DWORD *)(a4 + 256) == 4)
          {
            v76 = v113;
            v77 = 4;
            goto LABEL_86;
          }
        }
        else if (v112 == 1)
        {
          v75 = *(_DWORD *)(a4 + 256);
          if (v75 == 2)
          {
            v76 = (uint64_t **)v114;
            v77 = 2;
            goto LABEL_86;
          }
          if (v75 == 1)
          {
            v76 = (uint64_t **)v115;
            v77 = 1;
LABEL_86:
            CreateRenderFunctionHandles((GTMTLReplayAccessTracking *)a4, a3[1], (uint64_t)v76, v77);
          }
        }
LABEL_32:

        goto LABEL_33;
      }
LABEL_31:
      v13 = 0;
      GTMTLReplay_handleNSError(v42);
      goto LABEL_32;
    }
LABEL_79:

    goto LABEL_80;
  }
LABEL_2:
  v13 = 0;
LABEL_33:

  return v13;
}

void sub_2978CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void ReplaceFunctionTablesWithInstrumented(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, _QWORD *a5, uint64_t *a6, apr_pool_t *p)
{
  uint64_t v11;
  apr_array_header_t *v12;
  apr_array_header_t *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  int v19;
  uint64_t v21;
  unsigned __int8 v22;
  unint64_t v23;
  int v24;
  uint64_t v25;
  id v26;
  unint64_t v27;
  _QWORD *v28;
  id v29;
  id v30;
  _QWORD *v31;
  uint64_t *v32;
  _QWORD *Object;
  _QWORD *v34;
  id v35;
  id v36;
  id *v37;
  uint64_t i;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  int v43;
  uint64_t v45;
  unsigned __int8 v46;
  unint64_t v47;
  int v48;
  uint64_t v49;
  id v50;
  id v51;
  uint64_t v52;
  unint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  id v56;
  _QWORD *v57;
  _QWORD *v58;
  uint64_t *v59;
  _QWORD *v60;
  uint64_t v61;
  _QWORD *v62;
  _QWORD *v63;
  uint64_t *v64;
  id *v65;
  uint64_t *v66;
  void *v67;
  id v68;
  uint64_t *v69;
  id v71;
  void *v72;
  uint64_t v73;
  apr_pool_t *pa;
  unint64_t v76;
  _BYTE v78[40];
  _QWORD v79[5];
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;

  v11 = *(_QWORD *)a2;
  v12 = apr_array_make(p, 5, 8);
  pa = p;
  v13 = apr_array_make(p, 5, 8);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v11 + 40) + 56), a4, v12);
  v76 = a4;
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v11 + 40) + 64), a4, v13);
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_OWORD *)(a1 + 40) = 0u;
  v69 = (uint64_t *)(a1 + 40);
  *(_OWORD *)(a1 + 56) = 0u;
  v73 = a1;
  *(_DWORD *)(a1 + 72) = 1065353216;
  if (v12->nelts >= 1)
  {
    v14 = 0;
    while (1)
    {
      v15 = *(_QWORD *)&v12->elts[8 * v14];
      if (v15)
      {
        v16 = *(_QWORD *)(v15 + 16);
        v17 = *(_QWORD *)(v11 + 64);
        if (v17 > v16 || *(_QWORD *)(v11 + 72) + v17 <= v16)
        {
          v19 = *(_DWORD *)(a3 + 256);
          if (!*(_QWORD *)(v15 + 120) || v19 == 8)
          {
            v21 = *(_QWORD *)(v15 + 128);
            if (!v21)
              break;
            HIDWORD(v23) = *(unsigned __int8 *)(v15 + 168);
            LODWORD(v23) = (HIDWORD(v23) << 24) - 0x2000000;
            v22 = v23 >> 25;
            v24 = v22 > 7u ? 1 : dword_4A87C8[v22];
            if (v24 == v19)
              break;
          }
        }
      }
LABEL_46:
      if (++v14 >= v12->nelts)
        goto LABEL_47;
    }
    v25 = a5[1];
    if (v21 != v25)
    {
      v32 = *(uint64_t **)(v11 + 40);
      Object = a5;
      while (*(_QWORD *)(v15 + 120) != v25)
      {
        if (*(_DWORD *)Object == 29)
        {
          Object = GTMTLSMContext_getObject(*v32, Object[5], Object[2]);
          if (!Object || *(_DWORD *)Object != 29)
            goto LABEL_46;
        }
        else
        {
          if (*(_DWORD *)Object != 71)
            goto LABEL_46;
          Object = GTMTLSMContext_getObject(*v32, Object[5], Object[2]);
          if (!Object || *(_DWORD *)Object != 71)
            goto LABEL_46;
        }
        v25 = Object[1];
        if (*(_QWORD *)(v15 + 128) == v25)
          break;
      }
    }
    v71 = *(id *)(a2 + 8);
    v90 = 0u;
    v91 = 0u;
    v88 = 0u;
    v89 = 0u;
    v86 = 0u;
    v87 = 0u;
    v84 = 0u;
    v85 = 0u;
    v82 = 0u;
    v83 = 0u;
    v80 = 0u;
    v81 = 0u;
    GetVisibleFunctionTableState((uint64_t)&v80, v11, v15, v76, pa);
    v26 = objc_alloc_init((Class)MTLVisibleFunctionTableDescriptor);
    objc_msgSend(v26, "setFunctionCount:", **(_QWORD **)(v15 + 104));
    objc_msgSend(v26, "setResourceIndex:", *(_QWORD *)(*(_QWORD *)(v15 + 104) + 8));
    objc_msgSend(v26, "setForceResourceIndex:", 1);
    if (*(_QWORD *)(v15 + 128))
    {
      v27 = *(unsigned __int8 *)(v15 + 168);
      v28 = std::unordered_map<unsigned long long,-[GTShaderProfilerHelper _calculatePerSampleActiveShaders:withShaderProfilerResult:forWorkloadInfo:]::EncoderRangeInfo>::find[abi:nn180100](*(_QWORD *)(a3 + 40), *(_QWORD *)(a3 + 48), a5[1]);
      if (v28)
      {
        v29 = (id)v28[3];
        if (v29)
        {
          v67 = v29;
          v30 = objc_msgSend(v29, "newVisibleFunctionTableWithDescriptor:stage:", v26, v27);
          if (v30)
          {
            v31 = std::unordered_map<unsigned long long,-[GTShaderProfilerHelper _calculatePerSampleActiveShaders:withShaderProfilerResult:forWorkloadInfo:]::EncoderRangeInfo>::find[abi:nn180100](*(_QWORD *)(a3 + 80), *(_QWORD *)(a3 + 88), v27);
            if (!v31)
              abort();
            SetupInstrumentedFunctionTable(v30, *(uint64_t **)(v11 + 40), (uint64_t)(v31 + 3), (uint64_t)&v80, a5[1], v76);
          }
LABEL_41:

LABEL_43:
          if (v30)
          {
            *(_QWORD *)&v80 = *(_QWORD *)(v15 + 8);
            v37 = (id *)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::piecewise_construct_t const&<>>(v73, v80, &v80);
            objc_storeStrong(v37 + 3, v30);
            objc_msgSend(*(id *)(a2 + 8), "setVisibleFunctionTable:forKey:", v30, *(_QWORD *)(v15 + 8));
          }

          goto LABEL_46;
        }
      }
    }
    else if (*(_QWORD *)(v15 + 120))
    {
      v34 = std::unordered_map<unsigned long long,-[GTShaderProfilerHelper _calculatePerSampleActiveShaders:withShaderProfilerResult:forWorkloadInfo:]::EncoderRangeInfo>::find[abi:nn180100](*(_QWORD *)(a3 + 120), *(_QWORD *)(a3 + 128), a5[1]);
      if (v34)
      {
        v35 = (id)v34[3];
        if (v35)
        {
          v67 = v35;
          v36 = objc_msgSend(v35, "newVisibleFunctionTableWithDescriptor:", v26);
          v30 = v36;
          if (v36)
            SetupInstrumentedFunctionTable(v36, *(uint64_t **)(v11 + 40), a3 + 200, (uint64_t)&v80, a5[1], v76);
          goto LABEL_41;
        }
      }
    }
    v30 = 0;
    goto LABEL_43;
  }
LABEL_47:
  if (v13->nelts >= 1)
  {
    for (i = 0; i < v13->nelts; ++i)
    {
      v39 = *(_QWORD *)&v13->elts[8 * i];
      if (!v39)
        continue;
      v40 = *(_QWORD *)(v39 + 16);
      v41 = *(_QWORD *)(v11 + 64);
      if (v41 <= v40 && *(_QWORD *)(v11 + 72) + v41 > v40)
        continue;
      v43 = *(_DWORD *)(a3 + 256);
      if (*(_QWORD *)(v39 + 120) && v43 != 8)
        continue;
      v45 = *(_QWORD *)(v39 + 128);
      if (v45)
      {
        HIDWORD(v47) = *(unsigned __int8 *)(v39 + 160);
        LODWORD(v47) = (HIDWORD(v47) << 24) - 0x2000000;
        v46 = v47 >> 25;
        v48 = v46 > 7u ? 1 : dword_4A87C8[v46];
        if (v48 != v43)
          continue;
      }
      v49 = a5[1];
      if (v45 != v49)
      {
        v59 = *(uint64_t **)(v11 + 40);
        v60 = a5;
        while (*(_QWORD *)(v39 + 120) != v49)
        {
          if (*(_DWORD *)v60 == 29)
          {
            v60 = GTMTLSMContext_getObject(*v59, v60[5], v60[2]);
            if (!v60 || *(_DWORD *)v60 != 29)
              goto LABEL_94;
          }
          else
          {
            if (*(_DWORD *)v60 != 71)
              goto LABEL_94;
            v60 = GTMTLSMContext_getObject(*v59, v60[5], v60[2]);
            if (!v60 || *(_DWORD *)v60 != 71)
              goto LABEL_94;
          }
          v49 = v60[1];
          if (*(_QWORD *)(v39 + 128) == v49)
            break;
        }
      }
      std::unordered_map<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong}>::unordered_map((uint64_t)v78, v73);
      v50 = *(id *)(a2 + 8);
      v110 = 0u;
      v111 = 0u;
      v108 = 0u;
      v109 = 0u;
      v106 = 0u;
      v107 = 0u;
      v104 = 0u;
      v105 = 0u;
      v102 = 0u;
      v103 = 0u;
      v100 = 0u;
      v101 = 0u;
      v98 = 0u;
      v99 = 0u;
      v96 = 0u;
      v97 = 0u;
      v94 = 0u;
      v95 = 0u;
      v92 = 0u;
      v93 = 0u;
      v90 = 0u;
      v91 = 0u;
      v88 = 0u;
      v89 = 0u;
      v86 = 0u;
      v87 = 0u;
      v84 = 0u;
      v85 = 0u;
      v82 = 0u;
      v83 = 0u;
      v80 = 0u;
      v81 = 0u;
      GetIntersectionFunctionTableState(&v80, v11, v39, v76, a6, pa);
      v51 = objc_alloc_init((Class)MTLIntersectionFunctionTableDescriptor);
      objc_msgSend(v51, "setFunctionCount:", *(unsigned int *)(*(_QWORD *)(v39 + 104) + 8));
      objc_msgSend(v51, "setResourceIndex:", **(_QWORD **)(v39 + 104));
      objc_msgSend(v51, "setForceResourceIndex:", 1);
      v52 = *(_QWORD *)(v39 + 128);
      if (v52)
      {
        v53 = *(unsigned __int8 *)(v39 + 160);
        v54 = GTMTLSMContext_getObject(**(_QWORD **)(v11 + 40), v52, v76);
        if (v54)
        {
          v55 = std::unordered_map<unsigned long long,-[GTShaderProfilerHelper _calculatePerSampleActiveShaders:withShaderProfilerResult:forWorkloadInfo:]::EncoderRangeInfo>::find[abi:nn180100](*(_QWORD *)(a3 + 40), *(_QWORD *)(a3 + 48), v54[1]);
          if (v55)
          {
            v72 = v50;
            v68 = (id)v55[3];
            v56 = objc_msgSend(v68, "newIntersectionFunctionTableWithDescriptor:stage:", v51, v53);
            if (v56)
            {
              v66 = *(uint64_t **)(v11 + 40);
              v57 = std::unordered_map<unsigned long long,-[GTShaderProfilerHelper _calculatePerSampleActiveShaders:withShaderProfilerResult:forWorkloadInfo:]::EncoderRangeInfo>::find[abi:nn180100](*(_QWORD *)(a3 + 80), *(_QWORD *)(a3 + 88), v53);
              if (!v57)
                abort();
              v58 = v57;
              std::unordered_map<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong}>::unordered_map((uint64_t)v79, (uint64_t)v78);
              SetupInstrumentedIntersectionFunctionTable(v56, v72, v66, (uint64_t)(v58 + 3), v79, &v80, *(_QWORD *)(v39 + 128), v76);
LABEL_88:
              std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v79);
            }
            goto LABEL_90;
          }
        }
        v56 = 0;
      }
      else
      {
        v61 = *(_QWORD *)(v39 + 120);
        if (v61)
        {
          v62 = GTMTLSMContext_getObject(**(_QWORD **)(v11 + 40), v61, v76);
          if (v62)
          {
            v63 = std::unordered_map<unsigned long long,-[GTShaderProfilerHelper _calculatePerSampleActiveShaders:withShaderProfilerResult:forWorkloadInfo:]::EncoderRangeInfo>::find[abi:nn180100](*(_QWORD *)(a3 + 120), *(_QWORD *)(a3 + 128), v62[1]);
            if (v63)
            {
              v72 = v50;
              v68 = (id)v63[3];
              v56 = objc_msgSend(v68, "newIntersectionFunctionTableWithDescriptor:", v51);
              if (v56)
              {
                v64 = *(uint64_t **)(v11 + 40);
                std::unordered_map<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong}>::unordered_map((uint64_t)v79, (uint64_t)v78);
                SetupInstrumentedIntersectionFunctionTable(v56, v50, v64, a3 + 200, v79, &v80, *(_QWORD *)(v39 + 120), v76);
                goto LABEL_88;
              }
LABEL_90:

              v50 = v72;
              goto LABEL_91;
            }
          }
        }
        v56 = 0;
      }
LABEL_91:

      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v78);
      if (v56)
      {
        *(_QWORD *)&v80 = *(_QWORD *)(v39 + 8);
        v65 = (id *)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::piecewise_construct_t const&<>>(v69, v80, &v80);
        objc_storeStrong(v65 + 3, v56);
        objc_msgSend(*(id *)(a2 + 8), "setIntersectionFunctionTable:forKey:", v56, *(_QWORD *)(v39 + 8));
      }

LABEL_94:
      ;
    }
  }
}

void sub_298254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  void *v26;
  void *v27;

  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&a26);

  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&a21);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table(a13);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table(a16);
  _Unwind_Resume(a1);
}

void *GetVisibleFunctionTableState(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, apr_pool_t *p)
{
  uint64_t v9;
  size_t v10;
  void *v11;
  uint64_t v12;
  void *result;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t *v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)a1 = 83;
  *(_QWORD *)(a1 + 24) = -1;
  *(_WORD *)(a1 + 98) = 2;
  *(_QWORD *)(a1 + 64) = -1;
  v9 = **(_QWORD **)(a3 + 104);
  *(_QWORD *)(a1 + 184) = v9;
  v10 = 8 * v9;
  v11 = apr_palloc(p, 8 * v9);
  *(_QWORD *)(a1 + 176) = v11;
  bzero(v11, v10);
  v12 = *(_QWORD *)(a2 + 8);
  v25 = *(_QWORD *)(a3 + 8);
  result = find_entry(v12, &v25, 8uLL, 0);
  if (*(_QWORD *)result)
  {
    v14 = *(_QWORD *)(*(_QWORD *)result + 32);
    if (v14)
    {
      v15 = *(_QWORD *)(v14 + 32);
      if (v15)
      {
        v16 = 0;
        while (1)
        {
          v17 = atomic_load((unsigned int *)(v15 + 4));
          v18 = v16 + (v17 >> 6) - 1;
          if ((int)v18 > 0)
            break;
          v15 = *(_QWORD *)(v15 + 40);
          v16 = v18;
          if (!v15)
          {
            v16 = v18;
            goto LABEL_10;
          }
        }
      }
      else
      {
        v16 = 0;
      }
      v18 = 0;
LABEL_10:
      v19 = v16 | (unint64_t)(v18 << 32);
LABEL_11:
      v20 = v15 + 64;
      while (v15)
      {
        if ((*(_BYTE *)(v20 + ((uint64_t)(HIDWORD(v19) - (int)v19) << 6) + 15) & 8) == 0)
          break;
        v21 = (unint64_t *)(v20 + ((uint64_t)(HIDWORD(v19) - (int)v19) << 6));
        if (*v21 >= a4)
          break;
        result = GTMTLSMVisibleFunctionTableStateful_processTraceFuncWithMap(a1, *(_QWORD *)(a2 + 16), (uint64_t)v21);
        v22 = atomic_load((unsigned int *)(v15 + 4));
        v23 = v19 + (v22 >> 6);
        v24 = (HIDWORD(v19) + 1);
        v19 = (v24 << 32) | v19;
        if ((_DWORD)v24 == v23 - 1)
        {
          v19 = (v24 << 32) | v24;
          v15 = *(_QWORD *)(v15 + 40);
          goto LABEL_11;
        }
      }
    }
  }
  return result;
}

void SetupInstrumentedFunctionTable(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  unint64_t v11;
  uint64_t v12;
  _QWORD *Object;
  uint64_t v14;
  _QWORD *v15;
  id v16;
  id v17;
  _QWORD v18[2];

  v17 = a1;
  if (*(_QWORD *)(a4 + 184))
  {
    v11 = 0;
    do
    {
      v12 = *(_QWORD *)(*(_QWORD *)(a4 + 176) + 8 * v11);
      if (v12)
      {
        Object = GTMTLSMContext_getObject(*a2, v12, a6);
        if (Object)
        {
          v14 = Object[5];
          v18[0] = a5;
          v18[1] = v14;
          v15 = std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::find<FunctionHandleKey>(*(_QWORD *)a3, *(_QWORD *)(a3 + 8), v18);
          if (v15)
          {
            v16 = (id)v15[4];
            objc_msgSend(v17, "setFunction:atIndex:", v16, v11);

          }
        }
      }
      else
      {
        objc_msgSend(v17, "setFunction:atIndex:", 0, v11);
      }
      ++v11;
    }
    while (*(_QWORD *)(a4 + 184) > v11);
  }

}

void sub_2985BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::piecewise_construct_t const&<>>(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD **v9;
  _QWORD *i;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = a2;
  i[2] = *a3;
  i[3] = 0;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2)
        v3 = a2 % v7;
      else
        v3 = a2;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *i = *v19;
LABEL_38:
    *v19 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v20 = *(_QWORD *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_2987D4(_Unwind_Exception *a1)
{
  id *v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong}>,void *>>>::operator()[abi:nn180100](1, v1);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong}>::unordered_map(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  _QWORD *v10;
  _QWORD *i;
  unint64_t v12;
  _QWORD *v13;
  void *v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  v5 = *(_QWORD **)(a2 + 16);
  if (v5)
  {
    v6 = (_QWORD *)(a1 + 16);
    do
    {
      v7 = v5[2];
      v8 = *(_QWORD *)(a1 + 8);
      if (v8)
      {
        v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
        v9.i16[0] = vaddlv_u8(v9);
        if (v9.u32[0] > 1uLL)
        {
          v2 = v5[2];
          if (v7 >= v8)
            v2 = v7 % v8;
        }
        else
        {
          v2 = (v8 - 1) & v7;
        }
        v10 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v2);
        if (v10)
        {
          for (i = (_QWORD *)*v10; i; i = (_QWORD *)*i)
          {
            v12 = i[1];
            if (v12 == v7)
            {
              if (i[2] == v7)
                goto LABEL_41;
            }
            else
            {
              if (v9.u32[0] > 1uLL)
              {
                if (v12 >= v8)
                  v12 %= v8;
              }
              else
              {
                v12 &= v8 - 1;
              }
              if (v12 != v2)
                break;
            }
          }
        }
      }
      v13 = operator new(0x20uLL);
      *v13 = 0;
      v13[1] = v7;
      v14 = (void *)v5[3];
      v13[2] = v5[2];
      v13[3] = v14;
      v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
      v16 = *(float *)(a1 + 32);
      if (!v8 || (float)(v16 * (float)v8) < v15)
      {
        v17 = (v8 & (v8 - 1)) != 0;
        if (v8 < 3)
          v17 = 1;
        v18 = v17 | (2 * v8);
        v19 = vcvtps_u32_f32(v15 / v16);
        if (v18 <= v19)
          v20 = v19;
        else
          v20 = v18;
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v20);
        v8 = *(_QWORD *)(a1 + 8);
        if ((v8 & (v8 - 1)) != 0)
        {
          if (v7 >= v8)
            v2 = v7 % v8;
          else
            v2 = v7;
        }
        else
        {
          v2 = (v8 - 1) & v7;
        }
      }
      v21 = *(_QWORD *)a1;
      v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v2);
      if (v22)
      {
        *v13 = *v22;
      }
      else
      {
        *v13 = *v6;
        *v6 = v13;
        *(_QWORD *)(v21 + 8 * v2) = v6;
        if (!*v13)
          goto LABEL_40;
        v23 = *(_QWORD *)(*v13 + 8);
        if ((v8 & (v8 - 1)) != 0)
        {
          if (v23 >= v8)
            v23 %= v8;
        }
        else
        {
          v23 &= v8 - 1;
        }
        v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
      }
      *v22 = v13;
LABEL_40:
      ++*(_QWORD *)(a1 + 24);
LABEL_41:
      v5 = (_QWORD *)*v5;
    }
    while (v5);
  }
  return a1;
}

void sub_298A18(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void *GetIntersectionFunctionTableState(_DWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t *a5, apr_pool_t *a6)
{
  uint64_t v12;
  size_t v13;
  void *v14;
  uint64_t v15;
  void *result;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t *v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;

  bzero(a1, 0x3A0uLL);
  *a1 = 60;
  *((_QWORD *)a1 + 3) = -1;
  *((_WORD *)a1 + 49) = 2;
  *((_QWORD *)a1 + 8) = -1;
  v12 = *(unsigned int *)(*(_QWORD *)(a3 + 104) + 8);
  *((_QWORD *)a1 + 22) = v12;
  v13 = 16 * v12;
  v14 = apr_palloc(a6, 16 * v12);
  *((_QWORD *)a1 + 21) = v14;
  bzero(v14, v13);
  v15 = *(_QWORD *)(a2 + 8);
  v28 = *(_QWORD *)(a3 + 8);
  result = find_entry(v15, &v28, 8uLL, 0);
  if (*(_QWORD *)result)
  {
    v17 = *(_QWORD *)(*(_QWORD *)result + 32);
    if (v17)
    {
      v18 = *(_QWORD *)(v17 + 32);
      if (v18)
      {
        v19 = 0;
        while (1)
        {
          v20 = atomic_load((unsigned int *)(v18 + 4));
          v21 = v19 + (v20 >> 6) - 1;
          if ((int)v21 > 0)
            break;
          v18 = *(_QWORD *)(v18 + 40);
          v19 = v21;
          if (!v18)
          {
            v19 = v21;
            goto LABEL_10;
          }
        }
      }
      else
      {
        v19 = 0;
      }
      v21 = 0;
LABEL_10:
      v22 = v19 | (unint64_t)(v21 << 32);
LABEL_11:
      v23 = v18 + 64;
      while (v18)
      {
        if ((*(_BYTE *)(v23 + ((uint64_t)(HIDWORD(v22) - (int)v22) << 6) + 15) & 8) == 0)
          break;
        v24 = (unint64_t *)(v23 + ((uint64_t)(HIDWORD(v22) - (int)v22) << 6));
        if (*v24 >= a4)
          break;
        result = GTMTLSMIntersectionFunctionTableStateful_processTraceFuncWithMap((uint64_t)a1, *(_QWORD *)(a2 + 16), (uint64_t)v24, a5);
        v25 = atomic_load((unsigned int *)(v18 + 4));
        v26 = v22 + (v25 >> 6);
        v27 = (HIDWORD(v22) + 1);
        v22 = (v27 << 32) | v22;
        if ((_DWORD)v27 == v26 - 1)
        {
          v22 = (v27 << 32) | v27;
          v18 = *(_QWORD *)(v18 + 40);
          goto LABEL_11;
        }
      }
    }
  }
  return result;
}

void SetupInstrumentedIntersectionFunctionTable(void *a1, void *a2, uint64_t *a3, uint64_t a4, _QWORD *a5, _QWORD *a6, uint64_t a7, unint64_t a8)
{
  id v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  _QWORD *Object;
  uint64_t v22;
  _QWORD *v23;
  id v24;
  uint64_t v25;
  _QWORD *v26;
  int v27;
  id v28;
  _QWORD *v29;
  id v30;
  _QWORD v31[2];

  v30 = a1;
  v15 = a2;
  if (a6[22])
  {
    v16 = 0;
    v17 = 0;
    do
    {
      v18 = a6[21];
      v19 = *(_DWORD *)(v18 + v16);
      switch(v19)
      {
        case 3:
          objc_msgSend(v30, "setOpaqueCurveIntersectionFunctionWithSignature:atIndex:", *(_QWORD *)(v18 + v16 + 8), v17);
          break;
        case 2:
          objc_msgSend(v30, "setOpaqueTriangleIntersectionFunctionWithSignature:atIndex:", *(_QWORD *)(v18 + v16 + 8), v17);
          break;
        case 1:
          v20 = *(_QWORD *)(v18 + v16 + 8);
          if (v20)
          {
            Object = GTMTLSMContext_getObject(*a3, v20, a8);
            if (Object && (Object[7] == a7 || Object[6] == a7))
            {
              v22 = Object[5];
              v31[0] = a7;
              v31[1] = v22;
              v23 = std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::find<FunctionHandleKey>(*(_QWORD *)a4, *(_QWORD *)(a4 + 8), v31);
              if (v23)
              {
                v24 = (id)v23[4];
                objc_msgSend(v30, "setFunction:atIndex:", v24, v17);

              }
            }
          }
          else
          {
            objc_msgSend(v30, "setFunction:atIndex:", 0, v17);
          }
          break;
      }
      ++v17;
      v16 += 16;
    }
    while (a6[22] > v17);
  }
  v25 = 0;
  v26 = a6 + 25;
  do
  {
    v27 = *((_DWORD *)v26 - 4);
    if (v27 == 2)
    {
      v29 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(a5, *(v26 - 1));
      if (!v29)
        goto LABEL_23;
      v28 = (id)v29[3];
      objc_msgSend(v30, "setVisibleFunctionTable:atBufferIndex:", v28, v25);
    }
    else
    {
      if (v27 != 1)
        goto LABEL_23;
      v28 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "bufferForKey:", *(v26 - 1)));
      objc_msgSend(v30, "setBuffer:offset:atIndex:", v28, *v26, v25);
    }

LABEL_23:
    ++v25;
    v26 += 3;
  }
  while (v25 != 31);

}

void sub_298DC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::piecewise_construct_t const&<>>(uint64_t *a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v5;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD **v9;
  _QWORD *i;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  int8x8_t prime;
  void *v19;
  void *v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  uint8x8_t v24;
  unint64_t v25;
  uint8x8_t v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  void *v34;

  v5 = a2;
  v7 = a1[1];
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(_QWORD ***)(*a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  v12 = a1 + 2;
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v5;
  i[2] = *a3;
  i[3] = 0;
  v13 = (float)(unint64_t)(a1[3] + 1);
  v14 = *((float *)a1 + 8);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    v5 = v3;
    goto LABEL_64;
  }
  v15 = 1;
  if (v7 >= 3)
    v15 = (v7 & (v7 - 1)) != 0;
  v16 = v15 | (2 * v7);
  v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17)
    prime = (int8x8_t)v17;
  else
    prime = (int8x8_t)v16;
  if (*(_QWORD *)&prime == 1)
  {
    prime = (int8x8_t)2;
  }
  else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
  {
    prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    v7 = a1[1];
  }
  if (*(_QWORD *)&prime <= v7)
  {
    if (*(_QWORD *)&prime >= v7)
      goto LABEL_60;
    v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
    if (v7 < 3 || (v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      v25 = std::__next_prime(v25);
    }
    else
    {
      v27 = 1 << -(char)__clz(v25 - 1);
      if (v25 >= 2)
        v25 = v27;
    }
    if (*(_QWORD *)&prime <= v25)
      prime = (int8x8_t)v25;
    if (*(_QWORD *)&prime >= v7)
    {
      v7 = a1[1];
      goto LABEL_60;
    }
    if (!*(_QWORD *)&prime)
    {
      v34 = (void *)*a1;
      *a1 = 0;
      if (v34)
        operator delete(v34);
      v7 = 0;
      a1[1] = 0;
      goto LABEL_60;
    }
  }
  if (*(_QWORD *)&prime >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  v19 = operator new(8 * *(_QWORD *)&prime);
  v20 = (void *)*a1;
  *a1 = (uint64_t)v19;
  if (v20)
    operator delete(v20);
  v21 = 0;
  a1[1] = (uint64_t)prime;
  do
    *(_QWORD *)(*a1 + 8 * v21++) = 0;
  while (*(_QWORD *)&prime != v21);
  v22 = (_QWORD *)*v12;
  if (*v12)
  {
    v23 = v22[1];
    v24 = (uint8x8_t)vcnt_s8(prime);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      if (v23 >= *(_QWORD *)&prime)
        v23 %= *(_QWORD *)&prime;
    }
    else
    {
      v23 &= *(_QWORD *)&prime - 1;
    }
    *(_QWORD *)(*a1 + 8 * v23) = v12;
    v28 = (_QWORD *)*v22;
    if (*v22)
    {
      do
      {
        v29 = v28[1];
        if (v24.u32[0] > 1uLL)
        {
          if (v29 >= *(_QWORD *)&prime)
            v29 %= *(_QWORD *)&prime;
        }
        else
        {
          v29 &= *(_QWORD *)&prime - 1;
        }
        if (v29 != v23)
        {
          if (!*(_QWORD *)(*a1 + 8 * v29))
          {
            *(_QWORD *)(*a1 + 8 * v29) = v22;
            goto LABEL_56;
          }
          *v22 = *v28;
          *v28 = **(_QWORD **)(*a1 + 8 * v29);
          **(_QWORD **)(*a1 + 8 * v29) = v28;
          v28 = v22;
        }
        v29 = v23;
LABEL_56:
        v22 = v28;
        v28 = (_QWORD *)*v28;
        v23 = v29;
      }
      while (v28);
    }
  }
  v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5)
      v5 %= v7;
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_64:
  v30 = *a1;
  v31 = *(_QWORD **)(*a1 + 8 * v5);
  if (v31)
  {
    *i = *v31;
LABEL_72:
    *v31 = i;
    goto LABEL_73;
  }
  *i = *v12;
  *v12 = i;
  *(_QWORD *)(v30 + 8 * v5) = v12;
  if (*i)
  {
    v32 = *(_QWORD *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7)
        v32 %= v7;
    }
    else
    {
      v32 &= v7 - 1;
    }
    v31 = (_QWORD *)(*a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return i;
}

void sub_2991D0(_Unwind_Exception *a1)
{
  id *v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong}>,void *>>>::operator()[abi:nn180100](1, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong}>,void *>>>::operator()[abi:nn180100](char a1, id *a2)
{
  if (a1)
  {

  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

_QWORD *std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::find<FunctionHandleKey>(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *result;
  unint64_t v8;

  if (!a2)
    return 0;
  v3 = a3[1] ^ (*a3 << 32);
  v4 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = a3[1] ^ (*a3 << 32);
    if (v3 >= a2)
      v5 = v3 % a2;
  }
  else
  {
    v5 = (a2 - 1) & v3;
  }
  v6 = *(_QWORD **)(a1 + 8 * v5);
  if (!v6)
    return 0;
  result = (_QWORD *)*v6;
  if (*v6)
  {
    do
    {
      v8 = result[1];
      if (v3 == v8)
      {
        if (result[2] == *a3 && result[3] == a3[1])
          return result;
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= a2)
            v8 %= a2;
        }
        else
        {
          v8 &= a2 - 1;
        }
        if (v8 != v5)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>(uint64_t *a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v5;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD **v9;
  _QWORD *i;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  int8x8_t prime;
  void *v19;
  void *v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  uint8x8_t v24;
  unint64_t v25;
  uint8x8_t v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  void *v34;

  v5 = a2;
  v7 = a1[1];
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(_QWORD ***)(*a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  v12 = a1 + 2;
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v5;
  i[2] = *a3;
  i[3] = 0;
  v13 = (float)(unint64_t)(a1[3] + 1);
  v14 = *((float *)a1 + 8);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    v5 = v3;
    goto LABEL_64;
  }
  v15 = 1;
  if (v7 >= 3)
    v15 = (v7 & (v7 - 1)) != 0;
  v16 = v15 | (2 * v7);
  v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17)
    prime = (int8x8_t)v17;
  else
    prime = (int8x8_t)v16;
  if (*(_QWORD *)&prime == 1)
  {
    prime = (int8x8_t)2;
  }
  else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
  {
    prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    v7 = a1[1];
  }
  if (*(_QWORD *)&prime <= v7)
  {
    if (*(_QWORD *)&prime >= v7)
      goto LABEL_60;
    v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
    if (v7 < 3 || (v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      v25 = std::__next_prime(v25);
    }
    else
    {
      v27 = 1 << -(char)__clz(v25 - 1);
      if (v25 >= 2)
        v25 = v27;
    }
    if (*(_QWORD *)&prime <= v25)
      prime = (int8x8_t)v25;
    if (*(_QWORD *)&prime >= v7)
    {
      v7 = a1[1];
      goto LABEL_60;
    }
    if (!*(_QWORD *)&prime)
    {
      v34 = (void *)*a1;
      *a1 = 0;
      if (v34)
        operator delete(v34);
      v7 = 0;
      a1[1] = 0;
      goto LABEL_60;
    }
  }
  if (*(_QWORD *)&prime >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  v19 = operator new(8 * *(_QWORD *)&prime);
  v20 = (void *)*a1;
  *a1 = (uint64_t)v19;
  if (v20)
    operator delete(v20);
  v21 = 0;
  a1[1] = (uint64_t)prime;
  do
    *(_QWORD *)(*a1 + 8 * v21++) = 0;
  while (*(_QWORD *)&prime != v21);
  v22 = (_QWORD *)*v12;
  if (*v12)
  {
    v23 = v22[1];
    v24 = (uint8x8_t)vcnt_s8(prime);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      if (v23 >= *(_QWORD *)&prime)
        v23 %= *(_QWORD *)&prime;
    }
    else
    {
      v23 &= *(_QWORD *)&prime - 1;
    }
    *(_QWORD *)(*a1 + 8 * v23) = v12;
    v28 = (_QWORD *)*v22;
    if (*v22)
    {
      do
      {
        v29 = v28[1];
        if (v24.u32[0] > 1uLL)
        {
          if (v29 >= *(_QWORD *)&prime)
            v29 %= *(_QWORD *)&prime;
        }
        else
        {
          v29 &= *(_QWORD *)&prime - 1;
        }
        if (v29 != v23)
        {
          if (!*(_QWORD *)(*a1 + 8 * v29))
          {
            *(_QWORD *)(*a1 + 8 * v29) = v22;
            goto LABEL_56;
          }
          *v22 = *v28;
          *v28 = **(_QWORD **)(*a1 + 8 * v29);
          **(_QWORD **)(*a1 + 8 * v29) = v28;
          v28 = v22;
        }
        v29 = v23;
LABEL_56:
        v22 = v28;
        v28 = (_QWORD *)*v28;
        v23 = v29;
      }
      while (v28);
    }
  }
  v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5)
      v5 %= v7;
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_64:
  v30 = *a1;
  v31 = *(_QWORD **)(*a1 + 8 * v5);
  if (v31)
  {
    *i = *v31;
LABEL_72:
    *v31 = i;
    goto LABEL_73;
  }
  *i = *v12;
  *v12 = i;
  *(_QWORD *)(v30 + 8 * v5) = v12;
  if (*i)
  {
    v32 = *(_QWORD *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7)
        v32 %= v7;
    }
    else
    {
      v32 &= v7 - 1;
    }
    v31 = (_QWORD *)(*a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return i;
}

void sub_2996BC(_Unwind_Exception *a1)
{
  id *v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong}>,void *>>>::operator()[abi:nn180100](1, v1);
  _Unwind_Resume(a1);
}

id ObtainTracingFunction(void *a1, void *a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6)
{
  id v11;
  id v12;
  id v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  id MTLFunctionDescriptor;
  void *v18;
  id v19;
  uint64_t v20;
  id MTLIntersectionFunctionDescriptor;
  void *v22;
  unsigned int v23;
  void *v24;
  id v25;
  id v26;
  id v27;
  void *v28;
  void *v29;
  id *v30;
  _QWORD *v32;
  id MTLFunctionConstantValues;
  void *v34;
  unint64_t v35;

  v11 = a1;
  v12 = a2;
  v13 = a5;
  if (*(_BYTE *)(a4 + 132))
    goto LABEL_2;
  v15 = a3 + 160;
  v35 = *(_QWORD *)(a4 + 8);
  v14 = (id)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto11MTLFunction}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::piecewise_construct_t const&<>>(a3 + 160, v35, &v35)[3];
  if (v14)
    goto LABEL_15;
  v16 = *(_QWORD *)(a4 + 112);
  if (v16)
  {
    MTLFunctionDescriptor = MakeMTLFunctionDescriptor(v16, v13);
    v18 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionDescriptor);
    v19 = objc_msgSend(v12, "newFunctionWithDescriptor:error:", v18, a6);
LABEL_8:
    v14 = v19;
    goto LABEL_9;
  }
  v20 = *(_QWORD *)(a4 + 120);
  if (v20)
  {
    MTLIntersectionFunctionDescriptor = MakeMTLIntersectionFunctionDescriptor(v20, v13);
    v18 = (void *)objc_claimAutoreleasedReturnValue(MTLIntersectionFunctionDescriptor);
    v19 = objc_msgSend(v12, "newIntersectionFunctionWithDescriptor:error:", v18, a6);
    goto LABEL_8;
  }
  if (!*(_QWORD *)(a4 + 56))
  {
LABEL_2:
    v14 = 0;
    goto LABEL_15;
  }
  v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:"));
  v32 = *(_QWORD **)(a4 + 72);
  if (!v32)
  {
    v19 = objc_msgSend(v12, "newFunctionWithName:", v18);
    goto LABEL_8;
  }
  MTLFunctionConstantValues = MakeMTLFunctionConstantValues(v32);
  v34 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionConstantValues);
  v14 = objc_msgSend(v12, "newFunctionWithName:constantValues:error:", v18, v34, a6);

LABEL_9:
  if (v14)
  {
    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "device"));
    v23 = SupportsGlobalRelocation(v22, a3);

    if (v23)
    {
      v24 = *(void **)(a3 + 240);
      v25 = v14;
      v26 = v24;
      v27 = objc_msgSend(objc_alloc((Class)MTLBufferRelocation), "initWithSymbolName:buffer:offset:", CFSTR("__resource_tracking_impl_trace_buffer"), v26, 0);
      v28 = v27;
      if (v27)
      {
        v35 = (unint64_t)v27;
        v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v35, 1));
        objc_msgSend(v25, "setRelocations:", v29);

      }
    }
    v35 = *(_QWORD *)(a4 + 8);
    v30 = (id *)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto11MTLFunction}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::piecewise_construct_t const&<>>(v15, v35, &v35);
    objc_storeStrong(v30 + 3, v14);
  }
LABEL_15:

  return v14;
}

void sub_299930(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

id ObtainTracingLinkedFunctions(const GTMTLSMContext *a1, void *a2, GTMTLReplayAccessTracking *a3, uint64_t a4, unint64_t a5)
{
  GTMTLReplayObjectMap *v9;
  id v10;
  void *v11;
  id v12;
  void *v13;
  id v14;
  uint64_t v15;
  void *v16;
  id v17;

  v9 = a2;
  if (a4)
  {
    v10 = ObtainTracingFunctions(a1, v9, a3, *(const unint64_t **)(a4 + 16), *(_QWORD *)(a4 + 24), a5);
    v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    v12 = ObtainTracingFunctions(a1, v9, a3, *(const unint64_t **)a4, *(_QWORD *)(a4 + 8), a5);
    v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
    v14 = ObtainTracingFunctions(a1, v9, a3, *(const unint64_t **)(a4 + 48), *(_QWORD *)(a4 + 56), a5);
    v15 = objc_claimAutoreleasedReturnValue(v14);
    v16 = (void *)v15;
    if (v11 || v13 || v15)
    {
      v17 = objc_alloc_init((Class)MTLLinkedFunctions);
      objc_msgSend(v17, "setFunctions:", v11);
      objc_msgSend(v17, "setBinaryFunctions:", v13);
      objc_msgSend(v17, "setPrivateFunctions:", v16);
    }
    else
    {
      v17 = 0;
    }

  }
  else
  {
    v17 = 0;
  }

  return v17;
}

void sub_299AF0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

id SupportsGlobalRelocation(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  id v5;
  int v6;
  char v7;
  id v8;

  v3 = a1;
  v4 = v3;
  v5 = 0;
  v6 = *(_DWORD *)(a2 + 256);
  switch(v6)
  {
    case 1:
    case 4:
      goto LABEL_11;
    case 2:
      if (*(_BYTE *)(a2 + 261))
      {
        if (!objc_msgSend(v3, "supportsFamily:", 1009))
        {
LABEL_15:
          v5 = 0;
          goto LABEL_16;
        }
LABEL_5:
        v7 = objc_opt_respondsToSelector(v4, "supportsGlobalVariableRelocationRender");
      }
      else
      {
LABEL_11:
        v7 = objc_opt_respondsToSelector(v3, "supportsGlobalVariableRelocationRender");
      }
      if ((v7 & 1) == 0)
        goto LABEL_15;
      v8 = objc_msgSend(v4, "supportsGlobalVariableRelocationRender");
LABEL_14:
      v5 = v8;
LABEL_16:

      return v5;
    case 3:
    case 5:
    case 6:
    case 7:
      goto LABEL_16;
    case 8:
      if ((objc_opt_respondsToSelector(v3, "supportsGlobalVariableRelocationCompute") & 1) == 0)
        goto LABEL_15;
      v8 = objc_msgSend(v4, "supportsGlobalVariableRelocationCompute");
      goto LABEL_14;
    default:
      if (v6 != 16 && v6 != 32)
        goto LABEL_16;
      if (objc_msgSend(v3, "supportsFamily:", 1009))
        goto LABEL_5;
      goto LABEL_15;
  }
}

void sub_299C54(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

char *TraceBufferBindingIndex(void *a1, unsigned int a2)
{
  id v3;
  char *v4;
  id v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[128];

  v3 = a1;
  v4 = 0;
  if (a2 <= 0x20 && ((1 << a2) & 0x100010116) != 0)
  {
    v4 = 0;
    while (2)
    {
      v13 = 0u;
      v14 = 0u;
      v11 = 0u;
      v12 = 0u;
      v5 = v3;
      v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
      if (v6)
      {
        v7 = *(_QWORD *)v12;
LABEL_6:
        v8 = 0;
        while (1)
        {
          if (*(_QWORD *)v12 != v7)
            objc_enumerationMutation(v5);
          v9 = *(void **)(*((_QWORD *)&v11 + 1) + 8 * v8);
          if (!objc_msgSend(v9, "type") && objc_msgSend(v9, "index") == v4)
            break;
          if (v6 == (id)++v8)
          {
            v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
            if (v6)
              goto LABEL_6;
            goto LABEL_16;
          }
        }

        if (++v4 != (_BYTE *)&dword_1C + 3)
          continue;
        v4 = 0;
      }
      else
      {
LABEL_16:

      }
      break;
    }
  }

  return v4;
}

void sub_299DCC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x20uLL);
  *v10 = 0;
  v10[1] = a2;
  v10[2] = *a3;
  *((_DWORD *)v10 + 6) = 0;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2)
        v3 = a2 % v7;
      else
        v3 = a2;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *v10 = *v19;
LABEL_38:
    *v19 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v20 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_299FEC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void CreateRenderFunctionHandles(GTMTLReplayAccessTracking *a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  CreateRenderFunctionHandles(a1, a2, *(const unint64_t **)(a3 + 16), *(_QWORD *)(a3 + 24), a4);
  CreateRenderFunctionHandles(a1, a2, *(const unint64_t **)a3, *(_QWORD *)(a3 + 8), a4);
}

void CreateRenderFunctionHandles(GTMTLReplayAccessTracking *a1, unint64_t a2, const unint64_t *a3, uint64_t a4, unint64_t a5)
{
  uint64_t v5;
  uint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  void **v14;
  char *v15;
  unint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;
  id v26;
  id v27;
  void *v28;
  id v29;
  id *v30;
  char *v31;
  uint64_t *v32;
  unint64_t v36;
  unint64_t v37;
  __int128 v38;
  char v39;

  if (a3 && a4)
  {
    v8 = 0;
    v9 = (uint64_t *)((char *)a1 + 80);
    v31 = (char *)a1 + 160;
    v32 = (uint64_t *)((char *)a1 + 40);
    v10 = (_QWORD *)((char *)a1 + 96);
    do
    {
      v11 = a3[v8];
      v36 = v11;
      v37 = a2;
      v12 = *((_QWORD *)a1 + 11);
      if (v12)
      {
        v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
        v13.i16[0] = vaddlv_u8(v13);
        if (v13.u32[0] > 1uLL)
        {
          v5 = a5;
          if (v12 <= a5)
            v5 = a5 % v12;
        }
        else
        {
          v5 = (v12 - 1) & a5;
        }
        v14 = *(void ***)(*v9 + 8 * v5);
        if (v14)
        {
          v15 = (char *)*v14;
          if (*v14)
          {
            do
            {
              v16 = *((_QWORD *)v15 + 1);
              if (v16 == a5)
              {
                if (*((_QWORD *)v15 + 2) == a5)
                  goto LABEL_42;
              }
              else
              {
                if (v13.u32[0] > 1uLL)
                {
                  if (v16 >= v12)
                    v16 %= v12;
                }
                else
                {
                  v16 &= v12 - 1;
                }
                if (v16 != v5)
                  break;
              }
              v15 = *(char **)v15;
            }
            while (v15);
          }
        }
      }
      v15 = (char *)operator new(0x40uLL);
      *(_QWORD *)&v38 = v15;
      *((_QWORD *)&v38 + 1) = v10;
      *(_QWORD *)v15 = 0;
      *((_QWORD *)v15 + 1) = a5;
      *((_QWORD *)v15 + 2) = a5;
      *(_OWORD *)(v15 + 24) = 0u;
      *(_OWORD *)(v15 + 40) = 0u;
      *((_DWORD *)v15 + 14) = 1065353216;
      v39 = 1;
      v17 = (float)(unint64_t)(*((_QWORD *)a1 + 13) + 1);
      v18 = *((float *)a1 + 28);
      if (!v12 || (float)(v18 * (float)v12) < v17)
      {
        v19 = (v12 & (v12 - 1)) != 0;
        if (v12 < 3)
          v19 = 1;
        v20 = v19 | (2 * v12);
        v21 = vcvtps_u32_f32(v17 / v18);
        if (v20 <= v21)
          v22 = v21;
        else
          v22 = v20;
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)v9, v22);
        v12 = *((_QWORD *)a1 + 11);
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v12 <= a5)
            v5 = a5 % v12;
          else
            v5 = a5;
        }
        else
        {
          v5 = (v12 - 1) & a5;
        }
      }
      v23 = *v9;
      v24 = *(_QWORD **)(*v9 + 8 * v5);
      if (v24)
      {
        *(_QWORD *)v15 = *v24;
      }
      else
      {
        *(_QWORD *)v15 = *v10;
        *v10 = v15;
        *(_QWORD *)(v23 + 8 * v5) = v10;
        if (!*(_QWORD *)v15)
          goto LABEL_41;
        v25 = *(_QWORD *)(*(_QWORD *)v15 + 8);
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v25 >= v12)
            v25 %= v12;
        }
        else
        {
          v25 &= v12 - 1;
        }
        v24 = (_QWORD *)(*v9 + 8 * v25);
      }
      *v24 = v15;
LABEL_41:
      *(_QWORD *)&v38 = 0;
      ++*((_QWORD *)a1 + 13);
      std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,void *>,std::__hash_node_destructor<std::equal_to<FunctionHandleKey><void *>>>::reset[abi:nn180100]((uint64_t)&v38);
LABEL_42:
      v5 = (uint64_t)(v15 + 24);
      *(_QWORD *)&v38 = a2;
      *((_QWORD *)&v38 + 1) = v11;
      v26 = (id)std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::__emplace_unique_key_args<FunctionHandleKey,std::piecewise_construct_t const&,std::tuple<FunctionHandleKey const&>,std::piecewise_construct_t const&<>>((uint64_t)(v15 + 24), &v38, &v38)[4];
      if (!v26)
      {
        v27 = (id)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>(v32, v37, &v37)[3];
        if (v27)
        {
          v28 = v27;
          v29 = (id)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto11MTLFunction}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>((uint64_t)v31, v36, &v36)[3];
          if (v29)
          {
            v26 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "functionHandleWithFunction:stage:", v29, a5));
            if (v26)
            {
              v30 = (id *)std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::__emplace_unique_key_args<FunctionHandleKey,std::piecewise_construct_t const&,std::tuple<FunctionHandleKey const&>,std::piecewise_construct_t const&<>>(v5, &v38, &v38);
              objc_storeStrong(v30 + 4, v26);
            }
          }
          else
          {
            v26 = 0;
          }

        }
        else
        {
          v26 = 0;
        }
      }

      ++v8;
    }
    while (v8 != a4);
  }
}

void sub_29A38C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::__emplace_unique_key_args<FunctionHandleKey,std::piecewise_construct_t const&,std::tuple<FunctionHandleKey const&>,std::piecewise_construct_t const&<>>(uint64_t a1, _QWORD *a2, _OWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD **v9;
  _QWORD *i;
  unint64_t v11;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v6 = a2[1] ^ (*a2 << 32);
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2[1] ^ (*a2 << 32);
      if (v6 >= v7)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == v6)
        {
          if (i[2] == *a2 && i[3] == a2[1])
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x28uLL);
  *i = 0;
  i[1] = v6;
  *((_OWORD *)i + 1) = *a3;
  i[4] = 0;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v18);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v20)
  {
    *i = *v20;
LABEL_42:
    *v20 = i;
    goto LABEL_43;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v19 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v21 = *(_QWORD *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7)
        v21 %= v7;
    }
    else
    {
      v21 &= v7 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_42;
  }
LABEL_43:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_29A5C8(_Unwind_Exception *a1)
{
  id *v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,void *>>>::operator()[abi:nn180100](1, v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto11MTLFunction}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD **v9;
  _QWORD *i;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = a2;
  i[2] = *a3;
  i[3] = 0;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2)
        v3 = a2 % v7;
      else
        v3 = a2;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *i = *v19;
LABEL_38:
    *v19 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v20 = *(_QWORD *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_29A7D8(_Unwind_Exception *a1)
{
  id *v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong}>,void *>>>::operator()[abi:nn180100](1, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,void *>>>::operator()[abi:nn180100](char a1, id *a2)
{
  if (a1)
  {

  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,void *>,std::__hash_node_destructor<std::equal_to<FunctionHandleKey><void *>>>::reset[abi:nn180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)v1 + 24);
    operator delete(v1);
  }
}

id ObtainTracingFunctions(const GTMTLSMContext *a1, GTMTLReplayObjectMap *a2, GTMTLReplayAccessTracking *a3, const unint64_t *a4, uint64_t a5, unint64_t a6)
{
  GTMTLReplayObjectMap *v10;
  void *v11;
  uint64_t v12;
  uint64_t Object;
  uint64_t v14;
  void *v15;
  void *v16;
  id v17;
  void *v18;
  id v19;
  void *v20;
  id v22;
  void *v24;
  id v25;

  v10 = a2;
  v24 = (void *)objc_claimAutoreleasedReturnValue(-[GTMTLReplayObjectMap defaultDevice](v10, "defaultDevice"));
  if (a4)
  {
    v22 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", a5);
    if (a5)
    {
      v11 = 0;
      do
      {
        v12 = *a4++;
        Object = GTMTLSMContext_lastObject(*(_QWORD *)a1, v12, a6);
        if (Object)
        {
          v14 = Object;
          v15 = (void *)objc_claimAutoreleasedReturnValue(-[GTMTLReplayObjectMap libraryForKey:](v10, "libraryForKey:", *(_QWORD *)(Object + 40)));
          v16 = (void *)objc_claimAutoreleasedReturnValue(-[GTMTLReplayObjectMap functionMap](v10, "functionMap"));
          v25 = v11;
          v17 = ObtainTracingFunction(v24, v15, (uint64_t)a3, v14, v16, (uint64_t)&v25);
          v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
          v19 = v25;

          if (v18)
            objc_msgSend(v22, "addObject:", v18);

          v11 = v19;
        }
        else
        {
          v19 = v11;
        }
        --a5;
      }
      while (a5);
    }
    else
    {
      v19 = 0;
    }

    v20 = v22;
  }
  else
  {
    v20 = 0;
  }

  return v20;
}

void sub_29A9CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto11MTLFunction}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::piecewise_construct_t const&<>>(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD **v9;
  _QWORD *i;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = a2;
  i[2] = *a3;
  i[3] = 0;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2)
        v3 = a2 % v7;
      else
        v3 = a2;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *i = *v19;
LABEL_38:
    *v19 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v20 = *(_QWORD *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_29AC20(_Unwind_Exception *a1)
{
  id *v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong}>,void *>>>::operator()[abi:nn180100](1, v1);
  _Unwind_Resume(a1);
}

void FlushCommandQueue(GTMTLReplayController *a1)
{
  void *v2;
  id v3;

  objc_msgSend(a1->var1, "commitCommandBuffers");
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1->var1, "defaultCommandQueue"));
  v3 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "commandBuffer"));

  objc_msgSend(v3, "commit");
  objc_msgSend(v3, "waitUntilCompleted");
  objc_msgSend(v3, "status");

}

void sub_29ACA0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t UpdateDrawFunctionTables(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t a4, void *a5, unint64_t a6)
{
  id v11;
  uint64_t updated;
  signed int v13;
  uint64_t v14;
  uint64_t v15;

  v11 = a5;
  updated = 0;
  v13 = *(_DWORD *)(a1 + 256);
  if (v13 > 15)
  {
    if (v13 == 16)
    {
      v14 = a4 + 3584;
      v15 = a4 + 3576;
      goto LABEL_10;
    }
    if (v13 == 32)
    {
      v14 = a4 + 5240;
      v15 = a4 + 5232;
      goto LABEL_10;
    }
  }
  else
  {
    if (v13 == 1)
    {
      v14 = a4 + 24;
      v15 = a4 + 8;
      goto LABEL_10;
    }
    if (v13 == 2)
    {
      v14 = a4 + 1928;
      v15 = a4 + 1920;
LABEL_10:
      updated = UpdateFunctionTables<31ul,1ul>(v13, v11, v14, v15, a2, a6, a3);
    }
  }

  return updated;
}

void sub_29AD90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t UpdateFunctionTables<31ul,1ul>(unsigned int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t *a5, unint64_t a6, _QWORD *a7)
{
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *Object;
  _QWORD *v20;
  uint64_t *v21;
  int8x8_t v22;
  unint64_t v23;
  uint8x8_t v24;
  unint64_t v25;
  uint64_t ***v26;
  uint64_t **v27;
  unint64_t v28;

  v13 = a2;
  v14 = v13;
  LOBYTE(v15) = 0;
  if (a1 > 0x20)
    goto LABEL_46;
  if (((1 << a1) & 0x100010016) == 0)
  {
    if (a1 != 8)
      goto LABEL_46;
    if (objc_msgSend(v13, "conformsToProtocol:", &OBJC_PROTOCOL___MTLComputeCommandEncoder))
      goto LABEL_4;
LABEL_45:
    LOBYTE(v15) = 0;
    goto LABEL_46;
  }
  if ((objc_msgSend(v13, "conformsToProtocol:", &OBJC_PROTOCOL___MTLRenderCommandEncoder) & 1) == 0)
    goto LABEL_45;
LABEL_4:
  v16 = 0;
  v17 = 1;
  do
  {
    v18 = *(_QWORD *)(a3 + 8 * v16);
    if (!v18 || ((*(_QWORD *)(a4 + 8 * (v16 >> 6)) >> v16) & 1) != 0)
      goto LABEL_7;
    Object = GTMTLSMContext_getObject(*a5, v18, a6);
    if (!Object)
      goto LABEL_33;
    if (*(_DWORD *)Object != 60)
    {
      if (*(_DWORD *)Object != 83)
        goto LABEL_7;
      v20 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(a7, Object[1]);
      if (v20)
      {
        v21 = (uint64_t *)(id)v20[3];
        switch(a1)
        {
          case 1u:
            objc_msgSend(v14, "setVertexVisibleFunctionTable:atBufferIndex:", v21, v16);
            break;
          case 2u:
            objc_msgSend(v14, "setFragmentVisibleFunctionTable:atBufferIndex:", v21, v16);
            break;
          case 4u:
            objc_msgSend(v14, "setTileVisibleFunctionTable:atBufferIndex:", v21, v16);
            break;
          case 8u:
            objc_msgSend(v14, "setVisibleFunctionTable:atBufferIndex:", v21, v16);
            break;
          default:
            goto LABEL_37;
        }
        goto LABEL_37;
      }
LABEL_33:
      v15 = 0;
      goto LABEL_8;
    }
    v22 = (int8x8_t)a7[6];
    if (!*(_QWORD *)&v22)
      goto LABEL_33;
    v23 = Object[1];
    v24 = (uint8x8_t)vcnt_s8(v22);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      v25 = Object[1];
      if (v23 >= *(_QWORD *)&v22)
        v25 = v23 % *(_QWORD *)&v22;
    }
    else
    {
      v25 = (*(_QWORD *)&v22 - 1) & v23;
    }
    v26 = *(uint64_t ****)(a7[5] + 8 * v25);
    if (!v26)
      goto LABEL_33;
    v27 = *v26;
    if (!v27)
      goto LABEL_33;
    while (1)
    {
      v28 = (unint64_t)v27[1];
      if (v23 == v28)
        break;
      if (v24.u32[0] > 1uLL)
      {
        if (v28 >= *(_QWORD *)&v22)
          v28 %= *(_QWORD *)&v22;
      }
      else
      {
        v28 &= *(_QWORD *)&v22 - 1;
      }
      if (v28 != v25)
        goto LABEL_33;
LABEL_31:
      v15 = 0;
      v27 = (uint64_t **)*v27;
      if (!v27)
        goto LABEL_8;
    }
    if (v27[2] != (uint64_t *)v23)
      goto LABEL_31;
    v21 = v27[3];
    switch(a1)
    {
      case 1u:
        objc_msgSend(v14, "setVertexIntersectionFunctionTable:atBufferIndex:", v21, v16);
        break;
      case 2u:
        objc_msgSend(v14, "setFragmentIntersectionFunctionTable:atBufferIndex:", v21, v16);
        break;
      case 4u:
        objc_msgSend(v14, "setTileIntersectionFunctionTable:atBufferIndex:", v21, v16);
        break;
      case 8u:
        objc_msgSend(v14, "setIntersectionFunctionTable:atBufferIndex:", v21, v16);
        break;
      default:
        break;
    }
LABEL_37:

LABEL_7:
    v15 = v17;
LABEL_8:
    ++v16;
    v17 = v15;
  }
  while (v16 != 31);
LABEL_46:

  return v15 & 1;
}

void sub_29B088(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id ObtainTracingComputePipelineState(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, unint64_t a5, apr_pool_t *a6)
{
  id v11;
  unint64_t v12;
  _QWORD *v13;
  void *v14;
  uint64_t v15;
  unint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *Object;
  uint64_t v21;
  void *v22;
  id v23;
  void *v24;
  uint64_t (*v25)(void);
  void *v26;
  uint64_t v27;
  void *v28;
  id v29;
  void *v30;
  id v31;
  id v32;
  id v34;
  void *v35;
  unsigned int v36;
  id *v37;
  unint64_t v38;
  _QWORD *v39;
  void *v40;
  uint64_t v41;
  void *v42;
  id v43;
  void *v44;
  unsigned int v45;
  void *v46;
  unint64_t v47;
  id v48;
  id v49;
  id v50;
  _QWORD v51[94];
  unint64_t *v52[26];
  id v53;
  _QWORD v54[2];

  v11 = a2;
  v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "defaultDevice"));
  v12 = *(_QWORD *)(a3 + 8);
  v54[0] = v12;
  v13 = (id)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>((uint64_t *)(a4 + 120), v12, v54)[3];
  v45 = SupportsGlobalRelocation(v46, a4);
  if (v13)
  {
LABEL_2:
    v13 = v13;
    v14 = v13;
    goto LABEL_20;
  }
  v15 = *(_QWORD *)(a4 + 248);
  v16 = (unint64_t)(v15 == 2) << 31;
  v17 = v15 == 1;
  v18 = 0x40000000;
  if (!v17)
    v18 = v16;
  v41 = v18;
  v19 = *(_QWORD *)(a3 + 48);
  if (!v19)
  {
    Object = (_QWORD *)a3;
    while (1)
    {
      v21 = Object[7];
      if (v21)
        break;
      Object = GTMTLSMContext_getObject(*a1, Object[5], Object[2]);
      v19 = Object[6];
      if (v19)
        goto LABEL_11;
    }
    v19 = *(_QWORD *)(v21 + 848);
  }
LABEL_11:
  v13 = (_QWORD *)GTMTLSMContext_lastObject(*a1, v19, a5);
  if (!v13)
  {
LABEL_19:
    v14 = 0;
    goto LABEL_20;
  }
  v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "computePipelineStateForKey:", *(_QWORD *)(a3 + 8)));
  v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "libraryForKey:", v13[5]));
  if (!v42)
  {

    v13 = 0;
    goto LABEL_19;
  }
  v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "functionMap"));
  v53 = 0;
  v23 = ObtainTracingFunction(v46, v42, a4, (uint64_t)v13, v22, (uint64_t)&v53);
  v13 = (_QWORD *)objc_claimAutoreleasedReturnValue(v23);
  v43 = v53;

  v24 = v13;
  if (v13)
  {
    v39 = v13;
    GTMTLSMComputePipelineState_computePipelineDescriptor(a1, a3, v51, a6);
    v25 = MakeMTLComputePipelineDescriptor;
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "computePipelineDescriptorMap"));
    v27 = ((uint64_t (*)(_QWORD *, void *))v25)(v51, v26);
    v28 = (void *)objc_claimAutoreleasedReturnValue(v27);

    v40 = v28;
    objc_msgSend(v28, "setComputeFunction:", v39);
    v29 = ObtainTracingLinkedFunctions((const GTMTLSMContext *)a1, v11, (GTMTLReplayAccessTracking *)a4, (uint64_t)v52, a5);
    v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
    objc_msgSend(v28, "setLinkedFunctions:", v30);

    if (v44)
      objc_msgSend(v28, "setMaxTotalThreadsPerThreadgroup:", objc_msgSend(v44, "maxTotalThreadsPerThreadgroup"));
    if (v45)
    {
      v50 = v43;
      v13 = objc_msgSend(v46, "newComputePipelineStateWithDescriptor:options:reflection:error:", v28, v41, 0, &v50);
      v31 = v50;

      v32 = 0;
      v43 = v31;
    }
    else
    {
      v48 = v43;
      v49 = 0;
      v13 = objc_msgSend(v46, "newComputePipelineStateWithDescriptor:options:reflection:error:", v28, v41 | 1, &v49, &v48);
      v32 = v49;
      v34 = v48;

      v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "bindings"));
      v36 = TraceBufferBindingIndex(v35, *(_DWORD *)(a4 + 256));

      v47 = *(_QWORD *)(a3 + 8);
      *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(a4, v47, &v47)+ 6) = v36;
      v43 = v34;
    }
    if (v13)
    {
      v37 = (id *)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>((uint64_t *)(a4 + 120), v12, v54);
      objc_storeStrong(v37 + 3, v13);
      if (*(_DWORD *)(a4 + 256) == 8)
      {
        v38 = *(_QWORD *)(a3 + 8);
        CreateComputeFunctionHandles(a4, v38, v52[2], (uint64_t)v52[3]);
        CreateComputeFunctionHandles(a4, v38, v52[0], (uint64_t)v52[1]);
      }
    }
    else
    {
      GTMTLReplay_handleNSError(v43);
    }

    v24 = v39;
  }
  v14 = v24;

  if (v14)
    goto LABEL_2;
LABEL_20:

  return v14;
}

void sub_29B4B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>(uint64_t *a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v5;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD **v9;
  _QWORD *i;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  int8x8_t prime;
  void *v19;
  void *v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  uint8x8_t v24;
  unint64_t v25;
  uint8x8_t v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  void *v34;

  v5 = a2;
  v7 = a1[1];
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(_QWORD ***)(*a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  v12 = a1 + 2;
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v5;
  i[2] = *a3;
  i[3] = 0;
  v13 = (float)(unint64_t)(a1[3] + 1);
  v14 = *((float *)a1 + 8);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    v5 = v3;
    goto LABEL_64;
  }
  v15 = 1;
  if (v7 >= 3)
    v15 = (v7 & (v7 - 1)) != 0;
  v16 = v15 | (2 * v7);
  v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17)
    prime = (int8x8_t)v17;
  else
    prime = (int8x8_t)v16;
  if (*(_QWORD *)&prime == 1)
  {
    prime = (int8x8_t)2;
  }
  else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
  {
    prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    v7 = a1[1];
  }
  if (*(_QWORD *)&prime <= v7)
  {
    if (*(_QWORD *)&prime >= v7)
      goto LABEL_60;
    v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
    if (v7 < 3 || (v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      v25 = std::__next_prime(v25);
    }
    else
    {
      v27 = 1 << -(char)__clz(v25 - 1);
      if (v25 >= 2)
        v25 = v27;
    }
    if (*(_QWORD *)&prime <= v25)
      prime = (int8x8_t)v25;
    if (*(_QWORD *)&prime >= v7)
    {
      v7 = a1[1];
      goto LABEL_60;
    }
    if (!*(_QWORD *)&prime)
    {
      v34 = (void *)*a1;
      *a1 = 0;
      if (v34)
        operator delete(v34);
      v7 = 0;
      a1[1] = 0;
      goto LABEL_60;
    }
  }
  if (*(_QWORD *)&prime >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  v19 = operator new(8 * *(_QWORD *)&prime);
  v20 = (void *)*a1;
  *a1 = (uint64_t)v19;
  if (v20)
    operator delete(v20);
  v21 = 0;
  a1[1] = (uint64_t)prime;
  do
    *(_QWORD *)(*a1 + 8 * v21++) = 0;
  while (*(_QWORD *)&prime != v21);
  v22 = (_QWORD *)*v12;
  if (*v12)
  {
    v23 = v22[1];
    v24 = (uint8x8_t)vcnt_s8(prime);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      if (v23 >= *(_QWORD *)&prime)
        v23 %= *(_QWORD *)&prime;
    }
    else
    {
      v23 &= *(_QWORD *)&prime - 1;
    }
    *(_QWORD *)(*a1 + 8 * v23) = v12;
    v28 = (_QWORD *)*v22;
    if (*v22)
    {
      do
      {
        v29 = v28[1];
        if (v24.u32[0] > 1uLL)
        {
          if (v29 >= *(_QWORD *)&prime)
            v29 %= *(_QWORD *)&prime;
        }
        else
        {
          v29 &= *(_QWORD *)&prime - 1;
        }
        if (v29 != v23)
        {
          if (!*(_QWORD *)(*a1 + 8 * v29))
          {
            *(_QWORD *)(*a1 + 8 * v29) = v22;
            goto LABEL_56;
          }
          *v22 = *v28;
          *v28 = **(_QWORD **)(*a1 + 8 * v29);
          **(_QWORD **)(*a1 + 8 * v29) = v28;
          v28 = v22;
        }
        v29 = v23;
LABEL_56:
        v22 = v28;
        v28 = (_QWORD *)*v28;
        v23 = v29;
      }
      while (v28);
    }
  }
  v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5)
      v5 %= v7;
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_64:
  v30 = *a1;
  v31 = *(_QWORD **)(*a1 + 8 * v5);
  if (v31)
  {
    *i = *v31;
LABEL_72:
    *v31 = i;
    goto LABEL_73;
  }
  *i = *v12;
  *v12 = i;
  *(_QWORD *)(v30 + 8 * v5) = v12;
  if (*i)
  {
    v32 = *(_QWORD *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7)
        v32 %= v7;
    }
    else
    {
      v32 &= v7 - 1;
    }
    v31 = (_QWORD *)(*a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return i;
}

void sub_29B978(_Unwind_Exception *a1)
{
  id *v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong}>,void *>>>::operator()[abi:nn180100](1, v1);
  _Unwind_Resume(a1);
}

void CreateComputeFunctionHandles(uint64_t a1, unint64_t a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t *v5;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  id v12;
  id v13;
  void *v14;
  id v15;
  id *v16;
  __int128 v17;
  unint64_t v18;
  unint64_t v19;

  if (a3)
  {
    v4 = a4;
    if (a4)
    {
      v5 = a3;
      v7 = a1 + 200;
      v8 = (uint64_t *)(a1 + 120);
      v9 = a1 + 160;
      do
      {
        v11 = *v5++;
        v10 = v11;
        v18 = v11;
        v19 = a2;
        *(_QWORD *)&v17 = a2;
        *((_QWORD *)&v17 + 1) = v11;
        v12 = (id)std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::__emplace_unique_key_args<FunctionHandleKey,std::piecewise_construct_t const&,std::tuple<FunctionHandleKey const&>,std::piecewise_construct_t const&<>>(v7, &v17, &v17)[4];
        if (!v12)
        {
          v13 = (id)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>(v8, a2, &v19)[3];
          if (v13)
          {
            v14 = v13;
            v15 = (id)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto11MTLFunction}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>(v9, v10, &v18)[3];
            if (v15)
            {
              v12 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "functionHandleWithFunction:", v15));
              if (v12)
              {
                v16 = (id *)std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::__emplace_unique_key_args<FunctionHandleKey,std::piecewise_construct_t const&,std::tuple<FunctionHandleKey const&>,std::piecewise_construct_t const&<>>(v7, &v17, &v17);
                objc_storeStrong(v16 + 4, v12);
              }
            }
            else
            {
              v12 = 0;
            }

          }
          else
          {
            v12 = 0;
          }
        }

        --v4;
      }
      while (v4);
    }
  }
}

void sub_29BABC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ReplaceFunctionTablesWithRegular(uint64_t a1, uint64_t a2, int a3, unint64_t a4, uint64_t *a5, apr_pool_t *p)
{
  uint64_t v9;
  apr_array_header_t *v10;
  apr_array_header_t *v11;
  int nelts;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  BOOL v17;
  unsigned __int8 v18;
  unint64_t v19;
  int v20;
  id v21;
  id v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *Object;
  void *v26;
  void *v27;
  id v28;
  void *v29;
  uint64_t v30;
  _QWORD *v31;
  void *v32;
  id *v33;
  int v34;
  uint64_t v35;
  const CATransform3D **v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  BOOL v40;
  unsigned __int8 v41;
  unint64_t v42;
  int v43;
  id v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  void *v48;
  void *v49;
  id v50;
  uint64_t *v51;
  uint64_t v52;
  _QWORD *v53;
  void *v54;
  const CATransform3D **v55;
  uint64_t *v56;
  id *v57;
  uint64_t *v58;
  uint64_t *v59;
  uint64_t v60;
  apr_pool_t *pa;
  id v62;
  unint64_t v64;
  _BYTE v66[40];
  _QWORD v67[5];
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;

  v59 = a5;
  v9 = *(_QWORD *)a2;
  v10 = apr_array_make(p, 5, 8);
  pa = p;
  v11 = apr_array_make(p, 5, 8);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v9 + 40) + 56), a4, v10);
  v64 = a4;
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(v9 + 40) + 64), a4, v11);
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_OWORD *)(a1 + 40) = 0u;
  v58 = (uint64_t *)(a1 + 40);
  *(_OWORD *)(a1 + 56) = 0u;
  v60 = a1;
  *(_DWORD *)(a1 + 72) = 1065353216;
  nelts = v10->nelts;
  if (nelts >= 1)
  {
    v13 = 0;
    while (1)
    {
      v14 = *(_QWORD *)&v10->elts[8 * v13];
      if (v14)
      {
        v15 = *(_QWORD *)(v14 + 16);
        v16 = *(_QWORD *)(v9 + 64);
        v17 = v16 <= v15 && *(_QWORD *)(v9 + 72) + v16 > v15;
        if (!v17 && ((a3 & 8) != 0 || !*(_QWORD *)(v14 + 120)))
        {
          if (!*(_QWORD *)(v14 + 128))
            break;
          HIDWORD(v19) = *(unsigned __int8 *)(v14 + 168);
          LODWORD(v19) = (HIDWORD(v19) << 24) - 0x2000000;
          v18 = v19 >> 25;
          v20 = v18 > 7u ? 1 : dword_4A87C8[v18];
          if ((v20 & a3) != 0)
            break;
        }
      }
LABEL_30:
      if (++v13 >= nelts)
        goto LABEL_31;
    }
    v21 = *(id *)(a2 + 8);
    v78 = 0u;
    v79 = 0u;
    v76 = 0u;
    v77 = 0u;
    v74 = 0u;
    v75 = 0u;
    v72 = 0u;
    v73 = 0u;
    v70 = 0u;
    v71 = 0u;
    v68 = 0u;
    v69 = 0u;
    GetVisibleFunctionTableState((uint64_t)&v68, v9, v14, v64, pa);
    v22 = objc_alloc_init((Class)MTLVisibleFunctionTableDescriptor);
    objc_msgSend(v22, "setFunctionCount:", **(_QWORD **)(v14 + 104), v58, v59);
    objc_msgSend(v22, "setResourceIndex:", *(_QWORD *)(*(_QWORD *)(v14 + 104) + 8));
    objc_msgSend(v22, "setForceResourceIndex:", 1);
    v23 = *(_QWORD *)(v14 + 128);
    if (v23)
    {
      v24 = *(unsigned __int8 *)(v14 + 168);
      Object = GTMTLSMContext_getObject(**(_QWORD **)(v9 + 40), v23, v64);
      if (Object)
      {
        v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "renderPipelineStateForKey:", Object[1]));
        v27 = v26;
        if (v26)
        {
          v28 = objc_msgSend(v26, "newVisibleFunctionTableWithDescriptor:stage:", v22, v24);
          v29 = v28;
          if (v28)
            goto LABEL_24;
          goto LABEL_25;
        }
      }
    }
    else
    {
      v30 = *(_QWORD *)(v14 + 120);
      if (v30)
      {
        v31 = GTMTLSMContext_getObject(**(_QWORD **)(v9 + 40), v30, v64);
        if (v31)
        {
          v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "computePipelineStateForKey:", v31[1]));
          v27 = v32;
          if (v32)
          {
            v28 = objc_msgSend(v32, "newVisibleFunctionTableWithDescriptor:", v22);
            v29 = v28;
            if (v28)
LABEL_24:
              SetupRegularVisibleFunctionTable(v28, *(uint64_t **)(v9 + 40), v21, (uint64_t)&v68, v64);
LABEL_25:

LABEL_27:
            if (v29)
            {
              *(_QWORD *)&v68 = *(_QWORD *)(v14 + 8);
              v33 = (id *)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::piecewise_construct_t const&<>>(v60, v68, &v68);
              objc_storeStrong(v33 + 3, v29);
              objc_msgSend(*(id *)(a2 + 8), "setVisibleFunctionTable:forKey:", v29, *(_QWORD *)(v14 + 8));
            }

            nelts = v10->nelts;
            goto LABEL_30;
          }
        }
      }
    }
    v29 = 0;
    goto LABEL_27;
  }
LABEL_31:
  v34 = v11->nelts;
  if (v34 >= 1)
  {
    v35 = 0;
    v36 = &CATransform3DIdentity_ptr;
    do
    {
      v37 = *(_QWORD *)&v11->elts[8 * v35];
      if (!v37)
        goto LABEL_61;
      v38 = *(_QWORD *)(v37 + 16);
      v39 = *(_QWORD *)(v9 + 64);
      v40 = v39 <= v38 && *(_QWORD *)(v9 + 72) + v39 > v38;
      if (v40 || (a3 & 8) == 0 && *(_QWORD *)(v37 + 120))
        goto LABEL_61;
      if (*(_QWORD *)(v37 + 128))
      {
        HIDWORD(v42) = *(unsigned __int8 *)(v37 + 160);
        LODWORD(v42) = (HIDWORD(v42) << 24) - 0x2000000;
        v41 = v42 >> 25;
        v43 = v41 > 7u ? 1 : dword_4A87C8[v41];
        if ((v43 & a3) == 0)
          goto LABEL_61;
      }
      std::unordered_map<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong}>::unordered_map((uint64_t)v66, v60);
      v62 = *(id *)(a2 + 8);
      v98 = 0u;
      v99 = 0u;
      v96 = 0u;
      v97 = 0u;
      v94 = 0u;
      v95 = 0u;
      v92 = 0u;
      v93 = 0u;
      v90 = 0u;
      v91 = 0u;
      v88 = 0u;
      v89 = 0u;
      v86 = 0u;
      v87 = 0u;
      v84 = 0u;
      v85 = 0u;
      v82 = 0u;
      v83 = 0u;
      v80 = 0u;
      v81 = 0u;
      v78 = 0u;
      v79 = 0u;
      v76 = 0u;
      v77 = 0u;
      v74 = 0u;
      v75 = 0u;
      v72 = 0u;
      v73 = 0u;
      v70 = 0u;
      v71 = 0u;
      v68 = 0u;
      v69 = 0u;
      GetIntersectionFunctionTableState(&v68, v9, v37, v64, v59, pa);
      v44 = objc_alloc_init((Class)v36[244]);
      objc_msgSend(v44, "setFunctionCount:", *(unsigned int *)(*(_QWORD *)(v37 + 104) + 8));
      objc_msgSend(v44, "setResourceIndex:", **(_QWORD **)(v37 + 104));
      objc_msgSend(v44, "setForceResourceIndex:", 1);
      v45 = *(_QWORD *)(v37 + 128);
      if (v45)
      {
        v46 = *(unsigned __int8 *)(v37 + 160);
        v47 = GTMTLSMContext_getObject(**(_QWORD **)(v9 + 40), v45, v64);
        if (!v47)
          goto LABEL_57;
        v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v62, "renderPipelineStateForKey:", v47[1]));
        v49 = v48;
        if (!v48)
          goto LABEL_57;
        v50 = objc_msgSend(v48, "newIntersectionFunctionTableWithDescriptor:stage:", v44, v46);
        if (v50)
        {
          v51 = *(uint64_t **)(v9 + 40);
          std::unordered_map<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong}>::unordered_map((uint64_t)v67, (uint64_t)v66);
          SetupRegularIntersectionFunctionTable(v50, v62, v51, v67, &v68, *(_QWORD *)(v37 + 128), v64);
LABEL_55:
          std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v67);
        }
      }
      else
      {
        v52 = *(_QWORD *)(v37 + 120);
        if (!v52
          || (v53 = GTMTLSMContext_getObject(**(_QWORD **)(v9 + 40), v52, v64)) == 0
          || (v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v62, "computePipelineStateForKey:", v53[1])),
              (v49 = v54) == 0))
        {
LABEL_57:
          v50 = 0;
          goto LABEL_58;
        }
        v55 = v36;
        v50 = objc_msgSend(v54, "newIntersectionFunctionTableWithDescriptor:", v44);
        if (v50)
        {
          v56 = *(uint64_t **)(v9 + 40);
          std::unordered_map<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong}>::unordered_map((uint64_t)v67, (uint64_t)v66);
          SetupRegularIntersectionFunctionTable(v50, v62, v56, v67, &v68, *(_QWORD *)(v37 + 120), v64);
          v36 = v55;
          goto LABEL_55;
        }
      }

LABEL_58:
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v66);
      if (v50)
      {
        *(_QWORD *)&v68 = *(_QWORD *)(v37 + 8);
        v57 = (id *)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::piecewise_construct_t const&<>>(v58, v68, &v68);
        objc_storeStrong(v57 + 3, v50);
        objc_msgSend(*(id *)(a2 + 8), "setIntersectionFunctionTable:forKey:", v50, *(_QWORD *)(v37 + 8));
      }

      v34 = v11->nelts;
LABEL_61:
      ++v35;
    }
    while (v35 < v34);
  }
}

void sub_29C0DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  void *v11;
  uint64_t v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)va1);

  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)va);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table(a2);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table(a4);
  _Unwind_Resume(a1);
}

DYMTLResourceUsageItem *MakeResourceUsageItem(uint64_t a1, uint64_t a2)
{
  DYMTLResourceUsageItem *v4;

  v4 = objc_alloc_init(DYMTLResourceUsageItem);
  -[DYMTLResourceUsageItem setStage:](v4, "setStage:", a2);
  -[DYMTLResourceUsageItem setKind:](v4, "setKind:", *(_QWORD *)(a1 + 8));
  -[DYMTLResourceUsageItem setResourceID:](v4, "setResourceID:", *(_QWORD *)a1);
  -[DYMTLResourceUsageItem setUsage:](v4, "setUsage:", *(unsigned __int8 *)(a1 + 16));
  return v4;
}

void sub_29C20C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

DYMTLResourceUsageItem *MakeResourceUsageItem(uint64_t a1)
{
  DYMTLResourceUsageItem *v2;

  v2 = objc_alloc_init(DYMTLResourceUsageItem);
  -[DYMTLResourceUsageItem setStage:](v2, "setStage:", 0);
  -[DYMTLResourceUsageItem setKind:](v2, "setKind:", *(_QWORD *)(a1 + 8));
  -[DYMTLResourceUsageItem setResourceID:](v2, "setResourceID:", *(_QWORD *)a1);
  -[DYMTLResourceUsageItem setUsage:](v2, "setUsage:", *(unsigned __int8 *)(a1 + 16));
  return v2;
}

void sub_29C278(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id ObtainResourceTrackingTracingBufferV2(void *a1, _QWORD *a2)
{
  id v3;
  id v4;

  v3 = a1;
  v4 = objc_msgSend(v3, "newBufferWithLength:options:", 24 * *(int *)(*a2 + 12)+ 16* (*(_DWORD *)(a2[2] + 48)+ *(_DWORD *)(a2[1] + 48)+ *(_DWORD *)(a2[3] + 48)+ *(_DWORD *)(a2[4] + 48)+ *(_DWORD *)(a2[5] + 48)+ *(_DWORD *)(a2[6] + 48)+ *(_DWORD *)(a2[7] + 48)+ 2 * *(_DWORD *)(a2[8] + 48))+ 64, 0);

  return v4;
}

void sub_29C324(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void InstrumentSubCommandWithAccessTrackingV2(uint64_t a1, GTMTLReplayController *a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t *a6, apr_pool_t *a7)
{
  unsigned int v8;
  unsigned int v15;
  GTMTLReplayDataSource *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  GTMTLReplayDataSource *var0;
  _QWORD *Object;
  GTMTLReplayDataSource *v32;
  id v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  void *v48;
  uint64_t v49;
  _QWORD *v50;
  _QWORD *v51;
  id v52;
  void *v53;
  id v54;
  id v55;
  id v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  uint64_t v62;
  id v63;
  id v64;
  id v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  uint64_t v71;
  uint64_t v72;
  __int128 v73;
  __int128 v74;
  uint64_t v75;
  _OWORD __dst[141];
  __int128 v77;
  __int128 v78;
  uint64_t v79;
  uint64_t v80;

  v8 = *(_DWORD *)(a3 + 8);
  if (v8 >> 2 != 1073737833)
    goto LABEL_9;
  v15 = v8 & 0xFFFFFFFE;
  if (v15 == -15964)
  {
    var0 = a2->var0;
    v63 = a2->var1;
    v75 = 0;
    v73 = 0u;
    v74 = 0u;
    GetExecuteCommandsInBufferArgs((uint64_t)&v73, a3, (uint64_t)var0->var2);
    Object = GTMTLSMContext_getObject(*(_QWORD *)var0->var5, v73, *(_QWORD *)a3);
    GTMTLCreateIndirectCommandEncoder((uint64_t)&v66, Object[13]);
    if (*((_QWORD *)&v73 + 1) > a4 || (_QWORD)v74 + *((_QWORD *)&v73 + 1) < a4)
      goto LABEL_36;
    GTMTLReplayController_debugSubCommandResume((unsigned int *)a2, *(_DWORD *)a3 - LODWORD(var0->var9.var0.var0) + 1, a4 + 1);
    v32 = a2->var0;
    v33 = a2->var1;
    v34 = *((_QWORD *)&v74 + 1) + v72 * a4;
    v35 = *(_QWORD *)(v34 + *((_QWORD *)&v66 + 1));
    if (v35 != 64 && v35 != 32)
    {
      if (!v35)
      {

LABEL_16:
        memset(__dst, 0, 88);
        RemapIndirectResources((uint64_t)__dst, (uint64_t)a6, v63, a7);
        PopulateResourceTrackingBufferV2(*(void **)(a5 + 240), __dst, v36, v37, v38, v39, v40, v41, (uint64_t)v54, v57, (uint64_t)v60, (uint64_t)v63, v66, v67, v68, v69);
        FlushCommandQueue(a2);
        DecodeResourceTrackingBufferV2((unint64_t *)&v77, *(void **)(a5 + 240), __dst, v42, v43, v44, v45, v46, (uint64_t)v56, v59, v62, (uint64_t)v65, v66, v67, v68, v69);
        *(_BYTE *)a1 = 1;
        *(_OWORD *)(a1 + 8) = v77;
        *(_QWORD *)(a1 + 24) = v78;
        goto LABEL_37;
      }

      goto LABEL_35;
    }
    v60 = v33;
    v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v33, "computeCommandEncoderForKey:", a2->var21.var0.var2));
    v48 = v47;
    if (v47)
    {
      objc_msgSend(v47, "useResource:usage:", *(_QWORD *)(a5 + 240), 3);
      v57 = v66;
      v49 = *(_BYTE *)(v66 + 11)
          ? a2->var21.var3.var0.var1[0]
          : GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier(a6[4], *(_QWORD *)(v34 + v67));
      if (v49)
      {
        v50 = GTMTLSMContext_getObject(*(_QWORD *)v32->var5, v49, *(_QWORD *)a3);
        if (v50)
        {
          v51 = v50;
          v52 = ObtainTracingComputePipelineState((uint64_t *)v32->var5, v60, (uint64_t)v50, a5, *(_QWORD *)a3, a7);
          v53 = (void *)objc_claimAutoreleasedReturnValue(v52);
          if (v53)
          {
            v54 = v53;
            ReplaceFunctionTablesWithInstrumented((uint64_t)&v77, (uint64_t)a2, a5, *(_QWORD *)a3, v51, a6, a7);
            std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v80);
            std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v77);
            if (*(_BYTE *)(v57 + 10))
            {
              objc_msgSend(v48, "setComputePipelineState:", v54);
              DYMTLDispatchComputeCommandEncoder(v48, (uint64_t)&v66, v34);
LABEL_31:

              goto LABEL_16;
            }
            memcpy(__dst, &a2->var21.var3, sizeof(__dst));
            if (GTMTLSMComputeCommandEncoder_loadIndirectCommand((uint64_t)&a2->var21.var3, &v66, v34, a6))
            {
              GTMTLReplayController_restoreComputeCommandEncoder(v48, (uint64_t)&a2->var21.var3, (uint64_t)__dst, v60);
              objc_msgSend(v48, "setComputePipelineState:", v54);
              DYMTLDispatchComputeCommandEncoder(v48, (uint64_t)&v66, v34);
              goto LABEL_31;
            }
            v53 = v54;
          }

        }
      }
    }

LABEL_35:
    FlushCommandQueue(a2);
LABEL_36:
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_BYTE *)a1 = 0;
    goto LABEL_37;
  }
  if (v15 != -15962)
  {
LABEL_9:
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_BYTE *)a1 = 0;
    return;
  }
  v16 = a2->var0;
  v63 = a2->var1;
  v79 = 0;
  v77 = 0u;
  v78 = 0u;
  GetExecuteCommandsInBufferArgs((uint64_t)&v77, a3, (uint64_t)v16->var2);
  v17 = GTMTLSMContext_getObject(*(_QWORD *)v16->var5, v77, *(_QWORD *)a3);
  GTMTLCreateIndirectCommandEncoder((uint64_t)__dst, v17[13]);
  if (*((_QWORD *)&v77 + 1) > a4 || (_QWORD)v78 + *((_QWORD *)&v77 + 1) < a4 || !*((_QWORD *)&v78 + 1))
    goto LABEL_21;
  GTMTLReplayController_debugSubCommandResume((unsigned int *)a2, *(_DWORD *)a3 - LODWORD(v16->var9.var0.var0) + 1, a4 + 1);
  if (!InstrumentRenderSubCommand((uint64_t)a2, (unint64_t *)a3, a4, __dst, a6, &v77, a5, a7))
  {
    FlushCommandQueue(a2);
LABEL_21:
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_BYTE *)a1 = 0;
    goto LABEL_37;
  }
  v71 = 0;
  v69 = 0u;
  v70 = 0u;
  v67 = 0u;
  v68 = 0u;
  v66 = 0u;
  RemapIndirectResources((uint64_t)&v66, (uint64_t)a6, v63, a7);
  PopulateResourceTrackingBufferV2(*(void **)(a5 + 240), &v66, v18, v19, v20, v21, v22, v23, (uint64_t)v54, v57, (uint64_t)v60, (uint64_t)v63, v66, v67, v68, v69);
  FlushCommandQueue(a2);
  DecodeResourceTrackingBufferV2((unint64_t *)&v73, *(void **)(a5 + 240), &v66, v24, v25, v26, v27, v28, (uint64_t)v55, v58, v61, (uint64_t)v64, v66, v67, v68, v69);
  v29 = v74;
  *(_BYTE *)a1 = 1;
  *(_OWORD *)(a1 + 8) = v73;
  *(_QWORD *)(a1 + 24) = v29;
LABEL_37:

}

void sub_29C7E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *a11, id a12)
{
  void *v12;

  _Unwind_Resume(a1);
}

void RemapIndirectResources(uint64_t a1, uint64_t a2, void *a3, apr_pool_t *a4)
{
  __int128 v7;
  apr_hash_t *v8;
  int v9;
  uint64_t v10;
  uint64_t i;
  uint64_t v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  id v21;
  apr_hash_t *v22;
  apr_hash_index_t *j;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  id v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  id v31;
  apr_hash_t *v32;
  apr_hash_index_t *k;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  id v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  id v41;
  apr_hash_t *v42;
  apr_hash_index_t *m;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  id v47;
  _QWORD *v48;
  uint64_t v49;
  uint64_t v50;
  id v51;
  apr_hash_t *v52;
  apr_hash_index_t *n;
  uint64_t v54;
  uint64_t v55;
  void *v56;
  id v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  id v61;
  apr_hash_t *v62;
  apr_hash_index_t *ii;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  id v67;
  _QWORD *v68;
  uint64_t v69;
  uint64_t v70;
  id v71;
  apr_hash_t *v72;
  apr_hash_index_t *jj;
  uint64_t v74;
  uint64_t v75;
  void *v76;
  id v77;
  _QWORD *v78;
  uint64_t v79;
  uint64_t v80;
  id v81;
  apr_hash_t *v82;
  apr_hash_index_t *kk;
  uint64_t v84;
  uint64_t v85;
  void *v86;
  id v87;
  _QWORD *v88;
  uint64_t v89;
  uint64_t v90;
  apr_hash_t *v91;
  apr_hash_index_t *mm;
  uint64_t v93;
  uint64_t v94;
  void *v95;
  id v96;
  _QWORD *v97;
  uint64_t v98;
  id v99;
  id v100[2];
  id v101;
  uint64_t (*v102)(__int128 *, __int128 *);

  v99 = a3;
  v7 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)v100 = *(_OWORD *)a2;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v7;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 48) = apr_hash_make(a4);
  *(_QWORD *)(a1 + 56) = apr_hash_make(a4);
  v8 = apr_hash_make(a4);
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 64) = v8;
  if ((GT_SUPPORT_0 & 0x80000) == 0)
  {
    v9 = *((_DWORD *)v100[0] + 3);
    if (v9 <= 0)
    {
      v14 = v9;
    }
    else
    {
      v10 = 0;
      for (i = 0; i < v9; ++i)
      {
        v12 = *((_QWORD *)v100[0] + 3);
        v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v99, "bufferForKey:", *(_QWORD *)(v12 + v10 + 16)));
        *(_QWORD *)(v12 + v10) = objc_msgSend(v13, "gpuAddress");

        v9 = *((_DWORD *)v100[0] + 3);
        v10 += 24;
      }
      v14 = v9;
    }
    v15 = *((_QWORD *)v100[0] + 3);
    v16 = v15 + 24 * (int)v14;
    v102 = (uint64_t (*)(__int128 *, __int128 *))CompareGTMTLGPUAddressResource;
    v17 = 126 - 2 * __clz(v14);
    if (v9)
      v18 = v17;
    else
      v18 = 0;
    std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*,false>(v15, v16, &v102, v18, 1);
  }
  v19 = g_enableIndexedResourceType;
  if ((g_enableIndexedResourceType & 1) == 0)
  {
    v20 = *(_QWORD *)(a2 + 8);
    v21 = v99;
    v22 = apr_hash_make(a4);
    *(_QWORD *)(v20 + 24) = 0;
    *(_QWORD *)(v20 + 32) = 0;
    *(_QWORD *)(v20 + 16) = v20;
    *(_DWORD *)(v20 + 40) = 0;
    for (j = apr_hash_next((apr_hash_index_t *)(v20 + 16)); j; j = apr_hash_next(j))
    {
      v24 = *(_QWORD *)(*((_QWORD *)j + 1) + 32);
      v25 = objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "resourceForKey:", *(_QWORD *)(v24 + 8)));
      v26 = (void *)v25;
      if (v25 && (objc_opt_respondsToSelector(v25, "uniqueIdentifier") & 1) != 0)
      {
        v27 = objc_msgSend(v26, "uniqueIdentifier");
        v28 = apr_palloc(a4, 0x20uLL);
        v29 = *(_QWORD *)(v24 + 8);
        *v28 = v27;
        v28[1] = v29;
        apr_hash_set(v22, v28, 8, v28);
      }

    }
    *(_QWORD *)(a1 + 8) = v22;
    v19 = g_enableIndexedResourceType;
  }
  if ((v19 & 2) == 0)
  {
    v30 = *(_QWORD *)(a2 + 16);
    v31 = v99;
    v32 = apr_hash_make(a4);
    *(_QWORD *)(v30 + 24) = 0;
    *(_QWORD *)(v30 + 32) = 0;
    *(_QWORD *)(v30 + 16) = v30;
    *(_DWORD *)(v30 + 40) = 0;
    for (k = apr_hash_next((apr_hash_index_t *)(v30 + 16)); k; k = apr_hash_next(k))
    {
      v34 = *(_QWORD *)(*((_QWORD *)k + 1) + 32);
      v35 = objc_claimAutoreleasedReturnValue(objc_msgSend(v31, "resourceForKey:", *(_QWORD *)(v34 + 8)));
      v36 = (void *)v35;
      if (v35 && (objc_opt_respondsToSelector(v35, "uniqueIdentifier") & 1) != 0)
      {
        v37 = objc_msgSend(v36, "uniqueIdentifier");
        v38 = apr_palloc(a4, 0x20uLL);
        v39 = *(_QWORD *)(v34 + 8);
        *v38 = v37;
        v38[1] = v39;
        apr_hash_set(v32, v38, 8, v38);
      }

    }
    *(_QWORD *)(a1 + 16) = v32;
    v19 = g_enableIndexedResourceType;
  }
  if ((v19 & 0x10) == 0)
  {
    v40 = *(_QWORD *)(a2 + 24);
    v41 = v99;
    v42 = apr_hash_make(a4);
    *(_QWORD *)(v40 + 24) = 0;
    *(_QWORD *)(v40 + 32) = 0;
    *(_QWORD *)(v40 + 16) = v40;
    *(_DWORD *)(v40 + 40) = 0;
    for (m = apr_hash_next((apr_hash_index_t *)(v40 + 16)); m; m = apr_hash_next(m))
    {
      v44 = *(_QWORD *)(*((_QWORD *)m + 1) + 32);
      v45 = objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "resourceForKey:", *(_QWORD *)(v44 + 8)));
      v46 = (void *)v45;
      if (v45 && (objc_opt_respondsToSelector(v45, "uniqueIdentifier") & 1) != 0)
      {
        v47 = objc_msgSend(v46, "uniqueIdentifier");
        v48 = apr_palloc(a4, 0x20uLL);
        v49 = *(_QWORD *)(v44 + 8);
        *v48 = v47;
        v48[1] = v49;
        apr_hash_set(v42, v48, 8, v48);
      }

    }
    *(_QWORD *)(a1 + 24) = v42;
    v50 = *(_QWORD *)(a2 + 32);
    v51 = v41;
    v52 = apr_hash_make(a4);
    *(_QWORD *)(v50 + 24) = 0;
    *(_QWORD *)(v50 + 32) = 0;
    *(_QWORD *)(v50 + 16) = v50;
    *(_DWORD *)(v50 + 40) = 0;
    for (n = apr_hash_next((apr_hash_index_t *)(v50 + 16)); n; n = apr_hash_next(n))
    {
      v54 = *(_QWORD *)(*((_QWORD *)n + 1) + 32);
      v55 = objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "resourceForKey:", *(_QWORD *)(v54 + 8)));
      v56 = (void *)v55;
      if (v55 && (objc_opt_respondsToSelector(v55, "uniqueIdentifier") & 1) != 0)
      {
        v57 = objc_msgSend(v56, "uniqueIdentifier");
        v58 = apr_palloc(a4, 0x20uLL);
        v59 = *(_QWORD *)(v54 + 8);
        *v58 = v57;
        v58[1] = v59;
        apr_hash_set(v52, v58, 8, v58);
      }

    }
    *(_QWORD *)(a1 + 32) = v52;
  }
  v60 = *(_QWORD *)(a2 + 40);
  v61 = v99;
  v62 = apr_hash_make(a4);
  *(_QWORD *)(v60 + 24) = 0;
  *(_QWORD *)(v60 + 32) = 0;
  *(_QWORD *)(v60 + 16) = v60;
  *(_DWORD *)(v60 + 40) = 0;
  for (ii = apr_hash_next((apr_hash_index_t *)(v60 + 16)); ii; ii = apr_hash_next(ii))
  {
    v64 = *(_QWORD *)(*((_QWORD *)ii + 1) + 32);
    v65 = objc_claimAutoreleasedReturnValue(objc_msgSend(v61, "resourceForKey:", *(_QWORD *)(v64 + 8)));
    v66 = (void *)v65;
    if (v65 && (objc_opt_respondsToSelector(v65, "uniqueIdentifier") & 1) != 0)
    {
      v67 = objc_msgSend(v66, "uniqueIdentifier");
      v68 = apr_palloc(a4, 0x20uLL);
      v69 = *(_QWORD *)(v64 + 8);
      *v68 = v67;
      v68[1] = v69;
      apr_hash_set(v62, v68, 8, v68);
    }

  }
  *(_QWORD *)(a1 + 40) = v62;
  v70 = *(_QWORD *)(a2 + 48);
  v71 = v61;
  v72 = apr_hash_make(a4);
  *(_QWORD *)(v70 + 24) = 0;
  *(_QWORD *)(v70 + 32) = 0;
  *(_QWORD *)(v70 + 16) = v70;
  *(_DWORD *)(v70 + 40) = 0;
  for (jj = apr_hash_next((apr_hash_index_t *)(v70 + 16)); jj; jj = apr_hash_next(jj))
  {
    v74 = *(_QWORD *)(*((_QWORD *)jj + 1) + 32);
    v75 = objc_claimAutoreleasedReturnValue(objc_msgSend(v71, "resourceForKey:", *(_QWORD *)(v74 + 8)));
    v76 = (void *)v75;
    if (v75 && (objc_opt_respondsToSelector(v75, "uniqueIdentifier") & 1) != 0)
    {
      v77 = objc_msgSend(v76, "uniqueIdentifier");
      v78 = apr_palloc(a4, 0x20uLL);
      v79 = *(_QWORD *)(v74 + 8);
      *v78 = v77;
      v78[1] = v79;
      apr_hash_set(v72, v78, 8, v78);
    }

  }
  *(_QWORD *)(a1 + 48) = v72;
  v80 = *(_QWORD *)(a2 + 56);
  v81 = v71;
  v82 = apr_hash_make(a4);
  *(_QWORD *)(v80 + 24) = 0;
  *(_QWORD *)(v80 + 32) = 0;
  *(_QWORD *)(v80 + 16) = v80;
  *(_DWORD *)(v80 + 40) = 0;
  for (kk = apr_hash_next((apr_hash_index_t *)(v80 + 16)); kk; kk = apr_hash_next(kk))
  {
    v84 = *(_QWORD *)(*((_QWORD *)kk + 1) + 32);
    v85 = objc_claimAutoreleasedReturnValue(objc_msgSend(v81, "resourceForKey:", *(_QWORD *)(v84 + 8)));
    v86 = (void *)v85;
    if (v85 && (objc_opt_respondsToSelector(v85, "uniqueIdentifier") & 1) != 0)
    {
      v87 = objc_msgSend(v86, "uniqueIdentifier");
      v88 = apr_palloc(a4, 0x20uLL);
      v89 = *(_QWORD *)(v84 + 8);
      *v88 = v87;
      v88[1] = v89;
      apr_hash_set(v82, v88, 8, v88);
    }

  }
  *(_QWORD *)(a1 + 56) = v82;
  v90 = *(_QWORD *)(a2 + 64);
  v101 = v81;
  v91 = apr_hash_make(a4);
  *(_QWORD *)(v90 + 24) = 0;
  *(_QWORD *)(v90 + 32) = 0;
  *(_QWORD *)(v90 + 16) = v90;
  *(_DWORD *)(v90 + 40) = 0;
  for (mm = apr_hash_next((apr_hash_index_t *)(v90 + 16)); mm; mm = apr_hash_next(mm))
  {
    v93 = *(_QWORD *)(*((_QWORD *)mm + 1) + 32);
    v94 = objc_claimAutoreleasedReturnValue(objc_msgSend(v101, "resourceForKey:", *(_QWORD *)(v93 + 8)));
    v95 = (void *)v94;
    if (v94 && (objc_opt_respondsToSelector(v94, "uniqueIdentifier") & 1) != 0)
    {
      v96 = objc_msgSend(v95, "uniqueIdentifier");
      v97 = apr_palloc(a4, 0x20uLL);
      v98 = *(_QWORD *)(v93 + 8);
      *v97 = v96;
      v97[1] = v98;
      apr_hash_set(v91, v97, 8, v97);
    }

  }
  *(_QWORD *)(a1 + 64) = v91;

}

void sub_29CF90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, id a11)
{

  _Unwind_Resume(a1);
}

void PopulateResourceTrackingBufferV2(void *a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, __int128 a13, __int128 a14, __int128 a15, __int128 a16)
{
  uint64_t v17;
  unint64_t v18;
  int v19;
  char *v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  char *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  unint64_t v34;
  __int128 v35;
  char *v36;
  unint64_t v37;
  uint64_t v38;
  __int128 *v39;
  uint64_t v40;
  __int128 *v41;
  int v42;
  __int128 *v43;
  uint64_t v44;
  apr_hash_index_t *v45;
  __int128 *v46;
  __int128 *v47;
  apr_hash_index_t *v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  _OWORD *v58;
  __int128 v59;
  __int128 v60;
  size_t v61;
  id v62;
  uint64_t (*vars0)(__int128 *, __int128 *);
  uint64_t vars8;

  v62 = a1;
  v17 = 0;
  a15 = 0u;
  a16 = 0u;
  a13 = 0u;
  a14 = 0u;
  LOBYTE(a13) = 2;
  v18 = *(int *)(*a2 + 12);
  v19 = *(_DWORD *)(a2[1] + 48);
  HIDWORD(vars8) = v19;
  DWORD1(a13) = v18;
  HIDWORD(a13) = v19;
  do
  {
    v19 += *(_DWORD *)((char *)&vars8 + v17 + 8);
    *(_DWORD *)((char *)&a13 + v17 + 16) = v19;
    v17 += 4;
  }
  while (v17 != 32);
  if ((_DWORD)v18)
  {
    if ((v18 & 0x80000000) != 0)
      abort();
    v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v18);
    v22 = v20;
    v23 = *a2;
    if (*(int *)(*a2 + 12) < 1)
    {
      v26 = v20;
    }
    else
    {
      v24 = 0;
      v25 = &v20[24 * v21];
      v26 = v20;
      do
      {
        v27 = (uint64_t *)(*(_QWORD *)(v23 + 24) + 24 * v24);
        v28 = *v27;
        v29 = v27[1] + *v27;
        if (v26 >= v25)
        {
          v30 = 0xAAAAAAAAAAAAAAABLL * ((v26 - v22) >> 3) + 1;
          if (v30 > 0xAAAAAAAAAAAAAAALL)
            abort();
          if (0x5555555555555556 * ((v25 - v22) >> 3) > v30)
            v30 = 0x5555555555555556 * ((v25 - v22) >> 3);
          if (0xAAAAAAAAAAAAAAABLL * ((v25 - v22) >> 3) >= 0x555555555555555)
            v31 = 0xAAAAAAAAAAAAAAALL;
          else
            v31 = v30;
          if (v31)
            v31 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v31);
          else
            v32 = 0;
          v33 = (_QWORD *)(v31 + 8 * ((v26 - v22) >> 3));
          *v33 = v28;
          v33[1] = v29;
          v33[2] = 0;
          if (v26 == v22)
          {
            v36 = (char *)(v31 + 8 * ((v26 - v22) >> 3));
          }
          else
          {
            v34 = v31 + 8 * ((v26 - v22) >> 3);
            do
            {
              v35 = *(_OWORD *)(v26 - 24);
              v36 = (char *)(v34 - 24);
              *(_QWORD *)(v34 - 8) = *((_QWORD *)v26 - 1);
              *(_OWORD *)(v34 - 24) = v35;
              v26 -= 24;
              v34 -= 24;
            }
            while (v26 != v22);
          }
          v25 = (char *)(v31 + 24 * v32);
          v26 = (char *)(v33 + 3);
          if (v22)
            operator delete(v22);
          v22 = v36;
        }
        else
        {
          *(_QWORD *)v26 = v28;
          *((_QWORD *)v26 + 1) = v29;
          *((_QWORD *)v26 + 2) = 0;
          v26 += 24;
        }
        ++v24;
        v23 = *a2;
      }
      while (v24 < *(int *)(*a2 + 12));
    }
  }
  else
  {
    v22 = 0;
    v26 = 0;
  }
  v37 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((v26 - v22) >> 3));
  if (v26 == v22)
    v38 = 0;
  else
    v38 = v37;
  std::__introsort<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *,false>((uint64_t)v22, (unint64_t)v26, v38, 1);
  v61 = v26 - v22;
  if (HIDWORD(a15))
  {
    v39 = (__int128 *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(HIDWORD(a15));
    v41 = &v39[v40];
  }
  else
  {
    v39 = 0;
    v41 = 0;
  }
  v42 = 0;
  v43 = v39;
  do
  {
    v44 = IndirectResourcesByTypeIndex(a2, v42);
    if (v44)
    {
      v45 = (apr_hash_index_t *)(v44 + 16);
      *(_QWORD *)(v44 + 24) = 0;
      *(_QWORD *)(v44 + 32) = 0;
      *(_QWORD *)(v44 + 16) = v44;
      v46 = v43;
      *(_DWORD *)(v44 + 40) = 0;
LABEL_39:
      v47 = v39;
      while (1)
      {
        v48 = apr_hash_next(v45);
        if (!v48)
          break;
        v45 = v48;
        v49 = **(_QWORD **)(*((_QWORD *)v48 + 1) + 32);
        if (v46 >= v41)
        {
          v50 = v46 - v47;
          v51 = v50 + 1;
          if ((unint64_t)(v50 + 1) >> 60)
            abort();
          if (((char *)v41 - (char *)v47) >> 3 > v51)
            v51 = ((char *)v41 - (char *)v47) >> 3;
          if ((unint64_t)((char *)v41 - (char *)v47) >= 0x7FFFFFFFFFFFFFF0)
            v52 = 0xFFFFFFFFFFFFFFFLL;
          else
            v52 = v51;
          if (v52)
            v52 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(v52);
          else
            v53 = 0;
          v54 = (_QWORD *)(v52 + 16 * v50);
          *v54 = v49;
          v54[1] = 0;
          if (v46 == v47)
          {
            v39 = (__int128 *)(v52 + 16 * v50);
          }
          else
          {
            v55 = 0;
            do
            {
              *(_OWORD *)&v54[v55 / 8 - 2] = v46[v55 / 0x10 - 1];
              v55 -= 16;
            }
            while (&v46[v55 / 0x10] != v47);
            v39 = (__int128 *)&v54[v55 / 8];
          }
          v41 = (__int128 *)(v52 + 16 * v53);
          v46 = (__int128 *)(v54 + 2);
          if (v47)
            operator delete(v47);
          goto LABEL_39;
        }
        *(_QWORD *)v46 = v49;
        *((_QWORD *)v46++ + 1) = 0;
      }
      v56 = 126 - 2 * __clz(v46 - v43);
      vars0 = (uint64_t (*)(__int128 *, __int128 *))CompareResourceTrackingTracingResourceEntryV2;
      if (v46 == v43)
        v57 = 0;
      else
        v57 = v56;
      std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*,false>(v43, v46, &vars0, v57, 1);
      v39 = v47;
      v43 = v46;
    }
    ++v42;
  }
  while (v42 != 9);
  if ((unint64_t)objc_msgSend(v62, "length") >= (char *)v43 - (char *)v39 + v61 + 64)
  {
    v58 = objc_msgSend(objc_retainAutorelease(v62), "contents");
    v59 = a14;
    *v58 = a13;
    v58[1] = v59;
    v60 = a16;
    v58[2] = a15;
    v58[3] = v60;
    memcpy(v58 + 4, v22, v61);
    memcpy((char *)v58 + v61 + 64, v39, (char *)v43 - (char *)v39);
  }
  if (v39)
    operator delete(v39);
  if (v22)
    operator delete(v22);

}

void sub_29D4CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18)
{
  void *v18;
  void *v19;

  if (v19)
    operator delete(v19);
  if (v18)
    operator delete(v18);

  _Unwind_Resume(a1);
}

void DecodeResourceTrackingBufferV2(unint64_t *a1, void *a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, __int128 a13, __int128 a14, __int128 a15, __int128 a16)
{
  id v17;
  _OWORD *v18;
  __int128 v19;
  __int128 v20;
  unint64_t v21;
  size_t v22;
  char *v23;
  char *v24;
  size_t v25;
  char *v26;
  char *v27;
  size_t v28;
  _DWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  _QWORD *v34;
  uint64_t v35;
  unint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  __int128 v46;
  unint64_t *v47;
  uint64_t v48;
  unint64_t *v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  int *v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  unint64_t v62;
  _QWORD *v63;
  _QWORD *v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  unint64_t v71;
  __int128 v72;
  id v73;
  unint64_t v74;
  char *__dst;
  unint64_t *vars8;
  unsigned int *v78;
  char *v79;
  uint64_t v80;

  v17 = a2;
  if (IsTraceBufferValidV2(v17))
  {
    v73 = v17;
    v18 = objc_msgSend(objc_retainAutorelease(v17), "contents");
    v19 = v18[1];
    a13 = *v18;
    a14 = v19;
    v20 = v18[3];
    a15 = v18[2];
    a16 = v20;
    v21 = HIDWORD(a15);
    v22 = 24 * DWORD1(a13);
    if (DWORD1(a13))
    {
      v23 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(DWORD1(a13));
      bzero(v23, 24 * ((v22 - 24) / 0x18) + 24);
      v24 = &v23[24 * ((v22 - 24) / 0x18) + 24];
      __dst = v23;
    }
    else
    {
      __dst = 0;
      v24 = 0;
    }
    v25 = 16 * v21;
    if ((_DWORD)v21)
    {
      v26 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(v21);
      bzero(v26, v25);
      v79 = &v26[v25];
    }
    else
    {
      v26 = 0;
      v79 = 0;
    }
    v27 = (char *)(v18 + 4);
    memcpy(__dst, v27, v22);
    v28 = v25;
    v29 = __dst;
    memcpy(v26, &v27[v22], v28);
    a1[1] = 0;
    a1[2] = 0;
    *a1 = 0;
    vars8 = a1;
    v30 = 0;
    if (v24 != __dst)
    {
      v31 = 0;
      if ((unint64_t)((v24 - __dst) / 24) <= 1)
        v32 = 1;
      else
        v32 = (v24 - __dst) / 24;
      do
      {
        v33 = v29[6 * v31 + 4];
        if (v33)
        {
          v34 = GTMTLGPUAddressResource_resourceForGPUAddress(*(_QWORD **)(*a3 + 24), *(int *)(*a3 + 12), *(_QWORD *)&v29[6 * v31]);
          if (v34)
          {
            v35 = v34[2];
            v36 = vars8[2];
            if ((unint64_t)v30 >= v36)
            {
              v38 = (_QWORD *)*vars8;
              v39 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v30 - *vars8) >> 3);
              v40 = v39 + 1;
              if (v39 + 1 > 0xAAAAAAAAAAAAAAALL)
                abort();
              v41 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v36 - (_QWORD)v38) >> 3);
              if (2 * v41 > v40)
                v40 = 2 * v41;
              if (v41 >= 0x555555555555555)
                v42 = 0xAAAAAAAAAAAAAAALL;
              else
                v42 = v40;
              if (v42)
                v42 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v42);
              else
                v43 = 0;
              v44 = v42 + 24 * v39;
              *(_QWORD *)v44 = v35;
              *(_QWORD *)(v44 + 8) = 60;
              *(_BYTE *)(v44 + 16) = v33;
              *(_DWORD *)(v44 + 17) = 0;
              *(_DWORD *)(v44 + 20) = 0;
              v45 = v44;
              if (v30 == v38)
              {
                v29 = __dst;
                v47 = vars8;
              }
              else
              {
                v29 = __dst;
                do
                {
                  v46 = *(_OWORD *)(v30 - 3);
                  *(_QWORD *)(v45 - 8) = *(v30 - 1);
                  *(_OWORD *)(v45 - 24) = v46;
                  v45 -= 24;
                  v30 -= 3;
                }
                while (v30 != v38);
                v47 = vars8;
                v30 = (_QWORD *)*vars8;
              }
              v37 = (_QWORD *)(v44 + 24);
              *v47 = v45;
              v47[1] = v44 + 24;
              v47[2] = v42 + 24 * v43;
              if (v30)
                operator delete(v30);
            }
            else
            {
              *v30 = v35;
              v30[1] = 60;
              *((_BYTE *)v30 + 16) = v33;
              *(_DWORD *)((char *)v30 + 17) = 0;
              v37 = v30 + 3;
              *((_DWORD *)v30 + 5) = 0;
              v29 = __dst;
            }
            vars8[1] = (unint64_t)v37;
            v30 = v37;
          }
        }
        ++v31;
      }
      while (v31 != v32);
    }
    v48 = 0;
    v49 = vars8;
    v74 = (v79 - v26) >> 4;
    do
    {
      v80 = ResourceKindByResourceTypeIndex[v48];
      v50 = IndirectResourcesByTypeIndex(a3, v48);
      if (v50)
      {
        v51 = *((unsigned int *)&a13 + v48++ + 2);
        v78 = (unsigned int *)&a13 + v48 + 2;
        v52 = *v78;
        if (v51 < v52)
        {
          v53 = v50;
          if (v74 <= v51)
            v54 = v51;
          else
            v54 = v74;
          do
          {
            if (v51 == v54)
              break;
            v55 = &v26[16 * v51];
            v57 = *((_DWORD *)v55 + 2);
            v56 = (int *)(v55 + 8);
            if (v57)
            {
              a12 = *(_QWORD *)&v26[16 * v51];
              v58 = *find_entry(v53, &a12, 8uLL, 0);
              if (v58)
              {
                v59 = *(_QWORD *)(v58 + 32);
                if (v59)
                {
                  v60 = *(_QWORD *)(v59 + 8);
                  v61 = *v56;
                  v62 = v49[2];
                  if ((unint64_t)v30 >= v62)
                  {
                    v64 = (_QWORD *)*v49;
                    v65 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v30 - *v49) >> 3);
                    v66 = v65 + 1;
                    if (v65 + 1 > 0xAAAAAAAAAAAAAAALL)
                      abort();
                    v67 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v62 - (_QWORD)v64) >> 3);
                    if (2 * v67 > v66)
                      v66 = 2 * v67;
                    if (v67 >= 0x555555555555555)
                      v68 = 0xAAAAAAAAAAAAAAALL;
                    else
                      v68 = v66;
                    if (v68)
                      v68 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v68);
                    else
                      v69 = 0;
                    v70 = v68 + 24 * v65;
                    *(_QWORD *)v70 = v60;
                    *(_QWORD *)(v70 + 8) = v80;
                    *(_BYTE *)(v70 + 16) = v61;
                    *(_DWORD *)(v70 + 17) = 0;
                    *(_DWORD *)(v70 + 20) = 0;
                    v71 = v70;
                    if (v30 == v64)
                    {
                      v49 = vars8;
                    }
                    else
                    {
                      v49 = vars8;
                      do
                      {
                        v72 = *(_OWORD *)(v30 - 3);
                        *(_QWORD *)(v71 - 8) = *(v30 - 1);
                        *(_OWORD *)(v71 - 24) = v72;
                        v71 -= 24;
                        v30 -= 3;
                      }
                      while (v30 != v64);
                      v30 = (_QWORD *)*vars8;
                    }
                    v63 = (_QWORD *)(v70 + 24);
                    *v49 = v71;
                    v49[1] = v70 + 24;
                    v49[2] = v68 + 24 * v69;
                    if (v30)
                      operator delete(v30);
                  }
                  else
                  {
                    *v30 = v60;
                    v30[1] = v80;
                    *((_BYTE *)v30 + 16) = v61;
                    *(_DWORD *)((char *)v30 + 17) = 0;
                    v63 = v30 + 3;
                    *((_DWORD *)v30 + 5) = 0;
                  }
                  v49[1] = (unint64_t)v63;
                  v52 = *v78;
                  v30 = v63;
                }
              }
            }
            ++v51;
          }
          while (v51 < v52);
        }
      }
      else
      {
        ++v48;
      }
    }
    while (v48 != 9);
    if (v26)
      operator delete(v26);
    if (__dst)
      operator delete(__dst);
    v17 = v73;
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }

}

void sub_29DA54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{

  _Unwind_Resume(a1);
}

BOOL IsTraceBufferValidV2(void *a1)
{
  id v1;
  void *v2;
  _BOOL8 v3;
  id v5;
  _DWORD *v6;
  unsigned int v7;
  uint64_t v8;

  v1 = a1;
  v2 = v1;
  if (v1 && !objc_msgSend(v1, "storageMode") && (unint64_t)objc_msgSend(v2, "length") >= 0x40)
  {
    v5 = objc_retainAutorelease(v2);
    v6 = objc_msgSend(v5, "contents");
    v7 = v6[1];
    v8 = v6[11];
    v3 = (unint64_t)objc_msgSend(v5, "length") >= 16 * v8 + 24 * (unint64_t)v7 + 64;
  }
  else
  {
    v3 = 0;
  }

  return v3;
}

void sub_29DB54(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t IndirectResourcesByTypeIndex(_QWORD *a1, int a2)
{
  uint64_t result;

  switch(a2)
  {
    case 0:
      result = a1[1];
      break;
    case 1:
      result = a1[2];
      break;
    case 2:
      result = a1[6];
      break;
    case 3:
      result = a1[7];
      break;
    case 4:
    case 5:
      result = a1[8];
      break;
    case 6:
      result = a1[3];
      break;
    case 7:
      result = a1[4];
      break;
    case 8:
      result = a1[5];
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *,false>(uint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  __int128 v31;
  BOOL v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  __int128 v37;
  unint64_t v38;
  unint64_t v39;
  __int128 v40;
  __int128 v41;
  __int128 *v42;
  __int128 *v43;
  __int128 *v44;
  __int128 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  __int128 v49;
  uint64_t v50;
  __int128 v51;
  unint64_t v52;
  BOOL v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int64_t v62;
  int64_t v63;
  int64_t v64;
  uint64_t v65;
  unint64_t *v66;
  unint64_t v67;
  BOOL v68;
  unint64_t *v69;
  unint64_t v70;
  unint64_t *v71;
  __int128 v72;
  uint64_t v73;
  unint64_t v74;
  unint64_t v75;
  int64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  __int128 v82;
  __int128 v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  __int128 v89;
  uint64_t v91;
  unint64_t v92;
  unint64_t v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;

BOOL CompareResourceTrackingTracingResourceEntryV2(_QWORD *a1, _QWORD *a2)
{
  return *a1 < *a2;
}

double std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*,false>(__int128 *a1, __int128 *a2, uint64_t (**a3)(__int128 *, __int128 *), uint64_t a4, char a5)
{
  __int128 *v10;
  uint64_t v11;
  unint64_t v12;
  __int128 *v13;
  __int128 *v14;
  __int128 *v15;
  __int128 *v16;
  __int128 *v17;
  __int128 *v18;
  __int128 v19;
  BOOL v20;
  double result;
  __int128 *v22;
  int v23;
  __int128 *v24;
  __int128 *v25;
  __int128 *v26;
  BOOL v28;
  uint64_t v29;
  __int128 *v30;
  __int128 *v31;
  uint64_t v32;
  __int128 *v33;
  int64_t v34;
  int64_t v35;
  uint64_t v36;
  __int128 *v37;
  __int128 *v38;
  __int128 *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int128 *v43;
  __int128 *v44;
  uint64_t v45;
  __int128 *v46;
  __int128 *v47;
  uint64_t v48;
  uint64_t v49;
  __int128 *v50;
  uint64_t v51;
  unint64_t v52;
  __int128 *v53;
  __int128 *v54;
  __int128 *v56;
  __int128 *v57;
  __int128 *v58;
  char v59;
  __int128 *v60;
  __int128 *v61;
  __int128 *v62;
  __int128 *v63;
  int64_t v64;
  __int128 v65;
  __int128 v66;

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>(__int128 *a1, __int128 *a2, __int128 *a3, uint64_t (**a4)(__int128 *, __int128 *))
{
  char v8;
  uint64_t result;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;

  v8 = (*a4)(a2, a1);
  result = (*a4)(a3, a2);
  if ((v8 & 1) != 0)
  {
    if ((_DWORD)result)
    {
      v10 = *a1;
      *a1 = *a3;
    }
    else
    {
      v13 = *a1;
      *a1 = *a2;
      *a2 = v13;
      result = (*a4)(a3, a2);
      if (!(_DWORD)result)
        return result;
      v10 = *a2;
      *a2 = *a3;
    }
    *a3 = v10;
  }
  else if ((_DWORD)result)
  {
    v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    result = (*a4)(a2, a1);
    if ((_DWORD)result)
    {
      v12 = *a1;
      *a1 = *a2;
      *a2 = v12;
    }
  }
  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>(__int128 *a1, __int128 *a2, __int128 *a3, __int128 *a4, uint64_t (**a5)(__int128 *, __int128 *))
{
  __n128 result;
  __int128 v11;
  __int128 v12;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>(a1, a2, a3, a5);
  if ((*a5)(a4, a3))
  {
    v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    if ((*a5)(a3, a2))
    {
      v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      if ((*a5)(a2, a1))
      {
        result = (__n128)*a1;
        *a1 = *a2;
        *a2 = (__int128)result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>(__int128 *a1, __int128 *a2, __int128 *a3, __int128 *a4, __int128 *a5, uint64_t (**a6)(__int128 *, __int128 *))
{
  __n128 v12;
  __n128 result;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  v12 = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>(a1, a2, a3, a4, a6);
  if (((unsigned int (*)(__int128 *, __int128 *, __n128))*a6)(a5, a4, v12))
  {
    v14 = *a4;
    *a4 = *a5;
    *a5 = v14;
    if ((*a6)(a4, a3))
    {
      v15 = *a3;
      *a3 = *a4;
      *a4 = v15;
      if ((*a6)(a3, a2))
      {
        v16 = *a2;
        *a2 = *a3;
        *a3 = v16;
        if ((*a6)(a2, a1))
        {
          result = (__n128)*a1;
          *a1 = *a2;
          *a2 = (__int128)result;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>(__int128 *a1, __int128 *a2, uint64_t (**a3)(__int128 *, __int128 *))
{
  uint64_t v6;
  _BOOL8 result;
  __int128 *v8;
  __int128 v9;
  __int128 *v10;
  __int128 *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  __int128 *v15;
  __int128 *v16;
  __int128 v17;

  v6 = a2 - a1;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v8 = a2 - 1;
      if ((*a3)(a2 - 1, a1))
      {
        v9 = *a1;
        *a1 = *v8;
        *v8 = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      v10 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>(a1, a1 + 1, a1 + 2, a3);
      v11 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(v11, v10))
    {
      v17 = *v11;
      v14 = v12;
      while (1)
      {
        v15 = (__int128 *)((char *)a1 + v14);
        *(__int128 *)((char *)a1 + v14 + 48) = *(__int128 *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v14 -= 16;
        if (((*a3)(&v17, v15 + 1) & 1) == 0)
        {
          v16 = (__int128 *)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v17;
      if (++v13 == 8)
        return v11 + 1 == a2;
    }
    v10 = v11;
    v12 += 16;
    if (++v11 == a2)
      return 1;
  }
}

__int128 *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>(__int128 *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  __int128 v6;
  unint64_t v7;
  unint64_t v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  __int128 v12;
  unint64_t v13;
  unint64_t v14;
  __int128 v15;
  unint64_t v16;
  unint64_t v17;

  v3 = *a2;
  v4 = *a3;
  if (*a2 >= *(_QWORD *)result)
  {
    if (v4 < v3)
    {
      v8 = a2[2];
      v9 = *(_OWORD *)a2;
      v10 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v10;
      *(_OWORD *)a3 = v9;
      a3[2] = v8;
      if (*a2 < *(_QWORD *)result)
      {
        v11 = *((_QWORD *)result + 2);
        v12 = *result;
        v13 = a2[2];
        *result = *(_OWORD *)a2;
        *((_QWORD *)result + 2) = v13;
        *(_OWORD *)a2 = v12;
        a2[2] = v11;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      v14 = *((_QWORD *)result + 2);
      v15 = *result;
      v16 = a2[2];
      *result = *(_OWORD *)a2;
      *((_QWORD *)result + 2) = v16;
      *(_OWORD *)a2 = v15;
      a2[2] = v14;
      if (*a3 >= *a2)
        return result;
      v5 = a2[2];
      v6 = *(_OWORD *)a2;
      v17 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v17;
    }
    else
    {
      v5 = *((_QWORD *)result + 2);
      v6 = *result;
      v7 = a3[2];
      *result = *(_OWORD *)a3;
      *((_QWORD *)result + 2) = v7;
    }
    *(_OWORD *)a3 = v6;
    a3[2] = v5;
  }
  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>(uint64_t a1, unint64_t *a2, unint64_t *a3, uint64_t a4)
{
  __n128 result;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>((__int128 *)a1, a2, a3);
  if (*(_QWORD *)a4 < *a3)
  {
    v9 = a3[2];
    result = *(__n128 *)a3;
    v10 = *(_QWORD *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    a3[2] = v10;
    *(__n128 *)a4 = result;
    *(_QWORD *)(a4 + 16) = v9;
    if (*a3 < *a2)
    {
      v11 = a2[2];
      result = *(__n128 *)a2;
      v12 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v12;
      *(__n128 *)a3 = result;
      a3[2] = v11;
      if (*a2 < *(_QWORD *)a1)
      {
        v13 = *(_QWORD *)(a1 + 16);
        result = *(__n128 *)a1;
        v14 = a2[2];
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_QWORD *)(a1 + 16) = v14;
        *(__n128 *)a2 = result;
        a2[2] = v13;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 *v18;
  __int128 *v19;
  __int128 *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  __int128 v31;
  __int128 v32;

  v4 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v6 = (__int128 *)(a2 - 24);
      if (*(_QWORD *)(a2 - 24) < *(_QWORD *)a1)
      {
        v7 = *(_QWORD *)(a1 + 16);
        v8 = *(_OWORD *)a1;
        v9 = *(_QWORD *)(a2 - 8);
        *(_OWORD *)a1 = *v6;
        *(_QWORD *)(a1 + 16) = v9;
        *v6 = v8;
        *(_QWORD *)(a2 - 8) = v7;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>((__int128 *)a1, (unint64_t *)(a1 + 24), (unint64_t *)(a2 - 24));
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>(a1, (unint64_t *)(a1 + 24), (unint64_t *)(a1 + 48), a2 - 24);
      return 1;
    case 5uLL:
      v18 = (__int128 *)(a1 + 24);
      v19 = (__int128 *)(a1 + 48);
      v20 = (__int128 *)(a1 + 72);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>(a1, (unint64_t *)(a1 + 24), (unint64_t *)(a1 + 48), a1 + 72);
      v22 = *(_QWORD *)(a2 - 24);
      v21 = a2 - 24;
      if (v22 < *(_QWORD *)(a1 + 72))
      {
        v23 = *(_QWORD *)(a1 + 88);
        v24 = *v20;
        v25 = *(_QWORD *)(v21 + 16);
        *v20 = *(_OWORD *)v21;
        *(_QWORD *)(a1 + 88) = v25;
        *(_OWORD *)v21 = v24;
        *(_QWORD *)(v21 + 16) = v23;
        if (*(_QWORD *)v20 < *(_QWORD *)v19)
        {
          v26 = *(_QWORD *)(a1 + 64);
          v27 = *v19;
          *v19 = *v20;
          *(_QWORD *)(a1 + 64) = *(_QWORD *)(a1 + 88);
          *v20 = v27;
          *(_QWORD *)(a1 + 88) = v26;
          if (*(_QWORD *)v19 < *(_QWORD *)v18)
          {
            v28 = *(_QWORD *)(a1 + 40);
            v29 = *v18;
            *v18 = *v19;
            *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 64);
            *v19 = v29;
            *(_QWORD *)(a1 + 64) = v28;
            if (*(_QWORD *)(a1 + 24) < *(_QWORD *)a1)
            {
              v30 = *(_QWORD *)(a1 + 16);
              v31 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *v18;
              *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 40);
              *v18 = v31;
              *(_QWORD *)(a1 + 40) = v30;
            }
          }
        }
      }
      return 1;
    default:
      v10 = (_QWORD *)(a1 + 48);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>((__int128 *)a1, (unint64_t *)(a1 + 24), (unint64_t *)(a1 + 48));
      v11 = a1 + 72;
      if (a1 + 72 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    v14 = *(_QWORD *)v11;
    if (*(_QWORD *)v11 < *v10)
    {
      v32 = *(_OWORD *)(v11 + 8);
      v15 = v12;
      while (1)
      {
        v16 = a1 + v15;
        *(_OWORD *)(v16 + 72) = *(_OWORD *)(a1 + v15 + 48);
        *(_QWORD *)(v16 + 88) = *(_QWORD *)(a1 + v15 + 64);
        if (v15 == -48)
          break;
        v15 -= 24;
        if (v14 >= *(_QWORD *)(v16 + 24))
        {
          v17 = a1 + v15 + 72;
          goto LABEL_13;
        }
      }
      v17 = a1;
LABEL_13:
      *(_QWORD *)v17 = v14;
      *(_OWORD *)(v17 + 8) = v32;
      if (++v13 == 8)
        return v11 + 24 == a2;
    }
    v10 = (_QWORD *)v11;
    v12 += 24;
    v11 += 24;
    if (v11 == a2)
      return 1;
  }
}

BOOL CompareGTMTLGPUAddressResource(_QWORD *a1, _QWORD *a2)
{
  return *a1 < *a2;
}

double std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*,false>(uint64_t a1, unint64_t a2, uint64_t (**a3)(__int128 *, __int128 *), uint64_t a4, char a5)
{
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 *v18;
  uint64_t v19;
  __int128 *v20;
  unint64_t v21;
  __int128 *v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  BOOL v28;
  __int128 v29;
  __int128 v30;
  __int128 *v31;
  int v32;
  unint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 *v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 *v41;
  BOOL v43;
  uint64_t v44;
  unint64_t v45;
  __int128 *v46;
  __int128 v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int64_t v51;
  int64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  __int128 v56;
  uint64_t v57;
  __int128 v58;
  uint64_t v59;
  uint64_t v60;
  __int128 v61;
  int64_t v62;
  unint64_t v63;
  uint64_t v64;
  __int128 v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  __int128 v70;
  __int128 *v71;
  __int128 v72;
  uint64_t v73;
  unint64_t v74;
  unint64_t v75;
  __int128 v76;
  uint64_t v77;
  __int128 v78;
  __int128 *v80;
  __int128 v81;
  uint64_t v82;
  uint64_t v83;
  char v84;
  __int128 *v86;
  __int128 *v87;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  int64_t v91;
  __int128 v92;
  uint64_t v93;
  __int128 v94;
  uint64_t v95;

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>(__int128 *a1, __int128 *a2, __int128 *a3, uint64_t (**a4)(__int128 *, __int128 *))
{
  char v8;
  uint64_t result;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;

  v8 = (*a4)(a2, a1);
  result = (*a4)(a3, a2);
  if ((v8 & 1) != 0)
  {
    if ((_DWORD)result)
    {
      v10 = *((_QWORD *)a1 + 2);
      v11 = *a1;
      v12 = *((_QWORD *)a3 + 2);
      *a1 = *a3;
      *((_QWORD *)a1 + 2) = v12;
    }
    else
    {
      v19 = *((_QWORD *)a1 + 2);
      v20 = *a1;
      v21 = *((_QWORD *)a2 + 2);
      *a1 = *a2;
      *((_QWORD *)a1 + 2) = v21;
      *a2 = v20;
      *((_QWORD *)a2 + 2) = v19;
      result = (*a4)(a3, a2);
      if (!(_DWORD)result)
        return result;
      v10 = *((_QWORD *)a2 + 2);
      v11 = *a2;
      v22 = *((_QWORD *)a3 + 2);
      *a2 = *a3;
      *((_QWORD *)a2 + 2) = v22;
    }
    *a3 = v11;
    *((_QWORD *)a3 + 2) = v10;
  }
  else if ((_DWORD)result)
  {
    v13 = *((_QWORD *)a2 + 2);
    v14 = *a2;
    v15 = *((_QWORD *)a3 + 2);
    *a2 = *a3;
    *((_QWORD *)a2 + 2) = v15;
    *a3 = v14;
    *((_QWORD *)a3 + 2) = v13;
    result = (*a4)(a2, a1);
    if ((_DWORD)result)
    {
      v16 = *((_QWORD *)a1 + 2);
      v17 = *a1;
      v18 = *((_QWORD *)a2 + 2);
      *a1 = *a2;
      *((_QWORD *)a1 + 2) = v18;
      *a2 = v17;
      *((_QWORD *)a2 + 2) = v16;
    }
  }
  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (**a5)(__int128 *, __int128 *))
{
  __n128 result;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>((__int128 *)a1, (__int128 *)a2, (__int128 *)a3, a5);
  if ((*a5)((__int128 *)a4, (__int128 *)a3))
  {
    v11 = *(_QWORD *)(a3 + 16);
    v12 = *(_OWORD *)a3;
    v13 = *(_QWORD *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_QWORD *)(a3 + 16) = v13;
    *(_OWORD *)a4 = v12;
    *(_QWORD *)(a4 + 16) = v11;
    if ((*a5)((__int128 *)a3, (__int128 *)a2))
    {
      v14 = *(_QWORD *)(a2 + 16);
      v15 = *(_OWORD *)a2;
      v16 = *(_QWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_QWORD *)(a2 + 16) = v16;
      *(_OWORD *)a3 = v15;
      *(_QWORD *)(a3 + 16) = v14;
      if ((*a5)((__int128 *)a2, (__int128 *)a1))
      {
        v17 = *(_QWORD *)(a1 + 16);
        result = *(__n128 *)a1;
        v18 = *(_QWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_QWORD *)(a1 + 16) = v18;
        *(__n128 *)a2 = result;
        *(_QWORD *)(a2 + 16) = v17;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (**a6)(__int128 *, __int128 *))
{
  __n128 v12;
  __n128 result;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  __n128 v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;

  v12 = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>((uint64_t)a1, a2, a3, a4, a6);
  if (((unsigned int (*)(uint64_t, uint64_t, __n128))*a6)(a5, a4, v12))
  {
    v14 = *(_QWORD *)(a4 + 16);
    v15 = *(_OWORD *)a4;
    v16 = *(_QWORD *)(a5 + 16);
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_QWORD *)(a4 + 16) = v16;
    *(_OWORD *)a5 = v15;
    *(_QWORD *)(a5 + 16) = v14;
    if ((*a6)((__int128 *)a4, (__int128 *)a3))
    {
      v17 = *(_QWORD *)(a3 + 16);
      v18 = *(_OWORD *)a3;
      v19 = *(_QWORD *)(a4 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_QWORD *)(a3 + 16) = v19;
      *(_OWORD *)a4 = v18;
      *(_QWORD *)(a4 + 16) = v17;
      if ((*a6)((__int128 *)a3, (__int128 *)a2))
      {
        v20 = *(_QWORD *)(a2 + 16);
        v21 = *(__n128 *)a2;
        v22 = *(_QWORD *)(a3 + 16);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_QWORD *)(a2 + 16) = v22;
        *(__n128 *)a3 = v21;
        *(_QWORD *)(a3 + 16) = v20;
        if ((*a6)((__int128 *)a2, (__int128 *)a1))
        {
          v23 = a1[1].n128_u64[0];
          result = *a1;
          v24 = *(_QWORD *)(a2 + 16);
          *a1 = *(__n128 *)a2;
          a1[1].n128_u64[0] = v24;
          *(__n128 *)a2 = result;
          *(_QWORD *)(a2 + 16) = v23;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>(uint64_t a1, uint64_t a2, uint64_t (**a3)(__int128 *, __int128 *))
{
  unint64_t v6;
  _BOOL8 result;
  __int128 *v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  __int128 *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;

  v6 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
  result = 1;
  switch(v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v8 = (__int128 *)(a2 - 24);
      if ((*a3)((__int128 *)(a2 - 24), (__int128 *)a1))
      {
        v9 = *(_QWORD *)(a1 + 16);
        v10 = *(_OWORD *)a1;
        v11 = *(_QWORD *)(a2 - 8);
        *(_OWORD *)a1 = *v8;
        *(_QWORD *)(a1 + 16) = v11;
        *v8 = v10;
        *(_QWORD *)(a2 - 8) = v9;
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>((__int128 *)a1, (__int128 *)(a1 + 24), (__int128 *)(a2 - 24), a3);
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>(a1, a1 + 24, a1 + 48, a2 - 24, a3);
      return 1;
    case 5uLL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>((__n128 *)a1, a1 + 24, a1 + 48, a1 + 72, a2 - 24, a3);
      return 1;
    default:
      v12 = (__int128 *)(a1 + 48);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>((__int128 *)a1, (__int128 *)(a1 + 24), (__int128 *)(a1 + 48), a3);
      v13 = a1 + 72;
      if (a1 + 72 == a2)
        return 1;
      v14 = 0;
      v15 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)((__int128 *)v13, v12))
    {
      v19 = *(_OWORD *)v13;
      v20 = *(_QWORD *)(v13 + 16);
      v16 = v14;
      while (1)
      {
        v17 = a1 + v16;
        *(_OWORD *)(v17 + 72) = *(_OWORD *)(a1 + v16 + 48);
        *(_QWORD *)(v17 + 88) = *(_QWORD *)(a1 + v16 + 64);
        if (v16 == -48)
          break;
        v16 -= 24;
        if (((*a3)(&v19, (__int128 *)(v17 + 24)) & 1) == 0)
        {
          v18 = a1 + v16 + 72;
          goto LABEL_12;
        }
      }
      v18 = a1;
LABEL_12:
      *(_OWORD *)v18 = v19;
      *(_QWORD *)(v18 + 16) = v20;
      if (++v15 == 8)
        return v13 + 24 == a2;
    }
    v12 = (__int128 *)v13;
    v14 += 24;
    v13 += 24;
    if (v13 == a2)
      return 1;
  }
}

void SetupRegularVisibleFunctionTable(void *a1, uint64_t *a2, void *a3, uint64_t a4, unint64_t a5)
{
  id v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *Object;
  void *v13;
  id v14;

  v14 = a1;
  v9 = a3;
  if (*(_QWORD *)(a4 + 184))
  {
    v10 = 0;
    do
    {
      v11 = *(_QWORD *)(*(_QWORD *)(a4 + 176) + 8 * v10);
      if (v11)
      {
        Object = GTMTLSMContext_getObject(*a2, v11, a5);
        if (Object)
        {
          v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "functionHandleForKey:", Object[1]));
          objc_msgSend(v14, "setFunction:atIndex:", v13, v10);

        }
      }
      else
      {
        objc_msgSend(v14, "setFunction:atIndex:", 0, v10);
      }
      ++v10;
    }
    while (*(_QWORD *)(a4 + 184) > v10);
  }

}

void sub_2A03D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void SetupRegularIntersectionFunctionTable(void *a1, void *a2, uint64_t *a3, _QWORD *a4, _QWORD *a5, uint64_t a6, unint64_t a7)
{
  id v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  _QWORD *Object;
  void *v20;
  uint64_t v21;
  _QWORD *v22;
  int v23;
  id v24;
  _QWORD *v25;
  id v26;

  v26 = a1;
  v13 = a2;
  if (a5[22])
  {
    v14 = 0;
    v15 = 0;
    do
    {
      v16 = a5[21];
      v17 = *(_DWORD *)(v16 + v14);
      switch(v17)
      {
        case 3:
          objc_msgSend(v26, "setOpaqueCurveIntersectionFunctionWithSignature:atIndex:", *(_QWORD *)(v16 + v14 + 8), v15);
          break;
        case 2:
          objc_msgSend(v26, "setOpaqueTriangleIntersectionFunctionWithSignature:atIndex:", *(_QWORD *)(v16 + v14 + 8), v15);
          break;
        case 1:
          v18 = *(_QWORD *)(v16 + v14 + 8);
          if (v18)
          {
            Object = GTMTLSMContext_getObject(*a3, v18, a7);
            if (Object && (Object[7] == a6 || Object[6] == a6))
            {
              v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "functionHandleForKey:", Object[1]));
              objc_msgSend(v26, "setFunction:atIndex:", v20, v15);

            }
          }
          else
          {
            objc_msgSend(v26, "setFunction:atIndex:", 0, v15);
          }
          break;
      }
      ++v15;
      v14 += 16;
    }
    while (a5[22] > v15);
  }
  v21 = 0;
  v22 = a5 + 25;
  do
  {
    v23 = *((_DWORD *)v22 - 4);
    if (v23 == 2)
    {
      v25 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(a4, *(v22 - 1));
      if (!v25)
        goto LABEL_22;
      v24 = (id)v25[3];
      objc_msgSend(v26, "setVisibleFunctionTable:atBufferIndex:", v24, v21);
    }
    else
    {
      if (v23 != 1)
        goto LABEL_22;
      v24 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "bufferForKey:", *(v22 - 1)));
      objc_msgSend(v26, "setBuffer:offset:atIndex:", v24, *v22, v21);
    }

LABEL_22:
    ++v21;
    v22 += 3;
  }
  while (v21 != 31);

}

void sub_2A05DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

uint64_t GTMTLReplayClient_generateFunctionResourceUsageInfoV2(unsigned int *a1, unint64_t a2, unint64_t a3, _QWORD *a4)
{
  uint64_t v4;
  _DWORD *v8;

  *a4 = &__NSArray0__struct;
  v4 = *(_QWORD *)(*(_QWORD *)a1 + 120);
  if (*(int *)(v4 + 12) <= a2)
    return 0;
  v8 = (_DWORD *)(*(_QWORD *)(v4 + 24) + (a2 << 6));
  GTMTLReplayController_debugSubCommandResume(a1, *v8 - *(_DWORD *)(*(_QWORD *)a1 + 80) + 1, a3 + 1);
  return GTMTLReplayClient_generateFunctionResourceUsageInfoV2_impl((GTMTLReplayController *)a1, (uint64_t)v8, a3, a4);
}

uint64_t GTMTLReplayClient_generateFunctionResourceUsageInfoV2_impl(GTMTLReplayController *a1, uint64_t a2, unint64_t a3, _QWORD *a4)
{
  GTMTLReplayDataSource *var0;
  void *v5;
  id v6;
  apr_allocator_t *v7;
  unint64_t v8;
  apr_pool_t *v9;
  GTMTLSMContext *var5;
  apr_array_header_t *v11;
  apr_array_header_t *v12;
  int nelts;
  GTMTLReplayController *v14;
  apr_array_header_t *v15;
  uint64_t i;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  int8x16_t *v21;
  apr_array_header_t *v22;
  int v23;
  apr_array_header_t *v24;
  uint64_t j;
  _QWORD *v26;
  unint64_t v27;
  unint64_t v28;
  _QWORD *v30;
  apr_array_header_t *v31;
  int v32;
  apr_array_header_t *v33;
  uint64_t k;
  _QWORD *v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v39;
  _QWORD *v40;
  apr_array_header_t *v41;
  int v42;
  apr_array_header_t *v43;
  uint64_t m;
  _QWORD *v45;
  unint64_t v46;
  unint64_t v47;
  BOOL v48;
  _QWORD *v49;
  apr_array_header_t *v50;
  int v51;
  apr_array_header_t *v52;
  uint64_t n;
  _QWORD *v54;
  unint64_t v55;
  unint64_t v56;
  BOOL v57;
  _QWORD *v58;
  apr_array_header_t *v59;
  int v60;
  apr_array_header_t *v61;
  uint64_t ii;
  _QWORD *v63;
  unint64_t v64;
  unint64_t v65;
  _QWORD *v67;
  apr_array_header_t *v68;
  int v69;
  apr_array_header_t *v70;
  uint64_t jj;
  _QWORD *v72;
  unint64_t v73;
  unint64_t v74;
  _QWORD *v76;
  apr_array_header_t *v77;
  int v78;
  apr_array_header_t *v79;
  uint64_t kk;
  _QWORD *v81;
  unint64_t v82;
  unint64_t v83;
  _QWORD *v85;
  apr_array_header_t *v86;
  int v87;
  apr_array_header_t *v88;
  uint64_t mm;
  _QWORD *v90;
  unint64_t v91;
  unint64_t v92;
  _QWORD *v94;
  void *v95;
  int v96;
  void *v97;
  id v98;
  int v99;
  GTMTLReplayDataSource *v100;
  _QWORD *Object;
  uint64_t v102;
  uint64_t i1;
  _BOOL4 v104;
  _BYTE *v105;
  _BYTE *v106;
  uint64_t v107;
  int v108;
  uint64_t nn;
  apr_pool_t *v110;
  _BYTE *v111;
  _BYTE *v112;
  _BYTE *v113;
  _BYTE *v114;
  uint64_t i2;
  _BOOL4 v116;
  uint64_t v117;
  uint64_t i3;
  BOOL v119;
  char v120;
  _BYTE *v121;
  id v122;
  _QWORD *v123;
  __int128 v124;
  DYMTLResourceUsageItem *ResourceUsageItem;
  void *v126;
  _QWORD *v127;
  DYMTLResourceUsageItem *v128;
  void *v129;
  _QWORD *v130;
  DYMTLResourceUsageItem *v131;
  void *v132;
  _QWORD *v133;
  DYMTLResourceUsageItem *v134;
  void *v135;
  uint64_t i10;
  void *v137;
  id v138;
  apr_pool_t *v139;
  id v140;
  _QWORD *v141;
  _QWORD *v142;
  _QWORD *v143;
  DYMTLResourceUsageItem *v144;
  void *v145;
  uint64_t i4;
  void *v147;
  id v148;
  apr_pool_t *v149;
  id v150;
  _QWORD *v151;
  _QWORD *v152;
  _QWORD *v153;
  DYMTLResourceUsageItem *v154;
  void *v155;
  id v156;
  void *v158;
  id v159;
  void *v160;
  GTMTLReplayDataSource *v161;
  id v162;
  _QWORD *v163;
  unint64_t v164;
  uint64_t i6;
  _BOOL4 v166;
  void *v167;
  void *v168;
  uint64_t i5;
  void *v170;
  id v171;
  apr_pool_t *v172;
  id v173;
  _QWORD *v174;
  _QWORD *v175;
  _QWORD *v176;
  DYMTLResourceUsageItem *v177;
  void *v178;
  uint64_t i8;
  apr_pool_t *v180;
  _BYTE *v181;
  _BYTE *v182;
  int v183;
  void *v184;
  uint64_t v185;
  uint64_t i9;
  _BYTE *v187;
  _BYTE *v188;
  BOOL v189;
  _QWORD *v190;
  DYMTLResourceUsageItem *v191;
  void *v192;
  _QWORD *v193;
  DYMTLResourceUsageItem *v194;
  void *v195;
  uint64_t i7;
  _BYTE *v197;
  _BYTE *v198;
  int v199;
  void *v200;
  void *context;
  _BYTE *v203;
  _BYTE *__p;
  void *__pa;
  _BYTE v209[40];
  uint64_t v210;
  _BYTE v211[40];
  uint64_t v212;
  _BYTE v213[40];
  uint64_t v214;
  _BYTE v215[40];
  uint64_t v216;
  _BYTE v217[40];
  uint64_t v218;
  __int128 v219;
  __int128 v220;
  int v221;
  __int128 v222;
  __int128 v223;
  int v224;
  __int128 v225;
  __int128 v226;
  int v227;
  __int128 v228;
  __int128 v229;
  int v230;
  __int128 v231;
  __int128 v232;
  int v233;
  _OWORD v234[5];
  uint64_t v235;
  apr_pool_t *newpool;
  __int128 v237;
  __int128 v238;
  uint64_t v239;
  uint64_t v240;
  _BYTE v241[40];
  uint64_t v242;
  _BYTE v243[40];
  uint64_t v244;
  _BYTE v245[40];
  uint64_t v246;
  _BYTE v247[40];
  __int128 v248;
  _BYTE v249[24];
  __int128 v250;
  __int128 v251;
  int v252;
  _QWORD v253[5];
  __int128 v254;
  __int128 v255;
  int v256;
  __int128 v257;
  __int128 v258;
  int v259;
  __int128 v260;
  __int128 v261;
  int v262;
  id v263;
  uint64_t v264;
  uint64_t v265;

  var0 = a1->var0;
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1->var1, "defaultDevice"));
  v6 = objc_msgSend(v5, "argumentBuffersSupport");

  if (!v6)
    return 0;
  newpool = 0;
  apr_pool_create_ex(&newpool, 0, 0, v7);
  v235 = 0;
  memset(v234, 0, sizeof(v234));
  v8 = *(_QWORD *)a2;
  v9 = newpool;
  var5 = var0->var5;
  v11 = apr_array_make(newpool, 32, 8);
  v251 = 0u;
  v250 = 0u;
  *(_OWORD *)&v249[8] = 0u;
  v11->nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 1), v8, v11);
  v12 = apr_array_make(v9, v11->nelts, 24);
  *(_QWORD *)&v248 = v12;
  nelts = v11->nelts;
  v14 = a1;
  if (nelts >= 1)
  {
    v15 = v12;
    for (i = 0; i < nelts; ++i)
    {
      v17 = *(_QWORD *)&v11->elts[8 * i];
      v18 = *(_QWORD *)(v17 + 16);
      v19 = var0->var8.var0;
      if (v19 > v18 || var0->var8.var1 + v19 <= v18)
      {
        v21 = (int8x16_t *)apr_array_push(v15);
        *v21 = vextq_s8(*(int8x16_t *)(v17 + 104), *(int8x16_t *)(v17 + 104), 8uLL);
        v21[1].i64[0] = *(_QWORD *)(v17 + 8);
        nelts = v11->nelts;
      }
    }
  }
  v11->nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 2), v8, v11);
  v22 = apr_array_make(v9, v11->nelts, 32);
  *((_QWORD *)&v248 + 1) = v22;
  v23 = v11->nelts;
  if (v23 >= 1)
  {
    v24 = v22;
    for (j = 0; j < v23; ++j)
    {
      v26 = *(_QWORD **)&v11->elts[8 * j];
      v27 = v26[2];
      v28 = var0->var8.var0;
      if (v28 > v27 || var0->var8.var1 + v28 <= v27)
      {
        v30 = apr_array_push(v24);
        v30[1] = v26[1];
        *v30 = v26[21];
        v23 = v11->nelts;
      }
    }
  }
  v11->nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 3), v8, v11);
  v31 = apr_array_make(v9, v11->nelts, 32);
  *(_QWORD *)v249 = v31;
  v32 = v11->nelts;
  if (v32 >= 1)
  {
    v33 = v31;
    for (k = 0; k < v32; ++k)
    {
      v35 = *(_QWORD **)&v11->elts[8 * k];
      v36 = v35[2];
      v37 = var0->var8.var0;
      if (v37 > v36 || var0->var8.var1 + v37 <= v36)
      {
        v39 = v35[6];
        if (!v39 || *(_BYTE *)(v39 + 62))
        {
          v40 = apr_array_push(v33);
          v40[1] = v35[1];
          *v40 = v35[8];
          v32 = v11->nelts;
        }
      }
    }
  }
  v11->nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 4), v8, v11);
  v41 = apr_array_make(v9, v11->nelts, 32);
  *(_QWORD *)&v249[8] = v41;
  v42 = v11->nelts;
  if (v42 >= 1)
  {
    v43 = v41;
    for (m = 0; m < v42; ++m)
    {
      v45 = *(_QWORD **)&v11->elts[8 * m];
      v46 = v45[2];
      v47 = var0->var8.var0;
      v48 = v47 <= v46 && var0->var8.var1 + v47 > v46;
      if (!v48 && GTMTLSMPipelineState_supportsIndirectCommandBuffers(*(_QWORD *)&v11->elts[8 * m]))
      {
        v49 = apr_array_push(v43);
        v49[1] = v45[1];
        *v49 = v45[12];
        v42 = v11->nelts;
      }
    }
  }
  v11->nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 5), v8, v11);
  v50 = apr_array_make(v9, v11->nelts, 32);
  *(_QWORD *)&v249[16] = v50;
  v51 = v11->nelts;
  if (v51 >= 1)
  {
    v52 = v50;
    for (n = 0; n < v51; ++n)
    {
      v54 = *(_QWORD **)&v11->elts[8 * n];
      v55 = v54[2];
      v56 = var0->var8.var0;
      v57 = v56 <= v55 && var0->var8.var1 + v56 > v55;
      if (!v57 && GTMTLSMPipelineState_supportsIndirectCommandBuffers(*(_QWORD *)&v11->elts[8 * n]))
      {
        v58 = apr_array_push(v52);
        v58[1] = v54[1];
        *v58 = v54[12];
        v51 = v11->nelts;
      }
    }
  }
  v11->nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 6), v8, v11);
  v59 = apr_array_make(v9, v11->nelts, 32);
  *(_QWORD *)&v250 = v59;
  v60 = v11->nelts;
  if (v60 >= 1)
  {
    v61 = v59;
    for (ii = 0; ii < v60; ++ii)
    {
      v63 = *(_QWORD **)&v11->elts[8 * ii];
      v64 = v63[2];
      v65 = var0->var8.var0;
      if (v65 > v64 || var0->var8.var1 + v65 <= v64)
      {
        v67 = apr_array_push(v61);
        v67[1] = v63[1];
        *v67 = v63[15];
        v60 = v11->nelts;
      }
    }
  }
  v11->nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 7), v8, v11);
  v68 = apr_array_make(v9, v11->nelts, 32);
  *((_QWORD *)&v250 + 1) = v68;
  v69 = v11->nelts;
  if (v69 >= 1)
  {
    v70 = v68;
    for (jj = 0; jj < v69; ++jj)
    {
      v72 = *(_QWORD **)&v11->elts[8 * jj];
      v73 = v72[2];
      v74 = var0->var8.var0;
      if (v74 > v73 || var0->var8.var1 + v74 <= v73)
      {
        v76 = apr_array_push(v70);
        v76[1] = v72[1];
        *v76 = v72[17];
        v69 = v11->nelts;
      }
    }
  }
  v11->nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 8), v8, v11);
  v77 = apr_array_make(v9, v11->nelts, 32);
  *(_QWORD *)&v251 = v77;
  v78 = v11->nelts;
  if (v78 >= 1)
  {
    v79 = v77;
    for (kk = 0; kk < v78; ++kk)
    {
      v81 = *(_QWORD **)&v11->elts[8 * kk];
      v82 = v81[2];
      v83 = var0->var8.var0;
      if (v83 > v82 || var0->var8.var1 + v83 <= v82)
      {
        v85 = apr_array_push(v79);
        v85[1] = v81[1];
        *v85 = v81[18];
        v78 = v11->nelts;
      }
    }
  }
  v11->nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 9), v8, v11);
  v86 = apr_array_make(v9, v11->nelts, 32);
  *((_QWORD *)&v251 + 1) = v86;
  v87 = v11->nelts;
  if (v87 >= 1)
  {
    v88 = v86;
    for (mm = 0; mm < v87; ++mm)
    {
      v90 = *(_QWORD **)&v11->elts[8 * mm];
      v91 = v90[2];
      v92 = var0->var8.var0;
      if (v92 > v91 || var0->var8.var1 + v92 <= v91)
      {
        v94 = apr_array_push(v88);
        v94[1] = v90[1];
        *v94 = v90[16];
        v87 = v11->nelts;
      }
    }
  }
  GTMTLIndirectResources_optimizeByKey((uint64_t *)v234, (uint64_t *)&v248, 0, v9);
  v95 = objc_autoreleasePoolPush();
  v96 = *(_DWORD *)(a2 + 8);
  context = v95;
  if (IsFuncEnumDrawCall(v96))
  {
    v97 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1->var1, "defaultDevice"));
    v98 = ObtainResourceTrackingTracingBufferV2(v97, v234);
    v200 = (void *)objc_claimAutoreleasedReturnValue(v98);

    v99 = *(_DWORD *)(a2 + 8);
    if ((v99 + 15416) > 2)
    {
      *(_OWORD *)v249 = 0u;
      v248 = 0u;
      v250 = 0u;
      v251 = 0u;
      *(_DWORD *)&v249[16] = 1065353216;
      v252 = 1065353216;
      v231 = 0u;
      v232 = 0u;
      *(_QWORD *)&v237 = 1;
      v233 = 1065353216;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)&v237 + 8, (uint64_t)&v231);
      v228 = 0u;
      v229 = 0u;
      v230 = 1065353216;
      v240 = 2;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v241, (uint64_t)&v228);
      v225 = 0u;
      v226 = 0u;
      v227 = 1065353216;
      v242 = 4;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v243, (uint64_t)&v225);
      v222 = 0u;
      v223 = 0u;
      v224 = 1065353216;
      v244 = 16;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v245, (uint64_t)&v222);
      v219 = 0u;
      v220 = 0u;
      v221 = 1065353216;
      v246 = 8;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v247, (uint64_t)&v219);
      std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map((uint64_t)v253, (unint64_t *)&v237, 5);
      for (nn = 200; nn != -40; nn -= 48)
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v237 + nn);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v219);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v222);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v225);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v228);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v231);
      v254 = 0u;
      v255 = 0u;
      v256 = 1065353216;
      v257 = 0u;
      v258 = 0u;
      v260 = 0u;
      v261 = 0u;
      v259 = 1065353216;
      v262 = 1065353216;
      v263 = v200;
      v264 = 2;
      v265 = 1;
      v110 = newpool;
      InstrumentFunctionWithResourceTrackingV2((uint64_t)&v237, a1, a2, (uint64_t)&v248, (uint64_t)v234, newpool);
      v199 = v237;
      v111 = (_BYTE *)*((_QWORD *)&v237 + 1);
      v112 = (_BYTE *)v238;

      v198 = v111;
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v260);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v257);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v254);
      std::__hash_table<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,std::__unordered_map_hasher<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,std::hash,true>,std::equal_to<FunctionHandleKey><std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>>::~__hash_table((uint64_t)v253);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v250);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v248);
      v113 = 0;
      __p = 0;
      v106 = 0;
      v114 = 0;
    }
    else
    {
      v100 = a1->var0;
      if (IsFuncEnumDrawCall(v99)
        && a1->var21.var0.var0 == 70
        && (Object = GTMTLSMContext_getObject(*(_QWORD *)v100->var5, a1->var21.var3.var0.var23, *(_QWORD *)a2)) != 0
        && (v102 = Object[9]) != 0
        && *(_QWORD *)(v102 + 368))
      {
        *(_OWORD *)v249 = 0u;
        v248 = 0u;
        v250 = 0u;
        v251 = 0u;
        *(_DWORD *)&v249[16] = 1065353216;
        v252 = 1065353216;
        v231 = 0u;
        v232 = 0u;
        *(_QWORD *)&v237 = 1;
        v233 = 1065353216;
        std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)&v237 + 8, (uint64_t)&v231);
        v228 = 0u;
        v229 = 0u;
        v230 = 1065353216;
        v240 = 2;
        std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v241, (uint64_t)&v228);
        v225 = 0u;
        v226 = 0u;
        v227 = 1065353216;
        v242 = 4;
        std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v243, (uint64_t)&v225);
        v222 = 0u;
        v223 = 0u;
        v224 = 1065353216;
        v244 = 16;
        std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v245, (uint64_t)&v222);
        v219 = 0u;
        v220 = 0u;
        v221 = 1065353216;
        v246 = 8;
        std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v247, (uint64_t)&v219);
        std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map((uint64_t)v253, (unint64_t *)&v237, 5);
        for (i1 = 200; i1 != -40; i1 -= 48)
          std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v237 + i1);
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v219);
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v222);
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v225);
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v228);
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v231);
        v254 = 0u;
        v255 = 0u;
        v256 = 1065353216;
        v257 = 0u;
        v258 = 0u;
        v260 = 0u;
        v261 = 0u;
        v259 = 1065353216;
        v262 = 1065353216;
        v263 = v200;
        v264 = 2;
        v265 = 0x10000000010;
        InstrumentFunctionWithResourceTrackingV2((uint64_t)&v237, a1, a2, (uint64_t)&v248, (uint64_t)v234, newpool);
        v104 = (_BYTE)v237 != 0;
        v105 = (_BYTE *)*((_QWORD *)&v237 + 1);
        v106 = (_BYTE *)v238;

        v197 = v105;
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v260);
        std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v257);
        std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v254);
        std::__hash_table<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,std::__unordered_map_hasher<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,std::hash,true>,std::equal_to<FunctionHandleKey><std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>>::~__hash_table((uint64_t)v253);
        std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v250);
        std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v248);
        v14 = a1;
      }
      else
      {
        v106 = 0;
        v197 = 0;
        v104 = 1;
      }
      *(_OWORD *)v249 = 0u;
      v248 = 0u;
      v250 = 0u;
      v251 = 0u;
      *(_DWORD *)&v249[16] = 1065353216;
      v252 = 1065353216;
      v231 = 0u;
      v232 = 0u;
      *(_QWORD *)&v237 = 1;
      v233 = 1065353216;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)&v237 + 8, (uint64_t)&v231);
      v228 = 0u;
      v229 = 0u;
      v230 = 1065353216;
      v240 = 2;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v241, (uint64_t)&v228);
      v225 = 0u;
      v226 = 0u;
      v227 = 1065353216;
      v242 = 4;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v243, (uint64_t)&v225);
      v222 = 0u;
      v223 = 0u;
      v224 = 1065353216;
      v244 = 16;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v245, (uint64_t)&v222);
      v219 = 0u;
      v220 = 0u;
      v221 = 1065353216;
      v246 = 8;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v247, (uint64_t)&v219);
      std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map((uint64_t)v253, (unint64_t *)&v237, 5);
      for (i2 = 200; i2 != -40; i2 -= 48)
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v237 + i2);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v219);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v222);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v225);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v228);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v231);
      v254 = 0u;
      v255 = 0u;
      v256 = 1065353216;
      v257 = 0u;
      v258 = 0u;
      v260 = 0u;
      v261 = 0u;
      v259 = 1065353216;
      v262 = 1065353216;
      v263 = v200;
      v264 = 2;
      v265 = 0x10000000020;
      v110 = newpool;
      InstrumentFunctionWithResourceTrackingV2((uint64_t)&v237, v14, a2, (uint64_t)&v248, (uint64_t)v234, newpool);
      if ((_BYTE)v237)
        v116 = v104;
      else
        v116 = 0;
      v199 = v116;
      __p = (_BYTE *)*((_QWORD *)&v237 + 1);
      v113 = (_BYTE *)v238;

      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v260);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v257);
      v114 = v197;
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v254);
      std::__hash_table<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,std::__unordered_map_hasher<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,std::hash,true>,std::equal_to<FunctionHandleKey><std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>>::~__hash_table((uint64_t)v253);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v250);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v248);
      v112 = 0;
      v198 = 0;
    }
    v117 = (uint64_t)a1;
    if (ShouldInstrumentFragmentStage((uint64_t *)a1, (uint64_t)v234, a2, a3))
    {
      *(_OWORD *)v249 = 0u;
      v248 = 0u;
      v250 = 0u;
      v251 = 0u;
      *(_DWORD *)&v249[16] = 1065353216;
      v252 = 1065353216;
      v231 = 0u;
      v232 = 0u;
      *(_QWORD *)&v237 = 1;
      v233 = 1065353216;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)&v237 + 8, (uint64_t)&v231);
      v228 = 0u;
      v229 = 0u;
      v230 = 1065353216;
      v240 = 2;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v241, (uint64_t)&v228);
      v225 = 0u;
      v226 = 0u;
      v227 = 1065353216;
      v242 = 4;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v243, (uint64_t)&v225);
      v222 = 0u;
      v223 = 0u;
      v224 = 1065353216;
      v244 = 16;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v245, (uint64_t)&v222);
      v219 = 0u;
      v220 = 0u;
      v221 = 1065353216;
      v246 = 8;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v247, (uint64_t)&v219);
      std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map((uint64_t)v253, (unint64_t *)&v237, 5);
      for (i3 = 200; i3 != -40; i3 -= 48)
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v237 + i3);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v219);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v222);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v225);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v228);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v231);
      v254 = 0u;
      v255 = 0u;
      v256 = 1065353216;
      v257 = 0u;
      v258 = 0u;
      v260 = 0u;
      v261 = 0u;
      v259 = 1065353216;
      v262 = 1065353216;
      v263 = v200;
      v264 = 2;
      LODWORD(v265) = 2;
      BYTE4(v265) = 0;
      BYTE5(v265) = (*(_DWORD *)(a2 + 8) + 15416) < 3;
      HIWORD(v265) = 0;
      v110 = newpool;
      InstrumentFunctionWithResourceTrackingV2((uint64_t)&v237, a1, a2, (uint64_t)&v248, (uint64_t)v234, newpool);
      if (v199)
        v119 = v237 == 0;
      else
        v119 = 1;
      v120 = !v119;
      LOBYTE(v199) = v120;
      v203 = (_BYTE *)*((_QWORD *)&v237 + 1);
      v121 = (_BYTE *)v238;

      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v260);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v257);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v254);
      std::__hash_table<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,std::__unordered_map_hasher<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,std::hash,true>,std::equal_to<FunctionHandleKey><std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>>::~__hash_table((uint64_t)v253);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v250);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v248);
      v117 = (uint64_t)a1;
    }
    else
    {
      v121 = 0;
      v203 = 0;
    }
    ReplaceFunctionTablesWithRegular((uint64_t)v217, v117, 3, *(_QWORD *)a2, (uint64_t *)v234, v110);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v218);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v217);
    v122 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", 0xAAAAAAAAAAAAAAABLL * ((v113 - __p) >> 3)- 0x5555555555555555 * ((v106 - v114) >> 3)- 0x5555555555555555 * ((v112 - v198) >> 3)- 0x5555555555555555 * ((v121 - v203) >> 3));
    if (v114 != v106)
    {
      v123 = v114;
      do
      {
        v124 = *(_OWORD *)v123;
        *(_QWORD *)v249 = v123[2];
        v248 = v124;
        ResourceUsageItem = MakeResourceUsageItem((uint64_t)&v248, 8);
        v126 = (void *)objc_claimAutoreleasedReturnValue(ResourceUsageItem);
        objc_msgSend(v122, "addObject:", v126);

        v123 += 3;
      }
      while (v123 != (_QWORD *)v106);
    }
    if (__p != v113)
    {
      v127 = __p;
      do
      {
        v248 = *(_OWORD *)v127;
        *(_QWORD *)v249 = v127[2];
        v128 = MakeResourceUsageItem((uint64_t)&v248, 16);
        v129 = (void *)objc_claimAutoreleasedReturnValue(v128);
        objc_msgSend(v122, "addObject:", v129);

        v127 += 3;
      }
      while (v127 != (_QWORD *)v113);
    }
    if (v198 != v112)
    {
      v130 = v198;
      do
      {
        v248 = *(_OWORD *)v130;
        *(_QWORD *)v249 = v130[2];
        v131 = MakeResourceUsageItem((uint64_t)&v248, 1);
        v132 = (void *)objc_claimAutoreleasedReturnValue(v131);
        objc_msgSend(v122, "addObject:", v132);

        v130 += 3;
      }
      while (v130 != (_QWORD *)v112);
    }
    if (v203 != v121)
    {
      v133 = v203;
      do
      {
        v248 = *(_OWORD *)v133;
        *(_QWORD *)v249 = v133[2];
        v134 = MakeResourceUsageItem((uint64_t)&v248, 2);
        v135 = (void *)objc_claimAutoreleasedReturnValue(v134);
        objc_msgSend(v122, "addObject:", v135);

        v133 += 3;
      }
      while (v133 != (_QWORD *)v121);
    }
    if (__p)
      operator delete(__p);
    if (v114)
      operator delete(v114);
    if (v203)
      operator delete(v203);
    if (v198)
      operator delete(v198);

    v107 = v199 & 1;
    goto LABEL_156;
  }
  if (v96 <= -16080)
  {
    if (v96 != -16327 && v96 != -16220)
    {
      v108 = -16137;
      goto LABEL_138;
    }
LABEL_147:
    *(_OWORD *)v249 = 0u;
    v248 = 0u;
    v250 = 0u;
    v251 = 0u;
    *(_DWORD *)&v249[16] = 1065353216;
    v252 = 1065353216;
    v231 = 0u;
    v232 = 0u;
    *(_QWORD *)&v237 = 1;
    v233 = 1065353216;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)&v237 + 8, (uint64_t)&v231);
    v228 = 0u;
    v229 = 0u;
    v230 = 1065353216;
    v240 = 2;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v241, (uint64_t)&v228);
    v225 = 0u;
    v226 = 0u;
    v227 = 1065353216;
    v242 = 4;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v243, (uint64_t)&v225);
    v222 = 0u;
    v223 = 0u;
    v224 = 1065353216;
    v244 = 16;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v245, (uint64_t)&v222);
    v219 = 0u;
    v220 = 0u;
    v221 = 1065353216;
    v246 = 8;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v247, (uint64_t)&v219);
    std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map((uint64_t)v253, (unint64_t *)&v237, 5);
    for (i4 = 200; i4 != -40; i4 -= 48)
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v237 + i4);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v219);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v222);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v225);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v228);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v231);
    v254 = 0u;
    v255 = 0u;
    v256 = 1065353216;
    v257 = 0u;
    v258 = 0u;
    v260 = 0u;
    v261 = 0u;
    v259 = 1065353216;
    v262 = 1065353216;
    v147 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1->var1, "defaultDevice"));
    v148 = ObtainResourceTrackingTracingBufferV2(v147, v234);
    v263 = (id)objc_claimAutoreleasedReturnValue(v148);
    v264 = 2;
    v265 = 0x100000008;

    v149 = newpool;
    InstrumentFunctionWithResourceTrackingV2((uint64_t)&v237, a1, a2, (uint64_t)&v248, (uint64_t)v234, newpool);
    v107 = (_BYTE)v237 != 0;
    ReplaceFunctionTablesWithRegular((uint64_t)v213, (uint64_t)a1, 8, *(_QWORD *)a2, (uint64_t *)v234, v149);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v214);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v213);
    v150 = objc_alloc((Class)NSMutableArray);
    v151 = (_QWORD *)v238;
    v152 = (_QWORD *)*((_QWORD *)&v237 + 1);
    v122 = objc_msgSend(v150, "initWithCapacity:", 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v238 - *((_QWORD *)&v237 + 1)) >> 3));
    if (v152 != v151)
    {
      v153 = v152;
      do
      {
        v231 = *(_OWORD *)v153;
        *(_QWORD *)&v232 = v153[2];
        v154 = MakeResourceUsageItem((uint64_t)&v231);
        v155 = (void *)objc_claimAutoreleasedReturnValue(v154);
        objc_msgSend(v122, "addObject:", v155);

        v153 += 3;
      }
      while (v153 != v151);
    }
    if (v152)
      operator delete(v152);

    goto LABEL_155;
  }
  if ((v96 + 16079) < 2)
    goto LABEL_147;
  if (v96 == -15297)
    goto LABEL_139;
  v108 = -15486;
LABEL_138:
  if (v96 != v108)
  {
    if ((v96 & 0xFFFFFFFE) == 0xFFFFC1A4)
    {
      v168 = v95;
      *(_OWORD *)v249 = 0u;
      v248 = 0u;
      v250 = 0u;
      v251 = 0u;
      *(_DWORD *)&v249[16] = 1065353216;
      v252 = 1065353216;
      v231 = 0u;
      v232 = 0u;
      *(_QWORD *)&v237 = 1;
      v233 = 1065353216;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)&v237 + 8, (uint64_t)&v231);
      v228 = 0u;
      v229 = 0u;
      v230 = 1065353216;
      v240 = 2;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v241, (uint64_t)&v228);
      v225 = 0u;
      v226 = 0u;
      v227 = 1065353216;
      v242 = 4;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v243, (uint64_t)&v225);
      v222 = 0u;
      v223 = 0u;
      v224 = 1065353216;
      v244 = 16;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v245, (uint64_t)&v222);
      v219 = 0u;
      v220 = 0u;
      v221 = 1065353216;
      v246 = 8;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v247, (uint64_t)&v219);
      std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map((uint64_t)v253, (unint64_t *)&v237, 5);
      for (i5 = 200; i5 != -40; i5 -= 48)
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v237 + i5);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v219);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v222);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v225);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v228);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v231);
      v254 = 0u;
      v255 = 0u;
      v256 = 1065353216;
      v257 = 0u;
      v258 = 0u;
      v260 = 0u;
      v261 = 0u;
      v259 = 1065353216;
      v262 = 1065353216;
      v170 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1->var1, "defaultDevice"));
      v171 = ObtainResourceTrackingTracingBufferV2(v170, v234);
      v263 = (id)objc_claimAutoreleasedReturnValue(v171);
      v264 = 2;
      v265 = 8;

      v172 = newpool;
      InstrumentSubCommandWithAccessTrackingV2((uint64_t)&v237, a1, a2, a3, (uint64_t)&v248, (uint64_t *)v234, newpool);
      v107 = (_BYTE)v237 != 0;
      ReplaceFunctionTablesWithRegular((uint64_t)v209, (uint64_t)a1, 8, *(_QWORD *)a2, (uint64_t *)v234, v172);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v210);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v209);
      v173 = objc_alloc((Class)NSMutableArray);
      v174 = (_QWORD *)v238;
      v175 = (_QWORD *)*((_QWORD *)&v237 + 1);
      v122 = objc_msgSend(v173, "initWithCapacity:", 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v238 - *((_QWORD *)&v237 + 1)) >> 3));
      if (v175 != v174)
      {
        v176 = v175;
        do
        {
          v231 = *(_OWORD *)v176;
          *(_QWORD *)&v232 = v176[2];
          v177 = MakeResourceUsageItem((uint64_t)&v231);
          v178 = (void *)objc_claimAutoreleasedReturnValue(v177);
          objc_msgSend(v122, "addObject:", v178);

          v176 += 3;
        }
        while (v176 != v174);
      }
      if (v175)
        operator delete(v175);
      GTMTLReplayAccessTracking::~GTMTLReplayAccessTracking((id *)&v248);
      v95 = v168;
      goto LABEL_157;
    }
    if ((v96 & 0xFFFFFFFE) != 0xFFFFC1A6)
    {
      v107 = 0;
      v122 = 0;
      goto LABEL_157;
    }
    v158 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1->var1, "defaultDevice"));
    v159 = ObtainResourceTrackingTracingBufferV2(v158, v234);
    v160 = (void *)objc_claimAutoreleasedReturnValue(v159);

    __pa = v160;
    if (*(_DWORD *)(a2 + 8) >> 2 == 1073737833)
    {
      v161 = a1->var0;
      v162 = a1->var1;
      v239 = 0;
      v237 = 0u;
      v238 = 0u;
      GetExecuteCommandsInBufferArgs((uint64_t)&v237, a2, (uint64_t)v161->var2);
      v163 = GTMTLSMContext_getObject(*(_QWORD *)v161->var5, v237, *(_QWORD *)a2);
      GTMTLCreateIndirectCommandEncoder((uint64_t)&v248, v163[13]);
      if (*((_QWORD *)&v237 + 1) <= a3 && (_QWORD)v238 + *((_QWORD *)&v237 + 1) >= a3 && *((_QWORD *)&v238 + 1))
      {
        v164 = (*(_QWORD *)(*((_QWORD *)&v238 + 1) + v253[3] * a3 + *((_QWORD *)&v248 + 1)) - 128) & 0xFFFFFFFFFFFFFF7FLL;

        if (!v164)
        {
          if (ShouldInstrumentICBObjectStage((uint64_t *)a1, a2, a3))
          {
            *(_OWORD *)v249 = 0u;
            v248 = 0u;
            v250 = 0u;
            v251 = 0u;
            *(_DWORD *)&v249[16] = 1065353216;
            v252 = 1065353216;
            v231 = 0u;
            v232 = 0u;
            *(_QWORD *)&v237 = 1;
            v233 = 1065353216;
            std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)&v237 + 8, (uint64_t)&v231);
            v228 = 0u;
            v229 = 0u;
            v230 = 1065353216;
            v240 = 2;
            std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v241, (uint64_t)&v228);
            v225 = 0u;
            v226 = 0u;
            v227 = 1065353216;
            v242 = 4;
            std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v243, (uint64_t)&v225);
            v222 = 0u;
            v223 = 0u;
            v224 = 1065353216;
            v244 = 16;
            std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v245, (uint64_t)&v222);
            v219 = 0u;
            v220 = 0u;
            v221 = 1065353216;
            v246 = 8;
            std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v247, (uint64_t)&v219);
            std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map((uint64_t)v253, (unint64_t *)&v237, 5);
            for (i6 = 200; i6 != -40; i6 -= 48)
              std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v237 + i6);
            std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v219);
            std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v222);
            std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v225);
            std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v228);
            std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v231);
            v254 = 0u;
            v255 = 0u;
            v256 = 1065353216;
            v257 = 0u;
            v258 = 0u;
            v260 = 0u;
            v261 = 0u;
            v259 = 1065353216;
            v262 = 1065353216;
            v263 = v160;
            v264 = 2;
            v265 = 16;
            InstrumentSubCommandWithAccessTrackingV2((uint64_t)&v237, a1, a2, a3, (uint64_t)&v248, (uint64_t *)v234, newpool);
            v166 = (_BYTE)v237 != 0;
            v167 = (void *)*((_QWORD *)&v237 + 1);
            GTMTLReplayAccessTracking::~GTMTLReplayAccessTracking((id *)&v248);
          }
          else
          {
            v167 = 0;
            v166 = 1;
          }
          *(_OWORD *)v249 = 0u;
          v248 = 0u;
          v250 = 0u;
          v251 = 0u;
          *(_DWORD *)&v249[16] = 1065353216;
          v252 = 1065353216;
          v231 = 0u;
          v232 = 0u;
          *(_QWORD *)&v237 = 1;
          v233 = 1065353216;
          std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)&v237 + 8, (uint64_t)&v231);
          v228 = 0u;
          v229 = 0u;
          v230 = 1065353216;
          v240 = 2;
          std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v241, (uint64_t)&v228);
          v225 = 0u;
          v226 = 0u;
          v227 = 1065353216;
          v242 = 4;
          std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v243, (uint64_t)&v225);
          v222 = 0u;
          v223 = 0u;
          v224 = 1065353216;
          v244 = 16;
          std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v245, (uint64_t)&v222);
          v219 = 0u;
          v220 = 0u;
          v221 = 1065353216;
          v246 = 8;
          std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v247, (uint64_t)&v219);
          v185 = a2;
          std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map((uint64_t)v253, (unint64_t *)&v237, 5);
          for (i7 = 200; i7 != -40; i7 -= 48)
            std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v237 + i7);
          std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v219);
          std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v222);
          std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v225);
          std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v228);
          std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v231);
          v254 = 0u;
          v255 = 0u;
          v256 = 1065353216;
          v257 = 0u;
          v258 = 0u;
          v260 = 0u;
          v261 = 0u;
          v259 = 1065353216;
          v262 = 1065353216;
          v263 = v160;
          v264 = 2;
          v265 = 32;
          v180 = newpool;
          InstrumentSubCommandWithAccessTrackingV2((uint64_t)&v237, a1, a2, a3, (uint64_t)&v248, (uint64_t *)v234, newpool);
          if ((_BYTE)v237)
            v183 = v166;
          else
            v183 = 0;
          v184 = (void *)*((_QWORD *)&v237 + 1);
          GTMTLReplayAccessTracking::~GTMTLReplayAccessTracking((id *)&v248);
          v182 = 0;
          v181 = 0;
          goto LABEL_186;
        }
      }
      else
      {

      }
    }
    *(_OWORD *)v249 = 0u;
    v248 = 0u;
    v250 = 0u;
    v251 = 0u;
    *(_DWORD *)&v249[16] = 1065353216;
    v252 = 1065353216;
    v231 = 0u;
    v232 = 0u;
    *(_QWORD *)&v237 = 1;
    v233 = 1065353216;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)&v237 + 8, (uint64_t)&v231);
    v228 = 0u;
    v229 = 0u;
    v230 = 1065353216;
    v240 = 2;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v241, (uint64_t)&v228);
    v225 = 0u;
    v226 = 0u;
    v227 = 1065353216;
    v242 = 4;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v243, (uint64_t)&v225);
    v222 = 0u;
    v223 = 0u;
    v224 = 1065353216;
    v244 = 16;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v245, (uint64_t)&v222);
    v219 = 0u;
    v220 = 0u;
    v221 = 1065353216;
    v246 = 8;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v247, (uint64_t)&v219);
    std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map((uint64_t)v253, (unint64_t *)&v237, 5);
    for (i8 = 200; i8 != -40; i8 -= 48)
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v237 + i8);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v219);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v222);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v225);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v228);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v231);
    v254 = 0u;
    v255 = 0u;
    v256 = 1065353216;
    v257 = 0u;
    v258 = 0u;
    v260 = 0u;
    v261 = 0u;
    v259 = 1065353216;
    v262 = 1065353216;
    v263 = v160;
    v264 = 2;
    v265 = 1;
    v180 = newpool;
    InstrumentSubCommandWithAccessTrackingV2((uint64_t)&v237, a1, a2, a3, (uint64_t)&v248, (uint64_t *)v234, newpool);
    v181 = (_BYTE *)*((_QWORD *)&v237 + 1);
    v182 = (_BYTE *)v238;
    v183 = v237;

    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v260);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v257);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v254);
    std::__hash_table<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,std::__unordered_map_hasher<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,std::hash,true>,std::equal_to<FunctionHandleKey><std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>>::~__hash_table((uint64_t)v253);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v250);
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v248);
    v184 = 0;
    v167 = 0;
    v185 = a2;
LABEL_186:
    if (ShouldInstrumentFragmentStage((uint64_t *)a1, (uint64_t)v234, v185, a3))
    {
      *(_OWORD *)v249 = 0u;
      v248 = 0u;
      v250 = 0u;
      v251 = 0u;
      *(_DWORD *)&v249[16] = 1065353216;
      v252 = 1065353216;
      v231 = 0u;
      v232 = 0u;
      *(_QWORD *)&v237 = 1;
      v233 = 1065353216;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)&v237 + 8, (uint64_t)&v231);
      v228 = 0u;
      v229 = 0u;
      v230 = 1065353216;
      v240 = 2;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v241, (uint64_t)&v228);
      v225 = 0u;
      v226 = 0u;
      v227 = 1065353216;
      v242 = 4;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v243, (uint64_t)&v225);
      v222 = 0u;
      v223 = 0u;
      v224 = 1065353216;
      v244 = 16;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v245, (uint64_t)&v222);
      v219 = 0u;
      v220 = 0u;
      v221 = 1065353216;
      v246 = 8;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v247, (uint64_t)&v219);
      std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map((uint64_t)v253, (unint64_t *)&v237, 5);
      for (i9 = 200; i9 != -40; i9 -= 48)
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v237 + i9);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v219);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v222);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v225);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v228);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v231);
      v254 = 0u;
      v255 = 0u;
      v256 = 1065353216;
      v257 = 0u;
      v258 = 0u;
      v260 = 0u;
      v261 = 0u;
      v259 = 1065353216;
      v262 = 1065353216;
      v263 = __pa;
      v264 = 2;
      v265 = 0x100000002;
      v180 = newpool;
      InstrumentSubCommandWithAccessTrackingV2((uint64_t)&v237, a1, a2, a3, (uint64_t)&v248, (uint64_t *)v234, newpool);
      v187 = (_BYTE *)*((_QWORD *)&v237 + 1);
      v188 = (_BYTE *)v238;
      if (v183)
        v189 = v237 == 0;
      else
        v189 = 1;
      LOBYTE(v183) = !v189;
      GTMTLReplayAccessTracking::~GTMTLReplayAccessTracking((id *)&v248);
    }
    else
    {
      v188 = 0;
      v187 = 0;
    }
    ReplaceFunctionTablesWithRegular((uint64_t)v211, (uint64_t)a1, 3, *(_QWORD *)a2, (uint64_t *)v234, v180);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v212);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v211);
    v122 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", 0xAAAAAAAAAAAAAAABLL * ((v182 - v181) >> 3) - 0x5555555555555555 * ((v188 - v187) >> 3));
    if (v181 != v182)
    {
      v190 = v181;
      do
      {
        v248 = *(_OWORD *)v190;
        *(_QWORD *)v249 = v190[2];
        v191 = MakeResourceUsageItem((uint64_t)&v248, 1);
        v192 = (void *)objc_claimAutoreleasedReturnValue(v191);
        objc_msgSend(v122, "addObject:", v192);

        v190 += 3;
      }
      while (v190 != (_QWORD *)v182);
    }
    if (v187 != v188)
    {
      v193 = v187;
      do
      {
        v248 = *(_OWORD *)v193;
        *(_QWORD *)v249 = v193[2];
        v194 = MakeResourceUsageItem((uint64_t)&v248, 2);
        v195 = (void *)objc_claimAutoreleasedReturnValue(v194);
        objc_msgSend(v122, "addObject:", v195);

        v193 += 3;
      }
      while (v193 != (_QWORD *)v188);
    }
    if (v184)
      operator delete(v184);
    if (v167)
      operator delete(v167);
    if (v187)
      operator delete(v187);
    if (v181)
      operator delete(v181);

    v107 = v183 & 1;
    goto LABEL_156;
  }
LABEL_139:
  *(_OWORD *)v249 = 0u;
  v248 = 0u;
  v250 = 0u;
  v251 = 0u;
  *(_DWORD *)&v249[16] = 1065353216;
  v252 = 1065353216;
  v231 = 0u;
  v232 = 0u;
  *(_QWORD *)&v237 = 1;
  v233 = 1065353216;
  std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)&v237 + 8, (uint64_t)&v231);
  v228 = 0u;
  v229 = 0u;
  v230 = 1065353216;
  v240 = 2;
  std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v241, (uint64_t)&v228);
  v225 = 0u;
  v226 = 0u;
  v227 = 1065353216;
  v242 = 4;
  std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v243, (uint64_t)&v225);
  v222 = 0u;
  v223 = 0u;
  v224 = 1065353216;
  v244 = 16;
  std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v245, (uint64_t)&v222);
  v219 = 0u;
  v220 = 0u;
  v221 = 1065353216;
  v246 = 8;
  std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map((uint64_t)v247, (uint64_t)&v219);
  std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map((uint64_t)v253, (unint64_t *)&v237, 5);
  for (i10 = 200; i10 != -40; i10 -= 48)
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v237 + i10);
  std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v219);
  std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v222);
  std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v225);
  std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v228);
  std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v231);
  v254 = 0u;
  v255 = 0u;
  v256 = 1065353216;
  v257 = 0u;
  v258 = 0u;
  v260 = 0u;
  v261 = 0u;
  v259 = 1065353216;
  v262 = 1065353216;
  v137 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1->var1, "defaultDevice"));
  v138 = ObtainResourceTrackingTracingBufferV2(v137, v234);
  v263 = (id)objc_claimAutoreleasedReturnValue(v138);
  v264 = 2;
  v265 = 0x100000004;

  v139 = newpool;
  InstrumentFunctionWithResourceTrackingV2((uint64_t)&v237, a1, a2, (uint64_t)&v248, (uint64_t)v234, newpool);
  v107 = (_BYTE)v237 != 0;
  ReplaceFunctionTablesWithRegular((uint64_t)v215, (uint64_t)a1, 4, *(_QWORD *)a2, (uint64_t *)v234, v139);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v216);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v215);
  v140 = objc_alloc((Class)NSMutableArray);
  v141 = (_QWORD *)v238;
  v142 = (_QWORD *)*((_QWORD *)&v237 + 1);
  v122 = objc_msgSend(v140, "initWithCapacity:", 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v238 - *((_QWORD *)&v237 + 1)) >> 3));
  if (v142 != v141)
  {
    v143 = v142;
    do
    {
      v231 = *(_OWORD *)v143;
      *(_QWORD *)&v232 = v143[2];
      v144 = MakeResourceUsageItem((uint64_t)&v231, 4);
      v145 = (void *)objc_claimAutoreleasedReturnValue(v144);
      objc_msgSend(v122, "addObject:", v145);

      v143 += 3;
    }
    while (v143 != v141);
  }
  if (v142)
    operator delete(v142);

LABEL_155:
  std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v260);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v257);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v254);
  std::__hash_table<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,std::__unordered_map_hasher<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,std::hash,true>,std::equal_to<FunctionHandleKey><std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>>::~__hash_table((uint64_t)v253);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v250);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v248);
LABEL_156:
  v95 = context;
LABEL_157:
  objc_autoreleasePoolPop(v95);
  apr_pool_destroy(newpool);
  if (v122)
  {
    v156 = objc_retainAutorelease(objc_msgSend(v122, "copy"));
    *a4 = v156;

  }
  else
  {
    *a4 = &__NSArray0__struct;
  }

  return v107;
}

void sub_2A2A48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17)
{
  GTMTLReplayAccessTracking::~GTMTLReplayAccessTracking((id *)&STACK[0x430]);

  _Unwind_Resume(a1);
}

void InstrumentFunctionWithResourceTrackingV2(uint64_t a1, GTMTLReplayController *a2, uint64_t a3, uint64_t a4, uint64_t a5, apr_pool_t *a6)
{
  void *v12;
  GTMTLReplayDataSource *var0;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  unsigned int v17;
  void *v18;
  GTMTLReplayDataSource *v19;
  unsigned int v20;
  _QWORD *Object;
  _QWORD *v22;
  id v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  id v29;
  uint64_t v30;
  _QWORD *v31;
  char updated;
  int v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  int64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  char *v51;
  _QWORD *v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  void *v57;
  uint64_t v58;
  void *v59;
  uint64_t v60;
  uint64_t *var5;
  uint64_t v62;
  _BYTE v63[72];
  __int128 v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  uint64_t v71;

  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2->var1, "defaultDevice"));
  var0 = a2->var0;
  v14 = *(_OWORD *)(a5 + 32);
  v15 = *(_OWORD *)(a5 + 64);
  v69 = *(_OWORD *)(a5 + 48);
  v70 = v15;
  v71 = *(_QWORD *)(a5 + 80);
  v16 = *(_OWORD *)(a5 + 16);
  v17 = *(_DWORD *)(a3 + 8);
  v66 = *(_OWORD *)a5;
  v67 = v16;
  v68 = v14;
  if (v17 >> 2 == 1073737833)
    goto LABEL_60;
  GTMTLReplayController_debugSubCommandResume((unsigned int *)a2, *(_DWORD *)a3 - LODWORD(var0->var9.var0.var0) + 1, -1);
  if (!*(_QWORD *)(a4 + 240))
    goto LABEL_59;
  v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2->var1, "defaultDevice"));
  v19 = a2->var0;
  var5 = (uint64_t *)a2->var0->var5;
  v20 = a2->var21.var0.var0;
  if (v20 != 28)
  {
    if (v20 != 70)
    {
LABEL_58:

LABEL_59:
      GTMTLReplay_handleError(101, (uint64_t)"Resource access tracking failed", "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_accessTracking.mm", (uint64_t)"InstrumentFunctionWithResourceTrackingV2", 4806, 64);
      FlushCommandQueue(a2);
      goto LABEL_60;
    }
    *(_QWORD *)v63 = v18;
    v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2->var1, "renderCommandEncoderForKey:", a2->var21.var0.var2));
    if (!v59)
      goto LABEL_56;
    Object = GTMTLSMContext_getObject(*(_QWORD *)v19->var5, a2->var21.var3.var0.var23, *(_QWORD *)a3);
    if (!Object)
      goto LABEL_56;
    v22 = Object;
    v23 = ObtainTracingRenderPipelineState((uint64_t *)v19->var5, a2->var1, Object, a4, *(_QWORD *)a3, a6);
    v24 = objc_claimAutoreleasedReturnValue(v23);
    if (!v24)
      goto LABEL_56;
    v57 = (void *)v24;
    ReplaceFunctionTablesWithInstrumented((uint64_t)&v63[8], (uint64_t)a2, a4, *(_QWORD *)a3, v22, (uint64_t *)&v66, a6);
    objc_msgSend(v59, "setRenderPipelineState:", v24);
    v25 = *(_DWORD *)(a4 + 256) & 0x37;
    if ((*(_DWORD *)(a4 + 256) & 0x37u) <= 3)
    {
      if ((*(_DWORD *)(a4 + 256) & 0x37) != 1)
      {
        if ((*(_DWORD *)(a4 + 256) & 0x37) != 2)
          goto LABEL_55;
        v25 = 2;
      }
    }
    else
    {
      switch(*(_DWORD *)(a4 + 256) & 0x37)
      {
        case 4:
          v25 = 4;
          break;
        case 16:
          v25 = 8;
          break;
        case 32:
          v25 = 16;
          break;
        default:
          goto LABEL_55;
      }
    }
    objc_msgSend(v59, "useResource:usage:stages:", *(_QWORD *)(a4 + 240), 3, v25);
    v33 = *(_DWORD *)(a3 + 8);
    if (!IsFuncEnumDrawCall(v33))
    {
      if (v33 == -16137 || v33 == -15297 || v33 == -15486)
      {
        if ((SupportsGlobalRelocation(*(void **)v63, a4) & 1) == 0)
        {
          v34 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>((_QWORD *)a4, v22[1]);
          if (!v34)
            goto LABEL_55;
          objc_msgSend(v59, "setTileBuffer:offset:atIndex:", *(_QWORD *)(a4 + 240), 0, *((unsigned int *)v34 + 6));
        }
        if (!UpdateFunctionTables<31ul,1ul>(4u, v59, (uint64_t)&a2->var21.var3.var0.var20.var0, (uint64_t)a2->var21.var3.var0.var19, var5, *(_QWORD *)a3, &v63[8]))goto LABEL_55;
      }
LABEL_39:
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v63[48]);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v63[8]);

      v18 = *(void **)v63;
      goto LABEL_40;
    }
    GTMTLSMRenderPipelineState_fragmentFunction(var5, v22);
    if ((SupportsGlobalRelocation(*(void **)v63, a4) & 1) != 0)
      goto LABEL_30;
    v52 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>((_QWORD *)a4, v22[1]);
    if (v52)
    {
      v53 = *((unsigned int *)v52 + 6);
      v54 = *(_DWORD *)(a4 + 256);
      if (v54 > 15)
      {
        if (v54 == 16)
        {
          objc_msgSend(v59, "setObjectBuffer:offset:atIndex:", *(_QWORD *)(a4 + 240), 0, v53);
        }
        else
        {
          if (v54 != 32)
            goto LABEL_55;
          objc_msgSend(v59, "setMeshBuffer:offset:atIndex:", *(_QWORD *)(a4 + 240), 0, v53);
        }
      }
      else
      {
        if (v54 != 1)
        {
          if (v54 == 2)
          {
            objc_msgSend(v59, "setFragmentBuffer:offset:atIndex:", *(_QWORD *)(a4 + 240), 0, v53);
            goto LABEL_30;
          }
          goto LABEL_55;
        }
        objc_msgSend(v59, "setVertexBuffer:offset:atIndex:", *(_QWORD *)(a4 + 240), 0, v53);
      }
LABEL_30:
      if ((UpdateDrawFunctionTables(a4, var5, &v63[8], (uint64_t)&a2->var21.var3, v59, *(_QWORD *)a3) & 1) == 0)
        goto LABEL_55;
      goto LABEL_39;
    }
LABEL_55:
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v63[48]);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v63[8]);

LABEL_56:
    goto LABEL_57;
  }
  *(_QWORD *)v63 = v18;
  v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2->var1, "computeCommandEncoderForKey:", a2->var21.var0.var2));
  if (!v26
    || (v27 = GTMTLSMContext_getObject(*(_QWORD *)a2->var0->var5, a2->var21.var3.var0.var1[0], *(_QWORD *)a3)) == 0
    || (v28 = v27,
        v29 = ObtainTracingComputePipelineState((uint64_t *)a2->var0->var5, a2->var1, (uint64_t)v27, a4, *(_QWORD *)a3, a6), (v30 = objc_claimAutoreleasedReturnValue(v29)) == 0))
  {
LABEL_25:

LABEL_57:
    v18 = *(void **)v63;
    goto LABEL_58;
  }
  v59 = (void *)v30;
  ReplaceFunctionTablesWithInstrumented((uint64_t)&v63[8], (uint64_t)a2, a4, *(_QWORD *)a3, v28, (uint64_t *)&v66, a6);
  if ((SupportsGlobalRelocation(*(void **)v63, a4) & 1) != 0)
    goto LABEL_19;
  v31 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>((_QWORD *)a4, v28[1]);
  if (!v31)
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v63[48]);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v63[8]);

    goto LABEL_25;
  }
  objc_msgSend(v26, "setBuffer:offset:atIndex:", *(_QWORD *)(a4 + 240), 0, *((unsigned int *)v31 + 6));
LABEL_19:
  objc_msgSend(v26, "setComputePipelineState:", v59);
  objc_msgSend(v26, "useResource:usage:", *(_QWORD *)(a4 + 240), 3);
  updated = UpdateFunctionTables<31ul,1ul>(8u, v26, (uint64_t)&a2->var21.var3.var0.var3.var0.var0[1], (uint64_t)a2->var21.var3.var0.var2, var5, *(_QWORD *)a3, &v63[8]);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v63[48]);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v63[8]);

  v18 = *(void **)v63;
  if ((updated & 1) == 0)
    goto LABEL_58;
LABEL_40:

  RemapIndirectResources((uint64_t)&v63[8], a5, a2->var1, a6);
  v69 = *(_OWORD *)&v63[56];
  v70 = v64;
  v71 = v65;
  v66 = *(_OWORD *)&v63[8];
  v67 = *(_OWORD *)&v63[24];
  v68 = *(_OWORD *)&v63[40];
  PopulateResourceTrackingBufferV2(*(void **)(a4 + 240), &v66, v35, v36, v37, v38, v39, v40, v55, (uint64_t)v57, (uint64_t)v59, (uint64_t)var5, *(__int128 *)v63, *(__int128 *)&v63[16], *(__int128 *)&v63[32], *(__int128 *)&v63[48]);
  GTMTLReplayController_defaultDispatchFunction((uint64_t)a2, a3);
  FlushCommandQueue(a2);
  if (!IsTraceBufferValidV2(*(void **)(a4 + 240)))
  {
LABEL_60:
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_BYTE *)a1 = 0;
    goto LABEL_61;
  }
  DecodeResourceTrackingBufferV2((unint64_t *)&v63[8], *(void **)(a4 + 240), &v66, v41, v42, v43, v44, v45, v56, v58, v60, v62, *(__int128 *)v63, *(__int128 *)&v63[16], *(__int128 *)&v63[32], *(__int128 *)&v63[48]);
  v46 = *(void **)&v63[8];
  v47 = *(_QWORD *)&v63[16] - *(_QWORD *)&v63[8];
  if (*(_QWORD *)&v63[16] == *(_QWORD *)&v63[8])
  {
    v48 = 0;
    v50 = 0;
    v51 = 0;
  }
  else
  {
    if (0xAAAAAAAAAAAAAAABLL * (v47 >> 3) >= 0xAAAAAAAAAAAAAABLL)
      abort();
    v48 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(0xAAAAAAAAAAAAAAABLL * (v47 >> 3));
    v50 = &v48[24 * v49];
    memmove(v48, v46, v47);
    v51 = &v48[8 * (v47 >> 3)];
  }
  *(_BYTE *)a1 = 1;
  *(_QWORD *)(a1 + 8) = v48;
  *(_QWORD *)(a1 + 16) = v51;
  *(_QWORD *)(a1 + 24) = v50;
  if (v46)
    operator delete(v46);
LABEL_61:

}

void sub_2A3BE4(_Unwind_Exception *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, void *a6, ...)
{
  void *v6;
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)va1);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)va);

  _Unwind_Resume(a1);
}

_QWORD *ShouldInstrumentFragmentStage(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8;
  unsigned int v9;
  _QWORD *result;
  BOOL v11;
  _QWORD *Object;
  uint64_t v13;
  unint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  _QWORD v20[14];
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v8 = *a1;
  v9 = *(_DWORD *)(a3 + 8);
  if (IsFuncEnumDrawCall(v9))
  {
    if (*((_DWORD *)a1 + 2828) == 70)
    {
      result = GTMTLSMContext_getObject(**(_QWORD **)(v8 + 40), a1[2489], *(_QWORD *)a3);
      if (!result)
        return result;
      v11 = GTMTLSMRenderPipelineState_fragmentFunction(*(uint64_t **)(v8 + 40), result) == 0;
      return (_QWORD *)!v11;
    }
    return 0;
  }
  if (v9 >> 1 != 2147475667)
    return 0;
  v23 = 0;
  v21 = 0u;
  v22 = 0u;
  GetExecuteCommandsInBufferArgs((uint64_t)&v21, a3, *(_QWORD *)(v8 + 16));
  Object = GTMTLSMContext_getObject(**(_QWORD **)(v8 + 40), v21, *(_QWORD *)a3);
  GTMTLCreateIndirectCommandEncoder((uint64_t)v20, Object[13]);
  if (*((_QWORD *)&v21 + 1) > a4 || (_QWORD)v22 + *((_QWORD *)&v21 + 1) < a4)
    return 0;
  v13 = *((_QWORD *)&v22 + 1) + v20[13] * a4;
  v14 = *(_QWORD *)(v13 + v20[1]);
  v15 = v14 > 8;
  v16 = (1 << v14) & 0x116;
  if (v15 || v16 == 0)
    return 0;
  if (*(_BYTE *)(v20[0] + 11))
  {
    v18 = a1[2489];
    if (!v18)
      return 0;
  }
  else
  {
    v18 = GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier(*(_QWORD *)(a2 + 24), *(_QWORD *)(v13 + v20[2]));
    if (!v18)
      return 0;
  }
  result = GTMTLSMContext_getObject(**(_QWORD **)(v8 + 40), v18, *(_QWORD *)a3);
  if (!result)
    return result;
  v19 = result[6];
  if (!v19)
    return 0;
  v11 = *(_QWORD *)(v19 + 1176) == 0;
  return (_QWORD *)!v11;
}

BOOL ShouldInstrumentICBObjectStage(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6;
  id v7;
  apr_pool_t *v8;
  _QWORD *Object;
  uint64_t v10;
  uint64_t v11;
  _BOOL8 v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD v16[14];
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  if (*(_DWORD *)(a2 + 8) >> 2 != 1073737833)
    return 0;
  v6 = *a1;
  v7 = (id)a1[1];
  v8 = *(apr_pool_t **)a1[19];
  v25 = 0;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v20 = 0u;
  GTMTLSMContext_indirectCommandBufferResources((uint64_t)&v20, *(_DWORD ***)(v6 + 40), *(_QWORD *)a2, v8);
  v19 = 0;
  v17 = 0u;
  v18 = 0u;
  GetExecuteCommandsInBufferArgs((uint64_t)&v17, a2, *(_QWORD *)(v6 + 16));
  Object = GTMTLSMContext_getObject(**(_QWORD **)(v6 + 40), v17, *(_QWORD *)a2);
  GTMTLCreateIndirectCommandEncoder((uint64_t)v16, Object[13]);
  v12 = *((_QWORD *)&v17 + 1) <= a3
     && (_QWORD)v18 + *((_QWORD *)&v17 + 1) >= a3
     && *((_QWORD *)&v18 + 1)
     && (v10 = Object[13]) != 0
     && (!*(_BYTE *)(v10 + 11)
       ? (v11 = GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier(*((uint64_t *)&v21 + 1), *(_QWORD *)(*((_QWORD *)&v18 + 1) + v16[13] * a3 + v16[2]))): (v11 = a1[2489]), (v13 = GTMTLSMContext_getObject(**(_QWORD **)(v6 + 40), v11, *(_QWORD *)a2)) != 0 && (v14 = v13[9]) != 0)&& *(_QWORD *)(v14 + 368) != 0;

  return v12;
}

void MakeRootResourceAliasable(void *a1)
{
  void *v1;
  void *v2;
  id v3;
  void *v4;
  void *v5;
  id v6;

  v6 = a1;
  v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "heap"));
  v2 = v1;
  if (v1 && !objc_msgSend(v1, "type"))
  {
    if (objc_msgSend(v6, "conformsToProtocol:", &OBJC_PROTOCOL___MTLTexture))
    {
      v3 = v6;
      v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "parentTexture"));
      if (v4)
      {

        goto LABEL_8;
      }
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "buffer"));

      if (v5)
        goto LABEL_8;
    }
    objc_msgSend(v6, "makeAliasable");
  }
LABEL_8:

}

uint64_t IsResourceIndirectCommandBuffer(void *a1)
{
  id v1;
  char isKindOfClass;

  v1 = a1;
  if (IsResourceIndirectCommandBuffer_onceToken != -1)
    dispatch_once(&IsResourceIndirectCommandBuffer_onceToken, &__block_literal_global_4632);
  if ((objc_msgSend(v1, "conformsToProtocol:", &OBJC_PROTOCOL___MTLIndirectCommandBuffer) & 1) != 0)
  {
    isKindOfClass = 1;
  }
  else if (IsResourceIndirectCommandBuffer__MTLIOAccelIndirectCommandBufferClass)
  {
    isKindOfClass = objc_opt_isKindOfClass(v1, IsResourceIndirectCommandBuffer__MTLIOAccelIndirectCommandBufferClass);
  }
  else
  {
    isKindOfClass = 0;
  }

  return isKindOfClass & 1;
}

id GTMTLReplayController_generatePostMeshData(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, _QWORD *a12)
{
  id v14;
  id v15;
  void *v16;
  uint64_t v17;
  int v18;
  _QWORD *v19;
  void *v20;
  id MTLMeshRenderPipelineDescriptorWithoutResourceIndex;
  void *v22;
  void *v23;
  void *v24;
  id v25;
  id v26;
  id v27;
  id v28;
  id v29;
  id v30;
  uint64_t v31;
  void *v32;
  void *i;
  void *v34;
  char v35;
  unint64_t v36;
  id v37;
  id v38;
  void *v39;
  void *v40;
  id v41;
  id v42;
  uint64_t v43;
  void *j;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  id v49;
  id v50;
  uint64_t v51;
  void *k;
  void *v53;
  void *v54;
  void *v55;
  id v56;
  void *v57;
  void *v58;
  id v59;
  id v60;
  id v61;
  id v62;
  id v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  void *v67;
  id v68;
  char v69;
  id v70;
  id v71;
  void *v72;
  void *v73;
  void *v74;
  unsigned int v75;
  __CFString *v76;
  __CFString *v77;
  unsigned int v78;
  void *v79;
  void *v80;
  void *v81;
  void *v82;
  void *v83;
  void *v84;
  void *v85;
  void *v86;
  void *v87;
  void *v88;
  void *v89;
  void *v90;
  id v91;
  void *v92;
  void *v93;
  void *v94;
  void *v95;
  unsigned int v96;
  void *v97;
  void *v98;
  void *v99;
  void *v100;
  void *v101;
  void *v102;
  void *v103;
  uint64_t v104;
  void *v105;
  _BOOL4 v106;
  int v107;
  void *v108;
  id v109;
  uint64_t v110;
  id v111;
  id v112;
  void *v113;
  void *v114;
  void *v115;
  id v116;
  void *v117;
  void *v118;
  void *v119;
  void *v120;
  void *v121;
  void *v122;
  _QWORD *CommandEncoder;
  void *v124;
  uint64_t v125;
  void *v126;
  id v127;
  id v128;
  _BYTE *v129;
  id v130;
  char *v131;
  char *v132;
  char *v133;
  uint64_t v134;
  uint64_t v135;
  void *v136;
  uint64_t v137;
  unint64_t v138;
  unint64_t v139;
  id v140;
  unint64_t v141;
  size_t v142;
  id v143;
  void *v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  uint64_t PostMeshData;
  void *v154;
  void *v155;
  unint64_t v156;
  unint64_t v157;
  char *v158;
  id v159;
  unint64_t v160;
  int v161;
  char *v162;
  int v163;
  char *v164;
  unint64_t v166;
  char *v167;
  char *v168;
  id v169;
  unsigned int v170;
  unsigned int v171;
  unsigned int v172;
  unsigned int v173;
  unsigned int v174;
  unsigned int v175;
  unsigned int v176;
  unsigned int v177;
  unsigned int v178;
  unsigned int v179;
  unsigned int v180;
  unsigned int v181;
  unsigned int v182;
  unsigned int v183;
  unsigned int v184;
  unsigned int v185;
  char *v186;
  unsigned int v187;
  unsigned int v188;
  char *v189;
  unsigned int v190;
  void *v191;
  void *v192;
  void *v193;
  void *v194;
  void *v195;
  void *v196;
  void *v197;
  uint64_t v198;
  void *v199;
  _BOOL4 v200;
  void *v201;
  void *v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  id v208;
  _BYTE *v209;
  int v210;
  void *v211;
  unsigned int v212;
  id v213;
  void *v214;
  id v215;
  void *v216;
  unsigned int v217;
  unsigned int v218;
  int v219;
  int v220;
  uint64_t v221;
  void *v222;
  uint64_t v223;
  id v224;
  id v225;
  size_t __na;
  uint64_t v231;
  BOOL v232;
  unint64_t v234;
  void *v235;
  void *v236;
  id v237;
  void *v238;
  void *v239;
  id obj;
  id obja;
  id v242;
  _OWORD v243[16];
  _BYTE __dst[11096];
  __int128 v245;
  __int128 v246;
  __int128 v247;
  __int128 v248;
  id v249;
  id v250;
  __int128 v251;
  __int128 v252;
  __int128 v253;
  __int128 v254;
  __int128 v255;
  __int128 v256;
  __int128 v257;
  __int128 v258;
  __int128 v259;
  __int128 v260;
  __int128 v261;
  __int128 v262;
  id v263;
  id v264;
  _QWORD v265[64];
  _BYTE v266[128];
  const __CFString *v267;
  void *v268;
  _BYTE v269[128];
  _BYTE v270[128];
  _BYTE v271[128];
  uint64_t v272;
  int v273;

  v242 = a2;
  v14 = a11;
  v15 = *(id *)(a10 + 72);
  v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "device"));
  v223 = a8;
  memcpy(v265, *(const void **)(a8 + 72), sizeof(v265));
  v17 = 0;
  v18 = BYTE5(v265[63]);
  do
  {
    v19 = &v265[v17];
    *(_WORD *)v19 = 0;
    *((_BYTE *)v19 + 3) = 0;
    v17 += 2;
  }
  while (v17 != 16);
  LOWORD(v265[50]) = 0;
  LOWORD(v265[51]) = 0;
  BYTE6(v265[63]) = 0;
  LOWORD(v265[0]) = 70;
  memset(&v265[16], 0, 64);
  v265[43] = 0;
  v265[47] = 0;
  v231 = a1;
  v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 8), "renderPipelineDescriptorMap"));
  MTLMeshRenderPipelineDescriptorWithoutResourceIndex = MakeMTLMeshRenderPipelineDescriptorWithoutResourceIndex((uint64_t)v265, v20);
  v22 = (void *)objc_claimAutoreleasedReturnValue(MTLMeshRenderPipelineDescriptorWithoutResourceIndex);

  v273 = 0;
  v272 = 0;
  objc_msgSend(v22, "setRasterizationEnabled:", 0);
  objc_msgSend(v22, "setLabel:", CFSTR("GPUToolsInternalPostTransformPipelineStateLabel"));
  v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
  v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
  v264 = 0;
  v263 = 0;
  v25 = objc_msgSend(v16, "newRenderPipelineStateWithMeshDescriptor:options:reflection:error:", v22, 1, &v264, &v263);
  v26 = v264;
  v27 = v263;
  obj = v25;
  if (v25)
  {
    v238 = v16;
    v239 = v22;
    v259 = 0u;
    v260 = 0u;
    v261 = 0u;
    v262 = 0u;
    v28 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "meshBuiltInArguments"));
    v29 = objc_msgSend(v28, "countByEnumeratingWithState:objects:count:", &v259, v271, 16);
    v237 = v15;
    if (v29)
    {
      v30 = v29;
      v215 = v26;
      v219 = v18;
      v224 = v14;
      v31 = *(_QWORD *)v260;
      v32 = v242;
      while (2)
      {
        for (i = 0; i != v30; i = (char *)i + 1)
        {
          if (*(_QWORD *)v260 != v31)
            objc_enumerationMutation(v28);
          v34 = *(void **)(*((_QWORD *)&v259 + 1) + 8 * (_QWORD)i);
          if (objc_msgSend(v34, "builtInType") == &dword_18)
          {
            v217 = objc_msgSend(v34, "meshVertexCount");
            v218 = objc_msgSend(v34, "meshPrimitiveCount");
            v36 = (unint64_t)objc_msgSend(v34, "meshTopologyType") - 1;
            v213 = v27;
            if (v36 > 2)
              v210 = 0;
            else
              v210 = dword_4A87E8[v36];
            v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v34, "meshVertexStruct"));
            v235 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v34, "meshPrimitiveStruct"));
            v255 = 0u;
            v256 = 0u;
            v257 = 0u;
            v258 = 0u;
            v211 = v39;
            v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v39, "members"));
            v41 = objc_msgSend(v40, "countByEnumeratingWithState:objects:count:", &v255, v270, 16);
            if (v41)
            {
              v42 = v41;
              v43 = *(_QWORD *)v256;
              do
              {
                for (j = 0; j != v42; j = (char *)j + 1)
                {
                  if (*(_QWORD *)v256 != v43)
                    objc_enumerationMutation(v40);
                  v45 = *(void **)(*((_QWORD *)&v255 + 1) + 8 * (_QWORD)j);
                  v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v45, "dataType")));
                  v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45, "name"));
                  objc_msgSend(v23, "setObject:forKeyedSubscript:", v46, v47);

                }
                v42 = objc_msgSend(v40, "countByEnumeratingWithState:objects:count:", &v255, v270, 16);
              }
              while (v42);
            }

            v254 = 0u;
            v253 = 0u;
            v252 = 0u;
            v251 = 0u;
            v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v235, "members"));
            v49 = objc_msgSend(v48, "countByEnumeratingWithState:objects:count:", &v251, v269, 16);
            if (v49)
            {
              v50 = v49;
              v51 = *(_QWORD *)v252;
              do
              {
                for (k = 0; k != v50; k = (char *)k + 1)
                {
                  if (*(_QWORD *)v252 != v51)
                    objc_enumerationMutation(v48);
                  v53 = *(void **)(*((_QWORD *)&v251 + 1) + 8 * (_QWORD)k);
                  v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v53, "dataType")));
                  v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v53, "name"));
                  objc_msgSend(v24, "setObject:forKeyedSubscript:", v54, v55);

                }
                v50 = objc_msgSend(v48, "countByEnumeratingWithState:objects:count:", &v251, v269, 16);
              }
              while (v50);
            }

            v35 = 1;
            v32 = v242;
            v14 = v224;
            v18 = v219;
            v27 = v213;
            goto LABEL_33;
          }
        }
        v30 = objc_msgSend(v28, "countByEnumeratingWithState:objects:count:", &v259, v271, 16);
        if (v30)
          continue;
        break;
      }
      v210 = 0;
      v217 = 0;
      v218 = 0;
      v35 = 0;
      v14 = v224;
      v18 = v219;
LABEL_33:
      v26 = v215;
    }
    else
    {
      v210 = 0;
      v217 = 0;
      v218 = 0;
      v35 = 0;
      v32 = v242;
    }

    v22 = v239;
    if ((v35 & 1) == 0 && v18)
    {
      v56 = GTPostVertexDataError(1u, CFSTR("Internal error: Missing mesh reflection"), 0, 0);
      v38 = 0;
      *a12 = (id)objc_claimAutoreleasedReturnValue(v56);
      v15 = v237;
      v16 = v238;
      goto LABEL_122;
    }
    v16 = v238;
    if ((objc_opt_respondsToSelector(v239, "setGpuCompilerSPIOptions:") & 1) == 0)
    {
      v71 = GTPostVertexDataError(3u, CFSTR("Post-vertex data fetch for mesh pipelines is not supported"), CFSTR("Update target OS to the latest version"), 0);
      v38 = 0;
      *a12 = (id)objc_claimAutoreleasedReturnValue(v71);
      v15 = v237;
      goto LABEL_122;
    }
    v220 = v18;
    v267 = CFSTR("enable-post-mesh-dump-instrumentation");
    v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSNull null](NSNull, "null"));
    v268 = v57;
    v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v268, &v267, 1));
    objc_msgSend(v239, "setGpuCompilerSPIOptions:", v58);

    v250 = 0;
    v249 = 0;
    v59 = objc_msgSend(v238, "newRenderPipelineStateWithMeshDescriptor:options:reflection:error:", v239, 0x200000001, &v250, &v249);
    v60 = v250;
    v61 = v249;
    v214 = v60;
    v216 = v59;
    v236 = v61;
    if (v59)
    {
      v225 = v14;
      v245 = 0u;
      v246 = 0u;
      v247 = 0u;
      v248 = 0u;
      obja = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v60, "meshBindings"));
      v62 = objc_msgSend(obja, "countByEnumeratingWithState:objects:count:", &v245, v266, 16);
      if (v62)
      {
        v63 = v62;
        v64 = *(_QWORD *)v246;
LABEL_41:
        v65 = 0;
        while (1)
        {
          if (*(_QWORD *)v246 != v64)
            objc_enumerationMutation(obja);
          v66 = *(void **)(*((_QWORD *)&v245 + 1) + 8 * v65);
          v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v66, "name"));
          if (objc_msgSend(v67, "isEqualToString:", CFSTR("__post_mesh_dump_impl_trace_buffer")))
          {
            v68 = objc_msgSend(v66, "type");

            if (!v68)
            {
              v169 = objc_msgSend(v66, "index");
              v80 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v66, "bufferStructType"));
              v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v80, "memberByName:", CFSTR("size")));
              v168 = (char *)objc_msgSend(v81, "offset");
              v82 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v80, "memberByName:", CFSTR("os_tg_bounds")));
              v167 = (char *)objc_msgSend(v82, "offset");
              v83 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v82, "arrayType"));
              v166 = (unint64_t)objc_msgSend(v83, "stride");
              v84 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v80, "memberByName:", CFSTR("num_dumped_mesh_threadgroups")));
              v189 = (char *)objc_msgSend(v84, "offset");
              v85 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v80, "memberByName:", CFSTR("max_ms_tg_ids")));
              v186 = (char *)objc_msgSend(v85, "offset");

              v207 = v80;
              v86 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v80, "memberByName:", CFSTR("mesh_data")));
              v209 = objc_msgSend(v86, "offset");
              v205 = v86;
              v87 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v86, "arrayType"));
              v212 = objc_msgSend(v87, "stride");
              v203 = v87;
              v88 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v87, "elementStructType"));
              v201 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "memberByName:", CFSTR("primitive_count")));
              v188 = objc_msgSend(v201, "offset");
              v199 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "memberByName:", CFSTR("amplification_id")));
              v187 = objc_msgSend(v199, "offset");
              v197 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "memberByName:", CFSTR("object_threadgroup_position_in_grid")));
              v185 = objc_msgSend(v197, "offset");
              v196 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "memberByName:", CFSTR("threadgroup_position_in_grid")));
              v184 = objc_msgSend(v196, "offset");
              v195 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "memberByName:", CFSTR("indices")));
              v183 = objc_msgSend(v195, "offset");
              v194 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "memberByName:", CFSTR("indices_present")));
              v182 = objc_msgSend(v194, "offset");
              v89 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "memberByName:", CFSTR("indices_thread_id")));
              v181 = objc_msgSend(v89, "offset");
              v193 = v89;
              if (v218)
              {
                v90 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v89, "arrayType"));
                v180 = objc_msgSend(v90, "stride");

              }
              else
              {
                v180 = 0;
              }
              v32 = v242;
              v192 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "memberByName:", CFSTR("vertices_present")));
              v179 = objc_msgSend(v192, "offset");
              v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "memberByName:", CFSTR("vertices_thread_id")));
              v178 = objc_msgSend(v92, "offset");
              if (v217)
              {
                v93 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v92, "arrayType"));
                v177 = objc_msgSend(v93, "stride");

              }
              else
              {
                v177 = 0;
              }
              v191 = v92;
              v94 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "memberByName:", CFSTR("vertices")));
              v175 = objc_msgSend(v94, "offset");
              if (v217)
              {
                v95 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v94, "arrayType"));
                v96 = objc_msgSend(v95, "stride");
                v221 = objc_claimAutoreleasedReturnValue(objc_msgSend(v95, "elementStructType"));

                v176 = v96;
                v170 = v96;
              }
              else
              {
                v176 = 0;
                v170 = 0;
                v221 = 0;
              }
              v97 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "memberByName:", CFSTR("primitives_present")));
              v174 = objc_msgSend(v97, "offset");
              v98 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "memberByName:", CFSTR("primitives_thread_id")));
              v173 = objc_msgSend(v98, "offset");
              if (v218)
              {
                v99 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v98, "arrayType"));
                v172 = objc_msgSend(v99, "stride");

              }
              else
              {
                v172 = 0;
              }
              v100 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "memberByName:", CFSTR("primitives")));
              v171 = objc_msgSend(v100, "offset");
              if (v218)
              {
                v101 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v100, "arrayType"));
                v190 = objc_msgSend(v101, "stride");
                v102 = v97;
                v103 = v94;
                v104 = objc_claimAutoreleasedReturnValue(objc_msgSend(v101, "elementStructType"));

                v105 = (void *)v104;
                v94 = v103;
                v97 = v102;
              }
              else
              {
                v190 = 0;
                v105 = 0;
              }

              v106 = 0;
              v107 = 1;
              v14 = v225;
              v15 = v237;
              v22 = v239;
              v108 = (void *)v221;
              if (!v221)
                goto LABEL_80;
              goto LABEL_81;
            }
          }
          else
          {

          }
          if (v63 == (id)++v65)
          {
            v63 = objc_msgSend(obja, "countByEnumeratingWithState:objects:count:", &v245, v266, 16);
            if (v63)
              goto LABEL_41;
            break;
          }
        }
      }

      if (v220)
        v69 = 1;
      else
        v69 = v35;
      if ((v69 & 1) != 0)
      {
        v70 = GTPostVertexDataError(1u, CFSTR("Internal error: Post-vertex data buffer binding is missing"), 0, 0);
        v38 = 0;
        *a12 = (id)objc_claimAutoreleasedReturnValue(v70);
        v32 = v242;
        v14 = v225;
        v15 = v237;
        v16 = v238;
LABEL_119:
        v22 = v239;
        goto LABEL_120;
      }
      v175 = 0;
      v176 = 0;
      v171 = 0;
      v172 = 0;
      v190 = 0;
      v212 = 0;
      v187 = 0;
      v188 = 0;
      v184 = 0;
      v185 = 0;
      v182 = 0;
      v183 = 0;
      v178 = 0;
      v179 = 0;
      v173 = 0;
      v174 = 0;
      v177 = 0;
      v180 = 0;
      v181 = 0;
      v169 = 0;
      v170 = 0;
      v108 = 0;
      v105 = 0;
      v107 = 0;
      v168 = 0;
      v106 = v265[46] != 0;
      v166 = 0;
      v167 = (char *)&dword_4;
      v189 = (_BYTE *)(&stru_20 + 4);
      v186 = (_BYTE *)(&stru_20 + 8);
      v209 = (_BYTE *)(&stru_20 + 12);
      v32 = v242;
      v14 = v225;
      v15 = v237;
      v22 = v239;
LABEL_80:
      if (!v217)
      {
LABEL_81:
        if (v105 || !v218)
        {
          v200 = v106;
          v204 = v105;
          v222 = v108;
          if (v107)
          {
            v110 = *(_QWORD *)(a4 + 24)
                 + (*GroupBuilder_getCommandBuffer(*(_DWORD *)(*(_QWORD *)(a3 + 112) + 12), *(_QWORD **)(*(_QWORD *)(a3 + 112) + 24), a5) << 6);
            GTMTLReplayController_defaultDispatchFunction(v231, v110);
            v111 = objc_msgSend(v32, "commandBufferForKey:", *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)v110, *(unsigned __int8 *)(v110 + 13), *(_QWORD *)(a3 + 16))+ 1));
            v206 = (void *)objc_claimAutoreleasedReturnValue(v111);
            v112 = objc_alloc_init((Class)MTLRenderPassDescriptor);
            objc_msgSend(v112, "setRenderTargetWidth:", *(_QWORD *)(v231 + 22464));
            objc_msgSend(v112, "setRenderTargetHeight:", *(_QWORD *)(v231 + 22472));
            v113 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "colorAttachments"));
            v114 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "objectAtIndexedSubscript:", 0));
            v115 = (void *)objc_claimAutoreleasedReturnValue(+[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:width:height:mipmapped:](MTLTextureDescriptor, "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", objc_msgSend(v114, "pixelFormat"), *(_QWORD *)(v231 + 22464), *(_QWORD *)(v231 + 22472), 0));

            objc_msgSend(v115, "setStorageMode:", 2);
            if (objc_msgSend(v238, "supportsMemorylessRenderTargets"))
              objc_msgSend(v115, "setStorageMode:", 3);
            v116 = objc_msgSend(v238, "newTextureWithDescriptor:", v115);
            v117 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v112, "colorAttachments"));
            v118 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v117, "objectAtIndexedSubscript:", 0));
            objc_msgSend(v118, "setTexture:", v116);

            v119 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v112, "colorAttachments"));
            v120 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v119, "objectAtIndexedSubscript:", 0));
            objc_msgSend(v120, "setLoadAction:", 0);

            v121 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v112, "colorAttachments"));
            v122 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v121, "objectAtIndexedSubscript:", 0));
            objc_msgSend(v122, "setStoreAction:", 0);

            if ((GT_SUPPORT_0 & 0x40) != 0)
              objc_msgSend(v112, "setDefaultRasterSampleCount:", 1);
            CommandEncoder = GroupBuilder_getCommandEncoder(*(_DWORD *)(*(_QWORD *)(a3 + 112) + 12), *(_QWORD **)(*(_QWORD *)(a3 + 112) + 24), a5);
            v124 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v206, "renderCommandEncoderWithDescriptor:", v112));
            v125 = *(_QWORD *)(a4 + 24) + (*CommandEncoder << 6);
            objc_msgSend(v32, "setRenderCommandEncoder:forKey:", v124, *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)v125, *(unsigned __int8 *)(v125 + 13), *(_QWORD *)(a3 + 16))+ 1));
            *(_QWORD *)(a7 + 8544) = 0;
            *(_QWORD *)(a7 + 9848) = 0;
            *(_BYTE *)(a7 + 11085) = 0;
            *(_DWORD *)(a7 + 11076) = 0;
            GTMTLReplayController_restoreDefaultRenderCommandEncoder(v124, *(_QWORD *)(v231 + 22464), *(_QWORD *)(v231 + 22472), (uint64_t *)a7, v32);
            v202 = v124;
            objc_msgSend(v124, "setRenderPipelineState:", v216);

            v14 = v225;
            v126 = v222;
          }
          else
          {
            v126 = v108;
            v202 = 0;
            v206 = 0;
          }
          v127 = objc_retainAutorelease(v15);
          v128 = objc_msgSend(v127, "contents");
          v129 = objc_msgSend(v127, "length");
          bzero(v128, (size_t)v129);
          v208 = v128;
          if (v107)
          {
            v130 = objc_msgSend(v14, "length");
            v131 = (char *)objc_msgSend(objc_retainAutorelease(v14), "bytes");
            *(_DWORD *)&v168[(_QWORD)v128] = (_DWORD)v129;
            v132 = &v167[(_QWORD)v128];
            v133 = &v167[(_QWORD)v128 + v166];
            bzero(v132, 2 * v166);
            if (v130)
            {
              v134 = *(_QWORD *)v131;
              *((_DWORD *)v132 + 2) = *((_DWORD *)v131 + 2);
              *(_QWORD *)v132 = v134;
              v135 = *(_QWORD *)(v131 + 12);
              *((_DWORD *)v133 + 2) = *((_DWORD *)v131 + 5);
              *(_QWORD *)v133 = v135;
            }
            else
            {
              *((_DWORD *)v132 + 2) = 0;
              *(_QWORD *)v132 = 0;
              *(_QWORD *)v133 = -1;
              *((_DWORD *)v133 + 2) = -1;
            }
            *(_DWORD *)&v189[(_QWORD)v208] = 0;
            objc_msgSend(v202, "setMeshBuffer:offset:atIndex:", v127, 0, v169);
            if (*(_DWORD *)(a6 + 8) >> 2 == 1073737833)
            {
              v198 = *(_QWORD *)(a9 + 240);
              v136 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "executeIndirectCommandBufferMap"));
              DYMTLDrawRenderCommandEncoder(v202, a9 + 40, v198, a9 + 152, v136);

              apr_pool_clear(*(apr_pool_t **)(a9 + 248));
              v137 = v231;
            }
            else
            {
              v137 = v231;
              GTMTLReplayController_defaultDispatchFunction(v231, a6);
            }
            v126 = v222;
            GTMTLReplayController_restoreIndirectResourceUsageForCommandBuffer(v137, a5);
            objc_msgSend(v32, "commitCommandBuffers");
            objc_msgSend(v206, "waitUntilCompleted");
            v128 = v208;
          }
          v138 = *(unsigned int *)&v189[(_QWORD)v128];
          v139 = v209 + v212 * (_DWORD)v138;
          v16 = v238;
          v140 = objc_msgSend(v238, "maxBufferLength");
          if ((unint64_t)v140 >= v139)
            v141 = v209 + v212 * (_DWORD)v138;
          else
            v141 = (unint64_t)v140;
          if (v141 >= 0x20000000)
            v142 = 0x20000000;
          else
            v142 = v141;
          if (v142 > (unint64_t)v129
            && v142 < os_proc_available_memory() - 0x10000000
            && (v143 = objc_msgSend(v238, "newBufferWithLength:options:", v142, 0)) != 0)
          {
            v144 = *(void **)(a10 + 72);
            *(_QWORD *)(a10 + 72) = v143;

            memcpy(__dst, (const void *)a7, sizeof(__dst));
            v145 = *(_OWORD *)(a9 + 208);
            v243[12] = *(_OWORD *)(a9 + 192);
            v243[13] = v145;
            v146 = *(_OWORD *)(a9 + 240);
            v243[14] = *(_OWORD *)(a9 + 224);
            v243[15] = v146;
            v147 = *(_OWORD *)(a9 + 144);
            v243[8] = *(_OWORD *)(a9 + 128);
            v243[9] = v147;
            v148 = *(_OWORD *)(a9 + 176);
            v243[10] = *(_OWORD *)(a9 + 160);
            v243[11] = v148;
            v149 = *(_OWORD *)(a9 + 80);
            v243[4] = *(_OWORD *)(a9 + 64);
            v243[5] = v149;
            v150 = *(_OWORD *)(a9 + 112);
            v243[6] = *(_OWORD *)(a9 + 96);
            v243[7] = v150;
            v151 = *(_OWORD *)(a9 + 16);
            v243[0] = *(_OWORD *)a9;
            v243[1] = v151;
            v152 = *(_OWORD *)(a9 + 48);
            v243[2] = *(_OWORD *)(a9 + 32);
            v243[3] = v152;
            v14 = v225;
            PostMeshData = GTMTLReplayController_generatePostMeshData(v231, v32, a3, a4, a5, a6, __dst, v223, v243, a10, v225, a12);
            v38 = (id)objc_claimAutoreleasedReturnValue(PostMeshData);
            v154 = v204;
            v155 = v126;
          }
          else
          {
            v156 = SaveObjectStruct(v170, v126, v23, 0, 0);
            v234 = SaveObjectStruct(v190, v204, v24, 0, 0);
            v157 = (v156 + v234 + 380) & 0xFFFFFFFFFFFFFF00;
            v232 = (unint64_t)v129 < v139;
            if ((unint64_t)v129 < v139)
              v138 = (v129 - v209) / (unint64_t)v212;
            v158 = &v186[(_QWORD)v208];
            if (v200)
            {
              v159 = objc_msgSend(v216, "maxTotalThreadgroupsPerMeshGrid");
              v160 = 0xFFFFFFFFLL;
              if ((unint64_t)v159 < 0xFFFFFFFF)
                v160 = (unint64_t)v159;
              if (v160 <= 1)
                LODWORD(v160) = 1;
              v161 = v160 - 1;
              *(_DWORD *)v158 = v161;
              *((_DWORD *)v158 + 1) = v161;
              *((_DWORD *)v158 + 2) = v161;
            }
            v272 = *(_QWORD *)v158;
            v273 = *((_DWORD *)v158 + 2);
            __na = v138 * v212;
            v38 = objc_retainAutorelease(objc_msgSend(v238, "newBufferWithLength:options:", ((__na + 255) & 0xFFFFFFFFFFFFFF00) + v157, 0));
            v162 = (char *)objc_msgSend(v38, "contents");
            *(_DWORD *)v162 = 2;
            *((_DWORD *)v162 + 1) = v157;
            *((_DWORD *)v162 + 2) = 125;
            *((_DWORD *)v162 + 3) = v156;
            *((_DWORD *)v162 + 4) = v234;
            *((_DWORD *)v162 + 5) = v210;
            *((_DWORD *)v162 + 6) = v217;
            *((_DWORD *)v162 + 7) = v175;
            *((_DWORD *)v162 + 8) = v176;
            *((_DWORD *)v162 + 9) = v218;
            *((_DWORD *)v162 + 10) = v171;
            *((_DWORD *)v162 + 11) = v190;
            *((_DWORD *)v162 + 12) = v138;
            *((_DWORD *)v162 + 13) = v212;
            *((_DWORD *)v162 + 14) = v188;
            *((_DWORD *)v162 + 15) = v187;
            *((_DWORD *)v162 + 16) = v185;
            *((_DWORD *)v162 + 17) = v184;
            *((_DWORD *)v162 + 18) = v183;
            v163 = v273;
            *(_QWORD *)(v162 + 76) = v272;
            *((_DWORD *)v162 + 21) = v163;
            *((_DWORD *)v162 + 22) = v179;
            *((_DWORD *)v162 + 23) = v174;
            *((_DWORD *)v162 + 24) = v182;
            *((_DWORD *)v162 + 25) = v178;
            *((_DWORD *)v162 + 26) = v177;
            *((_DWORD *)v162 + 27) = v173;
            *((_DWORD *)v162 + 28) = v172;
            *((_DWORD *)v162 + 29) = v181;
            *((_DWORD *)v162 + 30) = v180;
            v162[124] = v232;
            v155 = v222;
            SaveObjectStruct(v176, v222, v23, v162 + 125, v156);
            v164 = &v162[v156 + 125];
            v16 = v238;
            v154 = v204;
            SaveObjectStruct(v190, v204, v24, v164, v234);
            memcpy(&v162[v157], &v209[(_QWORD)v208], __na);
            v14 = v225;
            v15 = v237;
          }

          goto LABEL_119;
        }
      }
      v109 = GTPostVertexDataError(1u, CFSTR("Internal error: Post-vertex data buffer binding error"), 0, 0);
      *a12 = (id)objc_claimAutoreleasedReturnValue(v109);

      v38 = 0;
      v16 = v238;
LABEL_120:

      goto LABEL_121;
    }
    v72 = v61;
    v73 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v61, "domain"));
    if ((objc_msgSend(v73, "hasPrefix:", CFSTR("AGXMetal")) & 1) != 0)
    {
      v74 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "localizedDescription"));
      v75 = objc_msgSend(v74, "containsString:", CFSTR("Payload size >"));

      v15 = v237;
      if (v75)
      {
        v76 = CFSTR("Maximum tools-supported payload size exceeded");
        v77 = CFSTR("Reduce your object data payload to 16368 bytes or less");
        v78 = 3;
        v79 = 0;
LABEL_63:
        v91 = GTPostVertexDataError(v78, v76, v77, v79);
        v38 = 0;
        v22 = v239;
        *a12 = (id)objc_claimAutoreleasedReturnValue(v91);
LABEL_121:

        goto LABEL_122;
      }
    }
    else
    {

      v15 = v237;
    }
    v76 = CFSTR("Post-vertex data fetch pipeline error");
    v78 = 2;
    v77 = 0;
    v79 = v236;
    goto LABEL_63;
  }
  v37 = GTPostVertexDataError(2u, CFSTR("Post-vertex data fetch pipeline reflection error"), 0, v27);
  *a12 = (id)objc_claimAutoreleasedReturnValue(v37);

  v38 = 0;
  v32 = v242;
LABEL_122:

  return v38;
}

id GTMTLReplayController_generatePostVertexData(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, _QWORD *a11)
{
  id v15;
  unint64_t v16;
  id v17;
  uint64_t i;
  _QWORD *v19;
  void *v20;
  id MTLRenderPipelineDescriptorWithoutResourceIndex;
  void *v22;
  id v23;
  id v24;
  id v25;
  unint64_t v26;
  id v27;
  unsigned int *v28;
  uint64_t v29;
  id v30;
  id v31;
  void *v32;
  id v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  const void *v40;
  _QWORD *CommandEncoder;
  void *v42;
  uint64_t v43;
  double v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  id v48;
  void *v49;
  id v50;
  uint64_t v51;
  unint64_t v52;
  id v53;
  void *v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  uint64_t PostVertexData;
  void *v64;
  unint64_t v65;
  uint64_t v66;
  unsigned int v67;
  size_t v68;
  char *v69;
  unsigned int *v71;
  id v72;
  void *v73;
  id v74;
  void *v75;
  uint64_t v76;
  id v77;
  uint64_t v78;
  uint64_t v79;
  void *v80;
  void *v81;
  void *v85;
  _OWORD v86[16];
  _BYTE __dst[11096];
  id v88;
  id v89;
  _QWORD v90[191];

  v15 = a2;
  v16 = 63 - __clz(~(*(_DWORD *)(a8 + 128) | *(_DWORD *)(a8 + 120)) & 0x7FFFFFFF);
  v17 = *(id *)(a10 + 72);
  v85 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "device"));
  if ((unint64_t)objc_msgSend(v85, "maxVertexBuffers") <= v16)
  {
    v48 = GTPostVertexDataError(1u, CFSTR("Internal error: Post-vertex data buffer binding error"), 0, 0);
    v23 = 0;
    *a11 = (id)objc_claimAutoreleasedReturnValue(v48);
  }
  else
  {
    v79 = a6;
    memcpy(v90, *(const void **)(a8 + 48), 0x5E8uLL);
    for (i = 0; i != 16; i += 2)
    {
      v19 = &v90[i];
      *((_WORD *)v19 + 372) = 0;
      *((_BYTE *)v19 + 747) = 0;
    }
    v78 = a7;
    WORD2(v90[167]) = 0;
    LOWORD(v90[169]) = 0;
    BYTE3(v90[187]) = 0;
    LOWORD(v90[93]) = 70;
    v90[147] = 0;
    memset(&v90[109], 0, 64);
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 8), "renderPipelineDescriptorMap"));
    MTLRenderPipelineDescriptorWithoutResourceIndex = MakeMTLRenderPipelineDescriptorWithoutResourceIndex((uint64_t)v90, v20);
    v22 = (void *)objc_claimAutoreleasedReturnValue(MTLRenderPipelineDescriptorWithoutResourceIndex);

    objc_msgSend(v22, "setLabel:", CFSTR("GPUToolsInternalPostTransformPipelineStateLabel"));
    objc_msgSend(v22, "setRasterizationEnabled:", 0);
    if ((GT_SUPPORT_0 & 0x20) != 0)
    {
      objc_msgSend(v22, "setTessellationPartitionMode:", 1);
      objc_msgSend(v22, "setMaxTessellationFactor:", 1);
      objc_msgSend(v22, "setTessellationFactorScaleEnabled:", 1);
    }
    objc_msgSend(v22, "setPostVertexDumpBufferIndex:", v16);
    v89 = 0;
    v88 = 0;
    v23 = objc_msgSend(v85, "newRenderPipelineStateWithDescriptor:options:reflection:error:", v22, 0x80000, &v89, &v88);
    v24 = v89;
    v25 = v88;
    v81 = v23;
    if (v23)
    {
      v72 = v25;
      v73 = v24;
      v26 = (unint64_t)objc_msgSend(v24, "postVertexDumpStride");
      v74 = v17;
      v27 = objc_retainAutorelease(v17);
      v28 = (unsigned int *)objc_msgSend(v27, "contents");
      *v28 = 0;
      v77 = v27;
      v76 = v26;
      v71 = v28;
      v28[1] = ((unint64_t)objc_msgSend(v27, "length") - 8) / v26;
      v29 = *(_QWORD *)(a4 + 24)
          + (*GroupBuilder_getCommandBuffer(*(_DWORD *)(*(_QWORD *)(a3 + 112) + 12), *(_QWORD **)(*(_QWORD *)(a3 + 112) + 24), a5) << 6);
      GTMTLReplayController_defaultDispatchFunction(a1, v29);
      v75 = v15;
      v30 = objc_msgSend(v15, "commandBufferForKey:", *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)v29, *(unsigned __int8 *)(v29 + 13), *(_QWORD *)(a3 + 16))+ 1));
      v80 = (void *)objc_claimAutoreleasedReturnValue(v30);
      v31 = objc_alloc_init((Class)MTLRenderPassDescriptor);
      objc_msgSend(v31, "setRenderTargetWidth:", *(_QWORD *)(a1 + 22464));
      objc_msgSend(v31, "setRenderTargetHeight:", *(_QWORD *)(a1 + 22472));
      v32 = (void *)objc_claimAutoreleasedReturnValue(+[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:width:height:mipmapped:](MTLTextureDescriptor, "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", LOWORD(v90[93]), *(_QWORD *)(a1 + 22464), *(_QWORD *)(a1 + 22472), 0));
      objc_msgSend(v32, "setStorageMode:", 2);
      if (objc_msgSend(v85, "supportsMemorylessRenderTargets"))
        objc_msgSend(v32, "setStorageMode:", 3);
      v33 = objc_msgSend(v85, "newTextureWithDescriptor:", v32);
      v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v31, "colorAttachments"));
      v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v34, "objectAtIndexedSubscript:", 0));
      objc_msgSend(v35, "setTexture:", v33);

      v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v31, "colorAttachments"));
      v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v36, "objectAtIndexedSubscript:", 0));
      objc_msgSend(v37, "setLoadAction:", 0);

      v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v31, "colorAttachments"));
      v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v38, "objectAtIndexedSubscript:", 0));
      objc_msgSend(v39, "setStoreAction:", 0);

      v40 = (const void *)v78;
      if ((GT_SUPPORT_0 & 0x40) != 0)
        objc_msgSend(v31, "setDefaultRasterSampleCount:", 1);
      CommandEncoder = GroupBuilder_getCommandEncoder(*(_DWORD *)(*(_QWORD *)(a3 + 112) + 12), *(_QWORD **)(*(_QWORD *)(a3 + 112) + 24), a5);
      v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v80, "renderCommandEncoderWithDescriptor:", v31));
      v43 = *(_QWORD *)(a4 + 24) + (*CommandEncoder << 6);
      v15 = v75;
      objc_msgSend(v75, "setRenderCommandEncoder:forKey:", v42, *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)v43, *(unsigned __int8 *)(v43 + 13), *(_QWORD *)(a3 + 16))+ 1));
      *(_QWORD *)(v78 + 8544) = 0;
      *(_QWORD *)(v78 + 9848) = 0;
      *(_BYTE *)(v78 + 11085) = 0;
      *(_DWORD *)(v78 + 11076) = 0;
      GTMTLReplayController_restoreDefaultRenderCommandEncoder(v42, *(_QWORD *)(a1 + 22464), *(_QWORD *)(a1 + 22472), (uint64_t *)v78, v75);

      if ((GT_SUPPORT_0 & 0x20) != 0)
      {
        LODWORD(v44) = 925353388;
        objc_msgSend(v42, "setTessellationFactorScale:", v44);
      }
      objc_msgSend(v42, "setRenderPipelineState:", v81);
      objc_msgSend(v42, "setVertexBuffer:offset:atIndex:", v77, 0, v16);
      v45 = v79;
      if (*(_DWORD *)(v79 + 8) >> 2 == 1073737833)
      {
        v46 = *(_QWORD *)(a9 + 240);
        v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v75, "executeIndirectCommandBufferMap"));
        v45 = v79;
        DYMTLDrawRenderCommandEncoder(v42, a9 + 40, v46, a9 + 152, v47);

        v40 = (const void *)v78;
        apr_pool_clear(*(apr_pool_t **)(a9 + 248));
      }
      else
      {
        GTMTLReplayController_defaultDispatchFunction(a1, v79);
      }
      GTMTLReplayController_restoreIndirectResourceUsageForCommandBuffer(a1, a5);
      objc_msgSend(v75, "commitCommandBuffers");
      objc_msgSend(v80, "waitUntilCompleted");
      v51 = *v71;
      if (v51 <= v71[1] || (v52 = v76 * v51 + 8, v52 >= os_proc_available_memory() - 0x10000000))
      {
        v24 = v73;
        v64 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v73, "postVertexDumpOutputs"));
        v65 = (SaveObject(v76, v64, 0, 0) + 259) & 0xFFFFFFFFFFFFFF00;
        LODWORD(v66) = *v71;
        v67 = v71[1];
        if (*v71 >= v67)
          v66 = v67;
        else
          v66 = v66;
        v68 = (v76 * v66 + 263) & 0xFFFFFFFFFFFFFF00;
        v23 = objc_retainAutorelease(objc_msgSend(v85, "newBufferWithLength:options:", v68 + v65, 0));
        v69 = (char *)objc_msgSend(v23, "contents");
        *(_DWORD *)v69 = v65;
        SaveObject(v76, v64, v69 + 4, v65 - 4);
        memcpy(&v69[v65], objc_msgSend(objc_retainAutorelease(v77), "contents"), v68);

        v17 = v74;
      }
      else
      {
        v53 = objc_msgSend(v85, "newBufferWithLength:options:", v52, 0);
        v54 = *(void **)(a10 + 72);
        *(_QWORD *)(a10 + 72) = v53;

        memcpy(__dst, v40, sizeof(__dst));
        v55 = *(_OWORD *)(a9 + 208);
        v86[12] = *(_OWORD *)(a9 + 192);
        v86[13] = v55;
        v56 = *(_OWORD *)(a9 + 240);
        v86[14] = *(_OWORD *)(a9 + 224);
        v86[15] = v56;
        v57 = *(_OWORD *)(a9 + 144);
        v86[8] = *(_OWORD *)(a9 + 128);
        v86[9] = v57;
        v58 = *(_OWORD *)(a9 + 176);
        v86[10] = *(_OWORD *)(a9 + 160);
        v86[11] = v58;
        v59 = *(_OWORD *)(a9 + 80);
        v86[4] = *(_OWORD *)(a9 + 64);
        v86[5] = v59;
        v60 = *(_OWORD *)(a9 + 112);
        v86[6] = *(_OWORD *)(a9 + 96);
        v86[7] = v60;
        v61 = *(_OWORD *)(a9 + 16);
        v86[0] = *(_OWORD *)a9;
        v86[1] = v61;
        v62 = *(_OWORD *)(a9 + 48);
        v86[2] = *(_OWORD *)(a9 + 32);
        v86[3] = v62;
        PostVertexData = GTMTLReplayController_generatePostVertexData(a1, v75, a3, a4, a5, v45, __dst, a8, v86, a10, a11);
        v23 = (id)objc_claimAutoreleasedReturnValue(PostVertexData);
        v24 = v73;
        v17 = v74;
      }

      v49 = v72;
    }
    else
    {
      v49 = v25;
      v50 = GTPostVertexDataError(2u, CFSTR("Post-vertex data fetch pipeline error"), 0, v25);
      *a11 = (id)objc_claimAutoreleasedReturnValue(v50);
    }

  }
  return v23;
}

id GTPostVertexDataError(unsigned int a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id v10;
  void *v11;

  v7 = a3;
  v8 = a4;
  v9 = a2;
  v10 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithObjectsAndKeys:", v9, NSLocalizedDescriptionKey, 0);

  if (v7)
    objc_msgSend(v10, "setObject:forKeyedSubscript:", v7, NSLocalizedRecoverySuggestionErrorKey);
  if (v8)
    objc_msgSend(v10, "setObject:forKeyedSubscript:", v8, NSUnderlyingErrorKey);
  v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("GTPostVertexDumpErrorDomain"), a1, v10));

  return v11;
}

uint64_t SaveObject(uint64_t a1, void *a2, _QWORD *a3, unint64_t a4)
{
  id v7;
  void *v8;
  uint64_t v9;
  id v10;
  id v11;
  id v12;
  uint64_t v13;
  void *i;
  void *v15;
  id v16;
  id v17;
  uint64_t v18;
  id v19;
  id v20;
  id v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  _BYTE v30[128];

  v7 = a2;
  v8 = v7;
  v27 = a3;
  v29 = a4;
  if (a4 >= 8 && (*a3 = 81, a4 > 0xF))
  {
    a3[1] = a1;
    v22 = objc_msgSend(v7, "count");
    if (a4 >= 0x18)
      a3[2] = v22;
  }
  else
  {
    objc_msgSend(v7, "count");
  }
  v9 = 24;
  v28 = 24;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  v10 = v8;
  v11 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v23, v30, 16);
  if (v11)
  {
    v12 = v11;
    v13 = *(_QWORD *)v24;
    do
    {
      for (i = 0; i != v12; i = (char *)i + 1)
      {
        if (*(_QWORD *)v24 != v13)
          objc_enumerationMutation(v10);
        v15 = *(void **)(*((_QWORD *)&v23 + 1) + 8 * (_QWORD)i);
        v16 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "airMDType", (_QWORD)v23)));
        WriteDynamicBufferString(&v27, (const char *)objc_msgSend(v16, "UTF8String"));

        v17 = objc_msgSend(v15, "dataType");
        v18 = v28 + 8;
        if (v28 + 8 <= v29)
          *(_QWORD *)((char *)v27 + v28) = v17;
        v28 = v18;
        v19 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "name")));
        WriteDynamicBufferString(&v27, (const char *)objc_msgSend(v19, "UTF8String"));

        v20 = objc_msgSend(v15, "offset");
        v9 = v28 + 8;
        if (v28 + 8 <= v29)
          *(_QWORD *)((char *)v27 + v28) = v20;
        v28 = v9;
      }
      v12 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v23, v30, 16);
    }
    while (v12);
  }

  return v9;
}

void WriteDynamicBufferString(_QWORD *a1, const char *a2)
{
  const char *v3;
  size_t v4;
  size_t v5;
  size_t v6;
  uint64_t v7;
  size_t v8;
  unint64_t v9;
  BOOL v10;
  size_t v11;
  size_t v12;

  if (a2)
    v3 = a2;
  else
    v3 = "";
  v4 = strlen(v3);
  v5 = v4 + 1;
  v7 = a1[1];
  v6 = a1[2];
  v8 = v7 + v4 + 1;
  if (v8 <= v6)
  {
    memcpy((void *)(*a1 + v7), v3, v5);
    v6 = a1[2];
    v8 = a1[1] + v5;
  }
  a1[1] = v8;
  v9 = (v4 & 0xFFFFFFFFFFFFFFF8) + ~v4 + 8;
  v10 = v6 > v8;
  v11 = v6 - v8;
  if (v10)
  {
    if (v11 >= v9)
      v12 = v9;
    else
      v12 = v11;
    bzero((void *)(*a1 + v8), v12);
    v8 = a1[1];
  }
  a1[1] = v8 + v9;
}

uint64_t SaveObjectStruct(uint64_t a1, void *a2, void *a3, _QWORD *a4, unint64_t a5)
{
  id v9;
  id v10;
  void *v11;
  id v12;
  uint64_t v13;
  void *v14;
  void *i;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  __CFString *v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  unint64_t v25;
  uint64_t v26;
  id v27;
  char *v28;
  id v29;
  uint64_t v30;
  uint64_t v31;
  id v32;
  uint64_t v33;
  id v35;
  id v36;
  id obj;
  uint64_t v38;
  id v39;
  void *v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  _QWORD *v45;
  uint64_t v46;
  unint64_t v47;
  _BYTE v48[128];

  v9 = a2;
  v10 = a3;
  v45 = a4;
  v47 = a5;
  if (a5 >= 8)
  {
    *a4 = 81;
    if (a5 >= 0x10)
      a4[1] = a1;
  }
  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "members"));
  v12 = objc_msgSend(v11, "count");
  if (a5 >= 0x18)
    a4[2] = v12;
  v13 = 24;
  v46 = 24;

  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  obj = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "members"));
  v39 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v41, v48, 16);
  if (v39)
  {
    v35 = v9;
    v36 = v10;
    v38 = *(_QWORD *)v42;
    v14 = obj;
    while (1)
    {
      for (i = 0; i != v39; i = (char *)i + 1)
      {
        if (*(_QWORD *)v42 != v38)
          objc_enumerationMutation(v14);
        v16 = *(void **)(*((_QWORD *)&v41 + 1) + 8 * (_QWORD)i);
        v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "name"));
        v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "componentsSeparatedByString:", CFSTR("/")));
        v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "objectAtIndexedSubscript:", 0));
        v20 = &stru_7282A8;
        if ((unint64_t)objc_msgSend(v18, "count") >= 2)
          v20 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "objectAtIndexedSubscript:", 1));
        v40 = v17;
        if (-[__CFString length](v20, "length")
          || objc_msgSend(v19, "isEqualToString:", CFSTR("air.position")))
        {
          v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", v20));
          if (objc_msgSend(v16, "dataType") != (char *)&dword_0 + 2)
          {
            if (v21)
            {
              v24 = objc_msgSend(v21, "unsignedIntegerValue");
            }
            else
            {
LABEL_33:
              v24 = objc_msgSend(v16, "dataType");
              v21 = 0;
            }
LABEL_34:
            WriteDynamicBufferString(&v45, (const char *)objc_msgSend(objc_retainAutorelease(v19), "UTF8String"));
            v31 = v46 + 8;
            if (v46 + 8 <= v47)
              *(_QWORD *)((char *)v45 + v46) = v24;
            v46 = v31;
            WriteDynamicBufferString(&v45, (const char *)-[__CFString UTF8String](objc_retainAutorelease(v20), "UTF8String"));
            v32 = objc_msgSend(v16, "offset");
            v33 = v46 + 8;
            if (v46 + 8 <= v47)
              *(_QWORD *)((char *)v45 + v46) = v32;
            v23 = 0;
            v46 = v33;
            goto LABEL_39;
          }
        }
        else
        {
          if (objc_msgSend(v16, "dataType") != (char *)&dword_0 + 2)
            goto LABEL_33;
          v21 = 0;
        }
        v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "arrayType"));
        v23 = v22;
        if (v21)
        {
          v24 = objc_msgSend(v21, "unsignedIntegerValue");
          if (!v23)
            goto LABEL_34;
        }
        else
        {
          if (!v22)
            goto LABEL_33;
          v24 = objc_msgSend(v22, "elementType");
        }
        if (objc_msgSend(v23, "arrayLength"))
        {
          v25 = 0;
          do
          {
            WriteDynamicBufferString(&v45, (const char *)objc_msgSend(objc_retainAutorelease(v19), "UTF8String"));
            v26 = v46 + 8;
            if (v46 + 8 <= v47)
              *(_QWORD *)((char *)v45 + v46) = v24;
            v46 = v26;
            v27 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(-[__CFString stringByAppendingFormat:](v20, "stringByAppendingFormat:", CFSTR("[%lu]"), v25)));
            WriteDynamicBufferString(&v45, (const char *)objc_msgSend(v27, "UTF8String"));

            v28 = (char *)objc_msgSend(v16, "offset");
            v29 = objc_msgSend(v23, "stride");
            v30 = v46 + 8;
            if (v46 + 8 <= v47)
              *(_QWORD *)((char *)v45 + v46) = &v28[(_QWORD)v29 * v25];
            v46 = v30;
            ++v25;
          }
          while (v25 < (unint64_t)objc_msgSend(v23, "arrayLength"));
          v10 = v36;
          v14 = obj;
        }
LABEL_39:

      }
      v39 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v41, v48, 16);
      if (!v39)
      {
        v13 = v46;
        v9 = v35;
        break;
      }
    }
  }

  return v13;
}

void sub_2AE278(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_2AE350(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_2AE5CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{

  _Unwind_Resume(a1);
}

void sub_2AE930(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20)
{
  void *v20;
  void *v21;
  void *v22;
  unint64_t v23;
  unint64_t v24;
  void *v25;

  if (v24 > v23)
  _Unwind_Resume(a1);
}

void sub_2AEB68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_2AEBFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_2AEE10(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

void sub_2AEFC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

id getRenderPipelineBinaries(void *a1)
{
  id v1;
  uint64_t v2;
  void *v3;
  void *v4;

  v1 = DEVICEOBJECT(a1);
  v2 = objc_claimAutoreleasedReturnValue(v1);
  v3 = (void *)v2;
  if ((dword_75313C & 0x200) != 0 && (objc_opt_respondsToSelector(v2, "pipelineBinaries") & 1) != 0)
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "pipelineBinaries"));
  else
    v4 = &__NSDictionary0__struct;

  return v4;
}

void sub_2AF12C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id getComputePipelineBinaries(void *a1)
{
  id v1;
  uint64_t v2;
  void *v3;
  void *v4;

  v1 = DEVICEOBJECT(a1);
  v2 = objc_claimAutoreleasedReturnValue(v1);
  v3 = (void *)v2;
  if ((dword_75313C & 0x200) != 0 && (objc_opt_respondsToSelector(v2, "pipelineBinaries") & 1) != 0)
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "pipelineBinaries"));
  else
    v4 = &__NSDictionary0__struct;

  return v4;
}

void sub_2AF1A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void GTMTLReplayController_dispatchForUSCSampling(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6)
{
  id v11;
  int v12;
  char *v13;
  void *v14;
  void *v15;
  char *v16;
  char *v17;
  id v18;
  id RenderPipelineBinaries;
  void *v20;
  char *v21;
  id ComputePipelineBinaries;
  void *v23;
  id v24;

  v24 = a3;
  v11 = a5;
  if ((dword_75313C & 0x200) == 0)
    goto LABEL_2;
  v12 = *(_DWORD *)(a2 + 8);
  if (v12 <= -16286)
  {
    if (v12 == -16337)
    {
      v21 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a4);
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "computeCommandEncoderForKey:", *(_QWORD *)v21));
      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "computePipelineStateForKey:", *((_QWORD *)v21 + 1)));
      GTMTLReplayController_defaultDispatchFunction(a1, a2);
      ComputePipelineBinaries = getComputePipelineBinaries(v15);
      v23 = (void *)objc_claimAutoreleasedReturnValue(ComputePipelineBinaries);
      objc_msgSend(v11, "addBinaries:", v23);

      goto LABEL_14;
    }
    if (v12 == -16325)
    {
      v16 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a4);
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "computeCommandEncoderForKey:", *(_QWORD *)v16));
      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "endEncodingAndRetrieveProgramAddressTable"));
      objc_msgSend(v11, "addProgramAddressTable:forEncoder:atEncoderIndex:", v15, objc_msgSend(v24, "globalTraceIdForEncoder:ofType:", *(_QWORD *)v16, 0), a6);
      objc_msgSend(v24, "removeComputeCommandEncoderForKey:", *(_QWORD *)v16);
      goto LABEL_14;
    }
  }
  else
  {
    switch(v12)
    {
      case -16285:
        v17 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a4);
        v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "parallelRenderCommandEncoderForKey:", *(_QWORD *)v17));
        v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "endEncodingAndRetrieveProgramAddressTable"));
        objc_msgSend(v11, "addProgramAddressTable:forEncoder:atEncoderIndex:", v15, objc_msgSend(v24, "globalTraceIdForEncoder:ofType:", *(_QWORD *)v17, 1), a6);
        objc_msgSend(v24, "removeRenderCommandEncoderForKey:", *(_QWORD *)v17);
        goto LABEL_14;
      case -16279:
        v18 = objc_msgSend(v24, "renderPipelineStateForKey:", *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a4) + 1));
        v14 = (void *)objc_claimAutoreleasedReturnValue(v18);
        RenderPipelineBinaries = getRenderPipelineBinaries(v14);
        v20 = (void *)objc_claimAutoreleasedReturnValue(RenderPipelineBinaries);
        objc_msgSend(v11, "addBinaries:", v20);

        GTMTLReplayController_defaultDispatchFunction(a1, a2);
LABEL_15:

        goto LABEL_16;
      case -16246:
        v13 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a4);
        v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "renderCommandEncoderForKey:", *(_QWORD *)v13));
        v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "endEncodingAndRetrieveProgramAddressTable"));
        objc_msgSend(v11, "addProgramAddressTable:forEncoder:atEncoderIndex:", v15, objc_msgSend(v24, "globalTraceIdForEncoder:ofType:", *(_QWORD *)v13, 0), a6);
        objc_msgSend(v24, "removeRenderCommandEncoderForKey:", *(_QWORD *)v13);
LABEL_14:

        goto LABEL_15;
    }
  }
LABEL_2:
  GTMTLReplayController_defaultDispatchFunction(a1, a2);
LABEL_16:

}

void sub_2AF488(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void ProcessMessage(uint64_t a1, void *a2, void *a3)
{
  id v5;
  unsigned int v6;
  os_signpost_id_t v7;
  int v8;
  void *v9;
  NSObject *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  NSObject *v17;
  void *v18;
  NSObject *v19;
  void *v20;
  void *v21;
  void *v22;
  id v23;
  void *v24;
  id v25;
  void *v26;
  void *v27;
  NSObject *v28;
  id v29;
  void *v30;
  NSObject *v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  void *v35;
  void *v36;
  id v37;
  void *v38;
  NSObject *v39;
  void *v40;
  void *v41;
  NSObject *v42;
  uint64_t v43;
  void *v44;
  id v45;
  void *v46;
  void *v47;
  NSObject *v48;
  void *v49;
  void *v50;
  NSObject *v51;
  void *v52;
  void *v53;
  void *v54;
  NSObject *v55;
  dispatch_semaphore_t v56;
  void *v57;
  NSObject *v58;
  id v59;
  void *v60;
  NSObject *v61;
  void *v62;
  id v63;
  void *v64;
  NSObject *v65;
  void *v66;
  void *v67;
  int v68;
  void *v69;
  NSObject *v70;
  int v71;
  void *v72;
  void *v73;
  int v74;
  void *v75;
  int v76;
  void *v77;
  NSObject *v78;
  double v79;
  void *v80;
  void *v81;
  void *v82;
  void *v83;
  NSObject *v84;
  dispatch_semaphore_t v85;
  void *v86;
  id v87;
  id v88;
  NSObject *v89;
  _BOOL8 v90;
  id v91;
  void *v92;
  void *v93;
  void *v94;
  NSObject *v95;
  void *v96;
  NSObject *v97;
  void *v98;
  void *v99;
  NSObject *v100;
  void *v101;
  void *v102;
  void *v103;
  _QWORD *v104;
  void *v105;
  NSObject *v106;
  void *v107;
  void *v108;
  NSObject *v109;
  void *v110;
  void *v111;
  void *v112;
  void *v113;
  void *v114;
  void *v115;
  int v116;
  void *v117;
  int v118;
  void *v119;
  void *v120;
  NSObject *v121;
  void *v122;
  void *v123;
  NSObject *v124;
  void *v125;
  void *v126;
  NSObject *v127;
  void *v128;
  id v129;
  void *v130;
  io_registry_entry_t v131;
  id MetalPluginName;
  const char *v133;
  unsigned int v134;
  unsigned int v135;
  id DerivedDataPayload;
  void *v137;
  BOOL v138;
  void *v139;
  BOOL v140;
  void *v141;
  BOOL v142;
  void *v143;
  BOOL v144;
  void *v145;
  void *v146;
  BOOL v147;
  void *v148;
  void *v149;
  BOOL v150;
  void *v151;
  void *v152;
  BOOL v153;
  void *v154;
  void *v155;
  BOOL v156;
  void *v157;
  uint64_t v158;
  apr_allocator_t *v159;
  uint64_t v160;
  void *v161;
  id v162;
  void *v163;
  void *v164;
  void *v165;
  dispatch_semaphore_t v166;
  uint64_t v167;
  id *v168;
  NSObject *v169;
  id v170;
  NSObject *v171;
  uint64_t v172;
  void *v173;
  const __CFString *v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  id v179;
  void *v180;
  void *v181;
  void *v182;
  id v183;
  uint64_t v184;
  NSObject *v185;
  void *v186;
  void *v187;
  void *v188;
  void *v189;
  void *v190;
  id v191;
  uint64_t v192;
  void *v193;
  void *v194;
  void *v195;
  void *v196;
  void *v197;
  void *v198;
  NSObject *v199;
  __CFString *v200;
  void *v201;
  void *v202;
  id v203;
  id v204;
  id v205;
  uint64_t v206;
  void *i;
  void *v208;
  void *v209;
  void *v210;
  void *v211;
  void *v212;
  void *v213;
  NSObject *v214;
  void *v215;
  void *v216;
  NSObject *v217;
  uint64_t v218;
  void *v219;
  void *v220;
  id v221;
  void *v222;
  void *v223;
  void *v224;
  uint64_t v225;
  void *v226;
  BOOL v227;
  void *v228;
  void *v229;
  void *context;
  void *v231;
  void *v232;
  void *v233;
  void *v234;
  void *v235;
  void *v236;
  id v237;
  void *v238;
  void *v239;
  void *v240;
  id v241;
  _QWORD v242[4];
  id v243;
  id v244;
  uint64_t v245;
  id v246;
  id v247;
  os_signpost_id_t v248;
  unsigned int v249;
  _QWORD v250[4];
  id v251;
  id v252;
  os_signpost_id_t v253;
  uint64_t v254;
  unsigned int v255;
  uint64_t v256;
  _QWORD v257[4];
  id v258;
  id v259;
  NSObject *v260;
  uint64_t v261;
  _QWORD v262[4];
  id v263;
  id v264;
  os_signpost_id_t v265;
  uint64_t v266;
  unsigned int v267;
  _QWORD v268[6];
  id v269;
  uint64_t v270;
  os_signpost_id_t v271;
  unsigned int v272;
  _QWORD v273[8];
  unsigned int v274;
  _QWORD v275[6];
  id v276;
  _QWORD v277[4];
  id v278;
  id v279;
  uint64_t v280;
  os_signpost_id_t v281;
  unsigned int v282;
  id v283;
  uint64_t v284;
  _QWORD v285[4];
  NSObject *v286;
  id v287;
  uint8_t *v288;
  __int128 *v289;
  _QWORD v290[4];
  id v291;
  id v292;
  os_signpost_id_t v293;
  uint64_t v294;
  unsigned int v295;
  _QWORD v296[4];
  id v297;
  id v298;
  os_signpost_id_t v299;
  uint64_t v300;
  unsigned int v301;
  _QWORD v302[4];
  id v303;
  id v304;
  os_signpost_id_t v305;
  uint64_t v306;
  unsigned int v307;
  _QWORD v308[4];
  id v309;
  id v310;
  os_signpost_id_t v311;
  uint64_t v312;
  unsigned int v313;
  _QWORD v314[4];
  id v315;
  id v316;
  _QWORD v317[4];
  id v318;
  id v319;
  uint64_t v320;
  os_signpost_id_t v321;
  unsigned int v322;
  _QWORD block[5];
  _QWORD v324[4];
  id v325;
  id v326;
  id v327;
  dispatch_semaphore_t v328;
  uint64_t v329;
  _QWORD v330[4];
  id v331;
  id v332;
  os_signpost_id_t v333;
  unsigned int v334;
  _QWORD v335[4];
  id v336;
  id v337;
  os_signpost_id_t v338;
  uint64_t v339;
  unsigned int v340;
  uint64_t v341;
  _QWORD v342[4];
  id v343;
  id v344;
  uint64_t v345;
  __int128 v346;
  __int128 v347;
  __int128 v348;
  __int128 v349;
  const __CFString *v350;
  void *v351;
  const __CFString *v352;
  void *v353;
  _QWORD v354[3];
  _QWORD v355[3];
  uint8_t buf[8];
  __int128 v357;
  char v358;
  NSURLResourceKey v359;

  v241 = a2;
  v5 = a3;
  v6 = objc_msgSend(v5, "serial");
  v7 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, v5);
  v240 = objc_autoreleasePoolPush();
  v8 = objc_msgSend(v5, "kind");
  if (v8 <= 1793)
  {
    if (v8 > 1536)
    {
      switch(v8)
      {
        case 1537:
          v45 = v241;
          v46 = (void *)objc_claimAutoreleasedReturnValue(+[GTTransportMessage_replayer messageWithKind:attributes:](GTTransportMessage_replayer, "messageWithKind:attributes:", 4096, &off_739310));
          objc_msgSend(v45, "send:error:", v46, 0);
LABEL_44:

LABEL_45:
          break;
        case 1540:
          v47 = g_signpostLog;
          v48 = v47;
          if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v47))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&buf[4] = v6;
            _os_signpost_emit_with_name_impl(&dword_0, v48, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageGuestAppInvalidateSavePointerAliases", buf, 8u);
          }

          v49 = (void *)objc_claimAutoreleasedReturnValue(+[GTTransportMessage_replayer messageWithKind:](GTTransportMessage_replayer, "messageWithKind:", objc_msgSend(v5, "kind")));
          objc_msgSend(v241, "send:inReplyTo:error:", v49, v5, 0);

          break;
        case 1793:
          v27 = g_signpostLog;
          v28 = v27;
          if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v27))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&buf[4] = v6;
            _os_signpost_emit_with_name_impl(&dword_0, v28, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageTraceConfiguration", buf, 8u);
          }

          v29 = objc_msgSend(v5, "uint32ForKey:", CFSTR("trace mode"));
          *(_DWORD *)(a1 + 56) = (_DWORD)v29;
          SetTraceMode(v241, (uint64_t)v29);
          *(_QWORD *)(a1 + 24) = objc_msgSend(v5, "uint64ForKey:", CFSTR("trace host type"));
          *(_QWORD *)(a1 + 32) = objc_msgSend(v5, "uint64ForKey:", CFSTR("profiling send period"));
          *(_QWORD *)(a1 + 40) = objc_msgSend(v5, "uint64ForKey:", CFSTR("profiling flags"));
          break;
      }
    }
    else
    {
      switch(v8)
      {
        case 1026:
          v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "attributes"));
          v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "objectForKeyedSubscript:", CFSTR("object")));
          v37 = objc_msgSend(v36, "unsignedLongLongValue");

          v38 = g_signpostLog;
          v39 = v38;
          if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v38))
          {
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)&buf[4] = v6;
            LOWORD(v357) = 2048;
            *(_QWORD *)((char *)&v357 + 2) = v37;
            _os_signpost_emit_with_name_impl(&dword_0, v39, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageFetchResourceObject %{xcode:address}llu", buf, 0x12u);
          }

          v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "attributes"));
          v317[0] = _NSConcreteStackBlock;
          v317[1] = 3221225472;
          v317[2] = __ProcessMessage_block_invoke_54;
          v317[3] = &unk_725F48;
          v320 = a1;
          v318 = v241;
          v319 = v5;
          v321 = v7;
          v322 = v6;
          FetchResourceObject((id *)a1, v40, v317);

          break;
        case 1028:
          v41 = g_signpostLog;
          v42 = v41;
          if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v41))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&buf[4] = v6;
            _os_signpost_emit_with_name_impl(&dword_0, v42, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageUpdateResourceObject", buf, 8u);
          }

          v250[0] = _NSConcreteStackBlock;
          v250[1] = 3221225472;
          v250[2] = __ProcessMessage_block_invoke_192;
          v250[3] = &unk_725E88;
          v43 = *(_QWORD *)(a1 + 64);
          v251 = v5;
          v253 = v7;
          v254 = a1;
          v255 = v6;
          v252 = v241;
          v256 = v43;
          v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v250));
          objc_msgSend(*(id *)(a1 + 256), "addOperation:", v44);

          break;
        case 1030:
          v18 = g_signpostLog;
          v19 = v18;
          if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v18))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&buf[4] = v6;
            _os_signpost_emit_with_name_impl(&dword_0, v19, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYGenerateShaderDebuggerTrace", buf, 8u);
          }

          v20 = *(void **)(a1 + 256);
          v262[0] = _NSConcreteStackBlock;
          v262[1] = 3221225472;
          v262[2] = __ProcessMessage_block_invoke_181;
          v262[3] = &unk_725F98;
          v263 = v5;
          v265 = v7;
          v266 = a1;
          v267 = v6;
          v264 = v241;
          objc_msgSend(v20, "addOperationWithBlock:", v262);

          break;
      }
    }
  }
  else
  {
    switch(v8)
    {
      case 4098:
        v9 = g_signpostLog;
        v10 = v9;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v9))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v6;
          _os_signpost_emit_with_name_impl(&dword_0, v10, OS_SIGNPOST_INTERVAL_BEGIN, v7, "Replayer-1-serial", "%u. kDYMessageReplayerReplayArchive", buf, 8u);
        }

        v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "stringPayload"));
        v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "attributes"));
        v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "objectForKeyedSubscript:", CFSTR("archivedExperiments")));
        v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "objectForKeyedSubscript:", CFSTR("queryAvailableCounters")));
        v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "objectForKeyedSubscript:", CFSTR("profileCounters")));
        v16 = g_signpostLog;
        v17 = v16;
        if (v7 - 1 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v16))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl(&dword_0, v17, OS_SIGNPOST_INTERVAL_END, v7, "Replayer-1-serial", (const char *)&unk_4AAB5F, buf, 2u);
        }

        break;
      case 4099:
      case 4100:
      case 4101:
      case 4105:
      case 4110:
      case 4111:
      case 4112:
      case 4113:
      case 4115:
      case 4116:
      case 4123:
      case 4124:
      case 4126:
      case 4127:
      case 4128:
        break;
      case 4102:
        v50 = g_signpostLog;
        v51 = v50;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v50))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v6;
          _os_signpost_emit_with_name_impl(&dword_0, v51, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageReplayerDeleteAllArchives", buf, 8u);
        }

        v52 = *(void **)(a1 + 256);
        v330[0] = _NSConcreteStackBlock;
        v330[1] = 3221225472;
        v330[2] = __ProcessMessage_block_invoke_44;
        v330[3] = &unk_725EB0;
        v331 = v5;
        v333 = v7;
        v334 = v6;
        v332 = v241;
        objc_msgSend(v52, "addBarrierBlock:", v330);

        break;
      case 4103:
        v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "stringPayload"));
        v54 = g_signpostLog;
        v55 = v54;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v54))
        {
          *(_DWORD *)buf = 67109378;
          *(_DWORD *)&buf[4] = v6;
          LOWORD(v357) = 2082;
          *(_QWORD *)((char *)&v357 + 2) = objc_msgSend(objc_retainAutorelease(v53), "UTF8String");
          _os_signpost_emit_with_name_impl(&dword_0, v55, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageReplayerBeginDebugArchive %{public}s", buf, 0x12u);
        }

        v56 = dispatch_semaphore_create(0);
        v57 = *(void **)(a1 + 256);
        v324[0] = _NSConcreteStackBlock;
        v324[1] = 3221225472;
        v324[2] = __ProcessMessage_block_invoke_45;
        v324[3] = &unk_725F00;
        v329 = a1;
        v325 = v5;
        v326 = v53;
        v327 = v241;
        v328 = v56;
        v58 = v56;
        v59 = v53;
        objc_msgSend(v57, "addBarrierBlock:", v324);
        dispatch_semaphore_wait(v58, 0xFFFFFFFFFFFFFFFFLL);

        break;
      case 4104:
        v60 = g_signpostLog;
        v61 = v60;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v60))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v6;
          _os_signpost_emit_with_name_impl(&dword_0, v61, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageReplayerEndDebugArchive", buf, 8u);
        }

        break;
      case 4106:
        v62 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectPayload"));
        v63 = objc_msgSend(v62, "unsignedLongLongValue");

        v64 = g_signpostLog;
        v65 = v64;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v64))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = v6;
          LOWORD(v357) = 1024;
          *(_DWORD *)((char *)&v357 + 2) = (_DWORD)v63;
          _os_signpost_emit_with_name_impl(&dword_0, v65, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageReplayerDebugFuncStop %u", buf, 0xEu);
        }

        v66 = (void *)objc_claimAutoreleasedReturnValue(+[GTTransportMessage_replayer messageWithKind:objectPayload:](GTTransportMessage_replayer, "messageWithKind:objectPayload:", 4105, &__kCFBooleanTrue));
        objc_msgSend(v241, "send:inReplyTo:error:", v66, v5, 0);

        if (*(id *)(a1 + 64) != v63)
        {
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = __ProcessMessage_block_invoke_51;
          block[3] = &__block_descriptor_40_e5_v8__0l;
          block[4] = a1;
          dispatch_async((dispatch_queue_t)&_dispatch_main_q, block);
          *(_QWORD *)(a1 + 64) = v63;
          DisplayAttachmentIfNeeded(a1, (int)v63, SHIDWORD(v63));
        }
        break;
      case 4107:
        v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectPayload"));
        if (objc_msgSend(v67, "BOOLValue"))
          v68 = 2;
        else
          v68 = 0;
        *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 84) & 0xFFFFFFFD | v68;

        v69 = g_signpostLog;
        v70 = v69;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v69))
        {
          v71 = (*(_DWORD *)(a1 + 84) >> 1) & 1;
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = v6;
          LOWORD(v357) = 1024;
          *(_DWORD *)((char *)&v357 + 2) = v71;
          _os_signpost_emit_with_name_impl(&dword_0, v70, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageReplayerDebugEnableWireframePresent %d", buf, 0xEu);
        }
        goto LABEL_113;
      case 4108:
        v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectPayload"));
        *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 84) & 0xFFFFFFFE | objc_msgSend(v72, "BOOLValue");

        v73 = g_signpostLog;
        v70 = v73;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v73))
        {
          v74 = *(_DWORD *)(a1 + 84) & 1;
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = v6;
          LOWORD(v357) = 1024;
          *(_DWORD *)((char *)&v357 + 2) = v74;
          _os_signpost_emit_with_name_impl(&dword_0, v70, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageReplayerDebugEnableDrawCallPresent %d", buf, 0xEu);
        }
        goto LABEL_113;
      case 4109:
        v75 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectPayload"));
        objc_msgSend(v75, "floatValue");
        *(_DWORD *)(a1 + 80) = v76;

        v77 = g_signpostLog;
        v78 = v77;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v77))
        {
          v79 = *(float *)(a1 + 80);
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = v6;
          LOWORD(v357) = 2048;
          *(double *)((char *)&v357 + 2) = v79;
          _os_signpost_emit_with_name_impl(&dword_0, v78, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageReplayerDebugWireframeLineWidth %f", buf, 0x12u);
        }

        v80 = (void *)objc_claimAutoreleasedReturnValue(+[GTTransportMessage_replayer messageWithKind:objectPayload:](GTTransportMessage_replayer, "messageWithKind:objectPayload:", 4105, &__kCFBooleanTrue));
        objc_msgSend(v241, "send:inReplyTo:error:", v80, v5, 0);

        break;
      case 4114:
        v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "plistPayload"));
        v82 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v81, "objectAtIndexedSubscript:", 0));
        v83 = g_signpostLog;
        v84 = v83;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v83))
        {
          *(_DWORD *)buf = 67109378;
          *(_DWORD *)&buf[4] = v6;
          LOWORD(v357) = 2082;
          *(_QWORD *)((char *)&v357 + 2) = objc_msgSend(objc_retainAutorelease(v82), "UTF8String");
          _os_signpost_emit_with_name_impl(&dword_0, v84, OS_SIGNPOST_INTERVAL_BEGIN, v7, "Replayer-1-serial", "%u. kDYMessageReplayerLoadArchives %{public}s", buf, 0x12u);
        }

        v85 = dispatch_semaphore_create(0);
        v86 = *(void **)(a1 + 256);
        v257[0] = _NSConcreteStackBlock;
        v257[1] = 3221225472;
        v257[2] = __ProcessMessage_block_invoke_182;
        v257[3] = &unk_726940;
        v87 = v5;
        v258 = v87;
        v88 = v82;
        v259 = v88;
        v261 = a1;
        v89 = v85;
        v260 = v89;
        objc_msgSend(v86, "addBarrierBlock:", v257);
        dispatch_semaphore_wait(v89, 0xFFFFFFFFFFFFFFFFLL);
        v90 = *(_QWORD *)(a1 + 8) != 0;
        v91 = objc_msgSend(v87, "kind");
        v92 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v90));
        v93 = (void *)objc_claimAutoreleasedReturnValue(+[GTTransportMessage_replayer messageWithKind:objectPayload:](GTTransportMessage_replayer, "messageWithKind:objectPayload:", v91, v92));
        objc_msgSend(v241, "send:inReplyTo:error:", v93, v87, 0);

        v94 = g_signpostLog;
        v95 = v94;
        if (v7 - 1 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v94))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl(&dword_0, v95, OS_SIGNPOST_INTERVAL_END, v7, "Replayer-1-serial", (const char *)&unk_4AAB5F, buf, 2u);
        }

        break;
      case 4117:
        v96 = g_signpostLog;
        v97 = v96;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v96))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v6;
          _os_signpost_emit_with_name_impl(&dword_0, v97, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageReplayerQueryShaderInfo", buf, 8u);
        }

        v277[0] = _NSConcreteStackBlock;
        v277[1] = 3221225472;
        v277[2] = __ProcessMessage_block_invoke_135;
        v277[3] = &unk_725F98;
        v280 = a1;
        v281 = v7;
        v282 = v6;
        v278 = v241;
        v279 = v5;
        v98 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v277));
        objc_msgSend(*(id *)(a1 + 264), "addOperation:", v98);

        break;
      case 4118:
        v99 = g_signpostLog;
        v100 = v99;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v99))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v6;
          _os_signpost_emit_with_name_impl(&dword_0, v100, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageReplayerDerivedCounterData", buf, 8u);
        }

        v101 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectPayload"));
        v102 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v101, "objectForKeyedSubscript:", CFSTR("profileCounters")));
        if (v102)
        {
          v103 = *(void **)(a1 + 264);
          v268[0] = _NSConcreteStackBlock;
          v268[1] = 3221225472;
          v268[2] = __ProcessMessage_block_invoke_175;
          v268[3] = &unk_726060;
          v270 = a1;
          v104 = v268;
          v268[4] = v5;
          v268[5] = v101;
          v269 = v241;
          v271 = v7;
          v272 = v6;
          objc_msgSend(v103, "addOperationWithBlock:", v268);

          goto LABEL_195;
        }
        v220 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v101, "objectForKeyedSubscript:", CFSTR("pause")));
        if (v220)
        {

LABEL_194:
          v228 = *(void **)(a1 + 264);
          v275[0] = _NSConcreteStackBlock;
          v275[1] = 3221225472;
          v275[2] = __ProcessMessage_block_invoke_171;
          v275[3] = &unk_726038;
          v104 = v275;
          v275[4] = v101;
          v275[5] = v241;
          v276 = v5;
          objc_msgSend(v228, "addOperationWithBlock:", v275);

          goto LABEL_195;
        }
        v226 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v101, "objectForKeyedSubscript:", CFSTR("resume")));
        v227 = v226 == 0;

        if (!v227)
          goto LABEL_194;
        v229 = *(void **)(a1 + 264);
        v273[0] = _NSConcreteStackBlock;
        v273[1] = 3221225472;
        v273[2] = __ProcessMessage_block_invoke_2_174;
        v273[3] = &unk_725F98;
        v274 = v6;
        v273[6] = v7;
        v273[7] = a1;
        v104 = v273;
        v273[4] = v241;
        v273[5] = v5;
        objc_msgSend(v229, "addOperationWithBlock:", v273);
LABEL_195:

        break;
      case 4119:
        v105 = g_signpostLog;
        v106 = v105;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v105))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v6;
          _os_signpost_emit_with_name_impl(&dword_0, v106, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageReplayerGenerateThumbnails", buf, 8u);
        }

        v302[0] = _NSConcreteStackBlock;
        v302[1] = 3221225472;
        v302[2] = __ProcessMessage_block_invoke_77;
        v302[3] = &unk_725F98;
        v303 = v5;
        v305 = v7;
        v307 = v6;
        v306 = a1;
        v304 = v241;
        v107 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v302));
        objc_msgSend(v107, "setQueuePriority:", 4);
        objc_msgSend(*(id *)(a1 + 256), "addOperation:", v107);

        break;
      case 4120:
        v108 = g_signpostLog;
        v109 = v108;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v108))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v6;
          _os_signpost_emit_with_name_impl(&dword_0, v109, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageReplayerGenerateDependencyGraphThumbnails", buf, 8u);
        }

        v296[0] = _NSConcreteStackBlock;
        v296[1] = 3221225472;
        v296[2] = __ProcessMessage_block_invoke_78;
        v296[3] = &unk_725F98;
        v297 = v5;
        v299 = v7;
        v301 = v6;
        v300 = a1;
        v298 = v241;
        v110 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v296));
        objc_msgSend(v110, "setQueuePriority:", 4);
        objc_msgSend(*(id *)(a1 + 256), "addOperation:", v110);

        break;
      case 4121:
        v111 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "attributes"));
        v112 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v111, "objectForKeyedSubscript:", CFSTR("stream")));

        v113 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "attributes"));
        v114 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "objectForKeyedSubscript:", CFSTR("compressed")));

        v314[0] = _NSConcreteStackBlock;
        v314[1] = 3221225472;
        v314[2] = __ProcessMessage_block_invoke_74;
        v314[3] = &unk_725F70;
        v315 = v241;
        v316 = v5;
        FetchResourceObjectBatch(a1, v112, v114, v314);

        break;
      case 4122:
        v115 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectPayload"));
        if (objc_msgSend(v115, "BOOLValue"))
          v116 = 4;
        else
          v116 = 0;
        *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 84) & 0xFFFFFFFB | v116;

        v117 = g_signpostLog;
        v70 = v117;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v117))
        {
          v118 = (*(_DWORD *)(a1 + 84) >> 2) & 1;
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = v6;
          LOWORD(v357) = 1024;
          *(_DWORD *)((char *)&v357 + 2) = v118;
          _os_signpost_emit_with_name_impl(&dword_0, v70, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageReplayerDebugEnableOutlinePresent %d", buf, 0xEu);
        }
LABEL_113:

        DisplayAttachmentIfNeeded(a1, *(_DWORD *)(a1 + 64), *(_DWORD *)(a1 + 68));
        v119 = (void *)objc_claimAutoreleasedReturnValue(+[GTTransportMessage_replayer messageWithKind:objectPayload:](GTTransportMessage_replayer, "messageWithKind:objectPayload:", 4105, &__kCFBooleanTrue));
        objc_msgSend(v241, "send:inReplyTo:error:", v119, v5, 0);

        break;
      case 4125:
        v120 = g_signpostLog;
        v121 = v120;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v120))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v6;
          _os_signpost_emit_with_name_impl(&dword_0, v121, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kGTMessageQueryInducedGPUPerfState", buf, 8u);
        }

        v122 = *(void **)(a1 + 256);
        v290[0] = _NSConcreteStackBlock;
        v290[1] = 3221225472;
        v290[2] = __ProcessMessage_block_invoke_79;
        v290[3] = &unk_725F98;
        v291 = v5;
        v293 = v7;
        v295 = v6;
        v294 = a1;
        v292 = v241;
        objc_msgSend(v122, "addOperationWithBlock:", v290);

        break;
      case 4129:
        v123 = g_signpostLog;
        v124 = v123;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v123))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v6;
          _os_signpost_emit_with_name_impl(&dword_0, v124, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kGTMessageReplayerResourcesUsedForFunctionIndex", buf, 8u);
        }

        v125 = *(void **)(a1 + 256);
        v308[0] = _NSConcreteStackBlock;
        v308[1] = 3221225472;
        v308[2] = __ProcessMessage_block_invoke_76;
        v308[3] = &unk_725F98;
        v309 = v5;
        v311 = v7;
        v313 = v6;
        v312 = a1;
        v310 = v241;
        objc_msgSend(v125, "addOperationWithBlock:", v308);

        break;
      case 4130:
        v126 = g_signpostLog;
        v127 = v126;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v126))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v6;
          _os_signpost_emit_with_name_impl(&dword_0, v127, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kGTMessageReplayerQueryAPSData", buf, 8u);
        }

        v128 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 8) + 8), "defaultDevice"));
        v129 = DEVICEOBJECT(v128);
        v130 = (void *)objc_claimAutoreleasedReturnValue(v129);
        v131 = objc_msgSend(v130, "acceleratorPort");

        LODWORD(v359) = 0x7FFFFFFF;
        MetalPluginName = GetMetalPluginName(v131, &v359);
        v236 = (void *)objc_claimAutoreleasedReturnValue(MetalPluginName);
        v134 = IsAGXMetalPlugin(v236, v133);
        if ((int)v359 > 4)
          v135 = v134;
        else
          v135 = 0;
        if (v135 == 1)
        {
          DerivedDataPayload = GTMTLReplayHost_generateDerivedDataPayload(**(_QWORD **)(a1 + 8), 1);
          v233 = (void *)objc_claimAutoreleasedReturnValue(DerivedDataPayload);
          v234 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionaryWithDictionary:](NSMutableDictionary, "dictionaryWithDictionary:", v233));
          v238 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectPayload"));
          v231 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "attributes"));
          if (v238)
          {
            v137 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "objectForKeyedSubscript:", CFSTR("UseMTLCounters")));
            v138 = v137 == 0;

            if (!v138)
              objc_msgSend(v234, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("UseMTLCounters"));
            v139 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "objectForKeyedSubscript:", CFSTR("UseKicktimestamps")));
            v140 = v139 == 0;

            if (!v140)
              objc_msgSend(v234, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("UseKicktimestamps"));
            v141 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "objectForKeyedSubscript:", CFSTR("CoalesceComputeEncoders")));
            v142 = v141 == 0;

            if (!v142)
              objc_msgSend(v234, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("CoalesceComputeEncoders"));
            v143 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "objectForKeyedSubscript:", CFSTR("CoalesceBlitEncoders")));
            v144 = v143 == 0;

            if (!v144)
              objc_msgSend(v234, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("CoalesceBlitEncoders"));
            v145 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "objectForKeyedSubscript:", CFSTR("GPUState")));
            if (v145)
              objc_msgSend(v234, "setObject:forKeyedSubscript:", v145, CFSTR("GPUState"));
            v146 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "objectForKeyedSubscript:", CFSTR("ProfilingConfig")));
            v147 = v146 == 0;

            if (!v147)
            {
              v148 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "objectForKeyedSubscript:", CFSTR("ProfilingConfig")));
              objc_msgSend(v234, "setObject:forKeyedSubscript:", v148, CFSTR("ProfilingConfig"));

            }
            v149 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "objectForKeyedSubscript:", CFSTR("CounterConfig")));
            v150 = v149 == 0;

            if (!v150)
            {
              v151 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "objectForKeyedSubscript:", CFSTR("CounterConfig")));
              objc_msgSend(v234, "setObject:forKeyedSubscript:", v151, CFSTR("CounterConfig"));

            }
            v152 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "objectForKeyedSubscript:", CFSTR("TimelineConfig")));
            v153 = v152 == 0;

            if (!v153)
            {
              v154 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "objectForKeyedSubscript:", CFSTR("TimelineConfig")));
              objc_msgSend(v234, "setObject:forKeyedSubscript:", v154, CFSTR("TimelineConfig"));

            }
            v155 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "objectForKeyedSubscript:", CFSTR("useOverlap")));
            v156 = v155 == 0;

            if (!v156)
            {
              v157 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "objectForKeyedSubscript:", CFSTR("useOverlap")));
              objc_msgSend(v234, "setObject:forKeyedSubscript:", v157, CFSTR("useOverlap"));

            }
          }
          objc_msgSend(v234, "setObject:forKeyedSubscript:", v236, CFSTR("MetalPluginName"));
          v160 = v359;
          if ((_DWORD)v359 != 0x7FFFFFFF)
          {
            v161 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:"));
            objc_msgSend(v234, "setObject:forKeyedSubscript:", v161, CFSTR("gpuTarget"));

          }
          v162 = GTShaderProfilerStreamDataFromReplayDataSource(**(uint64_t ****)(a1 + 8), v158, v160, v159);
          v163 = (void *)objc_claimAutoreleasedReturnValue(v162);
          context = objc_autoreleasePoolPush();
          v354[0] = CFSTR("Streaming APS Data");
          v354[1] = CFSTR("MetalPluginName");
          v355[0] = &__kCFBooleanTrue;
          v355[1] = v236;
          v354[2] = CFSTR("gpuTarget");
          v164 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v359));
          v355[2] = v164;
          v232 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v355, v354, 3));

          v165 = (void *)objc_claimAutoreleasedReturnValue(+[GTTransportMessage_replayer messageWithKind:objectPayload:](GTTransportMessage_replayer, "messageWithKind:objectPayload:", objc_msgSend(v5, "kind"), v232));
          objc_msgSend(v241, "send:inReplyTo:error:", v165, v5, 0);

          v166 = dispatch_semaphore_create(0);
          *(_QWORD *)buf = 0;
          *(_QWORD *)&v357 = buf;
          *((_QWORD *)&v357 + 1) = 0x2020000000;
          v358 = 0;
          *(_QWORD *)&v346 = 0;
          *((_QWORD *)&v346 + 1) = &v346;
          *(_QWORD *)&v347 = 0x2020000000;
          BYTE8(v347) = 0;
          v167 = *(_QWORD *)(a1 + 8);
          v168 = (id *)(a1 + 256);
          v285[0] = _NSConcreteStackBlock;
          v285[1] = 3221225472;
          v285[2] = __ProcessMessage_block_invoke_121;
          v285[3] = &unk_725FC0;
          v169 = v166;
          v286 = v169;
          v288 = buf;
          v170 = v163;
          v287 = v170;
          v289 = &v346;
          GTMTLReplayClient_collectAPSData(v167, v168, v234, v285);
          v171 = v169;
          dispatch_semaphore_wait(v169, 0xFFFFFFFFFFFFFFFFLL);
          v172 = objc_claimAutoreleasedReturnValue(objc_msgSend(v170, "traceName"));
          v173 = (void *)v172;
          v174 = CFSTR("local");
          if (v172)
            v174 = (const __CFString *)v172;
          v175 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("/tmp/com.apple.gputools.profiling/%@.gpuprofiler_raw"), v174));

          objc_msgSend(v170, "setMetalPluginName:", v236);
          v176 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
          v177 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v175, "stringByDeletingLastPathComponent"));
          objc_msgSend(v176, "createDirectoryAtPath:withIntermediateDirectories:attributes:error:", v177, 1, 0, 0);

          if (objc_msgSend(v176, "fileExistsAtPath:", v175))
          {
            v284 = 0;
            objc_msgSend(v176, "removeItemAtPath:error:", v175, &v284);
          }
          v283 = 0;
          v178 = (void *)objc_claimAutoreleasedReturnValue(+[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:](NSKeyedArchiver, "archivedDataWithRootObject:requiringSecureCoding:error:", v170, 1, &v283));
          v179 = v283;
          objc_msgSend(v178, "writeToFile:atomically:", v175, 0);
          v352 = CFSTR("Profiler Raw");
          v353 = v178;
          v180 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v353, &v352, 1));
          v181 = (void *)objc_claimAutoreleasedReturnValue(+[GTTransportMessage_replayer messageWithKind:plistPayload:](GTTransportMessage_replayer, "messageWithKind:plistPayload:", 4124, v180));
          objc_msgSend(v241, "send:inReplyTo:error:", v181, 0, 0);

          _Block_object_dispose(&v346, 8);
          _Block_object_dispose(buf, 8);

          objc_autoreleasePoolPop(context);
        }

        break;
      default:
        switch(v8)
        {
          case 4608:
            v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectPayload"));
            v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "objectForKeyedSubscript:", CFSTR("functionIndex")));
            v23 = objc_msgSend(v22, "unsignedIntegerValue");

            v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "objectForKeyedSubscript:", CFSTR("object")));
            v25 = objc_msgSend(v24, "unsignedIntegerValue");

            v242[0] = _NSConcreteStackBlock;
            v242[1] = 3221225472;
            v242[2] = __ProcessMessage_block_invoke_193;
            v242[3] = &unk_7260B0;
            v245 = a1;
            v246 = v23;
            v247 = v25;
            v248 = v7;
            v249 = v6;
            v243 = v241;
            v244 = v5;
            v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v242));
            objc_msgSend(*(id *)(a1 + 256), "addOperation:", v26);

            goto LABEL_196;
          case 4609:
            v182 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "attributes"));
            v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v182, "objectForKeyedSubscript:", CFSTR("sessionId")));

            if (!v46 || (objc_opt_respondsToSelector(v46, "unsignedIntegerValue") & 1) == 0)
              goto LABEL_45;
            v183 = objc_msgSend(v46, "unsignedIntegerValue");
            v184 = *(_QWORD *)(a1 + 8);
            v185 = *(NSObject **)(v184 + 48);
            v184 += 48;
            dispatch_semaphore_wait(v185, 0xFFFFFFFFFFFFFFFFLL);
            v186 = *(void **)(v184 + 8);
            v187 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", v183));
            v45 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v186, "objectForKey:", v187));

            dispatch_semaphore_signal(*(dispatch_semaphore_t *)v184);
            if (v45)
            {
              v188 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "payload"));
              objc_msgSend(v45, "receiveData:", v188);

            }
            goto LABEL_44;
          case 4610:
            v189 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectPayload"));
            v190 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v189, "objectForKeyedSubscript:", CFSTR("sessionId")));
            v191 = objc_msgSend(v190, "unsignedIntegerValue");

            v192 = *(_QWORD *)(a1 + 8);
            dispatch_semaphore_wait(*(dispatch_semaphore_t *)(v192 + 48), 0xFFFFFFFFFFFFFFFFLL);
            v193 = *(void **)(v192 + 56);
            v194 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v191));
            v195 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v193, "objectForKey:", v194));

            if (v195)
            {
              v196 = *(void **)(v192 + 56);
              v197 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v191));
              objc_msgSend(v196, "removeObjectForKey:", v197);

            }
            else
            {
              NSLog(CFSTR("ASV session %llu does not exist"), v191);
            }

            dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v192 + 48));
            v221 = objc_msgSend(v5, "kind");
            v350 = CFSTR("sessionId");
            v222 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v191));
            v351 = v222;
            v223 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v351, &v350, 1));
            v224 = (void *)objc_claimAutoreleasedReturnValue(+[GTTransportMessage_replayer messageWithKind:objectPayload:](GTTransportMessage_replayer, "messageWithKind:objectPayload:", v221, v223));

            objc_msgSend(v241, "send:inReplyTo:error:", v224, v5, 0);
            goto LABEL_196;
          case 4611:
            v198 = g_signpostLog;
            v199 = v198;
            if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v198))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = v6;
              _os_signpost_emit_with_name_impl(&dword_0, v199, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageReplayerGenerateListOfDebugFilesInCache", buf, 8u);
            }

            v200 = ArchiveDirectory();
            v239 = (void *)objc_claimAutoreleasedReturnValue(v200);
            v237 = objc_msgSend(objc_alloc((Class)NSURL), "initFileURLWithPath:", v239);
            v235 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
            v359 = NSURLNameKey;
            v201 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v359, 1));
            v202 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v235, "enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:", v237, v201, 17, 0));

            v203 = objc_alloc_init((Class)NSMutableArray);
            v349 = 0u;
            v348 = 0u;
            v347 = 0u;
            v346 = 0u;
            v204 = v202;
            v205 = objc_msgSend(v204, "countByEnumeratingWithState:objects:count:", &v346, buf, 16);
            if (v205)
            {
              v206 = *(_QWORD *)v347;
              do
              {
                for (i = 0; i != v205; i = (char *)i + 1)
                {
                  if (*(_QWORD *)v347 != v206)
                    objc_enumerationMutation(v204);
                  v208 = *(void **)(*((_QWORD *)&v346 + 1) + 8 * (_QWORD)i);
                  v209 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v208, "lastPathComponent"));
                  v210 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v209, "stringByDeletingPathExtension"));

                  v211 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v208, "pathExtension"));
                  LODWORD(v209) = objc_msgSend(v211, "isEqualToString:", CFSTR("metallib"));

                  if ((_DWORD)v209)
                    objc_msgSend(v203, "addObject:", v210);

                }
                v205 = objc_msgSend(v204, "countByEnumeratingWithState:objects:count:", &v346, buf, 16);
              }
              while (v205);
            }

            v212 = (void *)objc_claimAutoreleasedReturnValue(+[GTTransportMessage_replayer messageWithKind:objectPayload:](GTTransportMessage_replayer, "messageWithKind:objectPayload:", 4611, v203));
            objc_msgSend(v241, "send:inReplyTo:error:", v212, v5, 0);

            goto LABEL_196;
          case 4612:
            v213 = g_signpostLog;
            v214 = v213;
            if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v213))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = v6;
              _os_signpost_emit_with_name_impl(&dword_0, v214, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageReplayerSendDebuggingFiles", buf, 8u);
            }

            v342[0] = _NSConcreteStackBlock;
            v342[1] = 3221225472;
            v342[2] = __ProcessMessage_block_invoke;
            v342[3] = &unk_725E60;
            v343 = v5;
            v345 = a1;
            v344 = v241;
            v215 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v342));
            objc_msgSend(*(id *)(a1 + 256), "addOperation:", v215);

            goto LABEL_196;
          case 4613:
            v216 = g_signpostLog;
            v217 = v216;
            if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v216))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = v6;
              _os_signpost_emit_with_name_impl(&dword_0, v217, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageReplayerUpdateLibraries", buf, 8u);
            }

            v335[0] = _NSConcreteStackBlock;
            v335[1] = 3221225472;
            v335[2] = __ProcessMessage_block_invoke_41;
            v335[3] = &unk_725E88;
            v218 = *(_QWORD *)(a1 + 64);
            v336 = v5;
            v338 = v7;
            v340 = v6;
            v339 = a1;
            v337 = v241;
            v341 = v218;
            v219 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v335));
            objc_msgSend(*(id *)(a1 + 256), "addOperation:", v219);

            goto LABEL_196;
          default:
            if (v8 != 1794)
              goto LABEL_196;
            v30 = g_signpostLog;
            v31 = v30;
            if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v30))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = v6;
              _os_signpost_emit_with_name_impl(&dword_0, v31, OS_SIGNPOST_EVENT, v7, "Replayer-5-network", "%u. kDYMessageTraceOverridesConfiguration", buf, 8u);
            }

            v32 = objc_msgSend(v5, "uint32ForKey:", CFSTR("override_flags"));
            v33 = v32;
            if (v32 == *(_DWORD *)(a1 + 60))
              goto LABEL_191;
            if (v32)
            {
              if (*(_DWORD *)(a1 + 56) == 7)
                goto LABEL_190;
              v34 = 7;
            }
            else
            {
              v34 = 1;
            }
            SetTraceMode(v241, v34);
LABEL_190:
            *(_DWORD *)(a1 + 60) = v33;
LABEL_191:
            if ((v33 & 0x40) != 0)
            {
              objc_msgSend(v5, "doubleForKey:", CFSTR("override_scale_tesselation_factor"));
              *(_QWORD *)(a1 + 48) = v225;
            }
            break;
        }
        break;
    }
  }
LABEL_196:
  objc_autoreleasePoolPop(v240);

}

void sub_2B1F28(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose(&STACK[0x5C0], 8);
  _Block_object_dispose((const void *)(v1 - 256), 8);
  _Unwind_Resume(a1);
}

void SetTraceMode(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  id v5;

  v3 = a1;
  v5 = (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a2));
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[GTTransportMessage_replayer messageWithKind:objectPayload:](GTTransportMessage_replayer, "messageWithKind:objectPayload:", 1796, v5));
  objc_msgSend(v3, "send:error:", v4, 0);

}

void DisplayAttachmentIfNeeded(uint64_t a1, int a2, int a3)
{
  uint64_t v6;
  _QWORD *ExclusiveRange;
  int v8;
  uint64_t v10;
  BOOL v11;
  char v12;
  void *v13;
  _QWORD v14[6];
  int v15;
  int v16;
  _QWORD v17[5];
  char v18;
  BOOL v19;
  BOOL v20;
  char v21;

  if (*(_QWORD *)(a1 + 280))
  {
    if ((dword_75313C & 0x20) == 0)
    {
      v6 = *(_QWORD *)(**(_QWORD **)(a1 + 8) + 112);
      ExclusiveRange = GroupBuilder_findExclusiveRange(*(_DWORD *)(v6 + 12), *(_QWORD **)(v6 + 24), (a2 - 1));
      if (ExclusiveRange)
      {
        while (1)
        {
          v8 = *((_DWORD *)ExclusiveRange + 7);
          if (v8 == -16353 || v8 == -16351)
            break;
          v10 = *((unsigned int *)ExclusiveRange + 4);
          if ((_DWORD)v10)
            v11 = ExclusiveRange == 0;
          else
            v11 = 1;
          ExclusiveRange -= 4 * v10;
          if (v11)
            return;
        }
        v17[0] = 0;
        v17[1] = v17;
        v17[2] = 0x3010000000;
        v17[3] = &unk_4C2897;
        v17[4] = *(_QWORD *)(a1 + 72);
        v12 = *(_BYTE *)(a1 + 84);
        v18 = v12 & 1;
        v19 = (v12 & 2) != 0;
        v20 = (v12 & 4) != 0;
        v21 = 0;
        v14[0] = _NSConcreteStackBlock;
        v14[1] = 3221225472;
        v14[2] = __DisplayAttachmentIfNeeded_block_invoke;
        v14[3] = &unk_726150;
        v15 = a2;
        v16 = a3;
        v14[4] = v17;
        v14[5] = a1;
        v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v14));
        objc_msgSend(*(id *)(a1 + 256), "addOperation:", v13);

        _Block_object_dispose(v17, 8);
      }
    }
  }
}

void sub_2B2138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__CFString *ArchiveDirectory()
{
  void *v0;
  unsigned __int8 v1;
  __CFString *v2;
  NSString *v3;
  void *v4;

  v0 = (void *)objc_claimAutoreleasedReturnValue(+[NSProcessInfo processInfo](NSProcessInfo, "processInfo"));
  v1 = objc_msgSend(v0, "isiOSAppOnMac");

  if ((v1 & 1) != 0)
  {
    v2 = CFSTR("/tmp/com.apple.GPUToolsAgent");
  }
  else
  {
    v3 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", getpwnam("mobile")->pw_dir);
    v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
    v2 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "stringByAppendingPathComponent:", CFSTR("Library/GPUTools")));

  }
  return v2;
}

void sub_2B2548(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_msgSend(*(id *)(v1 + 56), "leaveActivity");
  _Unwind_Resume(a1);
}

void sub_2B2748(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_msgSend(*(id *)(v1 + 56), "leaveActivity");
  _Unwind_Resume(a1);
}

void sub_2B2940(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_msgSend(*(id *)(v1 + 56), "leaveActivity");
  _Unwind_Resume(a1);
}

void sub_2B32FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_msgSend(*(id *)(v1 + 56), "leaveActivity");
  _Unwind_Resume(a1);
}

void sub_2B34F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_msgSend(*(id *)(v1 + 56), "leaveActivity");
  _Unwind_Resume(a1);
}

void sub_2B36E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_msgSend(*(id *)(v1 + 56), "leaveActivity");
  _Unwind_Resume(a1);
}

void sub_2B3B2C(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_msgSend(*(id *)(v1 + 56), "leaveActivity");
  _Unwind_Resume(a1);
}

void sub_2B45E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_2B5164(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_msgSend(*(id *)(v1 + 56), "leaveActivity");
  _Unwind_Resume(a1);
}

void sub_2B5368(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_msgSend(*(id *)(v1 + 56), "leaveActivity");
  _Unwind_Resume(a1);
}

void sub_2B5604(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_msgSend(*(id *)(v1 + 56), "leaveActivity");
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__5240(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__5241(uint64_t a1)
{

}

void sub_2B5CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2B5E7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2B6010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2B6284(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_msgSend(*(id *)(v1 + 56), "leaveActivity");
  _Unwind_Resume(a1);
}

void GTMTLReplayClient_createOldTransport(uint64_t a1, uint64_t a2, uint64_t a3, apr_allocator_t *a4)
{
  NSString *v6;
  NSURL *v7;
  NSURL *v8;
  NSString *v9;
  id v10;
  __objc2_class **v11;
  id v12;
  id v13;
  ReplayErrorTransport *v14;
  id v15;
  id v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  void *v21;
  void *v22;
  __CFString *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  __CFString *v29;
  NSNumber *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  NSObject *v35;
  const char *v36;
  NSObject *v37;
  uint32_t v38;
  NSObject *v39;
  FILE *v40;
  FILE *v41;
  void *context;
  void *v43;
  dispatch_queue_t v44;
  NSObject *dsema;
  _QWORD v46[4];
  NSObject *v47;
  _QWORD v48[4];
  id v49;
  uint64_t v50;
  apr_pool_t *v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;
  id v68;
  id v69;
  id v70;
  __int128 v71;
  apr_pool_t *newpool;
  timeval v73;
  const __CFString *v74;
  const __CFString *v75;
  const __CFString *v76;
  const __CFString *v77;
  __int128 buf;
  void *v79;
  __CFString *v80;

  newpool = 0;
  apr_pool_create_ex(&newpool, 0, 0, a4);
  v71 = 0u;
  v52 = 0u;
  v53 = 0u;
  v54 = 0u;
  v55 = 0u;
  v56 = 0u;
  v57 = 0u;
  v58 = 0u;
  v59 = 0u;
  v60 = 0u;
  v61 = 0u;
  v62 = 0u;
  v63 = 0u;
  v64 = 0u;
  v65 = 0u;
  v66 = 0u;
  v67 = 0;
  v51 = newpool;
  *(_QWORD *)&v56 = 0xFF0000FF00FF00FFLL;
  DWORD2(v56) = 1082130432;
  *(_QWORD *)&v57 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", 128);
  v68 = objc_alloc_init((Class)NSOperationQueue);
  v69 = objc_alloc_init((Class)NSOperationQueue);
  v70 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", 16);
  __copy_assignment_8_8_t0w88_s88_S_s96_s104_t112w8_s120_s128_s136_t144w8_s152_s160_s168_s176_s184_s192_s200_s208_s216_s224_s232_s240_s248_S_s256_s264_s272_s280_s288(a1, (uint64_t)&v51);
  objc_msgSend(*(id *)(a1 + 264), "setName:", CFSTR("gputools.MTLReplayer.parallelQueue"));
  objc_msgSend(*(id *)(a1 + 256), "setName:", CFSTR("gputools.MTLReplayer.serialQueue"));
  objc_msgSend(*(id *)(a1 + 256), "setMaxConcurrentOperationCount:", 1);
  if (!a2)
  {
    if (s_logUsingOsLog)
    {
      v35 = gt_default_log();
      if (!os_log_type_enabled(v35, OS_LOG_TYPE_FAULT))
        goto LABEL_27;
      LOWORD(buf) = 0;
      v36 = "fail: [create_transport] GT_HOST_URL environment not set";
      v37 = v35;
      v38 = 2;
      goto LABEL_26;
    }
    v40 = __stderrp;
    -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("fail: [create_transport] GT_HOST_URL environment not set")), "UTF8String");
    fprintf(v40, "%s\n");
LABEL_27:
    abort();
  }
  v6 = +[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", a2, 4);
  if (!v6)
    __assert_rtn("GTTransport *DYCreateTransportC(const char *)", "", 0, "url_str");
  v7 = +[NSURL URLWithString:](NSURL, "URLWithString:", v6);
  v8 = v7;
  if (!v7)
  {
    if (s_logUsingOsLog)
    {
      v39 = gt_default_log();
      if (!os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
        goto LABEL_27;
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = a2;
      v36 = "fail: [create_transport] failed to parse GT_HOST_URL: %s";
LABEL_25:
      v37 = v39;
      v38 = 12;
LABEL_26:
      _os_log_fault_impl(&dword_0, v37, OS_LOG_TYPE_FAULT, v36, (uint8_t *)&buf, v38);
      goto LABEL_27;
    }
    v41 = __stderrp;
    -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("fail: [create_transport] failed to parse GT_HOST_URL: %s"), a2), "UTF8String");
    goto LABEL_32;
  }
  v9 = -[NSURL scheme](v7, "scheme");
  if (-[NSString isEqualToString:](v9, "isEqualToString:", CFSTR("null")))
  {
    v10 = 0;
    goto LABEL_12;
  }
  if (-[NSString isEqualToString:](v9, "isEqualToString:", CFSTR("file")))
  {
    v11 = off_4D45E8;
  }
  else
  {
    if (!-[NSString isEqualToString:](v9, "isEqualToString:", CFSTR("dysmt"))
      && !-[NSString isEqualToString:](v9, "isEqualToString:", CFSTR("dysmtdeferred")))
    {
      goto LABEL_22;
    }
    v11 = off_4D45E0;
  }
  v10 = objc_msgSend(objc_alloc(*v11), "initWithMode:", 1);
  objc_msgSend(v10, "setUrl:", v8);
  if (!v10)
  {
LABEL_22:
    if (s_logUsingOsLog)
    {
      v39 = gt_default_log();
      if (!os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
        goto LABEL_27;
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = a2;
      v36 = "fail: [create_transport] failed to create transport; GT_HOST_URL: %s";
      goto LABEL_25;
    }
    v41 = __stderrp;
    -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("fail: [create_transport] failed to create transport; GT_HOST_URL: %s"),
        a2),
      "UTF8String");
LABEL_32:
    fprintf(v41, "%s\n");
    goto LABEL_27;
  }
LABEL_12:
  objc_msgSend(v10, "setSynchronous:", 1);
  v44 = dispatch_queue_create("gputools.global_sync", 0);
  v12 = objc_msgSend(v10, "newSourceWithQueue:");
  v48[0] = _NSConcreteStackBlock;
  v48[1] = 3221225472;
  v48[2] = __GTMTLReplayClient_createOldTransport_block_invoke;
  v48[3] = &unk_726100;
  v50 = a1;
  v13 = v10;
  v49 = v13;
  objc_msgSend(v12, "setMessageHandler:", v48);
  v46[0] = _NSConcreteStackBlock;
  v46[1] = 3221225472;
  v46[2] = __GTMTLReplayClient_createOldTransport_block_invoke_2;
  v46[3] = &unk_726128;
  dsema = dispatch_semaphore_create(0);
  v47 = dsema;
  objc_msgSend(v12, "setRegistrationHandler:", v46);
  objc_msgSend(v12, "resume");
  dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
  v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "connect"));
  objc_msgSend(v43, "BOOLResult");
  v14 = -[ReplayErrorTransport initWithTransport:]([ReplayErrorTransport alloc], "initWithTransport:", v13);
  objc_storeStrong((id *)&_observer, v14);

  v15 = v13;
  context = objc_autoreleasePoolPush();
  mach_timebase_info((mach_timebase_info_t)&g_DYTimebaseInfo);
  v16 = v15;
  v17 = objc_autoreleasePoolPush();
  v73.tv_sec = 0;
  *(_QWORD *)&v73.tv_usec = 0;
  v18 = mach_absolute_time();
  gettimeofday(&v73, 0);
  v19 = mach_absolute_time();
  v74 = CFSTR("nanoseconds since epoch timestamp");
  v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", 1000000000 * v73.tv_sec + 1000 * v73.tv_usec));
  *(_QWORD *)&buf = v20;
  v75 = CFSTR("mach absolute timestamp");
  v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v18 + ((v19 - v18) >> 1)));
  *((_QWORD *)&buf + 1) = v21;
  v76 = CFSTR("mach timebase numerator");
  v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", g_DYTimebaseInfo));
  v79 = v22;
  v77 = CFSTR("mach timebase denominator");
  v23 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", dword_75301C));
  v80 = v23;
  v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &buf, &v74, 4));

  v25 = (void *)objc_claimAutoreleasedReturnValue(+[GTTransportMessage_replayer messageWithKind:attributes:](GTTransportMessage_replayer, "messageWithKind:attributes:", 1539, v24));
  objc_msgSend(v16, "send:inReplyTo:error:", v25, 0, 0);

  objc_autoreleasePoolPop(v17);
  v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSBundle mainBundle](NSBundle, "mainBundle"));
  v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "executablePath"));
  v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "bundleIdentifier"));
  if (v28)
    v29 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "bundleIdentifier"));
  else
    v29 = &stru_7282A8;

  v74 = CFSTR("pid");
  v30 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", getpid());
  v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
  *(_QWORD *)&buf = v31;
  v75 = CFSTR("path");
  v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "bundlePath"));
  *((_QWORD *)&buf + 1) = v32;
  v79 = v27;
  v76 = CFSTR("executable-path");
  v77 = CFSTR("identifier");
  v80 = v29;
  v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &buf, &v74, 4));

  v34 = (void *)objc_claimAutoreleasedReturnValue(+[GTTransportMessage_replayer messageWithKind:attributes:](GTTransportMessage_replayer, "messageWithKind:attributes:", 1536, v33));
  objc_msgSend(v16, "send:error:", v34, 0);

  objc_autoreleasePoolPop(context);
  __destructor_8_s88_S_s96_s104_s120_s128_s136_s152_s160_s168_s176_s184_s192_s200_s208_s216_s224_s232_s240_s248_S_s256_s264_s272_s280_s288((id *)&v51);
}

void sub_2B6A6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  __destructor_8_s88_S_s96_s104_s120_s128_s136_s152_s160_s168_s176_s184_s192_s200_s208_s216_s224_s232_s240_s248_S_s256_s264_s272_s280_s288((id *)va);
  _Unwind_Resume(a1);
}

void __copy_assignment_8_8_t0w88_s88_S_s96_s104_t112w8_s120_s128_s136_t144w8_s152_s160_s168_s176_s184_s192_s200_s208_s216_s224_s232_s240_s248_S_s256_s264_s272_s280_s288(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;

  v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  v5 = *(_OWORD *)(a2 + 32);
  v6 = *(_OWORD *)(a2 + 48);
  v7 = *(_OWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 48) = v6;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 32) = v5;
  objc_storeStrong((id *)(a1 + 88), *(id *)(a2 + 88));
  objc_storeStrong((id *)(a1 + 96), *(id *)(a2 + 96));
  objc_storeStrong((id *)(a1 + 104), *(id *)(a2 + 104));
  *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  objc_storeStrong((id *)(a1 + 120), *(id *)(a2 + 120));
  objc_storeStrong((id *)(a1 + 128), *(id *)(a2 + 128));
  objc_storeStrong((id *)(a1 + 136), *(id *)(a2 + 136));
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
  objc_storeStrong((id *)(a1 + 152), *(id *)(a2 + 152));
  objc_storeStrong((id *)(a1 + 160), *(id *)(a2 + 160));
  objc_storeStrong((id *)(a1 + 168), *(id *)(a2 + 168));
  objc_storeStrong((id *)(a1 + 176), *(id *)(a2 + 176));
  objc_storeStrong((id *)(a1 + 184), *(id *)(a2 + 184));
  objc_storeStrong((id *)(a1 + 192), *(id *)(a2 + 192));
  objc_storeStrong((id *)(a1 + 200), *(id *)(a2 + 200));
  objc_storeStrong((id *)(a1 + 208), *(id *)(a2 + 208));
  objc_storeStrong((id *)(a1 + 216), *(id *)(a2 + 216));
  objc_storeStrong((id *)(a1 + 224), *(id *)(a2 + 224));
  objc_storeStrong((id *)(a1 + 232), *(id *)(a2 + 232));
  objc_storeStrong((id *)(a1 + 240), *(id *)(a2 + 240));
  objc_storeStrong((id *)(a1 + 248), *(id *)(a2 + 248));
  objc_storeStrong((id *)(a1 + 256), *(id *)(a2 + 256));
  objc_storeStrong((id *)(a1 + 264), *(id *)(a2 + 264));
  objc_storeStrong((id *)(a1 + 272), *(id *)(a2 + 272));
  objc_storeStrong((id *)(a1 + 280), *(id *)(a2 + 280));
  objc_storeStrong((id *)(a1 + 288), *(id *)(a2 + 288));
}

void __destructor_8_s88_S_s96_s104_s120_s128_s136_s152_s160_s168_s176_s184_s192_s200_s208_s216_s224_s232_s240_s248_S_s256_s264_s272_s280_s288(id *a1)
{

  __destructor_8_s0_s8_s24_s32_s40_s56_s64_s72_s80_s88_s96_s104_s112_s120_s128_s136_s144_s152(a1 + 12);
}

void __destructor_8_s0_s8_s24_s32_s40_s56_s64_s72_s80_s88_s96_s104_s112_s120_s128_s136_s144_s152(id *a1)
{

}

uint64_t AddResourceRestoreRequest(apr_array_header_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t result;
  uint64_t v7;
  int v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v14;
  const char *v15;
  unint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t *AliasStream;
  uint64_t v24;
  char *v25;
  char *v26;
  int v27;
  int32x2_t v28;
  int16x4_t v29;
  int16x4_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  const char *v34;
  uint64_t *v35;
  uint64_t v36;
  const char *appended;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  char *v45;
  _QWORD *v46;
  uint64_t v47;
  char *v48;
  _QWORD *v49;
  __int128 v50;
  char *v51;
  __int16 v52;
  int64x2_t v53;
  __int32 v54;
  int16x4_t v55;
  apr_pool_t **v56;
  apr_pool_t *v57;
  unint64_t v58;
  char *Data;
  unint64_t v60;
  _QWORD *v61;
  _QWORD *v62;
  char v63;
  uint64_t v64;
  _QWORD *v65;
  uint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  char *v69;
  int32x2_t v70;
  char *v71;
  _QWORD *v72;
  char *v73;
  _QWORD *v74;
  _QWORD *v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  int64x2_t v79[5];
  int64x2_t v80;
  uint64_t v81;
  uint64_t v82;

  result = 0;
  v7 = *(_QWORD *)(a2 + 24);
  v8 = *(_DWORD *)(a3 + 4);
  if (v8 <= -10241)
  {
    if (v8 == -16313)
    {
LABEL_18:
      memset(v79, 0, 48);
      DYTraceDecode_MTLDevice_newBufferWithBytes_length_options((uint64_t)v79, a3, (*(_DWORD *)a3 - 36), 0);
      AliasStream = (uint64_t *)GetAliasStream(v7, v79[0].i64[1], a4);
      if (AliasStream)
        v24 = *AliasStream;
      else
        v24 = 0;
      v45 = apr_pstrdup(a1->pool, (const char *)v79[1].i64[0]);
      v46 = apr_array_push(a1);
      v47 = v79[1].i64[1];
      *v46 = 22;
      v46[1] = v24;
      v46[2] = a4;
      v46[3] = v45;
      v46[4] = 0;
      v46[5] = v47;
      v46[7] = 0;
LABEL_51:
      v46[6] = 0;
    }
    else
    {
      if (v8 == -16236)
      {
LABEL_16:
        v81 = 0;
        v80 = 0u;
        memset(v79, 0, sizeof(v79));
        DYTraceDecode_MTLTexture_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage((uint64_t)v79, a3, (*(_DWORD *)a3 - 36), 0);
        v21 = (uint64_t *)GetAliasStream(v7, v79[0].i64[0], a4);
        if (v21)
          v22 = *v21;
        else
          v22 = 0;
        v25 = apr_pstrdup(a1->pool, (const char *)v79[4].i64[1]);
        v26 = (char *)apr_array_push(a1);
        v27 = v81;
        v28 = vmovn_s64(v80);
        v29 = vmovn_s32(vuzp1q_s32((int32x4_t)vextq_s8(*(int8x16_t *)((char *)&v79[3] + 8), *(int8x16_t *)((char *)&v79[3] + 8), 8uLL), *(int32x4_t *)((char *)v79 + 8)));
        v30 = vmovn_s32(vuzp1q_s32(*(int32x4_t *)((char *)&v79[1] + 8), *(int32x4_t *)((char *)&v79[2] + 8)));
        *(_QWORD *)v26 = 80;
        *((_QWORD *)v26 + 1) = v22;
        *((_QWORD *)v26 + 2) = a4;
        *((_QWORD *)v26 + 3) = v25;
        *((int16x4_t *)v26 + 4) = v29;
        *((int16x4_t *)v26 + 5) = v30;
        *((int32x2_t *)v26 + 6) = v28;
        *((_DWORD *)v26 + 14) = v27;
      }
      else
      {
        if (v8 != -16234)
          return result;
        memset(v79, 0, sizeof(v79));
        DYTraceDecode_MTLTexture_replaceRegion_mipmapLevel_withBytes_bytesPerRow((uint64_t)v79, a3, (*(_DWORD *)a3 - 36), 0);
        v11 = (uint64_t *)GetAliasStream(v7, v79[0].i64[0], a4);
        if (v11)
          v12 = *v11;
        else
          v12 = 0;
        v51 = apr_pstrdup(a1->pool, (const char *)v79[4].i64[0]);
        v26 = (char *)apr_array_push(a1);
        v52 = v79[2].i16[4];
        v53 = v79[3];
        v54 = v79[4].i32[2];
        v55 = vmovn_s32(vuzp1q_s32(*(int32x4_t *)((char *)v79 + 8), *(int32x4_t *)((char *)&v79[1] + 8)));
        *(_QWORD *)v26 = 80;
        *((_QWORD *)v26 + 1) = v12;
        *((_QWORD *)v26 + 2) = a4;
        *((_QWORD *)v26 + 3) = v51;
        *((_WORD *)v26 + 16) = 0;
        *((_WORD *)v26 + 17) = v53.i16[4];
        *(int16x4_t *)(v26 + 36) = v55;
        *((_WORD *)v26 + 22) = v52;
        *((_WORD *)v26 + 23) = v53.i16[0];
        *((_DWORD *)v26 + 12) = v54;
        *(_QWORD *)(v26 + 52) = 0;
      }
      *((_DWORD *)v26 + 15) = 0;
    }
    return 1;
  }
  if (v8 > -10220)
  {
    switch(v8)
    {
      case -10219:
        v79[0].i64[0] = *(_QWORD *)(a3 + 40);
        v82 = 12;
        appended = AppendString_11072((const char **)&v79[0].i64[1], a3 + 36, &v82);
        v38 = (uint64_t *)GetAliasStream(v7, v79[0].i64[0], a4);
        if (v38)
          v39 = *v38;
        else
          v39 = 0;
        v71 = apr_pstrdup(a1->pool, appended);
        v72 = apr_array_push(a1);
        *v72 = 57;
        v72[1] = v39;
        v72[2] = a4;
        v72[3] = v71;
        *((_OWORD *)v72 + 2) = 0u;
        *((_OWORD *)v72 + 3) = 0u;
        break;
      case -10194:
        v40 = a3 + 36;
        v79[0].i64[0] = *(_QWORD *)(a3 + 44);
        v82 = 16;
        v41 = AppendString_11072((const char **)&v79[0].i64[1], a3 + 36, &v82);
        v42 = *(_QWORD *)(v40 + ((v82 + 3) & 0xFFFFFFFFFFFFFFFCLL));
        v43 = (uint64_t *)GetAliasStream(v7, v79[0].i64[0], a4);
        if (v43)
          v44 = *v43;
        else
          v44 = 0;
        v73 = apr_pstrdup(a1->pool, v41);
        v74 = apr_array_push(a1);
        *v74 = 16;
        v74[1] = v44;
        v74[2] = a4;
        v74[3] = v73;
        v74[4] = v42;
        v74[5] = 0;
        result = 1;
        v74[6] = 0;
        v74[7] = 0;
        return result;
      case -10190:
        v14 = a3 + 36;
        v79[0].i64[0] = *(_QWORD *)(a3 + 52);
        v82 = 24;
        v15 = AppendString_11072((const char **)&v79[0].i64[1], a3 + 36, &v82);
        v16 = (v82 + 3) & 0xFFFFFFFFFFFFFFFCLL;
        v17 = *(_QWORD *)(v14 + v16);
        v79[0].i64[1] = (uint64_t)v15;
        v79[1].i64[0] = v17;
        v82 = v16 + 8;
        v18 = (char *)AppendString_11072((const char **)&v79[1].i64[1], v14, &v82);
        v19 = *(_QWORD *)(v14 + ((v82 + 3) & 0xFFFFFFFFFFFFFFFCLL));
        v20 = (uint64_t *)GetAliasStream(v7, v79[0].i64[0], a4);
        if (v20)
          v78 = *v20;
        else
          v78 = 0;
        v77 = apr_pstrdup(a1->pool, (const char *)v79[0].i64[1]);
        v56 = *(apr_pool_t ***)(a2 + 8);
        v57 = *v56;
        Data = GTCaptureArchive_readData(*(const char ***)a2, v56, v18, *v56, 0);
        if (v19)
          LODWORD(v60) = v19;
        else
          v60 = v58 >> 3;
        v61 = apr_palloc(a1->pool, 8 * v60);
        v62 = v61;
        if ((_DWORD)v60)
        {
          v63 = 0;
          v64 = v60;
          v65 = v61;
          do
          {
            v66 = *(_QWORD *)Data;
            Data += 8;
            v67 = (uint64_t *)GetAliasStream(v7, v66, a4);
            if (v67)
              v68 = *v67;
            else
              v68 = 0;
            *v65++ = v68;
            v63 |= v68 == 0;
            --v64;
          }
          while (v64);
          apr_pool_clear(v57);
          if ((v63 & 1) != 0)
            return 1;
        }
        else
        {
          apr_pool_clear(v57);
        }
        v75 = apr_array_push(a1);
        v76 = v79[1].i64[0];
        *v75 = 16;
        v75[1] = v78;
        v75[2] = a4;
        v75[3] = v77;
        v75[4] = v76;
        v75[5] = v62;
        *((_DWORD *)v75 + 12) = v60;
        *((_DWORD *)v75 + 13) = 0;
        break;
      default:
        return result;
    }
    return 1;
  }
  switch(v8)
  {
    case -10240:
      memset(v79, 0, 40);
      DYTraceDecode_MTLCommandBuffer_restoreMTLBufferContents((uint64_t)v79, a3);
      v9 = (uint64_t *)GetAliasStream(v7, v79[0].i64[1], a4);
      if (v9)
        v10 = *v9;
      else
        v10 = 0;
      v48 = apr_pstrdup(a1->pool, (const char *)v79[1].i64[0]);
      v49 = apr_array_push(a1);
      v50 = *(__int128 *)((char *)&v79[1] + 8);
      *v49 = 22;
      v49[1] = v10;
      v49[2] = a4;
      v49[3] = v48;
      *((_OWORD *)v49 + 2) = v50;
      return 1;
    case -10238:
    case -10236:
      goto LABEL_16;
    case -10237:
      goto LABEL_18;
    case -10232:
      v31 = a3 + 36;
      v32 = strcmp((const char *)(a3 + 36), "CUulul");
      v33 = 12;
      if (!v32)
        v33 = 8;
      v79[0].i64[0] = *(_QWORD *)(v31 + v33);
      v82 = v33 + 8;
      v34 = AppendString_11072((const char **)&v79[0].i64[1], v31, &v82);
      v79[1] = *(int64x2_t *)(v31 + ((v82 + 3) & 0xFFFFFFFFFFFFFFFCLL));
      v35 = (uint64_t *)GetAliasStream(v7, v79[0].i64[0], a4);
      if (v35)
        v36 = *v35;
      else
        v36 = 0;
      v69 = apr_pstrdup(a1->pool, v34);
      v46 = apr_array_push(a1);
      v70 = vmovn_s64(v79[1]);
      *v46 = 86;
      v46[1] = v36;
      v46[2] = a4;
      v46[3] = v69;
      v46[4] = v70;
      v46[7] = 0;
      v46[5] = 0;
      goto LABEL_51;
    default:
      return result;
  }
  return result;
}

uint64_t GTMTLDataSource_compareRestores(uint64_t a1, uint64_t a2)
{
  int RestoreSortingOrder;

  RestoreSortingOrder = GetRestoreSortingOrder(a1);
  return RestoreSortingOrder - GetRestoreSortingOrder(a2);
}

uint64_t GetRestoreSortingOrder(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)a1;
  if (*(uint64_t *)a1 > 59)
  {
    if (v1 > 82)
    {
      if (v1 == 86)
        return 4;
      if (v1 == 83)
        return 2;
    }
    else
    {
      if (v1 == 60)
        return 1;
      if (v1 == 80)
        return 5;
    }
    return 0;
  }
  switch(v1)
  {
    case 16:
      if (*(_DWORD *)(a1 + 48))
        return 7;
      else
        return 6;
    case 22:
      return 3;
    case 57:
      return 8;
    default:
      return 0;
  }
}

id SharedBufferArray_retainArray(uint64_t a1)
{
  id v2;
  void *v3;
  void *v4;
  unint64_t v5;
  void *v6;
  id v7;

  v2 = objc_msgSend(*(id *)(a1 + 8), "copy");
  objc_msgSend(*(id *)(a1 + 8), "removeAllObjects");
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "lastObject"));
  v4 = v3;
  if (v3)
  {
    v5 = *(_QWORD *)(a1 + 16);
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "buffer"));
    v7 = objc_msgSend(v6, "length");

    if (v5 < (unint64_t)v7)
      objc_msgSend(*(id *)(a1 + 8), "addObject:", v4);
  }

  return v2;
}

void SharedCommandBuffer_clearCommandBuffer(uint64_t a1)
{
  void *v2;
  void *v3;

  objc_msgSend(*(id *)(a1 + 16), "endEncoding");
  v2 = *(void **)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;

  v3 = *(void **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = 0;

}

id SharedCommandBuffer_commandBuffer(uint64_t a1)
{
  void *v2;
  id v3;
  uint64_t v4;
  void *v5;

  v2 = *(void **)(a1 + 8);
  if (!v2)
  {
    v3 = InternalCommandBuffer(*(void **)a1, CFSTR("SharedCommandBuffer"));
    v4 = objc_claimAutoreleasedReturnValue(v3);
    v5 = *(void **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = v4;

    v2 = *(void **)(a1 + 8);
  }
  return v2;
}

id InternalCommandBuffer(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  id v6;
  void *v7;
  id v8;
  void *v9;

  v3 = a1;
  v4 = a2;
  if (objc_msgSend(v3, "isStatEnabled"))
  {
    v5 = objc_msgSend(v3, "getStatLocations");
    objc_msgSend(v3, "setStatLocations:", 0);
    v6 = NewCommandBuffer(v3);
    v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    objc_msgSend(v3, "setStatLocations:", v5);
  }
  else
  {
    v8 = NewCommandBuffer(v3);
    v7 = (void *)objc_claimAutoreleasedReturnValue(v8);
  }
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@.%@"), CFSTR("com.apple.gputools.replay"), v4));

  objc_msgSend(v7, "setLabel:", v9);
  return v7;
}

id InternalBlitCommandEncoder(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  void *v6;

  v3 = a1;
  v4 = a2;
  if (objc_msgSend(v4, "isStatEnabled"))
  {
    v5 = objc_msgSend(v4, "getStatLocations");
    objc_msgSend(v4, "setStatLocations:", 0);
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "blitCommandEncoder"));
    objc_msgSend(v4, "setStatLocations:", v5);
  }
  else
  {
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "blitCommandEncoder"));
  }

  return v6;
}

void verifyPerCounterCommandData(void *a1, void *a2, void *a3, id a4)
{
  id v7;
  id v8;
  id v9;
  id v10;
  uint64_t v11;
  id v12;
  void *i;
  uint64_t v14;
  void *v15;
  void *v16;
  void *v17;
  uint64_t v18;
  FILE *v19;
  const char *v20;
  id v21;
  id v22;
  void *v23;
  FILE *v24;
  const char *v25;
  id v26;
  id v27;
  id v28;
  id obj;
  void *v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  _BYTE v35[128];

  v7 = a2;
  v8 = a3;
  if (g_runningValidationCI)
  {
    v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "objectForKeyedSubscript:", v7));
    if (v30)
    {
      v33 = 0u;
      v34 = 0u;
      v31 = 0u;
      v32 = 0u;
      v28 = v8;
      obj = v8;
      v9 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v31, v35, 16);
      if (!v9)
        goto LABEL_18;
      v10 = v9;
      v11 = *(_QWORD *)v32;
      v12 = v7;
      while (1)
      {
        for (i = 0; i != v10; i = (char *)i + 1)
        {
          if (*(_QWORD *)v32 != v11)
            objc_enumerationMutation(obj);
          v14 = *(_QWORD *)(*((_QWORD *)&v31 + 1) + 8 * (_QWORD)i);
          v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "objectForKeyedSubscript:", v14));
          v16 = v15;
          if (v15)
          {
            if (objc_msgSend(v15, "count") == a4)
              goto LABEL_16;
            v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Counter %@ had incorrect number of results when validating %@ dictionary, size was %lu should be %lu"), v14, v7, objc_msgSend(v16, "count"), a4));
            v18 = 579;
          }
          else
          {
            v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Counter %@ not found when validating %@ dictionary"), v14, v7));
            v18 = 575;
          }
          v19 = __stdoutp;
          if (g_runningInCI)
            v20 = "#CI_ERROR# ";
          else
            v20 = "";
          v21 = objc_retainAutorelease(v17);
          fprintf(v19, "%s%s %u: %s\n", v20, "void verifyPerCounterCommandData(NSDictionary *__strong, NSString *__strong, NSArray *__strong, NSUInteger)", v18, (const char *)objc_msgSend(v21, "UTF8String"));
          v22 = objc_retainAutorelease(v21);
          GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v22, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m", (uint64_t)"verifyPerCounterCommandData", v18, 1);

          v7 = v12;
LABEL_16:

        }
        v10 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v31, v35, 16);
        if (!v10)
        {
LABEL_18:

          v8 = v28;
          goto LABEL_23;
        }
      }
    }
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Dictionary %@ not found in JSON dictionary"), v7));
    v24 = __stdoutp;
    if (g_runningInCI)
      v25 = "#CI_ERROR# ";
    else
      v25 = "";
    v26 = objc_retainAutorelease(v23);
    fprintf(v24, "%s%s %u: %s\n", v25, "void verifyPerCounterCommandData(NSDictionary *__strong, NSString *__strong, NSArray *__strong, NSUInteger)", 567, (const char *)objc_msgSend(v26, "UTF8String"));
    v27 = objc_retainAutorelease(v26);
    GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v27, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m", (uint64_t)"verifyPerCounterCommandData", 567, 1);

LABEL_23:
  }

}

id GenerateSimplePriorityList(void *a1, unint64_t *a2)
{
  id v2;
  id v3;
  unint64_t v4;
  unint64_t v5;
  void *v6;
  unsigned int v7;
  id v8;
  uint64_t i;
  void *v10;
  void *v11;
  void *v12;
  FILE *v13;
  id v14;

  v2 = a1;
  v3 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", objc_msgSend(v2, "count"));
  v4 = 0;
  if (objc_msgSend(v2, "count"))
  {
    v5 = 0;
    do
    {
      v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectAtIndexedSubscript:", v5));
      v7 = objc_msgSend(v6, "unsignedIntValue");

      if (v7)
      {
        v8 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", v7);
        for (i = 0; i != v7; ++i)
        {
          v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", i));
          objc_msgSend(v8, "addObject:", v10);

        }
        objc_msgSend(v3, "addObject:", v8);
        if (v4 <= v7)
          v4 = v7;

      }
      ++v5;
    }
    while (v5 < (unint64_t)objc_msgSend(v2, "count"));
  }
  if (g_runningInCI)
  {
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Batch ID filtering will require %lu batches"), v4));
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

    v13 = __stdoutp;
    v14 = objc_retainAutorelease(v12);
    fprintf(v13, "#CI-INFO# %s\n", (const char *)objc_msgSend(v14, "UTF8String"));

  }
  if (a2)
    *a2 = v4;

  return v3;
}

id RemoveUnfilterableCounters(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  uint64_t v6;
  id v7;
  id v8;
  id v9;
  uint64_t v10;
  void *v11;
  id v12;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _QWORD v18[4];
  id v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t (*v24)(uint64_t, uint64_t);
  void (*v25)(uint64_t);
  id v26;
  _BYTE v27[128];

  v3 = a1;
  v4 = a2;
  v5 = objc_msgSend(v3, "mutableCopy");
  v21 = 0;
  v22 = &v21;
  v23 = 0x3032000000;
  v24 = __Block_byref_object_copy__5673;
  v25 = __Block_byref_object_dispose__5674;
  v26 = (id)objc_opt_new(NSMutableArray, v6);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = __RemoveUnfilterableCounters_block_invoke;
  v18[3] = &unk_726218;
  v7 = v4;
  v19 = v7;
  v20 = &v21;
  objc_msgSend(v5, "enumerateKeysAndObjectsUsingBlock:", v18);
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v8 = (id)v22[5];
  v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v14, v27, 16);
  if (v9)
  {
    v10 = *(_QWORD *)v15;
    do
    {
      v11 = 0;
      do
      {
        if (*(_QWORD *)v15 != v10)
          objc_enumerationMutation(v8);
        objc_msgSend(v5, "removeObjectForKey:", *(_QWORD *)(*((_QWORD *)&v14 + 1) + 8 * (_QWORD)v11), (_QWORD)v14);
        v11 = (char *)v11 + 1;
      }
      while (v9 != v11);
      v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v14, v27, 16);
    }
    while (v9);
  }

  v12 = objc_msgSend(v5, "copy");
  _Block_object_dispose(&v21, 8);

  return v12;
}

void sub_2B9500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__5673(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__5674(uint64_t a1)
{

}

uint64_t GTMTLReplay_CLI(const char *a1, uint64_t a2, uint64_t a3, apr_allocator_t *a4)
{
  void *v5;
  void *v6;
  FILE *v7;
  id v8;
  apr_pool_t *v9;
  char *DataSource;
  void *v11;
  void *v12;
  FILE *v13;
  id v14;
  void *v15;
  NSString *v16;
  void *v17;
  id v18;
  void *v19;
  FILE *v20;
  int v21;
  id v22;
  const char *v23;
  const char *v24;
  id v25;
  uint64_t v26;
  unsigned int v27;
  void *v28;
  uint64_t v29;
  void (*v30)(uint64_t);
  void *v31;
  void *v32;
  FILE *v33;
  id v34;
  void *v35;
  void *v36;
  void *v37;
  FILE *v38;
  id v39;
  id v40;
  void *v41;
  io_registry_entry_t v42;
  id MetalPluginName;
  const char *v44;
  id v45;
  void *v46;
  char v47;
  void *v48;
  void *v49;
  FILE *v50;
  id v51;
  CFTypeRef v52;
  void *v53;
  void *v54;
  unsigned int v55;
  void *v56;
  void *v57;
  FILE *v58;
  id v59;
  GTMTLReplayObjectMap *v60;
  void *v61;
  void *v62;
  FILE *v63;
  id v64;
  size_t v65;
  uint64_t v66;
  unint64_t v67;
  NSString *v68;
  void *v69;
  void *v70;
  FILE *v71;
  id v72;
  int v73;
  void *v74;
  void *v75;
  FILE *v76;
  id v77;
  void *v78;
  void *v79;
  FILE *v80;
  id v81;
  void *v82;
  char *v83;
  uint64_t v84;
  void *v85;
  void *v86;
  FILE *v87;
  id v88;
  void *v89;
  void *v90;
  void *v91;
  void *v92;
  uint64_t v93;
  unsigned int v94;
  void *v95;
  void *v96;
  FILE *v97;
  id v98;
  void *v99;
  void *v100;
  FILE *v101;
  id v102;
  void *v103;
  id Analysis;
  void *v105;
  void *v106;
  id v107;
  void *v108;
  void *v109;
  id v110;
  uint64_t v111;
  void *v112;
  void *v113;
  void *v114;
  id v115;
  void *v116;
  void *v117;
  void *v118;
  FILE *v119;
  id v120;
  id v121;
  id DerivedDataPayload;
  void *v123;
  id v124;
  id v125;
  void *v126;
  void *v127;
  void *v128;
  id SimplePriorityList;
  void *v130;
  GTShaderProfilerHelper *v131;
  void *v132;
  void *v133;
  FILE *v134;
  id v135;
  void *v136;
  void *v137;
  FILE *v138;
  id v139;
  void *v140;
  void *v141;
  FILE *v142;
  id v143;
  char v144;
  void *v145;
  FILE *v146;
  int v147;
  id v148;
  const char *v149;
  const char *v150;
  id v151;
  void *v152;
  id v153;
  void *v154;
  uint64_t v155;
  uint64_t v156;
  apr_allocator_t *v157;
  id v158;
  void *v159;
  void *v160;
  void *v161;
  void *v162;
  void *v163;
  id v164;
  void *v165;
  void *v166;
  void *v167;
  void *v168;
  FILE *v169;
  id v170;
  id v171;
  void *v172;
  void *v173;
  FILE *v174;
  id v175;
  uint64_t *v176;
  uint64_t v177;
  int v178;
  int v179;
  uint64_t v180;
  uint64_t v181;
  __CFString *v182;
  __CFString *v183;
  uint64_t v184;
  uint64_t v185;
  unint64_t v186;
  unint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  int v191;
  BOOL v193;
  int v194;
  BOOL v195;
  int v196;
  uint64_t *v199;
  uint64_t v200;
  uint64_t v201;
  int v202;
  BOOL v203;
  int v204;
  char *v206;
  char *v207;
  void *v208;
  uint64_t v209;
  id v210;
  unint64_t v211;
  uint64_t v212;
  unint64_t v213;
  unint64_t v214;
  uint64_t v215;
  char *v219;
  char *v220;
  __CFString *v221;
  char *v222;
  char *v223;
  const __CFString *v224;
  BOOL v225;
  int v226;
  int v227;
  int v228;
  BOOL v231;
  void *v232;
  BOOL v233;
  void *v234;
  FILE *v235;
  int v236;
  id v237;
  const char *v238;
  const char *v239;
  void *v240;
  id v241;
  void *v242;
  void *v243;
  FILE *v244;
  id v245;
  GTShaderProfilerHelper *v246;
  void *v247;
  FILE *v248;
  int v249;
  id v250;
  const char *v251;
  const char *v252;
  void *v253;
  id v254;
  void *v255;
  void *v256;
  id v257;
  void *v258;
  id v259;
  void *v260;
  id v261;
  id v262;
  void *v263;
  id v264;
  void *v265;
  void *v266;
  FILE *v267;
  id v268;
  GTShaderProfilerHelper *v269;
  id v270;
  void *v271;
  id v272;
  void *v273;
  id v274;
  void *v275;
  void *v276;
  id DerivedCounterInfo;
  void *v278;
  id v279;
  void *v280;
  id v281;
  void *v282;
  void *v283;
  void *v284;
  int v285;
  uint64_t v286;
  void *v287;
  id v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  apr_allocator_t *v292;
  id v293;
  void *v294;
  void *v295;
  void *v296;
  void *v297;
  FILE *v298;
  id v299;
  id v300;
  void *v301;
  void *v302;
  FILE *v303;
  id v304;
  void *v305;
  void *v306;
  FILE *v307;
  id v308;
  id v309;
  void *v310;
  void *v311;
  FILE *v312;
  id v313;
  void *v314;
  void *v315;
  FILE *v316;
  id v317;
  void *v318;
  id v319;
  void *v320;
  id v321;
  void *v322;
  id v323;
  id v324;
  void *v325;
  void *v326;
  id v327;
  void *v328;
  id v329;
  id v330;
  void *v331;
  id v332;
  id v333;
  uint64_t v334;
  void *v335;
  void *v336;
  id v337;
  void *v338;
  void *v339;
  void *v340;
  FILE *v341;
  id v342;
  void *v343;
  void *v344;
  void *v345;
  FILE *v346;
  id v347;
  void *v348;
  id v349;
  BOOL v350;
  char v351;
  uint64_t v352;
  void *v353;
  void *v354;
  void *v355;
  FILE *v356;
  id v357;
  void *v358;
  void *v359;
  FILE *v360;
  id v361;
  void *v362;
  void *v363;
  unsigned int v364;
  unsigned int v365;
  void *v366;
  void *v367;
  void *v368;
  void *v369;
  void *v370;
  uint64_t v371;
  void *v372;
  unsigned int v373;
  uint64_t v374;
  void *v375;
  id v376;
  void *v377;
  FILE *v378;
  int v379;
  id v380;
  const char *v381;
  const char *v382;
  id v383;
  void *v384;
  id v385;
  void *v386;
  void *v387;
  void *v388;
  void *v389;
  void *v390;
  void *v391;
  void *v392;
  id v393;
  void *v394;
  void *v395;
  void *v396;
  void *v397;
  id v398;
  uint64_t v399;
  void *i;
  void *v401;
  id v402;
  uint64_t v403;
  void *j;
  void *v405;
  void *v406;
  id v407;
  void *v408;
  FILE *v409;
  int v410;
  id v411;
  const char *v412;
  const char *v413;
  id v414;
  id v415;
  uint64_t v416;
  id v417;
  void *v418;
  void *v419;
  void *v420;
  void *v421;
  void *v422;
  FILE *v423;
  int v424;
  id v425;
  const char *v426;
  const char *v427;
  id v428;
  id v429;
  void *v430;
  id v431;
  void *v432;
  id v433;
  void *v434;
  void *v435;
  uint64_t *v436;
  int v437;
  int v438;
  _QWORD *v439;
  uint64_t v440;
  uint64_t RenderPassDescriptor;
  int v442;
  uint64_t v443;
  uint64_t v444;
  unsigned int v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  void *v449;
  id *v450;
  void *v451;
  void *v452;
  _QWORD *Object;
  unint64_t v454;
  unint64_t v455;
  uint64_t v456;
  uint64_t v457;
  uint64_t v458;
  uint64_t v459;
  uint64_t v460;
  uint64_t v461;
  uint64_t v462;
  void *v463;
  void **v464;
  void *v465;
  void *v466;
  int v467;
  id v468;
  id v469;
  void *v470;
  id v471;
  void *v472;
  void *v473;
  void *v474;
  void *v475;
  void *v476;
  void *v477;
  void *v478;
  void *v479;
  id v480;
  void *v481;
  void *v482;
  void *v483;
  id v484;
  void *v485;
  void *v486;
  void *v487;
  void *v488;
  void *v489;
  void *v490;
  void *v491;
  void *v492;
  void *v493;
  void *v494;
  void *v495;
  void *v496;
  FILE *v497;
  id v498;
  void *v499;
  void *v500;
  void *v501;
  FILE *v502;
  id v503;
  uint64_t v505;
  uint64_t v506;
  void *v507;
  void *v508;
  FILE *v509;
  id v510;
  id v511;
  void *v512;
  void *v513;
  id v514;
  uint64_t v515;
  void *v516;
  void *v517;
  uint64_t v518;
  void *v519;
  void *v520;
  void *v521;
  id v522;
  void *v523;
  void *v524;
  void *v525;
  FILE *v526;
  id v527;
  dispatch_semaphore_t v528;
  NSObject *v529;
  void *v530;
  void *v531;
  FILE *v532;
  id v533;
  id v534;
  void *v535;
  id v536;
  void *v537;
  id v538;
  uint64_t v539;
  void *v540;
  void *v541;
  void *v542;
  void *v543;
  id v544;
  void *v545;
  void *v546;
  void *v547;
  FILE *v548;
  id v549;
  void *v550;
  id v551;
  BOOL v552;
  char v553;
  uint64_t v554;
  void *v555;
  void *v556;
  void *v557;
  FILE *v558;
  id v559;
  void *v560;
  void *v561;
  FILE *v562;
  id v563;
  void *v564;
  void *v565;
  void *v566;
  void *v567;
  unsigned int v568;
  unsigned int v569;
  void *v570;
  void *v571;
  void *v572;
  void *v573;
  uint64_t v574;
  void *v575;
  unsigned __int8 v576;
  uint64_t v577;
  void *v578;
  unsigned int v579;
  void *v580;
  void *v581;
  id v582;
  void *v583;
  void *v584;
  id v585;
  void *v586;
  void *v587;
  FILE *v588;
  id v589;
  GTShaderProfilerHelper *v590;
  void *v591;
  id v592;
  _UNKNOWN **v593;
  void *v594;
  id v595;
  void *v596;
  void *v597;
  _BOOL4 v598;
  void *v599;
  id v600;
  void *v601;
  void *v602;
  void *v603;
  void *v604;
  void *v605;
  id v606;
  id v607;
  id v608;
  void *v609;
  id v610;
  id v611;
  void *v612;
  void *v613;
  id v614;
  void *v615;
  void *v616;
  void *v617;
  void *v618;
  void *v619;
  id v620;
  void *v621;
  void *v622;
  void *v623;
  void *v624;
  void *v625;
  id v626;
  void *v627;
  id v628;
  void *v629;
  id v630;
  void *v631;
  id v632;
  void *v633;
  void *v634;
  void *v635;
  void *v636;
  id PerCounterCommandData;
  void *v638;
  void *v639;
  void *v640;
  void *v641;
  void *v642;
  GTShaderProfilerHelper *v643;
  void *v644;
  void *v645;
  id v646;
  id v647;
  void *v648;
  void *v649;
  id v650;
  id v651;
  uint64_t v652;
  uint64_t v653;
  uint64_t v654;
  void *v655;
  int v656;
  __CFString *v657;
  uint64_t v658;
  uint64_t *v659;
  id v660;
  void *v661;
  GTMTLReplayObjectMap *v662;
  void *v663;
  void *v664;
  id v665;
  id v666;
  id v667;
  void *v668;
  void *v669;
  void *v670;
  uint64_t *InclusiveRange;
  void *v672;
  uint64_t v673;
  void *v674;
  uint64_t **Controller;
  id v676;
  void *v677;
  int v678;
  void *v679;
  _QWORD *v680;
  void *v681;
  id obj;
  uint64_t *obja;
  id objb;
  id objc;
  id objd;
  _QWORD *obje;
  id objf;
  uint64_t v689;
  id v690;
  int v691;
  void *v692;
  void *v693;
  uint64_t v694;
  void *v695;
  void *v696;
  uint64_t v697;
  id v698;
  void *v699;
  int v700;
  void *v701;
  void *v702;
  void *v703;
  uint64_t v704;
  id v705;
  void *v706;
  void *v708;
  uint64_t v709;
  void *v711;
  __CFString *v712;
  id v713;
  void *v714;
  _QWORD v715[4];
  id v716;
  id v717;
  _QWORD v718[6];
  _QWORD v719[4];
  id v720;
  id *v721;
  _QWORD v722[4];
  id v723;
  void ***v724;
  _QWORD v725[6];
  _QWORD v726[4];
  NSObject *v727;
  id v728;
  __int128 *v729;
  void ***v730;
  __int128 *v731;
  id *v732;
  void **v733;
  _QWORD v734[4];
  id v735;
  _QWORD v736[4];
  id v737;
  _QWORD v738[4];
  id v739;
  void *v740;
  _QWORD v741[4];
  id v742;
  id v743;
  uint64_t v744;
  id v745[7];
  __int128 v746;
  __int128 v747;
  __int128 v748;
  __int128 v749;
  __int128 v750;
  __int128 v751;
  uint64_t v752;
  unsigned int v753;
  id v754;
  id v755;
  id v756;
  apr_pool_t *newpool;
  __int128 v758;
  __int128 v759;
  __int128 v760;
  __int128 v761;
  __int128 v762;
  __int128 v763;
  __int128 v764;
  __int128 v765;
  __int128 v766;
  __int128 v767;
  __int128 v768;
  __int128 v769;
  const __CFString *v770;
  id v771;
  _QWORD v772[2];
  _QWORD v773[2];
  _QWORD v774[3];
  _QWORD v775[3];
  const __CFString *v776;
  void *v777;
  _QWORD v778[5];
  _QWORD v779[5];
  _QWORD v780[2];
  _QWORD v781[2];
  void *v782;
  void **v783;
  uint64_t v784;
  uint64_t v785;
  id location;
  id *p_location;
  uint64_t v788;
  uint64_t v789;
  void **p_isa;
  uint64_t v791;
  uint64_t v792;
  __CFString *v793;
  id v794;
  _QWORD v795[12];
  __int128 v796;

  newpool = 0;
  apr_pool_create_ex(&newpool, 0, 0, a4);
  v755 = objc_alloc_init((Class)NSOperationQueue);
  v756 = objc_alloc_init((Class)NSOperationQueue);
  objc_msgSend(v756, "setName:", CFSTR("gputools.MTLReplayer.parallelQueue"));
  objc_msgSend(v755, "setName:", CFSTR("gputools.MTLReplayer.serialQueue"));
  objc_msgSend(v755, "setMaxConcurrentOperationCount:", 1);
  if (g_runningInCI)
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("MTLReplayer attempting to open capture archive: %s"), a1));
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

    v7 = __stdoutp;
    v8 = objc_retainAutorelease(v6);
    fprintf(v7, "#CI-INFO# %s\n", (const char *)objc_msgSend(v8, "UTF8String"));

  }
  v9 = newpool;
  DataSource = GTMTLReplayController_makeDataSource(a1, newpool);
  if (!DataSource)
  {
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Failed to open capture archive: %s"), a1));
    v20 = __stdoutp;
    v21 = g_runningInCI;
    v22 = objc_retainAutorelease(v19);
    v23 = (const char *)objc_msgSend(v22, "UTF8String");
    v24 = "#CI_ERROR# ";
    if (!v21)
      v24 = "";
    fprintf(v20, "%s%s %u: %s\n", v24, "int GTMTLReplay_CLI(const char *, GTMTLReplayCLIOptions, void (*)(NSData *__strong, NSURL *__strong))", 673, v23);
    v25 = objc_retainAutorelease(v22);
    v26 = 1;
    GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v25, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m", (uint64_t)"GTMTLReplay_CLI", 673, 1);
    goto LABEL_344;
  }
  if (g_runningInCI)
  {
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("MTLReplayer opened capture archive: %s"), a1));
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

    v13 = __stdoutp;
    v14 = objc_retainAutorelease(v12);
    fprintf(v13, "#CI-INFO# %s\n", (const char *)objc_msgSend(v14, "UTF8String"));

  }
  v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
  v754 = 0;
  objc_msgSend(v15, "createDirectoryAtPath:withIntermediateDirectories:attributes:error:", CFSTR("/tmp/com.apple.gputools.profiling"), 1, 0, &v754);
  v660 = v754;

  v16 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", *(_QWORD *)(GTMTLSMContext_getObject(**((_QWORD **)DataSource + 5), 1, *((_QWORD *)DataSource + 10))[5]+ 64));
  v661 = (void *)objc_claimAutoreleasedReturnValue(v16);
  v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"));
  v664 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "stringForKey:", CFSTR("GPUMTLOverrideDeviceFamily")));

  if (*(_QWORD *)(a2 + 40))
  {
    v18 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:"));
  }
  else
  {
    if (!v664 || (v27 = objc_msgSend(v661, "hasPrefix:", v664), v28 = v664, v27))
      v28 = v661;
    v18 = v28;
  }
  v655 = v18;
  v29 = *(_QWORD *)(GTMTLSMContext_getObject(**((_QWORD **)DataSource + 5), 1, *((_QWORD *)DataSource + 10))[5] + 16);
  v30 = (void (*)(uint64_t))dlsym((void *)0xFFFFFFFFFFFFFFFDLL, "MTLOverrideDeviceCreationFlags");
  if (v30)
    v30(v29);
  if (g_runningInCI)
  {
    v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Creating system default device")));
    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v31, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

    v33 = __stdoutp;
    v34 = objc_retainAutorelease(v32);
    fprintf(v33, "#CI-INFO# %s\n", (const char *)objc_msgSend(v34, "UTF8String"));

  }
  v676 = MTLCreateSystemDefaultDevice();
  if (g_runningInCI)
  {
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v676, "name"));
    v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Selected default device %@"), v35));

    v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v36, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));
    v38 = __stdoutp;
    v39 = objc_retainAutorelease(v37);
    fprintf(v38, "#CI-INFO# %s\n", (const char *)objc_msgSend(v39, "UTF8String"));

  }
  v40 = DEVICEOBJECT(v676);
  v41 = (void *)objc_claimAutoreleasedReturnValue(v40);
  v42 = objc_msgSend(v41, "acceleratorPort");

  v753 = 0x7FFFFFFF;
  MetalPluginName = GetMetalPluginName(v42, &v753);
  v669 = (void *)objc_claimAutoreleasedReturnValue(MetalPluginName);
  v689 = v753;
  if (v753 == 0x80000000)
    v689 = MetalPluginTarget(v669);
  v700 = IsAGXMetalPlugin(v669, v44);
  if (v700)
  {
    v45 = DEVICEOBJECT(v676);
    v46 = (void *)objc_claimAutoreleasedReturnValue(v45);
    v47 = objc_opt_respondsToSelector(v46, "setShaderDebugInfoCaching:");

    if ((v47 & 1) != 0)
    {
      objc_msgSend(v676, "setShaderDebugInfoCaching:", 1);
      if (g_runningInCI)
      {
        v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Enabled shaderDebugInfoCaching on device")));
        v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v48, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

        v50 = __stdoutp;
        v51 = objc_retainAutorelease(v49);
        fprintf(v50, "#CI-INFO# %s\n", (const char *)objc_msgSend(v51, "UTF8String"));

      }
    }
    if ((*(_BYTE *)(a2 + 186) & 0x40) != 0)
    {
      v52 = GTProfilerConfigurationVariables(v42);
      v53 = (void *)objc_claimAutoreleasedReturnValue(v52);
      v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v53, "objectForKeyedSubscript:", CFSTR("num_cores")));
      v55 = objc_msgSend(v54, "unsignedIntValue");

      if ((int)v689 > 5 || (_DWORD)v689 == 5 && v55 >= 7)
        *(_DWORD *)(a2 + 184) = *(_DWORD *)(a2 + 184) & 0xFF3FFFFF | 0x800000;

    }
  }
  if (g_runningInCI)
  {
    v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Calling GTMTLReplaySupport_init()")));
    v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v56, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

    v58 = __stdoutp;
    v59 = objc_retainAutorelease(v57);
    fprintf(v58, "#CI-INFO# %s\n", (const char *)objc_msgSend(v59, "UTF8String"));

  }
  v60 = -[GTMTLReplayObjectMap initWithDevice:]([GTMTLReplayObjectMap alloc], "initWithDevice:", v676);
  GTMTLReplaySupport_init(v676);
  GTMTLReplayController_initializeArgumentBufferSupport((uint64_t)DataSource, v676, v60);
  GTMTLReplayController_populateUnusedResources(DataSource, v60);
  v662 = v60;
  if (g_runningInCI)
  {
    v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Calling GTMTLReplayController_makeController()")));
    v62 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v61, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

    v63 = __stdoutp;
    v64 = objc_retainAutorelease(v62);
    fprintf(v63, "#CI-INFO# %s\n", (const char *)objc_msgSend(v64, "UTF8String"));

  }
  Controller = (uint64_t **)GTMTLReplayController_makeController((uint64_t)DataSource, v9, v676, v60, 0, 0);
  if ((*(_BYTE *)(a2 + 186) & 0xF0) != 0)
  {
    v65 = os_proc_available_memory();
    v66 = v65 - 0x10000000;
    if (v65 - 0x10000000 >= 0x18000000)
      v66 = 402653184;
    if (v65 >> 28)
      v67 = v66;
    else
      v67 = 0;
    if (g_runningInCI)
    {
      v68 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("OptimizingRestores, maxBufferLen = %zu, availableMemory = %zu\n"), v67, os_proc_available_memory());
      v69 = (void *)objc_claimAutoreleasedReturnValue(v68);
      v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v69, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

      v71 = __stdoutp;
      v72 = objc_retainAutorelease(v70);
      fprintf(v71, "#CI-INFO# %s\n", (const char *)objc_msgSend(v72, "UTF8String"));

    }
    GTMTLReplayController_optimizeRestores((uint64_t)Controller, v67);
  }
  v73 = g_runningInCI;
  if (g_runningInCI)
  {
    v74 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Creating GTMTLReplayWireframeRenderer")));
    v75 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v74, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

    v76 = __stdoutp;
    v77 = objc_retainAutorelease(v75);
    fprintf(v76, "#CI-INFO# %s\n", (const char *)objc_msgSend(v77, "UTF8String"));

    v73 = g_runningInCI;
  }
  v745[1] = 0;
  v745[0] = 0;
  memset(&v745[3], 0, 24);
  v746 = 0u;
  v747 = 0u;
  v748 = 0u;
  v749 = 0u;
  v750 = 0u;
  v751 = 0u;
  v752 = 0;
  if (v73)
  {
    v78 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Calling GTMTLReplayWireframeRenderer_initWithDevice()")));
    v79 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v78, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

    v80 = __stdoutp;
    v81 = objc_retainAutorelease(v79);
    fprintf(v80, "#CI-INFO# %s\n", (const char *)objc_msgSend(v81, "UTF8String"));

  }
  v82 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(Controller[1], "defaultDevice"));
  GTMTLReplayWireframeRenderer_initWithDevice((uint64_t)v745, v82);

  v83 = getenv("ATF_RESULTSDIRECTORY");
  if (!v83 || g_runningInCI)
  {
    v84 = a2;
    if (g_runningInCI)
    {
      v85 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("options.saveDestination=%s"), *(_QWORD *)(a2 + 48)));
      v86 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v85, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

      v87 = __stdoutp;
      v88 = objc_retainAutorelease(v86);
      fprintf(v87, "#CI-INFO# %s\n", (const char *)objc_msgSend(v88, "UTF8String"));

      v84 = a2;
    }
  }
  else
  {
    v84 = a2;
    *(_QWORD *)(a2 + 48) = v83;
    *(_DWORD *)(a2 + 184) |= 0x40u;
  }
  v89 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", *(_QWORD *)(v84 + 48)));
  v670 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:](NSURL, "fileURLWithPath:isDirectory:", v89, 1));

  v90 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
  objc_msgSend(v90, "createDirectoryAtURL:withIntermediateDirectories:attributes:error:", v670, 1, 0, 0);

  v91 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a1));
  v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v91, "lastPathComponent"));
  v663 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v92, "stringByDeletingPathExtension"));

  v94 = *(_DWORD *)(a2 + 184);
  if ((v94 & 1) != 0)
  {
    if (g_runningInCI)
    {
      v140 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Calling GenerateThumbnails")));
      v141 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v140, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

      v142 = __stdoutp;
      v143 = objc_retainAutorelease(v141);
      fprintf(v142, "#CI-INFO# %s\n", (const char *)objc_msgSend(v143, "UTF8String"));

    }
    v741[0] = _NSConcreteStackBlock;
    v741[1] = 3221225472;
    v741[2] = __GTMTLReplay_CLI_block_invoke;
    v741[3] = &unk_726240;
    v742 = v663;
    v744 = a3;
    v743 = v670;
    v740 = 0;
    v144 = GenerateThumbnails(Controller, (uint64_t)v745, (uint64_t)&v755, (unsigned int *)a2, v741, &v740);
    v665 = v740;
    if ((v144 & 1) == 0)
    {
      GTMTLReplay_handleNSError(v665);
      v145 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Failed to generate thumbnails!")));
      v146 = __stdoutp;
      v147 = g_runningInCI;
      v148 = objc_retainAutorelease(v145);
      v149 = (const char *)objc_msgSend(v148, "UTF8String");
      v150 = "#CI_ERROR# ";
      if (!v147)
        v150 = "";
      fprintf(v146, "%s%s %u: %s\n", v150, "int GTMTLReplay_CLI(const char *, GTMTLReplayCLIOptions, void (*)(NSData *__strong, NSURL *__strong))", 808, v149);
      v151 = objc_retainAutorelease(v148);
      GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v151, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m", (uint64_t)"GTMTLReplay_CLI", 808, 1);

    }
    v107 = v742;
    goto LABEL_337;
  }
  if ((v94 & 0xC40000) == 0x40000)
  {
    if (g_runningInCI)
    {
      v95 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("profileBatchIdFilter")));
      v96 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v95, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

      v97 = __stdoutp;
      v98 = objc_retainAutorelease(v96);
      fprintf(v97, "#CI-INFO# %s\n", (const char *)objc_msgSend(v98, "UTF8String"));

    }
    if ((v700 & 1) != 0)
    {
      if ((v689 & 0x80000000) == 0)
      {
        if (g_runningInCI)
        {
          v99 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("targetIndex=%d"), v689));
          v100 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v99, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

          v101 = __stdoutp;
          v102 = objc_retainAutorelease(v100);
          fprintf(v101, "#CI-INFO# %s\n", (const char *)objc_msgSend(v102, "UTF8String"));

        }
        v103 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(Controller[1], "defaultDevice"));
        Analysis = DYMTLReplayFrameProfiler_loadAnalysis(v103);
        v105 = (void *)objc_claimAutoreleasedReturnValue(Analysis);
        v665 = objc_msgSend(v105, "mutableCopy");

        v106 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v665, "objectForKeyedSubscript:", CFSTR("DerivedCounterDictionary")));
        v107 = objc_msgSend(v106, "mutableCopy");

        verifyCounterDictionary(v107);
        v693 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v107, "objectForKeyedSubscript:", CFSTR("DerivedCounters")));
        v108 = (void *)objc_claimAutoreleasedReturnValue(+[NSBundle mainBundle](NSBundle, "mainBundle"));
        v109 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v108, "pathForResource:ofType:", CFSTR("GPUCounterGraph"), CFSTR("plist")));

        v110 = v109;
        v701 = (void *)objc_opt_new(NSMutableSet, v111);
        if (v110)
        {
          v112 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithContentsOfFile:](NSDictionary, "dictionaryWithContentsOfFile:", v110));
          v113 = v112;
          if (v112)
          {
            v114 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v112, "objectForKey:", CFSTR("counters")));
            p_isa = _NSConcreteStackBlock;
            v791 = 3221225472;
            v792 = (uint64_t)__BatchIdFilteredCounters_block_invoke;
            v793 = (__CFString *)&unk_7261F0;
            v794 = v701;
            objc_msgSend(v114, "enumerateKeysAndObjectsUsingBlock:", &p_isa);

          }
        }

        objc_msgSend(v701, "addObject:", CFSTR("GPUTime"));
        v115 = RemoveUnfilterableCounters(v693, v701);
        v116 = (void *)objc_claimAutoreleasedReturnValue(v115);
        objc_msgSend(v107, "setObject:forKeyedSubscript:", v116, CFSTR("DerivedCounters"));
        objc_msgSend(v665, "setObject:forKeyedSubscript:", v107, CFSTR("DerivedCounterDictionary"));
        if (g_runningInCI)
        {
          v117 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Filtered counter list from %lu to %lu counters"), objc_msgSend(v693, "count"), objc_msgSend(v116, "count")));
          v118 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v117, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

          v119 = __stdoutp;
          v120 = objc_retainAutorelease(v118);
          fprintf(v119, "#CI-INFO# %s\n", (const char *)objc_msgSend(v120, "UTF8String"));

        }
        v121 = GTMTLReplayHost_rawCounters(v116);
        v677 = (void *)objc_claimAutoreleasedReturnValue(v121);
        DerivedDataPayload = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)*Controller, 1);
        v123 = (void *)objc_claimAutoreleasedReturnValue(DerivedDataPayload);
        v124 = objc_msgSend(v123, "mutableCopy");

        v125 = GTMTLReplayHost_rawCountersToNormalizeSet(v116);
        obj = (id)objc_claimAutoreleasedReturnValue(v125);
        objc_msgSend(v124, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("NoBlitSampling"));
        objc_msgSend(v124, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("SampleEncoders"));
        objc_msgSend(v124, "setObject:forKeyedSubscript:", &__kCFBooleanFalse, CFSTR("SplitEncoderData"));
        objc_msgSend(v124, "setObject:forKeyedSubscript:", obj, CFSTR("NormalizedCounters"));
        v126 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v124, "objectForKeyedSubscript:", CFSTR("activePerEncoderDrawCallCount")));
        if (v126)
        {
          objc_msgSend(v124, "setObject:forKeyedSubscript:", v665, CFSTR("derivedCounterInfo"));
          v127 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", (*(_DWORD *)(a2 + 184) >> 18) & 1));
          objc_msgSend(v124, "setObject:forKeyedSubscript:", v127, CFSTR("profileBatchIdFilter"));

          objc_msgSend(v124, "setObject:forKeyedSubscript:", v677, CFSTR("profileCounters"));
          objc_msgSend(v124, "setObject:forKeyedSubscript:", v669, CFSTR("MetalPluginName"));
          v128 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v689));
          objc_msgSend(v124, "setObject:forKeyedSubscript:", v128, CFSTR("gpuTarget"));

          SimplePriorityList = GenerateSimplePriorityList(v126, 0);
          v130 = (void *)objc_claimAutoreleasedReturnValue(SimplePriorityList);
          objc_msgSend(v124, "setObject:forKeyedSubscript:", v130, CFSTR("encoderBatchPriorityList"));

          objc_msgSend(v124, "setObject:forKeyedSubscript:", 0, CFSTR("pause"));
          objc_msgSend(v124, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("resume"));
          objc_msgSend(v124, "setObject:forKeyedSubscript:", v669, CFSTR("MetalPluginName"));
          v791 = 0;
          p_isa = 0;
          v792 = 0;
          p_isa = (void **)objc_claimAutoreleasedReturnValue(objc_msgSend(v670, "path"));
          v791 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a1));
          v792 = 256;
          v131 = -[GTShaderProfilerHelper initWithOptions:]([GTShaderProfilerHelper alloc], "initWithOptions:", &p_isa);
          -[GTShaderProfilerHelper profileBatchIdFilteredData:withPayload:forReplayController:](v131, "profileBatchIdFilteredData:withPayload:forReplayController:", *Controller, v124);
          objc_initWeak(&location, v131);
          v738[0] = _NSConcreteStackBlock;
          v738[1] = 3221225472;
          v738[2] = __GTMTLReplay_CLI_block_invoke_2;
          v738[3] = &unk_726268;
          objc_copyWeak(&v739, &location);
          GTMTLReplayClient_streamBatchFilteredData((uint64_t)Controller, &v755, v124, v738);
          if (g_runningInCI)
          {
            v132 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Waiting for batch ID streaming...")));
            v133 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v132, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

            v134 = __stdoutp;
            v135 = objc_retainAutorelease(v133);
            fprintf(v134, "#CI-INFO# %s\n", (const char *)objc_msgSend(v135, "UTF8String"));

          }
          objc_msgSend(v756, "waitUntilAllOperationsAreFinished");
          if (g_runningInCI)
          {
            v136 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Finished")));
            v137 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v136, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

            v138 = __stdoutp;
            v139 = objc_retainAutorelease(v137);
            fprintf(v138, "#CI-INFO# %s\n", (const char *)objc_msgSend(v139, "UTF8String"));

          }
          objc_destroyWeak(&v739);
          objc_destroyWeak(&location);

        }
        else
        {
          v377 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("activePerEncoderDrawCallCount missing in payload")));
          v378 = __stdoutp;
          v379 = g_runningInCI;
          v380 = objc_retainAutorelease(v377);
          v381 = (const char *)objc_msgSend(v380, "UTF8String");
          v382 = "#CI_ERROR# ";
          if (!v379)
            v382 = "";
          fprintf(v378, "%s%s %u: %s\n", v382, "int GTMTLReplay_CLI(const char *, GTMTLReplayCLIOptions, void (*)(NSData *__strong, NSURL *__strong))", 854, v381);
          v383 = objc_retainAutorelease(v380);
          GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v383, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m", (uint64_t)"GTMTLReplay_CLI", 854, 1);

        }
        goto LABEL_337;
      }
      v247 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("-profileBatchIdFilter only supported on recent AGX devices")));
      v248 = __stdoutp;
      v249 = g_runningInCI;
      v250 = objc_retainAutorelease(v247);
      v251 = (const char *)objc_msgSend(v250, "UTF8String");
      v252 = "#CI_ERROR# ";
      if (!v249)
        v252 = "";
      fprintf(v248, "%s%s %u: %s\n", v252, "int GTMTLReplay_CLI(const char *, GTMTLReplayCLIOptions, void (*)(NSData *__strong, NSURL *__strong))", 821, v251);
      v667 = objc_retainAutorelease(v250);
      GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v667, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m", (uint64_t)"GTMTLReplay_CLI", 821, 1);

    }
    else
    {
      v234 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("-profileBatchIdFilter only supported on AGX devices")));
      v235 = __stdoutp;
      v236 = g_runningInCI;
      v237 = objc_retainAutorelease(v234);
      v238 = (const char *)objc_msgSend(v237, "UTF8String");
      v239 = "#CI_ERROR# ";
      if (!v236)
        v239 = "";
      fprintf(v235, "%s%s %u: %s\n", v239, "int GTMTLReplay_CLI(const char *, GTMTLReplayCLIOptions, void (*)(NSData *__strong, NSURL *__strong))", 817, v238);
      v666 = objc_retainAutorelease(v237);
      GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v666, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m", (uint64_t)"GTMTLReplay_CLI", 817, 1);

    }
    goto LABEL_338;
  }
  v25 = v660;
  if ((v94 & 0x100) == 0)
  {
    if ((v94 & 0x20000) != 0)
    {
      if (v700)
      {
        v240 = (void *)objc_opt_new(NSMutableDictionary, v93);
        objc_msgSend(v240, "setObject:forKeyedSubscript:", v669, CFSTR("MetalPluginName"));
        objc_msgSend(v240, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("UseMTLCounters"));
        objc_msgSend(v240, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("UseKicktimestamps"));
        objc_msgSend(v240, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("CoalesceComputeEncoders"));
        objc_msgSend(v240, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("CoalesceBlitEncoders"));
        objc_msgSend(v240, "setObject:forKeyedSubscript:", &off_739C10, CFSTR("GPUState"));
        v665 = v240;
        v241 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)*Controller, 1);
        v107 = (id)objc_claimAutoreleasedReturnValue(v241);
        objc_msgSend(v240, "addEntriesFromDictionary:", v107);
        v791 = 0;
        p_isa = 0;
        v792 = 0;
        p_isa = (void **)objc_claimAutoreleasedReturnValue(objc_msgSend(v670, "path"));
        v791 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a1));
        v792 = 4416;
        if (g_runningInCI)
        {
          v242 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Creating Streaming Shader Profiler Helper")));
          v243 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v242, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

          v244 = __stdoutp;
          v245 = objc_retainAutorelease(v243);
          fprintf(v244, "#CI-INFO# %s\n", (const char *)objc_msgSend(v245, "UTF8String"));

        }
        v246 = -[GTShaderProfilerHelper initWithOptions:]([GTShaderProfilerHelper alloc], "initWithOptions:", &p_isa);
        -[GTShaderProfilerHelper profileShadersForDataSource:withPayload:forReplayController:](v246, "profileShadersForDataSource:withPayload:forReplayController:", *Controller, v665);
        objc_initWeak(&location, v246);
        v734[0] = _NSConcreteStackBlock;
        v734[1] = 3221225472;
        v734[2] = __GTMTLReplay_CLI_block_invoke_210;
        v734[3] = &unk_726268;
        objc_copyWeak(&v735, &location);
        GTMTLReplayClient_streamShaderProfilingData((uint64_t)Controller, &v755, v665, v734);
        objc_msgSend(v756, "waitUntilAllOperationsAreFinished");
        objc_destroyWeak(&v735);
        objc_destroyWeak(&location);

        goto LABEL_337;
      }
    }
    else
    {
      if ((v700 & (v94 >> 23)) == 1)
      {
        v152 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(Controller[1], "defaultDevice"));
        v153 = DYMTLReplayFrameProfiler_loadAnalysis(v152);
        v154 = (void *)objc_claimAutoreleasedReturnValue(v153);
        v665 = objc_msgSend(v154, "mutableCopy");

        v158 = GTShaderProfilerStreamDataFromReplayDataSource((uint64_t **)*Controller, v155, v156, v157);
        v107 = (id)objc_claimAutoreleasedReturnValue(v158);
        objc_msgSend(v107, "setMetalPluginName:", v669);
        v159 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a1));
        v160 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v159, "lastPathComponent"));
        objc_msgSend(v107, "setTraceName:", v160);

        objc_msgSend(v107, "setSupportsFileFormatV2:", 1);
        p_isa = 0;
        v791 = (uint64_t)&p_isa;
        v792 = 0x2020000000;
        v793 = 0;
        location = 0;
        p_location = &location;
        v788 = 0x2020000000;
        v789 = 0;
        v782 = 0;
        v783 = &v782;
        v784 = 0x2020000000;
        v785 = 0;
        v161 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v665, "objectForKeyedSubscript:", CFSTR("DerivedCounterDictionary")));
        v162 = v161;
        if (v161)
        {
          verifyCounterDictionary(v161);
          v163 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v162, "objectForKeyedSubscript:", CFSTR("DerivedCounters")));
          v164 = GTMTLReplayHost_rawCounters(v163);
          v165 = (void *)objc_claimAutoreleasedReturnValue(v164);
          objc_msgSend(v665, "setObject:forKeyedSubscript:", v165, CFSTR("profileCounters"));

          if (g_runningInCI)
          {
            v166 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v665, "description"));
            v167 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Derived Counters %@"), v166));

            v168 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v167, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));
            v169 = __stdoutp;
            v170 = objc_retainAutorelease(v168);
            fprintf(v169, "#CI-INFO# %s\n", (const char *)objc_msgSend(v170, "UTF8String"));

          }
          v171 = GTMTLReplayHost_rawCountersToNormalizeSet(v163);
          v702 = (void *)objc_claimAutoreleasedReturnValue(v171);

        }
        else
        {
          v702 = 0;
        }
        v514 = -[GTGPUAPSConfig initForProfiling]([GTGPUAPSConfig alloc], "initForProfiling");
        v698 = -[GTGPUAPSConfig initForCounters]([GTGPUAPSConfig alloc], "initForCounters");
        v516 = (void *)objc_opt_new(NSMutableDictionary, v515);
        objc_msgSend(v516, "setObject:forKeyedSubscript:", v669, CFSTR("MetalPluginName"));
        objc_msgSend(v516, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("CoalesceComputeEncoders"));
        objc_msgSend(v516, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("CoalesceBlitEncoders"));
        v517 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v689));
        objc_msgSend(v516, "setObject:forKeyedSubscript:", v517, CFSTR("gpuTarget"));

        v519 = v702;
        if (!v702)
          v519 = (void *)objc_opt_new(NSSet, v518);
        objc_msgSend(v516, "setObject:forKeyedSubscript:", v519, CFSTR("NormalizedCounters"));
        if (!v702)

        objc_msgSend(v516, "setObject:forKeyedSubscript:", v665, CFSTR("derivedCounterInfo"));
        objc_msgSend(v516, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("UseKicktimestamps"));
        v520 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v514, "toDictionary"));
        objc_msgSend(v516, "setObject:forKeyedSubscript:", v520, CFSTR("ProfilingConfig"));

        v521 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v698, "toDictionary"));
        objc_msgSend(v516, "setObject:forKeyedSubscript:", v521, CFSTR("CounterConfig"));

        objc_msgSend(v516, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("useOverlap"));
        v522 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)*Controller, 1);
        v523 = (void *)objc_claimAutoreleasedReturnValue(v522);
        objc_msgSend(v516, "addEntriesFromDictionary:", v523);
        if (v107)
        {
          if (g_runningInCI)
          {
            v524 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Collecting APS Data...")));
            v525 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v524, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

            v526 = __stdoutp;
            v527 = objc_retainAutorelease(v525);
            fprintf(v526, "#CI-INFO# %s\n", (const char *)objc_msgSend(v527, "UTF8String"));

          }
          *(_QWORD *)&v766 = 0;
          *((_QWORD *)&v766 + 1) = &v766;
          *(_QWORD *)&v767 = 0x2020000000;
          BYTE8(v767) = 0;
          *(_QWORD *)&v762 = 0;
          *((_QWORD *)&v762 + 1) = &v762;
          *(_QWORD *)&v763 = 0x2020000000;
          BYTE8(v763) = 0;
          v528 = dispatch_semaphore_create(0);
          v726[0] = _NSConcreteStackBlock;
          v726[1] = 3221225472;
          v726[2] = __GTMTLReplay_CLI_block_invoke_2_226;
          v726[3] = &unk_726290;
          v529 = v528;
          v727 = v529;
          v729 = &v766;
          v728 = v107;
          v730 = &p_isa;
          v731 = &v762;
          v732 = &location;
          v733 = &v782;
          GTMTLReplayClient_collectAPSData((uint64_t)Controller, &v755, v516, v726);
          if (g_runningInCI)
          {
            v530 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Waiting for APS Data...")));
            v531 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v530, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

            v532 = __stdoutp;
            v533 = objc_retainAutorelease(v531);
            fprintf(v532, "#CI-INFO# %s\n", (const char *)objc_msgSend(v533, "UTF8String"));

          }
          dispatch_semaphore_wait(v529, 0xFFFFFFFFFFFFFFFFLL);
          objc_msgSend(v756, "waitUntilAllOperationsAreFinished");

          _Block_object_dispose(&v762, 8);
          _Block_object_dispose(&v766, 8);
        }

        if ((*(_BYTE *)(a2 + 186) & 4) != 0)
        {
          v534 = BatchIdFiterableCounters();
          v535 = (void *)objc_claimAutoreleasedReturnValue(v534);
          NSLog(CFSTR("Filered: Batch Id Filtered Derived Counters %@"), v535);
          v536 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)*Controller, 1);
          v537 = (void *)objc_claimAutoreleasedReturnValue(v536);
          v538 = objc_msgSend(v537, "mutableCopy");

          v540 = (void *)objc_opt_new(NSMutableSet, v539);
          objc_msgSend(v538, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("NoBlitSampling"));
          objc_msgSend(v538, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("SampleEncoders"));
          objc_msgSend(v538, "setObject:forKeyedSubscript:", &__kCFBooleanFalse, CFSTR("SplitEncoderData"));
          objc_msgSend(v538, "setObject:forKeyedSubscript:", v540, CFSTR("NormalizedCounters"));
          v541 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v538, "objectForKeyedSubscript:", CFSTR("activePerEncoderDrawCallCount")));
          *(_QWORD *)&v762 = 0;
          objc_msgSend(v538, "setObject:forKeyedSubscript:", v665, CFSTR("derivedCounterInfo"));
          v542 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", (*(_DWORD *)(a2 + 184) >> 18) & 1));
          objc_msgSend(v538, "setObject:forKeyedSubscript:", v542, CFSTR("profileBatchIdFilter"));

          objc_msgSend(v538, "setObject:forKeyedSubscript:", v535, CFSTR("profileCounters"));
          objc_msgSend(v538, "setObject:forKeyedSubscript:", v669, CFSTR("MetalPluginName"));
          v543 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v689));
          objc_msgSend(v538, "setObject:forKeyedSubscript:", v543, CFSTR("gpuTarget"));

          v544 = GenerateSimplePriorityList(v541, (unint64_t *)&v762);
          v545 = (void *)objc_claimAutoreleasedReturnValue(v544);
          objc_msgSend(v538, "setObject:forKeyedSubscript:", v545, CFSTR("encoderBatchPriorityList"));

          objc_msgSend(v538, "setObject:forKeyedSubscript:", 0, CFSTR("pause"));
          objc_msgSend(v538, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("resume"));
          objc_msgSend(v538, "setObject:forKeyedSubscript:", v669, CFSTR("MetalPluginName"));
          *(_QWORD *)&v766 = 0;
          *((_QWORD *)&v766 + 1) = &v766;
          v767 = 0x2020000000uLL;
          v725[0] = _NSConcreteStackBlock;
          v725[1] = 3221225472;
          v725[2] = __GTMTLReplay_CLI_block_invoke_3;
          v725[3] = &unk_7262B8;
          v725[4] = &v766;
          v725[5] = v762;
          GTMTLReplayClient_streamBatchFilteredData((uint64_t)Controller, &v755, v538, v725);
          if (g_runningInCI)
          {
            v546 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Waiting for batch ID streaming...")));
            v547 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v546, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

            v548 = __stdoutp;
            v549 = objc_retainAutorelease(v547);
            fprintf(v548, "#CI-INFO# %s\n", (const char *)objc_msgSend(v549, "UTF8String"));

          }
          objc_msgSend(v756, "waitUntilAllOperationsAreFinished");
          v550 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v107, "archivedBatchIdFilteredCounterData"));
          v551 = objc_msgSend(v550, "count");
          v552 = v551 == (id)v762;

          if (g_runningInCI)
            v553 = v552;
          else
            v553 = 1;
          if ((v553 & 1) == 0)
          {
            v554 = v762;
            v555 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v107, "archivedBatchIdFilteredCounterData"));
            v556 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Invalid batch ID fitering counter count, expected max batches: %lu, got: %lu"), v554, objc_msgSend(v555, "count")));

            v557 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v556, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-ERROR# ")));
            v558 = __stdoutp;
            v559 = objc_retainAutorelease(v557);
            fprintf(v558, "#CI-ERROR# %s\n", (const char *)objc_msgSend(v559, "UTF8String"));

          }
          _Block_object_dispose(&v766, 8);

        }
        if (g_runningInCI)
        {
          v560 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Finished")));
          v561 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v560, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

          v562 = __stdoutp;
          v563 = objc_retainAutorelease(v561);
          fprintf(v562, "#CI-INFO# %s\n", (const char *)objc_msgSend(v563, "UTF8String"));

        }
        if (*(_QWORD *)(a2 + 48))
        {
          v564 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:"));
          v565 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v564, "stringByStandardizingPath"));

          LOBYTE(v766) = 0;
          v566 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
          objc_msgSend(v566, "createDirectoryAtPath:withIntermediateDirectories:attributes:error:", v565, 1, 0, 0);

          v567 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
          v568 = objc_msgSend(v567, "fileExistsAtPath:isDirectory:", v565, &v766);

          if ((_BYTE)v766)
            v569 = v568;
          else
            v569 = 0;
          if (v569 == 1)
          {
            v570 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a1));
            v571 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v570, "lastPathComponent"));
            v572 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v571, "stringByDeletingPathExtension"));
            v573 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@.gpuprofiler_raw"), v572));
            v574 = objc_claimAutoreleasedReturnValue(objc_msgSend(v565, "stringByAppendingPathComponent:", v573));

            v565 = (void *)v574;
          }
          v575 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v565, "pathExtension"));
          v576 = objc_msgSend(v575, "isEqualToString:", CFSTR("gpuprofiler_raw"));

          if ((v576 & 1) == 0)
          {
            v577 = objc_claimAutoreleasedReturnValue(objc_msgSend(v565, "stringByAppendingPathExtension:", CFSTR("gpuprofiler_raw")));

            v565 = (void *)v577;
          }
          NSLog(CFSTR("Save Destination %@"), v565);
          v578 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
          v579 = objc_msgSend(v578, "fileExistsAtPath:", v565);

          if (v579)
          {
            v580 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
            objc_msgSend(v580, "removeItemAtPath:error:", v565, 0);

          }
          v581 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:](NSURL, "fileURLWithPath:", v565));
          v582 = objc_msgSend(v107, "encode:error:", v581, 0);

          v583 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
          NSLog(CFSTR("Written %u at Destination %@"), objc_msgSend(v583, "fileExistsAtPath:", v565), v565);

          objc_msgSend(v107, "cleanupLocalFiles");
        }

        _Block_object_dispose(&v782, 8);
        _Block_object_dispose(&location, 8);
        _Block_object_dispose(&p_isa, 8);
        goto LABEL_337;
      }
      if ((v700 & (v94 >> 22)) == 1)
      {
        v283 = (void *)objc_opt_new(NSMutableDictionary, v93);
        objc_msgSend(v283, "setObject:forKeyedSubscript:", v669, CFSTR("MetalPluginName"));
        v284 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v689));
        objc_msgSend(v283, "setObject:forKeyedSubscript:", v284, CFSTR("gpuTarget"));
        v665 = v283;

        objc_msgSend(v283, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("UseMTLCounters"));
        objc_msgSend(v283, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("UseKicktimestamps"));
        objc_msgSend(v283, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("CoalesceComputeEncoders"));
        objc_msgSend(v283, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("CoalesceBlitEncoders"));
        v285 = *(_DWORD *)(a2 + 164);
        if ((v285 & 0x80000000) == 0)
        {
          if (v285 <= 2)
            v286 = 2;
          else
            v286 = v285;
          v287 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v286));
          objc_msgSend(v283, "setObject:forKeyedSubscript:", v287, CFSTR("GPUState"));

        }
        v288 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)*Controller, 1);
        v289 = objc_claimAutoreleasedReturnValue(v288);
        objc_msgSend(v665, "addEntriesFromDictionary:", v289);
        v651 = (id)v289;
        v293 = GTShaderProfilerStreamDataFromReplayDataSource((uint64_t **)*Controller, v290, v291, v292);
        v703 = (void *)objc_claimAutoreleasedReturnValue(v293);
        objc_msgSend(v703, "setMetalPluginName:", v669);
        v294 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a1));
        v295 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v294, "lastPathComponent"));
        objc_msgSend(v703, "setTraceName:", v295);

        p_isa = 0;
        v791 = (uint64_t)&p_isa;
        v792 = 0x2020000000;
        v793 = 0;
        location = 0;
        p_location = &location;
        v788 = 0x2020000000;
        v789 = 0;
        v782 = 0;
        v783 = &v782;
        v784 = 0x2020000000;
        v785 = 0;
        if (v703)
        {
          if (g_runningInCI)
          {
            v296 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Collecting Timeline Data...")));
            v297 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v296, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

            v298 = __stdoutp;
            v299 = objc_retainAutorelease(v297);
            fprintf(v298, "#CI-INFO# %s\n", (const char *)objc_msgSend(v299, "UTF8String"));

          }
          v722[0] = _NSConcreteStackBlock;
          v722[1] = 3221225472;
          v722[2] = __GTMTLReplay_CLI_block_invoke_4;
          v722[3] = &unk_7262E0;
          v300 = v703;
          v723 = v300;
          v724 = &p_isa;
          GTMTLReplayClient_collectGPUShaderTimelineData((uint64_t)Controller, &v755, v665, v722);
          if (g_runningInCI)
          {
            v301 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Waiting for GPU Timeline...")));
            v302 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v301, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

            v303 = __stdoutp;
            v304 = objc_retainAutorelease(v302);
            fprintf(v303, "#CI-INFO# %s\n", (const char *)objc_msgSend(v304, "UTF8String"));

          }
          objc_msgSend(v756, "waitUntilAllOperationsAreFinished");
          if (g_runningInCI)
          {
            v305 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Collecting Shader Profiler Data...")));
            v306 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v305, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

            v307 = __stdoutp;
            v308 = objc_retainAutorelease(v306);
            fprintf(v307, "#CI-INFO# %s\n", (const char *)objc_msgSend(v308, "UTF8String"));

          }
          v719[0] = _NSConcreteStackBlock;
          v719[1] = 3221225472;
          v719[2] = __GTMTLReplay_CLI_block_invoke_5;
          v719[3] = &unk_7262E0;
          v309 = v300;
          v720 = v309;
          v721 = &location;
          GTMTLReplayClient_streamShaderProfilingData((uint64_t)Controller, &v755, v665, v719);
          if (g_runningInCI)
          {
            v310 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Waiting for Shader Profiler...")));
            v311 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v310, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

            v312 = __stdoutp;
            v313 = objc_retainAutorelease(v311);
            fprintf(v312, "#CI-INFO# %s\n", (const char *)objc_msgSend(v313, "UTF8String"));

          }
          objc_msgSend(v756, "waitUntilAllOperationsAreFinished");
          if (g_runningInCI)
          {
            v314 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Colleting Batch ID Filtered Countersr...")));
            v315 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v314, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

            v316 = __stdoutp;
            v317 = objc_retainAutorelease(v315);
            fprintf(v316, "#CI-INFO# %s\n", (const char *)objc_msgSend(v317, "UTF8String"));

          }
          if ((*(_BYTE *)(a2 + 186) & 4) != 0)
          {
            v318 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(Controller[1], "defaultDevice"));
            v319 = DYMTLReplayFrameProfiler_loadAnalysis(v318);
            v320 = (void *)objc_claimAutoreleasedReturnValue(v319);
            v321 = objc_msgSend(v320, "mutableCopy");

            v322 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v321, "objectForKeyedSubscript:", CFSTR("DerivedCounterDictionary")));
            v323 = objc_msgSend(v322, "mutableCopy");

            verifyCounterDictionary(v323);
            v695 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v323, "objectForKeyedSubscript:", CFSTR("DerivedCounters")));
            v324 = BatchIdFiterableCounters();
            v325 = (void *)objc_claimAutoreleasedReturnValue(v324);
            v326 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithArray:](NSMutableSet, "setWithArray:", v325));

            objc_msgSend(v326, "addObject:", CFSTR("GPUTime"));
            v327 = RemoveUnfilterableCounters(v695, v326);
            v328 = (void *)objc_claimAutoreleasedReturnValue(v327);
            objc_msgSend(v323, "setObject:forKeyedSubscript:", v328, CFSTR("DerivedCounters"));
            objc_msgSend(v321, "setObject:forKeyedSubscript:", v323, CFSTR("DerivedCounterDictionary"));
            v329 = GTMTLReplayHost_rawCounters(v328);
            objc = (id)objc_claimAutoreleasedReturnValue(v329);
            v330 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)*Controller, 1);
            v331 = (void *)objc_claimAutoreleasedReturnValue(v330);
            v332 = objc_msgSend(v331, "mutableCopy");

            v333 = GTMTLReplayHost_rawCountersToNormalizeSet(v328);
            v334 = objc_claimAutoreleasedReturnValue(v333);
            objc_msgSend(v332, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("NoBlitSampling"));
            objc_msgSend(v332, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("SampleEncoders"));
            objc_msgSend(v332, "setObject:forKeyedSubscript:", &__kCFBooleanFalse, CFSTR("SplitEncoderData"));
            objc_msgSend(v332, "setObject:forKeyedSubscript:", v334, CFSTR("NormalizedCounters"));
            v672 = (void *)v334;
            v679 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v332, "objectForKeyedSubscript:", CFSTR("activePerEncoderDrawCallCount")));
            *(_QWORD *)&v766 = 0;
            objc_msgSend(v332, "setObject:forKeyedSubscript:", v321, CFSTR("derivedCounterInfo"));
            v335 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", (*(_DWORD *)(a2 + 184) >> 18) & 1));
            objc_msgSend(v332, "setObject:forKeyedSubscript:", v335, CFSTR("profileBatchIdFilter"));

            objc_msgSend(v332, "setObject:forKeyedSubscript:", objc, CFSTR("profileCounters"));
            objc_msgSend(v332, "setObject:forKeyedSubscript:", v669, CFSTR("MetalPluginName"));
            v336 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v689));
            objc_msgSend(v332, "setObject:forKeyedSubscript:", v336, CFSTR("gpuTarget"));

            v337 = GenerateSimplePriorityList(v679, (unint64_t *)&v766);
            v338 = (void *)objc_claimAutoreleasedReturnValue(v337);
            objc_msgSend(v332, "setObject:forKeyedSubscript:", v338, CFSTR("encoderBatchPriorityList"));

            objc_msgSend(v332, "setObject:forKeyedSubscript:", 0, CFSTR("pause"));
            objc_msgSend(v332, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("resume"));
            objc_msgSend(v332, "setObject:forKeyedSubscript:", v669, CFSTR("MetalPluginName"));
            if (g_runningInCI)
            {
              v339 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("\tBatch ID Filterable Counters: %@"), v326));
              v340 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v339, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

              v341 = __stdoutp;
              v342 = objc_retainAutorelease(v340);
              fprintf(v341, "#CI-INFO# %s\n", (const char *)objc_msgSend(v342, "UTF8String"));

            }
            v343 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v326, "allObjects"));
            objc_msgSend(v309, "setBatchIdFilterableCounters:", v343);

            v718[0] = _NSConcreteStackBlock;
            v718[1] = 3221225472;
            v718[2] = __GTMTLReplay_CLI_block_invoke_6;
            v718[3] = &unk_7262B8;
            v718[4] = &v782;
            v718[5] = v766;
            GTMTLReplayClient_streamBatchFilteredData((uint64_t)Controller, &v755, v332, v718);
            if (g_runningInCI)
            {
              v344 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Waiting for batch ID streaming...")));
              v345 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v344, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

              v346 = __stdoutp;
              v347 = objc_retainAutorelease(v345);
              fprintf(v346, "#CI-INFO# %s\n", (const char *)objc_msgSend(v347, "UTF8String"));

            }
            objc_msgSend(v756, "waitUntilAllOperationsAreFinished");
            v348 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v309, "archivedBatchIdFilteredCounterData"));
            v349 = objc_msgSend(v348, "count");
            v350 = v349 == (id)v766;

            if (g_runningInCI)
              v351 = v350;
            else
              v351 = 1;
            if ((v351 & 1) == 0)
            {
              v352 = v766;
              v353 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v309, "archivedBatchIdFilteredCounterData"));
              v354 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Invalid batch ID fitering counter count, expected max batches: %lu, got: %lu"), v352, objc_msgSend(v353, "count")));

              v355 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v354, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-ERROR# ")));
              v356 = __stdoutp;
              v357 = objc_retainAutorelease(v355);
              fprintf(v356, "#CI-ERROR# %s\n", (const char *)objc_msgSend(v357, "UTF8String"));

            }
          }

        }
        if (g_runningInCI)
        {
          v358 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Finished")));
          v359 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v358, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

          v360 = __stdoutp;
          v361 = objc_retainAutorelease(v359);
          fprintf(v360, "#CI-INFO# %s\n", (const char *)objc_msgSend(v361, "UTF8String"));

        }
        if (*(_QWORD *)(a2 + 48))
        {
          v362 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:"));
          LOBYTE(v766) = 0;
          v363 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
          v364 = objc_msgSend(v363, "fileExistsAtPath:isDirectory:", v362, &v766);

          if ((_BYTE)v766)
            v365 = v364;
          else
            v365 = 0;
          if (v365 == 1)
          {
            v366 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", *(_QWORD *)(a2 + 48)));
            v367 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a1));
            v368 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v367, "lastPathComponent"));
            v369 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v368, "stringByDeletingPathExtension"));
            v370 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@.gpuprofiler_raw"), v369));
            v371 = objc_claimAutoreleasedReturnValue(objc_msgSend(v366, "stringByAppendingPathComponent:", v370));

            v362 = (void *)v371;
          }
          v372 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v362, "pathExtension"));
          v373 = objc_msgSend(v372, "isEqualToString:", CFSTR("gpuprofiler_raw"));

          if (v373)
          {
            v374 = objc_claimAutoreleasedReturnValue(objc_msgSend(v362, "stringByAppendingPathExtension:", CFSTR("gpuprofiler_raw")));

            v362 = (void *)v374;
          }
          v717 = v660;
          v375 = (void *)objc_claimAutoreleasedReturnValue(+[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:](NSKeyedArchiver, "archivedDataWithRootObject:requiringSecureCoding:error:", v703, 1, &v717));
          v376 = v717;

          objc_msgSend(v375, "writeToFile:atomically:", v362, 0);
          v660 = v376;
        }
        _Block_object_dispose(&v782, 8);
        _Block_object_dispose(&location, 8);
        _Block_object_dispose(&p_isa, 8);

        goto LABEL_336;
      }
      if ((v94 & 0x100000) != 0)
      {
        if (v700)
        {
          v584 = (void *)objc_opt_new(NSMutableDictionary, v93);
          objc_msgSend(v584, "setObject:forKeyedSubscript:", v669, CFSTR("MetalPluginName"));
          objc_msgSend(v584, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("UseMTLCounters"));
          objc_msgSend(v584, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("UseKicktimestamps"));
          objc_msgSend(v584, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("CoalesceComputeEncoders"));
          objc_msgSend(v584, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("CoalesceBlitEncoders"));
          v665 = v584;
          v585 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)*Controller, 1);
          v107 = (id)objc_claimAutoreleasedReturnValue(v585);
          objc_msgSend(v584, "addEntriesFromDictionary:", v107);
          v791 = 0;
          p_isa = 0;
          v792 = 0;
          p_isa = (void **)objc_claimAutoreleasedReturnValue(objc_msgSend(v670, "path"));
          v791 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a1));
          v792 = 576;
          if (g_runningInCI)
          {
            v586 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Creating Streaming Shader Profiler Helper")));
            v587 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v586, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

            v588 = __stdoutp;
            v589 = objc_retainAutorelease(v587);
            fprintf(v588, "#CI-INFO# %s\n", (const char *)objc_msgSend(v589, "UTF8String"));

          }
          v590 = -[GTShaderProfilerHelper initWithOptions:]([GTShaderProfilerHelper alloc], "initWithOptions:", &p_isa);
          -[GTShaderProfilerHelper processGPUTimelineDataSources:withPayload:forReplayController:](v590, "processGPUTimelineDataSources:withPayload:forReplayController:", *Controller, v665);
          objc_initWeak(&location, v590);
          v715[0] = _NSConcreteStackBlock;
          v715[1] = 3221225472;
          v715[2] = __GTMTLReplay_CLI_block_invoke_7;
          v715[3] = &unk_726268;
          objc_copyWeak(&v716, &location);
          GTMTLReplayClient_collectGPUShaderTimelineData((uint64_t)Controller, &v755, v665, v715);
          objc_msgSend(v756, "waitUntilAllOperationsAreFinished");
          objc_destroyWeak(&v716);
          objc_destroyWeak(&location);

          goto LABEL_337;
        }
      }
      else if ((v94 & 0x200) != 0)
      {
        if (v700)
        {
          v591 = (void *)objc_opt_new(NSMutableDictionary, v93);
          objc_msgSend(v591, "setObject:forKeyedSubscript:", v669, CFSTR("MetalPluginName"));
          objc_msgSend(v591, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("CollectLimiters"));
          v592 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)*Controller, 1);
          v107 = (id)objc_claimAutoreleasedReturnValue(v592);
          objc_msgSend(v591, "addEntriesFromDictionary:", v107);
          v665 = v591;
          v593 = GTMTLReplayClient_embeddedQueryShaderInfo((uint64_t)Controller, &v755, v591);
          v594 = (void *)objc_claimAutoreleasedReturnValue(v593);
          v595 = objc_msgSend(v594, "mutableCopy");

          objc_msgSend(v595, "setObject:forKeyedSubscript:", v591, CFSTR("payload"));
          v596 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v595, "objectForKeyedSubscript:", CFSTR("LimiterCounters")));
          if (v596)
          {
            v597 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v595, "objectForKeyedSubscript:", CFSTR("limiter sample data")));
            v598 = v597 == 0;

            if (v598)
            {
              v714 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v595, "objectForKeyedSubscript:", CFSTR("LimiterCounters")));
              v706 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v714, "objectForKeyedSubscript:", CFSTR("DerivedCounterDictionary")));
              v599 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v706, "objectForKeyedSubscript:", CFSTR("DerivedCounters")));
              v600 = GTMTLReplayHost_rawCountersToNormalizeSet(v599);
              v699 = (void *)objc_claimAutoreleasedReturnValue(v600);

              objc_msgSend(v665, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("NoBlitSampling"));
              objc_msgSend(v665, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("SampleEncoders"));
              objc_msgSend(v665, "setObject:forKeyedSubscript:", &__kCFBooleanFalse, CFSTR("SplitEncoderData"));
              v601 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v706, "objectForKeyedSubscript:", CFSTR("counters")));
              objc_msgSend(v665, "setObject:forKeyedSubscript:", v601, CFSTR("profileCounters"));

              objc_msgSend(v665, "setObject:forKeyedSubscript:", v699, CFSTR("NormalizedCounters"));
              v602 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v595, "objectForKeyedSubscript:", CFSTR("gputime")));
              v603 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v595, "objectForKeyedSubscript:", CFSTR("consistent time")));
              objf = v603;
              if (v603)
              {
                v604 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v603, "objectForKeyedSubscript:", CFSTR("gputime")));
                v605 = v604;
                if (v604)
                {
                  v606 = v604;

                  v602 = v606;
                }

              }
              if (v602)
                v607 = objc_msgSend(v602, "unsignedLongLongValue");
              else
                v607 = 0;
              v624 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v595, "objectForKeyedSubscript:", CFSTR("encoder time data")));
              v625 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v595, "objectForKeyedSubscript:", CFSTR("kick time data")));
              v626 = ProcessEncoderTimeData(v624, v625, v665, (unint64_t)v607);
              v692 = (void *)objc_claimAutoreleasedReturnValue(v626);
              v681 = v625;

              v627 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v692, "objectAtIndexedSubscript:", 1));
              v628 = ProcessDerivedCounterDataFromDevice(v714, v665, v627);
              v629 = (void *)objc_claimAutoreleasedReturnValue(v628);

              v630 = GTMTLReplayHost_collectSoftwareEncoderCounters((uint64_t)*Controller, 1);
              v631 = (void *)objc_claimAutoreleasedReturnValue(v630);
              v632 = ComputeDerivedCounters(v714, v629, v631);
              v633 = (void *)objc_claimAutoreleasedReturnValue(v632);
              if (v633)
              {
                objc_msgSend(v595, "setObject:forKeyedSubscript:", v633, CFSTR("LimiterCounterData"));
                v634 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v633, "objectForKeyedSubscript:", CFSTR("derivedCounterDataForBottleneckAnalysis")));
                v674 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v634, "objectForKeyedSubscript:", CFSTR("counters")));

                v772[0] = CFSTR("PerCounterEncoderCallData");
                v635 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v633, "objectForKeyedSubscript:", CFSTR("derivedCounterDataForBottleneckAnalysis")));
                v636 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v635, "objectForKeyedSubscript:", CFSTR("AverageSamples")));
                PerCounterCommandData = GTMTLReplayHost_createPerCounterCommandData(v674, v636);
                v638 = (void *)objc_claimAutoreleasedReturnValue(PerCounterCommandData);
                v772[1] = CFSTR("MetalPluginName");
                v773[0] = v638;
                v773[1] = v669;
                v639 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v773, v772, 2));

                v640 = (void *)objc_claimAutoreleasedReturnValue(+[NSJSONSerialization dataWithJSONObject:options:error:](NSJSONSerialization, "dataWithJSONObject:options:error:", v639, 1, 0));
                v641 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v663, "stringByAppendingPathExtension:", CFSTR("json")));
                v642 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:relativeToURL:](NSURL, "fileURLWithPath:isDirectory:relativeToURL:", v641, 0, v670));
                objc_msgSend(v640, "writeToURL:atomically:", v642, 0);

              }
            }
          }
          p_isa = (void **)objc_claimAutoreleasedReturnValue(objc_msgSend(v670, "path"));
          v791 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a1));
          v792 = 76;
          v643 = -[GTShaderProfilerHelper initWithOptions:]([GTShaderProfilerHelper alloc], "initWithOptions:", &p_isa);
          -[GTShaderProfilerHelper analyzeShaderInfoResult:forDataSource:forReplayController:](v643, "analyzeShaderInfoResult:forDataSource:forReplayController:", v595, *Controller);

          goto LABEL_337;
        }
      }
      else if ((v94 & 0x80) == 0)
      {
        if ((v94 & 0x4000) != 0)
        {
          if (!strcmp(*(const char **)(a2 + 128), "all"))
          {
            v609 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(Controller[1], "defaultCommandQueue"));
            v665 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v609, "availableCounters"));
            v612 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v663, "stringByAppendingString:", CFSTR("_allCountersInfo.plist")));
            v613 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:relativeToURL:](NSURL, "fileURLWithPath:isDirectory:relativeToURL:", v612, 0, v670));
            objc_msgSend(v665, "writeToURL:error:", v613, 0);

          }
          else
          {
            v608 = objc_alloc((Class)NSArray);
            v609 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", *(_QWORD *)(a2 + 128)));
            v665 = objc_msgSend(v608, "initWithContentsOfFile:", v609);
          }

          v770 = CFSTR("profileCounters");
          v771 = v665;
          v107 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v771, &v770, 1));
          v614 = GTMTLReplayClient_derivedCounterData((id *)Controller, &v755, v107);
          v615 = (void *)objc_claimAutoreleasedReturnValue(v614);
          v616 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v663, "stringByAppendingPathExtension:", CFSTR(".csv")));
          v617 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:relativeToURL:](NSURL, "fileURLWithPath:isDirectory:relativeToURL:", v616, 0, v670));
          WriteToCSVFromCounterData(v615, v617);

          v618 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v663, "stringByAppendingPathExtension:", CFSTR(".plist")));
          v619 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:relativeToURL:](NSURL, "fileURLWithPath:isDirectory:relativeToURL:", v618, 0, v670));
          WriteToPlistFromCounterData(v615, v619);

          goto LABEL_337;
        }
        if ((v94 & 0x8000) != 0)
        {
          v610 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)*Controller, v700);
          v668 = (void *)objc_claimAutoreleasedReturnValue(v610);
          v611 = GTMTLReplayClient_queryShaderInfo((uint64_t)Controller, &v755, v668);

          goto LABEL_338;
        }
        if ((v94 & 0x80000) != 0)
        {
          v620 = GTMTLReplayClient_collectPipelinePerformanceStatistics((uint64_t)Controller, v93);
          v665 = (id)objc_claimAutoreleasedReturnValue(v620);
          v621 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v665, "description"));
          v107 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v621, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\\n"), CFSTR("\n")));

          v622 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v663, "stringByAppendingPathExtension:", CFSTR("txt")));
          v623 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:relativeToURL:](NSURL, "fileURLWithPath:isDirectory:relativeToURL:", v622, 0, v670));
          objc_msgSend(v107, "writeToURL:atomically:encoding:error:", v623, 0, 4, 0);

          goto LABEL_337;
        }
        if ((v94 & 0x10000) == 0)
        {
          v505 = *(unsigned int *)(a2 + 24);
          if ((int)v505 < 1)
            goto LABEL_338;
          v506 = 0;
          do
          {
            if (g_runningInCI)
            {
              v507 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("replayCapture, loop count=%d/%d"), v506, v505));
              v508 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v507, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

              v509 = __stdoutp;
              v510 = objc_retainAutorelease(v508);
              fprintf(v509, "#CI-INFO# %s\n", (const char *)objc_msgSend(v510, "UTF8String"));

            }
            v511 = objc_alloc_init((Class)MTLCaptureDescriptor);
            v512 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(Controller[1], "defaultDevice"));
            objc_msgSend(v511, "setCaptureObject:", v512);

            GTMTLReplayController_debugSubCommandStop((uint64_t)Controller, *(_DWORD *)((*Controller)[15] + 12), 0);
            if (*(_BYTE *)(a2 + 37))
            {
              v513 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(Controller[1], "defaultCommandQueue"));
              objc_msgSend(v513, "finish");

            }
            GTMTLReplayController_rewind((uint64_t)Controller);

            v660 = 0;
            v25 = 0;
            v506 = (v506 + 1);
            v505 = *(unsigned int *)(a2 + 24);
          }
          while ((int)v506 < (int)v505);
        }
      }
    }
    goto LABEL_339;
  }
  if (g_runningInCI)
  {
    v172 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("collectDerivedCounters")));
    v173 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v172, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

    v174 = __stdoutp;
    v175 = objc_retainAutorelease(v173);
    fprintf(v174, "#CI-INFO# %s\n", (const char *)objc_msgSend(v175, "UTF8String"));

  }
  v176 = *Controller;
  v665 = objc_alloc_init((Class)NSMutableArray);
  v177 = v176[14];
  v178 = *(_DWORD *)(v177 + 12);
  if (v178 < 1)
  {
    v182 = &stru_7282A8;
    v183 = &stru_7282A8;
    v657 = &stru_7282A8;
    goto LABEL_227;
  }
  v179 = 0;
  obja = 0;
  v180 = v176[2];
  v181 = v176[15];
  v182 = &stru_7282A8;
  v183 = &stru_7282A8;
  v657 = &stru_7282A8;
  v658 = v177;
  do
  {
    v184 = *(_QWORD *)(v177 + 24);
    v185 = *(_QWORD *)(v184 + 32 * v179);
    if (GetFuncEnumConstructorType(*(_DWORD *)(*(_QWORD *)(v181 + 24) + (v185 << 6) + 8)) != 25)
      goto LABEL_214;
    v694 = v184 + 32 * v179;
    v186 = *(_QWORD *)(v694 + 8);
    if (v186 <= (int)v185 + 1)
      goto LABEL_213;
    v678 = v179;
    v187 = (int)v185 + 1;
    v188 = (v185 + 1);
    do
    {
      v189 = *(_QWORD *)(v181 + 24);
      v190 = v189 + (v187 << 6);
      v191 = *(_DWORD *)(v190 + 8);
      if (v191 <= -15926)
      {
        if (v191 <= -16293)
        {
          if ((v191 + 0x4000) <= 0x2D && ((1 << v191) & 0x200800081001) != 0)
            goto LABEL_164;
          goto LABEL_127;
        }
        if (v191 > -16124)
        {
          v195 = (v191 + 16123) > 0x3C
              || ((1 << (v191 - 5)) & 0x1000000000000011) == 0;
          v196 = -15974;
        }
        else
        {
          v195 = (v191 + 16292) > 0x34
              || ((1 << (v191 - 92)) & 0x10000000000811) == 0;
          v196 = -16136;
        }
        if (v195 && v191 != v196)
          goto LABEL_127;
LABEL_164:
        if (v191 > -16289)
        {
          if (v191 != -16288 && v191 != -16281 && v191 != -15890)
            goto LABEL_191;
        }
        else if (v191 != -16384)
        {
          if (v191 == -16365)
          {
            v222 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v190, *(unsigned __int8 *)(v189 + (v187 << 6) + 13), v180);
            v223 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v190, v222[8], v180);
            if (v223)
            {
              v224 = (const __CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v223));
              v221 = v182;
            }
            else
            {
              v221 = v182;
              v224 = &stru_7282A8;
            }
            goto LABEL_193;
          }
          if (v191 != -16339)
            goto LABEL_191;
        }
        v219 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v190, *(unsigned __int8 *)(v189 + (v187 << 6) + 13), v180);
        v220 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v190, v219[8], v180);
        if (v220)
        {
          v221 = v183;
          v183 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v220));
LABEL_192:
          v224 = v182;
LABEL_193:

          v186 = *(_QWORD *)(v694 + 8);
          v182 = (__CFString *)v224;
          goto LABEL_194;
        }
LABEL_191:
        v221 = v183;
        v183 = &stru_7282A8;
        goto LABEL_192;
      }
      if (v191 > -15608)
      {
        if (v191 <= -15314)
        {
          v193 = v191 == -15607 || v191 == -15570;
          v194 = -15491;
LABEL_117:
          if (v193 || v191 == v194)
            goto LABEL_164;
          goto LABEL_127;
        }
        v225 = (v191 + 15313) > 0x17;
        v226 = 1 << (v191 - 47);
        v227 = 8388673;
      }
      else
      {
        if (v191 <= -15677)
        {
          v193 = (v191 + 15925) <= 0x2D && ((1 << (v191 + 53)) & 0x200800000001) != 0
              || v191 == -15794;
          v194 = -15743;
          goto LABEL_117;
        }
        v225 = (v191 + 15676) > 0x1C;
        v226 = 1 << (v191 + 60);
        v227 = 268468481;
      }
      v228 = v226 & v227;
      if (!v225 && v228 != 0)
        goto LABEL_164;
LABEL_127:
      if (IsFuncEnumSampledCall(*(_DWORD *)(v190 + 8), v700))
      {
        InclusiveRange = GroupBuilder_findInclusiveRange(*(_DWORD *)(v658 + 12), *(_QWORD **)(v658 + 24), v187);
        if (obja == InclusiveRange)
        {
          InclusiveRange = obja;
        }
        else
        {
          objb = objc_alloc_init((Class)NSMutableArray);
          if (InclusiveRange)
          {
            v199 = InclusiveRange;
            do
            {
              v200 = *(_QWORD *)(v181 + 24);
              v201 = *v199;
              v202 = *(_DWORD *)(v200 + (*v199 << 6) + 8);
              if (IsFuncEnumPushDebugGroup(v202))
              {
                if (v202 <= -16245)
                {
                  v203 = v202 == -16374 || v202 == -16323;
                  v204 = -16283;
                }
                else if (v202 > -15883)
                {
                  v203 = v202 == -15786;
                  v204 = -15882;
                }
                else
                {
                  v203 = v202 == -16244;
                  v204 = -16065;
                }
                if (v203 || v202 == v204)
                {
                  v206 = GTTraceFunc_argumentBytesWithMap((_QWORD *)(v200 + (v201 << 6)), *(unsigned __int8 *)(v200 + (v201 << 6) + 13), v180);
                  v207 = GTTraceFunc_argumentBytesWithMap((_QWORD *)(v200 + (v201 << 6)), v206[8], v180);
                  if (v207)
                  {
                    v208 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v207));
                    objc_msgSend(objb, "addObject:", v208);

                  }
                }
              }
              v209 = *((unsigned int *)v199 + 4);
              if ((_DWORD)v209)
                v199 -= 4 * v209;
              else
                v199 = 0;
            }
            while ((_DWORD)v209);
          }
          v210 = objb;
          v211 = (unint64_t)objc_msgSend(v210, "count");
          if (v211 >= 2)
          {
            v212 = 0;
            v213 = v211 >> 1;
            v214 = v211 - 1;
            do
              objc_msgSend(v210, "exchangeObjectAtIndex:withObjectAtIndex:", v212++, v214--);
            while (v213 != v212);
          }

          v215 = objc_claimAutoreleasedReturnValue(objc_msgSend(v210, "componentsJoinedByString:", CFSTR("->")));
          v657 = (__CFString *)v215;
        }
        v221 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v188));
        p_isa = &v221->isa;
        v791 = (uint64_t)v182;
        v792 = (uint64_t)v183;
        v793 = v657;
        v232 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &p_isa, 4));
        objc_msgSend(v665, "addObject:", v232);

        obja = InclusiveRange;
        goto LABEL_192;
      }
      if ((IsFuncEnumEndEncoding(v191) & 1) != 0)
        goto LABEL_191;
      if (v191 > -15344)
      {
        v233 = (v191 + 15343) > 0x1B || ((1 << (v191 - 17)) & 0xA000001) == 0;
        v221 = v182;
        v224 = &stru_7282A8;
        if (!v233)
          goto LABEL_193;
      }
      else
      {
        v231 = v191 == -16361 || v191 == -16202 || v191 == -15908;
        v221 = v182;
        v224 = &stru_7282A8;
        if (v231)
          goto LABEL_193;
      }
LABEL_194:
      v188 = (v188 + 1);
      v187 = (int)v188;
    }
    while (v186 > (int)v188);
    v177 = v658;
    v178 = *(_DWORD *)(v658 + 12);
    v179 = v678;
LABEL_213:
    v179 += *(_DWORD *)(v694 + 20);
LABEL_214:
    ++v179;
  }
  while (v179 < v178);
LABEL_227:

  if ((v700 & 1) != 0)
  {
    v253 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(Controller[1], "defaultDevice"));
    v254 = DYMTLReplayFrameProfiler_loadAnalysis(v253);
    v255 = (void *)objc_claimAutoreleasedReturnValue(v254);
    v651 = objc_msgSend(v255, "mutableCopy");

    v256 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v651, "objectForKeyedSubscript:", CFSTR("DerivedCounterDictionary")));
    verifyCounterDictionary(v256);
    v649 = v256;
    v650 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v256, "objectForKeyedSubscript:", CFSTR("DerivedCounters")));
    v257 = GTMTLReplayHost_rawCounters(v650);
    v258 = (void *)objc_claimAutoreleasedReturnValue(v257);
    objc_msgSend(v651, "setObject:forKeyedSubscript:", v258, CFSTR("profileCounters"));

    v259 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)*Controller, 1);
    v260 = (void *)objc_claimAutoreleasedReturnValue(v259);
    v261 = objc_msgSend(v260, "mutableCopy");

    v262 = GTMTLReplayHost_rawCountersToNormalizeSet(v650);
    v648 = (void *)objc_claimAutoreleasedReturnValue(v262);
    objc_msgSend(v261, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("NoBlitSampling"));
    objc_msgSend(v261, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("SampleEncoders"));
    objc_msgSend(v261, "setObject:forKeyedSubscript:", &__kCFBooleanFalse, CFSTR("SplitEncoderData"));
    objc_msgSend(v261, "setObject:forKeyedSubscript:", v648, CFSTR("NormalizedCounters"));
    objc_msgSend(v261, "setObject:forKeyedSubscript:", v651, CFSTR("derivedCounterInfo"));
    objc_msgSend(v261, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("UseMTLCounters"));
    objc_msgSend(v261, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("UseKicktimestamps"));
    v263 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v689));
    objc_msgSend(v261, "setObject:forKeyedSubscript:", v263, CFSTR("gpuTarget"));

    if ((v689 & 0x80000000) != 0)
      GTMTLReplayClient_embeddedDerivedCounterData((uint64_t)Controller, (uint64_t)&v755, v651);
    v264 = v261;
    objc_msgSend(v264, "setObject:forKeyedSubscript:", v669, CFSTR("MetalPluginName"));
    v791 = 0;
    p_isa = 0;
    v792 = 0;
    p_isa = (void **)objc_claimAutoreleasedReturnValue(objc_msgSend(v670, "path"));
    v791 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a1));
    v792 = 321;
    if (g_runningInCI)
    {
      v265 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Creating Streaming Derived Counters Helper")));
      v266 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v265, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

      v267 = __stdoutp;
      v268 = objc_retainAutorelease(v266);
      fprintf(v267, "#CI-INFO# %s\n", (const char *)objc_msgSend(v268, "UTF8String"));

    }
    v269 = -[GTShaderProfilerHelper initWithOptions:]([GTShaderProfilerHelper alloc], "initWithOptions:", &p_isa);
    -[GTShaderProfilerHelper profileShadersForDataSource:withPayload:forReplayController:](v269, "profileShadersForDataSource:withPayload:forReplayController:", *Controller, v264);
    objc_initWeak(&location, v269);
    v736[0] = _NSConcreteStackBlock;
    v736[1] = 3221225472;
    v736[2] = __GTMTLReplay_CLI_block_invoke_196;
    v736[3] = &unk_726268;
    objc_copyWeak(&v737, &location);
    GTMTLReplayClient_streamDerivedCounterData((uint64_t)Controller, &v755, v264, v736);
    objc_msgSend(v756, "waitUntilAllOperationsAreFinished");
    objc_destroyWeak(&v737);
    objc_destroyWeak(&location);

    v270 = v264;
  }
  else
  {
    v780[0] = CFSTR("MetalPluginName");
    v780[1] = CFSTR("GPUState");
    v781[0] = v669;
    v781[1] = &off_739BF8;
    v271 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v781, v780, 2));
    v272 = GTMTLReplayClient_queryShaderInfo((uint64_t)Controller, &v755, v271);
    v651 = (id)objc_claimAutoreleasedReturnValue(v272);

    v273 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v651, "objectForKeyedSubscript:", CFSTR("derivedCounterData")));
    v274 = objc_msgSend(v273, "mutableCopy");

    if (*(_QWORD *)(a2 + 56))
    {
      v275 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:"));
      v276 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", *(_QWORD *)(a2 + 56)));
      DerivedCounterInfo = GTMTLReplayClient_loadDerivedCounterInfo(v275, v276);
      v278 = (void *)objc_claimAutoreleasedReturnValue(DerivedCounterInfo);

      v279 = GTMTLReplayClient_mergeDerivedCounterInfo(v274, v278);
      v280 = (void *)objc_claimAutoreleasedReturnValue(v279);
      v281 = objc_msgSend(v280, "mutableCopy");

      v282 = v281;
    }
    else
    {
      v282 = v274;
    }
    v649 = v282;
    v384 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v282, "objectForKeyedSubscript:", CFSTR("DerivedCounterDictionary")));
    v385 = objc_msgSend(v384, "mutableCopy");

    verifyCounterDictionary(v385);
    v650 = v385;
    v386 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v650, "objectForKeyedSubscript:", CFSTR("DerivedCounters")));
    v270 = objc_msgSend(v386, "mutableCopy");

    v387 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v650, "objectForKeyedSubscript:", CFSTR("Instruments")));
    v388 = v387;
    if (v387)
    {
      v389 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v387, "objectForKeyedSubscript:", CFSTR("Profiles")));
      v390 = v389;
      v711 = v388;
      if (v389)
      {
        v391 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v389, "allKeys"));
        v392 = v391;
        if (v391)
        {
          v768 = 0u;
          v769 = 0u;
          v766 = 0u;
          v767 = 0u;
          v393 = objc_msgSend(v391, "countByEnumeratingWithState:objects:count:", &v766, &p_isa, 16);
          if (v393)
          {
            v704 = *(_QWORD *)v767;
            v708 = v390;
            objd = v392;
            do
            {
              v394 = 0;
              v690 = v393;
              do
              {
                if (*(_QWORD *)v767 != v704)
                  objc_enumerationMutation(objd);
                v395 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v708, "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v766 + 1) + 8 * (_QWORD)v394)));
                v396 = v395;
                if (v395)
                {
                  v397 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v395, "objectForKeyedSubscript:", CFSTR("DerivedCounters")));
                  v764 = 0u;
                  v765 = 0u;
                  v762 = 0u;
                  v763 = 0u;
                  v398 = objc_msgSend(v397, "countByEnumeratingWithState:objects:count:", &v762, &location, 16);
                  v696 = v396;
                  if (v398)
                  {
                    v399 = *(_QWORD *)v763;
                    do
                    {
                      for (i = 0; i != v398; i = (char *)i + 1)
                      {
                        if (*(_QWORD *)v763 != v399)
                          objc_enumerationMutation(v397);
                        v401 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v762 + 1)
                                                                                            + 8 * (_QWORD)i), "allValues"));
                        v761 = 0u;
                        v760 = 0u;
                        v759 = 0u;
                        v758 = 0u;
                        v402 = objc_msgSend(v401, "countByEnumeratingWithState:objects:count:", &v758, &v782, 16);
                        if (v402)
                        {
                          v403 = *(_QWORD *)v759;
                          do
                          {
                            for (j = 0; j != v402; j = (char *)j + 1)
                            {
                              if (*(_QWORD *)v759 != v403)
                                objc_enumerationMutation(v401);
                              objc_msgSend(v270, "removeObjectForKey:", *(_QWORD *)(*((_QWORD *)&v758 + 1) + 8 * (_QWORD)j));
                            }
                            v402 = objc_msgSend(v401, "countByEnumeratingWithState:objects:count:", &v758, &v782, 16);
                          }
                          while (v402);
                        }

                      }
                      v398 = objc_msgSend(v397, "countByEnumeratingWithState:objects:count:", &v762, &location, 16);
                    }
                    while (v398);
                  }

                  v396 = v696;
                }

                v394 = (char *)v394 + 1;
              }
              while (v394 != v690);
              v392 = objd;
              v393 = objc_msgSend(objd, "countByEnumeratingWithState:objects:count:", &v766, &p_isa, 16);
              v390 = v708;
            }
            while (v393);
          }
        }

      }
      v388 = v711;
    }

    objc_msgSend(v650, "setObject:forKeyedSubscript:", v270, CFSTR("DerivedCounters"));
    verifyCounterDictionary(v650);
    objc_msgSend(v649, "setObject:forKeyedSubscript:", v650, CFSTR("DerivedCounterDictionary"));
    v405 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v663, "stringByAppendingString:", CFSTR("_derivedCounterInfoResult.plist")));
    v406 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:relativeToURL:](NSURL, "fileURLWithPath:isDirectory:relativeToURL:", v405, 0, v670));
    objc_msgSend(v649, "writeToURL:atomically:", v406, 0);

    v407 = GTMTLReplayHost_rawCounters(v270);
    v648 = (void *)objc_claimAutoreleasedReturnValue(v407);
    if (!objc_msgSend(v648, "count"))
    {
      v408 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("No raw counters remain from derived counter list: %@"), v270));
      v409 = __stdoutp;
      v410 = g_runningInCI;
      v411 = objc_retainAutorelease(v408);
      v412 = (const char *)objc_msgSend(v411, "UTF8String");
      v413 = "#CI_ERROR# ";
      if (!v410)
        v413 = "";
      fprintf(v409, "%s%s %u: %s\n", v413, "int GTMTLReplay_CLI(const char *, GTMTLReplayCLIOptions, void (*)(NSData *__strong, NSURL *__strong))", 928, v412);
      v414 = objc_retainAutorelease(v411);
      GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v414, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m", (uint64_t)"GTMTLReplay_CLI", 928, 1);

    }
    v415 = GTMTLReplayHost_rawCountersToNormalizeSet(v270);
    v416 = objc_claimAutoreleasedReturnValue(v415);
    v778[0] = CFSTR("NoBlitSampling");
    v778[1] = CFSTR("SampleEncoders");
    v779[0] = &__kCFBooleanTrue;
    v779[1] = &__kCFBooleanTrue;
    v778[2] = CFSTR("SplitEncoderData");
    v778[3] = CFSTR("profileCounters");
    v779[2] = &__kCFBooleanFalse;
    v779[3] = v648;
    v778[4] = CFSTR("NormalizedCounters");
    v645 = (void *)v416;
    v779[4] = v416;
    v644 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v779, v778, 5));
    v417 = GTMTLReplayClient_derivedCounterData((id *)Controller, &v755, v644);
    v418 = (void *)objc_claimAutoreleasedReturnValue(v417);
    v647 = objc_msgSend(v418, "mutableCopy");

    v776 = CFSTR("frameProfile");
    v419 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v651, "objectForKeyedSubscript:"));
    v777 = v419;
    v420 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v777, &v776, 1));
    objc_msgSend(v647, "setObject:forKeyedSubscript:", v420, CFSTR("Timing Data"));

    v421 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v647, "objectForKeyedSubscript:", CFSTR("EncoderData")));
    if (!v421)
    {
      v422 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("encoderData is nil")));
      v423 = __stdoutp;
      v424 = g_runningInCI;
      v425 = objc_retainAutorelease(v422);
      v426 = (const char *)objc_msgSend(v425, "UTF8String");
      v427 = "#CI_ERROR# ";
      if (!v424)
        v427 = "";
      fprintf(v423, "%s%s %u: %s\n", v427, "int GTMTLReplay_CLI(const char *, GTMTLReplayCLIOptions, void (*)(NSData *__strong, NSURL *__strong))", 947, v426);
      v428 = objc_retainAutorelease(v425);
      GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v428, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m", (uint64_t)"GTMTLReplay_CLI", 947, 1);

    }
    v429 = GTMTLReplayHost_collectSoftwareEncoderCounters((uint64_t)*Controller, 0);
    v430 = (void *)objc_claimAutoreleasedReturnValue(v429);
    v431 = ComputeDerivedCounters(v649, v421, v430);
    v432 = (void *)objc_claimAutoreleasedReturnValue(v431);
    v433 = objc_msgSend(v432, "mutableCopy");

    objc_msgSend(v433, "setObject:forKeyedSubscript:", v665, CFSTR("TraceInformation"));
    v646 = objc_msgSend(v433, "copy");
    v434 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v663, "stringByAppendingString:", CFSTR("_encoder_derivedComputedData.plist")));
    v435 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:relativeToURL:](NSURL, "fileURLWithPath:isDirectory:relativeToURL:", v434, 0, v670));
    objc_msgSend(v646, "writeToURL:atomically:", v435, 0);

    v436 = *Controller;
    v705 = objc_alloc_init((Class)NSMutableArray);
    v659 = v436;
    v654 = v436[14];
    v437 = *(_DWORD *)(v654 + 12);
    if (v437 >= 1)
    {
      v438 = 0;
      v673 = v436[2];
      obje = (_QWORD *)v436[15];
      do
      {
        v656 = v438;
        v652 = v438;
        v653 = *(_QWORD *)(v654 + 24);
        v439 = (_QWORD *)(v653 + 32 * v438);
        v440 = obje[3] + (*v439 << 6);
        if (GTMTLReplayHost_IsFuncEnumSampledEncoder(*(_DWORD *)(v440 + 8), 0, 0))
        {
          RenderPassDescriptor = GetRenderPassDescriptor((uint64_t *)v440, v673);
          v709 = RenderPassDescriptorContainsClear(RenderPassDescriptor);
          v680 = v439 + 1;
          v442 = *(_DWORD *)v439 + 1;
          if (v439[1] > (unint64_t)v442)
          {
            v443 = v442;
            v691 = *(_DWORD *)v439 + 1;
            do
            {
              v444 = obje[3] + (v443 << 6);
              v445 = *(_DWORD *)(v444 + 8);
              if (IsFuncEnumSampledCall(v445, 0))
              {
                v446 = SoftwareCounterForFunc(v444, v673);
                v448 = v447;
                v449 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v709));
                location = v449;
                v450 = (id *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v446));
                p_location = v450;
                v451 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v448));
                v788 = (uint64_t)v451;
                v452 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &location, 3));
                objc_msgSend(v705, "addObject:", v452);

              }
              else if (v445 >> 2 == 1073737833)
              {
                GetExecuteCommandsInBufferArgs((uint64_t)&p_isa, v444, v659[2]);
                v796 = 0u;
                memset(v795, 0, sizeof(v795));
                Object = GTMTLSMContext_getObject(*(_QWORD *)v659[5], (uint64_t)p_isa, *(_QWORD *)v444);
                GTMTLCreateIndirectCommandEncoder((uint64_t)v795, Object[13]);
                v454 = v792;
                if (v792)
                {
                  v455 = 0;
                  v712 = v793;
                  v456 = *((_QWORD *)&v796 + 1);
                  v457 = v795[1];
                  v697 = v796;
                  v458 = v791 << 32;
                  do
                  {
                    v459 = (uint64_t)v712 + v456 * (v458 >> 32);
                    if (*(_QWORD *)(v459 + v457))
                    {
                      v460 = SoftwareCounterForIndirectCommand(v457, v697, v459);
                      v462 = v461;
                      v463 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v709));
                      v782 = v463;
                      v464 = (void **)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v460));
                      v783 = v464;
                      v465 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v462));
                      v784 = (uint64_t)v465;
                      v466 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v782, 3));
                      objc_msgSend(v705, "addObject:", v466);

                    }
                    ++v455;
                    v458 += 0x100000000;
                  }
                  while (v454 > v455);
                }
              }
              v443 = ++v691;
            }
            while (*v680 > (unint64_t)v691);
          }
          v467 = *(_DWORD *)(v653 + 32 * v652 + 20) + v656;
          v437 = *(_DWORD *)(v654 + 12);
        }
        else
        {
          v467 = v656;
        }
        v438 = v467 + 1;
      }
      while (v438 < v437);
    }
    v468 = objc_msgSend(v705, "copy");

    v469 = ComputeDerivedCounters(v649, v647, v468);
    v470 = (void *)objc_claimAutoreleasedReturnValue(v469);
    v471 = objc_msgSend(v470, "mutableCopy");

    objc_msgSend(v471, "setObject:forKeyedSubscript:", v665, CFSTR("TraceInformation"));
    v713 = objc_msgSend(v471, "copy");
    v472 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v663, "stringByAppendingString:", CFSTR("_derivedComputedData.plist")));
    v473 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:relativeToURL:](NSURL, "fileURLWithPath:isDirectory:relativeToURL:", v472, 0, v670));
    objc_msgSend(v713, "writeToURL:atomically:", v473, 0);

    v474 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v663, "stringByAppendingString:", CFSTR("_derivedCounterDataFromDeviceResult.plist")));
    v475 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:relativeToURL:](NSURL, "fileURLWithPath:isDirectory:relativeToURL:", v474, 0, v670));
    objc_msgSend(v647, "writeToURL:atomically:", v475, 0);

    v476 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v713, "objectForKeyedSubscript:", CFSTR("derivedCounterDataForBottleneckAnalysis")));
    v477 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v476, "objectForKeyedSubscript:", CFSTR("counters")));

    v774[0] = CFSTR("PerCounterDrawCallData");
    v478 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v713, "objectForKeyedSubscript:", CFSTR("derivedCounterDataForBottleneckAnalysis")));
    v479 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v478, "objectForKeyedSubscript:", CFSTR("AverageSamples")));
    v480 = GTMTLReplayHost_createPerCounterCommandData(v477, v479);
    v481 = (void *)objc_claimAutoreleasedReturnValue(v480);
    v775[0] = v481;
    v774[1] = CFSTR("PerCounterEncoderCallData");
    v482 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v646, "objectForKeyedSubscript:", CFSTR("derivedCounterDataForBottleneckAnalysis")));
    v483 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v482, "objectForKeyedSubscript:", CFSTR("AverageSamples")));
    v484 = GTMTLReplayHost_createPerCounterCommandData(v477, v483);
    v485 = (void *)objc_claimAutoreleasedReturnValue(v484);
    v775[1] = v485;
    v774[2] = CFSTR("MetalPluginName");
    v486 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v649, "objectForKeyedSubscript:"));
    v775[2] = v486;
    v487 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v775, v774, 3));

    v488 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v713, "objectForKeyedSubscript:", CFSTR("derivedCounterDataForBottleneckAnalysis")));
    v489 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v488, "objectForKeyedSubscript:", CFSTR("AverageSamples")));
    verifyPerCounterCommandData(v487, CFSTR("PerCounterDrawCallData"), v477, objc_msgSend(v489, "count"));

    v490 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v646, "objectForKeyedSubscript:", CFSTR("derivedCounterDataForBottleneckAnalysis")));
    v491 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v490, "objectForKeyedSubscript:", CFSTR("AverageSamples")));
    verifyPerCounterCommandData(v487, CFSTR("PerCounterEncoderCallData"), v477, objc_msgSend(v491, "count"));

    v492 = (void *)objc_claimAutoreleasedReturnValue(+[NSJSONSerialization dataWithJSONObject:options:error:](NSJSONSerialization, "dataWithJSONObject:options:error:", v487, 1, 0));
    v493 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v663, "stringByAppendingPathExtension:", CFSTR("json")));
    v494 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:relativeToURL:](NSURL, "fileURLWithPath:isDirectory:relativeToURL:", v493, 0, v670));
    objc_msgSend(v492, "writeToURL:atomically:", v494, 0);

    v264 = v645;
  }

LABEL_336:
  v107 = v651;
LABEL_337:

LABEL_338:
  v25 = v660;
LABEL_339:
  if (g_runningInCI)
  {
    v495 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("commandQueue finish")));
    v496 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v495, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

    v497 = __stdoutp;
    v498 = objc_retainAutorelease(v496);
    fprintf(v497, "#CI-INFO# %s\n", (const char *)objc_msgSend(v498, "UTF8String"));

  }
  v499 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(Controller[1], "defaultCommandQueue"));
  objc_msgSend(v499, "finish");
  objc_msgSend(v756, "waitUntilAllOperationsAreFinished");
  if (g_runningInCI)
  {
    v500 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("normal exit")));
    v501 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v500, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

    v502 = __stdoutp;
    v503 = objc_retainAutorelease(v501);
    fprintf(v502, "#CI-INFO# %s\n", (const char *)objc_msgSend(v503, "UTF8String"));

  }
  __destructor_8_s0_s8_s24_s32_s40_s56_s64_s72_s80_s88_s96_s104_s112_s120_s128_s136_s144_s152(v745);

  v26 = 0;
LABEL_344:

  return v26;
}

void sub_2BEE4C(_Unwind_Exception *a1)
{
  __destructor_8_s0_s8_s24_s32_s40_s56_s64_s72_s80_s88_s96_s104_s112_s120_s128_s136_s144_s152((id *)&STACK[0x328]);

  _Unwind_Resume(a1);
}

uint64_t GenerateThumbnails(uint64_t **a1, uint64_t a2, uint64_t a3, unsigned int *a4, void *a5, void **a6)
{
  void *v6;
  id v8;
  unsigned int v9;
  _UNKNOWN **v10;
  _BOOL4 v11;
  void *v12;
  apr_allocator_t *v13;
  apr_allocator_t *v14;
  unsigned int v15;
  const __CFString *v16;
  id Thumbnails;
  void *v18;
  void *v19;
  void *v20;
  char *v21;
  uint64_t v22;
  char *n;
  void *v24;
  apr_pool_t *v25;
  void *v26;
  void *v27;
  apr_pool_t *v28;
  apr_pool_t *v29;
  apr_pool_t *v30;
  apr_pool_t *v31;
  void *v32;
  char *v33;
  uint64_t v34;
  char *ii;
  uint64_t v36;
  void *v37;
  void *v38;
  void *v39;
  apr_allocator_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t *v48;
  uint64_t v49;
  apr_hash_index_t *v50;
  apr_hash_index_t *v51;
  apr_hash_index_t *v52;
  uint64_t v53;
  id v54;
  id v55;
  id v56;
  id v57;
  uint64_t v58;
  void *i;
  void *v60;
  BOOL v61;
  __CFString *v62;
  void *v63;
  uint64_t v64;
  id v65;
  void *v66;
  id DependencyGraphThumbnails;
  void *v68;
  void *v69;
  uint64_t v70;
  uint64_t v71;
  void *v72;
  char *v73;
  uint64_t v74;
  char *j;
  void *v76;
  apr_pool_t *v77;
  void *v78;
  void *v79;
  id v80;
  uint64_t v81;
  uint64_t v82;
  apr_pool_t *v83;
  void *v84;
  char *v85;
  uint64_t v86;
  char *k;
  void *v88;
  void *v89;
  void *v90;
  void *v91;
  uint64_t v92;
  void *v93;
  void *v94;
  id v95;
  id v96;
  id v97;
  uint64_t v98;
  void *jj;
  void *v100;
  void *v101;
  void *v102;
  id v103;
  void *v104;
  uint64_t v105;
  id v106;
  void *v107;
  void *v108;
  uint64_t v109;
  void *v110;
  void *v111;
  id v112;
  id v113;
  id v114;
  uint64_t v115;
  void *mm;
  void *v117;
  id v118;
  void *v119;
  void *v120;
  id v121;
  void *v122;
  unsigned int v123;
  uint64_t *AliasStream;
  uint64_t v125;
  uint64_t *v126;
  void *v127;
  void *v128;
  id v129;
  void *v130;
  id v131;
  void *v132;
  void *v133;
  void *v134;
  id v135;
  id v136;
  void *nn;
  void *v138;
  id v139;
  id v140;
  void *v141;
  void *v142;
  int v143;
  uint64_t *v144;
  id v145;
  id v146;
  id v147;
  uint64_t v148;
  uint64_t *v149;
  id v150;
  uint64_t *v151;
  void *v152;
  __CFString *v153;
  id v154;
  void *v155;
  void *v156;
  void *v157;
  id ResizeRenderPipelineState;
  void *v159;
  id v160;
  id v161;
  void *v162;
  id NSError;
  char *v164;
  char *i1;
  void *v166;
  void *v167;
  void *v168;
  id v169;
  uint64_t v170;
  apr_pool_t *v171;
  uint64_t v172;
  id v173;
  uint64_t *v174;
  void *v175;
  id v176;
  void *v177;
  int v178;
  void *v179;
  void *v180;
  void *v181;
  uint64_t v182;
  uint64_t *v184;
  id v186;
  id v187;
  uint64_t v188;
  id v189;
  void *v191;
  void *kk;
  id v193;
  unsigned int *v194;
  void *v195;
  void *v196;
  __CFString *v197;
  unint64_t v198;
  id v199;
  uint64_t v200;
  id v201;
  id v202;
  void *v203;
  void *v204;
  id v205;
  id v206;
  void *v207;
  id obj;
  id obja;
  id objb;
  id v211;
  char *v212;
  apr_pool_t *v213;
  id v214;
  id v215;
  id v216;
  apr_pool_t *p;
  apr_pool_t *pa;
  apr_pool_t *pb;
  apr_pool_t *pc;
  apr_pool_t *pd;
  apr_pool_t *pe;
  id v224;
  apr_pool_t *v225;
  _QWORD *v226;
  id v227;
  id v228;
  void *v229;
  void *v230;
  id v231;
  id v232;
  uint64_t v233;
  id v234;
  id v235;
  void *m;
  id v238;
  uint64_t *v239;
  uint64_t v240;
  id v241;
  id v242;
  id v243;
  _QWORD v244[4];
  id v245;
  id v246;
  id v247;
  id v248;
  uint64_t v249;
  void *v250;
  __int128 v251;
  __int128 v252;
  __int128 v253;
  void *v254;
  __int128 v255;
  __int128 v256;
  __int128 v257;
  __int128 v258;
  void *v259;
  __int128 v260;
  __int128 v261;
  __int128 v262;
  __int128 v263;
  __int128 v264;
  __int128 v265;
  __int128 v266;
  __int128 v267;
  apr_pool_t *newpool;
  apr_pool_t *parent[2];
  __int128 v270;
  __int128 v271;
  __int128 v272;
  NSErrorUserInfoKey v273;
  id v274;
  _BYTE v275[128];
  NSErrorUserInfoKey v276;
  void *v277;
  _BYTE v278[121];
  _BYTE v279[128];
  _QWORD v280[3];
  _QWORD v281[3];
  _QWORD v282[2];
  _QWORD v283[2];
  const __CFString *v284;
  const __CFString *v285;
  const __CFString *v286;
  const __CFString *v287;
  apr_pool_t *v288;
  __int128 v289;
  _UNKNOWN **v290;
  NSErrorUserInfoKey v291;
  __CFString *v292;
  _DWORD v293[14];
  uint64_t *v294;
  __int128 v295;
  __int128 v296;
  __int128 v297;
  __int128 v298;
  __int128 v299;
  __int128 v300;
  __int128 v301;
  __int128 v302;

  v186 = a5;
  v8 = objc_alloc((Class)NSMutableDictionary);
  v283[0] = &__kCFBooleanTrue;
  v282[0] = CFSTR("enable");
  v282[1] = CFSTR("resolution");
  v9 = a4[46];
  v194 = a4;
  if ((v9 & 8) != 0)
  {
    v10 = &off_7393D8;
  }
  else
  {
    v280[0] = CFSTR("width");
    a4 = (unsigned int *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", a4[39]));
    v281[0] = a4;
    v280[1] = CFSTR("height");
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v194[40]));
    v281[1] = v6;
    v280[2] = CFSTR("format");
    v281[2] = &off_739C58;
    v10 = (_UNKNOWN **)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v281, v280, 3));
  }
  v11 = (v9 & 8) == 0;
  v283[1] = v10;
  v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v283, v282, 2));
  v201 = objc_msgSend(v8, "initWithDictionary:", v12);

  if (v11)
  {

  }
  newpool = 0;
  apr_pool_create_ex(&newpool, 0, 0, v13);
  v202 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", 64);
  v235 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", 4);
  v15 = v194[46];
  if ((v15 & 4) != 0)
  {
    v239 = *a1;
    parent[0] = 0;
    v288 = 0;
    apr_pool_create_ex(parent, 0, 0, v14);
    v213 = parent[0];
    apr_pool_create_ex(&v288, parent[0], 0, v40);
    v206 = objc_alloc_init((Class)NSMutableDictionary);
    v242 = objc_alloc_init((Class)NSMutableArray);
    v41 = v239[14];
    if (*(int *)(v41 + 12) >= 1)
    {
      v42 = 0;
      pb = v288;
      do
      {
        v226 = *(_QWORD **)(v41 + 24);
        v43 = *(_QWORD *)(v239[15] + 24) + (v226[4 * v42] << 6);
        v44 = *(_DWORD *)(v43 + 8);
        if (v44 != -16286 && IsFuncEnumCreateCommandEncoder(v44))
        {
          v45 = GTResourceTrackerMake(v239[1], v239[2], pb);
          GTResourceTrackerProcessFunction(v45, v43);
          bzero(v293, 0x2B90uLL);
          GTMTLSMCommandEncoder_processTraceFunc((uint64_t)v293, (uint64_t *)v43, v239[2]);
          if (v293[0] == 70)
          {
            v46 = 0;
            v47 = v294;
            v48 = v294;
            do
            {
              AddAttachmentToArray(v242, v48, v46++, v45[4], v239[1]);
              v48 += 8;
            }
            while (v46 != 8);
            AddAttachmentToArray(v242, v47 + 84, 8, v45[4], v239[1]);
            AddAttachmentToArray(v242, v47 + 90, 9, v45[4], v239[1]);
          }
          v231 = objc_msgSend(v242, "copy");
          v49 = v45[4];
          v50 = (apr_hash_index_t *)(v49 + 16);
          *(_QWORD *)(v49 + 24) = 0;
          *(_QWORD *)(v49 + 32) = 0;
          *(_QWORD *)(v49 + 16) = v49;
          *(_DWORD *)(v49 + 40) = 0;
          while (1)
          {
            v51 = apr_hash_next(v50);
            v52 = v51;
            if (!v51)
              break;
            v53 = *(_QWORD *)(*((_QWORD *)v51 + 1) + 32);
            if (*(_DWORD *)(v53 + 40) == 80 && (*(_QWORD *)(v53 + 32) & 0x8000000000000000) == 0)
            {
              v54 = *(id *)v53;
              v55 = v231;
              v299 = 0u;
              v300 = 0u;
              v301 = 0u;
              v302 = 0u;
              v56 = v55;
              v57 = objc_msgSend(v56, "countByEnumeratingWithState:objects:count:", &v299, &v295, 16);
              if (v57)
              {
                v58 = *(_QWORD *)v300;
                while (2)
                {
                  for (i = 0; i != v57; i = (char *)i + 1)
                  {
                    if (*(_QWORD *)v300 != v58)
                      objc_enumerationMutation(v56);
                    v60 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v299 + 1) + 8 * (_QWORD)i), "objectForKeyedSubscript:", CFSTR("DependencyGraphRequestedTextureID")));
                    v61 = objc_msgSend(v60, "unsignedLongLongValue") == v54;

                    if (v61)
                    {

                      goto LABEL_61;
                    }
                  }
                  v57 = objc_msgSend(v56, "countByEnumeratingWithState:objects:count:", &v299, &v295, 16);
                  if (v57)
                    continue;
                  break;
                }
              }

              v292 = CFSTR("DependencyGraphRequestedTextureID");
              v62 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v54));
              v284 = v62;
              v63 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v284, &v292, 1));
              objc_msgSend(v242, "addObject:", v63);

            }
LABEL_61:
            v50 = v52;
          }
          if (objc_msgSend(v242, "count"))
          {
            v64 = v226[4 * v42 + 1];
            v65 = objc_msgSend(v242, "copy");
            v66 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v64));
            objc_msgSend(v206, "setObject:forKeyedSubscript:", v65, v66);

            objc_msgSend(v242, "removeAllObjects");
          }
          apr_pool_clear(pb);

          v41 = v239[14];
        }
        ++v42;
      }
      while (v42 < *(int *)(v41 + 12));
    }
    apr_pool_destroy(v213);

    objc_msgSend(v201, "setObject:forKeyedSubscript:", v206, CFSTR("DependencyGraphRequestedTexturesForThumbnail"));
    DependencyGraphThumbnails = GTMTLReplayClient_generateDependencyGraphThumbnails((uint64_t)*a1, v201, v202);
    v204 = (void *)objc_claimAutoreleasedReturnValue(DependencyGraphThumbnails);
    v227 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v204, "objectForKeyedSubscript:", CFSTR("object")));
    v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v227, "allKeys"));
    v69 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v68, "sortedArrayUsingSelector:"));

    v241 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", objc_msgSend(v227, "count")));
    v301 = 0u;
    v302 = 0u;
    v299 = 0u;
    v300 = 0u;
    v214 = v69;
    v232 = objc_msgSend(v214, "countByEnumeratingWithState:objects:count:", &v299, v293, 16);
    if (v232)
    {
      pc = *(apr_pool_t **)v300;
      do
      {
        v70 = 0;
        do
        {
          if (*(apr_pool_t **)v300 != pc)
          {
            v71 = v70;
            objc_enumerationMutation(v214);
            v70 = v71;
          }
          v240 = v70;
          v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v227, "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v299 + 1) + 8 * v70)));
          v271 = 0u;
          v272 = 0u;
          *(_OWORD *)parent = 0u;
          v270 = 0u;
          v73 = (char *)objc_msgSend(v72, "countByEnumeratingWithState:objects:count:", parent, &v295, 16);
          if (v73)
          {
            v74 = *(_QWORD *)v270;
            do
            {
              for (j = 0; j != v73; ++j)
              {
                if (*(_QWORD *)v270 != v74)
                  objc_enumerationMutation(v72);
                v76 = (void *)*((_QWORD *)parent[1] + (_QWORD)j);
                v284 = CFSTR("context");
                v77 = (apr_pool_t *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", 0));
                v288 = v77;
                *(_QWORD *)&v289 = &off_739BF8;
                v285 = CFSTR("type");
                v286 = CFSTR("object");
                v78 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v76, "objectForKeyedSubscript:", CFSTR("DependencyGraphRequestedThumbnailTextureID")));
                v287 = CFSTR("functionIndex");
                *((_QWORD *)&v289 + 1) = v78;
                v290 = &off_739C70;
                v79 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v288, &v284, 4));
                objc_msgSend(v241, "addObject:", v79);

              }
              v73 = (char *)objc_msgSend(v72, "countByEnumeratingWithState:objects:count:", parent, &v295, 16);
            }
            while (v73);
          }

          v70 = v240 + 1;
        }
        while ((id)(v240 + 1) != v232);
        v232 = objc_msgSend(v214, "countByEnumeratingWithState:objects:count:", &v299, v293, 16);
      }
      while (v232);
    }

    v80 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v204, "objectForKeyedSubscript:", CFSTR("object")));
    v238 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", objc_msgSend(v80, "count"));
    v301 = 0u;
    v302 = 0u;
    v299 = 0u;
    v300 = 0u;
    v225 = (apr_pool_t *)v80;
    pd = (apr_pool_t *)-[apr_pool_t countByEnumeratingWithState:objects:count:](v225, "countByEnumeratingWithState:objects:count:", &v299, v293, 16);
    if (pd)
    {
      v215 = *(id *)v300;
      do
      {
        v81 = 0;
        do
        {
          if (*(id *)v300 != v215)
          {
            v82 = v81;
            objc_enumerationMutation(v225);
            v81 = v82;
          }
          v233 = v81;
          v83 = *(apr_pool_t **)(*((_QWORD *)&v299 + 1) + 8 * v81);
          *(_OWORD *)parent = 0u;
          v270 = 0u;
          v271 = 0u;
          v272 = 0u;
          v84 = (void *)objc_claimAutoreleasedReturnValue(-[apr_pool_t objectForKeyedSubscript:](v225, "objectForKeyedSubscript:", v83));
          v85 = (char *)objc_msgSend(v84, "countByEnumeratingWithState:objects:count:", parent, &v295, 16);
          if (v85)
          {
            v86 = *(_QWORD *)v270;
            do
            {
              for (k = 0; k != v85; ++k)
              {
                if (*(_QWORD *)v270 != v86)
                  objc_enumerationMutation(v84);
                v88 = (void *)*((_QWORD *)parent[1] + (_QWORD)k);
                v89 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "objectForKeyedSubscript:", CFSTR("DependencyGraphRequestedThumbnailTextureID")));
                v90 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "objectForKeyedSubscript:", CFSTR("DependencyGraphRequestedTextureAttachmentIndex")));
                v91 = v90;
                v288 = v83;
                if (v90)
                  v92 = objc_claimAutoreleasedReturnValue(objc_msgSend(&off_738BB0, "objectAtIndexedSubscript:", objc_msgSend(v90, "unsignedIntegerValue")));
                else
                  v92 = objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "objectForKeyedSubscript:", CFSTR("DependencyGraphRequestedTextureID")));
                v93 = (void *)v92;
                *(_QWORD *)&v289 = v92;
                v94 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v288, 2));
                objc_msgSend(v238, "setObject:forKeyedSubscript:", v94, v89);

              }
              v85 = (char *)objc_msgSend(v84, "countByEnumeratingWithState:objects:count:", parent, &v295, 16);
            }
            while (v85);
          }

          v81 = v233 + 1;
        }
        while ((apr_pool_t *)(v233 + 1) != pd);
        pd = (apr_pool_t *)-[apr_pool_t countByEnumeratingWithState:objects:count:](v225, "countByEnumeratingWithState:objects:count:", &v299, v293, 16);
      }
      while (pd);
    }
  }
  else
  {
    if ((v15 & 2) != 0)
      v16 = CFSTR("All");
    else
      v16 = CFSTR("First");
    v206 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(&off_738BB0, "arrayByAddingObject:", v16));
    objc_msgSend(v201, "setObject:forKeyedSubscript:", v206, CFSTR("attachments"));
    Thumbnails = GTMTLReplayClient_generateThumbnails(*a1, v201, v202);
    v204 = (void *)objc_claimAutoreleasedReturnValue(Thumbnails);
    p = (apr_pool_t *)objc_claimAutoreleasedReturnValue(objc_msgSend(v204, "objectForKeyedSubscript:", CFSTR("object")));
    v18 = (void *)objc_claimAutoreleasedReturnValue(-[apr_pool_t allKeys](p, "allKeys"));
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "sortedArrayUsingSelector:"));

    v241 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", -[apr_pool_t count](p, "count")));
    v301 = 0u;
    v302 = 0u;
    v299 = 0u;
    v300 = 0u;
    obj = v19;
    v224 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v299, v293, 16);
    if (v224)
    {
      v211 = *(id *)v300;
      do
      {
        for (m = 0; m != v224; m = (char *)m + 1)
        {
          if (*(id *)v300 != v211)
            objc_enumerationMutation(obj);
          v229 = (void *)objc_claimAutoreleasedReturnValue(-[apr_pool_t objectForKeyedSubscript:](p, "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v299 + 1) + 8 * (_QWORD)m)));
          v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v229, "objectForKeyedSubscript:", CFSTR("target")));
          v271 = 0u;
          v272 = 0u;
          *(_OWORD *)parent = 0u;
          v270 = 0u;
          v21 = (char *)objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", parent, &v295, 16);
          if (v21)
          {
            v22 = *(_QWORD *)v270;
            do
            {
              for (n = 0; n != v21; ++n)
              {
                if (*(_QWORD *)v270 != v22)
                  objc_enumerationMutation(v20);
                v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectForKeyedSubscript:", *((_QWORD *)parent[1] + (_QWORD)n)));
                v284 = CFSTR("context");
                v25 = (apr_pool_t *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", 0));
                v288 = v25;
                *(_QWORD *)&v289 = &off_739BF8;
                v285 = CFSTR("type");
                v286 = CFSTR("object");
                v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "objectForKeyedSubscript:", CFSTR("object")));
                v287 = CFSTR("functionIndex");
                *((_QWORD *)&v289 + 1) = v26;
                v290 = &off_739C70;
                v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v288, &v284, 4));
                objc_msgSend(v241, "addObject:", v27);

              }
              v21 = (char *)objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", parent, &v295, 16);
            }
            while (v21);
          }

        }
        v224 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v299, v293, 16);
      }
      while (v224);
    }

    v28 = p;
    v238 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", -[apr_pool_t count](v28, "count"));
    v301 = 0u;
    v302 = 0u;
    v299 = 0u;
    v300 = 0u;
    v225 = v28;
    v212 = (char *)-[apr_pool_t countByEnumeratingWithState:objects:count:](v225, "countByEnumeratingWithState:objects:count:", &v299, v293, 16);
    if (v212)
    {
      obja = *(id *)v300;
      do
      {
        v29 = 0;
        do
        {
          if (*(id *)v300 != obja)
          {
            v30 = v29;
            objc_enumerationMutation(v225);
            v29 = v30;
          }
          pa = v29;
          v31 = *(apr_pool_t **)(*((_QWORD *)&v299 + 1) + 8 * (_QWORD)v29);
          v230 = (void *)objc_claimAutoreleasedReturnValue(-[apr_pool_t objectForKeyedSubscript:](v225, "objectForKeyedSubscript:", v31));
          v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v230, "objectForKeyedSubscript:", CFSTR("target")));
          v271 = 0u;
          v272 = 0u;
          *(_OWORD *)parent = 0u;
          v270 = 0u;
          v33 = (char *)objc_msgSend(v32, "countByEnumeratingWithState:objects:count:", parent, &v295, 16);
          if (v33)
          {
            v34 = *(_QWORD *)v270;
            do
            {
              for (ii = 0; ii != v33; ++ii)
              {
                if (*(_QWORD *)v270 != v34)
                  objc_enumerationMutation(v32);
                v36 = *((_QWORD *)parent[1] + (_QWORD)ii);
                v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "objectForKeyedSubscript:", v36));
                v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v37, "objectForKeyedSubscript:", CFSTR("object")));
                v288 = v31;
                *(_QWORD *)&v289 = v36;
                v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v288, 2));
                objc_msgSend(v238, "setObject:forKeyedSubscript:", v39, v38);

              }
              v33 = (char *)objc_msgSend(v32, "countByEnumeratingWithState:objects:count:", parent, &v295, 16);
            }
            while (v33);
          }

          v29 = (apr_pool_t *)((char *)pa + 1);
        }
        while ((char *)pa + 1 != v212);
        v212 = (char *)-[apr_pool_t countByEnumeratingWithState:objects:count:](v225, "countByEnumeratingWithState:objects:count:", &v299, v293, 16);
      }
      while (v212);
    }
  }

  v95 = v241;
  v96 = v202;
  v234 = objc_alloc_init((Class)NSMutableDictionary);
  v298 = 0u;
  v297 = 0u;
  v296 = 0u;
  v295 = 0u;
  v228 = v95;
  v97 = objc_msgSend(v228, "countByEnumeratingWithState:objects:count:", &v295, v293, 16);
  if (v97)
  {
    v98 = *(_QWORD *)v296;
    do
    {
      for (jj = 0; jj != v97; jj = (char *)jj + 1)
      {
        if (*(_QWORD *)v296 != v98)
          objc_enumerationMutation(v228);
        v100 = *(void **)(*((_QWORD *)&v295 + 1) + 8 * (_QWORD)jj);
        v101 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v100, "objectForKeyedSubscript:", CFSTR("functionIndex")));
        if (objc_msgSend(v101, "unsignedIntValue") == -1)
        {
          v102 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v100, "objectForKeyedSubscript:", CFSTR("object")));
          v103 = objc_msgSend(v102, "unsignedLongLongValue");

          v104 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectAtIndexedSubscript:", v103));
          v105 = objc_claimAutoreleasedReturnValue(objc_msgSend(v104, "objectForKeyedSubscript:", CFSTR("functionIndex")));

          v101 = (void *)v105;
        }
        v106 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v234, "objectForKeyedSubscript:", v101));
        if (!v106)
        {
          v106 = objc_alloc_init((Class)NSMutableArray);
          objc_msgSend(v234, "setObject:forKeyedSubscript:", v106, v101);
        }
        objc_msgSend(v106, "addObject:", v100);

      }
      v97 = objc_msgSend(v228, "countByEnumeratingWithState:objects:count:", &v295, v293, 16);
    }
    while (v97);
  }

  v288 = (apr_pool_t *)v293;
  v289 = xmmword_4AA560;
  *((_QWORD *)&v289 + 1) = objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](NSMutableData, "dataWithCapacity:", 4096));
  v184 = a1[3];
  v107 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v234, "allKeys"));
  v108 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v107, "sortedArrayUsingSelector:", "compare:"));

  if ((v194[46] & 0x10) != 0 && objc_msgSend(v108, "count"))
  {
    v109 = objc_claimAutoreleasedReturnValue(objc_msgSend(v108, "subarrayWithRange:", (char *)objc_msgSend(v108, "count") - 1, 1));

    v108 = (void *)v109;
  }
  v266 = 0u;
  v267 = 0u;
  v264 = 0u;
  v265 = 0u;
  v187 = v108;
  v189 = objc_msgSend(v187, "countByEnumeratingWithState:objects:count:", &v264, v279, 16);
  if (v189)
  {
    v188 = *(_QWORD *)v265;
    while (2)
    {
      for (kk = 0; kk != v189; kk = (char *)kk + 1)
      {
        if (*(_QWORD *)v265 != v188)
          objc_enumerationMutation(v187);
        v110 = *(void **)(*((_QWORD *)&v264 + 1) + 8 * (_QWORD)kk);
        GTMTLReplayController_debugSubCommandStop((uint64_t)a1, objc_msgSend(v110, "unsignedIntegerValue"), 0);
        v111 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v234, "objectForKeyedSubscript:", v110));
        v112 = objc_msgSend(v111, "count");
        v195 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", v112));
        v196 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", v112));
        objc_msgSend(v235, "removeAllObjects");
        v113 = objc_alloc_init((Class)NSMutableArray);
        v262 = 0u;
        v263 = 0u;
        v260 = 0u;
        v261 = 0u;
        v243 = v111;
        v114 = objc_msgSend(v243, "countByEnumeratingWithState:objects:count:", &v260, v278, 16);
        if (v114)
        {
          v115 = *(_QWORD *)v261;
          do
          {
            for (mm = 0; mm != v114; mm = (char *)mm + 1)
            {
              if (*(_QWORD *)v261 != v115)
                objc_enumerationMutation(v243);
              v117 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v260 + 1) + 8 * (_QWORD)mm), "objectForKeyedSubscript:", CFSTR("object")));
              v118 = objc_msgSend(v117, "unsignedIntegerValue");

              v119 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "objectAtIndexedSubscript:", v118));
              objc_msgSend(v235, "addObject:", v119);
              v120 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v119, "objectForKeyedSubscript:", CFSTR("object")));
              v121 = objc_msgSend(v120, "unsignedLongLongValue");

              v122 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v119, "objectForKeyedSubscript:", CFSTR("functionIndex")));
              v123 = objc_msgSend(v122, "unsignedIntValue");

              AliasStream = (uint64_t *)GetAliasStream((*a1)[3], (uint64_t)v121, (*a1)[10] + v123 - 1);
              if (AliasStream)
                v125 = *AliasStream;
              else
                v125 = 0;
              v126 = a1[5];
              v127 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v125));
              v128 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v126, "objectForKeyedSubscript:", v127));

              if (!v128)
                v128 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[1], "textureForKey:", v125));
              objc_msgSend(v113, "addObject:", v128);

            }
            v114 = objc_msgSend(v243, "countByEnumeratingWithState:objects:count:", &v260, v278, 16);
          }
          while (v114);
        }

        GTMTLReplayClient_waitForUntrackedWritesToComplete((uint64_t)a1, v113);
        v259 = 0;
        v129 = GTMTLReplayClient_retrieveTexturesForResize((id *)a1, v235, v113, 1, &v259);
        v191 = (void *)objc_claimAutoreleasedReturnValue(v129);
        v130 = v259;
        if (v130)
        {
          v131 = v130;
          v276 = NSUnderlyingErrorKey;
          v277 = v130;
          v216 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v277, &v276, 1));
          GTMTLReplay_fillError(a6, 101, v216);
          if (a6)
            v132 = *a6;
          else
            v132 = 0;
          GTMTLReplay_handleNSError(v132);
          v178 = 1;
        }
        else
        {
          v216 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", objc_msgSend(v191, "count"));
          v133 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[1], "defaultCommandQueue"));
          objb = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v133, "commandBuffer"));

          v134 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@.%@"), CFSTR("com.apple.gputools.replay"), CFSTR("TextureResize")));
          objc_msgSend(objb, "setLabel:", v134);

          v257 = 0u;
          v258 = 0u;
          v255 = 0u;
          v256 = 0u;
          v135 = v191;
          v136 = objc_msgSend(v135, "countByEnumeratingWithState:objects:count:", &v255, v275, 16);
          if (v136)
          {
            v200 = *(_QWORD *)v256;
            v193 = v135;
            while (2)
            {
              v199 = v136;
              for (nn = 0; nn != v199; nn = (char *)nn + 1)
              {
                if (*(_QWORD *)v256 != v200)
                  objc_enumerationMutation(v193);
                v138 = *(void **)(*((_QWORD *)&v255 + 1) + 8 * (_QWORD)nn);
                v139 = objc_msgSend(v138, "width");
                v140 = objc_msgSend(v138, "height");
                v285 = 0;
                v284 = 0;
                v286 = 0;
                v141 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v201, "objectForKeyedSubscript:", CFSTR("resolution")));
                *(_QWORD *)&v295 = v139;
                *((_QWORD *)&v295 + 1) = v140;
                *(_QWORD *)&v296 = 1;
                GTMTLReplayClient_resizeResolution((unint64_t *)&v284, v141, (unint64_t *)&v295);

                *(_QWORD *)&v272 = 0;
                v270 = 0u;
                v271 = 0u;
                *(_OWORD *)parent = 0u;
                v142 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v138, "device"));
                MTLPixelFormatGetInfoForDevice(v142, objc_msgSend(v138, "pixelFormat"));

                v143 = (int)parent[1];
                v144 = a1[2];
                v254 = 0;
                v145 = GTMTLReplayController_resizeTexture(v144, a2, objb, v138, (unint64_t)v284, (unint64_t)v285, &v254);
                v146 = (id)objc_claimAutoreleasedReturnValue(v145);
                v131 = v254;
                if ((v143 & 0x20000) != 0)
                {
                  v198 = v198 & 0xFFFFFFFF00000000 | 0x1040302;
                  v147 = objc_msgSend(v146, "newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:", objc_msgSend(v146, "pixelFormat"), 2, 0, objc_msgSend(v138, "mipmapLevelCount"), 0, 1, v198);

                  v203 = v131;
                  if ((v194[46] & 0x20) != 0)
                    v148 = 70;
                  else
                    v148 = 125;
                  v149 = a1[2];
                  v205 = objb;
                  v150 = v147;
                  v151 = v149;
                  v152 = v150;
                  v207 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v150, "device"));
                  objc_msgSend(v150, "pixelFormat");
                  *(_QWORD *)&v298 = 0;
                  v297 = 0u;
                  v296 = 0u;
                  v295 = 0u;
                  GTMTLPixelFormatGetInfoForDevice((uint64_t)&v295, (uint64_t)v207, v148);
                  pe = (apr_pool_t *)objc_claimAutoreleasedReturnValue(+[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:width:height:mipmapped:](MTLTextureDescriptor, "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", v148, objc_msgSend(v150, "width"), objc_msgSend(v150, "height"), 0));
                  -[apr_pool_t setUsage:](pe, "setUsage:", 5);
                  -[apr_pool_t setResourceOptions:](pe, "setResourceOptions:", 32);
                  v292 = 0;
                  v146 = objc_msgSend(v151, "newTextureWithDescriptor:error:", pe, &v292);

                  v153 = v292;
                  v197 = v153;
                  if (v146)
                  {
                    v154 = objc_alloc_init((Class)MTLRenderPassDescriptor);
                    v155 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v154, "colorAttachments"));
                    v156 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v155, "objectAtIndexedSubscript:", 0));
                    objc_msgSend(v156, "setTexture:", v146);

                    v157 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v205, "renderCommandEncoderWithDescriptor:", v154));
                    v299 = v295;
                    v300 = v296;
                    v301 = v297;
                    *(_QWORD *)&v302 = v298;
                    ResizeRenderPipelineState = GTMTLReplayController_getResizeRenderPipelineState(a2, (uint64_t)&v299, v148);
                    v159 = (void *)objc_claimAutoreleasedReturnValue(ResizeRenderPipelineState);
                    objc_msgSend(v157, "setRenderPipelineState:", v159);

                    objc_msgSend(v157, "setVertexBuffer:offset:atIndex:", *(_QWORD *)(a2 + 144), 0, 0);
                    objc_msgSend(v157, "setVertexBuffer:offset:atIndex:", *(_QWORD *)(a2 + 144), 96, 1);
                    objc_msgSend(v157, "setFragmentSamplerState:atIndex:", *(_QWORD *)(a2 + 128), 0);
                    objc_msgSend(v157, "setFragmentTexture:atIndex:", v152, 0);
                    objc_msgSend(v157, "drawPrimitives:vertexStart:vertexCount:", 3, 0, 6);
                    objc_msgSend(v157, "endEncoding");
                    v160 = v146;

                    v161 = v203;
                  }
                  else
                  {
                    if (v153)
                    {
                      v291 = NSUnderlyingErrorKey;
                      *(_QWORD *)&v299 = v153;
                      v162 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v299, &v291, 1));
                    }
                    else
                    {
                      v162 = 0;
                    }
                    v154 = v162;
                    NSError = MakeNSError(101, v162);
                    v161 = (id)objc_claimAutoreleasedReturnValue(NSError);
                    GTMTLReplay_handleNSError(v161);
                  }

                  v131 = v161;
                }
                if (v131)
                {
                  v273 = NSUnderlyingErrorKey;
                  v274 = v131;
                  v180 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v274, &v273, 1));
                  GTMTLReplay_fillError(a6, 101, v180);
                  if (a6)
                    v181 = *a6;
                  else
                    v181 = 0;
                  GTMTLReplay_handleNSError(v181);

                  v178 = 1;
                  v179 = v193;
                  goto LABEL_163;
                }
                objc_msgSend(v216, "addObject:", v146);

              }
              v135 = v193;
              v136 = objc_msgSend(v193, "countByEnumeratingWithState:objects:count:", &v255, v275, 16);
              if (v136)
                continue;
              break;
            }
          }

          GTMTLReplay_commitCommandBuffer(objb);
          v164 = (char *)objc_msgSend(v235, "count");
          if (v164)
          {
            for (i1 = 0; i1 != v164; ++i1)
            {
              v166 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v216, "objectAtIndexedSubscript:", i1));
              v167 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v243, "objectAtIndexedSubscript:", i1));
              v168 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v167, "objectForKeyedSubscript:", CFSTR("object")));
              v169 = objc_msgSend(v168, "unsignedIntegerValue");

              objc_msgSend(*((id *)&v289 + 1), "setLength:", 0);
              objc_msgSend(*((id *)&v289 + 1), "appendBytes:length:", "MTSP", 8);
              v251 = 0u;
              v252 = 0u;
              v253 = 0u;
              DWORD2(v251) = 7;
              LODWORD(v252) = 2;
              DYTraceEncode_InternalData((uint64_t)&v251, (unsigned int *)v288);
              v170 = *(unsigned int *)v288;
              if ((*((_BYTE *)v288 + 33) & 0x10) != 0)
              {
                v171 = v288;
                v172 = *(unsigned int *)v288;
                do
                {
                  v171 = (apr_pool_t *)((char *)v171 + v170);
                  v170 = *(unsigned int *)v171;
                  v172 += v170;
                }
                while ((*((_BYTE *)v171 + 33) & 0x20) == 0);
              }
              objc_msgSend(*((id *)&v289 + 1), "appendBytes:length:");
              *(_QWORD *)&v295 = &v288;
              v173 = v196;
              *((_QWORD *)&v295 + 1) = v173;
              *(_QWORD *)&v296 = 0;
              v174 = a1[3];
              v250 = 0;
              GTMTLReplayClient_harvestTexture(a2, v174, v166, (uint64_t)v169, (unsigned int ***)&v295, 0xFFFFFFFFFFFFFFFFLL, 0, 0, &v250);
              v175 = v250;
              v176 = objc_msgSend(*((id *)&v289 + 1), "copy");
              objc_msgSend(v195, "addObject:", v176);

            }
          }
          v177 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v184, "commandBuffer"));
          v244[0] = _NSConcreteStackBlock;
          v244[1] = 3221225472;
          v244[2] = __GenerateThumbnails_block_invoke;
          v244[3] = &unk_726330;
          v245 = v195;
          v246 = v238;
          v247 = v196;
          v249 = a3;
          v248 = v186;
          objc_msgSend(v177, "addCompletedHandler:", v244);

          objc_msgSend(v184, "commitCommandBuffer");
          v131 = 0;
          v178 = 0;
          v179 = v245;
LABEL_163:

        }
        if (v178)
        {

          v182 = 0;
          goto LABEL_169;
        }
      }
      v189 = objc_msgSend(v187, "countByEnumeratingWithState:objects:count:", &v264, v279, 16);
      if (v189)
        continue;
      break;
    }
  }

  apr_pool_destroy(newpool);
  v182 = 1;
LABEL_169:

  return v182;
}

void sub_2C1110(_Unwind_Exception *a1)
{

  _Unwind_Resume(a1);
}

id ComputeDerivedCounters(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  id v8;
  id v9;
  uint64_t v10;
  void *v11;
  void *v12;
  id v13;
  id v14;
  id v15;
  uint64_t v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  id v21;
  void *v22;
  void *v24;
  id v25;
  id v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  _BYTE v35[128];
  _BYTE v36[128];

  v26 = a1;
  v5 = a2;
  v25 = a3;
  v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("counters")));
  v6 = objc_alloc_init((Class)NSMutableArray);
  v31 = 0u;
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("AverageSamples")));
  v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v31, v36, 16);
  if (v8)
  {
    v9 = v8;
    v10 = *(_QWORD *)v32;
    do
    {
      v11 = 0;
      do
      {
        if (*(_QWORD *)v32 != v10)
          objc_enumerationMutation(v7);
        v12 = *(void **)(*((_QWORD *)&v31 + 1) + 8 * (_QWORD)v11);
        v27 = 0u;
        v28 = 0u;
        v29 = 0u;
        v30 = 0u;
        v13 = v12;
        v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v27, v35, 16);
        if (v14)
        {
          v15 = v14;
          v16 = *(_QWORD *)v28;
          do
          {
            v17 = 0;
            do
            {
              if (*(_QWORD *)v28 != v16)
                objc_enumerationMutation(v13);
              objc_msgSend(v6, "addObjectsFromArray:", *(_QWORD *)(*((_QWORD *)&v27 + 1) + 8 * (_QWORD)v17));
              v17 = (char *)v17 + 1;
            }
            while (v15 != v17);
            v15 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v27, v35, 16);
          }
          while (v15);
        }

        v11 = (char *)v11 + 1;
      }
      while (v11 != v9);
      v9 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v31, v36, 16);
    }
    while (v9);
  }

  v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "objectForKeyedSubscript:", CFSTR("DerivedCounterDictionary")));
  verifyCounterDictionary(v18);
  v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "objectForKeyedSubscript:", CFSTR("DerivedCounters")));
  v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "allKeys"));

  v21 = GTMTLReplayHost_computeDerivedCountersFromData(v24, v6, v25, v20, v26);
  v22 = (void *)objc_claimAutoreleasedReturnValue(v21);

  return v22;
}

id BatchIdFiterableCounters()
{
  if (BatchIdFiterableCounters__once != -1)
    dispatch_once(&BatchIdFiterableCounters__once, &__block_literal_global_5832);
  return (id)BatchIdFiterableCounters_filterableCounters;
}

void WriteToCSVFromCounterData(void *a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  id v6;
  id v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  void *v13;
  id v14;
  id v15;
  id v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  void *v25;
  id obj;
  uint64_t v27;
  id v28;
  uint64_t v29;
  id v30;
  uint64_t v31;
  id v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  _BYTE v46[128];
  _BYTE v47[128];
  _BYTE v48[128];

  v3 = a1;
  v24 = a2;
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("counters")));
  v25 = v3;
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("AverageSamples")));
  v6 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", (char *)objc_msgSend(v4, "count") + 1);
  objc_msgSend(v6, "addObject:", CFSTR("Index"));
  v23 = v4;
  objc_msgSend(v6, "addObjectsFromArray:", v4);
  v7 = objc_alloc_init((Class)NSMutableArray);
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "componentsJoinedByString:", CFSTR(",")));
  objc_msgSend(v7, "addObject:", v8);

  objc_msgSend(v7, "addObject:", CFSTR("Frame Start 1"));
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  obj = v5;
  v28 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v42, v48, 16);
  if (v28)
  {
    v9 = 0;
    v27 = *(_QWORD *)v43;
    do
    {
      v10 = 0;
      do
      {
        if (*(_QWORD *)v43 != v27)
          objc_enumerationMutation(obj);
        v29 = v10;
        v11 = *(void **)(*((_QWORD *)&v42 + 1) + 8 * v10);
        v38 = 0u;
        v39 = 0u;
        v40 = 0u;
        v41 = 0u;
        v30 = v11;
        v32 = objc_msgSend(v30, "countByEnumeratingWithState:objects:count:", &v38, v47, 16);
        if (v32)
        {
          v31 = *(_QWORD *)v39;
          do
          {
            v12 = 0;
            do
            {
              if (*(_QWORD *)v39 != v31)
                objc_enumerationMutation(v30);
              v33 = v12;
              v13 = *(void **)(*((_QWORD *)&v38 + 1) + 8 * v12);
              v34 = 0u;
              v35 = 0u;
              v36 = 0u;
              v37 = 0u;
              v14 = v13;
              v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v34, v46, 16);
              if (v15)
              {
                v16 = v15;
                v17 = *(_QWORD *)v35;
                do
                {
                  v18 = 0;
                  do
                  {
                    if (*(_QWORD *)v35 != v17)
                      objc_enumerationMutation(v14);
                    v19 = *(_QWORD *)(*((_QWORD *)&v34 + 1) + 8 * (_QWORD)v18);
                    objc_msgSend(v6, "removeAllObjects");
                    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", (char *)v18 + v9));
                    objc_msgSend(v6, "addObject:", v20);

                    objc_msgSend(v6, "addObjectsFromArray:", v19);
                    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "componentsJoinedByString:", CFSTR(",")));
                    objc_msgSend(v7, "addObject:", v21);

                    v18 = (char *)v18 + 1;
                  }
                  while (v16 != v18);
                  v9 += (uint64_t)v18;
                  v16 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v34, v46, 16);
                }
                while (v16);
              }

              v12 = v33 + 1;
            }
            while ((id)(v33 + 1) != v32);
            v32 = objc_msgSend(v30, "countByEnumeratingWithState:objects:count:", &v38, v47, 16);
          }
          while (v32);
        }

        v10 = v29 + 1;
      }
      while ((id)(v29 + 1) != v28);
      v28 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v42, v48, 16);
    }
    while (v28);
  }

  objc_msgSend(v7, "addObject:", CFSTR("Frame End 1"));
  v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "componentsJoinedByString:", CFSTR("\n")));
  objc_msgSend(v22, "writeToURL:atomically:encoding:error:", v24, 0, 4, 0);

}

void WriteToPlistFromCounterData(void *a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  id v14;
  id v15;
  id v16;
  id v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  id v22;
  id v23;
  id v24;
  id v25;
  void *v26;
  void *v27;
  id v28;
  void *v29;
  id obj;
  uint64_t v31;
  id v32;
  id v33;
  uint64_t v34;
  uint64_t v35;
  id v36;
  uint64_t v37;
  id v38;
  id v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  const __CFString *v55;
  id v56;
  _BYTE v57[128];
  _BYTE v58[128];
  _BYTE v59[128];

  v3 = a1;
  v28 = a2;
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("counters")));
  v29 = v3;
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("AverageSamples")));
  v32 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", objc_msgSend(v5, "count"));
  v51 = 0u;
  v52 = 0u;
  v53 = 0u;
  v54 = 0u;
  obj = v5;
  v33 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v51, v59, 16);
  if (v33)
  {
    v6 = 0;
    v31 = *(_QWORD *)v52;
    do
    {
      v7 = 0;
      v8 = v6;
      do
      {
        v34 = v8;
        if (*(_QWORD *)v52 != v31)
          objc_enumerationMutation(obj);
        v35 = v7;
        v9 = *(void **)(*((_QWORD *)&v51 + 1) + 8 * v7);
        v38 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", objc_msgSend(v9, "count"));
        v47 = 0u;
        v48 = 0u;
        v49 = 0u;
        v50 = 0u;
        v36 = v9;
        v39 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v47, v58, 16);
        if (v39)
        {
          v10 = 0;
          v37 = *(_QWORD *)v48;
          do
          {
            v11 = 0;
            v12 = v10;
            do
            {
              v40 = v12;
              if (*(_QWORD *)v48 != v37)
                objc_enumerationMutation(v36);
              v41 = v11;
              v13 = *(void **)(*((_QWORD *)&v47 + 1) + 8 * v11);
              v14 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", objc_msgSend(v13, "count"));
              v43 = 0u;
              v44 = 0u;
              v45 = 0u;
              v46 = 0u;
              v15 = v13;
              v16 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v43, v57, 16);
              if (v16)
              {
                v17 = v16;
                v18 = 0;
                v19 = *(_QWORD *)v44;
                do
                {
                  v20 = 0;
                  do
                  {
                    if (*(_QWORD *)v44 != v19)
                      objc_enumerationMutation(v15);
                    v21 = *(_QWORD *)(*((_QWORD *)&v43 + 1) + 8 * (_QWORD)v20);
                    v22 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Draw Call %llu"), (char *)v20 + v18);
                    v23 = objc_msgSend(objc_alloc((Class)NSDictionary), "initWithObjects:forKeys:", v21, v4);
                    objc_msgSend(v14, "setObject:forKeyedSubscript:", v23, v22);

                    v20 = (char *)v20 + 1;
                  }
                  while (v17 != v20);
                  v18 += (uint64_t)v20;
                  v17 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v43, v57, 16);
                }
                while (v17);
              }

              v10 = v40 + 1;
              v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Command Encoder %llu"), v40);
              objc_msgSend(v38, "setObject:forKeyedSubscript:", v14, v24);

              v11 = v41 + 1;
              v12 = v40 + 1;
            }
            while ((id)(v41 + 1) != v39);
            v39 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v47, v58, 16);
          }
          while (v39);
        }

        v6 = v34 + 1;
        v25 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Command Buffer %llu"), v34);
        objc_msgSend(v32, "setObject:forKeyedSubscript:", v38, v25);

        v7 = v35 + 1;
        v8 = v34 + 1;
      }
      while ((id)(v35 + 1) != v33);
      v33 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v51, v59, 16);
    }
    while (v33);
  }

  v55 = CFSTR("Frame 0");
  v56 = v32;
  v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v56, &v55, 1));
  v42 = 0;
  v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSPropertyListSerialization dataWithPropertyList:format:options:error:](NSPropertyListSerialization, "dataWithPropertyList:format:options:error:", v26, 100, 0, &v42));

  objc_msgSend(v27, "writeToURL:atomically:", v28, 0);
}

void FetchResourceObject(id *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  id v8;
  id v9;
  id v10;
  id v11;
  id v12;
  id v13;
  void *v14;
  void **v15;
  uint64_t v16;
  void (*v17)(uint64_t);
  void *v18;
  id v19;
  id v20;
  id v21[3];
  int v22;
  _QWORD v23[4];
  id v24;
  id v25[2];
  _QWORD block[4];
  id v27;
  id *v28;
  id location;

  v5 = a2;
  v6 = a3;
  v7 = (void *)os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, v5);
  v8 = objc_alloc_init((Class)NSOperation);
  objc_initWeak(&location, v8);
  v9 = &_dispatch_main_q;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = __FetchResourceObject_block_invoke;
  block[3] = &unk_726378;
  v28 = a1;
  v10 = v8;
  v27 = v10;
  dispatch_async((dispatch_queue_t)&_dispatch_main_q, block);
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472;
  v23[2] = __FetchResourceObject_block_invoke_2;
  v23[3] = &unk_7263C8;
  v11 = &_dispatch_main_q;
  v24 = &_dispatch_main_q;
  v25[1] = a1;
  objc_copyWeak(v25, &location);
  objc_msgSend(v10, "setCompletionBlock:", v23);
  objc_destroyWeak(v25);

  v15 = _NSConcreteStackBlock;
  v16 = 3221225472;
  v17 = __FetchResourceObject_block_invoke_4;
  v18 = &unk_7263F0;
  objc_copyWeak(v21, &location);
  v21[1] = a1;
  v12 = v5;
  v19 = v12;
  v13 = v6;
  v20 = v13;
  v21[2] = v7;
  v22 = 0;
  v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", &v15));
  objc_msgSend(a1[32], "addOperation:", v14, v15, v16, v17, v18);
  objc_msgSend(v10, "addDependency:", v14);
  objc_msgSend(a1[33], "addOperation:", v10);

  objc_destroyWeak(v21);
  objc_destroyWeak(&location);

}

void sub_2C28C8(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 104));
  _Unwind_Resume(a1);
}

void sub_2C2CFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,id location)
{
  id *v32;

  objc_destroyWeak(v32);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

id GetAttributes(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  unsigned int v5;
  id v6;
  void *v7;
  id v8;
  void *v9;

  v3 = a2;
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("functionIndex")));
  v5 = objc_msgSend(v4, "unsignedIntValue");

  if (v5 == -1)
  {
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("object")));
    v8 = objc_msgSend(v7, "unsignedLongLongValue");

    v6 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 88), "objectAtIndexedSubscript:", v8));
  }
  else
  {
    v6 = v3;
  }
  v9 = v6;

  return v9;
}

id PreprocessICBData(void *a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void *v5;
  const CATransform3D **v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int16 *v9;
  id v10;
  int v11;
  id v12;
  id v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  const char *v18;
  const char *v19;
  void *v20;
  void *v21;
  char *v22;
  uint32_t *v23;
  uint32_t *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  char *v30;
  void *v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  void *v37;
  char *v38;
  int v39;
  void *v40;
  char *v41;
  int v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  id v46;
  NSObject *v47;
  id v48;
  NSObject *v49;
  FILE *v50;
  FILE *v51;
  _BYTE *v52;
  id v53;
  id v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  id v58;
  id v59;
  uint64_t v60;
  unint64_t v61;
  char *v62;
  id v63;
  id v64;
  uint64_t v65;
  unint64_t v66;
  char *v67;
  id v68;
  id v69;
  char *v70;
  unint64_t v71;
  char *v72;
  id v73;
  id v74;
  unint64_t v75;
  char *v76;
  uint64_t v77;
  id v78;
  void *v79;
  id v80;
  uint64_t v81;
  void *v82;
  _BYTE *v83;
  char *v84;
  char *v85;
  char *v86;
  void *v87;
  uint64_t *v88;
  uint64_t *v89;
  uint64_t v90;
  char *v91;
  void *v92;
  void *v93;
  void *v94;
  __int128 v95;
  uint64_t v96;
  __int128 v97;
  uint64_t v98;
  char *v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  id v103;
  id v104;
  unint64_t v105;
  id v106;
  unint64_t v107;
  id v108;
  char *v110;
  id v111;
  void *v112;
  void *v113;
  void *v114;
  char *v115;
  id v116;
  id v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  id v122;
  uint64_t v123;
  id v124;
  id v125;
  id v126;
  uint64_t v127;
  void *v128;
  uint64_t v129;
  char *v130;
  uint64_t v131;
  char *v132;
  uint64_t v133;
  uint64_t v134;
  char *v135;
  char *v136;
  id v137;
  char *context;
  void *contexta;
  char *v140;
  char *v141;
  char *v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  uint64_t v151;
  __int128 v152;
  uint64_t v153;
  __int128 v154;
  uint64_t v155;
  uint8_t buf[16];
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  uint64_t v161;
  __int128 v162;
  uint64_t v163;

  v1 = a1;
  v3 = objc_opt_class(NSArray, v2);
  if ((objc_opt_isKindOfClass(v1, v3) & 1) != 0 && objc_msgSend(v1, "count") == (char *)&dword_0 + 2)
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "objectAtIndexedSubscript:", 0));
    if ((IsResourceIndirectCommandBuffer(v4) & 1) == 0)
    {
      v12 = v1;
LABEL_152:

      goto LABEL_153;
    }
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "objectAtIndexedSubscript:", 1));
    v6 = &CATransform3DIdentity_ptr;
    v8 = objc_opt_class(NSData, v7);
    if ((objc_opt_isKindOfClass(v5, v8) & 1) == 0 || objc_msgSend(v5, "length") != &dword_18)
    {
      v12 = v1;
LABEL_151:

      goto LABEL_152;
    }
    v9 = (unsigned __int16 *)objc_msgSend(objc_retainAutorelease(v5), "bytes");
    v10 = v4;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v144 = 0u;
    v145 = 0u;
    v143 = 0u;
    GTMTLCreateIndirectCommandEncoder((uint64_t)&v143, (uint64_t)v9);
    v11 = v9[4];
    if ((v11 & 0xFE70) != 0)
    {
      if ((v11 & 0xFFFFFF9F) != 0)
      {

        goto LABEL_149;
      }
      v111 = v1;
      v112 = v10;
      v113 = v5;
      v114 = v4;
      v137 = v10;
      v80 = objc_msgSend(v137, "size");
      v81 = *((_QWORD *)&v149 + 1);
      v117 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](NSMutableData, "dataWithLength:", *((_QWORD *)&v149 + 1) * (_QWORD)v80)));
      v135 = (char *)objc_msgSend(v117, "mutableBytes");
      if (v80)
      {
        v140 = 0;
        v82 = 0;
        v123 = v149 + 72;
        v125 = 0;
        v83 = (_BYTE *)v143;
        v131 = v81;
        v133 = *((_QWORD *)&v143 + 1);
        v121 = v144;
        v129 = v149;
        v127 = ((_QWORD)v149 - (_QWORD)v148) >> 3;
        v84 = &v135[v148];
        v119 = *((_QWORD *)&v146 + 1);
        v85 = &v135[*((_QWORD *)&v146 + 1)];
        v86 = &v135[*((_QWORD *)&v147 + 1)];
        while (1)
        {
          contexta = objc_autoreleasePoolPush();
          v87 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v137, "indirectComputeCommandAtIndex:", v82));
          v88 = (uint64_t *)objc_msgSend(v87, "getCommandType");
          v142 = &v135[v81 * (_QWORD)v82];
          *(_QWORD *)&v142[v133] = v88;
          if (v88)
            break;
LABEL_145:

          objc_autoreleasePoolPop(contexta);
          v82 = (char *)v82 + 1;
          v84 += v81;
          v85 += v81;
          v86 += v81;
          if (v82 == v80)
            goto LABEL_146;
        }
        v89 = v88;
        if ((int)v127 >= 1)
        {
          v90 = 0;
          do
          {
            *(_QWORD *)&v84[8 * v90] = objc_msgSend(v87, "getKernelAttributeStrideAtIndex:", v90);
            ++v90;
          }
          while (v127 != v90);
        }
        v91 = &v142[v129];
        if (v89 == (uint64_t *)&stru_20)
        {
          v94 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v87, "dispatchThreadgroupsArguments"));
          v93 = v94;
          v162 = 0uLL;
          v163 = 0;
          if (v94)
          {
            objc_msgSend(v94, "threadgroupsPerGrid");
            goto LABEL_123;
          }
        }
        else
        {
          if (v89 != &stru_20.vmsize)
          {
LABEL_129:
            if (!v83[11])
            {
              v103 = objc_msgSend(v87, "getPipelineStateUniqueIdentifier");
              v104 = v125;
              if (v103 != (id)-1)
                v104 = v103;
              v125 = v104;
              *(_QWORD *)&v142[v121] = v104;
            }
            v81 = v131;
            if (!v83[10])
            {
              if (v83[13])
              {
                v105 = 0;
                do
                {
                  v106 = objc_msgSend(v87, "getKernelBufferAtIndex:", v105);
                  if (v106 == (id)-1)
                  {
                    if (v140)
                      v106 = *(id *)&v140[8 * v105];
                    else
                      v106 = 0;
                  }
                  *(_QWORD *)&v85[8 * v105++] = v106;
                }
                while (v105 < v83[13]);
              }
              v140 = &v142[v119];
              v81 = v131;
            }
            if (v83[14])
            {
              v107 = 0;
              do
              {
                *(_QWORD *)&v86[8 * v107] = objc_msgSend(v87, "getThreadgroupMemoryLengthAtIndex:", v107);
                ++v107;
              }
              while (v107 < v83[14]);
            }
            goto LABEL_145;
          }
          v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v87, "dispatchThreadsArguments"));
          v93 = v92;
          v162 = 0uLL;
          v163 = 0;
          if (v92)
          {
            objc_msgSend(v92, "threadsPerGrid");
LABEL_123:
            v160 = 0uLL;
            v161 = 0;
            objc_msgSend(v93, "threadsPerThreadgroup");
            v95 = v162;
            v96 = v163;
            v97 = v160;
            v98 = v161;
LABEL_125:
            v99 = &v142[v123];
            *(_OWORD *)v99 = v95;
            *((_QWORD *)v99 + 2) = v96;
            *(_OWORD *)(v99 + 24) = v97;
            *((_QWORD *)v99 + 5) = v98;
            v100 = 0uLL;
            v158 = 0u;
            v159 = 0u;
            v157 = 0u;
            if (v87)
            {
              objc_msgSend(v87, "getStageInRegion");
              v100 = v157;
              v101 = v158;
              v102 = v159;
            }
            else
            {
              v101 = 0uLL;
              v102 = 0uLL;
            }
            *(_OWORD *)v91 = v100;
            *((_OWORD *)v91 + 1) = v101;
            *((_OWORD *)v91 + 2) = v102;
            v91[64] = objc_msgSend(v87, "hasBarrier");

            goto LABEL_129;
          }
        }
        v98 = 0;
        v96 = 0;
        v161 = 0;
        v95 = 0uLL;
        v160 = 0u;
        v97 = 0uLL;
        goto LABEL_125;
      }
LABEL_146:
      v78 = objc_msgSend(v117, "copy");

      v79 = v137;
    }
    else
    {
      v111 = v1;
      v112 = v10;
      v113 = v5;
      v114 = v4;
      v126 = v10;
      v13 = objc_msgSend(v126, "size");
      v14 = *((_QWORD *)&v149 + 1);
      v122 = v13;
      v124 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](NSMutableData, "dataWithLength:", *((_QWORD *)&v149 + 1) * (_QWORD)v13));
      if (v13)
      {
        v15 = 0;
        v115 = 0;
        v116 = 0;
        context = 0;
        v16 = 0;
        v110 = 0;
        v17 = 0;
        v18 = "getVertexBufferAddressAtIndex:";
        v141 = 0;
        v118 = v14;
        v120 = *((_QWORD *)&v143 + 1);
        do
        {
          v19 = v18;
          v20 = objc_autoreleasePoolPush();
          v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v126, "indirectRenderCommandAtIndex:", v17));
          v134 = v17;
          v136 = (char *)objc_msgSend(objc_retainAutorelease(v124), "mutableBytes");
          v22 = &v136[v14 * v17];
          v23 = (uint32_t *)objc_msgSend(v21, "getCommandType");
          *(_QWORD *)&v22[v120] = v23;
          if (v23)
          {
            v24 = v23;
            v128 = v20;
            v130 = v16;
            v132 = v22;
            v25 = v149;
            v26 = &v22[v149];
            if ((int)(((_QWORD)v149 - (_QWORD)v148) >> 3) >= 1)
            {
              v27 = 0;
              v28 = (((_QWORD)v149 - (_QWORD)v148) >> 3);
              v29 = &v136[v148 + v15];
              do
              {
                *(_QWORD *)&v29[8 * v27] = objc_msgSend(v21, "getVertexAttributeStrideAtIndex:", v27);
                ++v27;
              }
              while (v28 != v27);
            }
            v18 = v19;
            v30 = v132;
            switch((unint64_t)v24)
            {
              case 1uLL:
                v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "drawArguments"));
                *(_QWORD *)v26 = objc_msgSend(v31, "primitiveType");
                *((_QWORD *)v26 + 1) = objc_msgSend(v31, "vertexStart");
                *((_QWORD *)v26 + 2) = objc_msgSend(v31, "vertexCount");
                *((_QWORD *)v26 + 3) = objc_msgSend(v31, "instanceCount");
                *((_QWORD *)v26 + 4) = objc_msgSend(v31, "baseInstance");
                goto LABEL_44;
              case 2uLL:
                v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "drawIndexedArguments"));
                *(_QWORD *)v26 = objc_msgSend(v31, "primitiveType");
                *((_QWORD *)v26 + 1) = objc_msgSend(v31, "indexCount");
                *((_QWORD *)v26 + 2) = objc_msgSend(v31, "indexType");
                *((_QWORD *)v26 + 3) = objc_msgSend(v31, "indexBufferGPUVirtualAddress");
                *((_QWORD *)v26 + 4) = objc_msgSend(v31, "instanceCount");
                *((_QWORD *)v26 + 5) = objc_msgSend(v31, "baseVertex");
                *((_QWORD *)v26 + 6) = objc_msgSend(v31, "baseInstance");
                if (*((_QWORD *)v26 + 2) == -1)
                  *((_QWORD *)v26 + 2) = *((_QWORD *)v110 + 2);
                v110 = v26;
                goto LABEL_44;
              case 3uLL:
              case 5uLL:
              case 6uLL:
              case 7uLL:
                goto LABEL_45;
              case 4uLL:
                v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "getTessellationFactorArguments"));
                v38 = &v132[v25];
                *(_QWORD *)&v132[v25] = objc_msgSend(v37, "virtualAddress");
                *((_QWORD *)v26 + 1) = objc_msgSend(v37, "instanceStride");
                objc_msgSend(v37, "scale");
                *((_DWORD *)v26 + 4) = v39;

                v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "drawPatchesArguments"));
                *((_QWORD *)v38 + 3) = objc_msgSend(v31, "numberOfPatchControlPoints");
                *((_QWORD *)v38 + 4) = objc_msgSend(v31, "patchStart");
                *((_QWORD *)v38 + 5) = objc_msgSend(v31, "patchCount");
                *((_QWORD *)v38 + 6) = objc_msgSend(v31, "patchIndexBufferVirtualAddress");
                *((_QWORD *)v38 + 7) = objc_msgSend(v31, "instanceCount");
                *((_QWORD *)v38 + 8) = objc_msgSend(v31, "baseInstance");
                goto LABEL_44;
              case 8uLL:
                v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "getTessellationFactorArguments"));
                v41 = &v132[v25];
                *(_QWORD *)&v132[v25] = objc_msgSend(v40, "virtualAddress");
                *((_QWORD *)v26 + 1) = objc_msgSend(v40, "instanceStride");
                objc_msgSend(v40, "scale");
                *((_DWORD *)v26 + 4) = v42;

                v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "drawIndexedPatchesArguments"));
                *((_QWORD *)v41 + 3) = objc_msgSend(v31, "numberOfPatchControlPoints");
                *((_QWORD *)v41 + 4) = objc_msgSend(v31, "patchStart");
                *((_QWORD *)v41 + 5) = objc_msgSend(v31, "patchCount");
                *((_QWORD *)v41 + 6) = objc_msgSend(v31, "patchIndexBufferVirtualAddress");
                *((_QWORD *)v41 + 7) = objc_msgSend(v31, "controlPointIndexBufferVirtualAddress");
                *((_QWORD *)v41 + 8) = objc_msgSend(v31, "instanceCount");
                *((_QWORD *)v41 + 9) = objc_msgSend(v31, "baseInstance");
                goto LABEL_44;
              default:
                if (v24 == (uint32_t *)&stru_68.segname[8])
                {
                  v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "drawMeshThreadgroupsArguments"));
                  v31 = v43;
                  if (v43)
                  {
                    objc_msgSend(v43, "threadgroupsPerGrid");
                    v44 = v158;
                    *(_OWORD *)v26 = v157;
                    *((_QWORD *)v26 + 2) = v44;
                    objc_msgSend(v31, "threadsPerObjectThreadgroup");
                    v45 = v163;
                    *(_OWORD *)(v26 + 24) = v162;
                    *((_QWORD *)v26 + 5) = v45;
                    objc_msgSend(v31, "threadsPerMeshThreadgroup");
                    v35 = v160;
                    v36 = v161;
                    v18 = v19;
                    v30 = v132;
                  }
                  else
                  {
                    if (s_logUsingOsLog)
                    {
                      v48 = gt_default_log();
                      v49 = objc_claimAutoreleasedReturnValue(v48);
                      if (os_log_type_enabled(v49, OS_LOG_TYPE_FAULT))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_fault_impl(&dword_0, v49, OS_LOG_TYPE_FAULT, "fail: Unable to decode MTLIndirectCommandTypeDrawMeshThreadgroups", buf, 2u);
                      }
                    }
                    else
                    {
                      v51 = __stderrp;
                      v49 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("fail: Unable to decode MTLIndirectCommandTypeDrawMeshThreadgroups"))));
                      fprintf(v51, "%s\n", (const char *)-[NSObject UTF8String](v49, "UTF8String"));
                    }
                    v18 = v19;
                    v30 = v132;

                    v36 = 0;
                    *(_QWORD *)&v158 = 0;
                    v35 = 0uLL;
                    v157 = 0u;
                    *((_QWORD *)v26 + 2) = 0;
                    *(_OWORD *)v26 = 0u;
                    v163 = 0;
                    v162 = 0u;
                    *((_QWORD *)v26 + 5) = 0;
                    *(_OWORD *)(v26 + 24) = 0u;
                    v161 = 0;
                    v160 = 0u;
                  }
                }
                else
                {
                  v30 = v132;
                  if (v24 != &stru_B8.reserved2)
                  {
                    v18 = v19;
                    goto LABEL_45;
                  }
                  v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "drawMeshThreadsArguments"));
                  v31 = v32;
                  v18 = v19;
                  if (v32)
                  {
                    objc_msgSend(v32, "threadsPerGrid");
                    v33 = v155;
                    *(_OWORD *)v26 = v154;
                    *((_QWORD *)v26 + 2) = v33;
                    objc_msgSend(v31, "threadsPerObjectThreadgroup");
                    v34 = v153;
                    *(_OWORD *)(v26 + 24) = v152;
                    *((_QWORD *)v26 + 5) = v34;
                    objc_msgSend(v31, "threadsPerMeshThreadgroup");
                    v35 = v150;
                    v36 = v151;
                  }
                  else
                  {
                    if (s_logUsingOsLog)
                    {
                      v46 = gt_default_log();
                      v47 = objc_claimAutoreleasedReturnValue(v46);
                      if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_fault_impl(&dword_0, v47, OS_LOG_TYPE_FAULT, "fail: Unable to decode MTLIndirectCommandTypeDrawMeshThreads", buf, 2u);
                      }
                    }
                    else
                    {
                      v50 = __stderrp;
                      v47 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("fail: Unable to decode MTLIndirectCommandTypeDrawMeshThreads"))));
                      fprintf(v50, "%s\n", (const char *)-[NSObject UTF8String](v47, "UTF8String"));
                    }

                    v36 = 0;
                    v155 = 0;
                    v35 = 0uLL;
                    v154 = 0u;
                    *((_QWORD *)v26 + 2) = 0;
                    *(_OWORD *)v26 = 0u;
                    v153 = 0;
                    v152 = 0u;
                    *((_QWORD *)v26 + 5) = 0;
                    *(_OWORD *)(v26 + 24) = 0u;
                    v151 = 0;
                    v150 = 0u;
                  }
                }
                *((_OWORD *)v26 + 3) = v35;
                *((_QWORD *)v26 + 8) = v36;
LABEL_44:

LABEL_45:
                v52 = (_BYTE *)v143;
                if (!*(_BYTE *)(v143 + 11))
                {
                  v53 = objc_msgSend(v21, "getPipelineStateUniqueIdentifier");
                  v54 = v116;
                  if (v53 != (id)-1)
                    v54 = v53;
                  v116 = v54;
                  *(_QWORD *)&v30[v144] = v54;
                }
                v16 = v130;
                if (!v52[10])
                {
                  v55 = *((_QWORD *)&v144 + 1);
                  if (v52[18])
                  {
                    v56 = 0;
                    v57 = &v136[*((_QWORD *)&v144 + 1) + v15];
                    do
                    {
                      if ((objc_opt_respondsToSelector(v21, v18) & 1) != 0)
                        v58 = objc_msgSend(v21, "getVertexBufferAddressAtIndex:", v56);
                      else
                        v58 = objc_msgSend(v21, "getVertexBufferAtIndex:", v56);
                      if (v58 == (id)-1)
                        v59 = 0;
                      else
                        v59 = v58;
                      if (v58 == (id)-1 && v115)
                        v59 = *(id *)&v115[8 * v56];
                      *(_QWORD *)&v57[8 * v56++] = v59;
                    }
                    while (v56 < v52[18]);
                  }
                  v60 = v145;
                  if (v52[12])
                  {
                    v61 = 0;
                    v62 = &v136[v145 + v15];
                    do
                    {
                      if ((objc_opt_respondsToSelector(v21, "getFragmentBufferAddressAtIndex:") & 1) != 0)
                        v63 = objc_msgSend(v21, "getFragmentBufferAddressAtIndex:", v61);
                      else
                        v63 = objc_msgSend(v21, "getFragmentBufferAtIndex:", v61);
                      if (v63 == (id)-1)
                        v64 = 0;
                      else
                        v64 = v63;
                      if (v63 == (id)-1 && v141)
                        v64 = *(id *)&v141[8 * v61];
                      *(_QWORD *)&v62[8 * v61++] = v64;
                    }
                    while (v61 < v52[12]);
                  }
                  v65 = *((_QWORD *)&v145 + 1);
                  if (v52[16])
                  {
                    v66 = 0;
                    v67 = &v136[*((_QWORD *)&v145 + 1) + v15];
                    do
                    {
                      if ((objc_opt_respondsToSelector(v21, "getObjectBufferAddressAtIndex:") & 1) != 0)
                      {
                        v68 = objc_msgSend(v21, "getObjectBufferAddressAtIndex:", v66);
                        if (v68 == (id)-1)
                          v69 = 0;
                        else
                          v69 = v68;
                        if (v68 == (id)-1 && context)
                          v69 = *(id *)&context[8 * v66];
                      }
                      else
                      {
                        if (GTMTLDecodeIndirectRenderCommandBuffer_onceToken != -1)
                          dispatch_once(&GTMTLDecodeIndirectRenderCommandBuffer_onceToken, &__block_literal_global_1051);
                        v69 = 0;
                      }
                      *(_QWORD *)&v67[8 * v66++] = v69;
                    }
                    while (v66 < v52[16]);
                  }
                  v30 = v132;
                  v115 = &v132[v55];
                  v141 = &v132[v60];
                  context = &v132[v65];
                  v70 = &v132[v146];
                  if (v52[15])
                  {
                    v71 = 0;
                    v72 = &v136[v146 + v15];
                    do
                    {
                      if ((objc_opt_respondsToSelector(v21, "getMeshBufferAddressAtIndex:") & 1) != 0)
                      {
                        v73 = objc_msgSend(v21, "getMeshBufferAddressAtIndex:", v71);
                        if (v73 == (id)-1)
                          v74 = 0;
                        else
                          v74 = v73;
                        if (v73 == (id)-1 && v130)
                          v74 = *(id *)&v130[8 * v71];
                      }
                      else
                      {
                        if (GTMTLDecodeIndirectRenderCommandBuffer_onceToken_33 != -1)
                          dispatch_once(&GTMTLDecodeIndirectRenderCommandBuffer_onceToken_33, &__block_literal_global_35);
                        v74 = 0;
                      }
                      *(_QWORD *)&v72[8 * v71++] = v74;
                    }
                    while (v71 < v52[15]);
                    v16 = v70;
                    v30 = v132;
                  }
                  else
                  {
                    v16 = &v132[v146];
                  }
                }
                if (v52[17])
                {
                  v75 = 0;
                  v76 = &v136[v147 + v15];
                  do
                  {
                    *(_QWORD *)&v76[8 * v75] = objc_msgSend(v21, "getObjectThreadgroupMemoryLengthAtIndex:", v75);
                    ++v75;
                  }
                  while (v75 < v52[17]);
                }
                if (v52[21])
                {
                  v77 = *((_QWORD *)&v148 + 1);
                  *(_QWORD *)&v30[v77] = objc_msgSend(v21, "hasBarrier");
                }
                v14 = v118;
                v20 = v128;
                break;
            }
          }
          else
          {
            v18 = v19;
          }

          objc_autoreleasePoolPop(v20);
          v17 = v134 + 1;
          v15 += v14;
        }
        while ((id)(v134 + 1) != v122);
      }
      v78 = objc_msgSend(v124, "copy");

      v79 = v126;
    }

    v5 = v113;
    v4 = v114;
    v6 = &CATransform3DIdentity_ptr;
    v1 = v111;
    if (v78)
    {
      v108 = v78;
      v12 = v108;
LABEL_150:

      goto LABEL_151;
    }
LABEL_149:
    v12 = (id)objc_claimAutoreleasedReturnValue(-[CATransform3D data]((id)v6[269], "data"));
    v108 = 0;
    goto LABEL_150;
  }
  v12 = v1;
LABEL_153:

  return v12;
}

void FetchResourceObjectBatch(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  os_signpost_id_t v10;
  id v11;
  void *v12;
  NSObject *v13;
  id v14;
  id v15;
  id v16;
  void *v17;
  _QWORD v18[4];
  id v19;
  id v20;
  id v21;
  id v22;
  uint64_t v23;
  os_signpost_id_t v24;
  int v25;
  uint8_t buf[4];
  int v27;
  __int16 v28;
  id v29;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, v7);
  v11 = objc_msgSend(v7, "count");
  v12 = g_signpostLog;
  v13 = v12;
  if (v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v12))
  {
    *(_DWORD *)buf = 67109376;
    v27 = 0;
    v28 = 2048;
    v29 = v11;
    _os_signpost_emit_with_name_impl(&dword_0, v13, OS_SIGNPOST_EVENT, v10, "Replayer-1-serial", "%u. kDYMessageFetchResourceObjectBatch x%lu", buf, 0x12u);
  }

  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = __FetchResourceObjectBatch_block_invoke;
  v18[3] = &unk_726460;
  v21 = v9;
  v22 = v11;
  v23 = a1;
  v24 = v10;
  v25 = 0;
  v19 = v7;
  v20 = v8;
  v14 = v8;
  v15 = v9;
  v16 = v7;
  v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v18));
  objc_msgSend(v17, "setQueuePriority:", -4);
  objc_msgSend(*(id *)(a1 + 256), "addOperation:", v17);

}

void sub_2C48D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,void *a62)
{

  _Unwind_Resume(a1);
}

void std::vector<BOOL>::resize(uint64_t a1, unint64_t a2, int a3)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t v8;
  unint64_t v9;
  unint64_t v11;
  unint64_t v12;
  void *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  void *__dst;
  __int128 v20;

  v5 = *(_QWORD *)(a1 + 8);
  v6 = a2 - v5;
  if (a2 <= v5)
  {
    *(_QWORD *)(a1 + 8) = a2;
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 16);
    v9 = v8 << 6;
    if (v8 << 6 < v6 || v5 > (v8 << 6) - v6)
    {
      __dst = 0;
      v20 = 0uLL;
      if ((a2 & 0x8000000000000000) != 0)
        abort();
      v11 = v8 << 7;
      if (v11 <= ((a2 + 63) & 0xFFFFFFFFFFFFFFC0))
        v11 = (a2 + 63) & 0xFFFFFFFFFFFFFFC0;
      if (v9 <= 0x3FFFFFFFFFFFFFFELL)
        v12 = v11;
      else
        v12 = 0x7FFFFFFFFFFFFFFFLL;
      std::vector<BOOL>::reserve((uint64_t)&__dst, v12);
      v13 = *(void **)a1;
      v14 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)&v20 = v14 + v6;
      v15 = (char *)__dst;
      if (v14 < 1)
      {
        LODWORD(v18) = 0;
        v17 = (char *)__dst;
      }
      else
      {
        v16 = v14 >> 6;
        if ((unint64_t)(v14 + 63) >= 0x7F)
          memmove(__dst, v13, 8 * v16);
        v18 = v14 - (v16 << 6);
        v17 = &v15[8 * v16];
        if (v18 < 1)
          LODWORD(v18) = 0;
        else
          *(_QWORD *)v17 = *(_QWORD *)v17 & ~(0xFFFFFFFFFFFFFFFFLL >> -(char)v18) | *((_QWORD *)v13 + v16) & (0xFFFFFFFFFFFFFFFFLL >> -(char)v18);
        v13 = *(void **)a1;
      }
      *(_QWORD *)a1 = v15;
      *(_OWORD *)(a1 + 8) = v20;
      if (v13)
        operator delete(v13);
    }
    else
    {
      v17 = (char *)(*(_QWORD *)a1 + 8 * (v5 >> 6));
      v18 = *(_QWORD *)(a1 + 8) & 0x3FLL;
      *(_QWORD *)(a1 + 8) = a2;
    }
    if (a2 != v5)
    {
      if (a3)
      {
        __dst = v17;
        LODWORD(v20) = v18;
        std::__fill_n[abi:nn180100]<true,std::vector<BOOL>>(&__dst, v6);
      }
      else
      {
        __dst = v17;
        LODWORD(v20) = v18;
        std::__fill_n[abi:nn180100]<false,std::vector<BOOL>>((uint64_t)&__dst, v6);
      }
    }
  }
}

void sub_2C54D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::vector<BOOL>::reserve(uint64_t a1, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  int v12;
  _QWORD *v13;
  int v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  __int128 v20;

  if (a2 <= *(_QWORD *)(a1 + 16) << 6)
    return;
  if ((a2 & 0x8000000000000000) != 0)
    abort();
  v19 = 0;
  v20 = 0uLL;
  std::vector<BOOL>::__vallocate[abi:nn180100](&v19, a2);
  v3 = *(_QWORD **)a1;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = v20;
  v6 = v20 + v4;
  *(_QWORD *)&v20 = v20 + v4;
  if (!v5)
  {
    v7 = v6 - 1;
    goto LABEL_7;
  }
  v7 = v6 - 1;
  if (((v6 - 1) ^ (v5 - 1)) > 0x3F)
  {
LABEL_7:
    v8 = v19;
    v9 = v7 >> 6;
    if (v6 >= 0x41)
      v10 = v9;
    else
      v10 = 0;
    *(_QWORD *)(v19 + 8 * v10) = 0;
    goto LABEL_11;
  }
  v8 = v19;
LABEL_11:
  v11 = v4 & 0x3F;
  if (v4 > 0x3F || (v4 & 0x3F) != 0)
  {
    v12 = 0;
    v13 = &v3[v4 >> 6];
    v14 = v5 & 0x3F;
    v15 = (uint64_t *)(v8 + 8 * (v5 >> 6));
    do
    {
      v16 = 1 << v14;
      if (((*v3 >> v12) & 1) != 0)
        v17 = *v15 | v16;
      else
        v17 = *v15 & ~v16;
      *v15 = v17;
      v3 += v12 == 63;
      if (v12 == 63)
        v12 = 0;
      else
        ++v12;
      v15 += v14 == 63;
      if (v14 == 63)
        v14 = 0;
      else
        ++v14;
    }
    while (v3 != v13 || v12 != v11);
  }
  v18 = *(_QWORD **)a1;
  *(_QWORD *)a1 = v8;
  *(_OWORD *)(a1 + 8) = v20;
  if (v18)
    operator delete(v18);
}

void sub_2C561C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *,false>(unint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  uint64_t v7;
  int *v8;
  unint64_t i;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  int *v15;
  int *v16;
  int v17;
  __int128 v18;
  int v19;
  int v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t k;
  int v26;
  unint64_t v27;
  int v28;
  unint64_t m;
  unint64_t v30;
  int v31;
  int v32;
  unint64_t v33;
  int v35;
  int v36;
  unint64_t v37;
  __int128 v38;
  int v39;
  unint64_t v40;
  int v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  int v45;
  int v46;
  int v47;
  unint64_t v48;
  unint64_t j;
  unint64_t v50;
  int v51;
  int v52;
  int v53;
  __int128 v54;
  int v55;
  unint64_t v56;
  int v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  int v61;
  int v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  BOOL v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  int v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int64_t v83;
  int64_t v84;
  int64_t v85;
  uint64_t v86;
  unint64_t v87;
  int v88;
  unint64_t v89;
  int v90;
  int v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  int v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  uint64_t v103;
  uint64_t v104;
  _OWORD *n;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  _OWORD *ii;
  unint64_t v113;
  _OWORD *v114;
  int64_t v115;
  uint64_t v116;
  int v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  int64_t v124;
  int v125;
  unint64_t v126;
  unint64_t v127;
  uint64_t v128;
  unint64_t v129;
  unint64_t v130;
  unint64_t v131;
  int v132;
  int v133;
  unint64_t v134;
  unint64_t v135;
  uint64_t v136;
  unint64_t v137;
  unint64_t v138;
  int v139;
  unint64_t v140;
  uint64_t v141;

  v7 = result;
LABEL_2:
  v8 = (int *)(a2 - 24);
  i = v7;
  while (2)
  {
    v7 = i;
    v10 = a2 - i;
    v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2 - i) >> 3);
    switch(v11)
    {
      case 0:
      case 1:
        return result;
      case 2:
        v61 = *v8;
        v62 = *(_DWORD *)i;
        if (*v8 >= *(_DWORD *)i)
        {
          if (v62 < v61)
            return result;
          v64 = *(_QWORD *)(a2 - 16);
          v63 = *(_QWORD *)(i + 8);
          if (v64 >= v63 && (v63 < v64 || *(_QWORD *)(a2 - 8) >= *(_QWORD *)(i + 16)))
            return result;
        }
        else
        {
          v63 = *(_QWORD *)(i + 8);
          v64 = *(_QWORD *)(a2 - 16);
        }
        *(_DWORD *)i = v61;
        *(_DWORD *)(a2 - 24) = v62;
        v103 = *(_QWORD *)(i + 16);
        v104 = *(_QWORD *)(a2 - 8);
        *(_QWORD *)(i + 8) = v64;
        *(_QWORD *)(i + 16) = v104;
        *(_QWORD *)(a2 - 16) = v63;
        *(_QWORD *)(a2 - 8) = v103;
        return result;
      case 3:
        return (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>((int *)i, (int *)(i + 24), (int *)(a2 - 24));
      case 4:
        return (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>(i, i + 24, i + 48, a2 - 24);
      case 5:
        return (unint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>(i, i + 24, i + 48, i + 72, (int *)(a2 - 24));
      default:
        if (v10 > 575)
        {
          if (!a3)
          {
            if (i == a2)
              return result;
            v83 = (unint64_t)(v11 - 2) >> 1;
            v84 = v83;
            while (1)
            {
              v85 = v84;
              if (v83 >= v84)
              {
                v86 = (2 * v84) | 1;
                v87 = i + 24 * v86;
                if (2 * v85 + 2 < v11)
                {
                  v88 = *(_DWORD *)(v87 + 24);
                  if (*(_DWORD *)v87 < v88
                    || v88 >= *(_DWORD *)v87
                    && ((v101 = *(_QWORD *)(v87 + 8), v102 = *(_QWORD *)(v87 + 32), v101 < v102)
                     || v102 >= v101 && *(_QWORD *)(v87 + 16) < *(_QWORD *)(v87 + 40)))
                  {
                    v87 += 24;
                    v86 = 2 * v85 + 2;
                  }
                }
                v89 = i + 24 * v85;
                v90 = *(_DWORD *)v87;
                v91 = *(_DWORD *)v89;
                if (*(_DWORD *)v87 >= *(_DWORD *)v89)
                {
                  if (v91 < v90)
                  {
                    v92 = *(_QWORD *)(v89 + 8);
                    v93 = *(_QWORD *)(v87 + 8);
LABEL_156:
                    v94 = *(_QWORD *)(v89 + 16);
                    do
                    {
                      *(_DWORD *)v89 = v90;
                      v95 = *(_QWORD *)(v87 + 16);
                      *(_QWORD *)(v89 + 8) = v93;
                      *(_QWORD *)(v89 + 16) = v95;
                      if (v83 < v86)
                        goto LABEL_171;
                      v89 = v87;
                      v96 = 2 * v86;
                      v86 = (2 * v86) | 1;
                      v87 = i + 24 * v86;
                      v97 = v96 + 2;
                      if (v97 < v11)
                      {
                        v98 = *(_DWORD *)(v87 + 24);
                        if (*(_DWORD *)v87 < v98
                          || v98 >= *(_DWORD *)v87
                          && ((v99 = *(_QWORD *)(v87 + 8), v100 = *(_QWORD *)(v87 + 32), v99 < v100)
                           || v100 >= v99 && *(_QWORD *)(v87 + 16) < *(_QWORD *)(v87 + 40)))
                        {
                          v87 += 24;
                          v86 = v97;
                        }
                      }
                      v90 = *(_DWORD *)v87;
                      if (*(_DWORD *)v87 < v91)
                        break;
                      v93 = *(_QWORD *)(v87 + 8);
                    }
                    while (v91 < v90 || v93 >= v92 && (v92 < v93 || *(_QWORD *)(v87 + 16) >= v94));
                    v87 = v89;
LABEL_171:
                    *(_DWORD *)v87 = v91;
                    *(_QWORD *)(v87 + 8) = v92;
                    *(_QWORD *)(v87 + 16) = v94;
                    goto LABEL_173;
                  }
                  v93 = *(_QWORD *)(v87 + 8);
                  v92 = *(_QWORD *)(v89 + 8);
                  if (v93 >= v92 && (v92 < v93 || *(_QWORD *)(v87 + 16) >= *(_QWORD *)(v89 + 16)))
                    goto LABEL_156;
                }
              }
LABEL_173:
              v84 = v85 - 1;
              if (!v85)
              {
                v115 = v10 / 0x18uLL;
                while (1)
                {
                  v116 = 0;
                  v117 = *(_DWORD *)i;
                  v118 = *(_QWORD *)(i + 8);
                  v119 = *(_QWORD *)(i + 16);
                  v120 = v115 - 2;
                  if (v115 < 2)
                    v120 = v115 - 1;
                  v121 = v120 >> 1;
                  v122 = i;
                  do
                  {
                    result = v122;
                    v122 += 24 * v116 + 24;
                    v123 = 2 * v116;
                    v116 = (2 * v116) | 1;
                    v124 = v123 + 2;
                    if (v124 < v115)
                    {
                      v125 = *(_DWORD *)(v122 + 24);
                      if (*(_DWORD *)v122 < v125
                        || v125 >= *(_DWORD *)v122
                        && ((v126 = *(_QWORD *)(v122 + 8), v127 = *(_QWORD *)(v122 + 32), v126 < v127)
                         || v127 >= v126 && *(_QWORD *)(v122 + 16) < *(_QWORD *)(v122 + 40)))
                      {
                        v122 += 24;
                        v116 = v124;
                      }
                    }
                    *(_DWORD *)result = *(_DWORD *)v122;
                    *(_OWORD *)(result + 8) = *(_OWORD *)(v122 + 8);
                  }
                  while (v116 <= v121);
                  if (v122 == a2 - 24)
                  {
                    *(_DWORD *)v122 = v117;
                    *(_QWORD *)(v122 + 8) = v118;
                    *(_QWORD *)(v122 + 16) = v119;
                    goto LABEL_236;
                  }
                  *(_DWORD *)v122 = *(_DWORD *)(a2 - 24);
                  *(_OWORD *)(v122 + 8) = *(_OWORD *)(a2 - 16);
                  *(_DWORD *)(a2 - 24) = v117;
                  *(_QWORD *)(a2 - 16) = v118;
                  *(_QWORD *)(a2 - 8) = v119;
                  v128 = v122 - i + 24;
                  if (v128 < 25)
                    goto LABEL_236;
                  v129 = 0xAAAAAAAAAAAAAAABLL * (v128 >> 3) - 2;
                  v130 = v129 >> 1;
                  v131 = i + 24 * (v129 >> 1);
                  v132 = *(_DWORD *)v131;
                  v133 = *(_DWORD *)v122;
                  if (*(_DWORD *)v131 >= *(_DWORD *)v122)
                  {
                    if (v133 < v132)
                      goto LABEL_236;
                    v135 = *(_QWORD *)(v131 + 8);
                    v134 = *(_QWORD *)(v122 + 8);
                    if (v135 >= v134)
                    {
                      if (v134 < v135)
                        goto LABEL_236;
                      result = *(_QWORD *)(v131 + 16);
                      if (result >= *(_QWORD *)(v122 + 16))
                        goto LABEL_236;
                    }
                  }
                  else
                  {
                    v134 = *(_QWORD *)(v122 + 8);
                    v135 = *(_QWORD *)(v131 + 8);
                  }
                  result = *(_QWORD *)(v122 + 16);
                  *(_DWORD *)v122 = v132;
                  v136 = *(_QWORD *)(v131 + 16);
                  *(_QWORD *)(v122 + 8) = v135;
                  *(_QWORD *)(v122 + 16) = v136;
                  if (v129 < 2)
                    goto LABEL_235;
                  while (1)
                  {
                    v137 = v131;
                    v138 = v130 - 1;
                    v130 = (v130 - 1) >> 1;
                    v131 = i + 24 * v130;
                    v139 = *(_DWORD *)v131;
                    if (*(_DWORD *)v131 >= v133)
                      break;
                    v140 = *(_QWORD *)(v131 + 8);
LABEL_232:
                    *(_DWORD *)v137 = v139;
                    v141 = *(_QWORD *)(v131 + 16);
                    *(_QWORD *)(v137 + 8) = v140;
                    *(_QWORD *)(v137 + 16) = v141;
                    if (v138 <= 1)
                      goto LABEL_235;
                  }
                  if (v133 >= v139)
                  {
                    v140 = *(_QWORD *)(v131 + 8);
                    if (v140 < v134 || v134 >= v140 && *(_QWORD *)(v131 + 16) < result)
                      goto LABEL_232;
                  }
                  v131 = v137;
LABEL_235:
                  *(_DWORD *)v131 = v133;
                  *(_QWORD *)(v131 + 8) = v134;
                  *(_QWORD *)(v131 + 16) = result;
LABEL_236:
                  a2 -= 24;
                  if (v115-- <= 2)
                    return result;
                }
              }
            }
          }
          v12 = (unint64_t)v11 >> 1;
          v13 = i + 24 * ((unint64_t)v11 >> 1);
          if ((unint64_t)v10 < 0xC01)
          {
            result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>((int *)(v7 + 24 * v12), (int *)v7, (int *)(a2 - 24));
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>((int *)v7, (int *)(v7 + 24 * v12), (int *)(a2 - 24));
            v14 = 3 * v12;
            v15 = (int *)(v7 + 24 * v12 - 24);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>((int *)(v7 + 24), v15, (int *)(a2 - 48));
            v16 = (int *)(v7 + 24 + 8 * v14);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>((int *)(v7 + 48), v16, (int *)(a2 - 72));
            result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>(v15, (int *)v13, v16);
            v17 = *(_DWORD *)v7;
            *(_DWORD *)v7 = *(_DWORD *)v13;
            *(_DWORD *)v13 = v17;
            v18 = *(_OWORD *)(v7 + 8);
            *(_OWORD *)(v7 + 8) = *(_OWORD *)(v13 + 8);
            *(_OWORD *)(v13 + 8) = v18;
          }
          --a3;
          v19 = *(_DWORD *)v7;
          if ((a4 & 1) == 0)
          {
            v20 = *(_DWORD *)(v7 - 24);
            if (v20 >= v19)
            {
              if (v19 < v20)
              {
                v22 = *(_QWORD *)(v7 + 8);
              }
              else
              {
                v21 = *(_QWORD *)(v7 - 16);
                v22 = *(_QWORD *)(v7 + 8);
                if (v21 < v22 || v22 >= v21 && *(_QWORD *)(v7 - 8) < *(_QWORD *)(v7 + 16))
                  goto LABEL_15;
              }
              v44 = *(_QWORD *)(v7 + 16);
              v45 = *v8;
              if (v19 < *v8
                || v45 >= v19 && ((v60 = *(_QWORD *)(a2 - 16), v22 < v60) || v60 >= v22 && v44 < *(_QWORD *)(a2 - 8)))
              {
                i = v7;
                while (1)
                {
                  v47 = *(_DWORD *)(i + 24);
                  i += 24;
                  v46 = v47;
                  if (v19 < v47)
                    break;
                  if (v46 >= v19)
                  {
                    v48 = *(_QWORD *)(i + 8);
                    if (v22 < v48 || v48 >= v22 && v44 < *(_QWORD *)(i + 16))
                      break;
                  }
                }
              }
              else
              {
                for (i = v7 + 24; i < a2; i += 24)
                {
                  if (v19 < *(_DWORD *)i)
                    break;
                  if (*(_DWORD *)i >= v19)
                  {
                    v59 = *(_QWORD *)(i + 8);
                    if (v22 < v59 || v59 >= v22 && v44 < *(_QWORD *)(i + 16))
                      break;
                  }
                }
              }
              j = a2;
              if (i < a2)
              {
                for (j = a2 - 24; ; j -= 24)
                {
                  if (v19 >= v45)
                  {
                    if (v45 < v19)
                      break;
                    v50 = *(_QWORD *)(j + 8);
                    if (v22 >= v50 && (v50 < v22 || v44 >= *(_QWORD *)(j + 16)))
                      break;
                  }
                  v51 = *(_DWORD *)(j - 24);
                  v45 = v51;
                }
              }
              if (i < j)
              {
                v52 = *(_DWORD *)i;
                v53 = *(_DWORD *)j;
                do
                {
                  *(_DWORD *)i = v53;
                  *(_DWORD *)j = v52;
                  v54 = *(_OWORD *)(i + 8);
                  *(_OWORD *)(i + 8) = *(_OWORD *)(j + 8);
                  *(_OWORD *)(j + 8) = v54;
                  while (1)
                  {
                    v55 = *(_DWORD *)(i + 24);
                    i += 24;
                    v52 = v55;
                    if (v19 < v55)
                      break;
                    if (v52 >= v19)
                    {
                      v56 = *(_QWORD *)(i + 8);
                      if (v22 < v56 || v56 >= v22 && v44 < *(_QWORD *)(i + 16))
                        break;
                    }
                  }
                  do
                  {
                    do
                    {
                      v57 = *(_DWORD *)(j - 24);
                      j -= 24;
                      v53 = v57;
                    }
                    while (v19 < v57);
                    if (v53 < v19)
                      break;
                    v58 = *(_QWORD *)(j + 8);
                  }
                  while (v22 < v58 || v58 >= v22 && v44 < *(_QWORD *)(j + 16));
                }
                while (i < j);
              }
              if (i - 24 != v7)
              {
                *(_DWORD *)v7 = *(_DWORD *)(i - 24);
                *(_OWORD *)(v7 + 8) = *(_OWORD *)(i - 16);
              }
              a4 = 0;
              *(_DWORD *)(i - 24) = v19;
              *(_QWORD *)(i - 16) = v22;
              *(_QWORD *)(i - 8) = v44;
              continue;
            }
          }
LABEL_15:
          v23 = *(_QWORD *)(v7 + 8);
          v24 = *(_QWORD *)(v7 + 16);
          for (k = v7 + 24; ; k += 24)
          {
            v26 = *(_DWORD *)k;
            if (*(_DWORD *)k >= v19)
            {
              if (v19 < v26)
                break;
              v27 = *(_QWORD *)(k + 8);
              if (v27 >= v23 && (v23 < v27 || *(_QWORD *)(k + 16) >= v24))
                break;
            }
          }
          if (k - 24 == v7)
          {
            m = a2;
            if (k < a2)
            {
              v32 = *v8;
              m = a2 - 24;
              if (*v8 >= v19)
              {
                m = a2 - 24;
                do
                {
                  if (v19 < v32)
                    goto LABEL_36;
                  v33 = *(_QWORD *)(m + 8);
                  if (v33 < v23)
                    break;
                  if (v23 >= v33)
                  {
                    if (*(_QWORD *)(m + 16) < v24 || k >= m)
                      break;
                  }
                  else
                  {
LABEL_36:
                    if (k >= m)
                      break;
                  }
                  v35 = *(_DWORD *)(m - 24);
                  m -= 24;
                  v32 = v35;
                }
                while (v35 >= v19);
              }
            }
          }
          else
          {
            v28 = *v8;
            for (m = a2 - 24; v28 >= v19; m -= 24)
            {
              if (v19 >= v28)
              {
                v30 = *(_QWORD *)(m + 8);
                if (v30 < v23 || v23 >= v30 && *(_QWORD *)(m + 16) < v24)
                  break;
              }
              v31 = *(_DWORD *)(m - 24);
              v28 = v31;
            }
          }
          i = k;
          if (k < m)
          {
            v36 = *(_DWORD *)m;
            i = k;
            v37 = m;
            do
            {
              *(_DWORD *)i = v36;
              *(_DWORD *)v37 = v26;
              v38 = *(_OWORD *)(i + 8);
              *(_OWORD *)(i + 8) = *(_OWORD *)(v37 + 8);
              *(_OWORD *)(v37 + 8) = v38;
              do
              {
                do
                {
                  v39 = *(_DWORD *)(i + 24);
                  i += 24;
                  v26 = v39;
                }
                while (v39 < v19);
                if (v19 < v26)
                  break;
                v40 = *(_QWORD *)(i + 8);
              }
              while (v40 < v23 || v23 >= v40 && *(_QWORD *)(i + 16) < v24);
              while (1)
              {
                v41 = *(_DWORD *)(v37 - 24);
                v37 -= 24;
                v36 = v41;
                if (v41 < v19)
                  break;
                if (v19 >= v36)
                {
                  v42 = *(_QWORD *)(v37 + 8);
                  if (v42 < v23 || v23 >= v42 && *(_QWORD *)(v37 + 16) < v24)
                    break;
                }
              }
            }
            while (i < v37);
          }
          if (i - 24 != v7)
          {
            *(_DWORD *)v7 = *(_DWORD *)(i - 24);
            *(_OWORD *)(v7 + 8) = *(_OWORD *)(i - 16);
          }
          *(_DWORD *)(i - 24) = v19;
          *(_QWORD *)(i - 16) = v23;
          *(_QWORD *)(i - 8) = v24;
          if (k < m)
          {
LABEL_62:
            result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *,false>(v7, i - 24, a3, a4 & 1);
            a4 = 0;
            continue;
          }
          v43 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>(v7, i - 24);
          result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>(i, a2);
          if (!(_DWORD)result)
          {
            if (v43)
              continue;
            goto LABEL_62;
          }
          a2 = i - 24;
          if (v43)
            return result;
          goto LABEL_2;
        }
        v65 = i + 24;
        v67 = i == a2 || v65 == a2;
        if ((a4 & 1) == 0)
        {
          if (v67)
            return result;
          for (n = (_OWORD *)(i + 32); ; n = (_OWORD *)((char *)n + 24))
          {
            v106 = v7;
            v7 = v65;
            v107 = *(_DWORD *)(v106 + 24);
            v108 = *(_DWORD *)v106;
            if (v107 < *(_DWORD *)v106)
              break;
            if (v108 >= v107)
            {
              v109 = *(_QWORD *)(v106 + 32);
              v110 = *(_QWORD *)(v106 + 8);
              if (v109 < v110 || v110 >= v109 && *(_QWORD *)(v106 + 40) < *(_QWORD *)(v106 + 16))
                goto LABEL_195;
            }
LABEL_203:
            v65 = v7 + 24;
            if (v7 + 24 == a2)
              return result;
          }
          v109 = *(_QWORD *)(v106 + 32);
LABEL_195:
          v111 = *(_QWORD *)(v106 + 40);
          for (ii = n; ; ii = (_OWORD *)((char *)ii - 24))
          {
            *((_DWORD *)ii - 2) = v108;
            *ii = *(_OWORD *)((char *)ii - 24);
            v108 = *((_DWORD *)ii - 14);
            if (v107 >= v108)
            {
              if (v108 < v107)
                break;
              v113 = *((_QWORD *)ii - 6);
              if (v109 >= v113 && (v113 < v109 || v111 >= *((_QWORD *)ii - 5)))
                break;
            }
          }
          v114 = ii - 2;
          *((_DWORD *)ii - 8) = v107;
          *((_QWORD *)v114 + 1) = v109;
          *((_QWORD *)v114 + 2) = v111;
          goto LABEL_203;
        }
        if (v67)
          return result;
        v68 = 0;
        v69 = i;
        do
        {
          v70 = v69;
          v69 = v65;
          v71 = *(_DWORD *)(v70 + 24);
          v72 = *(_DWORD *)v70;
          if (v71 >= *(_DWORD *)v70)
          {
            if (v72 < v71)
              goto LABEL_144;
            v73 = *(_QWORD *)(v70 + 32);
            v74 = *(_QWORD *)(v70 + 8);
            if (v73 >= v74 && (v74 < v73 || *(_QWORD *)(v70 + 40) >= *(_QWORD *)(v70 + 16)))
              goto LABEL_144;
          }
          else
          {
            v73 = *(_QWORD *)(v70 + 32);
            v74 = *(_QWORD *)(v70 + 8);
          }
          v75 = *(_QWORD *)(v70 + 40);
          *(_DWORD *)(v70 + 24) = v72;
          v76 = *(_QWORD *)(v70 + 16);
          *(_QWORD *)(v69 + 8) = v74;
          *(_QWORD *)(v69 + 16) = v76;
          v77 = i;
          if (v70 == i)
            goto LABEL_143;
          v78 = v68;
          while (1)
          {
            v79 = *(_DWORD *)(i + v78 - 24);
            if (v71 < v79)
            {
              v80 = *(_QWORD *)(i + v78 - 16);
              goto LABEL_140;
            }
            if (v79 < v71)
              goto LABEL_142;
            v80 = *(_QWORD *)(i + v78 - 16);
            if (v73 >= v80)
              break;
LABEL_140:
            v70 -= 24;
            v81 = i + v78;
            *(_DWORD *)v81 = v79;
            v82 = *(_QWORD *)(i + v78 - 8);
            *(_QWORD *)(v81 + 8) = v80;
            *(_QWORD *)(v81 + 16) = v82;
            v78 -= 24;
            if (!v78)
            {
              v77 = i;
              goto LABEL_143;
            }
          }
          if (v80 >= v73)
          {
            v77 = i + v78;
            result = *(_QWORD *)(i + v78 - 8);
            if (v75 >= result)
              goto LABEL_143;
            goto LABEL_140;
          }
LABEL_142:
          v77 = v70;
LABEL_143:
          *(_DWORD *)v77 = v71;
          *(_QWORD *)(v77 + 8) = v73;
          *(_QWORD *)(v77 + 16) = v75;
LABEL_144:
          v65 = v69 + 24;
          v68 += 24;
        }
        while (v69 + 24 != a2);
        return result;
    }
  }
}

int *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>(int *result, int *a2, int *a3)
{
  int v3;
  int v4;
  int v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v3 = *a2;
  v4 = *result;
  if (*a2 < *result
    || v4 >= v3
    && ((v13 = *((_QWORD *)a2 + 1), v14 = *((_QWORD *)result + 1), v13 < v14)
     || v14 >= v13 && *((_QWORD *)a2 + 2) < *((_QWORD *)result + 2)))
  {
    v5 = *a3;
    if (*a3 < v3)
    {
      v6 = *((_QWORD *)a3 + 1);
LABEL_4:
      *result = v5;
      *a3 = v4;
      v7 = *((_QWORD *)a3 + 2);
      v8 = *(_OWORD *)(result + 2);
      *((_QWORD *)result + 1) = v6;
      *((_QWORD *)result + 2) = v7;
      *(_OWORD *)(a3 + 2) = v8;
      return result;
    }
    if (v3 >= v5)
    {
      v6 = *((_QWORD *)a3 + 1);
      v12 = *((_QWORD *)a2 + 1);
      if (v6 < v12 || v12 >= v6 && *((_QWORD *)a3 + 2) < *((_QWORD *)a2 + 2))
        goto LABEL_4;
    }
    else
    {
      v12 = *((_QWORD *)a2 + 1);
    }
    *result = v3;
    *a2 = v4;
    v21 = *((_QWORD *)result + 1);
    v22 = *((_QWORD *)result + 2);
    v23 = *((_QWORD *)a2 + 2);
    *((_QWORD *)result + 1) = v12;
    *((_QWORD *)result + 2) = v23;
    *((_QWORD *)a2 + 1) = v21;
    *((_QWORD *)a2 + 2) = v22;
    v24 = *a3;
    if (*a3 >= v4)
    {
      if (v4 < v24)
        return result;
      v25 = *((_QWORD *)a3 + 1);
      if (v25 >= v21 && (v21 < v25 || *((_QWORD *)a3 + 2) >= v22))
        return result;
    }
    else
    {
      v25 = *((_QWORD *)a3 + 1);
    }
    *a2 = v24;
    *a3 = v4;
    v28 = *((_QWORD *)a3 + 2);
    *((_QWORD *)a2 + 1) = v25;
    *((_QWORD *)a2 + 2) = v28;
    *((_QWORD *)a3 + 1) = v21;
    *((_QWORD *)a3 + 2) = v22;
    return result;
  }
  v9 = *a3;
  if (*a3 >= v3)
  {
    if (v3 < v9)
      return result;
    v11 = *((_QWORD *)a3 + 1);
    v10 = *((_QWORD *)a2 + 1);
    if (v11 >= v10 && (v10 < v11 || *((_QWORD *)a3 + 2) >= *((_QWORD *)a2 + 2)))
      return result;
  }
  else
  {
    v10 = *((_QWORD *)a2 + 1);
    v11 = *((_QWORD *)a3 + 1);
  }
  *a2 = v9;
  *a3 = v3;
  v15 = *((_QWORD *)a2 + 2);
  v16 = *((_QWORD *)a3 + 2);
  *((_QWORD *)a2 + 1) = v11;
  *((_QWORD *)a2 + 2) = v16;
  *((_QWORD *)a3 + 1) = v10;
  *((_QWORD *)a3 + 2) = v15;
  v17 = *a2;
  v18 = *result;
  if (*a2 < *result)
  {
    v19 = *((_QWORD *)result + 1);
    v20 = *((_QWORD *)a2 + 1);
LABEL_29:
    *result = v17;
    *a2 = v18;
    v26 = *((_QWORD *)result + 2);
    v27 = *((_QWORD *)a2 + 2);
    *((_QWORD *)result + 1) = v20;
    *((_QWORD *)result + 2) = v27;
    *((_QWORD *)a2 + 1) = v19;
    *((_QWORD *)a2 + 2) = v26;
    return result;
  }
  if (v18 >= v17)
  {
    v20 = *((_QWORD *)a2 + 1);
    v19 = *((_QWORD *)result + 1);
    if (v20 < v19 || v19 >= v20 && *((_QWORD *)a2 + 2) < *((_QWORD *)result + 2))
      goto LABEL_29;
  }
  return result;
}

int *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int *result;
  int v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;

  result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>((int *)a1, (int *)a2, (int *)a3);
  v9 = *(_DWORD *)a4;
  v10 = *(_DWORD *)a3;
  if (*(_DWORD *)a4 >= *(_DWORD *)a3)
  {
    if (v10 < v9)
      return result;
    v12 = *(_QWORD *)(a4 + 8);
    v11 = *(_QWORD *)(a3 + 8);
    if (v12 >= v11 && (v11 < v12 || *(_QWORD *)(a4 + 16) >= *(_QWORD *)(a3 + 16)))
      return result;
  }
  else
  {
    v11 = *(_QWORD *)(a3 + 8);
    v12 = *(_QWORD *)(a4 + 8);
  }
  *(_DWORD *)a3 = v9;
  *(_DWORD *)a4 = v10;
  v13 = *(_QWORD *)(a3 + 16);
  v14 = *(_QWORD *)(a4 + 16);
  *(_QWORD *)(a3 + 8) = v12;
  *(_QWORD *)(a3 + 16) = v14;
  *(_QWORD *)(a4 + 8) = v11;
  *(_QWORD *)(a4 + 16) = v13;
  v15 = *(_DWORD *)a3;
  v16 = *(_DWORD *)a2;
  if (*(_DWORD *)a3 >= *(_DWORD *)a2)
  {
    if (v16 < v15)
      return result;
    v18 = *(_QWORD *)(a3 + 8);
    v17 = *(_QWORD *)(a2 + 8);
    if (v18 >= v17 && (v17 < v18 || *(_QWORD *)(a3 + 16) >= *(_QWORD *)(a2 + 16)))
      return result;
  }
  else
  {
    v17 = *(_QWORD *)(a2 + 8);
    v18 = *(_QWORD *)(a3 + 8);
  }
  *(_DWORD *)a2 = v15;
  *(_DWORD *)a3 = v16;
  v19 = *(_QWORD *)(a2 + 16);
  v20 = *(_QWORD *)(a3 + 16);
  *(_QWORD *)(a2 + 8) = v18;
  *(_QWORD *)(a2 + 16) = v20;
  *(_QWORD *)(a3 + 8) = v17;
  *(_QWORD *)(a3 + 16) = v19;
  v21 = *(_DWORD *)a2;
  v22 = *(_DWORD *)a1;
  if (*(_DWORD *)a2 < *(_DWORD *)a1)
  {
    v23 = *(_QWORD *)(a1 + 8);
    v24 = *(_QWORD *)(a2 + 8);
LABEL_19:
    *(_DWORD *)a1 = v21;
    *(_DWORD *)a2 = v22;
    v25 = *(_QWORD *)(a1 + 16);
    v26 = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a1 + 8) = v24;
    *(_QWORD *)(a1 + 16) = v26;
    *(_QWORD *)(a2 + 8) = v23;
    *(_QWORD *)(a2 + 16) = v25;
    return result;
  }
  if (v22 >= v21)
  {
    v24 = *(_QWORD *)(a2 + 8);
    v23 = *(_QWORD *)(a1 + 8);
    if (v24 < v23 || v23 >= v24 && *(_QWORD *)(a2 + 16) < *(_QWORD *)(a1 + 16))
      goto LABEL_19;
  }
  return result;
}

int *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5)
{
  int *result;
  int v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;

  result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>(a1, a2, a3, a4);
  v11 = *a5;
  v12 = *(_DWORD *)a4;
  if (*a5 >= *(_DWORD *)a4)
  {
    if (v12 < v11)
      return result;
    v14 = *((_QWORD *)a5 + 1);
    v13 = *(_QWORD *)(a4 + 8);
    if (v14 >= v13 && (v13 < v14 || *((_QWORD *)a5 + 2) >= *(_QWORD *)(a4 + 16)))
      return result;
  }
  else
  {
    v13 = *(_QWORD *)(a4 + 8);
    v14 = *((_QWORD *)a5 + 1);
  }
  *(_DWORD *)a4 = v11;
  *a5 = v12;
  v15 = *(_QWORD *)(a4 + 16);
  v16 = *((_QWORD *)a5 + 2);
  *(_QWORD *)(a4 + 8) = v14;
  *(_QWORD *)(a4 + 16) = v16;
  *((_QWORD *)a5 + 1) = v13;
  *((_QWORD *)a5 + 2) = v15;
  v17 = *(_DWORD *)a4;
  v18 = *(_DWORD *)a3;
  if (*(_DWORD *)a4 >= *(_DWORD *)a3)
  {
    if (v18 < v17)
      return result;
    v20 = *(_QWORD *)(a4 + 8);
    v19 = *(_QWORD *)(a3 + 8);
    if (v20 >= v19 && (v19 < v20 || *(_QWORD *)(a4 + 16) >= *(_QWORD *)(a3 + 16)))
      return result;
  }
  else
  {
    v19 = *(_QWORD *)(a3 + 8);
    v20 = *(_QWORD *)(a4 + 8);
  }
  *(_DWORD *)a3 = v17;
  *(_DWORD *)a4 = v18;
  v21 = *(_QWORD *)(a3 + 16);
  v22 = *(_QWORD *)(a4 + 16);
  *(_QWORD *)(a3 + 8) = v20;
  *(_QWORD *)(a3 + 16) = v22;
  *(_QWORD *)(a4 + 8) = v19;
  *(_QWORD *)(a4 + 16) = v21;
  v23 = *(_DWORD *)a3;
  v24 = *(_DWORD *)a2;
  if (*(_DWORD *)a3 >= *(_DWORD *)a2)
  {
    if (v24 < v23)
      return result;
    v26 = *(_QWORD *)(a3 + 8);
    v25 = *(_QWORD *)(a2 + 8);
    if (v26 >= v25 && (v25 < v26 || *(_QWORD *)(a3 + 16) >= *(_QWORD *)(a2 + 16)))
      return result;
  }
  else
  {
    v25 = *(_QWORD *)(a2 + 8);
    v26 = *(_QWORD *)(a3 + 8);
  }
  *(_DWORD *)a2 = v23;
  *(_DWORD *)a3 = v24;
  v27 = *(_QWORD *)(a2 + 16);
  v28 = *(_QWORD *)(a3 + 16);
  *(_QWORD *)(a2 + 8) = v26;
  *(_QWORD *)(a2 + 16) = v28;
  *(_QWORD *)(a3 + 8) = v25;
  *(_QWORD *)(a3 + 16) = v27;
  v29 = *(_DWORD *)a2;
  v30 = *(_DWORD *)a1;
  if (*(_DWORD *)a2 < *(_DWORD *)a1)
  {
    v31 = *(_QWORD *)(a1 + 8);
    v32 = *(_QWORD *)(a2 + 8);
LABEL_26:
    *(_DWORD *)a1 = v29;
    *(_DWORD *)a2 = v30;
    v33 = *(_QWORD *)(a1 + 16);
    v34 = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a1 + 8) = v32;
    *(_QWORD *)(a1 + 16) = v34;
    *(_QWORD *)(a2 + 8) = v31;
    *(_QWORD *)(a2 + 16) = v33;
    return result;
  }
  if (v30 >= v29)
  {
    v32 = *(_QWORD *)(a2 + 8);
    v31 = *(_QWORD *)(a1 + 8);
    if (v32 < v31 || v31 >= v32 && *(_QWORD *)(a2 + 16) < *(_QWORD *)(a1 + 16))
      goto LABEL_26;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _BOOL8 result;
  int v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v4 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v6 = *(_DWORD *)(a2 - 24);
      v7 = *(_DWORD *)a1;
      if (v6 < *(_DWORD *)a1)
      {
        v8 = *(_QWORD *)(a1 + 8);
        v9 = *(_QWORD *)(a2 - 16);
LABEL_4:
        *(_DWORD *)a1 = v6;
        *(_DWORD *)(a2 - 24) = v7;
        v10 = *(_QWORD *)(a1 + 16);
        v11 = *(_QWORD *)(a2 - 8);
        *(_QWORD *)(a1 + 8) = v9;
        *(_QWORD *)(a1 + 16) = v11;
        *(_QWORD *)(a2 - 16) = v8;
        *(_QWORD *)(a2 - 8) = v10;
        return result;
      }
      if (v7 >= v6)
      {
        v9 = *(_QWORD *)(a2 - 16);
        v8 = *(_QWORD *)(a1 + 8);
        if (v9 < v8 || v8 >= v9 && *(_QWORD *)(a2 - 8) < *(_QWORD *)(a1 + 16))
          goto LABEL_4;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>((int *)a1, (int *)(a1 + 24), (int *)(a2 - 24));
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>(a1, a1 + 24, a1 + 48, a2 - 24);
      return 1;
    case 5uLL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>(a1, a1 + 24, a1 + 48, a1 + 72, (int *)(a2 - 24));
      return 1;
    default:
      v12 = a1 + 48;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>((int *)a1, (int *)(a1 + 24), (int *)(a1 + 48));
      v13 = a1 + 72;
      if (a1 + 72 == a2)
        return 1;
      v14 = 0;
      v15 = 0;
      break;
  }
LABEL_8:
  v16 = *(_DWORD *)v13;
  v17 = *(_DWORD *)v12;
  if (*(_DWORD *)v13 >= *(_DWORD *)v12)
  {
    if (v17 < v16)
      goto LABEL_28;
    v18 = *(_QWORD *)(v13 + 8);
    v19 = *(_QWORD *)(v12 + 8);
    if (v18 >= v19 && (v19 < v18 || *(_QWORD *)(v13 + 16) >= *(_QWORD *)(v12 + 16)))
      goto LABEL_28;
  }
  else
  {
    v18 = *(_QWORD *)(v13 + 8);
    v19 = *(_QWORD *)(v12 + 8);
  }
  v20 = *(_QWORD *)(v13 + 16);
  *(_DWORD *)v13 = v17;
  v21 = *(_QWORD *)(v12 + 16);
  *(_QWORD *)(v13 + 8) = v19;
  *(_QWORD *)(v13 + 16) = v21;
  v22 = a1;
  if (v12 == a1)
    goto LABEL_27;
  v23 = v14;
  while (1)
  {
    v24 = a1 + v23;
    v25 = *(_DWORD *)(a1 + v23 + 24);
    if (v16 >= v25)
    {
      if (v25 < v16)
        goto LABEL_25;
      v26 = *(_QWORD *)(a1 + v23 + 32);
      if (v18 >= v26)
      {
        if (v26 < v18)
        {
LABEL_25:
          v22 = v12;
          goto LABEL_27;
        }
        if (v20 >= *(_QWORD *)(a1 + v23 + 40))
        {
          v22 = a1 + v23 + 48;
LABEL_27:
          *(_DWORD *)v22 = v16;
          *(_QWORD *)(v22 + 8) = v18;
          *(_QWORD *)(v22 + 16) = v20;
          if (++v15 == 8)
            return v13 + 24 == a2;
LABEL_28:
          v12 = v13;
          v14 += 24;
          v13 += 24;
          if (v13 == a2)
            return 1;
          goto LABEL_8;
        }
      }
    }
    else
    {
      v26 = *(_QWORD *)(v24 + 32);
    }
    v12 -= 24;
    *(_DWORD *)(v24 + 48) = v25;
    v27 = a1 + v23;
    v28 = *(_QWORD *)(a1 + v23 + 40);
    *(_QWORD *)(v27 + 56) = v26;
    *(_QWORD *)(v27 + 64) = v28;
    v23 -= 24;
    if (v23 == -48)
    {
      v22 = a1;
      goto LABEL_27;
    }
  }
}

id DEVICEOBJECT(id a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  while ((objc_opt_respondsToSelector(a1, "baseObject") & 1) != 0)
    a1 = objc_msgSend(a1, "performSelector:", "baseObject");
  objc_autoreleasePoolPop(v2);
  return a1;
}

void GTMTLReplaySupport_init(void *a1)
{
  id v1;
  char v2;
  uint64_t v3;
  id v4;
  char v5;
  uint64_t v6;
  Class v7;
  id v8;
  char v9;
  uint64_t v10;
  id v11;
  char v12;
  uint64_t v13;
  id v14;
  char v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  __int16 v25;
  id v26;
  void *v27;
  uint64_t v28;
  char v29;
  id v30;
  char v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  BOOL v35;
  id v36;
  char v37;
  uint64_t v38;
  char v39;
  uint64_t v40;
  unsigned int v41;
  Class v42;
  id v43;
  void *v44;
  char v45;
  id v46;
  void *v47;
  BOOL v48;
  uint64_t v49;
  id v50;
  void *v51;
  char v52;
  id v53;
  void *v54;
  BOOL v55;
  id v56;

  v1 = DEVICEOBJECT(a1);
  v56 = (id)objc_claimAutoreleasedReturnValue(v1);
  GT_SUPPORT_0 = 0;
  GT_SUPPORT_0 = NSClassFromString(CFSTR("MTLTileRenderPipelineDescriptor")) != 0;
  v2 = objc_opt_respondsToSelector(v56, "supportsVertexAmplification");
  v3 = 2;
  if ((v2 & 1) == 0)
    v3 = 0;
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFFFDLL | v3;
  v4 = objc_alloc_init((Class)MTLCompileOptions);
  v5 = objc_opt_respondsToSelector(v4, "setAdditionalCompilerArguments:");
  v6 = 4;
  if ((v5 & 1) == 0)
    v6 = 0;
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFFFBLL | v6;

  v7 = NSClassFromString(CFSTR("MTLIndirectCommandBufferDescriptor"));
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFFF7 | (8 * (v7 != 0));
  if (v7)
  {
    v8 = objc_alloc_init((Class)MTLIndirectCommandBufferDescriptor);
    v9 = objc_opt_respondsToSelector(v8, "maxKernelBufferBindCount");
    v10 = 16;
    if ((v9 & 1) == 0)
      v10 = 0;
    GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFFEFLL | v10;

  }
  v11 = objc_alloc_init((Class)MTLRenderPipelineDescriptor);
  if (objc_msgSend(v56, "supportsTessellation"))
  {
    v12 = objc_opt_respondsToSelector(v11, "tessellationControlPointIndexType");
    v13 = 32;
    if ((v12 & 1) == 0)
      v13 = 0;
  }
  else
  {
    v13 = 0;
  }
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFFDFLL | v13;

  v14 = objc_alloc_init((Class)MTLRenderPassDescriptor);
  v15 = objc_opt_respondsToSelector(v14, "defaultColorSampleCount");
  v16 = 64;
  if ((v15 & 1) == 0)
    v16 = 0;
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFFBFLL | v16;
  v17 = objc_msgSend(v56, "supportsLayeredRendering");
  v18 = 128;
  if (!v17)
    v18 = 0;
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFF7FLL | v18;

  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFEFFLL | ((unint64_t)(NSClassFromString(CFSTR("MTLRasterizationRateMapDescriptor")) != 0) << 8);
  v19 = objc_msgSend(v56, "supportsImageBlocks");
  v20 = 512;
  if (!v19)
    v20 = 0;
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFDFFLL | v20;
  v21 = objc_opt_respondsToSelector(v56, "maxRasterizationRateLayerCount");
  v22 = 1024;
  if ((v21 & 1) == 0)
    v22 = 0;
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFBFFLL | v22;
  v23 = objc_opt_respondsToSelector(v56, "sparseTileSizeWithTextureType:pixelFormat:sampleCount:");
  v24 = 2048;
  if ((v23 & 1) == 0)
    v24 = 0;
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFF7FFLL | v24;
  v25 = dword_75313C;
  v26 = objc_alloc_init((Class)MTLRenderPipelineDescriptor);
  v27 = v26;
  v28 = 0;
  if ((v25 & 0x4000) == 0)
  {
    v29 = objc_opt_respondsToSelector(v26, "setDriverCompilerOptions:");
    v28 = 0x8000;
    if ((v29 & 1) == 0)
      v28 = 0;
  }
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFF7FFFLL | v28;

  v30 = objc_alloc_init((Class)MTLComputePipelineDescriptor);
  v31 = objc_opt_respondsToSelector(v30, "setMaxTotalThreadsPerThreadgroup:");
  v32 = 0x4000;
  if ((v31 & 1) == 0)
    v32 = 0;
  v33 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFBFFFLL | v32;
  GT_SUPPORT_0 = v33;
  if ((v25 & 0x4000) != 0)
  {
    v34 = 0;
  }
  else
  {
    if ((objc_opt_respondsToSelector(v30, "setDriverCompilerOptions:") & 1) != 0)
      v34 = 0x10000;
    else
      v34 = 0;
    v33 = GT_SUPPORT_0;
  }
  GT_SUPPORT_0 = v33 & 0xFFFFFFFFFFFEFFFFLL | v34;

  v35 = objc_msgSend(v56, "argumentBuffersSupport") != 0;
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFDFFFLL | ((unint64_t)v35 << 13);
  v36 = objc_alloc_init((Class)MTLRenderPipelineDescriptor);
  v37 = objc_opt_respondsToSelector(v36, "openGLModeEnabled");
  v38 = 0x20000;
  if ((v37 & 1) == 0)
    v38 = 0;
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFDFFFFLL | v38;

  v39 = objc_opt_respondsToSelector(v56, "supportsGlobalVariableRelocation");
  v40 = 0;
  if ((v39 & 1) != 0)
  {
    v41 = objc_msgSend(v56, "supportsGlobalVariableRelocation");
    v40 = 0x40000;
    if (!v41)
      v40 = 0;
  }
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFBFFFFLL | v40;
  v42 = NSClassFromString(CFSTR("MTLBufferDescriptor"));
  v43 = DEVICEOBJECT(v56);
  v44 = (void *)objc_claimAutoreleasedReturnValue(v43);
  v45 = objc_opt_respondsToSelector(v44, "resourcePatchingTypeForResourceType:");

  if ((v45 & 1) != 0 && v42)
  {
    v46 = DEVICEOBJECT(v56);
    v47 = (void *)objc_claimAutoreleasedReturnValue(v46);
    v48 = objc_msgSend(v47, "resourcePatchingTypeForResourceType:", 3) != (char *)&dword_0 + 2;

    v49 = 0x80000;
    if ((*(_DWORD *)&v48 & ((unsigned __int16)(dword_75313C & 0x100) >> 8)) == 0)
      v49 = 0;
    GT_SUPPORT_0 = v49 | GT_SUPPORT_0 & 0xFFFFFFFFFFF7FFFFLL;
  }
  v50 = DEVICEOBJECT(v56);
  v51 = (void *)objc_claimAutoreleasedReturnValue(v50);
  v52 = objc_opt_respondsToSelector(v51, "resourcePatchingTypeForResourceType:");

  if ((v52 & 1) != 0)
  {
    v53 = DEVICEOBJECT(v56);
    v54 = (void *)objc_claimAutoreleasedReturnValue(v53);
    v55 = objc_msgSend(v54, "resourcePatchingTypeForResourceType:", 8) == (char *)&dword_0 + 1;

    GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFEFFFFFLL | ((unint64_t)v55 << 20);
  }

}

unsigned int *ExpectedState(uint64_t a1)
{
  uint64_t v2;
  unsigned int *FileWithFilename;
  void *v4;
  uint64_t v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSSet *v16;
  void *v17;
  void *v18;

  v2 = **(_QWORD **)a1;
  FileWithFilename = (unsigned int *)GTCaptureArchive_getFileWithFilename(v2, "XPState");
  if (FileWithFilename)
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](NSMutableData, "dataWithLength:", *FileWithFilename));
    v5 = *(_QWORD *)(a1 + 152);
    v6 = objc_retainAutorelease(v4);
    GTCaptureArchive_fillBufferCompressedDeflate(v2, v5, (uint64_t)FileWithFilename, objc_msgSend(v6, "mutableBytes"), *FileWithFilename, 0);
    v8 = objc_opt_class(NSDictionary, v7);
    v10 = objc_opt_class(NSArray, v9);
    v12 = objc_opt_class(NSString, v11);
    v14 = objc_opt_class(NSNumber, v13);
    v16 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v8, v10, v12, v14, objc_opt_class(NSNull, v15), 0);
    v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
    v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:](NSKeyedUnarchiver, "unarchivedObjectOfClasses:fromData:error:", v17, v6, 0));

    if (v18)
      FileWithFilename = (unsigned int *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "objectForKeyedSubscript:", CFSTR("XPState")));
    else
      FileWithFilename = 0;

  }
  return FileWithFilename;
}

void sub_2C7028(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t GetIOAccelerator()
{
  const __CFDictionary *v0;
  uint64_t result;
  const __CFDictionary *v2;

  v0 = IOServiceMatching("IOAccelerator");
  result = IOServiceGetMatchingService(kIOMasterPortDefault, v0);
  if (!(_DWORD)result)
  {
    v2 = IOServiceMatching("IOAcceleratorES");
    return IOServiceGetMatchingService(kIOMasterPortDefault, v2);
  }
  return result;
}

id GetMetalPluginName(io_registry_entry_t a1, _DWORD *a2)
{
  void *CFProperty;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  unsigned int v10;
  void *v11;

  CFProperty = (void *)IORegistryEntryCreateCFProperty(a1, CFSTR("MetalPluginName"), 0, 0);
  v5 = CFProperty;
  if (CFProperty)
  {
    CFRelease(CFProperty);
    if (a2)
    {
      v6 = (void *)IORegistryEntryCreateCFProperty(a1, CFSTR("GPUConfigurationVariable"), 0, 0);
      v7 = v6;
      if (v6)
      {
        v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("gpu_gen")));
        v9 = v8;
        if (v8)
        {
          v10 = objc_msgSend(v8, "intValue");
          if (v10 == 15)
          {
            v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", CFSTR("num_cores")));
            if ((int)objc_msgSend(v11, "intValue") < 6)
              v10 = 14;
            else
              v10 = 15;

          }
          *a2 = v10 - 10;
        }

      }
    }
  }
  return v5;
}

void sub_2C71A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

CFTypeRef GTProfilerConfigurationVariables(io_registry_entry_t a1)
{
  return (id)IORegistryEntryCreateCFProperty(a1, CFSTR("GPUConfigurationVariable"), 0, 0);
}

uint64_t MetalPluginTarget(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  id v6;
  char *v7;
  int v8;
  unint64_t i;
  uint64_t v10;
  int v12;
  int v13;

  v1 = a1;
  v2 = v1;
  if (v1 && (objc_msgSend(v1, "hasPrefix:", CFSTR("AGXMetal")) & 1) != 0)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "substringFromIndex:", objc_msgSend(CFSTR("AGXMetal"), "length")));
    v4 = v3;
    if (v3)
    {
      if ((objc_msgSend(v3, "hasPrefix:", CFSTR("S4")) & 1) != 0
        || (objc_msgSend(v4, "hasPrefix:", CFSTR("S5")) & 1) != 0
        || (objc_msgSend(v4, "hasPrefix:", CFSTR("S6")) & 1) != 0)
      {
        v5 = 1;
LABEL_18:

        goto LABEL_19;
      }
      if ((objc_msgSend(v4, "hasPrefix:", CFSTR("G")) & 1) != 0
        || (objc_msgSend(v4, "hasPrefix:", CFSTR("A")) & 1) != 0
        || objc_msgSend(v4, "hasPrefix:", CFSTR("1")))
      {
        v6 = objc_retainAutorelease(v4);
        v7 = (char *)objc_msgSend(v6, "UTF8String");
        v8 = 0;
        for (i = objc_msgSend(v6, "hasPrefix:", CFSTR("1")) ^ 1;
              i < (unint64_t)objc_msgSend(v6, "length");
              ++i)
        {
          if (v7[i] < 0)
            break;
          v10 = v7[i];
          if ((_DefaultRuneLocale.__runetype[v10] & 0x400) == 0)
            break;
          v8 = v10 + 10 * v8 - 48;
        }
        if (v8 == 15)
        {
          if (i < (unint64_t)objc_msgSend(v6, "length")
            && objc_msgSend(v6, "characterAtIndex:", i) == 95
            || (id)i == objc_msgSend(v6, "length"))
          {
            v8 = 14;
          }
          else
          {
            v8 = 15;
          }
        }
        if (objc_msgSend(v6, "hasPrefix:", CFSTR("A")))
          v12 = -11;
        else
          v12 = -10;
        v13 = v12 + v8;
        if (v13 <= -2)
          v5 = 0x80000000;
        else
          v5 = v13;
        goto LABEL_18;
      }
    }
    v5 = 0x80000000;
    goto LABEL_18;
  }
  v5 = 0x80000000;
LABEL_19:

  return v5;
}

void sub_2C73FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id IsAGXMetalPlugin(void *a1, const char *a2)
{
  return objc_msgSend(a1, "containsString:", CFSTR("AGXMetal"));
}

id ProcessEncoderTimeData(void *a1, void *a2, void *a3, unint64_t a4)
{
  id v7;
  id v8;
  uint64_t v9;
  id v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  id v17;
  unint64_t v18;
  id v19;
  uint64_t v20;
  void *i;
  uint64_t v22;
  double v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  void *v34;
  unsigned int v35;
  void *v36;
  unsigned int v37;
  void *v38;
  void *v39;
  void *v40;
  uint64_t v41;
  void *v42;
  void *v43;
  id v44;
  uint64_t v45;
  void *j;
  void *v47;
  void *v48;
  void *v49;
  id v50;
  void *v51;
  void *v52;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  id v58;
  void *v59;
  void *v60;
  void *v61;
  unsigned int v62;
  void *v63;
  uint64_t v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  _QWORD v73[4];
  _BYTE v74[128];
  _QWORD v75[2];
  _BYTE v76[128];

  v7 = a1;
  v8 = a2;
  v10 = a3;
  v54 = v10;
  if (!v7)
    v7 = (id)objc_opt_new(NSArray, v9);
  v57 = v8;
  if (!v8)
    v57 = (void *)objc_opt_new(NSArray, v9);
  v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", CFSTR("activePerEncoderDrawCallCount")));
  v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", CFSTR("perEncoderKickCount"), v7));
  v11 = (unint64_t)objc_msgSend(v7, "count");
  v12 = v11;
  v58 = v8;
  if (v11)
  {
    if (v11 >> 61)
      abort();
    v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v11);
    v15 = (uint64_t)&v13[8 * v14];
    memset_pattern16(v13, &unk_4AA590, 8 * v12);
    v16 = &v13[8 * v12];
  }
  else
  {
    v16 = 0;
    v15 = 0;
    v13 = 0;
  }
  v71 = 0u;
  v72 = 0u;
  v69 = 0u;
  v70 = 0u;
  v17 = v7;
  v18 = 0;
  v19 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v69, v76, 16);
  if (v19)
  {
    v20 = *(_QWORD *)v70;
    do
    {
      for (i = 0; i != v19; i = (char *)i + 1)
      {
        if (*(_QWORD *)v70 != v20)
          objc_enumerationMutation(v17);
        v18 += (unint64_t)objc_msgSend(*(id *)(*((_QWORD *)&v69 + 1) + 8 * (_QWORD)i), "unsignedLongLongValue");
      }
      v19 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v69, v76, 16);
    }
    while (v19);
  }

  if (a4)
  {
    v23 = (double)a4 / (double)v18;
    v24 = (v16 - v13) >> 3;
    if (v24 <= (v15 - (uint64_t)v13) >> 3)
    {
      if (v16 != v13)
      {
        v29 = 0;
        do
          *(double *)&v13[8 * v29++] = v23;
        while (v24 != v29);
      }
    }
    else
    {
      if (v13)
      {
        operator delete(v13);
        v15 = 0;
      }
      if (v16 - v13 < 0)
        goto LABEL_60;
      v25 = v15 >> 2;
      if (v15 >> 2 <= v24)
        v25 = (v16 - v13) >> 3;
      v26 = (unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v25;
      if (v26 >> 61)
LABEL_60:
        abort();
      v27 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v26);
      v13 = v27;
      v28 = 0;
      do
      {
        *(double *)&v27[v28] = v23;
        v28 += 8;
      }
      while (8 * v24 != v28);
    }
  }
  if (!v61)
  {
    v75[0] = v17;
    v75[1] = v57;
    v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v75, 2));
    goto LABEL_56;
  }
  v60 = (void *)objc_opt_new(NSMutableArray, v22);
  v55 = (void *)objc_opt_new(NSMutableArray, v30);
  v56 = (void *)objc_opt_new(NSMutableArray, v31);
  v59 = (void *)objc_opt_new(NSMutableArray, v32);
  v33 = 0;
  v62 = 0;
  while (1)
  {
    if ((unint64_t)objc_msgSend(v63, "count") <= v33)
    {
      v73[0] = v59;
      v73[1] = v56;
      v73[2] = v60;
      v73[3] = v55;
      v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v73, 4));
      goto LABEL_55;
    }
    v64 = v33;
    v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v63, "objectAtIndexedSubscript:"));
    v35 = objc_msgSend(v34, "unsignedIntValue");

    v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v61, "objectAtIndexedSubscript:", v64));
    v37 = objc_msgSend(v36, "unsignedIntValue");

    if (!v35 && v37 == 1)
    {
      objc_msgSend(v59, "addObject:", &off_739CE8);
      objc_msgSend(v60, "addObject:", &off_739CE8);
      if (v58)
      {
        v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObject:](NSArray, "arrayWithObject:", &off_739CE8));
        objc_msgSend(v56, "addObject:", v38);

        v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObject:](NSArray, "arrayWithObject:", &off_739CE8));
        objc_msgSend(v55, "addObject:", v39);

      }
      goto LABEL_51;
    }
    if ((unint64_t)objc_msgSend(v17, "count") <= v62)
      break;
    v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "objectAtIndexedSubscript:", v62));
    objc_msgSend(v60, "addObject:", v40);

    if (v58)
    {
      v42 = (void *)objc_opt_new(NSMutableArray, v41);
      v67 = 0u;
      v68 = 0u;
      v65 = 0u;
      v66 = 0u;
      v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v57, "objectAtIndexedSubscript:", v62));
      v44 = objc_msgSend(v43, "countByEnumeratingWithState:objects:count:", &v65, v74, 16);
      if (v44)
      {
        v45 = *(_QWORD *)v66;
        do
        {
          for (j = 0; j != v44; j = (char *)j + 1)
          {
            if (*(_QWORD *)v66 != v45)
              objc_enumerationMutation(v43);
            v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", (unint64_t)(*(double *)&v13[8 * v62]* (double)(unint64_t)objc_msgSend(*(id *)(*((_QWORD *)&v65 + 1)+ 8 * (_QWORD)j), "unsignedLongLongValue"))));
            objc_msgSend(v42, "addObject:", v47);

          }
          v44 = objc_msgSend(v43, "countByEnumeratingWithState:objects:count:", &v65, v74, 16);
        }
        while (v44);
      }

      objc_msgSend(v56, "addObject:", v42);
      v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v57, "objectAtIndexedSubscript:", v62));
      objc_msgSend(v55, "addObject:", v48);

    }
    v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "objectAtIndexedSubscript:", v62));
    v50 = objc_msgSend(v49, "unsignedLongLongValue");

    v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", (unint64_t)(*(double *)&v13[8 * v62] * (double)(unint64_t)v50)));
    objc_msgSend(v59, "addObject:", v51);

    ++v62;
LABEL_51:
    v33 = v64 + 1;
  }
  v52 = 0;
LABEL_55:

LABEL_56:
  if (v13)
    operator delete(v13);

  return v52;
}

void sub_2C7A68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, void *a19)
{
  void *v19;

  if (v19)
    operator delete(v19);

  _Unwind_Resume(a1);
}

id ProcessDerivedCounterDataFromDevice(void *a1, void *a2, void *a3)
{
  id v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  id v9;
  uint64_t v10;
  void *i;
  void *v12;
  void *v13;
  id v14;
  uint64_t v15;
  void *j;
  id v17;
  uint64_t v18;
  void *v19;
  id v20;
  id v21;
  void *v22;
  NSNumber *v23;
  NSNumber *v24;
  void *v25;
  id v26;
  id v27;
  uint64_t v28;
  void *k;
  uint64_t v30;
  id v31;
  id v32;
  uint64_t v33;
  void *m;
  void *v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  void *v39;
  unsigned int v40;
  uint64_t v41;
  void *v42;
  unsigned int v43;
  void *v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  id v49;
  void *v50;
  id v51;
  void *v52;
  uint64_t v53;
  uint64_t v54;
  void *v55;
  void *v56;
  void *v57;
  id v58;
  unint64_t v59;
  unint64_t v60;
  void *v61;
  uint64_t v62;
  char *v63;
  unint64_t v64;
  void *v65;
  void *v66;
  id v67;
  void *v68;
  id v69;
  unint64_t v70;
  double v71;
  void *v72;
  id v73;
  id v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  void *n;
  void *v79;
  void *v80;
  void *v81;
  id v82;
  void *v83;
  void *v84;
  id v85;
  double v86;
  void *v87;
  void *v88;
  id v89;
  void *v91;
  unsigned int v92;
  void *v93;
  char v94;
  unsigned int v95;
  unsigned int v96;
  void *v97;
  void *v98;
  void *v99;
  void *v100;
  void *v101;
  unsigned int v102;
  uint64_t v103;
  void *v104;
  void *v105;
  id v106;
  id v107;
  void *v108;
  uint64_t v109;
  uint64_t v110;
  id v111;
  void *v112;
  id v113;
  id v114;
  id v115;
  id v116;
  unsigned int v117;
  void *v118;
  unint64_t v119;
  unsigned int v120;
  unint64_t v121;
  uint64_t v122;
  id v123;
  void *v124;
  id v125;
  id v126;
  uint64_t v127;
  id v128;
  char isKindOfClass;
  void *v130;
  id obj;
  id obja;
  id objb;
  void *v134;
  unsigned int v135;
  id v136;
  void *v137;
  unsigned int v138;
  id v139;
  unsigned int v140;
  id v141;
  id v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  void *__p[3];
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  _BYTE v164[128];
  _BYTE v165[128];
  _BYTE v166[128];
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  _QWORD v171[4];
  id v172;
  id v173;

  v5 = a1;
  v107 = a2;
  v126 = a3;
  v108 = v5;
  if (!v5)
    goto LABEL_114;
  v105 = (void *)objc_opt_new(NSMutableDictionary, v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("counters")));
  v137 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v107, "objectForKeyedSubscript:", CFSTR("NormalizedCounters")));
  if (!v7)
  {
    v5 = 0;
    goto LABEL_113;
  }
  objc_msgSend(v7, "count");
  v124 = (void *)objc_opt_new(NSMutableArray, v8);
  if (v137)
  {
    v154 = 0u;
    v155 = 0u;
    v152 = 0u;
    v153 = 0u;
    obj = v7;
    v9 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v152, v166, 16);
    if (v9)
    {
      v10 = *(_QWORD *)v153;
      do
      {
        for (i = 0; i != v9; i = (char *)i + 1)
        {
          if (*(_QWORD *)v153 != v10)
            objc_enumerationMutation(obj);
          v12 = *(void **)(*((_QWORD *)&v152 + 1) + 8 * (_QWORD)i);
          if (objc_msgSend(v137, "containsObject:", v12))
          {
            v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "stringByAppendingString:", CFSTR("_norm")));
            objc_msgSend(v124, "addObject:", v13);

          }
        }
        v9 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v152, v166, 16);
      }
      while (v9);
    }

  }
  memset(__p, 0, sizeof(__p));
  v147 = 0u;
  v148 = 0u;
  v149 = 0u;
  v150 = 0u;
  obja = v7;
  v14 = objc_msgSend(obja, "countByEnumeratingWithState:objects:count:", &v147, v165, 16);
  if (v14)
  {
    v15 = *(_QWORD *)v148;
    do
    {
      for (j = 0; j != v14; j = (char *)j + 1)
      {
        if (*(_QWORD *)v148 != v15)
          objc_enumerationMutation(obja);
        LOBYTE(v171[0]) = objc_msgSend(v137, "containsObject:", *(_QWORD *)(*((_QWORD *)&v147 + 1) + 8 * (_QWORD)j));
        std::vector<BOOL>::push_back((uint64_t *)__p, v171);
      }
      v14 = objc_msgSend(obja, "countByEnumeratingWithState:objects:count:", &v147, v165, 16);
    }
    while (v14);
  }

  v17 = (id)objc_claimAutoreleasedReturnValue(+[NSSet setWithObjects:](NSSet, "setWithObjects:", CFSTR("MTLStatDataMaster"), CFSTR("MTLStat_nSec"), 0));
  objb = obja;
  v19 = (void *)objc_opt_new(NSMutableDictionary, v18);
  v171[0] = _NSConcreteStackBlock;
  v171[1] = 3221225472;
  v171[2] = ___ZL28CounterIndicesFromCounterSetP5NSSetP7NSArray_block_invoke;
  v171[3] = &unk_7264D8;
  v20 = v17;
  v172 = v20;
  v21 = v19;
  v173 = v21;
  objc_msgSend(objb, "enumerateObjectsUsingBlock:", v171);
  v22 = v173;
  v106 = v21;

  v23 = (NSNumber *)objc_claimAutoreleasedReturnValue(objc_msgSend(v106, "objectForKeyedSubscript:", CFSTR("MTLStatDataMaster")));
  v140 = CounterIndex(v23);

  v24 = (NSNumber *)objc_claimAutoreleasedReturnValue(objc_msgSend(v106, "objectForKeyedSubscript:", CFSTR("MTLStat_nSec")));
  v138 = CounterIndex(v24);

  v5 = 0;
  if (v140 == -1 || v138 == -1)
    goto LABEL_110;
  v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(objb, "arrayByAddingObjectsFromArray:", v124));

  v135 = objc_msgSend(v25, "count");
  v26 = v25;
  objb = v26;
  v142 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", 4 * (_QWORD)objc_msgSend(v26, "count"));
  v162 = 0u;
  v163 = 0u;
  v160 = 0u;
  v161 = 0u;
  v27 = objc_msgSend(&off_738C10, "countByEnumeratingWithState:objects:count:", &v160, v171, 16);
  if (v27)
  {
    v28 = *(_QWORD *)v161;
    do
    {
      for (k = 0; k != v27; k = (char *)k + 1)
      {
        if (*(_QWORD *)v161 != v28)
          objc_enumerationMutation(&off_738C10);
        v30 = *(_QWORD *)(*((_QWORD *)&v160 + 1) + 8 * (_QWORD)k);
        v156 = 0u;
        v157 = 0u;
        v158 = 0u;
        v159 = 0u;
        v31 = v26;
        v32 = objc_msgSend(v31, "countByEnumeratingWithState:objects:count:", &v156, &v167, 16);
        if (v32)
        {
          v33 = *(_QWORD *)v157;
          do
          {
            for (m = 0; m != v32; m = (char *)m + 1)
            {
              if (*(_QWORD *)v157 != v33)
                objc_enumerationMutation(v31);
              v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v156 + 1) + 8 * (_QWORD)m), "stringByAppendingString:", v30));
              objc_msgSend(v142, "addObject:", v35);

            }
            v32 = objc_msgSend(v31, "countByEnumeratingWithState:objects:count:", &v156, &v167, 16);
          }
          while (v32);
        }

        v26 = objb;
      }
      v27 = objc_msgSend(&off_738C10, "countByEnumeratingWithState:objects:count:", &v160, v171, 16);
    }
    while (v27);
  }

  LODWORD(v160) = 0;
  DWORD1(v160) = v135;
  DWORD2(v160) = 2 * v135;
  HIDWORD(v160) = 3 * v135;
  v101 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v108, "objectForKeyedSubscript:", CFSTR("AverageSamples")));
  v91 = (void *)objc_opt_new(NSMutableArray, v36);
  v104 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v107, "objectForKeyedSubscript:", CFSTR("perCommandBufferEncoderCount")));
  v98 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v107, "objectForKeyedSubscript:", CFSTR("activePerEncoderDrawCallCount")));
  v99 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v107, "objectForKeyedSubscript:", CFSTR("perEncoderKickCount")));
  v95 = 0;
  v37 = 0;
  v38 = 0;
  v103 = 4 * v135;
  v110 = v140;
  v122 = v138;
  while (1)
  {
    if ((unint64_t)objc_msgSend(v104, "count") <= v38)
    {
      objc_msgSend(v105, "setObject:forKeyedSubscript:", v142, CFSTR("counters"));
      objc_msgSend(v105, "setObject:forKeyedSubscript:", v91, CFSTR("AverageSamples"));
      v88 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v108, "objectForKeyedSubscript:", CFSTR("counterLists")));
      v89 = objc_msgSend(v88, "copy");
      objc_msgSend(v105, "setObject:forKeyedSubscript:", v89, CFSTR("counterLists"));

      v5 = v105;
      goto LABEL_109;
    }
    v96 = v38;
    v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v104, "objectAtIndexedSubscript:"));
    v40 = objc_msgSend(v39, "unsignedIntValue");

    if (v40)
      break;
LABEL_104:
    v38 = v96 + 1;
  }
  if ((unint64_t)objc_msgSend(v101, "count") <= v95)
    goto LABEL_108;
  v97 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v101, "objectAtIndexedSubscript:"));
  v93 = (void *)objc_opt_new(NSMutableArray, v41);
  v102 = 0;
  v92 = v37 + v40;
  v94 = 1;
  while (1)
  {
    v119 = v37;
    v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v99, "objectAtIndexedSubscript:"));
    v43 = objc_msgSend(v42, "unsignedIntValue");

    v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v98, "objectAtIndexedSubscript:", v37));
    v45 = objc_msgSend(v44, "unsignedIntValue");

    if (v45 || v43 != 1)
      break;
    v113 = (id)objc_opt_new(NSMutableArray, v46);
LABEL_47:
    v100 = (void *)objc_opt_new(NSMutableArray, v47);
    v112 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", v103));
    if ((_DWORD)v103)
    {
      v48 = v103;
      do
      {
        objc_msgSend(v112, "addObject:", &off_739D30);
        --v48;
      }
      while (v48);
    }
    v145 = 0u;
    v146 = 0u;
    v143 = 0u;
    v144 = 0u;
    v114 = v113;
    v49 = objc_msgSend(v114, "countByEnumeratingWithState:objects:count:", &v143, v164, 16);
    if (v49)
    {
      v117 = 0;
      v109 = *(_QWORD *)v144;
      do
      {
        v118 = 0;
        v111 = v49;
        do
        {
          if (*(_QWORD *)v144 != v109)
            objc_enumerationMutation(v114);
          v50 = *(void **)(*((_QWORD *)&v143 + 1) + 8 * (_QWORD)v118);
          v136 = v112;
          v125 = v126;
          v51 = v50;
          v123 = v114;
          v115 = objb;
          v116 = v142;
          v130 = v51;
          v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "objectAtIndexedSubscript:", 0));
          v54 = objc_opt_class(NSArray, v53);
          isKindOfClass = objc_opt_isKindOfClass(v52, v54);

          if ((isKindOfClass & 1) != 0)
          {
            v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v130, "objectAtIndexedSubscript:", v110));
            v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v55, "objectAtIndexedSubscript:", 0));
          }
          else
          {
            v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v130, "objectAtIndexedSubscript:", v110));
            v55 = v56;
          }
          v128 = objc_msgSend(v56, "unsignedLongLongValue");
          if ((isKindOfClass & 1) != 0)

          if ((unint64_t)v128 < 4)
          {
            v120 = objc_msgSend(v130, "count");
            v121 = v117;
            if (v126 && (unint64_t)objc_msgSend(v125, "count") > v119)
            {
              v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v125, "objectAtIndexedSubscript:"));
              v58 = objc_msgSend(v57, "count");
              if ((unint64_t)v58 <= 1)
                v59 = 1;
              else
                v59 = (unint64_t)v58;

              v121 = v117 % v59;
            }
            v60 = 0;
            v127 = 0;
            while (v60 < (unint64_t)objc_msgSend(v130, "count"))
            {
              v134 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v130, "objectAtIndexedSubscript:", v60));
              if ((isKindOfClass & 1) != 0)
                v139 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v134, "objectAtIndexedSubscript:", 0));
              else
                v139 = v134;
              if (v126 && v60 == v122 && (unint64_t)objc_msgSend(v125, "count") > v119)
              {
                v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v125, "objectAtIndexedSubscript:"));
                v62 = objc_claimAutoreleasedReturnValue(objc_msgSend(v61, "objectAtIndexedSubscript:", v121));

                v139 = (id)v62;
              }
              v63 = (char *)objc_msgSend(v139, "unsignedLongLongValue");
              v64 = v60 + HIDWORD(v160);
              v65 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v136, "objectAtIndexedSubscript:", v64));
              v66 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", &v63[(_QWORD)objc_msgSend(v65, "unsignedLongLongValue")]));
              objc_msgSend(v136, "setObject:atIndexedSubscript:", v66, v64);

              objc_msgSend(v136, "setObject:atIndexedSubscript:", v139, v60 + *((unsigned int *)&v160 + (_QWORD)v128));
              if ((isKindOfClass & 1) != 0
                && ((*(_QWORD *)((char *)__p[0] + ((v60 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v60) & 1) != 0)
              {
                v67 = objc_msgSend(v139, "unsignedLongLongValue");
                v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v134, "objectAtIndexedSubscript:", 1));
                v69 = objc_msgSend(v68, "unsignedLongLongValue");

                if ((unint64_t)v69 <= 1)
                  v70 = 1;
                else
                  v70 = (unint64_t)v69;
                v71 = (double)(unint64_t)v67 * 100.0 / (double)v70;
                v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v71));
                objc_msgSend(v136, "setObject:atIndexedSubscript:", v72, v127 + *((_DWORD *)&v160 + (_QWORD)v128) + v120);

                v73 = objc_msgSend(v123, "count");
                if (v121 || (unint64_t)v73 < 2)
                {
                  if (objc_msgSend(v123, "count") == (char *)&dword_0 + 1)
                  {
                    v87 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v71));
                    objc_msgSend(v136, "setObject:atIndexedSubscript:", v87, v127 + HIDWORD(v160) + v120);
                    goto LABEL_97;
                  }
                }
                else
                {
                  v170 = 0u;
                  v169 = 0u;
                  v168 = 0u;
                  v167 = 0u;
                  v141 = v123;
                  v74 = objc_msgSend(v141, "countByEnumeratingWithState:objects:count:", &v167, v171, 16);
                  if (!v74)
                  {

                    v86 = 0.0;
                    goto LABEL_95;
                  }
                  v75 = 0;
                  v76 = 0;
                  v77 = *(_QWORD *)v168;
                  do
                  {
                    for (n = 0; n != v74; n = (char *)n + 1)
                    {
                      if (*(_QWORD *)v168 != v77)
                        objc_enumerationMutation(v141);
                      v79 = *(void **)(*((_QWORD *)&v167 + 1) + 8 * (_QWORD)n);
                      v80 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v79, "objectAtIndexedSubscript:", v60));
                      v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v80, "objectAtIndexedSubscript:", 0));
                      v82 = objc_msgSend(v81, "unsignedLongLongValue");

                      v83 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v79, "objectAtIndexedSubscript:", v60));
                      v84 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v83, "objectAtIndexedSubscript:", 1));
                      v85 = objc_msgSend(v84, "unsignedLongLongValue");

                      v76 += (unint64_t)v82;
                      v75 += (unint64_t)v85;
                    }
                    v74 = objc_msgSend(v141, "countByEnumeratingWithState:objects:count:", &v167, v171, 16);
                  }
                  while (v74);

                  v86 = (double)v76 * 100.0;
                  if (!v75)
LABEL_95:
                    v75 = 1;
                  v87 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v86 / (double)v75));
                  objc_msgSend(v136, "setObject:atIndexedSubscript:", v87, v127 + HIDWORD(v160) + v120);
LABEL_97:

                }
                ++v127;
              }

              ++v60;
              continue;
            }
          }

          ++v117;
          v118 = (char *)v118 + 1;
        }
        while (v118 != v111);
        v49 = objc_msgSend(v123, "countByEnumeratingWithState:objects:count:", &v143, v164, 16);
      }
      while (v49);
    }

    objc_msgSend(v100, "addObject:", v112);
    objc_msgSend(v93, "addObject:", v100);

    v37 = v119 + 1;
    if ((_DWORD)v119 + 1 == v92)
    {
      objc_msgSend(v91, "addObject:", v93);

      v95 += (v94 & 1) == 0;
      v37 = v92;
      goto LABEL_104;
    }
  }
  if ((unint64_t)objc_msgSend(v97, "count") > v102)
  {
    v113 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v97, "objectAtIndexedSubscript:"));
    v94 = 0;
    ++v102;
    goto LABEL_47;
  }

LABEL_108:
  v5 = 0;
LABEL_109:

LABEL_110:
  if (__p[0])
    operator delete(__p[0]);

LABEL_113:
LABEL_114:

  return v5;
}

void sub_2C8AEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,void *a25,void *a26,void *a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,void *a56)
{

  if (STACK[0x208])
    operator delete((void *)STACK[0x208]);

  _Unwind_Resume(a1);
}

void std::vector<BOOL>::push_back(uint64_t *a1, _BYTE *a2)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = a1[1];
  v5 = a1[2];
  if (v4 == v5 << 6)
  {
    if ((uint64_t)(v4 + 1) < 0)
      abort();
    v6 = v5 << 7;
    if (v6 <= (v4 & 0xFFFFFFFFFFFFFFC0) + 64)
      v6 = (v4 & 0xFFFFFFFFFFFFFFC0) + 64;
    if (v4 <= 0x3FFFFFFFFFFFFFFELL)
      v7 = v6;
    else
      v7 = 0x7FFFFFFFFFFFFFFFLL;
    std::vector<BOOL>::reserve((uint64_t)a1, v7);
    v4 = a1[1];
  }
  a1[1] = v4 + 1;
  v8 = *a1;
  v9 = v4 >> 6;
  v10 = 1 << v4;
  if (*a2)
    v11 = *(_QWORD *)(v8 + 8 * v9) | v10;
  else
    v11 = *(_QWORD *)(v8 + 8 * v9) & ~v10;
  *(_QWORD *)(v8 + 8 * v9) = v11;
}

void ___ZL28CounterIndicesFromCounterSetP5NSSetP7NSArray_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  void *v5;
  id v6;

  v6 = a2;
  if (objc_msgSend(*(id *)(a1 + 32), "containsObject:"))
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", a3));
    objc_msgSend(*(id *)(a1 + 40), "setObject:forKeyedSubscript:", v5, v6);

  }
}

void sub_2C9020(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t CounterIndex(NSNumber *a1)
{
  NSNumber *v1;
  NSNumber *v2;
  uint64_t v3;

  v1 = a1;
  v2 = v1;
  if (v1)
    v3 = -[NSNumber unsignedIntValue](v1, "unsignedIntValue");
  else
    v3 = 0xFFFFFFFFLL;

  return v3;
}

void sub_2C9080(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL IsGPUPerformanceStateInduced(void *a1)
{
  void *v1;
  _BOOL8 v2;
  id v4;
  char v5;
  uint64_t v6;

  v6 = 0;
  v4 = 0;
  v5 = 0;
  v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "defaultDevice"));
  GTAGXPerfStateControl::InitWithDevice((uint64_t)&v4, v1);

  v2 = GTAGXPerfStateControl::IsGPUPerformanceStateInduced((GTAGXPerfStateControl *)&v4);
  GTAGXPerfStateControl::~GTAGXPerfStateControl(&v4);
  return v2;
}

void sub_2C90F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);

  GTAGXPerfStateControl::~GTAGXPerfStateControl((id *)va);
  _Unwind_Resume(a1);
}

id ConsistentPerformanceStateInfo(uint64_t a1)
{
  unsigned int *v2;
  NSNumber *v3;
  void *v4;
  _UNKNOWN **v5;
  void *v6;
  id v8;
  char v9;
  uint64_t v10;

  v2 = ExpectedState(a1);
  v3 = (NSNumber *)objc_claimAutoreleasedReturnValue(v2);
  v10 = 0;
  v8 = 0;
  v9 = 0;
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 8), "defaultDevice"));
  GTAGXPerfStateControl::InitWithDevice((uint64_t)&v8, v4);

  v5 = GTAGXPerfStateControl::ConsistentGPUPerfStateLevel((GTAGXPerfStateControl *)&v8, v3);
  v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  GTAGXPerfStateControl::~GTAGXPerfStateControl(&v8);

  return v6;
}

void sub_2C9198(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  va_list va;

  va_start(va, a2);

  GTAGXPerfStateControl::~GTAGXPerfStateControl((id *)va);
  _Unwind_Resume(a1);
}

id GTShaderProfilerGenerateComputedKey(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7;
  id v8;

  v7 = a4;
  v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%08u%09u%09llu_%@"), a1, a2, a3, v7);

  return v8;
}

void sub_2C9224(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void GTMTLReplayClient_init(uint64_t a1, void *a2)
{
  void *v3;
  __CFString *v4;
  void *v5;
  void *v6;
  id v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  id v24;
  id v25;
  id v26;
  __int128 v27;

  v27 = 0u;
  v23 = 0;
  v22 = 0u;
  v21 = 0u;
  v20 = 0u;
  v19 = 0u;
  v18 = 0u;
  v17 = 0u;
  v16 = 0u;
  v14 = 0u;
  v15 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  v7 = a2;
  *(_QWORD *)&v12 = 0xFF0000FF00FF00FFLL;
  *((_QWORD *)&v12 + 1) = 1082130432;
  *(_QWORD *)&v13 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", 128);
  v24 = objc_alloc_init((Class)NSOperationQueue);
  v25 = objc_alloc_init((Class)NSOperationQueue);
  v26 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", 16);
  __copy_assignment_8_8_t0w88_s88_S_s96_s104_t112w8_s120_s128_s136_t144w8_s152_s160_s168_s176_s184_s192_s200_s208_s216_s224_s232_s240_s248_S_s256_s264_s272_s280_s288(a1, (uint64_t)&v7);
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSBundle mainBundle](NSBundle, "mainBundle"));
  v4 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForInfoDictionaryKey:", CFSTR("CFBundleName")));

  if (!v4)
    v4 = CFSTR("MTLReplayController");
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("gputools.%@.parallelQueue"), v4, v7, v8, v9, v10, v11, v12, v13, v14, v15, (_QWORD)v16, *((_QWORD *)&v16 + 1), (_QWORD)v17, *((_QWORD *)&v17 + 1), (_QWORD)v18,
                   *((_QWORD *)&v18 + 1),
                   (_QWORD)v19,
                   *((_QWORD *)&v19 + 1),
                   (_QWORD)v20,
                   *((_QWORD *)&v20 + 1),
                   (_QWORD)v21,
                   *((_QWORD *)&v21 + 1),
                   (_QWORD)v22,
                   *((_QWORD *)&v22 + 1),
                   v23,
                   v24,
                   v25));
  objc_msgSend(*(id *)(a1 + 264), "setName:", v5);

  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("gputools.%@.serialQueue"), v4));
  objc_msgSend(*(id *)(a1 + 256), "setName:", v6);

  objc_msgSend(*(id *)(a1 + 256), "setMaxConcurrentOperationCount:", 1);
  __destructor_8_s88_S_s96_s104_s120_s128_s136_s152_s160_s168_s176_s184_s192_s200_s208_s216_s224_s232_s240_s248_S_s256_s264_s272_s280_s288(&v7);
}

void sub_2C93C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;

  __destructor_8_s0_s8_s24_s32_s40_s56_s64_s72_s80_s88_s96_s104_s112_s120_s128_s136_s144_s152((id *)(v3 + 96));
  _Unwind_Resume(a1);
}

void GTMTLReplayClient_setDisplayDelegate(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(a1 + 280), a2);
}

GTMTLReplayService *GTMTLReplayClient_createNewTransport(uint64_t a1, uint64_t a2, uint64_t a3, apr_allocator_t *a4)
{
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  id v10;
  id v11;
  void *v12;
  char v13;
  id v14;
  GTMTLReplayService *v15;
  id v16;
  void *v17;
  char v18;
  id v19;
  GTMTLReplayService *v20;
  _QWORD v22[4];
  id v23;
  id location;
  apr_pool_t *newpool;

  newpool = 0;
  apr_pool_create_ex(&newpool, 0, 0, a4);
  GTMTLReplayClient_init(a1, newpool);
  v5 = dispatch_queue_create("com.apple.gputools.replay", 0);
  dispatch_suspend(v5);
  v6 = GTTransportServiceDaemonConnectionNew(v5);
  v7 = objc_claimAutoreleasedReturnValue(v6);
  v8 = (void *)GTMTLReplayClient_createNewTransport_connection;
  GTMTLReplayClient_createNewTransport_connection = v7;

  objc_initWeak(&location, (id)GTMTLReplayClient_createNewTransport_connection);
  v9 = (void *)GTMTLReplayClient_createNewTransport_connection;
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472;
  v22[2] = __GTMTLReplayClient_createNewTransport_block_invoke;
  v22[3] = &unk_726500;
  objc_copyWeak(&v23, &location);
  objc_msgSend(v9, "activateWithMessageHandler:andErrorHandler:", v22, &__block_literal_global_6391);
  v10 = objc_alloc_init((Class)GTBulkDataService);
  objc_storeStrong((id *)(a1 + 288), v10);
  v11 = objc_msgSend(objc_alloc((Class)GTServiceProperties), "initWithProtocol:", &OBJC_PROTOCOL___GTBulkDataService);
  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)GTMTLReplayClient_createNewTransport_connection, "connection"));
  v13 = registerService(v12, v11);

  if ((v13 & 1) != 0)
  {
    v14 = objc_msgSend(objc_alloc((Class)GTBulkDataServiceXPCDispatcher), "initWithService:properties:", v10, v11);
    objc_msgSend((id)GTMTLReplayClient_createNewTransport_connection, "registerDispatcher:forPort:", v14, objc_msgSend(v11, "servicePort"));
    v15 = -[GTMTLReplayService initWithContext:]([GTMTLReplayService alloc], "initWithContext:", a1);
    objc_storeStrong((id *)&_observer, v15);
    v16 = objc_msgSend(objc_alloc((Class)GTServiceProperties), "initWithProtocol:", &OBJC_PROTOCOL___GTMTLReplayService);
    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)GTMTLReplayClient_createNewTransport_connection, "connection"));
    v18 = registerService(v17, v16);

    if ((v18 & 1) != 0)
    {
      v19 = objc_msgSend(objc_alloc((Class)GTMTLReplayServiceXPCDispatcher), "initWithService:properties:bulkDataService:bulkDataServiceProperties:", v15, v16, v10, v11);
      objc_msgSend((id)GTMTLReplayClient_createNewTransport_connection, "registerDispatcher:forPort:", v19, objc_msgSend(v16, "servicePort"));
      dispatch_resume(v5);
      v20 = v15;

    }
    else
    {
      v20 = 0;
    }

  }
  else
  {
    v20 = 0;
  }

  objc_destroyWeak(&v23);
  objc_destroyWeak(&location);

  return v20;
}

void sub_2C9688(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id GTMTLReplayHost_computeDerivedCountersFromData(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9;
  _UNKNOWN **v10;
  id v11;
  id v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  size_t v16;
  id v17;
  unint64_t v18;
  void *v19;
  void *v20;
  void *v21;
  id v22;
  char *v23;
  unint64_t v24;
  void *v25;
  void *v26;
  id v27;
  id v28;
  id v29;
  id v30;
  id v31;
  id v32;
  id v33;
  id v34;
  id v35;
  id v36;
  id v37;
  uint64_t v38;
  void *i;
  void *v40;
  unint64_t v41;
  void *v42;
  void *v43;
  _UNKNOWN **v44;
  id v45;
  const CATransform3D **v46;
  id v47;
  uint64_t v48;
  void *j;
  void *v50;
  unint64_t v51;
  void *v52;
  void *v53;
  id v54;
  id v55;
  uint64_t v56;
  void *k;
  void *v58;
  void *v59;
  id v60;
  id v61;
  id v62;
  id v63;
  uint64_t v64;
  void *m;
  uint64_t v66;
  void *v67;
  void *v68;
  const OpaqueJSContext *v69;
  void *v70;
  const OpaqueJSContext *v71;
  void *v72;
  const OpaqueJSContext *v73;
  void *v74;
  const OpaqueJSContext *v75;
  id v76;
  id v77;
  unint64_t v78;
  void *v79;
  void *v80;
  const OpaqueJSContext *v81;
  const OpaqueJSContext *v82;
  void *v83;
  void *v84;
  const OpaqueJSContext *v85;
  const OpaqueJSContext *v86;
  const OpaqueJSContext *v87;
  void *v88;
  void *v89;
  const OpaqueJSContext *v90;
  id v91;
  id v92;
  void *v93;
  FILE *v94;
  const char *v95;
  id v96;
  id v97;
  id v98;
  void *v99;
  id v100;
  char *v101;
  unint64_t v102;
  void *v103;
  void *v104;
  id v105;
  id v106;
  void *v107;
  FILE *v108;
  const char *v109;
  id v110;
  void *v111;
  id v112;
  void *v113;
  FILE *v114;
  const char *v115;
  id v116;
  id v117;
  id v118;
  id v119;
  void *v120;
  FILE *v121;
  const char *v122;
  id v123;
  id v124;
  id v125;
  id v126;
  id v127;
  id v128;
  id v129;
  uint64_t v130;
  void *n;
  void *v132;
  __CFString *v133;
  __CFString *v134;
  __CFString *v135;
  const __CFString *v136;
  const __CFString *v137;
  const __CFString *v138;
  void *v139;
  id v140;
  void *v141;
  void *v142;
  uint64_t v143;
  void *v144;
  void *v145;
  void *v146;
  void *v147;
  id v148;
  id v149;
  void *v150;
  FILE *v151;
  const char *v152;
  id v153;
  id v154;
  id v156;
  id v157;
  void *v158;
  id v159;
  id v160;
  JSObjectRef v161;
  JSObjectRef v162;
  JSObjectRef v163;
  char *v164;
  id v165;
  id v166;
  id v167;
  id v168;
  id v169;
  id v170;
  id v171;
  id v172;
  id v173;
  __int128 v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  __int128 v189;
  __int128 v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  _QWORD v194[2];
  _QWORD v195[2];
  _QWORD v196[2];
  _QWORD v197[2];
  _QWORD v198[4];
  _QWORD v199[4];
  _BYTE v200[128];
  _BYTE v201[128];
  _BYTE v202[128];
  _BYTE v203[128];
  _QWORD v204[4];
  JSValueRef exception[16];

  v9 = a1;
  v169 = a2;
  v10 = &off_738BE0;
  v168 = a3;
  v11 = a4;
  v12 = a5;
  v13 = objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "objectForKeyedSubscript:", CFSTR("DerivedCounterScript")));
  v14 = (void *)v13;
  if (v13)
  {
    v158 = (void *)v13;
    v173 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "objectForKeyedSubscript:", CFSTR("DerivedCounterConfigurationVariables")));
    v167 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", (char *)objc_msgSend(v11, "count")+ (_QWORD)objc_msgSend(v9, "count")+ (unint64_t)objc_msgSend(&off_738BE0, "count"));
    objc_msgSend(v9, "count");
    __chkstk_darwin();
    v164 = (char *)&v156 - v15;
    bzero((char *)&v156 - v15, v16);
    v17 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", objc_msgSend(v9, "count"));
    if (objc_msgSend(v9, "count"))
    {
      v18 = 0;
      do
      {
        v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectAtIndexedSubscript:", v18));
        v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", v18));
        objc_msgSend(v17, "setObject:forKeyedSubscript:", v20, v19);

        ++v18;
      }
      while (v18 < (unint64_t)objc_msgSend(v9, "count"));
    }
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "sortedArrayUsingSelector:", "compare:"));
    v22 = objc_msgSend(v21, "count");
    v23 = v164;
    if (v22)
    {
      v24 = 0;
      do
      {
        v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "objectAtIndexedSubscript:", v24));
        v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "objectForKeyedSubscript:", v25));
        *(_DWORD *)&v23[4 * v24] = objc_msgSend(v26, "intValue");

        ++v24;
      }
      while (v24 < (unint64_t)objc_msgSend(v21, "count"));
    }
    v27 = v167;
    v160 = v11;
    objc_msgSend(v167, "addObjectsFromArray:", v11);
    objc_msgSend(v27, "addObjectsFromArray:", v21);
    objc_msgSend(v27, "addObjectsFromArray:", &off_738BE0);

    v28 = objc_alloc((Class)NSMutableArray);
    v29 = v169;
    v166 = objc_msgSend(v28, "initWithCapacity:", objc_msgSend(v169, "count"));
    v165 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", objc_msgSend(v29, "count"));
    v30 = objc_alloc_init((Class)JSVirtualMachine);
    v31 = objc_alloc((Class)JSContext);
    v156 = v30;
    v32 = objc_msgSend(v31, "initWithVirtualMachine:", v30);
    objc_msgSend(v32, "setObject:forKeyedSubscript:", &__block_literal_global_6415, CFSTR("ErrorLog"));
    objc_msgSend(v32, "setExceptionHandler:", &__block_literal_global_20);
    v33 = objc_msgSend(v32, "evaluateScript:", v158);
    v34 = objc_alloc_init((Class)NSMutableArray);
    v186 = 0u;
    v187 = 0u;
    v188 = 0u;
    v189 = 0u;
    v157 = v9;
    v35 = v9;
    v36 = objc_msgSend(v35, "countByEnumeratingWithState:objects:count:", &v186, v203, 16);
    if (v36)
    {
      v37 = v36;
      v38 = *(_QWORD *)v187;
      do
      {
        for (i = 0; i != v37; i = (char *)i + 1)
        {
          if (*(_QWORD *)v187 != v38)
            objc_enumerationMutation(v35);
          v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("var %@ = 0;"),
                            *(_QWORD *)(*((_QWORD *)&v186 + 1) + 8 * (_QWORD)i)));
          objc_msgSend(v34, "addObject:", v40);

        }
        v37 = objc_msgSend(v35, "countByEnumeratingWithState:objects:count:", &v186, v203, 16);
      }
      while (v37);
    }
    v159 = v12;

    objc_msgSend(v34, "addObject:", CFSTR("function _SetRawCounterValues() {"));
    if (objc_msgSend(v35, "count"))
    {
      v41 = 0;
      do
      {
        v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "objectAtIndexedSubscript:", v41));
        v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("\t%@ = _RawCounterValues[%lu];"),
                          v42,
                          v41));
        objc_msgSend(v34, "addObject:", v43);

        ++v41;
      }
      while (v41 < (unint64_t)objc_msgSend(v35, "count"));
    }
    objc_msgSend(v34, "addObject:", CFSTR("}"));
    v184 = 0u;
    v185 = 0u;
    v182 = 0u;
    v183 = 0u;
    v44 = &off_738BE0;
    v45 = objc_msgSend(&off_738BE0, "countByEnumeratingWithState:objects:count:", &v182, v202, 16);
    v46 = &CATransform3DIdentity_ptr;
    if (v45)
    {
      v47 = v45;
      v48 = *(_QWORD *)v183;
      do
      {
        for (j = 0; j != v47; j = (char *)j + 1)
        {
          if (*(_QWORD *)v183 != v48)
            objc_enumerationMutation(&off_738BE0);
          v50 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D stringWithFormat:]((id)v46[296], "stringWithFormat:", CFSTR("var %@ = 0;"),
                            *(_QWORD *)(*((_QWORD *)&v182 + 1) + 8 * (_QWORD)j)));
          objc_msgSend(v34, "addObject:", v50);

          v46 = &CATransform3DIdentity_ptr;
        }
        v47 = objc_msgSend(&off_738BE0, "countByEnumeratingWithState:objects:count:", &v182, v202, 16);
      }
      while (v47);
    }

    objc_msgSend(v34, "addObject:", CFSTR("function _SetSoftwareCounterValues() {"));
    if (objc_msgSend(&off_738BE0, "count"))
    {
      v51 = 0;
      do
      {
        v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(&off_738BE0, "objectAtIndexedSubscript:", v51));
        v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("\t%@ = _SoftwareCounterValues[%lu];"),
                          v52,
                          v51));
        objc_msgSend(v34, "addObject:", v53);

        v46 = &CATransform3DIdentity_ptr;
        ++v51;
      }
      while (v51 < (unint64_t)objc_msgSend(&off_738BE0, "count"));
    }
    objc_msgSend(v34, "addObject:", CFSTR("}"));
    objc_msgSend(v34, "addObject:", CFSTR("var _DerivedCounterResult = [];"));
    objc_msgSend(v34, "addObject:", CFSTR("function _EvaluteDerivedCounters() {"));
    objc_msgSend(v34, "addObject:", CFSTR("\t_DerivedCounterResult = [];"));
    v180 = 0u;
    v181 = 0u;
    v178 = 0u;
    v179 = 0u;
    v171 = v160;
    v54 = objc_msgSend(v171, "countByEnumeratingWithState:objects:count:", &v178, v201, 16);
    if (v54)
    {
      v55 = v54;
      v56 = *(_QWORD *)v179;
      do
      {
        for (k = 0; k != v55; k = (char *)k + 1)
        {
          if (*(_QWORD *)v179 != v56)
            objc_enumerationMutation(v171);
          v58 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D stringWithFormat:]((id)v46[296], "stringWithFormat:", CFSTR("\ttry { value = %@(); if (!isFinite(value)) { value = 0; } _DerivedCounterResult.push(value); } catch(err) { ErrorLog(err); _DerivedCounterResult.push(0); }"),
                            *(_QWORD *)(*((_QWORD *)&v178 + 1) + 8 * (_QWORD)k)));
          objc_msgSend(v34, "addObject:", v58);

        }
        v55 = objc_msgSend(v171, "countByEnumeratingWithState:objects:count:", &v178, v201, 16);
      }
      while (v55);
    }

    objc_msgSend(v34, "addObject:", CFSTR("}"));
    v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v34, "componentsJoinedByString:", CFSTR("\n")));
    v60 = objc_msgSend(v32, "evaluateScript:", v59);

    v176 = 0u;
    v177 = 0u;
    v174 = 0u;
    v175 = 0u;
    v61 = v173;
    v62 = objc_msgSend(v61, "countByEnumeratingWithState:objects:count:", &v174, v200, 16);
    v173 = v61;
    if (v62)
    {
      v63 = v62;
      v64 = *(_QWORD *)v175;
      do
      {
        for (m = 0; m != v63; m = (char *)m + 1)
        {
          if (*(_QWORD *)v175 != v64)
            objc_enumerationMutation(v61);
          v66 = *(_QWORD *)(*((_QWORD *)&v174 + 1) + 8 * (_QWORD)m);
          v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v61, "objectForKeyedSubscript:", v66));
          v68 = (void *)objc_claimAutoreleasedReturnValue(+[JSValue valueWithObject:inContext:](JSValue, "valueWithObject:inContext:", v67, v32));
          objc_msgSend(v32, "setObject:forKeyedSubscript:", v68, v66);

          v61 = v173;
        }
        v63 = objc_msgSend(v173, "countByEnumeratingWithState:objects:count:", &v174, v200, 16);
      }
      while (v63);
    }

    exception[0] = 0;
    v69 = (const OpaqueJSContext *)objc_msgSend(v32, "JSGlobalContextRef");
    v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "objectForKeyedSubscript:", CFSTR("_SetSoftwareCounterValues")));
    v161 = JSValueToObject(v69, (JSValueRef)objc_msgSend(v70, "JSValueRef"), exception);

    v71 = (const OpaqueJSContext *)objc_msgSend(v32, "JSGlobalContextRef");
    v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "objectForKeyedSubscript:", CFSTR("_SetRawCounterValues")));
    v163 = JSValueToObject(v71, (JSValueRef)objc_msgSend(v72, "JSValueRef"), exception);

    v73 = (const OpaqueJSContext *)objc_msgSend(v32, "JSGlobalContextRef");
    v74 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "objectForKeyedSubscript:", CFSTR("_EvaluteDerivedCounters")));
    v162 = JSValueToObject(v73, (JSValueRef)objc_msgSend(v74, "JSValueRef"), exception);

    v75 = (const OpaqueJSContext *)objc_msgSend(v32, "JSGlobalContextRef");
    LogException(v75, exception[0]);
    v76 = objc_msgSend(v169, "count");
    v77 = v168;
    if (v76)
    {
      v78 = 0;
      do
      {
        v170 = objc_autoreleasePoolPush();
        if (objc_msgSend(v77, "count"))
        {
          v79 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v77, "objectAtIndexedSubscript:", v78));
          v80 = (void *)objc_claimAutoreleasedReturnValue(+[JSValue valueWithObject:inContext:](JSValue, "valueWithObject:inContext:", v79, v32));
          objc_msgSend(v32, "setObject:forKeyedSubscript:", v80, CFSTR("_SoftwareCounterValues"));

          v81 = (const OpaqueJSContext *)objc_msgSend(v32, "JSGlobalContextRef");
          JSObjectCallAsFunction(v81, v161, 0, 0, 0, exception);
          v82 = (const OpaqueJSContext *)objc_msgSend(v32, "JSGlobalContextRef");
          LogException(v82, exception[0]);
        }
        v83 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v169, "objectAtIndexedSubscript:", v78));
        v84 = (void *)objc_claimAutoreleasedReturnValue(+[JSValue valueWithObject:inContext:](JSValue, "valueWithObject:inContext:", v83, v32));
        objc_msgSend(v32, "setObject:forKeyedSubscript:", v84, CFSTR("_RawCounterValues"));

        v85 = (const OpaqueJSContext *)objc_msgSend(v32, "JSGlobalContextRef");
        JSObjectCallAsFunction(v85, v163, 0, 0, 0, exception);
        v86 = (const OpaqueJSContext *)objc_msgSend(v32, "JSGlobalContextRef");
        LogException(v86, exception[0]);
        v87 = (const OpaqueJSContext *)objc_msgSend(v32, "JSGlobalContextRef");
        JSObjectCallAsFunction(v87, v162, 0, 0, 0, exception);
        v88 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "objectForKeyedSubscript:", CFSTR("_DerivedCounterResult")));
        v89 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "toArray"));

        v90 = (const OpaqueJSContext *)objc_msgSend(v32, "JSGlobalContextRef");
        LogException(v90, exception[0]);
        objc_msgSend(v166, "addObject:", v89);
        v91 = objc_msgSend(v89, "count");
        if (v91 != objc_msgSend(v171, "count"))
        {
          v92 = objc_msgSend(v89, "count");
          v93 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("derivedCounterResult contains %lu results, %lu expected (derivedCounterNames)"), v92, objc_msgSend(v171, "count")));
          v94 = __stdoutp;
          if (g_runningInCI)
            v95 = "#CI_ERROR# ";
          else
            v95 = "";
          v96 = objc_retainAutorelease(v93);
          fprintf(v94, "%s%s %u: %s\n", v95, "NSDictionary *GTMTLReplayHost_computeDerivedCountersFromData(NSArray *__strong, NSArray *__strong, NSArray *__strong, NSArray *__strong, NSArray *__strong, NSDictionary *__strong)", 190, (const char *)objc_msgSend(v96, "UTF8String"));
          v97 = objc_retainAutorelease(v96);
          GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v97, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/launcher/DYJavaScriptHelper.m", (uint64_t)"GTMTLReplayHost_computeDerivedCountersFromData", 190, 2);

        }
        v172 = v89;
        v98 = objc_msgSend(v89, "mutableCopy");
        v99 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v169, "objectAtIndexedSubscript:", v78));
        v100 = objc_msgSend(v35, "count");
        v101 = v164;
        if (v100)
        {
          v102 = 0;
          do
          {
            v103 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v99, "objectAtIndexedSubscript:", *(int *)&v101[4 * v102]));
            objc_msgSend(v98, "addObject:", v103);

            ++v102;
          }
          while (v102 < (unint64_t)objc_msgSend(v35, "count"));
        }
        v77 = v168;
        v104 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v168, "objectAtIndexedSubscript:", v78));
        objc_msgSend(v98, "addObjectsFromArray:", v104);

        objc_msgSend(v165, "addObject:", v98);
        v105 = objc_msgSend(v98, "count");
        if (v105 != objc_msgSend(v167, "count"))
        {
          v106 = objc_msgSend(v172, "count");
          v107 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("resultsForAnalysis contains %lu results, %lu expected (counterNamesForAnalysis)"), v106, objc_msgSend(v167, "count")));
          v108 = __stdoutp;
          if (g_runningInCI)
            v109 = "#CI_ERROR# ";
          else
            v109 = "";
          v110 = objc_retainAutorelease(v107);
          fprintf(v108, "%s%s %u: %s\n", v109, "NSDictionary *GTMTLReplayHost_computeDerivedCountersFromData(NSArray *__strong, NSArray *__strong, NSArray *__strong, NSArray *__strong, NSArray *__strong, NSDictionary *__strong)", 208, (const char *)objc_msgSend(v110, "UTF8String"));
          v111 = v110;
          v77 = v168;
          v112 = objc_retainAutorelease(v111);
          GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v112, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/launcher/DYJavaScriptHelper.m", (uint64_t)"GTMTLReplayHost_computeDerivedCountersFromData", 208, 2);

        }
        objc_autoreleasePoolPop(v170);
        ++v78;
      }
      while (v78 < (unint64_t)objc_msgSend(v169, "count"));
    }

    if (!objc_msgSend(v166, "count"))
    {
      v113 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("derivedDataResults contains no results")));
      v114 = __stdoutp;
      if (g_runningInCI)
        v115 = "#CI_ERROR# ";
      else
        v115 = "";
      v116 = objc_retainAutorelease(v113);
      fprintf(v114, "%s%s %u: %s\n", v115, "NSDictionary *GTMTLReplayHost_computeDerivedCountersFromData(NSArray *__strong, NSArray *__strong, NSArray *__strong, NSArray *__strong, NSArray *__strong, NSDictionary *__strong)", 216, (const char *)objc_msgSend(v116, "UTF8String"));
      v117 = objc_retainAutorelease(v116);
      GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v117, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/launcher/DYJavaScriptHelper.m", (uint64_t)"GTMTLReplayHost_computeDerivedCountersFromData", 216, 2);

    }
    v118 = objc_msgSend(v165, "count");
    v119 = v159;
    if (!v118)
    {
      v120 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("derivedDataResultsForBottleNeckAnalysis contains no results")));
      v121 = __stdoutp;
      if (g_runningInCI)
        v122 = "#CI_ERROR# ";
      else
        v122 = "";
      v123 = objc_retainAutorelease(v120);
      fprintf(v121, "%s%s %u: %s\n", v122, "NSDictionary *GTMTLReplayHost_computeDerivedCountersFromData(NSArray *__strong, NSArray *__strong, NSArray *__strong, NSArray *__strong, NSArray *__strong, NSDictionary *__strong)", 221, (const char *)objc_msgSend(v123, "UTF8String"));
      v124 = objc_retainAutorelease(v123);
      GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v124, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/launcher/DYJavaScriptHelper.m", (uint64_t)"GTMTLReplayHost_computeDerivedCountersFromData", 221, 2);

    }
    v164 = (char *)objc_claimAutoreleasedReturnValue(objc_msgSend(v119, "objectForKeyedSubscript:", CFSTR("DerivedCounterDictionary")));
    v172 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v164, "objectForKeyedSubscript:", CFSTR("DerivedCounters")));
    v125 = v171;
    v171 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", 0);
    v126 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", 0);
    v127 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", 0);
    v190 = 0u;
    v191 = 0u;
    v192 = 0u;
    v193 = 0u;
    v170 = v125;
    v128 = objc_msgSend(v170, "countByEnumeratingWithState:objects:count:", &v190, exception, 16);
    if (v128)
    {
      v129 = v128;
      v130 = *(_QWORD *)v191;
      do
      {
        for (n = 0; n != v129; n = (char *)n + 1)
        {
          if (*(_QWORD *)v191 != v130)
            objc_enumerationMutation(v170);
          v132 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v172, "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v190 + 1) + 8 * (_QWORD)n)));
          v133 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v132, "objectForKeyedSubscript:", CFSTR("name")));
          v134 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v132, "objectForKeyedSubscript:", CFSTR("description")));
          v135 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v132, "objectForKeyedSubscript:", CFSTR("type")));
          if (v133)
            v136 = v133;
          else
            v136 = CFSTR("Unknown");
          objc_msgSend(v171, "addObject:", v136);
          if (v134)
            v137 = v134;
          else
            v137 = &stru_7282A8;
          objc_msgSend(v126, "addObject:", v137);
          if (v135)
            v138 = v135;
          else
            v138 = CFSTR("Value");
          objc_msgSend(v127, "addObject:", v138);

        }
        v129 = objc_msgSend(v170, "countByEnumeratingWithState:objects:count:", &v190, exception, 16);
      }
      while (v129);
    }
    v139 = v170;

    v140 = v171;
    v204[0] = v139;
    v204[1] = v171;
    v204[2] = v126;
    v204[3] = v127;
    v141 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v204, 4));

    v12 = v159;
    v142 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v159, "objectForKeyedSubscript:", CFSTR("DerivedCounterAnalysis")));
    v144 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v164, "objectForKeyedSubscript:", CFSTR("Bottlenecks")));
    if (!v144)
      v144 = (void *)objc_opt_new(NSDictionary, v143);
    v198[0] = CFSTR("derivedCounterDataForBottleneckAnalysis");
    v196[0] = CFSTR("AverageSamples");
    v196[1] = CFSTR("counters");
    v197[0] = v165;
    v197[1] = v167;
    v145 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v197, v196, 2));
    v199[0] = v145;
    v198[1] = CFSTR("derivedCounterData");
    v194[0] = CFSTR("AverageSamples");
    v194[1] = CFSTR("counters");
    v195[0] = v166;
    v195[1] = v141;
    v146 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v195, v194, 2));
    v199[1] = v146;
    v199[2] = v142;
    v198[2] = CFSTR("DerivedCounterAnalysis");
    v198[3] = CFSTR("DerivedCounterAnalysisFunctions");
    v199[3] = v144;
    v147 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v199, v198, 4));

    v148 = v173;
    if (v173)
    {
      v149 = objc_msgSend(v147, "mutableCopy");
      objc_msgSend(v149, "setObject:forKeyedSubscript:", v148, CFSTR("DerivedCounterConfigurationVariables"));

      v147 = v149;
    }
    v9 = v157;
    v14 = v158;

    v11 = v160;
  }
  else
  {
    v150 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("derivedScriptCode missing")));
    v151 = __stdoutp;
    if (g_runningInCI)
      v152 = "#CI_ERROR# ";
    else
      v152 = "";
    v153 = objc_retainAutorelease(v150);
    fprintf(v151, "%s%s %u: %s\n", v152, "NSDictionary *GTMTLReplayHost_computeDerivedCountersFromData(NSArray *__strong, NSArray *__strong, NSArray *__strong, NSArray *__strong, NSArray *__strong, NSDictionary *__strong)", 59, (const char *)objc_msgSend(v153, "UTF8String"));
    v154 = objc_retainAutorelease(v153);
    GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v154, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/launcher/DYJavaScriptHelper.m", (uint64_t)"GTMTLReplayHost_computeDerivedCountersFromData", 59, 2);

    v147 = &__NSDictionary0__struct;
  }

  return v147;
}

void LogException(const OpaqueJSContext *a1, const OpaqueJSValue *a2)
{
  OpaqueJSString *v2;
  size_t MaximumUTF8CStringSize;
  uint64_t v4;
  char *v5;
  id v6;
  uint64_t v7;

  if (a2)
  {
    v2 = JSValueToStringCopy(a1, a2, 0);
    MaximumUTF8CStringSize = JSStringGetMaximumUTF8CStringSize(v2);
    __chkstk_darwin();
    v5 = (char *)&v7 - v4;
    bzero((char *)&v7 - v4, MaximumUTF8CStringSize);
    JSStringGetUTF8CString(v2, v5, MaximumUTF8CStringSize);
    JSStringRelease(v2);
    v6 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v5);
    NSLog(CFSTR("[DYJSScripting] \"%@\""), v6);

  }
}

void sub_2CAF48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_2CB07C(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 56));
  _Unwind_Resume(a1);
}

void sub_2CB298(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 72));
  _Unwind_Resume(a1);
}

void sub_2CB3C8(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 56));
  _Unwind_Resume(a1);
}

void sub_2CB540(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  id *v20;
  uint64_t v21;

  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Block_object_dispose((const void *)(v21 - 80), 8);
  _Unwind_Resume(a1);
}

id GTMTLReplayClient_loadDerivedCounterInfo(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  void *v6;
  id v7;
  id v8;
  id v9;
  void *v10;
  id v11;
  id v12;
  void *v13;
  __CFString *v14;
  const __CFString *v15;
  void *v16;
  _QWORD v18[3];
  _QWORD v19[3];

  v3 = a2;
  v4 = a1;
  v5 = objc_alloc((Class)NSURL);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "stringByAppendingString:", CFSTR("-counters.plist")));

  v7 = objc_msgSend(v5, "initFileURLWithPath:isDirectory:", v6, 0);
  v8 = objc_msgSend(objc_alloc((Class)NSDictionary), "initWithContentsOfURL:error:", v7, 0);
  if (v8)
  {
    v9 = objc_alloc((Class)NSString);
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "stringByAppendingString:", CFSTR("-derived.js")));
    v11 = objc_msgSend(v9, "initWithContentsOfFile:encoding:error:", v10, 4, 0);

    v12 = objc_alloc((Class)NSString);
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "stringByAppendingString:", CFSTR("-analysis.js")));
    v14 = (__CFString *)objc_msgSend(v12, "initWithContentsOfFile:encoding:error:", v13, 4, 0);

    v18[0] = CFSTR("DerivedCounterDictionary");
    v18[1] = CFSTR("DerivedCounterScript");
    v19[0] = v8;
    v19[1] = v11;
    v18[2] = CFSTR("DerivedCounterAnalysis");
    v15 = &stru_7282A8;
    if (v14)
      v15 = v14;
    v19[2] = v15;
    v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v19, v18, 3));

  }
  else
  {
    v16 = 0;
  }

  return v16;
}

id GTMTLReplayClient_mergeDerivedCounterInfo(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  void *v6;
  void *v7;
  id v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  id v16;

  v3 = a1;
  v4 = a2;
  v5 = objc_msgSend(v3, "mutableCopy");
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("DerivedCounterDictionary")));
  if (v6)
  {
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("DerivedCounterDictionary")));
    verifyCounterDictionary(v7);
    v8 = MergeDictionaries(v7, v6);
    v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v9, CFSTR("DerivedCounterDictionary"));

  }
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("DerivedCounterScript")));
  if (v10)
  {
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("DerivedCounterScript")));
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "stringByAppendingString:", v10));
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v12, CFSTR("DerivedCounterScript"));

  }
  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("DerivedCounterAnalysis")));
  if (v13)
  {
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("DerivedCounterAnalysis")));
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "stringByAppendingString:", v13));
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v15, CFSTR("DerivedCounterAnalysis"));

  }
  v16 = objc_msgSend(v5, "copy");

  return v16;
}

uint64_t verifyCounterDictionary(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  id v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  FILE *v8;
  const char *v9;
  id v10;
  id v11;

  v1 = a1;
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "objectForKeyedSubscript:", CFSTR("DerivedCounters")));

  if (v2)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "objectForKeyedSubscript:", CFSTR("DerivedCounters")));
    v4 = objc_msgSend(v3, "count");

    if (v4)
    {
      v5 = 1;
      goto LABEL_10;
    }
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("No derived counters in plist")));
    v7 = 982;
  }
  else
  {
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@ missing in plist"), CFSTR("DerivedCounters")));
    v7 = 977;
  }
  v8 = __stdoutp;
  if (g_runningInCI)
    v9 = "#CI_ERROR# ";
  else
    v9 = "";
  v10 = objc_retainAutorelease(v6);
  fprintf(v8, "%s%s %u: %s\n", v9, "_Bool verifyCounterDictionary(NSDictionary *__strong)", v7, (const char *)objc_msgSend(v10, "UTF8String"));
  v11 = objc_retainAutorelease(v10);
  GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v11, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_frameProfiler.m", (uint64_t)"verifyCounterDictionary", v7, 1);

  v5 = 0;
LABEL_10:

  return v5;
}

id MergeDictionaries(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  id v6;
  id v7;
  void **v9;
  uint64_t v10;
  void (*v11)(uint64_t, void *, void *);
  void *v12;
  id v13;
  id v14;

  v3 = a1;
  v4 = a2;
  v9 = _NSConcreteStackBlock;
  v10 = 3221225472;
  v11 = __MergeDictionaries_block_invoke;
  v12 = &unk_7267C8;
  v13 = v3;
  v14 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithDictionary:", v3);
  v5 = v14;
  v6 = v3;
  objc_msgSend(v4, "enumerateKeysAndObjectsUsingBlock:", &v9);

  v7 = objc_msgSend(v5, "copy", v9, v10, v11, v12);
  return v7;
}

void __debugDumpCounterDictionary_block_invoke(id a1, NSString *a2, NSDictionary *a3, BOOL *a4)
{
  NSString *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  FILE *v10;
  id v11;

  if (g_runningInCI)
  {
    v5 = a2;
    v6 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](a3, "objectForKeyedSubscript:", CFSTR("counters")));
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "componentsJoinedByString:", CFSTR(",")));
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Counter %@:%@"), v5, v7));

    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));
    v10 = __stdoutp;
    v11 = objc_retainAutorelease(v9);
    fprintf(v10, "#CI-INFO# %s\n", (const char *)objc_msgSend(v11, "UTF8String"));

  }
}

id DYMTLReplayFrameProfiler_loadAnalysis(void *a1)
{
  id v1;
  io_registry_entry_t v2;
  void *CFProperty;
  void *v4;
  void *v5;
  void *v6;
  FILE *v7;
  id v8;
  CFTypeRef v9;
  void *v10;
  CFTypeID v11;
  id v12;
  id v13;
  void *v14;
  id v15;
  void *v16;
  unsigned int v17;
  void *v18;
  unsigned int v19;
  void *v20;
  void *v21;
  id v22;
  void *v23;
  void *v24;
  void *v25;
  FILE *v26;
  const char *v27;
  id v28;
  id v29;
  id v30;
  void *v31;
  void *v32;
  const __CFString *v33;
  const __CFString *v34;
  const __CFString *v35;
  void *v36;
  void *v37;
  FILE *v38;
  id v39;
  unsigned int v40;
  void *v41;
  id v42;
  void *v43;
  void *v44;
  CFTypeRef v45;
  void *v46;
  void *v47;
  const __CFString *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  id v53;
  id v54;
  uint64_t v55;
  void *i;
  uint64_t v57;
  void *v58;
  void *v59;
  id v60;
  void *v61;
  void *v62;
  void *v63;
  FILE *v64;
  id v65;
  id DerivedCounterInfo;
  void *v67;
  void *v68;
  _BOOL4 v69;
  id v70;
  void *v71;
  void *v72;
  void *v73;
  FILE *v74;
  id v75;
  void *v76;
  FILE *v77;
  const char *v78;
  id v79;
  id v80;
  void *v81;
  id v82;
  void *v83;
  void *v84;
  void *v85;
  id v86;
  void *v87;
  void *v88;
  void *v89;
  FILE *v90;
  id v91;
  void *v92;
  void *v93;
  id v94;
  uint64_t v95;
  void *j;
  uint64_t v97;
  void *v98;
  _BOOL4 v99;
  void *v100;
  FILE *v101;
  const char *v102;
  id v103;
  id v104;
  void *v105;
  void *v106;
  FILE *v107;
  id v108;
  void *v109;
  FILE *v110;
  const char *v111;
  id v112;
  void *v113;
  FILE *v114;
  const char *v115;
  id v116;
  uint64_t v118;
  uint64_t v119;
  __CFString *v120;
  void *v121;
  id v122;
  void *v123;
  void *v124;
  id v125;
  id obj;
  id obja;
  void *v128;
  void *v129;
  void *v130;
  void *v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  const __CFString *v144;
  _UNKNOWN **v145;
  _QWORD v146[2];
  _QWORD v147[2];
  _QWORD v148[2];
  _QWORD v149[2];
  _BYTE v150[128];
  _BYTE v151[128];
  _QWORD v152[3];
  _BYTE v153[128];

  v1 = DEVICEOBJECT(a1);
  v130 = (void *)objc_claimAutoreleasedReturnValue(v1);
  v2 = objc_msgSend(v130, "acceleratorPort");
  CFProperty = (void *)IORegistryEntryCreateCFProperty(v2, CFSTR("GPUConfigurationVariable"), 0, 0);
  if (g_runningInCI)
  {
    v4 = CFProperty;
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Configuration Variables=%@"), CFProperty));
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

    v7 = __stdoutp;
    v8 = objc_retainAutorelease(v6);
    fprintf(v7, "#CI-INFO# %s\n", (const char *)objc_msgSend(v8, "UTF8String"));

    CFProperty = v4;
  }
  v9 = IORegistryEntryCreateCFProperty(v2, CFSTR("MetalStatisticsName"), 0, 0);
  v129 = CFProperty;
  if (!v9)
  {
    if (CFProperty)
    {
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(CFProperty, "objectForKeyedSubscript:", CFSTR("gpu_gen")));
      v15 = objc_msgSend(v14, "unsignedIntValue");

      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v129, "objectForKeyedSubscript:", CFSTR("num_cores")));
      v17 = objc_msgSend(v16, "unsignedIntValue");

      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v129, "objectForKeyedSubscript:", CFSTR("num_mgpus")));
      v19 = objc_msgSend(v18, "unsignedIntValue");

      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v129, "objectForKeyedSubscript:", CFSTR("usc_gen")));
      v21 = v20;
      if (v20 && objc_msgSend(v20, "unsignedIntValue") > 2)
      {

        goto LABEL_18;
      }
      if (v15 < 0xE)
      {
        v13 = 0;
      }
      else
      {
        v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableString stringWithFormat:](NSMutableString, "stringWithFormat:", CFSTR("AGXMetalStatisticsG%u"), v15));
        v32 = v31;
        v33 = CFSTR("D");
        v34 = CFSTR("P");
        if (v17 > 6)
          v34 = CFSTR("G");
        if (v19 == 4)
          v34 = CFSTR("C");
        if (v19 != 8)
          v33 = v34;
        if (v19 == 2)
          v35 = CFSTR("S");
        else
          v35 = v33;
        objc_msgSend(v31, "appendString:", v35);
        v13 = objc_msgSend(v32, "copy");

      }
    }
    else
    {
      v13 = 0;
    }
LABEL_33:
    v128 = v13;
    if (g_runningInCI)
    {
      v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("statisticsName=%@"), v13));
      v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v36, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

      v38 = __stdoutp;
      v39 = objc_retainAutorelease(v37);
      fprintf(v38, "#CI-INFO# %s\n", (const char *)objc_msgSend(v39, "UTF8String"));

    }
    v131 = (void *)IORegistryEntryCreateCFProperty(v2, CFSTR("MetalPluginName"), 0, 0);
    v40 = objc_msgSend(v131, "containsString:", CFSTR("AGXMetal"));
    v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", 2));
    objc_msgSend(v41, "addObject:", v13);
    if (v40)
    {
      v42 = objc_msgSend(v13, "rangeOfString:", CFSTR("AGXMetalStatistics"));
      if (objc_msgSend(v13, "rangeOfString:", CFSTR("AGXMetalStatisticsExternal")) == (id)0x7FFFFFFFFFFFFFFFLL
        && v42 < objc_msgSend(v13, "length"))
      {
        v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "substringFromIndex:", objc_msgSend(CFSTR("AGXMetalStatistics"), "length")));
        v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(CFSTR("AGXMetalStatisticsExternal"), "stringByAppendingString:", v43));

        objc_msgSend(v41, "addObject:", v44);
      }
    }
    v45 = IORegistryEntryCreateCFProperty(v2, CFSTR("MetalStatisticsScriptName"), 0, 0);
    v46 = (void *)IORegistryEntryCreateCFProperty(v2, CFSTR("AGXInternalPerfCounterResourcesPath"), 0, 0);
    if (v46)
    {
      v47 = v46;
      v48 = (const __CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v46, "stringByAppendingString:", CFSTR("/%@/%@")));

    }
    else
    {
      v48 = CFSTR("/AppleInternal/Library/AGX/Performance/%@/%@");
    }
    v120 = (__CFString *)v48;
    v152[0] = v48;
    v152[1] = CFSTR("/System/Library/Extensions/%@.bundle/%@");
    v152[2] = CFSTR("/System/Library/Extensions/%@.bundle/Contents/Resources/%@");
    v124 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v152, 3));
    v138 = 0u;
    v139 = 0u;
    v136 = 0u;
    v137 = 0u;
    obj = v41;
    v122 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v136, v151, 16);
    if (v122)
    {
      v49 = *(_QWORD *)v137;
      v118 = *(_QWORD *)v137;
      do
      {
        v50 = 0;
        do
        {
          if (*(_QWORD *)v137 != v49)
          {
            v51 = v50;
            objc_enumerationMutation(obj);
            v50 = v51;
          }
          v119 = v50;
          v52 = *(_QWORD *)(*((_QWORD *)&v136 + 1) + 8 * v50);
          v132 = 0u;
          v133 = 0u;
          v134 = 0u;
          v135 = 0u;
          v53 = v124;
          v54 = objc_msgSend(v53, "countByEnumeratingWithState:objects:count:", &v132, v150, 16);
          if (v54)
          {
            v55 = *(_QWORD *)v133;
            while (2)
            {
              for (i = 0; i != v54; i = (char *)i + 1)
              {
                if (*(_QWORD *)v133 != v55)
                  objc_enumerationMutation(v53);
                v57 = *(_QWORD *)(*((_QWORD *)&v132 + 1) + 8 * (_QWORD)i);
                v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", v57, v131, v52));
                v59 = v58;
                if (v45)
                  v60 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", v57, v131, v45));
                else
                  v60 = v58;
                v61 = v60;
                if (g_runningInCI)
                {
                  v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Checking with plistPrefix=%@, scriptPrefix=%@"), v59, v60));
                  v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v62, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

                  v64 = __stdoutp;
                  v65 = objc_retainAutorelease(v63);
                  fprintf(v64, "#CI-INFO# %s\n", (const char *)objc_msgSend(v65, "UTF8String"));

                }
                DerivedCounterInfo = GTMTLReplayClient_loadDerivedCounterInfo(v59, v61);
                v67 = (void *)objc_claimAutoreleasedReturnValue(DerivedCounterInfo);

                if (v67)
                {

                  goto LABEL_65;
                }
              }
              v54 = objc_msgSend(v53, "countByEnumeratingWithState:objects:count:", &v132, v150, 16);
              if (v54)
                continue;
              break;
            }
          }

          v49 = v118;
          v50 = v119 + 1;
        }
        while ((id)(v119 + 1) != v122);
        v122 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v136, v151, 16);
        v67 = 0;
        v49 = v118;
      }
      while (v122);
    }
    else
    {
      v67 = 0;
    }
LABEL_65:

    if (v45)
      CFRelease(v45);

    if (v67)
    {
      v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v67, "objectForKeyedSubscript:", CFSTR("DerivedCounterScript")));
      v69 = objc_msgSend(v68, "length") == 0;

      if (v69)
      {
        v113 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Derived counter script missing")));
        v114 = __stdoutp;
        if (g_runningInCI)
          v115 = "#CI_ERROR# ";
        else
          v115 = "";
        v116 = objc_retainAutorelease(v113);
        fprintf(v114, "%s%s %u: %s\n", v115, "NSDictionary *DYMTLReplayFrameProfiler_loadAnalysis(__strong id<MTLDevice>)", 1141, (const char *)objc_msgSend(v116, "UTF8String"));
        v82 = objc_retainAutorelease(v116);
        GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v82, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_frameProfiler.m", (uint64_t)"DYMTLReplayFrameProfiler_loadAnalysis", 1141, 1);
      }
      else
      {
        v70 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v67, "objectForKeyedSubscript:", CFSTR("DerivedCounterDictionary")));
        v71 = v70;
        if (g_runningInCI)
        {
          v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%d counters found"), objc_msgSend(v70, "count")));
          v73 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

          v74 = __stdoutp;
          v75 = objc_retainAutorelease(v73);
          fprintf(v74, "#CI-INFO# %s\n", (const char *)objc_msgSend(v75, "UTF8String"));

          if (!objc_msgSend(v71, "count"))
          {
            v76 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("No derivedCounterInfoResult counters present!")));
            v77 = __stdoutp;
            if (g_runningInCI)
              v78 = "#CI_ERROR# ";
            else
              v78 = "";
            v79 = objc_retainAutorelease(v76);
            fprintf(v77, "%s%s %u: %s\n", v78, "void debugDumpCounterDictionary(NSDictionary *__strong)", 962, (const char *)objc_msgSend(v79, "UTF8String"));
            v80 = objc_retainAutorelease(v79);
            GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v80, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_frameProfiler.m", (uint64_t)"debugDumpCounterDictionary", 962, 1);

          }
          if (g_runningValidationCI)
          {
            v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v71, "objectForKeyedSubscript:", CFSTR("DerivedCounters")));
            objc_msgSend(v81, "enumerateKeysAndObjectsUsingBlock:", &__block_literal_global_136);

          }
        }

        v82 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v67, "objectForKeyedSubscript:", CFSTR("DerivedCounterDictionary")));
        if (verifyCounterDictionary(v82))
        {
          v148[0] = CFSTR("DerivedCounterDictionary");
          v146[0] = CFSTR("Version");
          v83 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v82, "objectForKeyedSubscript:"));
          v146[1] = CFSTR("DerivedCounters");
          v147[0] = v83;
          v144 = CFSTR("GPUToolsGPUTime");
          v145 = &off_739450;
          v84 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v145, &v144, 1));
          v147[1] = v84;
          v85 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v147, v146, 2));
          v148[1] = CFSTR("DerivedCounterScript");
          v149[0] = v85;
          v149[1] = CFSTR("\nfunction GPUToolsGPUTime()\n{\n   return MTLStat_nSec\n}\n");
          v121 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v149, v148, 2));

          v86 = GTMTLReplayClient_mergeDerivedCounterInfo(v67, v121);
          v123 = (void *)objc_claimAutoreleasedReturnValue(v86);

          v87 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v123, "objectForKeyedSubscript:", CFSTR("DerivedCounterDictionary")));
          v125 = v82;
          obja = v87;
          if (g_runningInCI)
          {
            v88 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Validating merged derived counters")));
            v89 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

            v90 = __stdoutp;
            v91 = objc_retainAutorelease(v89);
            fprintf(v90, "#CI-INFO# %s\n", (const char *)objc_msgSend(v91, "UTF8String"));

          }
          v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(obja, "objectForKeyedSubscript:", CFSTR("DerivedCounters")));
          v142 = 0u;
          v143 = 0u;
          v140 = 0u;
          v141 = 0u;
          v93 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v125, "objectForKeyedSubscript:", CFSTR("DerivedCounters")));
          v94 = objc_msgSend(v93, "countByEnumeratingWithState:objects:count:", &v140, v153, 16);
          if (v94)
          {
            v95 = *(_QWORD *)v141;
            do
            {
              for (j = 0; j != v94; j = (char *)j + 1)
              {
                if (*(_QWORD *)v141 != v95)
                  objc_enumerationMutation(v93);
                v97 = *(_QWORD *)(*((_QWORD *)&v140 + 1) + 8 * (_QWORD)j);
                v98 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v92, "objectForKeyedSubscript:", v97));
                v99 = v98 == 0;

                if (v99)
                {
                  v100 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Counter %@ is missing from merged counter list"), v97));
                  v101 = __stdoutp;
                  if (g_runningInCI)
                    v102 = "#CI_ERROR# ";
                  else
                    v102 = "";
                  v103 = objc_retainAutorelease(v100);
                  fprintf(v101, "%s%s %u: %s\n", v102, "void validateMergeDerivedCounterInfo(NSDictionary *__strong, NSDictionary *__strong)", 950, (const char *)objc_msgSend(v103, "UTF8String"));
                  v104 = objc_retainAutorelease(v103);
                  GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v104, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_frameProfiler.m", (uint64_t)"validateMergeDerivedCounterInfo", 950, 1);

                }
              }
              v94 = objc_msgSend(v93, "countByEnumeratingWithState:objects:count:", &v140, v153, 16);
            }
            while (v94);
          }

          v82 = objc_msgSend(v123, "mutableCopy");
          objc_msgSend(v82, "setObject:forKeyedSubscript:", v131, CFSTR("MetalPluginName"));
          if (v129)
          {
            if (g_runningInCI)
            {
              v105 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Configuration Variables: %@"), v129));
              v106 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v105, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

              v107 = __stdoutp;
              v108 = objc_retainAutorelease(v106);
              fprintf(v107, "#CI-INFO# %s\n", (const char *)objc_msgSend(v108, "UTF8String"));

            }
            objc_msgSend(v82, "setObject:forKeyedSubscript:", v129, CFSTR("DerivedCounterConfigurationVariables"));
          }
          v30 = objc_msgSend(v82, "copy");
          v67 = v123;
          goto LABEL_106;
        }
      }
    }
    else
    {
      v109 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Failed to load any derived counters")));
      v110 = __stdoutp;
      if (g_runningInCI)
        v111 = "#CI_ERROR# ";
      else
        v111 = "";
      v112 = objc_retainAutorelease(v109);
      fprintf(v110, "%s%s %u: %s\n", v111, "NSDictionary *DYMTLReplayFrameProfiler_loadAnalysis(__strong id<MTLDevice>)", 1135, (const char *)objc_msgSend(v112, "UTF8String"));
      v82 = objc_retainAutorelease(v112);
      GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v82, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_frameProfiler.m", (uint64_t)"DYMTLReplayFrameProfiler_loadAnalysis", 1135, 1);
      v67 = 0;
    }
    v30 = &__NSDictionary0__struct;
LABEL_106:

    goto LABEL_107;
  }
  v10 = (void *)v9;
  v11 = CFGetTypeID(v9);
  if (v11 == CFStringGetTypeID())
  {
    v12 = v10;
    v13 = v12;
LABEL_13:
    CFRelease(v12);
    goto LABEL_33;
  }
  if (v11 == CFArrayGetTypeID())
  {
    v22 = v10;
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSPredicate predicateWithFormat:](NSPredicate, "predicateWithFormat:", CFSTR("NOT (self BEGINSWITH 'autocorr')")));
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "filteredArrayUsingPredicate:", v23));

    v13 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "firstObject"));
    if (v13)
    {
      v12 = v22;
      goto LABEL_13;
    }
  }
  v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Failed to determine statisticsName")));
  v26 = __stdoutp;
  if (g_runningInCI)
    v27 = "#CI_ERROR# ";
  else
    v27 = "";
  v28 = objc_retainAutorelease(v25);
  fprintf(v26, "%s%s %u: %s\n", v27, "NSDictionary *DYMTLReplayFrameProfiler_loadAnalysis(__strong id<MTLDevice>)", 1013, (const char *)objc_msgSend(v28, "UTF8String"));
  v29 = objc_retainAutorelease(v28);
  GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v29, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_frameProfiler.m", (uint64_t)"DYMTLReplayFrameProfiler_loadAnalysis", 1013, 1);

  CFRelease(v10);
LABEL_18:
  v30 = &__NSDictionary0__struct;
LABEL_107:

  return v30;
}

id AddShaderBinary(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  uLong v6;
  id v7;
  id v8;
  void *v9;
  const __CFString *v11;
  id v12;

  v3 = a1;
  v4 = a2;
  v5 = objc_alloc((Class)NSString);
  v6 = crc32(0, 0, 0);
  v7 = objc_retainAutorelease(v4);
  v8 = objc_msgSend(v5, "initWithFormat:", CFSTR("%0.8x"), crc32(v6, (const Bytef *)objc_msgSend(v7, "bytes"), (uInt)objc_msgSend(v7, "length")));
  if (v7)
  {
    v11 = CFSTR("binary");
    v12 = v7;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v12, &v11, 1));
    objc_msgSend(v3, "setObject:forKeyedSubscript:", v9, v8);

  }
  else
  {
    objc_msgSend(v3, "setObject:forKeyedSubscript:", &__NSDictionary0__struct, v8);
  }

  return v8;
}

id GTMTLReplayClient_collectPipelinePerformanceStatistics(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  unsigned int *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  int *v13;
  unint64_t v14;
  unint64_t v15;
  BOOL v16;
  int v17;
  BOOL v18;
  BOOL v19;
  int v20;
  uint64_t v21;
  void *v22;
  void *v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t v28;
  void *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  id v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  NSSet *v47;
  void *v48;
  void *v49;
  id v50;
  void *v51;
  void *v52;
  unsigned int v53;
  void *v54;
  uint64_t v56;
  uint64_t v57;
  apr_pool_t *p;
  id v59;
  void *v60;
  void *v61;
  void *v62;
  unsigned int v63;
  void *v64;
  void *context;
  id v66;
  _QWORD v67[2];
  _QWORD v68[2];
  _QWORD v69[2];
  _QWORD v70[2];
  _QWORD v71[2];

  p = **(apr_pool_t ***)(a1 + 152);
  v3 = *(_QWORD *)a1;
  v61 = (void *)objc_opt_new(NSMutableArray, a2);
  v60 = (void *)objc_opt_new(NSMutableArray, v4);
  v6 = objc_opt_new(NSMutableSet, v5);
  v7 = (void *)v6;
  v8 = (unsigned int *)(a1 + 22480);
  if (*(_DWORD *)(a1 + 22480) < *(_DWORD *)(*(_QWORD *)(v3 + 120) + 12))
  {
    v9 = 0;
    v10 = (uint64_t *)(a1 + 19912);
    v62 = (void *)v6;
    do
    {
      v11 = v10;
      context = objc_autoreleasePoolPush();
      v12 = *(_QWORD *)(*(_QWORD *)(v3 + 120) + 24) + ((unint64_t)*v8 << 6);
      v13 = (int *)(v12 + 8);
      if (GetFuncEnumConstructorType(*(_DWORD *)(v12 + 8)) == 25)
        GTMTLReplayController_restoreCommandBuffer(a1, v12);
      GTMTLReplayController_updateCommandEncoder(a1, v12);
      GTMTLReplayController_defaultDispatchFunction(a1, v12);
      v14 = *v8;
      v15 = *(_QWORD *)(v3 + 96);
      v16 = v15 <= v14 && *(_QWORD *)(v3 + 104) + v15 > v14;
      if (v16
        && ((v17 = *v13, (IsFuncEnumDrawCall(*v13) & 1) != 0)
         || ((v17 + 16079) >= 2 ? (v18 = v17 == -16220) : (v18 = 1),
             !v18 ? (v19 = v17 == -16327) : (v19 = 1),
             v19)))
      {
        v20 = *(_DWORD *)(a1 + 11312);
        if (v20 == 28)
        {
          v28 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(a1 + 11376)));
          v63 = v9 + 1;
          v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v9));
          v69[0] = v29;
          v69[1] = v28;
          v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v69, 2));
          objc_msgSend(v61, "addObject:", v30);

          v7 = v62;
          v64 = (void *)v28;
          if ((objc_msgSend(v62, "containsObject:", v28) & 1) != 0)
          {
            v10 = v11;
          }
          else
          {
            objc_msgSend(v62, "addObject:", v28);
            v31 = GTMTLSMContext_getObject(**(_QWORD **)(v3 + 40), *(_QWORD *)(a1 + 11376), *(_QWORD *)v12)[8];
            v25 = (uint64_t *)(v31 + 56);
            v26 = (uint64_t *)(v31 + 64);
            v27 = (uint64_t *)(a1 + 11376);
            v10 = v11;
LABEL_26:
            v32 = *v27;
            v33 = *v25;
            v34 = *v26;
            v35 = v60;
            if (v33)
            {
              v57 = v32;
              v59 = v35;
              v36 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytesNoCopy:length:freeWhenDone:", v33, v34, 0);
              v38 = objc_opt_class(NSDictionary, v37);
              v40 = objc_opt_class(NSNumber, v39);
              v42 = objc_opt_class(NSArray, v41);
              v44 = objc_opt_class(NSNull, v43);
              v56 = v42;
              v46 = v36;
              v47 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v38, v40, v56, v44, objc_opt_class(NSString, v45), 0);
              v48 = (void *)objc_claimAutoreleasedReturnValue(v47);
              v66 = 0;
              v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:](NSKeyedUnarchiver, "unarchivedObjectOfClasses:fromData:error:", v48, v36, &v66));
              v50 = v66;

              if (v49)
              {
                v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v57));
                v71[0] = v51;
                v71[1] = v49;
                v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v71, 2));
                objc_msgSend(v59, "addObject:", v52);

              }
              v10 = v11;
              v35 = v59;
            }

            apr_pool_clear(p);
            v7 = v62;
          }
LABEL_31:

          v9 = v63;
          goto LABEL_32;
        }
        v10 = v11;
        if (v20 == 70)
        {
          v21 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *v11));
          v63 = v9 + 1;
          v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v9));
          v70[0] = v22;
          v70[1] = v21;
          v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v70, 2));
          objc_msgSend(v61, "addObject:", v23);

          v7 = v62;
          v64 = (void *)v21;
          if ((objc_msgSend(v62, "containsObject:", v21) & 1) == 0)
          {
            objc_msgSend(v62, "addObject:", v21);
            v24 = GTMTLSMContext_getObject(**(_QWORD **)(v3 + 40), *v11, *(_QWORD *)v12)[7];
            v25 = (uint64_t *)(v24 + 112);
            v26 = (uint64_t *)(v24 + 120);
            v27 = v11;
            goto LABEL_26;
          }
          goto LABEL_31;
        }
      }
      else
      {
        v10 = v11;
      }
LABEL_32:
      objc_autoreleasePoolPop(context);
      v53 = *v8 + 1;
      *v8 = v53;
    }
    while (v53 < *(_DWORD *)(*(_QWORD *)(v3 + 120) + 12));
  }
  v67[0] = CFSTR("Draw ID -> PipelineState ID");
  v67[1] = CFSTR("PipelineState ID");
  v68[0] = v61;
  v68[1] = v60;
  v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v68, v67, 2));

  return v54;
}

void validateSubdividedCounterLists(void *a1, void *a2)
{
  id v3;
  id v4;
  const CATransform3D **v5;
  void *v6;
  void *v7;
  FILE *v8;
  id v9;
  id v10;
  id v11;
  id v12;
  id v13;
  uint64_t v14;
  void *i;
  id v16;
  id v17;
  id v18;
  uint64_t v19;
  void *j;
  uint64_t v21;
  void *v22;
  FILE *v23;
  const CATransform3D **v24;
  const char *v25;
  id v26;
  id v27;
  const char *v28;
  id v29;
  id v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  _BYTE v39[128];
  _BYTE v40[128];

  v3 = a1;
  v4 = a2;
  if (g_runningValidationCI)
  {
    v5 = &CATransform3DIdentity_ptr;
    if (g_runningInCI)
    {
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Required counters: %@, divided list: %@"), v3, v4));
      v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR("\n#CI-INFO# ")));

      v8 = __stdoutp;
      v9 = objc_retainAutorelease(v7);
      fprintf(v8, "#CI-INFO# %s\n", (const char *)objc_msgSend(v9, "UTF8String"));

    }
    v10 = objc_alloc_init((Class)NSMutableSet);
    v35 = 0u;
    v36 = 0u;
    v37 = 0u;
    v38 = 0u;
    v29 = v4;
    v11 = v4;
    v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v35, v40, 16);
    if (v12)
    {
      v13 = v12;
      v14 = *(_QWORD *)v36;
      do
      {
        for (i = 0; i != v13; i = (char *)i + 1)
        {
          if (*(_QWORD *)v36 != v14)
            objc_enumerationMutation(v11);
          objc_msgSend(v10, "addObjectsFromArray:", *(_QWORD *)(*((_QWORD *)&v35 + 1) + 8 * (_QWORD)i));
        }
        v13 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v35, v40, 16);
      }
      while (v13);
    }

    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v30 = v3;
    v16 = v3;
    v17 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v31, v39, 16);
    if (v17)
    {
      v18 = v17;
      v19 = *(_QWORD *)v32;
      do
      {
        for (j = 0; j != v18; j = (char *)j + 1)
        {
          if (*(_QWORD *)v32 != v19)
            objc_enumerationMutation(v16);
          v21 = *(_QWORD *)(*((_QWORD *)&v31 + 1) + 8 * (_QWORD)j);
          if ((objc_msgSend(v10, "containsObject:", v21) & 1) == 0)
          {
            v22 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D stringWithFormat:]((id)v5[296], "stringWithFormat:", CFSTR("Counter %@ missing from subdivided counter list"), v21));
            v23 = __stdoutp;
            v24 = v5;
            if (g_runningInCI)
              v25 = "#CI_ERROR# ";
            else
              v25 = "";
            v26 = objc_retainAutorelease(v22);
            v28 = v25;
            v5 = v24;
            fprintf(v23, "%s%s %u: %s\n", v28, "void validateSubdividedCounterLists(NSArray *__strong, NSArray *__strong)", 1531, (const char *)objc_msgSend(v26, "UTF8String"));
            v27 = objc_retainAutorelease(v26);
            GTMTLReplay_handleError(101, (uint64_t)objc_msgSend(v27, "UTF8String"), "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_frameProfiler.m", (uint64_t)"validateSubdividedCounterLists", 1531, 1);

          }
        }
        v18 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v31, v39, 16);
      }
      while (v18);
    }

    v4 = v29;
    v3 = v30;
  }

}

id GTMTLReplayClient_queryShaderInfo(uint64_t a1, id *a2, void *a3)
{
  void *v5;
  void *v6;
  void *v7;
  GTPMController *v8;
  void *v9;
  void *v10;
  GTPMController *v11;
  id v12;
  id v13;
  id v14;
  GTPMController *v15;
  id v16;
  void *v17;
  id v18;
  GTPMController *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  uint64_t v29;
  void *v30;
  id v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  void *v35;
  id v36;
  void *v37;
  id v39;
  id v40;
  id v41;
  _QWORD v42[6];
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t (*v46)(uint64_t, uint64_t);
  void (*v47)(uint64_t);
  id v48;
  _QWORD v49[4];
  id v50;
  GTPMController *v51;
  uint64_t *v52;
  _QWORD v53[6];
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t (*v57)(uint64_t, uint64_t);
  void (*v58)(uint64_t);
  id v59;
  _QWORD v60[4];
  id v61;
  GTPMController *v62;
  id v63;
  id v64;
  uint64_t *v65;
  uint64_t v66;
  id *v67;
  uint64_t v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t (*v71)(uint64_t, uint64_t);
  void (*v72)(uint64_t);
  id v73;
  uint64_t v74;
  double *v75;
  uint64_t v76;
  unint64_t v77;
  _QWORD v78[2];
  _QWORD v79[2];
  _QWORD v80[5];
  _QWORD v81[5];
  _QWORD v82[6];

  v40 = a3;
  v41 = objc_alloc_init((Class)NSOperation);
  v82[0] = CFSTR("MTLStatCommandBufferIndex");
  v82[1] = CFSTR("MTLStatEncoderIndex");
  v82[2] = CFSTR("MTLStatCommandIndex");
  v82[3] = CFSTR("MTLStat_nSec");
  v82[4] = CFSTR("MTLStatVertexCost");
  v82[5] = CFSTR("MTLStatFragmentCost");
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v82, 6));
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "objectForKeyedSubscript:", CFSTR("GPUState")));
  v7 = objc_autoreleasePoolPush();
  if (v6)
  {
    v8 = [GTPMController alloc];
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 8), "defaultDevice"));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "name"));
    v11 = -[GTPMController initWithGPUFamily:](v8, "initWithGPUFamily:", v10);

  }
  else
  {
    v11 = 0;
  }
  objc_autoreleasePoolPop(v7);
  v74 = 0;
  v75 = (double *)&v74;
  v76 = 0x2020000000;
  v77 = 0xBFF0000000000000;
  v68 = 0;
  v69 = &v68;
  v70 = 0x3032000000;
  v71 = __Block_byref_object_copy__6771;
  v72 = __Block_byref_object_dispose__6772;
  v73 = 0;
  v12 = objc_alloc_init((Class)NSOperation);
  v13 = *a2;
  v60[0] = _NSConcreteStackBlock;
  v60[1] = 3221225472;
  v60[2] = __GTMTLReplayClient_queryShaderInfo_block_invoke;
  v60[3] = &unk_726778;
  v14 = v6;
  v61 = v14;
  v15 = v11;
  v62 = v15;
  v66 = a1;
  v39 = v5;
  v63 = v39;
  v65 = &v68;
  v16 = v12;
  v64 = v16;
  v67 = a2;
  objc_msgSend(v13, "addOperationWithBlock:", v60);
  objc_msgSend(v41, "addDependency:", v16);

  v54 = 0;
  v55 = &v54;
  v56 = 0x3032000000;
  v57 = __Block_byref_object_copy__6771;
  v58 = __Block_byref_object_dispose__6772;
  v59 = 0;
  v53[0] = _NSConcreteStackBlock;
  v53[1] = 3221225472;
  v53[2] = __GTMTLReplayClient_queryShaderInfo_block_invoke_2;
  v53[3] = &unk_727530;
  v53[4] = &v54;
  v53[5] = a1;
  v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v53));
  objc_msgSend(v17, "setQueuePriority:", -8);
  objc_msgSend(*a2, "addOperation:", v17);
  v49[0] = _NSConcreteStackBlock;
  v49[1] = 3221225472;
  v49[2] = __GTMTLReplayClient_queryShaderInfo_block_invoke_3;
  v49[3] = &unk_7267A0;
  v18 = v14;
  v50 = v18;
  v52 = &v74;
  v19 = v15;
  v51 = v19;
  v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v49));
  objc_msgSend(v20, "addDependency:", v17);
  objc_msgSend(a2[1], "addOperation:", v20);
  objc_msgSend(v41, "addDependency:", v20);

  v43 = 0;
  v44 = &v43;
  v45 = 0x3032000000;
  v46 = __Block_byref_object_copy__6771;
  v47 = __Block_byref_object_dispose__6772;
  v48 = 0;
  v42[0] = _NSConcreteStackBlock;
  v42[1] = 3221225472;
  v42[2] = __GTMTLReplayClient_queryShaderInfo_block_invoke_4;
  v42[3] = &unk_727530;
  v42[4] = &v43;
  v42[5] = a1;
  v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v42));
  objc_msgSend(a2[1], "addOperation:", v21);
  objc_msgSend(v41, "addDependency:", v21);

  objc_msgSend(a2[1], "addOperation:", v41);
  objc_msgSend(v41, "waitUntilFinished");
  if (v19)
    -[GTPMController tearDown](v19, "tearDown");
  v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v55[5], "objectForKeyedSubscript:", CFSTR("frametime")));
  v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v44[5], "objectForKeyedSubscript:", CFSTR("MetalPluginName")));
  v25 = (void *)objc_opt_new(NSMutableDictionary, v24);
  v26 = v25;
  if (v6)
  {
    v27 = (void *)objc_claimAutoreleasedReturnValue(+[GTPMController stateFromWeightedAverage:](GTPMController, "stateFromWeightedAverage:", v75[3]));
    if (v75[3] <= -2.22044605e-16)
      v28 = &__kCFBooleanFalse;
    else
      v28 = &__kCFBooleanTrue;
    objc_msgSend(v26, "setObject:forKeyedSubscript:", v28, CFSTR("enabled"));
    if ((objc_msgSend(v27, "isEqualToString:", CFSTR("mixed")) & 1) != 0)
      v29 = 0;
    else
      v29 = objc_msgSend(v27, "isEqualToString:", CFSTR("none")) ^ 1;
    v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v29));
    objc_msgSend(v26, "setObject:forKeyedSubscript:", v30, CFSTR("consistent"));

    objc_msgSend(v26, "setObject:forKeyedSubscript:", v18, CFSTR("level"));
  }
  else
  {
    objc_msgSend(v25, "setObject:forKeyedSubscript:", &__kCFBooleanFalse, CFSTR("enabled"));
  }
  v31 = objc_alloc((Class)NSMutableDictionary);
  v78[0] = CFSTR("frame counters");
  v78[1] = CFSTR("frame profile data");
  v32 = v69[5];
  v79[0] = v39;
  v79[1] = v32;
  v80[0] = CFSTR("frameProfile");
  v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v79, v78, 2));
  v81[0] = v33;
  v81[1] = v22;
  v80[1] = CFSTR("frametime");
  v80[2] = CFSTR("Frame Consistent Perf Info");
  v34 = v44[5];
  v81[2] = v26;
  v81[3] = v34;
  v80[3] = CFSTR("derivedCounterData");
  v80[4] = CFSTR("BatchingFilteringAvailable");
  v81[4] = &__kCFBooleanFalse;
  v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v81, v80, 5));
  v36 = objc_msgSend(v31, "initWithDictionary:", v35);

  v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v55[5], "objectForKeyedSubscript:", CFSTR("frameGPUTime")));
  if (v37)
    objc_msgSend(v36, "setObject:forKeyedSubscript:", v37, CFSTR("frameGPUTime"));
  if (v23)
    objc_msgSend(v36, "setObject:forKeyedSubscript:", v23, CFSTR("MetalPluginName"));
  objc_msgSend(v36, "addEntriesFromDictionary:", &__NSDictionary0__struct);
  objc_msgSend(v36, "addEntriesFromDictionary:", &__NSDictionary0__struct);

  _Block_object_dispose(&v43, 8);
  _Block_object_dispose(&v54, 8);

  _Block_object_dispose(&v68, 8);
  _Block_object_dispose(&v74, 8);

  return v36;
}

void sub_2CE0A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  _Block_object_dispose(&a19, 8);
  _Block_object_dispose(&a38, 8);
  _Block_object_dispose(&a55, 8);
  _Block_object_dispose(&a61, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__6771(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__6772(uint64_t a1)
{

}

void sub_2CEBDC(_Unwind_Exception *a1)
{
  objc_msgSend((id)g_activityLog, "leaveActivity");
  _Unwind_Resume(a1);
}

void __performFrameTimingDesktop_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = a2;
  objc_msgSend(v3, "GPUStartTime");
  **(_QWORD **)(a1 + 32) = v4;
  objc_msgSend(v3, "GPUEndTime");
  v6 = v5;

  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = v6;
}

uint64_t CommandBufferTimeInfo_compare(double *a1, double *a2)
{
  double v3;
  double v4;

  if (*a1 == *a2)
  {
    v3 = a1[1];
    v4 = a2[1];
    if (v3 < v4)
      return 0xFFFFFFFFLL;
    else
      return v3 != v4;
  }
  else if (*a1 >= *a2)
  {
    return 1;
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

int64_t __performFrameTimingDesktop_block_invoke_321(id a1, NSNumber *a2, NSNumber *a3)
{
  return -[NSNumber compare:](a2, "compare:", a3);
}

id CollectFrameCounters(uint64_t a1, id *a2, void *a3, void *a4, uint64_t a5, void *a6)
{
  id v10;
  id v11;
  id v12;
  void *v13;
  char *v14;
  id v15;
  char *v16;
  void *v17;
  const CATransform3D **v18;
  id v19;
  id v20;
  uint64_t v21;
  void *v22;
  char *v23;
  NSObject *v24;
  void *v25;
  os_signpost_id_t v26;
  CATransform3D *v27;
  id v28;
  id v29;
  id v30;
  void *v31;
  id v32;
  void *v33;
  id v34;
  id v35;
  id v36;
  void *v37;
  id v39;
  id v40;
  id v41;
  id v42;
  void *v43;
  uint64_t v44;
  _QWORD v46[4];
  id v47;
  id v48;
  id v49;
  id v50;
  char *v51;
  uint64_t v52;
  os_signpost_id_t v53;
  char *v54;
  uint64_t v55;
  id *v56;
  _QWORD v57[4];
  id v58;
  id v59;
  os_signpost_id_t v60;
  char *v61;
  char *v62;
  _QWORD v63[4];
  id v64;
  id v65;
  id v66;
  id v67;

  v10 = a3;
  v11 = a4;
  v12 = a6;
  v44 = a1;
  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 8), "defaultCommandQueue"));
  v14 = (char *)objc_msgSend(v11, "count");
  v15 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", v14);
  if (v14)
  {
    v16 = v14;
    do
    {
      v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](NSMutableData, "dataWithCapacity:", 0x10000));
      objc_msgSend(v15, "addObject:", v17);

      --v16;
    }
    while (v16);
  }
  v18 = &CATransform3DIdentity_ptr;
  v63[0] = _NSConcreteStackBlock;
  v63[1] = 3221225472;
  v63[2] = __CollectFrameCounters_block_invoke;
  v63[3] = &unk_7267F0;
  v39 = v12;
  v64 = v39;
  v41 = v10;
  v65 = v41;
  v19 = v11;
  v66 = v19;
  v20 = v15;
  v67 = v20;
  v21 = objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v63));
  v22 = (void *)v21;
  if (v14)
  {
    v23 = 0;
    v42 = v19;
    v43 = (void *)v21;
    do
    {
      v24 = g_signpostLog;
      v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectAtIndexedSubscript:", v23, v39, v41));
      v26 = os_signpost_id_make_with_pointer(v24, v25);

      v27 = (CATransform3D *)v18[264];
      v57[0] = _NSConcreteStackBlock;
      v57[1] = 3221225472;
      v57[2] = __CollectFrameCounters_block_invoke_311;
      v57[3] = &unk_726818;
      v60 = v26;
      v61 = v23;
      v62 = v14;
      v28 = v20;
      v58 = v28;
      v29 = v19;
      v30 = v20;
      v31 = v13;
      v32 = v29;
      v59 = v29;
      v33 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D blockOperationWithBlock:](v27, "blockOperationWithBlock:", v57));
      objc_msgSend(v22, "addDependency:", v33);
      v46[0] = _NSConcreteStackBlock;
      v46[1] = 3221225472;
      v46[2] = __CollectFrameCounters_block_invoke_312;
      v46[3] = &unk_726868;
      v34 = v32;
      v13 = v31;
      v20 = v30;
      v47 = v34;
      v51 = v23;
      v52 = a5;
      v53 = v26;
      v54 = v14;
      v55 = v44;
      v48 = v28;
      v35 = v13;
      v56 = a2;
      v49 = v35;
      v50 = v33;
      v36 = v33;
      v19 = v42;
      v22 = v43;
      v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v46));
      objc_msgSend(v37, "setQueuePriority:", -8);
      objc_msgSend(*a2, "addOperation:", v37);

      v18 = &CATransform3DIdentity_ptr;
      ++v23;
    }
    while (v14 != v23);
  }
  objc_msgSend(a2[1], "addOperation:", v22, v39);

  return v22;
}

void sub_2D04D8(_Unwind_Exception *a1)
{
  objc_msgSend((id)g_activityLog, "leaveActivity");
  _Unwind_Resume(a1);
}

uint64_t compareSampleData(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v2 = 0;
  while (1)
  {
    v3 = *(_QWORD *)(a1 + v2);
    v4 = *(_QWORD *)(a2 + v2);
    if (v3 < v4)
      return 0xFFFFFFFFLL;
    if (v4 < v3)
      break;
    v2 += 8;
    if (v2 == 24)
      return 0;
  }
  return 1;
}

id GTMTLReplayClient_derivedCounterData(id *a1, id *a2, void *a3)
{
  id v4;
  void *v5;
  void *v6;
  id v7;
  id v8;
  uint64_t v9;
  void *i;
  uint64_t v11;
  id v12;
  id v13;
  void *v14;
  id v15;
  id v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id v21;
  void *v22;
  id v23;
  id v24;
  id v25;
  void *v26;
  void *v27;
  void *v28;
  id v30;
  id v31;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  _QWORD v37[4];
  _QWORD v38[4];
  void **v39;
  uint64_t v40;
  void (*v41)(uint64_t);
  void *v42;
  id v43;
  __int128 *v44;
  id *v45;
  id *v46;
  _QWORD v47[7];

  v30 = a3;
  v4 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "objectForKeyedSubscript:", CFSTR("profileCounters")));
  v47[0] = CFSTR("MTLStatCommandBufferIndex");
  v47[1] = CFSTR("MTLStatEncoderIndex");
  v47[2] = CFSTR("MTLStatCommandIndex");
  v47[3] = CFSTR("MTLStatDataMaster");
  v47[4] = CFSTR("MTLStatSampleLocation");
  v47[5] = CFSTR("MTLStatTotalGPUCycles");
  v47[6] = CFSTR("MTLStat_nSec");
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v47, 7));
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", (char *)objc_msgSend(v5, "count") + (_QWORD)objc_msgSend(v4, "count")));
  objc_msgSend(v6, "addObjectsFromArray:", v5);
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v7 = v4;
  v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v33, &v39, 16);
  if (v8)
  {
    v9 = *(_QWORD *)v34;
    do
    {
      for (i = 0; i != v8; i = (char *)i + 1)
      {
        if (*(_QWORD *)v34 != v9)
          objc_enumerationMutation(v7);
        v11 = *(_QWORD *)(*((_QWORD *)&v33 + 1) + 8 * (_QWORD)i);
        if ((objc_msgSend(v5, "containsObject:", v11) & 1) == 0)
          objc_msgSend(v6, "addObject:", v11);
      }
      v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v33, &v39, 16);
    }
    while (v8);
  }

  v12 = v6;
  *(_QWORD *)&v33 = 0;
  *((_QWORD *)&v33 + 1) = &v33;
  *(_QWORD *)&v34 = 0x3032000000;
  *((_QWORD *)&v34 + 1) = __Block_byref_object_copy__6771;
  *(_QWORD *)&v35 = __Block_byref_object_dispose__6772;
  *((_QWORD *)&v35 + 1) = 0;
  v39 = _NSConcreteStackBlock;
  v40 = 3221225472;
  v41 = __SubdivideCounterList_block_invoke;
  v42 = &unk_726918;
  v44 = &v33;
  v45 = a1;
  v13 = v12;
  v43 = v13;
  v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", &v39));
  objc_msgSend(v14, "setQueuePriority:", 8);
  objc_msgSend(*a2, "addOperation:", v14);
  objc_msgSend(v14, "waitUntilFinished");
  v15 = *(id *)(*((_QWORD *)&v33 + 1) + 40);

  _Block_object_dispose(&v33, 8);
  v31 = objc_alloc_init((Class)NSOperation);
  v16 = objc_alloc_init((Class)NSMutableArray);
  v17 = v13;
  v18 = v16;
  v19 = v15;
  v20 = objc_alloc_init((Class)NSMutableData);
  v21 = CollectFrameCounters((uint64_t)a1, a2, v17, v19, 63, v20);
  v22 = (void *)objc_claimAutoreleasedReturnValue(v21);

  v39 = _NSConcreteStackBlock;
  v40 = 3221225472;
  v41 = __ProfileFrameWithCounterListsForProfileInfo_block_invoke;
  v42 = &unk_726940;
  v43 = v18;
  v44 = (__int128 *)v17;
  v45 = (id *)v20;
  v46 = a1;
  v23 = v18;
  v24 = v17;
  v25 = v20;
  v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", &v39));
  objc_msgSend(v26, "addDependency:", v22);
  objc_msgSend(a2[1], "addOperation:", v26);

  objc_msgSend(v31, "addDependency:", v26);
  objc_msgSend(a2[1], "addOperation:", v31);
  objc_msgSend(v31, "waitUntilFinished");
  v37[0] = CFSTR("numberOfPasses");
  v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v19, "count")));
  v38[0] = v27;
  v38[1] = v19;
  v37[1] = CFSTR("counterLists");
  v37[2] = CFSTR("counters");
  v37[3] = CFSTR("AverageSamples");
  v38[2] = v24;
  v38[3] = v23;
  v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v38, v37, 4));

  return v28;
}

void sub_2D0A14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id GTShaderDebuggerMakeError(unsigned int a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9;
  id v10;
  id v11;
  id v12;
  id v13;
  void *v14;

  v9 = a3;
  v10 = a4;
  v11 = a5;
  v12 = a2;
  v13 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithObjectsAndKeys:", v12, NSLocalizedDescriptionKey, 0);

  if (v9)
    objc_msgSend(v13, "setObject:forKeyedSubscript:", v9, NSLocalizedRecoverySuggestionErrorKey);
  if (v10)
    objc_msgSend(v13, "setObject:forKeyedSubscript:", v10, NSUnderlyingErrorKey);
  if (v11)
    objc_msgSend(v13, "setObject:forKeyedSubscript:", v11, CFSTR("ErrorInfo"));
  v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("GTShaderDebuggerErrorDomain"), a1, v13));

  return v14;
}

void GTShaderDebuggerContextDeinit(_QWORD *a1)
{
  apr_pool_t *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  if (*a1)
    objc_msgSend(*(id *)(*a1 + 8), "commitCommandBuffers");
  v2 = (apr_pool_t *)a1[27];
  if (v2)
    apr_pool_destroy(v2);
  *a1 = 0;
  a1[27] = 0;
  v3 = (void *)a1[24];
  a1[24] = 0;

  v4 = (void *)a1[25];
  a1[25] = 0;

  a1[10] = 0;
  a1[11] = 0;
  v5 = (void *)a1[1];
  a1[1] = 0;

  v6 = (void *)a1[2];
  a1[2] = 0;

  v7 = (void *)a1[3];
  a1[3] = 0;

  v8 = (void *)a1[4];
  a1[4] = 0;

  v9 = (void *)a1[5];
  a1[5] = 0;

  v10 = (void *)a1[6];
  a1[6] = 0;

  v11 = (void *)a1[7];
  a1[7] = 0;

  v12 = (void *)a1[12];
  a1[12] = 0;

  v13 = (void *)a1[13];
  a1[13] = 0;

  v14 = (void *)a1[14];
  a1[14] = 0;

  v15 = (void *)a1[15];
  a1[15] = 0;

  v16 = (void *)a1[16];
  a1[16] = 0;

  v17 = (void *)a1[17];
  a1[17] = 0;

  v18 = (void *)a1[19];
  a1[19] = 0;

  v19 = (void *)a1[21];
  a1[21] = 0;

  v20 = (void *)a1[22];
  a1[22] = 0;

  v21 = (void *)a1[23];
  a1[23] = 0;

}

id GTShaderDebuggerSanitizeResponse(void *a1, void *a2, _DWORD *a3, _QWORD *a4)
{
  id v7;
  id v8;
  id v9;
  void *v10;
  unsigned int v11;
  BOOL v12;
  void *v13;
  id v14;
  void *v15;
  void *v16;
  void *v17;
  const CATransform3D **v18;
  int v19;
  uint64_t v20;
  uint64_t *v21;
  id v22;
  id v23;
  id v24;
  unint64_t *v25;
  uint64_t v26;
  void *i;
  void *v28;
  _QWORD *Object;
  _QWORD *v30;
  void *v31;
  void *v32;
  id v33;
  id v34;
  id v35;
  id v36;
  uint64_t v37;
  void *j;
  uint64_t v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  int v44;
  void *v45;
  int v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  unint64_t v58;
  id v59;
  id v60;
  void *v61;
  id Error;
  void *v64;
  void *v65;
  void *v66;
  void *v67;
  void *v68;
  void *v69;
  void *v70;
  id v71;
  id v72;
  _QWORD *v73;
  id v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  _QWORD v83[5];
  _QWORD v84[3];
  _QWORD v85[3];
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  _BYTE v90[128];
  _BYTE v91[128];

  v7 = a1;
  v8 = a2;
  v9 = v7;
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", CFSTR("ProtocolVersion")));
  v11 = objc_msgSend(v10, "intValue");

  v12 = v11 > 2 || v11 == 2;
  v13 = v9;
  if (v12)
  {
    if (!a4)
      goto LABEL_33;
    goto LABEL_31;
  }
  v72 = v8;
  v73 = a4;
  v71 = v9;
  v14 = v9;
  v69 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "objectForKeyedSubscript:", CFSTR("TraceData")));
  v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "objectForKeyedSubscript:", CFSTR("TraceMetadata")));
  v70 = v14;
  v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "objectForKeyedSubscript:", CFSTR("ResourceMapping")));
  v66 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKeyedSubscript:", CFSTR("Bytes")));
  v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKeyedSubscript:", CFSTR("Buffers")));
  v65 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKeyedSubscript:", CFSTR("Textures")));
  v64 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKeyedSubscript:", CFSTR("Samplers")));
  v67 = v15;
  v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKeyedSubscript:", CFSTR("ConstantSamplers")));
  v18 = &CATransform3DIdentity_ptr;
  if (objc_msgSend(v16, "count"))
  {
    v19 = a3[5620];
    v20 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a3 + 120) + 24);
    v21 = *(uint64_t **)(*(_QWORD *)a3 + 40);
    v74 = objc_alloc_init((Class)NSMutableDictionary);
    v79 = 0u;
    v80 = 0u;
    v81 = 0u;
    v82 = 0u;
    v22 = v16;
    v23 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v79, v91, 16);
    if (v23)
    {
      v24 = v23;
      v25 = (unint64_t *)(v20 + ((unint64_t)(v19 - 1) << 6));
      v26 = *(_QWORD *)v80;
      do
      {
        for (i = 0; i != v24; i = (char *)i + 1)
        {
          if (*(_QWORD *)v80 != v26)
            objc_enumerationMutation(v22);
          v28 = *(void **)(*((_QWORD *)&v79 + 1) + 8 * (_QWORD)i);
          Object = GTMTLSMContext_getObject(*v21, (uint64_t)objc_msgSend(v28, "unsignedLongLongValue"), *v25);
          if (Object)
          {
            v30 = Object;
            v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "objectForKeyedSubscript:", v28));
            v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v30[14]));
            objc_msgSend(v74, "setObject:forKeyedSubscript:", v31, v32);

          }
        }
        v24 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v79, v91, 16);
      }
      while (v24);
    }

    v18 = &CATransform3DIdentity_ptr;
  }
  else
  {
    v74 = v16;
  }
  if (objc_msgSend(v17, "count"))
  {
    v33 = objc_alloc_init((Class)v18[283]);
    v75 = 0u;
    v76 = 0u;
    v77 = 0u;
    v78 = 0u;
    v34 = v17;
    v35 = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v75, v90, 16);
    if (v35)
    {
      v36 = v35;
      v37 = *(_QWORD *)v76;
      do
      {
        for (j = 0; j != v36; j = (char *)j + 1)
        {
          if (*(_QWORD *)v76 != v37)
            objc_enumerationMutation(v34);
          v39 = *(_QWORD *)(*((_QWORD *)&v75 + 1) + 8 * (_QWORD)j);
          v88 = 0u;
          v89 = 0u;
          v86 = 0u;
          v87 = 0u;
          v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v34, "objectForKeyedSubscript:", v39));
          v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "objectForKeyedSubscript:", CFSTR("borderColor")));
          BYTE2(v89) = objc_msgSend(v41, "unsignedCharValue");

          v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "objectForKeyedSubscript:", CFSTR("compareFunction")));
          BYTE3(v89) = objc_msgSend(v42, "unsignedCharValue");

          v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "objectForKeyedSubscript:", CFSTR("lodMinClamp")));
          objc_msgSend(v43, "floatValue");
          HIDWORD(v88) = v44;

          v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "objectForKeyedSubscript:", CFSTR("lodMaxClamp")));
          objc_msgSend(v45, "floatValue");
          DWORD2(v88) = v46;

          v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "objectForKeyedSubscript:", CFSTR("lodAverage")));
          BYTE6(v89) = objc_msgSend(v47, "unsignedCharValue");

          v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "objectForKeyedSubscript:", CFSTR("minFilter")));
          BYTE8(v89) = objc_msgSend(v48, "unsignedCharValue");

          v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "objectForKeyedSubscript:", CFSTR("magFilter")));
          BYTE7(v89) = objc_msgSend(v49, "unsignedCharValue");

          v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "objectForKeyedSubscript:", CFSTR("mipFilter")));
          BYTE9(v89) = objc_msgSend(v50, "unsignedCharValue");

          v51 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "objectForKeyedSubscript:", CFSTR("maxAnisotropy")));
          *((_QWORD *)&v86 + 1) = objc_msgSend(v51, "unsignedCharValue");

          v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "objectForKeyedSubscript:", CFSTR("normalizedCoordinates")));
          BYTE10(v89) = objc_msgSend(v52, "unsignedCharValue");

          v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "objectForKeyedSubscript:", CFSTR("pixelFormat")));
          LOWORD(v89) = (unsigned __int16)objc_msgSend(v53, "unsignedShortValue");

          v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "objectForKeyedSubscript:", CFSTR("reductionMode")));
          BYTE12(v89) = objc_msgSend(v54, "unsignedCharValue");

          v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "objectForKeyedSubscript:", CFSTR("rAddressMode")));
          BYTE11(v89) = objc_msgSend(v55, "unsignedCharValue");

          v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "objectForKeyedSubscript:", CFSTR("sAddressMode")));
          BYTE13(v89) = objc_msgSend(v56, "unsignedCharValue");

          v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "objectForKeyedSubscript:", CFSTR("tAddressMode")));
          HIBYTE(v89) = objc_msgSend(v57, "unsignedCharValue");

          v58 = EncodeDYMTLSamplerDescriptor((uint64_t)&v86, 0, 0);
          v59 = objc_retainAutorelease(objc_msgSend(objc_alloc((Class)NSMutableData), "initWithLength:", v58));
          EncodeDYMTLSamplerDescriptor((uint64_t)&v86, (uint64_t)objc_msgSend(v59, "mutableBytes"), v58);
          v60 = objc_msgSend(v59, "copy");
          objc_msgSend(v33, "setObject:forKeyedSubscript:", v60, v39);

        }
        v36 = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v75, v90, 16);
      }
      while (v36);
    }

  }
  else
  {
    v33 = v17;
  }
  v84[0] = CFSTR("DYMTLShaderDebuggerTrace");
  v84[1] = CFSTR("DYMTLShaderDebuggerMetadata");
  v85[0] = v69;
  v85[1] = v68;
  v84[2] = CFSTR("DYMTLShaderDebuggerResourceResolutionRemappingTables");
  v83[0] = CFSTR("DYMTLShaderDebuggerResourceResolutionRemappingTablesBytes");
  v83[1] = CFSTR("DYMTLShaderDebuggerResourceResolutionRemappingTablesTextures");
  *(_QWORD *)&v86 = v66;
  *((_QWORD *)&v86 + 1) = v65;
  v83[2] = CFSTR("DYMTLShaderDebuggerResourceResolutionRemappingTablesSamplers");
  v83[3] = CFSTR("DYMTLShaderDebuggerResourceResolutionRemappingTablesBuffers");
  *(_QWORD *)&v87 = v64;
  *((_QWORD *)&v87 + 1) = v74;
  v83[4] = CFSTR("DYMTLShaderDebuggerResourceResolutionRemappingTablesConstantSamplersReflection");
  *(_QWORD *)&v88 = v33;
  v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v86, v83, 5));
  v85[2] = v61;
  v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v85, v84, 3));

  v8 = v72;
  a4 = v73;
  v9 = v71;
  if (v73)
  {
LABEL_31:
    if (!v13)
    {
      Error = GTShaderDebuggerMakeError(1u, CFSTR("Internal error: Unexpected response"), 0, 0, 0);
      *a4 = (id)objc_claimAutoreleasedReturnValue(Error);
    }
  }
LABEL_33:

  return v13;
}

uint64_t _FindDylibObjectIDForParentLibrary(unint64_t **a1, uint64_t a2, uint64_t a3, apr_allocator_t *a4)
{
  apr_pool_t *v6;
  apr_array_header_t *v7;
  uint64_t nelts;
  char *elts;
  uint64_t v10;
  apr_pool_t *newpool;

  newpool = 0;
  apr_pool_create_ex(&newpool, 0, 0, a4);
  v6 = newpool;
  v7 = apr_array_make(newpool, 32, 8);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(_QWORD *)(**a1 + 40) + 96), *a1[11], v7);
  nelts = v7->nelts;
  if ((int)nelts < 1)
  {
LABEL_5:
    v10 = 0;
  }
  else
  {
    elts = v7->elts;
    while (*(_QWORD *)(*(_QWORD *)elts + 48) != *(_QWORD *)(a2 + 8))
    {
      elts += 8;
      if (!--nelts)
        goto LABEL_5;
    }
    v10 = *(_QWORD *)(*(_QWORD *)elts + 8);
  }
  apr_pool_destroy(v6);
  return v10;
}

uint64_t GTShaderDebuggerMakeRuntimeLibrariesFromMetallibs(id *a1, void *a2, _QWORD *a3)
{
  id v5;
  id v6;
  id v7;
  id v8;
  void *i;
  void *v10;
  uint64_t *AliasStream;
  uint64_t v12;
  uint64_t Object;
  uint64_t v14;
  id v15;
  id v16;
  dispatch_data_t v17;
  id v18;
  id v19;
  id v20;
  uint64_t v21;
  apr_allocator_t *v22;
  uint64_t DylibObjectIDForParentLibrary;
  void *v24;
  void *v25;
  unint64_t *v26;
  unint64_t *v27;
  uint64_t v28;
  id Error;
  id v30;
  id v31;
  void *v32;
  id v33;
  _QWORD *v35;
  id v36;
  uint64_t v37;
  void *v38;
  unint64_t *v39;
  uint64_t *v40;
  unint64_t **v41;
  void *v42;
  id v43;
  id v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  _BYTE v49[128];

  v5 = a2;
  v41 = (unint64_t **)a1;
  v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*((id *)*a1 + 1), "defaultDevice"));
  v39 = (unint64_t *)a1[11];
  v40 = *(uint64_t **)(*(_QWORD *)*a1 + 40);
  v6 = objc_msgSend(a1[12], "mutableCopy");
  v45 = 0u;
  v46 = 0u;
  v47 = 0u;
  v48 = 0u;
  v7 = v5;
  v36 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v45, v49, 16);
  if (!v36)
  {
    v8 = 0;
    goto LABEL_20;
  }
  v35 = a3;
  v8 = 0;
  v37 = *(_QWORD *)v46;
  v38 = v6;
  while (2)
  {
    for (i = 0; i != v36; i = (char *)i + 1)
    {
      if (*(_QWORD *)v46 != v37)
        objc_enumerationMutation(v7);
      v10 = *(void **)(*((_QWORD *)&v45 + 1) + 8 * (_QWORD)i);
      AliasStream = (uint64_t *)GetAliasStream(*(_QWORD *)(**v41 + 24), (uint64_t)objc_msgSend(v10, "unsignedIntegerValue"), *v41[11]);
      if (AliasStream)
        v12 = *AliasStream;
      else
        v12 = 0;
      Object = GTMTLSMContext_lastObject(*v40, v12, *v39);
      if (!Object)
      {
        if (v35)
        {
          Error = GTShaderDebuggerMakeError(1u, CFSTR("Internal error: Library not found"), 0, 0, 0);
          v28 = 0;
          *v35 = (id)objc_claimAutoreleasedReturnValue(Error);
        }
        else
        {
          v28 = 0;
        }
        v27 = (unint64_t *)v7;
        v6 = v38;
        goto LABEL_37;
      }
      v14 = Object;
      v15 = v7;
      v16 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", v10)));
      v17 = dispatch_data_create(objc_msgSend(v16, "bytes"), (size_t)objc_msgSend(v16, "length"), 0, 0);
      v44 = v8;
      v18 = objc_msgSend(v42, "newLibraryWithData:error:", v17, &v44);
      v19 = v44;

      if (!v18)
      {
        v6 = v38;
        if (v35)
        {
          v30 = GTShaderDebuggerMakeError(1u, CFSTR("Internal error: Failed to set up runtime library"), 0, v19, 0);
          v18 = 0;
          *v35 = (id)objc_claimAutoreleasedReturnValue(v30);
        }
        else
        {
          v18 = 0;
        }
        v8 = v19;
        v7 = v15;
        goto LABEL_36;
      }
      if (*(_BYTE *)(v14 + 160) == 1)
      {
        v43 = v19;
        v20 = objc_msgSend(v42, "newDynamicLibrary:error:", v18, &v43);
        v8 = v43;

        if (v20)
        {
          DylibObjectIDForParentLibrary = _FindDylibObjectIDForParentLibrary(v41, v14, v21, v22);
          v7 = v15;
          if (DylibObjectIDForParentLibrary)
          {
            v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", DylibObjectIDForParentLibrary));
            objc_msgSend(v38, "setObject:forKeyedSubscript:", v20, v24);

            v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v14 + 8)));
            objc_msgSend(v38, "setObject:forKeyedSubscript:", v18, v25);

            goto LABEL_16;
          }
          v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Internal error: Failed to resolve dynamic library identifier \"%@\""), v10));
          if (v35)
          {
            v33 = GTShaderDebuggerMakeError(1u, v32, 0, 0, 0);
            *v35 = (id)objc_claimAutoreleasedReturnValue(v33);
          }

        }
        else
        {
          v7 = v15;
          if (v35)
          {
            v31 = GTShaderDebuggerMakeError(1u, CFSTR("Internal error: Failed to set up runtime dynamic library"), 0, v8, 0);
            v20 = 0;
            *v35 = (id)objc_claimAutoreleasedReturnValue(v31);
          }
          else
          {
            v20 = 0;
          }
        }
        v6 = v38;

LABEL_36:
        v28 = 0;
        v27 = (unint64_t *)v7;
        goto LABEL_37;
      }
      v20 = (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v14 + 8)));
      objc_msgSend(v38, "setObject:forKeyedSubscript:", v18, v20);
      v8 = v19;
      v7 = v15;
LABEL_16:

    }
    v6 = v38;
    v36 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v45, v49, 16);
    if (v36)
      continue;
    break;
  }
LABEL_20:

  v26 = (unint64_t *)objc_msgSend(v6, "copy");
  v27 = v41[12];
  v41[12] = v26;
  v28 = 1;
LABEL_37:

  return v28;
}

uint64_t GTShaderDebuggerMakeRuntimeLibrariesFromDependentLibs(uint64_t a1, void *a2, _QWORD *a3)
{
  id v4;
  void *v5;
  id v6;
  id v7;
  id v8;
  id v9;
  id v10;
  id v11;
  void *i;
  void *v13;
  id v14;
  dispatch_data_t v15;
  id v16;
  id v17;
  void *v18;
  unsigned int v19;
  uint64_t v20;
  void *v21;
  void *v22;
  id v23;
  void *v24;
  unsigned __int8 v25;
  id v26;
  id v27;
  void *v28;
  id v29;
  void *v30;
  uint64_t v31;
  id v32;
  id Error;
  uint64_t v36;
  void *v37;
  id obj;
  uint64_t v39;
  id v40;
  id v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  _BYTE v46[128];

  v4 = a2;
  v36 = a1;
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)a1 + 8), "defaultDevice"));
  v6 = objc_alloc_init((Class)NSMutableArray);
  v7 = objc_alloc_init((Class)NSMutableArray);
  v42 = 0u;
  v43 = 0u;
  v44 = 0u;
  v45 = 0u;
  v8 = v4;
  v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v42, v46, 16);
  if (v9)
  {
    v10 = v9;
    v11 = 0;
    v39 = *(_QWORD *)v43;
    v37 = v7;
    obj = v8;
    while (2)
    {
      for (i = 0; i != v10; i = (char *)i + 1)
      {
        v13 = v6;
        if (*(_QWORD *)v43 != v39)
          objc_enumerationMutation(obj);
        v14 = objc_retainAutorelease(*(id *)(*((_QWORD *)&v42 + 1) + 8 * (_QWORD)i));
        v15 = dispatch_data_create(objc_msgSend(v14, "bytes"), (size_t)objc_msgSend(v14, "length"), 0, 0);
        v41 = v11;
        v16 = objc_msgSend(v5, "newLibraryWithData:error:", v15, &v41);
        v17 = v41;

        if (!v16)
        {
          if (objc_msgSend(v17, "code") != (char *)&dword_0 + 1)
            goto LABEL_23;
          v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "domain"));
          v19 = objc_msgSend(v18, "isEqualToString:", MTLLibraryErrorDomain);

          if (!v19)
            goto LABEL_23;
          v20 = GTShaderDebuggerMakeRuntimeLibrariesFromDependentLibs_lib_index++;
          v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(CFSTR("dylib-"), "stringByAppendingFormat:", CFSTR("%llu.metallib"), v20));
          v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v36 + 200), "stringByAppendingPathComponent:", v21));
          if ((objc_msgSend(v14, "writeToFile:options:error:", v22, 0, 0) & 1) == 0)
          {

LABEL_23:
            if (a3)
            {
              Error = GTShaderDebuggerMakeError(1u, CFSTR("Internal error: Failed to set up dependent dynamic library"), 0, v17, 0);
              *a3 = (id)objc_claimAutoreleasedReturnValue(Error);
            }
            v11 = v17;
            v6 = v13;
LABEL_26:
            v7 = v37;
            v8 = obj;

            v31 = 0;
            v30 = obj;
            goto LABEL_27;
          }
          v23 = objc_msgSend(objc_alloc((Class)NSURL), "initFileURLWithPath:isDirectory:", v22, 0);
          v16 = objc_msgSend(v5, "newLibraryWithURL:error:", v23, 0);

          if (!v16)
            goto LABEL_23;
        }
        v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "installName"));
        v25 = objc_msgSend(v24, "containsString:", CFSTR("libtracepoint"));

        if ((v25 & 1) == 0)
          objc_msgSend(v37, "addObject:", v16);
        v40 = v17;
        v26 = objc_msgSend(v5, "newDynamicLibrary:error:", v16, &v40);
        v11 = v40;

        if (!v26)
        {
          v6 = v13;
          if (a3)
          {
            v32 = GTShaderDebuggerMakeError(1u, CFSTR("Internal error: Failed to set up dependent dynamic library"), 0, v11, 0);
            *a3 = (id)objc_claimAutoreleasedReturnValue(v32);
          }

          goto LABEL_26;
        }
        v6 = v13;
        objc_msgSend(v13, "addObject:", v26);

      }
      v8 = obj;
      v10 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v42, v46, 16);
      v7 = v37;
      if (v10)
        continue;
      break;
    }
  }
  else
  {
    v11 = 0;
  }

  v27 = objc_msgSend(v6, "copy");
  v28 = *(void **)(v36 + 112);
  *(_QWORD *)(v36 + 112) = v27;

  v29 = objc_msgSend(v7, "copy");
  v30 = *(void **)(v36 + 120);
  *(_QWORD *)(v36 + 120) = v29;
  v31 = 1;
LABEL_27:

  return v31;
}

uint64_t GTShaderDebuggerMakeRuntimeFunctions(uint64_t a1, void *a2, _QWORD *a3)
{
  id v5;
  id v6;
  uint64_t *v7;
  id v8;
  char **v9;
  uint64_t v10;
  void *v11;
  id v12;
  void *v13;
  void *v14;
  uint64_t *Object;
  void *v16;
  void *v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  void *v21;
  id MTLIntersectionFunctionDescriptor;
  void *v23;
  id v24;
  uint64_t v25;
  unint64_t v26;
  const __CFString *v27;
  void *v28;
  void *v29;
  id MTLFunctionDescriptor;
  void *v31;
  _BYTE *v32;
  id v33;
  id v34;
  id v35;
  uint64_t v36;
  void *i;
  id v38;
  void *v39;
  void *v40;
  void *v41;
  int v42;
  void *v43;
  void *v44;
  id v45;
  id v46;
  uint64_t v47;
  void *v48;
  id MTLFunctionConstantValues;
  void *v50;
  id v51;
  id v52;
  id v53;
  void *v54;
  id v55;
  id v56;
  id v57;
  id v58;
  uint64_t v59;
  id v60;
  void *v61;
  id Error;
  char *v64;
  id v65;
  id v66;
  _QWORD *v67;
  uint64_t *v68;
  uint64_t v69;
  id v70;
  uint64_t v71;
  id v72;
  void *v73;
  unint64_t v74;
  uint64_t v75;
  void *v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  id v81;
  id v82;
  id v83;
  id v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  _BYTE v89[128];
  _BYTE v90[128];

  v5 = a2;
  if (objc_msgSend(v5, "count"))
  {
    v6 = objc_msgSend(*(id *)(a1 + 96), "mutableCopy");
    v7 = *(uint64_t **)(**(_QWORD **)a1 + 40);
    v74 = **(_QWORD **)(a1 + 88);
    v85 = 0u;
    v86 = 0u;
    v87 = 0u;
    v88 = 0u;
    v65 = v5;
    v8 = v5;
    v70 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v85, v90, 16);
    if (v70)
    {
      v9 = &selRef_init_;
      v71 = *(_QWORD *)v86;
      v68 = v7;
      v69 = a1;
      v66 = v8;
      v67 = a3;
      do
      {
        v10 = 0;
        v64 = v9[289];
        do
        {
          if (*(_QWORD *)v86 != v71)
            objc_enumerationMutation(v8);
          v11 = *(void **)(*((_QWORD *)&v85 + 1) + 8 * v10);
          v12 = _ObjectUIDsWithAliasID((_QWORD **)a1, (uint64_t)objc_msgSend(v11, "unsignedLongLongValue"));
          v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
          if (!objc_msgSend(v13, "count")
            || (v75 = v10,
                v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "firstObject")),
                Object = (uint64_t *)GTMTLSMContext_lastObject(*v7, (uint64_t)objc_msgSend(v14, "unsignedLongLongValue"), v74), v14, !Object))
          {
            v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Internal error: Function '%@' not found"), v11));
            if (a3)
            {
              Error = GTShaderDebuggerMakeError(1u, v61, 0, 0, 0);
              *a3 = (id)objc_claimAutoreleasedReturnValue(Error);
            }

LABEL_60:
            v59 = 0;
            goto LABEL_61;
          }
          v76 = v13;
          v16 = *(void **)(a1 + 96);
          v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", Object[5]));
          v18 = objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "objectForKeyedSubscript:", v17));

          v19 = (void *)v18;
          if (v18)
          {
            v20 = Object[15];
            v73 = v19;
            if (v20)
            {
              v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)a1 + 8), "functionMap"));
              MTLIntersectionFunctionDescriptor = MakeMTLIntersectionFunctionDescriptor(v20, v21);
              v23 = (void *)objc_claimAutoreleasedReturnValue(MTLIntersectionFunctionDescriptor);
              v84 = 0;
              v24 = objc_msgSend(v19, "newIntersectionFunctionWithDescriptor:error:", v23, &v84);
              v72 = v84;

              goto LABEL_17;
            }
            v20 = Object[14];
            if (v20)
            {
              v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)a1 + 8), "functionMap"));
              MTLFunctionDescriptor = MakeMTLFunctionDescriptor(v20, v29);
              v31 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionDescriptor);
              v83 = 0;
              v24 = objc_msgSend(v19, "newFunctionWithDescriptor:error:", v31, &v83);
              v72 = v83;

LABEL_17:
              v32 = *(_BYTE **)(v20 + 8);
LABEL_18:
              if (v24)
              {
                v79 = 0u;
                v80 = 0u;
                v77 = 0u;
                v78 = 0u;
                v33 = v76;
                v34 = objc_msgSend(v33, "countByEnumeratingWithState:objects:count:", &v77, v89, 16);
                if (v34)
                {
                  v35 = v34;
                  v36 = *(_QWORD *)v78;
                  do
                  {
                    for (i = 0; i != v35; i = (char *)i + 1)
                    {
                      if (*(_QWORD *)v78 != v36)
                        objc_enumerationMutation(v33);
                      v38 = objc_msgSend(*(id *)(*((_QWORD *)&v77 + 1) + 8 * (_QWORD)i), "unsignedLongLongValue");
                      v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v38));
                      v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v39, "stringValue"));
                      objc_msgSend(v24, "setLabel:", v40);

                      v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v38));
                      objc_msgSend(v6, "setObject:forKeyedSubscript:", v24, v41);

                    }
                    v35 = objc_msgSend(v33, "countByEnumeratingWithState:objects:count:", &v77, v89, 16);
                  }
                  while (v35);
                }

                v42 = 0;
                v8 = v66;
                a3 = v67;
                v7 = v68;
                a1 = v69;
                v43 = v72;
LABEL_37:

                v28 = v76;
                v19 = v73;
                goto LABEL_38;
              }
              v7 = v68;
              a1 = v69;
            }
            else
            {
              v32 = (_BYTE *)Object[7];
              if (v32 && *v32)
              {
                v47 = Object[9];
                v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", Object[7]));
                if (v47)
                {
                  MTLFunctionConstantValues = MakeMTLFunctionConstantValues((_QWORD *)Object[9]);
                  v50 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionConstantValues);
                  v82 = 0;
                  v24 = objc_msgSend(v73, "newFunctionWithName:constantValues:error:", v48, v50, &v82);
                  v72 = v82;

                }
                else
                {
                  v52 = objc_msgSend(v73, "newFunctionWithName:", v48);

                  v53 = v52;
                  if ((objc_opt_respondsToSelector(v53, v64) & 1) != 0
                    && objc_msgSend(v53, "needsFunctionConstantValues"))
                  {
                    v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v32));
                    v55 = objc_alloc_init((Class)MTLFunctionConstantValues);
                    v81 = 0;
                    v56 = objc_msgSend(v73, "newFunctionWithName:constantValues:error:", v54, v55, &v81);
                    v72 = v81;

                    v24 = v53;
                    if (v56)
                    {
                      v24 = v56;

                    }
                  }
                  else
                  {
                    v72 = 0;
                    v24 = v53;
                  }

                }
                goto LABEL_18;
              }
              v51 = GTShaderDebuggerMakeError(1u, CFSTR("Capture did not resolve function name"), 0, 0, 0);
              v72 = (id)objc_claimAutoreleasedReturnValue(v51);
            }
            if (v32)
            {
              v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v32));
              v24 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Internal error: Failed to set up function '%@' (%@)"), v44, v11));

            }
            else
            {
              v24 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Internal error: Failed to set up function '%@' (%@)"), CFSTR("NULL"), v11));
            }
            v43 = v72;
            if (a3)
            {
              v46 = GTShaderDebuggerMakeError(2u, v24, 0, v72, 0);
              *a3 = (id)objc_claimAutoreleasedReturnValue(v46);
            }
            v42 = 1;
            goto LABEL_37;
          }
          v25 = GTMTLSMContext_lastObject(*v7, Object[5], v74);
          if (v25)
          {
            v26 = *(unsigned __int8 *)(v25 + 161);
            v27 = CFSTR("Unknown");
            v28 = v76;
            if (v26 <= 6)
              v27 = off_726A40[v26];
          }
          else
          {
            v27 = CFSTR("NULL");
            v28 = v76;
          }
          v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Internal error: Failed to find runtime library (%@) for function '%@'"), v27, v11));
          v42 = 1;
          if (a3)
          {
            v45 = GTShaderDebuggerMakeError(1u, v43, 0, 0, 0);
            *a3 = (id)objc_claimAutoreleasedReturnValue(v45);
          }
LABEL_38:

          if (v42)
            goto LABEL_60;
          v10 = v75 + 1;
        }
        while ((id)(v75 + 1) != v70);
        v57 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v85, v90, 16);
        v70 = v57;
        v9 = &selRef_init_;
      }
      while (v57);
    }

    v58 = objc_msgSend(v6, "copy");
    v8 = *(id *)(a1 + 96);
    *(_QWORD *)(a1 + 96) = v58;
    v59 = 1;
LABEL_61:
    v5 = v65;

  }
  else if (a3)
  {
    v60 = GTShaderDebuggerMakeError(1u, CFSTR("Internal error: Entry function not found"), 0, 0, 0);
    v59 = 0;
    *a3 = (id)objc_claimAutoreleasedReturnValue(v60);
  }
  else
  {
    v59 = 0;
  }

  return v59;
}

id _ObjectUIDsWithAliasID(_QWORD **a1, uint64_t a2)
{
  id v4;
  apr_allocator_t *v5;
  apr_pool_t *v6;
  apr_array_header_t *v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *entry;
  _QWORD *i;
  uint64_t v12;
  uint64_t nelts;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  void *v18;
  id v19;
  apr_pool_t *p;
  uint64_t v22;

  v4 = objc_alloc_init((Class)NSMutableArray);
  p = 0;
  apr_pool_create_ex(&p, 0, 0, v5);
  v6 = p;
  v7 = apr_array_make(p, 32, 8);
  v8 = *(_QWORD *)(**a1 + 24);
  v9 = *a1[11];
  v22 = a2;
  entry = find_entry(v8, &v22, 8uLL, 0);
  if (*entry)
  {
    for (i = *(_QWORD **)(*entry + 32); i; i = (_QWORD *)i[4])
    {
      if (i[2] <= v9 && i[3] >= v9)
      {
        v12 = i[1];
        *(_QWORD *)apr_array_push(v7) = v12;
      }
    }
  }
  nelts = v7->nelts;
  if ((int)nelts >= 1)
  {
    v14 = 0;
    v15 = 8 * nelts;
    do
    {
      v16 = *(uint64_t **)&v7->elts[v14];
      if (v16)
        v17 = *v16;
      else
        v17 = 0;
      v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v17));
      objc_msgSend(v4, "addObject:", v18);

      v14 += 8;
    }
    while (v15 != v14);
  }
  apr_pool_destroy(v6);
  v19 = objc_msgSend(v4, "copy");

  return v19;
}

uint64_t GTShaderDebuggerMakeDebugMetadata(uint64_t a1, void *a2, void *a3, _QWORD *a4)
{
  id v7;
  uint64_t v8;
  unint64_t k;
  id v10;
  void *i;
  void *v12;
  uint64_t *AliasStream;
  uint64_t v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  uint64_t Object;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  id v28;
  id v29;
  uint64_t v30;
  void *j;
  void *v32;
  uint64_t *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  id v45;
  id v46;
  uint64_t v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  id v54;
  id v55;
  char *v56;
  char *v57;
  id v58;
  llvm::Module *v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  __int128 *v65;
  uint64_t v66;
  id v67;
  id v68;
  unint64_t v69;
  uint64_t v70;
  char *v71;
  llvm::Module **v72;
  llvm::Module *v73;
  int64x2_t v74;
  llvm::Module **v75;
  llvm::Module **v76;
  id v77;
  BOOL v78;
  unint64_t v79;
  unint64_t v80;
  uint8x8_t v81;
  void **v82;
  std::string *v83;
  std::string::size_type size;
  float v85;
  _BOOL8 v86;
  unint64_t v87;
  unint64_t v88;
  int8x8_t prime;
  void *v90;
  void *v91;
  uint64_t v92;
  _QWORD **v93;
  unint64_t v94;
  uint8x8_t v95;
  unint64_t v96;
  uint8x8_t v97;
  uint64_t v98;
  _QWORD *m;
  unint64_t v100;
  uint64_t v101;
  std::string **v102;
  unint64_t v103;
  llvm::Module *v104;
  llvm::MemoryBuffer *v105;
  const std::string::value_type *v106;
  void *v107;
  id Error;
  id v110;
  id v111;
  uint64_t v112;
  void *n;
  void *v114;
  void *v115;
  id v116;
  uint64_t v117;
  _QWORD *v118;
  _QWORD *v119;
  _QWORD *v120;
  _QWORD *v121;
  _QWORD *v122;
  _QWORD *v123;
  _QWORD *v124;
  _QWORD *v125;
  _QWORD *v126;
  _QWORD *v127;
  _QWORD *v128;
  _QWORD *v129;
  _QWORD *v130;
  _QWORD *v131;
  _QWORD *v132;
  _QWORD *v133;
  _QWORD *v134;
  _QWORD *v135;
  _QWORD *v136;
  _QWORD *v137;
  uint64_t v138;
  llvm::MemoryBuffer **v139;
  int v140;
  const std::string::value_type *v141;
  std::string::size_type v142;
  uint64_t *v143;
  unint64_t v144;
  unint64_t v145;
  unint64_t v146;
  unint64_t v147;
  uint8x8_t v148;
  unint64_t v149;
  unsigned __int8 **v150;
  unsigned __int8 *ii;
  unint64_t v152;
  _QWORD *v153;
  std::string *v154;
  llvm::MemoryBuffer **v155;
  llvm::MemoryBuffer *v156;
  llvm::MemoryBuffer **v157;
  float v158;
  _BOOL8 v159;
  unint64_t v160;
  unint64_t v161;
  int8x8_t v162;
  void *v163;
  void *v164;
  uint64_t v165;
  _QWORD **v166;
  unint64_t v167;
  uint8x8_t v168;
  unint64_t v169;
  uint8x8_t v170;
  uint64_t v171;
  _QWORD *jj;
  unint64_t v173;
  uint64_t v174;
  _QWORD *v175;
  unint64_t v176;
  void *v177;
  uint64_t v178;
  _BYTE *v179;
  uint64_t v180;
  unint64_t v181;
  uint64_t v182;
  uint8x8_t v183;
  unint64_t v184;
  uint64_t **v185;
  uint64_t *kk;
  unint64_t v187;
  size_t v188;
  std::string *v189;
  const void *v190;
  std::string *v191;
  std::string::size_type v192;
  std::string *v193;
  std::string::size_type v194;
  __int128 *v195;
  uint64_t v196;
  uint64_t GlobalVariable;
  void *v198;
  size_t v199;
  uint64_t v200;
  unsigned int v201;
  uint64_t v202;
  uint64_t v203;
  llvm::NamedMDNode *NamedMetadata;
  uint64_t Operand;
  uint64_t v206;
  unsigned int v207;
  uint64_t v208;
  llvm::NamedMDNode *v209;
  llvm::NamedMDNode *v210;
  int NumOperands;
  int v212;
  unsigned int mm;
  uint64_t v214;
  uint64_t v215;
  uint64_t *v216;
  uint64_t v217;
  uint64_t v218;
  llvm::NamedMDNode *v219;
  llvm::NamedMDNode *v220;
  int v221;
  int v222;
  unsigned int nn;
  uint64_t v224;
  uint64_t v225;
  _QWORD **v226;
  _QWORD *v227;
  char *v228;
  _BYTE *v229;
  uint64_t v230;
  char *v231;
  char *v232;
  int64_t v233;
  uint64_t v234;
  unint64_t v235;
  size_t v236;
  char *v237;
  char *v238;
  char *v239;
  char *v240;
  uint64_t v241;
  char v242;
  char *v243;
  char *v244;
  int64_t v245;
  char v246;
  void *v247;
  _QWORD *v248;
  _QWORD **v249;
  BOOL v250;
  uint64_t *i1;
  llvm::MemoryBuffer *v252;
  int v253;
  _BYTE *v254;
  uint64_t v255;
  llvm::MemoryBuffer *v256;
  int v257;
  _BYTE *v258;
  uint64_t v259;
  uint64_t v260;
  void *v261;
  _QWORD *v262;
  _QWORD *v263;
  void *v264;
  void *v265;
  id v266;
  void *v267;
  uint64_t v268;
  void *v269;
  __CFString *v270;
  __CFString *v271;
  void *v272;
  id v273;
  id v274;
  id v275;
  _QWORD *v276;
  id v277;
  id v278;
  id v279;
  uint64_t *v280;
  unint64_t v281;
  std::string::value_type *v282;
  uint64_t v283;
  void *v284;
  std::string::value_type *__s;
  std::string::value_type *__sa;
  id v287;
  char *v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  __int128 v292;
  __int128 v293;
  __int128 v294;
  __int128 v295;
  uint64_t v296;
  __int128 v297;
  __int128 v298;
  __int128 v299;
  __int128 v300;
  uint64_t v301;
  __int128 v302;
  __int128 v303;
  __int128 v304;
  __int128 v305;
  void *v306;
  char *v307;
  char *v308;
  __int128 v309;
  __int128 v310;
  __int128 v311;
  __int128 v312;
  _QWORD **v313;
  _QWORD *v314;
  uint64_t v315;
  __int128 v316;
  __int128 v317;
  int v318;
  uint64_t v319;
  char v320[32];
  __int128 __p;
  __int128 v322;
  float v323;
  int64x2_t v324;
  char *v325;
  char v326[8];
  int *v327[3];
  std::string v328;
  __int16 v329;
  int v330;
  __int128 v331;
  uint64_t v332;
  void *v333;
  size_t v334;
  unsigned __int8 v335;
  std::string v336;
  __int128 v337;
  __int128 v338;
  float v339;
  _BYTE v340[128];
  _QWORD v341[2];
  _BYTE v342[128];
  _QWORD v343[2];
  _BYTE v344[128];
  llvm::Module *v345[16];
  __int128 v346;
  __int128 v347;
  __int128 v348;
  int v349;
  __int128 v350;
  __int128 v351;
  __int128 v352;
  __int128 v353;
  uint64_t v354;
  char *v355[2];
  _BYTE v356[168];
  llvm::MemoryBuffer *v357[2];
  _BYTE v358[32];
  _QWORD *v359;
  uint64_t v360[3];
  void *v361;
  uint64_t v362;
  _QWORD v363[2];
  uint64_t v364[6];
  void *v365;
  uint64_t v366;
  _QWORD v367[6];
  uint64_t v368;
  void *v369;
  uint64_t v370;
  _QWORD v371[3];
  uint64_t v372[5];
  void *v373;
  uint64_t v374;
  _QWORD v375[7];
  uint64_t v376;
  _QWORD *v377;
  void *v378;
  uint64_t v379;
  int v380;
  _QWORD v381[2];
  _QWORD v382[7];
  _QWORD v383[7];
  _QWORD v384[7];
  _QWORD v385[7];
  _QWORD v386[7];
  _QWORD v387[7];
  _QWORD v388[7];
  _QWORD v389[7];
  _QWORD v390[7];
  _QWORD v391[7];
  _QWORD v392[7];
  _QWORD v393[7];

  v279 = a2;
  v7 = a3;
  if ((*(_BYTE *)(a1 + 208) & 1) == 0)
    goto LABEL_2;
  v276 = a4;
  v278 = v7;
  v287 = objc_alloc_init((Class)NSMutableArray);
  __s = (std::string::value_type *)objc_alloc_init((Class)NSMutableArray);
  v290 = a1;
  v280 = *(uint64_t **)(**(_QWORD **)a1 + 40);
  v281 = **(_QWORD **)(a1 + 88);
  v302 = 0u;
  v303 = 0u;
  v304 = 0u;
  v305 = 0u;
  k = (unint64_t)v279;
  v10 = objc_msgSend((id)k, "countByEnumeratingWithState:objects:count:", &v302, v344, 16);
  if (v10)
  {
    v283 = *(_QWORD *)v303;
    do
    {
      for (i = 0; i != v10; i = (char *)i + 1)
      {
        if (*(_QWORD *)v303 != v283)
          objc_enumerationMutation((id)k);
        v12 = *(void **)(*((_QWORD *)&v302 + 1) + 8 * (_QWORD)i);
        AliasStream = (uint64_t *)GetAliasStream(*(_QWORD *)(**(_QWORD **)v290 + 24), (uint64_t)objc_msgSend(v12, "unsignedIntegerValue"), **(_QWORD **)(v290 + 88));
        if (AliasStream)
          v14 = *AliasStream;
        else
          v14 = 0;
        v15 = *(void **)(v290 + 96);
        v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v14));
        v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKeyedSubscript:", v16));

        v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "bitcodeData"));
        if (!v18)
        {
          if (v276)
          {
            Error = GTShaderDebuggerMakeError(1u, CFSTR("Internal error: Failed to process executable debug information"), 0, 0, 0);
            *v276 = (id)objc_claimAutoreleasedReturnValue(Error);
          }

          v8 = 0;
          v7 = v278;
          goto LABEL_176;
        }
        if ((*(_BYTE *)(v290 + 208) & 8) != 0)
        {
          v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "name"));
          v343[0] = v19;
          v343[1] = v12;
          v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v343, 2));
          v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "componentsJoinedByString:", CFSTR("_")));

          v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "stringByAppendingPathExtension:", CFSTR("bc")));
          v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v290 + 200), "stringByAppendingPathComponent:", v22));
          v301 = 0;
          objc_msgSend(v18, "writeToFile:options:error:", v23, 1, &v301);

        }
        Object = GTMTLSMContext_lastObject(*v280, v14, v281);
        if (Object
          && ((v25 = *(_QWORD *)(Object + 120)) != 0 || (v25 = *(_QWORD *)(Object + 112)) != 0)
          && *(_QWORD *)(v25 + 8))
        {
          v26 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:"));
        }
        else
        {
          v26 = objc_claimAutoreleasedReturnValue(+[NSNull null](NSNull, "null"));
        }
        v27 = (void *)v26;
        unk_755128(__s, "addObject:", v26);

        objc_msgSend(v287, "addObject:", v18);
      }
      v10 = objc_msgSend((id)k, "countByEnumeratingWithState:objects:count:", &v302, v344, 16);
    }
    while (v10);
  }

  v300 = 0u;
  v298 = 0u;
  v299 = 0u;
  v297 = 0u;
  v28 = v278;
  v29 = objc_msgSend(v28, "countByEnumeratingWithState:objects:count:", &v297, v342, 16);
  if (v29)
  {
    v30 = *(_QWORD *)v298;
    k = (unint64_t)&CATransform3DIdentity_ptr;
    do
    {
      for (j = 0; j != v29; j = (char *)j + 1)
      {
        if (*(_QWORD *)v298 != v30)
          objc_enumerationMutation(v28);
        v32 = *(void **)(*((_QWORD *)&v297 + 1) + 8 * (_QWORD)j);
        v33 = (uint64_t *)GetAliasStream(*(_QWORD *)(**(_QWORD **)v290 + 24), (uint64_t)objc_msgSend(v32, "unsignedIntegerValue"), **(_QWORD **)(v290 + 88));
        if (v33)
          v34 = *v33;
        else
          v34 = 0;
        v35 = *(void **)(v290 + 96);
        v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v34));
        v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "objectForKeyedSubscript:", v36));

        if (v37 && objc_msgSend(v37, "type"))
        {
          v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v37, "bitcodeData"));
          if (v38)
          {
            if ((*(_BYTE *)(v290 + 208) & 8) != 0)
            {
              v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v37, "installName"));
              v341[0] = v39;
              v341[1] = v32;
              v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v341, 2));
              v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "componentsJoinedByString:", CFSTR("_")));

              v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "stringByAppendingPathExtension:", CFSTR("bc")));
              v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v290 + 200), "stringByAppendingPathComponent:", v42));
              v296 = 0;
              objc_msgSend(v38, "writeToFile:options:error:", v43, 1, &v296);

            }
            objc_msgSend(v287, "addObject:", v38);
            v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSNull null](NSNull, "null"));
            unk_755130(__s, "addObject:", v44);

          }
        }

      }
      v29 = objc_msgSend(v28, "countByEnumeratingWithState:objects:count:", &v297, v342, 16);
    }
    while (v29);
  }

  v294 = 0u;
  v295 = 0u;
  v292 = 0u;
  v293 = 0u;
  v45 = *(id *)(v290 + 120);
  v46 = objc_msgSend(v45, "countByEnumeratingWithState:objects:count:", &v292, v340, 16);
  if (v46)
  {
    v47 = *(_QWORD *)v293;
    do
    {
      for (k = 0; (id)k != v46; ++k)
      {
        if (*(_QWORD *)v293 != v47)
          objc_enumerationMutation(v45);
        v48 = *(void **)(*((_QWORD *)&v292 + 1) + 8 * k);
        v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v48, "bitcodeData"));
        if (v49)
        {
          if ((*(_BYTE *)(v290 + 208) & 8) != 0)
          {
            v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v48, "installName"));
            v51 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v50, "stringByAppendingPathExtension:", CFSTR("bc")));
            v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v290 + 200), "stringByAppendingPathComponent:", v51));
            v291 = 0;
            objc_msgSend(v49, "writeToFile:options:error:", v52, 1, &v291);

          }
          objc_msgSend(v287, "addObject:", v49);
          v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSNull null](NSNull, "null"));
          unk_755138(__s, "addObject:", v53);

        }
      }
      v46 = objc_msgSend(v45, "countByEnumeratingWithState:objects:count:", &v292, v340, 16);
    }
    while (v46);
  }

  v54 = *(id *)(v290 + 104);
  v55 = v287;
  v282 = __s;
  v275 = v54;
  v349 = 0;
  v347 = 0u;
  v348 = 0u;
  v346 = 0u;
  v350 = 0u;
  v351 = 0u;
  v352 = 0u;
  v353 = 0u;
  v354 = 0;
  v355[0] = v356;
  v355[1] = (char *)0x400000000;
  v284 = v55;
  llvm::LLVMContext::LLVMContext((llvm::LLVMContext *)v326);
  v324 = 0uLL;
  v325 = 0;
  v322 = 0u;
  __p = 0u;
  v323 = 1.0;
  v56 = (char *)objc_msgSend(v55, "count");
  if (v56)
  {
    v288 = v56;
    v277 = 0;
    v57 = 0;
    while (1)
    {
      v58 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v55, "objectAtIndexedSubscript:", v57)));
      llvm::MemoryBuffer::getMemBuffer(v357, objc_msgSend(v58, "bytes"), objc_msgSend(v58, "length"), "", 0, 0);
      llvm::MemoryBuffer::getMemBufferRef(v357[0]);
      llvm::parseIR(v345, v320, &v346, v326, llvm::function_ref<llvm::Optional<std::string> ()(llvm::StringRef)>::callback_fn<llvm::$_0>, &v313);
      v59 = v345[0];
      if (v345[0])
      {
        v60 = (_QWORD *)v324.i64[1];
        v61 = (_QWORD *)v324.i64[0];
        v62 = v324.i64[1] - v324.i64[0];
        v63 = (v324.i64[1] - v324.i64[0]) >> 3;
        if (v324.i64[1] >= (unint64_t)v325)
        {
          v69 = v63 + 1;
          if ((unint64_t)(v63 + 1) >> 61)
            abort();
          v70 = (uint64_t)&v325[-v324.i64[0]];
          if ((uint64_t)&v325[-v324.i64[0]] >> 2 > v69)
            v69 = v70 >> 2;
          if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFF8)
            k = 0x1FFFFFFFFFFFFFFFLL;
          else
            k = v69;
          if (k)
          {
            if (k >> 61)
              std::__throw_bad_array_new_length[abi:nn180100]();
            v71 = (char *)operator new(8 * k);
          }
          else
          {
            v71 = 0;
          }
          v72 = (llvm::Module **)&v71[8 * v63];
          v345[0] = 0;
          *v72 = v59;
          v64 = v72 + 1;
          if (v60 == v61)
          {
            v74 = vdupq_n_s64((unint64_t)v60);
          }
          else
          {
            do
            {
              v73 = (llvm::Module *)*--v60;
              *v60 = 0;
              *--v72 = v73;
            }
            while (v60 != v61);
            v74 = v324;
          }
          v324.i64[0] = (uint64_t)v72;
          v324.i64[1] = (uint64_t)v64;
          v325 = &v71[8 * k];
          v76 = (llvm::Module **)v74.i64[1];
          v75 = (llvm::Module **)v74.i64[0];
          while (v76 != v75)
            std::unique_ptr<llvm::Module>::reset[abi:nn180100](--v76);
          if (v75)
            operator delete(v75);
        }
        else
        {
          v345[0] = 0;
          *(_QWORD *)v324.i64[1] = v59;
          v64 = v60 + 1;
        }
        v324.i64[1] = (uint64_t)v64;
        v67 = (id)objc_claimAutoreleasedReturnValue(unk_755140(v282, "objectAtIndexedSubscript:", v57));
        v77 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](NSNull, "null"));
        v78 = v67 == v77;

        if (!v78)
        {
          v67 = objc_retainAutorelease(v67);
          __sa = (std::string::value_type *)objc_msgSend(v67, "UTF8String");
          v79 = (v62 >> 3);
          v80 = *((_QWORD *)&__p + 1);
          if (*((_QWORD *)&__p + 1))
          {
            v81 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&__p + 8));
            v81.i16[0] = vaddlv_u8(v81);
            if (v81.u32[0] > 1uLL)
            {
              k = (v62 >> 3);
              if (*((_QWORD *)&__p + 1) <= v79)
                k = v79 % *((_QWORD *)&__p + 1);
            }
            else
            {
              k = (DWORD2(__p) - 1) & v79;
            }
            v82 = *(void ***)(__p + 8 * k);
            if (v82)
            {
              v83 = (std::string *)*v82;
              if (*v82)
              {
                do
                {
                  size = v83->__r_.__value_.__l.__size_;
                  if (size == v79)
                  {
                    if (LODWORD(v83->__r_.__value_.__r.__words[2]) == (_DWORD)v63)
                    {
                      v106 = __sa;
                      goto LABEL_156;
                    }
                  }
                  else
                  {
                    if (v81.u32[0] > 1uLL)
                    {
                      if (size >= *((_QWORD *)&__p + 1))
                        size %= *((_QWORD *)&__p + 1);
                    }
                    else
                    {
                      size &= *((_QWORD *)&__p + 1) - 1;
                    }
                    if (size != k)
                      break;
                  }
                  v83 = (std::string *)v83->__r_.__value_.__r.__words[0];
                }
                while (v83);
              }
            }
          }
          v83 = (std::string *)operator new(0x30uLL);
          v83->__r_.__value_.__r.__words[0] = 0;
          v83->__r_.__value_.__l.__size_ = v79;
          LODWORD(v83->__r_.__value_.__r.__words[2]) = v63;
          v83[1].__r_.__value_.__r.__words[0] = 0;
          v83[1].__r_.__value_.__l.__size_ = 0;
          v83[1].__r_.__value_.__r.__words[2] = 0;
          v85 = (float)(unint64_t)(*((_QWORD *)&v322 + 1) + 1);
          if (v80 && (float)(v323 * (float)v80) >= v85)
          {
            v106 = __sa;
            goto LABEL_146;
          }
          v86 = (v80 & (v80 - 1)) != 0;
          if (v80 < 3)
            v86 = 1;
          v87 = v86 | (2 * v80);
          v88 = vcvtps_u32_f32(v85 / v323);
          if (v87 <= v88)
            prime = (int8x8_t)v88;
          else
            prime = (int8x8_t)v87;
          if (*(_QWORD *)&prime == 1)
          {
            prime = (int8x8_t)2;
          }
          else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
          {
            prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
            v80 = *((_QWORD *)&__p + 1);
          }
          if (*(_QWORD *)&prime <= v80)
          {
            if (*(_QWORD *)&prime >= v80)
              goto LABEL_140;
            v96 = vcvtps_u32_f32((float)*((unint64_t *)&v322 + 1) / v323);
            if (v80 < 3 || (v97 = (uint8x8_t)vcnt_s8((int8x8_t)v80), v97.i16[0] = vaddlv_u8(v97), v97.u32[0] > 1uLL))
            {
              v96 = std::__next_prime(v96);
            }
            else
            {
              v98 = 1 << -(char)__clz(v96 - 1);
              if (v96 >= 2)
                v96 = v98;
            }
            if (*(_QWORD *)&prime <= v96)
              prime = (int8x8_t)v96;
            if (*(_QWORD *)&prime >= v80)
            {
              v80 = *((_QWORD *)&__p + 1);
              goto LABEL_140;
            }
            if (prime)
              goto LABEL_111;
            v107 = (void *)__p;
            *(_QWORD *)&__p = 0;
            v106 = __sa;
            if (v107)
              operator delete(v107);
            v80 = 0;
            *((_QWORD *)&__p + 1) = 0;
          }
          else
          {
LABEL_111:
            if (*(_QWORD *)&prime >> 61)
              std::__throw_bad_array_new_length[abi:nn180100]();
            v90 = operator new(8 * *(_QWORD *)&prime);
            v91 = (void *)__p;
            *(_QWORD *)&__p = v90;
            if (v91)
              operator delete(v91);
            v92 = 0;
            *((int8x8_t *)&__p + 1) = prime;
            do
              *(_QWORD *)(__p + 8 * v92++) = 0;
            while (*(_QWORD *)&prime != v92);
            v93 = (_QWORD **)v322;
            if ((_QWORD)v322)
            {
              v94 = *(_QWORD *)(v322 + 8);
              v95 = (uint8x8_t)vcnt_s8(prime);
              v95.i16[0] = vaddlv_u8(v95);
              if (v95.u32[0] > 1uLL)
              {
                if (v94 >= *(_QWORD *)&prime)
                  v94 %= *(_QWORD *)&prime;
              }
              else
              {
                v94 &= *(_QWORD *)&prime - 1;
              }
              *(_QWORD *)(__p + 8 * v94) = &v322;
              for (m = *v93; m; v94 = v100)
              {
                v100 = m[1];
                if (v95.u32[0] > 1uLL)
                {
                  if (v100 >= *(_QWORD *)&prime)
                    v100 %= *(_QWORD *)&prime;
                }
                else
                {
                  v100 &= *(_QWORD *)&prime - 1;
                }
                if (v100 != v94)
                {
                  if (!*(_QWORD *)(__p + 8 * v100))
                  {
                    *(_QWORD *)(__p + 8 * v100) = v93;
                    goto LABEL_136;
                  }
                  *v93 = (_QWORD *)*m;
                  *m = **(_QWORD **)(__p + 8 * v100);
                  **(_QWORD **)(__p + 8 * v100) = m;
                  m = v93;
                }
                v100 = v94;
LABEL_136:
                v93 = (_QWORD **)m;
                m = (_QWORD *)*m;
              }
            }
            v80 = (unint64_t)prime;
LABEL_140:
            v106 = __sa;
          }
          if ((v80 & (v80 - 1)) != 0)
          {
            if (v80 <= v79)
              k = v79 % v80;
            else
              k = v79;
          }
          else
          {
            k = ((_DWORD)v80 - 1) & v79;
          }
LABEL_146:
          v101 = __p;
          v102 = *(std::string ***)(__p + 8 * k);
          if (v102)
          {
            v83->__r_.__value_.__r.__words[0] = (std::string::size_type)*v102;
            goto LABEL_154;
          }
          v83->__r_.__value_.__r.__words[0] = v322;
          *(_QWORD *)&v322 = v83;
          *(_QWORD *)(v101 + 8 * k) = &v322;
          if (v83->__r_.__value_.__r.__words[0])
          {
            v103 = *(_QWORD *)(v83->__r_.__value_.__r.__words[0] + 8);
            if ((v80 & (v80 - 1)) != 0)
            {
              if (v103 >= v80)
                v103 %= v80;
            }
            else
            {
              v103 &= v80 - 1;
            }
            v102 = (std::string **)(__p + 8 * v103);
LABEL_154:
            *v102 = v83;
          }
          ++*((_QWORD *)&v322 + 1);
LABEL_156:
          std::string::assign(v83 + 1, v106);
        }
      }
      else
      {
        if ((SBYTE7(v351) & 0x80u) == 0)
          v65 = &v350;
        else
          v65 = (__int128 *)v350;
        if ((SBYTE7(v351) & 0x80u) == 0)
          v66 = BYTE7(v351);
        else
          v66 = *((_QWORD *)&v350 + 1);
        v67 = objc_msgSend(objc_alloc((Class)NSString), "initWithBytes:length:encoding:", v65, v66, +[NSString defaultCStringEncoding](NSString, "defaultCStringEncoding"));
        v68 = GTShaderDebuggerMDSerializerError(1u, (NSString *)v67);
        v277 = (id)objc_claimAutoreleasedReturnValue(v68);
      }

      v104 = v345[0];
      v345[0] = 0;
      if (v104)
      {
        llvm::Module::~Module(v104);
        operator delete();
      }
      v105 = v357[0];
      v357[0] = 0;
      if (v105)
        (*(void (**)(llvm::MemoryBuffer *))(*(_QWORD *)v105 + 8))(v105);

      if (!v59)
      {
        v260 = 0;
        v261 = 0;
        goto LABEL_461;
      }
      ++v57;
      v55 = v284;
      if (v57 == v288)
        goto LABEL_178;
    }
  }
  v277 = 0;
LABEL_178:
  v314 = 0;
  v315 = 0;
  v313 = &v314;
  v316 = 0u;
  v317 = 0u;
  v318 = 1065353216;
  v319 = 0;
  v309 = 0u;
  v310 = 0u;
  v311 = 0u;
  v312 = 0u;
  v110 = v275;
  v111 = objc_msgSend(v110, "countByEnumeratingWithState:objects:count:", &v309, v345, 16);
  if (v111)
  {
    v112 = *(_QWORD *)v310;
    do
    {
      for (n = 0; n != v111; n = (char *)n + 1)
      {
        if (*(_QWORD *)v310 != v112)
          objc_enumerationMutation(v110);
        v114 = *(void **)(*((_QWORD *)&v309 + 1) + 8 * (_QWORD)n);
        v115 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v110, "objectForKeyedSubscript:", v114));
        std::string::basic_string[abi:nn180100]<0>(v357, (char *)objc_msgSend(objc_retainAutorelease(v114), "UTF8String"));
        v116 = objc_retainAutorelease(v115);
        std::string::basic_string[abi:nn180100]<0>(&v337, (char *)objc_msgSend(v116, "UTF8String"));
        ShaderDebugger::Metadata::MDSerializer::addReferencedSourceFile((uint64_t)&v313, (uint64_t)v357, (uint64_t)&v337);
        if (SBYTE7(v338) < 0)
          operator delete((void *)v337);
        if ((v358[7] & 0x80000000) != 0)
          operator delete(v357[0]);

      }
      v111 = objc_msgSend(v110, "countByEnumeratingWithState:objects:count:", &v309, v345, 16);
    }
    while (v111);
  }

  std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::destroy(v314);
  v314 = 0;
  v315 = 0;
  v313 = &v314;
  v117 = (uint64_t)v357;
  std::string::basic_string[abi:nn180100]<0>(v357, "tracepoint_thread_begin");
  v118 = operator new(0x20uLL);
  *v118 = off_725920;
  v118[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeThreadTracePoint;
  v118[2] = 0;
  v118[3] = &v313;
  v359 = v118;
  std::string::basic_string[abi:nn180100]<0>(v360, "tracepoint_function_begin");
  v119 = operator new(0x20uLL);
  *v119 = off_725920;
  v119[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeFunctionBeginTracePoint;
  v119[2] = 0;
  v119[3] = &v313;
  v363[1] = v119;
  std::string::basic_string[abi:nn180100]<0>(v364, "tracepoint_function_end");
  v120 = operator new(0x20uLL);
  *v120 = off_725920;
  v120[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeFunctionEndTracePoint;
  v120[2] = 0;
  v120[3] = &v313;
  v365 = v120;
  std::string::basic_string[abi:nn180100]<0>(&v366, "tracepoint_call");
  v121 = operator new(0x20uLL);
  *v121 = off_725920;
  v121[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeFunctionCallTracePoint;
  v121[2] = 0;
  v121[3] = &v313;
  v367[5] = v121;
  std::string::basic_string[abi:nn180100]<0>(&v368, "tracepoint_variable");
  v122 = operator new(0x20uLL);
  *v122 = off_725920;
  v122[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeVariableTracePoint;
  v122[2] = 0;
  v122[3] = &v313;
  v371[2] = v122;
  std::string::basic_string[abi:nn180100]<0>(v372, "tracepoint_data");
  v123 = operator new(0x20uLL);
  *v123 = off_725920;
  v123[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeDataTracePoint;
  v123[2] = 0;
  v123[3] = &v313;
  v374 = (uint64_t)v123;
  std::string::basic_string[abi:nn180100]<0>(v375, "tracepoint_data_value");
  v124 = operator new(0x20uLL);
  *v124 = off_725920;
  v124[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeDataValueTracePoint;
  v124[2] = 0;
  v124[3] = &v313;
  v375[6] = v124;
  std::string::basic_string[abi:nn180100]<0>(&v376, "tracepoint_loop_begin_for");
  v125 = operator new(0x28uLL);
  *v125 = &off_725968;
  v125[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v125[2] = 0;
  v125[3] = &v313;
  v125[4] = 0;
  v381[1] = v125;
  std::string::basic_string[abi:nn180100]<0>(v382, "tracepoint_loop_begin_while");
  v126 = operator new(0x28uLL);
  *v126 = &off_725968;
  v126[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v126[2] = 0;
  v126[3] = &v313;
  v126[4] = 1;
  v382[6] = v126;
  std::string::basic_string[abi:nn180100]<0>(v383, "tracepoint_loop_begin_do");
  v127 = operator new(0x28uLL);
  *v127 = &off_725968;
  v127[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v127[2] = 0;
  v127[3] = &v313;
  v127[4] = 2;
  v383[6] = v127;
  std::string::basic_string[abi:nn180100]<0>(v384, "tracepoint_loop_init_begin");
  v128 = operator new(0x28uLL);
  *v128 = &off_725968;
  v128[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v128[2] = 0;
  v128[3] = &v313;
  v128[4] = 3;
  v384[6] = v128;
  std::string::basic_string[abi:nn180100]<0>(v385, "tracepoint_loop_init_end");
  v129 = operator new(0x28uLL);
  *v129 = &off_725968;
  v129[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v129[2] = 0;
  v129[3] = &v313;
  v129[4] = 4;
  v385[6] = v129;
  std::string::basic_string[abi:nn180100]<0>(v386, "tracepoint_loop_cond_begin");
  v130 = operator new(0x28uLL);
  *v130 = &off_725968;
  v130[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v130[2] = 0;
  v130[3] = &v313;
  v130[4] = 5;
  v386[6] = v130;
  std::string::basic_string[abi:nn180100]<0>(v387, "tracepoint_loop_cond_end");
  v131 = operator new(0x28uLL);
  *v131 = &off_725968;
  v131[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v131[2] = 0;
  v131[3] = &v313;
  v131[4] = 6;
  v387[6] = v131;
  std::string::basic_string[abi:nn180100]<0>(v388, "tracepoint_loop_inc_begin");
  v132 = operator new(0x28uLL);
  *v132 = &off_725968;
  v132[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v132[2] = 0;
  v132[3] = &v313;
  v132[4] = 7;
  v388[6] = v132;
  std::string::basic_string[abi:nn180100]<0>(v389, "tracepoint_loop_inc_end");
  v133 = operator new(0x28uLL);
  *v133 = &off_725968;
  v133[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v133[2] = 0;
  v133[3] = &v313;
  v133[4] = 8;
  v389[6] = v133;
  std::string::basic_string[abi:nn180100]<0>(v390, "tracepoint_loop_body_begin");
  v134 = operator new(0x28uLL);
  *v134 = &off_725968;
  v134[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v134[2] = 0;
  v134[3] = &v313;
  v134[4] = 9;
  v390[6] = v134;
  std::string::basic_string[abi:nn180100]<0>(v391, "tracepoint_loop_body_end");
  v135 = operator new(0x28uLL);
  *v135 = &off_725968;
  v135[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v135[2] = 0;
  v135[3] = &v313;
  v135[4] = 10;
  v391[6] = v135;
  std::string::basic_string[abi:nn180100]<0>(v392, "tracepoint_loop_end");
  v136 = operator new(0x28uLL);
  *v136 = &off_725968;
  v136[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v136[2] = 0;
  v136[3] = &v313;
  v136[4] = 11;
  v392[6] = v136;
  std::string::basic_string[abi:nn180100]<0>(v393, "tracepoint_thread_exit");
  v137 = operator new(0x28uLL);
  v138 = 0;
  *v137 = &off_725968;
  v137[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v137[2] = 0;
  v137[3] = &v313;
  v137[4] = 12;
  v393[6] = v137;
  v337 = 0u;
  v338 = 0u;
  v339 = 1.0;
  do
  {
    v139 = &v357[7 * v138];
    v140 = *((char *)v139 + 23);
    v141 = (const std::string::value_type *)*v139;
    v142 = (std::string::size_type)v139[1];
    if (v140 >= 0)
      v143 = (uint64_t *)&v357[7 * v138];
    else
      v143 = (uint64_t *)*v139;
    if (v140 >= 0)
      v144 = *((unsigned __int8 *)v139 + 23);
    else
      v144 = (unint64_t)v139[1];
    v145 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v143, v144);
    v146 = v145;
    v147 = *((_QWORD *)&v337 + 1);
    if (*((_QWORD *)&v337 + 1))
    {
      v148 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v337 + 8));
      v148.i16[0] = vaddlv_u8(v148);
      v149 = v148.u32[0];
      if (v148.u32[0] > 1uLL)
      {
        v117 = v145;
        if (v145 >= *((_QWORD *)&v337 + 1))
          v117 = v145 % *((_QWORD *)&v337 + 1);
      }
      else
      {
        v117 = (*((_QWORD *)&v337 + 1) - 1) & v145;
      }
      v150 = *(unsigned __int8 ***)(v337 + 8 * v117);
      if (v150)
      {
        for (ii = *v150; ii; ii = *(unsigned __int8 **)ii)
        {
          v152 = *((_QWORD *)ii + 1);
          if (v152 == v146)
          {
            if (std::equal_to<std::string>::operator()[abi:nn180100](ii + 16, (unsigned __int8 *)&v357[7 * v138]))
              goto LABEL_276;
          }
          else
          {
            if (v149 > 1)
            {
              if (v152 >= v147)
                v152 %= v147;
            }
            else
            {
              v152 &= v147 - 1;
            }
            if (v152 != v117)
              break;
          }
        }
      }
    }
    v153 = operator new(0x48uLL);
    *v153 = 0;
    v153[1] = v146;
    v154 = (std::string *)(v153 + 2);
    if (v140 < 0)
    {
      std::string::__init_copy_ctor_external(v154, v141, v142);
    }
    else
    {
      *(_OWORD *)&v154->__r_.__value_.__l.__data_ = *(_OWORD *)v139;
      v153[4] = v139[2];
    }
    v155 = &v357[7 * v138];
    v156 = v155[6];
    if (v156)
    {
      v157 = v155 + 3;
      if (v156 == (llvm::MemoryBuffer *)v157)
      {
        v153[8] = v153 + 5;
        (*((void (**)(llvm::MemoryBuffer **))*v157 + 3))(v157);
      }
      else
      {
        v153[8] = (*(uint64_t (**)(llvm::MemoryBuffer *))(*(_QWORD *)v156 + 16))(v156);
      }
    }
    else
    {
      v153[8] = 0;
    }
    v158 = (float)(unint64_t)(*((_QWORD *)&v338 + 1) + 1);
    if (!v147 || (float)(v339 * (float)v147) < v158)
    {
      v159 = (v147 & (v147 - 1)) != 0;
      if (v147 < 3)
        v159 = 1;
      v160 = v159 | (2 * v147);
      v161 = vcvtps_u32_f32(v158 / v339);
      if (v160 <= v161)
        v162 = (int8x8_t)v161;
      else
        v162 = (int8x8_t)v160;
      if (*(_QWORD *)&v162 == 1)
      {
        v162 = (int8x8_t)2;
      }
      else if ((*(_QWORD *)&v162 & (*(_QWORD *)&v162 - 1)) != 0)
      {
        v162 = (int8x8_t)std::__next_prime(*(_QWORD *)&v162);
      }
      v147 = *((_QWORD *)&v337 + 1);
      if (*(_QWORD *)&v162 > *((_QWORD *)&v337 + 1))
        goto LABEL_232;
      if (*(_QWORD *)&v162 < *((_QWORD *)&v337 + 1))
      {
        v169 = vcvtps_u32_f32((float)*((unint64_t *)&v338 + 1) / v339);
        if (*((_QWORD *)&v337 + 1) < 3uLL
          || (v170 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v337 + 8)),
              v170.i16[0] = vaddlv_u8(v170),
              v170.u32[0] > 1uLL))
        {
          v169 = std::__next_prime(v169);
        }
        else
        {
          v171 = 1 << -(char)__clz(v169 - 1);
          if (v169 >= 2)
            v169 = v171;
        }
        if (*(_QWORD *)&v162 <= v169)
          v162 = (int8x8_t)v169;
        if (*(_QWORD *)&v162 >= v147)
        {
          v147 = *((_QWORD *)&v337 + 1);
        }
        else
        {
          if (v162)
          {
LABEL_232:
            if (*(_QWORD *)&v162 >> 61)
              std::__throw_bad_array_new_length[abi:nn180100]();
            v163 = operator new(8 * *(_QWORD *)&v162);
            v164 = (void *)v337;
            *(_QWORD *)&v337 = v163;
            if (v164)
              operator delete(v164);
            v165 = 0;
            *((int8x8_t *)&v337 + 1) = v162;
            do
              *(_QWORD *)(v337 + 8 * v165++) = 0;
            while (*(_QWORD *)&v162 != v165);
            v166 = (_QWORD **)v338;
            if ((_QWORD)v338)
            {
              v167 = *(_QWORD *)(v338 + 8);
              v168 = (uint8x8_t)vcnt_s8(v162);
              v168.i16[0] = vaddlv_u8(v168);
              if (v168.u32[0] > 1uLL)
              {
                if (v167 >= *(_QWORD *)&v162)
                  v167 %= *(_QWORD *)&v162;
              }
              else
              {
                v167 &= *(_QWORD *)&v162 - 1;
              }
              *(_QWORD *)(v337 + 8 * v167) = &v338;
              for (jj = *v166; jj; v167 = v173)
              {
                v173 = jj[1];
                if (v168.u32[0] > 1uLL)
                {
                  if (v173 >= *(_QWORD *)&v162)
                    v173 %= *(_QWORD *)&v162;
                }
                else
                {
                  v173 &= *(_QWORD *)&v162 - 1;
                }
                if (v173 != v167)
                {
                  if (!*(_QWORD *)(v337 + 8 * v173))
                  {
                    *(_QWORD *)(v337 + 8 * v173) = v166;
                    goto LABEL_257;
                  }
                  *v166 = (_QWORD *)*jj;
                  *jj = **(_QWORD **)(v337 + 8 * v173);
                  **(_QWORD **)(v337 + 8 * v173) = jj;
                  jj = v166;
                }
                v173 = v167;
LABEL_257:
                v166 = (_QWORD **)jj;
                jj = (_QWORD *)*jj;
              }
            }
            v147 = (unint64_t)v162;
            goto LABEL_261;
          }
          v177 = (void *)v337;
          *(_QWORD *)&v337 = 0;
          if (v177)
            operator delete(v177);
          v147 = 0;
          *((_QWORD *)&v337 + 1) = 0;
        }
      }
LABEL_261:
      if ((v147 & (v147 - 1)) != 0)
      {
        if (v146 >= v147)
          v117 = v146 % v147;
        else
          v117 = v146;
      }
      else
      {
        v117 = (v147 - 1) & v146;
      }
    }
    v174 = v337;
    v175 = *(_QWORD **)(v337 + 8 * v117);
    if (v175)
    {
      *v153 = *v175;
LABEL_274:
      *v175 = v153;
      goto LABEL_275;
    }
    *v153 = v338;
    *(_QWORD *)&v338 = v153;
    *(_QWORD *)(v174 + 8 * v117) = &v338;
    if (*v153)
    {
      v176 = *(_QWORD *)(*v153 + 8);
      if ((v147 & (v147 - 1)) != 0)
      {
        if (v176 >= v147)
          v176 %= v147;
      }
      else
      {
        v176 &= v147 - 1;
      }
      v175 = (_QWORD *)(v337 + 8 * v176);
      goto LABEL_274;
    }
LABEL_275:
    ++*((_QWORD *)&v338 + 1);
LABEL_276:
    ++v138;
  }
  while (v138 != 20);
  v178 = 1120;
  do
  {
    v179 = *(_BYTE **)&v356[v178 + 160];
    if (&v356[v178 + 136] == v179)
    {
      v179 = &v356[v178 + 136];
      v180 = 4;
    }
    else
    {
      if (!v179)
        goto LABEL_292;
      v180 = 5;
    }
    (*(void (**)(void))(*(_QWORD *)v179 + 8 * v180))();
LABEL_292:
    if ((char)v356[v178 + 135] < 0)
      operator delete(*(void **)&v356[v178 + 112]);
    v178 -= 56;
  }
  while (v178);
  if (((v324.i64[1] - v324.i64[0]) & 0x7FFFFFFF8) != 0)
  {
    v181 = 0;
    v289 = ((unint64_t)(v324.i64[1] - v324.i64[0]) >> 3);
    do
    {
      v182 = v324.i64[0];
      v357[0] = (llvm::MemoryBuffer *)v358;
      v357[1] = (llvm::MemoryBuffer *)0x800000000;
      v361 = v363;
      v362 = 0x800000000;
      v365 = v367;
      v366 = 0x800000000;
      v369 = v371;
      v370 = 0x800000000;
      v373 = v375;
      v374 = 0x800000000;
      v377 = v381;
      v378 = v381;
      v379 = 32;
      v380 = 0;
      llvm::DebugInfoFinder::processModule((llvm::DebugInfoFinder *)v357, *(const llvm::Module **)(v324.i64[0] + 8 * v181));
      if ((_DWORD)v362)
      {
        if (*((_QWORD *)&__p + 1))
        {
          v183 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&__p + 8));
          v183.i16[0] = vaddlv_u8(v183);
          if (v183.u32[0] > 1uLL)
          {
            v184 = v181;
            if (*((_QWORD *)&__p + 1) <= v181)
              v184 = v181 % *((_QWORD *)&__p + 1);
          }
          else
          {
            v184 = (*((_QWORD *)&__p + 1) + 0xFFFFFFFFLL) & v181;
          }
          v185 = *(uint64_t ***)(__p + 8 * v184);
          if (v185)
          {
            for (kk = *v185; kk; kk = (uint64_t *)*kk)
            {
              v187 = kk[1];
              if (v187 == v181)
              {
                if (v181 == *((_DWORD *)kk + 4))
                {
                  v225 = (uint64_t)(kk + 3);
                  goto LABEL_315;
                }
              }
              else
              {
                if (v183.u32[0] > 1uLL)
                {
                  if (v187 >= *((_QWORD *)&__p + 1))
                    v187 %= *((_QWORD *)&__p + 1);
                }
                else
                {
                  v187 &= *((_QWORD *)&__p + 1) - 1;
                }
                if (v187 != v184)
                  break;
              }
            }
          }
        }
        v225 = *(_QWORD *)(v182 + 8 * v181) + 192;
LABEL_315:
        if (*(char *)(v225 + 23) < 0)
          std::string::__init_copy_ctor_external(&v336, *(const std::string::value_type **)v225, *(_QWORD *)(v225 + 8));
        else
          v336 = *(std::string *)v225;
        std::string::basic_string[abi:nn180100]<0>(&v333, "__trace.base_id");
        if ((v335 & 0x80u) == 0)
          v188 = v335;
        else
          v188 = v334;
        std::string::basic_string[abi:nn180100]((uint64_t)&v328, v188 + 1);
        if ((v328.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v189 = &v328;
        else
          v189 = (std::string *)v328.__r_.__value_.__r.__words[0];
        if (v188)
        {
          if ((v335 & 0x80u) == 0)
            v190 = &v333;
          else
            v190 = v333;
          memmove(v189, v190, v188);
        }
        *(_WORD *)((char *)&v189->__r_.__value_.__l.__data_ + v188) = 46;
        if ((v336.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v191 = &v336;
        else
          v191 = (std::string *)v336.__r_.__value_.__r.__words[0];
        if ((v336.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v192 = HIBYTE(v336.__r_.__value_.__r.__words[2]);
        else
          v192 = v336.__r_.__value_.__l.__size_;
        v193 = std::string::append(&v328, (const std::string::value_type *)v191, v192);
        v194 = v193->__r_.__value_.__r.__words[2];
        v331 = *(_OWORD *)&v193->__r_.__value_.__l.__data_;
        v332 = v194;
        v193->__r_.__value_.__l.__size_ = 0;
        v193->__r_.__value_.__r.__words[2] = 0;
        v193->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v328.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v328.__r_.__value_.__l.__data_);
        v330 = 0;
        if (v332 >= 0)
          v195 = &v331;
        else
          v195 = (__int128 *)v331;
        if (v332 >= 0)
          v196 = HIBYTE(v332);
        else
          v196 = *((_QWORD *)&v331 + 1);
        GlobalVariable = llvm::Module::getGlobalVariable(*(_QWORD *)(v182 + 8 * v181), v195, v196, 1);
        if (GlobalVariable
          || ((v335 & 0x80u) == 0 ? (v198 = &v333) : (v198 = v333),
              (v335 & 0x80u) == 0 ? (v199 = v335) : (v199 = v334),
              (GlobalVariable = llvm::Module::getGlobalVariable(*(_QWORD *)(v182 + 8 * v181), v198, v199, 1)) != 0))
        {
          v200 = *(_QWORD *)(GlobalVariable - 32);
          if (v200)
          {
            v201 = *(_DWORD *)(v200 + 32);
            if (v201 > 0x40)
              v202 = **(_QWORD **)(v200 + 24);
            else
              v202 = (uint64_t)(*(_QWORD *)(v200 + 24) << -(char)v201) >> -(char)v201;
            v330 = v202;
          }
        }
        v203 = *(_QWORD *)(v182 + 8 * v181);
        v328.__r_.__value_.__r.__words[0] = (std::string::size_type)"tracepoint_library_version";
        v329 = 259;
        NamedMetadata = (llvm::NamedMDNode *)llvm::Module::getNamedMetadata(v203, &v328);
        if (NamedMetadata)
        {
          Operand = llvm::NamedMDNode::getOperand(NamedMetadata, 0);
          v206 = *(_QWORD *)(*(_QWORD *)(Operand - 8 * *(unsigned int *)(Operand + 8)) + 128);
          v207 = *(_DWORD *)(v206 + 32);
          if (v207 > 0x40)
            LODWORD(v206) = **(_DWORD **)(v206 + 24);
          else
            v206 = (uint64_t)(*(_QWORD *)(v206 + 24) << -(char)v207) >> -(char)v207;
          v319 = v206;
        }
        v327[0] = &v330;
        v327[1] = (int *)&v337;
        v327[2] = (int *)v357;
        v208 = *(_QWORD *)(v182 + 8 * v181);
        v328.__r_.__value_.__r.__words[0] = (std::string::size_type)"tracepoint.sets";
        v329 = 259;
        v209 = (llvm::NamedMDNode *)llvm::Module::getNamedMetadata(v208, &v328);
        if (v209)
        {
          v210 = v209;
          NumOperands = llvm::NamedMDNode::getNumOperands(v209);
          if (NumOperands)
          {
            v212 = NumOperands;
            for (mm = 0; mm != v212; ++mm)
            {
              v214 = llvm::NamedMDNode::getOperand(v210, mm);
              if (v214)
              {
                v215 = *(_QWORD *)(v214 - 8 * *(unsigned int *)(v214 + 8) + 16);
                if (v215)
                  v216 = (uint64_t *)(v215 - 8 * *(unsigned int *)(v215 + 8));
                else
                  v216 = 0;
                while (v216 != (uint64_t *)v215)
                {
                  v217 = *v216++;
                  ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeModules(std::vector<std::unique_ptr<llvm::Module>> const&,std::unordered_map<unsigned int,std::string> const&,unsigned long long *)::$_0::operator()(v327, v217);
                }
              }
            }
          }
        }
        else
        {
          v218 = *(_QWORD *)(v182 + 8 * v181);
          v328.__r_.__value_.__r.__words[0] = (std::string::size_type)"tracepoint";
          v329 = 259;
          v219 = (llvm::NamedMDNode *)llvm::Module::getNamedMetadata(v218, &v328);
          if (v219)
          {
            v220 = v219;
            v221 = llvm::NamedMDNode::getNumOperands(v219);
            if (v221)
            {
              v222 = v221;
              for (nn = 0; nn != v222; ++nn)
              {
                v224 = llvm::NamedMDNode::getOperand(v220, nn);
                ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeModules(std::vector<std::unique_ptr<llvm::Module>> const&,std::unordered_map<unsigned int,std::string> const&,unsigned long long *)::$_0::operator()(v327, v224);
              }
            }
          }
        }
        if (SHIBYTE(v332) < 0)
          operator delete((void *)v331);
        if ((char)v335 < 0)
          operator delete(v333);
        if (SHIBYTE(v336.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v336.__r_.__value_.__l.__data_);
      }
      if (v378 != v377)
        free(v378);
      if (v373 != v375)
        free(v373);
      if (v369 != v371)
        free(v369);
      if (v365 != v367)
        free(v365);
      if (v361 != v363)
        free(v361);
      if ((_BYTE *)v357[0] != v358)
        free(v357[0]);
      ++v181;
    }
    while (v181 != v289);
  }
  v306 = 0;
  v307 = 0;
  v308 = 0;
  if (v315)
  {
    v357[0] = (llvm::MemoryBuffer *)&dword_4;
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)&v306, v357);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)&v306, &v319);
    v226 = v313;
    if (v313 != &v314)
    {
      do
      {
        v227 = v226[5];
        v357[0] = (llvm::MemoryBuffer *)v226[4];
        v328.__r_.__value_.__r.__words[0] = v226[6] - v227;
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)&v306, v357);
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)&v306, &v328);
        v228 = (char *)v226[11];
        v229 = v226[12];
        v230 = v229 - v228;
        if (v229 - v228 >= 1)
        {
          v231 = v307;
          if (v308 - v307 >= v230)
          {
            if (v230 <= 0)
            {
              v238 = v307;
              v239 = &v307[-v230];
              v240 = v307;
              if (&v307[-v230] < v307)
              {
                v241 = v229 - v228 - (v230 & ~(v230 >> 63));
                v240 = v307;
                do
                {
                  v242 = *v239++;
                  *v240++ = v242;
                  --v241;
                }
                while (v241);
              }
              v307 = v240;
              if (v238 != &v231[v230])
                memmove(&v231[v230], v231, v238 - &v231[v230]);
              if (v229 != v228)
                memmove(v231, v228, v229 - v228);
            }
            else
            {
              if (v229 != v228)
                memmove(v307, v226[11], v229 - v228);
              v307 = &v231[v229 - v228];
            }
          }
          else
          {
            v232 = (char *)v306;
            v233 = v307 - (_BYTE *)v306;
            v234 = v307 - (_BYTE *)v306 + v230;
            if (v234 < 0)
              abort();
            v235 = v308 - (_BYTE *)v306;
            if (2 * (v308 - (_BYTE *)v306) > (unint64_t)v234)
              v234 = 2 * v235;
            if (v235 >= 0x3FFFFFFFFFFFFFFFLL)
              v236 = 0x7FFFFFFFFFFFFFFFLL;
            else
              v236 = v234;
            if (v236)
              v237 = (char *)operator new(v236);
            else
              v237 = 0;
            v243 = &v237[v233];
            v244 = &v237[v233 + v230];
            v245 = v233;
            do
            {
              v246 = *v228++;
              v237[v245++] = v246;
              --v230;
            }
            while (v230);
            if (v231 != v232)
            {
              do
              {
                v237[v233 - 1] = v232[v233 - 1];
                --v233;
              }
              while (v233);
              v243 = v237;
            }
            v247 = v306;
            v306 = v243;
            v307 = v244;
            v308 = &v237[v236];
            if (v247)
              operator delete(v247);
          }
        }
        v248 = v226[1];
        if (v248)
        {
          do
          {
            v249 = (_QWORD **)v248;
            v248 = (_QWORD *)*v248;
          }
          while (v248);
        }
        else
        {
          do
          {
            v249 = (_QWORD **)v226[2];
            v250 = *v249 == v226;
            v226 = v249;
          }
          while (!v250);
        }
        v226 = v249;
      }
      while (v249 != &v314);
    }
    v357[0] = (llvm::MemoryBuffer *)-1;
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)&v306, v357);
    v357[0] = *((llvm::MemoryBuffer **)&v317 + 1);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)&v306, v357);
    for (i1 = (uint64_t *)v317; i1; i1 = (uint64_t *)*i1)
    {
      v252 = (llvm::MemoryBuffer *)*((unsigned __int8 *)i1 + 39);
      if ((char)v252 < 0)
        v252 = (llvm::MemoryBuffer *)i1[3];
      v357[0] = v252;
      ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)&v306, v357);
      v253 = *((char *)i1 + 39);
      if (v253 >= 0)
        v254 = i1 + 2;
      else
        v254 = (_BYTE *)i1[2];
      if (v253 >= 0)
        v255 = *((unsigned __int8 *)i1 + 39);
      else
        v255 = i1[3];
      ShaderDebugger::Metadata::MDSerializer::write((unint64_t *)&v306, v254, v255);
      v256 = (llvm::MemoryBuffer *)*((unsigned __int8 *)i1 + 63);
      if ((char)v256 < 0)
        v256 = (llvm::MemoryBuffer *)i1[6];
      v357[0] = v256;
      ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)&v306, v357);
      v257 = *((char *)i1 + 63);
      if (v257 >= 0)
        v258 = i1 + 5;
      else
        v258 = (_BYTE *)i1[5];
      if (v257 >= 0)
        v259 = *((unsigned __int8 *)i1 + 63);
      else
        v259 = i1[6];
      ShaderDebugger::Metadata::MDSerializer::write((unint64_t *)&v306, v258, v259);
    }
    v260 = v319;
  }
  else
  {
    v260 = 0;
  }
  v262 = (_QWORD *)v338;
  if ((_QWORD)v338)
  {
    do
    {
      v263 = (_QWORD *)*v262;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::function<void ()(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *)>>,0>((uint64_t)(v262 + 2));
      operator delete(v262);
      v262 = v263;
    }
    while (v263);
  }
  v264 = (void *)v337;
  *(_QWORD *)&v337 = 0;
  if (v264)
    operator delete(v264);
  v265 = v306;
  if (v306 == v307)
  {
    v274 = GTShaderDebuggerMDSerializerError(2u, CFSTR("Metadata serialization error"));
    v277 = (id)objc_claimAutoreleasedReturnValue(v274);
    v260 = 0;
    v261 = 0;
    if (v265)
LABEL_459:
      operator delete(v265);
  }
  else
  {
    v261 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", v306, v307 - (_BYTE *)v306));
    if (v265)
      goto LABEL_459;
  }
  ShaderDebugger::Metadata::MDSerializer::~MDSerializer((ShaderDebugger::Metadata::MDSerializer *)&v313);
LABEL_461:
  std::__hash_table<std::__hash_value_type<unsigned int,std::string>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::string>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::string>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::string>>>::~__hash_table((uint64_t)&__p);
  v357[0] = (llvm::MemoryBuffer *)&v324;
  std::vector<std::unique_ptr<llvm::Module>>::__destroy_vector::operator()[abi:nn180100]((void ***)v357);
  llvm::LLVMContext::~LLVMContext((llvm::LLVMContext *)v326);
  llvm::SmallVector<llvm::SMFixIt,4u>::~SmallVector(v355);
  if ((_QWORD)v353)
  {
    *((_QWORD *)&v353 + 1) = v353;
    operator delete((void *)v353);
  }
  if (SHIBYTE(v352) < 0)
    operator delete(*((void **)&v351 + 1));
  if (SBYTE7(v351) < 0)
    operator delete((void *)v350);
  if (SBYTE7(v348) < 0)
    operator delete((void *)v347);

  v266 = v277;
  v267 = v266;
  if (v261)
  {
    objc_storeStrong((id *)(v290 + 152), v261);
    *(_QWORD *)(v290 + 160) = v260;
  }
  else
  {
    v268 = objc_claimAutoreleasedReturnValue(objc_msgSend(v266, "localizedDescription"));
    v269 = (void *)v268;
    v270 = CFSTR("Unknown error");
    if (v268)
      v270 = (__CFString *)v268;
    v271 = v270;

    v272 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(CFSTR("Failed to process debug information: "), "stringByAppendingString:", v271));
    if (v276)
    {
      v273 = GTShaderDebuggerMakeError(4u, v272, CFSTR("Try updating your target device to the latest OS version or try matching your deployment target version to the target device"), 0, 0);
      *v276 = (id)objc_claimAutoreleasedReturnValue(v273);
    }

  }
  v7 = v278;
  if (!v261)
  {
    v8 = 0;
    goto LABEL_176;
  }
LABEL_2:
  v8 = 1;
LABEL_176:

  return v8;
}

void sub_2D4E90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char **a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a66;
  void *v66;
  void *v68;

  if (v66)
    operator delete(v66);
  ShaderDebugger::Metadata::MDSerializer::~MDSerializer((ShaderDebugger::Metadata::MDSerializer *)&a66);
  std::__hash_table<std::__hash_value_type<unsigned int,std::string>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::string>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::string>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::string>>>::~__hash_table((uint64_t)&STACK[0x230]);
  STACK[0x6A8] = (unint64_t)&STACK[0x260];
  std::vector<std::unique_ptr<llvm::Module>>::__destroy_vector::operator()[abi:nn180100]((void ***)&STACK[0x6A8]);
  llvm::LLVMContext::~LLVMContext((llvm::LLVMContext *)&STACK[0x280]);
  llvm::SmallVector<llvm::SMFixIt,4u>::~SmallVector(a11);
  v68 = (void *)STACK[0x5D8];
  if (STACK[0x5D8])
  {
    STACK[0x5E0] = (unint64_t)v68;
    operator delete(v68);
  }
  if (SLOBYTE(STACK[0x5D7]) < 0)
    operator delete((void *)STACK[0x5C0]);
  if (SLOBYTE(STACK[0x5BF]) < 0)
    operator delete((void *)STACK[0x5A8]);
  if (SLOBYTE(STACK[0x597]) < 0)
    operator delete((void *)STACK[0x580]);

  _Unwind_Resume(a1);
}

uint64_t GTShaderDebuggerMakePSOCompute(uint64_t a1, _QWORD *a2, uint64_t a3, apr_allocator_t *a4)
{
  uint64_t i;
  _QWORD *v6;
  uint64_t *v7;
  id v8;
  _QWORD *Object;
  void *v10;
  id v11;
  id v12;
  id v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  id MTLComputePipelineDescriptorWithoutResourceIndex;
  void *v18;
  void *v19;
  uint64_t v20;
  void *v21;
  void *v22;
  id PreloadedDylibsForGlobalRelocation;
  void *v24;
  char *v25;
  uint64_t v26;
  void *v27;
  id PreloadedDylibsForGlobalBinding;
  void *v29;
  char *v30;
  uint64_t v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  id v38;
  id v39;
  char *v40;
  uint64_t v41;
  id v42;
  id v43;
  int v44;
  void *v45;
  unsigned int v46;
  id v47;
  id v48;
  id v49;
  void *v50;
  unsigned int v51;
  uint64_t CurrentEncoderFreeBindingSlotIndex;
  id Error;
  id v54;
  void *v55;
  void *v56;
  void *v57;
  id ConstantSamplers;
  uint64_t v59;
  void *v60;
  void *v61;
  id Bindings;
  uint64_t v63;
  void *v64;
  void *v65;
  unsigned int v66;
  id v67;
  id v68;
  uint64_t v70;
  id v72;
  void *v73;
  id v74;
  id v75;
  id v76;
  id v77;
  id v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  _OWORD v83[53];
  uint64_t v84;
  unsigned __int16 v85;
  apr_pool_t *newpool;
  _BYTE v87[128];

  newpool = 0;
  apr_pool_create_ex(&newpool, 0, 0, a4);
  v6 = *(_QWORD **)a1;
  v74 = *(id *)(*(_QWORD *)a1 + 8);
  v73 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v74, "defaultDevice"));
  v7 = *(uint64_t **)(*v6 + 40);
  v8 = objc_msgSend(*(id *)(a1 + 96), "mutableCopy");
  v70 = v6[1422];
  Object = GTMTLSMContext_getObject(**(_QWORD **)(*v6 + 40), v70, **(_QWORD **)(a1 + 88));
  memset(v83, 0, 512);
  GTMTLSMComputePipelineState_computePipelineDescriptor(v7, (uint64_t)Object, v83, newpool);
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v74, "computePipelineDescriptorMap"));
  v11 = objc_msgSend(v10, "mutableCopy");

  v81 = 0u;
  v82 = 0u;
  v79 = 0u;
  v80 = 0u;
  v12 = v8;
  v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v79, v87, 16);
  if (v13)
  {
    v14 = *(_QWORD *)v80;
    do
    {
      for (i = 0; (id)i != v13; ++i)
      {
        if (*(_QWORD *)v80 != v14)
          objc_enumerationMutation(v12);
        v15 = *(_QWORD *)(*((_QWORD *)&v79 + 1) + 8 * i);
        v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "objectForKeyedSubscript:", v15));
        if ((objc_msgSend(v16, "conformsToProtocol:", &OBJC_PROTOCOL___MTLFunction) & 1) != 0
          || objc_msgSend(v16, "conformsToProtocol:", &OBJC_PROTOCOL___MTLDynamicLibrary))
        {
          objc_msgSend(v11, "setObject:forKeyedSubscript:", v16, v15);
        }

      }
      v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v79, v87, 16);
    }
    while (v13);
  }

  MTLComputePipelineDescriptorWithoutResourceIndex = MakeMTLComputePipelineDescriptorWithoutResourceIndex((uint64_t)v83, v11);
  v18 = (void *)objc_claimAutoreleasedReturnValue(MTLComputePipelineDescriptorWithoutResourceIndex);
  v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v74, "computePipelineStateForKey:", v70));
  objc_msgSend(v18, "setMaxTotalThreadsPerThreadgroup:", objc_msgSend(v19, "maxTotalThreadsPerThreadgroup"));

  if ((GT_SUPPORT_0 & 0x10000) != 0)
    objc_msgSend(v18, "setDriverCompilerOptions:", (unint64_t)&off_7394A0 & ((uint64_t)(*(_QWORD *)(a1 + 208) << 59) >> 63));
  v20 = *(_QWORD *)(a1 + 208);
  if ((v20 & 4) != 0)
  {
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "computeFunction"));
    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "preloadedLibraries"));
    PreloadedDylibsForGlobalRelocation = _GetPreloadedDylibsForGlobalRelocation(a1, v21, v22, a2);
    v24 = (void *)objc_claimAutoreleasedReturnValue(PreloadedDylibsForGlobalRelocation);

    if (!v24)
      goto LABEL_28;
    objc_msgSend(v18, "setPreloadedLibraries:", v24);
    v25 = (char *)objc_msgSend(v24, "count");
    if (v85 <= 1u)
      v26 = 1;
    else
      v26 = v85;
    objc_msgSend(v18, "setMaxCallStackDepth:", &v25[v26]);

    v20 = *(_QWORD *)(a1 + 208);
  }
  if ((v20 & 2) == 0)
    goto LABEL_25;
  v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "preloadedLibraries"));
  PreloadedDylibsForGlobalBinding = _GetPreloadedDylibsForGlobalBinding(a1, v27, a2);
  v29 = (void *)objc_claimAutoreleasedReturnValue(PreloadedDylibsForGlobalBinding);

  if (v29)
  {
    objc_msgSend(v18, "setPreloadedLibraries:", v29);
    v30 = (char *)objc_msgSend(v29, "count");
    if (v85 <= 1u)
      v31 = 1;
    else
      v31 = v85;
    objc_msgSend(v18, "setMaxCallStackDepth:", &v30[v31]);

    v20 = *(_QWORD *)(a1 + 208);
LABEL_25:
    if ((v20 & 6) == 0)
    {
      v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v74, "computePipelineDescriptorMap"));
      v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v84));
      v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "objectForKeyedSubscript:", v33));

      if (v34)
        i = (uint64_t)objc_msgSend(v73, "loadDynamicLibrariesForFunction:insertLibraries:error:", v34, &__NSArray0__struct, 0);
      else
        i = 0;
      if (objc_msgSend((id)i, "count"))
      {
        v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "preloadedLibraries"));
        v38 = objc_msgSend(v37, "mutableCopy");

        objc_msgSend(v38, "addObjectsFromArray:", i);
        v39 = objc_msgSend(v38, "copy");
        objc_msgSend(v18, "setPreloadedLibraries:", v39);

        v40 = (char *)objc_msgSend(v38, "count");
        if (v85 <= 1u)
          v41 = 1;
        else
          v41 = v85;
        objc_msgSend(v18, "setMaxCallStackDepth:", &v40[v41]);

      }
    }
    if (objc_msgSend(v73, "supportsFamily:", 1009))
      objc_msgSend(v18, "setMaxCallStackDepth:", (char *)objc_msgSend(v18, "maxCallStackDepth") + 1);
    v77 = 0;
    v78 = 0;
    v42 = objc_msgSend(v73, "newComputePipelineStateWithDescriptor:options:reflection:error:", v18, 0x200000, &v78, &v77);
    v72 = v78;
    v43 = v77;
    v35 = v43;
    if (v42 || objc_msgSend(v43, "code") != (char *)&dword_0 + 3)
    {
      v44 = 0;
    }
    else
    {
      i = objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "domain"));
      if (objc_msgSend((id)i, "containsString:", CFSTR("CompilerError")))
      {

        goto LABEL_50;
      }
      v44 = 1;
    }
    if (objc_msgSend(v35, "code") != &dword_4)
    {
      if ((v44 & 1) != 0)
LABEL_53:

LABEL_54:
      if (v42)
      {
        v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v70));
        objc_msgSend(v12, "setObject:forKeyedSubscript:", v42, v50);

        v51 = objc_msgSend(v72, "traceBufferIndex");
        if (v51 == -1)
          CurrentEncoderFreeBindingSlotIndex = 0x7FFFFFFFFFFFFFFFLL;
        else
          CurrentEncoderFreeBindingSlotIndex = v51;
        if ((*(_BYTE *)(a1 + 208) & 2) != 0)
          CurrentEncoderFreeBindingSlotIndex = _GetCurrentEncoderFreeBindingSlotIndex((_QWORD *)(a1 + 8));
        if (CurrentEncoderFreeBindingSlotIndex != 0x7FFFFFFFFFFFFFFFLL || (*(_BYTE *)(a1 + 208) & 4) != 0)
        {
          v54 = objc_msgSend(v12, "copy");
          v55 = *(void **)(a1 + 96);
          *(_QWORD *)(a1 + 96) = v54;

          v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "constantSamplerUniqueIdentifiers"));
          v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "constantSamplerDescriptors"));
          ConstantSamplers = _MakeConstantSamplers(v56, v57);
          v59 = objc_claimAutoreleasedReturnValue(ConstantSamplers);
          v60 = *(void **)(a1 + 136);
          *(_QWORD *)(a1 + 136) = v59;

          v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "bindings"));
          Bindings = _MakeBindings(v61);
          v63 = objc_claimAutoreleasedReturnValue(Bindings);
          v64 = *(void **)(a1 + 128);
          *(_QWORD *)(a1 + 128) = v63;

          *(_QWORD *)(a1 + 144) = CurrentEncoderFreeBindingSlotIndex;
          v36 = 1;
          goto LABEL_74;
        }
        if (a2)
        {
          Error = GTShaderDebuggerMakeError(1u, CFSTR("Internal error: Failed to set up GPU data buffer"), 0, 0, 0);
          v36 = 0;
          *a2 = (id)objc_claimAutoreleasedReturnValue(Error);
LABEL_74:

          goto LABEL_75;
        }
      }
      else if (a2)
      {
        v65 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "description"));
        if (objc_msgSend(v65, "localizedCaseInsensitiveContainsString:", CFSTR("Undefined symbol")))
        {
          *a2 = objc_retainAutorelease(v35);
        }
        else
        {
          if ((*(_QWORD *)(a1 + 208) & 0x10) != 0)
            v66 = 4;
          else
            v66 = 2;
          v67 = GTShaderDebuggerMakeError(v66, CFSTR("Failed to set up compute pipeline state for debugging"), 0, v35, 0);
          v68 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(v67));
          *a2 = v68;

        }
      }
      v36 = 0;
      goto LABEL_74;
    }
    v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "domain"));
    v46 = objc_msgSend(v45, "containsString:", CFSTR("AGXMetal"));

    if (v44)
    {

      if ((v46 & 1) == 0)
        goto LABEL_54;
    }
    else if (!v46)
    {
      goto LABEL_54;
    }
LABEL_50:
    if ((GT_SUPPORT_0 & 0x4000) != 0 && objc_msgSend(v18, "maxTotalThreadsPerThreadgroup") == &stru_3D8.size)
    {
      objc_msgSend(v18, "setMaxTotalThreadsPerThreadgroup:", 512);
      v75 = v35;
      v76 = v72;
      v47 = objc_msgSend(v73, "newComputePipelineStateWithDescriptor:options:reflection:error:", v18, 0x200000, &v76, &v75);
      v48 = v76;

      v49 = v75;
      i = (uint64_t)v42;
      v35 = v49;
      v72 = v48;
      v42 = v47;
      goto LABEL_53;
    }
    goto LABEL_54;
  }
LABEL_28:
  v35 = 0;
  v36 = 0;
LABEL_75:

  apr_pool_destroy(newpool);
  return v36;
}

void sub_2D57E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  apr_pool_destroy(*(apr_pool_t **)(v1 - 232));
  _Unwind_Resume(a1);
}

id _GetPreloadedDylibsForGlobalRelocation(uint64_t a1, void *a2, void *a3, _QWORD *a4)
{
  id v7;
  id v8;
  id v9;
  void *v10;
  id v11;
  id v12;
  id v13;
  void *v14;
  void *v15;
  id v16;
  id v17;
  unsigned int v18;
  id Error;
  void *v20;
  id v21;
  id v22;
  id v23;
  id v24;
  id v25;
  id v26;
  id v27;
  id v28;
  uint64_t v29;
  void *i;
  void *v31;
  void *v32;
  void *v33;
  unsigned int v34;
  void *v35;
  void *v36;
  uint64_t v37;
  void *v38;
  id v39;
  id v40;
  unsigned int v41;
  id v42;
  unsigned int v43;
  id v44;
  id v46;
  id v47;
  void *v48;
  id v49;
  id v50;
  void *v51;
  void *v52;
  id v53;
  _QWORD *v54;
  uint64_t v55;
  id v56;
  id v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  id v62;
  _BYTE v63[128];

  v7 = a2;
  v8 = a3;
  v9 = *(id *)(*(_QWORD *)a1 + 8);
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "defaultDevice"));
  v11 = *(id *)(a1 + 112);
  if (!objc_msgSend(v11, "count"))
  {
    if (a4)
    {
      if ((*(_QWORD *)(a1 + 208) & 0x10) != 0)
        v18 = 4;
      else
        v18 = 1;
      Error = GTShaderDebuggerMakeError(v18, CFSTR("Internal error: debug dylib not found"), 0, 0, 0);
      v20 = 0;
      *a4 = (id)objc_claimAutoreleasedReturnValue(Error);
    }
    else
    {
      v20 = 0;
    }
    goto LABEL_44;
  }
  v54 = a4;
  v55 = a1;
  v57 = 0;
  v12 = v10;
  v13 = objc_alloc_init((Class)MTLCompileOptions);
  objc_msgSend(v13, "setLibraryType:", 1);
  objc_msgSend(v13, "setLanguageVersion:", 131076);
  v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("@executable_path/%@.metallib"), CFSTR("libtracebuffer_gr")));
  objc_msgSend(v13, "setInstallName:", v14);

  objc_msgSend(v13, "setCompileSymbolVisibility:", 1);
  objc_msgSend(v13, "setAdditionalCompilerArguments:", CFSTR("-fexternally-initialized"));
  v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "extern device void * constant trace_buffer [[ clang::externally_initialized ]] __asm(\"trace.buffer\");\n"
                    "extern \"C\" {\n"
                    "  [[gnu::visibility(\"default\")]] device void *__tracepoint_get_trace_buffer() {\n"
                    "    return trace_buffer;\n"
                    "  }\n"
                    "}\n"));
  v16 = objc_msgSend(v12, "newLibraryWithSource:options:error:", v15, v13, &v57);

  if (v16)
    v17 = objc_msgSend(v12, "newDynamicLibrary:error:", v16, &v57);
  else
    v17 = 0;

  v21 = v57;
  if (!v17)
  {
    if (v54)
    {
      if ((*(_QWORD *)(v55 + 208) & 0x10) != 0)
        v41 = 4;
      else
        v41 = 1;
      v42 = GTShaderDebuggerMakeError(v41, CFSTR("Internal error: debug dylib setup failed"), 0, v21, 0);
      v20 = 0;
      *v54 = (id)objc_claimAutoreleasedReturnValue(v42);
    }
    else
    {
      v20 = 0;
    }
    v39 = v21;
    goto LABEL_43;
  }
  v22 = objc_alloc_init((Class)NSMutableArray);
  objc_msgSend(v22, "addObjectsFromArray:", v8);
  objc_msgSend(v22, "addObjectsFromArray:", v11);
  v53 = v17;
  objc_msgSend(v22, "addObject:", v17);
  v23 = objc_msgSend(objc_alloc((Class)MTLBufferRelocation), "initWithSymbolName:buffer:offset:", CFSTR("trace.buffer"), *(_QWORD *)(v55 + 184), 0);
  v51 = v21;
  v56 = v21;
  v24 = v23;
  v52 = v22;
  v25 = objc_msgSend(v12, "loadDynamicLibrariesForFunction:insertLibraries:error:", v7, v22, &v56);
  v20 = v25;
  if (!v25)
    goto LABEL_27;
  v47 = v11;
  v48 = v10;
  v49 = v9;
  v50 = v8;
  v60 = 0u;
  v61 = 0u;
  v58 = 0u;
  v59 = 0u;
  v46 = v25;
  v26 = v25;
  v27 = objc_msgSend(v26, "countByEnumeratingWithState:objects:count:", &v58, v63, 16);
  if (!v27)
    goto LABEL_26;
  v28 = v27;
  v29 = *(_QWORD *)v59;
  do
  {
    for (i = 0; i != v28; i = (char *)i + 1)
    {
      if (*(_QWORD *)v59 != v29)
        objc_enumerationMutation(v26);
      v31 = *(void **)(*((_QWORD *)&v58 + 1) + 8 * (_QWORD)i);
      v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v31, "installName"));
      if (objc_msgSend(v32, "containsString:", CFSTR("libtracepoint")))
      {

      }
      else
      {
        v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v31, "installName"));
        v34 = objc_msgSend(v33, "containsString:", CFSTR("libtracebuffer_gr"));

        if (!v34)
          continue;
      }
      v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v31, "relocations"));
      v36 = v35;
      if (v35)
      {
        v37 = objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "arrayByAddingObject:", v24));
      }
      else
      {
        v62 = v24;
        v37 = objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v62, 1));
      }
      v38 = (void *)v37;
      objc_msgSend(v31, "setRelocations:", v37);

    }
    v28 = objc_msgSend(v26, "countByEnumeratingWithState:objects:count:", &v58, v63, 16);
  }
  while (v28);
LABEL_26:

  v8 = v50;
  v10 = v48;
  v9 = v49;
  v20 = v46;
  v11 = v47;
LABEL_27:

  v39 = v56;
  if (v20)
  {
    v40 = v20;
  }
  else if (v54)
  {
    if ((*(_QWORD *)(v55 + 208) & 0x10) != 0)
      v43 = 4;
    else
      v43 = 1;
    v44 = GTShaderDebuggerMakeError(v43, CFSTR("Internal error: could not load debug dylib"), 0, v39, 0);
    *v54 = (id)objc_claimAutoreleasedReturnValue(v44);
  }

  v17 = v53;
LABEL_43:

LABEL_44:
  return v20;
}

id _GetPreloadedDylibsForGlobalBinding(uint64_t a1, void *a2, _QWORD *a3)
{
  id v5;
  id v6;
  void *v7;
  id v8;
  uint64_t CurrentEncoderFreeBindingSlotIndex;
  __CFString *v10;
  unsigned int v11;
  id Error;
  id v13;
  uint64_t v14;
  id v15;
  id v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  id v21;
  id v22;
  id v23;
  id v24;
  unsigned int v25;
  id v26;
  id v28;
  const __CFString *v29;
  void *v30;

  v5 = a2;
  v6 = *(id *)(*(_QWORD *)a1 + 8);
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "defaultDevice"));
  v8 = *(id *)(a1 + 112);
  if (!objc_msgSend(v8, "count"))
  {
    if (a3)
    {
      if ((*(_QWORD *)(a1 + 208) & 0x10) != 0)
        v11 = 4;
      else
        v11 = 1;
      v10 = CFSTR("Internal error: debug dylib not found");
      goto LABEL_10;
    }
LABEL_13:
    v13 = 0;
    goto LABEL_24;
  }
  CurrentEncoderFreeBindingSlotIndex = _GetCurrentEncoderFreeBindingSlotIndex((_QWORD *)(a1 + 8));
  if (CurrentEncoderFreeBindingSlotIndex == 0x7FFFFFFFFFFFFFFFLL)
  {
    if (a3)
    {
      v10 = CFSTR("Unable to debug pipeline - no available buffer binding slot");
      v11 = 4;
LABEL_10:
      Error = GTShaderDebuggerMakeError(v11, v10, 0, 0, 0);
      v13 = 0;
      *a3 = (id)objc_claimAutoreleasedReturnValue(Error);
      goto LABEL_24;
    }
    goto LABEL_13;
  }
  v14 = CurrentEncoderFreeBindingSlotIndex;
  v28 = 0;
  v15 = v7;
  v16 = objc_alloc_init((Class)MTLCompileOptions);
  objc_msgSend(v16, "setLibraryType:", 1);
  objc_msgSend(v16, "setLanguageVersion:", 196610);
  v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("@executable_path/%@.metallib"), CFSTR("libtracebuffer_gb")));
  objc_msgSend(v16, "setInstallName:", v17);

  objc_msgSend(v16, "setCompileSymbolVisibility:", 1);
  v29 = CFSTR("GLOBAL_BINDING");
  v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v14));
  v30 = v18;
  v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v30, &v29, 1));
  objc_msgSend(v16, "setPreprocessorMacros:", v19);

  v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "device void * constant trace_buffer [[ buffer(GLOBAL_BINDING) ]];\n"
                    "extern \"C\" {\n"
                    "  [[gnu::visibility(\"default\")]] device void *__tracepoint_get_trace_buffer() {\n"
                    "    return trace_buffer;\n"
                    "  }\n"
                    "}\n"));
  v21 = objc_msgSend(v15, "newLibraryWithSource:options:error:", v20, v16, &v28);

  if (v21)
    v22 = objc_msgSend(v15, "newDynamicLibrary:error:", v21, &v28);
  else
    v22 = 0;

  v23 = v28;
  if (v22)
  {
    v24 = objc_alloc_init((Class)NSMutableArray);
    objc_msgSend(v24, "addObjectsFromArray:", v5);
    objc_msgSend(v24, "addObjectsFromArray:", v8);
    objc_msgSend(v24, "addObject:", v22);
    v13 = objc_msgSend(v24, "copy");

  }
  else if (a3)
  {
    if ((*(_QWORD *)(a1 + 208) & 0x10) != 0)
      v25 = 4;
    else
      v25 = 1;
    v26 = GTShaderDebuggerMakeError(v25, CFSTR("Internal error: debug dylib setup failed"), 0, v23, 0);
    v13 = 0;
    *a3 = (id)objc_claimAutoreleasedReturnValue(v26);
  }
  else
  {
    v13 = 0;
  }

LABEL_24:
  return v13;
}

uint64_t _GetCurrentEncoderFreeBindingSlotIndex(_QWORD *a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  v2 = 30;
  while (1)
  {
    v3 = (void *)a1[3];
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v2));
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", v4));
    if (!v5)
      break;
LABEL_7:

LABEL_8:
    v2 = (v2 - 1);
    if ((_DWORD)v2 == -1)
      return 0x7FFFFFFFFFFFFFFFLL;
  }
  v6 = (void *)a1[2];
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v2));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", v5));
  if (v7)
  {
LABEL_6:

    goto LABEL_7;
  }
  v8 = (void *)a1[6];
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v2));
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", v9));
  if (v10)
  {

    v7 = 0;
    goto LABEL_6;
  }
  v11 = (void *)a1[7];
  v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v2));
  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", v12));

  if (v13)
    goto LABEL_8;
  if ((v2 & 0x80000000) == 0)
    return v2;
  return 0x7FFFFFFFFFFFFFFFLL;
}

id _MakeConstantSamplers(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  char *v6;
  id v7;
  void *v8;
  char *v9;
  void *v10;
  double v11;
  double v12;
  void *v13;
  void *v14;
  id v15;
  void *v16;
  void *v17;
  id v18;
  void *v19;
  void *v20;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  _OWORD v34[2];
  __int128 v35;
  __int128 v36;
  _QWORD v37[15];
  _QWORD v38[15];

  v3 = a1;
  v4 = a2;
  v5 = objc_msgSend(v3, "count");
  if (v5 == objc_msgSend(v4, "count"))
  {
    v6 = (char *)objc_msgSend(v4, "count");
    v7 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", v6);
    v8 = v7;
    if (v6)
    {
      v9 = 0;
      v22 = v7;
      do
      {
        v35 = 0u;
        v36 = 0u;
        memset(v34, 0, sizeof(v34));
        v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "objectAtIndexedSubscript:", v9, v22));
        MakeGTMTLSamplerDescriptor((uint64_t)v34, v10);

        v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectAtIndexedSubscript:", v9));
        v37[0] = CFSTR("borderColor");
        v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", BYTE2(v36)));
        v38[0] = v32;
        v37[1] = CFSTR("compareFunction");
        v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", BYTE3(v36)));
        v38[1] = v31;
        v37[2] = CFSTR("lodMinClamp");
        LODWORD(v11) = HIDWORD(v35);
        v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v11));
        v38[2] = v30;
        v37[3] = CFSTR("lodMaxClamp");
        LODWORD(v12) = DWORD2(v35);
        v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v12));
        v38[3] = v29;
        v37[4] = CFSTR("lodAverage");
        v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", BYTE6(v36)));
        v38[4] = v28;
        v37[5] = CFSTR("minFilter");
        v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", BYTE8(v36)));
        v38[5] = v27;
        v37[6] = CFSTR("magFilter");
        v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", BYTE7(v36)));
        v38[6] = v26;
        v37[7] = CFSTR("mipFilter");
        v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", BYTE9(v36)));
        v38[7] = v25;
        v37[8] = CFSTR("maxAnisotropy");
        v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *((_QWORD *)&v34[0] + 1)));
        v38[8] = v24;
        v37[9] = CFSTR("normalizedCoordinates");
        v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", BYTE10(v36)));
        v38[9] = v23;
        v37[10] = CFSTR("pixelFormat");
        v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", (unsigned __int16)v36));
        v38[10] = v13;
        v37[11] = CFSTR("reductionMode");
        v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", BYTE12(v36)));
        v38[11] = v14;
        v37[12] = CFSTR("rAddressMode");
        v15 = v4;
        v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", BYTE11(v36)));
        v38[12] = v16;
        v37[13] = CFSTR("sAddressMode");
        v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", BYTE13(v36)));
        v38[13] = v17;
        v37[14] = CFSTR("tAddressMode");
        v18 = v3;
        v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", HIBYTE(v36)));
        v38[14] = v19;
        v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v38, v37, 15));

        v3 = v18;
        v8 = v22;

        v4 = v15;
        objc_msgSend(v22, "setObject:forKeyedSubscript:", v20, v33);

        ++v9;
      }
      while (v6 != v9);
    }
  }
  else
  {
    v8 = &__NSDictionary0__struct;
  }

  return v8;
}

id _MakeBindings(void *a1)
{
  id v1;
  id v2;
  id v3;
  id v4;
  const __CFString *v5;
  uint64_t v6;
  void *i;
  void *v8;
  void *v9;
  id v10;
  const __CFString *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  id v16;
  id v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  _QWORD v23[4];
  _QWORD v24[4];
  _BYTE v25[128];

  v1 = a1;
  v18 = objc_alloc_init((Class)NSMutableArray);
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v2 = v1;
  v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v19, v25, 16);
  if (v3)
  {
    v4 = v3;
    v5 = CFSTR("__resource_tracking_impl_trace_buffer");
    v6 = *(_QWORD *)v20;
    do
    {
      for (i = 0; i != v4; i = (char *)i + 1)
      {
        if (*(_QWORD *)v20 != v6)
          objc_enumerationMutation(v2);
        v8 = *(void **)(*((_QWORD *)&v19 + 1) + 8 * (_QWORD)i);
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "name"));
        if ((objc_msgSend(v9, "isEqualToString:", CFSTR("trace.buffer")) & 1) == 0
          && (objc_msgSend(v9, "isEqualToString:", v5) & 1) == 0)
        {
          v23[0] = CFSTR("index");
          v10 = v2;
          v11 = v5;
          v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v8, "index")));
          v24[0] = v12;
          v23[1] = CFSTR("type");
          v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", objc_msgSend(v8, "type")));
          v24[1] = v13;
          v23[2] = CFSTR("used");
          v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(v8, "isUsed")));
          v23[3] = CFSTR("name");
          v24[2] = v14;
          v24[3] = v9;
          v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v24, v23, 4));
          objc_msgSend(v18, "addObject:", v15);

          v5 = v11;
          v2 = v10;
        }

      }
      v4 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v19, v25, 16);
    }
    while (v4);
  }

  v16 = objc_msgSend(v18, "copy");
  return v16;
}

uint64_t GTShaderDebuggerMakePSORender(id *a1, _QWORD *a2)
{
  _QWORD *v3;
  id v4;
  void *v5;
  void *v6;
  id v7;
  uint64_t *Object;
  void *v9;
  id v10;
  id v11;
  id v12;
  id v13;
  uint64_t v14;
  void *i;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  id MTLTileRenderPipelineDescriptor;
  void *v20;
  void *v21;
  void *v22;
  _QWORD *v23;
  void *v24;
  uint64_t v25;
  void *v26;
  void *v27;
  id v28;
  void *v29;
  char *v30;
  uint64_t v31;
  void *v32;
  id v33;
  _QWORD *v34;
  void *v35;
  char *v36;
  uint64_t v37;
  void *v38;
  void *v39;
  void *v40;
  id v41;
  uint64_t v42;
  id MTLMeshRenderPipelineDescriptorWithoutResourceIndex;
  uint64_t v44;
  char *v45;
  void *v46;
  id v47;
  void *v48;
  void *v49;
  id v50;
  void *v51;
  void *v52;
  id v53;
  void *v54;
  void *v55;
  id v56;
  void *v57;
  void *v58;
  id v59;
  void *v60;
  void *v61;
  id v62;
  void *v63;
  void *v64;
  uint64_t v65;
  uint64_t *v66;
  unsigned __int16 *v67;
  char *v68;
  id MTLRenderPipelineDescriptorWithoutResourceIndex;
  void *v70;
  id v71;
  void *v72;
  void *v73;
  id v74;
  void *v75;
  void *v76;
  id v77;
  void *v78;
  void *v79;
  id v80;
  void *v81;
  id v82;
  void *v83;
  void *v84;
  id v85;
  void *v86;
  void *v87;
  id v88;
  void *v89;
  void *v90;
  id v91;
  void *v92;
  void *v93;
  id v94;
  void *v95;
  void *v96;
  id v97;
  void *v98;
  void *v99;
  uint64_t v100;
  int v101;
  void *v102;
  uint64_t v103;
  void *v104;
  id v105;
  id v106;
  char *v107;
  uint64_t v108;
  id v109;
  id v110;
  id v111;
  void *v112;
  void *v113;
  id v114;
  void *v115;
  void *v116;
  id v117;
  void *v118;
  void *v119;
  id v120;
  uint64_t v121;
  void *v122;
  id v123;
  void *v124;
  void *v125;
  id v126;
  void *v127;
  void *v128;
  id v129;
  void *v130;
  void *v131;
  id v132;
  void *v133;
  void *v134;
  id v135;
  void *v136;
  void *v137;
  id v138;
  void *v139;
  void *v140;
  void *v141;
  id v142;
  uint64_t v143;
  void *v144;
  id PreloadedDylibsForGlobalRelocation;
  uint64_t v146;
  void *v147;
  char *v148;
  uint64_t v149;
  uint64_t v150;
  id v151;
  uint64_t v152;
  void *v153;
  _QWORD *v154;
  char *v155;
  uint64_t v156;
  void *v157;
  id PreloadedDylibsForGlobalBinding;
  uint64_t v159;
  void *v160;
  char *v161;
  uint64_t v162;
  char *v163;
  uint64_t v164;
  uint64_t v165;
  void *v166;
  void *v167;
  id v168;
  void *v169;
  void *v170;
  id v171;
  void *v172;
  id v173;
  id v174;
  void *v175;
  id v176;
  void *v177;
  id v178;
  void *v179;
  void *v180;
  id v181;
  id v182;
  char *v183;
  uint64_t v184;
  void *v185;
  id v186;
  id v187;
  char *v188;
  uint64_t v189;
  void *v190;
  unsigned int v191;
  uint64_t CurrentEncoderFreeBindingSlotIndex;
  id v193;
  uint64_t v194;
  uint64_t v195;
  void *v196;
  unsigned int v197;
  id Error;
  id v199;
  void *v200;
  id v201;
  void *v202;
  void *v203;
  _QWORD *v204;
  void *v205;
  id ConstantSamplers;
  uint64_t v207;
  void *v208;
  id Bindings;
  uint64_t v210;
  void *v211;
  void *v213;
  void *v214;
  void *v215;
  char *v216;
  void *v217;
  uint64_t v218;
  uint64_t v220;
  void *v221;
  void *v222;
  id v223;
  void *v224;
  id v225;
  __int128 v226;
  uint64_t v227;
  id v228;
  id v229;
  __int128 v230;
  __int128 v231;
  __int128 v232;
  __int128 v233;
  _BYTE v234[128];

  v3 = *a1;
  v4 = *((id *)*a1 + 1);
  v221 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "defaultDevice"));
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[24], "objectForKeyedSubscript:", CFSTR("ROI")));
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("Type")));
  v216 = (char *)objc_msgSend(v6, "integerValue");

  v7 = objc_msgSend(a1[12], "mutableCopy");
  v220 = (uint64_t)a1;
  v218 = v3[2489];
  Object = GTMTLSMContext_getObject(**(_QWORD **)(*(_QWORD *)*a1 + 40), v218, *(_QWORD *)a1[11]);
  v217 = v4;
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "renderPipelineDescriptorMap"));
  v10 = objc_msgSend(v9, "mutableCopy");

  v232 = 0u;
  v233 = 0u;
  v230 = 0u;
  v231 = 0u;
  v11 = v7;
  v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v230, v234, 16);
  if (v12)
  {
    v13 = v12;
    v14 = *(_QWORD *)v231;
    do
    {
      for (i = 0; i != v13; i = (char *)i + 1)
      {
        if (*(_QWORD *)v231 != v14)
          objc_enumerationMutation(v11);
        v16 = *(_QWORD *)(*((_QWORD *)&v230 + 1) + 8 * (_QWORD)i);
        v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", v16));
        if ((objc_msgSend(v17, "conformsToProtocol:", &OBJC_PROTOCOL___MTLFunction) & 1) != 0
          || objc_msgSend(v17, "conformsToProtocol:", &OBJC_PROTOCOL___MTLDynamicLibrary))
        {
          objc_msgSend(v10, "setObject:forKeyedSubscript:", v17, v16);
        }

      }
      v13 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v230, v234, 16);
    }
    while (v13);
  }

  v18 = Object[8];
  if (!v18)
  {
    v42 = Object[9];
    v21 = v217;
    if (!v42)
    {
      v67 = (unsigned __int16 *)Object[6];
      v68 = v216;
      if (!v67)
      {

        v110 = 0;
        v24 = v221;
        goto LABEL_182;
      }
      MTLRenderPipelineDescriptorWithoutResourceIndex = MakeMTLRenderPipelineDescriptorWithoutResourceIndex(Object[6], v10);
      v20 = (void *)objc_claimAutoreleasedReturnValue(MTLRenderPipelineDescriptorWithoutResourceIndex);
      v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v217, "renderPipelineDescriptorMap"));
      v24 = v221;
      v215 = v70;
      if (v216 == (_BYTE *)&dword_0 + 2)
      {
        v71 = _ObjectArrayWithMap(*((uint64_t **)v67 + 135), *((_QWORD *)v67 + 136), v70);
        v72 = (void *)objc_claimAutoreleasedReturnValue(v71);
        v73 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "vertexLinkedFunctions"));
        objc_msgSend(v73, "setFunctions:", v72);

        v74 = _ObjectArrayWithMap(*((uint64_t **)v67 + 139), *((_QWORD *)v67 + 140), v70);
        v75 = (void *)objc_claimAutoreleasedReturnValue(v74);
        v76 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "vertexLinkedFunctions"));
        objc_msgSend(v76, "setPrivateFunctions:", v75);

        v77 = _ObjectArrayWithMap(*((uint64_t **)v67 + 133), *((_QWORD *)v67 + 134), v70);
        v78 = (void *)objc_claimAutoreleasedReturnValue(v77);
        v79 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "vertexLinkedFunctions"));
        objc_msgSend(v79, "setBinaryFunctions:", v78);

        v80 = _ObjectArrayWithMap(*((uint64_t **)v67 + 163), *((_QWORD *)v67 + 164), v70);
        v81 = (void *)objc_claimAutoreleasedReturnValue(v80);
        objc_msgSend(v20, "setVertexPreloadedLibraries:", v81);
      }
      else
      {
        v111 = _ObjectArrayWithMap(*((uint64_t **)v67 + 111), *((_QWORD *)v67 + 112), v70);
        v112 = (void *)objc_claimAutoreleasedReturnValue(v111);
        v113 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "fragmentLinkedFunctions"));
        objc_msgSend(v113, "setFunctions:", v112);

        v114 = _ObjectArrayWithMap(*((uint64_t **)v67 + 115), *((_QWORD *)v67 + 116), v70);
        v115 = (void *)objc_claimAutoreleasedReturnValue(v114);
        v116 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "fragmentLinkedFunctions"));
        objc_msgSend(v116, "setPrivateFunctions:", v115);

        v117 = _ObjectArrayWithMap(*((uint64_t **)v67 + 109), *((_QWORD *)v67 + 110), v70);
        v118 = (void *)objc_claimAutoreleasedReturnValue(v117);
        v119 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "fragmentLinkedFunctions"));
        objc_msgSend(v119, "setBinaryFunctions:", v118);

        v120 = _ObjectArrayWithMap(*((uint64_t **)v67 + 148), *((_QWORD *)v67 + 149), v70);
        v81 = (void *)objc_claimAutoreleasedReturnValue(v120);
        objc_msgSend(v20, "setFragmentPreloadedLibraries:", v81);
      }

      v23 = (_QWORD *)v220;
      if ((GT_SUPPORT_0 & 0x8000) != 0)
        objc_msgSend(v20, "setDriverCompilerOptions:", (unint64_t)&off_7394F0 & ((uint64_t)(*(_QWORD *)(v220 + 208) << 59) >> 63));
      v121 = *(_QWORD *)(v220 + 208);
      if ((v121 & 4) != 0)
      {
        if (v216 == (_BYTE *)&dword_0 + 2)
        {
          v102 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "fragmentFunction"));
          v122 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "fragmentPreloadedLibraries"));
        }
        else
        {
          v102 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "vertexFunction"));
          v122 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "vertexPreloadedLibraries"));
        }
        v141 = v122;
        PreloadedDylibsForGlobalRelocation = _GetPreloadedDylibsForGlobalRelocation(v220, v102, v122, a2);
        v146 = objc_claimAutoreleasedReturnValue(PreloadedDylibsForGlobalRelocation);
        if (!v146)
          goto LABEL_80;
        v147 = (void *)v146;
        if (v216 == (_BYTE *)&dword_0 + 2)
        {
          objc_msgSend(v20, "setFragmentPreloadedLibraries:", v146);
          v148 = (char *)objc_msgSend(v147, "count");
          if (v67[672] <= 1u)
            v149 = 1;
          else
            v149 = v67[672];
          objc_msgSend(v20, "setMaxFragmentCallStackDepth:", &v148[v149]);
        }
        else
        {
          objc_msgSend(v20, "setVertexPreloadedLibraries:", v146);
          v155 = (char *)objc_msgSend(v147, "count");
          if (v67[675] <= 1u)
            v156 = 1;
          else
            v156 = v67[675];
          objc_msgSend(v20, "setMaxVertexCallStackDepth:", &v155[v156]);
        }

        v23 = (_QWORD *)v220;
        v121 = *(_QWORD *)(v220 + 208);
        v68 = v216;
      }
      if ((v121 & 2) != 0)
      {
        if (v68 == (_BYTE *)&dword_0 + 2)
          v157 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "fragmentPreloadedLibraries"));
        else
          v157 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "vertexPreloadedLibraries"));
        v102 = v157;
        PreloadedDylibsForGlobalBinding = _GetPreloadedDylibsForGlobalBinding((uint64_t)v23, v157, a2);
        v159 = objc_claimAutoreleasedReturnValue(PreloadedDylibsForGlobalBinding);
        if (!v159)
          goto LABEL_119;
        v160 = (void *)v159;
        if (v68 == (_BYTE *)&dword_0 + 2)
        {
          objc_msgSend(v20, "setFragmentPreloadedLibraries:", v159);
          v161 = (char *)objc_msgSend(v160, "count");
          if (v67[672] <= 1u)
            v162 = 1;
          else
            v162 = v67[672];
          objc_msgSend(v20, "setMaxFragmentCallStackDepth:", &v161[v162]);
        }
        else
        {
          objc_msgSend(v20, "setVertexPreloadedLibraries:", v159);
          v163 = (char *)objc_msgSend(v160, "count");
          if (v67[675] <= 1u)
            v164 = 1;
          else
            v164 = v67[675];
          objc_msgSend(v20, "setMaxVertexCallStackDepth:", &v163[v164]);
        }

        v23 = (_QWORD *)v220;
        v121 = *(_QWORD *)(v220 + 208);
      }
      if ((v121 & 6) == 0)
      {
        v165 = 648;
        if (v68 == (_BYTE *)&dword_0 + 2)
          v165 = 588;
        v166 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)&v67[v165]));
        v167 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v215, "objectForKeyedSubscript:", v166));

        if (v167)
          v168 = objc_msgSend(v221, "loadDynamicLibrariesForFunction:insertLibraries:error:", v167, &__NSArray0__struct, 0);
        else
          v168 = 0;
        if (objc_msgSend(v168, "count"))
        {
          v214 = v167;
          if (v216 == (_BYTE *)&dword_0 + 2)
          {
            v180 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "fragmentPreloadedLibraries"));
            v181 = objc_msgSend(v180, "mutableCopy");

            v213 = v181;
            objc_msgSend(v181, "addObjectsFromArray:", v168);
            v182 = objc_msgSend(v168, "copy");
            objc_msgSend(v20, "setFragmentPreloadedLibraries:", v182);

            v183 = (char *)objc_msgSend(v168, "count");
            if (v67[672] <= 1u)
              v184 = 1;
            else
              v184 = v67[672];
            objc_msgSend(v20, "setMaxFragmentCallStackDepth:", &v183[v184]);
          }
          else
          {
            v185 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "vertexPreloadedLibraries"));
            v186 = objc_msgSend(v185, "mutableCopy");

            v213 = v186;
            objc_msgSend(v186, "addObjectsFromArray:", v168);
            v187 = objc_msgSend(v168, "copy");
            objc_msgSend(v20, "setVertexPreloadedLibraries:", v187);

            v188 = (char *)objc_msgSend(v168, "count");
            if (v67[675] <= 1u)
              v189 = 1;
            else
              v189 = v67[675];
            objc_msgSend(v20, "setMaxVertexCallStackDepth:", &v188[v189]);
          }

          v167 = v214;
        }

        v68 = v216;
      }
      if (objc_msgSend(v221, "supportsFamily:", 1009))
      {
        if (v68 == (_BYTE *)&dword_0 + 2)
          objc_msgSend(v20, "setMaxFragmentCallStackDepth:", (char *)objc_msgSend(v20, "maxFragmentCallStackDepth") + 1);
        else
          objc_msgSend(v20, "setMaxVertexCallStackDepth:", (char *)objc_msgSend(v20, "maxVertexCallStackDepth") + 1);
      }
      v222 = 0;
      v223 = 0;
      v109 = objc_msgSend(v221, "newRenderPipelineStateWithDescriptor:options:reflection:error:", v20, 0x200000, &v223, &v222);
      v110 = v223;
      v179 = v222;
      goto LABEL_169;
    }
    MTLMeshRenderPipelineDescriptorWithoutResourceIndex = MakeMTLMeshRenderPipelineDescriptorWithoutResourceIndex(Object[9], v10);
    v20 = (void *)objc_claimAutoreleasedReturnValue(MTLMeshRenderPipelineDescriptorWithoutResourceIndex);
    objc_msgSend(v20, "setMaxTotalThreadsPerObjectThreadgroup:", *(unsigned __int16 *)(v42 + 406));
    objc_msgSend(v20, "setMaxTotalThreadsPerMeshThreadgroup:", *(unsigned __int16 *)(v42 + 404));
    v44 = *(_QWORD *)(v42 + 336);
    v226 = *(_OWORD *)(v42 + 320);
    v227 = v44;
    objc_msgSend(v20, "setMaxThreadgroupsPerMeshGrid:", &v226);
    v23 = (_QWORD *)v220;
    v45 = v216;
    if ((GT_SUPPORT_0 & 0x8000) != 0)
      objc_msgSend(v20, "setDriverCompilerOptions:", (unint64_t)&off_7394C8 & ((uint64_t)(*(_QWORD *)(v220 + 208) << 59) >> 63));
    v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v217, "renderPipelineDescriptorMap"));
    v215 = v46;
    if (v216 == (_BYTE *)&dword_0 + 2)
    {
      v47 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 272), *(_QWORD *)(v42 + 280), v46);
      v48 = (void *)objc_claimAutoreleasedReturnValue(v47);
      v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectLinkedFunctions"));
      objc_msgSend(v49, "setFunctions:", v48);

      v50 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 304), *(_QWORD *)(v42 + 312), v46);
      v51 = (void *)objc_claimAutoreleasedReturnValue(v50);
      v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectLinkedFunctions"));
      objc_msgSend(v52, "setPrivateFunctions:", v51);

      v53 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 256), *(_QWORD *)(v42 + 264), v46);
      v54 = (void *)objc_claimAutoreleasedReturnValue(v53);
      v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectLinkedFunctions"));
      objc_msgSend(v55, "setBinaryFunctions:", v54);

      v56 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 208), *(_QWORD *)(v42 + 216), v46);
      v57 = (void *)objc_claimAutoreleasedReturnValue(v56);
      v58 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "meshLinkedFunctions"));
      objc_msgSend(v58, "setFunctions:", v57);

      v59 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 240), *(_QWORD *)(v42 + 248), v46);
      v60 = (void *)objc_claimAutoreleasedReturnValue(v59);
      v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "meshLinkedFunctions"));
      objc_msgSend(v61, "setPrivateFunctions:", v60);

      v62 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 192), *(_QWORD *)(v42 + 200), v46);
      v63 = (void *)objc_claimAutoreleasedReturnValue(v62);
      v64 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "meshLinkedFunctions"));
      objc_msgSend(v64, "setBinaryFunctions:", v63);

      v23 = (_QWORD *)v220;
      v66 = (uint64_t *)(v220 + 208);
      v65 = *(_QWORD *)(v220 + 208);
      if ((v65 & 4) == 0)
      {
        if ((v65 & 2) == 0)
        {
          if ((v65 & 6) != 0)
          {
            if ((objc_msgSend(v221, "supportsFamily:", 1009) & 1) == 0)
              goto LABEL_150;
            goto LABEL_146;
          }
          v101 = 0;
          goto LABEL_132;
        }
        v101 = 0;
        goto LABEL_86;
      }
      v102 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "fragmentFunction"));
      v103 = objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "fragmentPreloadedLibraries"));
    }
    else
    {
      if (v216 == (_BYTE *)&dword_4 + 2)
      {
        v123 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 272), *(_QWORD *)(v42 + 280), v46);
        v124 = (void *)objc_claimAutoreleasedReturnValue(v123);
        v125 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectLinkedFunctions"));
        objc_msgSend(v125, "setFunctions:", v124);

        v126 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 304), *(_QWORD *)(v42 + 312), v46);
        v127 = (void *)objc_claimAutoreleasedReturnValue(v126);
        v128 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectLinkedFunctions"));
        objc_msgSend(v128, "setPrivateFunctions:", v127);

        v129 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 256), *(_QWORD *)(v42 + 264), v46);
        v130 = (void *)objc_claimAutoreleasedReturnValue(v129);
        v131 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectLinkedFunctions"));
        objc_msgSend(v131, "setBinaryFunctions:", v130);

        v132 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 144), *(_QWORD *)(v42 + 152), v46);
        v133 = (void *)objc_claimAutoreleasedReturnValue(v132);
        v134 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "fragmentLinkedFunctions"));
        objc_msgSend(v134, "setFunctions:", v133);

        v135 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 176), *(_QWORD *)(v42 + 184), v46);
        v136 = (void *)objc_claimAutoreleasedReturnValue(v135);
        v137 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "fragmentLinkedFunctions"));
        objc_msgSend(v137, "setPrivateFunctions:", v136);

        v138 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 128), *(_QWORD *)(v42 + 136), v46);
        v139 = (void *)objc_claimAutoreleasedReturnValue(v138);
        v140 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "fragmentLinkedFunctions"));
        objc_msgSend(v140, "setBinaryFunctions:", v139);

        v23 = (_QWORD *)v220;
        v66 = (uint64_t *)(v220 + 208);
        v100 = *(_QWORD *)(v220 + 208);
        if ((v100 & 4) == 0)
        {
          v101 = 1;
          goto LABEL_84;
        }
        v102 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "meshFunction"));
        v141 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "meshPreloadedLibraries"));
        v101 = 1;
        goto LABEL_66;
      }
      if (v216 == (_BYTE *)&dword_4 + 1)
      {
        v82 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 208), *(_QWORD *)(v42 + 216), v46);
        v83 = (void *)objc_claimAutoreleasedReturnValue(v82);
        v84 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "meshLinkedFunctions"));
        objc_msgSend(v84, "setFunctions:", v83);

        v85 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 240), *(_QWORD *)(v42 + 248), v46);
        v86 = (void *)objc_claimAutoreleasedReturnValue(v85);
        v87 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "meshLinkedFunctions"));
        objc_msgSend(v87, "setPrivateFunctions:", v86);

        v88 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 192), *(_QWORD *)(v42 + 200), v46);
        v89 = (void *)objc_claimAutoreleasedReturnValue(v88);
        v90 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "meshLinkedFunctions"));
        objc_msgSend(v90, "setBinaryFunctions:", v89);

        v91 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 144), *(_QWORD *)(v42 + 152), v46);
        v92 = (void *)objc_claimAutoreleasedReturnValue(v91);
        v93 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "fragmentLinkedFunctions"));
        objc_msgSend(v93, "setFunctions:", v92);

        v94 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 176), *(_QWORD *)(v42 + 184), v46);
        v95 = (void *)objc_claimAutoreleasedReturnValue(v94);
        v96 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "fragmentLinkedFunctions"));
        objc_msgSend(v96, "setPrivateFunctions:", v95);

        v97 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 128), *(_QWORD *)(v42 + 136), v46);
        v98 = (void *)objc_claimAutoreleasedReturnValue(v97);
        v99 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "fragmentLinkedFunctions"));
        objc_msgSend(v99, "setBinaryFunctions:", v98);

        v23 = (_QWORD *)v220;
      }
      v66 = v23 + 26;
      v100 = v23[26];
      if ((v100 & 4) == 0)
      {
        v101 = 0;
        goto LABEL_84;
      }
      v102 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectFunction"));
      v103 = objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectPreloadedLibraries"));
    }
    v141 = (void *)v103;
    v101 = 0;
LABEL_66:
    v142 = _GetPreloadedDylibsForGlobalRelocation((uint64_t)v23, v102, v141, a2);
    v143 = objc_claimAutoreleasedReturnValue(v142);
    if (v143)
    {
      v144 = (void *)v143;
      if (v216 == (_BYTE *)&dword_0 + 2)
      {
        objc_msgSend(v20, "setFragmentPreloadedLibraries:", v143);
        objc_msgSend(v20, "setMaxFragmentCallStackDepth:", (char *)objc_msgSend(v144, "count") + 1);
      }
      else if (v101)
      {
        objc_msgSend(v20, "setMeshPreloadedLibraries:", v143);
        objc_msgSend(v20, "setMaxMeshCallStackDepth:", (char *)objc_msgSend(v144, "count") + 1);
      }
      else
      {
        objc_msgSend(v20, "setObjectPreloadedLibraries:", v143);
        objc_msgSend(v20, "setMaxObjectCallStackDepth:", (char *)objc_msgSend(v144, "count") + 1);
      }

      v100 = *v66;
      v23 = (_QWORD *)v220;
      v45 = v216;
LABEL_84:
      if ((v100 & 2) == 0)
        goto LABEL_99;
      if (v45 != (_BYTE *)&dword_0 + 2)
      {
        if (v101)
        {
          v102 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "meshPreloadedLibraries"));
          v101 = 1;
LABEL_91:
          v151 = _GetPreloadedDylibsForGlobalBinding((uint64_t)v23, v102, a2);
          v152 = objc_claimAutoreleasedReturnValue(v151);
          if (v152)
          {
            v153 = (void *)v152;
            if (v45 == (_BYTE *)&dword_0 + 2)
            {
              objc_msgSend(v20, "setFragmentPreloadedLibraries:", v152);
              objc_msgSend(v20, "setMaxFragmentCallStackDepth:", (char *)objc_msgSend(v153, "count") + 1);
            }
            else if (v101)
            {
              objc_msgSend(v20, "setMeshPreloadedLibraries:", v152);
              objc_msgSend(v20, "setMaxMeshCallStackDepth:", (char *)objc_msgSend(v153, "count") + 1);
            }
            else
            {
              objc_msgSend(v20, "setObjectPreloadedLibraries:", v152);
              objc_msgSend(v20, "setMaxObjectCallStackDepth:", (char *)objc_msgSend(v153, "count") + 1);
            }

            v100 = *v66;
            v23 = (_QWORD *)v220;
LABEL_99:
            if ((v100 & 6) != 0)
            {
LABEL_144:
              if ((objc_msgSend(v221, "supportsFamily:", 1009) & 1) == 0)
              {
LABEL_150:
                v224 = 0;
                v225 = 0;
                v24 = v221;
                v109 = objc_msgSend(v221, "newRenderPipelineStateWithMeshDescriptor:options:reflection:error:", v20, 0x200000, &v225, &v224);
                v110 = v225;
                v179 = v224;
LABEL_169:
                v67 = v179;

                goto LABEL_170;
              }
              if (v45 != (_BYTE *)&dword_0 + 2)
              {
                if (v101)
                  objc_msgSend(v20, "setMaxMeshCallStackDepth:", (char *)objc_msgSend(v20, "maxMeshCallStackDepth") + 1);
                else
                  objc_msgSend(v20, "setMaxObjectCallStackDepth:", (char *)objc_msgSend(v20, "maxObjectCallStackDepth") + 1);
                goto LABEL_150;
              }
LABEL_146:
              objc_msgSend(v20, "setMaxFragmentCallStackDepth:", (char *)objc_msgSend(v20, "maxFragmentCallStackDepth") + 1);
              goto LABEL_150;
            }
            if (v45 != (_BYTE *)&dword_0 + 2)
            {
              v154 = (_QWORD *)(v42 + 368);
              if (v101)
              {
                v154 = (_QWORD *)(v42 + 360);
                v101 = 1;
              }
              else
              {
                v101 = 0;
              }
LABEL_133:
              v169 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *v154));
              v170 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v215, "objectForKeyedSubscript:", v169));

              if (v170)
                v171 = objc_msgSend(v221, "loadDynamicLibrariesForFunction:insertLibraries:error:", v170, &__NSArray0__struct, 0);
              else
                v171 = 0;
              if (objc_msgSend(v171, "count"))
              {
                if (v45 == (_BYTE *)&dword_0 + 2)
                {
                  v172 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "fragmentPreloadedLibraries"));
                  v173 = objc_msgSend(v172, "mutableCopy");

                  objc_msgSend(v173, "addObjectsFromArray:", v171);
                  v174 = objc_msgSend(v173, "copy");
                  objc_msgSend(v20, "setFragmentPreloadedLibraries:", v174);

                  objc_msgSend(v20, "setMaxFragmentCallStackDepth:", (char *)objc_msgSend(v173, "count") + 1);
                }
                else if (v101)
                {
                  v175 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "meshPreloadedLibraries"));
                  v173 = objc_msgSend(v175, "mutableCopy");

                  objc_msgSend(v173, "addObjectsFromArray:", v171);
                  v176 = objc_msgSend(v173, "copy");
                  objc_msgSend(v20, "setMeshPreloadedLibraries:", v176);

                  objc_msgSend(v20, "setMaxMeshCallStackDepth:", (char *)objc_msgSend(v173, "count") + 1);
                }
                else
                {
                  v177 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectPreloadedLibraries"));
                  v173 = objc_msgSend(v177, "mutableCopy");

                  objc_msgSend(v173, "addObjectsFromArray:", v171);
                  v178 = objc_msgSend(v173, "copy");
                  objc_msgSend(v20, "setObjectPreloadedLibraries:", v178);

                  objc_msgSend(v20, "setMaxObjectCallStackDepth:", (char *)objc_msgSend(v173, "count") + 1);
                }

                v45 = v216;
              }

              goto LABEL_144;
            }
LABEL_132:
            v154 = (_QWORD *)(v42 + 344);
            goto LABEL_133;
          }
          v24 = v221;
LABEL_119:

          goto LABEL_120;
        }
        v150 = objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectPreloadedLibraries"));
LABEL_90:
        v102 = (void *)v150;
        goto LABEL_91;
      }
LABEL_86:
      v150 = objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "fragmentPreloadedLibraries"));
      goto LABEL_90;
    }
    v24 = v221;
LABEL_80:

    goto LABEL_119;
  }
  MTLTileRenderPipelineDescriptor = MakeMTLTileRenderPipelineDescriptor(Object[8], v10);
  v20 = (void *)objc_claimAutoreleasedReturnValue(MTLTileRenderPipelineDescriptor);
  v21 = v217;
  v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v217, "renderPipelineStateForKey:", v218));
  objc_msgSend(v20, "setMaxTotalThreadsPerThreadgroup:", objc_msgSend(v22, "maxTotalThreadsPerThreadgroup"));

  v23 = (_QWORD *)v220;
  v24 = v221;
  v25 = *(_QWORD *)(v220 + 208);
  if ((v25 & 4) != 0)
  {
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "tileFunction"));
    v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "preloadedLibraries"));
    v28 = _GetPreloadedDylibsForGlobalRelocation(v220, v26, v27, a2);
    v29 = (void *)objc_claimAutoreleasedReturnValue(v28);

    if (!v29)
      goto LABEL_120;
    objc_msgSend(v20, "setPreloadedLibraries:", v29);
    v30 = (char *)objc_msgSend(v29, "count");
    if (*(unsigned __int16 *)(v18 + 130) <= 1u)
      v31 = 1;
    else
      v31 = *(unsigned __int16 *)(v18 + 130);
    objc_msgSend(v20, "setMaxCallStackDepth:", &v30[v31]);

    v25 = *(_QWORD *)(v220 + 208);
    v23 = (_QWORD *)v220;
  }
  if ((v25 & 2) != 0)
  {
    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "preloadedLibraries"));
    v33 = _GetPreloadedDylibsForGlobalBinding((uint64_t)v23, v32, a2);
    v34 = v23;
    v35 = (void *)objc_claimAutoreleasedReturnValue(v33);

    if (v35)
    {
      objc_msgSend(v20, "setPreloadedLibraries:", v35);
      v36 = (char *)objc_msgSend(v35, "count");
      if (*(unsigned __int16 *)(v18 + 130) <= 1u)
        v37 = 1;
      else
        v37 = *(unsigned __int16 *)(v18 + 130);
      objc_msgSend(v20, "setMaxCallStackDepth:", &v36[v37]);

      v25 = v34[26];
      v23 = v34;
      goto LABEL_24;
    }
LABEL_120:

    v67 = 0;
    v110 = 0;
LABEL_190:
    v109 = 0;
    goto LABEL_191;
  }
LABEL_24:
  if ((v25 & 6) == 0)
  {
    v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v217, "renderPipelineDescriptorMap"));
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v18 + 120)));
    v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v38, "objectForKeyedSubscript:", v39));

    if (v40)
      v41 = objc_msgSend(v221, "loadDynamicLibrariesForFunction:insertLibraries:error:", v40, &__NSArray0__struct, 0);
    else
      v41 = 0;
    if (objc_msgSend(v41, "count"))
    {
      v104 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "preloadedLibraries"));
      v105 = objc_msgSend(v104, "mutableCopy");

      objc_msgSend(v105, "addObjectsFromArray:", v41);
      v106 = objc_msgSend(v105, "copy");
      objc_msgSend(v20, "setPreloadedLibraries:", v106);

      v24 = v221;
      v107 = (char *)objc_msgSend(v105, "count");
      if (*(unsigned __int16 *)(v18 + 130) <= 1u)
        v108 = 1;
      else
        v108 = *(unsigned __int16 *)(v18 + 130);
      objc_msgSend(v20, "setMaxCallStackDepth:", &v107[v108]);

    }
    v23 = (_QWORD *)v220;
  }
  if (objc_msgSend(v24, "supportsFamily:", 1009))
    objc_msgSend(v20, "setMaxCallStackDepth:", (char *)objc_msgSend(v20, "maxCallStackDepth") + 1);
  v228 = 0;
  v229 = 0;
  v109 = objc_msgSend(v24, "newRenderPipelineStateWithTileDescriptor:options:reflection:error:", v20, 0x200000, &v229, &v228);
  v110 = v229;
  v67 = (unsigned __int16 *)v228;
LABEL_170:

  if (!v109)
  {
LABEL_182:
    if (a2)
    {
      v196 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v67, "description"));
      if (objc_msgSend(v196, "localizedCaseInsensitiveContainsString:", CFSTR("Undefined symbol")))
      {
        *a2 = objc_retainAutorelease(v67);
      }
      else
      {
        if ((*(_QWORD *)(v220 + 208) & 0x10) != 0)
          v197 = 4;
        else
          v197 = 2;
        Error = GTShaderDebuggerMakeError(v197, CFSTR("Failed to set up render pipeline state for debugging"), 0, v67, 0);
        v199 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(Error));
        *a2 = v199;

      }
    }
    goto LABEL_190;
  }
  v190 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v218));
  objc_msgSend(v11, "setObject:forKeyedSubscript:", v109, v190);

  v191 = objc_msgSend(v110, "traceBufferIndex");
  if (v191 == -1)
    CurrentEncoderFreeBindingSlotIndex = 0x7FFFFFFFFFFFFFFFLL;
  else
    CurrentEncoderFreeBindingSlotIndex = v191;
  if ((v23[26] & 2) != 0)
    CurrentEncoderFreeBindingSlotIndex = _GetCurrentEncoderFreeBindingSlotIndex(v23 + 1);
  if (CurrentEncoderFreeBindingSlotIndex == 0x7FFFFFFFFFFFFFFFLL && (v23[26] & 4) == 0)
  {
    if (a2)
    {
      v193 = GTShaderDebuggerMakeError(1u, CFSTR("Internal error: Failed to set up GPU data buffer"), 0, 0, 0);
      v194 = 0;
      *a2 = (id)objc_claimAutoreleasedReturnValue(v193);
      goto LABEL_199;
    }
LABEL_191:
    v194 = 0;
    goto LABEL_199;
  }
  switch((unint64_t)v216)
  {
    case 1uLL:
    case 4uLL:
      v195 = objc_claimAutoreleasedReturnValue(objc_msgSend(v110, "vertexBindings"));
      goto LABEL_197;
    case 2uLL:
      v195 = objc_claimAutoreleasedReturnValue(objc_msgSend(v110, "fragmentBindings"));
      goto LABEL_197;
    case 3uLL:
      v195 = objc_claimAutoreleasedReturnValue(objc_msgSend(v110, "tileBindings"));
      goto LABEL_197;
    case 5uLL:
      v195 = objc_claimAutoreleasedReturnValue(objc_msgSend(v110, "objectBindings"));
      goto LABEL_197;
    case 6uLL:
      v195 = objc_claimAutoreleasedReturnValue(objc_msgSend(v110, "meshBindings"));
LABEL_197:
      v200 = (void *)v195;
      break;
    default:
      v200 = 0;
      break;
  }
  v201 = objc_msgSend(v11, "copy");
  v202 = (void *)v23[12];
  v23[12] = v201;

  v203 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v110, "constantSamplerUniqueIdentifiers"));
  v204 = v23;
  v205 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v110, "constantSamplerDescriptors"));
  ConstantSamplers = _MakeConstantSamplers(v203, v205);
  v207 = objc_claimAutoreleasedReturnValue(ConstantSamplers);
  v208 = (void *)v204[17];
  v204[17] = v207;

  Bindings = _MakeBindings(v200);
  v210 = objc_claimAutoreleasedReturnValue(Bindings);
  v211 = (void *)v204[16];
  v204[16] = v210;

  v204[18] = CurrentEncoderFreeBindingSlotIndex;
  v194 = 1;
  v24 = v221;
LABEL_199:

  return v194;
}

id _ObjectArrayWithMap(uint64_t *a1, uint64_t a2, void *a3)
{
  id v5;
  id i;
  uint64_t v7;
  void *v8;
  void *v9;
  id v10;

  v5 = a3;
  for (i = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", a2); a2; --a2)
  {
    v7 = *a1++;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v7));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", v8));

    if (v9)
      objc_msgSend(i, "addObject:", v9);

  }
  v10 = objc_msgSend(i, "copy");

  return v10;
}

void GTShaderDebuggerJITResources(_QWORD *a1)
{
  _QWORD *v1;
  id v2;
  id v3;
  id v4;
  id v5;
  id v6;
  id v7;
  uint64_t v8;
  void *i;
  uint64_t v10;
  void *v11;
  void *v12;
  id v13;
  void *v14;
  id v15;
  void *v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id v21;
  uint64_t v22;
  void *j;
  uint64_t v24;
  void *v25;
  id v26;
  id v27;
  char v28;
  id v29;
  id v30;
  uint64_t v31;
  void *k;
  uint64_t v33;
  void *v34;
  id v35;
  void *v36;
  void *v37;
  void *v38;
  unsigned int v39;
  void *v40;
  uint64_t **v41;
  id v42;
  void *v43;
  id v44;
  void *v45;
  id v46;
  id v47;
  id v48;
  id v49;
  uint64_t v50;
  void *m;
  id v52;
  void *v53;
  void *v54;
  id v55;
  id v56;
  id v57;
  uint64_t v58;
  void *n;
  uint64_t v60;
  void *v61;
  void *v62;
  uint64_t *v63;
  uint64_t *v64;
  uint64_t *v65;
  uint64_t *v66;
  uint64_t *v67;
  void *ii;
  uint64_t v69;
  void *v70;
  id v71;
  void *v72;
  _QWORD *Object;
  _QWORD *v74;
  uint64_t *v75;
  uint64_t **v76;
  id v77;
  _QWORD *v78;
  id v79;
  void *v80;
  void *v81;
  id v82;
  void *v83;
  void *v84;
  id v85;
  apr_allocator_t *v86;
  void *v87;
  uint64_t v88;
  size_t v89;
  void *v90;
  void *v91;
  uint64_t v92;
  uint64_t v93;
  unsigned int v94;
  unsigned int v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t *v99;
  unsigned int v100;
  int v101;
  uint64_t v102;
  unint64_t jj;
  uint64_t v104;
  _QWORD *v105;
  _QWORD *v106;
  void *v107;
  uint64_t v108;
  void *v109;
  id v110;
  void *v111;
  void *v112;
  void *v113;
  uint64_t v114;
  void *v115;
  void *v116;
  void *v117;
  void *v118;
  id v119;
  void *v120;
  uint64_t *v121;
  uint64_t *v122;
  uint64_t v123;
  void *v124;
  id v125;
  void *v126;
  void *v127;
  uint64_t *v128;
  id v129;
  uint64_t *v130;
  id v131;
  _QWORD *v132;
  unint64_t v133;
  uint64_t *v134;
  void *v135;
  void *v136;
  uint64_t v137;
  void *v138;
  uint64_t v139;
  id v140;
  id v141;
  void *v142;
  id v143;
  void *v144;
  id v145;
  int v146;
  unint64_t v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  _QWORD v160[5];
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  apr_pool_t *newpool;
  _BYTE v166[128];
  _BYTE v167[128];
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  uint64_t v173;
  uint64_t v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;

  v1 = a1;
  v125 = *(id *)(*a1 + 8);
  v123 = objc_claimAutoreleasedReturnValue(objc_msgSend(v125, "defaultDevice"));
  v2 = objc_alloc_init((Class)NSMutableDictionary);
  v145 = objc_alloc_init((Class)NSMutableDictionary);
  v3 = (id)v1[3];
  v4 = (id)v1[16];
  v132 = v1;
  v127 = v2;
  if (objc_msgSend(v3, "count") && objc_msgSend(v4, "count", v123))
  {
    v140 = v3;
    v142 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*v1 + 8), "defaultDevice"));
    v168 = 0u;
    v169 = 0u;
    v170 = 0u;
    v171 = 0u;
    v5 = v3;
    v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v168, &v172, 16);
    if (v6)
    {
      v7 = v6;
      v8 = *(_QWORD *)v169;
      do
      {
        for (i = 0; i != v7; i = (char *)i + 1)
        {
          if (*(_QWORD *)v169 != v8)
            objc_enumerationMutation(v5);
          v10 = *(_QWORD *)(*((_QWORD *)&v168 + 1) + 8 * (_QWORD)i);
          v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", v10));
          v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "firstObject"));
          v13 = objc_msgSend(v12, "unsignedLongLongValue");

          if (v13)
          {
            v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "lastObject"));
            v15 = objc_msgSend(v14, "unsignedLongLongValue");

            if (v15)
            {
              *(_QWORD *)&v161 = _NSConcreteStackBlock;
              *((_QWORD *)&v161 + 1) = 3221225472;
              *(_QWORD *)&v162 = ___MakeBytesBufferReplacementsForPipeline_block_invoke;
              *((_QWORD *)&v162 + 1) = &unk_7269C8;
              *(_QWORD *)&v163 = v10;
              v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "gt_firstObjectPassingTest:", &v161));
              if (v16)
              {
                v17 = objc_msgSend(v142, "newBufferWithBytes:length:options:", v13, v15, 0);
                objc_msgSend(v145, "setObject:forKeyedSubscript:", v17, v10);

              }
            }
          }

        }
        v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v168, &v172, 16);
      }
      while (v7);
    }

    v1 = v132;
    v2 = v127;
    v3 = v140;
  }
  v18 = objc_msgSend(v145, "copy", v123);

  v152 = 0u;
  v153 = 0u;
  v154 = 0u;
  v155 = 0u;
  v19 = v18;
  v20 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v152, v167, 16);
  if (v20)
  {
    v21 = v20;
    v22 = *(_QWORD *)v153;
    do
    {
      for (j = 0; j != v21; j = (char *)j + 1)
      {
        if (*(_QWORD *)v153 != v22)
          objc_enumerationMutation(v19);
        v24 = *(_QWORD *)(*((_QWORD *)&v152 + 1) + 8 * (_QWORD)j);
        v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "objectForKeyedSubscript:", v24));
        objc_msgSend(v2, "setObject:forKeyedSubscript:", v25, v24);

      }
      v21 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v152, v167, 16);
    }
    while (v21);
  }
  v126 = v19;

  v143 = objc_alloc_init((Class)NSMutableArray);
  v26 = (id)v1[4];
  v27 = (id)v1[16];
  v28 = *((_BYTE *)v1 + 72);
  v161 = 0u;
  v162 = 0u;
  v163 = 0u;
  v164 = 0u;
  v29 = objc_msgSend(v26, "countByEnumeratingWithState:objects:count:", &v161, &v172, 16);
  if (v29)
  {
    v30 = v29;
    v31 = *(_QWORD *)v162;
    v146 = v28 & 1;
    do
    {
      for (k = 0; k != v30; k = (char *)k + 1)
      {
        if (*(_QWORD *)v162 != v31)
          objc_enumerationMutation(v26);
        v33 = *(_QWORD *)(*((_QWORD *)&v161 + 1) + 8 * (_QWORD)k);
        v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "objectForKeyedSubscript:", v33));
        v35 = objc_msgSend(v34, "unsignedLongLongValue");

        if (!v35)
        {
          v160[0] = _NSConcreteStackBlock;
          v160[1] = 3221225472;
          v160[2] = ___MakeDummyBufferReplacementsForPipeline_block_invoke;
          v160[3] = &unk_7269C8;
          v160[4] = v33;
          v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v27, "gt_firstObjectPassingTest:", v160));
          v37 = v36;
          if (v36)
          {
            v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v36, "objectForKeyedSubscript:", CFSTR("used")));
            v39 = objc_msgSend(v38, "BOOLValue");

            if (!v39 || v146)
            {
              v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v37, "objectForKeyedSubscript:", CFSTR("index")));
              objc_msgSend(v143, "addObject:", v40);

            }
          }

        }
      }
      v30 = objc_msgSend(v26, "countByEnumeratingWithState:objects:count:", &v161, &v172, 16);
    }
    while (v30);
  }

  if (objc_msgSend(v143, "count"))
  {
    v41 = (uint64_t **)v132;
    v42 = *(id *)(*v132 + 8);
    v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "defaultDevice"));
    v44 = objc_msgSend(v43, "newBufferWithLength:options:", 1024, 0);
    if (v44)
    {
      v45 = v44;
      v46 = objc_alloc_init((Class)NSMutableDictionary);
      v156 = 0u;
      v157 = 0u;
      v158 = 0u;
      v159 = 0u;
      v47 = v143;
      v48 = objc_msgSend(v47, "countByEnumeratingWithState:objects:count:", &v156, &v168, 16);
      if (v48)
      {
        v49 = v48;
        v50 = *(_QWORD *)v157;
        do
        {
          for (m = 0; m != v49; m = (char *)m + 1)
          {
            if (*(_QWORD *)v157 != v50)
              objc_enumerationMutation(v47);
            objc_msgSend(v46, "setObject:forKeyedSubscript:", v45, *(_QWORD *)(*((_QWORD *)&v156 + 1) + 8 * (_QWORD)m));
          }
          v49 = objc_msgSend(v47, "countByEnumeratingWithState:objects:count:", &v156, &v168, 16);
        }
        while (v49);
      }

      v52 = objc_msgSend(v46, "copy");
      v53 = v126;
    }
    else
    {
      v52 = 0;
      v53 = v126;
    }

    v54 = v127;
  }
  else
  {
    v52 = 0;
    v41 = (uint64_t **)v132;
    v53 = v126;
    v54 = v127;
  }

  v148 = 0u;
  v149 = 0u;
  v150 = 0u;
  v151 = 0u;
  v55 = v52;
  v56 = objc_msgSend(v55, "countByEnumeratingWithState:objects:count:", &v148, v166, 16);
  if (v56)
  {
    v57 = v56;
    v58 = *(_QWORD *)v149;
    do
    {
      for (n = 0; n != v57; n = (char *)n + 1)
      {
        if (*(_QWORD *)v149 != v58)
          objc_enumerationMutation(v55);
        v60 = *(_QWORD *)(*((_QWORD *)&v148 + 1) + 8 * (_QWORD)n);
        v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v53, "objectForKeyedSubscript:", v60));

        if (!v61)
        {
          v62 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v55, "objectForKeyedSubscript:", v60));
          objc_msgSend(v54, "setObject:forKeyedSubscript:", v62, v60);

        }
      }
      v57 = objc_msgSend(v55, "countByEnumeratingWithState:objects:count:", &v148, v166, 16);
    }
    while (v57);
  }

  v63 = (uint64_t *)objc_msgSend(v54, "copy");
  v64 = v41[21];
  v41[21] = v63;

  v133 = *v41[11];
  v134 = *(uint64_t **)(**v41 + 40);
  v65 = v41[16];
  v66 = v41[7];
  v129 = objc_alloc_init((Class)NSMutableDictionary);
  v161 = 0u;
  v162 = 0u;
  v163 = 0u;
  v164 = 0u;
  v67 = v66;
  v141 = objc_msgSend(v67, "countByEnumeratingWithState:objects:count:", &v161, &v168, 16);
  if (v141)
  {
    v139 = *(_QWORD *)v162;
    v130 = v67;
    v131 = v55;
    v128 = v65;
    do
    {
      for (ii = 0; ii != v141; ii = (char *)ii + 1)
      {
        if (*(_QWORD *)v162 != v139)
          objc_enumerationMutation(v67);
        v69 = *(_QWORD *)(*((_QWORD *)&v161 + 1) + 8 * (_QWORD)ii);
        v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v67, "objectForKeyedSubscript:", v69));
        v71 = objc_msgSend(v70, "unsignedLongLongValue");

        if (v71)
        {
          *(_QWORD *)&v156 = _NSConcreteStackBlock;
          *((_QWORD *)&v156 + 1) = 3221225472;
          *(_QWORD *)&v157 = ___MakeVisibleFunctionTablesForPipeline_block_invoke;
          *((_QWORD *)&v157 + 1) = &unk_7269C8;
          v137 = v69;
          *(_QWORD *)&v158 = v69;
          v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v65, "gt_firstObjectPassingTest:", &v156));
          if (v72)
          {
            Object = GTMTLSMContext_getObject(*v134, (uint64_t)v71, v133);
            if (Object)
            {
              v74 = Object;
              if (*(_DWORD *)Object == 83)
              {
                v75 = v65;
                v135 = v72;
                v76 = v41;
                v77 = objc_msgSend(v41[12], "mutableCopy");
                v78 = (_QWORD *)v74[13];
                v79 = objc_alloc_init((Class)MTLVisibleFunctionTableDescriptor);
                objc_msgSend(v79, "setFunctionCount:", *v78);
                v80 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v74[16]));
                v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v77, "objectForKeyedSubscript:", v80));

                v144 = v77;
                if (v81)
                {
                  v82 = objc_msgSend(v81, "newVisibleFunctionTableWithDescriptor:stage:", v79, *((unsigned __int8 *)v74 + 168));
                  v41 = v76;
                  v65 = v75;
                }
                else
                {
                  v83 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v74[15]));
                  v84 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v77, "objectForKeyedSubscript:", v83));

                  if (v84)
                    v85 = objc_msgSend(v84, "newVisibleFunctionTableWithDescriptor:", v79);
                  else
                    v85 = 0;
                  v41 = v76;

                  v55 = v131;
                  v65 = v75;
                  v82 = v85;
                }

                v87 = v82;
                if (v82)
                {
                  v88 = **v41;
                  v147 = *v41[11];
                  newpool = 0;
                  apr_pool_create_ex(&newpool, 0, 0, v86);
                  v172 = 0u;
                  v173 = 0;
                  v184 = 0u;
                  v182 = 0u;
                  v183 = 0u;
                  v180 = 0u;
                  v181 = 0u;
                  v178 = 0u;
                  v179 = 0u;
                  v176 = 0u;
                  v175 = 0u;
                  LODWORD(v172) = 83;
                  v174 = -1;
                  WORD1(v179) = 2;
                  v177 = 0xFFFFFFFFFFFFFFFFLL;
                  *((_QWORD *)&v184 + 1) = *(_QWORD *)v74[13];
                  v89 = 8 * *((_QWORD *)&v184 + 1);
                  v90 = apr_palloc(newpool, 8 * *((_QWORD *)&v184 + 1));
                  v91 = v90;
                  if (v90)
                    bzero(v90, v89);
                  *(_QWORD *)&v184 = v91;
                  v92 = *(_QWORD *)(v88 + 8);
                  v160[0] = v74[1];
                  v93 = *(_QWORD *)(*(_QWORD *)(*find_entry(v92, v160, 8uLL, 0) + 32) + 32);
                  v138 = v87;
                  v94 = 0;
                  if (v93)
                  {
                    while (1)
                    {
                      v95 = atomic_load((unsigned int *)(v93 + 4));
                      v96 = v94 + (v95 >> 6) - 1;
                      if ((int)v96 > 0)
                        break;
                      v93 = *(_QWORD *)(v93 + 40);
                      v94 = v96;
                      if (!v93)
                      {
                        v94 = v96;
                        goto LABEL_81;
                      }
                    }
                  }
                  v96 = 0;
LABEL_81:
                  v97 = v94 | (unint64_t)(v96 << 32);
LABEL_82:
                  v98 = v93 + 64;
                  while (v93)
                  {
                    if ((*(_BYTE *)(v98 + ((uint64_t)(HIDWORD(v97) - (int)v97) << 6) + 15) & 8) == 0)
                      break;
                    v99 = (unint64_t *)(v98 + ((uint64_t)(HIDWORD(v97) - (int)v97) << 6));
                    if (*v99 >= v147)
                      break;
                    GTMTLSMVisibleFunctionTableStateful_processTraceFuncWithMap((uint64_t)&v172, *(_QWORD *)(v88 + 16), (uint64_t)v99);
                    v100 = atomic_load((unsigned int *)(v93 + 4));
                    v101 = v97 + (v100 >> 6);
                    v102 = (HIDWORD(v97) + 1);
                    v97 = (v102 << 32) | v97;
                    if ((_DWORD)v102 == v101 - 1)
                    {
                      v97 = (v102 << 32) | v102;
                      v93 = *(_QWORD *)(v93 + 40);
                      goto LABEL_82;
                    }
                  }
                  v72 = v135;
                  if (*((_QWORD *)&v184 + 1))
                  {
                    for (jj = 0; *((_QWORD *)&v184 + 1) > jj; ++jj)
                    {
                      v104 = *(_QWORD *)(v184 + 8 * jj);
                      if (!v104)
                        continue;
                      v105 = GTMTLSMContext_getObject(**(_QWORD **)(v88 + 40), *(_QWORD *)(v184 + 8 * jj), v147);
                      if (!v105)
                        continue;
                      v106 = v105;
                      v107 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v104));
                      v108 = objc_claimAutoreleasedReturnValue(objc_msgSend(v144, "objectForKeyedSubscript:", v107));
                      if (v108)
                      {
                        v109 = (void *)v108;

                      }
                      else
                      {
                        v110 = v144;
                        v111 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v106[5]));
                        v109 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v110, "objectForKeyedSubscript:", v111));

                        v136 = v109;
                        if (v109)
                        {
                          v112 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v106[7]));
                          v113 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v110, "objectForKeyedSubscript:", v112));

                          if (v113)
                          {
                            v114 = *((unsigned __int8 *)v106 + 64);
                            v115 = v136;
                            v109 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "functionHandleWithFunction:stage:", v136, v114));
                          }
                          else
                          {
                            v116 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v106[6]));
                            v117 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v110, "objectForKeyedSubscript:", v116));

                            if (v117)
                              v109 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v117, "functionHandleWithFunction:", v136));
                            else
                              v109 = 0;

                            v115 = v136;
                          }

                        }
                        else
                        {
                          v115 = 0;
                        }

                        v72 = v135;
                        if (!v109)
                        {
                          v109 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*v132 + 8), "functionHandleForKey:", v104));
                          if (!v109)
                            continue;
                          goto LABEL_105;
                        }
                      }
                      v118 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v104));
                      objc_msgSend(v144, "setObject:forKeyedSubscript:", v109, v118);

LABEL_105:
                      objc_msgSend(v138, "setFunction:atIndex:", v109, jj);

                    }
                  }
                  apr_pool_destroy(newpool);
                  v119 = objc_msgSend(v144, "copy");
                  v41 = (uint64_t **)v132;
                  v120 = (void *)v132[12];
                  v132[12] = v119;

                  v87 = v138;
                  objc_msgSend(v129, "setObject:forKeyedSubscript:", v138, v137);
                  v55 = v131;
                  v65 = v128;
                }
                else
                {

                  v72 = v135;
                }

                v67 = v130;
              }
            }
          }

        }
      }
      v141 = objc_msgSend(v67, "countByEnumeratingWithState:objects:count:", &v161, &v168, 16);
    }
    while (v141);
  }

  v121 = (uint64_t *)objc_msgSend(v129, "copy");
  v122 = v41[22];
  v41[22] = v121;

}

uint64_t GTShaderDebuggerEncodeResourcesRender(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  id v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  void *v13;
  id v14;
  id v15;
  id v16;
  id v17;
  uint64_t v18;
  void *i;
  void *v20;
  void *v21;
  id v22;
  id v23;
  id v24;
  uint64_t v25;
  void *j;
  void *v27;
  void *v28;
  id v29;
  id Error;
  id v31;
  id v32;
  uint64_t v33;
  void *k;
  void *v35;
  void *v36;
  id v37;
  id v38;
  uint64_t v39;
  void *m;
  void *v41;
  void *v42;
  id v43;
  id v44;
  uint64_t v45;
  void *n;
  void *v47;
  void *v48;
  id v49;
  id v50;
  uint64_t v51;
  void *ii;
  void *v53;
  void *v54;
  id v55;
  id v56;
  id v57;
  uint64_t v58;
  void *jj;
  void *v60;
  void *v61;
  id v62;
  id v63;
  uint64_t v64;
  void *kk;
  void *v66;
  void *v67;
  _BOOL4 v69;
  id v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  _BYTE v103[128];
  _BYTE v104[128];
  _BYTE v105[128];
  _BYTE v106[128];
  _BYTE v107[128];
  _BYTE v108[128];
  _BYTE v109[128];
  _BYTE v110[128];

  v4 = *a1;
  v5 = (void *)a1[12];
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(*a1 + 19912)));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", v6));

  if (v7)
  {
    v8 = *(id *)(*a1 + 8);
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "renderCommandEncoderForKey:", *(_QWORD *)(v4 + 11320)));
    v10 = v9 != 0;
    if (v9)
    {
      v11 = a1[18];
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1[24], "objectForKeyedSubscript:", CFSTR("ROI")));
      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "objectForKeyedSubscript:", CFSTR("Type")));
      v14 = objc_msgSend(v13, "integerValue");

      v70 = v8;
      switch((unint64_t)v14)
      {
        case 1uLL:
        case 4uLL:
          if (v11 != 0x7FFFFFFFFFFFFFFFLL)
            objc_msgSend(v9, "setVertexBuffer:offset:atIndex:", a1[23], 0, v11);
          v69 = v9 != 0;
          v15 = (id)a1[21];
          v99 = 0u;
          v100 = 0u;
          v101 = 0u;
          v102 = 0u;
          v16 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v99, v110, 16);
          if (v16)
          {
            v17 = v16;
            v18 = *(_QWORD *)v100;
            do
            {
              for (i = 0; i != v17; i = (char *)i + 1)
              {
                if (*(_QWORD *)v100 != v18)
                  objc_enumerationMutation(v15);
                v20 = *(void **)(*((_QWORD *)&v99 + 1) + 8 * (_QWORD)i);
                v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKeyedSubscript:", v20));
                objc_msgSend(v9, "setVertexBuffer:offset:atIndex:", v21, 0, objc_msgSend(v20, "unsignedIntegerValue"));

              }
              v17 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v99, v110, 16);
            }
            while (v17);
          }
          v22 = (id)a1[22];
          v95 = 0u;
          v96 = 0u;
          v97 = 0u;
          v98 = 0u;
          v23 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v95, v109, 16);
          if (v23)
          {
            v24 = v23;
            v25 = *(_QWORD *)v96;
            do
            {
              for (j = 0; j != v24; j = (char *)j + 1)
              {
                if (*(_QWORD *)v96 != v25)
                  objc_enumerationMutation(v22);
                v27 = *(void **)(*((_QWORD *)&v95 + 1) + 8 * (_QWORD)j);
                v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "objectForKeyedSubscript:", v27));
                objc_msgSend(v9, "setVertexVisibleFunctionTable:atBufferIndex:", v28, objc_msgSend(v27, "unsignedIntegerValue"));

              }
              v24 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v95, v109, 16);
            }
            while (v24);
          }
          goto LABEL_60;
        case 2uLL:
          if (v11 != 0x7FFFFFFFFFFFFFFFLL)
            objc_msgSend(v9, "setFragmentBuffer:offset:atIndex:", a1[23], 0, v11);
          v69 = v9 != 0;
          v15 = (id)a1[21];
          v91 = 0u;
          v92 = 0u;
          v93 = 0u;
          v94 = 0u;
          v31 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v91, v108, 16);
          if (v31)
          {
            v32 = v31;
            v33 = *(_QWORD *)v92;
            do
            {
              for (k = 0; k != v32; k = (char *)k + 1)
              {
                if (*(_QWORD *)v92 != v33)
                  objc_enumerationMutation(v15);
                v35 = *(void **)(*((_QWORD *)&v91 + 1) + 8 * (_QWORD)k);
                v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKeyedSubscript:", v35));
                objc_msgSend(v9, "setFragmentBuffer:offset:atIndex:", v36, 0, objc_msgSend(v35, "unsignedIntegerValue"));

              }
              v32 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v91, v108, 16);
            }
            while (v32);
          }
          v22 = (id)a1[22];
          v87 = 0u;
          v88 = 0u;
          v89 = 0u;
          v90 = 0u;
          v37 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v87, v107, 16);
          if (v37)
          {
            v38 = v37;
            v39 = *(_QWORD *)v88;
            do
            {
              for (m = 0; m != v38; m = (char *)m + 1)
              {
                if (*(_QWORD *)v88 != v39)
                  objc_enumerationMutation(v22);
                v41 = *(void **)(*((_QWORD *)&v87 + 1) + 8 * (_QWORD)m);
                v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "objectForKeyedSubscript:", v41));
                objc_msgSend(v9, "setFragmentVisibleFunctionTable:atBufferIndex:", v42, objc_msgSend(v41, "unsignedIntegerValue"));

              }
              v38 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v87, v107, 16);
            }
            while (v38);
          }
          goto LABEL_60;
        case 3uLL:
          if (v11 != 0x7FFFFFFFFFFFFFFFLL)
            objc_msgSend(v9, "setTileBuffer:offset:atIndex:", a1[23], 0, v11);
          v69 = v9 != 0;
          v15 = (id)a1[21];
          v83 = 0u;
          v84 = 0u;
          v85 = 0u;
          v86 = 0u;
          v43 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v83, v106, 16);
          if (v43)
          {
            v44 = v43;
            v45 = *(_QWORD *)v84;
            do
            {
              for (n = 0; n != v44; n = (char *)n + 1)
              {
                if (*(_QWORD *)v84 != v45)
                  objc_enumerationMutation(v15);
                v47 = *(void **)(*((_QWORD *)&v83 + 1) + 8 * (_QWORD)n);
                v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKeyedSubscript:", v47));
                objc_msgSend(v9, "setTileBuffer:offset:atIndex:", v48, 0, objc_msgSend(v47, "unsignedIntegerValue"));

              }
              v44 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v83, v106, 16);
            }
            while (v44);
          }
          v22 = (id)a1[22];
          v79 = 0u;
          v80 = 0u;
          v81 = 0u;
          v82 = 0u;
          v49 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v79, v105, 16);
          if (v49)
          {
            v50 = v49;
            v51 = *(_QWORD *)v80;
            do
            {
              for (ii = 0; ii != v50; ii = (char *)ii + 1)
              {
                if (*(_QWORD *)v80 != v51)
                  objc_enumerationMutation(v22);
                v53 = *(void **)(*((_QWORD *)&v79 + 1) + 8 * (_QWORD)ii);
                v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "objectForKeyedSubscript:", v53));
                objc_msgSend(v9, "setTileVisibleFunctionTable:atBufferIndex:", v54, objc_msgSend(v53, "unsignedIntegerValue"));

              }
              v50 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v79, v105, 16);
            }
            while (v50);
          }
LABEL_60:

          v10 = v69;
          goto LABEL_81;
        case 5uLL:
          if (v11 != 0x7FFFFFFFFFFFFFFFLL)
            objc_msgSend(v9, "setObjectBuffer:offset:atIndex:", a1[23], 0, v11);
          v55 = (id)a1[21];
          v71 = 0u;
          v72 = 0u;
          v73 = 0u;
          v74 = 0u;
          v56 = objc_msgSend(v55, "countByEnumeratingWithState:objects:count:", &v71, v103, 16);
          if (v56)
          {
            v57 = v56;
            v58 = *(_QWORD *)v72;
            do
            {
              for (jj = 0; jj != v57; jj = (char *)jj + 1)
              {
                if (*(_QWORD *)v72 != v58)
                  objc_enumerationMutation(v55);
                v60 = *(void **)(*((_QWORD *)&v71 + 1) + 8 * (_QWORD)jj);
                v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v55, "objectForKeyedSubscript:", v60));
                objc_msgSend(v9, "setObjectBuffer:offset:atIndex:", v61, 0, objc_msgSend(v60, "unsignedIntegerValue"));

              }
              v57 = objc_msgSend(v55, "countByEnumeratingWithState:objects:count:", &v71, v103, 16);
            }
            while (v57);
          }
          goto LABEL_80;
        case 6uLL:
          if (v11 != 0x7FFFFFFFFFFFFFFFLL)
            objc_msgSend(v9, "setMeshBuffer:offset:atIndex:", a1[23], 0, v11);
          v55 = (id)a1[21];
          v75 = 0u;
          v76 = 0u;
          v77 = 0u;
          v78 = 0u;
          v62 = objc_msgSend(v55, "countByEnumeratingWithState:objects:count:", &v75, v104, 16);
          if (v62)
          {
            v63 = v62;
            v64 = *(_QWORD *)v76;
            do
            {
              for (kk = 0; kk != v63; kk = (char *)kk + 1)
              {
                if (*(_QWORD *)v76 != v64)
                  objc_enumerationMutation(v55);
                v66 = *(void **)(*((_QWORD *)&v75 + 1) + 8 * (_QWORD)kk);
                v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v55, "objectForKeyedSubscript:", v66));
                objc_msgSend(v9, "setMeshBuffer:offset:atIndex:", v67, 0, objc_msgSend(v66, "unsignedIntegerValue"));

              }
              v63 = objc_msgSend(v55, "countByEnumeratingWithState:objects:count:", &v75, v104, 16);
            }
            while (v63);
          }
LABEL_80:

LABEL_81:
          v8 = v70;
          break;
        default:
          GTMTLReplay_handleError(101, (uint64_t)"Unreachable", "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_shaderDebugger_internal.m", (uint64_t)"GTShaderDebuggerEncodeResourcesRender", 4089, 4);
          break;
      }
      objc_msgSend(v9, "useResource:usage:", a1[23], 2);
      objc_msgSend(v9, "setRenderPipelineState:", v7);
    }
    else if (a2)
    {
      Error = GTShaderDebuggerMakeError(1u, CFSTR("Internal error: Failed to resolve render encoder"), 0, 0, 0);
      *a2 = (id)objc_claimAutoreleasedReturnValue(Error);
    }

  }
  else if (a2)
  {
    v29 = GTShaderDebuggerMakeError(1u, CFSTR("Internal error: Failed to resolve render pipeline"), 0, 0, 0);
    v10 = 0;
    *a2 = (id)objc_claimAutoreleasedReturnValue(v29);
  }
  else
  {
    v10 = 0;
  }

  return v10;
}

uint64_t GTShaderDebuggerEncodeResourcesCompute(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  id v8;
  void *v9;
  void *v10;
  uint64_t v11;
  id v12;
  id v13;
  id v14;
  uint64_t v15;
  void *i;
  void *v17;
  void *v18;
  id v19;
  id v20;
  id v21;
  uint64_t v22;
  void *j;
  void *v24;
  void *v25;
  id v26;
  id Error;
  id v29;
  void *v30;
  unsigned int v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  _BYTE v40[128];
  _BYTE v41[128];

  v4 = *a1;
  v5 = (void *)a1[12];
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(*a1 + 11376)));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", v6));

  if (v7)
  {
    v8 = *(id *)(*a1 + 8);
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "computeCommandEncoderForKey:", *(_QWORD *)(v4 + 11320)));
    v10 = v9;
    v11 = v9 != 0;
    if (v9)
    {
      v29 = v8;
      if (a1[18] != 0x7FFFFFFFFFFFFFFFLL)
        objc_msgSend(v9, "setBuffer:offset:atIndex:", a1[23], 0);
      v12 = (id)a1[21];
      v36 = 0u;
      v37 = 0u;
      v38 = 0u;
      v39 = 0u;
      v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v36, v41, 16);
      if (v13)
      {
        v14 = v13;
        v15 = *(_QWORD *)v37;
        do
        {
          for (i = 0; i != v14; i = (char *)i + 1)
          {
            if (*(_QWORD *)v37 != v15)
              objc_enumerationMutation(v12);
            v17 = *(void **)(*((_QWORD *)&v36 + 1) + 8 * (_QWORD)i);
            v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "objectForKeyedSubscript:", v17, v29));
            objc_msgSend(v10, "setBuffer:offset:atIndex:", v18, 0, objc_msgSend(v17, "unsignedIntegerValue"));

          }
          v14 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v36, v41, 16);
        }
        while (v14);
      }
      v31 = v11;
      v19 = (id)a1[22];
      v32 = 0u;
      v33 = 0u;
      v34 = 0u;
      v35 = 0u;
      v20 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v32, v40, 16);
      if (v20)
      {
        v21 = v20;
        v22 = *(_QWORD *)v33;
        do
        {
          for (j = 0; j != v21; j = (char *)j + 1)
          {
            if (*(_QWORD *)v33 != v22)
              objc_enumerationMutation(v19);
            v24 = *(void **)(*((_QWORD *)&v32 + 1) + 8 * (_QWORD)j);
            v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "objectForKeyedSubscript:", v24, v29));
            objc_msgSend(v10, "setVisibleFunctionTable:atBufferIndex:", v25, objc_msgSend(v24, "unsignedIntegerValue"));

          }
          v21 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v32, v40, 16);
        }
        while (v21);
      }
      objc_msgSend(v10, "useResource:usage:", a1[23], 2, v29);
      objc_msgSend(v10, "setComputePipelineState:", v7);

      v11 = v31;
      v8 = v30;
    }
    else if (a2)
    {
      Error = GTShaderDebuggerMakeError(1u, CFSTR("Internal error: Failed to resolve compute encoder"), 0, 0, 0);
      *a2 = (id)objc_claimAutoreleasedReturnValue(Error);
    }

  }
  else if (a2)
  {
    v26 = GTShaderDebuggerMakeError(1u, CFSTR("Internal error: Failed to resolve compute pipeleine"), 0, 0, 0);
    v11 = 0;
    *a2 = (id)objc_claimAutoreleasedReturnValue(v26);
  }
  else
  {
    v11 = 0;
  }

  return v11;
}

uint64_t GTShaderDebuggerExecuteEncoder(uint64_t *a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  int v6;
  uint64_t v7;
  id v8;
  void *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  id Error;

  v3 = *a1;
  v4 = a1[10];
  if (v4)
  {
    v6 = *(_DWORD *)(v3 + 11312);
    v7 = *(_QWORD *)(v3 + 11320);
    v8 = *(id *)(v3 + 8);
    v9 = v8;
    if (v6 == 70)
    {
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "renderCommandEncoderForKey:", v7));
      v11 = *(_QWORD *)(v4 + 200);
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "executeIndirectCommandBufferMap"));
      v13 = DYMTLDrawRenderCommandEncoder(v10, v4, v11, v4 + 112, v12);

      v9 = v12;
    }
    else
    {
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "computeCommandEncoderForKey:", v7));
      v13 = DYMTLDispatchComputeCommandEncoder(v10, v4, *(_QWORD *)(v4 + 200));
    }

    if (a2 && (v13 & 1) == 0)
    {
      Error = GTShaderDebuggerMakeError(1u, CFSTR("Internal error: Problem encountered during execution"), 0, 0, 0);
      v13 = 0;
      *a2 = (id)objc_claimAutoreleasedReturnValue(Error);
    }
  }
  else
  {
    GTMTLReplayController_defaultDispatchFunction(v3, a1[11]);
    return 1;
  }
  return v13;
}

uint64_t GTShaderDebuggerValidateUserComputeDispatch(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  int v5;
  void *v6;
  id v7;
  id v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  char *v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t *v15;
  id v16;
  id v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  void *v24;
  __CFString *v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  unint64_t v33;
  id Error;

  v4 = *a1;
  v5 = *(_DWORD *)(*a1 + 11312);
  if (v5 == 70)
  {
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v4 + 8), "renderPipelineStateForKey:", *(_QWORD *)(v4 + 19912)));
    v16 = objc_msgSend(v6, "maxTotalThreadsPerThreadgroup");
    if (!v16)
      goto LABEL_25;
    v17 = v16;
    v18 = a1[11];
    if (*(_DWORD *)(v18 + 8) != -16137)
      goto LABEL_25;
    v19 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v18, *(unsigned __int8 *)(v18 + 13), *(_QWORD *)(*(_QWORD *)*a1 + 16));
    v20 = *((_QWORD *)v19 + 1);
    v21 = *((_QWORD *)v19 + 2);
    v22 = *((_QWORD *)v19 + 3);
    v23 = v21 * v20 * v22;
    if (!v23)
    {
      v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Dispatched total threads per tile (width(%llu) * height(%llu) * depth(%llu)) must not be 0"), v20, v21, v22));
      if (a2)
      {
        v25 = CFSTR("Failed to launch tile kernel: Dispatched total threads per tile is 0");
        goto LABEL_30;
      }
      goto LABEL_31;
    }
    if (v23 <= (unint64_t)v17)
      goto LABEL_25;
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Dispatched total threads per tile (%llu: (width(%llu) * height(%llu) * depth(%llu))) must not be greater than the pipeline's maximum total threads per threadgroup (%llu)"), v21 * v20 * v22, v20, v21, v22, v17));
    if (!a2)
      goto LABEL_31;
    v25 = CFSTR("Failed to launch tile kernel: Maximum total threads per threadgroup size limit exceeded");
    goto LABEL_30;
  }
  if (v5 == 28)
  {
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v4 + 8), "computePipelineStateForKey:", *(_QWORD *)(v4 + 11376)));
    v7 = objc_msgSend(v6, "maxTotalThreadsPerThreadgroup");
    if (!v7)
      goto LABEL_25;
    v8 = v7;
    v9 = a1[11];
    v10 = *(_QWORD *)(*(_QWORD *)*a1 + 16);
    v11 = *(_DWORD *)(v9 + 8);
    if (v11 != -16078)
    {
      if (v11 == -16220)
      {
        v32 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v9, *(unsigned __int8 *)(v9 + 13), v10);
        v13 = (uint64_t *)(v32 + 24);
        v14 = (uint64_t *)(v32 + 32);
        v15 = (uint64_t *)(v32 + 40);
      }
      else
      {
        if (v11 != -16327)
          goto LABEL_25;
        v12 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v9, *(unsigned __int8 *)(v9 + 13), v10);
        v13 = (uint64_t *)(v12 + 32);
        v14 = (uint64_t *)(v12 + 40);
        v15 = (uint64_t *)(v12 + 48);
      }
      v29 = *v13;
      v30 = *v14;
      v31 = *v15;
      goto LABEL_21;
    }
    v27 = GTTraceFunc_argumentBytesWithMap((_QWORD *)v9, *(unsigned __int8 *)(v9 + 13), v10);
    v28 = *((_QWORD *)v27 + 1);
    v29 = *((_QWORD *)v27 + 4);
    v30 = *((_QWORD *)v27 + 5);
    v31 = *((_QWORD *)v27 + 6);
    if (v28 == -1 || *((_QWORD *)v27 + 3) * v28 * *((_QWORD *)v27 + 2))
    {
LABEL_21:
      v33 = v30 * v31 * v29;
      if (!v33)
      {
        v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Dispatched total threads per threadgroup (width(%llu) * height(%llu) * depth(%llu)) must not be 0"), v29, v30, v31));
        if (a2)
        {
          v25 = CFSTR("Failed to launch compute kernel: Dispatched total threads per threadgroup is 0");
          goto LABEL_30;
        }
        goto LABEL_31;
      }
      if (v33 > (unint64_t)v8)
      {
        v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Dispatched total threads per threadgroup (%llu: (width(%llu) * height(%llu) * depth(%llu))) must not be greater than the pipeline's maximum total threads per threadgroup (%llu)"), v30 * v31 * v29, v29, v30, v31, v8));
        if (a2)
        {
          v25 = CFSTR("Failed to launch compute kernel: Maximum total threads per threadgroup size limit exceeded");
          goto LABEL_30;
        }
LABEL_31:

        v26 = 0;
        goto LABEL_32;
      }
LABEL_25:
      v26 = 1;
LABEL_32:

      return v26;
    }
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Dispatched total threads per grid (width(%llu) * height(%llu) * depth(%llu)) must not be 0"), v29, v30, v31));
    if (!a2)
      goto LABEL_31;
    v25 = CFSTR("Failed to launch compute kernel: Dispatched total threads per grid size is 0");
LABEL_30:
    Error = GTShaderDebuggerMakeError(4u, v25, v24, 0, 0);
    *a2 = (id)objc_claimAutoreleasedReturnValue(Error);
    goto LABEL_31;
  }
  return 1;
}

BOOL GTShaderDebuggerValidateUserEncoderBindings(uint64_t a1, _QWORD *a2)
{
  id v4;
  id v5;
  id v6;
  const __CFString *v7;
  uint64_t v8;
  void *i;
  void *v10;
  void *v11;
  unsigned int v12;
  void *v13;
  void *v14;
  const __CFString *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  id v21;
  _BOOL8 v22;
  void *v23;
  id Error;
  _QWORD *v26;
  id v27;
  id v28;
  id v29;
  void *v30;
  void *v31;
  void *v32;
  id obj;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  _BYTE v38[128];
  _QWORD v39[3];
  _QWORD v40[3];
  _QWORD v41[3];
  __int128 v42;
  uint64_t v43;

  v4 = *(id *)(a1 + 128);
  if (objc_msgSend(v4, "count"))
  {
    v26 = a2;
    v28 = *(id *)(a1 + 24);
    v42 = *(_OWORD *)(a1 + 32);
    v41[0] = &off_739D60;
    v41[1] = &off_739D78;
    v41[2] = &off_739D90;
    v43 = *(_QWORD *)(a1 + 48);
    v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v42, v41, 3));
    v39[0] = &off_739D60;
    v39[1] = &off_739D78;
    v40[0] = CFSTR("buffer");
    v40[1] = CFSTR("texture");
    v39[2] = &off_739D90;
    v40[2] = CFSTR("sampler");
    v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v40, v39, 3));
    v29 = objc_alloc_init((Class)NSMutableArray);
    v34 = 0u;
    v35 = 0u;
    v36 = 0u;
    v37 = 0u;
    v27 = v4;
    obj = v4;
    v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v34, v38, 16);
    if (v5)
    {
      v6 = v5;
      v7 = CFSTR("used");
      v8 = *(_QWORD *)v35;
      do
      {
        for (i = 0; i != v6; i = (char *)i + 1)
        {
          if (*(_QWORD *)v35 != v8)
            objc_enumerationMutation(obj);
          v10 = *(void **)(*((_QWORD *)&v34 + 1) + 8 * (_QWORD)i);
          v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", v7));
          v12 = objc_msgSend(v11, "BOOLValue");

          if (v12)
          {
            v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", CFSTR("type")));
            v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "objectForKeyedSubscript:", v13));
            if (v14)
            {
              v15 = v7;
              v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", CFSTR("index")));
              v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "objectForKeyedSubscript:", v16));
              if (!objc_msgSend(v17, "unsignedIntegerValue"))
              {
                if (objc_msgSend(v13, "integerValue")
                  || (v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "objectForKeyedSubscript:", v16)),
                      v20,
                      !v20))
                {
                  v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "objectForKeyedSubscript:", v13));
                  v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", CFSTR("name")));
                  v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Function argument '%@' does not have a valid %@ binding at index '%@'"), v18, v31, v16));
                  objc_msgSend(v29, "addObject:", v19);

                }
              }

              v7 = v15;
            }

          }
        }
        v6 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v34, v38, 16);
      }
      while (v6);
    }

    v21 = objc_msgSend(v29, "count");
    v22 = v21 == 0;
    v4 = v27;
    if (v21)
    {
      v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v29, "componentsJoinedByString:", CFSTR("\n")));
      if (v26)
      {
        Error = GTShaderDebuggerMakeError(4u, v23, CFSTR("Ensure all function arguments have valid resource bindings"), 0, 0);
        *v26 = (id)objc_claimAutoreleasedReturnValue(Error);
      }

    }
  }
  else
  {
    v22 = 1;
  }

  return v22;
}

uint64_t GTShaderDebuggerMakeTraceBuffer(uint64_t a1, _QWORD *a2)
{
  void *v4;
  id v5;
  id v6;
  uint64_t v7;
  void *v8;
  void *v9;
  id v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  id v14;
  char *v15;
  __CFString *v16;
  void *v17;
  id v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  __int128 v25;
  __CFString *v26;
  id Error;
  uint64_t v28;
  unsigned int v29;
  unint64_t v30;
  void *v31;
  int v32;
  void *v33;
  void *v34;
  __int128 v35;
  int v36;
  int32x4_t v37;
  __int32 v38;
  int v39;
  int32x4_t v40;
  __int32 v41;
  unsigned int v42;
  unint64_t v43;
  void *v44;
  unint64_t v45;
  void *v46;
  void *v47;
  __int128 v48;
  unsigned int v49;
  unint64_t v50;
  void *v51;
  unint64_t v52;
  unsigned int v53;
  unint64_t v54;
  void *v55;
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  void *v66;
  void *v67;
  void *v68;
  void *v69;
  id obj;
  id v71;

  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)a1 + 8), "defaultDevice"));
  v5 = objc_msgSend(v4, "maxBufferLength");
  v6 = v5;
  if ((unint64_t)v5 >= 0x10000000)
    v7 = 0x10000000;
  else
    v7 = (uint64_t)v5;
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 192), "objectForKeyedSubscript:", CFSTR("Options")));
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", CFSTR("TraceBufferSize")));
  v10 = objc_msgSend(v9, "unsignedIntegerValue");

  if (v6 >= v10)
    v11 = (unint64_t)v10;
  else
    v11 = (unint64_t)v6;
  if (v11 >= 0xFFFFFFFF)
    v11 = 0xFFFFFFFFLL;
  if (v10)
    v12 = v11;
  else
    v12 = v7;
  v71 = objc_msgSend(v4, "newBufferWithLength:options:", v12, 0);
  if (v71)
  {
    v13 = *(_QWORD *)(a1 + 160);
    v14 = objc_retainAutorelease(v71);
    v15 = (char *)objc_msgSend(v14, "contents");
    *(_DWORD *)v15 = 1;
    obj = v14;
    *((_DWORD *)v15 + 1) = objc_msgSend(v14, "length");
    v16 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 192), "objectForKeyedSubscript:", CFSTR("ROI")));
    v17 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("Type")));
    v18 = objc_msgSend(v17, "integerValue");

    switch((unint64_t)v18)
    {
      case 1uLL:
        v19 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("InstanceID")));
        v20 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("AmplificationID")));
        v21 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("VertexIDs")));
        if (v13)
        {
          v64 = v20;
          v67 = v19;
          *(_QWORD *)(v15 + 12) = -1;
          *((_DWORD *)v15 + 5) = -1;
          *((_DWORD *)v15 + 3) = objc_msgSend(v19, "unsignedIntValue");
          v29 = objc_msgSend(v21, "count");
          *((_DWORD *)v15 + 5) = v29;
          if (v29)
          {
            v30 = 0;
            do
            {
              v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "objectAtIndexedSubscript:", v30));
              *(_DWORD *)&v15[4 * v30 + 24] = objc_msgSend(v31, "unsignedIntValue");

              ++v30;
            }
            while (v30 < *((unsigned int *)v15 + 5));
          }
          v20 = v64;
          *((_DWORD *)v15 + 4) = objc_msgSend(v64, "unsignedIntValue");
          v32 = 4 * *((_DWORD *)v15 + 5) + 24;
          v19 = v67;
          goto LABEL_46;
        }
        *(_QWORD *)(v15 + 12) = -1;
        *((_DWORD *)v15 + 3) = objc_msgSend(v19, "unsignedIntValue");
        v49 = objc_msgSend(v21, "count");
        *((_DWORD *)v15 + 4) = v49;
        if (!v49)
          goto LABEL_44;
        v65 = v20;
        v68 = v19;
        v50 = 0;
        do
        {
          v51 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "objectAtIndexedSubscript:", v50));
          *(_DWORD *)&v15[4 * v50 + 20] = objc_msgSend(v51, "unsignedIntValue");

          ++v50;
          v52 = *((unsigned int *)v15 + 4);
        }
        while (v50 < v52);
        goto LABEL_42;
      case 2uLL:
        v19 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MinPositionX")));
        v20 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MinPositionY")));
        v21 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MaxPositionX")));
        v33 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MaxPositionY")));
        v59 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MinSampleID")));
        v61 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MaxSampleID")));
        v34 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("RenderTargetArrayIndex")));
        *(_QWORD *)&v35 = -1;
        *((_QWORD *)&v35 + 1) = -1;
        *(_OWORD *)(v15 + 12) = v35;
        *(_OWORD *)(v15 + 28) = v35;
        *(_OWORD *)(v15 + 44) = v35;
        *((_DWORD *)v15 + 15) = -1;
        objc_msgSend(v19, "floatValue");
        *((_DWORD *)v15 + 4) = v36;
        objc_msgSend(v20, "floatValue");
        v37 = vdupq_n_s32(0xCE6E6B28);
        v37.i32[0] = *((_DWORD *)v15 + 4);
        v37.i32[1] = v38;
        *((int32x4_t *)v15 + 1) = v37;
        objc_msgSend(v21, "floatValue");
        *((_DWORD *)v15 + 8) = v39;
        objc_msgSend(v33, "floatValue");
        v40 = vdupq_n_s32(0x4E6E6B28u);
        v40.i32[0] = *((_DWORD *)v15 + 8);
        v40.i32[1] = v41;
        *((int32x4_t *)v15 + 2) = v40;
        *((_DWORD *)v15 + 12) = objc_msgSend(v59, "unsignedIntValue");
        *((_DWORD *)v15 + 13) = objc_msgSend(v61, "unsignedIntValue");
        if (v13 >= 2)
          *((_DWORD *)v15 + 14) = objc_msgSend(v34, "unsignedIntValue");
        *((_DWORD *)v15 + 2) = 64;

        goto LABEL_47;
      case 3uLL:
      case 5uLL:
        v19 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MinPositionX")));
        v20 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MinPositionY")));
        v21 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MinPositionZ")));
        v22 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MaxPositionX")));
        v23 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MaxPositionY")));
        v24 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MaxPositionZ")));
        *(_QWORD *)&v25 = -1;
        *((_QWORD *)&v25 + 1) = -1;
        *(_OWORD *)(v15 + 12) = v25;
        *(_OWORD *)(v15 + 28) = v25;
        *((_DWORD *)v15 + 11) = -1;
        *((_DWORD *)v15 + 4) = objc_msgSend(v19, "unsignedIntValue");
        *((_DWORD *)v15 + 5) = objc_msgSend(v20, "unsignedIntValue");
        *((_DWORD *)v15 + 6) = objc_msgSend(v21, "unsignedIntValue");
        *((_DWORD *)v15 + 8) = objc_msgSend(v22, "unsignedIntValue");
        *((_DWORD *)v15 + 9) = objc_msgSend(v23, "unsignedIntValue");
        *((_DWORD *)v15 + 10) = objc_msgSend(v24, "unsignedIntValue");
        *((_DWORD *)v15 + 2) = 48;

        goto LABEL_47;
      case 4uLL:
        v19 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("InstanceID")));
        v20 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("AmplificationID")));
        v21 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("PatchIDs")));
        if (v13)
        {
          *(_QWORD *)(v15 + 12) = -1;
          *((_DWORD *)v15 + 5) = -1;
          *((_DWORD *)v15 + 3) = objc_msgSend(v19, "unsignedIntValue");
          *((_DWORD *)v15 + 4) = objc_msgSend(v20, "unsignedIntValue");
          v42 = objc_msgSend(v21, "count");
          *((_DWORD *)v15 + 5) = v42;
          if (v42)
          {
            v65 = v20;
            v68 = v19;
            v43 = 0;
            do
            {
              v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "objectAtIndexedSubscript:", v43));
              *(_DWORD *)&v15[4 * v43 + 24] = objc_msgSend(v44, "unsignedIntValue");

              ++v43;
              v45 = *((unsigned int *)v15 + 5);
            }
            while (v43 < v45);
            v32 = 4 * v45 + 24;
LABEL_43:
            v20 = v65;
            v19 = v68;
            goto LABEL_46;
          }
          v32 = 24;
        }
        else
        {
          *(_QWORD *)(v15 + 12) = -1;
          *((_DWORD *)v15 + 3) = objc_msgSend(v19, "unsignedIntValue");
          v53 = objc_msgSend(v21, "count");
          *((_DWORD *)v15 + 4) = v53;
          if (v53)
          {
            v65 = v20;
            v68 = v19;
            v54 = 0;
            do
            {
              v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "objectAtIndexedSubscript:", v54));
              *(_DWORD *)&v15[4 * v54 + 20] = objc_msgSend(v55, "unsignedIntValue");

              ++v54;
              v52 = *((unsigned int *)v15 + 4);
            }
            while (v54 < v52);
LABEL_42:
            v32 = 4 * v52 + 20;
            goto LABEL_43;
          }
LABEL_44:
          v32 = 20;
        }
LABEL_46:
        *((_DWORD *)v15 + 2) = v32;
LABEL_47:

        objc_storeStrong((id *)(a1 + 184), obj);
        v28 = 1;
        break;
      case 6uLL:
        v69 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("AmplificationID")));
        v66 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MinPositionX")));
        v21 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MinPositionY")));
        v60 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MinPositionZ")));
        v58 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MaxPositionX")));
        v63 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MaxPositionY")));
        v62 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("MaxPositionZ")));
        v46 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("ObjectThreadgroupPosX")));
        v47 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("ObjectThreadgroupPosY")));
        v57 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", CFSTR("ObjectThreadgroupPosZ")));
        *(_QWORD *)&v48 = -1;
        *((_QWORD *)&v48 + 1) = -1;
        *(_OWORD *)(v15 + 12) = v48;
        *(_OWORD *)(v15 + 28) = v48;
        *(_OWORD *)(v15 + 44) = v48;
        *(_QWORD *)(v15 + 60) = -1;
        *((_DWORD *)v15 + 4) = objc_msgSend(v66, "unsignedIntValue");
        *((_DWORD *)v15 + 5) = objc_msgSend(v21, "unsignedIntValue");
        *((_DWORD *)v15 + 6) = objc_msgSend(v60, "unsignedIntValue");
        *((_DWORD *)v15 + 8) = objc_msgSend(v58, "unsignedIntValue");
        *((_DWORD *)v15 + 9) = objc_msgSend(v63, "unsignedIntValue");
        *((_DWORD *)v15 + 10) = objc_msgSend(v62, "unsignedIntValue");
        *((_DWORD *)v15 + 12) = objc_msgSend(v46, "unsignedIntValue");
        *((_DWORD *)v15 + 13) = objc_msgSend(v47, "unsignedIntValue");
        *((_DWORD *)v15 + 14) = objc_msgSend(v57, "unsignedIntValue");
        v19 = v69;
        *((_DWORD *)v15 + 16) = objc_msgSend(v69, "unsignedIntValue");
        *((_DWORD *)v15 + 2) = 68;

        v20 = v66;
        goto LABEL_47;
      default:
        GTMTLReplay_handleError(101, (uint64_t)"Unreachable", "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_shaderDebugger_internal.m", (uint64_t)"GTShaderDebuggerMakeTraceBuffer", 4779, 4);
        if (!a2)
          goto LABEL_20;
        v26 = CFSTR("Error encountered while setting up GPU data buffer");
        goto LABEL_17;
    }
  }
  else
  {
    v16 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Failed to create GPU data buffer [%llu]"), v12));
    if (a2)
    {
      v26 = v16;
LABEL_17:
      Error = GTShaderDebuggerMakeError(1u, v26, 0, 0, 0);
      v28 = 0;
      *a2 = (id)objc_claimAutoreleasedReturnValue(Error);
    }
    else
    {
LABEL_20:
      v28 = 0;
    }
  }

  return v28;
}

id GTShaderDebuggerMakeTraceData(uint64_t a1, _QWORD *a2)
{
  id v4;
  void *v5;
  id v6;
  _DWORD *v7;
  id v8;
  void *v9;
  unsigned int v10;
  int v11;
  void *v14;
  __CFString *v15;
  unsigned int v16;
  void *v17;
  void *v18;
  unsigned int v19;
  void *v20;
  void *v21;
  id v22;
  id Error;
  id v24;
  id v26;
  const __CFString *v27;
  unsigned int v28;
  const __CFString *v29;
  void *v30;

  v4 = *(id *)(a1 + 184);
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 192), "objectForKeyedSubscript:", CFSTR("ROI")));
  v6 = objc_retainAutorelease(v4);
  v7 = objc_msgSend(v6, "contents");
  v8 = objc_msgSend(v6, "length");
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("Type")));
  v10 = objc_msgSend(v9, "integerValue");

  if (*v7 == 1)
  {
    v11 = *(_DWORD *)(*(_QWORD *)(a1 + 88) + 8);
    if ((v11 + 16079) < 2 || v11 == -16327 || v11 == -16220)
      v27 = CFSTR("dispatch");
    else
      v27 = CFSTR("draw");
    v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("No thread execution data for the %@ call"), v27));
    if (!a2)
      goto LABEL_33;
    if (v10 == 3)
      v15 = CFSTR("Select a different threadgroup to debug and try again");
    else
      v15 = 0;
    if ((*(_QWORD *)(a1 + 208) & 0x10) != 0)
      v16 = 4;
    else
      v16 = 3;
    v17 = v14;
    goto LABEL_32;
  }
  if (v8 != (id)v7[1])
  {
    v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Internal error: Corrupt GPU data buffer [%u:%llu]"), v7[1], v8));
    if (!a2)
    {
LABEL_33:

      goto LABEL_34;
    }
    if ((*(_QWORD *)(a1 + 208) & 0x10) != 0)
      v16 = 4;
    else
      v16 = 1;
    v17 = v14;
    v15 = 0;
LABEL_32:
    Error = GTShaderDebuggerMakeError(v16, v17, v15, 0, 0);
    *a2 = (id)objc_claimAutoreleasedReturnValue(Error);
    goto LABEL_33;
  }
  if ((unint64_t)v8 >= v7[2])
  {
    v28 = v10 - 1;
    v26 = objc_msgSend(objc_alloc((Class)NSMutableData), "initWithBytes:length:", &v28, 4);
    objc_msgSend(v26, "appendBytes:length:", v7, v7[2]);
    v24 = objc_msgSend(v26, "copy");

    goto LABEL_35;
  }
  v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("GPU data buffer limits exceeded [%u]"), v7[2]));
  if (a2)
  {
    if ((*(_QWORD *)(a1 + 208) & 0x10) != 0)
      v19 = 4;
    else
      v19 = 3;
    v29 = CFSTR("RequiredTraceBufferSize");
    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v7[2]));
    v30 = v20;
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v30, &v29, 1));
    v22 = GTShaderDebuggerMakeError(v19, v18, 0, 0, v21);
    *a2 = (id)objc_claimAutoreleasedReturnValue(v22);

  }
LABEL_34:
  v24 = 0;
LABEL_35:

  return v24;
}

id GTShaderDebuggerMakeResourceMappings(uint64_t **a1)
{
  id v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  id v6;
  uint64_t v7;
  void *i;
  uint64_t v9;
  void *v10;
  id v11;
  void *v12;
  void *v13;
  void *v14;
  uint64_t *v15;
  id v16;
  uint64_t v17;
  void *j;
  uint64_t v19;
  void *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  id v24;
  uint64_t v25;
  void *k;
  void *v27;
  _QWORD *Object;
  int v29;
  void *v30;
  apr_allocator_t *v31;
  apr_array_header_t *v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  unsigned int v41;
  void *v42;
  id v43;
  id v44;
  id v45;
  uint64_t v46;
  void *m;
  id v48;
  void *v49;
  id v50;
  void *v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  NSNumber *v55;
  void *v56;
  apr_pool_t *v57;
  id v58;
  uint64_t v59;
  void *n;
  id v61;
  void *v62;
  id v63;
  void *v64;
  _QWORD *v65;
  NSNumber *v66;
  void *v67;
  void *v68;
  id v69;
  id v70;
  uint64_t v71;
  void *ii;
  id v73;
  void *v74;
  id v75;
  void *v76;
  _QWORD *v77;
  NSNumber *v78;
  void *v79;
  void *v80;
  id v81;
  uint64_t *v82;
  id v83;
  id v84;
  uint64_t v85;
  void *jj;
  uint64_t v87;
  void *v88;
  id v89;
  void *v90;
  void *v91;
  void *v92;
  id v94;
  uint64_t **v95;
  id v96;
  uint64_t v97;
  apr_pool_t *v98;
  __int128 v99;
  id obj;
  id v101;
  id v102;
  apr_pool_t *p;
  apr_pool_t *pa;
  apr_pool_t *pb;
  apr_pool_t *pc;
  uint64_t v107;
  unint64_t v108;
  uint64_t *v109;
  uint64_t *v110;
  id v111;
  void *v112;
  uint64_t *v113;
  id v114;
  uint64_t *v115;
  id v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  apr_pool_t *newpool;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  _QWORD v140[5];
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  _QWORD v145[6];
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  _QWORD v154[5];
  _QWORD v155[5];
  _BYTE v156[128];
  _BYTE v157[128];
  _BYTE v158[128];
  _BYTE v159[128];
  _BYTE v160[128];
  _BYTE v161[128];
  _BYTE v162[128];
  _QWORD v163[16];
  _QWORD v164[3];
  __int128 v165;
  uint64_t *v166;
  _QWORD v167[3];
  _QWORD v168[3];

  v2 = (id)(*a1)[1];
  v3 = **a1;
  v109 = *(uint64_t **)(v3 + 40);
  v111 = v2;
  v107 = *(_QWORD *)(v3 + 8);
  v108 = *a1[11];
  v133 = 0u;
  v134 = 0u;
  v95 = a1;
  v115 = a1[16];
  if (objc_msgSend(v115, "count"))
  {
    v101 = objc_alloc_init((Class)NSMutableArray);
    v102 = objc_alloc_init((Class)NSMutableSet);
    v96 = objc_alloc_init((Class)NSMutableSet);
    v94 = objc_alloc_init((Class)NSMutableSet);
    v167[0] = &off_739D60;
    v167[1] = &off_739D78;
    v168[0] = v102;
    v168[1] = v96;
    v167[2] = &off_739D90;
    v168[2] = v94;
    v112 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v168, v167, 3));
    v165 = *((_OWORD *)a1 + 2);
    v164[0] = &off_739D60;
    v164[1] = &off_739D78;
    v164[2] = &off_739D90;
    v166 = a1[6];
    v152 = 0u;
    v153 = 0u;
    v150 = 0u;
    v151 = 0u;
    obj = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v165, v164, 3));
    v98 = (apr_pool_t *)objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v150, v163, 16);
    if (v98)
    {
      v97 = *(_QWORD *)v151;
      do
      {
        for (p = 0; p != v98; p = (apr_pool_t *)((char *)p + 1))
        {
          if (*(_QWORD *)v151 != v97)
            objc_enumerationMutation(obj);
          v4 = *(_QWORD *)(*((_QWORD *)&v150 + 1) + 8 * (_QWORD)p);
          v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(obj, "objectForKeyedSubscript:", v4));
          v148 = 0u;
          v149 = 0u;
          v146 = 0u;
          v147 = 0u;
          v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v146, v162, 16);
          if (v6)
          {
            v7 = *(_QWORD *)v147;
            do
            {
              for (i = 0; i != v6; i = (char *)i + 1)
              {
                if (*(_QWORD *)v147 != v7)
                  objc_enumerationMutation(v5);
                v9 = *(_QWORD *)(*((_QWORD *)&v146 + 1) + 8 * (_QWORD)i);
                v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", v9));
                v11 = objc_msgSend(v10, "unsignedLongLongValue");

                if (v11)
                {
                  v145[0] = _NSConcreteStackBlock;
                  v145[1] = 3221225472;
                  v145[2] = ___GetCurrentEncoderBoundResources_block_invoke;
                  v145[3] = &unk_7269F0;
                  v145[4] = v4;
                  v145[5] = v9;
                  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v115, "gt_firstObjectPassingTest:", v145));
                  if (v12)
                  {
                    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v112, "objectForKeyedSubscript:", v4));
                    v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v11));
                    objc_msgSend(v13, "addObject:", v14);

                  }
                }
              }
              v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v146, v162, 16);
            }
            while (v6);
          }

        }
        v98 = (apr_pool_t *)objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v150, v163, 16);
      }
      while (v98);
    }

    v15 = a1[3];
    v141 = 0u;
    v142 = 0u;
    v143 = 0u;
    v144 = 0u;
    v16 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v141, v161, 16);
    if (v16)
    {
      v17 = *(_QWORD *)v142;
      do
      {
        for (j = 0; j != v16; j = (char *)j + 1)
        {
          if (*(_QWORD *)v142 != v17)
            objc_enumerationMutation(v15);
          v19 = *(_QWORD *)(*((_QWORD *)&v141 + 1) + 8 * (_QWORD)j);
          v140[0] = _NSConcreteStackBlock;
          v140[1] = 3221225472;
          v140[2] = ___GetCurrentEncoderBoundResources_block_invoke_2;
          v140[3] = &unk_7269C8;
          v140[4] = v19;
          v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v115, "gt_firstObjectPassingTest:", v140));
          if (v20)
            objc_msgSend(v101, "addObject:", v19);

        }
        v16 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v141, v161, 16);
      }
      while (v16);
    }
    v21 = *v95[11];
    v22 = *(_QWORD *)(**v95 + 40);
    v23 = v95[2];
    v136 = 0u;
    v137 = 0u;
    v138 = 0u;
    v139 = 0u;
    v24 = objc_msgSend(v23, "countByEnumeratingWithState:objects:count:", &v136, v160, 16);
    if (v24)
    {
      v25 = *(_QWORD *)v137;
      do
      {
        for (k = 0; k != v24; k = (char *)k + 1)
        {
          if (*(_QWORD *)v137 != v25)
            objc_enumerationMutation(v23);
          v27 = *(void **)(*((_QWORD *)&v136 + 1) + 8 * (_QWORD)k);
          Object = GTMTLSMContext_getObject(*(_QWORD *)v22, (uint64_t)objc_msgSend(v27, "unsignedLongLongValue"), v21);
          if (Object)
          {
            v29 = *(_DWORD *)Object;
            v30 = v102;
            if (v29 != 22)
            {
              if (v29 != 80)
                continue;
              v30 = v96;
            }
            objc_msgSend(v30, "addObject:", v27);
          }
        }
        v24 = objc_msgSend(v23, "countByEnumeratingWithState:objects:count:", &v136, v160, 16);
      }
      while (v24);
    }
    v113 = v95[1];
    if (objc_msgSend(v113, "count"))
    {
      newpool = 0;
      apr_pool_create_ex(&newpool, 0, 0, v31);
      pa = newpool;
      v32 = apr_array_make(newpool, 32, 8);
      GTMTLSMContext_getObjects(*(_DWORD **)(v22 + 8), v21, v32);
      if (v32->nelts >= 1)
      {
        v33 = 0;
        do
        {
          v34 = *(_QWORD *)&v32->elts[8 * v33];
          if (v34)
          {
            if (*(_QWORD *)(v34 + 48))
            {
              v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:"));
              v36 = objc_msgSend(v113, "containsObject:", v35);

              if (v36)
              {
                v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v34 + 8)));
                objc_msgSend(v102, "addObject:", v37);

              }
            }
          }
          ++v33;
        }
        while (v33 < v32->nelts);
      }
      v32->nelts = 0;
      GTMTLSMContext_getObjects(*(_DWORD **)(v22 + 16), v21, v32);
      if (v32->nelts >= 1)
      {
        v38 = 0;
        do
        {
          v39 = *(_QWORD *)&v32->elts[8 * v38];
          if (v39)
          {
            if (*(_QWORD *)(v39 + 48))
            {
              v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:"));
              v41 = objc_msgSend(v113, "containsObject:", v40);

              if (v41)
              {
                v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v39 + 8)));
                objc_msgSend(v96, "addObject:", v42);

              }
            }
          }
          ++v38;
        }
        while (v38 < v32->nelts);
      }
      apr_pool_destroy(pa);
    }
    *((_QWORD *)&v99 + 1) = objc_msgSend(v101, "copy");
    v43 = objc_msgSend(v102, "copy");
    *(_QWORD *)&v133 = v43;
    pb = (apr_pool_t *)objc_msgSend(v96, "copy");
    *((_QWORD *)&v133 + 1) = pb;
    *(_QWORD *)&v99 = objc_msgSend(v94, "copy");
    v134 = v99;

  }
  else
  {
    v99 = 0uLL;
    pb = 0;
    v43 = 0;
  }

  v116 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", objc_msgSend(v43, "count"));
  v131 = 0u;
  v132 = 0u;
  v129 = 0u;
  v130 = 0u;
  v44 = v43;
  v45 = objc_msgSend(v44, "countByEnumeratingWithState:objects:count:", &v129, v159, 16);
  if (v45)
  {
    v46 = *(_QWORD *)v130;
    do
    {
      for (m = 0; m != v45; m = (char *)m + 1)
      {
        if (*(_QWORD *)v130 != v46)
          objc_enumerationMutation(v44);
        v48 = objc_msgSend(*(id *)(*((_QWORD *)&v129 + 1) + 8 * (_QWORD)m), "unsignedLongLongValue");
        v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v111, "bufferForKey:", v48));
        v50 = DEVICEOBJECT(v49);
        v51 = (void *)objc_claimAutoreleasedReturnValue(v50);

        if (v51)
        {
          v52 = GTMTLSMContext_getObject(*v109, (uint64_t)v48, v108);
          if (v52)
          {
            v53 = v52;
            v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", objc_msgSend(v51, "gpuAddress")));
            v163[0] = v53[1];
            v55 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(*(_QWORD *)(*find_entry(v107, v163, 8uLL, 0) + 32) + 8));
            v56 = (void *)objc_claimAutoreleasedReturnValue(v55);
            objc_msgSend(v116, "setObject:forKeyedSubscript:", v54, v56);

          }
        }

      }
      v45 = objc_msgSend(v44, "countByEnumeratingWithState:objects:count:", &v129, v159, 16);
    }
    while (v45);
  }

  v114 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", -[apr_pool_t count](pb, "count"));
  v127 = 0u;
  v128 = 0u;
  v125 = 0u;
  v126 = 0u;
  v57 = pb;
  v58 = -[apr_pool_t countByEnumeratingWithState:objects:count:](v57, "countByEnumeratingWithState:objects:count:", &v125, v158, 16);
  if (v58)
  {
    v59 = *(_QWORD *)v126;
    do
    {
      for (n = 0; n != v58; n = (char *)n + 1)
      {
        if (*(_QWORD *)v126 != v59)
          objc_enumerationMutation(v57);
        v61 = objc_msgSend(*(id *)(*((_QWORD *)&v125 + 1) + 8 * (_QWORD)n), "unsignedLongLongValue");
        v62 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v111, "textureForKey:", v61));
        v63 = DEVICEOBJECT(v62);
        v64 = (void *)objc_claimAutoreleasedReturnValue(v63);

        if (v64)
        {
          v65 = GTMTLSMContext_getObject(*v109, (uint64_t)v61, v108);
          if (v65)
          {
            v163[0] = v65[1];
            v66 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(*(_QWORD *)(*find_entry(v107, v163, 8uLL, 0) + 32) + 8));
            v67 = (void *)objc_claimAutoreleasedReturnValue(v66);
            v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v64, "uniqueIdentifier")));
            objc_msgSend(v114, "setObject:forKeyedSubscript:", v67, v68);

          }
        }

      }
      v58 = -[apr_pool_t countByEnumeratingWithState:objects:count:](v57, "countByEnumeratingWithState:objects:count:", &v125, v158, 16);
    }
    while (v58);
  }

  pc = (apr_pool_t *)objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", objc_msgSend((id)v99, "count"));
  v123 = 0u;
  v124 = 0u;
  v121 = 0u;
  v122 = 0u;
  v69 = (id)v99;
  v70 = objc_msgSend(v69, "countByEnumeratingWithState:objects:count:", &v121, v157, 16);
  if (v70)
  {
    v71 = *(_QWORD *)v122;
    do
    {
      for (ii = 0; ii != v70; ii = (char *)ii + 1)
      {
        if (*(_QWORD *)v122 != v71)
          objc_enumerationMutation(v69);
        v73 = objc_msgSend(*(id *)(*((_QWORD *)&v121 + 1) + 8 * (_QWORD)ii), "unsignedLongLongValue");
        v74 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v111, "samplerStateForKey:", v73));
        v75 = DEVICEOBJECT(v74);
        v76 = (void *)objc_claimAutoreleasedReturnValue(v75);

        if (v76)
        {
          v77 = GTMTLSMContext_getObject(*v109, (uint64_t)v73, v108);
          if (v77)
          {
            v163[0] = v77[1];
            v78 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(*(_QWORD *)(*find_entry(v107, v163, 8uLL, 0) + 32) + 8));
            v79 = (void *)objc_claimAutoreleasedReturnValue(v78);
            v80 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v76, "uniqueIdentifier")));
            -[apr_pool_t setObject:forKeyedSubscript:](pc, "setObject:forKeyedSubscript:", v79, v80);

          }
        }

      }
      v70 = objc_msgSend(v69, "countByEnumeratingWithState:objects:count:", &v121, v157, 16);
    }
    while (v70);
  }

  v110 = v95[17];
  v81 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", objc_msgSend(*((id *)&v99 + 1), "count"));
  v82 = v95[21];
  v117 = 0u;
  v118 = 0u;
  v119 = 0u;
  v120 = 0u;
  v83 = *((id *)&v99 + 1);
  v84 = objc_msgSend(v83, "countByEnumeratingWithState:objects:count:", &v117, v156, 16);
  if (v84)
  {
    v85 = *(_QWORD *)v118;
    do
    {
      for (jj = 0; jj != v84; jj = (char *)jj + 1)
      {
        if (*(_QWORD *)v118 != v85)
          objc_enumerationMutation(v83);
        v87 = *(_QWORD *)(*((_QWORD *)&v117 + 1) + 8 * (_QWORD)jj);
        v88 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v82, "objectForKeyedSubscript:", v87));
        v89 = DEVICEOBJECT(v88);
        v90 = (void *)objc_claimAutoreleasedReturnValue(v89);

        if (v90)
        {
          v91 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", objc_msgSend(v90, "gpuAddress")));
          objc_msgSend(v81, "setObject:forKeyedSubscript:", v91, v87);

        }
      }
      v84 = objc_msgSend(v83, "countByEnumeratingWithState:objects:count:", &v117, v156, 16);
    }
    while (v84);
  }

  v154[0] = CFSTR("Bytes");
  v154[1] = CFSTR("Buffers");
  v155[0] = v81;
  v155[1] = v116;
  v154[2] = CFSTR("Textures");
  v154[3] = CFSTR("Samplers");
  v155[2] = v114;
  v155[3] = pc;
  v154[4] = CFSTR("ConstantSamplers");
  v155[4] = v110;
  v92 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v155, v154, 5));

  __destructor_8_s0_s8_s16_s24((id *)&v133);
  return v92;
}

void sub_2DB9AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,id a57)
{
  __destructor_8_s0_s8_s16_s24(&a57);
  _Unwind_Resume(a1);
}

void __destructor_8_s0_s8_s16_s24(id *a1)
{

}

void ShaderDebugger::Metadata::MDSerializer::~MDSerializer(ShaderDebugger::Metadata::MDSerializer *this)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = (_QWORD *)*((_QWORD *)this + 5);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v4)
    operator delete(v4);
  std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::destroy(*((_QWORD **)this + 1));
}

void ShaderDebugger::Metadata::MDSerializer::addReferencedSourceFile(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v6;
  int v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  int8x8_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unint64_t v15;
  unsigned __int8 **v16;
  unsigned __int8 *i;
  unint64_t v18;
  uint64_t v19;
  char *v20;
  const char *v21;
  const char *v22;
  stat *v23;
  char *v24;
  std::string v25;
  int v26;
  size_t __n;
  void *v28;
  void *v29;
  stat v30;

  v6 = (uint64_t *)(a1 + 24);
  v7 = *(char *)(a2 + 23);
  if (v7 >= 0)
    v8 = (uint64_t *)a2;
  else
    v8 = *(uint64_t **)a2;
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(a2 + 23);
  else
    v9 = *(_QWORD *)(a2 + 8);
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  v11 = *(int8x8_t *)(a1 + 32);
  if (v11)
  {
    v12 = v10;
    v13 = (uint8x8_t)vcnt_s8(v11);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v15 = v10;
      if (v10 >= *(_QWORD *)&v11)
        v15 = v10 % *(_QWORD *)&v11;
    }
    else
    {
      v15 = (*(_QWORD *)&v11 - 1) & v10;
    }
    v16 = *(unsigned __int8 ***)(*v6 + 8 * v15);
    if (v16)
    {
      for (i = *v16; i; i = *(unsigned __int8 **)i)
      {
        v18 = *((_QWORD *)i + 1);
        if (v18 == v12)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2))
            return;
        }
        else
        {
          if (v14 > 1)
          {
            if (v18 >= *(_QWORD *)&v11)
              v18 %= *(_QWORD *)&v11;
          }
          else
          {
            v18 &= *(_QWORD *)&v11 - 1;
          }
          if (v18 != v15)
            break;
        }
      }
    }
  }
  v19 = *(unsigned __int8 *)(a3 + 23);
  if ((v19 & 0x80u) != 0)
    v19 = *(_QWORD *)(a3 + 8);
  if (v19)
  {
    v20 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v6, a2, a2);
    std::string::operator=((std::string *)(v20 + 40), (const std::string *)a3);
  }
  else
  {
    memset(&v25, 0, sizeof(v25));
    v26 = -1;
    v28 = 0;
    v29 = 0;
    __n = 0;
    std::string::operator=(&v25, (const std::string *)a2);
    if (*(char *)(a2 + 23) >= 0)
      v21 = (const char *)a2;
    else
      v21 = *(const char **)a2;
    if (!stat(v21, &v30) && (v30.st_mode & 0xF000) == 0x8000)
    {
      __n = v30.st_size;
      if (*(char *)(a2 + 23) >= 0)
        v22 = (const char *)a2;
      else
        v22 = *(const char **)a2;
      v26 = open(v22, 0, 0);
      v28 = mmap(0, __n, 1, 2, v26, 0);
      v29 = v28;
    }
    if (v26 != -1)
    {
      memset(&v30, 0, 24);
      if (__n)
      {
        std::string::resize((std::string *)&v30, __n, 0);
        if ((v30.st_gid & 0x80000000) == 0)
          v23 = &v30;
        else
          v23 = *(stat **)&v30.st_dev;
        memcpy(v23, v28, __n);
      }
      v24 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v6, a2, a2);
      std::string::operator=((std::string *)(v24 + 40), (const std::string *)&v30);
      if (SHIBYTE(v30.st_gid) < 0)
        operator delete(*(void **)&v30.st_dev);
      if (v26 != -1)
      {
        munmap(v28, __n);
        close(v26);
        v26 = -1;
      }
    }
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v25.__r_.__value_.__l.__data_);
  }
}

char *std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  int v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  void **v15;
  char *v16;
  unint64_t v17;
  _QWORD *v18;
  std::string *v19;
  float v20;
  float v21;
  _BOOL8 v22;
  unint64_t v23;
  unint64_t v24;
  int8x8_t prime;
  void *v26;
  void *v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  uint8x8_t v31;
  unint64_t v32;
  uint8x8_t v33;
  uint64_t v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  unint64_t v39;
  void *v41;

  v7 = *(char *)(a2 + 23);
  if (v7 >= 0)
    v8 = (uint64_t *)a2;
  else
    v8 = *(uint64_t **)a2;
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(a2 + 23);
  else
    v9 = *(_QWORD *)(a2 + 8);
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  v11 = v10;
  v12 = a1[1];
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v3 = v10;
      if (v10 >= v12)
        v3 = v10 % v12;
    }
    else
    {
      v3 = (v12 - 1) & v10;
    }
    v15 = *(void ***)(*a1 + 8 * v3);
    if (v15)
    {
      v16 = (char *)*v15;
      if (*v15)
      {
        do
        {
          v17 = *((_QWORD *)v16 + 1);
          if (v17 == v11)
          {
            if (std::equal_to<std::string>::operator()[abi:nn180100]((unsigned __int8 *)v16 + 16, (unsigned __int8 *)a2))
            {
              return v16;
            }
          }
          else
          {
            if (v14 > 1)
            {
              if (v17 >= v12)
                v17 %= v12;
            }
            else
            {
              v17 &= v12 - 1;
            }
            if (v17 != v3)
              break;
          }
          v16 = *(char **)v16;
        }
        while (v16);
      }
    }
  }
  v18 = a1 + 2;
  v16 = (char *)operator new(0x40uLL);
  *(_QWORD *)v16 = 0;
  *((_QWORD *)v16 + 1) = v11;
  v19 = (std::string *)(v16 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((_QWORD *)v16 + 4) = *(_QWORD *)(a3 + 16);
  }
  *((_QWORD *)v16 + 5) = 0;
  *((_QWORD *)v16 + 6) = 0;
  *((_QWORD *)v16 + 7) = 0;
  v20 = (float)(unint64_t)(a1[3] + 1);
  v21 = *((float *)a1 + 8);
  if (!v12 || (float)(v21 * (float)v12) < v20)
  {
    v22 = 1;
    if (v12 >= 3)
      v22 = (v12 & (v12 - 1)) != 0;
    v23 = v22 | (2 * v12);
    v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24)
      prime = (int8x8_t)v24;
    else
      prime = (int8x8_t)v23;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v12 = a1[1];
    if (*(_QWORD *)&prime > v12)
      goto LABEL_39;
    if (*(_QWORD *)&prime < v12)
    {
      v32 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v12 < 3 || (v33 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        v32 = std::__next_prime(v32);
      }
      else
      {
        v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2)
          v32 = v34;
      }
      if (*(_QWORD *)&prime <= v32)
        prime = (int8x8_t)v32;
      if (*(_QWORD *)&prime >= v12)
      {
        v12 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_39:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v26 = operator new(8 * *(_QWORD *)&prime);
          v27 = (void *)*a1;
          *a1 = (uint64_t)v26;
          if (v27)
            operator delete(v27);
          v28 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(_QWORD *)(*a1 + 8 * v28++) = 0;
          while (*(_QWORD *)&prime != v28);
          v29 = (_QWORD *)*v18;
          if (*v18)
          {
            v30 = v29[1];
            v31 = (uint8x8_t)vcnt_s8(prime);
            v31.i16[0] = vaddlv_u8(v31);
            if (v31.u32[0] > 1uLL)
            {
              if (v30 >= *(_QWORD *)&prime)
                v30 %= *(_QWORD *)&prime;
            }
            else
            {
              v30 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*a1 + 8 * v30) = v18;
            v35 = (_QWORD *)*v29;
            if (*v29)
            {
              do
              {
                v36 = v35[1];
                if (v31.u32[0] > 1uLL)
                {
                  if (v36 >= *(_QWORD *)&prime)
                    v36 %= *(_QWORD *)&prime;
                }
                else
                {
                  v36 &= *(_QWORD *)&prime - 1;
                }
                if (v36 != v30)
                {
                  if (!*(_QWORD *)(*a1 + 8 * v36))
                  {
                    *(_QWORD *)(*a1 + 8 * v36) = v29;
                    goto LABEL_64;
                  }
                  *v29 = *v35;
                  *v35 = **(_QWORD **)(*a1 + 8 * v36);
                  **(_QWORD **)(*a1 + 8 * v36) = v35;
                  v35 = v29;
                }
                v36 = v30;
LABEL_64:
                v29 = v35;
                v35 = (_QWORD *)*v35;
                v30 = v36;
              }
              while (v35);
            }
          }
          v12 = (unint64_t)prime;
          goto LABEL_68;
        }
        v41 = (void *)*a1;
        *a1 = 0;
        if (v41)
          operator delete(v41);
        v12 = 0;
        a1[1] = 0;
      }
    }
LABEL_68:
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v3 = v11 % v12;
      else
        v3 = v11;
    }
    else
    {
      v3 = (v12 - 1) & v11;
    }
  }
  v37 = *a1;
  v38 = *(_QWORD **)(*a1 + 8 * v3);
  if (v38)
  {
    *(_QWORD *)v16 = *v38;
LABEL_81:
    *v38 = v16;
    goto LABEL_82;
  }
  *(_QWORD *)v16 = *v18;
  *v18 = v16;
  *(_QWORD *)(v37 + 8 * v3) = v18;
  if (*(_QWORD *)v16)
  {
    v39 = *(_QWORD *)(*(_QWORD *)v16 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v39 >= v12)
        v39 %= v12;
    }
    else
    {
      v39 &= v12 - 1;
    }
    v38 = (_QWORD *)(*a1 + 8 * v39);
    goto LABEL_81;
  }
LABEL_82:
  ++a1[3];
  return v16;
}

void ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(unint64_t *a1, _BYTE *a2)
{
  _BYTE *v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  unint64_t v9;
  _BYTE *v10;
  unint64_t v11;
  unint64_t v12;
  size_t v13;
  char *v14;
  char *v15;
  _BYTE *v16;
  _BYTE *v17;
  char v18;

  v4 = (_BYTE *)a1[1];
  v5 = a1[2] - *a1;
  if (v5 < (unint64_t)&v4[-*a1 + 8])
  {
    std::vector<unsigned char>::reserve(a1, (2 * v5) | 1);
    v4 = (_BYTE *)a1[1];
  }
  v6 = 8;
  do
  {
    v7 = a1[2];
    if ((unint64_t)v4 >= v7)
    {
      v9 = *a1;
      v10 = &v4[-*a1];
      v11 = (unint64_t)(v10 + 1);
      if ((uint64_t)(v10 + 1) < 0)
        abort();
      v12 = v7 - v9;
      if (2 * v12 > v11)
        v11 = 2 * v12;
      if (v12 >= 0x3FFFFFFFFFFFFFFFLL)
        v13 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v13 = v11;
      if (v13)
        v14 = (char *)operator new(v13);
      else
        v14 = 0;
      v15 = &v10[(_QWORD)v14];
      v16 = &v10[(_QWORD)v14];
      *v16 = *a2;
      v8 = v16 + 1;
      if (v4 != (_BYTE *)v9)
      {
        v17 = &v4[~v9];
        do
        {
          v18 = *--v4;
          (v17--)[(_QWORD)v14] = v18;
        }
        while (v4 != (_BYTE *)v9);
        v4 = (_BYTE *)*a1;
        v15 = v14;
      }
      *a1 = (unint64_t)v15;
      a1[1] = (unint64_t)v8;
      a1[2] = (unint64_t)&v14[v13];
      if (v4)
        operator delete(v4);
    }
    else
    {
      *v4 = *a2;
      v8 = v4 + 1;
    }
    ++a2;
    a1[1] = (unint64_t)v8;
    v4 = v8;
    --v6;
  }
  while (v6);
}

void ShaderDebugger::Metadata::MDSerializer::write(unint64_t *a1, _BYTE *a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v6;
  _BYTE *v7;
  unint64_t v8;
  _BYTE *v9;
  unint64_t v10;
  _BYTE *v11;
  unint64_t v12;
  unint64_t v13;
  size_t v14;
  char *v15;
  char *v16;
  _BYTE *v17;
  _BYTE *v18;
  char v19;

  v3 = a3;
  v6 = a1[2] - *a1;
  if (v6 < a3 - *a1 + a1[1])
    std::vector<unsigned char>::reserve(a1, (2 * v6) | 1);
  if (v3)
  {
    v7 = (_BYTE *)a1[1];
    do
    {
      v8 = a1[2];
      if ((unint64_t)v7 >= v8)
      {
        v10 = *a1;
        v11 = &v7[-*a1];
        v12 = (unint64_t)(v11 + 1);
        if ((uint64_t)(v11 + 1) < 0)
          abort();
        v13 = v8 - v10;
        if (2 * v13 > v12)
          v12 = 2 * v13;
        if (v13 >= 0x3FFFFFFFFFFFFFFFLL)
          v14 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v14 = v12;
        if (v14)
          v15 = (char *)operator new(v14);
        else
          v15 = 0;
        v16 = &v11[(_QWORD)v15];
        v17 = &v11[(_QWORD)v15];
        *v17 = *a2;
        v9 = v17 + 1;
        if (v7 != (_BYTE *)v10)
        {
          v18 = &v7[~v10];
          do
          {
            v19 = *--v7;
            (v18--)[(_QWORD)v15] = v19;
          }
          while (v7 != (_BYTE *)v10);
          v7 = (_BYTE *)*a1;
          v16 = v15;
        }
        *a1 = (unint64_t)v16;
        a1[1] = (unint64_t)v9;
        a1[2] = (unint64_t)&v15[v14];
        if (v7)
          operator delete(v7);
      }
      else
      {
        *v7 = *a2;
        v9 = v7 + 1;
      }
      ++a2;
      a1[1] = (unint64_t)v9;
      v7 = v9;
      --v3;
    }
    while (v3);
  }
}

void std::vector<unsigned char>::reserve(unint64_t *a1, size_t __sz)
{
  unint64_t v2;
  char *v5;
  _BYTE *v6;
  char *v7;
  _BYTE *v8;
  char *v9;
  char v10;

  v2 = *a1;
  if (a1[2] - *a1 < __sz)
  {
    if ((__sz & 0x8000000000000000) != 0)
      abort();
    v5 = (char *)a1[1];
    v6 = operator new(__sz);
    v7 = &v5[(_QWORD)v6 - v2];
    v8 = v7;
    if (v5 != (char *)v2)
    {
      v9 = &v5[~v2];
      do
      {
        v10 = *--v5;
        (v9--)[(_QWORD)v6] = v10;
      }
      while (v5 != (char *)v2);
      v8 = v6;
    }
    *a1 = (unint64_t)v8;
    a1[1] = (unint64_t)v7;
    a1[2] = (unint64_t)&v6[__sz];
    if (v2)
      operator delete((void *)v2);
  }
}

uint64_t ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(uint64_t a1, uint64_t a2)
{
  int isMetadataIdReserved;
  char *v5;
  char *v6;
  char *v7;
  unint64_t v8;
  int v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  BOOL v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  char v22;

  isMetadataIdReserved = ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)a1, a2);
  v5 = *(char **)a1;
  v6 = *(char **)(a1 + 8);
  v7 = *(char **)a1;
  if (*(char **)a1 != v6)
  {
    v7 = *(char **)a1;
    while (*(_QWORD *)v7 != a2)
    {
      v7 += 8;
      if (v7 == v6)
      {
        v7 = *(char **)(a1 + 8);
        break;
      }
    }
  }
  if (v7 == v6)
    v8 = -1;
  else
    v8 = (v7 - v5) >> 3;
  if (v8 == -1)
    v9 = 1;
  else
    v9 = isMetadataIdReserved;
  if (v9 != 1)
    return -1;
  if (!isMetadataIdReserved)
  {
    v10 = *(_QWORD *)(a1 + 16);
    if ((unint64_t)v6 >= v10)
    {
      v12 = (v6 - v5) >> 3;
      v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61)
LABEL_34:
        abort();
      v14 = v10 - (_QWORD)v5;
      if (v14 >> 2 > v13)
        v13 = v14 >> 2;
      v15 = (unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8;
      v16 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v15)
        v16 = v13;
      if (v16)
      {
        v16 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v16);
        v5 = *(char **)a1;
        v6 = *(char **)(a1 + 8);
      }
      else
      {
        v17 = 0;
      }
      v18 = (uint64_t *)(v16 + 8 * v12);
      v19 = v16 + 8 * v17;
      *v18 = a2;
      v11 = v18 + 1;
      while (v6 != v5)
      {
        v20 = *((_QWORD *)v6 - 1);
        v6 -= 8;
        *--v18 = v20;
      }
      *(_QWORD *)a1 = v18;
      *(_QWORD *)(a1 + 8) = v11;
      *(_QWORD *)(a1 + 16) = v19;
      if (v5)
        operator delete(v5);
    }
    else
    {
      *(_QWORD *)v6 = a2;
      v11 = v6 + 8;
    }
    *(_QWORD *)(a1 + 8) = v11;
    v22 = 0;
    std::vector<BOOL>::push_back((uint64_t *)(a1 + 24), &v22);
    return ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3) - 1;
  }
  if (*(_QWORD *)(a1 + 32) <= v8)
    goto LABEL_34;
  *(_QWORD *)(*(_QWORD *)(a1 + 24) + ((v8 >> 3) & 0x1FFFFFFFFFFFFFF8)) &= ~(1 << v8);
  return v8;
}

uint64_t ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved(char **a1, uint64_t a2)
{
  char *v2;
  char *v3;
  char *v4;
  unint64_t v5;
  unint64_t v6;

  v2 = *a1;
  v3 = a1[1];
  v4 = *a1;
  if (*a1 != v3)
  {
    while (*(_QWORD *)v4 != a2)
    {
      v4 += 8;
      if (v4 == v3)
      {
        v4 = a1[1];
        break;
      }
    }
  }
  if (v4 == v3)
    return 0;
  v5 = v4 - v2;
  v6 = (v4 - v2) >> 3;
  if ((unint64_t)a1[4] <= v6)
    abort();
  return (*(_QWORD *)&a1[3][(v6 >> 3) & 0x1FFFFFFFFFFFFFF8] >> (v5 >> 3)) & 1;
}

uint64_t ShaderDebugger::Metadata::MDSerializer::serializeLocation(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  char *v10;
  char *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  _BYTE *v20;
  unint64_t *v21;
  _BYTE *v22;
  _BYTE *v23;
  int v24;
  _BYTE *v25;
  size_t v26;
  std::string *v27;
  const void *v28;
  int v29;
  const std::string::value_type *v30;
  std::string::size_type v31;
  std::string *v32;
  std::string::size_type v33;
  char v34;
  std::string *p_str;
  std::string::size_type size;
  int v37;
  std::string::size_type v38;
  std::string::size_type v39;
  std::string *v40;
  int v41;
  std::string::size_type v42;
  void *v43;
  std::string *v44;
  std::string::size_type v45;
  std::string *v46;
  std::string::size_type v47;
  std::string::size_type v48;
  char v49;
  std::string v51;
  std::string v52;
  std::string v53;
  std::string __str;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  __int128 v58;
  uint64_t v59;

  v57 = a5;
  v56 = a6;
  __str.__r_.__value_.__r.__words[0] = 1;
  v10 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>(a1, 1uLL, &__str);
  v11 = v10;
  v13 = (uint64_t)(v10 + 40);
  v12 = (_QWORD *)*((_QWORD *)v10 + 5);
  v14 = (_QWORD *)*((_QWORD *)v10 + 6);
  v15 = v12;
  if (v12 != v14)
  {
    while (*v15 != a2)
    {
      if (++v15 == v14)
      {
        v15 = (_QWORD *)*((_QWORD *)v10 + 6);
        break;
      }
    }
  }
  v16 = v15 - v12;
  if (v15 == v14)
    v17 = -1;
  else
    v17 = v16;
  if (v17 == -1 || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v10 + 5, a2))
  {
    v17 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v13, a2);
    v55 = v17;
    if (*(char *)(a3 + 23) < 0)
      std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
    else
      __str = *(std::string *)a3;
    if (*(char *)(a4 + 23) < 0)
      std::string::__init_copy_ctor_external(&v53, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
    else
      v53 = *(std::string *)a4;
    v18 = *(char *)(a3 + 23);
    if (v18 < 0)
    {
      std::string::__init_copy_ctor_external(&v52, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
      v18 = *(char *)(a3 + 23);
      if (v18 < 0)
      {
        v20 = *(_BYTE **)a3;
        v19 = *(_QWORD *)(a3 + 8);
        goto LABEL_20;
      }
    }
    else
    {
      v52 = *(std::string *)a3;
    }
    v19 = v18;
    v20 = (_BYTE *)a3;
LABEL_20:
    v21 = (unint64_t *)(v11 + 88);
    if (v19)
    {
      v22 = &v20[v19];
      v23 = v20;
      while (*v23 != 47)
      {
        ++v23;
        if (!--v19)
          goto LABEL_27;
      }
      if (v23 != v22 && v23 == v20)
      {
LABEL_56:
        p_str = &__str;
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
        size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          size = __str.__r_.__value_.__l.__size_;
        while (size)
        {
          v37 = p_str->__r_.__value_.__s.__data_[--size];
          if (v37 == 47)
          {
            if (size != -1)
            {
              v38 = size + 1;
              std::string::basic_string(&v51, &__str, 0, size + 1, (std::allocator<char> *)&v58);
              if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v53.__r_.__value_.__l.__data_);
              v53 = v51;
              std::string::basic_string(&v51, &__str, v38, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v58);
              if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v52.__r_.__value_.__l.__data_);
              v52 = v51;
            }
            break;
          }
        }
        if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
        {
          v39 = v53.__r_.__value_.__l.__size_;
          if (!v53.__r_.__value_.__l.__size_)
            goto LABEL_75;
          v40 = (std::string *)v53.__r_.__value_.__r.__words[0];
        }
        else
        {
          v39 = HIBYTE(v53.__r_.__value_.__r.__words[2]);
          if (!*((_BYTE *)&v53.__r_.__value_.__s + 23))
            goto LABEL_75;
          v40 = &v53;
        }
        if (v40->__r_.__value_.__s.__data_[v39 - 1] != 47)
          std::string::append(&v53, "/");
LABEL_75:
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(v21, &v55);
        v41 = SHIBYTE(v52.__r_.__value_.__r.__words[2]);
        if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v42 = HIBYTE(v52.__r_.__value_.__r.__words[2]);
        else
          v42 = v52.__r_.__value_.__l.__size_;
        v51.__r_.__value_.__r.__words[0] = v42;
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(v21, &v51);
        v43 = (void *)v52.__r_.__value_.__r.__words[0];
        if (v41 >= 0)
          v44 = &v52;
        else
          v44 = (std::string *)v52.__r_.__value_.__r.__words[0];
        ShaderDebugger::Metadata::MDSerializer::write(v21, v44, v42);
        v45 = HIBYTE(v53.__r_.__value_.__r.__words[2]);
        if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v45 = v53.__r_.__value_.__l.__size_;
        v51.__r_.__value_.__r.__words[0] = v45;
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(v21, &v51);
        if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v46 = &v53;
        else
          v46 = (std::string *)v53.__r_.__value_.__r.__words[0];
        if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v47 = HIBYTE(v53.__r_.__value_.__r.__words[2]);
        else
          v47 = v53.__r_.__value_.__l.__size_;
        ShaderDebugger::Metadata::MDSerializer::write(v21, v46, v47);
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(v21, &v57);
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(v21, &v56);
        std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>((uint64_t)&v51, (const void **)&v53.__r_.__value_.__l.__data_, (const void **)&v52.__r_.__value_.__l.__data_);
        v48 = HIBYTE(v51.__r_.__value_.__r.__words[2]);
        v49 = HIBYTE(v51.__r_.__value_.__r.__words[2]);
        if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v48 = v51.__r_.__value_.__l.__size_;
        if (v48)
        {
          v58 = 0uLL;
          v59 = 0;
          ShaderDebugger::Metadata::MDSerializer::addReferencedSourceFile((uint64_t)a1, (uint64_t)&v51, (uint64_t)&v58);
          if (SHIBYTE(v59) < 0)
            operator delete((void *)v58);
          v49 = HIBYTE(v51.__r_.__value_.__r.__words[2]);
        }
        if (v49 < 0)
        {
          operator delete(v51.__r_.__value_.__l.__data_);
          if ((v41 & 0x80000000) == 0)
            goto LABEL_97;
        }
        else if ((v41 & 0x80000000) == 0)
        {
LABEL_97:
          if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v53.__r_.__value_.__l.__data_);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__str.__r_.__value_.__l.__data_);
          return v17;
        }
        operator delete(v43);
        goto LABEL_97;
      }
    }
LABEL_27:
    v24 = *(unsigned __int8 *)(a4 + 23);
    if (*(char *)(a4 + 23) < 0)
    {
      if (*(_QWORD *)(a4 + 8) != 1)
      {
LABEL_36:
        if ((v24 & 0x80u) == 0)
          v26 = *(unsigned __int8 *)(a4 + 23);
        else
          v26 = *(_QWORD *)(a4 + 8);
        v27 = &v51;
        std::string::basic_string[abi:nn180100]((uint64_t)&v51, v26 + 1);
        if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v27 = (std::string *)v51.__r_.__value_.__r.__words[0];
        if (v26)
        {
          if (*(char *)(a4 + 23) >= 0)
            v28 = (const void *)a4;
          else
            v28 = *(const void **)a4;
          memmove(v27, v28, v26);
        }
        *(_WORD *)((char *)&v27->__r_.__value_.__l.__data_ + v26) = 47;
        v29 = *(char *)(a3 + 23);
        if (v29 >= 0)
          v30 = (const std::string::value_type *)a3;
        else
          v30 = *(const std::string::value_type **)a3;
        if (v29 >= 0)
          v31 = *(unsigned __int8 *)(a3 + 23);
        else
          v31 = *(_QWORD *)(a3 + 8);
        v32 = std::string::append(&v51, v30, v31);
        v33 = v32->__r_.__value_.__r.__words[0];
        *(_QWORD *)&v58 = v32->__r_.__value_.__l.__size_;
        *(_QWORD *)((char *)&v58 + 7) = *(std::string::size_type *)((char *)&v32->__r_.__value_.__r.__words[1] + 7);
        v34 = HIBYTE(v32->__r_.__value_.__r.__words[2]);
        v32->__r_.__value_.__l.__size_ = 0;
        v32->__r_.__value_.__r.__words[2] = 0;
        v32->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__str.__r_.__value_.__l.__data_);
        __str.__r_.__value_.__r.__words[0] = v33;
        __str.__r_.__value_.__l.__size_ = v58;
        *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 7) = *(_QWORD *)((char *)&v58 + 7);
        *((_BYTE *)&__str.__r_.__value_.__s + 23) = v34;
        if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v51.__r_.__value_.__l.__data_);
        goto LABEL_56;
      }
      v25 = *(_BYTE **)a4;
    }
    else
    {
      v25 = (_BYTE *)a4;
      if (v24 != 1)
        goto LABEL_36;
    }
    if (*v25 == 47)
    {
      std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>((uint64_t)&v51, (const void **)a4, (const void **)a3);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__str.__r_.__value_.__l.__data_);
      __str = v51;
      goto LABEL_56;
    }
    goto LABEL_36;
  }
  return v17;
}

uint64_t std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(uint64_t a1, const void **a2, const void **a3)
{
  size_t v5;
  size_t v6;
  uint64_t result;
  char *v8;
  const void *v9;
  char *v10;
  const void *v11;

  if (*((char *)a2 + 23) >= 0)
    v5 = *((unsigned __int8 *)a2 + 23);
  else
    v5 = (size_t)a2[1];
  if (*((char *)a3 + 23) >= 0)
    v6 = *((unsigned __int8 *)a3 + 23);
  else
    v6 = (size_t)a3[1];
  result = std::string::basic_string[abi:nn180100](a1, v6 + v5);
  if (*(char *)(result + 23) >= 0)
    v8 = (char *)result;
  else
    v8 = *(char **)result;
  if (v5)
  {
    if (*((char *)a2 + 23) >= 0)
      v9 = a2;
    else
      v9 = *a2;
    result = (uint64_t)memmove(v8, v9, v5);
  }
  v10 = &v8[v5];
  if (v6)
  {
    if (*((char *)a3 + 23) >= 0)
      v11 = a3;
    else
      v11 = *a3;
    result = (uint64_t)memmove(v10, v11, v6);
  }
  v10[v6] = 0;
  return result;
}

uint64_t ShaderDebugger::Metadata::MDSerializer::serializeSubprogram(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v6;
  char *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v20 = a4;
  v21 = 0;
  v6 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>(a1, 0, &v21);
  v7 = v6;
  v9 = (uint64_t)(v6 + 40);
  v8 = (_QWORD *)*((_QWORD *)v6 + 5);
  v10 = (_QWORD *)*((_QWORD *)v6 + 6);
  v11 = v8;
  if (v8 != v10)
  {
    while (*v11 != a2)
    {
      if (++v11 == v10)
      {
        v11 = (_QWORD *)*((_QWORD *)v6 + 6);
        break;
      }
    }
  }
  v12 = v11 - v8;
  if (v11 == v10)
    v13 = -1;
  else
    v13 = v12;
  if (v13 == -1 || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v6 + 5, a2))
  {
    v13 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v9, a2);
    v19 = v13;
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v7 + 11, &v19);
    v14 = *(unsigned __int8 *)(a3 + 23);
    if ((v14 & 0x80u) != 0)
      v14 = *(_QWORD *)(a3 + 8);
    v21 = v14;
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v7 + 11, &v21);
    v15 = *(char *)(a3 + 23);
    if (v15 >= 0)
      v16 = (_BYTE *)a3;
    else
      v16 = *(_BYTE **)a3;
    if (v15 >= 0)
      v17 = *(unsigned __int8 *)(a3 + 23);
    else
      v17 = *(_QWORD *)(a3 + 8);
    ShaderDebugger::Metadata::MDSerializer::write((unint64_t *)v7 + 11, v16, v17);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v7 + 11, &v20);
  }
  return v13;
}

void ShaderDebugger::Metadata::MDSerializer::serializeFunctionTracepoint(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v20 = a5;
  v21 = a3;
  v18 = -1;
  v19 = a6;
  v17 = 6;
  v8 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>(a1, 6uLL, &v17);
  v9 = v8;
  v11 = (uint64_t)(v8 + 40);
  v10 = (char *)*((_QWORD *)v8 + 5);
  v12 = (char *)*((_QWORD *)v8 + 6);
  v13 = v10;
  if (v10 != v12)
  {
    while (*(_QWORD *)v13 != a2)
    {
      v13 += 8;
      if (v13 == v12)
      {
        v13 = (char *)*((_QWORD *)v8 + 6);
        break;
      }
    }
  }
  v14 = (char *)(v13 - v10);
  v15 = v13 == v12 || v14 + 8 == 0;
  if (v15 || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v8 + 5, a2))
  {
    v17 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v11, a2);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v9 + 11, &v17);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v9 + 11, &v21);
    v16 = a4;
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v9 + 11, &v16);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v9 + 11, &v20);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v9 + 11, &v19);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v9 + 11, &v18);
  }
}

void ShaderDebugger::Metadata::MDSerializer::write<unsigned int>(unint64_t *a1, _BYTE *a2)
{
  _BYTE *v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  unint64_t v9;
  _BYTE *v10;
  unint64_t v11;
  unint64_t v12;
  size_t v13;
  char *v14;
  char *v15;
  _BYTE *v16;
  _BYTE *v17;
  char v18;

  v4 = (_BYTE *)a1[1];
  v5 = a1[2] - *a1;
  if (v5 < (unint64_t)&v4[-*a1 + 4])
  {
    std::vector<unsigned char>::reserve(a1, (2 * v5) | 1);
    v4 = (_BYTE *)a1[1];
  }
  v6 = 4;
  do
  {
    v7 = a1[2];
    if ((unint64_t)v4 >= v7)
    {
      v9 = *a1;
      v10 = &v4[-*a1];
      v11 = (unint64_t)(v10 + 1);
      if ((uint64_t)(v10 + 1) < 0)
        abort();
      v12 = v7 - v9;
      if (2 * v12 > v11)
        v11 = 2 * v12;
      if (v12 >= 0x3FFFFFFFFFFFFFFFLL)
        v13 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v13 = v11;
      if (v13)
        v14 = (char *)operator new(v13);
      else
        v14 = 0;
      v15 = &v10[(_QWORD)v14];
      v16 = &v10[(_QWORD)v14];
      *v16 = *a2;
      v8 = v16 + 1;
      if (v4 != (_BYTE *)v9)
      {
        v17 = &v4[~v9];
        do
        {
          v18 = *--v4;
          (v17--)[(_QWORD)v14] = v18;
        }
        while (v4 != (_BYTE *)v9);
        v4 = (_BYTE *)*a1;
        v15 = v14;
      }
      *a1 = (unint64_t)v15;
      a1[1] = (unint64_t)v8;
      a1[2] = (unint64_t)&v14[v13];
      if (v4)
        operator delete(v4);
    }
    else
    {
      *v4 = *a2;
      v8 = v4 + 1;
    }
    ++a2;
    a1[1] = (unint64_t)v8;
    v4 = v8;
    --v6;
  }
  while (v6);
}

void ShaderDebugger::Metadata::MDSerializer::serializeVariableBase(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  int v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v14 = a4;
  v15 = a2;
  v13 = a5;
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v15);
  v9 = *(unsigned __int8 *)(a3 + 23);
  if ((v9 & 0x80u) != 0)
    v9 = *(_QWORD *)(a3 + 8);
  v16 = v9;
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v16);
  v10 = *(char *)(a3 + 23);
  if (v10 >= 0)
    v11 = (_BYTE *)a3;
  else
    v11 = *(_BYTE **)a3;
  if (v10 >= 0)
    v12 = *(unsigned __int8 *)(a3 + 23);
  else
    v12 = *(_QWORD *)(a3 + 8);
  ShaderDebugger::Metadata::MDSerializer::write(a1, v11, v12);
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v14);
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v13);
  v16 = a6;
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v16);
}

uint64_t ShaderDebugger::Metadata::MDSerializer::serializeLocalVariable(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  char *v11;
  unint64_t *v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  _BYTE *v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  _BYTE *v25;
  unint64_t v26;
  unint64_t v27;
  size_t v28;
  unint64_t v29;
  char *v30;
  _BYTE *v31;
  char v32;
  uint64_t v34;

  v34 = 2;
  v11 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>(a1, 2uLL, &v34);
  v12 = (unint64_t *)v11;
  v14 = (uint64_t)(v11 + 40);
  v13 = (_QWORD *)*((_QWORD *)v11 + 5);
  v15 = (_QWORD *)*((_QWORD *)v11 + 6);
  v16 = v13;
  if (v13 != v15)
  {
    while (*v16 != a2)
    {
      if (++v16 == v15)
      {
        v16 = (_QWORD *)*((_QWORD *)v11 + 6);
        break;
      }
    }
  }
  v17 = v16 - v13;
  if (v16 == v15)
    v18 = -1;
  else
    v18 = v17;
  if (v18 == -1 || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v11 + 5, a2))
  {
    v18 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v14, a2);
    v19 = v12 + 11;
    ShaderDebugger::Metadata::MDSerializer::serializeVariableBase(v12 + 11, v18, a3, a4, a5, 0);
    v21 = (_BYTE *)v12[12];
    v20 = v12[13];
    v22 = v12[11];
    if (v20 - v22 < (unint64_t)&v21[-v22 + 1])
    {
      std::vector<unsigned char>::reserve(v12 + 11, (2 * (v20 - v22)) | 1);
      v21 = (_BYTE *)v12[12];
      v20 = v12[13];
    }
    if ((unint64_t)v21 >= v20)
    {
      v24 = *v19;
      v25 = &v21[-*v19];
      v26 = (unint64_t)(v25 + 1);
      if ((uint64_t)(v25 + 1) < 0)
        abort();
      v27 = v20 - v24;
      if (2 * v27 > v26)
        v26 = 2 * v27;
      if (v27 >= 0x3FFFFFFFFFFFFFFFLL)
        v28 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v28 = v26;
      if (v28)
        v29 = (unint64_t)operator new(v28);
      else
        v29 = 0;
      v30 = (char *)(v29 + v28);
      v25[v29] = a6;
      v23 = (uint64_t)&v25[v29 + 1];
      if (v21 == (_BYTE *)v24)
      {
        v29 += (unint64_t)v25;
      }
      else
      {
        v31 = &v21[~v24];
        do
        {
          v32 = *--v21;
          (v31--)[v29] = v32;
        }
        while (v21 != (_BYTE *)v24);
        v21 = (_BYTE *)*v19;
      }
      v12[11] = v29;
      v12[12] = v23;
      v12[13] = (unint64_t)v30;
      if (v21)
        operator delete(v21);
    }
    else
    {
      *v21 = a6;
      v23 = (uint64_t)(v21 + 1);
    }
    v12[12] = v23;
  }
  return v18;
}

uint64_t ShaderDebugger::Metadata::MDSerializer::serializeGlobalVariable(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  char *v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;

  v18 = 2;
  v9 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>(a1, 2uLL, &v18);
  v10 = v9;
  v12 = (uint64_t)(v9 + 40);
  v11 = (_QWORD *)*((_QWORD *)v9 + 5);
  v13 = (_QWORD *)*((_QWORD *)v9 + 6);
  v14 = v11;
  if (v11 != v13)
  {
    while (*v14 != a2)
    {
      if (++v14 == v13)
      {
        v14 = (_QWORD *)*((_QWORD *)v9 + 6);
        break;
      }
    }
  }
  v15 = v14 - v11;
  if (v14 == v13)
    v16 = -1;
  else
    v16 = v15;
  if (v16 == -1 || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v9 + 5, a2))
  {
    v16 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v12, a2);
    ShaderDebugger::Metadata::MDSerializer::serializeVariableBase((unint64_t *)v10 + 11, v16, a3, a4, a5, 1);
  }
  return v16;
}

void ShaderDebugger::Metadata::MDSerializer::serializeTypeBase(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, uint64_t a9)
{
  uint64_t v12;
  int v13;
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v19 = a4;
  v20 = a2;
  v17 = a6;
  v18 = a5;
  v16 = a7;
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v20);
  v12 = *(unsigned __int8 *)(a3 + 23);
  if ((v12 & 0x80u) != 0)
    v12 = *(_QWORD *)(a3 + 8);
  v21 = v12;
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v21);
  v13 = *(char *)(a3 + 23);
  if (v13 >= 0)
    v14 = (_BYTE *)a3;
  else
    v14 = *(_BYTE **)a3;
  if (v13 >= 0)
    v15 = *(unsigned __int8 *)(a3 + 23);
  else
    v15 = *(_QWORD *)(a3 + 8);
  ShaderDebugger::Metadata::MDSerializer::write(a1, v14, v15);
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v19);
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v18);
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v17);
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v16);
  v21 = a8;
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v21);
  v21 = a9;
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v21);
}

void sub_2DD688(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2DD894(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2DD928(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_2DDA58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_2DDAFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_2DDD20(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2DE160(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2DE280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_2DE424(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_2DE56C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_2DE788(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2DE9E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2DEA74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_2DEC48(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2DF1C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2DF338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_2DF410(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_2DF49C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_2DF4E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_2DF5C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void _GTShaderProfilerStreamDataFromReplayDataSource(GTMTLReplayDataSource const*,apr_pool_t *)::$_0::operator()(unint64_t **a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;
  _QWORD *v7;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *Object;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char **v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  unint64_t v20;
  int v21;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  int v27;
  unint64_t *v28;
  _QWORD *v29;
  _QWORD *v30;
  int v31;
  uint64_t v32;
  unint64_t v33;
  _QWORD *v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  char *v38;
  char *v39;
  __int128 v40;
  __int128 v41;
  int v42;

  v6 = **a1;
  v7 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(a1[2], v6);
  if (v6 == -1 || v7 != 0)
  {
    *(_DWORD *)a1[1] = v7[3];
    return;
  }
  v9 = *a1[4];
  v10 = *(_QWORD *)(v9 + 80) + a2;
  v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[3][1] - *a1[3]) >> 4);
  if (a3 != 4294950959)
  {
    if (a3 != 4294951017)
      goto LABEL_17;
    Object = GTMTLSMContext_getObject(**(_QWORD **)(v9 + 40), v6, v10);
    v13 = Object[6];
    if (v13)
    {
      AddFunctionIfExist(*a1[4], (char **)a1[3], *(_QWORD *)(v13 + 1296), v10, (void *)*a1[5], 1);
      AddFunctionIfExist(*a1[4], (char **)a1[3], *(_QWORD *)(Object[6] + 1176), v10, (void *)*a1[5], 2);
    }
    v14 = Object[8];
    if (v14)
      AddFunctionIfExist(*a1[4], (char **)a1[3], *(_QWORD *)(v14 + 120), v10, (void *)*a1[5], 3);
    v15 = Object[9];
    if (!v15)
      goto LABEL_17;
    AddFunctionIfExist(*a1[4], (char **)a1[3], *(_QWORD *)(v15 + 360), v10, (void *)*a1[5], 7);
    v16 = (char **)a1[3];
    v17 = *a1[4];
    v18 = *(_QWORD *)(Object[9] + 368);
    v19 = (void *)*a1[5];
    v20 = v10;
    v21 = 8;
    goto LABEL_16;
  }
  v22 = GTMTLSMContext_getObject(**(_QWORD **)(v9 + 40), v6, v10);
  AddFunctionIfExist(*a1[4], (char **)a1[3], v22[6], v10, (void *)*a1[5], 3);
  v23 = v22[7];
  if (v23)
  {
    v16 = (char **)a1[3];
    v17 = *a1[4];
    v18 = *(_QWORD *)(v23 + 848);
    v19 = (void *)*a1[5];
    v20 = v10;
    v21 = 3;
LABEL_16:
    AddFunctionIfExist(v17, v16, v18, v20, v19, v21);
  }
LABEL_17:
  v24 = **a1;
  v25 = *(_QWORD *)(*(_QWORD *)(*find_entry(*(_QWORD *)(*a1[4] + 8), *a1, 8uLL, 0) + 32) + 8);
  v26 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a1[6][1] - *a1[6]) >> 3);
  v27 = -1431655765 * ((a1[3][1] - *a1[3]) >> 4) - v11;
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)a1[2], **a1, *a1)[3] = v26;
  v28 = a1[6];
  v30 = (_QWORD *)*v28;
  v29 = (_QWORD *)v28[1];
  v31 = v11;
  v32 = (uint64_t)((uint64_t)v29 - *v28) / 40;
  *(_DWORD *)a1[1] = v32;
  v33 = v28[2];
  if ((unint64_t)v29 >= v33)
  {
    v42 = v31;
    v35 = v32 + 1;
    if ((unint64_t)(v32 + 1) > 0x666666666666666)
      abort();
    v36 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v33 - (_QWORD)v30) >> 3);
    if (2 * v36 > v35)
      v35 = 2 * v36;
    if (v36 >= 0x333333333333333)
      v37 = 0x666666666666666;
    else
      v37 = v35;
    if (v37)
    {
      if (v37 > 0x666666666666666)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v38 = (char *)operator new(40 * v37);
    }
    else
    {
      v38 = 0;
    }
    v39 = &v38[40 * v32];
    *(_QWORD *)v39 = v24;
    *((_QWORD *)v39 + 1) = v25;
    *((_QWORD *)v39 + 2) = a2;
    *((_DWORD *)v39 + 6) = v26;
    *((_DWORD *)v39 + 7) = 0;
    *((_DWORD *)v39 + 8) = v42;
    *((_DWORD *)v39 + 9) = v27;
    v34 = v39 + 40;
    if (v29 != v30)
    {
      do
      {
        v40 = *(_OWORD *)(v29 - 5);
        v41 = *(_OWORD *)(v29 - 3);
        *((_QWORD *)v39 - 1) = *(v29 - 1);
        *(_OWORD *)(v39 - 24) = v41;
        *(_OWORD *)(v39 - 40) = v40;
        v39 -= 40;
        v29 -= 5;
      }
      while (v29 != v30);
      v29 = (_QWORD *)*v28;
    }
    *v28 = (unint64_t)v39;
    v28[1] = (unint64_t)v34;
    v28[2] = (unint64_t)&v38[40 * v37];
    if (v29)
      operator delete(v29);
  }
  else
  {
    *v29 = v24;
    v29[1] = v25;
    v29[2] = a2;
    *((_DWORD *)v29 + 6) = v26;
    *((_DWORD *)v29 + 7) = 0;
    v34 = v29 + 5;
    *((_DWORD *)v29 + 8) = v31;
    *((_DWORD *)v29 + 9) = v27;
  }
  v28[1] = (unint64_t)v34;
}

void AddFunctionIfExist(uint64_t a1, char **a2, uint64_t a3, unint64_t a4, void *a5, int a6)
{
  _QWORD *Object;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  __CFString *v18;
  unsigned int v19;
  uint64_t v20;
  __CFString *v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  unint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  id v39;

  v39 = a5;
  Object = GTMTLSMContext_getObject(**(_QWORD **)(a1 + 40), a3, a4);
  if (!Object)
    goto LABEL_34;
  v12 = Object;
  v13 = Object + 1;
  v38 = Object[1];
  v14 = *(_QWORD *)(*(_QWORD *)(*find_entry(*(_QWORD *)(a1 + 8), (_BYTE *)Object + 8, 8uLL, 0) + 32) + 8);
  v37 = v13[4];
  v15 = *a2;
  v16 = a2[1];
  v17 = v13[6];
  if (v17)
    v18 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v17));
  else
    v18 = &stru_7282A8;
  v19 = objc_msgSend(v39, "addString:", v18);
  if (v17)

  v20 = v12[10];
  if (v20)
  {
    if (*(_QWORD *)(v20 + 8))
    {
      v21 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:"));
      v22 = objc_msgSend(v39, "addString:", v21);
    }
    else
    {
      v23 = *(_QWORD *)(v20 + 16);
      if (v23)
        v21 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", *(_QWORD *)(v20 + 16)));
      else
        v21 = &stru_7282A8;
      v22 = objc_msgSend(v39, "addString:", v21);
      if (!v23)
        goto LABEL_16;
    }

  }
  else
  {
    v22 = 0;
  }
LABEL_16:
  v24 = -1431655765 * ((unint64_t)(v16 - v15) >> 4);
  v26 = a2[1];
  v25 = (unint64_t)a2[2];
  if ((unint64_t)v26 >= v25)
  {
    v28 = *a2;
    v29 = 0xAAAAAAAAAAAAAAABLL * ((v26 - *a2) >> 4);
    v30 = v29 + 1;
    if (v29 + 1 > 0x555555555555555)
      abort();
    v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v25 - (_QWORD)v28) >> 4);
    if (2 * v31 > v30)
      v30 = 2 * v31;
    if (v31 >= 0x2AAAAAAAAAAAAAALL)
      v32 = 0x555555555555555;
    else
      v32 = v30;
    if (v32)
    {
      if (v32 > 0x555555555555555)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v33 = (char *)operator new(48 * v32);
    }
    else
    {
      v33 = 0;
    }
    v34 = &v33[48 * v29];
    *(_QWORD *)v34 = v38;
    *((_QWORD *)v34 + 1) = v14;
    *((_QWORD *)v34 + 2) = v37;
    *((_DWORD *)v34 + 6) = v24;
    *((_DWORD *)v34 + 7) = v19;
    *((_DWORD *)v34 + 8) = v22;
    *((_DWORD *)v34 + 9) = a6;
    *((_QWORD *)v34 + 5) = 0;
    v27 = v34 + 48;
    if (v26 != v28)
    {
      do
      {
        v35 = *((_OWORD *)v26 - 3);
        v36 = *((_OWORD *)v26 - 1);
        *((_OWORD *)v34 - 2) = *((_OWORD *)v26 - 2);
        *((_OWORD *)v34 - 1) = v36;
        *((_OWORD *)v34 - 3) = v35;
        v34 -= 48;
        v26 -= 48;
      }
      while (v26 != v28);
      v26 = *a2;
    }
    *a2 = v34;
    a2[1] = v27;
    a2[2] = &v33[48 * v32];
    if (v26)
      operator delete(v26);
  }
  else
  {
    *(_QWORD *)v26 = v38;
    *((_QWORD *)v26 + 1) = v14;
    *((_QWORD *)v26 + 2) = v37;
    *((_DWORD *)v26 + 6) = v24;
    *((_DWORD *)v26 + 7) = v19;
    *((_DWORD *)v26 + 8) = v22;
    *((_DWORD *)v26 + 9) = a6;
    v27 = v26 + 48;
    *((_QWORD *)v26 + 5) = 0;
  }
  a2[1] = v27;
LABEL_34:

}

void sub_2DFDA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  uint64_t v13;

  if (v13)

  _Unwind_Resume(a1);
}

id GTShaderProfilerStreamDataFromReplayDataSource(uint64_t **a1, uint64_t a2, uint64_t a3, apr_allocator_t *a4)
{
  void *v4;
  int v7;
  vm_address_t v8;
  apr_pool_t *v9;
  apr_allocator_t *v10;
  uint64_t v11;
  id v12;
  uint64_t v13;
  void *v14;
  uint64_t *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int *v29;
  int v30;
  int FuncEnumConstructorType;
  int v32;
  uint64_t v33;
  uint64_t *v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t *v39;
  unint64_t *v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int *v45;
  int v46;
  unint64_t *v47;
  char *v48;
  unint64_t v49;
  _QWORD *v50;
  char *v51;
  int v52;
  int v54;
  _QWORD *Object;
  unint64_t v56;
  unint64_t v57;
  char *v58;
  int v59;
  uint64_t v60;
  unsigned int v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t v66;
  __int128 v67;
  char *v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD *v71;
  uint64_t v72;
  unint64_t v73;
  int v74;
  unint64_t v75;
  unint64_t v76;
  char *v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  __int128 v87;
  char *v88;
  unint64_t v89;
  unint64_t v90;
  char *v91;
  int v92;
  uint64_t v93;
  unsigned int v94;
  unint64_t v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t v98;
  unint64_t v99;
  __int128 v100;
  char *v101;
  char *v102;
  char *v103;
  char *v104;
  __int128 v105;
  __int128 v106;
  BOOL v107;
  int v108;
  int v109;
  char *v110;
  char *v111;
  uint64_t v112;
  uint64_t v113;
  char *v114;
  uint64_t v115;
  unint64_t v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v120;
  _QWORD *v121;
  char *v122;
  char *v123;
  unint64_t v124;
  __int128 v125;
  char *v126;
  unint64_t v127;
  __int128 v128;
  char *v129;
  char *v130;
  uint64_t v131;
  char *v132;
  uint64_t v133;
  id v134;
  apr_pool_t *v136;
  apr_status_t (__cdecl *v137)(void *);
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t **v141;
  uint64_t v142;
  uint64_t v143;
  unint64_t v144;
  apr_pool_t **v145;
  uint64_t *v146;
  unint64_t v147;
  char *v148;
  char *v149;
  uint64_t v150;
  char *v151;
  unint64_t *v152;
  int v153;
  uint64_t *v154;
  char *v155;
  uint64_t v156;
  uint64_t *v157;
  unsigned int v158;
  uint64_t v159;
  unint64_t v160;
  char *__p;
  apr_pool_t *newpool;
  _QWORD __dst[1394];
  uint64_t v164;
  int v165;
  unint64_t v166;
  uint64_t v167;
  _QWORD v168[13];
  uint64_t v169;
  uint64_t v170[11];
  uint64_t v171;
  apr_pool_t *p;
  unint64_t *v173[7];
  unsigned int v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  void *v183;
  void *v184;
  uint64_t v185;
  _DWORD *v186;
  _DWORD *v187;
  uint64_t v188;
  _OWORD v189[2];
  int v190;
  _OWORD v191[2];
  int v192;
  id v193;
  apr_pool_t *v194;
  uint64_t **v195;

  if ((shared_initialized & 1) != 0)
    goto LABEL_11;
  if (initialized++)
    goto LABEL_11;
  if ((apr_pools_shared_initialized & 1) != 0
    || (v7 = apr_pools_initialized, ++apr_pools_initialized, v7))
  {
LABEL_5:
    *(_QWORD *)&v178 = 0;
    if (!apr_pool_create_ex((apr_pool_t **)&v178, 0, 0, a4))
      *(_QWORD *)(v178 + 80) = "apr_initialize";
    goto LABEL_11;
  }
  v4 = &RecordVisibleFunctionTableMutation_sValue;
  global_allocator = 0;
  v8 = GTCoreAlloc(0xC8uLL);
  if (!v8)
  {
LABEL_10:
    apr_pools_initialized = 0;
    goto LABEL_11;
  }
  *(_OWORD *)v8 = 0u;
  *(_OWORD *)(v8 + 16) = 0u;
  *(_QWORD *)(v8 + 192) = 0;
  *(_OWORD *)(v8 + 160) = 0u;
  *(_OWORD *)(v8 + 176) = 0u;
  *(_OWORD *)(v8 + 128) = 0u;
  *(_OWORD *)(v8 + 144) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 112) = 0u;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 32) = 0u;
  *(_OWORD *)(v8 + 48) = 0u;
  global_allocator = v8;
  *(int64x2_t *)(v8 + 8) = vdupq_n_s64(0x8000uLL);
  if (apr_pool_create_ex((apr_pool_t **)&global_pool, 0, (apr_abortfunc_t)v8, a4))
  {
    apr_allocator_destroy((apr_allocator_t *)global_allocator);
    global_allocator = 0;
    goto LABEL_10;
  }
  v136 = (apr_pool_t *)global_pool;
  *(_QWORD *)(global_pool + 80) = "apr_global_pool";
  if (hash_mutex)
  {
LABEL_256:
    *(_QWORD *)&v178 = 0;
    if (apr_thread_mutex_create((apr_thread_mutex_t **)&v178, v136, v9))
      goto LABEL_11;
    v139 = global_allocator;
    v140 = global_pool;
    *(_QWORD *)(global_allocator + 24) = v178;
    *(_QWORD *)(v139 + 32) = v140;
    goto LABEL_5;
  }
  hash_mutex = (uint64_t)apr_palloc(v136, 0x38uLL);
  apr_pool_cleanup_register(v136, (const void *)hash_mutex, (apr_status_t (__cdecl *)(void *))atomic_cleanup, v137);
  v138 = 0;
  while (!apr_thread_mutex_create((apr_thread_mutex_t **)(hash_mutex + v138), v136, v9))
  {
    v138 += 8;
    if (v138 == 56)
    {
      LODWORD(v136) = global_pool;
      goto LABEL_256;
    }
  }
LABEL_11:
  newpool = 0;
  apr_pool_create_ex(&newpool, 0, 0, a4);
  v195 = a1;
  v194 = 0;
  apr_pool_create_ex(&v194, newpool, 0, v10);
  v145 = (apr_pool_t **)GTCaptureArchiveDecompressor_create(v194);
  v12 = (id)objc_opt_new(GTMutableShaderProfilerStreamData, v11);
  v193 = v12;
  v13 = **a1;
  if (v13)
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", **a1));
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "lastPathComponent"));
    v12 = v193;
  }
  else
  {
    v14 = 0;
  }
  objc_msgSend(v12, "setTraceName:", v14);
  if (v13)
  {

  }
  v141 = a1;
  v150 = (uint64_t)v195[2];
  v15 = v195[14];
  v157 = v195[15];
  memset(v191, 0, sizeof(v191));
  v192 = 1065353216;
  memset(v189, 0, sizeof(v189));
  v190 = 1065353216;
  v187 = 0;
  v186 = 0;
  v188 = 0;
  v185 = 0;
  v184 = 0;
  v183 = 0;
  if (*((int *)v15 + 3) >= 1)
  {
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v147 = 0;
    v148 = 0;
    v20 = 0;
    v151 = 0;
    v142 = 0;
    v160 = 0;
    v21 = 0;
    v146 = v15;
    while (1)
    {
      v155 = v20;
      __p = v18;
      v22 = v15[3];
      v153 = v21;
      v23 = v21;
      v24 = (uint64_t *)(v22 + 32 * v21);
      v25 = v157[3];
      v26 = *v24;
      v27 = v25 + (*v24 << 6);
      if ((*(_BYTE *)(v27 + 15) & 0x40) != 0 && (*((_DWORD *)v24 + 7) + 12542) < 0xFFFFFFFE)
      {
        v18 = __p;
        v20 = v155;
LABEL_229:
        v109 = v153;
        goto LABEL_230;
      }
      v154 = (uint64_t *)(v22 + 32 * v21);
      v152 = (unint64_t *)(v25 + (*v24 << 6));
      v30 = *(_DWORD *)(v27 + 8);
      v29 = (int *)(v27 + 8);
      v28 = v30;
      FuncEnumConstructorType = GetFuncEnumConstructorType(v30);
      if (FuncEnumConstructorType == 25)
        break;
      if (FuncEnumConstructorType == 51)
      {
        v182 = 0u;
        v181 = 0u;
        v180 = 0u;
        v179 = 0u;
        v178 = 0u;
        v32 = *v29;
        if (*v29 == -15343)
        {
          v36 = 0;
          *((_QWORD *)&v179 + 1) = *v152;
          v111 = v155;
          v34 = v154;
        }
        else
        {
          v33 = (uint64_t)v195[2];
          v34 = v154;
          if (v32 == -15313)
          {
            v110 = GTTraceFunc_argumentBytesWithMap(v152, *(unsigned __int8 *)(v25 + (v26 << 6) + 13), (uint64_t)v195[2]);
            *((_QWORD *)&v181 + 1) = GTTraceFunc_argumentBytesWithMap(v152, v110[8], v33);
            v36 = *((_QWORD *)&v178 + 1);
          }
          else if (v32 == -15333)
          {
            v35 = GTTraceFunc_argumentBytesWithMap(v152, *(unsigned __int8 *)(v25 + (v26 << 6) + 13), (uint64_t)v195[2]);
            v178 = 0u;
            v179 = 0u;
            v180 = 0u;
            v181 = 0u;
            v182 = 0u;
            v36 = *((_QWORD *)v35 + 1);
            if (v36)
            {
              LODWORD(v178) = 51;
              *((_QWORD *)&v178 + 1) = v36;
              *(_QWORD *)&v179 = *v152;
              *((_QWORD *)&v179 + 1) = -1;
              BYTE9(v182) = 1;
              *(_QWORD *)&v181 = *(_QWORD *)v35;
            }
          }
          else
          {
            v36 = 0;
          }
          v111 = v155;
        }
        v112 = *(_QWORD *)(*(_QWORD *)(*find_entry((uint64_t)v195[1], (_BYTE *)&v178 + 8, 8uLL, 0) + 32) + 8);
        v113 = *v34;
        v114 = v151;
        v115 = (v151 - v111) >> 5;
        if ((unint64_t)v151 >= v147)
        {
          v116 = v115 + 1;
          if ((unint64_t)(v115 + 1) >> 59)
            abort();
          if ((uint64_t)(v147 - (_QWORD)v155) >> 4 > v116)
            v116 = (uint64_t)(v147 - (_QWORD)v155) >> 4;
          if (v147 - (unint64_t)v155 >= 0x7FFFFFFFFFFFFFE0)
            v117 = 0x7FFFFFFFFFFFFFFLL;
          else
            v117 = v116;
          if (v117)
            v117 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>>(v117);
          else
            v118 = 0;
          v121 = (_QWORD *)(v117 + 32 * v115);
          *v121 = v36;
          v121[1] = v112;
          v121[2] = v113;
          *((_DWORD *)v121 + 6) = v115;
          *((_DWORD *)v121 + 7) = 0;
          v122 = v155;
          v123 = v151;
          if (v151 != v155)
          {
            v124 = v117 + 32 * v115;
            v18 = __p;
            do
            {
              v125 = *((_OWORD *)v123 - 1);
              v20 = (char *)(v124 - 32);
              *(_OWORD *)(v124 - 32) = *((_OWORD *)v123 - 2);
              *(_OWORD *)(v124 - 16) = v125;
              v123 -= 32;
              v124 -= 32;
            }
            while (v123 != v155);
            goto LABEL_226;
          }
          goto LABEL_225;
        }
        goto LABEL_205;
      }
      if (!GTMTLReplayHost_IsFuncEnumSampledEncoder(v28, 1, 0))
        goto LABEL_206;
      bzero(&v178, 0x2B90uLL);
      bzero(&v176, 0x2B90uLL);
      ++*((_DWORD *)v151 - 1);
      v175 = 0;
      v174 = 0;
      v173[0] = (unint64_t *)&v175;
      v173[1] = (unint64_t *)&v174;
      v173[2] = (unint64_t *)v191;
      v173[3] = (unint64_t *)&v183;
      v173[4] = (unint64_t *)&v195;
      v173[5] = (unint64_t *)&v193;
      v173[6] = (unint64_t *)&v186;
      v43 = *v154;
      v143 = v22 + 32 * v23;
      if ((unint64_t)*v154 < *(_QWORD *)(v143 + 8))
      {
        v158 = ((unint64_t)(v151 - v155) >> 5) - 1;
        while (1)
        {
          v156 = v157[3];
          v44 = v156 + (v43 << 6);
          v45 = (int *)(v44 + 8);
          v46 = IsFuncEnumParallelCommandEncoderCall(*(_DWORD *)(v44 + 8));
          v47 = v46 ? (unint64_t *)&v178 : (unint64_t *)&v176;
          v48 = v46 ? (char *)&v178 + 8 : (char *)&v177;
          GTMTLSMCommandEncoder_processTraceFunc((uint64_t)v47, (uint64_t *)v44, (uint64_t)v195[2]);
          v49 = v47[1];
          v50 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v189, v49);
          if (v50)
            break;
          if (__p == v19 || *((_QWORD *)v19 - 3) != *v154)
          {
            v149 = v19;
            v69 = *(_QWORD *)(*(_QWORD *)(*find_entry((uint64_t)v195[1], v48, 8uLL, 0) + 32) + 8);
            v70 = *v154;
            v71 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)v189, v47[1], v48);
            v72 = (v149 - __p) / 40;
            v73 = (unint64_t)(v17 - v16) >> 5;
            v71[3] = v72;
            v159 = v72;
            if (v149 < v148)
            {
              *(_QWORD *)v149 = v49;
              *((_QWORD *)v149 + 1) = v69;
              *((_QWORD *)v149 + 2) = v70;
              *((_DWORD *)v149 + 6) = v72;
              *((_DWORD *)v149 + 7) = v73;
              *((_QWORD *)v149 + 4) = v158;
              v19 = v149 + 40;
              goto LABEL_46;
            }
            v75 = v72 + 1;
            if ((unint64_t)(v72 + 1) > 0x666666666666666)
              abort();
            if (0x999999999999999ALL * ((v148 - __p) >> 3) > v75)
              v75 = 0x999999999999999ALL * ((v148 - __p) >> 3);
            if (0xCCCCCCCCCCCCCCCDLL * ((v148 - __p) >> 3) >= 0x333333333333333)
              v76 = 0x666666666666666;
            else
              v76 = v75;
            if (v76)
            {
              if (v76 > 0x666666666666666)
                std::__throw_bad_array_new_length[abi:nn180100]();
              v144 = v76;
              v77 = (char *)operator new(40 * v76);
              v78 = v144;
              LODWORD(v73) = (unint64_t)(v17 - v16) >> 5;
            }
            else
            {
              v77 = 0;
              v78 = 0;
            }
            v102 = &v77[40 * v159];
            *(_QWORD *)v102 = v49;
            *((_QWORD *)v102 + 1) = v69;
            *((_QWORD *)v102 + 2) = v70;
            *((_DWORD *)v102 + 6) = v159;
            *((_DWORD *)v102 + 7) = v73;
            *((_QWORD *)v102 + 4) = v158;
            v103 = v149;
            if (__p == v149)
            {
              v51 = &v77[40 * v159];
            }
            else
            {
              v104 = &v77[40 * v159];
              do
              {
                v105 = *(_OWORD *)(v103 - 40);
                v106 = *(_OWORD *)(v103 - 24);
                v51 = v104 - 40;
                *((_QWORD *)v104 - 1) = *((_QWORD *)v103 - 1);
                *(_OWORD *)(v104 - 24) = v106;
                *(_OWORD *)(v104 - 40) = v105;
                v103 -= 40;
                v104 -= 40;
              }
              while (v103 != __p);
            }
            v148 = &v77[40 * v78];
            v19 = v102 + 40;
            if (__p)
              operator delete(__p);
          }
          else
          {
            v51 = __p;
            v159 = -1 - 0x3333333333333333 * ((v19 - __p) >> 3);
          }
LABEL_47:
          v52 = *v45;
          if (*v45 == -16279 || v52 == -16337)
          {
            v175 = *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)v44, *(unsigned __int8 *)(v156 + (v43 << 6) + 13), v150)+ 1);
            _GTShaderProfilerStreamDataFromReplayDataSource(GTMTLReplayDataSource const*,apr_pool_t *)::$_0::operator()(v173, v43, *v45);
            v52 = *v45;
          }
          __p = v51;
          if (!IsFuncEnumGPUCommandCall(v52))
          {
            if (v52 >> 2 == 1073737833)
            {
              p = *v145;
              GTMTLSMContext_indirectCommandBufferResources((uint64_t)v170, (_DWORD **)v195[5], *v152, p);
              GetExecuteCommandsInBufferArgs((uint64_t)&v164, v157[3] + (v43 << 6), (uint64_t)v195[2]);
              Object = GTMTLSMContext_getObject(*v195[5], v164, *v152);
              GTMTLCreateIndirectCommandEncoder((uint64_t)v168, Object[13]);
              memcpy(__dst, v47, sizeof(__dst));
              if (*(_DWORD *)v47 == 28)
              {
                if ((GT_SUPPORT_0 & 0x10) != 0)
                {
                  v89 = v166;
                  if (v166)
                  {
                    v90 = 0;
                    v91 = &v51[40 * v159 + 36];
                    do
                    {
                      v92 = v90 + v165;
                      v171 = v167 + v169 * ((int)v90 + v165);
                      if (GTMTLSMComputeCommandEncoder_loadIndirectCommand((uint64_t)&__dst[7], v168, v171, v170))
                      {
                        v175 = __dst[8];
                        _GTShaderProfilerStreamDataFromReplayDataSource(GTMTLReplayDataSource const*,apr_pool_t *)::$_0::operator()(v173, v43, 4294950959);
                        v93 = (v17 - v16) >> 5;
                        v94 = v174;
                        if ((unint64_t)v17 >= v160)
                        {
                          v95 = v93 + 1;
                          if ((unint64_t)(v93 + 1) >> 59)
                            abort();
                          if ((uint64_t)(v160 - (_QWORD)v16) >> 4 > v95)
                            v95 = (uint64_t)(v160 - (_QWORD)v16) >> 4;
                          if (v160 - (unint64_t)v16 >= 0x7FFFFFFFFFFFFFE0)
                            v96 = 0x7FFFFFFFFFFFFFFLL;
                          else
                            v96 = v95;
                          if (v96)
                            v96 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>>(v96);
                          else
                            v97 = 0;
                          v98 = v96 + 32 * v93;
                          *(_DWORD *)v98 = v93;
                          *(_DWORD *)(v98 + 4) = v159;
                          *(_DWORD *)(v98 + 8) = v158;
                          *(_DWORD *)(v98 + 12) = v94;
                          *(_QWORD *)(v98 + 16) = v43;
                          *(_DWORD *)(v98 + 24) = 2;
                          *(_DWORD *)(v98 + 28) = v92;
                          if (v17 == v16)
                          {
                            v101 = (char *)(v96 + 32 * v93);
                          }
                          else
                          {
                            v99 = v96 + 32 * v93;
                            do
                            {
                              v100 = *((_OWORD *)v17 - 1);
                              v101 = (char *)(v99 - 32);
                              *(_OWORD *)(v99 - 32) = *((_OWORD *)v17 - 2);
                              *(_OWORD *)(v99 - 16) = v100;
                              v17 -= 32;
                              v99 -= 32;
                            }
                            while (v17 != v16);
                          }
                          v160 = v96 + 32 * v97;
                          v17 = (char *)(v98 + 32);
                          if (v16)
                            operator delete(v16);
                          v16 = v101;
                        }
                        else
                        {
                          *(_DWORD *)v17 = v93;
                          *((_DWORD *)v17 + 1) = v159;
                          *((_DWORD *)v17 + 2) = v158;
                          *((_DWORD *)v17 + 3) = v94;
                          *((_QWORD *)v17 + 2) = v43;
                          *((_DWORD *)v17 + 6) = 2;
                          *((_DWORD *)v17 + 7) = v92;
                          v17 += 32;
                        }
                        if (v94 != -1)
                          ++v186[10 * v94 + 7];
                        ++*(_DWORD *)v91;
                        v89 = v166;
                      }
                      ++v90;
                    }
                    while (v89 > v90);
                  }
                }
              }
              else if (*(_DWORD *)v47 == 70)
              {
                v56 = v166;
                if (v166)
                {
                  v57 = 0;
                  v58 = &v51[40 * v159 + 36];
                  do
                  {
                    v59 = v57 + v165;
                    v171 = v167 + v169 * ((int)v57 + v165);
                    if (GTMTLSMRenderCommandEncoder_loadIndirectCommand((uint64_t)&__dst[7], v168, v171, v170))
                    {
                      v175 = __dst[1075];
                      _GTShaderProfilerStreamDataFromReplayDataSource(GTMTLReplayDataSource const*,apr_pool_t *)::$_0::operator()(v173, v43, 4294951017);
                      v60 = (v17 - v16) >> 5;
                      v61 = v174;
                      if ((unint64_t)v17 >= v160)
                      {
                        v62 = v60 + 1;
                        if ((unint64_t)(v60 + 1) >> 59)
                          abort();
                        if ((uint64_t)(v160 - (_QWORD)v16) >> 4 > v62)
                          v62 = (uint64_t)(v160 - (_QWORD)v16) >> 4;
                        if (v160 - (unint64_t)v16 >= 0x7FFFFFFFFFFFFFE0)
                          v63 = 0x7FFFFFFFFFFFFFFLL;
                        else
                          v63 = v62;
                        if (v63)
                          v63 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>>(v63);
                        else
                          v64 = 0;
                        v65 = v63 + 32 * v60;
                        *(_DWORD *)v65 = v60;
                        *(_DWORD *)(v65 + 4) = v159;
                        *(_DWORD *)(v65 + 8) = v158;
                        *(_DWORD *)(v65 + 12) = v61;
                        *(_QWORD *)(v65 + 16) = v43;
                        *(_DWORD *)(v65 + 24) = 1;
                        *(_DWORD *)(v65 + 28) = v59;
                        if (v17 == v16)
                        {
                          v68 = (char *)(v63 + 32 * v60);
                        }
                        else
                        {
                          v66 = v63 + 32 * v60;
                          do
                          {
                            v67 = *((_OWORD *)v17 - 1);
                            v68 = (char *)(v66 - 32);
                            *(_OWORD *)(v66 - 32) = *((_OWORD *)v17 - 2);
                            *(_OWORD *)(v66 - 16) = v67;
                            v17 -= 32;
                            v66 -= 32;
                          }
                          while (v17 != v16);
                        }
                        v160 = v63 + 32 * v64;
                        v17 = (char *)(v65 + 32);
                        if (v16)
                          operator delete(v16);
                        v16 = v68;
                      }
                      else
                      {
                        *(_DWORD *)v17 = v60;
                        *((_DWORD *)v17 + 1) = v159;
                        *((_DWORD *)v17 + 2) = v158;
                        *((_DWORD *)v17 + 3) = v61;
                        *((_QWORD *)v17 + 2) = v43;
                        *((_DWORD *)v17 + 6) = 1;
                        *((_DWORD *)v17 + 7) = v59;
                        v17 += 32;
                      }
                      if (v61 != -1)
                        ++v186[10 * v61 + 7];
                      ++*(_DWORD *)v58;
                      v56 = v166;
                    }
                    ++v57;
                  }
                  while (v56 > v57);
                }
              }
              apr_pool_clear(p);
            }
            goto LABEL_164;
          }
          if ((IsFuncEnumDrawCall(v52) & 1) != 0)
          {
            v54 = 1;
LABEL_113:
            v79 = (v17 - v16) >> 5;
            v80 = v174;
            goto LABEL_114;
          }
          v54 = 3;
          if (v52 <= -16080)
          {
            if (v52 == -16327 || v52 == -16220)
            {
LABEL_112:
              v54 = 2;
              goto LABEL_113;
            }
            v74 = -16137;
          }
          else
          {
            if ((v52 + 16079) < 2)
              goto LABEL_112;
            if (v52 == -15486)
              goto LABEL_113;
            v74 = -15297;
          }
          if (v52 == v74)
            goto LABEL_113;
          if (!IsFuncEnumSampledBlitCallAGX(v52) && !IsFuncEnumSampledBlitCall(v52))
          {
            if ((v52 + 15416) >= 3)
              v54 = 0;
            else
              v54 = 5;
            goto LABEL_113;
          }
          ++v142;
          v79 = (v17 - v16) >> 5;
          v54 = 4;
          v80 = 0xFFFFFFFFLL;
LABEL_114:
          if ((unint64_t)v17 >= v160)
          {
            v82 = v79 + 1;
            if ((unint64_t)(v79 + 1) >> 59)
              abort();
            if ((uint64_t)(v160 - (_QWORD)v16) >> 4 > v82)
              v82 = (uint64_t)(v160 - (_QWORD)v16) >> 4;
            if (v160 - (unint64_t)v16 >= 0x7FFFFFFFFFFFFFE0)
              v83 = 0x7FFFFFFFFFFFFFFLL;
            else
              v83 = v82;
            if (v83)
              v83 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>>(v83);
            else
              v84 = 0;
            v85 = v83 + 32 * v79;
            *(_DWORD *)v85 = v79;
            v81 = v159;
            *(_DWORD *)(v85 + 4) = v159;
            *(_DWORD *)(v85 + 8) = v158;
            *(_DWORD *)(v85 + 12) = v80;
            *(_QWORD *)(v85 + 16) = v43;
            *(_DWORD *)(v85 + 24) = v54;
            *(_DWORD *)(v85 + 28) = -1;
            if (v17 == v16)
            {
              v88 = (char *)v85;
            }
            else
            {
              v86 = v85;
              do
              {
                v87 = *((_OWORD *)v17 - 1);
                v88 = (char *)(v86 - 32);
                *(_OWORD *)(v86 - 32) = *((_OWORD *)v17 - 2);
                *(_OWORD *)(v86 - 16) = v87;
                v17 -= 32;
                v86 -= 32;
              }
              while (v17 != v16);
            }
            v160 = v83 + 32 * v84;
            v17 = (char *)(v85 + 32);
            if (v16)
              operator delete(v16);
            v16 = v88;
          }
          else
          {
            *(_DWORD *)v17 = v79;
            v81 = v159;
            *((_DWORD *)v17 + 1) = v159;
            *((_DWORD *)v17 + 2) = v158;
            *((_DWORD *)v17 + 3) = v80;
            *((_QWORD *)v17 + 2) = v43;
            *((_DWORD *)v17 + 6) = v54;
            *((_DWORD *)v17 + 7) = -1;
            v17 += 32;
          }
          if (v80 != 0xFFFFFFFFLL)
            ++v186[10 * v80 + 7];
          ++*(_DWORD *)&__p[40 * v81 + 36];
LABEL_164:
          if ((unint64_t)++v43 >= *(_QWORD *)(v143 + 8))
            goto LABEL_180;
        }
        LODWORD(v159) = *((_DWORD *)v50 + 6);
LABEL_46:
        v51 = __p;
        goto LABEL_47;
      }
LABEL_180:
      v109 = *(_DWORD *)(v143 + 20) + v153;
      v18 = __p;
      v20 = v155;
      v15 = v146;
LABEL_230:
      v21 = v109 + 1;
      if (v21 >= *((_DWORD *)v15 + 3))
        goto LABEL_240;
    }
    v182 = 0u;
    v181 = 0u;
    v180 = 0u;
    v179 = 0u;
    v178 = 0u;
    v37 = (uint64_t)v195[2];
    v38 = *v29;
    if (*v29 > -16203)
    {
      v39 = v154;
      v40 = v152;
      if (v38 <= -15702)
      {
        v107 = v38 == -16202;
        v108 = -15908;
      }
      else
      {
        if (v38 == -15701)
        {
          v130 = GTTraceFunc_argumentBytesWithMap(v152, *(unsigned __int8 *)(v25 + (v26 << 6) + 13), (uint64_t)v195[2]);
          v178 = 0u;
          v179 = 0u;
          v180 = 0u;
          v181 = 0u;
          v182 = 0u;
          v131 = *((_QWORD *)v130 + 1);
          if (v131)
          {
            LODWORD(v178) = 25;
            *((_QWORD *)&v178 + 1) = v131;
            *(_QWORD *)&v179 = *v152;
            *((_QWORD *)&v179 + 1) = -1;
            *(_QWORD *)&v181 = *(_QWORD *)v130;
            v132 = GTTraceFunc_argumentBytesWithMap(v152, v130[16], v37);
            *(_QWORD *)&v182 = v132;
            if (v132)
              BYTE9(v182) = v132[9];
          }
          goto LABEL_204;
        }
        v107 = v38 == -15318;
        v108 = -15316;
      }
      if (!v107 && v38 != v108)
        goto LABEL_204;
    }
    else
    {
      v39 = v154;
      v40 = v152;
      if (v38 <= -16362)
      {
        if (v38 == -16365)
        {
          v129 = GTTraceFunc_argumentBytesWithMap(v152, *(unsigned __int8 *)(v25 + (v26 << 6) + 13), (uint64_t)v195[2]);
          *((_QWORD *)&v181 + 1) = GTTraceFunc_argumentBytesWithMap(v152, v129[8], v37);
        }
        else if (v38 == -16364)
        {
          BYTE8(v182) = *((_DWORD *)GTTraceFunc_argumentBytesWithMap(v152, *(unsigned __int8 *)(v25 + (v26 << 6) + 13), (uint64_t)v195[2])+ 2);
        }
        goto LABEL_204;
      }
      if (v38 != -16361)
      {
        if (v38 == -16343)
        {
          v41 = GTTraceFunc_argumentBytesWithMap(v152, *(unsigned __int8 *)(v25 + (v26 << 6) + 13), (uint64_t)v195[2]);
          v178 = 0u;
          v179 = 0u;
          v180 = 0u;
          v181 = 0u;
          v182 = 0u;
          v133 = *((_QWORD *)v41 + 1);
          if (!v133)
            goto LABEL_204;
          LODWORD(v178) = 25;
          *((_QWORD *)&v178 + 1) = v133;
          *(_QWORD *)&v179 = *v152;
          *((_QWORD *)&v179 + 1) = -1;
          BYTE9(v182) = 1;
          goto LABEL_238;
        }
        if (v38 == -16342)
        {
          v41 = GTTraceFunc_argumentBytesWithMap(v152, *(unsigned __int8 *)(v25 + (v26 << 6) + 13), (uint64_t)v195[2]);
          v178 = 0u;
          v179 = 0u;
          v180 = 0u;
          v181 = 0u;
          v182 = 0u;
          v42 = *((_QWORD *)v41 + 1);
          if (v42)
          {
            LODWORD(v178) = 25;
            *((_QWORD *)&v178 + 1) = v42;
            *(_QWORD *)&v179 = *v152;
            *((_QWORD *)&v179 + 1) = -1;
LABEL_238:
            *(_QWORD *)&v181 = *(_QWORD *)v41;
          }
        }
LABEL_204:
        v36 = *((_QWORD *)&v178 + 1);
        v112 = *(_QWORD *)(*(_QWORD *)(*find_entry((uint64_t)v195[1], (_BYTE *)&v178 + 8, 8uLL, 0) + 32) + 8);
        v113 = *v39;
        v114 = v151;
        v115 = (v151 - v155) >> 5;
        if ((unint64_t)v151 >= v147)
        {
          v120 = v115 + 1;
          if ((unint64_t)(v115 + 1) >> 59)
            abort();
          if ((uint64_t)(v147 - (_QWORD)v155) >> 4 > v120)
            v120 = (uint64_t)(v147 - (_QWORD)v155) >> 4;
          if (v147 - (unint64_t)v155 >= 0x7FFFFFFFFFFFFFE0)
            v117 = 0x7FFFFFFFFFFFFFFLL;
          else
            v117 = v120;
          if (v117)
            v117 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>>(v117);
          else
            v118 = 0;
          v121 = (_QWORD *)(v117 + 32 * v115);
          *v121 = v36;
          v121[1] = v112;
          v121[2] = v113;
          v121[3] = v115;
          v122 = v155;
          v126 = v151;
          if (v151 != v155)
          {
            v127 = v117 + 32 * v115;
            v18 = __p;
            do
            {
              v128 = *((_OWORD *)v126 - 1);
              v20 = (char *)(v127 - 32);
              *(_OWORD *)(v127 - 32) = *((_OWORD *)v126 - 2);
              *(_OWORD *)(v127 - 16) = v128;
              v126 -= 32;
              v127 -= 32;
            }
            while (v126 != v155);
LABEL_226:
            v147 = v117 + 32 * v118;
            v151 = (char *)(v121 + 4);
            if (v122)
              operator delete(v122);
LABEL_228:
            v15 = v146;
            goto LABEL_229;
          }
LABEL_225:
          v20 = (char *)v121;
          v18 = __p;
          goto LABEL_226;
        }
LABEL_205:
        *(_QWORD *)v114 = v36;
        *((_QWORD *)v114 + 1) = v112;
        *((_QWORD *)v114 + 2) = v113;
        *((_DWORD *)v114 + 6) = v115;
        *((_DWORD *)v114 + 7) = 0;
        v151 = v114 + 32;
LABEL_206:
        v18 = __p;
        v20 = v155;
        goto LABEL_228;
      }
    }
    *((_QWORD *)&v179 + 1) = *v40;
    goto LABEL_204;
  }
  v16 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v151 = 0;
  v17 = 0;
  v142 = 0;
LABEL_240:
  objc_msgSend(v193, "addGPUCommands:count:", v16, (v17 - v16) >> 5);
  objc_msgSend(v193, "addEncoders:count:", v18, 0xCCCCCCCCCCCCCCCDLL * ((v19 - v18) >> 3));
  objc_msgSend(v193, "addPipelineStates:count:");
  objc_msgSend(v193, "addCommandBuffers:count:", v20, (v151 - v20) >> 5);
  objc_msgSend(v193, "addShaderFunctionInfo:count:");
  objc_msgSend(v193, "setNumBlitCalls:", v142);
  apr_pool_destroy(v194);
  v134 = v193;
  if (v183)
  {
    v184 = v183;
    operator delete(v183);
  }
  if (v20)
    operator delete(v20);
  if (v186)
  {
    v187 = v186;
    operator delete(v186);
  }
  if (v18)
    operator delete(v18);
  if (v16)
    operator delete(v16);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v189);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v191);

  objc_msgSend(v134, "setDataSourceHasUnusedResources:captureRange:", 0, v141[10], v141[11]);
  apr_pool_destroy(newpool);
  return v134;
}

void sub_2E1230(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, char a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38)
{
  void *v38;

  _Unwind_Resume(a1);
}

void GTMTLReplayController_tileMemoryFree(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  objc_msgSend(*(id *)(a1 + 40), "removeAllObjects");
  v2 = *(void **)(a1 + 104);
  *(_QWORD *)(a1 + 104) = 0;

  v3 = *(void **)(a1 + 64);
  *(_QWORD *)(a1 + 64) = 0;

  v4 = *(void **)(a1 + 72);
  *(_QWORD *)(a1 + 72) = 0;

  v5 = *(void **)(a1 + 80);
  *(_QWORD *)(a1 + 80) = 0;

  v6 = *(void **)(a1 + 112);
  *(_QWORD *)(a1 + 112) = 0;

  v7 = *(void **)(a1 + 88);
  *(_QWORD *)(a1 + 88) = 0;

  v8 = *(void **)(a1 + 96);
  *(_QWORD *)(a1 + 96) = 0;

}

void AddMemorylessTexture(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6;
  _QWORD *Object;
  void *v8;
  __int16 v9;
  void *v10;
  void *v11;
  id MTLTextureDescriptorWithoutResourceIndex;
  void *v13;
  id v14;
  id v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;

  v6 = *a1;
  v15 = (id)a1[5];
  Object = GTMTLSMContext_getObject(**(_QWORD **)(v6 + 40), a2, a3);
  if (Object && *(_DWORD *)Object == 80)
  {
    v19 = 0;
    v17 = 0u;
    v18 = 0u;
    v16 = 0u;
    GTMTLSMContext_getTextureDescriptor(*(uint64_t **)(v6 + 40), a2, a3, (uint64_t)&v16);
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a2));
    v9 = WORD2(v18);
    if ((BYTE4(v18) & 0xF0) == 0x30)
    {
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKeyedSubscript:", v8));

      if (!v10)
      {
        v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1[1], "defaultDevice"));
        WORD2(v18) = v9 & 0xFF0F | 0x20;
        DWORD1(v17) |= 1u;
        MTLTextureDescriptorWithoutResourceIndex = MakeMTLTextureDescriptorWithoutResourceIndex((uint64_t)&v16);
        v13 = (void *)objc_claimAutoreleasedReturnValue(MTLTextureDescriptorWithoutResourceIndex);
        v14 = objc_msgSend(v11, "newTextureWithDescriptor:", v13);
        objc_msgSend(v15, "setObject:forKeyedSubscript:", v14, v8);

      }
    }

  }
}

uint64_t *std::unique_ptr<GRCPerFrameData>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  uint64_t i;
  void **v5;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    objc_msgSend(*(id *)(v2 + 496), "cancelAllOperations");

    std::unique_ptr<GRCCurrentFrameStream>::reset[abi:nn180100]((uint64_t *)(v2 + 488), 0);
    std::__hash_table<std::__hash_value_type<unsigned int,RingBufferSampledData>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RingBufferSampledData>>>::~__hash_table(v2 + 448);
    v3 = *(void **)(v2 + 424);
    if (v3)
    {
      *(_QWORD *)(v2 + 432) = v3;
      operator delete(v3);
    }
    v5 = (void **)(v2 + 328);
    std::vector<std::pair<unsigned int,SampleInfoWithPayload>>::__destroy_vector::operator()[abi:nn180100](&v5);
    v5 = (void **)(v2 + 304);
    std::vector<std::tuple<unsigned int,SampleInfoWithPayload,unsigned long long>>::__destroy_vector::operator()[abi:nn180100](&v5);
    for (i = 264; i != 144; i -= 40)
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 + i);
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 + 144);
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 + 104);
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 + 64);
    std::__hash_table<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>>>::~__hash_table(v2 + 24);
    v5 = (void **)v2;
    std::vector<ProgramAddressHelper::PerRingBufferProgramInfo>::__destroy_vector::operator()[abi:nn180100](&v5);
    operator delete();
  }
  return result;
}

void sub_2E1648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v10;
  void *v12;
  uint64_t i;

  std::unique_ptr<GRCCurrentFrameStream>::reset[abi:nn180100]((uint64_t *)(v10 + 488), 0);
  std::__hash_table<std::__hash_value_type<unsigned int,RingBufferSampledData>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RingBufferSampledData>>>::~__hash_table(v10 + 448);
  v12 = *(void **)(v10 + 424);
  if (v12)
  {
    *(_QWORD *)(v10 + 432) = v12;
    operator delete(v12);
  }
  a10 = (void **)(v10 + 328);
  std::vector<std::pair<unsigned int,SampleInfoWithPayload>>::__destroy_vector::operator()[abi:nn180100](&a10);
  a10 = (void **)(v10 + 304);
  std::vector<std::tuple<unsigned int,SampleInfoWithPayload,unsigned long long>>::__destroy_vector::operator()[abi:nn180100](&a10);
  for (i = 264; i != 144; i -= 40)
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v10 + i);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v10 + 144);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v10 + 104);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v10 + 64);
  std::__hash_table<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>>>::~__hash_table(v10 + 24);
  a10 = (void **)v10;
  std::vector<ProgramAddressHelper::PerRingBufferProgramInfo>::__destroy_vector::operator()[abi:nn180100](&a10);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<GRCCurrentFrameStream>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;

  v2 = *result;
  *result = a2;
  if (v2)
  {

    v3 = *(void **)(v2 + 256);
    if (v3)
    {
      *(_QWORD *)(v2 + 264) = v3;
      operator delete(v3);
    }
    v4 = *(void **)(v2 + 232);
    if (v4)
    {
      *(_QWORD *)(v2 + 240) = v4;
      operator delete(v4);
    }
    v5 = *(void **)(v2 + 208);
    if (v5)
      operator delete(v5);
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 + 168);
    std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table(v2 + 128);
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 + 88);
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 + 48);
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 + 8);

    operator delete();
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,RingBufferSampledData>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RingBufferSampledData>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      RingBufferSampledData::~RingBufferSampledData((RingBufferSampledData *)(v2 + 3));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

void std::vector<std::pair<unsigned int,SampleInfoWithPayload>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::pair<unsigned int,SampleInfoWithPayload>>::__clear[abi:nn180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::tuple<unsigned int,SampleInfoWithPayload,unsigned long long>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::tuple<unsigned int,SampleInfoWithPayload,unsigned long long>>::__clear[abi:nn180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>>>::~__hash_table(uint64_t a1)
{
  _QWORD **v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD ***)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = *v2;
      std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>>>::destroy(v2[4]);
      operator delete(v2);
      v2 = (_QWORD **)v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

void std::vector<ProgramAddressHelper::PerRingBufferProgramInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 88;
        std::allocator<ProgramAddressHelper::PerRingBufferProgramInfo>::destroy[abi:nn180100](v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void ProgramAddressHelper::~ProgramAddressHelper(void **this)
{
  uint64_t i;
  void **v3;

  for (i = 33; i != 18; i -= 5)
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&this[i]);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)(this + 18));
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)(this + 13));
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)(this + 8));
  std::__hash_table<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>>>::~__hash_table((uint64_t)(this + 3));
  v3 = this;
  std::vector<ProgramAddressHelper::PerRingBufferProgramInfo>::__destroy_vector::operator()[abi:nn180100](&v3);
}

uint64_t std::allocator<ProgramAddressHelper::PerRingBufferProgramInfo>::destroy[abi:nn180100](uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(_QWORD *)(a1 + 72) = v2;
    operator delete(v2);
  }
  std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>>>::destroy(*(_QWORD **)(a1 + 48));
  return std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(a1);
}

void std::vector<std::tuple<unsigned int,SampleInfoWithPayload,unsigned long long>>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  void *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 104)
  {
    v4 = *(void **)(i - 32);
    if (v4)
    {
      *(_QWORD *)(i - 24) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

void std::vector<std::pair<unsigned int,SampleInfoWithPayload>>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  void *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 96)
  {
    v4 = *(void **)(i - 24);
    if (v4)
    {
      *(_QWORD *)(i - 16) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

void RingBufferSampledData::~RingBufferSampledData(RingBufferSampledData *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v2 = (void *)*((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = 0;

  v3 = (void *)*((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = 0;

  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    *((_QWORD *)this + 12) = v4;
    operator delete(v4);
  }

  v5 = (void *)*((_QWORD *)this + 1);
  if (v5)
  {
    *((_QWORD *)this + 2) = v5;
    operator delete(v5);
  }
}

uint64_t FindNextMarker(NSData *a1, unsigned int a2, uint64_t a3)
{
  NSData *v5;
  unsigned int v6;
  NSData *v7;
  _QWORD *v8;
  unsigned int v9;
  BOOL v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;

  v5 = a1;
  v6 = -[NSData length](v5, "length");
  v7 = objc_retainAutorelease(v5);
  v8 = -[NSData bytes](v7, "bytes");
  v9 = (v6 - 64) >> 3;
  v10 = v9 >= a2;
  v11 = v9 - a2;
  if (v10)
  {
    v12 = a2;
    v13 = v11 + 1;
    while (v8[v12] != a3)
    {
      ++v12;
      if (!--v13)
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    v12 = 0xFFFFFFFFLL;
  }

  return v12;
}

void sub_2E1BCC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::$_0 &,std::__wrap_iter<GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::PriorityQueueElement *>>(uint64_t result, uint64_t a2, uint64_t **a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v20;
  unsigned int *v21;
  unint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t v27;
  BOOL v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;

  v4 = a4 - 2;
  if (a4 < 2)
    return result;
  v5 = v4 >> 1;
  v6 = (unsigned int *)(result + 8 * (v4 >> 1));
  v7 = **a3;
  v8 = (_QWORD *)(*(_QWORD *)(v7 + 8 * *v6) + 8 * v6[1]);
  v9 = (_QWORD *)(*(_QWORD *)(v7 + 8 * *(unsigned int *)(a2 - 8)) + 8 * *(unsigned int *)(a2 - 4));
  v10 = v8[1];
  v11 = v9[1];
  v12 = v10 > v11;
  if (v10 == v11
    && (v13 = v8[4], v14 = v9[4], v12 = v13 > v14, v13 == v14)
    && (v15 = v8[5], v16 = v9[5], v12 = v15 > v16, v15 == v16))
  {
    v17 = v8[3];
    v18 = v9[3];
    if (v17 <= v10 || v17 == v18)
      return result;
  }
  else if (!v12)
  {
    return result;
  }
  v20 = *(_QWORD *)(a2 - 8);
  *(_QWORD *)(a2 - 8) = *(_QWORD *)v6;
  if (v4 >= 2)
  {
    while (1)
    {
      v22 = v5 - 1;
      v5 = (v5 - 1) >> 1;
      v21 = (unsigned int *)(result + 8 * v5);
      v23 = **a3;
      v24 = (_QWORD *)(*(_QWORD *)(v23 + 8 * *v21) + 8 * v21[1]);
      v25 = (_QWORD *)(*(_QWORD *)(v23 + 8 * v20) + 8 * HIDWORD(v20));
      v26 = v24[1];
      v27 = v25[1];
      v28 = v26 > v27;
      if (v26 == v27
        && (v29 = v24[4], v30 = v25[4], v28 = v29 > v30, v29 == v30)
        && (v31 = v24[5], v32 = v25[5], v28 = v31 > v32, v31 == v32))
      {
        v33 = v24[3];
        v34 = v25[3];
        if (v33 <= v26 || v33 == v34)
          break;
      }
      else if (!v28)
      {
        break;
      }
      *(_QWORD *)v6 = *(_QWORD *)v21;
      v6 = (unsigned int *)(result + 8 * v5);
      if (v22 <= 1)
        goto LABEL_27;
    }
  }
  v21 = v6;
LABEL_27:
  *(_QWORD *)v21 = v20;
  return result;
}

__n128 __Block_byref_object_copy__7742(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__7743(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void std::vector<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>::reserve(void **a1, unint64_t a2)
{
  int64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  __int128 v11;

  if (a2 > ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 5)
  {
    if (a2 >> 59)
      abort();
    v3 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>>(a2);
    v5 = &v4[v3 & 0xFFFFFFFFFFFFFFE0];
    v7 = &v4[32 * v6];
    v9 = (char *)*a1;
    v8 = (char *)a1[1];
    v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        v11 = *((_OWORD *)v8 - 1);
        *((_OWORD *)v10 - 2) = *((_OWORD *)v8 - 2);
        *((_OWORD *)v10 - 1) = v11;
        v10 -= 32;
        v8 -= 32;
      }
      while (v8 != v9);
      v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
      operator delete(v8);
  }
}

void ___ZN16GRCFrameTimeData26ProcessFrameTimeSampleDataERd_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5;
  unsigned int v6;
  void *v7;
  unsigned int v8;
  void *v9;
  void *v10;
  unsigned int v11;
  void *v12;
  id v13;
  uint64_t i;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  unint64_t v18;
  char *v19;
  _QWORD *v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  BOOL v25;
  unint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  __int128 v30;
  void *v31;
  id v32;
  unsigned int v33;

  v32 = a2;
  v5 = a3;
  v31 = v5;
  v6 = objc_msgSend(v32, "unsignedIntValue");
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectAtIndexedSubscript:", 0));
  v8 = objc_msgSend(v7, "unsignedIntValue");

  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectAtIndexedSubscript:", 1));
  v33 = objc_msgSend(v9, "unsignedIntValue");

  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectAtIndexedSubscript:", 2));
  v11 = objc_msgSend(v10, "unsignedIntValue");

  if ((unint64_t)objc_msgSend(v5, "count") < 4)
  {
    v13 = 0;
    if (!v11)
      goto LABEL_24;
  }
  else
  {
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectAtIndexedSubscript:", 3));
    v13 = objc_msgSend(v12, "unsignedLongLongValue");

    if (!v11)
      goto LABEL_24;
  }
  for (i = 0; i != v11; ++i)
  {
    v15 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * (v8 + i));
    if (v15)
    {
      v16 = v33 + i;
      v17 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
      v19 = (char *)v17[7];
      v18 = v17[8];
      if ((unint64_t)v19 >= v18)
      {
        v21 = (char *)v17[6];
        v22 = (v19 - v21) >> 5;
        v23 = v22 + 1;
        if ((unint64_t)(v22 + 1) >> 59)
          abort();
        v24 = v18 - (_QWORD)v21;
        if (v24 >> 4 > v23)
          v23 = v24 >> 4;
        v25 = (unint64_t)v24 >= 0x7FFFFFFFFFFFFFE0;
        v26 = 0x7FFFFFFFFFFFFFFLL;
        if (!v25)
          v26 = v23;
        if (v26)
        {
          v26 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>>(v26);
          v21 = (char *)v17[6];
          v19 = (char *)v17[7];
        }
        else
        {
          v27 = 0;
        }
        v28 = (_QWORD *)(v26 + 32 * v22);
        *v28 = v15;
        v28[1] = v6;
        v28[2] = v16;
        v28[3] = v13;
        v29 = v28;
        if (v19 != v21)
        {
          do
          {
            v30 = *((_OWORD *)v19 - 1);
            *((_OWORD *)v29 - 2) = *((_OWORD *)v19 - 2);
            *((_OWORD *)v29 - 1) = v30;
            v29 -= 4;
            v19 -= 32;
          }
          while (v19 != v21);
          v21 = (char *)v17[6];
        }
        v20 = v28 + 4;
        v17[6] = v29;
        v17[7] = v28 + 4;
        v17[8] = v26 + 32 * v27;
        if (v21)
          operator delete(v21);
      }
      else
      {
        *(_QWORD *)v19 = v15;
        *((_QWORD *)v19 + 1) = v6;
        v20 = v19 + 32;
        *((_QWORD *)v19 + 2) = v16;
        *((_QWORD *)v19 + 3) = v13;
      }
      v17[7] = v20;
    }
  }
LABEL_24:

}

void sub_2E1FFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, id a11)
{
  void *v11;

  _Unwind_Resume(a1);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *,false>(uint64_t result, char *a2, uint64_t a3, char a4)
{
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *i;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  char *k;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t *j;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  BOOL v82;
  uint64_t v83;
  uint64_t *v84;
  char *v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t *v91;
  uint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  char *v96;
  int64_t v97;
  int64_t v98;
  uint64_t v99;
  uint64_t *v100;
  uint64_t *v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  uint64_t *v105;
  uint64_t v106;
  uint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  uint64_t v112;
  char *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t *v118;
  uint64_t *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  unint64_t v123;
  unint64_t v124;
  uint64_t *v125;
  unint64_t v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v129;
  uint64_t *v130;
  unint64_t v131;
  unint64_t v132;
  unint64_t v133;
  unint64_t v134;
  char *v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t v139;
  unint64_t v140;
  unint64_t v141;
  _QWORD *v142;
  unint64_t v143;
  unint64_t v144;
  unint64_t v145;
  unint64_t v146;
  unint64_t v147;
  unint64_t v148;
  uint64_t v149;
  int64_t v150;
  uint64_t v151;
  int64_t v152;
  uint64_t v153;
  char *v154;

  v7 = (uint64_t *)result;
LABEL_2:
  v8 = (uint64_t *)(a2 - 32);
  v9 = (uint64_t *)(a2 - 64);
  v10 = (uint64_t *)(a2 - 96);
  i = v7;
  v154 = a2;
  while (2)
  {
    v7 = i;
    v12 = a2 - (char *)i;
    v13 = (a2 - (char *)i) >> 5;
    switch(v13)
    {
      case 0:
      case 1:
        return result;
      case 2:
        result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(v8, v7);
        if ((_DWORD)result)
        {
          v76 = *v7;
          *v7 = *((_QWORD *)a2 - 4);
          *((_QWORD *)a2 - 4) = v76;
          v77 = v7[1];
          v7[1] = *((_QWORD *)a2 - 3);
          *((_QWORD *)a2 - 3) = v77;
          v78 = v7[2];
          v7[2] = *((_QWORD *)a2 - 2);
          *((_QWORD *)a2 - 2) = v78;
          v79 = v7[3];
          v7[3] = *((_QWORD *)a2 - 1);
          *((_QWORD *)a2 - 1) = v79;
        }
        return result;
      case 3:
        return std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(v7, v7 + 4, v8);
      case 4:
        return std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(v7, v7 + 4, v7 + 8, v8);
      case 5:
        return std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(v7, v7 + 4, v7 + 8, v7 + 12, v8);
      default:
        if (v12 > 767)
        {
          if (!a3)
          {
            if (v7 != (uint64_t *)a2)
            {
              v97 = (unint64_t)(v13 - 2) >> 1;
              v152 = v97;
              do
              {
                v98 = v97;
                if (v152 >= v97)
                {
                  v99 = (2 * v97) | 1;
                  v100 = &v7[4 * v99];
                  if (2 * v97 + 2 < v13
                    && std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(&v7[4 * v99], v100 + 4))
                  {
                    v100 += 4;
                    v99 = 2 * v98 + 2;
                  }
                  v101 = &v7[4 * v98];
                  result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(v100, v101);
                  a2 = v154;
                  if ((result & 1) == 0)
                  {
                    v103 = *v101;
                    v102 = v101[1];
                    v104 = v101[2];
                    v147 = v101[3];
                    *v101 = *v100;
                    v101[1] = v100[1];
                    v101[2] = v100[2];
                    v101[3] = v100[3];
                    if (v152 >= v99)
                    {
                      v148 = v102;
                      v150 = v98;
                      while (1)
                      {
                        v105 = v100;
                        v106 = 2 * v99;
                        v99 = (2 * v99) | 1;
                        v100 = &v7[4 * v99];
                        v107 = v106 + 2;
                        if (v106 + 2 < v13)
                        {
                          v108 = v103;
                          result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(&v7[4 * v99], v100 + 4);
                          v103 = v108;
                          v102 = v148;
                          v98 = v150;
                          if ((_DWORD)result)
                          {
                            v100 += 4;
                            v99 = v107;
                          }
                        }
                        v109 = *v100;
                        if (*v100 < v103)
                          break;
                        if (v103 >= v109)
                        {
                          v110 = v100[1];
                          if (v110 < v102)
                            break;
                          if (v102 >= v110)
                          {
                            v111 = v100[2];
                            if (v111 < v104 || v104 >= v111 && v100[3] < v147)
                              break;
                          }
                        }
                        *v105 = v109;
                        v105[1] = v100[1];
                        v105[2] = v100[2];
                        v105[3] = v100[3];
                        if (v152 < v99)
                          goto LABEL_178;
                      }
                      v100 = v105;
                    }
LABEL_178:
                    *v100 = v103;
                    v100[1] = v102;
                    v100[2] = v104;
                    v100[3] = v147;
                    a2 = v154;
                  }
                }
                v97 = v98 - 1;
              }
              while (v98);
              v112 = (unint64_t)v12 >> 5;
              do
              {
                v113 = a2;
                v114 = 0;
                v151 = v7[1];
                v153 = *v7;
                v115 = v7[3];
                v149 = v7[2];
                v116 = v112 - 2;
                if (v112 < 2)
                  v116 = v112 - 1;
                v117 = v116 >> 1;
                v118 = v7;
                do
                {
                  v119 = &v118[4 * v114 + 4];
                  v120 = (2 * v114) | 1;
                  v121 = 2 * v114 + 2;
                  if (v121 < v112)
                  {
                    result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(&v118[4 * v114 + 4], &v118[4 * v114 + 8]);
                    if ((_DWORD)result)
                    {
                      v119 += 4;
                      v120 = v121;
                    }
                  }
                  *v118 = *v119;
                  v118[1] = v119[1];
                  v118[2] = v119[2];
                  v118[3] = v119[3];
                  v118 = v119;
                  v114 = v120;
                }
                while (v120 <= v117);
                if (v119 == (uint64_t *)(v113 - 32))
                {
                  *v119 = v153;
                  v119[1] = v151;
                  v119[2] = v149;
                  v119[3] = v115;
                  goto LABEL_205;
                }
                *v119 = *((_QWORD *)v113 - 4);
                v119[1] = *((_QWORD *)v113 - 3);
                v119[2] = *((_QWORD *)v113 - 2);
                v119[3] = *((_QWORD *)v113 - 1);
                *((_QWORD *)v113 - 4) = v153;
                *((_QWORD *)v113 - 3) = v151;
                *((_QWORD *)v113 - 2) = v149;
                *((_QWORD *)v113 - 1) = v115;
                v122 = (char *)v119 - (char *)v7 + 32;
                if (v122 >= 33)
                {
                  v123 = (v122 >> 5) - 2;
                  v124 = v123 >> 1;
                  v125 = &v7[4 * (v123 >> 1)];
                  result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(v125, v119);
                  if ((_DWORD)result)
                  {
                    v126 = *v119;
                    v127 = v119[1];
                    v128 = v119[2];
                    v129 = v119[3];
                    *v119 = *v125;
                    v119[1] = v125[1];
                    v119[2] = v125[2];
                    v119[3] = v125[3];
                    if (v123 < 2)
                      goto LABEL_204;
                    while (1)
                    {
                      v130 = v125;
                      v131 = v124 - 1;
                      v124 = (v124 - 1) >> 1;
                      v125 = &v7[4 * v124];
                      v132 = *v125;
                      if (*v125 >= v126)
                      {
                        if (v126 < v132
                          || (v133 = v125[1], v133 >= v127)
                          && (v127 < v133 || (v134 = v125[2], v134 >= v128) && (v128 < v134 || v125[3] >= v129)))
                        {
                          v125 = v130;
LABEL_204:
                          *v125 = v126;
                          v125[1] = v127;
                          v125[2] = v128;
                          v125[3] = v129;
                          break;
                        }
                      }
                      else
                      {
                        v133 = v125[1];
                      }
                      *v130 = v132;
                      v130[1] = v133;
                      v130[2] = v125[2];
                      v130[3] = v125[3];
                      if (v131 <= 1)
                        goto LABEL_204;
                    }
                  }
                }
LABEL_205:
                a2 = v113 - 32;
              }
              while (v112-- > 2);
            }
            return result;
          }
          v14 = (unint64_t)v13 >> 1;
          v15 = &v7[4 * ((unint64_t)v13 >> 1)];
          if ((unint64_t)v12 <= 0x1000)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(v15, v7, v8);
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(v7, v15, v8);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(v7 + 4, v15 - 4, v9);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(v7 + 8, &v7[4 * v14 + 4], v10);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(v15 - 4, v15, &v7[4 * v14 + 4]);
            v16 = *(_OWORD *)v7;
            v17 = *((_OWORD *)v7 + 1);
            v18 = *((_OWORD *)v15 + 1);
            *(_OWORD *)v7 = *(_OWORD *)v15;
            *((_OWORD *)v7 + 1) = v18;
            *(_OWORD *)v15 = v16;
            *((_OWORD *)v15 + 1) = v17;
          }
          --a3;
          a2 = v154;
          if ((a4 & 1) == 0)
          {
            result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(v7 - 4, v7);
            if ((result & 1) == 0)
            {
              v48 = *v7;
              v49 = v7[1];
              v50 = v7[2];
              v51 = v7[3];
              v52 = *v8;
              if (*v7 < (unint64_t)*v8
                || v52 >= v48
                && ((v74 = *((_QWORD *)v154 - 3), v49 < v74)
                 || v74 >= v49
                 && ((v75 = *((_QWORD *)v154 - 2), v50 < v75) || v75 >= v50 && v51 < *((_QWORD *)v154 - 1))))
              {
                i = v7;
                while (1)
                {
                  v54 = i[4];
                  i += 4;
                  v53 = v54;
                  if (v48 < v54)
                    break;
                  if (v53 >= v48)
                  {
                    v55 = i[1];
                    if (v49 < v55)
                      break;
                    if (v55 >= v49)
                    {
                      v56 = i[2];
                      if (v50 < v56 || v56 >= v50 && v51 < i[3])
                        break;
                    }
                  }
                }
              }
              else
              {
                for (i = v7 + 4; i < (uint64_t *)v154; i += 4)
                {
                  if (v48 < *i)
                    break;
                  if (*i >= v48)
                  {
                    v72 = i[1];
                    if (v49 < v72)
                      break;
                    if (v72 >= v49)
                    {
                      v73 = i[2];
                      if (v50 < v73 || v73 >= v50 && v51 < i[3])
                        break;
                    }
                  }
                }
              }
              j = (uint64_t *)v154;
              if (i < (uint64_t *)v154)
              {
                for (j = v8; ; j -= 4)
                {
                  if (v48 >= v52)
                  {
                    if (v52 < v48)
                      break;
                    v58 = j[1];
                    if (v49 >= v58)
                    {
                      if (v58 < v49)
                        break;
                      v59 = j[2];
                      if (v50 >= v59 && (v59 < v50 || v51 >= j[3]))
                        break;
                    }
                  }
                  v60 = *(j - 4);
                  v52 = v60;
                }
              }
              if (i < j)
              {
                v61 = *i;
                v62 = *j;
                do
                {
                  *i = v62;
                  *j = v61;
                  v63 = i[1];
                  i[1] = j[1];
                  j[1] = v63;
                  v64 = i[2];
                  i[2] = j[2];
                  j[2] = v64;
                  v65 = i[3];
                  i[3] = j[3];
                  j[3] = v65;
                  while (1)
                  {
                    v66 = i[4];
                    i += 4;
                    v61 = v66;
                    if (v48 < v66)
                      break;
                    if (v61 >= v48)
                    {
                      v67 = i[1];
                      if (v49 < v67)
                        break;
                      if (v67 >= v49)
                      {
                        v68 = i[2];
                        if (v50 < v68 || v68 >= v50 && v51 < i[3])
                          break;
                      }
                    }
                  }
                  while (1)
                  {
                    do
                    {
                      v69 = *(j - 4);
                      j -= 4;
                      v62 = v69;
                    }
                    while (v48 < v69);
                    if (v62 < v48)
                      break;
                    v70 = j[1];
                    if (v49 >= v70)
                    {
                      if (v70 < v49)
                        break;
                      v71 = j[2];
                      if (v50 >= v71 && (v71 < v50 || v51 >= j[3]))
                        break;
                    }
                  }
                }
                while (i < j);
              }
              if (i - 4 != v7)
              {
                *v7 = *(i - 4);
                v7[1] = *(i - 3);
                v7[2] = *(i - 2);
                v7[3] = *(i - 1);
              }
              a4 = 0;
              *(i - 4) = v48;
              *(i - 3) = v49;
              *(i - 2) = v50;
              *(i - 1) = v51;
              continue;
            }
          }
          v19 = *v7;
          v20 = v7[1];
          v21 = (char *)(v7 + 4);
          v23 = v7[2];
          v22 = v7[3];
          while (1)
          {
            v24 = *(_QWORD *)v21;
            if (*(_QWORD *)v21 >= v19)
            {
              if (v19 < v24)
                break;
              v25 = *((_QWORD *)v21 + 1);
              if (v25 >= v20)
              {
                if (v20 < v25)
                  break;
                v26 = *((_QWORD *)v21 + 2);
                if (v26 >= v23 && (v23 < v26 || *((_QWORD *)v21 + 3) >= v22))
                  break;
              }
            }
            v21 += 32;
          }
          if (v21 - 32 == (char *)v7)
          {
            k = v154;
            if (v21 < v154)
            {
              v32 = *v8;
              k = (char *)v8;
              if (*v8 >= v19)
              {
                k = (char *)v8;
                do
                {
                  if (v19 >= v32)
                  {
                    v33 = *((_QWORD *)k + 1);
                    if (v33 < v20)
                      break;
                    if (v20 >= v33)
                    {
                      v34 = *((_QWORD *)k + 2);
                      if (v34 < v23 || v23 >= v34 && *((_QWORD *)k + 3) < v22)
                        break;
                    }
                  }
                  if (v21 >= k)
                    break;
                  v35 = *((_QWORD *)k - 4);
                  k -= 32;
                  v32 = v35;
                }
                while (v35 >= v19);
              }
            }
          }
          else
          {
            v27 = *v8;
            for (k = (char *)v8; v27 >= v19; k -= 32)
            {
              if (v19 >= v27)
              {
                v29 = *((_QWORD *)k + 1);
                if (v29 < v20)
                  break;
                if (v20 >= v29)
                {
                  v30 = *((_QWORD *)k + 2);
                  if (v30 < v23 || v23 >= v30 && *((_QWORD *)k + 3) < v22)
                    break;
                }
              }
              v31 = *((_QWORD *)k - 4);
              v27 = v31;
            }
          }
          i = (uint64_t *)v21;
          if (v21 < k)
          {
            v36 = *(_QWORD *)k;
            i = (uint64_t *)v21;
            v37 = (uint64_t *)k;
            do
            {
              *i = v36;
              *v37 = v24;
              v38 = i[1];
              i[1] = v37[1];
              v37[1] = v38;
              v39 = i[2];
              i[2] = v37[2];
              v37[2] = v39;
              v40 = i[3];
              i[3] = v37[3];
              v37[3] = v40;
              while (1)
              {
                do
                {
                  v41 = i[4];
                  i += 4;
                  v24 = v41;
                }
                while (v41 < v19);
                if (v19 < v24)
                  break;
                v42 = i[1];
                if (v42 >= v20)
                {
                  if (v20 < v42)
                    break;
                  v43 = i[2];
                  if (v43 >= v23 && (v23 < v43 || i[3] >= v22))
                    break;
                }
              }
              while (1)
              {
                v44 = *(v37 - 4);
                v37 -= 4;
                v36 = v44;
                if (v44 < v19)
                  break;
                if (v19 >= v36)
                {
                  v45 = v37[1];
                  if (v45 < v20)
                    break;
                  if (v20 >= v45)
                  {
                    v46 = v37[2];
                    if (v46 < v23 || v23 >= v46 && v37[3] < v22)
                      break;
                  }
                }
              }
            }
            while (i < v37);
          }
          if (i - 4 != v7)
          {
            *v7 = *(i - 4);
            v7[1] = *(i - 3);
            v7[2] = *(i - 2);
            v7[3] = *(i - 1);
          }
          *(i - 4) = v19;
          *(i - 3) = v20;
          *(i - 2) = v23;
          *(i - 1) = v22;
          if (v21 < k)
          {
LABEL_64:
            result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *,false>(v7, i - 4, a3, a4 & 1);
            a4 = 0;
            continue;
          }
          v47 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(v7, (char *)i - 32);
          result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(i, v154);
          if (!(_DWORD)result)
          {
            if (v47)
              continue;
            goto LABEL_64;
          }
          a2 = (char *)(i - 4);
          if (v47)
            return result;
          goto LABEL_2;
        }
        v80 = (char *)(v7 + 4);
        v82 = v7 == (uint64_t *)a2 || v80 == a2;
        if ((a4 & 1) == 0)
        {
          if (!v82)
          {
            do
            {
              v136 = v80;
              result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(v80, v7);
              if ((_DWORD)result)
              {
                v137 = *(_QWORD *)v136;
                v138 = v7[5];
                v139 = v7[6];
                v140 = v7[7];
                v141 = *v7;
                while (1)
                {
                  do
                  {
                    v142 = v7;
                    v143 = v141;
                    v144 = *(v7 - 4);
                    v7 -= 4;
                    v141 = v144;
                    v7[8] = v143;
                    *(_OWORD *)(v7 + 9) = *(_OWORD *)(v7 + 5);
                    v7[11] = v7[7];
                  }
                  while (v137 < v144);
                  if (v141 < v137)
                    break;
                  v145 = *(v142 - 3);
                  if (v138 >= v145)
                  {
                    if (v145 < v138)
                      break;
                    v146 = *(v142 - 2);
                    if (v139 >= v146 && (v146 < v139 || v140 >= *(v142 - 1)))
                      break;
                  }
                }
                *v142 = v137;
                v142[1] = v138;
                v142[2] = v139;
                v142[3] = v140;
              }
              v80 = v136 + 32;
              v7 = (uint64_t *)v136;
            }
            while (v136 + 32 != a2);
          }
          return result;
        }
        if (v82)
          return result;
        v83 = 0;
        v84 = v7;
        do
        {
          v85 = v80;
          result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(v80, v84);
          if (!(_DWORD)result)
            goto LABEL_154;
          v86 = v84[4];
          v87 = v84[5];
          v88 = v84[6];
          v89 = v84[7];
          v90 = v84[1];
          v84[4] = *v84;
          *((_QWORD *)v85 + 1) = v90;
          *((_QWORD *)v85 + 2) = v84[2];
          *((_QWORD *)v85 + 3) = v84[3];
          v91 = v7;
          if (v84 == v7)
            goto LABEL_153;
          v92 = v83;
          while (1)
          {
            v93 = *(uint64_t *)((char *)v7 + v92 - 32);
            if (v86 < v93)
            {
              v94 = *(uint64_t *)((char *)v7 + v92 - 24);
              goto LABEL_150;
            }
            if (v93 < v86)
              goto LABEL_152;
            v94 = *(uint64_t *)((char *)v7 + v92 - 24);
            if (v87 >= v94)
            {
              if (v94 < v87)
                goto LABEL_152;
              v95 = *(uint64_t *)((char *)v7 + v92 - 16);
              if (v88 >= v95)
                break;
            }
LABEL_150:
            v84 -= 4;
            v96 = (char *)v7 + v92;
            *(_QWORD *)v96 = v93;
            *((_QWORD *)v96 + 1) = v94;
            *((_OWORD *)v96 + 1) = *(_OWORD *)((char *)v7 + v92 - 16);
            v92 -= 32;
            if (!v92)
            {
              v91 = v7;
              goto LABEL_153;
            }
          }
          if (v95 >= v88)
          {
            v91 = (uint64_t *)((char *)v7 + v92);
            if (v89 >= *(uint64_t *)((char *)v7 + v92 - 8))
              goto LABEL_153;
            goto LABEL_150;
          }
LABEL_152:
          v91 = v84;
LABEL_153:
          *v91 = v86;
          v91[1] = v87;
          v91[2] = v88;
          v91[3] = v89;
LABEL_154:
          v80 = v85 + 32;
          v83 += 32;
          v84 = (uint64_t *)v85;
        }
        while (v85 + 32 != a2);
        return result;
    }
  }
}

BOOL std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(_QWORD *a1, _QWORD *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;

  if (*a1 < *a2)
    return 1;
  if (*a2 < *a1)
    return 0;
  v2 = a1[1];
  v3 = a2[1];
  if (v2 < v3)
    return 1;
  if (v3 < v2)
    return 0;
  v4 = a1[2];
  v5 = a2[2];
  if (v4 < v5)
    return 1;
  return v5 >= v4 && a1[3] < a2[3];
}

BOOL std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  BOOL v6;
  _BOOL8 result;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v6 = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(a2, a1);
  result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(a3, a2);
  if (v6)
  {
    v9 = a1 + 3;
    v8 = *a1;
    if (result)
    {
      *a1 = *a3;
      *a3 = v8;
      v10 = a1[1];
      a1[1] = a3[1];
      a3[1] = v10;
      v11 = a1[2];
      a1[2] = a3[2];
    }
    else
    {
      *a1 = *a2;
      *a2 = v8;
      v20 = a1[1];
      a1[1] = a2[1];
      a2[1] = v20;
      v21 = a1[2];
      a1[2] = a2[2];
      a2[2] = v21;
      v9 = a2 + 3;
      v22 = a1[3];
      a1[3] = a2[3];
      a2[3] = v22;
      result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(a3, a2);
      if (!result)
        return result;
      v23 = *a2;
      *a2 = *a3;
      *a3 = v23;
      v24 = a2[1];
      a2[1] = a3[1];
      a3[1] = v24;
      v11 = a2[2];
      a2[2] = a3[2];
    }
    a3[2] = v11;
    v16 = a3 + 3;
    goto LABEL_10;
  }
  if (result)
  {
    v12 = *a2;
    *a2 = *a3;
    *a3 = v12;
    v13 = a2[1];
    a2[1] = a3[1];
    a3[1] = v13;
    v14 = a2[2];
    a2[2] = a3[2];
    a3[2] = v14;
    v16 = a2 + 3;
    v15 = a2[3];
    a2[3] = a3[3];
    a3[3] = v15;
    result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(a2, a1);
    if (result)
    {
      v17 = *a1;
      *a1 = *a2;
      *a2 = v17;
      v18 = a1[1];
      a1[1] = a2[1];
      a2[1] = v18;
      v19 = a1[2];
      a1[2] = a2[2];
      a2[2] = v19;
      v9 = a1 + 3;
LABEL_10:
      v25 = *v9;
      *v9 = *v16;
      *v16 = v25;
    }
  }
  return result;
}

BOOL std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  _BOOL8 result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(a1, a2, a3);
  result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(a4, a3);
  if (result)
  {
    v9 = *a3;
    *a3 = *a4;
    *a4 = v9;
    v10 = a3[1];
    a3[1] = a4[1];
    a4[1] = v10;
    v11 = a3[2];
    a3[2] = a4[2];
    a4[2] = v11;
    v12 = a3[3];
    a3[3] = a4[3];
    a4[3] = v12;
    result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(a3, a2);
    if (result)
    {
      v13 = *a2;
      *a2 = *a3;
      *a3 = v13;
      v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      v15 = a2[2];
      a2[2] = a3[2];
      a3[2] = v15;
      v16 = a2[3];
      a2[3] = a3[3];
      a3[3] = v16;
      result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(a2, a1);
      if (result)
      {
        v17 = *a1;
        *a1 = *a2;
        *a2 = v17;
        v18 = a1[1];
        a1[1] = a2[1];
        a2[1] = v18;
        v19 = a1[2];
        a1[2] = a2[2];
        a2[2] = v19;
        v20 = a1[3];
        a1[3] = a2[3];
        a2[3] = v20;
      }
    }
  }
  return result;
}

BOOL std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  _BOOL8 result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(a1, a2, a3, a4);
  result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(a5, a4);
  if (result)
  {
    v11 = *a4;
    *a4 = *a5;
    *a5 = v11;
    v12 = a4[1];
    a4[1] = a5[1];
    a5[1] = v12;
    v13 = a4[2];
    a4[2] = a5[2];
    a5[2] = v13;
    v14 = a4[3];
    a4[3] = a5[3];
    a5[3] = v14;
    result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(a4, a3);
    if (result)
    {
      v15 = *a3;
      *a3 = *a4;
      *a4 = v15;
      v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      v17 = a3[2];
      a3[2] = a4[2];
      a4[2] = v17;
      v18 = a3[3];
      a3[3] = a4[3];
      a4[3] = v18;
      result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(a3, a2);
      if (result)
      {
        v19 = *a2;
        *a2 = *a3;
        *a3 = v19;
        v20 = a2[1];
        a2[1] = a3[1];
        a3[1] = v20;
        v21 = a2[2];
        a2[2] = a3[2];
        a3[2] = v21;
        v22 = a2[3];
        a2[3] = a3[3];
        a3[3] = v22;
        result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(a2, a1);
        if (result)
        {
          v23 = *a1;
          *a1 = *a2;
          *a2 = v23;
          v24 = a1[1];
          a1[1] = a2[1];
          a2[1] = v24;
          v25 = a1[2];
          a1[2] = a2[2];
          a2[2] = v25;
          v26 = a1[3];
          a1[3] = a2[3];
          a2[3] = v26;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(uint64_t *a1, char *a2)
{
  uint64_t v4;
  _BOOL8 result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;

  v4 = (a2 - (char *)a1) >> 5;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>((_QWORD *)a2 - 4, a1))
      {
        v6 = *a1;
        *a1 = *((_QWORD *)a2 - 4);
        *((_QWORD *)a2 - 4) = v6;
        v7 = a1[1];
        a1[1] = *((_QWORD *)a2 - 3);
        *((_QWORD *)a2 - 3) = v7;
        v8 = a1[2];
        a1[2] = *((_QWORD *)a2 - 2);
        *((_QWORD *)a2 - 2) = v8;
        v9 = a1[3];
        a1[3] = *((_QWORD *)a2 - 1);
        *((_QWORD *)a2 - 1) = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(a1, a1 + 4, (uint64_t *)a2 - 4);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(a1, a1 + 4, a1 + 8, (uint64_t *)a2 - 4);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(a1, a1 + 4, a1 + 8, a1 + 12, (uint64_t *)a2 - 4);
      return 1;
    default:
      v10 = a1 + 8;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>(a1, a1 + 4, a1 + 8);
      v11 = a1 + 12;
      if (a1 + 12 == (uint64_t *)a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (2)
  {
    if (!std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>(v11, v10))goto LABEL_21;
    v14 = *v11;
    v15 = v11[1];
    v16 = v11[2];
    v17 = v11[3];
    *v11 = *v10;
    v11[1] = v10[1];
    v11[2] = v10[2];
    v11[3] = v10[3];
    v18 = a1;
    if (v10 == a1)
      goto LABEL_20;
    v19 = v12;
    while (1)
    {
      v20 = (char *)a1 + v19;
      v21 = *(uint64_t *)((char *)a1 + v19 + 32);
      if (v14 < v21)
      {
        v22 = *((_QWORD *)v20 + 5);
        goto LABEL_17;
      }
      if (v21 < v14)
        goto LABEL_19;
      v22 = *(uint64_t *)((char *)a1 + v19 + 40);
      if (v15 >= v22)
      {
        if (v22 < v15)
          goto LABEL_19;
        v23 = *(uint64_t *)((char *)a1 + v19 + 48);
        if (v16 >= v23)
        {
          if (v23 < v16)
          {
LABEL_19:
            v18 = v10;
            goto LABEL_20;
          }
          if (v17 >= *(uint64_t *)((char *)a1 + v19 + 56))
            break;
        }
      }
LABEL_17:
      v10 -= 4;
      *((_QWORD *)v20 + 8) = v21;
      v24 = (char *)a1 + v19;
      *((_QWORD *)v24 + 9) = v22;
      *((_OWORD *)v24 + 5) = *(_OWORD *)((char *)a1 + v19 + 48);
      v19 -= 32;
      if (v19 == -64)
      {
        v18 = a1;
        goto LABEL_20;
      }
    }
    v18 = (uint64_t *)((char *)a1 + v19 + 64);
LABEL_20:
    *v18 = v14;
    v18[1] = v15;
    v18[2] = v16;
    v18[3] = v17;
    if (++v13 != 8)
    {
LABEL_21:
      v10 = v11;
      v12 += 32;
      v11 += 4;
      if (v11 == (uint64_t *)a2)
        return 1;
      continue;
    }
    return v11 + 4 == (uint64_t *)a2;
  }
}

id GRCSplitBlitTimeData::CalculateBlitEncoderTime(uint64_t a1, void *a2, void *a3)
{
  unint64_t v3;
  unsigned int v5;
  id v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  uint64_t **v13;
  uint64_t *i;
  unint64_t v15;
  char *v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  id v27;
  id v28;
  uint64_t v29;
  void *j;
  id v31;
  id v32;
  char *v33;
  char *v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  char *v45;
  char *v46;
  void *v47;
  _BOOL4 v48;
  NSData *v49;
  int NextMarker;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  char *v54;
  char *v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  char *v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  _QWORD *v67;
  _QWORD *v68;
  unint64_t v69;
  unint64_t v70;
  BOOL v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  char *v79;
  _QWORD *v80;
  uint64_t v81;
  uint8x8_t v82;
  unint64_t v83;
  uint64_t **v84;
  uint64_t *v85;
  unint64_t v86;
  uint64_t v87;
  NSData *v88;
  int v89;
  char *v90;
  uint64_t v91;
  char *v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  char *v96;
  uint64_t v97;
  double v98;
  int v99;
  int v100;
  double v101;
  unint64_t v102;
  uint64_t v103;
  uint64_t *v104;
  char v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  int v109;
  BOOL v110;
  int v111;
  int v112;
  char *v113;
  char v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  unsigned int v119;
  uint64_t v120;
  int v121;
  unint64_t v122;
  uint64_t v123;
  unint64_t v124;
  uint8x8_t v125;
  unint64_t v126;
  void **v127;
  __int128 *v128;
  uint64_t v129;
  unint64_t v130;
  __int128 *v131;
  __int128 *v132;
  __int128 *v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  id v137;
  char *v138;
  uint64_t **k;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  char *v143;
  double v144;
  id v145;
  id v147;
  int v148;
  void *v149;
  void *v150;
  id v151;
  __int128 v153;
  __int128 v154;
  int v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  void *__p;
  char *v161;
  unint64_t v162;
  __int128 v163;
  __int128 v164;
  float v165;
  void **p_p;
  _BYTE v167[128];

  v151 = a2;
  v147 = a3;
  v5 = objc_msgSend(v147, "length");
  v6 = objc_retainAutorelease(v147);
  v7 = (unsigned int *)objc_msgSend(v6, "bytes");
  v149 = v6;
  LODWORD(v8) = v5 >> 2;
  v163 = 0u;
  v164 = 0u;
  v165 = 0.3;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)&v163, vcvtps_u32_f32((float)(v5 >> 2) / 0.3));
  if (v5 >= 4)
  {
    v9 = 0;
    if (v8 <= 1)
      v8 = 1;
    else
      v8 = v8;
    v10 = *((_QWORD *)&v163 + 1);
    do
    {
      v11 = v7[v9];
      if (v10)
      {
        v12 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
        v12.i16[0] = vaddlv_u8(v12);
        if (v12.u32[0] > 1uLL)
        {
          v3 = v7[v9];
          if (v10 <= v11)
            v3 = v11 % v10;
        }
        else
        {
          v3 = ((_DWORD)v10 - 1) & v11;
        }
        v13 = *(uint64_t ***)(v163 + 8 * v3);
        if (v13)
        {
          for (i = *v13; i; i = (uint64_t *)*i)
          {
            v15 = i[1];
            if (v15 == v11)
            {
              if (*((_DWORD *)i + 4) == (_DWORD)v11)
                goto LABEL_44;
            }
            else
            {
              if (v12.u32[0] > 1uLL)
              {
                if (v15 >= v10)
                  v15 %= v10;
              }
              else
              {
                v15 &= v10 - 1;
              }
              if (v15 != v3)
                break;
            }
          }
        }
      }
      v16 = (char *)operator new(0x40uLL);
      *(_QWORD *)v16 = 0;
      *((_QWORD *)v16 + 1) = v11;
      *((_DWORD *)v16 + 4) = v11;
      *(_OWORD *)(v16 + 24) = 0u;
      *(_OWORD *)(v16 + 40) = 0u;
      *((_DWORD *)v16 + 14) = 0;
      *((_DWORD *)v16 + 15) = v9;
      v17 = (float)(unint64_t)(*((_QWORD *)&v164 + 1) + 1);
      if (!v10 || (float)(v165 * (float)v10) < v17)
      {
        v18 = (v10 & (v10 - 1)) != 0;
        if (v10 < 3)
          v18 = 1;
        v19 = v18 | (2 * v10);
        v20 = vcvtps_u32_f32(v17 / v165);
        if (v19 <= v20)
          v21 = v20;
        else
          v21 = v19;
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)&v163, v21);
        v10 = *((_QWORD *)&v163 + 1);
        if ((*((_QWORD *)&v163 + 1) & (*((_QWORD *)&v163 + 1) - 1)) != 0)
        {
          if (*((_QWORD *)&v163 + 1) <= v11)
            v3 = v11 % *((_QWORD *)&v163 + 1);
          else
            v3 = v11;
        }
        else
        {
          v3 = (DWORD2(v163) - 1) & v11;
        }
      }
      v22 = v163;
      v23 = *(_QWORD **)(v163 + 8 * v3);
      if (v23)
      {
        *(_QWORD *)v16 = *v23;
      }
      else
      {
        *(_QWORD *)v16 = v164;
        *(_QWORD *)&v164 = v16;
        *(_QWORD *)(v22 + 8 * v3) = &v164;
        if (!*(_QWORD *)v16)
          goto LABEL_43;
        v24 = *(_QWORD *)(*(_QWORD *)v16 + 8);
        if ((v10 & (v10 - 1)) != 0)
        {
          if (v24 >= v10)
            v24 %= v10;
        }
        else
        {
          v24 &= v10 - 1;
        }
        v23 = (_QWORD *)(v163 + 8 * v24);
      }
      *v23 = v16;
LABEL_43:
      ++*((_QWORD *)&v164 + 1);
LABEL_44:
      ++v9;
    }
    while (v9 != v8);
  }
  v25 = (unint64_t)objc_msgSend(v151, "count");
  v26 = v25;
  if (v25)
  {
    if (v25 >> 62)
      abort();
    v150 = std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v25);
    bzero(v150, 4 * v26);
  }
  else
  {
    v150 = 0;
  }
  __p = 0;
  v161 = 0;
  v162 = 0;
  std::vector<std::pair<unsigned int,unsigned int>>::reserve(&__p, (unint64_t)objc_msgSend(v151, "count"));
  v158 = 0u;
  v159 = 0u;
  v156 = 0u;
  v157 = 0u;
  v27 = v151;
  v28 = objc_msgSend(v27, "countByEnumeratingWithState:objects:count:", &v156, v167, 16);
  if (v28)
  {
    v29 = *(_QWORD *)v157;
    do
    {
      for (j = 0; j != v28; j = (char *)j + 1)
      {
        if (*(_QWORD *)v157 != v29)
          objc_enumerationMutation(v27);
        v31 = objc_msgSend(objc_retainAutorelease(*(id *)(*((_QWORD *)&v156 + 1) + 8 * (_QWORD)j)), "bytes");
        v32 = v31;
        v33 = v161;
        if ((unint64_t)v161 >= v162)
        {
          v35 = (v161 - (_BYTE *)__p) >> 3;
          if ((unint64_t)(v35 + 1) >> 61)
            abort();
          v36 = (uint64_t)(v162 - (_QWORD)__p) >> 2;
          if (v36 <= v35 + 1)
            v36 = v35 + 1;
          if (v162 - (unint64_t)__p >= 0x7FFFFFFFFFFFFFF8)
            v37 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v37 = v36;
          if (v37)
            v37 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v37);
          else
            v38 = 0;
          v39 = (char *)(v37 + 8 * v35);
          *(_QWORD *)v39 = v32;
          v34 = v39 + 8;
          v41 = (char *)__p;
          v40 = v161;
          if (v161 != __p)
          {
            do
            {
              v42 = *((_QWORD *)v40 - 1);
              v40 -= 8;
              *((_QWORD *)v39 - 1) = v42;
              v39 -= 8;
            }
            while (v40 != v41);
            v40 = (char *)__p;
          }
          __p = v39;
          v161 = v34;
          v162 = v37 + 8 * v38;
          if (v40)
            operator delete(v40);
        }
        else
        {
          *(_QWORD *)v161 = v31;
          v34 = v33 + 8;
        }
        v161 = v34;
      }
      v28 = objc_msgSend(v27, "countByEnumeratingWithState:objects:count:", &v156, v167, 16);
    }
    while (v28);
  }

  if (v161 == __p)
  {
    v90 = 0;
    v153 = 0u;
    v154 = 0u;
    v155 = 1065353216;
    goto LABEL_238;
  }
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  do
  {
    v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v27, "objectAtIndexedSubscript:", v43));
    v48 = (unint64_t)objc_msgSend(v47, "length") > 0x3F;

    if (v48)
    {
      v49 = (NSData *)objc_claimAutoreleasedReturnValue(objc_msgSend(v27, "objectAtIndexedSubscript:", v43));
      NextMarker = FindNextMarker(v49, 0, *(_QWORD *)(a1 + 8));

      if (NextMarker != -1)
      {
        if (v45 >= v46)
        {
          v51 = (v45 - v44) >> 3;
          v52 = v51 + 1;
          if ((unint64_t)(v51 + 1) >> 61)
            abort();
          if ((v46 - v44) >> 2 > v52)
            v52 = (v46 - v44) >> 2;
          if ((unint64_t)(v46 - v44) >= 0x7FFFFFFFFFFFFFF8)
            v53 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v53 = v52;
          if (v53 >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v54 = (char *)operator new(8 * v53);
          v55 = &v54[8 * v51];
          *(_DWORD *)v55 = v43;
          *((_DWORD *)v55 + 1) = 0;
          v56 = v55;
          while (v45 != v44)
          {
            v57 = *((_QWORD *)v45 - 1);
            v45 -= 8;
            *((_QWORD *)v56 - 1) = v57;
            v56 -= 8;
          }
          v46 = &v54[8 * v53];
          v45 = v55 + 8;
          if (v44)
            operator delete(v44);
          v44 = v56;
        }
        else
        {
          *(_DWORD *)v45 = v43;
          *((_DWORD *)v45 + 1) = 0;
          v45 += 8;
        }
        *(_QWORD *)&v153 = &__p;
        std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::$_0 &,std::__wrap_iter<GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::PriorityQueueElement *>>((uint64_t)v44, (uint64_t)v45, (uint64_t **)&v153, (v45 - v44) >> 3);
      }
    }
    ++v43;
  }
  while (v43 < (v161 - (_BYTE *)__p) >> 3);
  v153 = 0u;
  v154 = 0u;
  v155 = 1065353216;
  if (v44 == v45)
  {
    v90 = v45;
    goto LABEL_238;
  }
  v58 = 0;
  v148 = 0;
  do
  {
    v59 = *(_QWORD *)v44;
    p_p = &__p;
    if (v45 - v44 < 9)
      goto LABEL_114;
    v60 = 0;
    v61 = (v45 - v44) >> 3;
    v62 = *(_QWORD *)v44;
    v63 = v44;
    do
    {
      v64 = v63;
      v63 += 8 * v60 + 8;
      v65 = 2 * v60;
      v60 = (2 * v60) | 1;
      v66 = v65 + 2;
      if (v66 >= v61)
        goto LABEL_110;
      v67 = (_QWORD *)(*((_QWORD *)*p_p + *(unsigned int *)v63) + 8 * *((unsigned int *)v63 + 1));
      v68 = (_QWORD *)(*((_QWORD *)*p_p + *((unsigned int *)v63 + 2)) + 8 * *((unsigned int *)v63 + 3));
      v69 = v67[1];
      v70 = v68[1];
      v71 = v69 > v70;
      if (v69 == v70
        && (v72 = v67[4], v73 = v68[4], v71 = v72 > v73, v72 == v73)
        && (v74 = v67[5], v75 = v68[5], v71 = v74 > v75, v74 == v75))
      {
        v76 = v67[3];
        v77 = v68[3];
        if (v76 > v69 && v76 != v77)
        {
LABEL_109:
          v63 += 8;
          v60 = v66;
        }
      }
      else if (v71)
      {
        goto LABEL_109;
      }
LABEL_110:
      *(_QWORD *)v64 = *(_QWORD *)v63;
    }
    while (v60 <= (uint64_t)((unint64_t)(v61 - 2) >> 1));
    v79 = v45 - 8;
    if (v63 == v45 - 8)
    {
      *(_QWORD *)v63 = v62;
    }
    else
    {
      *(_QWORD *)v63 = *(_QWORD *)v79;
      *(_QWORD *)v79 = v62;
      std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::$_0 &,std::__wrap_iter<GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::PriorityQueueElement *>>((uint64_t)v44, (uint64_t)(v63 + 8), (uint64_t **)&p_p, (v63 + 8 - v44) >> 3);
    }
LABEL_114:
    if (!*((_QWORD *)&v163 + 1))
      goto LABEL_131;
    v80 = (_QWORD *)(*((_QWORD *)__p + v59) + 8 * HIDWORD(v59));
    v81 = v80[4];
    v82 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v163 + 8));
    v82.i16[0] = vaddlv_u8(v82);
    if (v82.u32[0] > 1uLL)
    {
      v83 = v80[4];
      if (*((_QWORD *)&v163 + 1) <= (unint64_t)v81)
        v83 = (unint64_t)v81 % *((_QWORD *)&v163 + 1);
    }
    else
    {
      v83 = (DWORD2(v163) - 1) & v81;
    }
    v84 = *(uint64_t ***)(v163 + 8 * v83);
    if (!v84)
    {
LABEL_131:
      v87 = v58;
      goto LABEL_132;
    }
    v85 = *v84;
    if (!*v84)
    {
LABEL_130:
      v87 = v58;
      goto LABEL_132;
    }
    while (2)
    {
      v86 = v85[1];
      if (v86 != v81)
      {
        if (v82.u32[0] > 1uLL)
        {
          if (v86 >= *((_QWORD *)&v163 + 1))
            v86 %= *((_QWORD *)&v163 + 1);
        }
        else
        {
          v86 &= *((_QWORD *)&v163 + 1) - 1;
        }
        if (v86 != v83)
          goto LABEL_130;
LABEL_129:
        v85 = (uint64_t *)*v85;
        if (!v85)
          goto LABEL_130;
        continue;
      }
      break;
    }
    if (*((_DWORD *)v85 + 4) != (_DWORD)v81)
      goto LABEL_129;
    v87 = v80[1];
    v98 = (double)(unint64_t)(v87 - v58);
    v99 = v148;
    if (v148 <= 1)
      v100 = 1;
    else
      v100 = v148;
    v101 = v98 / (double)v100 * 125.0 / 3.0;
    v102 = v80[3];
    v103 = (v102 >> 1) & 3;
    v104 = (uint64_t *)v154;
    if ((v102 & 1) != 0)
    {
      if (!(_QWORD)v154)
        goto LABEL_183;
      v114 = 0;
      do
      {
        v115 = 0;
        v116 = v104[3];
        v117 = v116 + 24;
        do
        {
          if (*(_DWORD *)(v116 + 4 * v115 + 24))
            *(double *)(v116 + 8 * v115) = v101 + *(double *)(v116 + 8 * v115);
          ++v115;
        }
        while (v115 != 3);
        if (v81 == *((_DWORD *)v104 + 4))
        {
          v118 = *(_DWORD *)(v117 + 4 * v103);
          if (v118)
          {
            v119 = v118 - 1;
            *(_DWORD *)(v117 + 4 * v103) = v119;
            v99 = (__PAIR64__(v99, v119) - 1) >> 32;
          }
          else
          {
            ++v99;
          }
          v114 = 1;
        }
        v104 = (uint64_t *)*v104;
      }
      while (v104);
      if ((v114 & 1) == 0)
      {
LABEL_183:
        --*((_DWORD *)v85 + v103 + 12);
        v113 = std::unordered_map<unsigned int,GRCSplitBlitTimeData::CalculateBlitEncoderTime(NSArray<NSData *> *,NSData *)::TimeInfo *,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const,GRCSplitBlitTimeData::CalculateBlitEncoderTime(NSArray<NSData *> *,NSData *)::TimeInfo *>>>::operator[]((float *)&v153, v81);
LABEL_184:
        *(_QWORD *)v113 = v85 + 3;
        ++v99;
      }
    }
    else
    {
      if (!(_QWORD)v154)
        goto LABEL_169;
      v105 = 0;
      do
      {
        v106 = 0;
        v107 = v104[3];
        v108 = v107 + 24;
        do
        {
          if (*(_DWORD *)(v107 + 4 * v106 + 24))
            *(double *)(v107 + 8 * v106) = v101 + *(double *)(v107 + 8 * v106);
          ++v106;
        }
        while (v106 != 3);
        if (v81 == *((_DWORD *)v104 + 4))
        {
          v109 = *(_DWORD *)(v108 + 4 * v103);
          if (v109)
          {
            v110 = __CFADD__(v109, 1);
            v111 = v109 + 1;
            v112 = v110;
            *(_DWORD *)(v108 + 4 * v103) = v111;
            v99 -= v112;
          }
          else
          {
            ++v99;
          }
          v105 = 1;
        }
        v104 = (uint64_t *)*v104;
      }
      while (v104);
      if ((v105 & 1) == 0)
      {
LABEL_169:
        ++*((_DWORD *)v85 + v103 + 12);
        v113 = std::unordered_map<unsigned int,GRCSplitBlitTimeData::CalculateBlitEncoderTime(NSArray<NSData *> *,NSData *)::TimeInfo *,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const,GRCSplitBlitTimeData::CalculateBlitEncoderTime(NSArray<NSData *> *,NSData *)::TimeInfo *>>>::operator[]((float *)&v153, v81);
        goto LABEL_184;
      }
    }
    v120 = 0;
    v121 = 0;
    do
    {
      if (*(_DWORD *)((char *)v85 + v120 + 48))
        ++v121;
      v120 += 4;
    }
    while (v120 != 12);
    v148 = v99;
    if (v121)
      goto LABEL_132;
    v122 = *((_QWORD *)&v153 + 1);
    if (!*((_QWORD *)&v153 + 1))
      goto LABEL_132;
    v123 = v80[4];
    v124 = v123;
    v125 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v153 + 8));
    v125.i16[0] = vaddlv_u8(v125);
    if (v125.u32[0] > 1uLL)
    {
      v126 = v80[4];
      if (*((_QWORD *)&v153 + 1) <= (unint64_t)v123)
        v126 = (unint64_t)v123 % *((_QWORD *)&v153 + 1);
    }
    else
    {
      v126 = (DWORD2(v153) - 1) & v123;
    }
    v127 = *(void ***)(v153 + 8 * v126);
    if (!v127)
      goto LABEL_132;
    v128 = (__int128 *)*v127;
    if (!*v127)
      goto LABEL_132;
    v129 = *((_QWORD *)&v153 + 1) - 1;
    while (2)
    {
      v130 = *((_QWORD *)v128 + 1);
      if (v130 != v123)
      {
        if (v125.u32[0] > 1uLL)
        {
          if (v130 >= *((_QWORD *)&v153 + 1))
            v130 %= *((_QWORD *)&v153 + 1);
        }
        else
        {
          v130 &= v129;
        }
        if (v130 != v126)
          goto LABEL_132;
LABEL_206:
        v128 = *(__int128 **)v128;
        if (!v128)
          goto LABEL_132;
        continue;
      }
      break;
    }
    if (*((_DWORD *)v128 + 4) != (_DWORD)v123)
      goto LABEL_206;
    if (v125.u32[0] > 1uLL)
    {
      if (*((_QWORD *)&v153 + 1) <= (unint64_t)v123)
        v124 = (unint64_t)v123 % *((_QWORD *)&v153 + 1);
    }
    else
    {
      v124 = v129 & v123;
    }
    v131 = *(__int128 **)v128;
    v132 = *(__int128 **)(v153 + 8 * v124);
    do
    {
      v133 = v132;
      v132 = *(__int128 **)v132;
    }
    while (v132 != v128);
    if (v133 == &v154)
      goto LABEL_225;
    v134 = *((_QWORD *)v133 + 1);
    if (v125.u32[0] > 1uLL)
    {
      if (v134 >= *((_QWORD *)&v153 + 1))
        v134 %= *((_QWORD *)&v153 + 1);
    }
    else
    {
      v134 &= v129;
    }
    if (v134 == v124)
    {
LABEL_227:
      if (v131)
      {
        v135 = *((_QWORD *)v131 + 1);
        goto LABEL_229;
      }
    }
    else
    {
LABEL_225:
      if (!v131)
        goto LABEL_226;
      v135 = *((_QWORD *)v131 + 1);
      if (v125.u32[0] > 1uLL)
      {
        v136 = *((_QWORD *)v131 + 1);
        if (v135 >= *((_QWORD *)&v153 + 1))
          v136 = v135 % *((_QWORD *)&v153 + 1);
      }
      else
      {
        v136 = v135 & v129;
      }
      if (v136 != v124)
      {
LABEL_226:
        *(_QWORD *)(v153 + 8 * v124) = 0;
        v131 = *(__int128 **)v128;
        goto LABEL_227;
      }
LABEL_229:
      if (v125.u32[0] > 1uLL)
      {
        if (v135 >= v122)
          v135 %= v122;
      }
      else
      {
        v135 &= v129;
      }
      if (v135 != v124)
      {
        *(_QWORD *)(v153 + 8 * v135) = v133;
        v131 = *(__int128 **)v128;
      }
    }
    *(_QWORD *)v133 = v131;
    --*((_QWORD *)&v154 + 1);
    operator delete(v128);
LABEL_132:
    v88 = (NSData *)objc_claimAutoreleasedReturnValue(objc_msgSend(v27, "objectAtIndexedSubscript:", v59));
    v89 = FindNextMarker(v88, HIDWORD(v59) + 8, *(_QWORD *)(a1 + 8));

    v90 = v45 - 8;
    if (v89 != -1)
    {
      if (v90 >= v46)
      {
        v93 = (v90 - v44) >> 3;
        v94 = v93 + 1;
        if ((unint64_t)(v93 + 1) >> 61)
          abort();
        if ((v46 - v44) >> 2 > v94)
          v94 = (v46 - v44) >> 2;
        if ((unint64_t)(v46 - v44) >= 0x7FFFFFFFFFFFFFF8)
          v95 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v95 = v94;
        if (v95 >> 61)
          std::__throw_bad_array_new_length[abi:nn180100]();
        v96 = (char *)operator new(8 * v95);
        v92 = &v96[8 * v93];
        *(_DWORD *)v92 = v59;
        *((_DWORD *)v92 + 1) = v89;
        v91 = (uint64_t)v92;
        if (v90 != v44)
        {
          v91 = (uint64_t)v92;
          do
          {
            v97 = *((_QWORD *)v90 - 1);
            v90 -= 8;
            *(_QWORD *)(v91 - 8) = v97;
            v91 -= 8;
          }
          while (v90 != v44);
        }
        v46 = &v96[8 * v95];
        operator delete(v44);
        v44 = (char *)v91;
      }
      else
      {
        *((_DWORD *)v45 - 2) = v59;
        *((_DWORD *)v45 - 1) = v89;
        v91 = (uint64_t)v44;
        v92 = v90;
      }
      v90 = v92 + 8;
      p_p = &__p;
      std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::$_0 &,std::__wrap_iter<GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::PriorityQueueElement *>>(v91, (uint64_t)(v92 + 8), (uint64_t **)&p_p, (uint64_t)&v92[-v91 + 8] >> 3);
    }
    v58 = v87;
    v45 = v90;
  }
  while (v44 != v90);
LABEL_238:
  v137 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](NSMutableData, "dataWithLength:", 32 * *((_QWORD *)&v164 + 1))));
  v138 = (char *)objc_msgSend(v137, "mutableBytes");
  for (k = (uint64_t **)v164; k; k = (uint64_t **)*k)
  {
    v140 = 0;
    v141 = *((unsigned int *)k + 15);
    v142 = 4 * v141;
    v143 = &v138[32 * v141];
    v144 = 0.0;
    do
    {
      *(_QWORD *)&v143[v140 * 8] = k[v140 + 3];
      v144 = v144 + *(double *)&k[v140 + 3];
      ++v140;
    }
    while (v140 != 3);
    *(double *)&v138[(8 * v142) | 0x18] = v144;
  }
  v145 = v137;

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v153);
  if (v90)
    operator delete(v90);
  if (__p)
  {
    v161 = (char *)__p;
    operator delete(__p);
  }
  if (v150)
    operator delete(v150);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v163);

  return v145;
}

void sub_2E40DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,uint64_t a34,char a35)
{
  void *v35;

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a17);
  if (v35)
    operator delete(v35);
  if (__p)
  {
    a33 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a14)
    operator delete(a14);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a35);

  _Unwind_Resume(a1);
}

char *std::unordered_map<unsigned int,GRCSplitBlitTimeData::CalculateBlitEncoderTime(NSArray<NSData *> *,NSData *)::TimeInfo *,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const,GRCSplitBlitTimeData::CalculateBlitEncoderTime(NSArray<NSData *> *,NSData *)::TimeInfo *>>>::operator[](float *a1, unsigned int a2)
{
  unint64_t v2;
  unint64_t v5;
  unint64_t v6;
  uint8x8_t v7;
  void **v8;
  _QWORD *v9;
  unint64_t v10;
  float v11;
  float v12;
  _BOOL4 v13;
  unint64_t v14;
  unint64_t v15;
  int8x8_t prime;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;
  uint8x8_t v22;
  unint64_t v23;
  uint8x8_t v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  unint64_t v30;
  _QWORD *v32;

  v5 = a2;
  v6 = *((_QWORD *)a1 + 1);
  if (v6)
  {
    v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      v2 = a2;
      if (v6 <= a2)
        v2 = a2 % v6;
    }
    else
    {
      v2 = ((_DWORD)v6 - 1) & a2;
    }
    v8 = *(void ***)(*(_QWORD *)a1 + 8 * v2);
    if (v8)
    {
      v9 = *v8;
      if (*v8)
      {
        do
        {
          v10 = v9[1];
          if (v10 == a2)
          {
            if (*((_DWORD *)v9 + 4) == a2)
              return (char *)(v9 + 3);
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v10 >= v6)
                v10 %= v6;
            }
            else
            {
              v10 &= v6 - 1;
            }
            if (v10 != v2)
              break;
          }
          v9 = (_QWORD *)*v9;
        }
        while (v9);
      }
    }
  }
  v9 = operator new(0x20uLL);
  *v9 = 0;
  v9[1] = v5;
  *((_DWORD *)v9 + 4) = a2;
  v9[3] = 0;
  v11 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v12 = a1[8];
  if (v6 && (float)(v12 * (float)v6) >= v11)
  {
    v5 = v2;
    goto LABEL_64;
  }
  v13 = (v6 & (v6 - 1)) == 0;
  if (v6 < 3)
    v13 = 0;
  v14 = (2 * v6) | !v13;
  v15 = vcvtps_u32_f32(v11 / v12);
  if (v14 <= v15)
    prime = (int8x8_t)v15;
  else
    prime = (int8x8_t)v14;
  if (*(_QWORD *)&prime == 1)
  {
    prime = (int8x8_t)2;
  }
  else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
  {
    prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    v6 = *((_QWORD *)a1 + 1);
  }
  if (*(_QWORD *)&prime <= v6)
  {
    if (*(_QWORD *)&prime >= v6)
      goto LABEL_60;
    v23 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v6 < 3 || (v24 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v24.i16[0] = vaddlv_u8(v24), v24.u32[0] > 1uLL))
    {
      v23 = std::__next_prime(v23);
    }
    else
    {
      v25 = 1 << -(char)__clz(v23 - 1);
      if (v23 >= 2)
        v23 = v25;
    }
    if (*(_QWORD *)&prime <= v23)
      prime = (int8x8_t)v23;
    if (*(_QWORD *)&prime >= v6)
    {
      v6 = *((_QWORD *)a1 + 1);
      goto LABEL_60;
    }
    if (!*(_QWORD *)&prime)
    {
      v32 = *(_QWORD **)a1;
      *(_QWORD *)a1 = 0;
      if (v32)
        operator delete(v32);
      v6 = 0;
      *((_QWORD *)a1 + 1) = 0;
      goto LABEL_60;
    }
  }
  if (*(_QWORD *)&prime >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  v17 = operator new(8 * *(_QWORD *)&prime);
  v18 = *(_QWORD **)a1;
  *(_QWORD *)a1 = v17;
  if (v18)
    operator delete(v18);
  v19 = 0;
  *((int8x8_t *)a1 + 1) = prime;
  do
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v19++) = 0;
  while (*(_QWORD *)&prime != v19);
  v20 = (_QWORD *)*((_QWORD *)a1 + 2);
  if (v20)
  {
    v21 = v20[1];
    v22 = (uint8x8_t)vcnt_s8(prime);
    v22.i16[0] = vaddlv_u8(v22);
    if (v22.u32[0] > 1uLL)
    {
      if (v21 >= *(_QWORD *)&prime)
        v21 %= *(_QWORD *)&prime;
    }
    else
    {
      v21 &= *(_QWORD *)&prime - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v21) = a1 + 4;
    v26 = (_QWORD *)*v20;
    if (*v20)
    {
      do
      {
        v27 = v26[1];
        if (v22.u32[0] > 1uLL)
        {
          if (v27 >= *(_QWORD *)&prime)
            v27 %= *(_QWORD *)&prime;
        }
        else
        {
          v27 &= *(_QWORD *)&prime - 1;
        }
        if (v27 != v21)
        {
          if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v27))
          {
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v27) = v20;
            goto LABEL_56;
          }
          *v20 = *v26;
          *v26 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v27);
          **(_QWORD **)(*(_QWORD *)a1 + 8 * v27) = v26;
          v26 = v20;
        }
        v27 = v21;
LABEL_56:
        v20 = v26;
        v26 = (_QWORD *)*v26;
        v21 = v27;
      }
      while (v26);
    }
  }
  v6 = (unint64_t)prime;
LABEL_60:
  if ((v6 & (v6 - 1)) != 0)
  {
    if (v6 <= v5)
      v5 %= v6;
  }
  else
  {
    v5 = ((_DWORD)v6 - 1) & v5;
  }
LABEL_64:
  v28 = *(_QWORD **)a1;
  v29 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v5);
  if (v29)
  {
    *v9 = *v29;
LABEL_72:
    *v29 = v9;
    goto LABEL_73;
  }
  *v9 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = v9;
  v28[v5] = a1 + 4;
  if (*v9)
  {
    v30 = *(_QWORD *)(*v9 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v30 >= v6)
        v30 %= v6;
    }
    else
    {
      v30 &= v6 - 1;
    }
    v29 = (_QWORD *)(*(_QWORD *)a1 + 8 * v30);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
  return (char *)(v9 + 3);
}

void sub_2E45BC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

id GRCSplitBlitTimeData::BlitFrameEncoderTimeData(id *this, NSString *a2, NSString *a3)
{
  NSString *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSSet *v14;
  void *v15;
  void *v16;
  id v17;
  void *v18;
  id v19;
  id v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v24;
  id v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  double *v29;
  uint64_t v30;
  double v31;
  _QWORD v33[6];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  __n128 (*v37)(__n128 *, __n128 *);
  void (*v38)(uint64_t);
  void *v39;
  void *__p;
  void *v41;
  uint64_t v42;
  id v43;

  v5 = a3;
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*this, "objectForKeyedSubscript:", a2));
  if (v7)
  {
    v8 = objc_opt_class(NSDictionary, v6);
    v10 = objc_opt_class(NSArray, v9);
    v12 = objc_opt_class(NSNumber, v11);
    v14 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v8, v10, v12, objc_opt_class(NSNull, v13), 0);
    v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
    v43 = 0;
    v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:](NSKeyedUnarchiver, "unarchivedObjectOfClasses:fromData:error:", v15, v7, &v43));
    v17 = v43;

    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*this, "objectForKeyedSubscript:", v5));
    if (objc_msgSend(v16, "count") && objc_msgSend(v18, "length"))
    {
      v19 = objc_retainAutorelease(v18);
      v20 = objc_msgSend(v19, "bytes");
      v34 = 0;
      v35 = &v34;
      v36 = 0x4812000000;
      v37 = __Block_byref_object_copy__186;
      v38 = __Block_byref_object_dispose__187;
      v39 = &unk_4C2897;
      __p = 0;
      v41 = 0;
      v42 = 0;
      std::vector<std::pair<unsigned long long,unsigned long long>>::reserve(&__p, (unint64_t)objc_msgSend(v19, "length") >> 3);
      v33[0] = _NSConcreteStackBlock;
      v33[1] = 3221225472;
      v33[2] = ___ZN20GRCSplitBlitTimeData24BlitFrameEncoderTimeDataEP8NSStringS1__block_invoke;
      v33[3] = &unk_726A80;
      v33[4] = &v34;
      v33[5] = v20;
      objc_msgSend(v16, "enumerateKeysAndObjectsUsingBlock:", v33);
      v21 = v35[6];
      v22 = (unint64_t *)v35[7];
      v23 = 126 - 2 * __clz((uint64_t)((uint64_t)v22 - v21) >> 4);
      if (v22 == (unint64_t *)v21)
        v24 = 0;
      else
        v24 = v23;
      std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>(v21, v22, v24, 1);
      v25 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](NSMutableData, "dataWithLength:", 2 * (v35[7] - v35[6]))));
      v26 = (char *)objc_msgSend(v25, "mutableBytes");
      v27 = v35[6];
      if (v35[7] != v27)
      {
        v28 = 0;
        v29 = (double *)(v26 + 24);
        v30 = 8;
        do
        {
          v31 = (double)*(unint64_t *)(v27 + v30);
          *(v29 - 2) = v31;
          *v29 = v31;
          v29 += 4;
          ++v28;
          v27 = v35[6];
          v30 += 16;
        }
        while (v28 < (v35[7] - v27) >> 4);
      }
      _Block_object_dispose(&v34, 8);
      if (__p)
      {
        v41 = __p;
        operator delete(__p);
      }
    }
    else
    {
      v25 = 0;
    }

  }
  else
  {
    v25 = 0;
  }

  return v25;
}

void sub_2E4874(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;

  _Block_object_dispose(&a19, 8);
  if (__p)
  {
    a26 = (uint64_t)__p;
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__186(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__187(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void ___ZN20GRCSplitBlitTimeData24BlitFrameEncoderTimeDataEP8NSStringS1__block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5;
  unsigned int v6;
  void *v7;
  unsigned int v8;
  void *v9;
  unsigned int v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  uint64_t v23;
  char *v24;
  char *v25;
  char *v26;
  id v27;

  v27 = a2;
  v5 = a3;
  v6 = objc_msgSend(v27, "unsignedIntValue");
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectAtIndexedSubscript:", 0));
  v8 = objc_msgSend(v7, "unsignedIntValue");

  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectAtIndexedSubscript:", 2));
  v10 = objc_msgSend(v9, "unsignedIntValue");

  if (v10 == 2)
  {
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * (v8 + 1)) - *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v8);
    v12 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
    v14 = (_QWORD *)v12[7];
    v13 = v12[8];
    if ((unint64_t)v14 >= v13)
    {
      v16 = v12[6];
      v17 = ((uint64_t)v14 - v16) >> 4;
      v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 60)
        abort();
      v19 = v13 - v16;
      if (v19 >> 3 > v18)
        v18 = v19 >> 3;
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF0)
        v20 = 0xFFFFFFFFFFFFFFFLL;
      else
        v20 = v18;
      v21 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(v20);
      v22 = &v21[16 * v17];
      v24 = &v21[16 * v23];
      *(_QWORD *)v22 = v6;
      *((_QWORD *)v22 + 1) = v11;
      v15 = v22 + 16;
      v26 = (char *)v12[6];
      v25 = (char *)v12[7];
      if (v25 != v26)
      {
        do
        {
          *((_OWORD *)v22 - 1) = *((_OWORD *)v25 - 1);
          v22 -= 16;
          v25 -= 16;
        }
        while (v25 != v26);
        v25 = (char *)v12[6];
      }
      v12[6] = v22;
      v12[7] = v15;
      v12[8] = v24;
      if (v25)
        operator delete(v25);
    }
    else
    {
      *v14 = v6;
      v14[1] = v11;
      v15 = v14 + 2;
    }
    v12[7] = v15;
  }

}

void sub_2E4A9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void std::vector<std::vector<BOOL>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  void *v6;
  void *v7;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = (void *)*((_QWORD *)v4 - 3);
        v4 -= 24;
        v6 = v7;
        if (v7)
          operator delete(v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void ___ZN21GRCDerivedCounterData18RawCounterInfoListEv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  id v11;

  v11 = a3;
  objc_msgSend(*(id *)(a1 + 32), "addObject:", a2);
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("subtype")));
  v6 = v5;
  if (v5 && objc_msgSend(v5, "isEqualToString:", CFSTR("Normalize")))
  {
    v7 = *(void **)(a1 + 40);
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("counters")));
    objc_msgSend(v7, "addObjectsFromArray:", v8);

    v9 = *(void **)(a1 + 48);
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("counters")));
    objc_msgSend(v9, "addObjectsFromArray:", v10);

  }
}

void sub_2E4C14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void std::vector<RawCounterInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  void *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (void *)*((_QWORD *)v4 - 2);
        v4 -= 16;

      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__split_buffer<RawCounterInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 16;

  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void ___ZN21GRCDerivedCounterData32GenerateCodeForCounterProcessingEv_block_invoke(_QWORD *a1, uint64_t a2, void *a3)
{
  id v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  id v11;

  v4 = a3;
  v5 = (void *)a1[4];
  v11 = v4;
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("name")));
  objc_msgSend(v5, "addObject:", v6);

  v7 = (void *)a1[5];
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("description")));
  objc_msgSend(v7, "addObject:", v8);

  v9 = (void *)a1[6];
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("type")));
  objc_msgSend(v9, "addObject:", v10);

}

void sub_2E4DBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

id GRCDerivedCounterData::ProcessDerivedCounterData(uint64_t a1, void *a2)
{
  id v4;

  v4 = a2;
  if (*(_DWORD *)(a1 + 148))
    operator new();

  return 0;
}

void sub_2E7B2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,void *a60)
{
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void ***std::unique_ptr<FrameRawCounterData>::reset[abi:nn180100](void ***result, void **a2)
{
  void **v2;
  void **v3;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v3 = v2;
    std::vector<std::array<std::vector<std::vector<unsigned long long>>,3ul>>::__destroy_vector::operator()[abi:nn180100](&v3);
    operator delete();
  }
  return result;
}

double std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,KickBoundarySample *,false>(uint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  BOOL v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  unint64_t v39;
  _BOOL4 v40;
  unint64_t v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  BOOL v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;
  uint64_t v66;
  __int128 v67;
  uint64_t v68;
  __int128 v69;
  int64_t v70;
  int64_t v71;
  int64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  __int128 v76;
  __int128 v77;
  uint64_t v78;
  __int128 v79;
  __int128 v80;
  uint64_t v81;
  uint64_t v82;
  __int128 v83;
  __int128 v84;
  int64_t v85;
  unint64_t v86;
  uint64_t v87;
  __int128 v88;
  __int128 v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  __int128 v104;
  __int128 v105;
  uint64_t v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  uint64_t v112;
  __int128 v113;
  __int128 v114;
  uint64_t v115;
  uint64_t v116;
  __int128 v117;
  BOOL v118;
  __int128 v119;
  uint64_t v121;
  uint64_t v122;
  unint64_t v123;
  __int128 v124;
  __int128 v125;
  uint64_t v126;
  __int128 v127;
  __int128 v128;
  uint64_t v129;

_QWORD *BufferView<EncoderSampleIndexData>::BufferView(_QWORD *a1, void *a2)
{
  id v3;
  unint64_t v4;

  v3 = objc_retainAutorelease(a2);
  *a1 = objc_msgSend(v3, "bytes");
  v4 = (unint64_t)objc_msgSend(v3, "length");
  a1[1] = *a1 + 16 * (v4 >> 4);
  a1[2] = v4 >> 4;

  return a1;
}

void sub_2E8A44(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *std::vector<GPUEncoderInfo>::vector(_QWORD *a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  char *v5;
  size_t v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if (a2 >= 0x555555555555556)
      abort();
    v3 = 3 * a2;
    v4 = 48 * a2;
    v5 = (char *)operator new(48 * a2);
    *a1 = v5;
    a1[2] = &v5[16 * v3];
    v6 = 48 * ((v4 - 48) / 0x30uLL) + 48;
    bzero(v5, v6);
    a1[1] = &v5[v6];
  }
  return a1;
}

BOOL KickBoundarySample::operator<(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;

  v2 = *(_DWORD *)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 32);
  v4 = v2 >= v3;
  if (v2 == v3)
  {
    v4 = *(_QWORD *)a1 >= *(_QWORD *)a2;
    if (*(_QWORD *)a1 == *(_QWORD *)a2)
    {
      v5 = *(_QWORD *)(a1 + 8);
      v6 = *(_QWORD *)(a2 + 8);
      v4 = v5 >= v6;
      if (v5 == v6)
      {
        v7 = *(_QWORD *)(a1 + 16);
        v8 = *(_QWORD *)(a2 + 16);
        v4 = v7 >= v8;
        if (v7 == v8)
        {
          v9 = *(_QWORD *)(a1 + 24);
          v10 = *(_QWORD *)(a2 + 24);
          v4 = v9 >= v10;
          if (v9 == v10)
            return *(_DWORD *)(a1 + 36) < *(_DWORD *)(a2 + 36);
        }
      }
    }
  }
  return !v4;
}

BOOL std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KickBoundarySample *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v6;
  _BOOL8 result;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  __int128 v29;

  v6 = KickBoundarySample::operator<(a2, a1);
  result = KickBoundarySample::operator<(a3, a2);
  if (v6)
  {
    if (result)
    {
      v8 = *(_OWORD *)a1;
      v9 = *(_OWORD *)(a1 + 16);
      v10 = *(_QWORD *)(a1 + 32);
      v11 = *(_QWORD *)(a3 + 32);
      v12 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *(_OWORD *)(a1 + 16) = v12;
      *(_QWORD *)(a1 + 32) = v11;
    }
    else
    {
      v23 = *(_OWORD *)a1;
      v24 = *(_OWORD *)(a1 + 16);
      v25 = *(_QWORD *)(a1 + 32);
      v26 = *(_QWORD *)(a2 + 32);
      v27 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 16) = v27;
      *(_QWORD *)(a1 + 32) = v26;
      *(_QWORD *)(a2 + 32) = v25;
      *(_OWORD *)a2 = v23;
      *(_OWORD *)(a2 + 16) = v24;
      result = KickBoundarySample::operator<(a3, a2);
      if (!result)
        return result;
      v8 = *(_OWORD *)a2;
      v9 = *(_OWORD *)(a2 + 16);
      v10 = *(_QWORD *)(a2 + 32);
      v28 = *(_QWORD *)(a3 + 32);
      v29 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 16) = v29;
      *(_QWORD *)(a2 + 32) = v28;
    }
    *(_QWORD *)(a3 + 32) = v10;
    *(_OWORD *)a3 = v8;
    *(_OWORD *)(a3 + 16) = v9;
  }
  else if (result)
  {
    v13 = *(_OWORD *)a2;
    v14 = *(_OWORD *)(a2 + 16);
    v15 = *(_QWORD *)(a2 + 32);
    v16 = *(_QWORD *)(a3 + 32);
    v17 = *(_OWORD *)(a3 + 16);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)(a2 + 16) = v17;
    *(_QWORD *)(a2 + 32) = v16;
    *(_QWORD *)(a3 + 32) = v15;
    *(_OWORD *)a3 = v13;
    *(_OWORD *)(a3 + 16) = v14;
    result = KickBoundarySample::operator<(a2, a1);
    if (result)
    {
      v18 = *(_OWORD *)a1;
      v19 = *(_OWORD *)(a1 + 16);
      v20 = *(_QWORD *)(a1 + 32);
      v21 = *(_QWORD *)(a2 + 32);
      v22 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 16) = v22;
      *(_QWORD *)(a1 + 32) = v21;
      *(_QWORD *)(a2 + 32) = v20;
      *(_OWORD *)a2 = v18;
      *(_OWORD *)(a2 + 16) = v19;
    }
  }
  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KickBoundarySample *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  __n128 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KickBoundarySample *>(a1, a2, a3);
  if (KickBoundarySample::operator<(a4, a3))
  {
    v9 = *(_OWORD *)a3;
    v10 = *(_OWORD *)(a3 + 16);
    v11 = *(_QWORD *)(a3 + 32);
    v12 = *(_QWORD *)(a4 + 32);
    v13 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)(a3 + 16) = v13;
    *(_QWORD *)(a3 + 32) = v12;
    *(_QWORD *)(a4 + 32) = v11;
    *(_OWORD *)a4 = v9;
    *(_OWORD *)(a4 + 16) = v10;
    if (KickBoundarySample::operator<(a3, a2))
    {
      v14 = *(__n128 *)a2;
      v15 = *(_OWORD *)(a2 + 16);
      v16 = *(_QWORD *)(a2 + 32);
      v17 = *(_QWORD *)(a3 + 32);
      v18 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 16) = v18;
      *(_QWORD *)(a2 + 32) = v17;
      *(_QWORD *)(a3 + 32) = v16;
      *(__n128 *)a3 = v14;
      *(_OWORD *)(a3 + 16) = v15;
      if (KickBoundarySample::operator<(a2, a1))
      {
        result = *(__n128 *)a1;
        v19 = *(_OWORD *)(a1 + 16);
        v20 = *(_QWORD *)(a1 + 32);
        v21 = *(_QWORD *)(a2 + 32);
        v22 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v22;
        *(_QWORD *)(a1 + 32) = v21;
        *(_QWORD *)(a2 + 32) = v20;
        *(__n128 *)a2 = result;
        *(_OWORD *)(a2 + 16) = v19;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KickBoundarySample *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __n128 result;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __n128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;

  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KickBoundarySample *>(a1, a2, a3, a4);
  if (KickBoundarySample::operator<(a5, a4))
  {
    v11 = *(_OWORD *)a4;
    v12 = *(_OWORD *)(a4 + 16);
    v13 = *(_QWORD *)(a4 + 32);
    v14 = *(_QWORD *)(a5 + 32);
    v15 = *(_OWORD *)(a5 + 16);
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_OWORD *)(a4 + 16) = v15;
    *(_QWORD *)(a4 + 32) = v14;
    *(_QWORD *)(a5 + 32) = v13;
    *(_OWORD *)a5 = v11;
    *(_OWORD *)(a5 + 16) = v12;
    if (KickBoundarySample::operator<(a4, a3))
    {
      v16 = *(_OWORD *)a3;
      v17 = *(_OWORD *)(a3 + 16);
      v18 = *(_QWORD *)(a3 + 32);
      v19 = *(_QWORD *)(a4 + 32);
      v20 = *(_OWORD *)(a4 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_OWORD *)(a3 + 16) = v20;
      *(_QWORD *)(a3 + 32) = v19;
      *(_QWORD *)(a4 + 32) = v18;
      *(_OWORD *)a4 = v16;
      *(_OWORD *)(a4 + 16) = v17;
      if (KickBoundarySample::operator<(a3, a2))
      {
        v21 = *(__n128 *)a2;
        v22 = *(_OWORD *)(a2 + 16);
        v23 = *(_QWORD *)(a2 + 32);
        v24 = *(_QWORD *)(a3 + 32);
        v25 = *(_OWORD *)(a3 + 16);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_OWORD *)(a2 + 16) = v25;
        *(_QWORD *)(a2 + 32) = v24;
        *(_QWORD *)(a3 + 32) = v23;
        *(__n128 *)a3 = v21;
        *(_OWORD *)(a3 + 16) = v22;
        if (KickBoundarySample::operator<(a2, a1))
        {
          result = *(__n128 *)a1;
          v26 = *(_OWORD *)(a1 + 16);
          v27 = *(_QWORD *)(a1 + 32);
          v28 = *(_QWORD *)(a2 + 32);
          v29 = *(_OWORD *)(a2 + 16);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_OWORD *)(a1 + 16) = v29;
          *(_QWORD *)(a1 + 32) = v28;
          *(_QWORD *)(a2 + 32) = v27;
          *(__n128 *)a2 = result;
          *(_OWORD *)(a2 + 16) = v26;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KickBoundarySample *>(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _BOOL8 result;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v4 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v6 = a2 - 40;
      if (!KickBoundarySample::operator<(a2 - 40, a1))
        return 1;
      v7 = *(_OWORD *)a1;
      v8 = *(_OWORD *)(a1 + 16);
      v9 = *(_QWORD *)(a1 + 32);
      v10 = *(_QWORD *)(v6 + 32);
      v11 = *(_OWORD *)(v6 + 16);
      *(_OWORD *)a1 = *(_OWORD *)v6;
      *(_OWORD *)(a1 + 16) = v11;
      *(_QWORD *)(a1 + 32) = v10;
      *(_QWORD *)(v6 + 32) = v9;
      result = 1;
      *(_OWORD *)v6 = v7;
      *(_OWORD *)(v6 + 16) = v8;
      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KickBoundarySample *>(a1, a1 + 40, a2 - 40);
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KickBoundarySample *>(a1, a1 + 40, a1 + 80, a2 - 40);
      return 1;
    case 5uLL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KickBoundarySample *>(a1, a1 + 40, a1 + 80, a1 + 120, a2 - 40);
      return 1;
    default:
      v12 = a1 + 80;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KickBoundarySample *>(a1, a1 + 40, a1 + 80);
      v13 = a1 + 120;
      if (a1 + 120 == a2)
        return 1;
      v14 = 0;
      v15 = 0;
      break;
  }
  while (1)
  {
    if (KickBoundarySample::operator<(v13, v12))
    {
      v16 = *(_OWORD *)(v13 + 16);
      v22 = *(_OWORD *)v13;
      v23 = v16;
      v24 = *(_QWORD *)(v13 + 32);
      v17 = v14;
      while (1)
      {
        v18 = a1 + v17;
        v19 = *(_OWORD *)(a1 + v17 + 96);
        *(_OWORD *)(v18 + 120) = *(_OWORD *)(a1 + v17 + 80);
        *(_OWORD *)(v18 + 136) = v19;
        *(_QWORD *)(v18 + 152) = *(_QWORD *)(a1 + v17 + 112);
        if (v17 == -80)
          break;
        v17 -= 40;
        if (!KickBoundarySample::operator<((uint64_t)&v22, v18 + 40))
        {
          v20 = a1 + v17 + 120;
          goto LABEL_12;
        }
      }
      v20 = a1;
LABEL_12:
      v21 = v23;
      *(_OWORD *)v20 = v22;
      *(_OWORD *)(v20 + 16) = v21;
      *(_QWORD *)(v20 + 32) = v24;
      if (++v15 == 8)
        return v13 + 40 == a2;
    }
    v12 = v13;
    v14 += 40;
    v13 += 40;
    if (v13 == a2)
      return 1;
  }
}

void std::vector<std::array<std::vector<std::vector<unsigned long long>>,3ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  uint64_t i;
  void **v8;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4;
        v4 -= 72;
        for (i = -24; i != -96; i -= 24)
        {
          v8 = (void **)&v6[i];
          std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&v8);
        }
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void GRCCurrentFrameStream::GRCCurrentFrameStream(GRCCurrentFrameStream *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  *((_QWORD *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_DWORD *)this + 10) = 1065353216;
  *((_OWORD *)this + 4) = 0u;
  *((_DWORD *)this + 20) = 1065353216;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_DWORD *)this + 30) = 1065353216;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((_DWORD *)this + 50) = 1065353216;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *(_OWORD *)((char *)this + 350) = 0u;
  v2 = objc_autoreleasePoolPush();
  v4 = objc_opt_new(NSMutableDictionary, v3);
  v5 = *(void **)this;
  *(_QWORD *)this = v4;

  objc_autoreleasePoolPop(v2);
}

void sub_2E91BC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void **v6;
  void *v8;
  void *v9;

  v8 = *(void **)(v1 + 256);
  if (v8)
  {
    *(_QWORD *)(v1 + 264) = v8;
    operator delete(v8);
  }
  v9 = *(void **)(v1 + 232);
  if (v9)
  {
    *(_QWORD *)(v1 + 240) = v9;
    operator delete(v9);
  }
  if (*v6)
    operator delete(*v6);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v5);
  std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table(v4);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v3);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v1 + 8);

  _Unwind_Resume(a1);
}

id **std::unique_ptr<GRCSplitBlitTimeData>::reset[abi:nn180100](id **result, id *a2)
{
  id *v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {

    operator delete();
  }
  return result;
}

void MTLGRCStreamingSampleHelper::MTLGRCStreamingSampleHelper(uint64_t a1, void *a2)
{
  a2;
  operator new();
}

void sub_2E94E4()
{
  operator delete();
}

void MTLGRCStreamingSampleHelperImpl::ProcessStreamedData(MTLGRCStreamingSampleHelperImpl *this, NSDictionary *a2, NSDictionary *a3)
{
  unsigned __int8 v4;
  os_signpost_id_t v5;
  void *v6;
  NSObject *v7;
  NSDictionary *v8;
  void *v9;
  BOOL v10;
  void *v11;
  NSObject *v12;
  int v13;
  const char *v14;
  void *v15;
  _BOOL4 v16;
  void *v17;
  BOOL v18;
  void *v19;
  id v20;
  void *v21;
  void *v22;
  id v23;
  void *v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  _BYTE *v36;
  char *v37;
  char *v38;
  int64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  char *v43;
  _QWORD *v44;
  char *v45;
  char *v46;
  char *v47;
  char *v48;
  unint64_t v49;
  unint64_t v50;
  char *v51;
  char *v52;
  unsigned int v53;
  uint64_t v54;
  unint64_t v55;
  char *v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  char *v60;
  char *v61;
  char *v62;
  int v63;
  uint64_t v64;
  char *v65;
  char *v66;
  int v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  char *v71;
  char *v72;
  char *v73;
  __int128 *v74;
  _BYTE *v75;
  unint64_t v76;
  char *v77;
  int64_t v78;
  unint64_t v79;
  unsigned int *v80;
  unint64_t v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  char *v85;
  int v86;
  uint64_t v87;
  unint64_t v88;
  unint64_t v89;
  char *v90;
  uint64_t v91;
  char *v92;
  char *v93;
  unsigned int *v94;
  void *v95;
  BOOL v96;
  uint64_t v97;
  void *v98;
  id v99;
  void *v100;
  void *v101;
  NSObject *v102;
  os_signpost_id_t v103;
  uint32_t v104;
  void *v105;
  BOOL v106;
  void *v107;
  int v108;
  void *v109;
  BOOL v110;
  void *v111;
  BOOL v112;
  BOOL v113;
  void *v114;
  BOOL v115;
  id v116;
  void *v117;
  void *v118;
  id v119;
  id v120;
  void *v121;
  void *v122;
  unint64_t v123;
  char *v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  unint64_t v128;
  char *v129;
  uint64_t v130;
  char *v131;
  char *v132;
  unsigned int *v133;
  uint64_t v134;
  char *v135;
  unint64_t v136;
  unint64_t v137;
  char *v138;
  uint64_t v139;
  char *v140;
  char *v141;
  unsigned int *v142;
  int v143;
  unint64_t v144;
  uint64_t v145;
  uint64_t v146;
  unint64_t v147;
  uint64_t v148;
  uint64_t v149;
  BOOL v150;
  uint64_t v151;
  uint64_t v152;
  unsigned int *v153;
  unsigned int *v154;
  uint64_t v155;
  uint64_t v156;
  _OWORD *v157;
  int v158;
  unsigned int v159;
  unsigned int v160;
  BOOL v161;
  int64x2_t v162;
  uint64_t k;
  BOOL v164;
  void *v165;
  BOOL v166;
  unsigned __int8 v167;
  id v168;
  void *v169;
  id v170;
  void *v171;
  uint64_t v172;
  void *v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  NSSet *v178;
  void *v179;
  void *v180;
  id v181;
  uint64_t v182;
  void *v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  NSSet *v194;
  void *v195;
  void *v196;
  id v197;
  NSDictionary *v198;
  void *v199;
  uint64_t v200;
  void *v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  NSSet *v209;
  void *v210;
  void *v211;
  unint64_t v212;
  void *v213;
  uint64_t v214;
  void *v215;
  id v216;
  unint64_t v217;
  unint64_t v218;
  float v219;
  float v220;
  uint64_t v221;
  char *v222;
  unint64_t v223;
  uint64_t v224;
  void *v225;
  _QWORD *v226;
  _QWORD *i;
  uint64_t v228;
  unint64_t j;
  id v230;
  void *v231;
  void *v232;
  void *v233;
  _BOOL4 v234;
  uint64_t v235;
  void *v236;
  id v237;
  void *v238;
  void *v239;
  id v240;
  void *v241;
  void *v242;
  void *v243;
  void *v244;
  void *v245;
  int v246;
  uint64_t v247;
  void *v248;
  NSObject *v249;
  void *v250;
  id v251;
  void *v252;
  void *v253;
  void *v254;
  uint64_t v255;
  void *v256;
  char *v257;
  void *v258;
  char *v259;
  char *v260;
  void *v261;
  void *v262;
  char *m;
  void *v264;
  void *v265;
  id v266;
  id v267;
  uint64_t v268;
  void *n;
  id v270;
  void *v271;
  id v272;
  uint64_t v273;
  void *v274;
  void *v275;
  void *v276;
  id v277;
  id v278;
  id *v279;
  unint64_t v280;
  void *v281;
  void *v282;
  id v283;
  unint64_t v284;
  id v285;
  id v286;
  unsigned int v287;
  unsigned int v288;
  uint64_t v289;
  void *ii;
  unsigned int v291;
  int8x8_t v292;
  uint8x8_t v293;
  unsigned int v294;
  unint64_t v295;
  char *v296;
  _DWORD *v297;
  char *v298;
  uint64_t v299;
  unint64_t v300;
  uint64_t v301;
  unint64_t v302;
  uint64_t v303;
  unsigned int *v304;
  unsigned int v305;
  double v306;
  double *v307;
  double *v308;
  void *v309;
  unsigned int v310;
  unsigned int v311;
  unint64_t v312;
  unsigned int *v313;
  _DWORD *v314;
  unsigned int *v315;
  uint64_t v316;
  unint64_t v317;
  uint64_t v318;
  BOOL v319;
  unint64_t v320;
  uint64_t v321;
  unsigned int *v322;
  unint64_t v323;
  unsigned int v324;
  void *v325;
  void *v326;
  _QWORD *v327;
  unint64_t jj;
  void *v329;
  void *v330;
  unsigned int v331;
  uint64_t *v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  void *v338;
  void *v339;
  BOOL v340;
  uint64_t v341;
  void *v342;
  void *v343;
  void *v344;
  BOOL v345;
  void *v346;
  void *v347;
  unsigned int v348;
  void *v349;
  id v350;
  char *v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  int v355;
  void *v356;
  id v357;
  id v358;
  id v359;
  void *v360;
  id v361;
  char *__p;
  char *__pa;
  void *__pb;
  void *__pc;
  NSDictionary *context;
  id contexta;
  uint64_t v368;
  NSDictionary *v369;
  os_signpost_id_t spid;
  unint64_t v371;
  id v372;
  MTLGRCStreamingSampleHelperImpl *v373;
  _QWORD v374[4];
  NSObject *v375;
  MTLGRCStreamingSampleHelperImpl *v376;
  os_signpost_id_t v377;
  _QWORD v378[4];
  NSObject *v379;
  id v380;
  MTLGRCStreamingSampleHelperImpl *v381;
  os_signpost_id_t v382;
  _QWORD v383[6];
  NSDictionary *v384;
  void *v385[3];
  __int128 v386;
  __int128 v387;
  __int128 v388;
  uint8_t *v389;
  uint64_t v390;
  id v391;
  BOOL v392;
  _QWORD v393[8];
  __int128 v394;
  __int128 v395;
  __int128 v396;
  __int128 v397;
  id v398[4];
  _QWORD v399[2];
  uint8_t buf[16];
  __int128 v401;
  __int128 v402;
  __int128 v403;
  __int128 v404;
  __int128 v405;
  __int128 v406;
  __int128 v407;

  v384 = a2;
  v373 = this;
  v4 = atomic_load((unsigned __int8 *)this + 140);
  if ((v4 & 1) != 0)
    goto LABEL_319;
  v5 = os_signpost_id_generate((os_log_t)g_signpostLog);
  v6 = g_signpostLog;
  v7 = v6;
  spid = v5;
  v371 = v5 - 1;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v6))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_0, v7, OS_SIGNPOST_INTERVAL_BEGIN, v5, "ShaderProfiler-ProcessStreamedDataPayload", (const char *)&unk_4AAB5F, buf, 2u);
  }

  v8 = v384;
  v9 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v384, "objectForKeyedSubscript:", CFSTR("Post Processing Frame Marker")));
  v10 = v9 == 0;

  if (!v10)
  {
    *(_BYTE *)(*((_QWORD *)v373 + 1) + 364) = 1;
    v11 = g_signpostLog;
    v12 = v11;
    if (v371 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v11))
    {
      v13 = *(_DWORD *)(*((_QWORD *)v373 + 1) + 360);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v13;
      v14 = "bPostProcessingMarkerReceived: %u";
LABEL_237:
      v102 = v12;
      v103 = spid;
      v104 = 8;
      goto LABEL_238;
    }
    goto LABEL_239;
  }
  v15 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v384, "objectForKeyedSubscript:", CFSTR("profileCounters")));
  if (v15)
  {
    v16 = *((_QWORD *)v373 + 4) == 0;

    if (v16)
    {
      v99 = -[NSDictionary copy](v384, "copy");
      v100 = (void *)*((_QWORD *)v373 + 4);
      *((_QWORD *)v373 + 4) = v99;

      v101 = g_signpostLog;
      v12 = v101;
      if (v371 >= 0xFFFFFFFFFFFFFFFELL || !os_signpost_enabled((os_log_t)v101))
        goto LABEL_239;
      *(_WORD *)buf = 0;
      v14 = "profileCounters";
      goto LABEL_92;
    }
  }
  v17 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v384, "objectForKeyedSubscript:", CFSTR("Frame Index")));
  v18 = v17 == 0;

  if (!v18)
  {
    v368 = *((_QWORD *)v373 + 1);
    context = v384;
    v19 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](context, "objectForKeyedSubscript:", CFSTR("Program Address Buffer")));
    v20 = objc_msgSend(v19, "mutableCopy");
    v21 = *(void **)(v368 + 304);
    *(_QWORD *)(v368 + 304) = v20;

    v22 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](context, "objectForKeyedSubscript:", CFSTR("Program Address Mappings")));
    v23 = objc_msgSend(v22, "mutableCopy");
    v24 = *(void **)(v368 + 312);
    *(_QWORD *)(v368 + 312) = v23;

    v25 = objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](context, "objectForKeyedSubscript:", CFSTR("Frame Consistent Perf Info")));
    v26 = *(void **)(v368 + 320);
    *(_QWORD *)(v368 + 320) = v25;

    v27 = objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](context, "objectForKeyedSubscript:", CFSTR("Restore Timestamps")));
    v28 = *(void **)(v368 + 328);
    *(_QWORD *)(v368 + 328) = v27;

    v29 = objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](context, "objectForKeyedSubscript:", CFSTR("Command Buffer Timestamps")));
    v30 = *(void **)(v368 + 336);
    *(_QWORD *)(v368 + 336) = v29;

    v31 = objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](context, "objectForKeyedSubscript:", CFSTR("PState Info Data")));
    v32 = *(void **)(v368 + 344);
    *(_QWORD *)(v368 + 344) = v31;

    v33 = *(void **)(v368 + 320);
    if (!v33 || !*(_QWORD *)(v368 + 344))
    {
LABEL_199:
      v173 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](context, "objectForKeyedSubscript:", CFSTR("TraceId to BatchId")));
      if (v173)
      {
        v174 = objc_opt_class(NSDictionary, v172);
        v176 = objc_opt_class(NSNumber, v175);
        v178 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v174, v176, objc_opt_class(NSNull, v177), 0);
        v179 = (void *)objc_claimAutoreleasedReturnValue(v178);
        *(_QWORD *)&v387 = 0;
        v180 = (void *)objc_claimAutoreleasedReturnValue(+[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:](NSKeyedUnarchiver, "unarchivedObjectOfClasses:fromData:error:", v179, v173, &v387));
        v181 = (id)v387;

        if (v180)
        {
          *(_QWORD *)buf = _NSConcreteStackBlock;
          *(_QWORD *)&buf[8] = 3221225472;
          *(_QWORD *)&v401 = ___ZN21GRCCurrentFrameStream30PopulateProgramAddressDataInfoEP12NSDictionary_block_invoke;
          *((_QWORD *)&v401 + 1) = &__block_descriptor_40_e35_v32__0__NSNumber_8__NSNumber_16_B24l;
          *(_QWORD *)&v402 = v368;
          objc_msgSend(v180, "enumerateKeysAndObjectsUsingBlock:", buf);
        }

      }
      v183 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](context, "objectForKeyedSubscript:", CFSTR("TraceId to Coalesced BatchId")));
      if (v183)
      {
        v184 = objc_opt_class(NSDictionary, v182);
        v186 = objc_opt_class(NSMutableDictionary, v185);
        v188 = objc_opt_class(NSArray, v187);
        v190 = objc_opt_class(NSMutableArray, v189);
        v192 = objc_opt_class(NSNumber, v191);
        v194 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v184, v186, v188, v190, v192, objc_opt_class(NSNull, v193), 0);
        v195 = (void *)objc_claimAutoreleasedReturnValue(v194);
        v398[0] = 0;
        v196 = (void *)objc_claimAutoreleasedReturnValue(+[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:](NSKeyedUnarchiver, "unarchivedObjectOfClasses:fromData:error:", v195, v183, v398));
        v197 = v398[0];

        v393[0] = _NSConcreteStackBlock;
        v393[1] = 3221225472;
        v393[2] = ___ZN21GRCCurrentFrameStream30PopulateProgramAddressDataInfoEP12NSDictionary_block_invoke_2;
        v393[3] = &__block_descriptor_40_e34_v32__0__NSNumber_8__NSArray_16_B24l;
        v393[4] = v368;
        objc_msgSend(v196, "enumerateKeysAndObjectsUsingBlock:", v393);

      }
      v198 = v384;
      v199 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v384, "objectForKeyedSubscript:", CFSTR("Source Sample Marker")));
      *(_QWORD *)(*((_QWORD *)v373 + 1) + 352) = objc_msgSend(v199, "unsignedLongLongValue");

      v200 = *((_QWORD *)v373 + 1);
      v369 = v198;
      v201 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v369, "objectForKeyedSubscript:", CFSTR("TraceId to SampleIndex")));
      if (v201)
      {
        __pb = v201;
        v203 = objc_opt_class(NSDictionary, v202);
        v205 = objc_opt_class(NSArray, v204);
        v207 = objc_opt_class(NSNumber, v206);
        v209 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v203, v205, v207, objc_opt_class(NSNull, v208), 0);
        v210 = (void *)objc_claimAutoreleasedReturnValue(v209);
        v398[0] = 0;
        v211 = (void *)objc_claimAutoreleasedReturnValue(+[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:](NSKeyedUnarchiver, "unarchivedObjectOfClasses:fromData:error:", v210, __pb, v398));
        v361 = v398[0];

        contexta = (id)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v369, "objectForKeyedSubscript:", CFSTR("Frame Encoder Time Data")));
        if (objc_msgSend(v211, "count") || objc_msgSend(contexta, "length"))
        {
          v212 = (unint64_t)objc_msgSend(contexta, "length");
          if (v212)
          {
            v213 = objc_autoreleasePoolPush();
            if (!objc_msgSend(*(id *)v200, "count"))
            {
              v215 = (void *)objc_opt_new(NSMutableDictionary, v214);
              objc_msgSend(*(id *)v200, "setObject:forKeyedSubscript:", v215, &off_739E08);

            }
            objc_autoreleasePoolPop(v213);
          }
          if ((unint64_t)objc_msgSend(v211, "count") | v212)
          {
            if (v212)
              v216 = objc_msgSend(objc_retainAutorelease(contexta), "bytes");
            else
              v216 = 0;
            v217 = (unint64_t)objc_msgSend(contexta, "length") >> 3;
            *(_QWORD *)buf = 0;
            *(_QWORD *)&buf[8] = buf;
            *((_QWORD *)&v401 + 1) = __Block_byref_object_copy__7742;
            *(_QWORD *)&v402 = __Block_byref_object_dispose__7743;
            *(_QWORD *)&v401 = 0x4812000000;
            *((_QWORD *)&v402 + 1) = &unk_4C2897;
            v403 = 0uLL;
            *(_QWORD *)&v404 = 0;
            std::vector<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>::reserve((void **)&v403, v217);
            v218 = *(_QWORD *)(v200 + 96);
            if (v218)
              v219 = (float)*(unint64_t *)(v200 + 112) / (float)v218;
            else
              v219 = 0.0;
            v220 = fmaxf(v219, 0.3);
            *(float *)(v200 + 120) = v220;
            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(v200 + 88, vcvtps_u32_f32((float)v217 / v220));
            *(_QWORD *)&v387 = _NSConcreteStackBlock;
            *((_QWORD *)&v387 + 1) = 3221225472;
            *(_QWORD *)&v388 = ___ZN21GRCCurrentFrameStream23AddFrameEncoderTimeDataEP12NSDictionary_block_invoke;
            *((_QWORD *)&v388 + 1) = &unk_726C10;
            v392 = v212 != 0;
            v391 = v216;
            v390 = v200;
            v389 = buf;
            objc_msgSend(v211, "enumerateKeysAndObjectsUsingBlock:", &v387);
            if (v212)
            {
              v221 = *(_QWORD *)(*(_QWORD *)&buf[8] + 48);
              v222 = *(char **)(*(_QWORD *)&buf[8] + 56);
              v223 = 126 - 2 * __clz((uint64_t)&v222[-v221] >> 5);
              if (v222 == (char *)v221)
                v224 = 0;
              else
                v224 = v223;
              std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *,false>(v221, v222, v224, 1);
              v225 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](NSMutableData, "dataWithCapacity:", 2 * (*(_QWORD *)(*(_QWORD *)&buf[8] + 56) - *(_QWORD *)(*(_QWORD *)&buf[8] + 48))));
              v226 = *(_QWORD **)(*(_QWORD *)&buf[8] + 48);
              for (i = *(_QWORD **)(*(_QWORD *)&buf[8] + 56); v226 != i; v226 += 4)
              {
                memset(&v393[3], 0, 40);
                *(_OWORD *)&v393[1] = 0u;
                v393[0] = *(_QWORD *)(v200 + 352);
                v228 = v226[2];
                v393[1] = *v226;
                v393[3] = v228;
                v393[4] = v226[1];
                v393[5] = v226[3];
                v393[6] = 0;
                objc_msgSend(v225, "appendBytes:length:", v393, 64);
              }
              for (j = 0; j < (unint64_t)objc_msgSend(*(id *)v200, "count"); ++j)
              {
                v230 = *(id *)v200;
                v231 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", j));
                v232 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v230, "objectForKeyedSubscript:", v231));
                v233 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v232, "objectForKeyedSubscript:", CFSTR("EncoderTime")));
                v234 = v233 == 0;

                if (v234)
                {
                  v236 = (void *)objc_opt_new(NSMutableArray, v235);
                  v237 = *(id *)v200;
                  v238 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", j));
                  v239 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v237, "objectForKeyedSubscript:", v238));
                  objc_msgSend(v239, "setObject:forKeyedSubscript:", v236, CFSTR("EncoderTime"));

                }
                v240 = *(id *)v200;
                v241 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", j));
                v242 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v240, "objectForKeyedSubscript:", v241));
                v243 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v242, "objectForKeyedSubscript:", CFSTR("EncoderTime")));
                objc_msgSend(v243, "addObject:", v225);

              }
            }
            _Block_object_dispose(buf, 8);
            if ((_QWORD)v403)
            {
              *((_QWORD *)&v403 + 1) = v403;
              operator delete((void *)v403);
            }
          }
        }

        v201 = __pb;
      }

      v244 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v369, "objectForKeyedSubscript:", CFSTR("Frame Index")));
      *(_DWORD *)(*((_QWORD *)v373 + 1) + 360) = objc_msgSend(v244, "unsignedIntValue");

      *(_BYTE *)(*((_QWORD *)v373 + 1) + 365) = 1;
      v245 = g_signpostLog;
      v12 = v245;
      if (v371 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v245))
      {
        v246 = *(_DWORD *)(*((_QWORD *)v373 + 1) + 360);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v246;
        v14 = "Frame Index: %u";
        goto LABEL_237;
      }
      goto LABEL_239;
    }
    v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v33, "objectForKeyedSubscript:", CFSTR("consistent")));
    v360 = v34;
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v368 + 320), "objectForKeyedSubscript:", CFSTR("mapping")));
    if (!v34
      || (objc_msgSend(v34, "BOOLValue") & 1) != 0
      || !objc_msgSend(*(id *)(v368 + 344), "count")
      || !v35)
    {
LABEL_198:

      goto LABEL_199;
    }
    v349 = v35;
    v348 = objc_msgSend(v35, "unsignedIntValue");
    v357 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v368 + 344), "objectForKeyedSubscript:", CFSTR("GPU Stats"))));
    v36 = objc_msgSend(v357, "bytes");
    v350 = objc_retainAutorelease(v357);
    v37 = (char *)objc_msgSend(v350, "bytes");
    v38 = &v37[24 * ((unint64_t)objc_msgSend(v350, "length") / 0x18)];
    v39 = v38 - v36;
    if (v38 == v36)
    {

LABEL_197:
      v170 = objc_msgSend(*(id *)(v368 + 320), "mutableCopy");
      objc_msgSend(v170, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("consistent"));
      v171 = *(void **)(v368 + 320);
      *(_QWORD *)(v368 + 320) = v170;

      v35 = v349;
      goto LABEL_198;
    }
    v40 = 0xAAAAAAAAAAAAAAABLL * (v39 >> 3);
    if (v40 >= 0xAAAAAAAAAAAAAABLL)
      abort();
    v41 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v40);
    memmove(v41, v36, v39);
    v42 = 0;
    v387 = 0u;
    v388 = 0u;
    LODWORD(v389) = 1065353216;
    v43 = v41;
    v351 = v41;
    do
    {
      v44 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)&v387, *(_QWORD *)&v41[v42 + 8], &v41[v42 + 8]);
      ++*((_DWORD *)v44 + 6);
      v42 += 24;
    }
    while (24 * v40 != v42);
    v45 = 0;
    v46 = 0;
    v47 = 0;
    v48 = 0;
    v49 = 0;
    v399[1] = -1;
    v399[0] = -1;
    memset(v398, 0, sizeof(v398));
    v50 = (uint64_t)(24 * v40) / 24;
    v51 = v41 + 40;
    do
    {
      v52 = &v43[24 * v49];
      v53 = *(_DWORD *)v52;
      v54 = (*(_DWORD *)v52 >> 8) & 0x7F;
      if (v54 < 4)
      {
        v56 = (char *)*((_QWORD *)v52 + 1);
        v57 = *(_QWORD *)&v43[24 * v49 + 16];
        v55 = v49 + 1;
        __p = v45;
        if (v49 + 1 < v50)
        {
          v58 = &v51[24 * v49];
          while (*((char **)v58 - 1) == v56 && ((*((_DWORD *)v58 - 4) >> 8) & 0x7F) == (_DWORD)v54)
          {
            v59 = *(_QWORD *)v58;
            v58 += 24;
            v57 += v59;
            if (v50 == ++v55)
            {
              v55 = v50;
              break;
            }
          }
        }
        v60 = (char *)v398[v54];
        v61 = &v56[-v57];
        if (&v56[-v57] <= v60)
          v62 = (char *)v398[v54];
        else
          v62 = &v56[-v57];
        v63 = *((_DWORD *)v399 + v54);
        if (v49 < v55)
        {
          while (v63 != (*(_DWORD *)v52 >> 15))
          {
            ++v49;
            v52 += 24;
            if (v55 == v49)
              goto LABEL_41;
          }
          v64 = *(_QWORD *)&v43[24 * v49 + 16];
          v65 = &v61[v64];
          v66 = &v60[v64];
          if (v66 >= v65)
            v62 = v65;
          else
            v62 = v66;
        }
LABEL_41:
        v67 = (v53 >> 23);
        if (v67 == v63)
        {
          v45 = __p;
        }
        else
        {
          if (v48 >= v47)
          {
            v68 = (v48 - __p) >> 4;
            v69 = v68 + 1;
            if ((unint64_t)(v68 + 1) >> 60)
              abort();
            if ((v47 - __p) >> 3 > v69)
              v69 = (v47 - __p) >> 3;
            if ((unint64_t)(v47 - __p) >= 0x7FFFFFFFFFFFFFF0)
              v70 = 0xFFFFFFFFFFFFFFFLL;
            else
              v70 = v69;
            if (v70 >> 60)
              std::__throw_bad_array_new_length[abi:nn180100]();
            v71 = (char *)operator new(16 * v70);
            v72 = &v71[16 * v68];
            *(_QWORD *)v72 = v62;
            *((_DWORD *)v72 + 2) = v67 | ((_DWORD)v54 << 16);
            if (v46 == __p)
            {
              v45 = &v71[16 * v68];
            }
            else
            {
              v73 = &v71[16 * v68];
              do
              {
                v45 = v73 - 16;
                *((_OWORD *)v73 - 1) = *((_OWORD *)v46 - 1);
                v46 -= 16;
                v73 -= 16;
              }
              while (v46 != __p);
            }
            v47 = &v71[16 * v70];
            v46 = v72 + 16;
            if (__p)
              operator delete(__p);
            v43 = v351;
          }
          else
          {
            *(_QWORD *)v48 = v62;
            *((_DWORD *)v48 + 2) = v67 | ((_DWORD)v54 << 16);
            v46 = v48 + 16;
            v45 = __p;
          }
          *((_DWORD *)v399 + v54) = v67;
          v48 = v46;
        }
        v398[v54] = v56;
      }
      else
      {
        v55 = v49 + 1;
      }
      v49 = v55;
    }
    while (v55 < v50);
    v74 = (__int128 *)objc_msgSend(*(id *)(v368 + 336), "bytes");
    v75 = objc_msgSend(*(id *)(v368 + 336), "bytes");
    v76 = (unint64_t)objc_msgSend(*(id *)(v368 + 336), "length");
    memset(v385, 0, sizeof(v385));
    std::vector<std::pair<unsigned long long,unsigned long long>>::__init_with_size[abi:nn180100]<std::pair<unsigned long long,unsigned long long>*,std::pair<unsigned long long,unsigned long long>*>(v385, v74, (__int128 *)&v75[v76 & 0xFFFFFFFFFFFFFFF0], (&v75[v76 & 0xFFFFFFFFFFFFFFF0] - (_BYTE *)v74) >> 4);
    v77 = (char *)v385[0];
    if (v385[0] == v385[1])
    {
      v113 = 0;
      v34 = v360;
      goto LABEL_190;
    }
    v78 = (char *)v385[1] - (char *)v385[0];
    std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>((unint64_t)v385[0], (unint64_t *)v385[1], 126 - 2 * __clz(((char *)v385[1] - (char *)v385[0]) >> 4), 1);
    __pa = v45;
    v79 = v46 - v45;
    if (((v46 - v45) & 0xFFFFFFFF0) != 0)
    {
      v80 = 0;
      v81 = 0;
      v82 = 0;
      v83 = 0;
      if (((v79 >> 4) & 0xFFFFFFFE) != 0)
        v84 = (v79 >> 4);
      else
        v84 = 1;
      v34 = v360;
      do
      {
        v85 = &__pa[16 * v83];
        v86 = *((_DWORD *)v85 + 2) >> 31;
        if (v81 >= (unint64_t)v82)
        {
          v87 = (uint64_t)(v81 - (_QWORD)v80) >> 4;
          v88 = v87 + 1;
          if ((unint64_t)(v87 + 1) >> 60)
            abort();
          if ((v82 - (char *)v80) >> 3 > v88)
            v88 = (v82 - (char *)v80) >> 3;
          if ((unint64_t)(v82 - (char *)v80) >= 0x7FFFFFFFFFFFFFF0)
            v89 = 0xFFFFFFFFFFFFFFFLL;
          else
            v89 = v88;
          v90 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(v89);
          v92 = &v90[16 * v87];
          *(_QWORD *)v92 = *(_QWORD *)v85;
          *((_DWORD *)v92 + 2) = v86 | (4 * v83);
          if ((unsigned int *)v81 == v80)
          {
            v94 = (unsigned int *)&v90[16 * v87];
            v34 = v360;
          }
          else
          {
            v93 = &v90[16 * v87];
            v34 = v360;
            do
            {
              v94 = (unsigned int *)(v93 - 16);
              *((_OWORD *)v93 - 1) = *(_OWORD *)(v81 - 16);
              v81 -= 16;
              v93 -= 16;
            }
            while ((unsigned int *)v81 != v80);
          }
          v82 = &v90[16 * v91];
          v81 = (unint64_t)(v92 + 16);
          if (v80)
            operator delete(v80);
          v80 = v94;
        }
        else
        {
          *(_QWORD *)v81 = *(_QWORD *)v85;
          *(_DWORD *)(v81 + 8) = v86 | (4 * v83);
          v81 += 16;
        }
        std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,std::less<GRCCurrentFrameStream::IsWorkloadThrottled::TimestampInfoElement> &,std::__wrap_iter<GRCCurrentFrameStream::IsWorkloadThrottled::TimestampInfoElement*>>((_BOOL8)v80, v81, (uint64_t)(v81 - (_QWORD)v80) >> 4);
        ++v83;
      }
      while (v83 != v84);
      v77 = (char *)v385[0];
      v78 = (char *)v385[1] - (char *)v385[0];
    }
    else
    {
      v80 = 0;
      v81 = 0;
      v82 = 0;
      v34 = v360;
    }
    if ((v78 & 0xFFFFFFFF0) != 0)
    {
      v123 = 0;
      do
      {
        v124 = &v77[16 * v123];
        if (v81 >= (unint64_t)v82)
        {
          v126 = (uint64_t)(v81 - (_QWORD)v80) >> 4;
          v127 = v126 + 1;
          if ((unint64_t)(v126 + 1) >> 60)
            abort();
          if ((v82 - (char *)v80) >> 3 > v127)
            v127 = (v82 - (char *)v80) >> 3;
          if ((unint64_t)(v82 - (char *)v80) >= 0x7FFFFFFFFFFFFFF0)
            v128 = 0xFFFFFFFFFFFFFFFLL;
          else
            v128 = v127;
          v129 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(v128);
          v131 = &v129[16 * v126];
          *(_QWORD *)v131 = *(_QWORD *)v124;
          *((_DWORD *)v131 + 2) = (4 * v123) | 2;
          if ((unsigned int *)v81 == v80)
          {
            v133 = (unsigned int *)&v129[16 * v126];
          }
          else
          {
            v132 = &v129[16 * v126];
            do
            {
              v133 = (unsigned int *)(v132 - 16);
              *((_OWORD *)v132 - 1) = *(_OWORD *)(v81 - 16);
              v81 -= 16;
              v132 -= 16;
            }
            while ((unsigned int *)v81 != v80);
          }
          v82 = &v129[16 * v130];
          v125 = (unint64_t)(v131 + 16);
          if (v80)
            operator delete(v80);
          v80 = v133;
        }
        else
        {
          *(_QWORD *)v81 = *(_QWORD *)v124;
          *(_DWORD *)(v81 + 8) = (4 * v123) | 2;
          v125 = v81 + 16;
        }
        v134 = (uint64_t)(v125 - (_QWORD)v80) >> 4;
        std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,std::less<GRCCurrentFrameStream::IsWorkloadThrottled::TimestampInfoElement> &,std::__wrap_iter<GRCCurrentFrameStream::IsWorkloadThrottled::TimestampInfoElement*>>((_BOOL8)v80, v125, v134);
        v135 = &v77[16 * v123 + 8];
        if (v125 >= (unint64_t)v82)
        {
          v136 = v134 + 1;
          if ((unint64_t)(v134 + 1) >> 60)
            abort();
          if ((v82 - (char *)v80) >> 3 > v136)
            v136 = (v82 - (char *)v80) >> 3;
          if ((unint64_t)(v82 - (char *)v80) >= 0x7FFFFFFFFFFFFFF0)
            v137 = 0xFFFFFFFFFFFFFFFLL;
          else
            v137 = v136;
          v138 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(v137);
          v140 = &v138[16 * v134];
          *(_QWORD *)v140 = *(_QWORD *)v135;
          *((_DWORD *)v140 + 2) = (4 * v123) | 3;
          if ((unsigned int *)v125 == v80)
          {
            v142 = (unsigned int *)&v138[16 * v134];
          }
          else
          {
            v141 = &v138[16 * v134];
            do
            {
              v142 = (unsigned int *)(v141 - 16);
              *((_OWORD *)v141 - 1) = *(_OWORD *)(v125 - 16);
              v125 -= 16;
              v141 -= 16;
            }
            while ((unsigned int *)v125 != v80);
          }
          v82 = &v138[16 * v139];
          v81 = (unint64_t)(v140 + 16);
          if (v80)
            operator delete(v80);
          v80 = v142;
        }
        else
        {
          *(_QWORD *)v125 = *(_QWORD *)v135;
          *(_DWORD *)(v125 + 8) = (4 * v123) | 3;
          v81 = v125 + 16;
        }
        std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,std::less<GRCCurrentFrameStream::IsWorkloadThrottled::TimestampInfoElement> &,std::__wrap_iter<GRCCurrentFrameStream::IsWorkloadThrottled::TimestampInfoElement*>>((_BOOL8)v80, v81, (uint64_t)(v81 - (_QWORD)v80) >> 4);
        ++v123;
        v77 = (char *)v385[0];
      }
      while (v123 < ((unint64_t)((char *)v385[1] - (char *)v385[0]) >> 4));
    }
    v406 = 0u;
    v407 = 0u;
    v404 = 0u;
    v405 = 0u;
    v402 = 0u;
    v403 = 0u;
    *(_OWORD *)buf = 0u;
    v401 = 0u;
    v396 = 0u;
    v397 = 0u;
    v394 = 0u;
    v395 = 0u;
    memset(v393, 0, sizeof(v393));
    if (v80 == (unsigned int *)v81)
    {
      v161 = 0;
      v113 = 0;
      v45 = __pa;
      if (!v80)
      {
LABEL_190:
        if (v77)
        {
          v385[1] = v77;
          operator delete(v77);
        }
        if (v45)
          operator delete(v45);
        std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v387);
        if (v351)
          operator delete(v351);

        v35 = v349;
        if (v113)
          goto LABEL_198;
        goto LABEL_197;
      }
    }
    else
    {
      v143 = 0;
      v144 = 0;
      v352 = *(_QWORD *)v80;
      v353 = 0;
      do
      {
        v145 = *(_QWORD *)v80;
        v146 = v80[2];
        v147 = v81 - (_QWORD)v80;
        if ((uint64_t)(v81 - (_QWORD)v80) >= 17)
        {
          v354 = *(_QWORD *)v80;
          v355 = v143;
          v358 = (id)v144;
          v148 = 0;
          v149 = v147 >> 4;
          v386 = *(_OWORD *)v80;
          v150 = __OFSUB__(v147 >> 4, 2);
          v151 = (v147 >> 4) - 2;
          if (v151 < 0 != v150)
            v151 = v149 - 1;
          v152 = v151 >> 1;
          v153 = v80;
          do
          {
            v154 = &v153[4 * v148 + 4];
            v155 = (2 * v148) | 1;
            v156 = 2 * v148 + 2;
            if (v156 < v149
              && GRCCurrentFrameStream::IsWorkloadThrottled::TimestampInfoElement::operator<((uint64_t)&v153[4 * v148 + 4], *(_QWORD *)&v153[4 * v148 + 8], v153[4 * v148 + 10]))
            {
              v154 += 4;
              v155 = v156;
            }
            *(_OWORD *)v153 = *(_OWORD *)v154;
            v153 = v154;
            v148 = v155;
          }
          while (v155 <= v152);
          v157 = (_OWORD *)(v81 - 16);
          if ((unsigned int *)(v81 - 16) == v154)
          {
            *(_OWORD *)v154 = v386;
          }
          else
          {
            *(_OWORD *)v154 = *v157;
            *v157 = v386;
            std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,std::less<GRCCurrentFrameStream::IsWorkloadThrottled::TimestampInfoElement> &,std::__wrap_iter<GRCCurrentFrameStream::IsWorkloadThrottled::TimestampInfoElement*>>((_BOOL8)v80, (uint64_t)(v154 + 4), ((char *)(v154 + 4) - (char *)v80) >> 4);
          }
          v144 = (unint64_t)v358;
          v34 = v360;
          v143 = v355;
          v145 = v354;
        }
        if (v143 >= 1)
        {
          *(_QWORD *)&buf[8 * v353] += v145 - v352;
          v144 += v145 - v352;
          v393[HIDWORD(v353)] += v145 - v352;
        }
        if ((v146 & 2) != 0)
        {
          if ((v146 & 1) != 0)
            --v143;
          else
            ++v143;
        }
        else
        {
          v158 = HIWORD(*(_DWORD *)&__pa[((4 * v146) & 0x3FFFFFFF0) + 8]) & 0x7FFF;
          if (v158 == 1)
          {
            v160 = (unsigned __int16)*(_DWORD *)&__pa[((4 * v146) & 0x3FFFFFFF0) + 8];
            if (v160 >= 0xF)
              v160 = 15;
            HIDWORD(v353) = v160;
          }
          else if (v158 == 2)
          {
            v159 = (unsigned __int16)*(_DWORD *)&__pa[((4 * v146) & 0x3FFFFFFF0) + 8];
            if (v159 >= 0xF)
              v159 = 15;
            LODWORD(v353) = v159;
          }
        }
        v81 -= 16;
      }
      while (v80 != (unsigned int *)v81);
      v161 = 0;
      if (v348 > 0x10)
      {
        v45 = __pa;
      }
      else
      {
        v45 = __pa;
        if (v144)
        {
          v162 = 0uLL;
          for (k = 16; k != 128; k += 16)
            v162 = vaddq_s64(*(int64x2_t *)&buf[k], v162);
          v164 = (double)(unint64_t)vaddvq_s64(v162) * 100.0 / (double)v144 > 5.0;
          v161 = (1.0 - (double)(unint64_t)(v393[v348] + v393[0]) / (double)v144) * 100.0 > 5.0 && v164;
        }
      }
    }
    operator delete(v80);
    v77 = (char *)v385[0];
    v113 = v161;
    goto LABEL_190;
  }
  v95 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v384, "objectForKeyedSubscript:", CFSTR("usc sampling address data")));
  v96 = v95 == 0;

  if (!v96)
  {
    v97 = objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v384, "objectForKeyedSubscript:", CFSTR("usc sampling address data")));
    v98 = (void *)*((_QWORD *)v373 + 5);
    *((_QWORD *)v373 + 5) = v97;

    objc_msgSend(*((id *)v373 + 6), "addOperation:", *((_QWORD *)v373 + 9));
    objc_msgSend(*((id *)v373 + 9), "waitUntilFinished");
    v383[0] = _NSConcreteStackBlock;
    v383[1] = 3221225472;
    v383[2] = ___ZN31MTLGRCStreamingSampleHelperImpl19ProcessStreamedDataEP12NSDictionaryS1__block_invoke;
    v383[3] = &__block_descriptor_48_e5_v8__0l;
    v383[4] = v373;
    v383[5] = spid;
    v12 = objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v383));
    objc_msgSend(*((id *)v373 + 10), "addDependency:", v12);
    objc_msgSend(*((id *)v373 + 6), "addOperation:", v12);
    objc_msgSend(*((id *)v373 + 6), "addOperation:", *((_QWORD *)v373 + 10));
    goto LABEL_239;
  }
  v105 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v384, "objectForKeyedSubscript:", CFSTR("ShaderProfilerData")));
  v106 = v105 == 0;

  if (v106)
  {
    v109 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v384, "objectForKeyedSubscript:", CFSTR("Frame Time Data")));
    v110 = v109 == 0;

    if (!v110)
      std::make_unique[abi:nn180100]<GRCFrameTimeData,NSDictionary * {__strong}&>();
    v111 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v384, "objectForKeyedSubscript:", CFSTR("Blit Encoder Frame Data")));
    v112 = v111 == 0;

    if (!v112)
      std::make_unique[abi:nn180100]<GRCSplitBlitTimeData,NSDictionary * {__strong}&>();
    v114 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v384, "objectForKeyedSubscript:", CFSTR("Derived Counter Sample Data")));
    v115 = v114 == 0;

    if (!v115)
    {
      v116 = -[NSDictionary copy](v384, "copy");
      v117 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(0, "objectForKeyedSubscript:", CFSTR("Kick Times")));
      v118 = v117;
      if (!v117)
        v118 = (void *)*((_QWORD *)v373 + 11);
      v119 = v118;
      v378[0] = _NSConcreteStackBlock;
      v378[1] = 3221225472;
      v378[2] = ___ZN31MTLGRCStreamingSampleHelperImpl19ProcessStreamedDataEP12NSDictionaryS1__block_invoke_221;
      v378[3] = &unk_726B58;
      v381 = v373;
      v12 = v116;
      v379 = v12;
      v120 = v119;
      v380 = v120;
      v382 = spid;
      v121 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v378));
      objc_msgSend(*((id *)v373 + 16), "addDependency:", v121);
      v122 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v8, "objectForKeyedSubscript:", CFSTR("Batch Filtered Counters")));
      if (v122)
      {

      }
      else if (*((_DWORD *)v373 + 34) != 1)
      {
        objc_msgSend(v121, "addDependency:", *((_QWORD *)v373 + 10));
      }
      objc_msgSend(*((id *)v373 + 6), "addOperation:", v121);
      if (*((_DWORD *)v373 + 34) == 1)
      {
        objc_msgSend(*((id *)v373 + 9), "addDependency:", v121);
        objc_msgSend(*((id *)v373 + 6), "addOperation:", *((_QWORD *)v373 + 9));
        v337 = objc_opt_new(NSOperation, v336);
        v338 = (void *)*((_QWORD *)v373 + 9);
        *((_QWORD *)v373 + 9) = v337;

      }
      else
      {
        objc_msgSend(*((id *)v373 + 7), "addDependency:", v121);
      }

      goto LABEL_239;
    }
    v165 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v384, "objectForKeyedSubscript:", CFSTR("Havested Binaries")));
    v166 = v165 == 0;

    if (v166)
    {
      v339 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v384, "objectForKeyedSubscript:", CFSTR("Kick Times")));
      v340 = v339 == 0;

      if (v340)
      {
        v344 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v384, "objectForKeyedSubscript:", CFSTR("End Batch ID Streaming Data")));
        v345 = v344 == 0;

        if (!v345)
        {
          v374[0] = _NSConcreteStackBlock;
          v374[1] = 3221225472;
          v374[2] = ___ZN31MTLGRCStreamingSampleHelperImpl19ProcessStreamedDataEP12NSDictionaryS1__block_invoke_229;
          v374[3] = &unk_726B30;
          v376 = v373;
          v12 = -[NSDictionary copy](v384, "copy");
          v375 = v12;
          v377 = spid;
          v346 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v374));
          objc_msgSend(*((id *)v373 + 6), "addOperation:", *((_QWORD *)v373 + 16));
          objc_msgSend(v346, "addDependency:", *((_QWORD *)v373 + 16));
          objc_msgSend(*((id *)v373 + 6), "addOperation:", v346);
          objc_msgSend(*((id *)v373 + 7), "addDependency:", v346);

          goto LABEL_239;
        }
        v347 = g_signpostLog;
        v12 = v347;
        if (v371 > 0xFFFFFFFFFFFFFFFDLL || !os_signpost_enabled((os_log_t)v347))
          goto LABEL_239;
        *(_WORD *)buf = 0;
        v14 = (const char *)&unk_4AAB5F;
      }
      else
      {
        v341 = objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v384, "objectForKeyedSubscript:", CFSTR("Kick Times")));
        v342 = (void *)*((_QWORD *)v373 + 11);
        *((_QWORD *)v373 + 11) = v341;

        v343 = g_signpostLog;
        v12 = v343;
        if (v371 >= 0xFFFFFFFFFFFFFFFELL || !os_signpost_enabled((os_log_t)v343))
          goto LABEL_239;
        *(_WORD *)buf = 0;
        v14 = "Kick Times";
      }
    }
    else
    {
      v167 = atomic_load((unsigned __int8 *)v373 + 140);
      if ((v167 & 1) == 0)
        v168 = (id)(*(uint64_t (**)(void))(*((_QWORD *)v373 + 14) + 16))();
      v169 = g_signpostLog;
      v12 = v169;
      if (v371 > 0xFFFFFFFFFFFFFFFDLL || !os_signpost_enabled((os_log_t)v169))
        goto LABEL_239;
      *(_WORD *)buf = 0;
      v14 = "Havested Binaries";
    }
LABEL_92:
    v102 = v12;
    v103 = spid;
    v104 = 2;
LABEL_238:
    _os_signpost_emit_with_name_impl(&dword_0, v102, OS_SIGNPOST_INTERVAL_END, v103, "ShaderProfiler-ProcessStreamedDataPayload", v14, buf, v104);
    goto LABEL_239;
  }
  GRCCurrentFrameStream::AddGRCSampledData(*((id **)v373 + 1), v384);
  v107 = g_signpostLog;
  v12 = v107;
  if (v371 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v107))
  {
    v108 = *(_DWORD *)(*((_QWORD *)v373 + 1) + 360);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v108;
    v14 = "Frame Index, ShaderProfilerData: %u";
    goto LABEL_237;
  }
LABEL_239:

  v247 = *((_QWORD *)v373 + 1);
  if (*(_BYTE *)(v247 + 364) && *(_BYTE *)(v247 + 365))
  {
    objc_autoreleasePoolPush();
    v248 = g_signpostLog;
    v249 = v248;
    if (v371 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v248))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_0, v249, OS_SIGNPOST_INTERVAL_BEGIN, spid, "ShaderProfiler-ProcessStreamedDataPostProcessing", (const char *)&unk_4AAB5F, buf, 2u);
    }

    v250 = (void *)*((_QWORD *)v373 + 12);
    if (v250)
    {
      v251 = v250;
    }
    else
    {
      v252 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*((id *)v373 + 4), "objectForKeyedSubscript:", CFSTR("limiter sample counters")));
      v253 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*((id *)v373 + 4), "objectForKeyedSubscript:", CFSTR("DerivedCounterDictionary")));
      v254 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v253, "objectForKeyedSubscript:", CFSTR("DerivedCounters")));

      v255 = objc_claimAutoreleasedReturnValue(objc_msgSend(v254, "allKeys"));
      v256 = (void *)*((_QWORD *)v373 + 13);
      *((_QWORD *)v373 + 13) = v255;

      v257 = (char *)objc_msgSend(v252, "count");
      v258 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableString string](NSMutableString, "string"));
      v259 = v257 - 1;
      if (v257 != (_BYTE *)&dword_0 + 1)
      {
        v260 = 0;
        do
        {
          v261 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v252, "objectAtIndexedSubscript:", v260));
          v262 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v252, "objectAtIndexedSubscript:", v260));
          objc_msgSend(v258, "appendFormat:", CFSTR("var %@ = 0;\nvar %@_norm = 0;\n"), v261, v262);

          ++v260;
        }
        while (v259 != v260);
      }
      objc_msgSend(v258, "appendString:", CFSTR("var core_count = num_cores;\n\n"));
      objc_msgSend(v258, "appendString:", CFSTR("var MTLStat_nSec = 0;\n\n"));
      objc_msgSend(v258, "appendString:", CFSTR("var _DerivedCounterResult = [];\n\n"));
      objc_msgSend(v258, "appendFormat:", CFSTR("function _SetAndEvaluateRawCounterValues(numSamples, gpuCyclesCounterIndex, ringBufferIndex) {\n"));
      objc_msgSend(v258, "appendString:", CFSTR("\tnum_cores = _CoreCount[ringBufferIndex];\n"));
      objc_msgSend(v258, "appendString:", CFSTR("\t_DerivedCounterResult = [];\n"));
      objc_msgSend(v258, "appendString:", CFSTR("\tfor (var sampleIndex = 0; sampleIndex < numSamples; ++sampleIndex) {\n"));
      objc_msgSend(v258, "appendFormat:", CFSTR("\t\tvar sampleStartIndex = sampleIndex * %lu;\n"),
        objc_msgSend(v252, "count"));
      objc_msgSend(v258, "appendFormat:", CFSTR("\t\tvar gpuCycles = _RawCounterValues[gpuCyclesCounterIndex + sampleStartIndex] / num_cores;\n"));
      objc_msgSend(v258, "appendFormat:", CFSTR("\t\tMTLStat_nSec = (_RawTimestampDelta[sampleIndex]) * %u / %u;\n"),
        125,
        3);
      if (v259)
      {
        for (m = 0; m != v259; ++m)
        {
          v264 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v252, "objectAtIndexedSubscript:", m));
          objc_msgSend(v258, "appendFormat:", CFSTR("\t\t%@ = _RawCounterValues[%lu + sampleStartIndex];\n"), v264, m);

          v265 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v252, "objectAtIndexedSubscript:", m));
          objc_msgSend(v258, "appendFormat:", CFSTR("\t\t%@_norm = 100.0 * (_RawCounterValues[%lu + sampleStartIndex] / gpuCycles);\n"),
            v265,
            m);

        }
      }
      memset(v393, 0, sizeof(v393));
      v266 = *((id *)v373 + 13);
      v267 = objc_msgSend(v266, "countByEnumeratingWithState:objects:count:", v393, buf, 16);
      if (v267)
      {
        v268 = *(_QWORD *)v393[2];
        do
        {
          for (n = 0; n != v267; n = (char *)n + 1)
          {
            if (*(_QWORD *)v393[2] != v268)
              objc_enumerationMutation(v266);
            v270 = *(id *)(v393[1] + 8 * (_QWORD)n);
            objc_msgSend(v258, "appendFormat:", CFSTR("\t\ttry { value = %@(); if (!isFinite(value)) { value = 0; } _DerivedCounterResult.push(value); } catch(err) { ErrorLog(err); _DerivedCounterResult.push(0); }\n"),
              v270);

          }
          v267 = objc_msgSend(v266, "countByEnumeratingWithState:objects:count:", v393, buf, 16);
        }
        while (v267);
      }

      objc_msgSend(v258, "appendFormat:", CFSTR("\t}\n"));
      objc_msgSend(v258, "appendFormat:", CFSTR("}\n"));
      v271 = (void *)*((_QWORD *)v373 + 12);
      *((_QWORD *)v373 + 12) = v258;
      v272 = v258;

      v251 = *((id *)v373 + 12);
    }

    v273 = *((_QWORD *)v373 + 1);
    v275 = (void *)*((_QWORD *)v373 + 12);
    v274 = (void *)*((_QWORD *)v373 + 13);
    v276 = (void *)*((_QWORD *)v373 + 4);
    v277 = v275;
    v278 = v274;
    v372 = v276;
    objc_storeStrong((id *)(v273 + 288), v275);
    objc_storeStrong((id *)(v273 + 296), v274);
    v279 = (id *)(v273 + 280);
    objc_storeStrong((id *)(v273 + 280), v276);
    v280 = *(_QWORD *)(v273 + 32);
    v281 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v273 + 280), "objectForKeyedSubscript:", CFSTR("DerivedCounterConfigurationVariables")));
    v282 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v281, "objectForKeyedSubscript:", CFSTR("core_mask_list")));
    v283 = objc_msgSend(v282, "count");
    if (v280 <= (unint64_t)v283)
      v284 = (unint64_t)v283;
    else
      v284 = v280;
    *(_QWORD *)buf = 0x3FF0000000000000;
    std::vector<double>::resize((char **)(v273 + 232), v284, buf);
    if (v282)
    {
      memset(v393, 0, sizeof(v393));
      v285 = v282;
      v286 = objc_msgSend(v285, "countByEnumeratingWithState:objects:count:", v393, buf, 16);
      if (v286)
      {
        v356 = v282;
        v359 = v281;
        __pc = v277;
        v287 = 0;
        v288 = 0;
        v289 = *(_QWORD *)v393[2];
        do
        {
          for (ii = 0; ii != v286; ii = (char *)ii + 1)
          {
            v291 = v288;
            if (*(_QWORD *)v393[2] != v289)
              objc_enumerationMutation(v285);
            v292.i32[0] = objc_msgSend(*(id *)(v393[1] + 8 * (_QWORD)ii), "unsignedIntValue");
            v293 = (uint8x8_t)vcnt_s8(v292);
            v293.i16[0] = vaddlv_u8(v293);
            v294 = v293.i32[0];
            v296 = *(char **)(v273 + 264);
            v295 = *(_QWORD *)(v273 + 272);
            if ((unint64_t)v296 >= v295)
            {
              v298 = *(char **)(v273 + 256);
              v299 = (v296 - v298) >> 2;
              v300 = v299 + 1;
              if ((unint64_t)(v299 + 1) >> 62)
                abort();
              v301 = v295 - (_QWORD)v298;
              if (v301 >> 1 > v300)
                v300 = v301 >> 1;
              if ((unint64_t)v301 >= 0x7FFFFFFFFFFFFFFCLL)
                v302 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v302 = v300;
              if (v302)
              {
                v302 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v302);
                v298 = *(char **)(v273 + 256);
                v296 = *(char **)(v273 + 264);
              }
              else
              {
                v303 = 0;
              }
              v304 = (unsigned int *)(v302 + 4 * v299);
              *v304 = v294;
              v297 = v304 + 1;
              while (v296 != v298)
              {
                v305 = *((_DWORD *)v296 - 1);
                v296 -= 4;
                *--v304 = v305;
              }
              *(_QWORD *)(v273 + 256) = v304;
              *(_QWORD *)(v273 + 264) = v297;
              *(_QWORD *)(v273 + 272) = v302 + 4 * v303;
              if (v298)
                operator delete(v298);
            }
            else
            {
              *(_DWORD *)v296 = v293.i32[0];
              v297 = v296 + 4;
            }
            *(_QWORD *)(v273 + 264) = v297;
            v288 = v291 + 1;
            *(double *)(*(_QWORD *)(v273 + 232) + 8 * v291) = (double)v294;
            v287 += v294;
          }
          v286 = objc_msgSend(v285, "countByEnumeratingWithState:objects:count:", v393, buf, 16);
        }
        while (v286);
        v306 = (double)v287;
        v277 = __pc;
        v282 = v356;
        v281 = v359;
        v279 = (id *)(v273 + 280);
      }
      else
      {
        v306 = 0.0;
      }

      v307 = *(double **)(v273 + 232);
      v308 = *(double **)(v273 + 240);
      while (v307 != v308)
      {
        *v307 = *v307 / v306;
        ++v307;
      }
    }
    if (*(_QWORD *)(v273 + 256) == *(_QWORD *)(v273 + 264))
    {
      v309 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v281, "objectForKeyedSubscript:", CFSTR("num_cores")));
      v310 = objc_msgSend(v309, "unsignedIntValue");
      v311 = v310;
      v313 = *(unsigned int **)(v273 + 264);
      v312 = *(_QWORD *)(v273 + 272);
      if ((unint64_t)v313 >= v312)
      {
        v315 = *(unsigned int **)(v273 + 256);
        v316 = v313 - v315;
        v317 = v316 + 1;
        if ((unint64_t)(v316 + 1) >> 62)
          abort();
        v318 = v312 - (_QWORD)v315;
        if (v318 >> 1 > v317)
          v317 = v318 >> 1;
        v319 = (unint64_t)v318 >= 0x7FFFFFFFFFFFFFFCLL;
        v320 = 0x3FFFFFFFFFFFFFFFLL;
        if (!v319)
          v320 = v317;
        if (v320)
        {
          v320 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v320);
          v315 = *(unsigned int **)(v273 + 256);
          v313 = *(unsigned int **)(v273 + 264);
        }
        else
        {
          v321 = 0;
        }
        v322 = (unsigned int *)(v320 + 4 * v316);
        v323 = v320 + 4 * v321;
        *v322 = v311;
        v314 = v322 + 1;
        while (v313 != v315)
        {
          v324 = *--v313;
          *--v322 = v324;
        }
        *(_QWORD *)(v273 + 256) = v322;
        *(_QWORD *)(v273 + 264) = v314;
        *(_QWORD *)(v273 + 272) = v323;
        if (v315)
          operator delete(v315);
      }
      else
      {
        *v313 = v310;
        v314 = v313 + 1;
      }
      *(_QWORD *)(v273 + 264) = v314;

    }
    v325 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*v279, "objectForKeyedSubscript:", CFSTR("limiter sample counters")));
    v326 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*v279, "objectForKeyedSubscript:", CFSTR("Counter Info")));
    v327 = (_QWORD *)(v273 + 208);
    std::vector<BOOL>::resize(v273 + 208, (unint64_t)objc_msgSend(v325, "count"), 1);
    if (!v326)
    {
LABEL_318:

      objc_opt_new(GRCPerFrameDataClass, v335);
      operator new();
    }
    for (jj = 0; ; ++jj)
    {
      if (jj >= (unint64_t)objc_msgSend(v325, "count"))
        goto LABEL_318;
      v329 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v325, "objectAtIndexedSubscript:", jj));
      v330 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v326, "objectForKeyedSubscript:", v329));

      if (v330)
      {
        v331 = objc_msgSend(v330, "unsignedIntValue");
        v332 = (uint64_t *)(*v327 + 8 * (jj >> 6));
        v333 = 1 << jj;
        if (v331 != 1)
        {
          v334 = *v332 & ~v333;
          goto LABEL_317;
        }
      }
      else
      {
        v332 = (uint64_t *)(*v327 + 8 * (jj >> 6));
        v333 = 1 << jj;
      }
      v334 = *v332 | v333;
LABEL_317:
      *v332 = v334;

    }
  }
LABEL_319:

}

void sub_2EBDA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,_Unwind_Exception *exception_objecta,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43)
{
  void *v43;

  _Unwind_Resume(a1);
}

void ___ZN31MTLGRCStreamingSampleHelperImpl19ProcessStreamedDataEP12NSDictionaryS1__block_invoke(uint64_t a1)
{
  uint64_t v2;
  unsigned __int8 v3;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  NSObject *v9;
  os_signpost_id_t v10;
  uint8_t v11[16];

  v2 = *(_QWORD *)(a1 + 32);
  v3 = atomic_load((unsigned __int8 *)(v2 + 140));
  if ((v3 & 1) == 0)
  {
    v4 = (*(uint64_t (**)(void))(*(_QWORD *)(v2 + 112) + 16))();
    v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
    v6 = v5;
    if (v5)
    {
      v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("Kick Time Data")));
      if (v7)
        objc_msgSend(*(id *)(v2 + 88), "setArray:", v7);

    }
  }
  v8 = g_signpostLog;
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 40);
  if (v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v8))
  {
    *(_WORD *)v11 = 0;
    _os_signpost_emit_with_name_impl(&dword_0, v9, OS_SIGNPOST_INTERVAL_END, v10, "ShaderProfiler-ProcessStreamedDataPayload", "usc sampling address data", v11, 2u);
  }

}

void sub_2EC410(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void GRCCurrentFrameStream::AddGRCSampledData(id *this, NSDictionary *a2)
{
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  unint64_t v15;
  id v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  uint8x8_t v22;
  void **v23;
  _QWORD *v24;
  unint64_t v25;
  float v26;
  float v27;
  _BOOL8 v28;
  unint64_t v29;
  unint64_t v30;
  size_t v31;
  uint64_t v32;
  _QWORD *v33;
  unint64_t v34;
  void *context;
  void *v36;
  NSDictionary *v37;

  v37 = a2;
  v3 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v37, "objectForKeyedSubscript:", CFSTR("RingBufferIndex")));
  if (!v3)
    goto LABEL_46;
  v36 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v37, "objectForKeyedSubscript:", CFSTR("ShaderProfilerData")));
  v4 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v37, "objectForKeyedSubscript:", CFSTR("Source")));
  context = objc_autoreleasePoolPush();
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*this, "objectForKeyedSubscript:", v3));

  if (!v5)
  {
    v7 = (void *)objc_opt_new(NSMutableDictionary, v6);
    objc_msgSend(*this, "setObject:forKeyedSubscript:", v7, v3);

  }
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*this, "objectForKeyedSubscript:", v3));
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", v4));

  if (!v9)
  {
    v11 = (void *)objc_opt_new(NSMutableArray, v10);
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*this, "objectForKeyedSubscript:", v3));
    objc_msgSend(v12, "setObject:forKeyedSubscript:", v11, v4);

  }
  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*this, "objectForKeyedSubscript:", v3));
  v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "objectForKeyedSubscript:", v4));
  v15 = (unint64_t)v36;
  objc_msgSend(v14, "addObject:", v36);

  v16 = objc_msgSend(v36, "length");
  v17 = objc_msgSend(v3, "unsignedIntValue");
  v18 = v17;
  v19 = (uint64_t *)(this + 1);
  v20 = v17;
  v21 = (unint64_t)this[2];
  if (v21)
  {
    v22 = (uint8x8_t)vcnt_s8((int8x8_t)v21);
    v22.i16[0] = vaddlv_u8(v22);
    if (v22.u32[0] > 1uLL)
    {
      v15 = v17;
      if (v21 <= v17)
        v15 = v17 % v21;
    }
    else
    {
      v15 = ((_DWORD)v21 - 1) & v17;
    }
    v23 = *(void ***)(*v19 + 8 * v15);
    if (v23)
    {
      v24 = *v23;
      if (*v23)
      {
        do
        {
          v25 = v24[1];
          if (v25 == v17)
          {
            if (*((_DWORD *)v24 + 4) == v17)
              goto LABEL_45;
          }
          else
          {
            if (v22.u32[0] > 1uLL)
            {
              if (v25 >= v21)
                v25 %= v21;
            }
            else
            {
              v25 &= v21 - 1;
            }
            if (v25 != v15)
              break;
          }
          v24 = (_QWORD *)*v24;
        }
        while (v24);
      }
    }
  }
  v24 = operator new(0x20uLL);
  *v24 = 0;
  v24[1] = v20;
  *((_DWORD *)v24 + 4) = v18;
  v24[3] = 0;
  v26 = (float)((unint64_t)this[4] + 1);
  v27 = *((float *)this + 10);
  if (!v21 || (float)(v27 * (float)v21) < v26)
  {
    v28 = 1;
    if (v21 >= 3)
      v28 = (v21 & (v21 - 1)) != 0;
    v29 = v28 | (2 * v21);
    v30 = vcvtps_u32_f32(v26 / v27);
    if (v29 <= v30)
      v31 = v30;
    else
      v31 = v29;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)(this + 1), v31);
    v21 = (unint64_t)this[2];
    if ((v21 & (v21 - 1)) != 0)
    {
      if (v21 <= v20)
        v15 = v20 % v21;
      else
        v15 = v20;
    }
    else
    {
      v15 = ((_DWORD)v21 - 1) & v20;
    }
  }
  v32 = *v19;
  v33 = *(_QWORD **)(*v19 + 8 * v15);
  if (v33)
  {
    *v24 = *v33;
  }
  else
  {
    *v24 = this[3];
    this[3] = v24;
    *(_QWORD *)(v32 + 8 * v15) = this + 3;
    if (!*v24)
      goto LABEL_44;
    v34 = *(_QWORD *)(*v24 + 8);
    if ((v21 & (v21 - 1)) != 0)
    {
      if (v34 >= v21)
        v34 %= v21;
    }
    else
    {
      v34 &= v21 - 1;
    }
    v33 = (_QWORD *)(*v19 + 8 * v34);
  }
  *v33 = v24;
LABEL_44:
  this[4] = (char *)this[4] + 1;
LABEL_45:
  v24[3] += v16;
  objc_autoreleasePoolPop(context);

LABEL_46:
}

void sub_2EC7B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, id a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void std::make_unique[abi:nn180100]<GRCFrameTimeData,NSDictionary * {__strong}&>()
{
  operator new();
}

void ___ZN31MTLGRCStreamingSampleHelperImpl19ProcessStreamedDataEP12NSDictionaryS1__block_invoke_211(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSSet *v8;
  void *v9;
  void *v10;
  void *v11;
  double v12;
  void *v13;
  BOOL v14;
  unint64_t v15;
  unint64_t v16;
  id v17;
  id v18;
  void *v19;
  unint64_t v20;
  void *v21;
  uint64_t v22;
  char *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t *v27;
  int v28;
  uint64_t v29;
  unint64_t v30;
  char v31;
  unsigned int *v32;
  unsigned int v33;
  void *v34;
  uint64_t v35;
  unsigned int v36;
  id v37;
  id v38;
  unint64_t v39;
  unint64_t v40;
  id v41;
  id v42;
  uint64_t v43;
  void *j;
  id v45;
  id v46;
  char *v47;
  char *v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;
  char *v55;
  uint64_t v56;
  char *v57;
  unint64_t v58;
  char *v59;
  char *v60;
  char *v61;
  void *v62;
  _BOOL4 v63;
  NSData *v64;
  int NextMarker;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  char *v69;
  char *v70;
  char *v71;
  uint64_t v72;
  int v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  char *v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  _QWORD *v82;
  _QWORD *v83;
  unint64_t v84;
  unint64_t v85;
  BOOL v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  char *v94;
  uint64_t v95;
  NSData *v96;
  int v97;
  char *v98;
  uint64_t v99;
  char *v100;
  uint64_t v101;
  unint64_t v102;
  unint64_t v103;
  char *v104;
  uint64_t v105;
  unsigned __int8 v106;
  uint64_t v107;
  void *v108;
  void *v109;
  id v110;
  void *v111;
  NSObject *v112;
  os_signpost_id_t v113;
  id v114;
  uint64_t v116;
  void *v117;
  void *v118;
  void *v119;
  id obj;
  uint64_t v121;
  id v122;
  void *v123;
  void *i;
  uint64_t v125;
  id v126;
  unint64_t v127;
  uint64_t v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  _OWORD v133[2];
  int v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  void *__p;
  char *v140;
  unint64_t v141;
  void **p_p;
  _QWORD v143[3];
  _QWORD v144[3];
  _QWORD v145[16];
  uint8_t buf[8];
  uint8_t *v147;
  uint64_t v148;
  __n128 (*v149)(__n128 *, __n128 *);
  void (*v150)(uint64_t);
  void *v151;
  void *v152;
  void *v153;
  uint64_t v154;

  v116 = *(_QWORD *)(a1 + 40);
  v128 = *(_QWORD *)(v116 + 16);
  if (!*(_QWORD *)v128)
  {
    v12 = 0.0;
    goto LABEL_151;
  }
  v117 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)v128, "objectForKeyedSubscript:", CFSTR("TraceId to SampleIndex")));
  if (!v117)
    goto LABEL_32;
  v2 = objc_opt_class(NSDictionary, v1);
  v4 = objc_opt_class(NSArray, v3);
  v6 = objc_opt_class(NSNumber, v5);
  v8 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v2, v4, v6, objc_opt_class(NSNull, v7), 0);
  v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  *(_QWORD *)&v135 = 0;
  v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:](NSKeyedUnarchiver, "unarchivedObjectOfClasses:fromData:error:", v9, v117, &v135));
  v126 = (id)v135;

  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)v128, "objectForKeyedSubscript:", CFSTR("Frame Encoder Times Data")));
  v12 = 0.0;
  if (!objc_msgSend(v10, "count"))
    goto LABEL_29;
  if (objc_msgSend(v11, "count")
    && (v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "firstObject")),
        v14 = objc_msgSend(v13, "length") == 0,
        v13,
        !v14))
  {
    v15 = 0;
    v16 = -1;
    while (v15 < (unint64_t)objc_msgSend(v11, "count"))
    {
      v17 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectAtIndexedSubscript:", v15)));
      v18 = objc_msgSend(v17, "bytes");

      v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectAtIndexedSubscript:", v15));
      v20 = (unint64_t)objc_msgSend(v19, "length");

      *(_QWORD *)buf = 0;
      v147 = buf;
      v148 = 0x4812000000;
      v149 = __Block_byref_object_copy__7742;
      v150 = __Block_byref_object_dispose__7743;
      v151 = &unk_4C2897;
      v153 = 0;
      v154 = 0;
      v152 = 0;
      std::vector<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>::reserve(&v152, v20 >> 3);
      v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectAtIndexedSubscript:", v15));
      v145[0] = _NSConcreteStackBlock;
      v145[1] = 3221225472;
      v145[2] = ___ZN16GRCFrameTimeData26ProcessFrameTimeSampleDataERd_block_invoke;
      v145[3] = &unk_726A80;
      v145[4] = buf;
      v145[5] = v18;
      objc_msgSend(v21, "enumerateKeysAndObjectsUsingBlock:", v145);

      v22 = *((_QWORD *)v147 + 6);
      v23 = (char *)*((_QWORD *)v147 + 7);
      v24 = 126 - 2 * __clz((uint64_t)&v23[-v22] >> 5);
      if (v23 == (char *)v22)
        v25 = 0;
      else
        v25 = v24;
      std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *,false>(v22, v23, v25, 1);
      v26 = (uint64_t *)*((_QWORD *)v147 + 6);
      v27 = (uint64_t *)*((_QWORD *)v147 + 7);
      if (v26 == v27)
      {
        v30 = 0;
      }
      else
      {
        v28 = 0;
        v29 = 0;
        v30 = 0;
        do
        {
          if (!v28)
            v29 = *v26;
          if ((v26[2] & 1) != 0)
            --v28;
          else
            ++v28;
          if (!v28)
            v30 = v30 - v29 + *v26;
          v26 += 4;
        }
        while (v26 != v27);
      }
      if (v30 < v16)
        v16 = v30;
      _Block_object_dispose(buf, 8);
      if (v152)
      {
        v153 = v152;
        operator delete(v152);
      }
      ++v15;
    }
    v12 = (double)v16;
    v31 = 1;
  }
  else
  {
LABEL_29:
    v31 = 0;
  }

  if ((v31 & 1) == 0)
  {
LABEL_32:
    v118 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)v128, "objectForKeyedSubscript:", CFSTR("Frame Time Data")));
    v114 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)v128, "objectForKeyedSubscript:", CFSTR("Encoder TraceId Data"))));
    v32 = (unsigned int *)objc_msgSend(v114, "bytes");
    v33 = objc_msgSend(v114, "length");
    v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)v128, "objectForKeyedSubscript:", CFSTR("Sample Marker")));
    LODWORD(v35) = v33 >> 2;
    *(_QWORD *)(v128 + 8) = objc_msgSend(v34, "unsignedLongLongValue");

    memset(v133, 0, sizeof(v133));
    v134 = 1050253722;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)v133, vcvtps_u32_f32((float)(v33 >> 2) / 0.3));
    if (v33 >= 4)
    {
      if (v35 <= 1)
        v35 = 1;
      else
        v35 = v35;
      do
      {
        v36 = *v32++;
        std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)v133, v36, v36);
        --v35;
      }
      while (v35);
    }
    v131 = 0u;
    v132 = 0u;
    v129 = 0u;
    v130 = 0u;
    obj = v118;
    v37 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v129, v145, 16);
    if (!v37)
    {
      v12 = 1.79769313e308;
      goto LABEL_150;
    }
    v121 = *(_QWORD *)v130;
    v122 = v37;
    v12 = 1.79769313e308;
    while (1)
    {
      for (i = 0; i != v122; i = (char *)i + 1)
      {
        if (*(_QWORD *)v130 != v121)
          objc_enumerationMutation(obj);
        v38 = *(id *)(*((_QWORD *)&v129 + 1) + 8 * (_QWORD)i);
        v39 = (unint64_t)objc_msgSend(v38, "count");
        v40 = v39;
        if (v39)
        {
          if (v39 >> 62)
            abort();
          v123 = std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v39);
          bzero(v123, 4 * v40);
        }
        else
        {
          v123 = 0;
        }
        __p = 0;
        v140 = 0;
        v141 = 0;
        std::vector<std::pair<unsigned int,unsigned int>>::reserve(&__p, (unint64_t)objc_msgSend(v38, "count"));
        v137 = 0u;
        v138 = 0u;
        v135 = 0u;
        v136 = 0u;
        v41 = v38;
        v42 = objc_msgSend(v41, "countByEnumeratingWithState:objects:count:", &v135, buf, 16);
        if (v42)
        {
          v43 = *(_QWORD *)v136;
          do
          {
            for (j = 0; j != v42; j = (char *)j + 1)
            {
              if (*(_QWORD *)v136 != v43)
                objc_enumerationMutation(v41);
              v45 = objc_msgSend(objc_retainAutorelease(*(id *)(*((_QWORD *)&v135 + 1) + 8 * (_QWORD)j)), "bytes");
              v46 = v45;
              v47 = v140;
              if ((unint64_t)v140 >= v141)
              {
                v49 = (v140 - (_BYTE *)__p) >> 3;
                if ((unint64_t)(v49 + 1) >> 61)
                  abort();
                v50 = (uint64_t)(v141 - (_QWORD)__p) >> 2;
                if (v50 <= v49 + 1)
                  v50 = v49 + 1;
                if (v141 - (unint64_t)__p >= 0x7FFFFFFFFFFFFFF8)
                  v51 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v51 = v50;
                if (v51)
                  v51 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v51);
                else
                  v52 = 0;
                v53 = (char *)(v51 + 8 * v49);
                *(_QWORD *)v53 = v46;
                v48 = v53 + 8;
                v55 = (char *)__p;
                v54 = v140;
                if (v140 != __p)
                {
                  do
                  {
                    v56 = *((_QWORD *)v54 - 1);
                    v54 -= 8;
                    *((_QWORD *)v53 - 1) = v56;
                    v53 -= 8;
                  }
                  while (v54 != v55);
                  v54 = (char *)__p;
                }
                __p = v53;
                v140 = v48;
                v141 = v51 + 8 * v52;
                if (v54)
                  operator delete(v54);
              }
              else
              {
                *(_QWORD *)v140 = v45;
                v48 = v47 + 8;
              }
              v140 = v48;
            }
            v42 = objc_msgSend(v41, "countByEnumeratingWithState:objects:count:", &v135, buf, 16);
          }
          while (v42);
        }

        v57 = v140;
        if (v140 == __p)
        {
          v127 = 0;
          goto LABEL_140;
        }
        v58 = 0;
        v59 = 0;
        v60 = 0;
        v61 = 0;
        do
        {
          v62 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "objectAtIndexedSubscript:", v58));
          v63 = (unint64_t)objc_msgSend(v62, "length") > 0x3F;

          if (v63)
          {
            v64 = (NSData *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "objectAtIndexedSubscript:", v58));
            NextMarker = FindNextMarker(v64, 0, *(_QWORD *)(v128 + 8));

            if (NextMarker != -1)
            {
              if (v60 >= v61)
              {
                v66 = (v60 - v59) >> 3;
                v67 = v66 + 1;
                if ((unint64_t)(v66 + 1) >> 61)
                  abort();
                if ((v61 - v59) >> 2 > v67)
                  v67 = (v61 - v59) >> 2;
                if ((unint64_t)(v61 - v59) >= 0x7FFFFFFFFFFFFFF8)
                  v68 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v68 = v67;
                if (v68 >> 61)
                  std::__throw_bad_array_new_length[abi:nn180100]();
                v69 = (char *)operator new(8 * v68);
                v70 = &v69[8 * v66];
                *(_DWORD *)v70 = v58;
                *((_DWORD *)v70 + 1) = 0;
                v71 = v70;
                while (v60 != v59)
                {
                  v72 = *((_QWORD *)v60 - 1);
                  v60 -= 8;
                  *((_QWORD *)v71 - 1) = v72;
                  v71 -= 8;
                }
                v61 = &v69[8 * v68];
                v60 = v70 + 8;
                if (v59)
                  operator delete(v59);
                v59 = v71;
              }
              else
              {
                *(_DWORD *)v60 = v58;
                *((_DWORD *)v60 + 1) = 0;
                v60 += 8;
              }
              p_p = &__p;
              std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::$_0 &,std::__wrap_iter<GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::PriorityQueueElement *>>((uint64_t)v59, (uint64_t)v60, (uint64_t **)&p_p, (v60 - v59) >> 3);
            }
          }
          ++v58;
          v57 = (char *)__p;
        }
        while (v58 < (v140 - (_BYTE *)__p) >> 3);
        if (v59 != v60)
        {
          v125 = 0;
          v127 = 0;
          v73 = 0;
          while (1)
          {
            v74 = *(_QWORD *)v59;
            p_p = &__p;
            if (v60 - v59 < 9)
              goto LABEL_111;
            v75 = 0;
            v76 = (v60 - v59) >> 3;
            v77 = *(_QWORD *)v59;
            v78 = v59;
            do
            {
              v79 = v78;
              v78 += 8 * v75 + 8;
              v80 = 2 * v75;
              v75 = (2 * v75) | 1;
              v81 = v80 + 2;
              if (v81 >= v76)
                goto LABEL_107;
              v82 = (_QWORD *)(*((_QWORD *)*p_p + *(unsigned int *)v78) + 8 * *((unsigned int *)v78 + 1));
              v83 = (_QWORD *)(*((_QWORD *)*p_p + *((unsigned int *)v78 + 2)) + 8 * *((unsigned int *)v78 + 3));
              v84 = v82[1];
              v85 = v83[1];
              v86 = v84 > v85;
              if (v84 == v85
                && (v87 = v82[4], v88 = v83[4], v86 = v87 > v88, v87 == v88)
                && (v89 = v82[5], v90 = v83[5], v86 = v89 > v90, v89 == v90))
              {
                v91 = v82[3];
                v92 = v83[3];
                if (v91 > v84 && v91 != v92)
                {
LABEL_106:
                  v78 += 8;
                  v75 = v81;
                }
              }
              else if (v86)
              {
                goto LABEL_106;
              }
LABEL_107:
              *(_QWORD *)v79 = *(_QWORD *)v78;
            }
            while (v75 <= (uint64_t)((unint64_t)(v76 - 2) >> 1));
            v94 = v60 - 8;
            if (v78 == v60 - 8)
            {
              *(_QWORD *)v78 = v77;
            }
            else
            {
              *(_QWORD *)v78 = *(_QWORD *)v94;
              *(_QWORD *)v94 = v77;
              std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::$_0 &,std::__wrap_iter<GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::PriorityQueueElement *>>((uint64_t)v59, (uint64_t)(v78 + 8), (uint64_t **)&p_p, (v78 + 8 - v59) >> 3);
            }
LABEL_111:
            v95 = *((_QWORD *)__p + v74) + 8 * HIDWORD(v74);
            if (std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>(v133, *(_DWORD *)(v95 + 32)))
            {
              if (!v73)
                v125 = *(_QWORD *)(v95 + 8);
              if ((*(_BYTE *)(v95 + 24) & 1) != 0)
                --v73;
              else
                ++v73;
              if (!v73)
                v127 = v127 - v125 + *(_QWORD *)(v95 + 8);
            }
            v96 = (NSData *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "objectAtIndexedSubscript:", v74));
            v97 = FindNextMarker(v96, HIDWORD(v74) + 8, *(_QWORD *)(v128 + 8));

            v98 = v60 - 8;
            if (v97 != -1)
            {
              if (v98 >= v61)
              {
                v101 = (v98 - v59) >> 3;
                v102 = v101 + 1;
                if ((unint64_t)(v101 + 1) >> 61)
                  abort();
                if ((v61 - v59) >> 2 > v102)
                  v102 = (v61 - v59) >> 2;
                if ((unint64_t)(v61 - v59) >= 0x7FFFFFFFFFFFFFF8)
                  v103 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v103 = v102;
                if (v103 >> 61)
                  std::__throw_bad_array_new_length[abi:nn180100]();
                v104 = (char *)operator new(8 * v103);
                v100 = &v104[8 * v101];
                *(_DWORD *)v100 = v74;
                *((_DWORD *)v100 + 1) = v97;
                v99 = (uint64_t)v100;
                if (v98 != v59)
                {
                  v99 = (uint64_t)v100;
                  do
                  {
                    v105 = *((_QWORD *)v98 - 1);
                    v98 -= 8;
                    *(_QWORD *)(v99 - 8) = v105;
                    v99 -= 8;
                  }
                  while (v98 != v59);
                }
                v61 = &v104[8 * v103];
                operator delete(v59);
                v59 = (char *)v99;
              }
              else
              {
                *((_DWORD *)v60 - 2) = v74;
                *((_DWORD *)v60 - 1) = v97;
                v99 = (uint64_t)v59;
                v100 = v60 - 8;
              }
              v98 = v100 + 8;
              p_p = &__p;
              std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::$_0 &,std::__wrap_iter<GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::PriorityQueueElement *>>(v99, (uint64_t)(v100 + 8), (uint64_t **)&p_p, (uint64_t)&v100[-v99 + 8] >> 3);
            }
            v60 = v98;
            if (v59 == v98)
            {
LABEL_139:
              operator delete(v98);
              v57 = (char *)__p;
              goto LABEL_140;
            }
          }
        }
        v127 = 0;
        if (v60)
        {
          v98 = v60;
          goto LABEL_139;
        }
LABEL_140:
        if (v57)
        {
          v140 = v57;
          operator delete(v57);
        }
        if (v123)
          operator delete(v123);

        if (v12 >= (double)v127 * 125.0 / 3.0)
          v12 = (double)v127 * 125.0 / 3.0;
      }
      v122 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v129, v145, 16);
      if (!v122)
      {
LABEL_150:

        std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v133);
        break;
      }
    }
  }
LABEL_151:
  v106 = atomic_load((unsigned __int8 *)(v116 + 140));
  if ((v106 & 1) == 0)
  {
    v107 = *(_QWORD *)(v116 + 112);
    v143[0] = CFSTR("GPU Time");
    v119 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v12));
    v144[0] = v119;
    v143[1] = CFSTR("Frame Time Data");
    v144[1] = **(_QWORD **)(v116 + 16);
    v143[2] = CFSTR("Num Ring Buffers");
    v108 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:"));
    v144[2] = v108;
    v109 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v144, v143, 3));
    v110 = (id)(*(uint64_t (**)(uint64_t, void *))(v107 + 16))(v107, v109);

  }
  v111 = g_signpostLog;
  v112 = v111;
  v113 = *(_QWORD *)(a1 + 48);
  if (v113 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v111))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_0, v112, OS_SIGNPOST_INTERVAL_END, v113, "ShaderProfiler-ProcessStreamedDataPayload", "Frame Time Data", buf, 2u);
  }

}

void sub_2ED494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *__p,uint64_t a48)
{
  void *v48;
  void *v49;
  void *v50;

  _Unwind_Resume(a1);
}

void std::make_unique[abi:nn180100]<GRCSplitBlitTimeData,NSDictionary * {__strong}&>()
{
  operator new();
}

void sub_2ED6C8()
{
  id *v0;
  void *v1;
  void *v2;

  operator delete();
}

void ___ZN31MTLGRCStreamingSampleHelperImpl19ProcessStreamedDataEP12NSDictionaryS1__block_invoke_216(uint64_t a1)
{
  id *v1;
  id v2;
  id v3;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  id v8;
  void *v9;
  void *v10;
  id v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  void *v16;
  unint64_t v17;
  unint64_t v18;
  void *v19;
  double *v20;
  unint64_t v21;
  uint64_t v22;
  void *v23;
  void *v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  double v28;
  double *v29;
  double v30;
  char *v31;
  char *v32;
  uint64_t v33;
  double *v34;
  void *v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  double v39;
  uint64_t v40;
  double v41;
  double v42;
  void *v43;
  const CATransform3D **v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  uint64_t i;
  void *v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  void *v53;
  uint64_t j;
  void *v55;
  unsigned __int8 v56;
  id v57;
  void *v58;
  NSObject *v59;
  os_signpost_id_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v65;
  id v66;
  void *v67;
  char *v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  _QWORD v73[6];
  uint8_t buf[8];
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  void *v79;

  v63 = *(_QWORD *)(a1 + 32);
  v1 = *(id **)(v63 + 24);
  v2 = GRCSplitBlitTimeData::BlitFrameEncoderTimeData(v1, CFSTR("Blit TraceId to Sample Index"), CFSTR("Blit Encoder Time Data"));
  v66 = (id)objc_claimAutoreleasedReturnValue(v2);
  v3 = GRCSplitBlitTimeData::BlitFrameEncoderTimeData(v1, CFSTR("Blit Split TraceId to Sample Index"), CFSTR("Blit Split Encoder Time Data"));
  v4 = objc_claimAutoreleasedReturnValue(v3);
  v5 = (void *)v4;
  if (v66)
  {
    if (v4)
      goto LABEL_6;
  }
  else
  {
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*v1, "objectForKeyedSubscript:", CFSTR("Blit Encoder Frame Data")));
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*v1, "objectForKeyedSubscript:", CFSTR("Blit Encoder Info")));
    v8 = GRCSplitBlitTimeData::CalculateBlitEncoderTime((uint64_t)v1, v6, v7);
    v66 = (id)objc_claimAutoreleasedReturnValue(v8);

    if (v5)
      goto LABEL_6;
  }
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*v1, "objectForKeyedSubscript:", CFSTR("Blit Split Encoder Frame Data")));
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*v1, "objectForKeyedSubscript:", CFSTR("Blit Split Encoder Info")));
  v11 = GRCSplitBlitTimeData::CalculateBlitEncoderTime((uint64_t)v1, v9, v10);
  v5 = (void *)objc_claimAutoreleasedReturnValue(v11);

LABEL_6:
  if (objc_msgSend(v5, "length"))
  {
    v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*v1, "objectForKeyedSubscript:", CFSTR("Blit Encoder Indices")));
    v71 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*v1, "objectForKeyedSubscript:", CFSTR("Encoder Draw Call Count")));
    v12 = (unint64_t)objc_msgSend(v5, "length");
    v13 = (unint64_t)objc_msgSend(v66, "length");
    v14 = v12 >> 5;
    if (v12 >= 0x20)
    {
      v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v12 >> 5);
      memset(v15, 255, 4 * v14);
      v68 = &v15[4 * v14];
    }
    else
    {
      v15 = 0;
      v68 = 0;
    }
    v17 = v13 >> 5;
    v61 = v12;
    v62 = v13;
    v65 = v12 >> 5;
    if (v13 >= 0x20)
    {
      v19 = std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v13 >> 5);
      v18 = v13 >> 5;
      bzero(v19, 8 * v17);
    }
    else
    {
      v18 = v13 >> 5;
      v19 = 0;
    }
    v20 = (double *)objc_msgSend(objc_retainAutorelease(v5), "bytes");
    v21 = 0;
    v22 = 0;
    while (v21 < (unint64_t)objc_msgSend(v72, "count", v61))
    {
      v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "objectAtIndexedSubscript:", v21));
      v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v71, "objectAtIndexedSubscript:", objc_msgSend(v23, "unsignedIntValue")));
      v25 = objc_msgSend(v24, "unsignedIntValue");

      if (v25)
        v26 = v22;
      else
        v26 = v22 + 1;
      if (v25)
      {
        v27 = v25;
        v28 = *((double *)v19 + v21);
        v29 = &v20[4 * v26 + 3];
        do
        {
          v30 = *v29;
          v29 += 4;
          v28 = v30 + v28;
          *((double *)v19 + v21) = v28;
          v22 = v26 + 1;
          *(_DWORD *)&v15[4 * v26++] = v21;
          --v27;
        }
        while (v27);
      }
      else
      {
        v22 = v26;
      }
      ++v21;
    }
    v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", v65));
    v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", v18));
    v31 = (char *)objc_msgSend(objc_retainAutorelease(v66), "bytes");
    v32 = v31;
    if (v62 >= 0x20)
    {
      if (v18 <= 1)
        v33 = 1;
      else
        v33 = v18;
      v34 = (double *)(v31 + 24);
      do
      {
        v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *v34));
        objc_msgSend(v70, "addObject:", v35);

        v34 += 4;
        --v33;
      }
      while (v33);
    }
    if (v68 != v15)
    {
      v36 = 0;
      v37 = 0;
      do
      {
        v38 = *(unsigned int *)&v15[4 * v36];
        if ((_DWORD)v38 != -1)
        {
          v39 = *((double *)v19 + v38);
          if (v39 >= 2.22044605e-16)
          {
            v40 = 0;
            v41 = v20[4 * v36 + 3];
            v42 = *(double *)&v32[32 * v38 + 24] * v41 / v39 / v41;
            if (v41 <= 2.22044605e-16)
              v42 = 1.0;
            do
            {
              v20[v40] = v42 * v20[v40];
              ++v40;
            }
            while (v40 != 3);
            v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:"));
            objc_msgSend(v67, "addObject:", v43);

          }
          else
          {
            objc_msgSend(v67, "addObject:", &off_739E08);
          }
        }
        v36 = ++v37;
      }
      while ((v68 - v15) >> 2 > (unint64_t)v37);
    }
    v44 = &CATransform3DIdentity_ptr;
    v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", v18));
    if (v62 >= 0x20)
    {
      v45 = 0;
      if (v18 <= 1)
        v46 = 1;
      else
        v46 = v18;
      do
      {
        v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", 3));
        for (i = 0; i != 24; i += 8)
        {
          v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)&v32[i]));
          objc_msgSend(v47, "addObject:", v49);

        }
        objc_msgSend(v69, "addObject:", v47);

        ++v45;
        v32 += 32;
        v44 = &CATransform3DIdentity_ptr;
      }
      while (v45 != v46);
    }
    v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", v65));
    if (v61 >= 0x20)
    {
      v51 = 0;
      if (v65 <= 1)
        v52 = 1;
      else
        v52 = v65;
      do
      {
        v53 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D arrayWithCapacity:]((id)v44[281], "arrayWithCapacity:", 3));
        for (j = 0; j != 3; ++j)
        {
          v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v20[j]));
          objc_msgSend(v53, "addObject:", v55);

        }
        objc_msgSend(v50, "addObject:", v53);

        ++v51;
        v20 += 4;
        v44 = &CATransform3DIdentity_ptr;
      }
      while (v51 != v52);
    }
    v73[0] = CFSTR("Blit Command Nsec Times");
    v73[1] = CFSTR("Blit Encoder Indices");
    *(_QWORD *)buf = v67;
    v75 = v72;
    v73[2] = CFSTR("Encoder Draw Call Count");
    v73[3] = CFSTR("Blit Encoder Nsec Times");
    v76 = v71;
    v77 = v70;
    v73[4] = CFSTR("Blit Encoder Kick Times Nsec");
    v73[5] = CFSTR("Blit Command Kick Times Nsec");
    v78 = v69;
    v79 = v50;
    v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", buf, v73, 6));

    if (v19)
      operator delete(v19);
    if (v15)
      operator delete(v15);

  }
  else
  {
    v16 = 0;
  }

  if (v16)
  {
    v56 = atomic_load((unsigned __int8 *)(v63 + 140));
    if ((v56 & 1) == 0)
      v57 = (id)(*(uint64_t (**)(void))(*(_QWORD *)(v63 + 112) + 16))();
  }
  v58 = g_signpostLog;
  v59 = v58;
  v60 = *(_QWORD *)(a1 + 40);
  if (v60 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v58))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_0, v59, OS_SIGNPOST_INTERVAL_END, v60, "ShaderProfiler-ProcessStreamedDataPayload", "Blit Encoder Frame Data", buf, 2u);
  }

}

void sub_2EDDEC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZN31MTLGRCStreamingSampleHelperImpl19ProcessStreamedDataEP12NSDictionaryS1__block_invoke_221()
{
  operator new();
}

void sub_2EF474(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,GRCDerivedCounterData *a25,void *__p,uint64_t a27)
{
  void *v27;

  std::unique_ptr<GRCDerivedCounterData>::reset[abi:nn180100](&a25);
  _Unwind_Resume(a1);
}

void ___ZN31MTLGRCStreamingSampleHelperImpl19ProcessStreamedDataEP12NSDictionaryS1__block_invoke_229(uint64_t a1)
{
  id v2;
  void *v3;
  NSObject *v4;
  os_signpost_id_t v5;
  uint8_t v6[16];

  v2 = objc_unsafeClaimAutoreleasedReturnValue((id)(*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 112)
                                                                        + 16))());
  v3 = g_signpostLog;
  v4 = v3;
  v5 = *(_QWORD *)(a1 + 48);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v3))
  {
    *(_WORD *)v6 = 0;
    _os_signpost_emit_with_name_impl(&dword_0, v4, OS_SIGNPOST_INTERVAL_END, v5, "ShaderProfiler-ProcessStreamedDataPayload", "End Batch ID Streaming Data", v6, 2u);
  }

}

void ___ZN31MTLGRCStreamingSampleHelperImpl19ProcessStreamedDataEP12NSDictionaryS1__block_invoke_231(uint64_t a1)
{
  unsigned __int8 v1;
  unsigned int v2;
  unsigned __int8 *v3;
  void *v4;
  unint64_t v5;
  unint64_t v6;
  float *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  char *v31;
  char *v32;
  char *v33;
  unint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  float v37;
  unint64_t v38;
  float v39;
  char *v40;
  float v41;
  unsigned int v42;
  unint64_t v43;
  unsigned int v44;
  uint64_t *v45;
  uint64_t *v46;
  int v47;
  unsigned __int16 v48;
  uint64_t **v49;
  GRCPerFrameData *v50;
  char *v51;
  unsigned int v52;
  uint64_t v53;
  void *v54;
  void *v55;
  unsigned int v56;
  void *v57;
  unsigned int v58;
  void *v59;
  unsigned int v60;
  void *v61;
  unsigned int v62;
  void *v63;
  void *v64;
  void *v65;
  unsigned int v66;
  uint64_t *v67;
  uint64_t *v68;
  id v69;
  void *v70;
  uint64_t *v71;
  uint64_t v72;
  void *v73;
  uint64_t **v74;
  uint64_t **v75;
  _DWORD *v76;
  unsigned int v77;
  uint64_t *v78;
  void *v79;
  NSObject *v80;
  os_signpost_id_t v81;
  _QWORD *WeakRetained;
  uint64_t v84;
  _QWORD *v85;
  uint64_t v86;
  char **v87;
  char *v88;
  id v89;
  _QWORD **v90;
  _QWORD *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  _QWORD *v95;
  unsigned int v96;
  uint8_t buf[16];
  __int128 v98;
  int v99;

  v84 = *(_QWORD *)(a1 + 40);
  v1 = atomic_load((unsigned __int8 *)(v84 + 140));
  if ((v1 & 1) != 0)
    return;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v87 = (char **)WeakRetained[1];
  if (objc_msgSend(*(id *)v87[61], "count"))
  {
    v2 = objc_msgSend(*((id *)v87[61] + 38), "length");
    v3 = (unsigned __int8 *)objc_msgSend(*((id *)v87[61] + 38), "mutableBytes");
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)v87[61], "allKeys"));
    v5 = (unint64_t)objc_msgSend(v4, "count");
    v6 = v5;
    v7 = (float *)&unk_4AA000;
    if (!v5)
    {
LABEL_42:

      v40 = v87[61];
      *(_DWORD *)buf = -1;
      v86 = (uint64_t)(v87 + 13);
      *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>((uint64_t)(v87 + 13), 0xFFFFFFFF, buf)+ 5) = -1;
      *(_OWORD *)buf = 0u;
      v98 = 0u;
      v99 = 1050253722;
      v41 = v7[373];
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)buf, vcvtps_u32_f32((float)*((unint64_t *)v40 + 24) / v41));
      if (v2 >= 0x18)
      {
        v42 = 0;
        v43 = v2 / 0x18uLL;
        do
        {
          if ((*(_QWORD *)v3 & *((_QWORD *)v3 + 1) & *((_QWORD *)v3 + 2)) != -1)
          {
            v44 = *((_DWORD *)v3 + 1);
            if (v44 == -1)
            {
              v42 = *(_DWORD *)v3 >> 8;
            }
            else
            {
              v96 = *((_DWORD *)v3 + 1);
              v45 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>((_QWORD *)v40 + 21, v42);
              if (v45)
              {
                v44 = *((_DWORD *)v45 + 5);
                v96 = v44;
                *((_DWORD *)v3 + 1) = v44;
                v46 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>(buf, v44);
                if (v46)
                {
                  v47 = *((_DWORD *)v46 + 5) + 1;
                  *((_DWORD *)v46 + 5) = v47;
                }
                else
                {
                  v47 = *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,unsigned int &,int>((uint64_t)buf, v44, v44, 0)+ 5);
                }
                *(_DWORD *)v3 = *v3 | (v47 << 8);
              }
              *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v86, v44, &v96)+ 5) = v42;
              if (*((_QWORD *)v3 + 1) != -1)
              {
                v48 = *v3;
                v91 = 0;
                v92 = 0;
                v90 = &v91;
                LODWORD(v93) = v44;
                std::set<ProgramAddressHelper::ProgramAddressInfo>::set[abi:nn180100]((uint64_t)&v94, &v90);
                v49 = (uint64_t **)std::__hash_table<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,std::set<ProgramAddressHelper::ProgramAddressInfo>>>((uint64_t)(v87 + 3), v93, (uint64_t)&v93);
                std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>>>::destroy(v95);
                std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>>>::destroy(v91);
                v49 += 3;
                std::__tree<ProgramAddressHelper::ProgramAddressInfo>::__emplace_unique_impl<unsigned long long &,ProgramAddressHelper::eAddressRange,unsigned int &>(v49, *((_QWORD *)v3 + 1), 0, v48);
                std::__tree<ProgramAddressHelper::ProgramAddressInfo>::__emplace_unique_impl<unsigned long long &,ProgramAddressHelper::eAddressRange,unsigned int &>(v49, *((_QWORD *)v3 + 2), 2u, v48);
                if ((*(_DWORD *)v3 & 0xFE) == 0x64)
                  std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int &>((uint64_t)(v87 + 8), v44, v44);
              }
            }
          }
          v3 += 24;
          --v43;
        }
        while (v43);
      }
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)buf);
      v50 = (GRCPerFrameData *)v87;
      v51 = v87[61];
      v89 = *((id *)v51 + 39);
      *(_OWORD *)buf = 0u;
      v98 = 0u;
      v99 = 1050253722;
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)buf, vcvtps_u32_f32((float)*((unint64_t *)v51 + 24) / v41));
      v52 = 0;
      v85 = v51 + 168;
      while (1)
      {
        v53 = v52;
        if ((unint64_t)objc_msgSend(v89, "count") <= v52)
          break;
        v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v89, "objectAtIndexedSubscript:", v52));
        v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v54, "objectForKeyedSubscript:", CFSTR("encID")));
        v56 = objc_msgSend(v55, "unsignedIntValue");

        v96 = v56;
        v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v54, "objectForKeyedSubscript:", CFSTR("mappedAddress")));
        v58 = objc_msgSend(v57, "unsignedLongLongValue");

        v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v54, "objectForKeyedSubscript:", CFSTR("mappedSize")));
        v60 = objc_msgSend(v59, "unsignedLongLongValue");

        v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v54, "objectForKeyedSubscript:", CFSTR("encIndex")));
        v62 = objc_msgSend(v61, "unsignedIntValue");

        v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v54, "objectForKeyedSubscript:", CFSTR("type")));
        v64 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(&off_739540, "objectForKeyedSubscript:", v63));
        v65 = v64;
        if (v64)
          v66 = objc_msgSend(v64, "unsignedIntValue");
        else
          v66 = 255;

        v67 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>(v85, v62);
        if (v67)
        {
          v68 = v67;
          v69 = objc_msgSend(v54, "mutableCopy");
          v96 = *((_DWORD *)v68 + 5);
          v56 = v96;
          v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v96));
          objc_msgSend(v69, "setObject:forKeyedSubscript:", v70, CFSTR("encID"));

          v71 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>(buf, v56);
          if (v71)
          {
            v72 = (*((_DWORD *)v71 + 5) + 1);
            *((_DWORD *)v71 + 5) = v72;
          }
          else
          {
            v72 = *((unsigned int *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,unsigned int &,int>((uint64_t)buf, v56, v56, 0)+ 5);
          }
          v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v72));
          objc_msgSend(v69, "setObject:forKeyedSubscript:", v73, CFSTR("index"));

          objc_msgSend(v89, "setObject:atIndexedSubscript:", v69, v53);
        }
        *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v86, v56, &v96)+ 5) = v62;
        v91 = 0;
        v92 = 0;
        v90 = &v91;
        LODWORD(v93) = v56;
        std::set<ProgramAddressHelper::ProgramAddressInfo>::set[abi:nn180100]((uint64_t)&v94, &v90);
        v74 = (uint64_t **)std::__hash_table<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,std::set<ProgramAddressHelper::ProgramAddressInfo>>>((uint64_t)(v87 + 3), v93, (uint64_t)&v93);
        std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>>>::destroy(v95);
        std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>>>::destroy(v91);
        v75 = v74 + 3;
        std::__tree<ProgramAddressHelper::ProgramAddressInfo>::__emplace_unique_impl<unsigned long long &,ProgramAddressHelper::eAddressRange,unsigned int &>(v74 + 3, v58, 0, v66);
        v50 = (GRCPerFrameData *)v87;
        v76 = operator new(0x28uLL);
        v77 = (v66 << 16) | 2;
        v76[7] = v58 + v60;
        v76[8] = v77;
        v78 = std::__tree<ProgramAddressHelper::ProgramAddressInfo>::__find_equal<ProgramAddressHelper::ProgramAddressInfo>((uint64_t)v75, &v93, v58 + v60, v77);
        if (*v78)
          operator delete(v76);
        else
          std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>>>::__insert_node_at(v75, v93, (uint64_t **)v78, (uint64_t *)v76);
        if ((v66 & 0xFFFFFFFE) == 0x64)
          std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int &>((uint64_t)(v87 + 8), v56, v56);

        v52 = v53 + 1;
      }
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)buf);

      GRCPerFrameData::EvaluatePerRingBufferSamples(v50);
      goto LABEL_73;
    }
    v8 = *v87;
    v9 = (uint64_t)v87[1];
    v10 = 0x2E8BA2E8BA2E8BA3 * ((v9 - (uint64_t)*v87) >> 3);
    v11 = v5 - v10;
    if (v5 <= v10)
    {
      if (v5 >= v10)
      {
        v34 = (unint64_t)v87[1];
        v35 = (uint64_t *)v87;
LABEL_36:
        v36 = *v35;
        if (v36 != v34)
        {
          v37 = v7[373];
          do
          {
            v38 = *(_QWORD *)(v36 + 8);
            if (v38)
              v39 = (float)*(unint64_t *)(v36 + 24) / (float)v38;
            else
              v39 = 0.0;
            *(float *)(v36 + 32) = fmaxf(v39, v37);
            v36 += 88;
          }
          while (v36 != v34);
        }
        goto LABEL_42;
      }
      v34 = (unint64_t)&v8[88 * v5];
      while (v9 != v34)
      {
        v9 -= 88;
        std::allocator<ProgramAddressHelper::PerRingBufferProgramInfo>::destroy[abi:nn180100](v9);
      }
    }
    else
    {
      v12 = v87[2];
      if (0x2E8BA2E8BA2E8BA3 * ((uint64_t)&v12[-v9] >> 3) < v11)
      {
        if (v5 > 0x2E8BA2E8BA2E8BALL)
          abort();
        v13 = 0x2E8BA2E8BA2E8BA3 * ((v12 - v8) >> 3);
        v14 = 2 * v13;
        if (2 * v13 <= v5)
          v14 = v5;
        if (v13 >= 0x1745D1745D1745DLL)
          v15 = 0x2E8BA2E8BA2E8BALL;
        else
          v15 = v14;
        if (v15 > 0x2E8BA2E8BA2E8BALL)
          std::__throw_bad_array_new_length[abi:nn180100]();
        v16 = (char *)operator new(88 * v15);
        v17 = &v16[88 * v10];
        v18 = &v16[88 * v6];
        v19 = v17;
        do
        {
          *((_QWORD *)v19 + 6) = 0;
          *((_QWORD *)v19 + 4) = 0;
          *((_QWORD *)v19 + 5) = v19 + 48;
          *(_OWORD *)v19 = 0uLL;
          *((_OWORD *)v19 + 1) = 0uLL;
          *((_DWORD *)v19 + 8) = 1065353216;
          *((_QWORD *)v19 + 7) = 0;
          *((_QWORD *)v19 + 8) = 0;
          *((_QWORD *)v19 + 9) = 0;
          *((_QWORD *)v19 + 10) = 0;
          v19 += 88;
        }
        while (v19 != v18);
        v20 = &v16[88 * v15];
        v22 = *v87;
        v21 = v87[1];
        if (v21 == *v87)
        {
          *v87 = v17;
          v87[1] = v18;
          v87[2] = v20;
        }
        else
        {
          v88 = v20;
          v23 = 0;
          do
          {
            v24 = &v17[v23];
            v25 = &v21[v23];
            std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__hash_table((uint64_t)&v17[v23 - 88], (uint64_t *)&v21[v23 - 88]);
            *((_QWORD *)v24 - 6) = *(_QWORD *)&v21[v23 - 48];
            v26 = &v21[v23 - 40];
            v27 = *(_QWORD *)v26;
            *((_QWORD *)v24 - 5) = *(_QWORD *)v26;
            v28 = (uint64_t)&v17[v23 - 40];
            v29 = *(_QWORD *)&v21[v23 - 32];
            *((_QWORD *)v24 - 4) = v29;
            if (v29)
            {
              *(_QWORD *)(v27 + 16) = v28;
              *((_QWORD *)v25 - 6) = v26;
              *(_QWORD *)v26 = 0;
              *((_QWORD *)v25 - 4) = 0;
            }
            else
            {
              *((_QWORD *)v24 - 6) = v28;
            }
            v30 = &v17[v23];
            v31 = &v21[v23];
            *((_QWORD *)v30 - 3) = 0;
            *((_QWORD *)v30 - 2) = 0;
            *((_QWORD *)v30 - 1) = 0;
            *(_OWORD *)(v30 - 24) = *(_OWORD *)&v21[v23 - 24];
            *((_QWORD *)v30 - 1) = *(_QWORD *)&v21[v23 - 8];
            *((_QWORD *)v31 - 3) = 0;
            *((_QWORD *)v31 - 2) = 0;
            *((_QWORD *)v31 - 1) = 0;
            v23 -= 88;
          }
          while (&v21[v23] != v22);
          v32 = &v17[v23];
          v33 = *v87;
          v21 = v87[1];
          *v87 = v32;
          v87[1] = v18;
          v87[2] = v88;
          v7 = (float *)&unk_4AA000;
          if (v21 != v33)
          {
            do
            {
              v21 -= 88;
              std::allocator<ProgramAddressHelper::PerRingBufferProgramInfo>::destroy[abi:nn180100]((uint64_t)v21);
            }
            while (v21 != v33);
            v21 = v33;
          }
        }
        if (v21)
          operator delete(v21);
        v35 = (uint64_t *)v87;
        v34 = (unint64_t)v87[1];
        goto LABEL_36;
      }
      v34 = v9 + 88 * v11;
      do
      {
        *(_QWORD *)(v9 + 48) = 0;
        *(_QWORD *)(v9 + 32) = 0;
        *(_QWORD *)(v9 + 40) = v9 + 48;
        *(_OWORD *)v9 = 0uLL;
        *(_OWORD *)(v9 + 16) = 0uLL;
        *(_DWORD *)(v9 + 32) = 1065353216;
        *(_QWORD *)(v9 + 56) = 0;
        *(_QWORD *)(v9 + 64) = 0;
        *(_QWORD *)(v9 + 72) = 0;
        *(_QWORD *)(v9 + 80) = 0;
        v9 += 88;
      }
      while (v9 != v34);
    }
    v35 = (uint64_t *)v87;
    v87[1] = (char *)v34;
    goto LABEL_36;
  }
LABEL_73:
  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(v84 + 120), 0xFFFFFFFFFFFFFFFFLL);
  objc_msgSend(*(id *)v84, "removeObject:", WeakRetained);
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v84 + 120));
  v79 = g_signpostLog;
  v80 = v79;
  v81 = *(_QWORD *)(a1 + 48);
  if (v81 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v79))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_0, v80, OS_SIGNPOST_INTERVAL_END, v81, "ShaderProfiler-ProcessStreamedDataPostProcessing", (const char *)&unk_4AAB5F, buf, 2u);
  }

}

void sub_2F0168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  uint64_t v20;

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v20 - 144);

  _Unwind_Resume(a1);
}

void GRCPerFrameData::EvaluatePerRingBufferSamples(GRCPerFrameData *this)
{
  uint64_t v1;
  GRCPerFrameData *v2;
  void *v3;
  unsigned int v4;
  void *v5;
  void *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  char *v14;
  uint64_t v15;
  int64x2_t v16;
  void *v17;
  id v18;
  void *v19;
  uint64_t v20;
  uint64_t *v21;
  unint64_t v22;
  uint8x8_t v23;
  void **v24;
  _QWORD *v25;
  unint64_t v26;
  float v27;
  float v28;
  _BOOL8 v29;
  unint64_t v30;
  unint64_t v31;
  size_t v32;
  uint64_t v33;
  _QWORD *v34;
  unint64_t v35;
  std::vector<unsigned int>::size_type v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  void *v40;
  void *v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  void *v45;
  _QWORD *v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t j;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  void *v55;
  unint64_t *v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t *v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t *v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t *v68;
  void *v69;
  unint64_t v70;
  unsigned int *v71;
  void *v72;
  uint64_t v73;
  void *v74;
  _QWORD *v75;
  unint64_t v76;
  unint64_t v77;
  char *v78;
  uint64_t v79;
  size_t v80;
  uint64_t v81;
  unint64_t v82;
  _QWORD *v83;
  uint64_t v84;
  void *v85;
  void **v86;
  void *v87;
  _BYTE *v88;
  unint64_t v89;
  void *v90;
  id v91;
  void *v92;
  _OWORD *v93;
  id v94;
  id v95;
  void *v96;
  id v97;
  uint64_t v98;
  uint64_t v99;
  unsigned int v100;
  unint64_t v101;
  void *v102;
  uint64_t v103;
  uint64_t v104;
  void *v105;
  void *v106;
  void *v107;
  _QWORD *k;
  void *v109;
  uint64_t v110;
  uint64_t v111;
  void *v112;
  void *v113;
  void **v114;
  void *v115;
  uint64_t v116;
  __int128 *v117;
  GRCPerFrameData *v118;
  uint64_t v119;
  void *v120;
  uint64_t v121;
  void *v122;
  uint64_t v123;
  void *v124;
  _UNKNOWN **v125;
  id v126;
  unsigned int v127;
  unint64_t v128;
  uint64_t v129;
  char *v130;
  unint64_t v131;
  size_t v132;
  unint64_t v133;
  char *v134;
  unsigned int v135;
  char *v136;
  uint64_t v137;
  uint64_t v138;
  unint64_t v139;
  unint64_t v140;
  _QWORD *v141;
  uint64_t v142;
  uint64_t v143;
  char *v144;
  char *v145;
  __int128 v146;
  char *v147;
  uint64_t v148;
  unint64_t *v149;
  unint64_t v150;
  unint64_t v151;
  id v152;
  char **v153;
  char **v154;
  int64_t v155;
  unint64_t v156;
  unint64_t v157;
  char **v158;
  uint64_t v159;
  uint64_t v160;
  char **v161;
  char **v162;
  char **v163;
  char **v164;
  __int128 v165;
  GRCPerFrameData *v166;
  unint64_t v167;
  unint64_t v168;
  unint64_t v169;
  unint64_t v170;
  _QWORD *v171;
  unint64_t v172;
  unint64_t v173;
  unint64_t v174;
  GRCPerFrameData *v175;
  void *v176;
  unsigned __int8 v177;
  unint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  unsigned int *v182;
  unsigned int *m;
  void *v184;
  int v185;
  int n;
  void *v187;
  void *v188;
  char **v189;
  char **v190;
  int64_t v191;
  unint64_t v192;
  unint64_t v193;
  char **v194;
  uint64_t v195;
  uint64_t v196;
  char **v197;
  char **v198;
  char **v199;
  char **v200;
  __int128 v201;
  void *v202;
  void *v203;
  char *v204;
  char *v205;
  unint64_t v206;
  unint64_t v207;
  unint64_t v208;
  _QWORD *v209;
  uint64_t v210;
  uint64_t v211;
  char *v212;
  _QWORD *v213;
  _QWORD *v214;
  char *v215;
  __int128 v216;
  char *v217;
  char *v218;
  uint64_t v219;
  uint64_t v220;
  char *v221;
  uint64_t **v222;
  char *v223;
  char *v224;
  char *v225;
  unint64_t v226;
  unint64_t v227;
  _QWORD *v228;
  uint64_t v229;
  uint64_t v230;
  char *v231;
  char *v232;
  char *v233;
  __int128 v234;
  char *v235;
  unint64_t v236;
  unint64_t v237;
  _QWORD *v238;
  uint64_t v239;
  uint64_t v240;
  char *v241;
  char *v242;
  char *v243;
  __int128 v244;
  char *v245;
  uint64_t v246;
  char *v247;
  uint64_t v248;
  unint64_t v249;
  unint64_t v250;
  uint64_t v251;
  uint64_t v252;
  unint64_t v253;
  unint64_t v254;
  char *v255;
  uint64_t v256;
  char *v257;
  char *v258;
  __int128 v259;
  char *v260;
  unint64_t v261;
  uint64_t v262;
  unint64_t v263;
  unint64_t *v264;
  unint64_t *v265;
  unint64_t v266;
  unint64_t *v267;
  uint64_t v268;
  unint64_t v269;
  unint64_t v270;
  uint64_t v271;
  unint64_t *v272;
  unint64_t v273;
  unsigned int **ii;
  unsigned int *v275;
  unint64_t v276;
  uint8x8_t v277;
  unint64_t v278;
  __int128 **v279;
  __int128 *jj;
  unint64_t v281;
  unint64_t *v282;
  unint64_t v283;
  unint64_t *v284;
  uint64_t v285;
  unint64_t v286;
  unsigned int *v287;
  uint64_t v288;
  unint64_t v289;
  uint64_t v290;
  unint64_t *v291;
  unint64_t v292;
  int v293;
  unsigned int *v294;
  unint64_t v295;
  unint64_t v296;
  uint8x8_t v297;
  unsigned int *v298;
  unint64_t v299;
  uint8x8_t v300;
  __int128 *v301;
  __int128 *v302;
  unint64_t v303;
  _QWORD *v304;
  _QWORD *kk;
  unint64_t v306;
  _QWORD *v307;
  float v308;
  _BOOL8 v309;
  unint64_t v310;
  unint64_t v311;
  size_t v312;
  unint64_t v313;
  __int128 *v314;
  unint64_t v315;
  __int128 *v316;
  unint64_t v317;
  unint64_t v318;
  uint8x8_t v319;
  _QWORD *v320;
  _QWORD *v321;
  unint64_t v322;
  char *v323;
  char *v324;
  __int128 *v325;
  __int128 *v326;
  unint64_t v327;
  char *v328;
  uint64_t v329;
  unint64_t v330;
  uint64_t v331;
  unint64_t v332;
  char *v333;
  uint64_t v334;
  char *v335;
  char *v336;
  unint64_t v337;
  uint64_t v338;
  unint64_t v339;
  unint64_t v340;
  char *v341;
  char *v342;
  unint64_t v343;
  unint64_t v344;
  unint64_t v345;
  _QWORD *v346;
  unint64_t v347;
  void *v348;
  uint64_t v349;
  void *v350;
  void *v351;
  void ***v352;
  void *v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  char *v357;
  _QWORD *v358;
  _QWORD *v359;
  char *v360;
  void ***v361;
  uint64_t v362;
  void **v363;
  char *v364;
  unint64_t v365;
  unint64_t v366;
  double v367;
  uint64_t v368;
  unint64_t v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t v372;
  char *v373;
  unint64_t v374;
  unint64_t v375;
  uint64_t v376;
  double v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  char *v382;
  uint64_t v383;
  double v384;
  double v385;
  double v386;
  void **v387;
  uint64_t v388;
  GRCPerFrameData *v389;
  void *v390;
  GRCPerFrameData *v391;
  void *v392;
  id v393;
  size_t v394;
  size_t v395;
  id obj;
  char *obja;
  unint64_t v398;
  void ***v399;
  void *v400;
  uint64_t v401;
  void *v402;
  id v403;
  char *v404;
  void *v405;
  void *context;
  void *contexta;
  void *v408;
  char *v409;
  void *v410;
  char *v411;
  void *v412;
  void *i;
  void *v414;
  char *v415;
  id v416;
  id v417;
  unsigned int v418;
  void ***v419;
  __int32 v420;
  char *v421;
  char *v422;
  unint64_t v423;
  void ***v424;
  char *v425;
  void *v426;
  id v427;
  unint64_t v428;
  void *v430;
  id v431;
  char *v432;
  _DWORD *v433;
  char *v434;
  __int128 v435;
  __int128 v436;
  __int128 v437;
  __int128 v438;
  char *v439;
  char *v440;
  char *v441;
  unint64_t *v442;
  unint64_t *v443;
  unint64_t v444;
  int64x2_t v445;
  __int128 v446;
  int v447;
  void *v448[2];
  __int128 v449;
  uint64_t v450;
  char *v451[4];
  void *v452;
  char **v453;
  unint64_t v454;
  void *v455;
  char *v456;
  unint64_t v457;
  void *v458;
  unint64_t v459;
  uint64_t v460;
  void *v461;
  char **v462;
  unint64_t v463;
  _BYTE v464[128];
  __int128 v465;
  __int128 v466;
  __int128 v467;
  void *__p[2];
  const __CFString *v469;
  const __CFString *v470;
  const __CFString *v471;
  const __CFString *v472;
  const __CFString *v473;
  const __CFString *v474;
  const __CFString *v475;
  const __CFString *v476;
  void **v477;
  int64x2_t v478;
  void *v479;
  __int128 *v480;
  __int128 v481;
  __int128 *v482;
  GRCPerFrameData *v483;
  void *v484;
  _DWORD *v485;
  unint64_t v486;
  uint64_t v487;
  _DWORD *v488;
  id v489;
  void *v490;
  _QWORD v491[2];

  v435 = 0u;
  v436 = 0u;
  v437 = 0u;
  v438 = 0u;
  obj = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(**((id **)this + 61), "allKeys"));
  v2 = this;
  v403 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v435, v464, 16);
  if (v403)
  {
    v411 = (char *)this + 448;
    v401 = *(_QWORD *)v436;
    do
    {
      for (i = 0; i != v403; i = (char *)i + 1)
      {
        if (*(_QWORD *)v436 != v401)
          objc_enumerationMutation(obj);
        v3 = *(void **)(*((_QWORD *)&v435 + 1) + 8 * (_QWORD)i);
        v426 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(**((id **)v2 + 61), "objectForKeyedSubscript:", v3));
        v4 = objc_msgSend(v3, "unsignedIntValue");
        v408 = v3;
        LODWORD(v461) = v4;
        v427 = v426;
        context = objc_autoreleasePoolPush();
        v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v427, "allKeys"));
        v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", objc_msgSend(v5, "count")));
        v445 = 0uLL;
        *(_QWORD *)&v446 = 0;
        v430 = v6;
        v7 = (unint64_t)objc_msgSend(v6, "count");
        v8 = v445.i64[0];
        if (v7 > (uint64_t)(v446 - v445.i64[0]) >> 3)
        {
          if (v7 >> 61)
            abort();
          v9 = v445.i64[1];
          v480 = &v446;
          v10 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v7);
          v12 = (_QWORD *)v445.i64[1];
          v13 = (_QWORD *)v445.i64[0];
          if (v445.i64[1] == v445.i64[0])
          {
            v16 = vdupq_n_s64(v445.u64[1]);
            v14 = &v10[(v9 - v8) & 0xFFFFFFFFFFFFFFF8];
          }
          else
          {
            v14 = &v10[(v9 - v8) & 0xFFFFFFFFFFFFFFF8];
            do
            {
              v15 = *--v12;
              *v12 = 0;
              *((_QWORD *)v14 - 1) = v15;
              v14 -= 8;
            }
            while (v12 != v13);
            v16 = v445;
          }
          v445.i64[0] = (uint64_t)v14;
          v445.i64[1] = (uint64_t)&v10[(v9 - v8) & 0xFFFFFFFFFFFFFFF8];
          v478 = v16;
          v17 = (void *)v446;
          *(_QWORD *)&v446 = &v10[8 * v11];
          v479 = v17;
          v477 = (void **)v16.i64[0];
          std::__split_buffer<std::unique_ptr<GRCPerFrameData::PriorityQueueElement>>::~__split_buffer((uint64_t)&v477);
        }
        v467 = 0u;
        *(_OWORD *)__p = 0u;
        v465 = 0u;
        v466 = 0u;
        v18 = v5;
        if (objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v465, &v477, 16))
        {
          v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v427, "objectForKeyedSubscript:", **((_QWORD **)&v465 + 1)));
          objc_msgSend(v430, "addObject:", v19);

          operator new();
        }

        v415 = (char *)std::__hash_table<std::__hash_value_type<unsigned int,RingBufferSampledData>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RingBufferSampledData>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v411, v4, &v461);
        v20 = *((_QWORD *)this + 61);
        v21 = (uint64_t *)(v20 + 8);
        v22 = *(_QWORD *)(v20 + 16);
        if (v22)
        {
          v23 = (uint8x8_t)vcnt_s8((int8x8_t)v22);
          v23.i16[0] = vaddlv_u8(v23);
          if (v23.u32[0] > 1uLL)
          {
            v1 = v4;
            if (v22 <= v4)
              v1 = v4 % v22;
          }
          else
          {
            v1 = ((_DWORD)v22 - 1) & v4;
          }
          v24 = *(void ***)(*v21 + 8 * v1);
          if (v24)
          {
            v25 = *v24;
            if (*v24)
            {
              do
              {
                v26 = v25[1];
                if (v26 == v4)
                {
                  if (*((_DWORD *)v25 + 4) == v4)
                    goto LABEL_54;
                }
                else
                {
                  if (v23.u32[0] > 1uLL)
                  {
                    if (v26 >= v22)
                      v26 %= v22;
                  }
                  else
                  {
                    v26 &= v22 - 1;
                  }
                  if (v26 != v1)
                    break;
                }
                v25 = (_QWORD *)*v25;
              }
              while (v25);
            }
          }
        }
        v25 = operator new(0x20uLL);
        *v25 = 0;
        v25[1] = v4;
        *((_DWORD *)v25 + 4) = v4;
        v25[3] = 0;
        v27 = (float)(unint64_t)(*(_QWORD *)(v20 + 32) + 1);
        v28 = *(float *)(v20 + 40);
        if (!v22 || (float)(v28 * (float)v22) < v27)
        {
          v29 = (v22 & (v22 - 1)) != 0;
          if (v22 < 3)
            v29 = 1;
          v30 = v29 | (2 * v22);
          v31 = vcvtps_u32_f32(v27 / v28);
          if (v30 <= v31)
            v32 = v31;
          else
            v32 = v30;
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(v20 + 8, v32);
          v22 = *(_QWORD *)(v20 + 16);
          if ((v22 & (v22 - 1)) != 0)
          {
            if (v22 <= v4)
              v1 = v4 % v22;
            else
              v1 = v4;
          }
          else
          {
            v1 = ((_DWORD)v22 - 1) & v4;
          }
        }
        v33 = *v21;
        v34 = *(_QWORD **)(*v21 + 8 * v1);
        if (v34)
        {
          *v25 = *v34;
LABEL_52:
          *v34 = v25;
          goto LABEL_53;
        }
        *v25 = *(_QWORD *)(v20 + 24);
        *(_QWORD *)(v20 + 24) = v25;
        *(_QWORD *)(v33 + 8 * v1) = v20 + 24;
        if (*v25)
        {
          v35 = *(_QWORD *)(*v25 + 8);
          if ((v22 & (v22 - 1)) != 0)
          {
            if (v35 >= v22)
              v35 %= v22;
          }
          else
          {
            v35 &= v22 - 1;
          }
          v34 = (_QWORD *)(*v21 + 8 * v35);
          goto LABEL_52;
        }
LABEL_53:
        ++*(_QWORD *)(v20 + 32);
LABEL_54:
        v36 = v25[3];
        v37 = objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](NSMutableData, "dataWithLength:", v36));
        v38 = (void *)*((_QWORD *)v415 + 9);
        *((_QWORD *)v415 + 9) = v37;

        std::vector<unsigned int>::reserve((std::vector<unsigned int> *)(v415 + 112), v36 >> 6);
        v36 >>= 4;
        std::vector<unsigned int>::reserve((std::vector<unsigned int> *)(v415 + 32), v36);
        v39 = objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](NSMutableData, "dataWithCapacity:", v36));
        v40 = (void *)*((_QWORD *)v415 + 7);
        *((_QWORD *)v415 + 7) = v39;

        v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)this + 61) + 280), "objectForKeyedSubscript:", CFSTR("limiter sample counters")));
        *((_DWORD *)v415 + 6) = *((_DWORD *)v415 + 6) & 0x3FFFFFF | (objc_msgSend(v41, "count") << 26);

        v42 = objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](NSMutableData, "dataWithCapacity:", 1572864));
        v43 = (void *)*((_QWORD *)v415 + 11);
        *((_QWORD *)v415 + 11) = v42;

        v44 = objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](NSMutableData, "dataWithCapacity:", 1572864));
        v45 = (void *)*((_QWORD *)v415 + 12);
        *((_QWORD *)v415 + 12) = v44;

        if (*((_QWORD *)this + 38) != *((_QWORD *)this + 39))
          GRCPerFrameData::AddDeferredKickSamples((ProgramAddressHelper *)this, v461, (_QWORD *)this + 45);
        if (*((_QWORD *)this + 21))
        {
          v46 = (_QWORD *)*((_QWORD *)this + 20);
          if (v46)
          {
            do
            {
              v47 = (_QWORD *)*v46;
              operator delete(v46);
              v46 = v47;
            }
            while (v47);
          }
          *((_QWORD *)this + 20) = 0;
          v48 = *((_QWORD *)this + 19);
          if (v48)
          {
            for (j = 0; j != v48; ++j)
              *(_QWORD *)(*((_QWORD *)this + 18) + 8 * j) = 0;
          }
          *((_QWORD *)this + 21) = 0;
        }
        objc_msgSend(*((id *)v415 + 9), "setLength:", 8 * *((unsigned int *)v415 + 21));
        v448[0] = &v445;
        std::vector<std::unique_ptr<GRCPerFrameData::PriorityQueueElement>>::__destroy_vector::operator()[abi:nn180100]((void ***)v448);

        objc_autoreleasePoolPop(context);
        v445.i32[0] = objc_msgSend(v408, "unsignedIntValue");
        v50 = std::__hash_table<std::__hash_value_type<unsigned int,RingBufferSampledData>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RingBufferSampledData>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v411, v445.u32[0], &v445);
        v448[0] = 0;
        v448[1] = 0;
        *(_QWORD *)&v449 = 0;
        v51 = (unint64_t)objc_msgSend(*((id *)this + 62), "maxConcurrentOperationCount");
        std::vector<unsigned long long>::reserve(v448, v51 + 1);
        v433 = (_DWORD *)(v50 + 24);
        v53 = (unint64_t *)v448[1];
        v54 = v449;
        if (v51)
        {
          v55 = 0;
          v56 = (unint64_t *)v448[0];
          do
          {
            v57 = (unint64_t)v55 * (*v433 & 0x3FFFFFF) / v51 * ((unint64_t)*v433 >> 26);
            if ((unint64_t)v53 >= v54)
            {
              v58 = v53 - v56;
              v59 = v58 + 1;
              if ((unint64_t)(v58 + 1) >> 61)
              {
                v448[0] = v56;
                abort();
              }
              if ((uint64_t)(v54 - (_QWORD)v56) >> 2 > v59)
                v59 = (uint64_t)(v54 - (_QWORD)v56) >> 2;
              if (v54 - (unint64_t)v56 >= 0x7FFFFFFFFFFFFFF8)
                v60 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v60 = v59;
              if (v60)
                v60 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v60);
              else
                v52 = 0;
              v61 = (unint64_t *)(v60 + 8 * v58);
              *v61 = v57;
              v1 = (uint64_t)(v61 + 1);
              while (v53 != v56)
              {
                v62 = *--v53;
                *--v61 = v62;
              }
              v54 = v60 + 8 * v52;
              v448[1] = (void *)v1;
              if (v56)
                operator delete(v56);
              v56 = v61;
              v53 = (unint64_t *)v1;
            }
            else
            {
              *v53++ = v57;
            }
            v448[1] = v53;
            v55 = (char *)v55 + 1;
          }
          while (v55 != (void *)v51);
          *(_QWORD *)&v449 = v54;
          v448[0] = v56;
        }
        v63 = ((*(_QWORD *)(v50 + 40) - *(_QWORD *)(v50 + 32)) >> 2);
        if ((unint64_t)v53 >= v54)
        {
          v64 = (unint64_t *)v448[0];
          v65 = ((char *)v53 - (char *)v448[0]) >> 3;
          v66 = v65 + 1;
          if ((unint64_t)(v65 + 1) >> 61)
            abort();
          if ((uint64_t)(v54 - (unint64_t)v448[0]) >> 2 > v66)
            v66 = (uint64_t)(v54 - (unint64_t)v448[0]) >> 2;
          if (v54 - (unint64_t)v448[0] >= 0x7FFFFFFFFFFFFFF8)
            v67 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v67 = v66;
          if (v67)
            v67 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v67);
          else
            v52 = 0;
          v68 = (unint64_t *)(v67 + 8 * v65);
          *v68 = v63;
          v69 = v68 + 1;
          while (v53 != v64)
          {
            v70 = *--v53;
            *--v68 = v70;
          }
          v448[0] = v68;
          v448[1] = v69;
          *(_QWORD *)&v449 = v67 + 8 * v52;
          if (v64)
            operator delete(v64);
        }
        else
        {
          *v53 = v63;
        }
        v71 = (unsigned int *)(v50 + 24);
        v72 = (void *)objc_opt_new(NSOperation, v52);
        v73 = objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](NSMutableData, "dataWithLength:", 8 * (*v433 & 0x3FFFFFFu) * *((_DWORD *)this + 130)));
        v74 = *(void **)(v50 + 104);
        *(_QWORD *)(v50 + 104) = v73;

        v431 = objc_msgSend(*(id *)(v50 + 104), "mutableBytes");
        v75 = objc_msgSend(*(id *)(v50 + 56), "mutableBytes");
        v76 = (unint64_t)objc_msgSend(*(id *)(v50 + 56), "length");
        v77 = v76;
        *(_QWORD *)&v465 = 0;
        *((_QWORD *)&v465 + 1) = &v465;
        *(_QWORD *)&v466 = 0x4812000000;
        *((_QWORD *)&v466 + 1) = __Block_byref_object_copy__357;
        *(_QWORD *)&v467 = __Block_byref_object_dispose__358;
        *((_QWORD *)&v467 + 1) = &unk_4C2897;
        __p[1] = 0;
        v469 = 0;
        __p[0] = 0;
        if (v76 >= 8)
        {
          v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v76 >> 3);
          __p[0] = v78;
          v469 = (const __CFString *)&v78[8 * v79];
          v80 = v77 & 0xFFFFFFFFFFFFFFF8;
          bzero(v78, v80);
          __p[1] = &v78[v80];
        }
        if ((*v433 & 0x3FFFFFE) != 0)
        {
          v81 = 0;
          do
          {
            *(_QWORD *)(*(_QWORD *)(*((_QWORD *)&v465 + 1) + 48) + 8 * v81 + 8) = v75[v81 + 1] - v75[v81];
            v82 = v81 + 2;
            ++v81;
          }
          while (v82 < (*v433 & 0x3FFFFFFu));
        }
        v83 = *(_QWORD **)(*((_QWORD *)&v465 + 1) + 48);
        if (*(_QWORD *)(*((_QWORD *)&v465 + 1) + 56) - (_QWORD)v83 > 8uLL)
          *v83 = v83[1];
        if (v51)
        {
          v84 = 0;
          v422 = (char *)v448[0];
          v420 = v445.i32[0];
          do
          {
            v85 = v72;
            v86 = (void **)&v422[8 * v84];
            v87 = *v86;
            v88 = v86[1];
            v89 = *v71;
            v90 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)this + 61) + 280), "objectForKeyedSubscript:", CFSTR("DerivedCounterScript")));
            v91 = *(id *)(*((_QWORD *)this + 61) + 288);
            v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)this + 61) + 280), "objectForKeyedSubscript:", CFSTR("DerivedCounterConfigurationVariables")));
            v477 = _NSConcreteStackBlock;
            v478.i64[0] = 3221225472;
            v478.i64[1] = (uint64_t)___ZN15GRCPerFrameData23EvaluateDerivedLimitersEj_block_invoke;
            v479 = &unk_726C38;
            v483 = this;
            v93 = v90;
            v480 = v93;
            v94 = v91;
            *(_QWORD *)&v481 = v94;
            v95 = v92;
            *((_QWORD *)&v481 + 1) = v95;
            v482 = &v465;
            v484 = v87;
            v485 = v433;
            v486 = (v88 - (_BYTE *)v87) / (v89 >> 26);
            v487 = v84;
            LODWORD(v490) = v420;
            v488 = v433;
            v489 = v431;
            v1 = objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", &v477));
            v72 = v85;
            objc_msgSend(*((id *)this + 62), "addOperation:", v1);
            objc_msgSend(v85, "addDependency:", v1);

            v71 = v433;
            ++v84;
          }
          while (v51 != v84);
        }
        objc_msgSend(*((id *)this + 62), "addOperation:", v72);
        objc_msgSend(v72, "waitUntilFinished");
        _Block_object_dispose(&v465, 8);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }

        if (v448[0])
          operator delete(v448[0]);
        v96 = objc_autoreleasePoolPush();
        v97 = objc_msgSend(v408, "unsignedIntValue");
        LODWORD(v448[0]) = (_DWORD)v97;
        v98 = std::__hash_table<std::__hash_value_type<unsigned int,RingBufferSampledData>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RingBufferSampledData>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v411, v97, v448);
        v99 = v98;
        if ((*(_DWORD *)(v98 + 24) & 0x3FFFFFF) != 0 && *(_DWORD *)(v98 + 80))
        {
          v100 = std::thread::hardware_concurrency();
          v101 = v100 >> 1;
          v102 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", v101));
          if (v100 >= 2)
          {
            v103 = 0;
            if (v101 <= 1)
              v104 = 1;
            else
              v104 = v100 >> 1;
            do
            {
              v105 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(*(_QWORD *)(v99 + 112)+ 4 * (v103 * (unint64_t)*(unsigned int *)(v99 + 80) / v101))));
              objc_msgSend(v102, "addObject:", v105);

              ++v103;
            }
            while (v104 != v103);
          }
          v106 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v99 + 84)));
          objc_msgSend(v102, "addObject:", v106);

          v107 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", *(_QWORD *)(*((_QWORD *)this + 61) + 152)));
          for (k = *(_QWORD **)(*((_QWORD *)this + 61) + 144); k; k = (_QWORD *)*k)
          {
            v109 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", (uint64_t)(k[4] - k[3]) >> 4));
            v110 = k[3];
            v111 = k[4];
            while (v110 != v111)
            {
              v112 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v110 + 8)));
              objc_msgSend(v109, "addObject:", v112);

              v110 += 16;
            }
            if ((unint64_t)objc_msgSend(v109, "count") >= 2)
            {
              v113 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v109, "firstObject"));
              objc_msgSend(v107, "setObject:forKeyedSubscript:", v109, v113);

            }
          }
          *(_QWORD *)&v465 = CFSTR("ring buffer");
          v114 = (void **)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v97));
          v477 = v114;
          *((_QWORD *)&v465 + 1) = CFSTR("frame index");
          v115 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(*((_QWORD *)this + 61) + 360)));
          v116 = *(_QWORD *)(v99 + 104);
          v478.i64[0] = (uint64_t)v115;
          v478.i64[1] = v116;
          *(_QWORD *)&v466 = CFSTR("limiter data");
          *((_QWORD *)&v466 + 1) = CFSTR("limiter time stamps");
          v117 = *(__int128 **)(*((_QWORD *)this + 61) + 296);
          v479 = *(void **)(v99 + 56);
          v480 = v117;
          *(_QWORD *)&v467 = CFSTR("limiter counter list");
          *((_QWORD *)&v467 + 1) = CFSTR("shader timeline data");
          v481 = *(_OWORD *)(v99 + 88);
          __p[0] = CFSTR("shader timeline data ex");
          __p[1] = CFSTR("usc sampling sample data");
          v482 = *(__int128 **)(v99 + 72);
          v469 = CFSTR("usc sample count");
          v118 = (GRCPerFrameData *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v99 + 80)));
          v483 = v118;
          v484 = v102;
          v470 = CFSTR("usc sample data thread offsets");
          v471 = CFSTR("usc sampling address data");
          v119 = *((_QWORD *)this + 61);
          v120 = *(void **)(v119 + 312);
          if (!v120)
            v120 = &__NSArray0__struct;
          v485 = *(_DWORD **)(v119 + 304);
          v486 = (unint64_t)v120;
          v472 = CFSTR("usc sampling address mappings");
          v473 = CFSTR("DerivedCounterConfigurationVariables");
          v121 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v119 + 280), "objectForKeyedSubscript:"));
          v122 = (void *)v121;
          v123 = *((_QWORD *)this + 61);
          v125 = *(_UNKNOWN ***)(v123 + 320);
          v124 = *(void **)(v123 + 328);
          if (!v125)
            v125 = &off_739568;
          v487 = v121;
          v488 = v125;
          v474 = CFSTR("Frame Consistent Perf Info");
          v475 = CFSTR("coalesced encoder mapping");
          v476 = CFSTR("Restore Timestamps");
          if (!v124)
            v124 = &__NSArray0__struct;
          v489 = v107;
          v490 = v124;
          v1 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v477, &v465, 16));

          v126 = (id)(*(uint64_t (**)(void))(*((_QWORD *)this + 63) + 16))();
        }
        objc_autoreleasePoolPop(v96);

        v2 = this;
      }
      v403 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v435, v464, 16);
    }
    while (v403);
  }

  if (*((_DWORD *)this + 134) != 2)
    return;
  v127 = objc_msgSend(**((id **)this + 61), "count");
  v418 = v127;
  v128 = v127;
  v428 = v127;
  if (v127)
  {
    v425 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v127);
    v130 = &v425[24 * v129];
    v128 = v428;
  }
  else
  {
    v130 = 0;
    v425 = 0;
  }
  v461 = 0;
  v462 = 0;
  v463 = 0;
  v131 = v128;
  std::vector<BufferView2D<double>>::reserve(&v461, v128);
  v132 = 8 * v131;
  if (v131)
  {
    v133 = v131;
    v134 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v131);
    bzero(v134, v132);
    v434 = v134;
    v404 = &v134[8 * v133];
  }
  else
  {
    v404 = 0;
    v434 = 0;
  }
  v394 = v132;
  LODWORD(v477) = 0;
  if (v418)
  {
    v135 = 0;
    v416 = 0;
    v423 = -1;
    v136 = v425;
    do
    {
      v137 = std::__hash_table<std::__hash_value_type<unsigned int,RingBufferSampledData>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RingBufferSampledData>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)this + 448, v135, &v477);
      v138 = v137;
      if (v136 >= v130)
      {
        v139 = 0xAAAAAAAAAAAAAAABLL * ((v136 - v425) >> 3) + 1;
        if (v139 > 0xAAAAAAAAAAAAAAALL)
          abort();
        if (0x5555555555555556 * ((v130 - v425) >> 3) > v139)
          v139 = 0x5555555555555556 * ((v130 - v425) >> 3);
        if (0xAAAAAAAAAAAAAAABLL * ((v130 - v425) >> 3) >= 0x555555555555555)
          v140 = 0xAAAAAAAAAAAAAAALL;
        else
          v140 = v139;
        if (v140)
        {
          v141 = std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v140);
          v143 = v142;
        }
        else
        {
          v141 = 0;
          v143 = 0;
        }
        v144 = (char *)BufferView<unsigned long long>::BufferView(&v141[(v136 - v425) >> 3], *(void **)(v138 + 56));
        if (v136 == v425)
        {
          v147 = v136;
          v425 = v144;
        }
        else
        {
          v145 = v144;
          do
          {
            v146 = *(_OWORD *)(v136 - 24);
            *((_QWORD *)v145 - 1) = *((_QWORD *)v136 - 1);
            *(_OWORD *)(v145 - 24) = v146;
            v145 -= 24;
            v136 -= 24;
          }
          while (v136 != v425);
          v147 = v425;
          v425 = v145;
        }
        v130 = (char *)&v141[3 * v143];
        v136 = v144 + 24;
        if (v147)
          operator delete(v147);
      }
      else
      {
        BufferView<unsigned long long>::BufferView(v136, *(void **)(v137 + 56));
        v136 += 24;
      }
      v148 = *((_QWORD *)v136 - 1);
      if (v148)
      {
        v149 = (unint64_t *)*((_QWORD *)v136 - 3);
        v150 = v423;
        if (v423 >= *v149)
          v150 = *v149;
        v423 = v150;
        v151 = v149[v148 - 1];
        v152 = v416;
        if (v151 > (unint64_t)v416)
          v152 = (id)v151;
        v416 = v152;
      }
      v153 = v462;
      if ((unint64_t)v462 >= v463)
      {
        v155 = ((char *)v462 - (_BYTE *)v461) >> 5;
        if ((unint64_t)(v155 + 1) >> 59)
          abort();
        v156 = (uint64_t)(v463 - (_QWORD)v461) >> 4;
        if (v156 <= v155 + 1)
          v156 = v155 + 1;
        if (v463 - (unint64_t)v461 >= 0x7FFFFFFFFFFFFFE0)
          v157 = 0x7FFFFFFFFFFFFFFLL;
        else
          v157 = v156;
        if (v157)
        {
          v158 = (char **)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>>(v157);
          v160 = v159;
        }
        else
        {
          v158 = 0;
          v160 = 0;
        }
        v161 = BufferView2D<double>::BufferView2D(&v158[4 * v155], *(void **)(v138 + 104), (char *)*((unsigned int *)this + 130));
        v163 = (char **)v461;
        v162 = v462;
        v164 = v161;
        if (v462 != v461)
        {
          do
          {
            v165 = *((_OWORD *)v162 - 1);
            *((_OWORD *)v164 - 2) = *((_OWORD *)v162 - 2);
            *((_OWORD *)v164 - 1) = v165;
            v164 -= 4;
            v162 -= 4;
          }
          while (v162 != v163);
          v162 = v163;
        }
        v154 = v161 + 4;
        v461 = v164;
        v463 = (unint64_t)&v158[4 * v160];
        if (v162)
          operator delete(v162);
      }
      else
      {
        BufferView2D<double>::BufferView2D(v462, *(void **)(v138 + 104), (char *)*((unsigned int *)this + 130));
        v154 = v153 + 4;
      }
      v462 = v154;
      v135 = (_DWORD)v477 + 1;
      LODWORD(v477) = v135;
    }
    while (v135 < v418);
  }
  else
  {
    v416 = 0;
    v423 = -1;
  }
  v166 = this;
  v167 = *((unsigned int *)this + 130);
  v459 = 0;
  v460 = 0;
  v458 = 0;
  if ((_DWORD)v167)
  {
    std::vector<BOOL>::__vallocate[abi:nn180100](&v458, v167);
    v168 = v459;
    v169 = v459 + v167;
    v459 += v167;
    if (v168)
    {
      v170 = v169 - 1;
      if (((v169 - 1) ^ (v168 - 1)) <= 0x3F)
      {
        v171 = v458;
        goto LABEL_199;
      }
    }
    else
    {
      v170 = v169 - 1;
    }
    v171 = v458;
    v172 = v170 >> 6;
    if (v169 >= 0x41)
      v173 = v172;
    else
      v173 = 0;
    *((_QWORD *)v458 + v173) = 0;
LABEL_199:
    v477 = (void **)&v171[v168 >> 6];
    v478.i32[0] = v168 & 0x3F;
    std::__fill_n[abi:nn180100]<false,std::vector<BOOL>>((uint64_t)&v477, v167);
    if (*((_DWORD *)this + 130))
    {
      v174 = 0;
      v175 = this;
      do
      {
        v176 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)v175 + 61) + 296), "objectAtIndexedSubscript:", v174, v394));
        v177 = objc_msgSend(v176, "containsString:", CFSTR("Bandwidth"));
        v178 = v174 >> 6;
        v179 = 1 << v174;
        if ((v177 & 1) != 0)
          v180 = v171[v178] & ~v179;
        else
          v180 = v171[v178] | v179;
        v171[v178] = v180;

        ++v174;
        v175 = this;
      }
      while (v174 < *((unsigned int *)this + 130));
      v166 = this;
    }
  }
  contexta = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", (uint64_t)(*(_QWORD *)(*((_QWORD *)v166 + 61) + 264)- *(_QWORD *)(*((_QWORD *)v166 + 61) + 256)) >> 2, v394));
  v181 = *((_QWORD *)v166 + 61);
  v182 = *(unsigned int **)(v181 + 256);
  for (m = *(unsigned int **)(v181 + 264); v182 != m; ++v182)
  {
    v184 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *v182));
    objc_msgSend(contexta, "addObject:", v184);

  }
  v412 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", v428));
  v455 = 0;
  v456 = 0;
  v457 = 0;
  std::vector<DYMTLShaderProfilerProgramAddress>::reserve(&v455, v428);
  v414 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", v428));
  v452 = 0;
  v453 = 0;
  v454 = 0;
  std::vector<BufferView2D<double>>::reserve(&v452, v428);
  v398 = ((unint64_t)v416 - v423) / 0x3C;
  v185 = v398 + 1;
  if (v418)
  {
    for (n = 0; n != v418; ++n)
    {
      v187 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](NSMutableData, "dataWithLength:", 8 * (*((_DWORD *)this + 130) * v185)));
      objc_msgSend(v414, "addObject:", v187);

      v188 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v414, "lastObject"));
      v189 = v453;
      if ((unint64_t)v453 >= v454)
      {
        v191 = ((char *)v453 - (_BYTE *)v452) >> 5;
        if ((unint64_t)(v191 + 1) >> 59)
          abort();
        v192 = (uint64_t)(v454 - (_QWORD)v452) >> 4;
        if (v192 <= v191 + 1)
          v192 = v191 + 1;
        if (v454 - (unint64_t)v452 >= 0x7FFFFFFFFFFFFFE0)
          v193 = 0x7FFFFFFFFFFFFFFLL;
        else
          v193 = v192;
        if (v193)
        {
          v194 = (char **)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>>(v193);
          v196 = v195;
        }
        else
        {
          v194 = 0;
          v196 = 0;
        }
        v197 = BufferView2D<double>::BufferView2D(&v194[4 * v191], v188, (char *)*((unsigned int *)this + 130));
        v199 = (char **)v452;
        v198 = v453;
        v200 = v197;
        if (v453 != v452)
        {
          do
          {
            v201 = *((_OWORD *)v198 - 1);
            *((_OWORD *)v200 - 2) = *((_OWORD *)v198 - 2);
            *((_OWORD *)v200 - 1) = v201;
            v200 -= 4;
            v198 -= 4;
          }
          while (v198 != v199);
          v198 = v199;
        }
        v190 = v197 + 4;
        v452 = v200;
        v454 = (unint64_t)&v194[4 * v196];
        if (v198)
          operator delete(v198);
      }
      else
      {
        BufferView2D<double>::BufferView2D(v453, v188, (char *)*((unsigned int *)this + 130));
        v190 = v189 + 4;
      }
      v453 = v190;

      v202 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](NSMutableData, "dataWithLength:", 8 * (v398 + 1)));
      objc_msgSend(v412, "addObject:", v202);

      v203 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v412, "lastObject"));
      v204 = v456;
      if ((unint64_t)v456 >= v457)
      {
        v206 = 0xAAAAAAAAAAAAAAABLL * ((v456 - (_BYTE *)v455) >> 3);
        v207 = v206 + 1;
        if (v206 + 1 > 0xAAAAAAAAAAAAAAALL)
          abort();
        if (0x5555555555555556 * ((uint64_t)(v457 - (_QWORD)v455) >> 3) > v207)
          v207 = 0x5555555555555556 * ((uint64_t)(v457 - (_QWORD)v455) >> 3);
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v457 - (_QWORD)v455) >> 3) >= 0x555555555555555)
          v208 = 0xAAAAAAAAAAAAAAALL;
        else
          v208 = v207;
        if (v208)
        {
          v209 = std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v208);
          v211 = v210;
        }
        else
        {
          v209 = 0;
          v211 = 0;
        }
        v212 = (char *)BufferView<double>::BufferView(&v209[3 * v206], v203);
        v214 = v455;
        v213 = v456;
        v215 = v212;
        if (v456 != v455)
        {
          do
          {
            v216 = *(_OWORD *)(v213 - 3);
            *((_QWORD *)v215 - 1) = *(v213 - 1);
            *(_OWORD *)(v215 - 24) = v216;
            v215 -= 24;
            v213 -= 3;
          }
          while (v213 != v214);
          v213 = v455;
        }
        v205 = v212 + 24;
        v455 = v215;
        v457 = (unint64_t)&v209[3 * v211];
        if (v213)
          operator delete(v213);
      }
      else
      {
        BufferView<double>::BufferView(v456, v203);
        v205 = v204 + 24;
      }
      v456 = v205;

    }
  }
  v400 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](NSMutableData, "dataWithLength:", 8 * (*((_DWORD *)this + 130) * v185)));
  BufferView2D<double>::BufferView2D(v451, v400, (char *)*((unsigned int *)this + 130));
  v405 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](NSMutableData, "dataWithCapacity:", 8 * (v398 + 1)));
  v217 = (char *)*((_QWORD *)this + 59);
  if (!v217)
  {
    v409 = 0;
    v218 = 0;
LABEL_249:
    v221 = 0;
    goto LABEL_250;
  }
  if ((unint64_t)v217 > 0xAAAAAAAAAAAAAAALL)
    abort();
  v218 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>((unint64_t)v217);
  v409 = &v218[24 * v219];
  v217 = (char *)*((_QWORD *)this + 59);
  if (!v217)
    goto LABEL_249;
  if ((unint64_t)v217 > 0xAAAAAAAAAAAAAAALL)
    abort();
  v217 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>((unint64_t)v217);
  v221 = &v217[24 * v220];
LABEL_250:
  v421 = v217;
  v432 = v218;
  v222 = (uint64_t **)*((_QWORD *)this + 58);
  if (v222)
  {
    v223 = 0;
    v224 = v218;
    v225 = v217;
    do
    {
      if (v224 >= v409)
      {
        v226 = 0xAAAAAAAAAAAAAAABLL * ((v224 - v432) >> 3) + 1;
        if (v226 > 0xAAAAAAAAAAAAAAALL)
          abort();
        if (0x5555555555555556 * ((v409 - v432) >> 3) > v226)
          v226 = 0x5555555555555556 * ((v409 - v432) >> 3);
        if (0xAAAAAAAAAAAAAAABLL * ((v409 - v432) >> 3) >= 0x555555555555555)
          v227 = 0xAAAAAAAAAAAAAAALL;
        else
          v227 = v226;
        if (v227)
        {
          v228 = std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v227);
          v230 = v229;
        }
        else
        {
          v228 = 0;
          v230 = 0;
        }
        v231 = (char *)BufferView<ShaderProfilerSampleTimelineInfo>::BufferView(&v228[(v224 - v432) >> 3], v222[11]);
        if (v224 == v432)
        {
          v235 = v231;
          v233 = v432;
        }
        else
        {
          v232 = v231;
          v233 = v432;
          do
          {
            v234 = *(_OWORD *)(v224 - 24);
            v235 = v232 - 24;
            *((_QWORD *)v232 - 1) = *((_QWORD *)v224 - 1);
            *(_OWORD *)(v232 - 24) = v234;
            v224 -= 24;
            v232 -= 24;
          }
          while (v224 != v432);
        }
        v409 = (char *)&v228[3 * v230];
        v224 = v231 + 24;
        if (v233)
          operator delete(v233);
        v432 = v235;
      }
      else
      {
        BufferView<ShaderProfilerSampleTimelineInfo>::BufferView(v224, v222[11]);
        v224 += 24;
      }
      if (v225 >= v221)
      {
        v236 = 0xAAAAAAAAAAAAAAABLL * ((v225 - v421) >> 3) + 1;
        if (v236 > 0xAAAAAAAAAAAAAAALL)
          abort();
        if (0x5555555555555556 * ((v221 - v421) >> 3) > v236)
          v236 = 0x5555555555555556 * ((v221 - v421) >> 3);
        if (0xAAAAAAAAAAAAAAABLL * ((v221 - v421) >> 3) >= 0x555555555555555)
          v237 = 0xAAAAAAAAAAAAAAALL;
        else
          v237 = v236;
        if (v237)
        {
          v238 = std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v237);
          v240 = v239;
        }
        else
        {
          v238 = 0;
          v240 = 0;
        }
        v241 = (char *)BufferView<ShaderProfilerSampleTimelineInfoEx>::BufferView(&v238[(v225 - v421) >> 3], v222[12]);
        if (v225 == v421)
        {
          v245 = v241;
          v243 = v421;
        }
        else
        {
          v242 = v241;
          v243 = v421;
          do
          {
            v244 = *(_OWORD *)(v225 - 24);
            v245 = v242 - 24;
            *((_QWORD *)v242 - 1) = *((_QWORD *)v225 - 1);
            *(_OWORD *)(v242 - 24) = v244;
            v225 -= 24;
            v242 -= 24;
          }
          while (v225 != v421);
        }
        v221 = (char *)&v238[3 * v240];
        v225 = v241 + 24;
        if (v243)
          operator delete(v243);
        v421 = v245;
      }
      else
      {
        BufferView<ShaderProfilerSampleTimelineInfoEx>::BufferView(v225, v222[12]);
        v225 += 24;
      }
      v223 += *((_QWORD *)v224 - 1);
      v222 = (uint64_t **)*v222;
    }
    while (v222);
    if (v223)
    {
      if ((unint64_t)v223 > 0xAAAAAAAAAAAAAAALL)
        abort();
      v223 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>((unint64_t)v223);
      v247 = &v223[24 * v246];
      goto LABEL_296;
    }
  }
  else
  {
    v223 = 0;
  }
  v247 = 0;
LABEL_296:
  if (v418)
  {
    v248 = 0;
    v249 = (unint64_t)v223;
    do
    {
      if (*(_QWORD *)&v432[24 * v248 + 16])
      {
        v250 = 0;
        do
        {
          v251 = *(_QWORD *)&v432[24 * v248] + 24 * v250;
          v252 = *(_QWORD *)&v421[24 * v248] + 24 * v250;
          if (v249 >= (unint64_t)v247)
          {
            v253 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v249 - (_QWORD)v223) >> 3) + 1;
            if (v253 > 0xAAAAAAAAAAAAAAALL)
              abort();
            if (0x5555555555555556 * ((v247 - v223) >> 3) > v253)
              v253 = 0x5555555555555556 * ((v247 - v223) >> 3);
            if (0xAAAAAAAAAAAAAAABLL * ((v247 - v223) >> 3) >= 0x555555555555555)
              v254 = 0xAAAAAAAAAAAAAAALL;
            else
              v254 = v253;
            v255 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v254);
            v257 = &v255[8 * ((uint64_t)(v249 - (_QWORD)v223) >> 3)];
            *(_QWORD *)v257 = v251;
            *((_QWORD *)v257 + 1) = v252;
            *((_DWORD *)v257 + 4) = v248;
            if ((char *)v249 == v223)
            {
              v260 = &v255[8 * ((uint64_t)(v249 - (_QWORD)v223) >> 3)];
            }
            else
            {
              v258 = &v255[8 * ((uint64_t)(v249 - (_QWORD)v223) >> 3)];
              do
              {
                v259 = *(_OWORD *)(v249 - 24);
                v260 = v258 - 24;
                *((_QWORD *)v258 - 1) = *(_QWORD *)(v249 - 8);
                *(_OWORD *)(v258 - 24) = v259;
                v249 -= 24;
                v258 -= 24;
              }
              while ((char *)v249 != v223);
            }
            v247 = &v255[24 * v256];
            v249 = (unint64_t)(v257 + 24);
            if (v223)
              operator delete(v223);
            v223 = v260;
          }
          else
          {
            *(_QWORD *)v249 = v251;
            *(_QWORD *)(v249 + 8) = v252;
            *(_DWORD *)(v249 + 16) = v248;
            v249 += 24;
          }
          ++v250;
        }
        while (v250 < *(_QWORD *)&v432[24 * v248 + 16]);
      }
      ++v248;
    }
    while (v248 != v428);
  }
  else
  {
    v249 = (unint64_t)v223;
  }
  v261 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v249 - (_QWORD)v223) >> 3));
  if ((char *)v249 == v223)
    v262 = 0;
  else
    v262 = v261;
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos *,false>((uint64_t)v223, v249, v262, 1);
  *(_OWORD *)v448 = 0u;
  v449 = 0u;
  LODWORD(v450) = 1065353216;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)v448, 0x20uLL);
  v445 = 0u;
  v446 = 0u;
  v447 = 1065353216;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)&v445, 0x20uLL);
  v402 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](NSMutableData, "dataWithCapacity:", v249 - (_QWORD)v223));
  v410 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](NSMutableData, "dataWithCapacity:", v249 - (_QWORD)v223));
  v442 = 0;
  v443 = 0;
  v444 = 0;
  std::vector<unsigned long long>::reserve((void **)&v442, v398 + 1);
  if ((unint64_t)v416 >= v423)
  {
    v264 = v443;
    v263 = v444;
    v265 = v442;
    do
    {
      if ((unint64_t)v264 >= v263)
      {
        v268 = v264 - v265;
        v269 = v268 + 1;
        if ((unint64_t)(v268 + 1) >> 61)
        {
          v444 = v263;
          v442 = v265;
          abort();
        }
        if ((uint64_t)(v263 - (_QWORD)v265) >> 2 > v269)
          v269 = (uint64_t)(v263 - (_QWORD)v265) >> 2;
        if (v263 - (unint64_t)v265 >= 0x7FFFFFFFFFFFFFF8)
          v270 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v270 = v269;
        if (v270)
          v270 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v270);
        else
          v271 = 0;
        v272 = (unint64_t *)(v270 + 8 * v268);
        *v272 = v423;
        v267 = v272 + 1;
        while (v264 != v265)
        {
          v273 = *--v264;
          *--v272 = v273;
        }
        v263 = v270 + 8 * v271;
        v443 = v267;
        if (v265)
          operator delete(v265);
        v265 = v272;
        v266 = v423;
      }
      else
      {
        v266 = v423;
        *v264 = v423;
        v267 = v264 + 1;
      }
      v443 = v267;
      v264 = v267;
      v423 = v266 + 60;
    }
    while (v266 + 60 <= (unint64_t)v416);
    v444 = v263;
    v442 = v265;
  }
  v439 = 0;
  v440 = 0;
  v441 = 0;
  std::vector<std::pair<unsigned long long,unsigned long long>>::reserve((void **)&v439, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v249 - (_QWORD)v223) >> 3));
  if ((char *)v249 != v223)
  {
    for (ii = (unsigned int **)v223; ii != (unsigned int **)v249; ii += 3)
    {
      v275 = *ii;
      v276 = ((unint64_t)**ii >> 1) & 7 | ((unint64_t)(*ii)[5] << 32);
      if (!v448[1])
        goto LABEL_363;
      v277 = (uint8x8_t)vcnt_s8((int8x8_t)v448[1]);
      v277.i16[0] = vaddlv_u8(v277);
      if (v277.u32[0] > 1uLL)
      {
        v278 = ((unint64_t)**ii >> 1) & 7 | ((unint64_t)(*ii)[5] << 32);
        if ((void *)v276 >= v448[1])
          v278 = v276 % (unint64_t)v448[1];
      }
      else
      {
        v278 = ((unint64_t)v448[1] - 1) & v276;
      }
      v279 = (__int128 **)*((_QWORD *)v448[0] + v278);
      if (v279)
      {
        for (jj = *v279; jj; jj = *(__int128 **)jj)
        {
          v281 = *((_QWORD *)jj + 1);
          if (v281 == v276)
          {
            if (*((_QWORD *)jj + 2) == v276)
              break;
          }
          else
          {
            if (v277.u32[0] > 1uLL)
            {
              if ((void *)v281 >= v448[1])
                v281 %= (unint64_t)v448[1];
            }
            else
            {
              v281 &= (unint64_t)v448[1] - 1;
            }
            if (v281 != v278)
              goto LABEL_363;
          }
        }
      }
      else
      {
LABEL_363:
        jj = 0;
      }
      v282 = v443;
      if ((unint64_t)v443 >= v444)
      {
        v284 = v442;
        v285 = v443 - v442;
        v286 = v285 + 1;
        if ((unint64_t)(v285 + 1) >> 61)
          goto LABEL_585;
        v287 = *ii;
        v288 = v444 - (_QWORD)v442;
        if ((uint64_t)(v444 - (_QWORD)v442) >> 2 > v286)
          v286 = v288 >> 2;
        if ((unint64_t)v288 >= 0x7FFFFFFFFFFFFFF8)
          v289 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v289 = v286;
        if (v289)
          v289 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v289);
        else
          v290 = 0;
        v291 = (unint64_t *)(v289 + 8 * v285);
        *v291 = *(_QWORD *)(v287 + 3);
        v283 = (unint64_t)(v291 + 1);
        while (v282 != v284)
        {
          v292 = *--v282;
          *--v291 = v292;
        }
        v442 = v291;
        v444 = v289 + 8 * v290;
        if (v284)
          operator delete(v284);
        v275 = v287;
      }
      else
      {
        *v443 = *(_QWORD *)(v275 + 3);
        v283 = (unint64_t)(v282 + 1);
      }
      v443 = (unint64_t *)v283;
      if ((*(_BYTE *)v275 & 1) != 0)
      {
        if (jj)
        {
          v293 = *((_DWORD *)jj + 6) - 1;
          *((_DWORD *)jj + 6) = v293;
          if (!v293)
          {
            v294 = v275;
            objc_msgSend(v402, "appendBytes:length:");
            objc_msgSend(v410, "appendBytes:length:", ii[1], 24);
            v295 = (unint64_t)v448[1];
            v296 = *((_QWORD *)jj + 1);
            v297 = (uint8x8_t)vcnt_s8((int8x8_t)v448[1]);
            v297.i16[0] = vaddlv_u8(v297);
            if (v297.u32[0] > 1uLL)
            {
              if ((void *)v296 >= v448[1])
                v296 %= (unint64_t)v448[1];
            }
            else
            {
              v296 &= (unint64_t)v448[1] - 1;
            }
            v301 = (__int128 *)*((_QWORD *)v448[0] + v296);
            do
            {
              v302 = v301;
              v301 = *(__int128 **)v301;
            }
            while (v301 != jj);
            if (v302 == &v449)
              goto LABEL_430;
            v303 = *((_QWORD *)v302 + 1);
            if (v297.u32[0] > 1uLL)
            {
              if ((void *)v303 >= v448[1])
                v303 %= (unint64_t)v448[1];
            }
            else
            {
              v303 &= (unint64_t)v448[1] - 1;
            }
            if (v303 != v296)
            {
LABEL_430:
              if (!*(_QWORD *)jj)
                goto LABEL_431;
              v313 = *(_QWORD *)(*(_QWORD *)jj + 8);
              if (v297.u32[0] > 1uLL)
              {
                if ((void *)v313 >= v448[1])
                  v313 %= (unint64_t)v448[1];
              }
              else
              {
                v313 &= (unint64_t)v448[1] - 1;
              }
              if (v313 != v296)
LABEL_431:
                *((_QWORD *)v448[0] + v296) = 0;
            }
            v314 = *(__int128 **)jj;
            if (*(_QWORD *)jj)
            {
              v315 = *((_QWORD *)v314 + 1);
              if (v297.u32[0] > 1uLL)
              {
                if (v315 >= v295)
                  v315 %= v295;
              }
              else
              {
                v315 &= v295 - 1;
              }
              if (v315 != v296)
              {
                *((_QWORD *)v448[0] + v315) = v302;
                v314 = *(__int128 **)jj;
              }
            }
            *(_QWORD *)v302 = v314;
            --*((_QWORD *)&v449 + 1);
            operator delete(jj);
            if (*(_QWORD *)ii[1] <= 0xFFFFFFFEuLL)
            {
              v316 = (__int128 *)std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(&v445, v276);
              if (v316)
              {
                v317 = v445.u64[1];
                v318 = *((_QWORD *)v316 + 1);
                v319 = (uint8x8_t)vcnt_s8((int8x8_t)v445.u64[1]);
                v319.i16[0] = vaddlv_u8(v319);
                if (v319.u32[0] > 1uLL)
                {
                  if (v318 >= v445.i64[1])
                    v318 %= v445.i64[1];
                }
                else
                {
                  v318 &= v445.i64[1] - 1;
                }
                v325 = *(__int128 **)(v445.i64[0] + 8 * v318);
                do
                {
                  v326 = v325;
                  v325 = *(__int128 **)v325;
                }
                while (v325 != v316);
                if (v326 == &v446)
                  goto LABEL_486;
                v327 = *((_QWORD *)v326 + 1);
                if (v319.u32[0] > 1uLL)
                {
                  if (v327 >= v445.i64[1])
                    v327 %= v445.i64[1];
                }
                else
                {
                  v327 &= v445.i64[1] - 1;
                }
                if (v327 != v318)
                {
LABEL_486:
                  if (!*(_QWORD *)v316)
                    goto LABEL_487;
                  v337 = *(_QWORD *)(*(_QWORD *)v316 + 8);
                  if (v319.u32[0] > 1uLL)
                  {
                    if (v337 >= v445.i64[1])
                      v337 %= v445.i64[1];
                  }
                  else
                  {
                    v337 &= v445.i64[1] - 1;
                  }
                  if (v337 != v318)
LABEL_487:
                    *(_QWORD *)(v445.i64[0] + 8 * v318) = 0;
                }
                v338 = *(_QWORD *)v316;
                if (*(_QWORD *)v316)
                {
                  v339 = *(_QWORD *)(v338 + 8);
                  if (v319.u32[0] > 1uLL)
                  {
                    if (v339 >= v317)
                      v339 %= v317;
                  }
                  else
                  {
                    v339 &= v317 - 1;
                  }
                  if (v339 != v318)
                  {
                    *(_QWORD *)(v445.i64[0] + 8 * v339) = v326;
                    v338 = *(_QWORD *)v316;
                  }
                }
                *(_QWORD *)v326 = v338;
                --*((_QWORD *)&v446 + 1);
                operator delete(v316);
              }
              if (!*((_QWORD *)&v446 + 1) && v439 != v440)
              {
                v340 = *(_QWORD *)(v294 + 3);
                if (*((_QWORD *)v440 - 2) <= v340)
                  *((_QWORD *)v440 - 1) = v340;
              }
            }
          }
        }
      }
      else
      {
        if (!jj)
        {
          v298 = v275;
          objc_msgSend(v402, "appendBytes:length:");
          objc_msgSend(v410, "appendBytes:length:", ii[1], 24);
          v299 = (unint64_t)v448[1];
          if (v448[1])
          {
            v300 = (uint8x8_t)vcnt_s8((int8x8_t)v448[1]);
            v300.i16[0] = vaddlv_u8(v300);
            if (v300.u32[0] > 1uLL)
            {
              v283 = v276;
              if ((void *)v276 >= v448[1])
                v283 = v276 % (unint64_t)v448[1];
            }
            else
            {
              v283 = ((unint64_t)v448[1] - 1) & v276;
            }
            v304 = (_QWORD *)*((_QWORD *)v448[0] + v283);
            if (v304)
            {
              for (kk = (_QWORD *)*v304; kk; kk = (_QWORD *)*kk)
              {
                v306 = kk[1];
                if (v306 == v276)
                {
                  if (kk[2] == v276)
                    goto LABEL_454;
                }
                else
                {
                  if (v300.u32[0] > 1uLL)
                  {
                    if ((void *)v306 >= v448[1])
                      v306 %= (unint64_t)v448[1];
                  }
                  else
                  {
                    v306 &= (unint64_t)v448[1] - 1;
                  }
                  if (v306 != v283)
                    break;
                }
              }
            }
          }
          v307 = operator new(0x20uLL);
          *v307 = 0;
          v307[1] = v276;
          v307[2] = v276;
          *((_DWORD *)v307 + 6) = 1;
          v308 = (float)(unint64_t)(*((_QWORD *)&v449 + 1) + 1);
          if (!v299 || (float)(*(float *)&v450 * (float)v299) < v308)
          {
            v309 = (v299 & (v299 - 1)) != 0;
            if (v299 < 3)
              v309 = 1;
            v310 = v309 | (2 * v299);
            v311 = vcvtps_u32_f32(v308 / *(float *)&v450);
            if (v310 <= v311)
              v312 = v311;
            else
              v312 = v310;
            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)v448, v312);
            v299 = (unint64_t)v448[1];
            if (((unint64_t)v448[1] & ((unint64_t)v448[1] - 1)) != 0)
            {
              if ((void *)v276 >= v448[1])
                v283 = v276 % (unint64_t)v448[1];
              else
                v283 = v276;
            }
            else
            {
              v283 = ((unint64_t)v448[1] - 1) & v276;
            }
          }
          v320 = v448[0];
          v321 = (_QWORD *)*((_QWORD *)v448[0] + v283);
          if (v321)
          {
            *v307 = *v321;
            goto LABEL_452;
          }
          *v307 = v449;
          *(_QWORD *)&v449 = v307;
          v320[v283] = &v449;
          if (*v307)
          {
            v322 = *(_QWORD *)(*v307 + 8);
            if ((v299 & (v299 - 1)) != 0)
            {
              if (v322 >= v299)
                v322 %= v299;
            }
            else
            {
              v322 &= v299 - 1;
            }
            v321 = (char *)v448[0] + 8 * v322;
LABEL_452:
            *v321 = v307;
          }
          ++*((_QWORD *)&v449 + 1);
LABEL_454:
          if (*(_QWORD *)ii[1] <= 0xFFFFFFFEuLL)
          {
            if (!*((_QWORD *)&v446 + 1))
            {
              v323 = v440;
              if (v440 >= v441)
              {
                v328 = v439;
                v329 = (v440 - v439) >> 4;
                v330 = v329 + 1;
                if ((unint64_t)(v329 + 1) >> 60)
LABEL_585:
                  abort();
                v331 = v441 - v439;
                if ((v441 - v439) >> 3 > v330)
                  v330 = v331 >> 3;
                if ((unint64_t)v331 >= 0x7FFFFFFFFFFFFFF0)
                  v332 = 0xFFFFFFFFFFFFFFFLL;
                else
                  v332 = v330;
                v333 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(v332);
                v335 = &v333[16 * v329];
                *(_QWORD *)v335 = *(_QWORD *)(v298 + 3);
                *((_QWORD *)v335 + 1) = *(_QWORD *)(v298 + 3);
                v336 = v335;
                if (v323 != v328)
                {
                  do
                  {
                    *((_OWORD *)v336 - 1) = *((_OWORD *)v323 - 1);
                    v336 -= 16;
                    v323 -= 16;
                  }
                  while (v323 != v328);
                  v323 = v328;
                }
                v324 = v335 + 16;
                v439 = v336;
                v441 = &v333[16 * v334];
                if (v323)
                  operator delete(v323);
              }
              else
              {
                *(_QWORD *)v440 = *(_QWORD *)(v298 + 3);
                *((_QWORD *)v323 + 1) = *(_QWORD *)(v298 + 3);
                v324 = v323 + 16;
              }
              v440 = v324;
            }
            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long &>((uint64_t)&v445, v276, v276);
          }
          continue;
        }
        ++*((_DWORD *)jj + 6);
      }
    }
  }
  v342 = v439;
  v341 = v440;
  v343 = v440 - v439;
  v344 = (v440 - v439) >> 4;
  v417 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:"));
  obja = v342;
  if (v342 == v341)
    v345 = 0;
  else
    v345 = *((_QWORD *)v342 + 1);
  if (v343 >= 0x11)
  {
    v346 = v342 + 16;
    v347 = 1;
    do
    {
      if (v345 + 6000 < *v346)
      {
        v348 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v345));
        v491[0] = v348;
        if (*v346 - 6000 <= v345 + 6000)
          v349 = v345 + 6000;
        else
          v349 = *v346 - 6000;
        v350 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v349));
        v491[1] = v350;
        v351 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v491, 2));
        objc_msgSend(v417, "addObject:", v351);

      }
      if (v345 <= v346[1])
        v345 = v346[1];
      ++v347;
      v346 += 2;
    }
    while (v347 < v344);
  }
  objc_storeStrong((id *)(*((_QWORD *)this + 61) + 328), v417);
  v352 = (void ***)v442;
  v419 = (void ***)v443;
  std::__sort<std::__less<unsigned long long,unsigned long long> &,unsigned long long *>(v442, v443, &v477);
  if (v428)
  {
    v353 = std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v428);
    bzero(v353, v395);
  }
  else
  {
    v353 = 0;
  }
  v399 = v352;
  if (v352 != v419)
  {
    v354 = 0;
    v355 = 0;
    if ((unint64_t)((v404 - v434) >> 3) <= 1)
      v356 = 1;
    else
      v356 = (v404 - v434) >> 3;
    v357 = (char *)v461;
    v358 = v455;
    v359 = v452;
    v360 = (char *)v458;
    v361 = v399;
    do
    {
      v477 = 0;
      v424 = v361;
      v477 = *v361;
      objc_msgSend(v405, "appendBytes:length:", &v477, 8);
      if (v404 != v434)
      {
        v362 = 0;
        v363 = v477;
        do
        {
          v364 = &v425[24 * v362];
          v365 = *(_QWORD *)&v434[8 * v362];
          v366 = *((_QWORD *)v364 + 2);
          if (v365 < v366)
          {
            while (*(_QWORD *)(*(_QWORD *)v364 + 8 * v365) <= (unint64_t)v363)
            {
              if (v366 == ++v365)
              {
                v365 = *((_QWORD *)v364 + 2);
                break;
              }
            }
          }
          if (v365 <= 1)
            v365 = 1;
          v367 = (double)v365 + -1.0;
          *(_QWORD *)&v434[8 * v362] = v365 - 1;
          if (v365 < *((_QWORD *)v364 + 2))
          {
            v368 = *(_QWORD *)v364;
            v369 = *(_QWORD *)(v368 + 8 * (v365 - 1));
            if ((unint64_t)v363 > v369)
              v367 = v367 + (double)((unint64_t)v363 - v369) / (double)(*(_QWORD *)(v368 + 8 * v365) - v369);
          }
          *((double *)v353 + v362++) = v367;
        }
        while (v362 != v356);
      }
      if (v428)
      {
        v370 = 0;
        v371 = *((unsigned int *)this + 130);
        do
        {
          v372 = *(unsigned int *)&v434[8 * v370];
          v373 = &v357[32 * v370];
          v374 = *((_QWORD *)v373 + 2);
          *(_QWORD *)(v358[3 * v370] + 8 * v355) = *((_QWORD *)v353 + v370);
          if ((_DWORD)v371)
          {
            v375 = 0;
            if (v374 <= (v372 + 1))
              v376 = v372;
            else
              v376 = (v372 + 1);
            v377 = (double)v372;
            v378 = *(_QWORD *)v373;
            v379 = *((_QWORD *)v373 + 3);
            v380 = *(_QWORD *)v373 + 8 * v379 * v376;
            v381 = v378 + 8 * v379 * v372;
            v382 = &v451[0][v354 * (uint64_t)v451[3]];
            v383 = v359[4 * v370] + v354 * v359[4 * v370 + 3];
            do
            {
              v384 = *((double *)v353 + v370) - v377;
              if (v384 < 0.0)
                v384 = 0.0;
              v385 = (1.0 - v384) * *(double *)(v381 + 8 * v375) + v384 * *(double *)(v380 + 8 * v375);
              *(double *)(v383 + 8 * v375) = v385;
              if (((*(_QWORD *)&v360[(v375 >> 3) & 0x1FFFFFFFFFFFFFF8] >> v375) & 1) != 0)
              {
                v386 = v385 * *(double *)(*(_QWORD *)(*((_QWORD *)this + 61) + 232) + 8 * v370)
                     + *(double *)&v382[8 * v375];
                if (v386 > 100.0)
                  v386 = 100.0;
              }
              else
              {
                v386 = v385 + *(double *)&v382[8 * v375];
              }
              *(double *)&v382[8 * v375++] = v386;
            }
            while (v371 != v375);
          }
          ++v370;
        }
        while (v370 != v428);
      }
      ++v355;
      v361 = v424 + 1;
      v354 += 8;
    }
    while (v424 + 1 != v419);
  }
  *(_QWORD *)&v465 = CFSTR("frame index");
  v387 = (void **)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(*((_QWORD *)this + 61) + 360)));
  v477 = v387;
  v478.i64[0] = (uint64_t)v405;
  *((_QWORD *)&v465 + 1) = CFSTR("sampled timestamps");
  *(_QWORD *)&v466 = CFSTR("aggregated timeline data");
  v478.i64[1] = (uint64_t)v402;
  v479 = v410;
  *((_QWORD *)&v466 + 1) = CFSTR("aggregated timeline data ex");
  *(_QWORD *)&v467 = CFSTR("aggregated derived counters");
  v480 = (__int128 *)v400;
  *(_QWORD *)&v481 = v414;
  *((_QWORD *)&v467 + 1) = CFSTR("ring buffer sampled counter data");
  __p[0] = CFSTR("ring buffer blend factors");
  *((_QWORD *)&v481 + 1) = v412;
  v482 = (__int128 *)contexta;
  __p[1] = CFSTR("core counts");
  v469 = CFSTR("Frame Consistent Perf Info");
  v388 = *((_QWORD *)this + 61);
  v389 = (GRCPerFrameData *)&off_739590;
  v391 = *(GRCPerFrameData **)(v388 + 320);
  v390 = *(void **)(v388 + 328);
  if (v391)
    v389 = v391;
  v470 = CFSTR("Restore Timestamps");
  if (!v390)
    v390 = &__NSArray0__struct;
  v483 = v389;
  v484 = v390;
  v392 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v477, &v465, 10));

  v393 = (id)(*(uint64_t (**)(void))(*((_QWORD *)this + 63) + 16))();
  if (v353)
    operator delete(v353);

  if (obja)
    operator delete(obja);
  if (v399)
    operator delete(v399);

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v445);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v448);
  if (v223)
    operator delete(v223);
  if (v421)
    operator delete(v421);
  if (v432)
    operator delete(v432);

  if (v452)
    operator delete(v452);

  if (v455)
    operator delete(v455);

  if (v458)
    operator delete(v458);
  if (v434)
    operator delete(v434);
  if (v461)
    operator delete(v461);
  if (v425)
    operator delete(v425);
}

void sub_2F3574(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,uint64_t a21,void *a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,void *a59,uint64_t a60,uint64_t a61,void *a62,uint64_t a63)
{
  uint64_t a65;
  void *a68;
  void *v68;
  void *v70;

  if (__p)
    operator delete(__p);
  if (a40)
    operator delete(a40);

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a43);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a49);
  if (v68)
    operator delete(v68);
  if (a22)
    operator delete(a22);
  if (a27)
    operator delete(a27);

  if (a59)
    operator delete(a59);

  if (a62)
    operator delete(a62);

  v70 = (void *)a65;
  if (v70)
    operator delete(v70);
  if (a28)
    operator delete(a28);
  if (a68)
    operator delete(a68);
  if (a24)
    operator delete(a24);
  _Unwind_Resume(a1);
}

void std::vector<BufferView2D<double>>::reserve(void **a1, unint64_t a2)
{
  int64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  __int128 v11;

  if (a2 > ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 5)
  {
    v3 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>>(a2);
    v5 = &v4[v3 & 0xFFFFFFFFFFFFFFE0];
    v7 = &v4[32 * v6];
    v9 = (char *)*a1;
    v8 = (char *)a1[1];
    v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        v11 = *((_OWORD *)v8 - 1);
        *((_OWORD *)v10 - 2) = *((_OWORD *)v8 - 2);
        *((_OWORD *)v10 - 1) = v11;
        v10 -= 32;
        v8 -= 32;
      }
      while (v8 != v9);
      v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
      operator delete(v8);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,RingBufferSampledData>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RingBufferSampledData>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  uint64_t *v9;
  uint64_t i;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  int8x8_t prime;
  void *v20;
  void *v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;
  uint8x8_t v25;
  unint64_t v26;
  uint8x8_t v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  uint64_t *v31;
  unint64_t v32;
  void *v34;
  uint64_t v35[2];
  char v36;

  v6 = a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & a2;
    }
    v9 = *(uint64_t **)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = *(_QWORD *)i)
      {
        v11 = *(_QWORD *)(i + 8);
        if (v11 == a2)
        {
          if (*(_DWORD *)(i + 16) == a2)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  v12 = (_QWORD *)(a1 + 16);
  v13 = operator new(0x88uLL);
  v35[0] = (uint64_t)v13;
  v35[1] = a1 + 16;
  *v13 = 0;
  v13[1] = v6;
  *((_DWORD *)v13 + 4) = *a3;
  *((_OWORD *)v13 + 2) = 0u;
  *((_OWORD *)v13 + 3) = 0u;
  *((_OWORD *)v13 + 4) = 0u;
  *((_OWORD *)v13 + 5) = 0u;
  *((_OWORD *)v13 + 6) = 0u;
  *((_OWORD *)v13 + 7) = 0u;
  v13[16] = 0;
  *((_DWORD *)v13 + 6) = 0;
  v36 = 1;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    v6 = v3;
    goto LABEL_64;
  }
  v16 = 1;
  if (v7 >= 3)
    v16 = (v7 & (v7 - 1)) != 0;
  v17 = v16 | (2 * v7);
  v18 = vcvtps_u32_f32(v14 / v15);
  if (v17 <= v18)
    prime = (int8x8_t)v18;
  else
    prime = (int8x8_t)v17;
  if (*(_QWORD *)&prime == 1)
  {
    prime = (int8x8_t)2;
  }
  else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
  {
    prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    v7 = *(_QWORD *)(a1 + 8);
  }
  if (*(_QWORD *)&prime <= v7)
  {
    if (*(_QWORD *)&prime >= v7)
      goto LABEL_60;
    v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (v7 < 3 || (v27 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
    {
      v26 = std::__next_prime(v26);
    }
    else
    {
      v28 = 1 << -(char)__clz(v26 - 1);
      if (v26 >= 2)
        v26 = v28;
    }
    if (*(_QWORD *)&prime <= v26)
      prime = (int8x8_t)v26;
    if (*(_QWORD *)&prime >= v7)
    {
      v7 = *(_QWORD *)(a1 + 8);
      goto LABEL_60;
    }
    if (!*(_QWORD *)&prime)
    {
      v34 = *(void **)a1;
      *(_QWORD *)a1 = 0;
      if (v34)
        operator delete(v34);
      v7 = 0;
      *(_QWORD *)(a1 + 8) = 0;
      goto LABEL_60;
    }
  }
  if (*(_QWORD *)&prime >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  v20 = operator new(8 * *(_QWORD *)&prime);
  v21 = *(void **)a1;
  *(_QWORD *)a1 = v20;
  if (v21)
    operator delete(v21);
  v22 = 0;
  *(int8x8_t *)(a1 + 8) = prime;
  do
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v22++) = 0;
  while (*(_QWORD *)&prime != v22);
  v23 = (_QWORD *)*v12;
  if (*v12)
  {
    v24 = v23[1];
    v25 = (uint8x8_t)vcnt_s8(prime);
    v25.i16[0] = vaddlv_u8(v25);
    if (v25.u32[0] > 1uLL)
    {
      if (v24 >= *(_QWORD *)&prime)
        v24 %= *(_QWORD *)&prime;
    }
    else
    {
      v24 &= *(_QWORD *)&prime - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v12;
    v29 = (_QWORD *)*v23;
    if (*v23)
    {
      do
      {
        v30 = v29[1];
        if (v25.u32[0] > 1uLL)
        {
          if (v30 >= *(_QWORD *)&prime)
            v30 %= *(_QWORD *)&prime;
        }
        else
        {
          v30 &= *(_QWORD *)&prime - 1;
        }
        if (v30 != v24)
        {
          if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v30))
          {
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v30) = v23;
            goto LABEL_56;
          }
          *v23 = *v29;
          *v29 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v30);
          **(_QWORD **)(*(_QWORD *)a1 + 8 * v30) = v29;
          v29 = v23;
        }
        v30 = v24;
LABEL_56:
        v23 = v29;
        v29 = (_QWORD *)*v29;
        v24 = v30;
      }
      while (v29);
    }
  }
  v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v6)
      v6 %= v7;
  }
  else
  {
    v6 = ((_DWORD)v7 - 1) & v6;
  }
LABEL_64:
  v31 = *(uint64_t **)(*(_QWORD *)a1 + 8 * v6);
  i = v35[0];
  if (v31)
  {
    *(_QWORD *)v35[0] = *v31;
LABEL_72:
    *v31 = i;
    goto LABEL_73;
  }
  *(_QWORD *)v35[0] = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(*(_QWORD *)a1 + 8 * v6) = v12;
  if (*(_QWORD *)i)
  {
    v32 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7)
        v32 %= v7;
    }
    else
    {
      v32 &= v7 - 1;
    }
    v31 = (uint64_t *)(*(_QWORD *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  v35[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,RingBufferSampledData>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,RingBufferSampledData>,void *>>>>::reset[abi:nn180100](v35);
  return i;
}

void sub_2F3FE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,RingBufferSampledData>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,RingBufferSampledData>,void *>>>>::reset[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

char **BufferView2D<double>::BufferView2D(char **a1, void *a2, char *a3)
{
  id v5;
  char *v6;
  unint64_t v7;
  unint64_t v8;

  v5 = objc_retainAutorelease(a2);
  v6 = (char *)objc_msgSend(v5, "mutableBytes");
  *a1 = v6;
  if (a3)
  {
    v7 = (unint64_t)objc_msgSend(v5, "length");
    v6 = *a1;
    v8 = v7 / (8 * (uint64_t)a3);
  }
  else
  {
    v8 = 0;
  }
  a1[1] = &v6[8 * v8 * (_QWORD)a3];
  a1[2] = (char *)v8;
  a1[3] = a3;

  return a1;
}

void sub_2F406C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

double std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos *,false>(uint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  __int128 v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  unsigned int v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  _DWORD *v20;
  _DWORD *v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  BOOL v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  unint64_t v30;
  _BOOL4 v31;
  unint64_t v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  __int128 *v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  _DWORD *v43;
  BOOL v45;
  uint64_t v46;
  _DWORD *v47;
  uint64_t v48;
  unsigned int v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int64_t v54;
  int64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int v60;
  uint64_t v61;
  __int128 v62;
  uint64_t v63;
  int64_t v64;
  unint64_t v65;
  uint64_t v66;
  __int128 v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  __int128 v74;
  __int128 *v75;
  __int128 v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  uint64_t v81;
  unsigned int v82;
  uint64_t v83;
  BOOL v84;
  uint64_t v85;
  unsigned int v86;
  __int128 v87;
  uint64_t v88;
  uint64_t v89;
  BOOL v90;
  unint64_t v92;
  int v94;
  int v95;
  __int128 *v96;
  uint64_t v97;
  uint64_t v98;
  int v99;
  int64_t v100;
  uint64_t v101;
  int64_t v102;
  __int128 v103;
  uint64_t v104;
  __int128 v105;
  uint64_t v106;

BOOL GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos::operator<(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  _DWORD *v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;

  v3 = *(_DWORD **)a1;
  v4 = *(_QWORD *)(*(_QWORD *)a1 + 12);
  v5 = *(_QWORD *)(a2 + 12);
  v6 = v4 >= v5;
  if (v4 == v5)
  {
    v7 = v3[5];
    v8 = *(_DWORD *)(a2 + 20);
    v6 = v7 >= v8;
    if (v7 == v8)
    {
      v9 = *v3 & 0xF;
      v6 = v9 >= (*(_DWORD *)a2 & 0xFu);
      if (v9 == (*(_DWORD *)a2 & 0xF))
        v6 = a1[4] >= a3;
    }
  }
  return !v6;
}

BOOL std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos *>(__int128 *a1, _DWORD *a2, __int128 *a3)
{
  BOOL v6;
  _BOOL8 result;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;

  v6 = GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos::operator<(a2, *(_QWORD *)a1, *((_DWORD *)a1 + 4));
  result = GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos::operator<(a3, *(_QWORD *)a2, a2[4]);
  if (v6)
  {
    if (result)
    {
      v8 = *((_QWORD *)a1 + 2);
      v9 = *a1;
      v10 = *((_QWORD *)a3 + 2);
      *a1 = *a3;
      *((_QWORD *)a1 + 2) = v10;
    }
    else
    {
      v17 = *((_QWORD *)a1 + 2);
      v18 = *a1;
      v19 = *((_QWORD *)a2 + 2);
      *a1 = *(_OWORD *)a2;
      *((_QWORD *)a1 + 2) = v19;
      *(_OWORD *)a2 = v18;
      *((_QWORD *)a2 + 2) = v17;
      result = GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos::operator<(a3, *(_QWORD *)a2, v17);
      if (!result)
        return result;
      v8 = *((_QWORD *)a2 + 2);
      v9 = *(_OWORD *)a2;
      v20 = *((_QWORD *)a3 + 2);
      *(_OWORD *)a2 = *a3;
      *((_QWORD *)a2 + 2) = v20;
    }
    *a3 = v9;
    *((_QWORD *)a3 + 2) = v8;
  }
  else if (result)
  {
    v11 = *((_QWORD *)a2 + 2);
    v12 = *(_OWORD *)a2;
    v13 = *((_QWORD *)a3 + 2);
    *(_OWORD *)a2 = *a3;
    *((_QWORD *)a2 + 2) = v13;
    *a3 = v12;
    *((_QWORD *)a3 + 2) = v11;
    result = GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos::operator<(a2, *(_QWORD *)a1, *((_DWORD *)a1 + 4));
    if (result)
    {
      v14 = *((_QWORD *)a1 + 2);
      v15 = *a1;
      v16 = *((_QWORD *)a2 + 2);
      *a1 = *(_OWORD *)a2;
      *((_QWORD *)a1 + 2) = v16;
      *(_OWORD *)a2 = v15;
      *((_QWORD *)a2 + 2) = v14;
    }
  }
  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos *>(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  __n128 result;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos *>((__int128 *)a1, a2, (__int128 *)a3);
  if (GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos::operator<((_DWORD *)a4, *(_QWORD *)a3, *(_DWORD *)(a3 + 16)))
  {
    v9 = *(_QWORD *)(a3 + 16);
    v10 = *(_OWORD *)a3;
    v11 = *(_QWORD *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_QWORD *)(a3 + 16) = v11;
    *(_OWORD *)a4 = v10;
    *(_QWORD *)(a4 + 16) = v9;
    if (GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos::operator<((_DWORD *)a3, *(_QWORD *)a2, a2[4]))
    {
      v12 = *((_QWORD *)a2 + 2);
      v13 = *(_OWORD *)a2;
      v14 = *(_QWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_QWORD *)a2 + 2) = v14;
      *(_OWORD *)a3 = v13;
      *(_QWORD *)(a3 + 16) = v12;
      if (GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos::operator<(a2, *(_QWORD *)a1, *(_DWORD *)(a1 + 16)))
      {
        v15 = *(_QWORD *)(a1 + 16);
        result = *(__n128 *)a1;
        v16 = *((_QWORD *)a2 + 2);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_QWORD *)(a1 + 16) = v16;
        *(__n128 *)a2 = result;
        *((_QWORD *)a2 + 2) = v15;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos *>(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, uint64_t a5)
{
  __n128 result;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos *>(a1, a2, (uint64_t)a3, (uint64_t)a4);
  if (GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos::operator<((_DWORD *)a5, *(_QWORD *)a4, a4[4]))
  {
    v11 = *((_QWORD *)a4 + 2);
    v12 = *(_OWORD *)a4;
    v13 = *(_QWORD *)(a5 + 16);
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *((_QWORD *)a4 + 2) = v13;
    *(_OWORD *)a5 = v12;
    *(_QWORD *)(a5 + 16) = v11;
    if (GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos::operator<(a4, *(_QWORD *)a3, a3[4]))
    {
      v14 = *((_QWORD *)a3 + 2);
      v15 = *(_OWORD *)a3;
      v16 = *((_QWORD *)a4 + 2);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *((_QWORD *)a3 + 2) = v16;
      *(_OWORD *)a4 = v15;
      *((_QWORD *)a4 + 2) = v14;
      if (GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos::operator<(a3, *(_QWORD *)a2, a2[4]))
      {
        v17 = *((_QWORD *)a2 + 2);
        v18 = *(_OWORD *)a2;
        v19 = *((_QWORD *)a3 + 2);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *((_QWORD *)a2 + 2) = v19;
        *(_OWORD *)a3 = v18;
        *((_QWORD *)a3 + 2) = v17;
        if (GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos::operator<(a2, *(_QWORD *)a1, *(_DWORD *)(a1 + 16)))
        {
          v20 = *(_QWORD *)(a1 + 16);
          result = *(__n128 *)a1;
          v21 = *((_QWORD *)a2 + 2);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_QWORD *)(a1 + 16) = v21;
          *(__n128 *)a2 = result;
          *((_QWORD *)a2 + 2) = v20;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos *>(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _BOOL8 result;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;

  v4 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v6 = a2 - 24;
      if (GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos::operator<((_DWORD *)(a2 - 24), *(_QWORD *)a1, *(_DWORD *)(a1 + 16)))
      {
        v7 = *(_QWORD *)(a1 + 16);
        v8 = *(_OWORD *)a1;
        v9 = *(_QWORD *)(v6 + 16);
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_QWORD *)(a1 + 16) = v9;
        *(_OWORD *)v6 = v8;
        *(_QWORD *)(v6 + 16) = v7;
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos *>((__int128 *)a1, (_DWORD *)(a1 + 24), (__int128 *)(a2 - 24));
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos *>(a1, (_DWORD *)(a1 + 24), a1 + 48, a2 - 24);
      return 1;
    case 5uLL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos *>(a1, (_DWORD *)(a1 + 24), (_DWORD *)(a1 + 48), (_DWORD *)(a1 + 72), a2 - 24);
      return 1;
    default:
      v10 = a1 + 48;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos *>((__int128 *)a1, (_DWORD *)(a1 + 24), (__int128 *)(a1 + 48));
      v11 = a1 + 72;
      if (a1 + 72 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    if (GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos::operator<((_DWORD *)v11, *(_QWORD *)v10, *(_DWORD *)(v10 + 16)))
    {
      v17 = *(_OWORD *)v11;
      v18 = *(_QWORD *)(v11 + 16);
      v14 = v12;
      while (1)
      {
        v15 = a1 + v14;
        *(_OWORD *)(v15 + 72) = *(_OWORD *)(a1 + v14 + 48);
        *(_QWORD *)(v15 + 88) = *(_QWORD *)(a1 + v14 + 64);
        if (v14 == -48)
          break;
        v14 -= 24;
        if (!GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos::operator<(&v17, *(_QWORD *)(v15 + 24), *(_DWORD *)(v15 + 40)))
        {
          v16 = a1 + v14 + 72;
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *(_OWORD *)v16 = v17;
      *(_QWORD *)(v16 + 16) = v18;
      if (++v13 == 8)
        return v11 + 24 == a2;
    }
    v10 = v11;
    v12 += 24;
    v11 += 24;
    if (v11 == a2)
      return 1;
  }
}

_QWORD *BufferView<ShaderProfilerSampleTimelineInfoEx>::BufferView(_QWORD *a1, void *a2)
{
  id v3;
  unint64_t v4;

  v3 = objc_retainAutorelease(a2);
  *a1 = objc_msgSend(v3, "mutableBytes");
  v4 = (unint64_t)objc_msgSend(v3, "length");
  a1[1] = *a1 + 24 * (v4 / 0x18);
  a1[2] = v4 / 0x18;

  return a1;
}

void sub_2F4F48(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *BufferView<ShaderProfilerSampleTimelineInfo>::BufferView(_QWORD *a1, void *a2)
{
  id v3;
  unint64_t v4;

  v3 = objc_retainAutorelease(a2);
  *a1 = objc_msgSend(v3, "mutableBytes");
  v4 = (unint64_t)objc_msgSend(v3, "length");
  a1[1] = *a1 + 24 * (v4 / 0x18);
  a1[2] = v4 / 0x18;

  return a1;
}

void sub_2F4FB8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_2F5018(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_2F5078(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,RingBufferSampledData>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,RingBufferSampledData>,void *>>>>::reset[abi:nn180100](uint64_t *a1)
{
  uint64_t v1;

  v1 = *a1;
  *a1 = 0;
  if (v1)
  {
    if (*((_BYTE *)a1 + 16))
      RingBufferSampledData::~RingBufferSampledData((RingBufferSampledData *)(v1 + 24));
    operator delete((void *)v1);
  }
}

__n128 __Block_byref_object_copy__357(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__358(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void ___ZN15GRCPerFrameData23EvaluateDerivedLimitersEj_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  void *v5;
  id v6;
  id v7;
  void *v8;
  unsigned int *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  id v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  unint64_t v34;
  void *v35;
  uint64_t v36;
  _QWORD v38[3];

  v2 = *(_QWORD *)(a1 + 64);
  v3 = objc_autoreleasePoolPush();
  v5 = (void *)objc_opt_new(DYJSScriptingContext, v4);
  if ((objc_msgSend(v5, "evaluteScript:scriptURL:", *(_QWORD *)(a1 + 32), 0) & 1) == 0)
    goto LABEL_25;
  v6 = *(id *)(a1 + 40);
  v7 = v5;
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "context"));
  objc_msgSend(v8, "setObject:forKeyedSubscript:", &__block_literal_global_362, CFSTR("ErrorLog"));

  LODWORD(v8) = objc_msgSend(v7, "evaluteScript:scriptURL:", v6, 0);
  if (!(_DWORD)v8)
    goto LABEL_25;
  if (*(_QWORD *)(a1 + 48))
    objc_msgSend(v7, "setValues:");
  objc_msgSend(v7, "setRawArrayValues:withUint64Values:andNumCounters:", CFSTR("_RawTimestampDelta"), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 48)+ 8 * (*(_QWORD *)(a1 + 72) / ((unint64_t)**(unsigned int **)(a1 + 80) >> 26)), *(_QWORD *)(a1 + 88));
  v9 = *(unsigned int **)(a1 + 80);
  v10 = *(_QWORD *)(a1 + 88);
  v11 = *v9;
  v12 = v10 * (v11 >> 26);
  if (v12)
  {
    if (v12 >> 62)
      abort();
    v13 = std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v10 * (v11 >> 26));
    bzero(v13, 4 * v12);
    v9 = *(unsigned int **)(a1 + 80);
    v10 = *(_QWORD *)(a1 + 88);
    LODWORD(v11) = *v9;
    if (!v10)
      goto LABEL_20;
    goto LABEL_10;
  }
  v13 = 0;
  if (v10)
  {
LABEL_10:
    LODWORD(v14) = 0;
    while (1)
    {
      LODWORD(v15) = v11 >> 26;
      if (v11 >> 26)
        break;
LABEL_19:
      v14 = (v14 + 1);
      if (v10 <= v14)
        goto LABEL_20;
    }
    v16 = 0;
    v17 = *(_QWORD *)(*(_QWORD *)(v2 + 488) + 208);
    v18 = (v14 * v15);
    while (1)
    {
      if (((*(_QWORD *)(v17 + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v16) & 1) != 0)
      {
        v19 = *(_QWORD *)(a1 + 72);
        v20 = *((_QWORD *)v9 + 1);
      }
      else
      {
        v19 = *(_QWORD *)(a1 + 72);
        v20 = *((_QWORD *)v9 + 1);
        if (*(_QWORD *)(a1 + 96))
        {
          v21 = *(_DWORD *)(v20 + 4 * (v18 + v16 + v19)) - *(_DWORD *)(v20 + 4 * (v18 + v16 + v19 - v15));
          goto LABEL_18;
        }
      }
      v21 = *(_DWORD *)(v20 + 4 * (v18 + v19 + v16));
LABEL_18:
      *((_DWORD *)v13 + (v18 + v16++)) = v21;
      v11 = *v9;
      v15 = v11 >> 26;
      if (v16 >= v11 >> 26)
        goto LABEL_19;
    }
  }
LABEL_20:
  v22 = v11 >> 26;
  v23 = *(unsigned int *)(a1 + 120);
  v24 = v7;
  objc_msgSend(v24, "setRawArrayValues:withUint32Values:andNumCounters:", CFSTR("_RawCounterValues"), v13, v10 * v22);
  objc_msgSend(v24, "setRawArrayValues:withUint32Values:andNumCounters:", CFSTR("_CoreCount"));
  v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v10));
  v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", (int)v22 - 1, v25));
  v38[1] = v26;
  v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v23));
  v38[2] = v27;
  v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v38, 3));
  objc_msgSend(v24, "callFunction:withArguments:", CFSTR("_SetAndEvaluateRawCounterValues"), v28);

  v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "getValue:", CFSTR("_DerivedCounterResult")));
  v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v29, "toArray"));

  v31 = *(unsigned int *)(v2 + 520);
  if (*(_QWORD *)(a1 + 88) * v31)
  {
    v32 = 0;
    v33 = 1;
    v34 = *(_QWORD *)(a1 + 72) * v31 / ((unint64_t)**(unsigned int **)(a1 + 104) >> 26);
    do
    {
      v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "objectAtIndexedSubscript:", v32));
      objc_msgSend(v35, "doubleValue");
      *(_QWORD *)(*(_QWORD *)(a1 + 112) + 8 * (v32 + v34)) = v36;

      v32 = v33;
    }
    while (*(_QWORD *)(a1 + 88) * (unint64_t)*(unsigned int *)(v2 + 520) > v33++);
  }

  if (v13)
    operator delete(v13);
LABEL_25:

  objc_autoreleasePoolPop(v3);
}

void sub_2F54BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  if (v2)
    operator delete(v2);

  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::unique_ptr<GRCPerFrameData::PriorityQueueElement>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    v4 = *(_QWORD *)(i - 8);
    *(_QWORD *)(i - 8) = 0;
    if (v4)
      std::default_delete<GRCPerFrameData::PriorityQueueElement>::operator()[abi:nn180100](v4);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::default_delete<GRCPerFrameData::PriorityQueueElement>::operator()[abi:nn180100](uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 80);
  if (v2)
  {
    *(_QWORD *)(a1 + 88) = v2;
    operator delete(v2);
  }
  operator delete();
}

void GRCPerFrameData::FindNextMarker(uint64_t a1, void *a2, unsigned int a3, unsigned int a4, uint64_t a5)
{
  int v8;
  unsigned int *v9;
  unsigned int *v10;
  unint64_t v11;
  unsigned int *v12;
  uint64_t v13;
  id v14;
  _QWORD *v15;
  void *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t v22;
  unsigned int *v23;
  unsigned int *v24;
  uint64_t v25;
  uint64_t v26;
  id v27;
  char *v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  unint64_t v32;
  id v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  id v37;
  char *v38;
  char *v39;
  char *v40;
  _BYTE *v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  _BYTE *v45;
  int64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  char *v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  unsigned int v57;
  id v58;
  void *__p;
  void *__dst;
  uint64_t v61;
  unsigned int *v62;
  unsigned int *v63;
  unsigned int *v64;

  v58 = a2;
  v62 = 0;
  v63 = 0;
  v64 = 0;
  std::vector<std::pair<unsigned int,unsigned int>>::reserve((void **)&v62, 2uLL);
  v8 = 0;
  v10 = v63;
  v9 = v64;
  v11 = a4;
  v12 = v62;
LABEL_2:
  if ((unint64_t)objc_msgSend(v58, "count") <= a3)
  {
    if (v8 != 1)
    {
      *(_QWORD *)(a5 + 4) = -1;
      if (!v12)
        goto LABEL_27;
LABEL_26:
      v63 = v12;
      operator delete(v12);
      goto LABEL_27;
    }
    *(_QWORD *)(a5 + 4) = (*(_DWORD *)(a5 + 4) + 1);
    v33 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v58, "objectAtIndexedSubscript:", *v12));
    v51 = ((unint64_t)objc_msgSend(v33, "length") >> 3) - v12[1];
    if (v51 >= 8)
    {
      v52 = (char *)objc_msgSend(objc_retainAutorelease(v33), "bytes") + 8 * v12[1];
      *(_QWORD *)(a5 + 88) = *(_QWORD *)(a5 + 80);
      v53 = *(_OWORD *)v52;
      v54 = *((_OWORD *)v52 + 1);
      v55 = *((_OWORD *)v52 + 3);
      *(_OWORD *)(a5 + 48) = *((_OWORD *)v52 + 2);
      *(_OWORD *)(a5 + 64) = v55;
      *(_OWORD *)(a5 + 16) = v53;
      *(_OWORD *)(a5 + 32) = v54;
      std::vector<unsigned long long>::reserve((void **)(a5 + 80), v51 - 8);
      std::vector<unsigned long long>::__assign_with_size[abi:nn180100]<unsigned long long *,unsigned long long *>((char *)(a5 + 80), v52 + 64, (uint64_t)&v52[8 * v51], (uint64_t)(8 * v51 - 64) >> 3);
    }
LABEL_43:

    if (!v12)
      goto LABEL_27;
    goto LABEL_26;
  }
  v57 = a3;
  v13 = a3;
  v14 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v58, "objectAtIndexedSubscript:", a3)));
  v15 = objc_msgSend(v14, "bytes");

  while (1)
  {
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v58, "objectAtIndexedSubscript:", v13));
    v17 = objc_msgSend(v16, "length") >> 3;

    if (v17 <= v11)
    {
      v11 = 0;
      v63 = v10;
      v64 = v9;
      a3 = v57 + 1;
      v62 = v12;
      goto LABEL_2;
    }
    if (v15[v11] == *(_QWORD *)(*(_QWORD *)(a1 + 488) + 352))
      break;
LABEL_22:
    ++v11;
  }
  if (v10 >= v9)
  {
    v18 = ((char *)v10 - (char *)v12) >> 3;
    v19 = v18 + 1;
    if ((unint64_t)(v18 + 1) >> 61)
    {
      v63 = v10;
      v64 = v9;
      v62 = v12;
      abort();
    }
    if (v9 - v12 > v19)
      v19 = v9 - v12;
    if ((unint64_t)((char *)v9 - (char *)v12) >= 0x7FFFFFFFFFFFFFF8)
      v20 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v20 = v19;
    v21 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v20);
    v23 = (unsigned int *)&v21[8 * v18];
    *v23 = v57;
    v23[1] = v11;
    v24 = v23;
    while (v10 != v12)
    {
      v25 = *((_QWORD *)v10 - 1);
      v10 -= 2;
      *((_QWORD *)v24 - 1) = v25;
      v24 -= 2;
    }
    v9 = (unsigned int *)&v21[8 * v22];
    v10 = v23 + 2;
    if (v12)
      operator delete(v12);
    v12 = v24;
  }
  else
  {
    *v10 = v57;
    v10[1] = v11;
    v10 += 2;
  }
  if (v8 != 1)
  {
    v8 = 1;
    goto LABEL_22;
  }
  v64 = v9;
  v62 = v12;
  v26 = *((_QWORD *)v12 + 1);
  *(_QWORD *)(a5 + 4) = v26;
  if (*v12 != (_DWORD)v26)
  {
    v33 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v58, "objectAtIndexedSubscript:")));
    v34 = (char *)objc_msgSend(v33, "bytes");
    v35 = v12[1];
    v36 = ((unint64_t)objc_msgSend(v33, "length") >> 3) - v12[1];
    __dst = 0;
    v61 = 0;
    __p = 0;
    std::vector<unsigned long long>::reserve(&__p, v12[3] + v36);
    std::vector<unsigned long long>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned long long *>,std::__wrap_iter<unsigned long long *>>(&__p, (char *)__dst, &v34[8 * v35], &v34[8 * v35 + 8 * v36], v36);
    v37 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v58, "objectAtIndexedSubscript:", v12[2])));
    v38 = (char *)objc_msgSend(v37, "bytes");

    std::vector<unsigned long long>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned long long *>,std::__wrap_iter<unsigned long long *>>(&__p, (char *)__dst, v38, &v38[8 * v12[3]], v12[3]);
    v39 = *(char **)(a5 + 80);
    *(_QWORD *)(a5 + 88) = v39;
    v40 = (char *)__p;
    v41 = __dst;
    v42 = *(_OWORD *)__p;
    v43 = *((_OWORD *)__p + 1);
    v44 = *((_OWORD *)__p + 3);
    *(_OWORD *)(a5 + 48) = *((_OWORD *)__p + 2);
    *(_OWORD *)(a5 + 64) = v44;
    *(_OWORD *)(a5 + 16) = v42;
    *(_OWORD *)(a5 + 32) = v43;
    if ((unint64_t)(v41 - v40) < 0x41)
      goto LABEL_42;
    v45 = v40 + 64;
    v46 = v41 - (v40 + 64);
    v47 = v46 >> 3;
    v48 = *(_QWORD *)(a5 + 96);
    if (v46 >> 3 > (unint64_t)((v48 - (uint64_t)v39) >> 3))
    {
      if (v39)
      {
        *(_QWORD *)(a5 + 88) = v39;
        operator delete(v39);
        v48 = 0;
        *(_QWORD *)(a5 + 80) = 0;
        *(_QWORD *)(a5 + 88) = 0;
        *(_QWORD *)(a5 + 96) = 0;
      }
      if (v46 < 0)
        abort();
      v49 = v48 >> 2;
      if (v48 >> 2 <= v47)
        v49 = v46 >> 3;
      if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8)
        v50 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v50 = v49;
      std::vector<NSString * {__strong}>::__vallocate[abi:nn180100]((_QWORD *)(a5 + 80), v50);
      v39 = *(char **)(a5 + 88);
    }
    if (v41 != v45)
      memmove(v39, v45, v46);
    *(_QWORD *)(a5 + 88) = &v39[8 * v47];
    v40 = (char *)__p;
    if (__p)
    {
LABEL_42:
      __dst = v40;
      operator delete(v40);
    }
    goto LABEL_43;
  }
  v27 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v58, "objectAtIndexedSubscript:")));
  v28 = (char *)objc_msgSend(v27, "bytes") + 8 * v12[1];

  *(_QWORD *)(a5 + 88) = *(_QWORD *)(a5 + 80);
  v29 = *((_OWORD *)v28 + 3);
  v31 = *(_OWORD *)v28;
  v30 = *((_OWORD *)v28 + 1);
  *(_OWORD *)(a5 + 48) = *((_OWORD *)v28 + 2);
  *(_OWORD *)(a5 + 64) = v29;
  *(_OWORD *)(a5 + 16) = v31;
  *(_OWORD *)(a5 + 32) = v30;
  std::vector<unsigned long long>::reserve((void **)(a5 + 80), v12[3] - v12[1] - 8);
  v32 = v12[3] - v12[1] - 8;
  std::vector<unsigned long long>::__assign_with_size[abi:nn180100]<unsigned long long *,unsigned long long *>((char *)(a5 + 80), v28 + 64, (uint64_t)&v28[8 * v32 + 64], v32);
  if (v12)
    goto LABEL_26;
LABEL_27:

}

void sub_2F5AB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  void *v18;
  void *v19;

  if (v18)
    operator delete(v18);

  _Unwind_Resume(a1);
}

BOOL std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,GRCPerFrameData::GreaterPQElement &,std::__wrap_iter<GRCPerFrameData::PriorityQueueElement **>>(_BOOL8 result, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  _BOOL8 v4;
  unint64_t v5;
  _QWORD **v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;

  v3 = a3 - 2;
  if (a3 >= 2)
  {
    v4 = result;
    v5 = v3 >> 1;
    v6 = (_QWORD **)(result + 8 * (v3 >> 1));
    v7 = (uint64_t)*v6;
    v9 = (_QWORD *)(a2 - 8);
    v8 = *(_QWORD **)(a2 - 8);
    result = GRCPerFrameData::GreaterPQElement::operator()(*v6, v8);
    if (result)
    {
      do
      {
        v10 = v6;
        *v9 = v7;
        if (!v5)
          break;
        v5 = (v5 - 1) >> 1;
        v6 = (_QWORD **)(v4 + 8 * v5);
        v7 = (uint64_t)*v6;
        result = GRCPerFrameData::GreaterPQElement::operator()(*v6, v8);
        v9 = v10;
      }
      while (result);
      *v10 = v8;
    }
  }
  return result;
}

void GRCPerFrameData::AddLimiterCounterSample(uint64_t a1, unsigned int a2, __int128 *a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  __int128 v11;
  __int128 v12;
  _DWORD *v13;
  unint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  _DWORD *v27;
  uint64_t v28;
  char *v29;
  char *v30;
  _DWORD *v31;
  char *v32;
  uint64_t v33;
  _DWORD *v34;
  uint64_t v35;
  char *v36;
  char *v37;
  int v38;
  unint64_t v39;
  char *v40;
  int64_t v41;
  void *v42;
  char *v43;
  char *v44;
  _DWORD *v45;
  int v46;
  uint64_t v47;
  unsigned int v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  void *__p;
  _BYTE *v54;
  unsigned int v55;

  v55 = a2;
  v8 = std::__hash_table<std::__hash_value_type<unsigned int,RingBufferSampledData>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RingBufferSampledData>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(a1 + 448, a2, &v55);
  if ((uint64_t)(*((_QWORD *)a3 + 9) - *((_QWORD *)a3 + 8)) >> 3 >= (unint64_t)*(unsigned int *)(v8 + 24) >> 26)
  {
    v9 = v8;
    if (!a4)
      goto LABEL_50;
    v10 = GRCPerFrameData::AddDeferredKickSamples((ProgramAddressHelper *)a1, a2, a3);
    v48 = a2;
    v11 = a3[1];
    v49 = *a3;
    v50 = v11;
    v12 = a3[3];
    v51 = a3[2];
    v52 = v12;
    std::vector<unsigned long long>::vector(&__p, (uint64_t)(a3 + 4));
    *(_DWORD *)(a1 + 352) = a2;
    *(_OWORD *)(a1 + 360) = v49;
    *(_OWORD *)(a1 + 376) = v50;
    *(_OWORD *)(a1 + 392) = v51;
    *(_OWORD *)(a1 + 408) = v52;
    if ((unsigned int *)(a1 + 352) != &v48)
      std::vector<unsigned long long>::__assign_with_size[abi:nn180100]<unsigned long long *,unsigned long long *>((char *)(a1 + 424), (char *)__p, (uint64_t)v54, (v54 - (_BYTE *)__p) >> 3);
    if (__p)
    {
      v54 = __p;
      operator delete(__p);
    }
    if (v10)
    {
LABEL_50:
      if (objc_msgSend(*(id *)(v9 + 88), "length"))
      {
        v13 = objc_msgSend(*(id *)(v9 + 88), "mutableBytes");
        v14 = (unint64_t)objc_msgSend(*(id *)(v9 + 88), "length");
        v13[6 * (v14 / 0x18) - 6] += 16;
      }
      *(_DWORD *)(v9 + 24) = *(_DWORD *)(v9 + 24) & 0xFC000000 | (*(_DWORD *)(v9 + 24) + 1) & 0x3FFFFFF;
      v16 = (char *)*((_QWORD *)a3 + 8);
      v15 = (char *)*((_QWORD *)a3 + 9);
      if (v15 - v16 >= 1)
      {
        v17 = (v15 - v16) >> 3;
        v19 = *(char **)(v9 + 40);
        v18 = *(_QWORD *)(v9 + 48);
        if (v17 <= (v18 - (uint64_t)v19) >> 2)
        {
          if (v17 <= 0)
          {
            v29 = &v16[8 * v17];
            v30 = *(char **)(v9 + 40);
            v43 = &v19[4 * v17];
            v44 = &v30[-4 * v17];
            v45 = *(_DWORD **)(v9 + 40);
            if (v44 < v19)
            {
              v45 = *(_DWORD **)(v9 + 40);
              do
              {
                v46 = *(_DWORD *)v44;
                v44 += 4;
                *v45++ = v46;
              }
              while (v44 < v19);
            }
            *(_QWORD *)(v9 + 40) = v45;
            if (v30 != v43)
              memmove(&v30[-4 * ((v30 - v43) >> 2)], v19, v30 - v43);
            for (; v16 != v29; v19 += 4)
            {
              v47 = *(_QWORD *)v16;
              v16 += 8;
              *(_DWORD *)v19 = v47;
            }
          }
          else
          {
            if (*((char **)a3 + 8) == v15)
            {
              v27 = *(_DWORD **)(v9 + 40);
            }
            else
            {
              v26 = (char *)*((_QWORD *)a3 + 8);
              v27 = *(_DWORD **)(v9 + 40);
              do
              {
                v28 = *(_QWORD *)v26;
                v26 += 8;
                *v27++ = v28;
              }
              while (v26 != v15);
            }
            *(_QWORD *)(v9 + 40) = v27;
          }
        }
        else
        {
          v20 = *(_QWORD *)(v9 + 32);
          v21 = (uint64_t)&v19[-v20] >> 2;
          if ((unint64_t)(v21 + v17) >> 62)
            abort();
          v22 = v18 - v20;
          v23 = v22 >> 1;
          if (v22 >> 1 <= (unint64_t)(v21 + v17))
            v23 = v21 + v17;
          if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFFCLL)
            v24 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v24 = v23;
          if (v24)
            v24 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v24);
          else
            v25 = 0;
          v31 = (_DWORD *)(v24 + 4 * v21);
          v32 = (char *)&v31[v17];
          v33 = 4 * v17;
          v34 = v31;
          do
          {
            v35 = *(_QWORD *)v16;
            v16 += 8;
            *v34++ = v35;
            v33 -= 4;
          }
          while (v33);
          v36 = *(char **)(v9 + 32);
          if (v36 != v19)
          {
            v37 = v19;
            do
            {
              v38 = *((_DWORD *)v37 - 1);
              v37 -= 4;
              *--v31 = v38;
            }
            while (v37 != v36);
          }
          v39 = v24 + 4 * v25;
          v40 = *(char **)(v9 + 40);
          v41 = v40 - v19;
          if (v40 != v19)
            memmove(v32, v19, v40 - v19);
          v42 = *(void **)(v9 + 32);
          *(_QWORD *)(v9 + 32) = v31;
          *(_QWORD *)(v9 + 40) = &v32[v41];
          *(_QWORD *)(v9 + 48) = v39;
          if (v42)
            operator delete(v42);
        }
      }
      objc_msgSend(*(id *)(v9 + 56), "appendBytes:length:", (char *)a3 + 8, 8);
    }
  }
}

void sub_2F5F28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL GRCPerFrameData::AddDeferredKickSamples(ProgramAddressHelper *a1, unsigned int a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  __int128 v19;
  ProgramAddressHelper *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t *v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t *v33;
  unint64_t v34;
  __int128 v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  double v39;
  double v40;
  uint64_t *v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  void *v47;
  BOOL v48;
  char *v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  char *v58;
  char *v59;
  char *v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t *v66;
  unint64_t v67;
  ProgramAddressHelper *v68;
  uint64_t v69;
  unsigned int v70;
  unsigned int v71;
  void *v72;
  uint64_t *v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t *v79;
  uint64_t v80;
  __n128 *v81;
  uint64_t v82;
  __n128 *v83;
  uint64_t v84;
  unint64_t v85;
  int v86;
  int v87;
  __n128 *v88;
  unsigned int v89;
  uint64_t v90;
  unsigned int v91;
  uint64_t v92;
  _QWORD *v93;
  _QWORD *v94;
  unsigned int v95;
  unint64_t v96;
  int8x8_t v97;
  uint8x8_t v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  unint64_t v102;
  uint64_t *v103;
  unint64_t v104;
  uint64_t *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t *v108;
  unsigned int v109;
  BOOL v110;
  _BOOL4 v111;
  BOOL v112;
  uint64_t *v113;
  unsigned int v114;
  uint64_t *v115;
  _QWORD *v116;
  _QWORD *v117;
  unsigned int v118;
  unsigned __int32 v119;
  unint64_t v120;
  unint64_t v121;
  char *v122;
  uint64_t v123;
  char *v124;
  __n128 *v125;
  __n128 v126;
  __n128 *v127;
  char *v128;
  uint64_t v129;
  __n128 *v130;
  unint64_t v131;
  uint64_t v132;
  __n128 *v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  _DWORD *v137;
  int v138;
  int v139;
  unsigned __int16 *v140;
  unsigned int v141;
  uint64_t v142;
  char *v143;
  unint64_t v144;
  int v145;
  int v146;
  unint64_t *v147;
  int v148;
  unsigned int v149;
  unsigned int v150;
  unsigned int v151;
  uint64_t *v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t *v155;
  unint64_t v156;
  unint64_t *v157;
  unint64_t v158;
  uint64_t v159;
  unint64_t v160;
  char *v161;
  _DWORD *v162;
  char *v163;
  uint64_t v164;
  unint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  _DWORD *v170;
  int v171;
  _QWORD *v172;
  unsigned int v173;
  char *v174;
  char *v175;
  unsigned int *v176;
  unsigned int v177;
  unsigned int v178;
  unsigned int i;
  unsigned int v180;
  int v181;
  uint64_t v182;
  unint64_t v183;
  uint8x8_t v184;
  unint64_t v185;
  uint64_t **v186;
  uint64_t *v187;
  unint64_t v188;
  uint64_t v189;
  uint64_t v190;
  unsigned int v191;
  int v192;
  uint64_t v193;
  unint64_t v194;
  char *v195;
  unint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t *v199;
  char *v201;
  char *v202;
  _OWORD *v203;
  _QWORD *v205;
  uint64_t v206;
  uint64_t *v207;
  uint64_t *v208;
  _QWORD *v209;
  uint64_t v211;
  uint64_t *v212;
  uint64_t *v213;
  uint64_t *v214;
  uint64_t v215;
  uint64_t *v216;
  _QWORD *v217;
  uint64_t *v218;
  _QWORD *v219;
  unsigned int v220;
  uint64_t v221;
  unint64_t v222;
  int v223;
  __n128 *v224;
  unint64_t v225;
  int64_t v226;
  __int8 *v227;
  int v228;
  unint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  unint64_t v234;
  uint64_t v235;
  unsigned __int32 v236;
  int v237;
  uint64_t v238;
  unint64_t v239;
  int v240;
  char *v241;
  __n128 *v242;
  unsigned int *v243;
  int v244;
  _BYTE v246[32];
  __int128 v247;
  __int128 v248;
  void *__p;
  char *v250;
  unint64_t v251;
  void *v252[2];
  unsigned int v253[4];
  unsigned int v254[4];
  __int128 v255;
  void *v256[4];
  char *v257[3];
  unsigned int v258[7];
  unsigned int v259[3];

  v238 = a3[8];
  v241 = (char *)a3[9];
  v232 = *((_QWORD *)a1 + 53);
  v235 = *((_QWORD *)a1 + 54);
  v3 = *((_QWORD *)a1 + 38);
  v4 = *((_QWORD *)a1 + 39);
  if (-991146299 * ((unint64_t)(v4 - v3) >> 3))
  {
    v5 = 0;
    v216 = 0;
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = v3 + 104 * v7;
      if ((unint64_t)v216 >= v6)
      {
        v9 = v5;
        v10 = 0xAAAAAAAAAAAAAAABLL * (v216 - v5);
        v11 = v10 + 1;
        if (v10 + 1 > 0xAAAAAAAAAAAAAAALL)
          abort();
        v12 = v9;
        v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - (_QWORD)v9) >> 3);
        if (2 * v13 > v11)
          v11 = 2 * v13;
        if (v13 >= 0x555555555555555)
          v14 = 0xAAAAAAAAAAAAAAALL;
        else
          v14 = v11;
        if (v14)
          v14 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v14);
        else
          v15 = 0;
        v16 = v14 + 24 * v10;
        *(_QWORD *)v16 = *(_QWORD *)(v8 + 16);
        *(_DWORD *)(v16 + 8) = 0;
        *(_DWORD *)(v16 + 12) = *(_QWORD *)(v8 + 96);
        *(_QWORD *)(v16 + 16) = v7;
        v17 = v216;
        if (v216 == v12)
        {
          v5 = (uint64_t *)(v14 + 24 * v10);
        }
        else
        {
          v18 = v14 + 24 * v10;
          do
          {
            v5 = (uint64_t *)(v18 - 24);
            v19 = *(_OWORD *)(v17 - 3);
            *(_QWORD *)(v18 - 8) = *(v17 - 1);
            *(_OWORD *)(v18 - 24) = v19;
            v17 -= 3;
            v18 -= 24;
          }
          while (v17 != v12);
        }
        v6 = v14 + 24 * v15;
        v216 = (uint64_t *)(v16 + 24);
        if (v12)
          operator delete(v12);
      }
      else
      {
        *v216 = *(_QWORD *)(v8 + 16);
        *((_DWORD *)v216 + 2) = 0;
        *((_DWORD *)v216 + 3) = *(_QWORD *)(v8 + 96);
        v216[2] = v7;
        v216 += 3;
      }
      ++v7;
      v3 = *((_QWORD *)a1 + 38);
      v4 = *((_QWORD *)a1 + 39);
    }
    while (v7 < -991146299 * ((unint64_t)(v4 - v3) >> 3));
    v20 = a1;
  }
  else
  {
    v20 = a1;
    v5 = 0;
    v216 = 0;
    v6 = 0;
  }
  v21 = *((_QWORD *)v20 + 41);
  v22 = *((_QWORD *)v20 + 42);
  if (-1431655765 * ((unint64_t)(v22 - v21) >> 5))
  {
    v23 = 0;
    do
    {
      v24 = *(_QWORD *)(v21 + 96 * v23 + 16) + 200;
      if ((unint64_t)v216 >= v6)
      {
        v25 = v5;
        v26 = 0xAAAAAAAAAAAAAAABLL * (v216 - v5);
        v27 = v26 + 1;
        if (v26 + 1 > 0xAAAAAAAAAAAAAAALL)
          abort();
        v28 = v25;
        v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - (_QWORD)v25) >> 3);
        if (2 * v29 > v27)
          v27 = 2 * v29;
        if (v29 >= 0x555555555555555)
          v30 = 0xAAAAAAAAAAAAAAALL;
        else
          v30 = v27;
        if (v30)
          v30 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v30);
        else
          v31 = 0;
        v32 = (uint64_t *)(v30 + 24 * v26);
        *v32 = v24;
        v32[1] = 0xFFFFFFFF00000001;
        v32[2] = v23;
        v33 = v216;
        if (v216 == v28)
        {
          v5 = (uint64_t *)(v30 + 24 * v26);
        }
        else
        {
          v34 = v30 + 24 * v26;
          do
          {
            v5 = (uint64_t *)(v34 - 24);
            v35 = *(_OWORD *)(v33 - 3);
            *(_QWORD *)(v34 - 8) = *(v33 - 1);
            *(_OWORD *)(v34 - 24) = v35;
            v33 -= 3;
            v34 -= 24;
          }
          while (v33 != v28);
        }
        v6 = v30 + 24 * v31;
        v216 = v32 + 3;
        if (v28)
          operator delete(v28);
      }
      else
      {
        *v216 = v24;
        v216[1] = 0xFFFFFFFF00000001;
        v216[2] = v23;
        v216 += 3;
      }
      ++v23;
      v21 = *((_QWORD *)a1 + 41);
      v22 = *((_QWORD *)a1 + 42);
    }
    while (v23 < -1431655765 * ((unint64_t)(v22 - v21) >> 5));
    v20 = a1;
    v3 = *((_QWORD *)a1 + 38);
    v4 = *((_QWORD *)a1 + 39);
  }
  if (v21 != v22 && v3 != v4)
  {
    v36 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (v216 - v5));
    if (v216 == v5)
      v37 = 0;
    else
      v37 = v36;
    std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *,false>((uint64_t)v5, (unint64_t *)v216, v37, 1);
    v3 = *((_QWORD *)v20 + 38);
    v4 = *((_QWORD *)v20 + 39);
  }
  memset(v257, 0, sizeof(v257));
  v212 = v5;
  if (v3 != v4)
  {
    v38 = (uint64_t)(a3[9] - a3[8]) >> 3;
    v252[0] = 0;
    std::vector<unsigned long long>::resize(v257, v38, v252);
  }
  v207 = (uint64_t *)((char *)v20 + 304);
  v208 = (uint64_t *)((char *)v20 + 328);
  if (v5 != v216)
  {
    v202 = &v241[-v238];
    v203 = (_OWORD *)((char *)v20 + 360);
    v201 = (char *)(v235 - v232);
    v206 = *((_QWORD *)v20 + 46);
    v39 = (double)(unint64_t)(a3[1] - v206);
    v211 = (uint64_t)v20 + 448;
    v217 = (_QWORD *)((char *)v20 + 224);
    v209 = (_QWORD *)((char *)v20 + 64);
    v205 = (_QWORD *)((char *)v20 + 104);
    v40 = 0.0;
    v41 = v5;
    while (1)
    {
      v42 = *((_DWORD *)v41 + 2);
      v43 = v41[2];
      if (v42 != 1)
      {
        if (!v42)
        {
          v213 = v41;
          v44 = *v41;
          memset(v256, 0, 24);
          v45 = *v207 + 104 * v43;
          v46 = *(_DWORD *)v45;
          *(_OWORD *)v252 = *(_OWORD *)(v45 + 8);
          *(_OWORD *)v253 = *(_OWORD *)(v45 + 24);
          *(_OWORD *)v254 = *(_OWORD *)(v45 + 40);
          v255 = *(_OWORD *)(v45 + 56);
          std::vector<unsigned long long>::__assign_with_size[abi:nn180100]<unsigned long long *,unsigned long long *>((char *)v256, *(char **)(v45 + 72), *(_QWORD *)(v45 + 80), (uint64_t)(*(_QWORD *)(v45 + 80) - *(_QWORD *)(v45 + 72)) >> 3);
          if (v206 != v44 && *((_QWORD *)v20 + 53) != *((_QWORD *)v20 + 54) && *((_DWORD *)v20 + 88) == a2)
          {
            v47 = (void *)*((_QWORD *)v20 + 46);
            v48 = v252[1] >= v47;
            v49 = (char *)((char *)v252[1] - (char *)v47);
            if (v49 != 0 && v48 && (void *)a3[1] > v252[1] && (double)((unint64_t)v252[1] - v206) / v39 > 0.05)
            {
              __p = 0;
              v250 = 0;
              v251 = 0;
              v50 = v203[1];
              *(_OWORD *)v246 = *v203;
              *(_OWORD *)&v246[16] = v50;
              v51 = v203[3];
              v40 = (double)(unint64_t)v49 / v39;
              v247 = v203[2];
              v248 = v51;
              *(void **)&v246[8] = v252[1];
              if (v202 == v201)
              {
                *(_QWORD *)&v246[16] = (unint64_t)(v40 * (double)(unint64_t)a3[2]);
                std::vector<unsigned long long>::reserve(&__p, (uint64_t)(a3[9] - a3[8]) >> 3);
                v52 = a3[8];
                if (((a3[9] - v52) & 0x7FFFFFFF8) != 0)
                {
                  v53 = 0;
                  v54 = v257[0];
                  do
                  {
                    v55 = (unint64_t)(v40 * (double)*(unint64_t *)(v52 + 8 * v53));
                    v56 = *(_QWORD *)&v54[8 * v53];
                    *(_QWORD *)&v54[8 * v53] = v55;
                    if (((*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v20 + 61) + 208) + ((v53 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v53) & 1) != 0)
                      v57 = v55 - v56;
                    else
                      v57 = (unint64_t)((1.0 - v40)
                                             * (double)*(unint64_t *)(*((_QWORD *)v20 + 53) + 8 * v53))
                          + v55;
                    v58 = v250;
                    if ((unint64_t)v250 >= v251)
                    {
                      v60 = (char *)__p;
                      v61 = (v250 - (_BYTE *)__p) >> 3;
                      v62 = v61 + 1;
                      if ((unint64_t)(v61 + 1) >> 61)
                        abort();
                      v63 = v251 - (_QWORD)__p;
                      if ((uint64_t)(v251 - (_QWORD)__p) >> 2 > v62)
                        v62 = v63 >> 2;
                      v48 = (unint64_t)v63 >= 0x7FFFFFFFFFFFFFF8;
                      v64 = 0x1FFFFFFFFFFFFFFFLL;
                      if (!v48)
                        v64 = v62;
                      if (v64)
                      {
                        v64 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v64);
                        v60 = (char *)__p;
                        v58 = v250;
                      }
                      else
                      {
                        v65 = 0;
                      }
                      v66 = (unint64_t *)(v64 + 8 * v61);
                      *v66 = v57;
                      v59 = (char *)(v66 + 1);
                      while (v58 != v60)
                      {
                        v67 = *((_QWORD *)v58 - 1);
                        v58 -= 8;
                        *--v66 = v67;
                      }
                      __p = v66;
                      v250 = v59;
                      v251 = v64 + 8 * v65;
                      if (v60)
                        operator delete(v60);
                    }
                    else
                    {
                      *(_QWORD *)v250 = v57;
                      v59 = v58 + 8;
                    }
                    v250 = v59;
                    ++v53;
                    v52 = a3[8];
                  }
                  while (v53 < ((unint64_t)(a3[9] - v52) >> 3));
                }
                GRCPerFrameData::AddLimiterCounterSample(v20, a2, v246, 0);
                v206 = *(_QWORD *)&v246[8];
                if (__p)
                {
                  v250 = (char *)__p;
                  operator delete(__p);
                }
              }
            }
          }
          v68 = v20;
          v259[0] = v46;
          v69 = std::__hash_table<std::__hash_value_type<unsigned int,RingBufferSampledData>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RingBufferSampledData>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v211, v46, v259);
          v70 = v254[0];
          v71 = v253[2];
          v72 = v252[1];
          ProgramAddressHelper::UpdateActiveEncoderRef(v68, v46, v254[0], v253[2], (unint64_t)v252[1]);
          v73 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>(v205, v70);
          if (v73)
            v74 = *((_DWORD *)v73 + 5);
          else
            v74 = -1;
          v181 = *(_DWORD *)(v69 + 24) & 0x3FFFFFF;
          *(_DWORD *)v246 = v71 & 0xF;
          *(_DWORD *)&v246[4] = v181;
          *(_DWORD *)&v246[8] = v74;
          *(_QWORD *)&v246[12] = v72;
          *(_DWORD *)&v246[20] = v70;
          objc_msgSend(*(id *)(v69 + 88), "appendBytes:length:", v246, 24, v201, v202, v203);
          *(_QWORD *)v258 = *(_QWORD *)&v254[2];
          objc_msgSend(*(id *)(v69 + 96), "appendBytes:length:", v258, 24);
          v182 = *((_QWORD *)v68 + 61);
          v183 = *(_QWORD *)(v182 + 136);
          if (v183)
          {
            v184 = (uint8x8_t)vcnt_s8((int8x8_t)v183);
            v184.i16[0] = vaddlv_u8(v184);
            if (v184.u32[0] > 1uLL)
            {
              v185 = v70;
              if (v183 <= v70)
                v185 = v70 % v183;
            }
            else
            {
              v185 = ((_DWORD)v183 - 1) & v70;
            }
            v186 = *(uint64_t ***)(*(_QWORD *)(v182 + 128) + 8 * v185);
            if (v186)
            {
              v187 = *v186;
              if (v187)
              {
                v244 = *((_DWORD *)v68 + 134);
                do
                {
                  v188 = v187[1];
                  if (v188 == v70)
                  {
                    if (*((_DWORD *)v187 + 4) == v70)
                    {
                      v190 = v187[3];
                      v189 = v187[4];
                      while (v190 != v189)
                      {
                        v191 = *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(*((_QWORD *)v68 + 61) + 168, *(_DWORD *)v190, (_DWORD *)v190)+ 5);
                        if (v191 != v70)
                        {
                          ProgramAddressHelper::UpdateActiveEncoderRef(v68, v46, v191, v71, (unint64_t)v72);
                          if (v244 != 2)
                          {
                            v192 = *(_DWORD *)(v69 + 24) & 0x3FFFFFF;
                            *(_DWORD *)v246 = v71 & 0xF;
                            *(_DWORD *)&v246[4] = v192;
                            *(_DWORD *)&v246[8] = *(_DWORD *)v190;
                            *(_QWORD *)&v246[12] = v72;
                            *(_DWORD *)&v246[20] = v191;
                            objc_msgSend(*(id *)(v69 + 88), "appendBytes:length:", v246, 24);
                            *(_QWORD *)v258 = *(_QWORD *)(v190 + 8);
                            objc_msgSend(*(id *)(v69 + 96), "appendBytes:length:", v258, 24);
                          }
                        }
                        v190 += 16;
                      }
                      break;
                    }
                  }
                  else
                  {
                    if (v184.u32[0] > 1uLL)
                    {
                      if (v188 >= v183)
                        v188 %= v183;
                    }
                    else
                    {
                      v188 &= v183 - 1;
                    }
                    if (v188 != v185)
                      break;
                  }
                  v187 = (uint64_t *)*v187;
                }
                while (v187);
              }
            }
          }
          if (v256[0])
            operator delete(v256[0]);
          v5 = v212;
          v41 = v213;
          v20 = v68;
        }
        goto LABEL_277;
      }
      v214 = v41;
      v75 = *v208;
      v258[0] = a2;
      v230 = std::__hash_table<std::__hash_value_type<unsigned int,RingBufferSampledData>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RingBufferSampledData>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v211, a2, v258);
      v76 = v75 + 96 * v43;
      v77 = *(_QWORD *)(v76 + 80);
      v219 = (_QWORD *)(v76 + 80);
      v79 = (uint64_t *)(v76 + 72);
      v78 = *(_QWORD *)(v76 + 72);
      v218 = v79;
      v80 = v77 - v78;
      if (v77 == v78)
      {
        v215 = v78;
        v81 = 0;
        v83 = 0;
      }
      else
      {
        if ((unint64_t)v80 >= 0x6666666666666661)
          abort();
        v81 = (__n128 *)std::__allocate_at_least[abi:nn180100]<std::allocator<DYMTLShaderProfilerProcessedUSCSample>>(v80 >> 3);
        v83 = (__n128 *)((char *)v81 + 20 * v82);
        v215 = *v218;
        v80 = *v219 - *v218;
      }
      v246[0] = 0;
      std::vector<BOOL>::vector(v252, v80 >> 2, v246);
      v231 = v75 + 96 * v43 + 8;
      v84 = *v218;
      if (*v219 == *v218)
      {
        v129 = 0;
        v130 = v81;
      }
      else
      {
        v85 = 0;
        v86 = 0;
        v87 = 0;
        v242 = v81;
        v88 = v83;
        do
        {
          v89 = 0;
          v90 = v84 + 8 * v85;
          v226 = (char *)v81 - (char *)v242;
          v228 = v87;
          v239 = (2 * v87);
          v236 = v239 + 8;
          v91 = 1;
          v233 = v90;
          do
          {
            if ((*(_DWORD *)(v90 + 4 * v89) & 1) != 0)
            {
              if (0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*((_QWORD *)v20 + 1) - *(_QWORD *)v20) >> 3) <= (unint64_t)v258[0])
              {
                LOWORD(v118) = -1;
                LODWORD(v101) = -1;
              }
              else
              {
                v92 = *(_QWORD *)v20 + 88 * v258[0];
                v93 = *(_QWORD **)(v92 + 40);
                v94 = (_QWORD *)(v92 + 48);
                if (v93 == (_QWORD *)(v92 + 48))
                {
                  LOWORD(v118) = -1;
                  LODWORD(v101) = -1;
                }
                else
                {
                  v95 = *(_DWORD *)(v90 + 4 * v91);
                  v96 = *(_QWORD *)(v231 + 8);
                  v97 = *(int8x8_t *)((char *)v20 + 32);
                  v98 = (uint8x8_t)vcnt_s8(v97);
                  v98.i16[0] = vaddlv_u8(v98);
                  v99 = v98.u32[0];
                  v100 = *(_QWORD *)&v97 + 0xFFFFFFFFLL;
                  do
                  {
                    if (v97)
                    {
                      v101 = *((unsigned int *)v93 + 7);
                      if (v99 > 1)
                      {
                        v102 = *((unsigned int *)v93 + 7);
                        if (*(_QWORD *)&v97 <= v101)
                          v102 = v101 % *(_QWORD *)&v97;
                      }
                      else
                      {
                        v102 = v100 & v101;
                      }
                      v103 = *(uint64_t **)(*((_QWORD *)a1 + 3) + 8 * v102);
                      if (v103)
                      {
                        while (1)
                        {
                          v103 = (uint64_t *)*v103;
                          if (!v103)
                            break;
                          v104 = v103[1];
                          if (v104 == v101)
                          {
                            if (*((_DWORD *)v103 + 4) == (_DWORD)v101)
                            {
                              if ((unint64_t)v103[5] >= 2)
                              {
                                v107 = v103[4];
                                v105 = v103 + 4;
                                v106 = v107;
                                if (v107)
                                {
                                  v108 = v105;
                                  do
                                  {
                                    v109 = *(_DWORD *)(v106 + 28);
                                    if (v95 == v109)
                                    {
                                      if ((unsigned __int16)*(_DWORD *)(v106 + 32))
                                        v110 = 1;
                                      else
                                        v110 = HIWORD(*(_DWORD *)(v106 + 32)) > 0x66u;
                                      v111 = v110;
                                    }
                                    else
                                    {
                                      v111 = v95 < v109;
                                    }
                                    v112 = !v111;
                                    if (v111)
                                      v113 = (uint64_t *)v106;
                                    else
                                      v113 = (uint64_t *)(v106 + 8);
                                    if (!v112)
                                      v108 = (uint64_t *)v106;
                                    v106 = *v113;
                                  }
                                  while (*v113);
                                  if (v105 != v108)
                                  {
                                    v114 = *((_DWORD *)v108 + 8);
                                    if ((unsigned __int16)v114 == 2)
                                    {
                                      if ((v114 & 0xFFFE0000 | 0x10000) != 0x650000)
                                        goto LABEL_172;
                                      v221 = v100;
                                      v222 = v96;
                                      v224 = v88;
                                      v223 = v86;
                                      v220 = v114;
                                      v115 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>(v217, v101);
                                      v114 = v220;
                                      v100 = v221;
                                      v96 = v222;
                                      v86 = v223;
                                      v90 = v233;
                                      v88 = v224;
                                      if (v115)
                                      {
                                        if (v115[3] <= v222 && v115[4] >= v222)
                                        {
LABEL_172:
                                          v118 = HIWORD(v114);
                                          goto LABEL_149;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              break;
                            }
                          }
                          else
                          {
                            if (v99 > 1)
                            {
                              if (v104 >= *(_QWORD *)&v97)
                                v104 %= *(_QWORD *)&v97;
                            }
                            else
                            {
                              v104 &= *(_QWORD *)&v97 - 1;
                            }
                            if (v104 != v102)
                              break;
                          }
                        }
                      }
                    }
                    v116 = (_QWORD *)v93[1];
                    if (v116)
                    {
                      do
                      {
                        v117 = v116;
                        v116 = (_QWORD *)*v116;
                      }
                      while (v116);
                    }
                    else
                    {
                      do
                      {
                        v117 = (_QWORD *)v93[2];
                        v112 = *v117 == (_QWORD)v93;
                        v93 = v117;
                      }
                      while (!v112);
                    }
                    v93 = v117;
                  }
                  while (v117 != v94);
                  LOWORD(v118) = -1;
                  LODWORD(v101) = -1;
LABEL_149:
                  v20 = a1;
                }
              }
              v119 = v89 + v239;
              if (v242 != v81)
              {
                v81[-1].n128_u32[1] += v86;
                v81[-1].n128_u32[2] = v119;
              }
              if (v81 >= v88)
              {
                v120 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v81 - (char *)v242) >> 2) + 1;
                if (v120 > 0xCCCCCCCCCCCCCCCLL)
                  abort();
                if (0x999999999999999ALL * (((char *)v88 - (char *)v242) >> 2) > v120)
                  v120 = 0x999999999999999ALL * (((char *)v88 - (char *)v242) >> 2);
                if (0xCCCCCCCCCCCCCCCDLL * (((char *)v88 - (char *)v242) >> 2) >= 0x666666666666666)
                  v121 = 0xCCCCCCCCCCCCCCCLL;
                else
                  v121 = v120;
                v122 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<DYMTLShaderProfilerProcessedUSCSample>>(v121);
                v124 = &v122[4 * (((char *)v81 - (char *)v242) >> 2)];
                *(_DWORD *)v124 = v101;
                *((_DWORD *)v124 + 1) = v119;
                *((_DWORD *)v124 + 2) = 0;
                *((_DWORD *)v124 + 3) = v236;
                *((_WORD *)v124 + 8) = v118;
                if (v242 == v81)
                {
                  v127 = v81;
                  v242 = (__n128 *)&v122[4 * (((char *)v81 - (char *)v242) >> 2)];
                }
                else
                {
                  v125 = (__n128 *)&v122[4 * (((char *)v81 - (char *)v242) >> 2)];
                  do
                  {
                    v126 = *(__n128 *)((char *)v81 - 20);
                    v125[-1].n128_u32[3] = v81[-1].n128_u32[3];
                    *(__n128 *)((char *)v125 - 20) = v126;
                    v125 = (__n128 *)((char *)v125 - 20);
                    v81 = (__n128 *)((char *)v81 - 20);
                  }
                  while (v81 != v242);
                  v127 = v242;
                  v242 = v125;
                }
                v88 = (__n128 *)&v122[20 * v123];
                v81 = (__n128 *)(v124 + 20);
                if (v127)
                {
                  v128 = &v122[20 * v123];
                  operator delete(v127);
                  v88 = (__n128 *)v128;
                }
                v86 = 0;
                v90 = v233;
              }
              else
              {
                v86 = 0;
                v81->n128_u32[0] = v101;
                v81->n128_u32[1] = v119;
                v81->n128_u32[2] = 0;
                v81->n128_u32[3] = v236;
                v81[1].n128_u16[0] = v118;
                v81 = (__n128 *)((char *)v81 + 20);
              }
            }
            else
            {
              v91 = v89;
            }
            v89 = v91 + 1;
            v91 += 2;
          }
          while (v91 < 8);
          v129 = (char *)v81 - (char *)v242;
          if (v226 == (char *)v81 - (char *)v242)
          {
            ++v86;
            *(_QWORD *)((char *)v252[0] + ((v239 >> 3) & 0x1FFFFFF8)) |= 1 << (v239 & 0x38);
          }
          v85 = (v228 + 4);
          v84 = *v218;
          v87 = v228 + 4;
        }
        while (v85 < (*v219 - *v218) >> 3);
        v130 = v242;
      }
      v131 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * (v129 >> 2));
      v132 = v81 == v130 ? 0 : v131;
      std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo *,false>(v130, v81, v132, 1);
      BufferView<unsigned long long>::BufferView(v246, *(void **)(v230 + 56));
      v133 = v130;
      if (v81 != v130)
        break;
LABEL_251:
      if (v252[0])
        operator delete(v252[0]);
      v5 = v212;
      v20 = a1;
      if (v133)
        operator delete(v133);
      v41 = v214;
LABEL_277:
      v41 += 3;
      if (v41 == v216)
        goto LABEL_285;
    }
    v134 = 0;
    v135 = ((char *)v81 - (char *)v130) / 20;
    v225 = v135 - 1;
    v227 = &v130[2].n128_i8[8];
    v136 = v135 - 2;
    v234 = v135;
    v229 = v135 - 2;
    while (1)
    {
      v137 = (_DWORD *)v133 + 5 * v134;
      v138 = v137[2];
      v139 = v137[3] - v137[1];
      v140 = (unsigned __int16 *)(v137 + 4);
      v243 = v137;
      if (v134 + 1 >= v135)
      {
        v144 = v134;
        v142 = v230;
      }
      else
      {
        v141 = *v137;
        v142 = v230;
        if (*v137 == v133[1].n128_u32[5 * v134 + 1])
        {
          v143 = &v227[20 * v134];
          v144 = v134;
          while (*v140 == *((unsigned __int16 *)v143 - 2))
          {
            v139 = *((_DWORD *)v143 - 2) + v139 - *((_DWORD *)v143 - 4);
            v138 += *((_DWORD *)v143 - 3);
            if (v136 == v144)
            {
              v144 = v225;
              break;
            }
            v145 = *(_DWORD *)v143;
            v143 += 20;
            ++v144;
            if (v141 != v145)
              break;
          }
        }
        else
        {
          v144 = v134;
        }
      }
      v240 = v139 + 7;
      v237 = ((v139 + 7) >> 3) - v138;
      v146 = (4 * v237) | 1;
      if ((unint64_t)objc_msgSend(*(id *)(v142 + 72), "length", v201, v202, v203) < 8
                                                                                          * (unint64_t)(v146 + *(_DWORD *)(v142 + 84)))
        objc_msgSend(*(id *)(v142 + 72), "increaseLengthBy:", objc_msgSend(*(id *)(v142 + 72), "length"));
      v147 = (unint64_t *)((char *)objc_msgSend(*(id *)(v142 + 72), "mutableBytes")
                                + 8 * *(unsigned int *)(v142 + 84));
      v148 = *(_DWORD *)(v142 + 24);
      v149 = v148 & 0x3FFFFFF;
      if ((v148 & 0x3FFFFFF) == 0)
      {
        v154 = *v147 & 0x7FFFFFFFFFLL;
LABEL_220:
        *v147 = v154;
        v159 = v230;
        v161 = *(char **)(v230 + 120);
        v160 = *(_QWORD *)(v230 + 128);
        if ((unint64_t)v161 >= v160)
        {
          v163 = *(char **)(v230 + 112);
          v164 = (v161 - v163) >> 2;
          v165 = v164 + 1;
          if ((unint64_t)(v164 + 1) >> 62)
            abort();
          v166 = v160 - (_QWORD)v163;
          if (v166 >> 1 > v165)
            v165 = v166 >> 1;
          v48 = (unint64_t)v166 >= 0x7FFFFFFFFFFFFFFCLL;
          v167 = 0x3FFFFFFFFFFFFFFFLL;
          if (!v48)
            v167 = v165;
          if (v167)
          {
            v167 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v167);
            v169 = v230;
            v163 = *(char **)(v230 + 112);
            v161 = *(char **)(v230 + 120);
          }
          else
          {
            v168 = 0;
            v169 = v230;
          }
          v170 = (_DWORD *)(v167 + 4 * v164);
          *v170 = *(_DWORD *)(v169 + 84);
          v162 = v170 + 1;
          while (v161 != v163)
          {
            v171 = *((_DWORD *)v161 - 1);
            v161 -= 4;
            *--v170 = v171;
          }
          *(_QWORD *)(v230 + 112) = v170;
          *(_QWORD *)(v230 + 120) = v162;
          *(_QWORD *)(v230 + 128) = v167 + 4 * v168;
          if (v163)
            operator delete(v163);
          v159 = v230;
        }
        else
        {
          *(_DWORD *)v161 = *(_DWORD *)(v230 + 84);
          v162 = v161 + 4;
        }
        *(_QWORD *)(v159 + 120) = v162;
        *(_DWORD *)(v159 + 84) += v146;
        *v147 = *v147 & 0xFFFFFF8000000000 | *v243 | ((unint64_t)(v237 & 0x7F) << 32);
        v172 = v147 + 1;
        ++*(_DWORD *)(v159 + 80);
        if (v134 <= v144)
        {
          v173 = 0;
          v174 = (char *)v252[0];
          do
          {
            v175 = (char *)v133 + 20 * v134;
            v178 = *((_DWORD *)v175 + 3);
            v176 = (unsigned int *)(v175 + 12);
            v177 = v178;
            for (i = *(v176 - 2); i < v177; ++i)
            {
              if (((*(_QWORD *)&v174[((unint64_t)i >> 3) & 0x1FFFFFF8] >> i) & 1) != 0)
              {
                i += 8;
              }
              else
              {
                *((_DWORD *)v172 + v173++) = *(_DWORD *)(v215 + 4 * i);
                v177 = *v176;
              }
            }
            ++v134;
          }
          while (v134 <= v144);
        }
        else
        {
          v173 = 0;
        }
        if ((v240 & 0xFFFFFFF8) != v139)
        {
          v180 = (v240 & 0xFFFFFFF8) - v139;
          if (v180 <= 1)
            v180 = 1;
          do
          {
            *((_DWORD *)v172 + v173++) = 0;
            --v180;
          }
          while (v180);
        }
        goto LABEL_250;
      }
      v150 = *v243;
      if (*v243 == -1)
      {
        v154 = *v147 & 0x7FFFFFFFFFLL | ((unint64_t)(v148 - 1) << 39);
        goto LABEL_220;
      }
      v151 = *v140;
      if (v151 > 0x63)
        break;
      switch(v151)
      {
        case 1u:
          v153 = 0;
          break;
        case 2u:
          goto LABEL_207;
        case 3u:
          v152 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>(v209, *v243);
          v153 = 1;
          if (!v152)
            v153 = 2;
          break;
        default:
          goto LABEL_250;
      }
LABEL_209:
      v155 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>((_QWORD *)a1 + 5 * v153 + 23, v150);
      if (v155)
      {
        v156 = v155[4];
        if (v156 == -1)
        {
          v156 = v155[3];
          if (v156 <= *(_QWORD *)(v231 + 8))
            v156 = *(_QWORD *)(v231 + 8);
        }
        else if (v156 >= *(_QWORD *)(v231 + 8))
        {
          v156 = *(_QWORD *)(v231 + 8);
        }
        v157 = (unint64_t *)(*(_QWORD *)v246 + 8 * (v149 - 1));
        do
        {
          if (!--v149)
            break;
          v158 = *v157--;
        }
        while (v158 >= v156);
        v154 = *v147 & 0x7FFFFFFFFFLL | ((unint64_t)v149 << 39);
        goto LABEL_220;
      }
LABEL_250:
      v134 = v144 + 2;
      v135 = v234;
      v136 = v229;
      if (v144 + 2 >= v234)
        goto LABEL_251;
    }
    if (v151 - 100 >= 2)
      goto LABEL_250;
LABEL_207:
    v153 = 1;
    goto LABEL_209;
  }
  v40 = 0.0;
LABEL_285:
  if (*((_QWORD *)v20 + 38) == *((_QWORD *)v20 + 39))
  {
    v195 = v257[0];
    goto LABEL_293;
  }
  v193 = a3[8];
  v194 = a3[9] - v193;
  v195 = v257[0];
  if ((v194 & 0x7FFFFFFF8) == 0)
  {
LABEL_293:
    v199 = &qword_4A5000;
    goto LABEL_294;
  }
  v196 = 0;
  v197 = *(_QWORD *)(*((_QWORD *)v20 + 61) + 208);
  v198 = (v194 >> 3);
  v199 = &qword_4A5000;
  do
  {
    if (((*(_QWORD *)(v197 + ((v196 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v196) & 1) != 0)
      *(_QWORD *)(v193 + 8 * v196) -= *(_QWORD *)&v195[8 * v196];
    ++v196;
  }
  while (v198 != v196);
LABEL_294:
  std::vector<std::tuple<unsigned int,SampleInfoWithPayload,unsigned long long>>::__clear[abi:nn180100](v207);
  std::vector<std::pair<unsigned int,SampleInfoWithPayload>>::__clear[abi:nn180100](v208);
  if (v195)
    operator delete(v195);
  if (v5)
    operator delete(v5);
  return 1.0 - v40 > *((double *)v199 + 28);
}

void sub_2F72EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *__p,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,void *a63)
{
  uint64_t v63;
  void *v65;

  if (__p)
    operator delete(__p);
  if (a63)
    operator delete(a63);
  v65 = *(void **)(v63 - 192);
  if (v65)
    operator delete(v65);
  if (a22)
    operator delete(a22);
  _Unwind_Resume(exception_object);
}

void std::vector<std::unique_ptr<GRCPerFrameData::PriorityQueueElement>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
          std::default_delete<GRCPerFrameData::PriorityQueueElement>::operator()[abi:nn180100](v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *,false>(uint64_t result, unint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v7;
  unint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t i;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unsigned int v21;
  unsigned int v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unsigned int v26;
  unsigned int v27;
  unint64_t v28;
  _QWORD *k;
  unsigned int v30;
  unsigned int v31;
  unint64_t v32;
  unint64_t v33;
  unsigned int v34;
  unsigned int v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  int v39;
  int v40;
  uint64_t v41;
  unint64_t v42;
  unsigned int v43;
  unsigned int v44;
  unint64_t v45;
  unsigned int v46;
  unsigned int v47;
  BOOL v48;
  unint64_t v49;
  unsigned int v50;
  unsigned int v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unsigned int v56;
  unsigned int v57;
  _QWORD *j;
  unsigned int v59;
  unsigned int v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  int v66;
  int v67;
  unsigned int v68;
  unsigned int v69;
  unint64_t v70;
  unint64_t v71;
  unsigned int v72;
  unsigned int v73;
  unsigned int v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  BOOL v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unsigned int v86;
  unsigned int v87;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t v93;
  unsigned int v94;
  unsigned int v95;
  uint64_t v96;
  int v97;
  int64_t v98;
  int64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  unsigned int v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  unint64_t v110;
  unsigned int v111;
  unsigned int v112;
  int64_t v113;
  unint64_t *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  unint64_t v123;
  unint64_t v124;
  uint64_t v125;
  unint64_t v126;
  unsigned int v127;
  unsigned int v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  unint64_t v132;
  unsigned int v133;
  unsigned int v134;
  unint64_t *v136;
  unint64_t v137;
  unsigned int v138;
  unsigned int v139;
  unint64_t v140;
  unint64_t v141;
  uint64_t v142;
  unint64_t v143;
  unint64_t v144;
  int v145;
  unsigned int v146;
  unsigned int v147;
  unint64_t v148;
  unint64_t v149;
  unsigned int v150;
  int v151;
  int64_t v152;
  int v153;
  int64_t v154;
  unint64_t v155;
  unint64_t v156;

  v7 = result;
LABEL_2:
  v8 = a2 - 3;
  v9 = (uint64_t)(a2 - 6);
  v10 = (uint64_t)(a2 - 9);
  i = v7;
  v156 = (unint64_t)a2;
  while (2)
  {
    v7 = i;
    v12 = (uint64_t)a2 - i;
    v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - i) >> 3);
    switch(v13)
    {
      case 0:
      case 1:
        return result;
      case 2:
        result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>((uint64_t)v8, v7);
        if ((_DWORD)result)
        {
          v78 = *(_QWORD *)v7;
          *(_QWORD *)v7 = *(a2 - 3);
          *(a2 - 3) = v78;
          LODWORD(v78) = *(_DWORD *)(v7 + 8);
          *(_DWORD *)(v7 + 8) = *((_DWORD *)a2 - 4);
          *((_DWORD *)a2 - 4) = v78;
          LODWORD(v78) = *(_DWORD *)(v7 + 12);
          *(_DWORD *)(v7 + 12) = *((_DWORD *)a2 - 3);
          *((_DWORD *)a2 - 3) = v78;
          v79 = *(_QWORD *)(v7 + 16);
          *(_QWORD *)(v7 + 16) = *(a2 - 1);
          *(a2 - 1) = v79;
        }
        return result;
      case 3:
        return std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(v7, v7 + 24, (uint64_t)v8);
      case 4:
        return std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(v7, v7 + 24, v7 + 48, (uint64_t)v8);
      case 5:
        return std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(v7, v7 + 24, v7 + 48, v7 + 72, (uint64_t)v8);
      default:
        if (v12 > 575)
        {
          if (!a3)
          {
            if ((unint64_t *)v7 != a2)
            {
              v98 = (unint64_t)(v13 - 2) >> 1;
              v154 = v98;
              do
              {
                v99 = v98;
                if (v154 >= v98)
                {
                  v100 = (2 * v98) | 1;
                  v101 = v7 + 24 * v100;
                  if (2 * v98 + 2 < v13
                    && std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(v7 + 24 * v100, v101 + 24))
                  {
                    v101 += 24;
                    v100 = 2 * v99 + 2;
                  }
                  v102 = v7 + 24 * v99;
                  result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(v101, v102);
                  a2 = (unint64_t *)v156;
                  if ((result & 1) == 0)
                  {
                    v103 = *(_QWORD *)v102;
                    v104 = *(unsigned int *)(v102 + 8);
                    v105 = *(_DWORD *)(v102 + 12);
                    v148 = *(_QWORD *)(v102 + 16);
                    *(_QWORD *)v102 = *(_QWORD *)v101;
                    *(_DWORD *)(v102 + 8) = *(_DWORD *)(v101 + 8);
                    *(_DWORD *)(v102 + 12) = *(_DWORD *)(v101 + 12);
                    *(_QWORD *)(v102 + 16) = *(_QWORD *)(v101 + 16);
                    if (v154 >= v100)
                    {
                      v152 = v99;
                      v150 = v105;
                      while (1)
                      {
                        v106 = v101;
                        v107 = 2 * v100;
                        v100 = (2 * v100) | 1;
                        v101 = v7 + 24 * v100;
                        v108 = v107 + 2;
                        if (v107 + 2 < v13)
                        {
                          v109 = v104;
                          result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(v7 + 24 * v100, v101 + 24);
                          v105 = v150;
                          v104 = v109;
                          v99 = v152;
                          if ((_DWORD)result)
                          {
                            v101 += 24;
                            v100 = v108;
                          }
                        }
                        v110 = *(_QWORD *)v101;
                        if (*(_QWORD *)v101 < v103)
                          break;
                        v111 = *(_DWORD *)(v101 + 8);
                        if (v103 >= v110)
                        {
                          if (v111 < v104)
                            break;
                          if (v104 >= v111)
                          {
                            v112 = *(_DWORD *)(v101 + 12);
                            if (v112 < v105 || v105 >= v112 && *(_QWORD *)(v101 + 16) < v148)
                              break;
                          }
                        }
                        *(_QWORD *)v106 = v110;
                        *(_DWORD *)(v106 + 8) = v111;
                        *(_DWORD *)(v106 + 12) = *(_DWORD *)(v101 + 12);
                        *(_QWORD *)(v106 + 16) = *(_QWORD *)(v101 + 16);
                        if (v154 < v100)
                          goto LABEL_179;
                      }
                      v101 = v106;
                    }
LABEL_179:
                    *(_QWORD *)v101 = v103;
                    *(_DWORD *)(v101 + 8) = v104;
                    *(_DWORD *)(v101 + 12) = v105;
                    *(_QWORD *)(v101 + 16) = v148;
                    a2 = (unint64_t *)v156;
                  }
                }
                v98 = v99 - 1;
              }
              while (v99);
              v113 = v12 / 0x18uLL;
              do
              {
                v114 = a2;
                v115 = 0;
                v151 = *(_DWORD *)(v7 + 12);
                v153 = *(_DWORD *)(v7 + 8);
                v149 = *(_QWORD *)(v7 + 16);
                v116 = v113 - 2;
                v155 = *(_QWORD *)v7;
                if (v113 < 2)
                  v116 = v113 - 1;
                v117 = v116 >> 1;
                v118 = v7;
                do
                {
                  v119 = v118 + 24 * v115 + 24;
                  v120 = (2 * v115) | 1;
                  v121 = 2 * v115 + 2;
                  if (v121 < v113)
                  {
                    result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(v118 + 24 * v115 + 24, v118 + 24 * v115 + 48);
                    if ((_DWORD)result)
                    {
                      v119 += 24;
                      v120 = v121;
                    }
                  }
                  *(_QWORD *)v118 = *(_QWORD *)v119;
                  *(_DWORD *)(v118 + 8) = *(_DWORD *)(v119 + 8);
                  *(_DWORD *)(v118 + 12) = *(_DWORD *)(v119 + 12);
                  *(_QWORD *)(v118 + 16) = *(_QWORD *)(v119 + 16);
                  v118 = v119;
                  v115 = v120;
                }
                while (v120 <= v117);
                if ((unint64_t *)v119 == v114 - 3)
                {
                  *(_QWORD *)v119 = v155;
                  *(_DWORD *)(v119 + 8) = v153;
                  *(_DWORD *)(v119 + 12) = v151;
                  *(_QWORD *)(v119 + 16) = v149;
                  goto LABEL_206;
                }
                *(_QWORD *)v119 = *(v114 - 3);
                *(_DWORD *)(v119 + 8) = *((_DWORD *)v114 - 4);
                *(_DWORD *)(v119 + 12) = *((_DWORD *)v114 - 3);
                *(_QWORD *)(v119 + 16) = *(v114 - 1);
                *(v114 - 3) = v155;
                *((_DWORD *)v114 - 4) = v153;
                *((_DWORD *)v114 - 3) = v151;
                *(v114 - 1) = v149;
                v122 = v119 - v7 + 24;
                if (v122 >= 25)
                {
                  v123 = -2 - 0x5555555555555555 * (v122 >> 3);
                  v124 = v123 >> 1;
                  v125 = v7 + 24 * (v123 >> 1);
                  result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(v125, v119);
                  if ((_DWORD)result)
                  {
                    v126 = *(_QWORD *)v119;
                    v127 = *(_DWORD *)(v119 + 8);
                    v128 = *(_DWORD *)(v119 + 12);
                    v129 = *(_QWORD *)(v119 + 16);
                    *(_QWORD *)v119 = *(_QWORD *)v125;
                    *(_DWORD *)(v119 + 8) = *(_DWORD *)(v125 + 8);
                    *(_DWORD *)(v119 + 12) = *(_DWORD *)(v125 + 12);
                    *(_QWORD *)(v119 + 16) = *(_QWORD *)(v125 + 16);
                    if (v123 < 2)
                      goto LABEL_205;
                    while (1)
                    {
                      v130 = v125;
                      v131 = v124 - 1;
                      v124 = (v124 - 1) >> 1;
                      v125 = v7 + 24 * v124;
                      v132 = *(_QWORD *)v125;
                      if (*(_QWORD *)v125 >= v126)
                      {
                        if (v126 < v132
                          || (v133 = *(_DWORD *)(v125 + 8), v133 >= v127)
                          && (v127 < v133
                           || (v134 = *(_DWORD *)(v125 + 12), v134 >= v128)
                           && (v128 < v134 || *(_QWORD *)(v125 + 16) >= v129)))
                        {
                          v125 = v130;
LABEL_205:
                          *(_QWORD *)v125 = v126;
                          *(_DWORD *)(v125 + 8) = v127;
                          *(_DWORD *)(v125 + 12) = v128;
                          *(_QWORD *)(v125 + 16) = v129;
                          break;
                        }
                      }
                      else
                      {
                        v133 = *(_DWORD *)(v125 + 8);
                      }
                      *(_QWORD *)v130 = v132;
                      *(_DWORD *)(v130 + 8) = v133;
                      *(_DWORD *)(v130 + 12) = *(_DWORD *)(v125 + 12);
                      *(_QWORD *)(v130 + 16) = *(_QWORD *)(v125 + 16);
                      if (v131 <= 1)
                        goto LABEL_205;
                    }
                  }
                }
LABEL_206:
                a2 = v114 - 3;
              }
              while (v113-- > 2);
            }
            return result;
          }
          v14 = (unint64_t)v13 >> 1;
          v15 = (unint64_t *)(v7 + 24 * ((unint64_t)v13 >> 1));
          if ((unint64_t)v12 < 0xC01)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>((uint64_t)v15, v7, (uint64_t)v8);
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(v7, (uint64_t)v15, (uint64_t)v8);
            v16 = 3 * v14;
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(v7 + 24, v7 + 8 * v16 - 24, v9);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(v7 + 48, v7 + 24 + 8 * v16, v10);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(v7 + 8 * v16 - 24, (uint64_t)v15, v7 + 24 + 8 * v16);
            v17 = *(_QWORD *)v7;
            *(_QWORD *)v7 = *v15;
            *v15 = v17;
            v18 = *(_QWORD *)(v7 + 8);
            *(_QWORD *)(v7 + 8) = v15[1];
            v15[1] = v18;
            v19 = *(_QWORD *)(v7 + 16);
            *(_QWORD *)(v7 + 16) = v15[2];
            v15[2] = v19;
          }
          --a3;
          a2 = (unint64_t *)v156;
          if ((a4 & 1) == 0)
          {
            result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(v7 - 24, v7);
            if ((result & 1) == 0)
            {
              v49 = *(_QWORD *)v7;
              v50 = *(_DWORD *)(v7 + 8);
              v51 = *(_DWORD *)(v7 + 12);
              v52 = *(_QWORD *)(v7 + 16);
              v53 = *v8;
              if (*(_QWORD *)v7 < *v8
                || v53 >= v49
                && ((v76 = *(_DWORD *)(v156 - 16), v50 < v76)
                 || v76 >= v50
                 && ((v77 = *(_DWORD *)(v156 - 12), v51 < v77) || v77 >= v51 && v52 < *(_QWORD *)(v156 - 8))))
              {
                i = v7;
                while (1)
                {
                  v55 = *(_QWORD *)(i + 24);
                  i += 24;
                  v54 = v55;
                  if (v49 < v55)
                    break;
                  if (v54 >= v49)
                  {
                    v56 = *(_DWORD *)(i + 8);
                    if (v50 < v56)
                      break;
                    if (v56 >= v50)
                    {
                      v57 = *(_DWORD *)(i + 12);
                      if (v51 < v57 || v57 >= v51 && v52 < *(_QWORD *)(i + 16))
                        break;
                    }
                  }
                }
              }
              else
              {
                for (i = v7 + 24; i < v156; i += 24)
                {
                  if (v49 < *(_QWORD *)i)
                    break;
                  if (*(_QWORD *)i >= v49)
                  {
                    v74 = *(_DWORD *)(i + 8);
                    if (v50 < v74)
                      break;
                    if (v74 >= v50)
                    {
                      v75 = *(_DWORD *)(i + 12);
                      if (v51 < v75 || v75 >= v51 && v52 < *(_QWORD *)(i + 16))
                        break;
                    }
                  }
                }
              }
              j = (_QWORD *)v156;
              if (i < v156)
              {
                for (j = v8; ; j -= 3)
                {
                  if (v49 >= v53)
                  {
                    if (v53 < v49)
                      break;
                    v59 = *((_DWORD *)j + 2);
                    if (v50 >= v59)
                    {
                      if (v59 < v50)
                        break;
                      v60 = *((_DWORD *)j + 3);
                      if (v51 >= v60 && (v60 < v51 || v52 >= j[2]))
                        break;
                    }
                  }
                  v61 = *(j - 3);
                  v53 = v61;
                }
              }
              if (i < (unint64_t)j)
              {
                v62 = *(_QWORD *)i;
                v63 = *j;
                do
                {
                  *(_QWORD *)i = v63;
                  *j = v62;
                  v64 = *(_QWORD *)(i + 16);
                  *(_QWORD *)(i + 16) = j[2];
                  j[2] = v64;
                  v65 = *(_QWORD *)(i + 24);
                  i += 24;
                  v62 = v65;
                  v66 = *(_DWORD *)(i - 16);
                  *(_DWORD *)(i - 16) = *((_DWORD *)j + 2);
                  *((_DWORD *)j + 2) = v66;
                  v67 = *(_DWORD *)(i - 12);
                  *(_DWORD *)(i - 12) = *((_DWORD *)j + 3);
                  *((_DWORD *)j + 3) = v67;
                  while (v49 >= v62)
                  {
                    if (v62 >= v49)
                    {
                      v68 = *(_DWORD *)(i + 8);
                      if (v50 < v68)
                        break;
                      if (v68 >= v50)
                      {
                        v69 = *(_DWORD *)(i + 12);
                        if (v51 < v69 || v69 >= v51 && v52 < *(_QWORD *)(i + 16))
                          break;
                      }
                    }
                    v70 = *(_QWORD *)(i + 24);
                    i += 24;
                    v62 = v70;
                  }
                  while (1)
                  {
                    do
                    {
                      v71 = *(j - 3);
                      j -= 3;
                      v63 = v71;
                    }
                    while (v49 < v71);
                    if (v63 < v49)
                      break;
                    v72 = *((_DWORD *)j + 2);
                    if (v50 >= v72)
                    {
                      if (v72 < v50)
                        break;
                      v73 = *((_DWORD *)j + 3);
                      if (v51 >= v73 && (v73 < v51 || v52 >= j[2]))
                        break;
                    }
                  }
                }
                while (i < (unint64_t)j);
              }
              if (i - 24 != v7)
              {
                *(_QWORD *)v7 = *(_QWORD *)(i - 24);
                *(_DWORD *)(v7 + 8) = *(_DWORD *)(i - 16);
                *(_DWORD *)(v7 + 12) = *(_DWORD *)(i - 12);
                *(_QWORD *)(v7 + 16) = *(_QWORD *)(i - 8);
              }
              a4 = 0;
              *(_QWORD *)(i - 24) = v49;
              *(_DWORD *)(i - 16) = v50;
              *(_DWORD *)(i - 12) = v51;
              *(_QWORD *)(i - 8) = v52;
              continue;
            }
          }
          v20 = *(_QWORD *)v7;
          v21 = *(_DWORD *)(v7 + 8);
          v22 = *(_DWORD *)(v7 + 12);
          v23 = v7 + 24;
          v24 = *(_QWORD *)(v7 + 16);
          while (1)
          {
            v25 = *(_QWORD *)v23;
            if (*(_QWORD *)v23 >= v20)
            {
              if (v20 < v25)
                break;
              v26 = *(_DWORD *)(v23 + 8);
              if (v26 >= v21)
              {
                if (v21 < v26)
                  break;
                v27 = *(_DWORD *)(v23 + 12);
                if (v27 >= v22 && (v22 < v27 || *(_QWORD *)(v23 + 16) >= v24))
                  break;
              }
            }
            v23 += 24;
          }
          if (v23 - 24 == v7)
          {
            k = (_QWORD *)v156;
            if (v23 < v156)
            {
              v33 = *v8;
              k = v8;
              if (*v8 >= v20)
              {
                k = v8;
                do
                {
                  if (v20 >= v33)
                  {
                    v34 = *((_DWORD *)k + 2);
                    if (v34 < v21)
                      break;
                    if (v21 >= v34)
                    {
                      v35 = *((_DWORD *)k + 3);
                      if (v35 < v22 || v22 >= v35 && k[2] < v24)
                        break;
                    }
                  }
                  if (v23 >= (unint64_t)k)
                    break;
                  v36 = *(k - 3);
                  k -= 3;
                  v33 = v36;
                }
                while (v36 >= v20);
              }
            }
          }
          else
          {
            v28 = *v8;
            for (k = v8; v28 >= v20; k -= 3)
            {
              if (v20 >= v28)
              {
                v30 = *((_DWORD *)k + 2);
                if (v30 < v21)
                  break;
                if (v21 >= v30)
                {
                  v31 = *((_DWORD *)k + 3);
                  if (v31 < v22 || v22 >= v31 && k[2] < v24)
                    break;
                }
              }
              v32 = *(k - 3);
              v28 = v32;
            }
          }
          i = v23;
          if (v23 < (unint64_t)k)
          {
            v37 = *k;
            i = v23;
            v38 = (unint64_t)k;
            do
            {
              *(_QWORD *)i = v37;
              *(_QWORD *)v38 = v25;
              v39 = *(_DWORD *)(i + 8);
              *(_DWORD *)(i + 8) = *(_DWORD *)(v38 + 8);
              *(_DWORD *)(v38 + 8) = v39;
              v40 = *(_DWORD *)(i + 12);
              *(_DWORD *)(i + 12) = *(_DWORD *)(v38 + 12);
              *(_DWORD *)(v38 + 12) = v40;
              v41 = *(_QWORD *)(i + 16);
              *(_QWORD *)(i + 16) = *(_QWORD *)(v38 + 16);
              *(_QWORD *)(v38 + 16) = v41;
              while (1)
              {
                do
                {
                  v42 = *(_QWORD *)(i + 24);
                  i += 24;
                  v25 = v42;
                }
                while (v42 < v20);
                if (v20 < v25)
                  break;
                v43 = *(_DWORD *)(i + 8);
                if (v43 >= v21)
                {
                  if (v21 < v43)
                    break;
                  v44 = *(_DWORD *)(i + 12);
                  if (v44 >= v22 && (v22 < v44 || *(_QWORD *)(i + 16) >= v24))
                    break;
                }
              }
              while (1)
              {
                v45 = *(_QWORD *)(v38 - 24);
                v38 -= 24;
                v37 = v45;
                if (v45 < v20)
                  break;
                if (v20 >= v37)
                {
                  v46 = *(_DWORD *)(v38 + 8);
                  if (v46 < v21)
                    break;
                  if (v21 >= v46)
                  {
                    v47 = *(_DWORD *)(v38 + 12);
                    if (v47 < v22 || v22 >= v47 && *(_QWORD *)(v38 + 16) < v24)
                      break;
                  }
                }
              }
            }
            while (i < v38);
          }
          if (i - 24 != v7)
          {
            *(_QWORD *)v7 = *(_QWORD *)(i - 24);
            *(_DWORD *)(v7 + 8) = *(_DWORD *)(i - 16);
            *(_DWORD *)(v7 + 12) = *(_DWORD *)(i - 12);
            *(_QWORD *)(v7 + 16) = *(_QWORD *)(i - 8);
          }
          *(_QWORD *)(i - 24) = v20;
          *(_DWORD *)(i - 16) = v21;
          *(_DWORD *)(i - 12) = v22;
          *(_QWORD *)(i - 8) = v24;
          if (v23 < (unint64_t)k)
          {
LABEL_64:
            result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *,false>(v7, i - 24, a3, a4 & 1);
            a4 = 0;
            continue;
          }
          v48 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(v7, i - 24);
          result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(i, v156);
          if (!(_DWORD)result)
          {
            if (v48)
              continue;
            goto LABEL_64;
          }
          a2 = (unint64_t *)(i - 24);
          if (v48)
            return result;
          goto LABEL_2;
        }
        v80 = v7 + 24;
        v82 = (unint64_t *)v7 == a2 || v80 == (_QWORD)a2;
        if ((a4 & 1) == 0)
        {
          if (!v82)
          {
            do
            {
              v136 = (unint64_t *)v80;
              result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(v80, v7);
              if ((_DWORD)result)
              {
                v137 = *v136;
                v138 = *(_DWORD *)(v7 + 32);
                v139 = *(_DWORD *)(v7 + 36);
                v140 = *(_QWORD *)(v7 + 40);
                v141 = *(_QWORD *)v7;
                while (1)
                {
                  do
                  {
                    v142 = v7;
                    v143 = v141;
                    v144 = *(_QWORD *)(v7 - 24);
                    v7 -= 24;
                    v141 = v144;
                    *(_QWORD *)(v7 + 48) = v143;
                    v145 = *(_DWORD *)(v7 + 36);
                    *(_DWORD *)(v7 + 56) = *(_DWORD *)(v7 + 32);
                    *(_DWORD *)(v7 + 60) = v145;
                    *(_QWORD *)(v7 + 64) = *(_QWORD *)(v7 + 40);
                  }
                  while (v137 < v144);
                  if (v141 < v137)
                    break;
                  v146 = *(_DWORD *)(v142 - 16);
                  if (v138 >= v146)
                  {
                    if (v146 < v138)
                      break;
                    v147 = *(_DWORD *)(v142 - 12);
                    if (v139 >= v147 && (v147 < v139 || v140 >= *(_QWORD *)(v142 - 8)))
                      break;
                  }
                }
                *(_QWORD *)v142 = v137;
                *(_DWORD *)(v142 + 8) = v138;
                *(_DWORD *)(v142 + 12) = v139;
                *(_QWORD *)(v142 + 16) = v140;
              }
              v80 = (uint64_t)(v136 + 3);
              v7 = (uint64_t)v136;
            }
            while (v136 + 3 != a2);
          }
          return result;
        }
        if (v82)
          return result;
        v83 = 0;
        v84 = v7;
        do
        {
          v85 = v80;
          result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(v80, v84);
          if (!(_DWORD)result)
            goto LABEL_155;
          v86 = *(_DWORD *)(v84 + 32);
          v87 = *(_DWORD *)(v84 + 36);
          v88 = *(_QWORD *)(v84 + 40);
          v90 = *(_QWORD *)(v84 + 16);
          v89 = *(_QWORD *)(v84 + 24);
          *(_QWORD *)(v84 + 24) = *(_QWORD *)v84;
          *(_DWORD *)(v85 + 8) = *(_DWORD *)(v84 + 8);
          *(_DWORD *)(v85 + 12) = *(_DWORD *)(v84 + 12);
          *(_QWORD *)(v85 + 16) = v90;
          v91 = v7;
          if (v84 == v7)
            goto LABEL_154;
          v92 = v83;
          while (1)
          {
            v93 = *(_QWORD *)(v7 + v92 - 24);
            if (v89 < v93)
            {
              v94 = *(_DWORD *)(v7 + v92 - 16);
              goto LABEL_151;
            }
            if (v93 < v89)
              goto LABEL_153;
            v94 = *(_DWORD *)(v7 + v92 - 16);
            if (v86 >= v94)
            {
              if (v94 < v86)
                goto LABEL_153;
              v95 = *(_DWORD *)(v7 + v92 - 12);
              if (v87 >= v95)
                break;
            }
LABEL_151:
            v84 -= 24;
            v96 = v7 + v92;
            *(_QWORD *)v96 = v93;
            v97 = *(_DWORD *)(v7 + v92 - 12);
            *(_DWORD *)(v96 + 8) = v94;
            *(_DWORD *)(v96 + 12) = v97;
            *(_QWORD *)(v96 + 16) = *(_QWORD *)(v7 + v92 - 8);
            v92 -= 24;
            if (!v92)
            {
              v91 = v7;
              goto LABEL_154;
            }
          }
          if (v95 >= v87)
          {
            v91 = v7 + v92;
            if (v88 >= *(_QWORD *)(v7 + v92 - 8))
              goto LABEL_154;
            goto LABEL_151;
          }
LABEL_153:
          v91 = v84;
LABEL_154:
          *(_QWORD *)v91 = v89;
          *(_DWORD *)(v91 + 8) = v86;
          *(_DWORD *)(v91 + 12) = v87;
          *(_QWORD *)(v91 + 16) = v88;
LABEL_155:
          v80 = v85 + 24;
          v83 += 24;
          v84 = v85;
        }
        while ((unint64_t *)(v85 + 24) != a2);
        return result;
    }
  }
}

double std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo *,false>(__n128 *a1, __n128 *a2, uint64_t a3, char a4)
{
  uint64_t v8;
  __n128 *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __n128 v15;
  unsigned __int32 v16;
  __n128 v17;
  __n128 v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  __n128 v24;
  unsigned __int32 v25;
  int v26;
  __n128 v27;
  __n128 v28;
  BOOL v29;
  __n128 v30;
  __n128 v31;
  unint64_t v32;
  _BOOL4 v33;
  unint64_t v34;
  __n128 v35;
  __n128 v36;
  __n128 v37;
  __n128 *v38;
  __n128 v39;
  __n128 v40;
  __n128 v41;
  uint64_t v42;
  BOOL v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  __n128 v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  int64_t v52;
  int64_t v53;
  int64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  __n128 v58;
  uint64_t v59;
  __int128 v60;
  uint64_t v61;
  uint64_t v62;
  __n128 v63;
  int64_t v64;
  __n128 *v65;
  uint64_t v66;
  __n128 v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  __n128 v74;
  __n128 v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  __n128 v79;
  uint64_t v80;
  __int128 v81;
  uint64_t v83;
  __n128 v84;
  __n128 *v85;
  __n128 *v86;
  BOOL v87;
  uint64_t v89;
  uint64_t v90;
  __n128 *v91;
  __n128 v92;
  unsigned __int32 v93;
  __n128 v94;
  unsigned __int32 v95;

BOOL GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo::operator<(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;

  v2 = *(_DWORD *)a1 >= *(_DWORD *)a2;
  if (*(_DWORD *)a1 == *(_DWORD *)a2)
  {
    v3 = *(unsigned __int16 *)(a1 + 16);
    v4 = *(unsigned __int16 *)(a2 + 16);
    v2 = v3 >= v4;
    if (v3 == v4)
    {
      v5 = *(_DWORD *)(a1 + 4);
      v6 = *(_DWORD *)(a2 + 4);
      v2 = v5 >= v6;
      if (v5 == v6)
      {
        v7 = *(_DWORD *)(a1 + 8);
        v8 = *(_DWORD *)(a2 + 8);
        v2 = v7 >= v8;
        if (v7 == v8)
          v2 = *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a2 + 12);
      }
    }
  }
  return !v2;
}

BOOL std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v6;
  _BOOL8 result;
  int v8;
  __int128 v9;
  int v10;
  int v11;
  __int128 v12;
  int v13;
  int v14;
  __int128 v15;
  int v16;
  int v17;
  __int128 v18;
  int v19;
  int v20;

  v6 = GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo::operator<(a2, a1);
  result = GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo::operator<(a3, a2);
  if (v6)
  {
    if (result)
    {
      v8 = *(_DWORD *)(a1 + 16);
      v9 = *(_OWORD *)a1;
      v10 = *(_DWORD *)(a3 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *(_DWORD *)(a1 + 16) = v10;
    }
    else
    {
      v17 = *(_DWORD *)(a1 + 16);
      v18 = *(_OWORD *)a1;
      v19 = *(_DWORD *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_DWORD *)(a1 + 16) = v19;
      *(_OWORD *)a2 = v18;
      *(_DWORD *)(a2 + 16) = v17;
      result = GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo::operator<(a3, a2);
      if (!result)
        return result;
      v8 = *(_DWORD *)(a2 + 16);
      v9 = *(_OWORD *)a2;
      v20 = *(_DWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_DWORD *)(a2 + 16) = v20;
    }
    *(_OWORD *)a3 = v9;
    *(_DWORD *)(a3 + 16) = v8;
  }
  else if (result)
  {
    v11 = *(_DWORD *)(a2 + 16);
    v12 = *(_OWORD *)a2;
    v13 = *(_DWORD *)(a3 + 16);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_DWORD *)(a2 + 16) = v13;
    *(_OWORD *)a3 = v12;
    *(_DWORD *)(a3 + 16) = v11;
    result = GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo::operator<(a2, a1);
    if (result)
    {
      v14 = *(_DWORD *)(a1 + 16);
      v15 = *(_OWORD *)a1;
      v16 = *(_DWORD *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_DWORD *)(a1 + 16) = v16;
      *(_OWORD *)a2 = v15;
      *(_DWORD *)(a2 + 16) = v14;
    }
  }
  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo *>(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result;
  int v9;
  __int128 v10;
  int v11;
  int v12;
  __n128 v13;
  int v14;
  unsigned __int32 v15;
  unsigned __int32 v16;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo *>((uint64_t)a1, a2, a3);
  if (GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo::operator<(a4, a3))
  {
    v9 = *(_DWORD *)(a3 + 16);
    v10 = *(_OWORD *)a3;
    v11 = *(_DWORD *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_DWORD *)(a3 + 16) = v11;
    *(_OWORD *)a4 = v10;
    *(_DWORD *)(a4 + 16) = v9;
    if (GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo::operator<(a3, a2))
    {
      v12 = *(_DWORD *)(a2 + 16);
      v13 = *(__n128 *)a2;
      v14 = *(_DWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_DWORD *)(a2 + 16) = v14;
      *(__n128 *)a3 = v13;
      *(_DWORD *)(a3 + 16) = v12;
      if (GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo::operator<(a2, (uint64_t)a1))
      {
        v15 = a1[1].n128_u32[0];
        result = *a1;
        v16 = *(_DWORD *)(a2 + 16);
        *a1 = *(__n128 *)a2;
        a1[1].n128_u32[0] = v16;
        *(__n128 *)a2 = result;
        *(_DWORD *)(a2 + 16) = v15;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo *>(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __n128 result;
  int v11;
  __int128 v12;
  int v13;
  int v14;
  __int128 v15;
  int v16;
  int v17;
  __n128 v18;
  int v19;
  unsigned __int32 v20;
  unsigned __int32 v21;

  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo *>(a1, a2, a3, a4);
  if (GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo::operator<(a5, a4))
  {
    v11 = *(_DWORD *)(a4 + 16);
    v12 = *(_OWORD *)a4;
    v13 = *(_DWORD *)(a5 + 16);
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_DWORD *)(a4 + 16) = v13;
    *(_OWORD *)a5 = v12;
    *(_DWORD *)(a5 + 16) = v11;
    if (GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo::operator<(a4, a3))
    {
      v14 = *(_DWORD *)(a3 + 16);
      v15 = *(_OWORD *)a3;
      v16 = *(_DWORD *)(a4 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_DWORD *)(a3 + 16) = v16;
      *(_OWORD *)a4 = v15;
      *(_DWORD *)(a4 + 16) = v14;
      if (GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo::operator<(a3, a2))
      {
        v17 = *(_DWORD *)(a2 + 16);
        v18 = *(__n128 *)a2;
        v19 = *(_DWORD *)(a3 + 16);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_DWORD *)(a2 + 16) = v19;
        *(__n128 *)a3 = v18;
        *(_DWORD *)(a3 + 16) = v17;
        if (GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo::operator<(a2, (uint64_t)a1))
        {
          v20 = a1[1].n128_u32[0];
          result = *a1;
          v21 = *(_DWORD *)(a2 + 16);
          *a1 = *(__n128 *)a2;
          a1[1].n128_u32[0] = v21;
          *(__n128 *)a2 = result;
          *(_DWORD *)(a2 + 16) = v20;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo *>(__n128 *a1, __n128 *a2)
{
  unint64_t v4;
  _BOOL8 result;
  __n128 *v6;
  unsigned __int32 v7;
  __n128 v8;
  unsigned __int32 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  __int128 v17;
  int v18;

  v4 = 0xCCCCCCCCCCCCCCCDLL * (((char *)a2 - (char *)a1) >> 2);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v6 = (__n128 *)((char *)a2 - 20);
      if (GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo::operator<((uint64_t)&a2[-2].n128_i64[1] + 4, (uint64_t)a1))
      {
        v7 = a1[1].n128_u32[0];
        v8 = *a1;
        v9 = v6[1].n128_u32[0];
        *a1 = *v6;
        a1[1].n128_u32[0] = v9;
        *v6 = v8;
        v6[1].n128_u32[0] = v7;
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo *>((uint64_t)a1, (uint64_t)a1[1].n128_i64 + 4, (uint64_t)&a2[-2].n128_i64[1] + 4);
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo *>(a1, (uint64_t)a1[1].n128_i64 + 4, (uint64_t)&a1[2].n128_i64[1], (uint64_t)&a2[-2].n128_i64[1] + 4);
      return 1;
    case 5uLL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo *>(a1, (uint64_t)a1[1].n128_i64 + 4, (uint64_t)&a1[2].n128_i64[1], (uint64_t)&a1[3].n128_i64[1] + 4, (uint64_t)&a2[-2].n128_i64[1] + 4);
      return 1;
    default:
      v10 = (uint64_t)&a1[2].n128_i64[1];
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo *>((uint64_t)a1, (uint64_t)a1[1].n128_i64 + 4, (uint64_t)&a1[2].n128_i64[1]);
      v11 = (uint64_t)&a1[3].n128_i64[1] + 4;
      if ((__n128 *)((char *)&a1[3].n128_f64[1] + 4) == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    if (GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo::operator<(v11, v10))
    {
      v17 = *(_OWORD *)v11;
      v18 = *(_DWORD *)(v11 + 16);
      v14 = v12;
      while (1)
      {
        v15 = (char *)a1 + v14;
        *(__n128 *)(v15 + 60) = *(__n128 *)((char *)a1 + v14 + 40);
        *((_DWORD *)v15 + 19) = *(unsigned __int32 *)((char *)&a1[3].n128_u32[2] + v14);
        if (v14 == -40)
          break;
        v14 -= 20;
        if (!GRCPerFrameData::AddShaderProfilerSample(unsigned int,SampleInfoWithPayload const&)::EncoderTracePacketInfo::operator<((uint64_t)&v17, (uint64_t)(v15 + 20)))
        {
          v16 = (uint64_t)&a1[3].n128_i64[1] + v14 + 4;
          goto LABEL_12;
        }
      }
      v16 = (uint64_t)a1;
LABEL_12:
      *(_OWORD *)v16 = v17;
      *(_DWORD *)(v16 + 16) = v18;
      if (++v13 == 8)
        return v11 + 20 == (_QWORD)a2;
    }
    v10 = v11;
    v12 += 20;
    v11 += 20;
    if ((__n128 *)v11 == a2)
      return 1;
  }
}

void ProgramAddressHelper::UpdateActiveEncoderRef(ProgramAddressHelper *this, unsigned int a2, unsigned int a3, unsigned int a4, unint64_t a5)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t **v10;
  uint64_t **v11;
  unsigned int v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t *v15;
  unsigned int v16;
  BOOL v17;
  uint64_t **v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t *v21;
  BOOL v22;
  unint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t **v26;
  uint64_t *v27;
  uint64_t *v28;
  _QWORD *v29;
  unsigned int v30;
  uint64_t **v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  BOOL v38;
  uint64_t *v39;
  int v40;
  uint64_t *v41;
  _QWORD *v42;
  uint64_t **v43;
  uint64_t *v44;
  uint64_t *v45;
  int v46;
  int v47;
  _QWORD *v48;
  char *v49;
  uint64_t *v50;
  _QWORD *v51;
  unint64_t v52;
  unint64_t v53;
  uint8x8_t v54;
  void **v55;
  _QWORD *v56;
  unint64_t v57;
  float v58;
  float v59;
  _BOOL8 v60;
  unint64_t v61;
  unint64_t v62;
  int8x8_t prime;
  void *v64;
  void *v65;
  uint64_t v66;
  _QWORD *v67;
  unint64_t v68;
  uint8x8_t v69;
  unint64_t v70;
  uint8x8_t v71;
  uint64_t v72;
  _QWORD *v73;
  unint64_t v74;
  uint64_t v75;
  _QWORD *v76;
  unint64_t v77;
  void *v78;
  unsigned int v81;
  unsigned int v82;
  unsigned int v83;

  if (0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3) > (unint64_t)a2)
  {
    v8 = (_QWORD *)(*(_QWORD *)this + 88 * a2);
    v9 = v8[2];
    if (v9)
    {
      v10 = (uint64_t **)(v8 + 5);
      v11 = (uint64_t **)(v8 + 6);
      do
      {
        while (1)
        {
          v81 = *(_DWORD *)(v9 + 16);
          v12 = v81;
          if (std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)this + 36, v81, &v81)[4]+ 500 < a5)break;
          v9 = *(_QWORD *)v9;
          if (!v9)
            goto LABEL_27;
        }
        v13 = *v11;
        if (*v11)
        {
          v14 = v8 + 6;
          v15 = *v11;
          do
          {
            v16 = *((_DWORD *)v15 + 7);
            v17 = v16 >= v12;
            if (v16 >= v12)
              v18 = (uint64_t **)v15;
            else
              v18 = (uint64_t **)(v15 + 1);
            if (v17)
              v14 = v15;
            v15 = *v18;
          }
          while (*v18);
          if (v14 != (uint64_t *)v11 && v12 >= *((_DWORD *)v14 + 7))
          {
            v19 = (uint64_t *)v14[1];
            v20 = v14;
            if (v19)
            {
              do
              {
                v21 = v19;
                v19 = (uint64_t *)*v19;
              }
              while (v19);
            }
            else
            {
              do
              {
                v21 = (uint64_t *)v20[2];
                v22 = *v21 == (_QWORD)v20;
                v20 = v21;
              }
              while (!v22);
            }
            if (*v10 == v14)
              *v10 = v21;
            --v8[7];
            std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v13, v14);
            operator delete(v14);
          }
        }
        v9 = std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::erase(v8, (uint64_t *)v9);
      }
      while (v9);
    }
LABEL_27:
    v23 = a4;
    v24 = a4 >> 1;
    if ((a4 & 1) == 0)
    {
      v83 = a3;
      v25 = *(_QWORD *)this + 88 * a2;
      v28 = *(uint64_t **)(v25 + 48);
      v26 = (uint64_t **)(v25 + 48);
      v27 = v28;
      if (v28)
      {
        while (1)
        {
          while (1)
          {
            v29 = v27;
            v30 = *((_DWORD *)v27 + 7);
            if (v30 <= a3)
              break;
            v27 = (uint64_t *)*v29;
            v31 = (uint64_t **)v29;
            if (!*v29)
              goto LABEL_51;
          }
          if (v30 >= a3)
            break;
          v27 = (uint64_t *)v29[1];
          if (!v27)
          {
            v31 = (uint64_t **)(v29 + 1);
            goto LABEL_51;
          }
        }
      }
      else
      {
        v31 = v26;
        v29 = v26;
LABEL_51:
        v42 = v29;
        v43 = v26 - 1;
        v29 = operator new(0x28uLL);
        *(_QWORD *)((char *)v29 + 28) = a3;
        *v29 = 0;
        v29[1] = 0;
        v29[2] = v42;
        *v31 = v29;
        v44 = (uint64_t *)**v43;
        v45 = v29;
        if (v44)
        {
          *v43 = v44;
          v45 = *v31;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v43[1], v45);
        v43[2] = (uint64_t *)((char *)v43[2] + 1);
      }
      v46 = 1 << a4;
      v47 = (unsigned __int16)++*((_WORD *)v29 + 16);
      if (v47 == 1)
      {
        v48 = std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)this + 36, a3, &v83);
        v48[3] = a5;
        v48[4] = -1;
        *((_DWORD *)v48 + 10) = v46;
      }
      v49 = (char *)this + 40 * v24 + 184;
      v50 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>(v49, a3);
      if (v50)
      {
        v51 = v50 + 4;
        if (v50[4] == -1)
        {
LABEL_134:
          *((_DWORD *)v29 + 8) |= v46 << v24 << 16;
          return;
        }
        v50[3] = a5;
LABEL_133:
        *v51 = -1;
        goto LABEL_134;
      }
      v52 = a3;
      v53 = *((_QWORD *)v49 + 1);
      if (v53)
      {
        v54 = (uint8x8_t)vcnt_s8((int8x8_t)v53);
        v54.i16[0] = vaddlv_u8(v54);
        if (v54.u32[0] > 1uLL)
        {
          v23 = a3;
          if (v53 <= a3)
            v23 = a3 % v53;
        }
        else
        {
          v23 = ((_DWORD)v53 - 1) & a3;
        }
        v55 = *(void ***)(*(_QWORD *)v49 + 8 * v23);
        if (v55)
        {
          v56 = *v55;
          if (*v55)
          {
            do
            {
              v57 = v56[1];
              if (v57 == a3)
              {
                if (*((_DWORD *)v56 + 4) == a3)
                  goto LABEL_132;
              }
              else
              {
                if (v54.u32[0] > 1uLL)
                {
                  if (v57 >= v53)
                    v57 %= v53;
                }
                else
                {
                  v57 &= v53 - 1;
                }
                if (v57 != v23)
                  break;
              }
              v56 = (_QWORD *)*v56;
            }
            while (v56);
          }
        }
      }
      v56 = operator new(0x28uLL);
      *v56 = 0;
      v56[1] = a3;
      *((_DWORD *)v56 + 4) = a3;
      v56[3] = 0;
      v56[4] = 0;
      v58 = (float)(unint64_t)(*((_QWORD *)v49 + 3) + 1);
      v59 = *((float *)v49 + 8);
      if (v53 && (float)(v59 * (float)v53) >= v58)
      {
        v52 = v23;
        goto LABEL_122;
      }
      v60 = 1;
      if (v53 >= 3)
        v60 = (v53 & (v53 - 1)) != 0;
      v61 = v60 | (2 * v53);
      v62 = vcvtps_u32_f32(v58 / v59);
      if (v61 <= v62)
        prime = (int8x8_t)v62;
      else
        prime = (int8x8_t)v61;
      if (*(_QWORD *)&prime == 1)
      {
        prime = (int8x8_t)2;
      }
      else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
      {
        prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
        v53 = *((_QWORD *)v49 + 1);
      }
      if (*(_QWORD *)&prime <= v53)
      {
        if (*(_QWORD *)&prime >= v53)
          goto LABEL_118;
        v70 = vcvtps_u32_f32((float)*((unint64_t *)v49 + 3) / *((float *)v49 + 8));
        if (v53 < 3 || (v71 = (uint8x8_t)vcnt_s8((int8x8_t)v53), v71.i16[0] = vaddlv_u8(v71), v71.u32[0] > 1uLL))
        {
          v70 = std::__next_prime(v70);
        }
        else
        {
          v72 = 1 << -(char)__clz(v70 - 1);
          if (v70 >= 2)
            v70 = v72;
        }
        if (*(_QWORD *)&prime <= v70)
          prime = (int8x8_t)v70;
        if (*(_QWORD *)&prime >= v53)
        {
          v53 = *((_QWORD *)v49 + 1);
          goto LABEL_118;
        }
        if (!*(_QWORD *)&prime)
        {
          v78 = *(void **)v49;
          *(_QWORD *)v49 = 0;
          if (v78)
            operator delete(v78);
          v53 = 0;
          *((_QWORD *)v49 + 1) = 0;
          goto LABEL_118;
        }
      }
      if (*(_QWORD *)&prime >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v64 = operator new(8 * *(_QWORD *)&prime);
      v65 = *(void **)v49;
      *(_QWORD *)v49 = v64;
      if (v65)
        operator delete(v65);
      v66 = 0;
      *((int8x8_t *)v49 + 1) = prime;
      do
        *(_QWORD *)(*(_QWORD *)v49 + 8 * v66++) = 0;
      while (*(_QWORD *)&prime != v66);
      v67 = (_QWORD *)*((_QWORD *)v49 + 2);
      if (v67)
      {
        v68 = v67[1];
        v69 = (uint8x8_t)vcnt_s8(prime);
        v69.i16[0] = vaddlv_u8(v69);
        if (v69.u32[0] > 1uLL)
        {
          if (v68 >= *(_QWORD *)&prime)
            v68 %= *(_QWORD *)&prime;
        }
        else
        {
          v68 &= *(_QWORD *)&prime - 1;
        }
        *(_QWORD *)(*(_QWORD *)v49 + 8 * v68) = v49 + 16;
        v73 = (_QWORD *)*v67;
        if (*v67)
        {
          do
          {
            v74 = v73[1];
            if (v69.u32[0] > 1uLL)
            {
              if (v74 >= *(_QWORD *)&prime)
                v74 %= *(_QWORD *)&prime;
            }
            else
            {
              v74 &= *(_QWORD *)&prime - 1;
            }
            if (v74 != v68)
            {
              if (!*(_QWORD *)(*(_QWORD *)v49 + 8 * v74))
              {
                *(_QWORD *)(*(_QWORD *)v49 + 8 * v74) = v67;
                goto LABEL_114;
              }
              *v67 = *v73;
              *v73 = **(_QWORD **)(*(_QWORD *)v49 + 8 * v74);
              **(_QWORD **)(*(_QWORD *)v49 + 8 * v74) = v73;
              v73 = v67;
            }
            v74 = v68;
LABEL_114:
            v67 = v73;
            v73 = (_QWORD *)*v73;
            v68 = v74;
          }
          while (v73);
        }
      }
      v53 = (unint64_t)prime;
LABEL_118:
      if ((v53 & (v53 - 1)) != 0)
      {
        if (v53 <= v52)
          v52 %= v53;
      }
      else
      {
        v52 = ((_DWORD)v53 - 1) & v52;
      }
LABEL_122:
      v75 = *(_QWORD *)v49;
      v76 = *(_QWORD **)(*(_QWORD *)v49 + 8 * v52);
      if (v76)
      {
        *v56 = *v76;
      }
      else
      {
        *v56 = *((_QWORD *)v49 + 2);
        *((_QWORD *)v49 + 2) = v56;
        *(_QWORD *)(v75 + 8 * v52) = v49 + 16;
        if (!*v56)
          goto LABEL_131;
        v77 = *(_QWORD *)(*v56 + 8);
        if ((v53 & (v53 - 1)) != 0)
        {
          if (v77 >= v53)
            v77 %= v53;
        }
        else
        {
          v77 &= v53 - 1;
        }
        v76 = (_QWORD *)(*(_QWORD *)v49 + 8 * v77);
      }
      *v76 = v56;
LABEL_131:
      ++*((_QWORD *)v49 + 3);
LABEL_132:
      v56[3] = a5;
      v51 = v56 + 4;
      goto LABEL_133;
    }
    v82 = a3;
    v32 = *(_QWORD *)this + 88 * a2;
    v35 = *(_QWORD *)(v32 + 48);
    v33 = v32 + 48;
    v34 = v35;
    if (v35)
    {
      v36 = v33;
      do
      {
        v37 = *(_DWORD *)(v34 + 28);
        v38 = v37 >= a3;
        if (v37 >= a3)
          v39 = (uint64_t *)v34;
        else
          v39 = (uint64_t *)(v34 + 8);
        if (v38)
          v36 = v34;
        v34 = *v39;
      }
      while (*v39);
      if (v36 != v33 && *(_DWORD *)(v36 + 28) <= a3)
      {
        v40 = *(_DWORD *)(v36 + 32);
        *(_DWORD *)(v36 + 32) = (v40 & 0xFFFF0000 | (unsigned __int16)(v40 - 1)) & ((~(1 << (a4 & 0xFE) << v24) << 16) | 0xFFFF);
        if ((_WORD)v40 == 1)
        {
          std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((float *)this + 36, a3, &v82)[4] = a5;
          std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(*(_QWORD *)this + 88 * a2, *(_DWORD *)(v36 + 28), *(_DWORD *)(v36 + 28));
        }
        v41 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>((_QWORD *)this + 5 * v24 + 23, a3);
        if (v41)
          v41[4] = a5;
      }
    }
  }
}

void sub_2F9640(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(float *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  int8x8_t prime;
  void *v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  uint8x8_t v23;
  unint64_t v24;
  uint8x8_t v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  unint64_t v31;
  _QWORD *v33;

  v6 = a2;
  v7 = *((_QWORD *)a1 + 1);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & a2;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x30uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[3] = 0;
  v10[4] = 0;
  *((_DWORD *)v10 + 10) = 0;
  v12 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v13 = a1[8];
  if (v7 && (float)(v13 * (float)v7) >= v12)
  {
    v6 = v3;
    goto LABEL_64;
  }
  v14 = 1;
  if (v7 >= 3)
    v14 = (v7 & (v7 - 1)) != 0;
  v15 = v14 | (2 * v7);
  v16 = vcvtps_u32_f32(v12 / v13);
  if (v15 <= v16)
    prime = (int8x8_t)v16;
  else
    prime = (int8x8_t)v15;
  if (*(_QWORD *)&prime == 1)
  {
    prime = (int8x8_t)2;
  }
  else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
  {
    prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    v7 = *((_QWORD *)a1 + 1);
  }
  if (*(_QWORD *)&prime <= v7)
  {
    if (*(_QWORD *)&prime >= v7)
      goto LABEL_60;
    v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v7 < 3 || (v25 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
    {
      v24 = std::__next_prime(v24);
    }
    else
    {
      v26 = 1 << -(char)__clz(v24 - 1);
      if (v24 >= 2)
        v24 = v26;
    }
    if (*(_QWORD *)&prime <= v24)
      prime = (int8x8_t)v24;
    if (*(_QWORD *)&prime >= v7)
    {
      v7 = *((_QWORD *)a1 + 1);
      goto LABEL_60;
    }
    if (!*(_QWORD *)&prime)
    {
      v33 = *(_QWORD **)a1;
      *(_QWORD *)a1 = 0;
      if (v33)
        operator delete(v33);
      v7 = 0;
      *((_QWORD *)a1 + 1) = 0;
      goto LABEL_60;
    }
  }
  if (*(_QWORD *)&prime >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  v18 = operator new(8 * *(_QWORD *)&prime);
  v19 = *(_QWORD **)a1;
  *(_QWORD *)a1 = v18;
  if (v19)
    operator delete(v19);
  v20 = 0;
  *((int8x8_t *)a1 + 1) = prime;
  do
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v20++) = 0;
  while (*(_QWORD *)&prime != v20);
  v21 = (_QWORD *)*((_QWORD *)a1 + 2);
  if (v21)
  {
    v22 = v21[1];
    v23 = (uint8x8_t)vcnt_s8(prime);
    v23.i16[0] = vaddlv_u8(v23);
    if (v23.u32[0] > 1uLL)
    {
      if (v22 >= *(_QWORD *)&prime)
        v22 %= *(_QWORD *)&prime;
    }
    else
    {
      v22 &= *(_QWORD *)&prime - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v22) = a1 + 4;
    v27 = (_QWORD *)*v21;
    if (*v21)
    {
      do
      {
        v28 = v27[1];
        if (v23.u32[0] > 1uLL)
        {
          if (v28 >= *(_QWORD *)&prime)
            v28 %= *(_QWORD *)&prime;
        }
        else
        {
          v28 &= *(_QWORD *)&prime - 1;
        }
        if (v28 != v22)
        {
          if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v28))
          {
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v28) = v21;
            goto LABEL_56;
          }
          *v21 = *v27;
          *v27 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v28);
          **(_QWORD **)(*(_QWORD *)a1 + 8 * v28) = v27;
          v27 = v21;
        }
        v28 = v22;
LABEL_56:
        v21 = v27;
        v27 = (_QWORD *)*v27;
        v22 = v28;
      }
      while (v27);
    }
  }
  v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v6)
      v6 %= v7;
  }
  else
  {
    v6 = ((_DWORD)v7 - 1) & v6;
  }
LABEL_64:
  v29 = *(_QWORD **)a1;
  v30 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v6);
  if (v30)
  {
    *v10 = *v30;
LABEL_72:
    *v30 = v10;
    goto LABEL_73;
  }
  *v10 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = v10;
  v29[v6] = a1 + 4;
  if (*v10)
  {
    v31 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v31 >= v7)
        v31 %= v7;
    }
    else
    {
      v31 &= v7 - 1;
    }
    v30 = (_QWORD *)(*(_QWORD *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
  return v10;
}

void sub_2F9A34(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::erase(_QWORD *a1, uint64_t *__p)
{
  int8x8_t v2;
  unint64_t v3;
  uint64_t v4;
  uint8x8_t v5;
  uint64_t *v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;

  v2 = (int8x8_t)a1[1];
  v4 = *__p;
  v3 = __p[1];
  v5 = (uint8x8_t)vcnt_s8(v2);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v3 >= *(_QWORD *)&v2)
      v3 %= *(_QWORD *)&v2;
  }
  else
  {
    v3 &= *(_QWORD *)&v2 - 1;
  }
  v6 = *(uint64_t **)(*a1 + 8 * v3);
  do
  {
    v7 = v6;
    v6 = (uint64_t *)*v6;
  }
  while (v6 != __p);
  if (v7 != a1 + 2)
  {
    v8 = v7[1];
    if (v5.u32[0] > 1uLL)
    {
      if (v8 >= *(_QWORD *)&v2)
        v8 %= *(_QWORD *)&v2;
    }
    else
    {
      v8 &= *(_QWORD *)&v2 - 1;
    }
    v9 = *__p;
    if (v8 == v3)
    {
LABEL_20:
      if (!v9)
        goto LABEL_27;
      goto LABEL_21;
    }
  }
  if (!v4)
    goto LABEL_19;
  v10 = *(_QWORD *)(v4 + 8);
  if (v5.u32[0] > 1uLL)
  {
    if (v10 >= *(_QWORD *)&v2)
      v10 %= *(_QWORD *)&v2;
  }
  else
  {
    v10 &= *(_QWORD *)&v2 - 1;
  }
  v9 = *__p;
  if (v10 != v3)
  {
LABEL_19:
    *(_QWORD *)(*a1 + 8 * v3) = 0;
    v9 = *__p;
    goto LABEL_20;
  }
LABEL_21:
  v11 = *(_QWORD *)(v9 + 8);
  if (v5.u32[0] > 1uLL)
  {
    if (v11 >= *(_QWORD *)&v2)
      v11 %= *(_QWORD *)&v2;
  }
  else
  {
    v11 &= *(_QWORD *)&v2 - 1;
  }
  if (v11 != v3)
  {
    *(_QWORD *)(*a1 + 8 * v11) = v7;
    v9 = *__p;
  }
LABEL_27:
  *v7 = v9;
  *__p = 0;
  --a1[3];
  operator delete(__p);
  return v4;
}

uint64_t *std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 != v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v18 = v7[1];
      *(_QWORD *)v12 = v18;
      if (v18)
        *(_QWORD *)(v18 + 16) = v12;
      v7[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
      v7[1] = v12;
      *(_QWORD *)(v12 + 16) = v7;
      if (result == (uint64_t *)v12)
        result = v7;
      v7 = *(uint64_t **)v12;
    }
    v19 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v19 + 24))
      goto LABEL_68;
    v20 = (uint64_t *)v7[1];
    if (v20 && !*((_BYTE *)v20 + 24))
    {
      if (v19 && !*((_BYTE *)v19 + 24))
      {
LABEL_68:
        v20 = v7;
      }
      else
      {
        *((_BYTE *)v20 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v26 = *v20;
        v7[1] = *v20;
        if (v26)
          *(_QWORD *)(v26 + 16) = v7;
        v20[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
        *v20 = (uint64_t)v7;
        v7[2] = (uint64_t)v20;
        v19 = v7;
      }
      v23 = v20[2];
      *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v19 + 24) = 1;
      v24 = *(uint64_t **)v23;
      v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
      *(_QWORD *)v23 = v27;
      if (v27)
        *(_QWORD *)(v27 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      v24[1] = v23;
      goto LABEL_72;
    }
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v13 = *(uint64_t **)(v12 + 8);
    v14 = *v13;
    *(_QWORD *)(v12 + 8) = *v13;
    if (v14)
      *(_QWORD *)(v14 + 16) = v12;
    v13[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
    *v13 = v12;
    *(_QWORD *)(v12 + 16) = v13;
    if (result == (uint64_t *)*v7)
      result = v7;
    v7 = *(uint64_t **)(*v7 + 8);
  }
  v15 = (_QWORD *)*v7;
  if (!*v7 || *((_BYTE *)v15 + 24))
  {
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_59;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
    goto LABEL_49;
  }
  v16 = (uint64_t *)v7[1];
  if (v16 && !*((_BYTE *)v16 + 24))
  {
LABEL_59:
    v15 = v7;
  }
  else
  {
    *((_BYTE *)v15 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v22 = v15[1];
    *v7 = v22;
    if (v22)
      *(_QWORD *)(v22 + 16) = v7;
    v15[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
    v15[1] = v7;
    v7[2] = (uint64_t)v15;
    v16 = v7;
  }
  v23 = v15[2];
  *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v16 + 24) = 1;
  v24 = *(uint64_t **)(v23 + 8);
  v25 = *v24;
  *(_QWORD *)(v23 + 8) = *v24;
  if (v25)
    *(_QWORD *)(v25 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  *v24 = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

char *std::vector<unsigned long long>::__assign_with_size[abi:nn180100]<unsigned long long *,unsigned long long *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 3)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61)
      abort();
    v10 = v8 >> 2;
    if (v8 >> 2 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<NSString * {__strong}>::__vallocate[abi:nn180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 3;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

BOOL std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;

  if (*(_QWORD *)a1 < *(_QWORD *)a2)
    return 1;
  if (*(_QWORD *)a2 < *(_QWORD *)a1)
    return 0;
  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a2 + 8);
  if (v2 < v3)
    return 1;
  if (v3 < v2)
    return 0;
  v4 = *(_DWORD *)(a1 + 12);
  v5 = *(_DWORD *)(a2 + 12);
  if (v4 < v5)
    return 1;
  return v5 >= v4 && *(_QWORD *)(a1 + 16) < *(_QWORD *)(a2 + 16);
}

BOOL std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v6;
  _BOOL8 result;
  uint64_t v8;
  uint64_t *v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v6 = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(a2, a1);
  result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(a3, a2);
  if (v6)
  {
    v9 = (uint64_t *)(a1 + 16);
    v8 = *(_QWORD *)a1;
    if (result)
    {
      *(_QWORD *)a1 = *(_QWORD *)a3;
      *(_QWORD *)a3 = v8;
      v10 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(a3 + 8) = v10;
      v11 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(a3 + 12);
    }
    else
    {
      *(_QWORD *)a1 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v8;
      v16 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 8) = v16;
      v17 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 12) = v17;
      v9 = (uint64_t *)(a2 + 16);
      v18 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(a2 + 16) = v18;
      result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(a3, a2);
      if (!result)
        return result;
      v19 = *(_QWORD *)a2;
      *(_QWORD *)a2 = *(_QWORD *)a3;
      *(_QWORD *)a3 = v19;
      LODWORD(v19) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(a3 + 8) = v19;
      v11 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(a3 + 12);
    }
    *(_DWORD *)(a3 + 12) = v11;
    v14 = (uint64_t *)(a3 + 16);
    goto LABEL_10;
  }
  if (result)
  {
    v12 = *(_QWORD *)a2;
    *(_QWORD *)a2 = *(_QWORD *)a3;
    *(_QWORD *)a3 = v12;
    LODWORD(v12) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
    *(_DWORD *)(a3 + 8) = v12;
    LODWORD(v12) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(a3 + 12);
    *(_DWORD *)(a3 + 12) = v12;
    v14 = (uint64_t *)(a2 + 16);
    v13 = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a2 + 16) = *(_QWORD *)(a3 + 16);
    *(_QWORD *)(a3 + 16) = v13;
    result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(a2, a1);
    if (result)
    {
      v15 = *(_QWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v15;
      LODWORD(v15) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 8) = v15;
      LODWORD(v15) = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 12) = v15;
      v9 = (uint64_t *)(a1 + 16);
LABEL_10:
      v20 = *v9;
      *v9 = *v14;
      *v14 = v20;
    }
  }
  return result;
}

BOOL std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _BOOL8 result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(a1, a2, a3);
  result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(a4, a3);
  if (result)
  {
    v9 = *(_QWORD *)a3;
    *(_QWORD *)a3 = *(_QWORD *)a4;
    *(_QWORD *)a4 = v9;
    LODWORD(v9) = *(_DWORD *)(a3 + 8);
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a4 + 8);
    *(_DWORD *)(a4 + 8) = v9;
    LODWORD(v9) = *(_DWORD *)(a3 + 12);
    *(_DWORD *)(a3 + 12) = *(_DWORD *)(a4 + 12);
    *(_DWORD *)(a4 + 12) = v9;
    v10 = *(_QWORD *)(a3 + 16);
    *(_QWORD *)(a3 + 16) = *(_QWORD *)(a4 + 16);
    *(_QWORD *)(a4 + 16) = v10;
    result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(a3, a2);
    if (result)
    {
      v11 = *(_QWORD *)a2;
      *(_QWORD *)a2 = *(_QWORD *)a3;
      *(_QWORD *)a3 = v11;
      LODWORD(v11) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(a3 + 8) = v11;
      LODWORD(v11) = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(a3 + 12);
      *(_DWORD *)(a3 + 12) = v11;
      v12 = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(a2 + 16) = *(_QWORD *)(a3 + 16);
      *(_QWORD *)(a3 + 16) = v12;
      result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(a2, a1);
      if (result)
      {
        v13 = *(_QWORD *)a1;
        *(_QWORD *)a1 = *(_QWORD *)a2;
        *(_QWORD *)a2 = v13;
        LODWORD(v13) = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
        *(_DWORD *)(a2 + 8) = v13;
        LODWORD(v13) = *(_DWORD *)(a1 + 12);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(a2 + 12) = v13;
        v14 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
        *(_QWORD *)(a2 + 16) = v14;
      }
    }
  }
  return result;
}

BOOL std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(a1, a2, a3, a4);
  result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(a5, a4);
  if (result)
  {
    v11 = *(_QWORD *)a4;
    *(_QWORD *)a4 = *(_QWORD *)a5;
    *(_QWORD *)a5 = v11;
    LODWORD(v11) = *(_DWORD *)(a4 + 8);
    *(_DWORD *)(a4 + 8) = *(_DWORD *)(a5 + 8);
    *(_DWORD *)(a5 + 8) = v11;
    LODWORD(v11) = *(_DWORD *)(a4 + 12);
    *(_DWORD *)(a4 + 12) = *(_DWORD *)(a5 + 12);
    *(_DWORD *)(a5 + 12) = v11;
    v12 = *(_QWORD *)(a4 + 16);
    *(_QWORD *)(a4 + 16) = *(_QWORD *)(a5 + 16);
    *(_QWORD *)(a5 + 16) = v12;
    result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(a4, a3);
    if (result)
    {
      v13 = *(_QWORD *)a3;
      *(_QWORD *)a3 = *(_QWORD *)a4;
      *(_QWORD *)a4 = v13;
      LODWORD(v13) = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(a4 + 8);
      *(_DWORD *)(a4 + 8) = v13;
      LODWORD(v13) = *(_DWORD *)(a3 + 12);
      *(_DWORD *)(a3 + 12) = *(_DWORD *)(a4 + 12);
      *(_DWORD *)(a4 + 12) = v13;
      v14 = *(_QWORD *)(a3 + 16);
      *(_QWORD *)(a3 + 16) = *(_QWORD *)(a4 + 16);
      *(_QWORD *)(a4 + 16) = v14;
      result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(a3, a2);
      if (result)
      {
        v15 = *(_QWORD *)a2;
        *(_QWORD *)a2 = *(_QWORD *)a3;
        *(_QWORD *)a3 = v15;
        LODWORD(v15) = *(_DWORD *)(a2 + 8);
        *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
        *(_DWORD *)(a3 + 8) = v15;
        LODWORD(v15) = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(a2 + 12) = *(_DWORD *)(a3 + 12);
        *(_DWORD *)(a3 + 12) = v15;
        v16 = *(_QWORD *)(a2 + 16);
        *(_QWORD *)(a2 + 16) = *(_QWORD *)(a3 + 16);
        *(_QWORD *)(a3 + 16) = v16;
        result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(a2, a1);
        if (result)
        {
          v17 = *(_QWORD *)a1;
          *(_QWORD *)a1 = *(_QWORD *)a2;
          *(_QWORD *)a2 = v17;
          LODWORD(v17) = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
          *(_DWORD *)(a2 + 8) = v17;
          LODWORD(v17) = *(_DWORD *)(a1 + 12);
          *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
          *(_DWORD *)(a2 + 12) = v17;
          v18 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
          *(_QWORD *)(a2 + 16) = v18;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _BOOL8 result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  int v23;

  v4 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(a2 - 24, a1))
      {
        v6 = *(_QWORD *)a1;
        *(_QWORD *)a1 = *(_QWORD *)(a2 - 24);
        *(_QWORD *)(a2 - 24) = v6;
        LODWORD(v6) = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 - 16);
        *(_DWORD *)(a2 - 16) = v6;
        LODWORD(v6) = *(_DWORD *)(a1 + 12);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 - 12);
        *(_DWORD *)(a2 - 12) = v6;
        v7 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 - 8);
        *(_QWORD *)(a2 - 8) = v7;
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(a1, a1 + 24, a2 - 24);
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(a1, a1 + 24, a1 + 48, a2 - 24);
      return 1;
    case 5uLL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(a1, a1 + 24, a1 + 48, a1 + 72, a2 - 24);
      return 1;
    default:
      v8 = a1 + 48;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>(a1, a1 + 24, a1 + 48);
      v9 = a1 + 72;
      if (a1 + 72 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (2)
  {
    if (!std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>(v9, v8))goto LABEL_21;
    v12 = *(_QWORD *)v9;
    v13 = *(_DWORD *)(v9 + 8);
    v14 = *(_DWORD *)(v9 + 12);
    v15 = *(_QWORD *)(v9 + 16);
    *(_QWORD *)v9 = *(_QWORD *)v8;
    *(_DWORD *)(v9 + 8) = *(_DWORD *)(v8 + 8);
    *(_DWORD *)(v9 + 12) = *(_DWORD *)(v8 + 12);
    *(_QWORD *)(v9 + 16) = *(_QWORD *)(v8 + 16);
    v16 = a1;
    if (v8 == a1)
      goto LABEL_20;
    v17 = v10;
    while (1)
    {
      v18 = a1 + v17;
      v19 = *(_QWORD *)(a1 + v17 + 24);
      if (v12 < v19)
      {
        v20 = *(_DWORD *)(v18 + 32);
        goto LABEL_17;
      }
      if (v19 < v12)
        goto LABEL_19;
      v20 = *(_DWORD *)(a1 + v17 + 32);
      if (v13 >= v20)
      {
        if (v20 < v13)
          goto LABEL_19;
        v21 = *(_DWORD *)(a1 + v17 + 36);
        if (v14 >= v21)
        {
          if (v21 < v14)
          {
LABEL_19:
            v16 = v8;
            goto LABEL_20;
          }
          if (v15 >= *(_QWORD *)(a1 + v17 + 40))
            break;
        }
      }
LABEL_17:
      v8 -= 24;
      *(_QWORD *)(v18 + 48) = v19;
      v22 = a1 + v17;
      v23 = *(_DWORD *)(a1 + v17 + 36);
      *(_DWORD *)(v22 + 56) = v20;
      *(_DWORD *)(v22 + 60) = v23;
      *(_QWORD *)(v22 + 64) = *(_QWORD *)(a1 + v17 + 40);
      v17 -= 24;
      if (v17 == -48)
      {
        v16 = a1;
        goto LABEL_20;
      }
    }
    v16 = a1 + v17 + 48;
LABEL_20:
    *(_QWORD *)v16 = v12;
    *(_DWORD *)(v16 + 8) = v13;
    *(_DWORD *)(v16 + 12) = v14;
    *(_QWORD *)(v16 + 16) = v15;
    if (++v11 != 8)
    {
LABEL_21:
      v8 = v9;
      v10 += 24;
      v9 += 24;
      if (v9 == a2)
        return 1;
      continue;
    }
    return v9 + 24 == a2;
  }
}

uint64_t std::__split_buffer<std::tuple<unsigned int,SampleInfoWithPayload,unsigned long long>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    *(_QWORD *)(a1 + 16) = v2 - 104;
    v4 = *(void **)(v2 - 32);
    if (v4)
    {
      *(_QWORD *)(v2 - 24) = v4;
      operator delete(v4);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 104;
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

BOOL GRCPerFrameData::GreaterPQElement::operator()(_QWORD *a1, _QWORD *a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;

  v2 = a1[3];
  v3 = a2[3];
  v4 = v2 > v3;
  if (v2 == v3)
  {
    v5 = a1[6];
    v6 = a2[6];
    v4 = v5 > v6;
    if (v5 == v6)
    {
      v7 = a1[7];
      v8 = a2[7];
      v4 = v7 > v8;
      if (v7 == v8)
      {
        v9 = a1[5];
        v10 = a2[5];
        v4 = v9 > v10;
        if (v9 == v10)
        {
          v11 = a1[8];
          v12 = a2[8];
          v4 = v11 > v12;
          if (v11 == v12)
            return a1[9] > a2[9];
        }
      }
    }
  }
  return v4;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,unsigned int &,int>(uint64_t a1, unsigned int a2, int a3, int a4)
{
  unint64_t v4;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  void **v11;
  _QWORD *v12;
  unint64_t v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v8 = a2;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v4 = a2;
      if (v9 <= a2)
        v4 = a2 % v9;
    }
    else
    {
      v4 = ((_DWORD)v9 - 1) & a2;
    }
    v11 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v11)
    {
      v12 = *v11;
      if (*v11)
      {
        do
        {
          v13 = v12[1];
          if (v13 == a2)
          {
            if (*((_DWORD *)v12 + 4) == a2)
              return v12;
          }
          else
          {
            if (v10.u32[0] > 1uLL)
            {
              if (v13 >= v9)
                v13 %= v9;
            }
            else
            {
              v13 &= v9 - 1;
            }
            if (v13 != v4)
              break;
          }
          v12 = (_QWORD *)*v12;
        }
        while (v12);
      }
    }
  }
  v12 = operator new(0x18uLL);
  *v12 = 0;
  v12[1] = v8;
  *((_DWORD *)v12 + 4) = a3;
  *((_DWORD *)v12 + 5) = a4;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    v16 = 1;
    if (v9 >= 3)
      v16 = (v9 & (v9 - 1)) != 0;
    v17 = v16 | (2 * v9);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v19);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v9 <= v8)
        v4 = v8 % v9;
      else
        v4 = v8;
    }
    else
    {
      v4 = ((_DWORD)v9 - 1) & v8;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v21)
  {
    *v12 = *v21;
LABEL_38:
    *v21 = v12;
    goto LABEL_39;
  }
  *v12 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v12;
  *(_QWORD *)(v20 + 8 * v4) = a1 + 16;
  if (*v12)
  {
    v22 = *(_QWORD *)(*v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9)
        v22 %= v9;
    }
    else
    {
      v22 &= v9 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v12;
}

void sub_2FA9FC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::set<ProgramAddressHelper::ProgramAddressInfo>::set[abi:nn180100](uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t *v15;
  uint64_t *v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v20;

  *(_QWORD *)(a1 + 8) = 0;
  v3 = a1 + 8;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  v4 = a2 + 1;
  v5 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    while (1)
    {
      v6 = *(_QWORD *)(a1 + 8);
      v7 = v3;
      if (*(_QWORD *)a1 == v3)
        break;
      v8 = *(_QWORD *)(a1 + 8);
      v9 = v3;
      if (v6)
      {
        do
        {
          v7 = v8;
          v8 = *(_QWORD *)(v8 + 8);
        }
        while (v8);
      }
      else
      {
        do
        {
          v7 = *(_QWORD *)(v9 + 16);
          v10 = *(_QWORD *)v7 == v9;
          v9 = v7;
        }
        while (v10);
      }
      v11 = *(_DWORD *)(v7 + 28);
      v12 = *((_DWORD *)v5 + 7);
      if (v11 == v12)
      {
        v13 = (unsigned __int16)*(_DWORD *)(v7 + 32);
        v14 = *((_DWORD *)v5 + 8);
        if (v13 == (unsigned __int16)v14)
        {
          if (HIWORD(*(_DWORD *)(v7 + 32)) < HIWORD(v14))
            break;
        }
        else if (v13 < (unsigned __int16)*((_DWORD *)v5 + 8))
        {
          break;
        }
      }
      else
      {
        if (v11 < v12)
          break;
        v14 = *((_DWORD *)v5 + 8);
      }
      v15 = std::__tree<ProgramAddressHelper::ProgramAddressInfo>::__find_equal<ProgramAddressHelper::ProgramAddressInfo>(a1, &v20, v12, v14);
LABEL_18:
      if (!*v15)
      {
        v16 = (uint64_t *)operator new(0x28uLL);
        *(uint64_t *)((char *)v16 + 28) = *(_QWORD *)((char *)v5 + 28);
        std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>>>::__insert_node_at((uint64_t **)a1, v20, (uint64_t **)v15, v16);
      }
      v17 = (_QWORD *)v5[1];
      if (v17)
      {
        do
        {
          v18 = v17;
          v17 = (_QWORD *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          v18 = (_QWORD *)v5[2];
          v10 = *v18 == (_QWORD)v5;
          v5 = v18;
        }
        while (!v10);
      }
      v5 = v18;
      if (v18 == v4)
        return a1;
    }
    if (v6)
    {
      v20 = v7;
      v15 = (uint64_t *)(v7 + 8);
    }
    else
    {
      v20 = v3;
      v15 = (uint64_t *)v3;
    }
    goto LABEL_18;
  }
  return a1;
}

void sub_2FAB84(_Unwind_Exception *a1)
{
  _QWORD **v1;

  std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>>>::destroy(*v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,std::set<ProgramAddressHelper::ProgramAddressInfo>>>(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;

  v6 = a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & a2;
    }
    v9 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = (_QWORD *)*v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v12 = operator new(0x30uLL);
  v10 = v12;
  *v12 = 0;
  v12[1] = v6;
  *((_DWORD *)v12 + 4) = *(_DWORD *)a3;
  v13 = (_QWORD *)(a3 + 16);
  v14 = *(_QWORD *)(a3 + 16);
  v12[3] = *(_QWORD *)(a3 + 8);
  v12[4] = v14;
  v15 = (char *)(v12 + 4);
  v16 = *(_QWORD *)(a3 + 24);
  v12[5] = v16;
  if (v16)
  {
    *(_QWORD *)(v14 + 16) = v15;
    *(_QWORD *)(a3 + 8) = v13;
    *v13 = 0;
    *(_QWORD *)(a3 + 24) = 0;
  }
  else
  {
    v12[3] = v15;
  }
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v7 || (float)(v18 * (float)v7) < v17)
  {
    v19 = 1;
    if (v7 >= 3)
      v19 = (v7 & (v7 - 1)) != 0;
    v20 = v19 | (2 * v7);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v22);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v23 = *(_QWORD *)a1;
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v24)
  {
    *v10 = *v24;
LABEL_41:
    *v24 = v10;
    goto LABEL_42;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v23 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v25 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v25 >= v7)
        v25 %= v7;
    }
    else
    {
      v25 &= v7 - 1;
    }
    v24 = (_QWORD *)(*(_QWORD *)a1 + 8 * v25);
    goto LABEL_41;
  }
LABEL_42:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_2FADCC(_Unwind_Exception *a1)
{
  _QWORD **v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,void *>>>::operator()[abi:nn180100](1, v1);
  _Unwind_Resume(a1);
}

void std::__tree<ProgramAddressHelper::ProgramAddressInfo>::__emplace_unique_impl<unsigned long long &,ProgramAddressHelper::eAddressRange,unsigned int &>(uint64_t **a1, unsigned int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  _DWORD *v8;
  unsigned int v9;
  uint64_t *v10;
  uint64_t v11;

  v8 = operator new(0x28uLL);
  v9 = a3 | (a4 << 16);
  v8[7] = a2;
  v8[8] = v9;
  v10 = std::__tree<ProgramAddressHelper::ProgramAddressInfo>::__find_equal<ProgramAddressHelper::ProgramAddressInfo>((uint64_t)a1, &v11, a2, v9);
  if (*v10)
    operator delete(v8);
  else
    std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>>>::__insert_node_at(a1, v11, (uint64_t **)v10, (uint64_t *)v8);
}

void std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int &>(uint64_t a1, unsigned int a2, int a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  uint64_t **v9;
  uint64_t *i;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v6 = a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & a2;
    }
    v9 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (uint64_t *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2)
            return;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  v12 = operator new(0x18uLL);
  *v12 = 0;
  v12[1] = v6;
  *((_DWORD *)v12 + 4) = a3;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v18);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v20)
  {
    *v12 = *v20;
LABEL_38:
    *v20 = v12;
    goto LABEL_39;
  }
  *v12 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v12;
  *(_QWORD *)(v19 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    v21 = *(_QWORD *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7)
        v21 %= v7;
    }
    else
    {
      v21 &= v7 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
}

void sub_2FB074(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<ProgramAddressHelper::ProgramAddressInfo>::__find_equal<ProgramAddressHelper::ProgramAddressInfo>(uint64_t a1, _QWORD *a2, unsigned int a3, unsigned int a4)
{
  uint64_t *result;
  uint64_t *v5;
  uint64_t *v6;
  unsigned int v7;
  uint64_t *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;

  v6 = *(uint64_t **)(a1 + 8);
  result = (uint64_t *)(a1 + 8);
  v5 = v6;
  if (v6)
  {
    v7 = HIWORD(a4);
    while (1)
    {
      while (1)
      {
        v8 = v5;
        v9 = *((_DWORD *)v5 + 7);
        if (v9 == a3)
          break;
        if (v9 <= a3)
        {
          if (v9 >= a3)
            goto LABEL_18;
          goto LABEL_15;
        }
LABEL_12:
        v5 = (uint64_t *)*v8;
        result = v8;
        if (!*v8)
          goto LABEL_18;
      }
      v10 = *((_DWORD *)v8 + 8);
      if ((unsigned __int16)a4 != (unsigned __int16)v10)
      {
        v11 = (unsigned __int16)*((_DWORD *)v8 + 8);
        if ((unsigned __int16)a4 >= v11)
        {
          if (v11 >= (unsigned __int16)a4)
            goto LABEL_18;
          goto LABEL_15;
        }
        goto LABEL_12;
      }
      if (v7 < HIWORD(v10))
        goto LABEL_12;
      if (HIWORD(v10) >= v7)
        goto LABEL_18;
LABEL_15:
      result = v8 + 1;
      v5 = (uint64_t *)v8[1];
      if (!v5)
        goto LABEL_18;
    }
  }
  v8 = result;
LABEL_18:
  *a2 = v8;
  return result;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,void *>>>::operator()[abi:nn180100](char a1, _QWORD **__p)
{
  if (a1)
    std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>>>::destroy(__p[4]);
  operator delete(__p);
}

void GRCDerivedCounterData::~GRCDerivedCounterData(GRCDerivedCounterData *this)
{
  void *v2;
  void **v3;

  v3 = (void **)((char *)this + 232);
  std::vector<std::vector<std::vector<BOOL>>>::__destroy_vector::operator()[abi:nn180100](&v3);

  v3 = (void **)((char *)this + 184);
  std::vector<std::unordered_map<unsigned int,GTEncoderSampleIndexInfo>>::__destroy_vector::operator()[abi:nn180100](&v3);
  std::unique_ptr<FrameRawCounterData>::reset[abi:nn180100]((void ***)this + 22, 0);
  v3 = (void **)((char *)this + 152);
  std::vector<PassSourceCounterInfo>::__destroy_vector::operator()[abi:nn180100](&v3);

  v2 = (void *)*((_QWORD *)this + 5);
  if (v2)
  {
    *((_QWORD *)this + 6) = v2;
    operator delete(v2);
  }

}

GRCDerivedCounterData *std::unique_ptr<GRCDerivedCounterData>::reset[abi:nn180100](GRCDerivedCounterData **a1)
{
  GRCDerivedCounterData *result;

  result = *a1;
  *a1 = 0;
  if (result)
  {
    GRCDerivedCounterData::~GRCDerivedCounterData(result);
    operator delete();
  }
  return result;
}

void std::vector<std::vector<std::vector<BOOL>>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;
  void **v6;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        v6 = v4;
        std::vector<std::vector<BOOL>>::__destroy_vector::operator()[abi:nn180100](&v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<PassSourceCounterInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  void *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (void *)*((_QWORD *)v4 - 3);
        if (v6)
        {
          *((_QWORD *)v4 - 2) = v6;
          operator delete(v6);
        }
        v4 -= 32;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void ___ZN21GRCCurrentFrameStream23AddFrameEncoderTimeDataEP12NSDictionary_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  unsigned int v8;
  void *v9;
  unsigned int v10;
  void *v11;
  void *v12;
  unsigned int v13;
  void *v14;
  id v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  BOOL v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t *v32;
  unint64_t *v33;
  __int128 v34;
  void *v35;
  void *v36;
  unsigned int v37;
  uint64_t v38;

  v5 = a2;
  v6 = a3;
  v7 = *(_QWORD *)(a1 + 40);
  v35 = v5;
  v36 = v6;
  v8 = objc_msgSend(v5, "unsignedIntValue");
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectAtIndexedSubscript:", 0));
  v10 = objc_msgSend(v9, "unsignedIntValue");

  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectAtIndexedSubscript:", 1));
  v37 = objc_msgSend(v11, "unsignedIntValue");

  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectAtIndexedSubscript:", 2));
  v13 = objc_msgSend(v12, "unsignedIntValue");

  if ((unint64_t)objc_msgSend(v6, "count") < 4)
  {
    v15 = 0;
    if (!v13)
      goto LABEL_25;
  }
  else
  {
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectAtIndexedSubscript:", 3));
    v15 = objc_msgSend(v14, "unsignedLongLongValue");

    v38 = v8;
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v7 + 88, v8, &v38)[3] = v15;
    if (!v13)
      goto LABEL_25;
  }
  v16 = 0;
  v17 = v8;
  do
  {
    if (*(_BYTE *)(a1 + 56))
    {
      v18 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * (v10 + v16));
      if (v18)
      {
        v19 = v37 + v16;
        v20 = 3 * v18 / 0x7DuLL;
        v21 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
        v23 = (unint64_t *)v21[7];
        v22 = v21[8];
        if ((unint64_t)v23 >= v22)
        {
          v25 = (unint64_t *)v21[6];
          v26 = ((char *)v23 - (char *)v25) >> 5;
          v27 = v26 + 1;
          if ((unint64_t)(v26 + 1) >> 59)
            abort();
          v28 = v22 - (_QWORD)v25;
          if (v28 >> 4 > v27)
            v27 = v28 >> 4;
          v29 = (unint64_t)v28 >= 0x7FFFFFFFFFFFFFE0;
          v30 = 0x7FFFFFFFFFFFFFFLL;
          if (!v29)
            v30 = v27;
          if (v30)
          {
            v30 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>>(v30);
            v25 = (unint64_t *)v21[6];
            v23 = (unint64_t *)v21[7];
          }
          else
          {
            v31 = 0;
          }
          v32 = (unint64_t *)(v30 + 32 * v26);
          *v32 = v20;
          v32[1] = v17;
          v32[2] = v19;
          v32[3] = (unint64_t)v15;
          v33 = v32;
          if (v23 != v25)
          {
            do
            {
              v34 = *((_OWORD *)v23 - 1);
              *((_OWORD *)v33 - 2) = *((_OWORD *)v23 - 2);
              *((_OWORD *)v33 - 1) = v34;
              v33 -= 4;
              v23 -= 4;
            }
            while (v23 != v25);
            v25 = (unint64_t *)v21[6];
          }
          v24 = v32 + 4;
          v21[6] = v33;
          v21[7] = v32 + 4;
          v21[8] = v30 + 32 * v31;
          if (v25)
            operator delete(v25);
        }
        else
        {
          *v23 = v20;
          v23[1] = v17;
          v24 = v23 + 4;
          v23[2] = v19;
          v23[3] = (unint64_t)v15;
        }
        v21[7] = v24;
      }
    }
    ++v16;
  }
  while (v16 != v13);
LABEL_25:

}

void sub_2FB5EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{

  _Unwind_Resume(a1);
}

void ___ZN21GRCCurrentFrameStream30PopulateProgramAddressDataInfoEP12NSDictionary_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;

  v5 = a2;
  v6 = a3;
  v7 = v6;
  if (v5 && v6)
  {
    v8 = *(_QWORD *)(a1 + 32);
    v9 = objc_msgSend(v6, "unsignedIntValue");
    v10 = objc_msgSend(v5, "unsignedIntValue");
    *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(v8 + 48, v10, &v10)+ 5) = v9;
  }

}

void sub_2FB6CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZN21GRCCurrentFrameStream30PopulateProgramAddressDataInfoEP12NSDictionary_block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  id v5;
  uint64_t v6;
  unsigned int v7;
  id v8;
  _QWORD v9[4];
  id v10;
  uint64_t v11;
  unsigned int v12;

  v8 = a2;
  v5 = a3;
  v6 = *(_QWORD *)(a1 + 32);
  if ((unint64_t)objc_msgSend(v5, "count") >= 2)
  {
    v7 = objc_msgSend(v8, "unsignedIntValue");
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = ___ZN21GRCCurrentFrameStream30PopulateProgramAddressDataInfoEP12NSDictionary_block_invoke_3;
    v9[3] = &unk_726BC8;
    v11 = v6;
    v10 = v8;
    v12 = v7;
    objc_msgSend(v5, "enumerateObjectsUsingBlock:", v9);

  }
}

void sub_2FB79C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void ___ZN21GRCCurrentFrameStream30PopulateProgramAddressDataInfoEP12NSDictionary_block_invoke_3(uint64_t a1, void *a2)
{
  unint64_t v2;
  id v4;
  void *v5;
  uint64_t v6;
  void *v7;
  unsigned int v8;
  void *v9;
  id v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  void **v14;
  _QWORD *v15;
  unint64_t v16;
  _QWORD *v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  int8x8_t prime;
  void *v24;
  void *v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  uint8x8_t v29;
  unint64_t v30;
  uint8x8_t v31;
  uint64_t v32;
  _QWORD *v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  char *v50;
  char *v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  void *v55;
  unsigned int v56;

  v4 = a2;
  v5 = v4;
  if (!v4)
    goto LABEL_94;
  if (!*(_QWORD *)(a1 + 32))
    goto LABEL_94;
  v6 = *(_QWORD *)(a1 + 40);
  if (objc_msgSend(v4, "count") != (char *)&dword_0 + 2)
    goto LABEL_94;
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "firstObject"));
  v8 = objc_msgSend(v7, "unsignedIntValue");

  v56 = v8;
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "lastObject"));
  v10 = objc_msgSend(v9, "unsignedLongLongValue");

  v11 = *(unsigned int *)(a1 + 48);
  v12 = *(_QWORD *)(v6 + 136);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      v2 = *(unsigned int *)(a1 + 48);
      if (v12 <= v11)
        v2 = v11 % v12;
    }
    else
    {
      v2 = ((_DWORD)v12 - 1) & v11;
    }
    v14 = *(void ***)(*(_QWORD *)(v6 + 128) + 8 * v2);
    if (v14)
    {
      v15 = *v14;
      if (*v14)
      {
        do
        {
          v16 = v15[1];
          if (v16 == v11)
          {
            if (*((_DWORD *)v15 + 4) == (_DWORD)v11)
              goto LABEL_77;
          }
          else
          {
            if (v13.u32[0] > 1uLL)
            {
              if (v16 >= v12)
                v16 %= v12;
            }
            else
            {
              v16 &= v12 - 1;
            }
            if (v16 != v2)
              break;
          }
          v15 = (_QWORD *)*v15;
        }
        while (v15);
      }
    }
  }
  v15 = operator new(0x30uLL);
  v17 = (_QWORD *)(v6 + 144);
  *v15 = 0;
  v15[1] = v11;
  *((_DWORD *)v15 + 4) = v11;
  v15[4] = 0;
  v15[5] = 0;
  v15[3] = 0;
  v18 = (float)(unint64_t)(*(_QWORD *)(v6 + 152) + 1);
  v19 = *(float *)(v6 + 160);
  if (v12 && (float)(v19 * (float)v12) >= v18)
  {
    v11 = v2;
    goto LABEL_67;
  }
  v20 = 1;
  if (v12 >= 3)
    v20 = (v12 & (v12 - 1)) != 0;
  v21 = v20 | (2 * v12);
  v22 = vcvtps_u32_f32(v18 / v19);
  if (v21 <= v22)
    prime = (int8x8_t)v22;
  else
    prime = (int8x8_t)v21;
  if (*(_QWORD *)&prime == 1)
  {
    prime = (int8x8_t)2;
  }
  else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
  {
    prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    v12 = *(_QWORD *)(v6 + 136);
  }
  if (*(_QWORD *)&prime <= v12)
  {
    if (*(_QWORD *)&prime >= v12)
      goto LABEL_63;
    v30 = vcvtps_u32_f32((float)*(unint64_t *)(v6 + 152) / *(float *)(v6 + 160));
    if (v12 < 3 || (v31 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
    {
      v30 = std::__next_prime(v30);
    }
    else
    {
      v32 = 1 << -(char)__clz(v30 - 1);
      if (v30 >= 2)
        v30 = v32;
    }
    if (*(_QWORD *)&prime <= v30)
      prime = (int8x8_t)v30;
    if (*(_QWORD *)&prime >= v12)
    {
      v12 = *(_QWORD *)(v6 + 136);
      goto LABEL_63;
    }
    if (!*(_QWORD *)&prime)
    {
      v55 = *(void **)(v6 + 128);
      *(_QWORD *)(v6 + 128) = 0;
      if (v55)
        operator delete(v55);
      v12 = 0;
      *(_QWORD *)(v6 + 136) = 0;
      goto LABEL_63;
    }
  }
  if (*(_QWORD *)&prime >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  v24 = operator new(8 * *(_QWORD *)&prime);
  v25 = *(void **)(v6 + 128);
  *(_QWORD *)(v6 + 128) = v24;
  if (v25)
    operator delete(v25);
  v26 = 0;
  *(int8x8_t *)(v6 + 136) = prime;
  do
    *(_QWORD *)(*(_QWORD *)(v6 + 128) + 8 * v26++) = 0;
  while (*(_QWORD *)&prime != v26);
  v27 = (_QWORD *)*v17;
  if (*v17)
  {
    v28 = v27[1];
    v29 = (uint8x8_t)vcnt_s8(prime);
    v29.i16[0] = vaddlv_u8(v29);
    if (v29.u32[0] > 1uLL)
    {
      if (v28 >= *(_QWORD *)&prime)
        v28 %= *(_QWORD *)&prime;
    }
    else
    {
      v28 &= *(_QWORD *)&prime - 1;
    }
    *(_QWORD *)(*(_QWORD *)(v6 + 128) + 8 * v28) = v17;
    v33 = (_QWORD *)*v27;
    if (*v27)
    {
      do
      {
        v34 = v33[1];
        if (v29.u32[0] > 1uLL)
        {
          if (v34 >= *(_QWORD *)&prime)
            v34 %= *(_QWORD *)&prime;
        }
        else
        {
          v34 &= *(_QWORD *)&prime - 1;
        }
        if (v34 != v28)
        {
          v35 = *(_QWORD *)(v6 + 128);
          if (!*(_QWORD *)(v35 + 8 * v34))
          {
            *(_QWORD *)(v35 + 8 * v34) = v27;
            goto LABEL_59;
          }
          *v27 = *v33;
          *v33 = **(_QWORD **)(*(_QWORD *)(v6 + 128) + 8 * v34);
          **(_QWORD **)(*(_QWORD *)(v6 + 128) + 8 * v34) = v33;
          v33 = v27;
        }
        v34 = v28;
LABEL_59:
        v27 = v33;
        v33 = (_QWORD *)*v33;
        v28 = v34;
      }
      while (v33);
    }
  }
  v12 = (unint64_t)prime;
LABEL_63:
  if ((v12 & (v12 - 1)) != 0)
  {
    if (v12 <= v11)
      v11 %= v12;
  }
  else
  {
    v11 = ((_DWORD)v12 - 1) & v11;
  }
LABEL_67:
  v36 = *(_QWORD *)(v6 + 128);
  v37 = *(_QWORD **)(v36 + 8 * v11);
  if (v37)
  {
    *v15 = *v37;
  }
  else
  {
    *v15 = *v17;
    *v17 = v15;
    *(_QWORD *)(v36 + 8 * v11) = v17;
    if (!*v15)
      goto LABEL_76;
    v38 = *(_QWORD *)(*v15 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v38 >= v12)
        v38 %= v12;
    }
    else
    {
      v38 &= v12 - 1;
    }
    v37 = (_QWORD *)(*(_QWORD *)(v6 + 128) + 8 * v38);
  }
  *v37 = v15;
LABEL_76:
  ++*(_QWORD *)(v6 + 152);
LABEL_77:
  v40 = v15[4];
  v39 = v15[5];
  if (v40 >= v39)
  {
    v42 = v15[3];
    v43 = (uint64_t)(v40 - v42) >> 4;
    v44 = v43 + 1;
    if ((unint64_t)(v43 + 1) >> 60)
      abort();
    v45 = v39 - v42;
    if (v45 >> 3 > v44)
      v44 = v45 >> 3;
    if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF0)
      v46 = 0xFFFFFFFFFFFFFFFLL;
    else
      v46 = v44;
    if (v46 >> 60)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v47 = (char *)operator new(16 * v46);
    v48 = &v47[16 * v43];
    v49 = &v47[16 * v46];
    *(_DWORD *)v48 = v8;
    *((_QWORD *)v48 + 1) = v10;
    v41 = v48 + 16;
    v51 = (char *)v15[3];
    v50 = (char *)v15[4];
    if (v50 != v51)
    {
      do
      {
        *((_OWORD *)v48 - 1) = *((_OWORD *)v50 - 1);
        v48 -= 16;
        v50 -= 16;
      }
      while (v50 != v51);
      v50 = (char *)v15[3];
    }
    v15[3] = v48;
    v15[4] = v41;
    v15[5] = v49;
    if (v50)
      operator delete(v50);
  }
  else
  {
    *(_DWORD *)v40 = v8;
    *(_QWORD *)(v40 + 8) = v10;
    v41 = (char *)(v40 + 16);
  }
  v15[4] = v41;
  v52 = *(_DWORD *)(a1 + 48);
  v53 = *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>((_QWORD *)(v6 + 48), v52)+ 5);
  v54 = v6 + 168;
  if (v53 == v8)
    *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v54, v8, &v56)+ 5) = v52;
  else
    *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v54, v8, &v56)+ 5) = (_DWORD)v10;
LABEL_94:

}

void sub_2FBD24(_Unwind_Exception *a1)
{
  void *v1;
  _QWORD *v2;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,void *>>>::operator()[abi:nn180100](1, v2);

  _Unwind_Resume(a1);
}

BOOL std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,std::less<GRCCurrentFrameStream::IsWorkloadThrottled(unsigned int)::TimestampInfoElement> &,std::__wrap_iter<GRCCurrentFrameStream::IsWorkloadThrottled(unsigned int)::TimestampInfoElement*>>(_BOOL8 result, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  _BOOL8 v5;
  unint64_t v6;
  _OWORD *v7;
  unint64_t v8;
  _OWORD *v9;
  unsigned int v10;
  int v11;
  _OWORD *v12;

  v3 = a3 - 2;
  if (a3 >= 2)
  {
    v5 = result;
    v6 = v3 >> 1;
    v7 = (_OWORD *)(result + 16 * (v3 >> 1));
    v9 = (_OWORD *)(a2 - 16);
    v8 = *(_QWORD *)(a2 - 16);
    v10 = *(_DWORD *)(a2 - 8);
    result = GRCCurrentFrameStream::IsWorkloadThrottled::TimestampInfoElement::operator<((uint64_t)v7, v8, v10);
    if (result)
    {
      v11 = *(_DWORD *)(a2 - 4);
      do
      {
        v12 = v7;
        *v9 = *v7;
        if (!v6)
          break;
        v6 = (v6 - 1) >> 1;
        v7 = (_OWORD *)(v5 + 16 * v6);
        result = GRCCurrentFrameStream::IsWorkloadThrottled::TimestampInfoElement::operator<((uint64_t)v7, v8, v10);
        v9 = v12;
      }
      while (result);
      *(_QWORD *)v12 = v8;
      *((_DWORD *)v12 + 2) = v10;
      *((_DWORD *)v12 + 3) = v11;
    }
  }
  return result;
}

BOOL GRCCurrentFrameStream::IsWorkloadThrottled(unsigned int)::TimestampInfoElement::operator<(uint64_t a1, unint64_t a2, unsigned int a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  _BOOL4 v8;
  BOOL v9;
  _BOOL4 v10;
  _BOOL4 v11;

  if (*(_QWORD *)a1 != a2)
    return *(_QWORD *)a1 > a2;
  v3 = *(_DWORD *)(a1 + 8);
  v4 = v3 & 1;
  v5 = a3 & 1;
  v6 = (v3 >> 1) & 1;
  v7 = (a3 >> 1) & 1;
  v8 = v3 >> 2 > a3 >> 2;
  v9 = v6 == v7;
  v10 = v6 > v7;
  if (!v9)
    v8 = v10;
  v9 = v4 == v5;
  v11 = v4 > v5;
  if (v9)
    return v8;
  else
    return v11;
}

void FillAttachmentPixelFormats(uint64_t a1, uint64_t *a2, unint64_t a3, void *a4)
{
  uint64_t v7;
  int v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  uint64_t v15;
  id v16;
  _OWORD v17[2];
  __int128 v18;
  uint64_t v19;

  v16 = a4;
  v7 = 0;
  v8 = 0;
  v9 = (uint64_t *)(a1 + 8);
  do
  {
    v11 = *v9;
    v9 += 8;
    v10 = v11;
    if (v11)
    {
      v19 = 0;
      v18 = 0u;
      memset(v17, 0, sizeof(v17));
      GTMTLSMContext_getTextureDescriptor(a2, v10, a3, (uint64_t)v17);
      v12 = WORD1(v18);
      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "colorAttachments"));
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "objectAtIndexedSubscript:", v7));
      objc_msgSend(v14, "setPixelFormat:", v12);

      v8 = HIBYTE(v18);
    }
    ++v7;
  }
  while (v7 != 8);
  if (v8 <= 1)
    v15 = 1;
  else
    v15 = v8;
  objc_msgSend(v16, "setRasterSampleCount:", v15);

}

uint64_t countStructMember(uint64_t a1)
{
  int v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v1 = *(unsigned __int8 *)(a1 + 24);
  if (v1 == 1)
  {
    v3 = *(_QWORD *)(a1 + 8);
    v4 = *(unsigned int *)(v3 + 16);
    if ((_DWORD)v4)
    {
      LODWORD(v5) = 0;
      v6 = *(_QWORD *)(v3 + 8);
      do
      {
        v5 = countStructMember(v6) + v5;
        v6 += 32;
        --v4;
      }
      while (v4);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if (v1 == 2)
      return countArrayType(*(_QWORD *)(a1 + 8));
    return 1;
  }
  return v5;
}

uint64_t nameStructType1(apr_array_header_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  const char **v7;
  const char **i;
  int v9;
  const char *v11;
  const char **v12;
  int v13;
  const char *v14;

  v3 = *(unsigned int *)(a2 + 16);
  if (!(_DWORD)v3)
    return 0;
  v6 = 0;
  v7 = *(const char ***)(a2 + 8);
  for (i = v7; ; i += 4)
  {
    v9 = countStructMember((uint64_t)i);
    if ((int)a3 < v9)
      break;
    ++v6;
    a3 = (a3 - v9);
    if (v3 == v6)
      return 0;
  }
  v11 = *i;
  if (!strncmp(v11, "user(", 5uLL))
    v11 = "fragmentMember%d";
  *(_QWORD *)apr_array_push(a1) = v11;
  v12 = &v7[4 * v6];
  v13 = *((unsigned __int8 *)v12 + 24);
  if (v13 == 1)
  {
    v14 = v12[1];
    *(_QWORD *)apr_array_push(a1) = ".";
    return nameStructType1(a1, v14, a3);
  }
  else if (v13 == 2)
  {
    return nameArrayType(a1, (uint64_t)v7[4 * v6 + 1], a3);
  }
  else
  {
    return 0;
  }
}

uint64_t processStructMember(apr_array_header_t *a1, uint64_t a2, uint64_t a3, apr_allocator_t *a4)
{
  void *v8;
  void *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;

  v8 = *(void **)a2;
  if (!strncmp(*(const char **)a2, "user(", 5uLL))
    v9 = v8;
  else
    v9 = 0;
  if (v9)
    v8 = apr_psprintf(a1->pool, "fragmentMember%d", (_DWORD)a4);
  *(_QWORD *)apr_array_push(a1) = v8;
  v10 = *(unsigned __int8 *)(a2 + 24);
  switch(v10)
  {
    case 1:
      v11 = processStructType(a1, *(_QWORD *)(a2 + 8), a3, a4);
      break;
    case 60:
      v11 = processPointerType(a1, *(_QWORD *)(a2 + 8), a3, a4);
      break;
    case 2:
      v11 = processArrayType(a1, *(_QWORD *)(a2 + 8), a3, a4);
      break;
    default:
      processDataType(a1, *(unsigned __int8 *)(a2 + 25), v10, a3);
      v12 = 1;
      if (!v9)
        goto LABEL_14;
      goto LABEL_13;
  }
  v12 = v11;
  if (v9)
  {
LABEL_13:
    *(_QWORD *)apr_array_push(a1) = "[[ ";
    *(_QWORD *)apr_array_push(a1) = v9;
    *(_QWORD *)apr_array_push(a1) = " ]]";
  }
LABEL_14:
  *(_QWORD *)apr_array_push(a1) = ";\n";
  return v12;
}

_QWORD *GenerateStringForWritingDataToTexture(apr_array_header_t *arr, uint64_t a2)
{
  char *v4;
  const char *v5;
  _QWORD *result;

  if (*(unsigned __int8 *)(a2 + 14) - 3 > 0x35)
    v4 = 0;
  else
    v4 = off_726C78[(*(_BYTE *)(a2 + 14) - 3)];
  *(_QWORD *)apr_array_push(arr) = v4;
  if (*(unsigned __int8 *)(a2 + 14) - 4 > 0x34)
    v5 = "4(currData, 0, 0, 0)";
  else
    v5 = (&off_726FD8)[(*(_BYTE *)(a2 + 14) - 4)];
  result = apr_array_push(arr);
  *result = v5;
  return result;
}

uint64_t processArrayType(apr_array_header_t *a1, uint64_t a2, uint64_t a3, apr_allocator_t *a4)
{
  int i;
  char *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;

  for (i = 1; ; i *= v11)
  {
    v9 = apr_psprintf(a1->pool, "[%u]", *(unsigned __int16 *)(a2 + 20));
    *(_QWORD *)apr_array_push(a1) = v9;
    v10 = *(unsigned __int8 *)(a2 + 24);
    if (v10 != 2)
      break;
    v11 = *(unsigned __int16 *)(a2 + 20);
    a2 = *(_QWORD *)(a2 + 8);
  }
  if (v10 == 1)
  {
    v12 = *(unsigned __int16 *)(a2 + 20);
    v13 = processStructType(a1, *(_QWORD *)(a2 + 8), a3, a4);
  }
  else
  {
    if (v10 != 60)
    {
      v14 = *(unsigned __int16 *)(a2 + 20);
      processDataType(a1, *(unsigned __int8 *)(a2 + 25), v10, a3);
      return (v14 * i);
    }
    v12 = *(unsigned __int16 *)(a2 + 20);
    v13 = processPointerType(a1, *(_QWORD *)(a2 + 8), a3, a4);
  }
  v14 = v13 * v12;
  return (v14 * i);
}

uint64_t processStructType(apr_array_header_t *a1, uint64_t a2, int a3, apr_allocator_t *a4)
{
  int v4;
  apr_array_header_t *v8;
  uint64_t nelts;
  uint64_t v10;
  char *elts;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  apr_pool_t *p;
  apr_pool_t *newpool;

  v4 = (int)a4;
  newpool = 0;
  apr_pool_create_ex(&newpool, a1->pool, 0, a4);
  p = newpool;
  v8 = apr_array_make(newpool, 8, 8);
  nelts = a1->nelts;
  if ((int)nelts > 1)
  {
    v10 = 0;
    do
    {
      elts = a1->elts;
      v12 = *(_QWORD *)&elts[8 * v10];
      v13 = nelts - 2;
      *(_QWORD *)&elts[8 * v10] = *(_QWORD *)&elts[8 * (int)--nelts];
      *(_QWORD *)&a1->elts[8 * (int)nelts] = v12;
      ++v10;
    }
    while (v13 > v10);
  }
  *(_QWORD *)apr_array_push(a1) = "} ";
  if (a3 >= 1)
  {
    v14 = a3;
    do
    {
      *(_QWORD *)apr_array_push(a1) = "\t";
      --v14;
    }
    while (v14);
  }
  v15 = *(unsigned int *)(a2 + 16);
  if ((int)v15 < 1)
  {
    v16 = 0;
  }
  else
  {
    LODWORD(v16) = 0;
    v17 = v15 + 1;
    do
    {
      v8->nelts = 0;
      v16 = processStructMember(v8, *(_QWORD *)(a2 + 8) + 32 * (v17 - 2), (a3 + 1), (v16 + v4))+ v16;
      v19 = apr_array_pstrcat(a1->pool, v8, v18);
      *(_QWORD *)apr_array_push(a1) = v19;
      --v17;
    }
    while (v17 > 1);
  }
  *(_QWORD *)apr_array_push(a1) = "struct {\n";
  if (a3 >= 1)
  {
    do
    {
      *(_QWORD *)apr_array_push(a1) = "\t";
      --a3;
    }
    while (a3);
  }
  v20 = a1->nelts;
  if ((int)v20 > 1)
  {
    v21 = 0;
    do
    {
      v22 = a1->elts;
      v23 = *(_QWORD *)&v22[8 * v21];
      v24 = v20 - 2;
      *(_QWORD *)&v22[8 * v21] = *(_QWORD *)&v22[8 * (int)--v20];
      *(_QWORD *)&a1->elts[8 * (int)v20] = v23;
      ++v21;
    }
    while (v24 > v21);
  }
  apr_pool_destroy(p);
  return v16;
}

uint64_t processPointerType(apr_array_header_t *arr, uint64_t a2, uint64_t a3, apr_allocator_t *a4)
{
  int v5;
  int v8;
  uint64_t v9;
  uint64_t v11;

  v5 = a3;
  v8 = *(unsigned __int8 *)(a2 + 22);
  if (v8 == 1)
  {
    push_front(arr, (uint64_t)"*");
    if (*(_BYTE *)(a2 + 22) == 1)
      v11 = *(_QWORD *)(a2 + 8);
    else
      v11 = 0;
    return processStructType(arr, v11, v5, a4);
  }
  else if (v8 == 2)
  {
    v9 = processArrayType(arr, *(_QWORD *)(a2 + 8), a3, a4);
    push_front(arr, (uint64_t)"(*");
    *(_QWORD *)apr_array_push(arr) = ")";
    return v9;
  }
  else
  {
    return 1;
  }
}

_QWORD *processDataType(apr_array_header_t *arr, int a2, int a3, int a4)
{
  uint64_t nelts;
  uint64_t v7;
  char *elts;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  unsigned int v12;
  char v13;
  char *v14;
  _QWORD *result;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;

  nelts = arr->nelts;
  if ((int)nelts >= 2)
  {
    v7 = 0;
    do
    {
      elts = arr->elts;
      v9 = *(_QWORD *)&elts[8 * v7];
      v10 = nelts - 2;
      *(_QWORD *)&elts[8 * v7] = *(_QWORD *)&elts[8 * (int)--nelts];
      *(_QWORD *)&arr->elts[8 * (int)nelts] = v9;
      ++v7;
    }
    while (v10 > v7);
  }
  if ((a3 - 62) > 0xFu)
  {
    v11 = 0;
    v13 = 1;
    goto LABEL_45;
  }
  v11 = 0;
  v12 = asc_4A9374[(a3 - 62)];
  v13 = 1;
  if (v12 > 0x45)
  {
    if (asc_4A9374[(a3 - 62)] > 0x5Bu)
    {
      if (asc_4A9374[(a3 - 62)] > 0x6Du)
      {
        if (v12 == 110)
        {
          v11 = "rgba16unorm";
        }
        else
        {
          if (v12 != 112)
            goto LABEL_45;
          v11 = "rgba16snorm";
        }
      }
      else if (v12 == 92)
      {
        v11 = "rg11b10f";
      }
      else
      {
        if (v12 != 93)
          goto LABEL_45;
        v11 = "rgb9e5";
      }
    }
    else if (asc_4A9374[(a3 - 62)] > 0x47u)
    {
      if (v12 == 72)
      {
        v11 = "rgba8snorm";
      }
      else
      {
        if (v12 != 90)
          goto LABEL_45;
        v11 = "rgb10a2";
      }
    }
    else if (v12 == 70)
    {
      v11 = "rgba8unorm";
    }
    else
    {
      v11 = "srgba8unorm";
    }
  }
  else if (asc_4A9374[(a3 - 62)] > 0x1Du)
  {
    if (asc_4A9374[(a3 - 62)] > 0x3Bu)
    {
      if (v12 == 60)
      {
        v11 = "rg16unorm";
      }
      else
      {
        if (v12 != 62)
          goto LABEL_45;
        v11 = "rg16snorm";
      }
    }
    else if (v12 == 30)
    {
      v11 = "rg8unorm";
    }
    else
    {
      if (v12 != 32)
        goto LABEL_45;
      v11 = "rg8snorm";
    }
  }
  else if (asc_4A9374[(a3 - 62)] > 0x13u)
  {
    if (v12 == 20)
    {
      v11 = "r16unorm";
    }
    else
    {
      if (v12 != 22)
        goto LABEL_45;
      v11 = "r16snorm";
    }
  }
  else if (v12 == 10)
  {
    v11 = "r8unorm";
  }
  else
  {
    if (v12 != 12)
      goto LABEL_45;
    v11 = "r8snorm";
  }
  v13 = 0;
  a3 = a2;
LABEL_45:
  if ((a3 - 3) > 0x35)
    v14 = 0;
  else
    v14 = off_726E28[(a3 - 3)];
  *(_QWORD *)apr_array_push(arr) = " ";
  result = apr_array_push(arr);
  if ((v13 & 1) != 0)
  {
    *result = v14;
  }
  else
  {
    *result = ">";
    *(_QWORD *)apr_array_push(arr) = v14;
    *(_QWORD *)apr_array_push(arr) = "<";
    result = apr_array_push(arr);
    *result = v11;
  }
  if (a4 >= 1)
  {
    do
    {
      result = apr_array_push(arr);
      *result = "\t";
      --a4;
    }
    while (a4);
  }
  v16 = arr->nelts;
  if ((int)v16 > 1)
  {
    v17 = 0;
    do
    {
      v18 = arr->elts;
      v19 = *(_QWORD *)&v18[8 * v17];
      v20 = v16 - 2;
      *(_QWORD *)&v18[8 * v17] = *(_QWORD *)&v18[8 * (int)--v16];
      *(_QWORD *)&arr->elts[8 * (int)v16] = v19;
      ++v17;
    }
    while (v20 > v17);
  }
  return result;
}

_QWORD *push_front(apr_array_header_t *arr, uint64_t a2)
{
  uint64_t nelts;
  uint64_t v5;
  char *elts;
  uint64_t v7;
  uint64_t v8;
  _QWORD *result;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;

  nelts = arr->nelts;
  if ((int)nelts >= 2)
  {
    v5 = 0;
    do
    {
      elts = arr->elts;
      v7 = *(_QWORD *)&elts[8 * v5];
      v8 = nelts - 2;
      *(_QWORD *)&elts[8 * v5] = *(_QWORD *)&elts[8 * (int)--nelts];
      *(_QWORD *)&arr->elts[8 * (int)nelts] = v7;
      ++v5;
    }
    while (v8 > v5);
  }
  result = apr_array_push(arr);
  *result = a2;
  v10 = arr->nelts;
  if ((int)v10 >= 2)
  {
    v11 = 0;
    do
    {
      v12 = arr->elts;
      v13 = *(_QWORD *)&v12[8 * v11];
      v14 = v10 - 2;
      *(_QWORD *)&v12[8 * v11] = *(_QWORD *)&v12[8 * (int)--v10];
      *(_QWORD *)&arr->elts[8 * (int)v10] = v13;
      ++v11;
    }
    while (v14 > v11);
  }
  return result;
}

uint64_t nameArrayType(apr_array_header_t *a1, uint64_t a2, int a3)
{
  int v6;
  int v7;
  int v8;
  char *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;

  v6 = countArrayType(a2);
  v7 = *(unsigned __int8 *)(a2 + 24);
  v8 = v6 / *(unsigned __int16 *)(a2 + 20);
  if (v7 == 1)
  {
    v11 = apr_psprintf(a1->pool, "[%u]", a3 / v8);
    *(_QWORD *)apr_array_push(a1) = v11;
    if (*(_BYTE *)(a2 + 24) == 1)
      v12 = *(_QWORD *)(a2 + 8);
    else
      v12 = 0;
    *(_QWORD *)apr_array_push(a1) = ".";
    return nameStructType1(a1, v12, (a3 % v8));
  }
  else if (v7 == 2)
  {
    v9 = apr_psprintf(a1->pool, "[%u]", a3 / v8);
    *(_QWORD *)apr_array_push(a1) = v9;
    if (*(_BYTE *)(a2 + 24) == 2)
      v10 = *(_QWORD *)(a2 + 8);
    else
      v10 = 0;
    return nameArrayType(a1, v10, (a3 % v8));
  }
  else
  {
    return 0;
  }
}

uint64_t countArrayType(uint64_t a1)
{
  int i;
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;

  for (i = 1; ; i *= v3)
  {
    v2 = *(unsigned __int8 *)(a1 + 24);
    if (v2 != 2)
      break;
    v3 = *(unsigned __int16 *)(a1 + 20);
    a1 = *(_QWORD *)(a1 + 8);
  }
  if (v2 == 1)
  {
    v4 = *(unsigned __int16 *)(a1 + 20);
    v5 = *(_QWORD *)(a1 + 8);
    v6 = *(unsigned int *)(v5 + 16);
    if ((_DWORD)v6)
    {
      v7 = 0;
      v8 = *(_QWORD *)(v5 + 8);
      do
      {
        v7 += countStructMember(v8);
        v8 += 32;
        --v6;
      }
      while (v6);
    }
    else
    {
      v7 = 0;
    }
    v9 = v7 * v4;
  }
  else
  {
    v9 = *(unsigned __int16 *)(a1 + 20);
  }
  return (v9 * i);
}

BOOL UpdateLibraryResource(id *a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id v10;
  void *v11;
  void *v12;
  id v13;
  id v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  void *v19;
  id v20;
  unint64_t v21;
  uint64_t Object;
  _QWORD *v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  id v27;
  void *v28;
  uint64_t v29;
  void *v30;
  id MTLCompileOptions;
  id v32;
  void *v33;
  id Error;
  void *v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  id v40;
  void *v41;
  void *v42;
  id v43;
  void *v44;
  id v45;
  id v46;
  void *v47;
  uint64_t v48;
  id v49;
  void *v50;
  id v51;
  void *v52;
  id v53;
  __CFString *v54;
  void *v55;
  void *v56;
  id v57;
  void *v58;
  void *v59;
  id v60;
  BOOL v61;
  void *v62;
  void *v63;
  apr_allocator_t *v64;
  apr_array_header_t *v65;
  int nelts;
  uint64_t i;
  _QWORD *v68;
  id v69;
  id v70;
  void *v71;
  uint64_t v72;
  void *v73;
  void *v74;
  int v75;
  uint64_t j;
  uint64_t v77;
  id v78;
  void *v79;
  void *v80;
  void *v81;
  id v82;
  id v83;
  id v84;
  id v85;
  void *v86;
  char v87;
  id v88;
  uint64_t v89;
  uint64_t *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void *v94;
  void *v95;
  void *v96;
  id v97;
  id v98;
  id v99;
  id v100;
  uint64_t v101;
  void *v102;
  void *k;
  void *v104;
  unsigned int v105;
  void *v106;
  id v107;
  id v108;
  uint64_t v109;
  void *v110;
  void *m;
  void *v112;
  unsigned int v113;
  void *v114;
  id v115;
  id v116;
  uint64_t v117;
  void *n;
  void *v119;
  void *v120;
  id v121;
  id v122;
  uint64_t v123;
  void *ii;
  void *v125;
  void *v126;
  id v127;
  id v128;
  uint64_t v129;
  void *jj;
  void *v131;
  void *v132;
  id v133;
  id v134;
  uint64_t v135;
  void *kk;
  void *v137;
  void *v138;
  id v139;
  id v140;
  uint64_t v141;
  void *mm;
  void *v143;
  void *v144;
  id v145;
  id v146;
  uint64_t v147;
  void *nn;
  void *v149;
  void *v150;
  id v151;
  void *v152;
  void *v153;
  id v155;
  apr_pool_t *p;
  _QWORD *v157;
  void *v158;
  id v159;
  id v160;
  void *v161;
  void *v162;
  id v163;
  id v164;
  id v165;
  id v166;
  id v167;
  id v168;
  id v169;
  id v170;
  uint64_t obj;
  id obja;
  id objb;
  id v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  uint64_t *v178;
  id v179;
  __int128 v180;
  unint64_t v181;
  unint64_t v182;
  __int128 v183;
  __int128 v184;
  id v185;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  __int128 v189;
  __int128 v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  __int128 v211;
  __int128 v212;
  __int128 v213;
  __int128 v214;
  __int128 v215;
  __int128 v216;
  __int128 v217;
  _BYTE v218[128];
  _BYTE v219[128];
  _BYTE v220[128];
  _BYTE v221[128];
  _BYTE v222[128];
  _BYTE v223[128];
  apr_pool_t *newpool[16];
  id v225[16];

  v7 = a2;
  v163 = a3;
  v8 = a4;
  v162 = v8;
  if (v8)
  {
    v9 = objc_msgSend(objc_alloc((Class)NSData), "initWithContentsOfURL:options:error:", v8, 0, 0);
    v10 = objc_msgSend(v7, "mutableCopy");
    v11 = v10;
    if (v9)
    {
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v9, CFSTR("IR"));
    }
    else
    {
      v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSData data](NSData, "data"));
      objc_msgSend(v11, "setObject:forKeyedSubscript:", v12, CFSTR("IR"));

    }
    v13 = objc_msgSend(v11, "copy");

    v7 = v13;
  }
  v174 = 0;
  v179 = 0;
  v183 = 0u;
  v184 = 0u;
  v185 = 0;
  v164 = v7;
  GTMTLReplayController_rewind((uint64_t)a1);
  v14 = a1[1];
  v15 = (char *)*a1;
  v16 = *((_QWORD *)*a1 + 5);
  v18 = *((_QWORD *)*a1 + 10);
  v17 = *((_QWORD *)*a1 + 11);
  v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v164, "objectForKeyedSubscript:", CFSTR("streamref")));
  v20 = objc_msgSend(v19, "unsignedLongLongValue");
  v21 = v17 + v18;

  Object = GTMTLSMContext_lastObject(*(_QWORD *)v16, (uint64_t)v20, v21);
  if (!Object)
  {
    v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Internal error: Unable to find object (%llu)"), v20));
    Error = GTUpdateShaderMakeError(1u, v33, 0, 0);
    v35 = (void *)objc_claimAutoreleasedReturnValue(Error);
    goto LABEL_21;
  }
  v23 = (_QWORD *)Object;
  v178 = (uint64_t *)v16;
  v167 = v14;
  v179 = v167;
  v24 = *(_OWORD *)(v15 + 8);
  v180 = v24;
  v181 = v18;
  v182 = v21;
  v25 = *(unsigned int *)v23;
  if ((_DWORD)v25 != 43)
  {
    if ((_DWORD)v25 == 62)
    {
      v165 = v164;
      v26 = v23[1];
      v157 = v23;
      if (v23[2] >= v18)
      {
        v27 = objc_alloc((Class)NSMutableSet);
        v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v26));
        v185 = objc_msgSend(v27, "initWithObjects:", v28, 0);

      }
      v158 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v167, "defaultDevice"));
      v161 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v165, "objectForKeyedSubscript:", CFSTR("source")));
      if (v161)
      {
        v29 = v23[13];
        if (v29)
        {
          v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v167, "dynamicLibraries"));
          MTLCompileOptions = MakeMTLCompileOptions(v29, v30);
          v32 = (id)objc_claimAutoreleasedReturnValue(MTLCompileOptions);

        }
        else
        {
          v32 = objc_alloc_init((Class)MTLCompileOptions);
        }
        objc_msgSend(v32, "setDebuggingEnabled:", 1);
        v160 = objc_msgSend(v158, "newLibraryWithSource:options:error:", v161, v32, &v174);
        v61 = v160 == 0;

      }
      else
      {
        v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v165, "objectForKeyedSubscript:", CFSTR("IR")));
        v60 = GTCreateMTLLibrary(a1, (uint64_t)v23, v59, &v174);
        v160 = (id)objc_claimAutoreleasedReturnValue(v60);
        v61 = v160 == 0;

      }
      if (v61)
      {

      }
      else
      {
        v159 = objc_alloc_init((Class)NSMutableDictionary);
        v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v26));
        objc_msgSend(v159, "setObject:forKeyedSubscript:", v160, v62);

        *(_QWORD *)&v183 = objc_msgSend(v159, "copy");
        obja = objc_alloc_init((Class)NSMutableDictionary);
        v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[1], "functionMap"));
        objc_msgSend(obja, "addEntriesFromDictionary:", v63);

        objc_msgSend(obja, "addEntriesFromDictionary:", v159);
        newpool[0] = 0;
        apr_pool_create_ex(newpool, 0, 0, v64);
        p = newpool[0];
        v65 = apr_array_make(newpool[0], 128, 8);
        v169 = objc_alloc_init((Class)NSMutableDictionary);
        GTMTLSMContext_getObjects(*(_DWORD **)(v16 + 224), v18, v65);
        nelts = v65->nelts;
        if (nelts >= 1)
        {
          for (i = 0; i < nelts; ++i)
          {
            v68 = *(_QWORD **)&v65->elts[8 * i];
            if (v68[5] == v26)
            {
              v69 = objc_msgSend(obja, "copy");
              v70 = GTCreateMTLFunction((uint64_t)a1, v68, v69, &v174);
              v71 = (void *)objc_claimAutoreleasedReturnValue(v70);

              if (!v71)
              {
                v155 = 0;
LABEL_49:
                v87 = 0;
LABEL_60:

                goto LABEL_61;
              }
              v72 = v68[1];
              v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v72));
              objc_msgSend(obja, "setObject:forKeyedSubscript:", v71, v73);

              v74 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v72));
              objc_msgSend(v169, "setObject:forKeyedSubscript:", v71, v74);

              nelts = v65->nelts;
            }
          }
        }
        v155 = objc_msgSend(v169, "copy");
        *((_QWORD *)&v184 + 1) = v155;

        v65->nelts = 0;
        v169 = objc_alloc_init((Class)NSMutableDictionary);
        GTMTLSMContext_getObjects(*(_DWORD **)(v16 + 96), v18, v65);
        v75 = v65->nelts;
        if (v75 >= 1)
        {
          for (j = 0; j < v75; ++j)
          {
            v77 = *(_QWORD *)&v65->elts[8 * j];
            if (*(_QWORD *)(v77 + 48) == v26)
            {
              v78 = obja;
              v79 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v26));
              v80 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v78, "objectForKeyedSubscript:", v79));

              if (!v80)
              {
                v97 = GTUpdateShaderMakeError(1u, CFSTR("Internal error: Failed to find runtime library for dylib"), 0, 0);
                v87 = 0;
                v174 = (id)objc_claimAutoreleasedReturnValue(v97);
                goto LABEL_60;
              }
              v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[1], "defaultDevice"));
              v225[0] = 0;
              v82 = objc_msgSend(v81, "newDynamicLibrary:error:", v80, v225);
              v83 = v225[0];
              if (v82)
              {
                v84 = v82;
              }
              else
              {
                v85 = GTUpdateShaderMakeError(4u, CFSTR("Failed to instantiate dynamic library"), 0, v83);
                v174 = (id)objc_claimAutoreleasedReturnValue(v85);
              }

              if (!v82)
                goto LABEL_49;
              v86 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v77 + 8)));
              objc_msgSend(v169, "setObject:forKeyedSubscript:", v82, v86);

              v75 = v65->nelts;
            }
          }
        }
        *((_QWORD *)&v183 + 1) = objc_msgSend(v169, "copy");

        if (!v161)
        {
          v169 = objc_alloc_init((Class)NSMutableDictionary);
          v89 = v157[13];
          if (v89)
          {
            v90 = *(uint64_t **)(v89 + 32);
            if (v90)
            {
              v91 = *(_QWORD *)(v89 + 40);
              if ((int)v91 >= 1)
              {
                v92 = v91;
                do
                {
                  v93 = *v90++;
                  v94 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v93));
                  v95 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v167, "dynamicLibraries"));
                  v96 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v95, "objectForKeyedSubscript:", v94));

                  if (v96)
                    objc_msgSend(v169, "setObject:forKeyedSubscript:", v96, v94);

                  --v92;
                }
                while (v92);
              }
            }
          }
          *(_QWORD *)&v184 = objc_msgSend(v169, "copy");
          v87 = 1;
          goto LABEL_60;
        }
        v87 = 1;
LABEL_61:
        apr_pool_destroy(p);

        if ((v87 & 1) != 0)
          goto LABEL_62;
      }
LABEL_129:
      v53 = 0;
      v52 = v164;
      goto LABEL_130;
    }
    v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Internal error: Unknown object type (%llu:%u)"), v20, v25));
    v51 = GTUpdateShaderMakeError(1u, v33, 0, 0);
    v35 = (void *)objc_claimAutoreleasedReturnValue(v51);
LABEL_21:
    v174 = v35;

    v52 = v164;
    v53 = 0;
    goto LABEL_130;
  }
  obj = v24;
  v36 = v164;
  if (v23[2] >= v18)
  {
    v54 = _GTMTLSMFunctionDisplayLabel(v23, obj);
    v55 = (void *)objc_claimAutoreleasedReturnValue(v54);
    v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Ensure the modified function '%@' isn't created during the capture"), v55));

    v57 = GTUpdateShaderMakeError(5u, CFSTR("Unable to update shader function"), v56, 0);
    v58 = (void *)objc_claimAutoreleasedReturnValue(v57);
LABEL_47:
    v174 = v58;

    goto LABEL_129;
  }
  v37 = GTMTLSMContext_lastObject(*(_QWORD *)v16, v23[5], v18);
  if (!v37)
  {
    v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Internal error: Unable to find library (%llu)"), v23[5]));
    v88 = GTUpdateShaderMakeError(1u, v56, 0, 0);
    v58 = (void *)objc_claimAutoreleasedReturnValue(v88);
    goto LABEL_47;
  }
  v38 = v37;
  v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v36, "objectForKeyedSubscript:", CFSTR("IR")));
  v40 = GTCreateMTLLibrary(a1, v38, v39, &v174);
  v41 = (void *)objc_claimAutoreleasedReturnValue(v40);
  if (!v41)
  {

    goto LABEL_129;
  }
  v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[1], "functionMap"));
  v43 = objc_msgSend(v42, "mutableCopy");

  v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v23[5]));
  objc_msgSend(v43, "setObject:forKeyedSubscript:", v41, v44);

  v45 = objc_msgSend(v43, "copy");
  v46 = GTCreateMTLFunction((uint64_t)a1, v23, v45, &v174);
  v47 = (void *)objc_claimAutoreleasedReturnValue(v46);

  if (!v47)
  {

    goto LABEL_129;
  }
  v48 = v23[1];
  v49 = objc_alloc_init((Class)NSMutableDictionary);
  v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v48));
  objc_msgSend(v49, "setObject:forKeyedSubscript:", v47, v50);

  v155 = objc_msgSend(v49, "copy");
  *((_QWORD *)&v184 + 1) = v155;

LABEL_62:
  v176 = 0u;
  v177 = 0u;
  v175 = 0u;
  v52 = v164;
  if ((GTUpdateShaderPipelines(&v178, (uint64_t)&v175, &v174) & 1) != 0)
  {
    v98 = a1[1];
    v99 = v155;
    v214 = 0u;
    v215 = 0u;
    v216 = 0u;
    v217 = 0u;
    objb = v99;
    v100 = objc_msgSend(v99, "countByEnumeratingWithState:objects:count:", &v214, v225, 16);
    if (v100)
    {
      v101 = *(_QWORD *)v215;
      v102 = v185;
      do
      {
        for (k = 0; k != v100; k = (char *)k + 1)
        {
          if (*(_QWORD *)v215 != v101)
            objc_enumerationMutation(objb);
          v104 = *(void **)(*((_QWORD *)&v214 + 1) + 8 * (_QWORD)k);
          v105 = objc_msgSend(v102, "containsObject:", v104);
          v106 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(objb, "objectForKeyedSubscript:", v104));
          if (v105)
            objc_msgSend(a1[18], "setObject:forKeyedSubscript:", v106, v104);
          else
            objc_msgSend(v98, "setFunction:forKey:", v106, objc_msgSend(v104, "unsignedLongLongValue"));

        }
        v100 = objc_msgSend(objb, "countByEnumeratingWithState:objects:count:", &v214, v225, 16);
      }
      while (v100);
    }
    v107 = (id)v183;
    v210 = 0u;
    v211 = 0u;
    v212 = 0u;
    v213 = 0u;
    v170 = v107;
    v108 = objc_msgSend(v107, "countByEnumeratingWithState:objects:count:", &v210, newpool, 16);
    if (v108)
    {
      v109 = *(_QWORD *)v211;
      v110 = v185;
      do
      {
        for (m = 0; m != v108; m = (char *)m + 1)
        {
          if (*(_QWORD *)v211 != v109)
            objc_enumerationMutation(v170);
          v112 = *(void **)(*((_QWORD *)&v210 + 1) + 8 * (_QWORD)m);
          v113 = objc_msgSend(v110, "containsObject:", v112);
          v114 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v170, "objectForKeyedSubscript:", v112));
          if (v113)
            objc_msgSend(a1[18], "setObject:forKeyedSubscript:", v114, v112);
          else
            objc_msgSend(v98, "setLibrary:forKey:", v114, objc_msgSend(v112, "unsignedLongLongValue"));

        }
        v108 = objc_msgSend(v170, "countByEnumeratingWithState:objects:count:", &v210, newpool, 16);
      }
      while (v108);
    }
    v115 = *((id *)&v183 + 1);
    v206 = 0u;
    v207 = 0u;
    v208 = 0u;
    v209 = 0u;
    v168 = v115;
    v116 = objc_msgSend(v115, "countByEnumeratingWithState:objects:count:", &v206, v223, 16);
    if (v116)
    {
      v117 = *(_QWORD *)v207;
      do
      {
        for (n = 0; n != v116; n = (char *)n + 1)
        {
          if (*(_QWORD *)v207 != v117)
            objc_enumerationMutation(v168);
          v119 = *(void **)(*((_QWORD *)&v206 + 1) + 8 * (_QWORD)n);
          v120 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v168, "objectForKeyedSubscript:", v119));
          objc_msgSend(v98, "setDynamicLibrary:forKey:", v120, objc_msgSend(v119, "unsignedLongLongValue"));

        }
        v116 = objc_msgSend(v168, "countByEnumeratingWithState:objects:count:", &v206, v223, 16);
      }
      while (v116);
    }
    v121 = (id)v175;
    v202 = 0u;
    v203 = 0u;
    v204 = 0u;
    v205 = 0u;
    v166 = v121;
    v122 = objc_msgSend(v166, "countByEnumeratingWithState:objects:count:", &v202, v222, 16);
    if (v122)
    {
      v123 = *(_QWORD *)v203;
      do
      {
        for (ii = 0; ii != v122; ii = (char *)ii + 1)
        {
          if (*(_QWORD *)v203 != v123)
            objc_enumerationMutation(v166);
          v125 = *(void **)(*((_QWORD *)&v202 + 1) + 8 * (_QWORD)ii);
          v126 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v166, "objectForKeyedSubscript:", v125));
          objc_msgSend(v98, "setRenderPipelineState:forKey:", v126, objc_msgSend(v125, "unsignedLongLongValue"));

        }
        v122 = objc_msgSend(v166, "countByEnumeratingWithState:objects:count:", &v202, v222, 16);
      }
      while (v122);
    }

    v127 = *((id *)&v175 + 1);
    v198 = 0u;
    v199 = 0u;
    v200 = 0u;
    v201 = 0u;
    v128 = objc_msgSend(v127, "countByEnumeratingWithState:objects:count:", &v198, v221, 16);
    if (v128)
    {
      v129 = *(_QWORD *)v199;
      do
      {
        for (jj = 0; jj != v128; jj = (char *)jj + 1)
        {
          if (*(_QWORD *)v199 != v129)
            objc_enumerationMutation(v127);
          v131 = *(void **)(*((_QWORD *)&v198 + 1) + 8 * (_QWORD)jj);
          v132 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v127, "objectForKeyedSubscript:", v131));
          objc_msgSend(v98, "setComputePipelineState:forKey:", v132, objc_msgSend(v131, "unsignedLongLongValue"));

        }
        v128 = objc_msgSend(v127, "countByEnumeratingWithState:objects:count:", &v198, v221, 16);
      }
      while (v128);
    }
    v133 = (id)v176;
    v194 = 0u;
    v195 = 0u;
    v196 = 0u;
    v197 = 0u;
    v134 = objc_msgSend(v133, "countByEnumeratingWithState:objects:count:", &v194, v220, 16);
    if (v134)
    {
      v135 = *(_QWORD *)v195;
      do
      {
        for (kk = 0; kk != v134; kk = (char *)kk + 1)
        {
          if (*(_QWORD *)v195 != v135)
            objc_enumerationMutation(v133);
          v137 = *(void **)(*((_QWORD *)&v194 + 1) + 8 * (_QWORD)kk);
          v138 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v133, "objectForKeyedSubscript:", v137));
          objc_msgSend(v98, "setFunctionHandle:forKey:", v138, objc_msgSend(v137, "unsignedLongLongValue"));

        }
        v134 = objc_msgSend(v133, "countByEnumeratingWithState:objects:count:", &v194, v220, 16);
      }
      while (v134);
    }
    v139 = *((id *)&v176 + 1);
    v190 = 0u;
    v191 = 0u;
    v192 = 0u;
    v193 = 0u;
    v140 = objc_msgSend(v139, "countByEnumeratingWithState:objects:count:", &v190, v219, 16);
    if (v140)
    {
      v141 = *(_QWORD *)v191;
      do
      {
        for (mm = 0; mm != v140; mm = (char *)mm + 1)
        {
          if (*(_QWORD *)v191 != v141)
            objc_enumerationMutation(v139);
          v143 = *(void **)(*((_QWORD *)&v190 + 1) + 8 * (_QWORD)mm);
          v144 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v139, "objectForKeyedSubscript:", v143));
          objc_msgSend(v98, "setVisibleFunctionTable:forKey:", v144, objc_msgSend(v143, "unsignedLongLongValue"));

        }
        v140 = objc_msgSend(v139, "countByEnumeratingWithState:objects:count:", &v190, v219, 16);
      }
      while (v140);
    }
    v145 = (id)v177;
    v186 = 0u;
    v187 = 0u;
    v188 = 0u;
    v189 = 0u;
    v146 = objc_msgSend(v145, "countByEnumeratingWithState:objects:count:", &v186, v218, 16);
    if (v146)
    {
      v147 = *(_QWORD *)v187;
      do
      {
        for (nn = 0; nn != v146; nn = (char *)nn + 1)
        {
          if (*(_QWORD *)v187 != v147)
            objc_enumerationMutation(v145);
          v149 = *(void **)(*((_QWORD *)&v186 + 1) + 8 * (_QWORD)nn);
          v150 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v145, "objectForKeyedSubscript:", v149));
          objc_msgSend(v98, "setIntersectionFunctionTable:forKey:", v150, objc_msgSend(v149, "unsignedLongLongValue"));

        }
        v146 = objc_msgSend(v145, "countByEnumeratingWithState:objects:count:", &v186, v218, 16);
      }
      while (v146);
    }

    v53 = *((id *)&v177 + 1);
    v52 = v164;
  }
  else
  {
    v53 = 0;
  }
  __destructor_8_s0_s8_s16_s24_s32_s40((id *)&v175);
LABEL_130:
  __destructor_8_s8_S_s48_s56_s64_s72_s80((id *)&v178);

  v151 = v174;
  v152 = v151;
  if (v53)
  {
    objc_msgSend(v163, "setObject:forKeyedSubscript:", v53, CFSTR("updatedPipelines"));
  }
  else
  {
    v153 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v151, "localizedDescription"));
    objc_msgSend(v163, "setObject:forKeyedSubscript:", v153, CFSTR("propagate"));

    objc_msgSend(v163, "setObject:forKeyedSubscript:", v152, CFSTR("error"));
  }

  return v53 != 0;
}

void sub_2FDE70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, apr_pool_t *p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,id a36)
{
  apr_pool_destroy(p);
  __destructor_8_s8_S_s48_s56_s64_s72_s80(&a36);
  _Unwind_Resume(a1);
}

id GTUpdateShaderMakeError(unsigned int a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id v10;
  void *v11;

  v7 = a3;
  v8 = a4;
  v9 = a2;
  v10 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithObjectsAndKeys:", v9, NSLocalizedDescriptionKey, 0);

  if (v7)
    objc_msgSend(v10, "setObject:forKeyedSubscript:", v7, NSLocalizedRecoverySuggestionErrorKey);
  if (v8)
    objc_msgSend(v10, "setObject:forKeyedSubscript:", v8, NSUnderlyingErrorKey);
  v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("GTUpdateShaderErrorDomain"), a1, v10));

  return v11;
}

id GTCreateMTLLibrary(id *a1, uint64_t a2, void *a3, _QWORD *a4)
{
  id v7;
  void *v8;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  unsigned int v16;
  id v17;
  void *v18;
  id v19;
  void *v20;
  id v21;
  id v22;
  void *v23;
  id v24;
  void *v25;
  id Error;
  id v27;
  dispatch_data_t v28;
  id v29;
  id v30;
  id v31;
  void *v32;
  void *v33;
  id v34;
  void *v36;
  id v37;
  void *v38;
  _QWORD *v39;
  id v40;
  id v41;
  id v42;

  v7 = a3;
  if (objc_msgSend(v7, "length"))
  {
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[1], "defaultDevice"));
    if (!*(_QWORD *)(a2 + 136))
      goto LABEL_15;
    v39 = a4;
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](NSUUID, "UUID"));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "UUIDString"));
    v11 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "substringToIndex:", 8));

    v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", *(_QWORD *)(a2 + 136)));
    v37 = v11;
    v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("tmp-%@"), v11));
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "stringByAppendingPathExtension:", v13));

    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[2821], "URLByAppendingPathComponent:", v14));
    v42 = 0;
    v16 = objc_msgSend(v7, "writeToURL:options:error:", v15, 1, &v42);
    v17 = v42;
    v18 = v17;
    v38 = v8;
    if (v16)
    {
      v41 = v17;
      v11 = objc_msgSend(v8, "newLibraryWithURL:error:", v15, &v41);
      v19 = v41;

      v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
      objc_msgSend(v20, "removeItemAtURL:error:", v15, 0);

      if (v11)
      {
        v21 = v11;
      }
      else
      {
        v24 = _GTMTLSMLibraryDisplayLabel(a2, *((_QWORD *)*a1 + 1));
        v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
        v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Failed to instantiate library <url> '%@'"), v25));

        if (v39)
        {
          Error = GTUpdateShaderMakeError(3u, v36, 0, v19);
          *v39 = (id)objc_claimAutoreleasedReturnValue(Error);
        }

      }
      v23 = v37;

    }
    else
    {
      v19 = v17;
      v23 = v11;
    }

    v8 = v38;
    a4 = v39;
    if ((v16 & 1) == 0)
    {
LABEL_15:
      v27 = objc_retainAutorelease(v7);
      v28 = dispatch_data_create(objc_msgSend(v27, "bytes"), (size_t)objc_msgSend(v27, "length"), 0, 0);
      v40 = 0;
      v11 = objc_msgSend(v8, "newLibraryWithData:error:", v28, &v40);
      v29 = v40;
      if (v11)
      {
        v30 = v11;
      }
      else
      {
        v31 = _GTMTLSMLibraryDisplayLabel(a2, *((_QWORD *)*a1 + 1));
        v32 = (void *)objc_claimAutoreleasedReturnValue(v31);
        v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Failed to instantiate library <data> '%@'"), v32));

        if (a4)
        {
          v34 = GTUpdateShaderMakeError(3u, v33, 0, v29);
          *a4 = (id)objc_claimAutoreleasedReturnValue(v34);
        }

      }
    }

  }
  else if (a4)
  {
    v22 = GTUpdateShaderMakeError(1u, CFSTR("Internal error: No library data"), 0, 0);
    v11 = 0;
    *a4 = (id)objc_claimAutoreleasedReturnValue(v22);
  }
  else
  {
    v11 = 0;
  }

  return v11;
}

id GTCreateMTLFunction(uint64_t a1, _QWORD *a2, void *a3, _QWORD *a4)
{
  id v7;
  void *v8;
  void *v9;
  uint64_t v10;
  id MTLIntersectionFunctionDescriptor;
  void *v12;
  id v13;
  void *v14;
  id v15;
  uint64_t v16;
  id MTLFunctionDescriptor;
  id v18;
  _BYTE *v19;
  id MTLFunctionConstantValues;
  void *v21;
  id Error;
  __CFString *v23;
  void *v24;
  void *v25;
  id v26;
  id v28;
  void *v29;
  void *v30;

  v7 = a3;
  v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a2[5]));
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", v8));

  if (v9)
  {
    v10 = a2[15];
    if (v10)
    {
      MTLIntersectionFunctionDescriptor = MakeMTLIntersectionFunctionDescriptor(v10, v7);
      v12 = (void *)objc_claimAutoreleasedReturnValue(MTLIntersectionFunctionDescriptor);
      v30 = 0;
      v13 = objc_msgSend(v9, "newIntersectionFunctionWithDescriptor:error:", v12, &v30);
      v14 = v30;
    }
    else
    {
      v16 = a2[14];
      if (!v16)
      {
        v19 = (_BYTE *)a2[7];
        if (!v19 || !*v19)
        {
          Error = GTUpdateShaderMakeError(1u, CFSTR("Internal error: empty function name"), 0, 0);
          v18 = (id)objc_claimAutoreleasedReturnValue(Error);
          goto LABEL_17;
        }
        v18 = (id)a2[9];
        v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:"));
        if (v18)
        {
          MTLFunctionConstantValues = MakeMTLFunctionConstantValues((_QWORD *)a2[9]);
          v21 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionConstantValues);
          v28 = 0;
          v13 = objc_msgSend(v9, "newFunctionWithName:constantValues:error:", v12, v21, &v28);
          v18 = v28;

        }
        else
        {
          v13 = objc_msgSend(v9, "newFunctionWithName:", v12);
        }
LABEL_9:

        if (v13)
        {
LABEL_20:

          goto LABEL_21;
        }
LABEL_17:
        v23 = _GTMTLSMFunctionDisplayLabel(a2, *(_QWORD *)(*(_QWORD *)a1 + 8));
        v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
        v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Failed to instantiate function '%@'"), v24));

        if (a4)
        {
          v26 = GTUpdateShaderMakeError(3u, v25, 0, v18);
          *a4 = (id)objc_claimAutoreleasedReturnValue(v26);
        }

        v13 = 0;
        goto LABEL_20;
      }
      MTLFunctionDescriptor = MakeMTLFunctionDescriptor(v16, v7);
      v12 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionDescriptor);
      v29 = 0;
      v13 = objc_msgSend(v9, "newFunctionWithDescriptor:error:", v12, &v29);
      v14 = v29;
    }
    v18 = v14;
    goto LABEL_9;
  }
  if (a4)
  {
    v15 = GTUpdateShaderMakeError(1u, CFSTR("Internal error: Failed to find runtime library for function"), 0, 0);
    v13 = 0;
    *a4 = (id)objc_claimAutoreleasedReturnValue(v15);
  }
  else
  {
    v13 = 0;
  }
LABEL_21:

  return v13;
}

__CFString *_GTMTLSMFunctionDisplayLabel(_QWORD *a1, uint64_t a2)
{
  _BYTE *v4;
  __CFString *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  id v10;
  void *v11;
  uint64_t v13;

  if (!a1)
    return &stru_7282A8;
  v4 = (_BYTE *)a1[8];
  if (!v4
    || !*v4
    || (v5 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:"))) == 0)
  {
    v6 = a1[15];
    if (!v6 || (v7 = *(_QWORD *)(v6 + 8)) == 0)
    {
      v8 = a1[14];
      if (!v8 || (v7 = *(_QWORD *)(v8 + 8)) == 0)
        v7 = a1[7];
    }
    v9 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v7));
    if (v9)
      v5 = (__CFString *)v9;
    else
      v5 = CFSTR("MTLFunction");
  }
  v13 = a1[1];
  v10 = -[__CFString stringByAppendingFormat:](v5, "stringByAppendingFormat:", CFSTR(" 0x%llx"), *(_QWORD *)(*(_QWORD *)(*find_entry(a2, &v13, 8uLL, 0) + 32) + 8));
  v11 = (void *)objc_claimAutoreleasedReturnValue(v10);

  return (__CFString *)v11;
}

uint64_t GTUpdateShaderPipelines(uint64_t **a1, uint64_t a2, _QWORD *a3)
{
  apr_allocator_t *v4;
  apr_array_header_t *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  unsigned __int8 v10;
  apr_allocator_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  apr_pool_t *v16;
  BOOL ProgramUpdateObjectMapForPipelineObjects;
  id v18;
  void *v19;
  id v20;
  void *v21;
  id v22;
  id v23;
  uint64_t v24;
  void *i;
  uint64_t v26;
  void *v27;
  uint64_t MTLComputePipelineDescriptor;
  void *v29;
  void *v30;
  void *v31;
  id v32;
  void *v33;
  id v34;
  id v35;
  id v36;
  void *v37;
  __CFString *v38;
  uint64_t v39;
  uint64_t v40;
  NSNumber *v41;
  void *v42;
  id Error;
  apr_allocator_t *v44;
  apr_array_header_t *v45;
  uint64_t v46;
  _QWORD *v47;
  void *v48;
  void *v49;
  unsigned __int8 v50;
  _QWORD *v51;
  id v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  void *v59;
  void *v60;
  id v61;
  id v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  void *v66;
  BOOL v67;
  void *v68;
  id v69;
  id v70;
  id v71;
  uint64_t v72;
  void *k;
  uint64_t v74;
  void *v75;
  id MTLRenderPipelineFunctionsDescriptor;
  id v77;
  void *v78;
  void *v79;
  void *v80;
  id v81;
  id v82;
  id v83;
  void *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  BOOL v88;
  _QWORD *v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  uint64_t v93;
  BOOL v94;
  id v95;
  void *v96;
  id v97;
  uint64_t v98;
  void *j;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  uint64_t MTLRenderPipelineDescriptor;
  void *v104;
  void *v105;
  void *v106;
  id v107;
  uint64_t v108;
  uint64_t MTLMeshRenderPipelineDescriptor;
  void *v110;
  void *v111;
  id v112;
  void *v113;
  void *v114;
  id v115;
  void *v116;
  id v117;
  uint64_t *v118;
  uint64_t v119;
  id MTLTileRenderPipelineDescriptor;
  void *v121;
  void *v122;
  id v123;
  void *v124;
  void *v125;
  id v126;
  void *v127;
  void *v128;
  id v129;
  void *v130;
  void *v131;
  uint64_t v132;
  void *v133;
  __CFString *v134;
  uint64_t v135;
  NSNumber *v136;
  void *v137;
  char v138;
  id v139;
  id v140;
  void *v141;
  id v142;
  id v143;
  id v144;
  void *v145;
  apr_allocator_t *v146;
  apr_array_header_t *v147;
  uint64_t v148;
  uint64_t v149;
  void *v150;
  void *v151;
  uint64_t *v152;
  void *v153;
  void *v154;
  void *v155;
  id v156;
  void *v157;
  uint64_t *v158;
  void *v159;
  void *v160;
  void *v161;
  id v162;
  void *v163;
  void *v164;
  void *v165;
  void *v166;
  void *v167;
  void *v168;
  uint64_t v169;
  uint64_t v170;
  void *v171;
  void *v172;
  uint64_t v173;
  void *v174;
  id v175;
  void *v176;
  uint64_t MTLVisibleFunctionTableDescriptor;
  void *v178;
  uint64_t v179;
  uint64_t v180;
  void *v181;
  void *v182;
  uint64_t MTLIntersectionFunctionTableDescriptor;
  void *v184;
  id v185;
  void *v186;
  uint64_t v187;
  void *v188;
  id v189;
  void *v190;
  id v191;
  void *v192;
  id v193;
  uint64_t v194;
  id v195;
  id v196;
  id v197;
  id v198;
  id v199;
  id v201;
  uint64_t v202;
  id v203;
  id v204;
  id v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  id v209;
  id v210;
  uint64_t v211;
  uint64_t v212;
  id v214;
  id v216;
  id v217;
  id v218;
  uint64_t v219;
  id v220;
  void *v221;
  id v222;
  void *v223;
  id v224;
  void *v225;
  id v226;
  id v227;
  uint64_t nelts;
  id v229;
  id v230;
  apr_array_header_t *v231;
  uint64_t v232;
  id v233;
  uint64_t *v234;
  apr_array_header_t *v235;
  uint64_t v236;
  id v237;
  uint64_t *v238;
  apr_array_header_t *v239;
  uint64_t v240;
  uint64_t v241;
  id v242;
  id v243;
  id v244;
  id v245;
  id v246;
  id v247;
  id v248;
  __int128 v249;
  __int128 v250;
  __int128 v251;
  __int128 v252;
  id v253;
  id v254;
  id v255;
  __int128 v256;
  __int128 v257;
  __int128 v258;
  __int128 v259;
  apr_pool_t *newpool;
  apr_pool_t *v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  __int128 v265;
  __int128 v266;
  __int128 v267;
  __int128 v268;
  __int128 v269;
  __int128 v270;
  __int128 v271;
  __int128 v272;
  __int128 v273;
  __int128 v274;
  __int128 v275;
  __int128 v276;
  __int128 v277;
  __int128 v278;
  __int128 v279;
  __int128 v280;
  __int128 v281;
  __int128 v282;
  __int128 v283;
  __int128 v284;
  __int128 v285;
  __int128 v286;
  __int128 v287;
  __int128 v288;
  __int128 v289;
  __int128 v290;
  __int128 v291;
  __int128 v292;
  __int128 v293;
  __int128 v294;
  __int128 v295;
  __int128 v296;
  _QWORD v297[15];
  uint64_t v298;
  __int128 v299;
  apr_pool_t *p[16];
  __int128 v301;
  __int128 v302;
  __int128 v303;
  __int128 v304;
  uint64_t v305;
  _QWORD *v306;
  uint64_t v307;
  uint64_t v308;

  v216 = objc_alloc_init((Class)NSMutableDictionary);
  v217 = objc_alloc_init((Class)NSMutableDictionary);
  v234 = a1[1];
  v221 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v234, "defaultDevice"));
  newpool = 0;
  apr_pool_create_ex(&newpool, 0, 0, v4);
  v5 = apr_array_make(newpool, 128, 8);
  GTMTLSMContext_getObjects((_DWORD *)(*a1)[5], (unint64_t)a1[4], v5);
  nelts = v5->nelts;
  v231 = v5;
  if ((int)nelts < 1)
  {
LABEL_42:
    v220 = objc_msgSend(v217, "copy");
    goto LABEL_43;
  }
  v6 = 0;
  while (1)
  {
    v7 = *(_QWORD *)&v231->elts[8 * v6];
    if (v7)
      v240 = *(_QWORD *)(v7 + 8);
    else
      v240 = 0;
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v234, "unusedResourceKeys"));
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v240));
    v10 = objc_msgSend(v8, "containsObject:", v9);

    if ((v10 & 1) != 0)
      goto LABEL_41;
    v254 = 0;
    v255 = 0;
    v12 = *(_QWORD *)(v7 + 64);
    if (v12)
    {
      v13 = *(_QWORD *)(v12 + 40);
      v14 = *(unsigned __int16 *)(v12 + 96);
    }
    else
    {
      v13 = 0;
      v14 = 0;
    }
    v15 = *a1;
    v261 = 0;
    apr_pool_create_ex(&v261, 0, 0, v11);
    v295 = 0u;
    v296 = 0u;
    v293 = 0u;
    v294 = 0u;
    v291 = 0u;
    v292 = 0u;
    v289 = 0u;
    v290 = 0u;
    v287 = 0u;
    v288 = 0u;
    v285 = 0u;
    v286 = 0u;
    v283 = 0u;
    v284 = 0u;
    v281 = 0u;
    v282 = 0u;
    v279 = 0u;
    v280 = 0u;
    v277 = 0u;
    v278 = 0u;
    v275 = 0u;
    v276 = 0u;
    v273 = 0u;
    v274 = 0u;
    v271 = 0u;
    v272 = 0u;
    v269 = 0u;
    v270 = 0u;
    v267 = 0u;
    v268 = 0u;
    v265 = 0u;
    v266 = 0u;
    v16 = v261;
    GTMTLSMComputePipelineState_computePipelineDescriptor(v15, v7, &v265, v261);
    *(_QWORD *)&v256 = v297[12];
    *((_QWORD *)&v256 + 1) = v297;
    v257 = v299;
    *(_QWORD *)&v249 = &v256;
    *((_QWORD *)&v249 + 1) = 1;
    *(_QWORD *)&v250 = v13;
    *((_QWORD *)&v250 + 1) = v14;
    ProgramUpdateObjectMapForPipelineObjects = GetProgramUpdateObjectMapForPipelineObjects((uint64_t *)&v249, (id *)a1, &v255, &v254);
    apr_pool_destroy(v16);
    v237 = v255;
    v18 = v254;
    if (ProgramUpdateObjectMapForPipelineObjects)
      break;

LABEL_41:
    if (++v6 == nelts)
      goto LABEL_42;
  }
  v225 = v18;
  v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v234, "computePipelineDescriptorMap"));
  v20 = objc_msgSend(v19, "mutableCopy");

  v21 = v225;
  if (objc_msgSend(v237, "count"))
  {
    v303 = 0u;
    v304 = 0u;
    v301 = 0u;
    v302 = 0u;
    v22 = v237;
    v23 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v301, p, 16);
    if (v23)
    {
      v24 = *(_QWORD *)v302;
      do
      {
        for (i = 0; i != v23; i = (char *)i + 1)
        {
          if (*(_QWORD *)v302 != v24)
            objc_enumerationMutation(v22);
          v26 = *(_QWORD *)(*((_QWORD *)&v301 + 1) + 8 * (_QWORD)i);
          v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "objectForKeyedSubscript:", v26));
          objc_msgSend(v20, "setObject:forKeyedSubscript:", v27, v26);

        }
        v23 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v301, p, 16);
      }
      while (v23);
    }

    v21 = v225;
  }
  v295 = 0u;
  v296 = 0u;
  v293 = 0u;
  v294 = 0u;
  v291 = 0u;
  v292 = 0u;
  v289 = 0u;
  v290 = 0u;
  v287 = 0u;
  v288 = 0u;
  v285 = 0u;
  v286 = 0u;
  v283 = 0u;
  v284 = 0u;
  v281 = 0u;
  v282 = 0u;
  v279 = 0u;
  v280 = 0u;
  v277 = 0u;
  v278 = 0u;
  v275 = 0u;
  v276 = 0u;
  v273 = 0u;
  v274 = 0u;
  v271 = 0u;
  v272 = 0u;
  v269 = 0u;
  v270 = 0u;
  v267 = 0u;
  v268 = 0u;
  v265 = 0u;
  v266 = 0u;
  GTMTLSMComputePipelineState_computePipelineDescriptor(*a1, v7, &v265, newpool);
  MTLComputePipelineDescriptor = MakeMTLComputePipelineDescriptor(&v265, v20);
  v29 = (void *)objc_claimAutoreleasedReturnValue(MTLComputePipelineDescriptor);
  if (objc_msgSend(v21, "count"))
  {
    v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v29, "preloadedLibraries"));
    v31 = v30;
    if (v30)
    {
      v219 = objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "arrayByAddingObjectsFromArray:", v21));
      v32 = (id)v219;
    }
    else
    {
      v214 = objc_msgSend(v21, "copy");
      v32 = v214;
    }
    objc_msgSend(v29, "setPreloadedLibraries:", v32);
    v33 = v214;
    if (v31)
      v33 = (void *)v219;

  }
  v253 = 0;
  v248 = 0;
  v34 = objc_msgSend(v221, "newComputePipelineStateWithDescriptor:options:reflection:error:", v29, 0x40000, &v253, &v248);
  v35 = v253;
  v36 = v248;
  if (v34)
  {
    v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v240));
    objc_msgSend(v217, "setObject:forKeyedSubscript:", v34, v37);

    if (!v35)
      goto LABEL_40;
    v38 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "performanceStatistics"));
    if (v7)
      v39 = *(_QWORD *)(v7 + 8);
    else
      v39 = 0;
    v40 = (uint64_t)a1[2];
    *(_QWORD *)&v256 = v39;
    v41 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(*(_QWORD *)(*find_entry(v40, &v256, 8uLL, 0) + 32) + 8));
    v42 = (void *)objc_claimAutoreleasedReturnValue(v41);
    objc_msgSend(v216, "setObject:forKeyedSubscript:", v38, v42);
  }
  else
  {
    if (v298)
      v38 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR(": '%s'"), v298));
    else
      v38 = &stru_7282A8;
    v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Failed to recreate compute pipeline%@"), v38));
    if (a3)
    {
      Error = GTUpdateShaderMakeError(4u, v42, 0, v36);
      *a3 = (id)objc_claimAutoreleasedReturnValue(Error);
    }
  }

LABEL_40:
  if (v34)
    goto LABEL_41;
  v220 = 0;
LABEL_43:
  apr_pool_destroy(newpool);

  if (!v220)
  {
    v194 = 0;
    goto LABEL_212;
  }
  v218 = v216;
  v226 = objc_alloc_init((Class)NSMutableDictionary);
  v238 = a1[1];
  v223 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "defaultDevice"));
  newpool = 0;
  apr_pool_create_ex(&newpool, 0, 0, v44);
  v45 = apr_array_make(newpool, 128, 8);
  GTMTLSMContext_getObjects((_DWORD *)(*a1)[4], (unint64_t)a1[4], v45);
  v232 = v45->nelts;
  v235 = v45;
  if ((int)v232 < 1)
  {
LABEL_152:
    v235->nelts = 0;
    v222 = objc_msgSend(v226, "copy");
    goto LABEL_153;
  }
  v46 = 0;
  while (2)
  {
    v47 = *(_QWORD **)&v235->elts[8 * v46];
    if (v47)
      v241 = v47[1];
    else
      v241 = 0;
    v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "unusedResourceKeys"));
    v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v241));
    v50 = objc_msgSend(v48, "containsObject:", v49);

    if ((v50 & 1) != 0)
    {
LABEL_99:
      if (++v46 == v232)
        goto LABEL_152;
      continue;
    }
    break;
  }
  v51 = (_QWORD *)v47[10];
  if (!v51)
  {
    v253 = 0;
    v254 = 0;
    v63 = v47[7];
    if (v63)
    {
      v64 = *(_QWORD *)(v63 + 96);
      v63 = *(unsigned __int16 *)(v63 + 214);
    }
    else
    {
      v64 = 0;
    }
    v261 = 0;
    v262 = 0;
    v263 = v64;
    v264 = v63;
    v85 = v47[6];
    if (v85)
    {
      *(_QWORD *)&v301 = *(_QWORD *)(v85 + 1296);
      *((_QWORD *)&v301 + 1) = v85 + 1064;
      v302 = *(_OWORD *)(v85 + 1304);
      *(_QWORD *)&v303 = *(_QWORD *)(v85 + 1176);
      *((_QWORD *)&v303 + 1) = v85 + 872;
      v86 = *(_QWORD *)(v85 + 1184);
      v87 = *(_QWORD *)(v85 + 1192);
      *(_QWORD *)&v304 = v86;
      *((_QWORD *)&v304 + 1) = v87;
      v261 = (apr_pool_t *)&v301;
      v262 = 2;
      v88 = GetProgramUpdateObjectMapForPipelineObjects((uint64_t *)&v261, (id *)a1, &v254, &v253);
    }
    else
    {
      v89 = (_QWORD *)v47[9];
      if (v89)
      {
        v90 = v89[45];
        *(_QWORD *)&v301 = v89[46];
        *((_QWORD *)&v301 + 1) = v89 + 32;
        v302 = 0uLL;
        *(_QWORD *)&v303 = v90;
        *((_QWORD *)&v303 + 1) = v89 + 24;
        v304 = 0uLL;
        v305 = v89[43];
        v306 = v89 + 16;
        v307 = 0;
        v308 = 0;
        v261 = (apr_pool_t *)&v301;
        v262 = 3;
        v88 = GetProgramUpdateObjectMapForPipelineObjects((uint64_t *)&v261, (id *)a1, &v254, &v253);
      }
      else
      {
        v91 = (_QWORD *)v47[8];
        if (!v91)
        {
          v94 = 0;
LABEL_85:
          v70 = v254;
          v95 = v253;
          if (!v94)
          {
            v69 = v95;
            goto LABEL_98;
          }
          v229 = v95;
          v96 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "renderPipelineDescriptorMap"));
          v77 = objc_msgSend(v96, "mutableCopy");

          v251 = 0u;
          v252 = 0u;
          v249 = 0u;
          v250 = 0u;
          v69 = v70;
          v97 = objc_msgSend(v69, "countByEnumeratingWithState:objects:count:", &v249, p, 16);
          if (v97)
          {
            v98 = *(_QWORD *)v250;
            do
            {
              for (j = 0; j != v97; j = (char *)j + 1)
              {
                if (*(_QWORD *)v250 != v98)
                  objc_enumerationMutation(v69);
                v100 = *(_QWORD *)(*((_QWORD *)&v249 + 1) + 8 * (_QWORD)j);
                v101 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v69, "objectForKeyedSubscript:", v100));
                objc_msgSend(v77, "setObject:forKeyedSubscript:", v101, v100);

              }
              v97 = objc_msgSend(v69, "countByEnumeratingWithState:objects:count:", &v249, p, 16);
            }
            while (v97);
          }

          v102 = v47[6];
          if (v102)
          {
            MTLRenderPipelineDescriptor = MakeMTLRenderPipelineDescriptor(v102, v77);
            v104 = (void *)objc_claimAutoreleasedReturnValue(MTLRenderPipelineDescriptor);
            if (objc_msgSend(v229, "count"))
            {
              v105 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v104, "vertexPreloadedLibraries"));
              v106 = v105;
              if (v105)
              {
                v212 = objc_claimAutoreleasedReturnValue(objc_msgSend(v105, "arrayByAddingObjectsFromArray:", v229));
                v107 = (id)v212;
              }
              else
              {
                v210 = objc_msgSend(v229, "copy");
                v107 = v210;
              }
              objc_msgSend(v104, "setVertexPreloadedLibraries:", v107);
              v113 = v210;
              if (v106)
                v113 = (void *)v212;

              v114 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v104, "fragmentPreloadedLibraries"));
              if (v114)
              {
                v211 = objc_claimAutoreleasedReturnValue(objc_msgSend(v114, "arrayByAddingObjectsFromArray:", v229));
                v115 = (id)v211;
              }
              else
              {
                v209 = objc_msgSend(v229, "copy");
                v115 = v209;
              }
              objc_msgSend(v104, "setFragmentPreloadedLibraries:", v115);
              v116 = v209;
              if (v114)
                v116 = (void *)v211;

            }
            v247 = 0;
            v248 = 0;
            v82 = objc_msgSend(v223, "newRenderPipelineStateWithDescriptor:options:reflection:error:", v104, 0x40000, &v248, &v247);
            v117 = v248;
            v70 = v247;
            v118 = (uint64_t *)(v47[6] + 1200);
          }
          else
          {
            v108 = v47[9];
            if (v108)
            {
              MTLMeshRenderPipelineDescriptor = MakeMTLMeshRenderPipelineDescriptor(v108, v77);
              v104 = (void *)objc_claimAutoreleasedReturnValue(MTLMeshRenderPipelineDescriptor);
              if (objc_msgSend(v229, "count"))
              {
                v110 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v104, "objectPreloadedLibraries"));
                v111 = v110;
                if (v110)
                {
                  v208 = objc_claimAutoreleasedReturnValue(objc_msgSend(v110, "arrayByAddingObjectsFromArray:", v229));
                  v112 = (id)v208;
                }
                else
                {
                  v205 = objc_msgSend(v229, "copy");
                  v112 = v205;
                }
                objc_msgSend(v104, "setObjectPreloadedLibraries:", v112);
                v124 = v205;
                if (v111)
                  v124 = (void *)v208;

                v125 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v104, "meshPreloadedLibraries"));
                if (v125)
                {
                  v207 = objc_claimAutoreleasedReturnValue(objc_msgSend(v125, "arrayByAddingObjectsFromArray:", v229));
                  v126 = (id)v207;
                }
                else
                {
                  v204 = objc_msgSend(v229, "copy");
                  v126 = v204;
                }
                objc_msgSend(v104, "setMeshPreloadedLibraries:", v126);
                v127 = v204;
                if (v125)
                  v127 = (void *)v207;

                v128 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v104, "fragmentPreloadedLibraries"));
                if (v128)
                {
                  v206 = objc_claimAutoreleasedReturnValue(objc_msgSend(v128, "arrayByAddingObjectsFromArray:", v229));
                  v129 = (id)v206;
                }
                else
                {
                  v203 = objc_msgSend(v229, "copy");
                  v129 = v203;
                }
                objc_msgSend(v104, "setFragmentPreloadedLibraries:", v129);
                v130 = v203;
                if (v128)
                  v130 = (void *)v206;

              }
              v245 = 0;
              v246 = 0;
              v82 = objc_msgSend(v223, "newRenderPipelineStateWithMeshDescriptor:options:reflection:error:", v104, 0x40000, &v246, &v245);
              v117 = v246;
              v70 = v245;
              v118 = (uint64_t *)(v47[9] + 352);
            }
            else
            {
              v119 = v47[8];
              if (!v119)
              {
                v117 = 0;
                v70 = 0;
                goto LABEL_146;
              }
              MTLTileRenderPipelineDescriptor = MakeMTLTileRenderPipelineDescriptor(v119, v77);
              v104 = (void *)objc_claimAutoreleasedReturnValue(MTLTileRenderPipelineDescriptor);
              if (objc_msgSend(v229, "count"))
              {
                v121 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v104, "preloadedLibraries"));
                v122 = v121;
                if (v121)
                {
                  v202 = objc_claimAutoreleasedReturnValue(objc_msgSend(v121, "arrayByAddingObjectsFromArray:", v229));
                  v123 = (id)v202;
                }
                else
                {
                  v201 = objc_msgSend(v229, "copy");
                  v123 = v201;
                }
                objc_msgSend(v104, "setPreloadedLibraries:", v123);
                v131 = v201;
                if (v122)
                  v131 = (void *)v202;

              }
              v243 = 0;
              v244 = 0;
              v82 = objc_msgSend(v223, "newRenderPipelineStateWithTileDescriptor:options:reflection:error:", v104, 0x40000, &v244, &v243);
              v117 = v244;
              v70 = v243;
              v118 = (uint64_t *)(v47[8] + 96);
            }
          }
          v132 = *v118;

          if (v82)
          {
            v133 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v241));
            objc_msgSend(v226, "setObject:forKeyedSubscript:", v82, v133);

            if (v117)
            {
              v134 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v117, "performanceStatistics"));
              v135 = (uint64_t)a1[2];
              *(_QWORD *)&v301 = v47[1];
              v136 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(*(_QWORD *)(*find_entry(v135, &v301, 8uLL, 0) + 32) + 8));
              v137 = (void *)objc_claimAutoreleasedReturnValue(v136);
              objc_msgSend(v218, "setObject:forKeyedSubscript:", v134, v137);
              v138 = 1;
              goto LABEL_150;
            }
LABEL_76:

LABEL_98:
            goto LABEL_99;
          }
          if (v132)
          {
            v134 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR(": '%s'"), v132));
            goto LABEL_147;
          }
LABEL_146:
          v134 = &stru_7282A8;
LABEL_147:
          v137 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Failed to recreate render pipeline%@"), v134));
          if (a3)
          {
            v139 = GTUpdateShaderMakeError(4u, v137, 0, v70);
            v82 = 0;
            v138 = 0;
            *a3 = (id)objc_claimAutoreleasedReturnValue(v139);
          }
          else
          {
            v82 = 0;
            v138 = 0;
          }
LABEL_150:

          if ((v138 & 1) == 0)
            goto LABEL_199;
          goto LABEL_99;
        }
        *(_QWORD *)&v301 = v91[15];
        *((_QWORD *)&v301 + 1) = v91;
        v93 = v91[13];
        v92 = v91[14];
        *(_QWORD *)&v302 = v93;
        *((_QWORD *)&v302 + 1) = v92;
        v261 = (apr_pool_t *)&v301;
        v262 = 1;
        v88 = GetProgramUpdateObjectMapForPipelineObjects((uint64_t *)&v261, (id *)a1, &v254, &v253);
      }
    }
    v94 = v88;
    goto LABEL_85;
  }
  if (!v47[5])
  {
    v65 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v47[5]));
    v66 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v226, "objectForKeyedSubscript:", v65));
    v67 = v66 == 0;

    if (!v67)
    {
      v62 = 0;
      goto LABEL_64;
    }
    goto LABEL_99;
  }
  v52 = objc_alloc_init((Class)NSMutableDictionary);
  v53 = 0;
  v54 = v51[9];
  *(_QWORD *)&v301 = v51[8];
  DWORD2(v301) = v54;
  *(_QWORD *)&v302 = *v51;
  DWORD2(v302) = v51[1];
  v55 = v51[7];
  *(_QWORD *)&v303 = v51[6];
  DWORD2(v303) = v55;
  *(_QWORD *)&v304 = v51[4];
  DWORD2(v304) = v51[5];
  v305 = v51[2];
  LODWORD(v306) = v51[3];
  do
  {
    v56 = (uint64_t *)*((_QWORD *)&v301 + 2 * v53);
    if (v56)
    {
      v57 = *((unsigned int *)&v301 + 4 * v53 + 2);
      if ((int)v57 >= 1)
      {
        do
        {
          v58 = *v56++;
          v59 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v58));
          v60 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[9], "objectForKeyedSubscript:", v59));
          if (v60)
            objc_msgSend(v52, "setObject:forKeyedSubscript:", v60, v59);

          --v57;
        }
        while (v57);
      }
    }
    ++v53;
  }
  while (v53 != 5);
  v61 = objc_msgSend(v52, "copy");

  v62 = v61;
LABEL_64:
  v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "functionMap"));
  v69 = objc_msgSend(v68, "mutableCopy");

  v258 = 0u;
  v259 = 0u;
  v256 = 0u;
  v257 = 0u;
  v70 = v62;
  v71 = objc_msgSend(v70, "countByEnumeratingWithState:objects:count:", &v256, &v265, 16);
  if (v71)
  {
    v72 = *(_QWORD *)v257;
    do
    {
      for (k = 0; k != v71; k = (char *)k + 1)
      {
        if (*(_QWORD *)v257 != v72)
          objc_enumerationMutation(v70);
        v74 = *(_QWORD *)(*((_QWORD *)&v256 + 1) + 8 * (_QWORD)k);
        v75 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v70, "objectForKeyedSubscript:", v74));
        objc_msgSend(v69, "setObject:forKeyedSubscript:", v75, v74);

      }
      v71 = objc_msgSend(v70, "countByEnumeratingWithState:objects:count:", &v256, &v265, 16);
    }
    while (v71);
  }

  MTLRenderPipelineFunctionsDescriptor = MakeMTLRenderPipelineFunctionsDescriptor(v47[10], v69);
  v77 = (id)objc_claimAutoreleasedReturnValue(MTLRenderPipelineFunctionsDescriptor);
  v78 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v47[5]));
  v79 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v226, "objectForKeyedSubscript:", v78));
  v80 = v79;
  if (v79)
    v81 = v79;
  else
    v81 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v238, "renderPipelineStateForKey:", v47[5]));
  v82 = v81;

  v255 = 0;
  v83 = objc_msgSend(v82, "newRenderPipelineStateWithAdditionalBinaryFunctions:error:", v77, &v255);
  v229 = v255;
  if (v83)
  {
    v84 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v241));
    objc_msgSend(v226, "setObject:forKeyedSubscript:", v83, v84);

    goto LABEL_76;
  }
  if (a3)
  {
    v196 = GTUpdateShaderMakeError(4u, CFSTR("Failed to recreate render pipeline with additional shaders"), 0, v229);
    *a3 = (id)objc_claimAutoreleasedReturnValue(v196);
  }

LABEL_199:
  v222 = 0;
LABEL_153:
  apr_pool_destroy(newpool);

  if (!v222)
  {
    v194 = 0;
    goto LABEL_211;
  }
  v140 = objc_msgSend(v218, "copy");
  v141 = *(void **)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v140;

  v142 = objc_msgSend(v222, "copy");
  v143 = *(id *)a2;
  *(_QWORD *)a2 = v142;

  v144 = objc_msgSend(v220, "copy");
  v145 = *(void **)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v144;

  v230 = objc_alloc_init((Class)NSMutableDictionary);
  v224 = objc_alloc_init((Class)NSMutableDictionary);
  v233 = objc_alloc_init((Class)NSMutableDictionary);
  v242 = *(id *)a2;
  v227 = *(id *)(a2 + 8);
  p[0] = 0;
  apr_pool_create_ex(p, 0, 0, v146);
  v147 = apr_array_make(p[0], 128, 8);
  v147->nelts = 0;
  GTMTLSMContext_getObjects((_DWORD *)(*a1)[32], (unint64_t)a1[4], v147);
  v239 = v147;
  if (v147->nelts >= 1)
  {
    v148 = 0;
    while (1)
    {
      v149 = *(_QWORD *)&v147->elts[8 * v148];
      v236 = v149 ? *(_QWORD *)(v149 + 8) : 0;
      v150 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v149 + 56)));
      v151 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v242, "objectForKey:", v150));

      if (v151)
        break;
      v157 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v149 + 48)));
      v156 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v227, "objectForKey:", v157));

      if (v156)
      {
        v158 = a1[9];
        v159 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v149 + 40)));
        v160 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v158, "objectForKeyedSubscript:", v159));
        v161 = v160;
        if (v160)
        {
          v162 = v160;
        }
        else
        {
          v166 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[1], "functionMap"));
          v167 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v149 + 40)));
          v162 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v166, "objectForKeyedSubscript:", v167));

        }
        v165 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v156, "functionHandleWithFunction:", v162));
        v168 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v236));
        objc_msgSend(v233, "setObject:forKeyedSubscript:", v165, v168);

        goto LABEL_169;
      }
LABEL_170:

      ++v148;
      v147 = v239;
      if (v148 >= v239->nelts)
        goto LABEL_171;
    }
    v152 = a1[9];
    v153 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v149 + 40)));
    v154 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v152, "objectForKeyedSubscript:", v153));
    v155 = v154;
    if (v154)
    {
      v156 = v154;
    }
    else
    {
      v163 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[1], "functionMap"));
      v164 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v149 + 40)));
      v156 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v163, "objectForKeyedSubscript:", v164));

    }
    v162 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v151, "functionHandleWithFunction:stage:", v156, *(unsigned __int8 *)(v149 + 64)));
    v165 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v236));
    objc_msgSend(v233, "setObject:forKeyedSubscript:", v162, v165);
LABEL_169:

    goto LABEL_170;
  }
LABEL_171:
  v147->nelts = 0;
  GTMTLSMContext_getObjects((_DWORD *)(*a1)[7], (unint64_t)a1[4], v147);
  if (v147->nelts >= 1)
  {
    v169 = 0;
    while (1)
    {
      v170 = *(_QWORD *)&v147->elts[8 * v169];
      v171 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v170 + 128)));
      v172 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v242, "objectForKey:", v171));

      if (v172)
        break;
      v176 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v170 + 120)));
      v172 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v227, "objectForKey:", v176));

      if (v172)
      {
        MTLVisibleFunctionTableDescriptor = MakeMTLVisibleFunctionTableDescriptor(*(_QWORD *)(v170 + 104));
        v174 = (void *)objc_claimAutoreleasedReturnValue(MTLVisibleFunctionTableDescriptor);
        v175 = objc_msgSend(v172, "newVisibleFunctionTableWithDescriptor:", v174);
        if ((UpdateVisibleFunctionTable((uint64_t)a1, v175, v170, v233) & 1) == 0)
        {
          if (a3)
          {
            v198 = GTUpdateShaderMakeError(1u, CFSTR("Internal: Could not update visiable function table for compute pipeline"), 0, 0);
            *a3 = (id)objc_claimAutoreleasedReturnValue(v198);
          }
          goto LABEL_205;
        }
        goto LABEL_178;
      }
LABEL_179:
      ++v169;
      v147 = v239;
      if (v169 >= v239->nelts)
        goto LABEL_180;
    }
    v173 = MakeMTLVisibleFunctionTableDescriptor(*(_QWORD *)(v170 + 104));
    v174 = (void *)objc_claimAutoreleasedReturnValue(v173);
    v175 = objc_msgSend(v172, "newVisibleFunctionTableWithDescriptor:stage:", v174, *(unsigned __int8 *)(v170 + 168));
    if ((UpdateVisibleFunctionTable((uint64_t)a1, v175, v170, v233) & 1) == 0)
    {
      if (a3)
      {
        v195 = GTUpdateShaderMakeError(1u, CFSTR("Internal: Could not update visiable function table for render pipeline"), 0, 0);
        *a3 = (id)objc_claimAutoreleasedReturnValue(v195);
      }
LABEL_205:

      v194 = 0;
      goto LABEL_210;
    }
LABEL_178:
    v178 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v170 + 8)));
    objc_msgSend(v230, "setObject:forKeyedSubscript:", v175, v178);

    goto LABEL_179;
  }
LABEL_180:
  v147->nelts = 0;
  GTMTLSMContext_getObjects((_DWORD *)(*a1)[8], (unint64_t)a1[4], v147);
  *(_QWORD *)&v270 = 0;
  v268 = 0u;
  v269 = 0u;
  v266 = 0u;
  v267 = 0u;
  v265 = 0u;
  GTMTLIndirectResources_allResourcesByKey((uint64_t *)&v265, (_DWORD **)*a1, (unint64_t)a1[4], 1, p[0]);
  if (v147->nelts < 1)
  {
LABEL_189:
    v189 = objc_msgSend(v233, "copy");
    v190 = *(void **)(a2 + 16);
    *(_QWORD *)(a2 + 16) = v189;

    v191 = objc_msgSend(v230, "copy");
    v192 = *(void **)(a2 + 24);
    *(_QWORD *)(a2 + 24) = v191;

    v193 = objc_msgSend(v224, "copy");
    v182 = *(void **)(a2 + 32);
    *(_QWORD *)(a2 + 32) = v193;
    v194 = 1;
    goto LABEL_209;
  }
  v179 = 0;
  while (1)
  {
    v180 = *(_QWORD *)&v147->elts[8 * v179];
    v181 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v180 + 128)));
    v182 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v242, "objectForKey:", v181));

    if (v182)
    {
      MTLIntersectionFunctionTableDescriptor = MakeMTLIntersectionFunctionTableDescriptor(*(_QWORD *)(v180 + 104));
      v184 = (void *)objc_claimAutoreleasedReturnValue(MTLIntersectionFunctionTableDescriptor);
      v185 = objc_msgSend(v182, "newIntersectionFunctionTableWithDescriptor:stage:", v184, *(unsigned __int8 *)(v180 + 160));
      if ((UpdateIntersectionFunctionTable((uint64_t)a1, v185, v180, v233, v230, (uint64_t *)&v265) & 1) == 0)
      {
        if (a3)
        {
          v197 = GTUpdateShaderMakeError(1u, CFSTR("Internal: Could not update intersection function table for render pipeline"), 0, 0);
          *a3 = (id)objc_claimAutoreleasedReturnValue(v197);
        }
        goto LABEL_208;
      }
      goto LABEL_187;
    }
    v186 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v180 + 120)));
    v182 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v227, "objectForKey:", v186));

    if (v182)
      break;
LABEL_188:
    ++v179;
    v147 = v239;
    if (v179 >= v239->nelts)
      goto LABEL_189;
  }
  v187 = MakeMTLIntersectionFunctionTableDescriptor(*(_QWORD *)(v180 + 104));
  v184 = (void *)objc_claimAutoreleasedReturnValue(v187);
  v185 = objc_msgSend(v182, "newIntersectionFunctionTableWithDescriptor:", v184);
  if ((UpdateIntersectionFunctionTable((uint64_t)a1, v185, v180, v233, v230, (uint64_t *)&v265) & 1) != 0)
  {
LABEL_187:
    v188 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v180 + 8)));
    objc_msgSend(v224, "setObject:forKeyedSubscript:", v185, v188);

    goto LABEL_188;
  }
  if (a3)
  {
    v199 = GTUpdateShaderMakeError(1u, CFSTR("Internal: Could not update intersection function table for compute pipeline"), 0, 0);
    *a3 = (id)objc_claimAutoreleasedReturnValue(v199);
  }
LABEL_208:

  v194 = 0;
LABEL_209:

LABEL_210:
  apr_pool_destroy(p[0]);

LABEL_211:
LABEL_212:

  return v194;
}

void sub_3000AC(_Unwind_Exception *a1)
{
  apr_pool_destroy((apr_pool_t *)STACK[0x5A0]);
  _Unwind_Resume(a1);
}

void __destructor_8_s8_S_s48_s56_s64_s72_s80(id *a1)
{

  __destructor_8_s0_s8_s16_s24(a1 + 6);
}

BOOL GetProgramUpdateObjectMapForPipelineObjects(uint64_t *a1, id *a2, _QWORD *a3, _QWORD *a4)
{
  id v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  int v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  void *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  id v31;
  _BOOL8 v32;
  _QWORD *v34;
  id v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  int v45;

  v34 = a3;
  v6 = objc_alloc_init((Class)NSMutableDictionary);
  v36 = objc_alloc_init((Class)NSMutableArray);
  if ((int)a1[1] >= 1)
  {
    v7 = 0;
    v37 = a1[1];
    do
    {
      v8 = *a1;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(*a1 + 32 * v7), v34));
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2[9], "objectForKeyedSubscript:", v9));
      v39 = v7;
      if (v10)
      {
        objc_msgSend(v6, "setObject:forKeyedSubscript:", v10, v9);
        v11 = 1;
      }
      else
      {
        v11 = 0;
      }

      v12 = 0;
      v38 = v8;
      v13 = *(uint64_t **)(v8 + 32 * v39 + 8);
      v14 = v13[3];
      v40 = v13[2];
      v41 = v14;
      v15 = v13[1];
      v42 = *v13;
      v43 = v15;
      v17 = v13[6];
      v16 = v13[7];
      v44 = v17;
      v45 = v16;
      do
      {
        v18 = (uint64_t *)*(&v40 + 2 * v12);
        if (v18)
        {
          v19 = *((unsigned int *)&v40 + 4 * v12 + 2);
          if ((int)v19 >= 1)
          {
            do
            {
              v20 = *v18++;
              v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v20));
              v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2[9], "objectForKeyedSubscript:", v21));
              if (v22)
              {
                objc_msgSend(v6, "setObject:forKeyedSubscript:", v22, v21);
                ++v11;
              }

              --v19;
            }
            while (v19);
          }
        }
        ++v12;
      }
      while (v12 != 3);
      v23 = v38 + 32 * v39;
      v24 = *(uint64_t **)(v23 + 16);
      if (v24)
      {
        v25 = *(_QWORD *)(v23 + 24);
        if ((int)v25 >= 1)
        {
          v26 = v25;
          do
          {
            v27 = *v24++;
            v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v27));
            v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2[7], "objectForKeyedSubscript:", v28));
            if (v29)
              objc_msgSend(v6, "setObject:forKeyedSubscript:", v29, v28);

            --v26;
          }
          while (v26);
        }
      }
      if (v11 && objc_msgSend(a2[8], "count"))
      {
        v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2[8], "allValues"));
        objc_msgSend(v36, "addObjectsFromArray:", v30);

      }
      v7 = v39 + 1;
    }
    while (v39 + 1 != v37);
  }
  if (v34)
    *v34 = objc_msgSend(v6, "copy");
  if (a4)
    *a4 = objc_msgSend(v36, "copy");
  v31 = objc_msgSend(v6, "count", v34);
  v32 = (char *)objc_msgSend(v36, "count") + (_QWORD)v31 != 0;

  return v32;
}

uint64_t UpdateVisibleFunctionTable(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v7;
  id v8;
  apr_allocator_t *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  unint64_t i;
  uint64_t v22;
  void *v23;
  void *v24;
  uint64_t v25;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  void *v38;
  unint64_t v39;
  apr_pool_t *newpool;
  uint64_t v41;

  v7 = a2;
  v8 = a4;
  newpool = 0;
  apr_pool_create_ex(&newpool, 0, 0, v9);
  v27 = 0u;
  *(_QWORD *)&v28 = 0;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v29 = 0u;
  LODWORD(v27) = 83;
  *((_QWORD *)&v28 + 1) = -1;
  WORD1(v33) = 2;
  v31 = 0xFFFFFFFFFFFFFFFFLL;
  v39 = **(_QWORD **)(a3 + 104);
  v38 = apr_palloc(newpool, 8 * v39);
  bzero(v38, 8 * v39);
  v10 = *(_QWORD *)(a1 + 16);
  v41 = *(_QWORD *)(a3 + 8);
  v11 = *(_QWORD *)(*(_QWORD *)(*find_entry(v10, &v41, 8uLL, 0) + 32) + 32);
  if (v11)
  {
    v12 = 0;
    while (1)
    {
      v13 = atomic_load((unsigned int *)(v11 + 4));
      v14 = v12 + (v13 >> 6) - 1;
      if ((int)v14 > 0)
        break;
      v11 = *(_QWORD *)(v11 + 40);
      v12 = v14;
      if (!v11)
      {
        v12 = v14;
        goto LABEL_8;
      }
    }
  }
  else
  {
    v12 = 0;
  }
  v14 = 0;
LABEL_8:
  v15 = v12 | (unint64_t)(v14 << 32);
LABEL_9:
  v16 = v11 + 64;
  while (v11)
  {
    if ((*(_BYTE *)(v16 + ((uint64_t)(HIDWORD(v15) - (int)v15) << 6) + 15) & 8) == 0)
      break;
    v17 = (_QWORD *)(v16 + ((uint64_t)(HIDWORD(v15) - (int)v15) << 6));
    if (*v17 >= *(_QWORD *)(a1 + 32))
      break;
    GTMTLSMVisibleFunctionTableStateful_processTraceFuncWithMap((uint64_t)&v27, *(_QWORD *)(a1 + 24), (uint64_t)v17);
    v18 = atomic_load((unsigned int *)(v11 + 4));
    v19 = v15 + (v18 >> 6);
    v20 = (HIDWORD(v15) + 1);
    v15 = (v20 << 32) | v15;
    if ((_DWORD)v20 == v19 - 1)
    {
      v15 = (v20 << 32) | v20;
      v11 = *(_QWORD *)(v11 + 40);
      goto LABEL_9;
    }
  }
  if (v39)
  {
    for (i = 0; v39 > i; ++i)
    {
      v22 = *((_QWORD *)v38 + i);
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v22, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37));
      v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", v23));
      if (v24)
      {

      }
      else
      {
        v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 8), "functionHandleForKey:", v22));

        if (!v24)
        {
          v25 = 0;
          goto LABEL_22;
        }
      }
      objc_msgSend(v7, "setFunction:atIndex:", v24, i);

    }
  }
  v25 = 1;
LABEL_22:
  apr_pool_destroy(newpool);

  return v25;
}

void sub_300730(_Unwind_Exception *a1)
{
  uint64_t v1;

  apr_pool_destroy(*(apr_pool_t **)(v1 - 96));
  _Unwind_Resume(a1);
}

uint64_t UpdateIntersectionFunctionTable(uint64_t a1, void *a2, uint64_t a3, void *a4, void *a5, uint64_t *a6)
{
  id v11;
  id v12;
  id v13;
  apr_allocator_t *v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t i;
  int v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t v33;
  uint64_t *v34;
  int v35;
  void *v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  _DWORD v41[6];
  uint64_t v42;
  uint64_t v43;
  __int16 v44;
  char *v45;
  unint64_t v46;
  uint64_t v47;
  apr_pool_t *newpool;
  uint64_t v49;

  v11 = a2;
  v12 = a4;
  v13 = a5;
  newpool = 0;
  apr_pool_create_ex(&newpool, 0, 0, v14);
  bzero(v41, 0x3A0uLL);
  v41[0] = 60;
  v44 = 2;
  v42 = -1;
  v43 = -1;
  v46 = *(unsigned int *)(*(_QWORD *)(a3 + 104) + 8);
  v15 = 16 * v46;
  v45 = (char *)apr_palloc(newpool, 16 * v46);
  bzero(v45, v15);
  v16 = *(_QWORD *)(a1 + 16);
  v49 = *(_QWORD *)(a3 + 8);
  v17 = *(_QWORD *)(*(_QWORD *)(*find_entry(v16, &v49, 8uLL, 0) + 32) + 32);
  if (v17)
  {
    v18 = 0;
    while (1)
    {
      v19 = atomic_load((unsigned int *)(v17 + 4));
      v20 = v18 + (v19 >> 6) - 1;
      if ((int)v20 > 0)
        break;
      v17 = *(_QWORD *)(v17 + 40);
      v18 = v20;
      if (!v17)
      {
        v18 = v20;
        goto LABEL_8;
      }
    }
  }
  else
  {
    v18 = 0;
  }
  v20 = 0;
LABEL_8:
  v21 = v18 | (unint64_t)(v20 << 32);
LABEL_9:
  v22 = v17 + 64;
  while (v17)
  {
    if ((*(_BYTE *)(v22 + ((uint64_t)(HIDWORD(v21) - (int)v21) << 6) + 15) & 8) == 0)
      break;
    v23 = (_QWORD *)(v22 + ((uint64_t)(HIDWORD(v21) - (int)v21) << 6));
    if (*v23 >= *(_QWORD *)(a1 + 32))
      break;
    GTMTLSMIntersectionFunctionTableStateful_processTraceFuncWithMap((uint64_t)v41, *(_QWORD *)(a1 + 24), (uint64_t)v23, a6);
    v24 = atomic_load((unsigned int *)(v17 + 4));
    v25 = v21 + (v24 >> 6);
    v26 = (HIDWORD(v21) + 1);
    v21 = (v26 << 32) | v21;
    if ((_DWORD)v26 == v25 - 1)
    {
      v21 = (v26 << 32) | v26;
      v17 = *(_QWORD *)(v17 + 40);
      goto LABEL_9;
    }
  }
  if (v46)
  {
    v27 = 0;
    for (i = 0; i < v46; ++i)
    {
      v29 = *(_DWORD *)&v45[v27];
      switch(v29)
      {
        case 3:
          objc_msgSend(v11, "setOpaqueCurveIntersectionFunctionWithSignature:atIndex:", *(_QWORD *)&v45[v27 + 8], i);
          break;
        case 2:
          objc_msgSend(v11, "setOpaqueTriangleIntersectionFunctionWithSignature:atIndex:", *(_QWORD *)&v45[v27 + 8], i);
          break;
        case 1:
          v30 = *(_QWORD *)&v45[v27 + 8];
          if (v30)
          {
            v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)&v45[v27 + 8]));
            v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "objectForKeyedSubscript:", v31));
            if (v32)
            {

            }
            else
            {
              v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 8), "functionHandleForKey:", v30));

              if (!v32)
              {
LABEL_41:
                v39 = 0;
                goto LABEL_42;
              }
            }
            objc_msgSend(v11, "setFunction:atIndex:", v32, i);

          }
          break;
      }
      v27 += 16;
    }
  }
  v33 = 0;
  v34 = &v47;
  do
  {
    v35 = *((_DWORD *)v34 - 4);
    if (v35 == 2)
    {
      v37 = *(v34 - 1);
      v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v37));
      v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "objectForKeyedSubscript:", v38));
      if (v36)
      {

      }
      else
      {
        v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 8), "visibleFunctionTableForKey:", v37));

        if (!v36)
          goto LABEL_41;
      }
      objc_msgSend(v11, "setVisibleFunctionTable:atBufferIndex:", v36, v33);
      goto LABEL_38;
    }
    if (v35 == 1 && *(v34 - 1))
    {
      v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 8), "bufferForKey:"));
      if (!v36)
        goto LABEL_41;
      objc_msgSend(v11, "setBuffer:offset:atIndex:", v36, *v34, v33);
LABEL_38:

    }
    ++v33;
    v34 += 3;
  }
  while (v33 != 31);
  v39 = 1;
LABEL_42:
  apr_pool_destroy(newpool);

  return v39;
}

void sub_300AD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  apr_pool_destroy(*(apr_pool_t **)(v1 - 104));
  _Unwind_Resume(a1);
}

id _GTMTLSMLibraryDisplayLabel(uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  __CFString *v5;
  id v6;
  void *v7;
  uint64_t v9;

  v4 = *(_BYTE **)(a1 + 112);
  if (v4 && *v4)
    v5 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:"));
  else
    v5 = CFSTR("MTLLibrary");
  v9 = *(_QWORD *)(a1 + 8);
  v6 = -[__CFString stringByAppendingFormat:](v5, "stringByAppendingFormat:", CFSTR(" 0x%llx"), *(_QWORD *)(*(_QWORD *)(*find_entry(a2, &v9, 8uLL, 0) + 32) + 8));
  v7 = (void *)objc_claimAutoreleasedReturnValue(v6);

  return v7;
}

uint64_t GTResourceTrackerGetResourceType(uint64_t a1, uint64_t a2)
{
  _QWORD *entry;
  uint64_t v3;
  uint64_t v5;

  v5 = a1;
  entry = find_entry(a2, &v5, 8uLL, 0);
  if (*entry && (v3 = *(_QWORD *)(*entry + 32)) != 0)
    return GetFuncEnumConstructorType(*(_DWORD *)(*(_QWORD *)(v3 + 32) + 72));
  else
    return 0;
}

uint64_t GTResourceTrackerUsingResource(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  apr_pool_t **v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  apr_pool_t **v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;

  v17 = a3;
  if (a3)
  {
    v8 = (apr_pool_t **)result;
    result = (uint64_t)find_entry(result, &v17, 8uLL, 0);
    if (!*(_QWORD *)result || !*(_QWORD *)(*(_QWORD *)result + 32))
    {
      v9 = apr_palloc(*v8, 0x10uLL);
      *(_QWORD *)v9 = v17;
      apr_hash_set((apr_hash_t *)v8, v9, 8, v9);
      *(_QWORD *)&v18 = v17;
      v10 = *find_entry(a4, &v18, 8uLL, 0);
      if (v10 && (v11 = *(_QWORD *)(v10 + 32)) != 0)
      {
        v12 = *(_QWORD *)(v11 + 32);
        if (v12)
          v13 = v12 + 64;
        else
          v13 = 0;
      }
      else
      {
        v13 = 0;
      }
      result = GetFuncEnumConstructorType(*(_DWORD *)(v13 + 8));
      v9[2] = result;
      if (a2 != 16)
      {
        if (a2 != 80)
        {
          if (a2 != 22)
            return result;
          v18 = 0u;
          v19 = 0;
          v25 = 0u;
          v27 = 0u;
          v28 = 0u;
          v24 = 0u;
          v21 = 0u;
          v22 = 0u;
          LODWORD(v18) = 22;
          v20 = -1;
          WORD1(v25) = 2;
          v23 = 0xFFFFFFFFFFFFFFFFLL;
          v26 = 0xFFFFFFFFFFFFFFFFLL;
          GTMTLSMBuffer_processTraceFuncWithMap((char *)&v18, a5, (uint64_t *)v13);
          goto LABEL_14;
        }
        v18 = 0u;
        v19 = 0;
        v30 = 0u;
        v31 = 0u;
        v28 = 0u;
        v29 = 0u;
        v27 = 0u;
        v25 = 0u;
        v26 = 0u;
        v24 = 0u;
        v21 = 0u;
        v22 = 0u;
        LODWORD(v18) = 80;
        v20 = -1;
        WORD1(v25) = 2;
        v23 = 0xFFFFFFFFFFFFFFFFLL;
        v32 = 0xFFFFFFFFLL;
        GTMTLSMTexture_processTraceFuncWithMap((char *)&v18, a5, (uint64_t *)v13);
        v14 = v28;
        if ((_QWORD)v28)
        {
          v15 = v8;
          v16 = 80;
          return GTResourceTrackerUsingResource(v15, v16, v14, a4, a5);
        }
        v14 = *((_QWORD *)&v27 + 1);
        if (!*((_QWORD *)&v27 + 1))
        {
LABEL_14:
          v14 = v22;
          v15 = v8;
          v16 = 50;
          return GTResourceTrackerUsingResource(v15, v16, v14, a4, a5);
        }
LABEL_22:
        v15 = v8;
        v16 = 22;
        return GTResourceTrackerUsingResource(v15, v16, v14, a4, a5);
      }
      v18 = 0u;
      v19 = 0;
      v30 = 0u;
      v31 = 0u;
      v28 = 0u;
      v29 = 0u;
      v27 = 0u;
      v25 = 0u;
      v26 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      LODWORD(v18) = 16;
      v20 = -1;
      WORD1(v25) = 2;
      v23 = 0xFFFFFFFFFFFFFFFFLL;
      result = (uint64_t)GTMTLSMAccelerationStructure_processTraceFuncWithMap((char *)&v18, a5, (uint64_t *)v13);
      if ((_QWORD)v22)
        result = GTResourceTrackerUsingResource(v8, 50, v22, a4, a5);
      v14 = v28;
      if ((_QWORD)v28)
        goto LABEL_22;
    }
  }
  return result;
}

_QWORD *tracker_resource_get(uint64_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  apr_hash_t *v7;
  _QWORD *entry;
  _QWORD *v9;
  apr_pool_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  _OWORD *v17;
  int FuncEnumConstructorType;
  unsigned int v19;
  int v20;
  uint64_t ParentResource;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;

  v5 = a3;
  v23 = a3;
  GTResourceTrackerUsingResource(a1[2], a2, a3, *a1, a1[1]);
  ParentResource = GetParentResource(*a1, v5, a1[1]);
  if (ParentResource != v5)
  {
    find_entry(*a1, &ParentResource, 8uLL, 0);
    v5 = ParentResource;
    v23 = ParentResource;
  }
  if (!v5)
    return 0;
  v7 = (apr_hash_t *)a1[4];
  entry = find_entry((uint64_t)v7, &v23, 8uLL, 0);
  if (!*entry || (v9 = *(_QWORD **)(*entry + 32)) == 0)
  {
    v10 = *(apr_pool_t **)v7;
    v11 = *a1;
    v12 = a1[1];
    v24 = v23;
    v13 = *find_entry(v11, &v24, 8uLL, 0);
    if (v13)
    {
      v14 = *(_QWORD **)(v13 + 32);
      if (v14)
      {
        v15 = v14[4];
        if (v15)
        {
          if ((*(_BYTE *)(v15 + 79) & 8) != 0)
          {
            v16 = v15 + 64;
            goto LABEL_14;
          }
        }
      }
    }
    else
    {
      v14 = 0;
    }
    v16 = 0;
LABEL_14:
    v17 = apr_palloc(v10, 0x38uLL);
    v9 = v17;
    if (v17)
    {
      *((_QWORD *)v17 + 6) = 0;
      v17[1] = 0u;
      v17[2] = 0u;
      *v17 = 0u;
    }
    *(_QWORD *)v17 = v14[1];
    *((_QWORD *)v17 + 1) = v24;
    FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v16 + 8));
    v9[3] = -1;
    *((_DWORD *)v9 + 10) = FuncEnumConstructorType;
    v9[2] = a4;
    v9[4] = -1;
    if (FuncEnumConstructorType > 59)
    {
      if (FuncEnumConstructorType != 60)
      {
        if (FuncEnumConstructorType != 80)
        {
          if (FuncEnumConstructorType != 83)
            goto LABEL_36;
          goto LABEL_26;
        }
        v25 = 0u;
        v26 = 0;
        v31 = 0u;
        v32 = 0u;
        v37 = 0u;
        v38 = 0u;
        v35 = 0u;
        v36 = 0u;
        v33 = 0u;
        v34 = 0u;
        v29 = 0u;
        v28 = 0u;
        LODWORD(v25) = 80;
        v27 = -1;
        WORD1(v32) = 2;
        v30 = 0xFFFFFFFFFFFFFFFFLL;
        v39 = 0xFFFFFFFFLL;
        GTMTLSMTexture_processTraceFuncWithMap((char *)&v25, v12, (uint64_t *)v16);
        if (*((_QWORD *)&v32 + 1) && (*(_WORD *)(*((_QWORD *)&v32 + 1) + 36) & 0xF0) == 0x30)
          v9[3] = 0x7FFFFFFFFFFFFFFFLL;
        if (IsFuncEnumSharedResourceConstructor(*(_DWORD *)(v16 + 8)))
          LOBYTE(v20) = (*(_BYTE *)(v16 + 15) & 2) == 0;
        else
          LOBYTE(v20) = 0;
LABEL_35:
        *((_BYTE *)v9 + 48) = v20;
        goto LABEL_36;
      }
      *v9 = v14[2];
LABEL_28:
      LOBYTE(v20) = 1;
      goto LABEL_35;
    }
    if (FuncEnumConstructorType == 16)
    {
LABEL_26:
      *v9 = v14[2];
      goto LABEL_36;
    }
    if (FuncEnumConstructorType == 22)
    {
      v25 = 0u;
      v26 = 0;
      v31 = 0u;
      v32 = 0u;
      v34 = 0u;
      v35 = 0u;
      v33 = 0u;
      v29 = 0u;
      v28 = 0u;
      LODWORD(v25) = 22;
      v27 = -1;
      WORD1(v32) = 2;
      v30 = 0xFFFFFFFFFFFFFFFFLL;
      *(_QWORD *)&v33 = -1;
      GTMTLSMBuffer_processTraceFuncWithMap((char *)&v25, v12, (uint64_t *)v16);
      if ((IsFuncEnumSharedResourceConstructor(*(_DWORD *)(v16 + 8)) & 1) != 0)
        goto LABEL_28;
      if ((v32 & 0xE0) == 0)
      {
        v19 = atomic_load(v14 + 7);
        v20 = (v19 >> 1) & 1;
        goto LABEL_35;
      }
    }
LABEL_36:
    apr_hash_set(v7, v9 + 1, 8, v9);
  }
  return v9;
}

uint64_t GetParentResource(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v12 = a2;
  if (!a2)
    return v12;
  v5 = *find_entry(a1, &v12, 8uLL, 0);
  if (v5 && (v6 = *(_QWORD *)(v5 + 32)) != 0)
  {
    v7 = *(_QWORD *)(v6 + 32);
    v8 = v7 ? v7 + 64 : 0;
  }
  else
  {
    v8 = 0;
  }
  v9 = *(_DWORD *)(v8 + 8);
  if ((IsFuncEnumSharedResourceConstructor(v9) & 1) != 0)
    return v12;
  if (GetFuncEnumConstructorType(v9) != 80)
    return v12;
  v13 = 0u;
  v14 = 0;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v22 = 0u;
  v20 = 0u;
  v21 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  LODWORD(v13) = 80;
  v15 = -1;
  WORD1(v20) = 2;
  v18 = 0xFFFFFFFFFFFFFFFFLL;
  v27 = 0xFFFFFFFFLL;
  GTMTLSMTexture_processTraceFuncWithMap((char *)&v13, a3, (uint64_t *)v8);
  v10 = v23;
  if ((_QWORD)v23)
    return GetParentResource(a1, v10, a3);
  v10 = *((_QWORD *)&v22 + 1);
  if (*((_QWORD *)&v22 + 1))
    return GetParentResource(a1, v10, a3);
  else
    return v12;
}

_QWORD *GTResourceTrackerResourceRead(uint64_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;

  v8 = tracker_resource_get(a1, a2, a3, a4);
  v9 = v8;
  if (v8)
  {
    v10 = v8[3];
    if (v10 < 0)
      v10 = a4;
    v8[3] = v10;
    if (*((_BYTE *)v8 + 48))
    {
      v11 = tracker_resource_get(a1, a2, a3, a4);
      if (v11)
        v11[4] = a4;
    }
  }
  return v9;
}

uint64_t *GTResourceTrackerResourceUsage(uint64_t *result, int a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t *v9;

  v9 = result;
  if ((a5 & 2) != 0)
  {
    result = tracker_resource_get(result, a2, a3, a4);
    if (result)
      result[4] = a4;
  }
  if ((a5 & 5) != 0)
    return GTResourceTrackerResourceRead(v9, a2, a3, a4);
  return result;
}

uint64_t GTResourceTrackerUsingResourceArray(uint64_t result, int a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v11;
  uint64_t v12;
  int ResourceType;

  if (a4)
  {
    v8 = a4;
    v11 = result;
    do
    {
      v12 = *a3;
      if (*a3)
      {
        if (a2)
        {
          ResourceType = a2;
        }
        else
        {
          ResourceType = GTResourceTrackerGetResourceType(*a3, a5);
          v12 = *a3;
        }
        result = GTResourceTrackerUsingResource(v11, ResourceType, v12, a5, a6);
      }
      ++a3;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t *GTResourceTrackerResourceReadMTLArray(uint64_t *result, uint64_t *a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v3 = a2 + 1;
  v4 = *a2;
  if (*a2)
  {
    v6 = result;
    do
    {
      v8 = *v3++;
      v7 = v8;
      if (v8)
        result = GTResourceTrackerResourceRead(v6, 16, v7, a3);
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t *GTResourceTrackerResourceWriteArray(uint64_t *result, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  if (a3)
  {
    v5 = a3;
    v7 = result;
    do
    {
      v9 = *a2++;
      v8 = v9;
      if (v9)
      {
        result = tracker_resource_get(v7, 80, v8, a4);
        if (result)
          result[4] = a4;
      }
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t *GTResourceTrackerResourceUsageArray(uint64_t *result, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v7;
  uint64_t *v9;
  int ResourceType;

  if (a3)
  {
    v7 = a3;
    v9 = result;
    do
    {
      result = (uint64_t *)*a2;
      if (*a2)
      {
        ResourceType = GTResourceTrackerGetResourceType((uint64_t)result, *v9);
        result = GTResourceTrackerResourceUsage(v9, ResourceType, *a2, a4, a5);
      }
      ++a2;
      --v7;
    }
    while (v7);
  }
  return result;
}

void GTResourceTrackerUsingResourceHeap(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *entry;
  _QWORD *v6;
  uint64_t v7;

  v7 = a2;
  if (a2)
  {
    GTResourceTrackerUsingResource(a1[2], 50, a2, *a1, a1[1]);
    entry = find_entry(a1[3], &v7, 8uLL, 0);
    if (!*entry || !*(_QWORD *)(*entry + 32))
    {
      v6 = apr_palloc(*(apr_pool_t **)a1[3], 0x10uLL);
      *v6 = v7;
      v6[1] = a3;
      apr_hash_set((apr_hash_t *)a1[3], v6, 8, v6);
    }
  }
}

uint64_t IsHeapResourceMadeAliasable(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  int v12;
  BOOL v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  uint64_t v19;

  v19 = a2;
  v4 = *(_QWORD *)(*(_QWORD *)(*find_entry(a1, &v19, 8uLL, 0) + 32) + 32);
  if (v4)
  {
    v5 = 0;
    while (1)
    {
      v6 = atomic_load((unsigned int *)(v4 + 4));
      v7 = v5 + (v6 >> 6) - 1;
      if ((int)v7 > 0)
        break;
      v4 = *(_QWORD *)(v4 + 40);
      v5 = v7;
      if (!v4)
      {
        v5 = v7;
        goto LABEL_8;
      }
    }
  }
  else
  {
    v5 = 0;
  }
  v7 = 0;
LABEL_8:
  v8 = v5 | (unint64_t)(v7 << 32);
LABEL_9:
  v9 = v4 + 64;
  while (v4)
  {
    v10 = HIDWORD(v8) - v8;
    if ((*(_BYTE *)(v9 + ((uint64_t)(HIDWORD(v8) - (int)v8) << 6) + 15) & 8) == 0)
      break;
    v11 = *(_QWORD *)(v9 + ((uint64_t)v10 << 6));
    if (v11 > a3)
      break;
    v12 = *(_DWORD *)(v9 + ((uint64_t)v10 << 6) + 8);
    v14 = v12 == -16122 || v12 == -16114 || v12 == -15651;
    if (v14 || (IsFuncEnumDestructor(v12) & 1) != 0)
      return v11;
    v15 = atomic_load((unsigned int *)(v4 + 4));
    v16 = v8 + (v15 >> 6);
    v17 = (HIDWORD(v8) + 1);
    v8 = (v17 << 32) | v8;
    if ((_DWORD)v17 == v16 - 1)
    {
      v8 = (v17 << 32) | v17;
      v4 = *(_QWORD *)(v4 + 40);
      goto LABEL_9;
    }
  }
  return -1;
}

_QWORD *GTResourceTrackerMake(uint64_t a1, uint64_t a2, apr_pool_t *p)
{
  _QWORD *v6;

  v6 = apr_palloc(p, 0x30uLL);
  *v6 = a1;
  v6[1] = a2;
  v6[2] = apr_hash_make(p);
  v6[3] = apr_hash_make(p);
  v6[4] = apr_hash_make(p);
  v6[5] = apr_hash_make(p);
  return v6;
}

void GTResourceTrackerProcessFunction(uint64_t *a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  char *v16;
  int FuncEnumReceiverType;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  unsigned int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t *v45;
  unsigned int v46;
  int v47;
  uint64_t v48;
  _QWORD *v49;
  uint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int v54;
  unsigned int v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  __int128 **v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t v67;
  unsigned int v68;
  unsigned int v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unsigned int v74;
  int v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  _WORD *v79;
  uint64_t v80;
  __int128 *v81;
  __int16 v82;
  int v83;
  __int16 v84;
  uint64_t *v85;
  _WORD v86[5544];
  __int128 v87;
  uint64_t v88;
  uint64_t v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  uint64_t v97;
  __int16 v98;
  _WORD v99[616];
  _QWORD v100[3];

  v4 = *(_DWORD *)(a2 + 8);
  if (IsFuncEnumCreateCommandEncoder(v4))
  {
    bzero(&v77, 0x2B90uLL);
    GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v77, (uint64_t *)a2, a1[1]);
    if (v77 <= 64)
    {
      if (v77 != 17 && v77 != 21)
      {
        if (v77 != 28)
          return;
        goto LABEL_35;
      }
    }
    else
    {
      if (v77 <= 73)
      {
        if (v77 != 65)
        {
          if (v77 != 70)
            return;
          v5 = *a1;
          *(_QWORD *)&v87 = v78;
          v6 = *find_entry(v5, &v87, 8uLL, 0);
          if (v6
            && (v7 = *(_QWORD *)(v6 + 32)) != 0
            && (v8 = *(_QWORD *)(v7 + 32)) != 0
            && (*(_BYTE *)(v8 + 79) & 8) != 0)
          {
            v9 = v8 + 64;
          }
          else
          {
            v9 = 0;
          }
          bzero(&v87, 0x2B90uLL);
          GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v87, (uint64_t *)v9, a1[1]);
          bzero(&v81, 0x2B90uLL);
          v80 = 0;
          v79 = 0;
          if (*(_DWORD *)(v9 + 8) != -16286)
          {
            v50 = (uint64_t *)*((_QWORD *)&v91 + 1);
            v51 = renderCommandEncoder_processStreamWithDescriptor(a1, *((uint64_t *)&v91 + 1), (uint64_t)&v87);
            v79 = v99;
            LOWORD(v80) = v99[607];
            goto LABEL_110;
          }
          v10 = *a1;
          v100[0] = *((_QWORD *)&v90 + 1);
          v11 = *find_entry(v10, v100, 8uLL, 0);
          if (v11)
          {
            v12 = *(_QWORD *)(v11 + 32);
            if (v12)
            {
              v13 = *(_QWORD *)(v12 + 32);
              if (v13)
              {
                if ((*(_BYTE *)(v13 + 79) & 8) != 0)
                {
                  v14 = (uint64_t *)(v13 + 64);
LABEL_94:
                  GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v81, v14, a1[1]);
                  v67 = *(_QWORD *)(v12 + 32);
                  if (v67)
                  {
                    v68 = 0;
                    while (1)
                    {
                      v69 = atomic_load((unsigned int *)(v67 + 4));
                      v70 = v68 + (v69 >> 6) - 1;
                      if ((int)v70 > 1)
                        break;
                      v67 = *(_QWORD *)(v67 + 40);
                      v68 = v70;
                      if (!v67)
                      {
                        v68 = v70;
                        goto LABEL_101;
                      }
                    }
                    v70 = 1;
                  }
                  else
                  {
                    v68 = 0;
                    v70 = 0;
                  }
LABEL_101:
                  v71 = v68 | (unint64_t)(v70 << 32);
LABEL_102:
                  v72 = v67 + 64;
                  while (v67 && (*(_BYTE *)(v72 + ((uint64_t)(HIDWORD(v71) - (int)v71) << 6) + 15) & 8) != 0)
                  {
                    v73 = v72 + ((uint64_t)(HIDWORD(v71) - (int)v71) << 6);
                    if (!IsFuncEnumCreateCommandEncoder(*(_DWORD *)(v73 + 8)))
                      GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v81, (uint64_t *)v73, a1[1]);
                    v74 = atomic_load((unsigned int *)(v67 + 4));
                    v75 = v71 + (v74 >> 6);
                    v76 = (HIDWORD(v71) + 1);
                    v71 = (v76 << 32) | v71;
                    if ((_DWORD)v76 == v75 - 1)
                    {
                      v71 = (v76 << 32) | v76;
                      v67 = *(_QWORD *)(v67 + 40);
                      goto LABEL_102;
                    }
                  }
                  v50 = v85;
                  v79 = v86;
                  LOWORD(v80) = v86[64];
                  v51 = renderCommandEncoder_processStreamWithDescriptor(a1, (uint64_t)v85, (uint64_t)&v87);
LABEL_110:
                  RenderEncoderWithDescriptor(a1, v50);
                  if ((_DWORD)v87 == 70)
                  {
                    v64 = (__int128 **)&v79;
                    v65 = a1;
                    v66 = (uint64_t)v50;
                    v63 = v51;
LABEL_112:
                    RenderEncoderEndEncoding(v65, v66, (uint64_t)v64, v63);
                  }
                  return;
                }
              }
            }
          }
          else
          {
            v12 = 0;
          }
          v14 = 0;
          goto LABEL_94;
        }
        v31 = *a1;
        *(_QWORD *)&v87 = v78;
        v32 = *find_entry(v31, &v87, 8uLL, 0);
        if (v32)
        {
          v33 = *(_QWORD *)(v32 + 32);
          bzero(&v87, 0x2B90uLL);
          if (v33)
          {
            v34 = *(_QWORD *)(v33 + 32);
            if (v34)
            {
              if ((*(_BYTE *)(v34 + 79) & 8) != 0)
              {
                v35 = (uint64_t *)(v34 + 64);
LABEL_74:
                GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v87, v35, a1[1]);
                v52 = *((_QWORD *)&v91 + 1);
                RenderEncoderWithDescriptor(a1, *((uint64_t **)&v91 + 1));
                v53 = *(_QWORD *)(v33 + 32);
                if (v53)
                {
                  v54 = 0;
                  while (1)
                  {
                    v55 = atomic_load((unsigned int *)(v53 + 4));
                    v56 = v54 + (v55 >> 6) - 1;
                    if ((int)v56 > 1)
                      break;
                    v53 = *(_QWORD *)(v53 + 40);
                    v54 = v56;
                    if (!v53)
                    {
                      v54 = v56;
                      goto LABEL_81;
                    }
                  }
                  v56 = 1;
                }
                else
                {
                  v54 = 0;
                  v56 = 0;
                }
LABEL_81:
                v57 = v54 | (unint64_t)(v56 << 32);
LABEL_82:
                v58 = v53 + 64;
                while (v53 && (*(_BYTE *)(v58 + ((uint64_t)(HIDWORD(v57) - (int)v57) << 6) + 15) & 8) != 0)
                {
                  v59 = v58 + ((uint64_t)(HIDWORD(v57) - (int)v57) << 6);
                  if ((IsFuncEnumEndEncoding(*(_DWORD *)(v59 + 8)) & 1) != 0)
                  {
                    v81 = &v92;
                    v82 = v98;
                    v83 = 0;
                    v84 = 0;
                    v63 = *(_QWORD *)v59;
                    v64 = &v81;
                    v65 = a1;
                    v66 = v52;
                    goto LABEL_112;
                  }
                  GTResourceTrackerProcessResourceUse(a1, v59, *(_QWORD *)v59);
                  if (IsFuncEnumCreateCommandEncoder(*(_DWORD *)(v59 + 8)))
                  {
                    bzero(&v81, 0x2B90uLL);
                    GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v81, (uint64_t *)v59, a1[1]);
                    renderCommandEncoder_processStreamWithDescriptor(a1, v52, (uint64_t)&v81);
                  }
                  else
                  {
                    GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v87, (uint64_t *)v59, a1[1]);
                  }
                  v60 = atomic_load((unsigned int *)(v53 + 4));
                  v61 = v57 + (v60 >> 6);
                  v62 = (HIDWORD(v57) + 1);
                  v57 = (v62 << 32) | v57;
                  if ((_DWORD)v62 == v61 - 1)
                  {
                    v57 = (v62 << 32) | v62;
                    v53 = *(_QWORD *)(v53 + 40);
                    goto LABEL_82;
                  }
                }
                return;
              }
            }
          }
        }
        else
        {
          bzero(&v87, 0x2B90uLL);
          v33 = 0;
        }
        v35 = 0;
        goto LABEL_74;
      }
      if (v77 != 74)
      {
        if (v77 != 82)
          return;
LABEL_35:
        computeCommandEncoder_processStream(a1, v78);
        return;
      }
    }
    defaultCommandEncoder_processStream(a1, v78);
    return;
  }
  if (v4 != -20457 && v4 != -20474)
  {
    GTResourceTrackerProcessResourceUse(a1, a2, *(_QWORD *)a2);
    return;
  }
  v16 = GTTraceFunc_targetContext(a2, a1[1]);
  FuncEnumReceiverType = GetFuncEnumReceiverType(*(_DWORD *)(a2 + 8));
  if (FuncEnumReceiverType == 40)
  {
    v18 = *(_QWORD *)a2;
    v25 = *a1;
    *(_QWORD *)&v87 = v16;
    v26 = *(_QWORD *)(*find_entry(v25, &v87, 8uLL, 0) + 32);
    v87 = 0u;
    v88 = 0;
    v97 = 0;
    v96 = 0u;
    v95 = 0u;
    v94 = 0u;
    v93 = 0u;
    v92 = 0u;
    v91 = 0u;
    v90 = 0u;
    LODWORD(v87) = 40;
    v89 = -1;
    v27 = *(_QWORD *)(v26 + 32);
    if (v27)
    {
      v28 = 0;
      while (1)
      {
        v29 = atomic_load((unsigned int *)(v27 + 4));
        v30 = v28 + (v29 >> 6) - 1;
        if ((int)v30 > 0)
          break;
        v27 = *(_QWORD *)(v27 + 40);
        v28 = v30;
        if (!v27)
        {
          v28 = v30;
          goto LABEL_59;
        }
      }
    }
    else
    {
      v28 = 0;
    }
    v30 = 0;
LABEL_59:
    v43 = v28 | (unint64_t)(v30 << 32);
LABEL_60:
    v44 = v27 + 64;
    while (v27)
    {
      if ((*(_BYTE *)(v44 + ((uint64_t)(HIDWORD(v43) - (int)v43) << 6) + 15) & 8) == 0)
        break;
      v45 = (uint64_t *)(v44 + ((uint64_t)(HIDWORD(v43) - (int)v43) << 6));
      if (*v45 > v18)
        break;
      GTMTLFXSMTemporalScaler_processTraceFuncWithMap((uint64_t)&v87, a1[1], v45);
      v46 = atomic_load((unsigned int *)(v27 + 4));
      v47 = v43 + (v46 >> 6);
      v48 = (HIDWORD(v43) + 1);
      v43 = (v48 << 32) | v43;
      if ((_DWORD)v48 == v47 - 1)
      {
        v43 = (v48 << 32) | v48;
        v27 = *(_QWORD *)(v27 + 40);
        goto LABEL_60;
      }
    }
    GTResourceTrackerUsingResource(a1[2], 40, (uint64_t)v16, *a1, a1[1]);
    GTResourceTrackerResourceRead(a1, 80, v92, v18);
    GTResourceTrackerResourceRead(a1, 80, *((uint64_t *)&v92 + 1), v18);
    GTResourceTrackerResourceRead(a1, 80, v93, v18);
    GTResourceTrackerResourceRead(a1, 80, *((uint64_t *)&v93 + 1), v18);
    v42 = v94;
  }
  else
  {
    if (FuncEnumReceiverType != 39)
      return;
    v18 = *(_QWORD *)a2;
    v19 = *a1;
    *(_QWORD *)&v87 = v16;
    v20 = *(_QWORD *)(*find_entry(v19, &v87, 8uLL, 0) + 32);
    v87 = 0u;
    v88 = 0;
    v93 = 0u;
    v92 = 0u;
    v91 = 0u;
    v90 = 0u;
    LODWORD(v87) = 39;
    v89 = -1;
    v21 = *(_QWORD *)(v20 + 32);
    if (v21)
    {
      v22 = 0;
      while (1)
      {
        v23 = atomic_load((unsigned int *)(v21 + 4));
        v24 = v22 + (v23 >> 6) - 1;
        if ((int)v24 > 0)
          break;
        v21 = *(_QWORD *)(v21 + 40);
        v22 = v24;
        if (!v21)
        {
          v22 = v24;
          goto LABEL_49;
        }
      }
    }
    else
    {
      v22 = 0;
    }
    v24 = 0;
LABEL_49:
    v36 = v22 | (unint64_t)(v24 << 32);
LABEL_50:
    v37 = v21 + 64;
    while (v21)
    {
      if ((*(_BYTE *)(v37 + ((uint64_t)(HIDWORD(v36) - (int)v36) << 6) + 15) & 8) == 0)
        break;
      v38 = (uint64_t *)(v37 + ((uint64_t)(HIDWORD(v36) - (int)v36) << 6));
      if (*v38 > v18)
        break;
      GTMTLFXSMSpatialScaler_processTraceFuncWithMap((char *)&v87, a1[1], v38);
      v39 = atomic_load((unsigned int *)(v21 + 4));
      v40 = v36 + (v39 >> 6);
      v41 = (HIDWORD(v36) + 1);
      v36 = (v41 << 32) | v36;
      if ((_DWORD)v41 == v40 - 1)
      {
        v36 = (v41 << 32) | v41;
        v21 = *(_QWORD *)(v21 + 40);
        goto LABEL_50;
      }
    }
    GTResourceTrackerUsingResource(a1[2], 39, (uint64_t)v16, *a1, a1[1]);
    GTResourceTrackerResourceRead(a1, 80, v92, v18);
    v42 = *((_QWORD *)&v92 + 1);
  }
  v49 = tracker_resource_get(a1, 80, v42, v18);
  if (v49)
    v49[4] = v18;
  GTResourceTrackerUsingResource(a1[2], 41, *((uint64_t *)&v91 + 1), *a1, a1[1]);
}

void defaultCommandEncoder_processStream(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t k;
  uint64_t v17;
  uint64_t v18;
  uint64_t i;
  uint64_t v20;
  uint64_t v21;
  uint64_t j;
  uint64_t v23;
  _DWORD v24[14];
  uint64_t v25;
  uint64_t v26;

  bzero(v24, 0x2B90uLL);
  v4 = *a1;
  v26 = a2;
  v5 = *(_QWORD *)(*(_QWORD *)(*find_entry(v4, &v26, 8uLL, 0) + 32) + 32);
  if (v5)
  {
    v6 = 0;
    while (1)
    {
      v7 = atomic_load((unsigned int *)(v5 + 4));
      v8 = v6 + (v7 >> 6) - 1;
      if ((int)v8 > 0)
        break;
      v5 = *(_QWORD *)(v5 + 40);
      v6 = v8;
      if (!v5)
      {
        v6 = v8;
        goto LABEL_8;
      }
    }
  }
  else
  {
    v6 = 0;
  }
  v8 = 0;
LABEL_8:
  v9 = v6 | (unint64_t)(v8 << 32);
LABEL_9:
  v10 = v5 + 64;
  while (v5 && (*(_BYTE *)(v10 + ((uint64_t)(HIDWORD(v9) - (int)v9) << 6) + 15) & 8) != 0)
  {
    v11 = (uint64_t *)(v10 + ((uint64_t)(HIDWORD(v9) - (int)v9) << 6));
    GTResourceTrackerProcessResourceUse(a1, (uint64_t)v11, *v11);
    GTMTLSMCommandEncoder_processTraceFunc((uint64_t)v24, v11, a1[1]);
    v12 = atomic_load((unsigned int *)(v5 + 4));
    v13 = v9 + (v12 >> 6);
    v14 = (HIDWORD(v9) + 1);
    v9 = (v14 << 32) | v9;
    if ((_DWORD)v14 == v13 - 1)
    {
      v9 = (v14 << 32) | v14;
      v5 = *(_QWORD *)(v5 + 40);
      goto LABEL_9;
    }
  }
  switch(v24[0])
  {
    case 0x11:
      v18 = v25;
      if (v25)
      {
        for (i = 8; i != 104; i += 24)
        {
          v20 = *(_QWORD *)(v18 + i);
          if (v20)
            GTResourceTrackerUsingResource(a1[2], 31, v20, *a1, a1[1]);
        }
      }
      break;
    case 0x15:
      v21 = v25;
      if (v25)
      {
        for (j = 8; j != 104; j += 24)
        {
          v23 = *(_QWORD *)(v21 + j);
          if (v23)
            GTResourceTrackerUsingResource(a1[2], 31, v23, *a1, a1[1]);
        }
      }
      break;
    case 0x4A:
      v15 = v25;
      if (v25)
      {
        for (k = 8; k != 104; k += 24)
        {
          v17 = *(_QWORD *)(v15 + k);
          if (v17)
            GTResourceTrackerUsingResource(a1[2], 31, v17, *a1, a1[1]);
        }
      }
      break;
  }
}

uint64_t computeCommandEncoder_processStream(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  uint64_t v18;
  _DWORD v19[14];
  uint64_t v20;
  uint64_t v21;

  bzero(v19, 0x2B90uLL);
  v4 = *a1;
  v21 = a2;
  result = (uint64_t)find_entry(v4, &v21, 8uLL, 0);
  v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)result + 32) + 32);
  if (v6)
  {
    v7 = 0;
    while (1)
    {
      v8 = atomic_load((unsigned int *)(v6 + 4));
      v9 = v7 + (v8 >> 6) - 1;
      if ((int)v9 > 0)
        break;
      v6 = *(_QWORD *)(v6 + 40);
      v7 = v9;
      if (!v6)
      {
        v7 = v9;
        goto LABEL_8;
      }
    }
  }
  else
  {
    v7 = 0;
  }
  v9 = 0;
LABEL_8:
  v10 = v7 | (unint64_t)(v9 << 32);
LABEL_9:
  v11 = v6 + 64;
  while (v6 && (*(_BYTE *)(v11 + ((uint64_t)(HIDWORD(v10) - (int)v10) << 6) + 15) & 8) != 0)
  {
    v12 = v11 + ((uint64_t)(HIDWORD(v10) - (int)v10) << 6);
    GTResourceTrackerProcessResourceUse(a1, v12, *(_QWORD *)v12);
    GTMTLSMCommandEncoder_processTraceFunc((uint64_t)v19, (uint64_t *)v12, a1[1]);
    result = (uint64_t)ResourceTracker_processCommandEncoder(a1, *(_DWORD *)(v12 + 8), (uint64_t)v19, *(_QWORD *)v12);
    v13 = atomic_load((unsigned int *)(v6 + 4));
    v14 = v10 + (v13 >> 6);
    v15 = (HIDWORD(v10) + 1);
    v10 = (v15 << 32) | v10;
    if ((_DWORD)v15 == v14 - 1)
    {
      v10 = (v15 << 32) | v15;
      v6 = *(_QWORD *)(v6 + 40);
      goto LABEL_9;
    }
  }
  if (v19[0] == 28)
  {
    v16 = v20;
    if (v20)
    {
      for (i = 8; i != 104; i += 24)
      {
        v18 = *(_QWORD *)(v16 + i);
        if (v18)
          result = GTResourceTrackerUsingResource(a1[2], 31, v18, *a1, a1[1]);
      }
    }
  }
  return result;
}

uint64_t renderCommandEncoder_processStreamWithDescriptor(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  uint64_t v26;

  v6 = *a1;
  v26 = *(_QWORD *)(a3 + 8);
  v7 = *(_QWORD *)(*(_QWORD *)(*find_entry(v6, &v26, 8uLL, 0) + 32) + 32);
  if (v7)
  {
    v8 = 0;
    while (1)
    {
      v9 = atomic_load((unsigned int *)(v7 + 4));
      v10 = v8 + (v9 >> 6) - 1;
      if ((int)v10 > 1)
        break;
      v7 = *(_QWORD *)(v7 + 40);
      v8 = v10;
      if (!v7)
      {
        v8 = v10;
        goto LABEL_8;
      }
    }
    v10 = 1;
  }
  else
  {
    v8 = 0;
    v10 = 0;
  }
LABEL_8:
  v11 = v8 | (unint64_t)(v10 << 32);
LABEL_9:
  v12 = v7 + 64;
  while (v7 && (*(_BYTE *)(v12 + ((uint64_t)(HIDWORD(v11) - (int)v11) << 6) + 15) & 8) != 0)
  {
    v13 = v12 + ((uint64_t)(HIDWORD(v11) - (int)v11) << 6);
    v14 = (int *)(v13 + 8);
    v15 = IsFuncEnumEndEncoding(*(_DWORD *)(v13 + 8));
    v16 = *(_QWORD *)v13;
    if ((v15 & 1) != 0)
      return v16;
    GTResourceTrackerProcessResourceUse(a1, v13, v16);
    GTMTLSMCommandEncoder_processTraceFunc(a3, (uint64_t *)v13, a1[1]);
    ResourceTracker_processCommandEncoder(a1, *v14, a3, *(_QWORD *)v13);
    if (IsFuncEnumDrawCall(*v14))
    {
      if (*(_DWORD *)a3 == 70)
        v17 = *(unsigned __int8 *)(a3 + 11141);
      else
        v17 = 0;
      v18 = 0;
      v19 = *(_QWORD *)v13;
      do
      {
        RenderEncoderLoadAttachment(a1, a2 + v18, v19);
        v18 += 64;
      }
      while (v18 != 512);
      RenderEncoderLoadAttachment(a1, a2 + 672, v19);
      RenderEncoderLoadAttachment(a1, a2 + 720, v19);
      if (v17)
      {
        v20 = *(_QWORD *)(a2 + 792);
        if (v20)
        {
          v21 = tracker_resource_get(a1, 22, v20, v19);
          if (v21)
            v21[4] = v19;
        }
      }
      GTResourceTrackerUsingResource(a1[2], 68, *(_QWORD *)(a2 + 784), *a1, a1[1]);
    }
    v22 = atomic_load((unsigned int *)(v7 + 4));
    v23 = v11 + (v22 >> 6);
    v24 = (HIDWORD(v11) + 1);
    v11 = (v24 << 32) | v11;
    if ((_DWORD)v24 == v23 - 1)
    {
      v11 = (v24 << 32) | v24;
      v7 = *(_QWORD *)(v7 + 40);
      goto LABEL_9;
    }
  }
  return -1;
}

uint64_t RenderEncoderWithDescriptor(uint64_t *a1, uint64_t *a2)
{
  uint64_t i;
  uint64_t result;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;

  for (i = 0; i != 64; i += 8)
  {
    GTResourceTrackerUsingResource(a1[2], 80, a2[i + 1], *a1, a1[1]);
    GTResourceTrackerUsingResource(a1[2], 80, a2[i], *a1, a1[1]);
  }
  GTResourceTrackerUsingResource(a1[2], 80, a2[85], *a1, a1[1]);
  GTResourceTrackerUsingResource(a1[2], 80, a2[84], *a1, a1[1]);
  GTResourceTrackerUsingResource(a1[2], 80, a2[91], *a1, a1[1]);
  GTResourceTrackerUsingResource(a1[2], 80, a2[90], *a1, a1[1]);
  GTResourceTrackerUsingResource(a1[2], 22, a2[99], *a1, a1[1]);
  result = GTResourceTrackerUsingResource(a1[2], 68, a2[98], *a1, a1[1]);
  v6 = 0;
  v7 = a2 + 66;
  do
  {
    v8 = v7[v6];
    if (v8)
      result = GTResourceTrackerUsingResource(a1[2], 31, v8, *a1, a1[1]);
    v6 += 5;
  }
  while (v6 != 20);
  return result;
}

uint64_t *RenderEncoderEndEncoding(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;

  v8 = 0;
  v9 = a2;
  do
  {
    v10 = *(unsigned __int8 *)(v9 + 27);
    if (v10 == 4)
      v10 = *(_QWORD *)(*(_QWORD *)a3 + v8);
    RenderEncoderStoreAttachment(a1, (uint64_t *)v9, v10, a4);
    v8 += 8;
    v9 += 64;
  }
  while (v8 != 64);
  v11 = *(unsigned __int8 *)(a2 + 699);
  if (v11 == 4)
    v11 = *(unsigned __int8 *)(a3 + 8);
  RenderEncoderStoreAttachment(a1, (uint64_t *)(a2 + 672), v11, a4);
  v12 = *(unsigned __int8 *)(a2 + 747);
  if (v12 == 4)
    v12 = *(unsigned __int8 *)(a3 + 9);
  return RenderEncoderStoreAttachment(a1, (uint64_t *)(a2 + 720), v12, a4);
}

uint64_t *RenderEncoderStoreAttachment(uint64_t *result, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t *v8;
  _QWORD *v9;

  v5 = a2[1];
  v8 = result;
  switch(a3)
  {
    case 0:
    case 1:
    case 5:
      goto LABEL_5;
    case 2:
      goto LABEL_4;
    case 3:
      v9 = tracker_resource_get(result, 80, v5, a4);
      if (v9)
        v9[4] = a4;
LABEL_4:
      v5 = *a2;
LABEL_5:
      result = tracker_resource_get(v8, 80, v5, a4);
      if (result)
        result[4] = a4;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t *ResourceTracker_processCommandEncoder(uint64_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t *result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t *v24;
  int8x16_t v25;
  int8x16_t v26;
  __int128 v27;
  __int128 v28;
  int8x16_t v29[2];
  __int128 v30;
  __int128 v31;
  int8x16_t v32[5];
  __int128 v33;
  __int128 v34;
  int8x16_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  int8x16_t v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;

  result = (uint64_t *)IsFuncEnumDrawCall(a2);
  if ((_DWORD)result)
  {
    if (*(_DWORD *)a3 != 70)
      return result;
    v9 = *a1;
    v26.i64[0] = *(_QWORD *)(a3 + 8600);
    v10 = *find_entry(v9, &v26, 8uLL, 0);
    if (v10)
      v11 = *(_QWORD *)(v10 + 32);
    else
      v11 = 0;
    v38 = 0;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v33 = 0u;
    memset(v32, 0, sizeof(v32));
    v30 = 0u;
    v31 = 0u;
    memset(v29, 0, sizeof(v29));
    v27 = 0u;
    v28 = 0u;
    v26 = 0u;
    GTMTLSMRenderPipelineState_resourceAccess(&v26, v11, a1[1]);
    v26 = vandq_s8(v26, (int8x16_t)vdupq_n_s64(~*(_QWORD *)(a3 + 64)));
    BufferAccess(a1, a3 + 80, &v26, a4);
    TextureAccess(a1, a3 + 824, (uint64_t)&v27, a4);
    *(int8x16_t *)((char *)v29 + 8) = vandq_s8(*(int8x16_t *)((char *)v29 + 8), (int8x16_t)vdupq_n_s64(~*(_QWORD *)(a3 + 1976)));
    BufferAccess(a1, a3 + 1984, &v29[0].i64[1], a4);
    TextureAccess(a1, a3 + 2480, (uint64_t)&v29[1].i64[1], a4);
    v32[0] = vandq_s8(v32[0], (int8x16_t)vdupq_n_s64(~*(_QWORD *)(a3 + 3632)));
    BufferAccess(a1, a3 + 3640, v32, a4);
    TextureAccess(a1, a3 + 4136, (uint64_t)v32[1].i64, a4);
    *(int8x16_t *)((char *)&v32[3] + 8) = vandq_s8(*(int8x16_t *)((char *)&v32[3] + 8), (int8x16_t)vdupq_n_s64(~*(_QWORD *)(a3 + 5288)));
    BufferAccess(a1, a3 + 5296, &v32[3].i64[1], a4);
    v21 = a3 + 5792;
    v22 = &v32[4].i64[1];
    v23 = a1;
    return TextureAccess(v23, v21, (uint64_t)v22, a4);
  }
  if (a2 <= -16080)
  {
    if (a2 != -16327 && a2 != -16220)
    {
      v12 = -16137;
LABEL_12:
      if (a2 != v12)
        return result;
      goto LABEL_13;
    }
LABEL_15:
    v16 = *a1;
    v26.i64[0] = *(_QWORD *)(a3 + 64);
    v17 = *find_entry(v16, &v26, 8uLL, 0);
    if (v17)
      v17 = *(_QWORD *)(v17 + 32);
    v42 = 0;
    v40 = 0u;
    v41 = 0u;
    v39 = 0u;
    v18 = a1[1];
    v26 = 0u;
    *(_QWORD *)&v27 = 0;
    *(_QWORD *)&v33 = 0;
    memset(v32, 0, sizeof(v32));
    v30 = 0u;
    v28 = 0u;
    memset(v29, 0, sizeof(v29));
    v26.i32[0] = 29;
    *((_QWORD *)&v27 + 1) = -1;
    v31 = 0xFFFFFFFFFFFFFFFFLL;
    if (v17 && (v19 = *(_QWORD *)(v17 + 32)) != 0 && (*(_BYTE *)(v19 + 79) & 8) != 0)
      v20 = (uint64_t *)(v19 + 64);
    else
      v20 = 0;
    GTMTLSMComputePipelineState_processTraceFuncWithMap(v26.i8, v18, v20);
    v39 = *(int8x16_t *)((char *)v32 + 8);
    v40 = *(__int128 *)((char *)&v32[1] + 8);
    v25 = vandq_s8(*(int8x16_t *)((char *)v32 + 8), (int8x16_t)vdupq_n_s64(~*(_QWORD *)(a3 + 72)));
    v42 = v32[3].i64[1];
    v24 = (uint64_t *)&v40;
    v41 = *(__int128 *)((char *)&v32[2] + 8);
    v39 = v25;
    BufferAccess(a1, a3 + 88, &v39, a4);
    v21 = a3 + 832;
    goto LABEL_27;
  }
  if ((a2 + 16079) < 2)
    goto LABEL_15;
  if (a2 != -15297)
  {
    v12 = -15486;
    goto LABEL_12;
  }
LABEL_13:
  v13 = *a1;
  v26.i64[0] = *(_QWORD *)(a3 + 8600);
  v14 = *find_entry(v13, &v26, 8uLL, 0);
  if (v14)
    v15 = *(_QWORD *)(v14 + 32);
  else
    v15 = 0;
  v38 = 0;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v33 = 0u;
  memset(v32, 0, sizeof(v32));
  v30 = 0u;
  v31 = 0u;
  memset(v29, 0, sizeof(v29));
  v27 = 0u;
  v28 = 0u;
  v26 = 0u;
  v24 = (uint64_t *)&v36;
  GTMTLSMRenderPipelineState_resourceAccess(&v26, v15, a1[1]);
  v35 = vandq_s8(v35, (int8x16_t)vdupq_n_s64(~*(_QWORD *)(a3 + 6944)));
  BufferAccess(a1, a3 + 6952, &v35, a4);
  v21 = a3 + 7448;
LABEL_27:
  v23 = a1;
  v22 = v24;
  return TextureAccess(v23, v21, (uint64_t)v22, a4);
}

uint64_t *RenderEncoderLoadAttachment(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;

  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v6 = result;
    v7 = *(unsigned __int8 *)(a2 + 25);
    if (v7 == 2)
      return GTResourceTrackerResourceRead(result, 80, v4, 0x7FFFFFFFFFFFFFFFLL);
    if (v7 != 1)
    {
      if (*(_BYTE *)(a2 + 25))
        return result;
      return GTResourceTrackerResourceRead(result, 80, v4, 0x7FFFFFFFFFFFFFFFLL);
    }
    GTResourceTrackerResourceRead(result, 80, v4, a3);
    v8 = *v6;
    v9 = *(_QWORD *)(a2 + 8);
    result = find_entry(v8, &v9, 8uLL, 0);
    if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*result + 32) + 32) + 72) == -16294)
    {
      result = tracker_resource_get(v6, 80, *(_QWORD *)(a2 + 8), a3);
      *((_BYTE *)result + 48) = 1;
    }
  }
  return result;
}

uint64_t *BufferAccess(uint64_t *result, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t *v7;
  int v8;
  unint64_t v9;
  int v10;
  int v11;
  unint64_t v12;
  int v13;

  v7 = result;
  v8 = 0;
  do
  {
    v9 = *a3 >> v8;
    if (!v9)
      break;
    v10 = v8 + __clz(__rbit64(v9));
    result = GTResourceTrackerResourceRead(v7, 22, *(_QWORD *)(a2 + 8 * v10), a4);
    v8 = v10 + 1;
  }
  while (v10 < 63);
  v11 = 0;
  do
  {
    v12 = a3[1] >> v11;
    if (!v12)
      break;
    v13 = v11 + __clz(__rbit64(v12));
    result = tracker_resource_get(v7, 22, *(_QWORD *)(a2 + 8 * v13), a4);
    if (result)
      result[4] = a4;
    v11 = v13 + 1;
  }
  while (v13 < 63);
  return result;
}

uint64_t *TextureAccess(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v7;
  uint64_t v8;
  char v9;
  int v10;
  char v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  int v15;
  _QWORD *v16;
  unint64_t v17;
  int v18;

  v7 = result;
  v8 = 0;
  v9 = 1;
  do
  {
    v10 = 0;
    v11 = v9;
    v12 = v8 << 6;
    do
    {
      v13 = *(_QWORD *)(a3 + 16 * v8) >> v10;
      if (!v13)
        break;
      v14 = v10 + __clz(__rbit64(v13));
      result = GTResourceTrackerResourceRead(v7, 80, *(_QWORD *)(a2 + 8 * (v12 + v14)), a4);
      v10 = v14 + 1;
    }
    while (v14 < 63);
    v15 = 0;
    v16 = (_QWORD *)(a3 + 16 * v8 + 8);
    do
    {
      v17 = *v16 >> v15;
      if (!v17)
        break;
      v18 = v15 + __clz(__rbit64(v17));
      result = tracker_resource_get(v7, 80, *(_QWORD *)(a2 + 8 * (v12 + v18)), a4);
      if (result)
        result[4] = a4;
      v15 = v18 + 1;
    }
    while (v18 < 63);
    v9 = 0;
    v8 = 1;
  }
  while ((v11 & 1) != 0);
  return result;
}

void GTResourceTrackerProcessCommandBuffer(uint64_t a1, apr_pool_t *a2, char a3)
{
  uint64_t v5;
  _QWORD *entry;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  apr_allocator_t *v32;
  unint64_t v33;
  apr_pool_t *v34;
  apr_pool_t **v35;
  apr_hash_index_t *v36;
  apr_hash_index_t *v37;
  apr_pool_t *v38;
  apr_hash_t *v39;
  apr_hash_t *v40;
  apr_hash_index_t *v41;
  apr_hash_index_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  unint64_t v55;
  int v56;
  unsigned int v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  unsigned int v62;
  unsigned int v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  unint64_t *v68;
  unsigned int v69;
  int v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  _QWORD *v74;
  uint64_t v75;
  char *v76;
  char *v77;
  char *v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  apr_hash_t *v82;
  _QWORD *v83;
  char *v84;
  char *v85;
  char *v86;
  char *v87;
  unint64_t v88;
  char v89;
  char v90;
  apr_hash_t *v91;
  apr_hash_index_t *i;
  apr_hash_index_t *v93;
  uint64_t *v94;
  uint64_t v95;
  int ResourceType;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  apr_hash_index_t *hi;
  apr_hash_t *v101;
  char *v102;
  apr_pool_t **h;
  apr_pool_t *pool;
  apr_pool_t *newpool;

  v5 = *(_QWORD *)a1;
  newpool = a2;
  entry = find_entry(v5, &newpool, 8uLL, 0);
  if (*entry)
    v7 = *(_QWORD *)(*entry + 32);
  else
    v7 = 0;
  v8 = *(_QWORD *)(v7 + 32);
  if (v8)
  {
    v9 = 0;
    while (1)
    {
      v10 = atomic_load((unsigned int *)(v8 + 4));
      v11 = v9 + (v10 >> 6) - 1;
      if ((int)v11 > 0)
        break;
      v8 = *(_QWORD *)(v8 + 40);
      v9 = v11;
      if (!v8)
      {
        v9 = v11;
        goto LABEL_11;
      }
    }
  }
  else
  {
    v9 = 0;
  }
  v11 = 0;
LABEL_11:
  v12 = v9 | (unint64_t)(v11 << 32);
LABEL_12:
  v13 = v8 + 64;
  while (v8 && (*(_BYTE *)(v13 + ((uint64_t)(HIDWORD(v12) - (int)v12) << 6) + 15) & 8) != 0)
  {
    GTResourceTrackerProcessFunction((uint64_t *)a1, v13 + ((uint64_t)(HIDWORD(v12) - (int)v12) << 6));
    v14 = atomic_load((unsigned int *)(v8 + 4));
    v15 = v12 + (v14 >> 6);
    v16 = (HIDWORD(v12) + 1);
    v12 = (v16 << 32) | v12;
    if ((_DWORD)v16 == v15 - 1)
    {
      v12 = (v16 << 32) | v16;
      v8 = *(_QWORD *)(v8 + 40);
      goto LABEL_12;
    }
  }
  if ((a3 & 1) != 0)
  {
    v17 = *(_QWORD *)a1;
    v18 = *(_QWORD *)(a1 + 8);
    v19 = *(_QWORD *)(v7 + 32);
    if (v19)
    {
      v20 = 0;
      while (1)
      {
        v21 = atomic_load((unsigned int *)(v19 + 4));
        v22 = v20 + (v21 >> 6) - 1;
        if ((int)v22 > 0)
          break;
        v19 = *(_QWORD *)(v19 + 40);
        v20 = v22;
        if (!v19)
        {
          v20 = v22;
          goto LABEL_25;
        }
      }
    }
    else
    {
      v20 = 0;
    }
    v22 = 0;
LABEL_25:
    v23 = v20 | (unint64_t)(v22 << 32);
LABEL_26:
    v24 = v19 + 64;
    while (1)
    {
      if (!v19 || (*(_BYTE *)(v24 + ((uint64_t)(HIDWORD(v23) - (int)v23) << 6) + 15) & 8) == 0)
      {
        v29 = -1;
        goto LABEL_34;
      }
      v25 = v24 + ((uint64_t)(HIDWORD(v23) - (int)v23) << 6);
      if (GetFuncEnumConstructorType(*(_DWORD *)(v25 + 8)) == 25)
        break;
      v26 = atomic_load((unsigned int *)(v19 + 4));
      v27 = v23 + (v26 >> 6);
      v28 = (HIDWORD(v23) + 1);
      v23 = (v28 << 32) | v23;
      if ((_DWORD)v28 == v27 - 1)
      {
        v23 = (v28 << 32) | v28;
        v19 = *(_QWORD *)(v19 + 40);
        goto LABEL_26;
      }
    }
    v29 = *(_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)v25, *(unsigned __int8 *)(v25 + 13), v18);
LABEL_34:
    newpool = (apr_pool_t *)v29;
    v30 = *find_entry(v17, &newpool, 8uLL, 0);
    if (v30)
    {
      v31 = *(_QWORD *)(v30 + 32);
      v33 = CommandBufferCommitIndex(*(_QWORD *)(v7 + 32));
      if (v31)
      {
        newpool = 0;
        apr_pool_create_ex(&newpool, 0, 0, v32);
        v34 = newpool;
        v35 = (apr_pool_t **)apr_hash_make(newpool);
        GatherCommandQueueResidencySetsUpToIndexInternal(v35, v31, *(_QWORD *)(a1 + 8), v33, 1);
        v36 = apr_hash_first(v34, (apr_hash_t *)v35);
        if (v36)
        {
          v37 = v36;
          do
          {
            GTResourceTrackerUsingResidencySet((uint64_t *)a1, **(_QWORD **)(*((_QWORD *)v37 + 1) + 16));
            v37 = apr_hash_next(v37);
          }
          while (v37);
        }
        apr_pool_destroy(v34);
      }
    }
    else
    {
      v33 = CommandBufferCommitIndex(*(_QWORD *)(v7 + 32));
    }
    if (*(_DWORD *)(*(_QWORD *)(a1 + 40) + 48))
    {
      pool = 0;
      apr_pool_create_ex(&pool, 0, 0, v32);
      v38 = pool;
      v39 = apr_hash_make(pool);
      v40 = apr_hash_make(v38);
      v41 = apr_hash_first(v38, *(apr_hash_t **)(a1 + 40));
      if (v41)
      {
        v42 = v41;
        h = (apr_pool_t **)v40;
        do
        {
          v43 = *(_QWORD *)a1;
          newpool = **(apr_pool_t ***)(*((_QWORD *)v42 + 1) + 16);
          v44 = *find_entry(v43, &newpool, 8uLL, 0);
          if (v44)
            v44 = *(_QWORD *)(v44 + 32);
          v45 = *(_QWORD *)(a1 + 8);
          v46 = *(_QWORD *)(v44 + 32);
          if (v46)
          {
            v47 = 0;
            while (1)
            {
              v48 = atomic_load((unsigned int *)(v46 + 4));
              v49 = v47 + (v48 >> 6) - 1;
              if ((int)v49 > 0)
                break;
              v46 = *(_QWORD *)(v46 + 40);
              v47 = v49;
              if (!v46)
              {
                v47 = v49;
                goto LABEL_53;
              }
            }
            v49 = 0;
          }
          else
          {
            v47 = 0;
            v49 = 0;
          }
LABEL_53:
          v50 = 0;
          v51 = v47 | (unint64_t)(v49 << 32);
LABEL_54:
          v52 = v46 + 64;
          while (v46)
          {
            v53 = HIDWORD(v51) - v51;
            if ((*(_BYTE *)(v52 + ((uint64_t)(HIDWORD(v51) - (int)v51) << 6) + 15) & 8) == 0)
              break;
            v54 = v53;
            v55 = *(_QWORD *)(v52 + ((uint64_t)v53 << 6));
            if (v55 >= v33)
              break;
            v56 = *(_DWORD *)(v52 + (v54 << 6) + 8);
            if (*(char *)(v52 + ((uint64_t)(HIDWORD(v51) - (int)v51) << 6) + 15) < 0 && v56 == -15208)
              v50 = v55;
            v58 = atomic_load((unsigned int *)(v46 + 4));
            v59 = (HIDWORD(v51) + 1);
            v60 = v51 + (v58 >> 6) - 1;
            v51 = (v59 << 32) | v51;
            if ((_DWORD)v59 == v60)
            {
              v51 = (v59 << 32) | v59;
              v46 = *(_QWORD *)(v46 + 40);
              goto LABEL_54;
            }
          }
          v61 = *(_QWORD *)(v44 + 32);
          hi = v42;
          v101 = v39;
          v62 = 0;
          if (v61)
          {
            while (1)
            {
              v63 = atomic_load((unsigned int *)(v61 + 4));
              v64 = v62 + (v63 >> 6) - 1;
              if ((int)v64 > 0)
                break;
              v61 = *(_QWORD *)(v61 + 40);
              v62 = v64;
              if (!v61)
              {
                v62 = v64;
                goto LABEL_70;
              }
            }
          }
          v64 = 0;
LABEL_70:
          v65 = v62 | (unint64_t)(v64 << 32);
LABEL_71:
          v66 = v61 + 64;
          while (v61)
          {
            v67 = HIDWORD(v65) - v65;
            if ((*(_BYTE *)(v66 + ((uint64_t)(HIDWORD(v65) - (int)v65) << 6) + 15) & 8) == 0)
              break;
            v68 = (unint64_t *)(v66 + ((uint64_t)v67 << 6));
            if (*v68 >= v50)
            {
              if (*v68 >= v33)
              {
                if ((*(_BYTE *)(v66 + ((uint64_t)(HIDWORD(v65) - (int)v65) << 6) + 15) & 0x80) != 0)
                  break;
              }
              else
              {
                switch(*(_DWORD *)(v66 + ((uint64_t)v67 << 6) + 8))
                {
                  case 0xFFFFC48C:
                    v101 = apr_hash_copy(*h, (const apr_hash_t *)h);
                    break;
                  case 0xFFFFC494:
                    v98 = v66;
                    v72 = GTTraceFunc_argumentBytesWithMap(v68, *(unsigned __int8 *)(v66 + ((uint64_t)v67 << 6) + 13), v45)+ 8;
                    v73 = *find_entry((uint64_t)h, v72, 8uLL, 0);
                    if (!v73 || !*(_QWORD *)(v73 + 32))
                    {
                      v74 = apr_palloc(*h, 8uLL);
                      *v74 = *(_QWORD *)v72;
                      apr_hash_set((apr_hash_t *)h, v74, 8, v74);
                    }
                    v66 = v98;
                    break;
                  case 0xFFFFC495:
                    v75 = v45;
                    v76 = GTTraceFunc_argumentBytesWithMap(v68, *(unsigned __int8 *)(v66 + ((uint64_t)v67 << 6) + 13), v45);
                    v77 = GTTraceFunc_argumentBytesWithMap(v68, v76[16], v75);
                    v102 = v76;
                    if (!*((_QWORD *)v76 + 1))
                      goto LABEL_101;
                    v78 = v77;
                    v97 = v75;
                    v99 = v66;
                    v79 = 0;
                    v80 = 0;
                    do
                    {
                      v81 = *find_entry((uint64_t)h, &v78[v79], 8uLL, 0);
                      if (!v81 || !*(_QWORD *)(v81 + 32))
                      {
                        if (v78)
                        {
                          v82 = (apr_hash_t *)h;
                          v83 = apr_palloc(*h, 8uLL);
                          *v83 = *(_QWORD *)&v78[8 * v80];
                        }
                        else
                        {
                          v83 = 0;
                          v82 = (apr_hash_t *)h;
                        }
                        apr_hash_set(v82, v83, 8, v83);
                      }
                      ++v80;
                      v79 += 8;
                    }
                    while (*((_QWORD *)v102 + 1) > v80);
                    goto LABEL_100;
                  case 0xFFFFC498:
                    apr_hash_clear((apr_hash_t *)h);
                    break;
                  case 0xFFFFC499:
                    v84 = GTTraceFunc_argumentBytesWithMap(v68, *(unsigned __int8 *)(v66 + ((uint64_t)v67 << 6) + 13), v45);
                    apr_hash_set((apr_hash_t *)h, v84 + 8, 8, 0);
                    break;
                  case 0xFFFFC49A:
                    v75 = v45;
                    v85 = GTTraceFunc_argumentBytesWithMap(v68, *(unsigned __int8 *)(v66 + ((uint64_t)v67 << 6) + 13), v45);
                    v86 = GTTraceFunc_argumentBytesWithMap(v68, v85[16], v75);
                    if (*((_QWORD *)v85 + 1))
                    {
                      v87 = v86;
                      v97 = v75;
                      v99 = v66;
                      v88 = 0;
                      do
                      {
                        apr_hash_set((apr_hash_t *)h, v87, 8, 0);
                        ++v88;
                        v87 += 8;
                      }
                      while (*((_QWORD *)v85 + 1) > v88);
LABEL_100:
                      v45 = v97;
                      v66 = v99;
                    }
                    else
                    {
LABEL_101:
                      v45 = v75;
                    }
                    break;
                  default:
                    break;
                }
              }
            }
            v69 = atomic_load((unsigned int *)(v61 + 4));
            v70 = v65 + (v69 >> 6);
            v71 = (HIDWORD(v65) + 1);
            v65 = (v71 << 32) | v65;
            if ((_DWORD)v71 == v70 - 1)
            {
              v65 = (v71 << 32) | v71;
              v61 = *(_QWORD *)(v61 + 40);
              goto LABEL_71;
            }
          }
          v89 = 1;
          v39 = v101;
          do
          {
            v90 = v89;
            if ((v89 & 1) != 0)
              v91 = v101;
            else
              v91 = (apr_hash_t *)h;
            for (i = apr_hash_first(pool, v91); ; i = apr_hash_next(v93))
            {
              v93 = i;
              if (!i)
                break;
              v94 = *(uint64_t **)(*((_QWORD *)i + 1) + 16);
              if (GTResourceTrackerGetResourceType(*v94, *(_QWORD *)a1) == 50)
              {
                GTResourceTrackerUsingResourceHeap((uint64_t *)a1, *v94, v33);
              }
              else
              {
                v95 = *(_QWORD *)(a1 + 16);
                ResourceType = GTResourceTrackerGetResourceType(*v94, *(_QWORD *)a1);
                GTResourceTrackerUsingResource(v95, ResourceType, *v94, *(_QWORD *)a1, *(_QWORD *)(a1 + 8));
              }
            }
            v89 = 0;
          }
          while ((v90 & 1) != 0);
          apr_hash_clear(v101);
          apr_hash_clear((apr_hash_t *)h);
          v42 = apr_hash_next(hi);
        }
        while (v42);
        v38 = pool;
      }
      apr_pool_destroy(v38);
      apr_hash_clear(*(apr_hash_t **)(a1 + 40));
    }
  }
}

void GTResourceTrackerUsingResidencySet(uint64_t *a1, uint64_t a2)
{
  _QWORD *entry;
  _QWORD *v4;
  uint64_t v5;

  v5 = a2;
  GTResourceTrackerUsingResource(a1[2], 72, a2, *a1, a1[1]);
  entry = find_entry(a1[5], &v5, 8uLL, 0);
  if (!*entry || !*(_QWORD *)(*entry + 32))
  {
    v4 = apr_palloc(*(apr_pool_t **)a1[5], 8uLL);
    *v4 = v5;
    apr_hash_set((apr_hash_t *)a1[5], v4, 8, v4);
  }
}

uint64_t *GTResourceTrackerUsingAccelerationStructureDescriptor(uint64_t *result, uint64_t *a2, uint64_t a3)
{
  uint64_t *v5;
  int v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  uint64_t *v21;
  unint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;

  v5 = result;
  v6 = *(unsigned __int8 *)a2;
  if (v6 == 3)
  {
    GTResourceTrackerResourceRead(result, 22, a2[1], a3);
    GTResourceTrackerResourceRead(v5, 22, a2[3], a3);
    GTResourceTrackerResourceRead(v5, 22, a2[5], a3);
    return GTResourceTrackerResourceRead(v5, 22, a2[7], a3);
  }
  else if (v6 == 2)
  {
    GTResourceTrackerResourceRead(result, 22, a2[2], a3);
    result = GTResourceTrackerResourceRead(v5, 22, a2[3], a3);
    if (*((_DWORD *)a2 + 14))
    {
      v28 = 0;
      do
        result = GTResourceTrackerResourceRead(v5, 16, *(_QWORD *)(a2[1] + 8 * v28++), a3);
      while (v28 < *((unsigned int *)a2 + 14));
    }
  }
  else if (v6 == 1 && a2[2])
  {
    v7 = 0;
    do
    {
      v8 = a2[1];
      v9 = v8 + 136 * v7;
      result = GTResourceTrackerResourceRead(v5, 22, *(_QWORD *)(v9 + 8), a3);
      switch(*(_BYTE *)(v9 + 36))
      {
        case 1:
          v10 = (uint64_t *)(v8 + 136 * v7);
          GTResourceTrackerResourceRead(v5, 22, v10[10], a3);
          GTResourceTrackerResourceRead(v5, 22, v10[5], a3);
          v11 = v10 + 7;
          goto LABEL_25;
        case 2:
          v11 = (uint64_t *)(v8 + 136 * v7 + 40);
          goto LABEL_25;
        case 3:
          v12 = v8 + 136 * v7;
          v13 = (uint64_t *)(v12 + 40);
          if (*(_QWORD *)(v12 + 88))
          {
            v14 = 0;
            v15 = 0;
            do
            {
              GTResourceTrackerResourceRead(v5, 22, *(_QWORD *)(v13[5] + v14), a3);
              ++v15;
              v14 += 16;
            }
            while (v13[6] > v15);
          }
          v16 = *v13;
          v11 = v13 + 2;
          GTResourceTrackerResourceRead(v5, 22, v16, a3);
          goto LABEL_25;
        case 4:
          v17 = v8 + 136 * v7;
          if (*(_QWORD *)(v17 + 48))
          {
            v18 = 0;
            v19 = 0;
            v20 = (_QWORD *)(v17 + 40);
            do
            {
              result = GTResourceTrackerResourceRead(v5, 22, *(_QWORD *)(*v20 + v18), a3);
              ++v19;
              v18 += 16;
            }
            while (v20[1] > v19);
          }
          break;
        case 5:
          v21 = (uint64_t *)(v8 + 136 * v7);
          GTResourceTrackerResourceRead(v5, 22, v21[5], a3);
          GTResourceTrackerResourceRead(v5, 22, v21[11], a3);
          v11 = v21 + 9;
          goto LABEL_25;
        case 6:
          v22 = v8 + 136 * v7;
          v23 = (_QWORD *)(v22 + 40);
          if (*(_QWORD *)(v22 + 48))
          {
            v24 = 0;
            v25 = 0;
            do
            {
              GTResourceTrackerResourceRead(v5, 22, *(_QWORD *)(*v23 + v24), a3);
              ++v25;
              v24 += 16;
            }
            while (v23[1] > v25);
          }
          if (v23[7])
          {
            v26 = 0;
            v27 = 0;
            do
            {
              GTResourceTrackerResourceRead(v5, 22, *(_QWORD *)(v23[6] + v26), a3);
              ++v27;
              v26 += 16;
            }
            while (v23[7] > v27);
          }
          v11 = v23 + 4;
LABEL_25:
          result = GTResourceTrackerResourceRead(v5, 22, *v11, a3);
          break;
        default:
          break;
      }
      ++v7;
    }
    while (a2[2] > v7);
  }
  return result;
}

void GTResourceTrackerProcessResourceUse(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  int v6;
  uint64_t v7;
  uint64_t *v8;
  int v9;
  char *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t *v25;
  _QWORD *v26;
  char *v27;
  uint64_t v28;
  uint64_t *v29;
  int v30;
  char *v31;
  char *v32;
  char *v33;
  unsigned int v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t *v39;
  int v40;
  char *v41;
  int v42;
  char *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  char *v55;
  _QWORD *v56;
  uint64_t *v57;
  char *v58;
  _QWORD *v59;
  int v60;
  uint64_t v61;
  char *v62;
  int ResourceType;
  char *v64;
  char *v65;
  uint64_t *v66;
  uint64_t v67;
  uint64_t *v68;
  int v69;
  char *v70;
  uint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  char *v75;
  uint64_t v76;
  uint64_t *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  _QWORD *v83;
  char *v84;
  _QWORD *v85;
  unsigned int v86;
  _QWORD *v87;
  int v88;
  char *v89;
  char *v90;
  uint64_t v91;
  char *v92;
  _QWORD *v93;
  char *v94;
  _QWORD *v95;
  uint64_t *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  uint64_t *v100;
  uint64_t v101;
  char *v102;
  char *v103;
  uint64_t v104;
  char *v105;
  uint64_t v106;
  uint64_t *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  char *v112;
  uint64_t v113;
  char *v114;
  uint64_t v115;
  uint64_t *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  char *v121;
  uint64_t v122;
  char *v123;
  uint64_t v124;
  uint64_t *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  char *v131;
  uint64_t v132;
  uint64_t *v133;
  uint64_t v134;
  uint64_t v135;
  char *v136;
  uint64_t v137;
  char *v138;
  uint64_t v139;
  uint64_t *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  char *v145;
  uint64_t v146;
  char *v147;
  uint64_t v148;
  uint64_t *v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  _QWORD *v154;
  char *v155;
  uint64_t *v156;
  uint64_t v157;
  uint64_t *v158;
  uint64_t v159;
  char *v160;
  char *v161;
  char *v162;
  uint64_t v163;
  uint64_t *v164;
  uint64_t v165;
  char *v166;
  char *v167;
  uint64_t v168;
  uint64_t *v169;
  uint64_t v170;
  char *v171;
  unsigned int v172;
  uint64_t v173;
  uint64_t *v174;
  char *v175;
  uint64_t v176;
  char *v177;
  uint64_t v178;
  uint64_t *v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  char *v184;
  uint64_t v185;
  char *v186;
  uint64_t v187;
  uint64_t *v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  char *v193;
  char *v194;
  uint64_t v195;
  char *v196;
  uint64_t v197;
  uint64_t *v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  char *v203;
  uint64_t v204;
  char *v205;
  uint64_t v206;
  uint64_t *v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  char *v212;
  uint64_t v213;
  char *v214;
  uint64_t v215;
  uint64_t *v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  char *v221;
  _QWORD *v222;
  char *v223;
  char *v224;
  uint64_t v225;
  uint64_t *v226;
  uint64_t v227;
  uint64_t *v228;
  char *v229;
  char *v230;
  char *v231;
  uint64_t v232;
  uint64_t *v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t *v236;
  uint64_t *v237;
  _QWORD *v238;
  uint64_t *v239;
  uint64_t *v240;
  uint64_t v241;
  uint64_t *v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  int v247;
  uint64_t *v248;
  uint64_t *v249;
  uint64_t *v250;
  char *v251;
  char *v252;
  uint64_t v253;
  uint64_t *v254;
  uint64_t v255;
  uint64_t v256;
  char *v257;
  uint64_t v258;
  uint64_t *v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t *v262;
  char *v263;
  char *v264;
  uint64_t v265;
  uint64_t *v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t *v269;
  char *v270;
  uint64_t v271;
  uint64_t *v272;
  uint64_t v273;
  uint64_t v274;
  char *v275;
  uint64_t v276;
  uint64_t *v277;
  uint64_t v278;
  uint64_t v279;
  _QWORD *v280;
  _QWORD *v281;
  _QWORD *v282;
  _QWORD *v283;
  _QWORD *v284;
  _QWORD *v285;
  uint64_t *v286;
  uint64_t *v287;
  _QWORD *v288;
  uint64_t *v289;
  _QWORD *v290;
  char *v291;
  uint64_t v292;
  char *v293;
  uint64_t v294;
  uint64_t *v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  char *v300;
  uint64_t v301;
  char *v302;
  uint64_t v303;
  uint64_t *v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  char *v309;
  uint64_t v310;
  char *v311;
  uint64_t v312;
  uint64_t *v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  char *v318;
  uint64_t v319;
  char *v320;
  uint64_t v321;
  uint64_t *v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  char *v327;
  uint64_t v328;
  char *v329;
  uint64_t v330;
  uint64_t *v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  char *v336;
  uint64_t v337;
  char *v338;
  uint64_t v339;
  uint64_t *v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  char *v345;
  uint64_t v346;
  char *v347;
  uint64_t v348;
  uint64_t *v349;
  uint64_t v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  char *v354;
  uint64_t v355;
  char *v356;
  uint64_t v357;
  uint64_t *v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  char *v363;
  uint64_t v364;
  char *v365;
  uint64_t v366;
  uint64_t *v367;
  uint64_t v368;
  uint64_t v369;
  uint64_t v370;
  uint64_t v371;
  char *v372;
  uint64_t v373;
  char *v374;
  uint64_t v375;
  uint64_t *v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  char *v381;
  uint64_t v382;
  char *v383;
  uint64_t v384;
  uint64_t *v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  char *v390;
  uint64_t v391;
  char *v392;
  uint64_t v393;
  uint64_t *v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  char *v399;
  uint64_t v400;
  char *v401;
  uint64_t v402;
  uint64_t *v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  uint64_t v407;
  char *v408;
  uint64_t *v409;
  char *v410;
  char *v411;
  uint64_t v412;
  char *v413;
  uint64_t v414;
  uint64_t *v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  char *v420;
  uint64_t v421;
  char *v422;
  uint64_t v423;
  uint64_t *v424;
  uint64_t v425;
  uint64_t v426;
  uint64_t v427;
  uint64_t v428;
  char *v429;
  uint64_t v430;
  char *v431;
  uint64_t v432;
  uint64_t *v433;
  uint64_t v434;
  uint64_t v435;
  uint64_t v436;
  uint64_t v437;
  char *v438;
  uint64_t v439;
  char *v440;
  uint64_t v441;
  uint64_t *v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t v446;
  char *v447;
  uint64_t v448;
  char *v449;
  uint64_t v450;
  uint64_t *v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t v455;
  char *v456;
  uint64_t v457;
  char *v458;
  uint64_t v459;
  uint64_t *v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  uint64_t v464;
  char *v465;
  uint64_t v466;
  char *v467;
  uint64_t v468;
  uint64_t *v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  char *v474;
  uint64_t v475;
  char *v476;
  uint64_t v477;
  uint64_t *v478;
  uint64_t v479;
  uint64_t v480;
  uint64_t v481;
  uint64_t v482;
  char *v483;
  char *v484;
  char *v485;
  char *v486;
  uint64_t v487;
  char *v488;
  uint64_t v489;
  uint64_t *v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  uint64_t v494;
  char *v495;
  uint64_t v496;
  char *v497;
  uint64_t v498;
  uint64_t *v499;
  uint64_t v500;
  uint64_t v501;
  uint64_t v502;
  uint64_t v503;
  char *v504;
  uint64_t v505;
  char *v506;
  uint64_t v507;
  uint64_t *v508;
  uint64_t v509;
  uint64_t v510;
  uint64_t v511;
  uint64_t v512;
  char *v513;
  uint64_t v514;
  char *v515;
  uint64_t v516;
  uint64_t *v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  uint64_t v521;
  char *v522;
  _QWORD *v523;

  v6 = *(_DWORD *)(a2 + 8);
  if (v6 > -15757)
  {
    if (v6 <= -15367)
    {
      if (v6 <= -15525)
      {
        if (v6 > -15599)
        {
          switch(v6)
          {
            case -15598:
              v102 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v20 = a1[1];
              v21 = *((_QWORD *)v102 + 1);
              v22 = *a1;
              v23 = a1[2];
              v24 = 44;
              goto LABEL_400;
            case -15597:
              v103 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v104 = a1[2];
              v105 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v103[24], a1[1]);
              v106 = *((_QWORD *)v103 + 2);
              if (v106)
              {
                v107 = (uint64_t *)v105;
                v109 = *a1;
                v108 = a1[1];
                do
                {
                  v111 = *v107++;
                  v110 = v111;
                  if (v111)
                    GTResourceTrackerUsingResource(v104, 44, v110, v109, v108);
                  --v106;
                }
                while (v106);
              }
              break;
            case -15592:
            case -15591:
LABEL_46:
              v37 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v38 = v37[1];
              v39 = a1;
              v40 = 22;
LABEL_209:
              GTResourceTrackerResourceRead(v39, v40, v38, a3);
              v28 = v37[3];
              goto LABEL_232;
            case -15588:
              goto LABEL_231;
            case -15583:
LABEL_88:
              v64 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v20 = a1[1];
              v21 = *((_QWORD *)v64 + 1);
              v22 = *a1;
              v23 = a1[2];
              v24 = 60;
              goto LABEL_400;
            case -15582:
              v112 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v113 = a1[2];
              v114 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v112[24], a1[1]);
              v115 = *((_QWORD *)v112 + 2);
              if (v115)
              {
                v116 = (uint64_t *)v114;
                v118 = *a1;
                v117 = a1[1];
                do
                {
                  v120 = *v116++;
                  v119 = v120;
                  if (v120)
                    GTResourceTrackerUsingResource(v113, 60, v119, v118, v117);
                  --v115;
                }
                while (v115);
              }
              break;
            case -15581:
LABEL_89:
              v65 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v20 = a1[1];
              v21 = *((_QWORD *)v65 + 1);
              v22 = *a1;
              v23 = a1[2];
              v24 = 83;
              goto LABEL_400;
            case -15580:
              v121 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v122 = a1[2];
              v123 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v121[24], a1[1]);
              v124 = *((_QWORD *)v121 + 2);
              if (v124)
              {
                v125 = (uint64_t *)v123;
                v127 = *a1;
                v126 = a1[1];
                do
                {
                  v129 = *v125++;
                  v128 = v129;
                  if (v129)
                    GTResourceTrackerUsingResource(v122, 83, v128, v127, v126);
                  --v124;
                }
                while (v124);
              }
              break;
            default:
              return;
          }
        }
        else
        {
          switch(v6)
          {
            case -15647:
              v92 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v93 = tracker_resource_get(a1, 16, *((_QWORD *)v92 + 1), a3);
              if (v93)
                v93[4] = a3;
              GTResourceTrackerUsingResource(a1[2], 22, *((_QWORD *)v92 + 2), *a1, a1[1]);
              v86 = v92[32];
              goto LABEL_131;
            case -15646:
            case -15645:
              v27 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              GTResourceTrackerResourceRead(a1, 16, *((_QWORD *)v27 + 1), a3);
              v28 = *((_QWORD *)v27 + 2);
              v29 = a1;
              v30 = 16;
              goto LABEL_233;
            case -15644:
            case -15643:
            case -15642:
            case -15641:
            case -15640:
            case -15639:
            case -15636:
            case -15628:
            case -15627:
            case -15626:
            case -15625:
            case -15624:
              return;
            case -15638:
              v94 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              GTResourceTrackerResourceRead(a1, 16, *((_QWORD *)v94 + 1), a3);
              v95 = tracker_resource_get(a1, 16, *((_QWORD *)v94 + 2), a3);
              if (v95)
                v95[4] = a3;
              GTResourceTrackerUsingResource(a1[2], 22, *((_QWORD *)v94 + 3), *a1, a1[1]);
              v86 = v94[40];
              goto LABEL_131;
            case -15637:
LABEL_48:
              v41 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v20 = a1[1];
              v21 = *((_QWORD *)v41 + 1);
              v22 = *a1;
              v23 = a1[2];
              v24 = 31;
              goto LABEL_400;
            case -15635:
            case -15630:
LABEL_58:
              v43 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v20 = a1[1];
              v21 = *((_QWORD *)v43 + 1);
              v22 = *a1;
              v23 = a1[2];
              v24 = 41;
              goto LABEL_400;
            case -15634:
LABEL_85:
              v61 = *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 1);
              GTResourceTrackerUsingResourceHeap(a1, v61, a3);
              break;
            case -15633:
              v97 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v98 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v97[16], a1[1]);
              v99 = *((_QWORD *)v97 + 1);
              if (v99)
              {
                v100 = (uint64_t *)v98;
                do
                {
                  v101 = *v100++;
                  GTResourceTrackerUsingResourceHeap(a1, v101, a3);
                  --v99;
                }
                while (v99);
              }
              break;
            case -15632:
LABEL_86:
              v62 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              ResourceType = GTResourceTrackerGetResourceType(*((_QWORD *)v62 + 1), *a1);
              GTResourceTrackerResourceUsage(a1, ResourceType, *((_QWORD *)v62 + 1), a3, *((_DWORD *)v62 + 4));
              break;
            case -15631:
LABEL_42:
              v33 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v34 = v33[24];
LABEL_241:
              v228 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v34, a1[1]);
              GTResourceTrackerResourceUsageArray(a1, v228, *((_QWORD *)v33 + 1), a3, *((_DWORD *)v33 + 4));
              break;
            case -15629:
              goto LABEL_231;
            case -15623:
LABEL_87:
              v7 = *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 1);
              v8 = a1;
              v9 = 16;
              goto LABEL_455;
            default:
              switch(v6)
              {
                case -15756:
                  v32 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
                  GTResourceTrackerUsingResource(a1[2], 31, *((_QWORD *)v32 + 1), *a1, a1[1]);
LABEL_156:
                  v28 = *((_QWORD *)v32 + 4);
                  goto LABEL_232;
                case -15755:
                case -15754:
                case -15750:
                  goto LABEL_48;
                case -15753:
                case -15752:
                case -15751:
                  return;
                case -15749:
                  goto LABEL_124;
                default:
                  switch(v6)
                  {
                    case -15728:
                    case -15726:
                    case -15723:
                    case -15722:
LABEL_71:
                      v7 = *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1])+ 1);
                      goto LABEL_72;
                    default:
                      return;
                  }
              }
          }
        }
      }
      else
      {
        switch(v6)
        {
          case -15474:
LABEL_90:
            v28 = *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 1);
            goto LABEL_232;
          case -15473:
          case -15472:
          case -15471:
          case -15470:
          case -15469:
LABEL_55:
            v28 = *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 1);
            goto LABEL_56;
          case -15468:
          case -15467:
          case -15464:
          case -15463:
          case -15462:
          case -15461:
          case -15460:
          case -15444:
          case -15443:
          case -15442:
          case -15441:
          case -15440:
          case -15439:
          case -15438:
          case -15437:
          case -15436:
          case -15435:
          case -15434:
          case -15433:
          case -15432:
          case -15431:
          case -15430:
          case -15429:
          case -15428:
          case -15427:
          case -15426:
          case -15425:
          case -15424:
          case -15423:
          case -15422:
          case -15421:
          case -15420:
          case -15419:
          case -15418:
          case -15417:
          case -15416:
          case -15414:
          case -15413:
          case -15412:
          case -15411:
          case -15410:
          case -15409:
          case -15408:
          case -15407:
          case -15406:
          case -15405:
          case -15404:
          case -15403:
          case -15402:
          case -15400:
          case -15398:
          case -15390:
          case -15388:
            return;
          case -15466:
LABEL_74:
            v55 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v56 = tracker_resource_get(a1, 16, *((_QWORD *)v55 + 1), a3);
            if (v56)
              v56[4] = a3;
            v57 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v55[32], a1[1]);
            GTResourceTrackerResourceReadMTLArray(a1, v57, a3);
            v7 = *((_QWORD *)v55 + 2);
            goto LABEL_454;
          case -15465:
LABEL_117:
            v73 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v87 = tracker_resource_get(a1, 16, *((_QWORD *)v73 + 1), a3);
            if (v87)
              v87[4] = a3;
LABEL_119:
            v7 = *((_QWORD *)v73 + 2);
            goto LABEL_454;
          case -15459:
          case -15454:
          case -15449:
            goto LABEL_87;
          case -15458:
          case -15453:
          case -15448:
            goto LABEL_88;
          case -15457:
            v10 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v11 = a1[2];
            v12 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v10[24], a1[1]);
            v13 = *((_QWORD *)v10 + 2);
            if (v13)
            {
              v14 = (uint64_t *)v12;
              v16 = *a1;
              v15 = a1[1];
              do
              {
                v18 = *v14++;
                v17 = v18;
                if (v18)
                  GTResourceTrackerUsingResource(v11, 60, v17, v16, v15);
                --v13;
              }
              while (v13);
            }
            break;
          case -15456:
          case -15451:
          case -15446:
            goto LABEL_89;
          case -15455:
            v291 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v292 = a1[2];
            v293 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v291[24], a1[1]);
            v294 = *((_QWORD *)v291 + 2);
            if (v294)
            {
              v295 = (uint64_t *)v293;
              v297 = *a1;
              v296 = a1[1];
              do
              {
                v299 = *v295++;
                v298 = v299;
                if (v299)
                  GTResourceTrackerUsingResource(v292, 83, v298, v297, v296);
                --v294;
              }
              while (v294);
            }
            break;
          case -15452:
            v300 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v301 = a1[2];
            v302 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v300[24], a1[1]);
            v303 = *((_QWORD *)v300 + 2);
            if (v303)
            {
              v304 = (uint64_t *)v302;
              v306 = *a1;
              v305 = a1[1];
              do
              {
                v308 = *v304++;
                v307 = v308;
                if (v308)
                  GTResourceTrackerUsingResource(v301, 60, v307, v306, v305);
                --v303;
              }
              while (v303);
            }
            break;
          case -15450:
            v309 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v310 = a1[2];
            v311 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v309[24], a1[1]);
            v312 = *((_QWORD *)v309 + 2);
            if (v312)
            {
              v313 = (uint64_t *)v311;
              v315 = *a1;
              v314 = a1[1];
              do
              {
                v317 = *v313++;
                v316 = v317;
                if (v317)
                  GTResourceTrackerUsingResource(v310, 83, v316, v315, v314);
                --v312;
              }
              while (v312);
            }
            break;
          case -15447:
            v318 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v319 = a1[2];
            v320 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v318[24], a1[1]);
            v321 = *((_QWORD *)v318 + 2);
            if (v321)
            {
              v322 = (uint64_t *)v320;
              v324 = *a1;
              v323 = a1[1];
              do
              {
                v326 = *v322++;
                v325 = v326;
                if (v326)
                  GTResourceTrackerUsingResource(v319, 60, v325, v324, v323);
                --v321;
              }
              while (v321);
            }
            break;
          case -15445:
            v327 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v328 = a1[2];
            v329 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v327[24], a1[1]);
            v330 = *((_QWORD *)v327 + 2);
            if (v330)
            {
              v331 = (uint64_t *)v329;
              v333 = *a1;
              v332 = a1[1];
              do
              {
                v335 = *v331++;
                v334 = v335;
                if (v335)
                  GTResourceTrackerUsingResource(v328, 83, v334, v333, v332);
                --v330;
              }
              while (v330);
            }
            break;
          case -15415:
LABEL_211:
            v7 = *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 1);
            goto LABEL_454;
          case -15401:
          case -15391:
            goto LABEL_99;
          case -15399:
            v336 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v337 = a1[2];
            v338 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v336[24], a1[1]);
            v339 = *((_QWORD *)v336 + 2);
            if (v339)
            {
              v340 = (uint64_t *)v338;
              v342 = *a1;
              v341 = a1[1];
              do
              {
                v344 = *v340++;
                v343 = v344;
                if (v344)
                  GTResourceTrackerUsingResource(v337, 22, v343, v342, v341);
                --v339;
              }
              while (v339);
            }
            break;
          case -15397:
          case -15396:
          case -15387:
          case -15386:
LABEL_60:
            v44 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v20 = a1[1];
            v21 = *((_QWORD *)v44 + 1);
            v22 = *a1;
            v23 = a1[2];
LABEL_61:
            v24 = 75;
            goto LABEL_400;
          case -15395:
            v345 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v346 = a1[2];
            v347 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v345[24], a1[1]);
            v348 = *((_QWORD *)v345 + 2);
            if (v348)
            {
              v349 = (uint64_t *)v347;
              v351 = *a1;
              v350 = a1[1];
              do
              {
                v353 = *v349++;
                v352 = v353;
                if (v353)
                  GTResourceTrackerUsingResource(v346, 75, v352, v351, v350);
                --v348;
              }
              while (v348);
            }
            break;
          case -15394:
            v354 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v355 = a1[2];
            v356 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v354[24], a1[1]);
            v357 = *((_QWORD *)v354 + 2);
            if (v357)
            {
              v358 = (uint64_t *)v356;
              v360 = *a1;
              v359 = a1[1];
              do
              {
                v362 = *v358++;
                v361 = v362;
                if (v362)
                  GTResourceTrackerUsingResource(v355, 75, v361, v360, v359);
                --v357;
              }
              while (v357);
            }
            break;
          case -15393:
          case -15383:
LABEL_69:
            v54 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v20 = a1[1];
            v21 = *((_QWORD *)v54 + 1);
            v22 = *a1;
            v23 = a1[2];
            v24 = 80;
            goto LABEL_400;
          case -15392:
            v363 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v364 = a1[2];
            v365 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v363[24], a1[1]);
            v366 = *((_QWORD *)v363 + 2);
            if (v366)
            {
              v367 = (uint64_t *)v365;
              v369 = *a1;
              v368 = a1[1];
              do
              {
                v371 = *v367++;
                v370 = v371;
                if (v371)
                  GTResourceTrackerUsingResource(v364, 80, v370, v369, v368);
                --v366;
              }
              while (v366);
            }
            break;
          case -15389:
            v372 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v373 = a1[2];
            v374 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v372[24], a1[1]);
            v375 = *((_QWORD *)v372 + 2);
            if (v375)
            {
              v376 = (uint64_t *)v374;
              v378 = *a1;
              v377 = a1[1];
              do
              {
                v380 = *v376++;
                v379 = v380;
                if (v380)
                  GTResourceTrackerUsingResource(v373, 22, v379, v378, v377);
                --v375;
              }
              while (v375);
            }
            break;
          case -15385:
            v381 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v382 = a1[2];
            v383 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v381[24], a1[1]);
            v384 = *((_QWORD *)v381 + 2);
            if (v384)
            {
              v385 = (uint64_t *)v383;
              v387 = *a1;
              v386 = a1[1];
              do
              {
                v389 = *v385++;
                v388 = v389;
                if (v389)
                  GTResourceTrackerUsingResource(v382, 75, v388, v387, v386);
                --v384;
              }
              while (v384);
            }
            break;
          case -15384:
            v390 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v391 = a1[2];
            v392 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v390[24], a1[1]);
            v393 = *((_QWORD *)v390 + 2);
            if (v393)
            {
              v394 = (uint64_t *)v392;
              v396 = *a1;
              v395 = a1[1];
              do
              {
                v398 = *v394++;
                v397 = v398;
                if (v398)
                  GTResourceTrackerUsingResource(v391, 75, v397, v396, v395);
                --v393;
              }
              while (v393);
            }
            break;
          case -15382:
            v399 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v400 = a1[2];
            v401 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v399[24], a1[1]);
            v402 = *((_QWORD *)v399 + 2);
            if (v402)
            {
              v403 = (uint64_t *)v401;
              v405 = *a1;
              v404 = a1[1];
              do
              {
                v407 = *v403++;
                v406 = v407;
                if (v407)
                  GTResourceTrackerUsingResource(v400, 80, v406, v405, v404);
                --v402;
              }
              while (v402);
            }
            break;
          default:
            switch(v6)
            {
              case -15524:
                goto LABEL_74;
              case -15523:
                goto LABEL_117;
              case -15522:
                v408 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
                GTResourceTrackerResourceRead(a1, 16, *((_QWORD *)v408 + 1), a3);
                v409 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v408[32], a1[1]);
                GTResourceTrackerResourceReadMTLArray(a1, v409, a3);
                v28 = *((_QWORD *)v408 + 2);
                goto LABEL_232;
              case -15521:
                goto LABEL_231;
              default:
                if (v6 == -15502)
                  goto LABEL_231;
                break;
            }
            break;
        }
      }
      return;
    }
    if (v6 > -7158)
    {
      switch(v6)
      {
        case -6142:
          v230 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 7, *(_QWORD *)v230, *a1, a1[1]);
          v231 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v230[40], a1[1]);
          v232 = *((_QWORD *)v230 + 6);
          if (v232)
          {
            v233 = (uint64_t *)v231;
            do
            {
              v235 = *v233++;
              v234 = v235;
              if (v235)
                GTResourceTrackerResourceRead(a1, 80, v234, a3);
              --v232;
            }
            while (v232);
          }
          v236 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v230[64], a1[1]);
          GTResourceTrackerResourceWriteArray(a1, v236, *((_QWORD *)v230 + 9), a3);
          v7 = *((_QWORD *)v230 + 13);
          goto LABEL_454;
        case -6141:
        case -6139:
        case -6138:
        case -6134:
        case -6133:
        case -6131:
        case -6129:
        case -6128:
        case -6127:
        case -6124:
        case -6123:
        case -6122:
        case -6120:
        case -6119:
        case -6116:
        case -6111:
        case -6110:
        case -6109:
          return;
        case -6140:
          v237 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 11, *v237, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v237[6], a3);
          GTResourceTrackerResourceRead(a1, 22, v237[11], a3);
          v238 = tracker_resource_get(a1, 22, v237[15], a3);
          if (v238)
            v238[4] = a3;
          v7 = v237[19];
          goto LABEL_454;
        case -6137:
          v239 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 11, *v239, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v239[6], a3);
          GTResourceTrackerResourceRead(a1, 22, v239[11], a3);
          v28 = v239[15];
          goto LABEL_232;
        case -6136:
          v240 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 5, *v240, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v240[3], a3);
          v241 = v240[4];
          goto LABEL_452;
        case -6135:
          v242 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v244 = a1[1];
          v243 = a1[2];
          v245 = *v242;
          v246 = *a1;
          v247 = 8;
          goto LABEL_258;
        case -6132:
          v248 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 10, *v248, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v248[11], a3);
          GTResourceTrackerResourceRead(a1, 22, v248[16], a3);
          v28 = v248[21];
          goto LABEL_232;
        case -6130:
          v249 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 10, *v249, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v249[6], a3);
          GTResourceTrackerResourceRead(a1, 22, v249[11], a3);
          v28 = v249[16];
          goto LABEL_232;
        case -6126:
          v242 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v244 = a1[1];
          v243 = a1[2];
          v245 = *v242;
          v246 = *a1;
          v247 = 7;
LABEL_258:
          GTResourceTrackerUsingResource(v243, v247, v245, v246, v244);
          GTResourceTrackerResourceRead(a1, 80, v242[5], a3);
          v28 = v242[7];
          goto LABEL_56;
        case -6125:
          v35 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 4, *v35, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 80, v35[6], a3);
          v36 = v35[8];
LABEL_260:
          GTResourceTrackerResourceRead(a1, 80, v36, a3);
          v28 = v35[10];
          goto LABEL_56;
        case -6121:
          v250 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 7, *v250, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 80, v250[5], a3);
          v7 = v250[7];
LABEL_72:
          v8 = a1;
          v9 = 80;
          goto LABEL_455;
        case -6118:
          v251 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 4, *(_QWORD *)v251, *a1, a1[1]);
          v252 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v251[48], a1[1]);
          v253 = *((_QWORD *)v251 + 7);
          if (v253)
          {
            v254 = (uint64_t *)v252;
            do
            {
              v256 = *v254++;
              v255 = v256;
              if (v256)
                GTResourceTrackerResourceRead(a1, 80, v255, a3);
              --v253;
            }
            while (v253);
          }
          v257 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v251[72], a1[1]);
          v258 = *((_QWORD *)v251 + 10);
          if (v258)
          {
            v259 = (uint64_t *)v257;
            do
            {
              v261 = *v259++;
              v260 = v261;
              if (v261)
                GTResourceTrackerResourceRead(a1, 80, v260, a3);
              --v258;
            }
            while (v258);
          }
          v262 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v251[96], a1[1]);
          GTResourceTrackerResourceWriteArray(a1, v262, *((_QWORD *)v251 + 13), a3);
          goto LABEL_295;
        case -6117:
          v66 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 8, *v66, *a1, a1[1]);
          v67 = v66[6];
          v68 = a1;
          v69 = 80;
LABEL_274:
          GTResourceTrackerResourceRead(v68, v69, v67, a3);
          v28 = v66[8];
          goto LABEL_56;
        case -6115:
          v263 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 8, *(_QWORD *)v263, *a1, a1[1]);
          v264 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v263[48], a1[1]);
          v265 = *((_QWORD *)v263 + 7);
          if (v265)
          {
            v266 = (uint64_t *)v264;
            do
            {
              v268 = *v266++;
              v267 = v268;
              if (v268)
                GTResourceTrackerResourceRead(a1, 80, v267, a3);
              --v265;
            }
            while (v265);
          }
          v269 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v263[72], a1[1]);
          GTResourceTrackerResourceWriteArray(a1, v269, *((_QWORD *)v263 + 10), a3);
          v7 = *((_QWORD *)v263 + 12);
          goto LABEL_454;
        case -6114:
          v251 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 6, *(_QWORD *)v251, *a1, a1[1]);
          v270 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v251[48], a1[1]);
          v271 = *((_QWORD *)v251 + 7);
          if (v271)
          {
            v272 = (uint64_t *)v270;
            do
            {
              v274 = *v272++;
              v273 = v274;
              if (v274)
                GTResourceTrackerResourceRead(a1, 80, v273, a3);
              --v271;
            }
            while (v271);
          }
          v275 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v251[72], a1[1]);
          v276 = *((_QWORD *)v251 + 10);
          if (v276)
          {
            v277 = (uint64_t *)v275;
            do
            {
              v279 = *v277++;
              v278 = v279;
              if (v279)
                GTResourceTrackerResourceRead(a1, 80, v278, a3);
              --v276;
            }
            while (v276);
          }
          GTResourceTrackerResourceRead(a1, 22, *((_QWORD *)v251 + 12), a3);
          v280 = tracker_resource_get(a1, 22, *((_QWORD *)v251 + 12), a3);
          if (v280)
            v280[4] = a3;
          GTResourceTrackerResourceRead(a1, 22, *((_QWORD *)v251 + 13), a3);
          v281 = tracker_resource_get(a1, 22, *((_QWORD *)v251 + 13), a3);
          if (v281)
            v281[4] = a3;
LABEL_295:
          v7 = *((_QWORD *)v251 + 15);
          goto LABEL_454;
        case -6113:
          v156 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 6, *v156, *a1, a1[1]);
          v157 = v156[3];
LABEL_297:
          GTResourceTrackerResourceRead(a1, 22, v157, a3);
          v7 = v156[4];
          goto LABEL_454;
        case -6112:
          v240 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 5, *v240, *a1, a1[1]);
          v282 = tracker_resource_get(a1, 22, v240[3], a3);
          if (v282)
            v282[4] = a3;
          v283 = tracker_resource_get(a1, 22, v240[4], a3);
          if (v283)
            v283[4] = a3;
          goto LABEL_453;
        case -6108:
          v158 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 5, *v158, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v158[3], a3);
          v159 = v158[5];
LABEL_303:
          GTResourceTrackerResourceRead(a1, 22, v159, a3);
          goto LABEL_304;
        case -6107:
          v240 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 6, *v240, *a1, a1[1]);
          v241 = v240[3];
LABEL_452:
          GTResourceTrackerResourceRead(a1, 22, v241, a3);
LABEL_453:
          v7 = v240[5];
          goto LABEL_454;
        case -6106:
          v158 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 5, *v158, *a1, a1[1]);
          v284 = tracker_resource_get(a1, 22, v158[3], a3);
          if (v284)
            v284[4] = a3;
          v285 = tracker_resource_get(a1, 22, v158[5], a3);
          if (v285)
            v285[4] = a3;
LABEL_304:
          v7 = v158[6];
          goto LABEL_454;
        case -6105:
        case -6101:
          v25 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 10, *v25, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v25[11], a3);
          GTResourceTrackerResourceRead(a1, 22, v25[16], a3);
          v26 = tracker_resource_get(a1, 22, v25[21], a3);
          if (v26)
            v26[4] = a3;
          v7 = v25[26];
          goto LABEL_454;
        case -6104:
          v286 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 9, *v286, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v286[6], a3);
          GTResourceTrackerResourceRead(a1, 22, v286[11], a3);
          GTResourceTrackerResourceRead(a1, 22, v286[16], a3);
          v28 = v286[20];
          goto LABEL_232;
        case -6103:
          v287 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 9, *v287, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v287[6], a3);
          GTResourceTrackerResourceRead(a1, 22, v287[11], a3);
          GTResourceTrackerResourceRead(a1, 22, v287[16], a3);
          v288 = tracker_resource_get(a1, 22, v287[20], a3);
          if (v288)
            v288[4] = a3;
          v7 = v287[33];
          goto LABEL_454;
        case -6102:
        case -6100:
          v77 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v79 = a1[1];
          v78 = a1[2];
          v80 = *v77;
          v81 = *a1;
          v82 = 14;
          goto LABEL_111;
        case -6099:
        case -6098:
          v77 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v79 = a1[1];
          v78 = a1[2];
          v80 = *v77;
          v81 = *a1;
          v82 = 13;
LABEL_111:
          GTResourceTrackerUsingResource(v78, v82, v80, v81, v79);
          GTResourceTrackerResourceRead(a1, 22, v77[6], a3);
          GTResourceTrackerResourceRead(a1, 22, v77[8], a3);
          GTResourceTrackerResourceRead(a1, 22, v77[10], a3);
          v83 = tracker_resource_get(a1, 22, v77[12], a3);
          if (v83)
            v83[4] = a3;
          v7 = v77[15];
          goto LABEL_454;
        case -6097:
          v289 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 12, *v289, *a1, a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v289[6], a3);
          GTResourceTrackerResourceRead(a1, 22, v289[8], a3);
          v290 = tracker_resource_get(a1, 22, v289[10], a3);
          if (v290)
            v290[4] = a3;
          v7 = v289[12];
LABEL_454:
          v8 = a1;
          v9 = 22;
LABEL_455:
          GTResourceTrackerResourceRead(v8, v9, v7, a3);
          return;
        default:
          if (v6 == -7157)
            goto LABEL_108;
          v42 = -7156;
          goto LABEL_107;
      }
    }
    if (v6 <= -15288)
    {
      if (v6 > -15341)
      {
        switch(v6)
        {
          case -15311:
            goto LABEL_78;
          case -15310:
            v522 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v523 = tracker_resource_get(a1, 80, *((_QWORD *)v522 + 1), a3);
            if (v523)
              *((_BYTE *)v523 + 48) = 1;
            v28 = *((_QWORD *)v522 + 1);
            goto LABEL_56;
          case -15309:
          case -15308:
            goto LABEL_124;
          default:
            if (v6 == -15340 || v6 == -15339)
              goto LABEL_124;
            break;
        }
        return;
      }
      if (v6 == -15366)
      {
        v84 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
        GTResourceTrackerResourceRead(a1, 16, *((_QWORD *)v84 + 1), a3);
        v85 = tracker_resource_get(a1, 16, *((_QWORD *)v84 + 2), a3);
        if (v85)
          v85[4] = a3;
        GTResourceTrackerUsingResource(a1[2], 22, *((_QWORD *)v84 + 3), *a1, a1[1]);
        v86 = v84[48];
LABEL_131:
        v96 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v86, a1[1]);
        GTResourceTrackerUsingAccelerationStructureDescriptor(a1, v96, a3);
        return;
      }
      if (v6 != -15365)
      {
        if (v6 != -15342)
          return;
LABEL_78:
        v58 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
        v59 = tracker_resource_get(a1, 22, *((_QWORD *)v58 + 1), a3);
        if (v59)
          *((_BYTE *)v59 + 48) = 1;
        v28 = *((_QWORD *)v58 + 1);
        goto LABEL_232;
      }
LABEL_231:
      v221 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
      GTResourceTrackerResourceRead(a1, 16, *((_QWORD *)v221 + 1), a3);
      v28 = *((_QWORD *)v221 + 2);
LABEL_232:
      v29 = a1;
      v30 = 22;
      goto LABEL_233;
    }
    if (v6 <= -15274)
    {
      if (v6 > -15283)
      {
        if (v6 == -15282)
        {
          v145 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v146 = a1[2];
          v147 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v145[24], a1[1]);
          v148 = *((_QWORD *)v145 + 2);
          if (v148)
          {
            v149 = (uint64_t *)v147;
            v151 = *a1;
            v150 = a1[1];
            do
            {
              v153 = *v149++;
              v152 = v153;
              if (v153)
                GTResourceTrackerUsingResource(v146, 22, v152, v151, v150);
              --v148;
            }
            while (v148);
          }
          return;
        }
        v60 = -15275;
      }
      else
      {
        if (v6 == -15287)
          goto LABEL_231;
        v60 = -15284;
      }
      if (v6 != v60)
        return;
LABEL_99:
      v72 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
      v20 = a1[1];
      v21 = *((_QWORD *)v72 + 1);
      v22 = *a1;
      v23 = a1[2];
      v24 = 22;
    }
    else
    {
      if (v6 <= -15254)
      {
        if (v6 == -15273)
        {
          v136 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v137 = a1[2];
          v138 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v136[24], a1[1]);
          v139 = *((_QWORD *)v136 + 2);
          if (v139)
          {
            v140 = (uint64_t *)v138;
            v142 = *a1;
            v141 = a1[1];
            do
            {
              v144 = *v140++;
              v143 = v144;
              if (v144)
                GTResourceTrackerUsingResource(v137, 22, v143, v142, v141);
              --v139;
            }
            while (v139);
          }
        }
        else if (v6 == -15254)
        {
          v71 = *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 1);
          GTResourceTrackerUsingResidencySet(a1, v71);
        }
        return;
      }
      if (v6 == -15253)
      {
        v130 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
        v131 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v130[16], a1[1]);
        v132 = *((_QWORD *)v130 + 1);
        if (v132)
        {
          v133 = (uint64_t *)v131;
          do
          {
            v135 = *v133++;
            v134 = v135;
            if (v135)
              GTResourceTrackerUsingResidencySet(a1, v134);
            --v132;
          }
          while (v132);
        }
        return;
      }
      if (v6 == -15217)
      {
LABEL_124:
        v90 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
        v91 = a1[2];
        v24 = GTResourceTrackerGetResourceType(*((_QWORD *)v90 + 1), *a1);
        v21 = *((_QWORD *)v90 + 1);
        v22 = *a1;
        v20 = a1[1];
        v23 = v91;
      }
      else
      {
        v42 = -7158;
LABEL_107:
        if (v6 != v42)
          return;
LABEL_108:
        v75 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
        v76 = a1[2];
        v21 = *(_QWORD *)v75;
LABEL_399:
        v22 = *a1;
        v20 = a1[1];
        v23 = v76;
        v24 = 2;
      }
    }
LABEL_400:
    GTResourceTrackerUsingResource(v23, v24, v21, v22, v20);
    return;
  }
  if (v6 <= -16157)
  {
    if (v6 <= -16359)
    {
      switch(v6)
      {
        case -20480:
        case -20473:
        case -20471:
        case -20470:
        case -20464:
        case -20456:
          goto LABEL_71;
        case -20479:
        case -20469:
          goto LABEL_58;
        case -20478:
        case -20477:
        case -20475:
        case -20472:
        case -20468:
        case -20467:
        case -20466:
        case -20465:
        case -20463:
        case -20462:
        case -20460:
        case -20459:
        case -20458:
          return;
        case -20476:
        case -20461:
          goto LABEL_55;
        case -20474:
          v31 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v20 = a1[1];
          v21 = *(_QWORD *)v31;
          v22 = *a1;
          v23 = a1[2];
          v24 = 39;
          goto LABEL_400;
        case -20457:
          v89 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v20 = a1[1];
          v21 = *(_QWORD *)v89;
          v22 = *a1;
          v23 = a1[2];
          v24 = 40;
          goto LABEL_400;
        default:
          switch(v6)
          {
            case -16382:
LABEL_44:
              v35 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v36 = v35[1];
              goto LABEL_260;
            case -16381:
LABEL_91:
              v66 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v67 = v66[1];
              v68 = a1;
              v69 = 22;
              goto LABEL_274;
            case -16380:
LABEL_92:
              v70 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              GTResourceTrackerResourceRead(a1, 80, *((_QWORD *)v70 + 1), a3);
LABEL_177:
              v28 = *((_QWORD *)v70 + 10);
              goto LABEL_232;
            case -16379:
              goto LABEL_55;
            case -16378:
              goto LABEL_90;
            case -16377:
              goto LABEL_46;
            default:
              v88 = -16359;
LABEL_397:
              if (v6 != v88)
                return;
LABEL_398:
              v410 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v76 = a1[2];
              v21 = *((_QWORD *)v410 + 1);
              break;
          }
          goto LABEL_399;
      }
    }
    else
    {
      switch(v6)
      {
        case -16279:
          v19 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v20 = a1[1];
          v21 = *((_QWORD *)v19 + 1);
          v22 = *a1;
          v23 = a1[2];
          v24 = 71;
          goto LABEL_400;
        case -16278:
        case -16263:
          goto LABEL_99;
        case -16277:
          v411 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v412 = a1[2];
          v413 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v411[24], a1[1]);
          v414 = *((_QWORD *)v411 + 2);
          if (v414)
          {
            v415 = (uint64_t *)v413;
            v417 = *a1;
            v416 = a1[1];
            do
            {
              v419 = *v415++;
              v418 = v419;
              if (v419)
                GTResourceTrackerUsingResource(v412, 22, v418, v417, v416);
              --v414;
            }
            while (v414);
          }
          break;
        case -16276:
        case -16261:
          goto LABEL_69;
        case -16275:
          v420 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v421 = a1[2];
          v422 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v420[24], a1[1]);
          v423 = *((_QWORD *)v420 + 2);
          if (v423)
          {
            v424 = (uint64_t *)v422;
            v426 = *a1;
            v425 = a1[1];
            do
            {
              v428 = *v424++;
              v427 = v428;
              if (v428)
                GTResourceTrackerUsingResource(v421, 80, v427, v426, v425);
              --v423;
            }
            while (v423);
          }
          break;
        case -16274:
        case -16272:
        case -16259:
        case -16257:
          goto LABEL_60;
        case -16273:
          v429 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v430 = a1[2];
          v431 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v429[24], a1[1]);
          v432 = *((_QWORD *)v429 + 2);
          if (v432)
          {
            v433 = (uint64_t *)v431;
            v435 = *a1;
            v434 = a1[1];
            do
            {
              v437 = *v433++;
              v436 = v437;
              if (v437)
                GTResourceTrackerUsingResource(v430, 75, v436, v435, v434);
              --v432;
            }
            while (v432);
          }
          break;
        case -16271:
          v438 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v439 = a1[2];
          v440 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v438[24], a1[1]);
          v441 = *((_QWORD *)v438 + 2);
          if (v441)
          {
            v442 = (uint64_t *)v440;
            v444 = *a1;
            v443 = a1[1];
            do
            {
              v446 = *v442++;
              v445 = v446;
              if (v446)
                GTResourceTrackerUsingResource(v439, 75, v445, v444, v443);
              --v441;
            }
            while (v441);
          }
          break;
        case -16270:
        case -16269:
        case -16268:
        case -16267:
        case -16266:
        case -16265:
        case -16264:
        case -16255:
        case -16253:
        case -16252:
        case -16251:
        case -16250:
        case -16247:
        case -16246:
        case -16245:
        case -16244:
        case -16243:
        case -16242:
        case -16241:
        case -16240:
        case -16239:
        case -16238:
        case -16237:
        case -16236:
        case -16235:
        case -16234:
        case -16233:
        case -16232:
        case -16231:
        case -16230:
        case -16229:
        case -16228:
        case -16227:
        case -16226:
        case -16225:
        case -16224:
        case -16223:
        case -16222:
        case -16221:
        case -16219:
        case -16218:
          return;
        case -16262:
          v447 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v448 = a1[2];
          v449 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v447[24], a1[1]);
          v450 = *((_QWORD *)v447 + 2);
          if (v450)
          {
            v451 = (uint64_t *)v449;
            v453 = *a1;
            v452 = a1[1];
            do
            {
              v455 = *v451++;
              v454 = v455;
              if (v455)
                GTResourceTrackerUsingResource(v448, 22, v454, v453, v452);
              --v450;
            }
            while (v450);
          }
          break;
        case -16260:
          v456 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v457 = a1[2];
          v458 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v456[24], a1[1]);
          v459 = *((_QWORD *)v456 + 2);
          if (v459)
          {
            v460 = (uint64_t *)v458;
            v462 = *a1;
            v461 = a1[1];
            do
            {
              v464 = *v460++;
              v463 = v464;
              if (v464)
                GTResourceTrackerUsingResource(v457, 80, v463, v462, v461);
              --v459;
            }
            while (v459);
          }
          break;
        case -16258:
          v465 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v466 = a1[2];
          v467 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v465[24], a1[1]);
          v468 = *((_QWORD *)v465 + 2);
          if (v468)
          {
            v469 = (uint64_t *)v467;
            v471 = *a1;
            v470 = a1[1];
            do
            {
              v473 = *v469++;
              v472 = v473;
              if (v473)
                GTResourceTrackerUsingResource(v466, 75, v472, v471, v470);
              --v468;
            }
            while (v468);
          }
          break;
        case -16256:
          v474 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v475 = a1[2];
          v476 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v474[24], a1[1]);
          v477 = *((_QWORD *)v474 + 2);
          if (v477)
          {
            v478 = (uint64_t *)v476;
            v480 = *a1;
            v479 = a1[1];
            do
            {
              v482 = *v478++;
              v481 = v482;
              if (v482)
                GTResourceTrackerUsingResource(v475, 75, v481, v480, v479);
              --v477;
            }
            while (v477);
          }
          break;
        case -16254:
          v483 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v20 = a1[1];
          v21 = *((_QWORD *)v483 + 1);
          v22 = *a1;
          v23 = a1[2];
          v24 = 34;
          goto LABEL_400;
        case -16249:
        case -16248:
        case -16217:
LABEL_29:
          v7 = *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 4);
          goto LABEL_454;
        case -16220:
          goto LABEL_211;
        case -16216:
          v7 = *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 2);
          goto LABEL_454;
        case -16215:
          v240 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v241 = v240[3];
          goto LABEL_452;
        case -16214:
          v484 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerUsingResource(a1[2], 80, *((_QWORD *)v484 + 1), *a1, a1[1]);
          v20 = a1[1];
          v23 = a1[2];
          v21 = *((_QWORD *)v484 + 3);
          v22 = *a1;
          goto LABEL_61;
        case -16213:
          goto LABEL_124;
        case -16212:
          goto LABEL_55;
        case -16211:
          goto LABEL_44;
        case -16210:
          goto LABEL_91;
        case -16209:
          goto LABEL_92;
        default:
          switch(v6)
          {
            case -16337:
              v485 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v20 = a1[1];
              v21 = *((_QWORD *)v485 + 1);
              v22 = *a1;
              v23 = a1[2];
              v24 = 29;
              goto LABEL_400;
            case -16336:
              goto LABEL_99;
            case -16335:
              v486 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v487 = a1[2];
              v488 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v486[24], a1[1]);
              v489 = *((_QWORD *)v486 + 2);
              if (v489)
              {
                v490 = (uint64_t *)v488;
                v492 = *a1;
                v491 = a1[1];
                do
                {
                  v494 = *v490++;
                  v493 = v494;
                  if (v494)
                    GTResourceTrackerUsingResource(v487, 22, v493, v492, v491);
                  --v489;
                }
                while (v489);
              }
              break;
            case -16334:
              goto LABEL_69;
            case -16333:
              v495 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v496 = a1[2];
              v497 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v495[24], a1[1]);
              v498 = *((_QWORD *)v495 + 2);
              if (v498)
              {
                v499 = (uint64_t *)v497;
                v501 = *a1;
                v500 = a1[1];
                do
                {
                  v503 = *v499++;
                  v502 = v503;
                  if (v503)
                    GTResourceTrackerUsingResource(v496, 80, v502, v501, v500);
                  --v498;
                }
                while (v498);
              }
              break;
            case -16332:
            case -16330:
              goto LABEL_60;
            case -16331:
              v504 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v505 = a1[2];
              v506 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v504[24], a1[1]);
              v507 = *((_QWORD *)v504 + 2);
              if (v507)
              {
                v508 = (uint64_t *)v506;
                v510 = *a1;
                v509 = a1[1];
                do
                {
                  v512 = *v508++;
                  v511 = v512;
                  if (v512)
                    GTResourceTrackerUsingResource(v505, 75, v511, v510, v509);
                  --v507;
                }
                while (v507);
              }
              break;
            case -16329:
              v513 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v514 = a1[2];
              v515 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v513[24], a1[1]);
              v516 = *((_QWORD *)v513 + 2);
              if (v516)
              {
                v517 = (uint64_t *)v515;
                v519 = *a1;
                v518 = a1[1];
                do
                {
                  v521 = *v517++;
                  v520 = v521;
                  if (v521)
                    GTResourceTrackerUsingResource(v514, 75, v520, v519, v518);
                  --v516;
                }
                while (v516);
              }
              break;
            default:
              v88 = -16358;
              goto LABEL_397;
          }
          break;
      }
    }
  }
  else
  {
    if (v6 > -16009)
    {
      if (v6 <= -15899)
      {
        switch(v6)
        {
          case -15977:
            v70 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            v154 = tracker_resource_get(a1, 80, *((_QWORD *)v70 + 1), a3);
            if (v154)
              v154[4] = a3;
            goto LABEL_177;
          case -15976:
            goto LABEL_55;
          case -15975:
          case -15974:
          case -15973:
          case -15972:
          case -15971:
          case -15970:
          case -15969:
          case -15968:
          case -15965:
            return;
          case -15967:
            goto LABEL_124;
          case -15966:
            goto LABEL_85;
          case -15964:
          case -15962:
            v7 = *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 1);
            v8 = a1;
            v9 = 57;
            goto LABEL_455;
          case -15963:
          case -15961:
            v73 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            GTResourceTrackerResourceRead(a1, 57, *((_QWORD *)v73 + 1), a3);
            goto LABEL_119;
          case -15960:
          case -15958:
            v28 = *((_QWORD *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]) + 1);
            goto LABEL_179;
          case -15959:
            v155 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            GTResourceTrackerResourceRead(a1, 57, *((_QWORD *)v155 + 1), a3);
            v28 = *((_QWORD *)v155 + 4);
LABEL_179:
            v29 = a1;
            v30 = 57;
            goto LABEL_233;
          default:
            switch(v6)
            {
              case -16008:
                v171 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
                v172 = v171[16];
                goto LABEL_194;
              case -16003:
                v171 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
                v172 = v171[32];
LABEL_194:
                v173 = a1[2];
                v174 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v172, a1[1]);
                GTResourceTrackerUsingResourceArray(v173, 0, v174, *((_QWORD *)v171 + 1), *a1, a1[1]);
                break;
              case -15995:
              case -15994:
              case -15993:
              case -15992:
                goto LABEL_55;
              case -15991:
              case -15990:
                goto LABEL_124;
              default:
                return;
            }
            return;
        }
      }
      if (v6 > -15822)
      {
        switch(v6)
        {
          case -15792:
            v32 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            GTResourceTrackerResourceRead(a1, 80, *((_QWORD *)v32 + 1), a3);
            goto LABEL_156;
          case -15791:
          case -15790:
          case -15789:
          case -15788:
          case -15787:
          case -15786:
            return;
          case -15785:
          case -15781:
            goto LABEL_58;
          case -15784:
            v160 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            GTResourceTrackerResourceRead(a1, 80, *((_QWORD *)v160 + 1), a3);
            v7 = *((_QWORD *)v160 + 3);
            goto LABEL_454;
          case -15783:
          case -15782:
            goto LABEL_71;
          default:
            switch(v6)
            {
              case -15821:
                goto LABEL_85;
              case -15820:
                v223 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
                v224 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v223[24], a1[1]);
                v225 = *((_QWORD *)v223 + 1);
                if (v225)
                {
                  v226 = (uint64_t *)v224;
                  do
                  {
                    v227 = *v226++;
                    GTResourceTrackerUsingResourceHeap(a1, v227, a3);
                    --v225;
                  }
                  while (v225);
                }
                break;
              case -15819:
                goto LABEL_86;
              case -15818:
                v33 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
                v34 = v33[32];
                goto LABEL_241;
              default:
                return;
            }
            break;
        }
        return;
      }
      switch(v6)
      {
        case -15898:
          v175 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v176 = a1[2];
          v177 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v175[16], a1[1]);
          v178 = *((_QWORD *)v175 + 1);
          if (v178)
          {
            v179 = (uint64_t *)v177;
            v181 = *a1;
            v180 = a1[1];
            do
            {
              v183 = *v179++;
              v182 = v183;
              if (v183)
                GTResourceTrackerUsingResource(v176, 73, v182, v181, v180);
              --v178;
            }
            while (v178);
          }
          return;
        case -15897:
          v184 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v185 = a1[2];
          v186 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v184[16], a1[1]);
          v187 = *((_QWORD *)v184 + 1);
          if (v187)
          {
            v188 = (uint64_t *)v186;
            v190 = *a1;
            v189 = a1[1];
            do
            {
              v192 = *v188++;
              v191 = v192;
              if (v192)
                GTResourceTrackerUsingResource(v185, 73, v191, v190, v189);
              --v187;
            }
            while (v187);
          }
          return;
        case -15896:
        case -15895:
        case -15894:
        case -15893:
        case -15892:
        case -15891:
        case -15890:
        case -15889:
          return;
        case -15888:
          v193 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v20 = a1[1];
          v21 = *((_QWORD *)v193 + 1);
          v22 = *a1;
          v23 = a1[2];
          v24 = 64;
          goto LABEL_400;
        case -15887:
          v37 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerResourceRead(a1, 80, v37[1], a3);
          v38 = v37[2];
          v39 = a1;
          v40 = 80;
          goto LABEL_209;
        case -15886:
        case -15885:
          goto LABEL_58;
        default:
          if (v6 == -15878)
          {
            v229 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            GTResourceTrackerResourceRead(a1, 80, *((_QWORD *)v229 + 1), a3);
            v28 = *((_QWORD *)v229 + 4);
          }
          else
          {
            if (v6 != -15877)
              return;
            v74 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
            GTResourceTrackerResourceRead(a1, 80, *((_QWORD *)v74 + 1), a3);
            v28 = *((_QWORD *)v74 + 2);
          }
          break;
      }
LABEL_56:
      v29 = a1;
      v30 = 80;
LABEL_233:
      v222 = tracker_resource_get(v29, v30, v28, a3);
      if (v222)
        v222[4] = a3;
      return;
    }
    if (v6 > -16088)
    {
      switch(v6)
      {
        case -16047:
        case -16043:
          goto LABEL_86;
        case -16046:
        case -16042:
          goto LABEL_42;
        case -16045:
        case -16041:
          goto LABEL_85;
        case -16044:
          v161 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v162 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v161[16], a1[1]);
          v163 = *((_QWORD *)v161 + 1);
          if (v163)
          {
            v164 = (uint64_t *)v162;
            do
            {
              v165 = *v164++;
              GTResourceTrackerUsingResourceHeap(a1, v165, a3);
              --v163;
            }
            while (v163);
          }
          break;
        case -16040:
          v166 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v167 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v166[16], a1[1]);
          v168 = *((_QWORD *)v166 + 1);
          if (v168)
          {
            v169 = (uint64_t *)v167;
            do
            {
              v170 = *v169++;
              GTResourceTrackerUsingResourceHeap(a1, v170, a3);
              --v168;
            }
            while (v168);
          }
          break;
        default:
          switch(v6)
          {
            case -16087:
              v45 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v46 = a1[2];
              v47 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v45[24], a1[1]);
              v48 = *((_QWORD *)v45 + 2);
              if (v48)
              {
                v49 = (uint64_t *)v47;
                v51 = *a1;
                v50 = a1[1];
                do
                {
                  v53 = *v49++;
                  v52 = v53;
                  if (v53)
                    GTResourceTrackerUsingResource(v46, 22, v52, v51, v50);
                  --v48;
                }
                while (v48);
              }
              break;
            case -16086:
              v194 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v195 = a1[2];
              v196 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v194[24], a1[1]);
              v197 = *((_QWORD *)v194 + 2);
              if (v197)
              {
                v198 = (uint64_t *)v196;
                v200 = *a1;
                v199 = a1[1];
                do
                {
                  v202 = *v198++;
                  v201 = v202;
                  if (v202)
                    GTResourceTrackerUsingResource(v195, 80, v201, v200, v199);
                  --v197;
                }
                while (v197);
              }
              break;
            case -16085:
              v203 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v204 = a1[2];
              v205 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v203[24], a1[1]);
              v206 = *((_QWORD *)v203 + 2);
              if (v206)
              {
                v207 = (uint64_t *)v205;
                v209 = *a1;
                v208 = a1[1];
                do
                {
                  v211 = *v207++;
                  v210 = v211;
                  if (v211)
                    GTResourceTrackerUsingResource(v204, 75, v210, v209, v208);
                  --v206;
                }
                while (v206);
              }
              break;
            case -16084:
              v212 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              v213 = a1[2];
              v214 = GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, v212[24], a1[1]);
              v215 = *((_QWORD *)v212 + 2);
              if (v215)
              {
                v216 = (uint64_t *)v214;
                v218 = *a1;
                v217 = a1[1];
                do
                {
                  v220 = *v216++;
                  v219 = v220;
                  if (v220)
                    GTResourceTrackerUsingResource(v213, 75, v219, v218, v217);
                  --v215;
                }
                while (v215);
              }
              break;
            case -16083:
            case -16082:
            case -16081:
            case -16080:
              return;
            case -16079:
              goto LABEL_211;
            default:
              if (v6 == -16017)
                goto LABEL_211;
              break;
          }
          break;
      }
    }
    else
    {
      switch(v6)
      {
        case -16156:
        case -16155:
          goto LABEL_71;
        case -16148:
          goto LABEL_211;
        case -16147:
          goto LABEL_29;
        case -16146:
          v156 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v157 = v156[2];
          goto LABEL_297;
        case -16145:
          v158 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          v159 = v158[4];
          goto LABEL_303;
        case -16144:
          v158 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((_QWORD *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v158[2], a3);
          v159 = v158[4];
          goto LABEL_303;
        case -16142:
          goto LABEL_99;
        case -16140:
          goto LABEL_69;
        case -16139:
        case -16138:
          goto LABEL_60;
        case -16133:
          goto LABEL_398;
        case -16131:
        case -16130:
        case -16129:
        case -16126:
        case -16125:
        case -16124:
          goto LABEL_58;
        default:
          return;
      }
    }
  }
}

uint64_t CommandBufferCommitIndex(uint64_t a1)
{
  unsigned int v1;
  unsigned int v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  unsigned int v10;
  BOOL v11;
  int v12;
  unsigned int v14;
  uint64_t v15;
  int v16;

  v1 = 0;
  if (a1)
  {
    while (1)
    {
      v2 = atomic_load((unsigned int *)(a1 + 4));
      v3 = v1 + (v2 >> 6) - 1;
      if ((int)v3 > 0)
        break;
      a1 = *(_QWORD *)(a1 + 40);
      v1 = v3;
      if (!a1)
      {
        v1 = v3;
        goto LABEL_6;
      }
    }
  }
  v3 = 0;
LABEL_6:
  v4 = v1 | (unint64_t)(v3 << 32);
LABEL_7:
  v5 = a1 + 64;
  while (a1)
  {
    v6 = HIDWORD(v4) - v4;
    if ((*(_BYTE *)(v5 + ((uint64_t)(HIDWORD(v4) - (int)v4) << 6) + 15) & 8) == 0)
      break;
    v7 = *(_DWORD *)(v5 + ((uint64_t)v6 << 6) + 8);
    if (v7 > -15344)
    {
      v10 = v7 + 15343;
      v11 = v10 > 0x1B;
      v12 = (1 << v10) & 0xA000001;
      if (!v11 && v12 != 0)
        return *(_QWORD *)(v5 + ((uint64_t)v6 << 6));
    }
    else if (v7 == -16361 || v7 == -16202 || v7 == -15908)
    {
      return *(_QWORD *)(v5 + ((uint64_t)v6 << 6));
    }
    v14 = atomic_load((unsigned int *)(a1 + 4));
    v15 = (HIDWORD(v4) + 1);
    v16 = v4 + (v14 >> 6) - 1;
    v4 = (v15 << 32) | v4;
    if ((_DWORD)v15 == v16)
    {
      v4 = (v15 << 32) | v15;
      a1 = *(_QWORD *)(a1 + 40);
      goto LABEL_7;
    }
  }
  return -1;
}

void GatherCommandQueueResidencySetsUpToIndexInternal(apr_pool_t **a1, uint64_t a2, uint64_t a3, unint64_t a4, int a5)
{
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  unsigned int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  int v27;
  unint64_t *v28;
  int v29;
  char *v30;
  uint64_t v31;
  char *v32;
  apr_hash_t *v33;
  char *v34;
  unsigned int v35;
  int v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  char *v45;
  char *v46;
  char *v47;
  unint64_t v48;

  v6 = *(_QWORD *)(a2 + 32);
  if (v6)
  {
    v7 = 0;
    while (1)
    {
      v8 = atomic_load((unsigned int *)(v6 + 4));
      v9 = v7 + (v8 >> 6) - 1;
      if ((int)v9 > 0)
        break;
      v6 = *(_QWORD *)(v6 + 40);
      v7 = v9;
      if (!v6)
      {
        v7 = v9;
        goto LABEL_8;
      }
    }
  }
  else
  {
    v7 = 0;
  }
  v9 = 0;
LABEL_8:
  v10 = 0;
  v11 = v7 | (unint64_t)(v9 << 32);
LABEL_9:
  v12 = v6 + 64;
  while (v6)
  {
    v13 = HIDWORD(v11) - v11;
    if ((*(_BYTE *)(v12 + ((uint64_t)(HIDWORD(v11) - (int)v11) << 6) + 15) & 8) == 0)
      break;
    v14 = v13;
    v15 = *(_QWORD *)(v12 + ((uint64_t)v13 << 6));
    if (v15 >= a4)
      break;
    v16 = *(_DWORD *)(v12 + (v14 << 6) + 8);
    if (*(char *)(v12 + ((uint64_t)(HIDWORD(v11) - (int)v11) << 6) + 15) < 0 && v16 == -15251)
      v10 = v15;
    v18 = atomic_load((unsigned int *)(v6 + 4));
    v19 = (HIDWORD(v11) + 1);
    v20 = v11 + (v18 >> 6) - 1;
    v11 = (v19 << 32) | v11;
    if ((_DWORD)v19 == v20)
    {
      v11 = (v19 << 32) | v19;
      v6 = *(_QWORD *)(v6 + 40);
      goto LABEL_9;
    }
  }
  v21 = *(_QWORD *)(a2 + 32);
  v22 = 0;
  if (v21)
  {
    while (1)
    {
      v23 = atomic_load((unsigned int *)(v21 + 4));
      v24 = v22 + (v23 >> 6) - 1;
      if ((int)v24 > 0)
        break;
      v21 = *(_QWORD *)(v21 + 40);
      v22 = v24;
      if (!v21)
      {
        v22 = v24;
        goto LABEL_25;
      }
    }
  }
  v24 = 0;
LABEL_25:
  v25 = v22 | (unint64_t)(v24 << 32);
LABEL_26:
  v26 = v21 + 64;
  while (v21)
  {
    v27 = HIDWORD(v25) - v25;
    if ((*(_BYTE *)(v26 + ((uint64_t)(HIDWORD(v25) - (int)v25) << 6) + 15) & 8) == 0)
      break;
    v28 = (unint64_t *)(v26 + ((uint64_t)v27 << 6));
    if (*v28 >= v10)
    {
      if (*v28 >= a4)
      {
        if ((*(_BYTE *)(v26 + ((uint64_t)(HIDWORD(v25) - (int)v25) << 6) + 15) & 0x80) != 0)
          return;
      }
      else
      {
        v29 = *(_DWORD *)(v26 + ((uint64_t)v27 << 6) + 8);
        if (!a5 || (v29 & 0xFFFFFFFE) != 0xFFFFC46E)
        {
          switch(v29)
          {
            case -15252:
              v30 = GTTraceFunc_argumentBytesWithMap(v28, *(unsigned __int8 *)(v26 + ((uint64_t)v27 << 6) + 13), a3) + 8;
              v31 = *find_entry((uint64_t)a1, v30, 8uLL, 0);
              if (!v31 || !*(_QWORD *)(v31 + 32))
              {
                v32 = (char *)apr_palloc(*a1, 8uLL);
                *(_QWORD *)v32 = *(_QWORD *)v30;
                v33 = (apr_hash_t *)a1;
                v34 = v32;
                goto LABEL_51;
              }
              break;
            case -15251:
              v38 = GTTraceFunc_argumentBytesWithMap(v28, *(unsigned __int8 *)(v26 + ((uint64_t)v27 << 6) + 13), a3);
              v39 = GTTraceFunc_argumentBytesWithMap(v28, v38[16], a3);
              if (*((_QWORD *)v38 + 1))
              {
                v40 = v39;
                v41 = 0;
                v42 = 0;
                do
                {
                  v43 = *find_entry((uint64_t)a1, &v40[v41], 8uLL, 0);
                  if (!v43 || !*(_QWORD *)(v43 + 32))
                  {
                    if (v40)
                    {
                      v44 = apr_palloc(*a1, 8uLL);
                      *v44 = *(_QWORD *)&v40[8 * v42];
                    }
                    else
                    {
                      v44 = 0;
                    }
                    apr_hash_set((apr_hash_t *)a1, v44, 8, v44);
                  }
                  ++v42;
                  v41 += 8;
                }
                while (*((_QWORD *)v38 + 1) > v42);
              }
              break;
            case -15250:
              v32 = GTTraceFunc_argumentBytesWithMap(v28, *(unsigned __int8 *)(v26 + ((uint64_t)v27 << 6) + 13), a3) + 8;
              v33 = (apr_hash_t *)a1;
              v34 = 0;
LABEL_51:
              apr_hash_set(v33, v32, 8, v34);
              break;
            case -15249:
              v45 = GTTraceFunc_argumentBytesWithMap(v28, *(unsigned __int8 *)(v26 + ((uint64_t)v27 << 6) + 13), a3);
              v46 = GTTraceFunc_argumentBytesWithMap(v28, v45[16], a3);
              if (*((_QWORD *)v45 + 1))
              {
                v47 = v46;
                v48 = 0;
                do
                {
                  apr_hash_set((apr_hash_t *)a1, v47, 8, 0);
                  ++v48;
                  v47 += 8;
                }
                while (*((_QWORD *)v45 + 1) > v48);
              }
              break;
            default:
              break;
          }
        }
      }
    }
    v35 = atomic_load((unsigned int *)(v21 + 4));
    v36 = v25 + (v35 >> 6);
    v37 = (HIDWORD(v25) + 1);
    v25 = (v37 << 32) | v25;
    if ((_DWORD)v37 == v36 - 1)
    {
      v25 = (v37 << 32) | v37;
      v21 = *(_QWORD *)(v21 + 40);
      goto LABEL_26;
    }
  }
}

void AccelerationStructureViewerServer::Renderer::~Renderer(AccelerationStructureViewerServer::Renderer *this)
{
  AccelerationStructureViewerServer::Renderer::~Renderer(this);
  operator delete();
}

{
  NSObject *v2;
  void *v3;
  int v4;
  int v5;
  uint64_t i;
  uint64_t j;

  *(_QWORD *)this = off_7271B0;
  v2 = *((id *)this + 2197);
  v3 = (void *)*((_QWORD *)this + 2197);
  *((_QWORD *)this + 2197) = 0;

  v4 = 3;
  do
  {
    dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
    --v4;
  }
  while (v4);
  std::mutex::lock((std::mutex *)((char *)this + 48));
  std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewer::IntersectionFunctionTable>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewer::IntersectionFunctionTable>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewer::IntersectionFunctionTable>>>::destroy(*((_QWORD **)this + 2205));
  *((_QWORD *)this + 2204) = (char *)this + 17640;
  *((_QWORD *)this + 2206) = 0;
  *((_QWORD *)this + 2205) = 0;
  std::__tree<std::__value_type<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::unique_ptr<AccelerationStructureViewerServer::Intersector>>,std::__map_value_compare<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::__value_type<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::unique_ptr<AccelerationStructureViewerServer::Intersector>>,std::less<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>>,true>,std::allocator<std::__value_type<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::unique_ptr<AccelerationStructureViewerServer::Intersector>>>>::destroy(*((_QWORD **)this + 2212));
  *((_QWORD *)this + 2211) = (char *)this + 17696;
  *((_QWORD *)this + 2213) = 0;
  *((_QWORD *)this + 2212) = 0;
  if (*((_QWORD *)this + 2192))
    std::unique_ptr<AccelerationStructureViewerServer::Profiler>::reset[abi:nn180100]((uint64_t *)this + 2192, 0);
  std::mutex::unlock((std::mutex *)((char *)this + 48));
  v5 = 3;
  do
  {
    dispatch_semaphore_signal(v2);
    --v5;
  }
  while (v5);

  std::__tree<std::__value_type<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::unique_ptr<AccelerationStructureViewerServer::Intersector>>,std::__map_value_compare<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::__value_type<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::unique_ptr<AccelerationStructureViewerServer::Intersector>>,std::less<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>>,true>,std::allocator<std::__value_type<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::unique_ptr<AccelerationStructureViewerServer::Intersector>>>>::destroy(*((_QWORD **)this + 2212));
  std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewer::IntersectionFunctionTable>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewer::IntersectionFunctionTable>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewer::IntersectionFunctionTable>>>::destroy(*((_QWORD **)this + 2205));
  for (i = 0; i != -24; i -= 8)

  for (j = 0; j != -24; j -= 8)
  std::unique_ptr<AccelerationStructureViewerServer::Profiler>::reset[abi:nn180100]((uint64_t *)this + 2192, 0);

  std::mutex::~mutex((std::mutex *)((char *)this + 48));
}

void AccelerationStructureViewerServer::Renderer::setResolver(uint64_t a1, uint64_t a2)
{
  std::mutex *v4;

  v4 = (std::mutex *)(a1 + 48);
  std::mutex::lock((std::mutex *)(a1 + 48));
  *(_QWORD *)(a1 + 16840) = a2;
  std::mutex::unlock(v4);
}

void AccelerationStructureViewerServer::Renderer::setTransform(uint64_t a1, float32x4_t *a2)
{
  uint64_t v4;
  std::mutex *v5;
  char *v6;
  float v7;
  float v8;
  float v9;
  float v10;
  BOOL v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  char v19;
  int v20;
  uint64_t v21;
  __int128 v22;
  _OWORD v23[3];
  __int128 v24;
  __int128 v25;
  __int128 v26;

  v4 = a1 + 16832;
  v5 = (std::mutex *)(a1 + 48);
  std::mutex::lock((std::mutex *)(a1 + 48));
  *(_BYTE *)(v4 + 673) = 1;
  v6 = (char *)(a1 + 16848);
  if (memcmp(a2, (const void *)(a1 + 16848), 0x90uLL))
  {
    if (a2->u8[0] != *v6
      || a2->u16[1] != *(unsigned __int16 *)(v4 + 18)
      || ((v7 = a2->f32[1], v8 = *(float *)(v4 + 20), v9 = v8 + -0.001, v10 = v8 + 0.001, v7 >= v9)
        ? (v11 = v7 > v10)
        : (v11 = 1),
          v11
       || a2->i32[2] != *(_DWORD *)(v4 + 24)
       || a2->i32[3] != *(_DWORD *)(v4 + 28)
       || (v12.i64[0] = 0x3400000034000000,
           v12.i64[1] = 0x3400000034000000,
           (vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v12, vabdq_f32(a2[2], *(float32x4_t *)(a1 + 16880))), (int8x16_t)vcgeq_f32(v12, vabdq_f32(a2[1], *(float32x4_t *)(a1 + 16864)))), vandq_s8((int8x16_t)vcgeq_f32(v12, vabdq_f32(a2[3], *(float32x4_t *)(a1 + 16896))), (int8x16_t)vcgeq_f32(v12, vabdq_f32(a2[4], *(float32x4_t *)(a1 + 16912)))))) & 0x80000000) == 0)|| (vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v12, vabdq_f32(a2[6], *(float32x4_t *)(a1 + 16944))), (int8x16_t)vcgeq_f32(v12, vabdq_f32(a2[5], *(float32x4_t *)(a1 + 16928)))), vandq_s8((int8x16_t)vcgeq_f32(v12, vabdq_f32(a2[7], *(float32x4_t *)(a1 + 16960))), (int8x16_t)vcgeq_f32(v12, vabdq_f32(a2[8], *(float32x4_t *)(a1 + 16976)))))) & 0x80000000) == 0))
    {
      *(CFAbsoluteTime *)(a1 + 17512) = CFAbsoluteTimeGetCurrent();
      atomic_store(1u, (unsigned __int8 *)(v4 + 712));
    }
  }
  *(float32x4_t *)v6 = *a2;
  v13 = a2[1];
  v14 = a2[2];
  v15 = a2[4];
  *(float32x4_t *)(a1 + 16896) = a2[3];
  *(float32x4_t *)(a1 + 16912) = v15;
  *(float32x4_t *)(a1 + 16864) = v13;
  *(float32x4_t *)(a1 + 16880) = v14;
  v16 = a2[5];
  v17 = a2[6];
  v18 = a2[8];
  *(float32x4_t *)(a1 + 16960) = a2[7];
  *(float32x4_t *)(a1 + 16976) = v18;
  *(float32x4_t *)(a1 + 16928) = v16;
  *(float32x4_t *)(a1 + 16944) = v17;
  v19 = *v6;
  if (*v6)
  {
    *(_BYTE *)(v4 + 164) = v19;
    v19 = 1;
  }
  *(_BYTE *)v4 = v19;
  v20 = *(unsigned __int8 *)(v4 + 674);
  v21 = *(_QWORD *)(a1 + 16840);
  *(_BYTE *)(v4 + 674) = 0;
  v22 = *(_OWORD *)(a1 + 17472);
  v24 = *(_OWORD *)(a1 + 17456);
  v25 = v22;
  v26 = *(_OWORD *)(a1 + 17488);
  std::mutex::unlock(v5);
  if (v20)
  {
    if (v21)
    {
      v23[1] = v25;
      v23[2] = v26;
      v23[0] = v24;
      (*(void (**)(uint64_t, uint64_t, _OWORD *))(*(_QWORD *)v21 + 24))(v21, a1, v23);
    }
  }
}

void AccelerationStructureViewerServer::Renderer::setIntersectionHints(uint64_t a1, const void *a2)
{
  std::mutex *v4;

  v4 = (std::mutex *)(a1 + 48);
  std::mutex::lock((std::mutex *)(a1 + 48));
  *(_BYTE *)(a1 + 17505) = 1;
  memcpy((void *)(a1 + 17016), a2, 0x1B8uLL);
  std::mutex::unlock(v4);
}

void AccelerationStructureViewerServer::Renderer::setVersion(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  std::mutex *v4;
  uint64_t v5;

  if (a2 >= 0xD)
    v3 = 13;
  else
    v3 = a2;
  v4 = (std::mutex *)(a1 + 48);
  std::mutex::lock((std::mutex *)(a1 + 48));
  *(_QWORD *)(a1 + 112) = v3;
  v5 = *(_QWORD *)(a1 + 16840);
  std::mutex::unlock(v4);
  if (v5)
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 72))(v5, v3);
  NSLog(CFSTR("ASVServer to use version %llu"), v3);
}

BOOL AccelerationStructureViewerServer::Renderer::writeGBVHToFile(AccelerationStructureViewerServer::Renderer *this, NSString *a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v4 = 0;
  return writeAccelerationStructureToGBVH5Path(v2, 0, 0, a2, (uint64_t)&v4);
}

void AccelerationStructureViewerServer::Renderer::requestGBVH(AccelerationStructureViewerServer::Renderer *this, uint64_t a2)
{
  void *v4;
  NSString *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  id v16;
  void *v17;
  id v18;
  id v19;
  id v20;
  _BYTE __dst[464];
  _OWORD v22[9];

  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
  v5 = NSTemporaryDirectory();
  v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  v7 = objc_claimAutoreleasedReturnValue(+[NSUUID UUID](NSUUID, "UUID"));
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v7, "UUIDString"));
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@.mtlas"), v8));
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "stringByAppendingPathComponent:", v9));

  v11 = *((_QWORD *)this + 1);
  std::mutex::lock((std::mutex *)((char *)this + 48));
  memcpy(__dst, (char *)this + 16992, sizeof(__dst));
  v12 = *((_OWORD *)this + 1058);
  v13 = *((_OWORD *)this + 1060);
  v22[6] = *((_OWORD *)this + 1059);
  v22[7] = v13;
  v22[8] = *((_OWORD *)this + 1061);
  v14 = *((_OWORD *)this + 1054);
  v15 = *((_OWORD *)this + 1056);
  v22[2] = *((_OWORD *)this + 1055);
  v22[3] = v15;
  v22[4] = *((_OWORD *)this + 1057);
  v22[5] = v12;
  v22[0] = *((_OWORD *)this + 1053);
  v22[1] = v14;
  std::mutex::unlock((std::mutex *)((char *)this + 48));
  v20 = 0;
  LOBYTE(v7) = writeAccelerationStructureToGBVH5Path(v11, (char *)v22, (uint64_t)__dst, v10, (uint64_t)&v20);
  v16 = v20;
  if ((v7 & 1) != 0)
  {
    v19 = v16;
    v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithContentsOfFile:options:error:](NSData, "dataWithContentsOfFile:options:error:", v10, 2, &v19));
    v18 = v19;

    (*(void (**)(_QWORD, uint64_t, void *, id))(**((_QWORD **)this + 2105) + 32))(*((_QWORD *)this + 2105), a2, v17, v18);
    objc_msgSend(v4, "removeItemAtPath:error:", v10, 0);

    v16 = v18;
  }
  else
  {
    objc_msgSend(v4, "removeItemAtPath:error:", v10, 0);
    (*(void (**)(_QWORD, uint64_t, _QWORD, id))(**((_QWORD **)this + 2105) + 32))(*((_QWORD *)this + 2105), a2, 0, v16);
  }

}

void AccelerationStructureViewerServer::Renderer::capture(AccelerationStructureViewerServer::Renderer *this, uint64_t a2)
{
  unsigned int v2;

  v2 = a2;
  NSLog(CFSTR("Requesting capture of %d samples"), a2);
  std::mutex::lock((std::mutex *)((char *)this + 48));
  *((_QWORD *)this + 2214) = v2;
  std::mutex::unlock((std::mutex *)((char *)this + 48));
}

void AccelerationStructureViewerServer::Renderer::acknowledge(AccelerationStructureViewerServer::Renderer *this, unint64_t a2, char a3)
{
  std::mutex *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  double Current;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;

  v6 = (std::mutex *)((char *)this + 48);
  std::mutex::lock((std::mutex *)((char *)this + 48));
  v7 = (char *)this + 376;
  v8 = a2 & 0x1F;
  v9 = *((unsigned __int16 *)this + v8 + 188);
  if (v9 > 0x3FF)
  {
    if ((a3 & 1) != 0)
      goto LABEL_14;
    Current = CFAbsoluteTimeGetCurrent();
  }
  else
  {
    v10 = (char *)this + 8 * v9;
    *((_QWORD *)v10 + 1079) = 0;
    *(_WORD *)&v7[2 * v8] = 1024;
    if ((a3 & 1) != 0)
      goto LABEL_14;
    Current = CFAbsoluteTimeGetCurrent();
    *((double *)v10 + 55) = Current;
  }
  v12 = atomic_load((unint64_t *)this + 4);
  if (v12 < a2)
  {
    v13 = 0;
    do
    {
      v14 = ((_BYTE)v12 + (_BYTE)v13) & 0x1F;
      v15 = *(unsigned __int16 *)&v7[2 * v14];
      if (v15 <= 0x3FF)
      {
        *((_QWORD *)this + v15 + 1079) = 0;
        *(_WORD *)&v7[2 * v14] = 1024;
      }
      if (~v12 + a2 == v13)
        break;
    }
    while (v13++ < 0x1F);
    *((double *)this + 2103) = (Current - *((double *)this + v8 + 15)) * 0.5;
    atomic_store(a2, (unint64_t *)this + 4);
  }
LABEL_14:
  std::mutex::unlock(v6);
}

BOOL AccelerationStructureViewerServer::Renderer::requestSample(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  unsigned int v6;
  double Current;
  __int32 v8;
  unsigned int v9;
  __int128 v10;
  char v11;
  char v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned __int32 v17;
  uint64_t v18;
  void *v19;
  float32x2_t *v20;
  int32x2_t v21;
  float32x2_t *v22;
  float32x2_t v23;
  double v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  double v29;
  int v30;
  char v31;
  unsigned int v32;
  uint64_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  unint64_t v39;
  unint64_t v40;
  _BOOL8 v41;
  uint64_t v42;
  unsigned __int8 *v43;
  int32x2_t v44;
  uint64x2_t v45;
  _DWORD *v50;
  _QWORD *v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  _QWORD *v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unsigned __int8 v60;
  int v61;
  int v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unsigned int v67;
  uint64_t Intersector;
  int v69;
  uint64_t v70;
  id v71;
  uint64_t v72;
  char v73;
  char v74;
  unint64_t *v75;
  unint64_t v76;
  void *v77;
  id v78;
  void *v79;
  uint64_t v80;
  id v81;
  void *v82;
  void *v84;
  uint64_t v85;
  id v86;
  void *v87;
  id v88;
  id v89;
  id v90;
  void *v91;
  id v92;
  void *v93;
  void *v94;
  void *v95;
  unsigned int v96;
  id v97;
  id v98;
  _QWORD *v99;
  void *v100;
  void *v101;
  void *v102;
  void *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  int v114;
  id v115;
  void *v116;
  id v117;
  void *v118;
  id v119;
  id v120;
  id *v121;
  id v122;
  _QWORD *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  void *v127;
  unsigned int v128;
  char v129;
  int v130;
  uint64_t v131;
  int v132;
  uint64_t v133;
  int v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  char v139;
  char v140;
  unint64_t v141;
  unsigned int v142;
  unsigned int v143;
  __int128 v144;
  __int128 v145;
  float32x4_t v146;
  float32x4_t v147;
  simd_float4 v148;
  simd_float4 v149;
  simd_float4 v150;
  simd_float4 v151;
  void *v152;
  uint32x2_t v153;
  int v154;
  void *v155;
  int64x2_t v156;
  uint64_t v157;
  _QWORD v158[3];
  double __dst[1024];
  _QWORD v160[1024];
  uint64_t v161;
  id *v162;
  uint64_t v163;
  uint64_t (*v164)(uint64_t, uint64_t);
  void (*v165)(uint64_t);
  id v166;
  _OWORD v167[4];
  id v168[82];
  id v169[82];
  id v170[82];
  id v171[82];
  _QWORD v172[4];
  _QWORD v173[82];
  id v174;
  id v175;
  id v176;
  uint64_t *v177;
  uint64_t v178;
  _DWORD *v179;
  double v180;
  char v181;
  _QWORD v182[82];
  id v183[82];
  id v184[82];
  _BYTE v185[432];
  char v186;
  char v187;
  __int16 v188;
  __int32 v189;
  uint32x2_t v190;
  simd_float4 v191;
  simd_float4 v192;
  simd_float4 v193;
  simd_float4 v194;
  __int128 v195;
  __int128 v196;
  float32x4_t v197;
  float32x4_t v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  id v202;
  _BYTE v203[410];
  _BYTE v204[19];
  simd_float4x4 v205;
  simd_float4x4 v206;
  simd_float4x4 v207;

  v3 = a2;
  v4 = objc_autoreleasePoolPush();
  v161 = 0;
  v162 = (id *)&v161;
  v163 = 0x3032000000;
  v164 = __Block_byref_object_copy__8522;
  v165 = __Block_byref_object_dispose__8523;
  v166 = 0;
  std::mutex::lock((std::mutex *)(a1 + 48));
  if (*(_QWORD *)(a1 + 17712)
    || *(_QWORD *)(a1 + 17752)
    && (!*(_QWORD *)(a1 + 16840)
     || (v39 = atomic_load((unint64_t *)(a1 + 40)),
         v40 = atomic_load((unint64_t *)(a1 + 32)),
         v39 < v40 + 32)))
  {
    v5 = 120;
    while (*(double *)(a1 + v5) >= *(double *)(a1 + 17512))
    {
      v5 += 8;
      if (v5 == 376)
      {
        atomic_store(0, (unsigned __int8 *)(a1 + 17544));
        break;
      }
    }
    if (*(_BYTE *)(a1 + 16996) && *(_QWORD *)(a1 + 16840))
    {
      v152 = v4;
      objc_storeStrong(v162 + 5, *(id *)(a1 + 17576));
      std::mutex::unlock((std::mutex *)(a1 + 48));
      v6 = AccelerationStructureViewerServer::Renderer::reserveUniformBufferIndex(a1, v162[5]);
      Current = CFAbsoluteTimeGetCurrent();
      std::mutex::lock((std::mutex *)(a1 + 48));
      v141 = *(_QWORD *)(a1 + 112);
      v131 = *(_QWORD *)(a1 + 16840);
      v130 = *(unsigned __int8 *)(a1 + 17504);
      v129 = *(_BYTE *)(a1 + 16849);
      v8 = *(_DWORD *)(a1 + 16852);
      v153 = *(uint32x2_t *)(a1 + 16856);
      v150 = *(simd_float4 *)(a1 + 16880);
      v151 = *(simd_float4 *)(a1 + 16864);
      v148 = *(simd_float4 *)(a1 + 16912);
      v149 = *(simd_float4 *)(a1 + 16896);
      v144 = *(_OWORD *)(a1 + 16944);
      v145 = *(_OWORD *)(a1 + 16928);
      v146 = *(float32x4_t *)(a1 + 16976);
      v147 = *(float32x4_t *)(a1 + 16960);
      v134 = *(_DWORD *)(a1 + 16992);
      v9 = *(unsigned __int8 *)(a1 + 16996);
      v10 = *(_OWORD *)(a1 + 16997);
      *(_DWORD *)&v204[15] = *(_DWORD *)(a1 + 17012);
      *(_OWORD *)v204 = v10;
      v137 = *(unsigned int *)(a1 + 17016);
      v135 = *(unsigned int *)(a1 + 17020);
      v11 = *(_BYTE *)(a1 + 17024);
      v133 = *(_QWORD *)(a1 + 17025);
      v12 = *(_BYTE *)(a1 + 17033);
      v139 = *(_BYTE *)(a1 + 17034);
      v140 = *(_BYTE *)(a1 + 17035);
      v132 = *(_DWORD *)(a1 + 17036);
      v13 = *(_DWORD *)(a1 + 17040);
      v142 = *(unsigned __int8 *)(a1 + 17045);
      v143 = *(unsigned __int8 *)(a1 + 17044);
      memcpy(v203, (const void *)(a1 + 17046), sizeof(v203));
      memcpy(v160, (const void *)(a1 + 8632), sizeof(v160));
      memcpy(__dst, (const void *)(a1 + 440), sizeof(__dst));
      std::mutex::unlock((std::mutex *)(a1 + 48));
      v14 = v6;
      v15 = v9 - 1;
      v16 = v9 - 1 + v153.i32[0];
      if (v16 < v9
        || (v17 = v15 + v153.i32[1], v15 + v153.i32[1] < v9)
        || (v18 = a1 + 8 * v14, (v19 = *(void **)(v18 + 17584)) == 0))
      {
        AccelerationStructureViewerServer::Renderer::releaseUniformBufferIndex(a1, v14, v162[5]);
        v41 = 0;
LABEL_95:
        v4 = v152;
        goto LABEL_96;
      }
      v128 = v14;
      v127 = v3;
      v20 = (float32x2_t *)objc_msgSend(objc_retainAutorelease(v19), "contents");
      if (!v20)
        goto LABEL_93;
      v22 = v20;
      v123 = (_QWORD *)(v18 + 17584);
      v20[1].i32[0] = v8;
      *(float *)v21.i32 = (float)v9;
      v23 = (float32x2_t)vdup_lane_s32(v21, 0);
      v20[2] = vdiv_f32(v23, vcvt_f32_u32(v153));
      ++v20->i32[0];
      v24 = CFAbsoluteTimeGetCurrent();
      v25 = v9 * v9;
      v26 = v22->i32[0] % (v9 * v9);
      if (v9)
      {
        v27 = 0;
        if (v25 <= 1)
          v28 = 1;
        else
          v28 = v25;
        v29 = 1.79769313e308;
        do
        {
          if (v24 - *(double *)&v160[v27] > 1.0 && __dst[v27] < v29)
          {
            v29 = __dst[v27];
            LOWORD(v26) = v27;
          }
          ++v27;
        }
        while (v28 != v27);
      }
      v125 = v16 / v9;
      v30 = (unsigned __int16)v26;
      v124 = v17 / v9;
      v31 = v11;
      do
      {
        if (v24 - *(double *)&v160[(unsigned __int16)v26] >= 1.0)
          break;
        v26 = (unsigned __int16)(v26 + 1) % v25;
      }
      while (v26 != v30);
      v32 = (unsigned __int16)v26;
      v22->i32[1] = (unsigned __int16)v26;
      *(_OWORD *)v22[8].f32 = v145;
      *(_OWORD *)v22[10].f32 = v144;
      v205.columns[3] = v148;
      *(float32x4_t *)v22[12].f32 = v147;
      *(float32x4_t *)v22[14].f32 = v146;
      v205.columns[1] = v150;
      v205.columns[0] = v151;
      v205.columns[2] = v149;
      v206 = __invert_f4(v205);
      v33 = 0;
      *(simd_float4x4 *)v22[24].f32 = v206;
      v34 = *(float32x4_t *)v22[8].f32;
      v35 = *(float32x4_t *)v22[10].f32;
      v36 = *(float32x4_t *)v22[12].f32;
      v37 = *(float32x4_t *)v22[14].f32;
      v167[0] = v151;
      v167[1] = v150;
      v167[2] = v149;
      v167[3] = v148;
      do
      {
        *(float32x4_t *)&v185[v33 * 16] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v34, COERCE_FLOAT(v167[v33])), v35, *(float32x2_t *)&v167[v33], 1), v36, (float32x4_t)v167[v33], 2), v37, (float32x4_t)v167[v33], 3);
        ++v33;
      }
      while (v33 != 4);
      v207 = *(simd_float4x4 *)v185;
      *(_OWORD *)v22[16].f32 = *(_OWORD *)v185;
      *(simd_float4 *)v22[18].f32 = v207.columns[1];
      *(simd_float4 *)v22[20].f32 = v207.columns[2];
      *(simd_float4 *)v22[22].f32 = v207.columns[3];
      *(simd_float4x4 *)v22[32].f32 = __invert_f4(v207);
      v38 = vdivq_f32(v146, v147);
      v22[3].i32[0] = v38.i32[2];
      v22[3].f32[1] = vmuls_lane_f32(v147.f32[2], v38, 2) / (float)(v147.f32[2] + 1.0);
      if ((int)v9 <= 7)
      {
        if (v9 == 2)
        {
          v42 = (unsigned __int16)v26;
          v43 = (unsigned __int8 *)&ASVDither2x2;
        }
        else
        {
          if (v9 != 4)
            goto LABEL_44;
          v42 = (unsigned __int16)v26;
          v43 = (unsigned __int8 *)&ASVDither4x4;
        }
      }
      else if (v9 == 8)
      {
        v42 = (unsigned __int16)v26;
        v43 = (unsigned __int8 *)&ASVDither8x8;
      }
      else
      {
        if (v9 != 16)
        {
          if (v9 == 32)
            v32 = ASVDither32x32[(unsigned __int16)v26];
LABEL_44:
          v44.i32[0] = v32 % v9;
          v44.i32[1] = v32 / v9;
          v22[4] = v23;
          v22[5] = vcvt_f32_s32(v44);
          v45.i64[0] = v153.u32[0];
          v45.i64[1] = v153.u32[1];
          __asm { FMOV            V1.2D, #1.0 }
          v22[6] = vcvt_f32_f64(vdivq_f64(_Q1, vcvtq_f64_u64(v45)));
          v126 = a1 + 8 * v128;
          v50 = objc_msgSend(objc_retainAutorelease(*(id *)(v126 + 17608)), "contents");
          *v50 = v134;
          *((_BYTE *)v50 + 4) = v9;
          *(_OWORD *)((char *)v50 + 5) = *(_OWORD *)v204;
          v50[5] = *(_DWORD *)&v204[15];
          v50[6] = v137;
          v50[7] = v135;
          *((_BYTE *)v50 + 32) = v11;
          *(_QWORD *)((char *)v50 + 33) = v133;
          *((_BYTE *)v50 + 41) = v12;
          *((_BYTE *)v50 + 42) = v139;
          *((_BYTE *)v50 + 43) = v140;
          v50[11] = v132;
          v50[12] = v13;
          *((_BYTE *)v50 + 52) = v143;
          *((_BYTE *)v50 + 53) = v142;
          memcpy((char *)v50 + 54, v203, 0x19AuLL);
          v51 = *(_QWORD **)(a1 + 17640);
          if (!v51)
            goto LABEL_57;
          v52 = v137 | (v135 << 32);
          v53 = a1 + 17640;
          do
          {
            v54 = v51[4];
            _CF = v54 >= v52;
            if (v54 >= v52)
              v56 = v51;
            else
              v56 = v51 + 1;
            if (_CF)
              v53 = (uint64_t)v51;
            v51 = (_QWORD *)*v56;
          }
          while (*v56);
          if (v53 == a1 + 17640)
          {
LABEL_57:
            v59 = 0;
          }
          else
          {
            v57 = *(_QWORD *)(v53 + 32);
            v58 = v53 + 40;
            if (v52 >= v57)
              v59 = v58;
            else
              v59 = 0;
          }
          v60 = (v141 < 3) | v12;
          v61 = v31 & 1;
          if (*(_QWORD *)(a1 + 17536))
          {
            if ((((v141 < 3) | v12) & (v61 == 0)) == 0)
            {
              Intersector = AccelerationStructureViewerServer::Renderer::getIntersector(a1, 2, v59);
              v66 = 0;
              if ((v141 < 3) | v12 & 1 && v61)
              {
                v69 = v61;
                v70 = Intersector;
                v66 = AccelerationStructureViewerServer::Renderer::getIntersector(a1, 3, a1 + 17656);
                Intersector = v70;
                v61 = v69;
                v60 = (v141 < 3) | v12;
                v67 = v128;
                if (!v66)
                  goto LABEL_77;
                goto LABEL_71;
              }
              goto LABEL_70;
            }
            v62 = 3;
          }
          else
          {
            if ((v60 & (v61 != 0)) == 1)
            {
              v63 = v61;
              v64 = AccelerationStructureViewerServer::Renderer::getIntersector(a1, 2, v59);
              v65 = AccelerationStructureViewerServer::Renderer::getIntersector(a1, 5, a1 + 17656);
              if (!v65)
              {
LABEL_93:
                v71 = v162[5];
                v72 = a1;
                v67 = v128;
                goto LABEL_94;
              }
              v66 = v65;
              v67 = v128;
              Intersector = v64;
              v61 = v63;
              v60 = (v141 < 3) | v12;
              goto LABEL_71;
            }
            v62 = 5;
          }
          Intersector = AccelerationStructureViewerServer::Renderer::getIntersector(a1, v62, v59);
          v66 = 0;
LABEL_70:
          v67 = v128;
LABEL_71:
          if (Intersector)
          {
            if (*(_QWORD *)(Intersector + 32))
            {
              v3 = v127;
              v4 = v152;
              if (v131 && !v130)
              {
                (*(void (**)(void))(*(_QWORD *)v131 + 80))();
                std::mutex::lock((std::mutex *)(a1 + 48));
                *(_BYTE *)(a1 + 17504) = 1;
                std::mutex::unlock((std::mutex *)(a1 + 48));
                v67 = v128;
              }
              AccelerationStructureViewerServer::Renderer::releaseUniformBufferIndex(a1, v67, v162[5]);
              goto LABEL_35;
            }
            v136 = v66;
            v138 = Intersector;
            if (v130 && v131)
            {
              (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v131 + 88))(v131, a1);
              std::mutex::lock((std::mutex *)(a1 + 48));
              *(_BYTE *)(a1 + 17504) = 0;
              std::mutex::unlock((std::mutex *)(a1 + 48));
              goto LABEL_82;
            }
            if (*(_QWORD *)(Intersector + 8))
            {
LABEL_82:
              v185[0] = 0;
              v199 = 0u;
              v200 = 0u;
              v201 = 0u;
              v202 = 0;
              v73 = v143;
              if (v143 <= 1)
                v73 = 1;
              v185[16] = v73;
              v74 = v142;
              if (v142 <= 1)
                v74 = 1;
              v185[17] = v74;
              memcpy(&v185[24], &v203[2], 0x198uLL);
              *(_DWORD *)&v185[4] = v13;
              v185[1] = v61;
              v75 = (unint64_t *)(a1 + 40);
              do
                v76 = __ldaxr(v75);
              while (__stlxr(v76 + 1, v75));
              *(_QWORD *)&v185[8] = v76;
              v186 = v9;
              v187 = v129;
              v188 = v26;
              v189 = v8;
              v190 = v153;
              v191 = v151;
              v192 = v150;
              v193 = v149;
              v194 = v148;
              v195 = v145;
              v196 = v144;
              v197 = v147;
              v198 = v146;
              v77 = (void *)objc_claimAutoreleasedReturnValue(+[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:width:height:mipmapped:](MTLTextureDescriptor, "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", 70, v125, v124, 0));
              objc_msgSend(v77, "setPixelFormat:", 55);
              objc_msgSend(v77, "setStorageMode:", 2);
              objc_msgSend(v77, "setUsage:", 3);
              v78 = objc_msgSend(*(id *)(a1 + 24), "newTextureWithDescriptor:", v77);
              v79 = (void *)*((_QWORD *)&v199 + 1);
              *((_QWORD *)&v199 + 1) = v78;

              objc_msgSend(*((id *)&v199 + 1), "setLabel:", CFSTR("ASVBVH-PreviousDepth"));
              if ((v60 & 1) != 0)
              {
                if ((v140 & 1) != 0)
                  v80 = 113;
                else
                  v80 = 123;
                objc_msgSend(v77, "setPixelFormat:", v80);
                objc_msgSend(v77, "setUsage:", 3);
                objc_msgSend(v77, "setStorageMode:", 2);
                v81 = objc_msgSend(*(id *)(a1 + 24), "newTextureWithDescriptor:", v77);
                v82 = (void *)v200;
                *(_QWORD *)&v200 = v81;

                objc_msgSend((id)v200, "setLabel:", CFSTR("ASVBVH-Traversals"));
              }
              else
              {
                v84 = (void *)v200;
                *(_QWORD *)&v200 = 0;

              }
              v3 = v127;
              if (v141 < 0xB)
              {
                objc_msgSend(v77, "setPixelFormat:", 123);
                objc_msgSend(v77, "setStorageMode:", 2);
                objc_msgSend(v77, "setUsage:", 3);
                v90 = objc_msgSend(*(id *)(a1 + 24), "newTextureWithDescriptor:", v77);
                v91 = (void *)*((_QWORD *)&v200 + 1);
                *((_QWORD *)&v200 + 1) = v90;

                objc_msgSend(*((id *)&v200 + 1), "setLabel:", CFSTR("ASVBVH-Hit"));
                if (v141 >= 3 && (v139 & 1) != 0)
                {
                  objc_msgSend(v77, "setPixelFormat:", 123);
                  objc_msgSend(v77, "setStorageMode:", 2);
                  objc_msgSend(v77, "setUsage:", 3);
                  v92 = objc_msgSend(*(id *)(a1 + 24), "newTextureWithDescriptor:", v77);
                  v93 = (void *)v201;
                  *(_QWORD *)&v201 = v92;

                  objc_msgSend((id)v201, "setLabel:", CFSTR("ASVBVH-Data"));
                }
                else
                {
                  v94 = (void *)v201;
                  *(_QWORD *)&v201 = 0;

                }
              }
              else
              {
                if (v185[16] != 1)
                {
                  if ((v140 & 1) != 0)
                    v85 = 125;
                  else
                    v85 = 90;
                  objc_msgSend(v77, "setPixelFormat:", v85);
                  objc_msgSend(v77, "setStorageMode:", 2);
                  objc_msgSend(v77, "setUsage:", 3);
                  v86 = objc_msgSend(*(id *)(a1 + 24), "newTextureWithDescriptor:", v77);
                  v87 = (void *)*((_QWORD *)&v201 + 1);
                  *((_QWORD *)&v201 + 1) = v86;

                  objc_msgSend(*((id *)&v201 + 1), "setLabel:", CFSTR("ASVBVH-Material"));
                }
                if (v185[17] != 1)
                {
                  objc_msgSend(v77, "setPixelFormat:", 13);
                  objc_msgSend(v77, "setStorageMode:", 2);
                  objc_msgSend(v77, "setUsage:", 3);
                  v88 = objc_msgSend(*(id *)(a1 + 24), "newTextureWithDescriptor:", v77);
                  v89 = v202;
                  v202 = v88;

                  objc_msgSend(v202, "setLabel:", CFSTR("ASVBVH-SelectionMask"));
                }
              }
              std::mutex::lock((std::mutex *)(a1 + 48));
              *(_WORD *)(a1 + 2 * (v185[8] & 0x1F) + 376) = v26;
              *(CFAbsoluteTime *)(a1 + 8632 + 8 * (unsigned __int16)v26) = CFAbsoluteTimeGetCurrent();
              std::mutex::unlock((std::mutex *)(a1 + 48));
              if ((*(_DWORD *)v138 - 2) >= 4)
              {
                if (*(_DWORD *)v138 >= 2u)
                {
                  v41 = 0;
                  v4 = v152;
LABEL_158:

                  AccelerationStructureViewer::Sample::~Sample((id *)v185);
                  goto LABEL_96;
                }
                v99 = *(_QWORD **)(a1 + 8);
                v100 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v127, "commandBufferWithDescriptor:", *(_QWORD *)(a1 + 17552)));
                objc_msgSend(v100, "setLabel:", CFSTR("ASVS Generic Intersector"));
                v155 = v100;
                v101 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v100, "computeCommandEncoder"));
                v102 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v138 + 8), "label"));
                v103 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("ASV BVH HeatMap '%@'"), v102));
                objc_msgSend(v101, "setLabel:", v103);

                objc_msgSend(v101, "setComputePipelineState:", *(_QWORD *)(v138 + 8));
                objc_msgSend(v101, "setTexture:atIndex:", *((_QWORD *)&v199 + 1), 1);
                objc_msgSend(v101, "setTexture:atIndex:", (_QWORD)v200, 2);
                objc_msgSend(v101, "setTexture:atIndex:", *((_QWORD *)&v200 + 1), 3);
                objc_msgSend(v101, "setTexture:atIndex:", (_QWORD)v201, 4);
                objc_msgSend(v101, "setTexture:atIndex:", *((_QWORD *)&v201 + 1), 5);
                objc_msgSend(v101, "setTexture:atIndex:", v202, 6);
                objc_msgSend(v101, "setBuffer:offset:atIndex:", *v123, 0, 0);
                objc_msgSend(v101, "setBuffer:offset:atIndex:", *(_QWORD *)(v126 + 17608), 0, 1);
                v104 = *(_QWORD *)(a1 + 17736);
                if (v104)
                  objc_msgSend(v101, "setAccelerationStructure:atBufferIndex:", v104, 3);
                v105 = *(_QWORD *)(v138 + 16);
                if (v105)
                {
                  objc_msgSend(v101, "setVisibleFunctionTable:atBufferIndex:", v105, 4);
                  (*(void (**)(_QWORD *, void *))(*v99 + 104))(v99, v101);
                }
                objc_msgSend(v101, "setBuffer:offset:atIndex:", *(_QWORD *)(a1 + 17752), 0, 5);
                v106 = v99[23];
                if (v99[24] != v106)
                {
                  v107 = 0;
                  v108 = 0;
                  do
                  {
                    objc_msgSend(v101, "useResource:usage:", *(_QWORD *)(v106 + v107 + 24), 1);
                    objc_msgSend(v101, "useResource:usage:", *(_QWORD *)(v106 + v107 + 40), 1);
                    objc_msgSend(v101, "useResource:usage:", *(_QWORD *)(v106 + v107 + 56), 1);
                    v109 = *(_QWORD *)(v106 + v107 + 72);
                    if (v109)
                      objc_msgSend(v101, "useResource:usage:", v109, 1);
                    v110 = *(_QWORD *)(v106 + v107 + 88);
                    if (v110)
                      objc_msgSend(v101, "useResource:usage:", v110, 1);
                    v111 = *(_QWORD *)(v106 + v107 + 104);
                    if (v111)
                      objc_msgSend(v101, "useResource:usage:", v111, 1);
                    v112 = *(_QWORD *)(v106 + v107 + 152);
                    if (v112)
                      objc_msgSend(v101, "useResource:usage:", v112, 1);
                    v113 = *(_QWORD *)(v106 + v107 + 168);
                    if (v113)
                      objc_msgSend(v101, "useResource:usage:", v113, 1);
                    ++v108;
                    v106 = v99[23];
                    v107 += 184;
                  }
                  while (v108 < 0xD37A6F4DE9BD37A7 * ((v99[24] - v106) >> 3));
                }
                v158[0] = v125;
                v158[1] = v124;
                v41 = 1;
                v158[2] = 1;
                v156 = vdupq_n_s64(8uLL);
                v157 = 1;
                objc_msgSend(v101, "dispatchThreads:threadsPerThreadgroup:", v158, &v156);
                objc_msgSend(v101, "endEncoding");

                AccelerationStructureViewer::Sample::Sample(v168, (uint64_t)v185);
                v95 = v155;
                AccelerationStructureViewerServer::Renderer::commitSample(a1, v128, (uint64_t)v168, v155, v162[5], Current);
                AccelerationStructureViewer::Sample::~Sample(v168);
                v3 = v127;
                goto LABEL_156;
              }
              v95 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v127, "commandBufferWithDescriptor:", *(_QWORD *)(a1 + 17552)));
              objc_msgSend(v95, "setLabel:", CFSTR("ASVS Metal Intersector"));
              if (*(_QWORD *)(a1 + 17536))
              {
                v154 = v61;
                if (v61)
                {
                  AccelerationStructureViewer::Sample::Sample(v184, (uint64_t)v185);
                  v96 = v128;
                  v97 = AccelerationStructureViewerServer::Renderer::metalIntersectorPass(a1, v128, (uint64_t)v184, v95, v136, v50, 0, 0);
                  v98 = (id)objc_claimAutoreleasedReturnValue(v97);
                  AccelerationStructureViewer::Sample::~Sample(v184);
                  if (!v98)
                  {
                    AccelerationStructureViewerServer::Renderer::releaseUniformBufferIndex(a1, v128, v162[5]);
                    v41 = 0;
LABEL_156:
                    v4 = v152;
LABEL_157:

                    goto LABEL_158;
                  }
                }
                else
                {
                  v98 = 0;
                  v96 = v128;
                }
                AccelerationStructureViewer::Sample::Sample(v183, (uint64_t)v185);
                v119 = AccelerationStructureViewerServer::Renderer::metalIntersectorPass(a1, v96, (uint64_t)v183, v95, v138, v50, 1, 1);
                v120 = (id)objc_claimAutoreleasedReturnValue(v119);
                AccelerationStructureViewer::Sample::~Sample(v183);
                v41 = v120 != 0;
                if (v120)
                {
                  if (*(_DWORD *)v138 == 3 || v154)
                  {
                    v4 = v152;
                    if (!v154)
                    {
                      v122 = v120;

                      v98 = v122;
                      v3 = v127;
                    }
                    v172[0] = _NSConcreteStackBlock;
                    v172[1] = 3321888768;
                    v172[2] = ___ZN33AccelerationStructureViewerServer8Renderer13requestSampleEPU26objcproto15MTLCommandQueue11objc_object_block_invoke;
                    v172[3] = &unk_7272D8;
                    v178 = a1;
                    AccelerationStructureViewer::Sample::Sample(v173, (uint64_t)v185);
                    v174 = v3;
                    v98 = v98;
                    v175 = v98;
                    v181 = v128;
                    v179 = v50;
                    v176 = v120;
                    v180 = Current;
                    v177 = &v161;
                    objc_msgSend(v95, "addCompletedHandler:", v172);
                    objc_msgSend(v95, "commit");

                    v121 = (id *)v173;
                  }
                  else
                  {
                    v4 = v152;
                    if (v98 != v120)
                      AccelerationStructureViewerServer::Profiler::finishSkipFrame(*(_QWORD *)(a1 + 17536), v120);
                    AccelerationStructureViewer::Sample::Sample(v182, (uint64_t)v185);
                    AccelerationStructureViewerServer::Renderer::commitSample(a1, v128, (uint64_t)v182, v95, v162[5], Current);
                    v121 = (id *)v182;
                  }
                  AccelerationStructureViewer::Sample::~Sample(v121);
                }
                else
                {
                  AccelerationStructureViewerServer::Renderer::releaseUniformBufferIndex(a1, v96, v162[5]);
                  v4 = v152;
                }

                goto LABEL_157;
              }
              v114 = v60 & (v61 != 0);
              AccelerationStructureViewer::Sample::Sample(v171, (uint64_t)v185);
              v115 = AccelerationStructureViewerServer::Renderer::metalIntersectorPass(a1, v128, (uint64_t)v171, v95, v138, v50, 1, v114 ^ 1u);
              v116 = (void *)objc_claimAutoreleasedReturnValue(v115);
              AccelerationStructureViewer::Sample::~Sample(v171);
              if (v116)
              {
                if (v114)
                {
                  AccelerationStructureViewer::Sample::Sample(v170, (uint64_t)v185);
                  v117 = AccelerationStructureViewerServer::Renderer::metalIntersectorPass(a1, v128, (uint64_t)v170, v95, v136, v50, 0, 1);
                  v118 = (void *)objc_claimAutoreleasedReturnValue(v117);
                  AccelerationStructureViewer::Sample::~Sample(v170);
                  if (!v118)
                  {
                    AccelerationStructureViewerServer::Renderer::releaseUniformBufferIndex(a1, v128, v162[5]);
                    v41 = 0;
                    v3 = v127;
                    goto LABEL_155;
                  }

                  v3 = v127;
                }
                AccelerationStructureViewer::Sample::Sample(v169, (uint64_t)v185);
                AccelerationStructureViewerServer::Renderer::commitSample(a1, v128, (uint64_t)v169, v95, v162[5], Current);
                AccelerationStructureViewer::Sample::~Sample(v169);
                v41 = 1;
              }
              else
              {
                AccelerationStructureViewerServer::Renderer::releaseUniformBufferIndex(a1, v128, v162[5]);
                v41 = 0;
              }
LABEL_155:

              goto LABEL_156;
            }
            goto LABEL_93;
          }
LABEL_77:
          v71 = v162[5];
          v72 = a1;
LABEL_94:
          AccelerationStructureViewerServer::Renderer::releaseUniformBufferIndex(v72, v67, v71);
          v41 = 0;
          v3 = v127;
          goto LABEL_95;
        }
        v42 = (unsigned __int16)v26;
        v43 = (unsigned __int8 *)&ASVDither16x16;
      }
      v32 = v43[v42];
      goto LABEL_44;
    }
  }
  std::mutex::unlock((std::mutex *)(a1 + 48));
LABEL_35:
  v41 = 0;
LABEL_96:
  _Block_object_dispose(&v161, 8);

  objc_autoreleasePoolPop(v4);
  return v41;
}

void AccelerationStructureViewerServer::Renderer::requestQueryRays(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  BOOL v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  uint64_t Intersector;
  uint64_t v26;
  void *v27;
  void *v28;
  uint64_t v29;
  _QWORD *v30;
  void *v31;
  void *v32;
  uint64_t v33;
  id v34;
  id v35;
  id v36;
  uint64_t v37;
  void *i;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  void *v53;
  _QWORD v54[8];
  int v55;
  unsigned int v56;
  id v57;
  int64x2_t v58;
  uint64_t v59;
  int64x2_t v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  _BYTE __dst[432];
  __int128 v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t (*v71)(uint64_t, uint64_t);
  void (*v72)(uint64_t);
  id v73;
  uint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  uint64_t (*v77)(uint64_t, uint64_t);
  void (*v78)(uint64_t);
  id v79;
  _BYTE v80[128];

  v9 = (unsigned int *)(a1 + 17016);
  v74 = 0;
  v75 = &v74;
  v76 = 0x3032000000;
  v77 = __Block_byref_object_copy__8522;
  v78 = __Block_byref_object_dispose__8523;
  v79 = objc_msgSend(*(id *)(a1 + 24), "newBufferWithBytes:length:options:", a4, 48 * a5, 0);
  v68 = 0;
  v69 = &v68;
  v70 = 0x3032000000;
  v71 = __Block_byref_object_copy__8522;
  v72 = __Block_byref_object_dispose__8523;
  v51 = a5;
  v73 = objc_msgSend(*(id *)(a1 + 24), "newBufferWithLength:options:", 416 * a5, 0);
  std::mutex::lock((std::mutex *)(a1 + 48));
  v66 = *(_OWORD *)(a1 + 16992);
  v67 = *(_QWORD *)(a1 + 17008);
  v10 = *v9;
  v11 = v9[1];
  memcpy(__dst, (const void *)(a1 + 17024), sizeof(__dst));
  v12 = *(id *)(a1 + 17576);
  std::mutex::unlock((std::mutex *)(a1 + 48));
  v53 = v12;
  v52 = AccelerationStructureViewerServer::Renderer::reserveUniformBufferIndex(a1, v12);
  v13 = a1 + 8 * v52;
  v14 = objc_msgSend(objc_retainAutorelease(*(id *)(v13 + 17608)), "contents");
  *(_OWORD *)v14 = v66;
  v14[2] = v67;
  *((_DWORD *)v14 + 6) = v10;
  *((_DWORD *)v14 + 7) = v11;
  memcpy(v14 + 4, __dst, 0x1B0uLL);
  v15 = *(_QWORD **)(a1 + 17640);
  if (!v15)
    goto LABEL_14;
  v16 = v10 | (v11 << 32);
  v17 = a1 + 17640;
  do
  {
    v18 = v15[4];
    v19 = v18 >= v16;
    if (v18 >= v16)
      v20 = v15;
    else
      v20 = v15 + 1;
    if (v19)
      v17 = (uint64_t)v15;
    v15 = (_QWORD *)*v20;
  }
  while (*v20);
  if (v17 == a1 + 17640)
  {
LABEL_14:
    v23 = 0;
  }
  else
  {
    v21 = *(_QWORD *)(v17 + 32);
    v22 = v17 + 40;
    if (v16 >= v21)
      v23 = v22;
    else
      v23 = 0;
  }
  v24 = *(_QWORD **)(a1 + 8);
  Intersector = AccelerationStructureViewerServer::Renderer::getIntersector(a1, 4, v23);
  if (*(_QWORD *)(Intersector + 32))
  {
    v26 = *(_QWORD *)(a1 + 16840);
    if (v26)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v26 + 48))(v26, a1, a2, a3, 0, 0);
    v27 = (void *)v75[5];
    v75[5] = 0;

    v28 = (void *)v69[5];
    v69[5] = 0;
    goto LABEL_47;
  }
  v29 = Intersector;
  v49 = a3;
  v50 = a2;
  v30 = (_QWORD *)(v13 + 17608);
  v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 17568), "commandBufferWithDescriptor:", *(_QWORD *)(a1 + 17552)));
  objc_msgSend(v28, "setLabel:", CFSTR("ASVS Metal Intersector"));
  v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "computeCommandEncoder"));
  v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("ASVS Metal Intersector '%@'"), &stru_7282A8));
  objc_msgSend(v31, "setLabel:", v32);

  objc_msgSend(v31, "setComputePipelineState:", *(_QWORD *)(v29 + 8));
  objc_msgSend(v31, "setBuffer:offset:atIndex:", *v30, 0, 1);
  v33 = *(_QWORD *)(a1 + 17736);
  if (v33)
    objc_msgSend(v31, "setAccelerationStructure:atBufferIndex:", v33, 2);
  v63 = 0u;
  v64 = 0u;
  v62 = 0u;
  v61 = 0u;
  v34 = *(id *)(a1 + 17744);
  v35 = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v61, v80, 16);
  if (v35)
  {
    v36 = v35;
    v37 = *(_QWORD *)v62;
    do
    {
      for (i = 0; i != v36; i = (char *)i + 1)
      {
        if (*(_QWORD *)v62 != v37)
          objc_enumerationMutation(v34);
        objc_msgSend(v31, "useResource:usage:", *(_QWORD *)(*((_QWORD *)&v61 + 1) + 8 * (_QWORD)i), 1);
      }
      v36 = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v61, v80, 16);
    }
    while (v36);
  }

  v39 = *(_QWORD *)(v29 + 24);
  if (v39)
  {
    objc_msgSend(v31, "setIntersectionFunctionTable:atBufferIndex:", v39, 3);
LABEL_32:
    (*(void (**)(_QWORD *, void *))(*v24 + 104))(v24, v31);
    goto LABEL_33;
  }
  v40 = *(_QWORD *)(v29 + 16);
  if (v40)
  {
    objc_msgSend(v31, "setVisibleFunctionTable:atBufferIndex:", v40, 3);
    goto LABEL_32;
  }
LABEL_33:
  objc_msgSend(v31, "setBuffer:offset:atIndex:", v75[5], 0, 4);
  objc_msgSend(v31, "setBuffer:offset:atIndex:", v69[5], 0, 5);
  objc_msgSend(v31, "setBuffer:offset:atIndex:", *(_QWORD *)(a1 + 17752), 0, 6);
  v41 = v24[23];
  if (v24[24] != v41)
  {
    v42 = 0;
    v43 = 0;
    do
    {
      objc_msgSend(v31, "useResource:usage:", *(_QWORD *)(v41 + v42 + 24), 1);
      objc_msgSend(v31, "useResource:usage:", *(_QWORD *)(v41 + v42 + 40), 1);
      objc_msgSend(v31, "useResource:usage:", *(_QWORD *)(v41 + v42 + 56), 1);
      v44 = *(_QWORD *)(v41 + v42 + 72);
      if (v44)
        objc_msgSend(v31, "useResource:usage:", v44, 1);
      v45 = *(_QWORD *)(v41 + v42 + 88);
      if (v45)
        objc_msgSend(v31, "useResource:usage:", v45, 1);
      v46 = *(_QWORD *)(v41 + v42 + 104);
      if (v46)
        objc_msgSend(v31, "useResource:usage:", v46, 1);
      v47 = *(_QWORD *)(v41 + v42 + 152);
      if (v47)
        objc_msgSend(v31, "useResource:usage:", v47, 1);
      v48 = *(_QWORD *)(v41 + v42 + 168);
      if (v48)
        objc_msgSend(v31, "useResource:usage:", v48, 1);
      ++v43;
      v41 = v24[23];
      v42 += 184;
    }
    while (v43 < 0xD37A6F4DE9BD37A7 * ((v24[24] - v41) >> 3));
  }
  objc_msgSend(v31, "waitForFence:", *(_QWORD *)(a1 + 17528));
  v59 = v51;
  v60 = vdupq_n_s64(1uLL);
  v57 = objc_msgSend(*(id *)(v29 + 8), "maxTotalThreadsPerThreadgroup");
  v58 = v60;
  objc_msgSend(v31, "dispatchThreads:threadsPerThreadgroup:", &v59, &v57);
  objc_msgSend(v31, "updateFence:", *(_QWORD *)(a1 + 17528));
  objc_msgSend(v31, "endEncoding");

  v54[0] = _NSConcreteStackBlock;
  v54[1] = 3221225472;
  v54[2] = ___ZN33AccelerationStructureViewerServer8Renderer16requestQueryRaysE15ASVQueryRayTypeyP6ASVRayj_block_invoke;
  v54[3] = &unk_727278;
  v54[6] = a1;
  v54[7] = v49;
  v55 = v50;
  v56 = v51;
  v54[4] = &v68;
  v54[5] = &v74;
  objc_msgSend(v28, "addCompletedHandler:", v54);
  objc_msgSend(v28, "commit");
LABEL_47:

  AccelerationStructureViewerServer::Renderer::releaseUniformBufferIndex(a1, v52, v53);
  _Block_object_dispose(&v68, 8);

  _Block_object_dispose(&v74, 8);
}

uint64_t __Block_byref_object_copy__8522(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__8523(uint64_t a1)
{

}

uint64_t AccelerationStructureViewerServer::Renderer::reserveUniformBufferIndex(uint64_t a1, void *a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;

  v3 = a2;
  dispatch_semaphore_wait(v3, 0xFFFFFFFFFFFFFFFFLL);
  std::mutex::lock((std::mutex *)(a1 + 48));
  v4 = 0;
  v5 = a1 + 17520;
  while (*(_BYTE *)(v5 + v4))
  {
    if (++v4 == 3)
    {
      dispatch_semaphore_signal(v3);
      LOBYTE(v4) = -1;
      goto LABEL_6;
    }
  }
  *(_BYTE *)(v5 + v4) = 1;
LABEL_6:
  std::mutex::unlock((std::mutex *)(a1 + 48));

  return v4;
}

uint64_t AccelerationStructureViewerServer::Renderer::getIntersector(uint64_t a1, int a2, unint64_t a3)
{
  std::mutex *v6;
  uint64_t *v7;
  uint64_t *v8;
  int v9;
  int v10;
  uint64_t v11;

  v6 = (std::mutex *)(a1 + 48);
  std::mutex::lock((std::mutex *)(a1 + 48));
  v7 = *(uint64_t **)(a1 + 17696);
  if (!v7)
    goto LABEL_13;
  v8 = (uint64_t *)(a1 + 17696);
  do
  {
    v9 = *((_DWORD *)v7 + 8);
    if (v9 >= a2)
    {
      if (v9 <= a2)
      {
        if (v7[5] < a3)
          ++v7;
        else
          v8 = v7;
      }
      else
      {
        v8 = v7;
      }
    }
    else
    {
      ++v7;
    }
    v7 = (uint64_t *)*v7;
  }
  while (v7);
  if (v8 == (uint64_t *)(a1 + 17696) || (v10 = *((_DWORD *)v8 + 8), v10 > a2) || v10 >= a2 && v8[5] > a3)
LABEL_13:
    operator new();
  v11 = v8[6];
  std::mutex::unlock(v6);
  return v11;
}

void AccelerationStructureViewerServer::Renderer::releaseUniformBufferIndex(uint64_t a1, unsigned int a2, void *a3)
{
  std::mutex *v5;
  NSObject *dsema;

  if (a2 != 3)
  {
    v5 = (std::mutex *)(a1 + 48);
    dsema = a3;
    std::mutex::lock(v5);
    *(_BYTE *)(a1 + a2 + 17520) = 0;
    std::mutex::unlock(v5);
    dispatch_semaphore_signal(dsema);

  }
}

void ___ZN33AccelerationStructureViewerServer8Renderer16requestQueryRaysE15ASVQueryRayTypeyP6ASVRayj_block_invoke(uint64_t a1)
{
  uint64_t v2;
  dispatch_queue_global_t global_queue;
  NSObject *v4;
  uint64_t v5;
  _QWORD block[4];
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *(_QWORD *)(a1 + 48);
  global_queue = dispatch_get_global_queue(0, 0);
  v4 = objc_claimAutoreleasedReturnValue(global_queue);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = ___ZN33AccelerationStructureViewerServer8Renderer16requestQueryRaysE15ASVQueryRayTypeyP6ASVRayj_block_invoke_2;
  block[3] = &unk_727250;
  v5 = *(_QWORD *)(a1 + 56);
  v8 = v2;
  v9 = v5;
  v10 = *(_QWORD *)(a1 + 64);
  v7 = *(_OWORD *)(a1 + 32);
  dispatch_async(v4, block);

}

void ___ZN33AccelerationStructureViewerServer8Renderer16requestQueryRaysE15ASVQueryRayTypeyP6ASVRayj_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;

  v2 = *(_QWORD *)(a1 + 48);
  v3 = *(_QWORD *)(v2 + 16840);
  if (v3)
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, id, _QWORD))(*(_QWORD *)v3 + 48))(v3, v2, *(unsigned int *)(a1 + 64), *(_QWORD *)(a1 + 56), objc_msgSend(objc_retainAutorelease(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40)), "contents"), *(unsigned int *)(a1 + 68));
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = 0;

  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v7 = *(void **)(v6 + 40);
  *(_QWORD *)(v6 + 40) = 0;

}

void std::default_delete<AccelerationStructureViewerServer::Intersector>::operator()[abi:nn180100](id *a1)
{

  operator delete();
}

_QWORD *AccelerationStructureViewer::Sample::Sample(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;

  memcpy(a1, (const void *)a2, 0x240uLL);
  v4 = *(_QWORD *)(a2 + 600);
  if (v4)
  {
    if (v4 == a2 + 576)
    {
      a1[75] = a1 + 72;
      (*(void (**)(_QWORD))(**(_QWORD **)(a2 + 600) + 24))(*(_QWORD *)(a2 + 600));
    }
    else
    {
      a1[75] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
    }
  }
  else
  {
    a1[75] = 0;
  }
  a1[76] = *(id *)(a2 + 608);
  a1[77] = *(id *)(a2 + 616);
  a1[78] = *(id *)(a2 + 624);
  a1[79] = *(id *)(a2 + 632);
  a1[80] = *(id *)(a2 + 640);
  a1[81] = *(id *)(a2 + 648);
  return a1;
}

id AccelerationStructureViewerServer::Renderer::metalIntersectorPass(uint64_t a1, unsigned int a2, uint64_t a3, void *a4, uint64_t a5, _DWORD *a6, int a7, int a8)
{
  uint64_t v14;
  void *v15;
  void *v16;
  void *v17;
  uint64_t v18;
  signed int v19;
  unsigned int v20;
  unint64_t v21;
  uint64_t v22;
  void *v23;
  void **v24;
  void *v25;
  id v26;
  void *v27;
  std::mutex *v28;
  uint64_t v29;
  char *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  uint64_t v34;
  uint64_t shared_weak_owners;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  id v41;
  unint64_t v42;
  unint64_t v43;
  char *v44;
  char *v45;
  void **v46;
  void *v47;
  id v48;
  void *v49;
  void *v50;
  id v51;
  void *v52;
  unsigned int v53;
  __n128 v54;
  unint64_t v55;
  uint64_t *v56;
  int v57;
  uint64_t **v58;
  unsigned int v59;
  uint64_t **v60;
  int v61;
  unsigned int v62;
  id v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  id v67;
  unsigned int v68;
  void *v69;
  void *v70;
  void *v71;
  uint64_t v72;
  void *v73;
  void *v74;
  void *v75;
  uint64_t v76;
  void *v77;
  void *v78;
  id v79;
  id v80;
  id v81;
  uint64_t v82;
  void *i;
  void *v84;
  void *v85;
  unsigned int v86;
  void *v87;
  void *v88;
  uint64_t v89;
  void *v90;
  uint64_t v91;
  void *v92;
  void *v93;
  void *v94;
  void *v95;
  void *v96;
  void *v97;
  char *v98;
  char *v99;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  void *v103;
  void *v104;
  void *v105;
  void *v106;
  void *v107;
  unsigned __int8 v108;
  uint64_t v109;
  unint64_t v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  char *v114;
  char *v115;
  uint64_t v116;
  char *v117;
  char *v118;
  char *v119;
  char *v120;
  char *v121;
  uint64_t v122;
  char *v123;
  char *v124;
  char *v125;
  char *v126;
  char *v127;
  unint64_t v128;
  uint64_t v129;
  unsigned int v130;
  char *v131;
  uint64_t v132;
  uint64_t *v133;
  uint64_t v134;
  std::__shared_weak_count *v135;
  unint64_t *v136;
  unint64_t v137;
  uint64_t v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  unint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  id v153;
  id v154;
  id v155;
  uint64_t v156;
  void *j;
  uint64_t v158;
  uint64_t v159;
  id v160;
  void *v162;
  void *v163;
  void *v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  id v169;
  id *location;
  void *context;
  void *contexta;
  char *v173;
  void *v174;
  id obj;
  int v176;
  signed int v177;
  _DWORD *v178;
  id v179;
  uint64_t v180;
  uint64_t v181;
  unsigned int v182;
  void **v183;
  uint64_t v184;
  int v185;
  int v186;
  id v187;
  uint64_t v188;
  uint64_t v189;
  char **v190;
  id v191;
  id v192;
  __n128 v193;
  int64x2_t v194;
  int v195;
  std::__shared_weak_count *v196;
  id v197;
  uint64_t v198;
  _QWORD v199[3];
  _QWORD v200[3];
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  uint64_t v205;
  int64x2_t v206;
  uint64_t v207;
  int64x2_t v208;
  uint64_t v209;
  int64x2_t v210;
  uint64_t v211;
  int64x2_t v212;
  std::unique_lock<std::mutex> v213;
  __int128 v214;
  __int128 v215;
  __int128 v216;
  __int128 v217;
  _BYTE v218[128];
  _QWORD v219[4];
  _QWORD v220[4];
  _QWORD v221[4];
  _QWORD v222[4];
  std::condition_variable v223;
  _OWORD v224[5];
  _QWORD v225[2];

  v14 = a1;
  v198 = *(_QWORD *)(a1 + 8);
  v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a4, "computeCommandEncoder"));
  v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a5 + 8), "label"));
  v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("ASVS Metal Intersector '%@'"), v16));
  objc_msgSend(v15, "setLabel:", v17);

  v189 = a5;
  if (*(_DWORD *)a5 == 3)
  {
    v195 = *(_DWORD *)(*(_QWORD *)(v14 + 17536) + 8);
    v179 = objc_msgSend(*(id *)(a5 + 8), "maxTotalThreadsPerThreadgroup");
    v181 = v14;
    v18 = *(_QWORD *)(v14 + 17536);
    v187 = v15;
    v19 = (3 * *(_DWORD *)(a3 + 440) * *(_DWORD *)(a3 + 444)) / *(_DWORD *)(v18 + 8);
    a6[2] = objc_msgSend(*(id *)(a3 + 608), "width");
    a6[3] = objc_msgSend(*(id *)(a3 + 608), "height");
    v20 = objc_msgSend(*(id *)(a3 + 608), "width");
    a6[4] = objc_msgSend(*(id *)(a3 + 608), "height") * v20;
    a6[5] = v19;
    v177 = v19;
    v21 = 4 * *(int *)(v18 + 8) * (uint64_t)v19;
    v22 = v18 + 8 * a2;
    v25 = *(void **)(v22 + 112);
    v24 = (void **)(v22 + 112);
    v23 = v25;
    if (!v25 || (unint64_t)objc_msgSend(v23, "length") < v21)
    {
      v26 = objc_msgSend(*(id *)v18, "newBufferWithLength:options:", v21, 0);
      v27 = *v24;
      *v24 = v26;

    }
    v183 = v24;
    v28 = (std::mutex *)(v18 + 320);
    v213.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v18 + 320);
    v213.__owns_ = 1;
    std::mutex::lock((std::mutex *)(v18 + 320));
    v178 = a6;
    v184 = a3;
    if (*(_BYTE *)(v18 + 432))
    {
      ++*(_DWORD *)(v18 + 436);
      v185 = a7;
      v176 = a8;
      v182 = a2;
      std::mutex::unlock(v213.__m_);
      memset(v224, 0, 48);
      v29 = (v195 * v195);
      memset(v223.__cv_.__opaque, 0, sizeof(v223.__cv_.__opaque));
      v223.__cv_.__sig = 1018212795;
      v30 = (char *)operator new(0x78uLL);
      *((_QWORD *)v30 + 1) = 0;
      v31 = (unint64_t *)(v30 + 8);
      *((_QWORD *)v30 + 2) = 0;
      *((_QWORD *)v30 + 3) = 1018212795;
      v173 = v30 + 24;
      *(_QWORD *)v30 = off_727588;
      *((_OWORD *)v30 + 2) = 0u;
      *((_OWORD *)v30 + 3) = 0u;
      *((_QWORD *)v30 + 8) = 0;
      *((_OWORD *)v30 + 5) = 0u;
      *((_OWORD *)v30 + 6) = 0u;
      *((_WORD *)v30 + 56) = 0;
      v32 = atomic_load((unint64_t *)v224);
      v33 = (unint64_t *)(v30 + 72);
      atomic_store(v32, (unint64_t *)v30 + 9);
      v34 = *(_QWORD *)&v224[1];
      *((_QWORD *)v30 + 10) = *((_QWORD *)&v224[0] + 1);
      v190 = (char **)(v30 + 88);
      std::vector<AccelerationStructureViewerServer::APSUSCRayCollector>::resize((char **)v30 + 11, (*((_QWORD *)&v224[1] + 1) - v34) >> 5);
      v30[113] = BYTE9(v224[2]);
      shared_weak_owners = *((_QWORD *)v30 + 11);
      v196 = (std::__shared_weak_count *)v30;
      if (*((_QWORD *)v30 + 12) != shared_weak_owners)
      {
        v36 = 0;
        v37 = 0;
        do
        {
          v38 = *(_QWORD *)&v224[1] + v36;
          v39 = shared_weak_owners + v36;
          *(_OWORD *)(shared_weak_owners + v36) = *(_OWORD *)(*(_QWORD *)&v224[1] + v36);
          objc_storeStrong((id *)(shared_weak_owners + v36 + 16), *(id *)(v38 + 16));
          v40 = *(_QWORD *)(v38 + 24);
          v30 = (char *)v196;
          *(_QWORD *)(v39 + 24) = v40;
          ++v37;
          shared_weak_owners = v196[3].__shared_weak_owners_;
          v36 += 32;
        }
        while (v37 < ((uint64_t)v196[4].__vftable - shared_weak_owners) >> 5);
      }
      v180 = (_QWORD)v179 * v29;
      *(_QWORD *)&v214 = &v224[1];
      std::vector<AccelerationStructureViewerServer::APSUSCRayCollector>::__destroy_vector::operator()[abi:nn180100]((void ***)&v214);
      std::condition_variable::~condition_variable(&v223);
      atomic_store(0, v33);
      v41 = objc_msgSend(*(id *)(v184 + 608), "width");
      *((_QWORD *)v30 + 10) = (_QWORD)objc_msgSend(*(id *)(v184 + 608), "height") * (_QWORD)v41;
      std::vector<AccelerationStructureViewerServer::APSUSCRayCollector>::resize(v190, *(int *)(v18 + 8));
      context = objc_autoreleasePoolPush();
      std::mutex::lock((std::mutex *)(v18 + 136));
      if (*(_DWORD *)(v18 + 8))
      {
        v42 = 0;
        v43 = 12 * v178[5];
        do
        {
          v44 = *v190;
          v45 = &(*v190)[32 * v42];
          *(_QWORD *)v45 = -1;
          *((_QWORD *)v45 + 1) = v177;
          v47 = (void *)*((_QWORD *)v45 + 2);
          v46 = (void **)(v45 + 16);
          *v46 = 0;

          while (*(_QWORD *)(v18 + 240))
          {
            v48 = objc_retain(*(id *)(*(_QWORD *)(*(_QWORD *)(v18 + 208)
                                                + ((*(_QWORD *)(v18 + 232) >> 6) & 0x3FFFFFFFFFFFFF8))
                                    + 8 * (*(_QWORD *)(v18 + 232) & 0x1FFLL)));
            std::deque<objc_object  {objcproto9MTLBuffer}* {__strong}>::pop_front(v18 + 200);
            if ((unint64_t)objc_msgSend(v48, "length") >= v43)
            {
              v49 = *v46;
              *v46 = v48;

              break;
            }

          }
          v50 = *v46;
          if (!*v46)
          {
            v51 = objc_msgSend(*(id *)v18, "newBufferWithLength:options:", v43, 0);
            v52 = *v46;
            *v46 = v51;

            v50 = *v46;
          }
          *(_QWORD *)&v44[32 * v42++ + 24] = objc_msgSend(v50, "contents");
        }
        while (v42 < *(int *)(v18 + 8));
      }
      std::mutex::unlock((std::mutex *)(v18 + 136));
      objc_autoreleasePoolPop(context);
      v53 = objc_msgSend(v187, "globalTraceObjectID");
      v223.__cv_.__sig = v18 + 624;
      v223.__cv_.__opaque[0] = 1;
      std::mutex::lock((std::mutex *)(v18 + 624));
      v54.n128_u64[0] = (unint64_t)v173;
      v54.n128_u64[1] = (unint64_t)v196;
      v14 = v181;
      do
        v55 = __ldxr(v31);
      while (__stxr(v55 + 1, v31));
      v56 = *(uint64_t **)(v18 + 736);
      if (v56)
      {
        a3 = v184;
        v57 = v185;
        while (1)
        {
          while (1)
          {
            v58 = (uint64_t **)v56;
            v59 = *((_DWORD *)v56 + 8);
            if (v59 <= v53)
              break;
            v56 = *v58;
            v60 = v58;
            if (!*v58)
              goto LABEL_75;
          }
          if (v59 >= v53)
            break;
          v56 = v58[1];
          if (!v56)
          {
            v60 = v58 + 1;
            goto LABEL_75;
          }
        }
        v130 = v182;
        v134 = v182;
      }
      else
      {
        v60 = (uint64_t **)(v18 + 736);
        v58 = (uint64_t **)(v18 + 736);
        a3 = v184;
        v57 = v185;
LABEL_75:
        v193 = v54;
        v131 = (char *)operator new(0x38uLL);
        *((_DWORD *)v131 + 8) = v53;
        *(__n128 *)(v131 + 40) = v193;
        *(_QWORD *)v131 = 0;
        *((_QWORD *)v131 + 1) = 0;
        *((_QWORD *)v131 + 2) = v58;
        *v60 = (uint64_t *)v131;
        v132 = **(_QWORD **)(v18 + 728);
        if (v132)
        {
          *(_QWORD *)(v18 + 728) = v132;
          v133 = *v60;
        }
        else
        {
          v133 = (uint64_t *)v131;
        }
        v130 = v182;
        v134 = v182;
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v18 + 736), v133);
        ++*(_QWORD *)(v18 + 744);
        v54 = 0uLL;
      }
      v135 = (std::__shared_weak_count *)v54.n128_u64[1];
      if (v54.n128_u64[1])
      {
        v136 = (unint64_t *)(v54.n128_u64[1] + 8);
        do
          v137 = __ldaxr(v136);
        while (__stlxr(v137 - 1, v136));
        if (!v137)
        {
          (*(void (**)(unint64_t, __n128))(*(_QWORD *)v54.n128_u64[1] + 16))(v54.n128_u64[1], v54);
          std::__shared_weak_count::__release_weak(v135);
        }
      }
      std::unique_lock<std::mutex>::unlock((std::unique_lock<std::mutex> *)&v223);
      v138 = v18 + 8 * v134;
      objc_msgSend(v187, "setBuffer:offset:atIndex:", *(_QWORD *)(v138 + 64), 0, 5);
      objc_msgSend(v187, "setComputePipelineState:", *(_QWORD *)(v18 + 40));
      v211 = *(int *)(v18 + 8) + 1;
      v194 = vdupq_n_s64(1uLL);
      v212 = v194;
      v209 = v211;
      v210 = v194;
      objc_msgSend(v187, "dispatchThreads:threadsPerThreadgroup:", &v211, &v209);
      objc_msgSend(v187, "setBuffer:offset:atIndex:", *(_QWORD *)(v138 + 64), 0, 4);
      objc_msgSend(v187, "setBuffer:offset:atIndex:", *(_QWORD *)(v138 + 88), 0, 5);
      objc_msgSend(v187, "setBuffer:offset:atIndex:", *v183, 0, 6);
      objc_msgSend(v187, "setComputePipelineState:", *(_QWORD *)(v18 + 40));
      v139 = *(int *)(v18 + 8);
      v207 = v139;
      v208 = v194;
      v205 = v139;
      v206 = v194;
      objc_msgSend(v187, "dispatchThreads:threadsPerThreadgroup:", &v207, &v205);
      if (v223.__cv_.__opaque[0])
        std::mutex::unlock((std::mutex *)v223.__cv_.__sig);
      v129 = v180;
      do
        v140 = __ldaxr(v31);
      while (__stlxr(v140 - 1, v31));
      if (!v140)
      {
        ((void (*)(std::__shared_weak_count *))v196->__on_zero_shared)(v196);
        std::__shared_weak_count::__release_weak(v196);
      }

      v197 = &dword_0 + 1;
      v188 = 1;
      v191 = &dword_0 + 1;
      a8 = v176;
      goto LABEL_94;
    }
    v192 = *(id *)v18;
    v69 = *(void **)(v18 + 760);
    *(_QWORD *)(v18 + 760) = 0;

    v70 = *(void **)(v18 + 752);
    *(_QWORD *)(v18 + 752) = 0;

    GRCReleaseAllCounterSourceGroup();
    v71 = objc_autoreleasePoolPush();
    v72 = GRCCopyAllCounterSourceGroup();
    v73 = *(void **)(v18 + 752);
    *(_QWORD *)(v18 + 752) = v72;

    v74 = *(void **)(v18 + 752);
    if (v74 && objc_msgSend(v74, "count"))
    {
      v75 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v18 + 752), "firstObject"));
      v76 = objc_claimAutoreleasedReturnValue(objc_msgSend(v75, "sourceList"));
      v77 = *(void **)(v18 + 760);
      *(_QWORD *)(v18 + 760) = v76;

      v78 = *(void **)(v18 + 760);
      if (v78 && objc_msgSend(v78, "count"))
      {
        contexta = v71;
        v174 = v75;
        obj = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", 3));
        v214 = 0u;
        v215 = 0u;
        v216 = 0u;
        v217 = 0u;
        location = (id *)(v18 + 760);
        v79 = *(id *)(v18 + 760);
        v80 = objc_msgSend(v79, "countByEnumeratingWithState:objects:count:", &v214, &v223, 16);
        if (v80)
        {
          v81 = v80;
          v82 = *(_QWORD *)v215;
          while (2)
          {
            for (i = 0; i != v81; i = (char *)i + 1)
            {
              if (*(_QWORD *)v215 != v82)
                objc_enumerationMutation(v79);
              v84 = *(void **)(*((_QWORD *)&v214 + 1) + 8 * (_QWORD)i);
              if (!objc_msgSend(v84, "ringBufferNum"))
              {
                v106 = v79;
                v28 = (std::mutex *)(v18 + 320);
                v87 = contexta;
                goto LABEL_142;
              }
              v85 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v84, "name"));
              v86 = objc_msgSend(v85, "containsString:", CFSTR("APS_USC"));

              if (v86)
              {
                objc_msgSend(obj, "addObject:", v84);
                *(_DWORD *)(v18 + 848) = objc_msgSend(obj, "count") - 1;
              }
            }
            v81 = objc_msgSend(v79, "countByEnumeratingWithState:objects:count:", &v214, &v223, 16);
            if (v81)
              continue;
            break;
          }
        }

        v28 = (std::mutex *)(v18 + 320);
        v87 = contexta;
        if (objc_msgSend(obj, "count"))
        {
          objc_storeStrong(location, obj);
          *(_QWORD *)(v18 + 768) = objc_msgSend(v174, "sampleMarker");
          v221[0] = CFSTR("RingBufferSizeInKB");
          v221[1] = CFSTR("SyncDrainMode");
          v222[0] = &off_739EE0;
          v222[1] = &off_739EF8;
          v221[2] = CFSTR("SystemTimePeriod");
          v88 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v18 + 808)));
          v221[3] = CFSTR("ProfileControl");
          v222[2] = v88;
          v222[3] = &off_7395B8;
          v89 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v222, v221, 4));
          v90 = *(void **)(v18 + 824);
          *(_QWORD *)(v18 + 824) = v89;

          v91 = objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", 1));
          v92 = *(void **)(v18 + 832);
          *(_QWORD *)(v18 + 832) = v91;

          v93 = *(void **)(v18 + 832);
          v219[0] = CFSTR("TileTracing");
          v219[1] = CFSTR("ESLInstTracing");
          v220[0] = &off_739F10;
          v220[1] = &off_739F10;
          v219[2] = CFSTR("CountPeriod");
          v94 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v18 + 812)));
          v220[2] = v94;
          v219[3] = CFSTR("PulsePeriod");
          v95 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v18 + 816)));
          v220[3] = v95;
          v96 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v220, v219, 4));
          v97 = (void *)objc_claimAutoreleasedReturnValue(+[GPURawCounterSourceTriggerSelect selectWithName:options:](GPURawCounterSourceTriggerSelect, "selectWithName:options:", CFSTR("KickTracing"), v96));
          objc_msgSend(v93, "addObject:", v97);

          agxps_load_counter_obfuscation_map((uint64_t)"/AppleInternal/Library/AGX/AGXRawCounterMapping.csv");
          v98 = agxps_counter_deobfuscate_name("_bc236dcf3744edf6bcf329ae47088528b35ea5e0beac601cf6781545eb2327cc");
          v99 = agxps_counter_deobfuscate_name("_dc9d2c02b3df41ad60f6512a3823b2d0f9b735ae9c41650c4396bac13a7a3c5e");
          v100 = objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", 20));
          v101 = *(void **)(v18 + 840);
          *(_QWORD *)(v18 + 840) = v100;

          v102 = 0;
          v225[0] = v98;
          v225[1] = v99;
          do
          {
            v103 = *(void **)(v18 + 840);
            v104 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v225[v102]));
            v105 = (void *)objc_claimAutoreleasedReturnValue(+[GPURawCounterSelect selectWithName:options:](GPURawCounterSelect, "selectWithName:options:", v104, 0));
            objc_msgSend(v103, "addObject:", v105);

            ++v102;
          }
          while (v102 != 2);
          objc_msgSend(v174, "setOptions:", &off_7395E0);
          v106 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v18 + 760), "objectAtIndexedSubscript:", *(int *)(v18 + 848)));
          v87 = contexta;
          if ((objc_msgSend(v106, "requestTriggers:firstErrorIndex:", *(_QWORD *)(v18 + 832), 0) & 1) != 0)
          {
            v225[0] = 0;
            if ((objc_msgSend(v106, "requestCounters:firstErrorIndex:", *(_QWORD *)(v18 + 840), v225) & 1) != 0)
            {
              objc_msgSend(v106, "setOptions:", *(_QWORD *)(v18 + 824));
              if ((objc_msgSend(v106, "setEnabled:", 1) & 1) != 0)
              {

                if (objc_msgSend(*location, "count"))
                {

                  objc_autoreleasePoolPop(contexta);
                  v107 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v18 + 752), "firstObject"));
                  v108 = objc_msgSend(v107, "startSampling");

                  if ((v108 & 1) != 0)
                  {
                    v109 = *(_QWORD *)(v18 + 600);
                    *(_QWORD *)(v18 + 608) = v109;
                    v110 = *(int *)(v18 + 8);
                    if ((_DWORD)v110)
                    {
                      v111 = 0xFFC00FFC00FFC01 * ((*(_QWORD *)(v18 + 616) - v109) >> 7);
                      if (v111 >= v110)
                      {
                        v166 = v109 + 131200 * (int)v110;
                        v167 = 131200 * (int)v110;
                        do
                        {
                          v168 = v109 + 131160;
                          *(_QWORD *)(v109 + 8) = -1;
                          *(_QWORD *)(v109 + 16) = -1;
                          *(_QWORD *)(v109 + 24) = 0;
                          *(_BYTE *)(v109 + 32) = 1;
                          *(_DWORD *)(v109 + 131160) = 0;
                          *(_QWORD *)(v109 + 131176) = 0;
                          *(_QWORD *)(v109 + 131184) = 0;
                          *(_QWORD *)(v109 + 131168) = 0;
                          *(_DWORD *)(v109 + 131192) = 0;
                          atomic_store(0, (unint64_t *)(v109 + 40));
                          *(_QWORD *)(v109 + 48) = 0;
                          *(_QWORD *)(v109 + 56) = 0;
                          *(_DWORD *)(v109 + 131160) = 0;
                          v109 += 131200;
                          *(_QWORD *)(v168 + 8) = 0;
                          v167 -= 131200;
                        }
                        while (v167);
                        *(_QWORD *)(v18 + 608) = v166;
                      }
                      else
                      {
                        if ((v110 & 0x80000000) != 0)
                          abort();
                        v112 = 0x1FF801FF801FF802 * ((*(_QWORD *)(v18 + 616) - v109) >> 7);
                        if (2 * v111 <= v110)
                          v112 = *(int *)(v18 + 8);
                        if (v111 >= 0x3FF003FF003FLL)
                          v113 = 0x7FE007FE007FLL;
                        else
                          v113 = v112;
                        if (v113 > 0x7FE007FE007FLL)
                          std::__throw_bad_array_new_length[abi:nn180100]();
                        v114 = (char *)operator new(131200 * v113);
                        v115 = &v114[131200 * (int)v110];
                        v116 = 131200 * (int)v110;
                        v117 = v114;
                        do
                        {
                          v118 = v117 + 131160;
                          *((_QWORD *)v117 + 1) = -1;
                          *((_QWORD *)v117 + 2) = -1;
                          *((_QWORD *)v117 + 3) = 0;
                          v117[32] = 1;
                          *((_DWORD *)v117 + 32790) = 0;
                          *((_QWORD *)v117 + 16397) = 0;
                          *((_QWORD *)v117 + 16398) = 0;
                          *((_QWORD *)v117 + 16396) = 0;
                          *((_DWORD *)v117 + 32798) = 0;
                          atomic_store(0, (unint64_t *)v117 + 5);
                          *((_QWORD *)v117 + 6) = 0;
                          *((_QWORD *)v117 + 7) = 0;
                          *((_DWORD *)v117 + 32790) = 0;
                          v117 += 131200;
                          *((_QWORD *)v118 + 1) = 0;
                          v116 -= 131200;
                        }
                        while (v116);
                        v119 = &v114[131200 * v113];
                        v120 = *(char **)(v18 + 608);
                        v121 = *(char **)(v18 + 600);
                        if (v120 != v121)
                        {
                          v122 = 0;
                          v123 = v120 - 131160;
                          v124 = v114 - 131144;
                          do
                          {
                            v125 = &v114[v122 - 131192];
                            v126 = &v124[v122];
                            *(_QWORD *)v125 = -1;
                            *((_QWORD *)v125 + 1) = -1;
                            *((_QWORD *)v126 - 4) = 0;
                            v114[v122 - 131168] = 1;
                            v127 = &v114[v122];
                            *((_DWORD *)v127 - 10) = 0;
                            *((_QWORD *)v127 - 3) = 0;
                            *((_QWORD *)v127 - 2) = 0;
                            *((_QWORD *)v127 - 4) = 0;
                            *((_DWORD *)v127 - 2) = 0;
                            v128 = atomic_load((unint64_t *)&v123[v122]);
                            atomic_store(v128, (unint64_t *)&v124[v122 - 16]);
                            *((_QWORD *)v126 - 1) = *(_QWORD *)&v123[v122 + 8];
                            *(_QWORD *)v126 = *(_QWORD *)&v123[v122 + 16];
                            *((_DWORD *)v127 - 10) = *(_DWORD *)&v120[v122 - 40];
                            *((_QWORD *)v127 - 4) = *(_QWORD *)&v120[v122 - 32];
                            v122 -= 131200;
                          }
                          while (&v120[v122] != v121);
                          v114 += v122;
                          v120 = *(char **)(v18 + 600);
                        }
                        *(_QWORD *)(v18 + 600) = v114;
                        *(_QWORD *)(v18 + 608) = v115;
                        *(_QWORD *)(v18 + 616) = v119;
                        if (v120)
                          operator delete(v120);
                      }
                    }
                    atomic_store(0, (unint64_t *)(v18 + 776));
                    atomic_store(0, (unint64_t *)(v18 + 784));
                    *(_BYTE *)(v18 + 432) = 1;
                    v169 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v18 + 760), "objectAtIndexedSubscript:", 0));
                    operator new();
                  }
                  goto LABEL_136;
                }
                goto LABEL_143;
              }
              v164 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v106, "name"));
              NSLog(CFSTR("Fail, error while enabling aps source %@"), v164);
            }
            else
            {
              v165 = v225[0];
              v164 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v18 + 840), "objectAtIndexedSubscript:", v225[0]));
              NSLog(CFSTR("Fail, error while requesting %lu %@ counter for apsSource "), v165, v164);
            }
          }
          else
          {
            v164 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v106, "name"));
            NSLog(CFSTR("Fail, error while requesting triggers for %@"), v164);
          }

LABEL_142:
        }
LABEL_143:

        v162 = v87;
        goto LABEL_135;
      }

    }
    v162 = v71;
LABEL_135:
    objc_autoreleasePoolPop(v162);
LABEL_136:

    NSLog(CFSTR("Unable to start streaming"));
    v163 = *v183;
    *v183 = 0;

    std::mutex::unlock(v28);
    objc_msgSend(v187, "endEncoding");
    v160 = 0;
    goto LABEL_132;
  }
  v61 = a7;
  v62 = a2;
  v63 = objc_msgSend(*(id *)(a3 + 608), "width");
  v191 = objc_msgSend(*(id *)(a3 + 608), "height");
  v197 = objc_msgSend(*(id *)(a5 + 8), "threadExecutionWidth");
  v64 = (unint64_t)objc_msgSend(*(id *)(a5 + 8), "maxTotalThreadsPerThreadgroup");
  v65 = (unint64_t)objc_msgSend(*(id *)(a5 + 8), "threadExecutionWidth");
  v66 = *(_QWORD *)(v14 + 17536);
  v188 = v64 / v65;
  if (v66)
  {
    v186 = v61;
    v67 = v15;
    std::mutex::lock((std::mutex *)(v66 + 320));
    if (*(_BYTE *)(v66 + 432) && !*(_DWORD *)(v66 + 436))
    {
      AccelerationStructureViewerServer::Profiler::stopAPSStreaming(v66, *(void **)v66);
    }
    else
    {
      v68 = objc_msgSend(v67, "globalTraceObjectID");
      v223.__cv_.__sig = v66 + 624;
      v223.__cv_.__opaque[0] = 1;
      std::mutex::lock((std::mutex *)(v66 + 624));
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(v66 + 688, v68, v68);
      std::unique_lock<std::mutex>::unlock((std::unique_lock<std::mutex> *)&v223);
      if (v223.__cv_.__opaque[0])
        std::mutex::unlock((std::mutex *)v223.__cv_.__sig);
    }
    std::mutex::unlock((std::mutex *)(v66 + 320));

    v129 = (uint64_t)v63;
    v130 = v62;
    v57 = v186;
  }
  else
  {
    v129 = (uint64_t)v63;
    v130 = v62;
    v57 = v61;
  }
LABEL_94:
  if (*(_QWORD *)(v14 + 17536))
    objc_msgSend(v15, "waitForFence:", *(_QWORD *)(v14 + 17528));
  if (v57)
  {
    objc_msgSend(v15, "setTexture:atIndex:", *(_QWORD *)(a3 + 608), 1);
    objc_msgSend(v15, "setTexture:atIndex:", *(_QWORD *)(a3 + 624), 3);
    objc_msgSend(v15, "setTexture:atIndex:", *(_QWORD *)(a3 + 632), 4);
    objc_msgSend(v15, "setTexture:atIndex:", *(_QWORD *)(a3 + 640), 5);
    v141 = *(_QWORD *)(a3 + 648);
  }
  else
  {
    objc_msgSend(v15, "setTexture:atIndex:", 0, 1);
    objc_msgSend(v15, "setTexture:atIndex:", 0, 3);
    objc_msgSend(v15, "setTexture:atIndex:", 0, 4);
    objc_msgSend(v15, "setTexture:atIndex:", 0, 5);
    v141 = 0;
  }
  objc_msgSend(v15, "setTexture:atIndex:", v141, 6);
  if (a8)
    v142 = *(_QWORD *)(a3 + 616);
  else
    v142 = 0;
  objc_msgSend(v15, "setTexture:atIndex:", v142, 2);
  v143 = v14 + 8 * v130;
  objc_msgSend(v15, "setBuffer:offset:atIndex:", *(_QWORD *)(v143 + 17584), 0, 0);
  objc_msgSend(v15, "setBuffer:offset:atIndex:", *(_QWORD *)(v143 + 17608), 0, 1);
  v144 = *(_QWORD *)(v14 + 17736);
  if (v144)
    objc_msgSend(v15, "setAccelerationStructure:atBufferIndex:", v144, 2);
  objc_msgSend(v15, "setBuffer:offset:atIndex:", *(_QWORD *)(v14 + 17752), 0, 9);
  v145 = *(_QWORD *)(v198 + 184);
  if (*(_QWORD *)(v198 + 192) != v145)
  {
    v146 = 0;
    v147 = 0;
    do
    {
      objc_msgSend(v15, "useResource:usage:", *(_QWORD *)(v145 + v146 + 24), 1);
      objc_msgSend(v15, "useResource:usage:", *(_QWORD *)(v145 + v146 + 40), 1);
      objc_msgSend(v15, "useResource:usage:", *(_QWORD *)(v145 + v146 + 56), 1);
      v148 = *(_QWORD *)(v145 + v146 + 72);
      if (v148)
        objc_msgSend(v15, "useResource:usage:", v148, 1);
      v149 = *(_QWORD *)(v145 + v146 + 88);
      if (v149)
        objc_msgSend(v15, "useResource:usage:", v149, 1);
      v150 = *(_QWORD *)(v145 + v146 + 104);
      if (v150)
        objc_msgSend(v15, "useResource:usage:", v150, 1);
      v151 = *(_QWORD *)(v145 + v146 + 152);
      if (v151)
        objc_msgSend(v15, "useResource:usage:", v151, 1);
      v152 = *(_QWORD *)(v145 + v146 + 168);
      if (v152)
        objc_msgSend(v15, "useResource:usage:", v152, 1);
      ++v147;
      v145 = *(_QWORD *)(v198 + 184);
      v146 += 184;
    }
    while (v147 < 0xD37A6F4DE9BD37A7 * ((*(_QWORD *)(v198 + 192) - v145) >> 3));
  }
  v203 = 0u;
  v204 = 0u;
  v201 = 0u;
  v202 = 0u;
  v153 = *(id *)(v14 + 17744);
  v154 = objc_msgSend(v153, "countByEnumeratingWithState:objects:count:", &v201, v218, 16);
  if (v154)
  {
    v155 = v154;
    v156 = *(_QWORD *)v202;
    do
    {
      for (j = 0; j != v155; j = (char *)j + 1)
      {
        if (*(_QWORD *)v202 != v156)
          objc_enumerationMutation(v153);
        objc_msgSend(v15, "useResource:usage:", *(_QWORD *)(*((_QWORD *)&v201 + 1) + 8 * (_QWORD)j), 1);
      }
      v155 = objc_msgSend(v153, "countByEnumeratingWithState:objects:count:", &v201, v218, 16);
    }
    while (v155);
  }

  v158 = *(_QWORD *)(v189 + 24);
  if (v158)
  {
    objc_msgSend(v15, "setIntersectionFunctionTable:atBufferIndex:", v158, 3);
    if (*(_QWORD *)(v189 + 24))
      (*(void (**)(_QWORD, void *))(**(_QWORD **)(v14 + 8) + 104))(*(_QWORD *)(v14 + 8), v15);
  }
  v159 = *(_QWORD *)(v14 + 17536);
  if (v159)
    objc_msgSend(v15, "setBuffer:offset:atIndex:", *(_QWORD *)(v159 + 16), 0, 7);
  objc_msgSend(v15, "setComputePipelineState:", *(_QWORD *)(v189 + 8));
  v200[0] = v129;
  v200[1] = v191;
  v200[2] = 1;
  v199[0] = v197;
  v199[1] = v188;
  v199[2] = 1;
  objc_msgSend(v15, "dispatchThreads:threadsPerThreadgroup:", v200, v199);
  if (*(_QWORD *)(v14 + 17536))
    objc_msgSend(v15, "updateFence:", *(_QWORD *)(v14 + 17528));
  objc_msgSend(v15, "endEncoding");
  v160 = v15;
LABEL_132:

  return v160;
}

void AccelerationStructureViewer::Sample::~Sample(id *this)
{
  AccelerationStructureViewer::Sample *v2;
  uint64_t v3;

  v2 = (AccelerationStructureViewer::Sample *)this[75];
  if (v2 == (AccelerationStructureViewer::Sample *)(this + 72))
  {
    v3 = 4;
    v2 = (AccelerationStructureViewer::Sample *)(this + 72);
  }
  else
  {
    if (!v2)
      return;
    v3 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
}

void AccelerationStructureViewerServer::Renderer::commitSample(uint64_t a1, char a2, uint64_t a3, void *a4, void *a5, double a6)
{
  id v11;
  id v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t (*v19)(uint64_t, uint64_t);
  void (*v20)(uint64_t);
  id v21;
  _QWORD v22[4];
  _QWORD v23[72];
  _QWORD v24[13];
  char v25;
  _QWORD v26[72];
  _QWORD v27[11];

  v11 = a4;
  v16 = 0;
  v17 = &v16;
  v18 = 0x3032000000;
  v19 = __Block_byref_object_copy__8522;
  v20 = __Block_byref_object_dispose__8523;
  v12 = a5;
  v21 = v12;
  if (v11)
  {
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 3321888768;
    v22[2] = ___ZN33AccelerationStructureViewerServer8Renderer12commitSampleEhN27AccelerationStructureViewer6SampleEdPU27objcproto16MTLCommandBuffer11objc_objectPU32objcproto21OS_dispatch_semaphore8NSObject_block_invoke;
    v22[3] = &unk_727348;
    v24[11] = a1;
    v25 = a2;
    AccelerationStructureViewer::Sample::Sample(v23, a3);
    *(double *)&v24[12] = a6;
    v24[10] = &v16;
    objc_msgSend(v11, "addCompletedHandler:", v22);
    objc_msgSend(v11, "commit");

    v13 = v24;
    v14 = (_QWORD *)v24[3];
  }
  else
  {
    AccelerationStructureViewer::Sample::Sample(v26, a3);
    AccelerationStructureViewerServer::Renderer::completeSample(a1, a2, (uint64_t)v26, (void *)v17[5], a6);

    v13 = v27;
    v14 = (_QWORD *)v27[3];
  }
  if (v14 == v13)
  {
    v15 = 4;
    v14 = v13;
    goto LABEL_8;
  }
  if (v14)
  {
    v15 = 5;
LABEL_8:
    (*(void (**)(void))(*v14 + 8 * v15))();
  }
  _Block_object_dispose(&v16, 8);

}

_QWORD *__copy_helper_block_a16_32c42_ZTSN27AccelerationStructureViewer6SampleE(uint64_t a1, uint64_t a2)
{
  return AccelerationStructureViewer::Sample::Sample((_QWORD *)(a1 + 32), a2 + 32);
}

_QWORD *__destroy_helper_block_a16_32c42_ZTSN27AccelerationStructureViewer6SampleE(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = *(_QWORD **)(a1 + 632);
  if (result == (_QWORD *)(a1 + 608))
  {
    v3 = 4;
    result = (_QWORD *)(a1 + 608);
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void AccelerationStructureViewerServer::Renderer::completeSample(uint64_t a1, char a2, uint64_t a3, void *a4, double a5)
{
  id v9;
  dispatch_queue_global_t global_queue;
  NSObject *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD v14[5];
  id v15;
  _QWORD block[4];
  _QWORD v17[72];
  _BYTE v18[24];
  _BYTE *v19;
  id v20;
  id v21;
  id v22;
  id v23;
  id v24;
  id v25;
  _QWORD *v26;
  uint64_t v27;
  double v28;
  char v29;

  v14[0] = 0;
  v14[1] = v14;
  v14[2] = 0x3032000000;
  v14[3] = __Block_byref_object_copy__8522;
  v14[4] = __Block_byref_object_dispose__8523;
  v9 = a4;
  v15 = v9;
  global_queue = dispatch_get_global_queue(0, 0);
  v11 = objc_claimAutoreleasedReturnValue(global_queue);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = ___ZN33AccelerationStructureViewerServer8Renderer14completeSampleEhN27AccelerationStructureViewer6SampleEdPU32objcproto21OS_dispatch_semaphore8NSObject_block_invoke;
  block[3] = &unk_727310;
  v27 = a1;
  v29 = a2;
  v26 = v14;
  AccelerationStructureViewer::Sample::Sample(v17, a3);
  v28 = a5;
  dispatch_async(v11, block);

  v12 = v19;
  if (v19 == v18)
  {
    v13 = 4;
    v12 = v18;
    goto LABEL_5;
  }
  if (v19)
  {
    v13 = 5;
LABEL_5:
    (*(void (**)(void))(*v12 + 8 * v13))();
  }
  _Block_object_dispose(v14, 8);

}

void ___ZN33AccelerationStructureViewerServer8Renderer14completeSampleEhN27AccelerationStructureViewer6SampleEdPU32objcproto21OS_dispatch_semaphore8NSObject_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  double Current;
  float v7;
  float v8;
  float v9;
  float v10;
  unsigned int v12;
  unsigned int v13;
  char *v15;
  unsigned int v16;
  char v17;
  _QWORD v18[72];
  _BYTE v19[24];
  _BYTE *v20;
  id v21;
  id v22;
  id v23;
  id v24;
  id v25;
  id v26;

  v2 = *(_QWORD *)(a1 + 696);
  if (!*(_QWORD *)(v2 + 16840))
  {
    AccelerationStructureViewerServer::Renderer::releaseUniformBufferIndex(*(_QWORD *)(a1 + 696), *(unsigned __int8 *)(a1 + 712), *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 688) + 8) + 40));
    return;
  }
  *(CFAbsoluteTime *)(v2 + 8 * (*(_QWORD *)(a1 + 40) & 0x1FLL) + 120) = CFAbsoluteTimeGetCurrent();
  v3 = *(_QWORD *)(v2 + 16840);
  AccelerationStructureViewer::Sample::Sample(v18, a1 + 32);
  (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v3 + 40))(v3, v2, v18);

  v4 = v20;
  if (v20 == v19)
  {
    v5 = 4;
    v4 = v19;
  }
  else
  {
    if (!v20)
      goto LABEL_8;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_8:
  std::mutex::lock((std::mutex *)(v2 + 48));
  Current = CFAbsoluteTimeGetCurrent();
  if (*(_BYTE *)(v2 + 16832))
    goto LABEL_29;
  v7 = Current - *(double *)(a1 + 704);
  v8 = 1.0 / v7;
  v9 = *(double *)(v2 + 16824);
  v10 = 1.0 / v9;
  if (v8 < 30.0 || v10 < 30.0)
  {
    v12 = *(unsigned __int8 *)(v2 + 16996);
    LOBYTE(v13) = 2 * v12;
    goto LABEL_21;
  }
  if (v8 > 180.0 && v10 > 180.0)
  {
    v12 = *(unsigned __int8 *)(v2 + 16996);
    v13 = v12 >> 1;
LABEL_21:
    v16 = *(_DWORD *)(v2 + 16992) + 1;
    *(_DWORD *)(v2 + 16992) = v16;
    v15 = (char *)(v2 + 16996);
    if (v16 <= 4 * v12)
    {
      LOBYTE(v13) = v12;
    }
    else
    {
      *(_BYTE *)(v2 + 16996) = v13;
      *(_DWORD *)(v2 + 16992) = 0;
    }
    goto LABEL_24;
  }
  LOBYTE(v13) = *(_BYTE *)(v2 + 16996);
  *(_DWORD *)(v2 + 16992) = 0;
  v15 = (char *)(v2 + 16996);
LABEL_24:
  if (v13 > 0x10u)
  {
    v17 = 16;
LABEL_28:
    *v15 = v17;
    goto LABEL_29;
  }
  if (v13 <= 7u)
  {
    v17 = 8;
    goto LABEL_28;
  }
LABEL_29:
  std::mutex::unlock((std::mutex *)(v2 + 48));
  AccelerationStructureViewerServer::Renderer::releaseUniformBufferIndex(v2, *(unsigned __int8 *)(a1 + 712), *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 688) + 8) + 40));
}

void std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewer::IntersectionFunctionTable>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewer::IntersectionFunctionTable>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewer::IntersectionFunctionTable>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewer::IntersectionFunctionTable>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewer::IntersectionFunctionTable>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewer::IntersectionFunctionTable>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewer::IntersectionFunctionTable>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewer::IntersectionFunctionTable>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewer::IntersectionFunctionTable>>>::destroy(a1[1]);

    operator delete(a1);
  }
}

void std::__tree<std::__value_type<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::unique_ptr<AccelerationStructureViewerServer::Intersector>>,std::__map_value_compare<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::__value_type<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::unique_ptr<AccelerationStructureViewerServer::Intersector>>,std::less<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>>,true>,std::allocator<std::__value_type<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::unique_ptr<AccelerationStructureViewerServer::Intersector>>>>::destroy(_QWORD *a1)
{
  id *v2;

  if (a1)
  {
    std::__tree<std::__value_type<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::unique_ptr<AccelerationStructureViewerServer::Intersector>>,std::__map_value_compare<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::__value_type<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::unique_ptr<AccelerationStructureViewerServer::Intersector>>,std::less<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>>,true>,std::allocator<std::__value_type<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::unique_ptr<AccelerationStructureViewerServer::Intersector>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::unique_ptr<AccelerationStructureViewerServer::Intersector>>,std::__map_value_compare<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::__value_type<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::unique_ptr<AccelerationStructureViewerServer::Intersector>>,std::less<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>>,true>,std::allocator<std::__value_type<std::pair<AccelerationStructureViewerServer::IntersectorType,AccelerationStructureViewer::IntersectionFunctionTable *>,std::unique_ptr<AccelerationStructureViewerServer::Intersector>>>>::destroy(a1[1]);
    v2 = (id *)a1[6];
    a1[6] = 0;
    if (v2)
      std::default_delete<AccelerationStructureViewerServer::Intersector>::operator()[abi:nn180100](v2);
    operator delete(a1);
  }
}

uint64_t *std::unique_ptr<AccelerationStructureViewerServer::Profiler>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t i;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void **v15;
  void **v16;
  _QWORD *v17;
  unint64_t v18;
  void **v19;
  void **v20;
  uint64_t v21;
  void *v22;
  void **v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  uint64_t j;
  std::unique_lock<std::mutex> v32;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v32.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v2 + 320);
    v32.__owns_ = 1;
    std::mutex::lock((std::mutex *)(v2 + 320));
    while (1)
    {
      if (!*(_BYTE *)(v2 + 432))
        goto LABEL_8;
      if (!*(_DWORD *)(v2 + 436))
        break;
      std::condition_variable::wait((std::condition_variable *)(v2 + 384), &v32);
    }
    AccelerationStructureViewerServer::Profiler::stopAPSStreaming(v2, *(void **)v2);
LABEL_8:
    for (i = 0; i != 24; i += 8)
    {
      v4 = *(void **)(v2 + i + 64);
      *(_QWORD *)(v2 + i + 64) = 0;

      v5 = *(void **)(v2 + i + 88);
      *(_QWORD *)(v2 + i + 88) = 0;

    }
    v6 = *(void **)(v2 + 16);
    *(_QWORD *)(v2 + 16) = 0;

    v7 = *(void **)(v2 + 48);
    *(_QWORD *)(v2 + 48) = 0;

    v8 = *(void **)(v2 + 40);
    *(_QWORD *)(v2 + 40) = 0;

    v9 = *(void **)v2;
    *(_QWORD *)v2 = 0;

    if (v32.__owns_)
      std::mutex::unlock(v32.__m_);

    std::__tree<std::__value_type<unsigned int,std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>>>>::destroy(*(_QWORD **)(v2 + 736));
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 + 688);
    std::mutex::~mutex((std::mutex *)(v2 + 624));
    v10 = *(void **)(v2 + 600);
    if (v10)
    {
      *(_QWORD *)(v2 + 608) = v10;
      operator delete(v10);
    }
    v11 = *(_QWORD *)(v2 + 576);
    if (v11)
    {
      v12 = *(_QWORD *)(v2 + 584);
      v13 = *(void **)(v2 + 576);
      if (v12 != v11)
      {
        do
          v12 = std::deque<AccelerationStructureViewerServer::APSRawChunk>::~deque[abi:nn180100](v12 - 48);
        while (v12 != v11);
        v13 = *(void **)(v2 + 576);
      }
      *(_QWORD *)(v2 + 584) = v11;
      operator delete(v13);
    }
    v32.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v2 + 552);
    std::vector<std::mutex>::__destroy_vector::operator()[abi:nn180100]((void ***)&v32);
    std::deque<AccelerationStructureViewerServer::APSRawChunk>::~deque[abi:nn180100](v2 + 504);
    std::mutex::~mutex((std::mutex *)(v2 + 440));
    std::condition_variable::~condition_variable((std::condition_variable *)(v2 + 384));
    std::mutex::~mutex((std::mutex *)(v2 + 320));
    v14 = *(void **)(v2 + 296);
    if (v14)
    {
      *(_QWORD *)(v2 + 304) = v14;
      operator delete(v14);
    }
    v32.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v2 + 272);
    std::vector<std::thread>::__destroy_vector::operator()[abi:nn180100]((void ***)&v32);
    v32.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v2 + 248);
    std::vector<std::thread>::__destroy_vector::operator()[abi:nn180100]((void ***)&v32);
    v15 = *(void ***)(v2 + 208);
    v16 = *(void ***)(v2 + 216);
    if (v16 == v15)
    {
      v17 = (_QWORD *)(v2 + 240);
      v16 = *(void ***)(v2 + 208);
    }
    else
    {
      v17 = (_QWORD *)(v2 + 240);
      v18 = *(_QWORD *)(v2 + 232);
      v19 = &v15[v18 >> 9];
      v20 = (void **)((char *)*v19 + 8 * (v18 & 0x1FF));
      v21 = *(uint64_t *)((char *)v15 + (((*(_QWORD *)(v2 + 240) + v18) >> 6) & 0x3FFFFFFFFFFFFF8))
          + 8 * ((*(_QWORD *)(v2 + 240) + v18) & 0x1FF);
      if (v20 != (void **)v21)
      {
        do
        {
          v22 = *v20++;

          if ((char *)v20 - (_BYTE *)*v19 == 4096)
          {
            v23 = (void **)v19[1];
            ++v19;
            v20 = v23;
          }
        }
        while (v20 != (void **)v21);
        v15 = *(void ***)(v2 + 208);
        v16 = *(void ***)(v2 + 216);
      }
    }
    *v17 = 0;
    v24 = (char *)v16 - (char *)v15;
    if ((unint64_t)((char *)v16 - (char *)v15) >= 0x11)
    {
      do
      {
        operator delete(*v15);
        v16 = *(void ***)(v2 + 216);
        v15 = (void **)(*(_QWORD *)(v2 + 208) + 8);
        *(_QWORD *)(v2 + 208) = v15;
        v24 = (char *)v16 - (char *)v15;
      }
      while ((unint64_t)((char *)v16 - (char *)v15) > 0x10);
    }
    v25 = v24 >> 3;
    if (v25 == 1)
    {
      v26 = 256;
    }
    else
    {
      if (v25 != 2)
      {
LABEL_35:
        if (v15 != v16)
        {
          do
          {
            v27 = *v15++;
            operator delete(v27);
          }
          while (v15 != v16);
          v29 = *(_QWORD *)(v2 + 208);
          v28 = *(_QWORD *)(v2 + 216);
          if (v28 != v29)
            *(_QWORD *)(v2 + 216) = v28 + ((v29 - v28 + 7) & 0xFFFFFFFFFFFFFFF8);
        }
        v30 = *(void **)(v2 + 200);
        if (v30)
          operator delete(v30);
        std::mutex::~mutex((std::mutex *)(v2 + 136));
        for (j = 128; j != 104; j -= 8)

        do
        {

          j -= 8;
        }
        while (j != 80);
        do
        {

          j -= 8;
        }
        while (j != 56);

        operator delete();
      }
      v26 = 512;
    }
    *(_QWORD *)(v2 + 232) = v26;
    goto LABEL_35;
  }
  return result;
}

void ___ZN33AccelerationStructureViewerServer8Renderer13setDataSourceEPNS_10DataSourceEPU35objcproto24MTLAccelerationStructure11objc_objectP7NSArrayIS4_EPU15__autoreleasingP7NSError_block_invoke(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t **v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  id v11;
  uint64_t *v12;
  uint64_t **v13;
  uint64_t **v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t *v18;
  id v19;
  __int128 v21;

  v19 = a3;
  v4 = *a2;
  if (*a2 != a2[1])
  {
    v5 = *(_QWORD *)(a1 + 40);
    v6 = (_QWORD *)(v5 + 17016);
    v7 = (uint64_t **)(v5 + 17640);
    do
    {
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v9 = *(_QWORD *)(v8 + 24);
      if (v9 <= *(_QWORD *)(v4 + 24))
        v9 = *(_QWORD *)(v4 + 24);
      *(_QWORD *)(v8 + 24) = v9;
      v10 = *(_QWORD *)(v4 + 16);
      v11 = *(id *)(v4 + 8);
      v21 = *(_OWORD *)(v4 + 16);
      v12 = *v7;
      v13 = (uint64_t **)(v5 + 17640);
      v14 = (uint64_t **)(v5 + 17640);
      if (*v7)
      {
        while (1)
        {
          while (1)
          {
            v14 = (uint64_t **)v12;
            v15 = v12[4];
            if (v10 >= v15)
              break;
            v12 = *v14;
            v13 = v14;
            if (!*v14)
              goto LABEL_12;
          }
          if (v15 >= v10)
            break;
          v12 = v14[1];
          if (!v12)
          {
            v13 = v14 + 1;
            goto LABEL_12;
          }
        }
      }
      else
      {
LABEL_12:
        v16 = (char *)operator new(0x48uLL);
        *((_QWORD *)v16 + 4) = v10;
        *((_QWORD *)v16 + 5) = off_7274E0;
        *((_QWORD *)v16 + 6) = v11;
        *(_OWORD *)(v16 + 56) = v21;
        *(_QWORD *)v16 = 0;
        *((_QWORD *)v16 + 1) = 0;
        *((_QWORD *)v16 + 2) = v14;
        *v13 = (uint64_t *)v16;
        v17 = **(_QWORD **)(v5 + 17632);
        if (v17)
        {
          *(_QWORD *)(v5 + 17632) = v17;
          v18 = *v13;
        }
        else
        {
          v18 = (uint64_t *)v16;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v5 + 17640), v18);
        v11 = 0;
        ++*(_QWORD *)(v5 + 17648);
      }

      if (!*(_DWORD *)v6 && !*(_DWORD *)(v5 + 17020))
        *v6 = *(_QWORD *)(v4 + 16);
      v4 += 32;
    }
    while (v4 != a2[1]);
  }

}

BOOL writeAccelerationStructureToGBVH5Path(uint64_t a1, char *a2, uint64_t a3, void *a4, uint64_t a5)
{
  id v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  __int128 v15;
  _BYTE *v16;
  _BYTE *v17;
  int64_t v18;
  char *v19;
  char *v20;
  uint64_t v21;
  char *v22;
  char *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  uint64_t v28;
  size_t v29;
  _DWORD *v30;
  void *v31;
  unint64_t v32;
  char *v33;
  _DWORD *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  char *v39;
  void *v40;
  uint64_t v41;
  char *v42;
  void *v43;
  uint64_t v44;
  char *v45;
  void *v46;
  uint64_t v47;
  char *v48;
  void *v49;
  uint64_t v50;
  char *v51;
  void *v52;
  uint64_t v53;
  char *v54;
  void *v55;
  uint64_t v56;
  char *v57;
  void *v58;
  id v59;
  unint64_t v60;
  void *v61;
  double v62;
  void *v63;
  uint8x8_t v64;
  uint64_t v65;
  int v66;
  char v67;
  int16x8_t v68;
  int8x8_t v69;
  unsigned int v70;
  unsigned int v71;
  int v72;
  int v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  void *v78;
  void *v79;
  unsigned int v81;
  unint64_t v82;
  uint64_t v83;
  size_t v84;
  id v87;
  uint64_t v88;
  uint64_t v89;
  void *v90;
  void **v91;
  _BYTE v92[58];
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  uint64_t v115;
  int v116;
  char v117;
  int v118;
  char v119;
  uint64_t v120;
  float v121;
  float v122;
  _QWORD v123[4];
  id v124;
  unint64_t v125;
  uint64_t v126;
  _QWORD v127[5];
  uint64_t v128;
  uint64_t *v129;
  uint64_t v130;
  int v131;
  int v132;
  char *v133;
  char *v134;
  char *v135;
  _DWORD __dst[65];

  v7 = a4;
  NSLog(CFSTR("Writing GBVH to %@"), v7);
  v134 = 0;
  v133 = 0;
  v135 = 0;
  v8 = *(_QWORD *)(a1 + 192);
  v88 = a1;
  v89 = *(_QWORD *)(a1 + 184);
  v87 = v7;
  if (v8 == v89)
  {
    v22 = 0;
    v23 = 0;
  }
  else
  {
    v83 = a5;
    v9 = 0xD37A6F4DE9BD37A7 * ((v8 - v89) >> 3);
    if (v9 >= 0x1642C8590B21643)
LABEL_30:
      abort();
    v10 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewerServer::AccelerationStructure>>(v9);
    v11 = 0;
    v133 = v10;
    v134 = v10;
    v135 = &v10[184 * v12];
    do
    {
      v13 = v89 + v11;
      v14 = &v10[v11];
      *(_QWORD *)v14 = *(id *)(v89 + v11);
      *(_OWORD *)(v14 + 8) = *(_OWORD *)(v89 + v11 + 8);
      *((_QWORD *)v14 + 3) = *(id *)(v89 + v11 + 24);
      *((_QWORD *)v14 + 4) = *(_QWORD *)(v89 + v11 + 32);
      *((_QWORD *)v14 + 5) = *(id *)(v89 + v11 + 40);
      *((_QWORD *)v14 + 6) = *(_QWORD *)(v89 + v11 + 48);
      *((_QWORD *)v14 + 7) = *(id *)(v89 + v11 + 56);
      *((_QWORD *)v14 + 8) = *(_QWORD *)(v89 + v11 + 64);
      *((_QWORD *)v14 + 9) = *(id *)(v89 + v11 + 72);
      *((_QWORD *)v14 + 10) = *(_QWORD *)(v89 + v11 + 80);
      *((_QWORD *)v14 + 11) = *(id *)(v89 + v11 + 88);
      *((_QWORD *)v14 + 12) = *(_QWORD *)(v89 + v11 + 96);
      *((_QWORD *)v14 + 13) = *(id *)(v89 + v11 + 104);
      v15 = *(_OWORD *)(v89 + v11 + 112);
      *((_QWORD *)v14 + 16) = 0;
      *((_OWORD *)v14 + 7) = v15;
      *((_QWORD *)v14 + 17) = 0;
      *((_QWORD *)v14 + 18) = 0;
      v17 = *(_BYTE **)(v89 + v11 + 128);
      v16 = *(_BYTE **)(v89 + v11 + 136);
      v18 = v16 - v17;
      if (v16 != v17)
      {
        if (v16 - v17 < 0)
          goto LABEL_30;
        v19 = &v10[v11];
        v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v18 >> 3);
        *((_QWORD *)v14 + 16) = v20;
        *((_QWORD *)v19 + 17) = v20;
        *((_QWORD *)v19 + 18) = &v20[8 * v21];
        memmove(v20, v17, v18);
        *((_QWORD *)v19 + 17) = &v20[v18];
      }
      *((_QWORD *)v14 + 19) = *(id *)(v13 + 152);
      *((_QWORD *)v14 + 20) = *(_QWORD *)(v13 + 160);
      *((_QWORD *)v14 + 21) = *(id *)(v13 + 168);
      v14[176] = *(_BYTE *)(v13 + 176);
      v11 += 184;
    }
    while (v13 + 184 != v8);
    v22 = v10;
    v23 = &v10[v11];
    v134 = v23;
    v7 = v87;
    a5 = v83;
  }
  v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:](NSURL, "fileURLWithPath:", v7));
  v132 = 259;
  v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &v132, 4));
  v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:](NSURL, "fileURLWithPath:", v7));
  objc_msgSend(v25, "writeToURL:atomically:", v26, 0);

  v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileHandle fileHandleForWritingToURL:error:](NSFileHandle, "fileHandleForWritingToURL:error:", v24, a5));
  if (v27)
  {
    v90 = v24;
    v128 = 0;
    v129 = &v128;
    v130 = 0x2020000000;
    v131 = 0;
    v127[0] = _NSConcreteStackBlock;
    v127[1] = 3221225472;
    v127[2] = ___Z37writeAccelerationStructureToGBVH5PathPN33AccelerationStructureViewerServer10DataSourceEP18ASVCameraTransformP18ASVSRenderSettingsP8NSStringPU15__autoreleasingP7NSError_block_invoke;
    v127[3] = &unk_727380;
    v127[4] = &v128;
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v88 + 16))(v88, v127);
    v28 = 16;
    if (a2 != 0 && a3 != 0)
      v28 = 28;
    v29 = v28 + 0xFFFFFFFE42C8590CLL * ((v23 - v22) >> 3) + 24 * *((unsigned int *)v129 + 6);
    v30 = malloc_type_malloc(v29, 0x87136C1BuLL);
    *v30 = 5;
    v30[1] = -373475417 * ((v23 - v22) >> 3);
    v30[2] = *((_DWORD *)v129 + 6);
    v30[3] = a2 != 0 && a3 != 0;
    v81 = *((_DWORD *)v129 + 6);
    v82 = (unint64_t)&v30[-1867377085 * ((v23 - v22) >> 3) + 4];
    objc_msgSend(v27, "seekToFileOffset:", 0);
    v84 = v29;
    v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", v30, v29));
    objc_msgSend(v27, "writeData:", v31);

    objc_msgSend(v27, "offsetInFile");
    if (v30[1])
    {
      v32 = 0;
      v33 = v22 + 80;
      v34 = v30 + 8;
      do
      {
        objc_msgSend(objc_retainAutorelease(*((id *)v33 - 7)), "contents");
        NSLog(CFSTR("\tWriting AccelerationStructure 0x%llx to offset 0x%llx"), *((_QWORD *)v33 - 8), objc_msgSend(v27, "offsetInFile"));
        v91 = (void **)((char *)objc_msgSend(*((id *)v33 - 7), "length") - *((_QWORD *)v33 - 6));
        *(_QWORD *)v92 = (char *)objc_msgSend(*((id *)v33 - 5), "length") - *((_QWORD *)v33 - 4);
        *(_QWORD *)&v92[8] = (char *)objc_msgSend(*((id *)v33 - 3), "length") - *((_QWORD *)v33 - 2);
        *(_QWORD *)&v92[16] = (char *)objc_msgSend(*((id *)v33 - 1), "length") - *(_QWORD *)v33;
        *(_QWORD *)&v92[24] = (char *)objc_msgSend(*((id *)v33 + 1), "length") - *((_QWORD *)v33 + 2);
        *(_QWORD *)&v92[32] = (char *)objc_msgSend(*((id *)v33 + 9), "length") - *((_QWORD *)v33 + 10);
        *(_QWORD *)&v92[40] = *((_QWORD *)v33 + 5);
        NSLog(CFSTR("\t\theaderBufferSize: 0x%llx"), v91);
        NSLog(CFSTR("\t\tinnerNodeBufferSize: 0x%llx"), *(_QWORD *)v92);
        NSLog(CFSTR("\t\tleafNodeBufferSize: 0x%llx"), *(_QWORD *)&v92[8]);
        NSLog(CFSTR("\t\tprimitiveBufferSize: 0x%llx"), *(_QWORD *)&v92[16]);
        NSLog(CFSTR("\t\tgeometryBufferSize: 0x%llx"), *(_QWORD *)&v92[24]);
        NSLog(CFSTR("\t\tinstanceBufferSize: 0x%llx"), *(_QWORD *)&v92[32]);
        NSLog(CFSTR("\t\tperPrimitiveDataBufferSize: 0x%llx"), *(_QWORD *)&v92[40]);
        *((_QWORD *)v34 - 2) = objc_msgSend(v27, "offsetInFile");
        *((_QWORD *)v34 - 1) = *((_QWORD *)v33 - 8);
        v35 = (void *)*((_QWORD *)v33 - 10);
        if (v35)
        {
          v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "dataUsingEncoding:", 30));
          *v34 = objc_msgSend(v36, "length");
          objc_msgSend(v27, "writeData:", v36);

        }
        else
        {
          *v34 = 0;
        }
        v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &v91, 56));
        objc_msgSend(v27, "writeData:", v37);

        v38 = *((_QWORD *)v33 - 6);
        v39 = (char *)objc_msgSend(objc_retainAutorelease(*((id *)v33 - 7)), "contents");
        v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &v39[v38], v91));
        objc_msgSend(v27, "writeData:", v40);

        v41 = *((_QWORD *)v33 - 4);
        v42 = (char *)objc_msgSend(objc_retainAutorelease(*((id *)v33 - 5)), "contents");
        v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &v42[v41], *(_QWORD *)v92));
        objc_msgSend(v27, "writeData:", v43);

        v44 = *((_QWORD *)v33 - 2);
        v45 = (char *)objc_msgSend(objc_retainAutorelease(*((id *)v33 - 3)), "contents");
        v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &v45[v44], *(_QWORD *)&v92[8]));
        objc_msgSend(v27, "writeData:", v46);

        v47 = *(_QWORD *)v33;
        v48 = (char *)objc_msgSend(objc_retainAutorelease(*((id *)v33 - 1)), "contents");
        v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &v48[v47], *(_QWORD *)&v92[16]));
        objc_msgSend(v27, "writeData:", v49);

        v50 = *((_QWORD *)v33 + 2);
        v51 = (char *)objc_msgSend(objc_retainAutorelease(*((id *)v33 + 1)), "contents");
        v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &v51[v50], *(_QWORD *)&v92[24]));
        objc_msgSend(v27, "writeData:", v52);

        v53 = *((_QWORD *)v33 + 10);
        v54 = (char *)objc_msgSend(objc_retainAutorelease(*((id *)v33 + 9)), "contents");
        v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &v54[v53], *(_QWORD *)&v92[32]));
        objc_msgSend(v27, "writeData:", v55);

        v56 = *((_QWORD *)v33 + 4);
        v57 = (char *)objc_msgSend(objc_retainAutorelease(*((id *)v33 + 3)), "contents");
        v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &v57[v56], *(_QWORD *)&v92[40]));
        objc_msgSend(v27, "writeData:", v58);

        ++v32;
        v33 += 184;
        v34 += 5;
      }
      while (v32 < v30[1]);
    }
    v123[0] = _NSConcreteStackBlock;
    v123[1] = 3221225472;
    v123[2] = ___Z37writeAccelerationStructureToGBVH5PathPN33AccelerationStructureViewerServer10DataSourceEP18ASVCameraTransformP18ASVSRenderSettingsP8NSStringPU15__autoreleasingP7NSError_block_invoke_2;
    v123[3] = &unk_7273A8;
    v125 = v82;
    v59 = v27;
    v124 = v59;
    v126 = v88;
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v88 + 16))(v88, v123);
    if (a2 != 0 && a3 != 0)
    {
      v60 = v82 + 24 * v81;
      *(_QWORD *)v60 = objc_msgSend(v59, "offsetInFile");
      v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(CFSTR("default"), "dataUsingEncoding:", 30));
      *(_DWORD *)(v60 + 8) = objc_msgSend(v61, "length");
      objc_msgSend(v59, "writeData:", v61);

      v118 = *((_DWORD *)a2 + 1);
      v119 = *a2;
      v120 = *((_QWORD *)a2 + 1);
      float2matrix(&v121, (simd_float4x4 *)(a2 + 16));
      *(float *)&v62 = float2matrix(&v122, (simd_float4x4 *)(a2 + 80));
      v63 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &v117, 142, v62));
      objc_msgSend(v59, "writeData:", v63);

      BYTE1(v91) = *(_BYTE *)(a3 + 32);
      v65 = *(_QWORD *)(a3 + 24);
      v66 = *(unsigned __int8 *)(a3 + 38);
      if (v66 == 2)
        v67 = 2;
      else
        v67 = v66 == 1;
      BYTE2(v91) = *(_BYTE *)(a3 + 33) == 1;
      v64.i32[0] = *(_DWORD *)(a3 + 34);
      v68 = (int16x8_t)vmovl_u8(v64);
      v69 = (int8x8_t)vceq_s16(*(int16x4_t *)v68.i8, (int16x4_t)0x1000100010001);
      *(int16x4_t *)v68.i8 = vceq_s16(*(int16x4_t *)v68.i8, (int16x4_t)0x2000200020002);
      *(int16x4_t *)v68.i8 = vsub_s16((int16x4_t)vand_s8(*(int8x8_t *)v68.i8, (int8x8_t)0x2000200020002), (int16x4_t)vbic_s8(v69, *(int8x8_t *)v68.i8));
      *(_DWORD *)((char *)&v91 + 3) = vmovn_s16(v68).u32[0];
      HIBYTE(v91) = v67;
      *(_WORD *)v92 = *(_WORD *)(a3 + 39);
      *(_QWORD *)&v92[2] = v65;
      v92[10] = *(_BYTE *)(a3 + 41);
      *(_QWORD *)&v92[11] = *(_QWORD *)(a3 + 44);
      v92[19] = *(_BYTE *)(a3 + 42);
      v70 = *(unsigned __int8 *)(a3 + 52);
      if (v70 >= 7)
        LOBYTE(v70) = 0;
      v92[20] = v70;
      v71 = *(unsigned __int8 *)(a3 + 53);
      if (v71 >= 7)
        LOBYTE(v71) = 0;
      v92[21] = v71;
      v72 = *(_DWORD *)(a3 + 56);
      memcpy(__dst, (const void *)(a3 + 60), sizeof(__dst));
      v73 = *(_DWORD *)(a3 + 456);
      *(_DWORD *)&v92[22] = v72;
      v105 = *(_OWORD *)&__dst[57];
      v106 = *(_OWORD *)&__dst[61];
      v103 = *(_OWORD *)&__dst[49];
      v104 = *(_OWORD *)&__dst[53];
      v99 = *(_OWORD *)&__dst[33];
      v100 = *(_OWORD *)&__dst[37];
      v101 = *(_OWORD *)&__dst[41];
      v102 = *(_OWORD *)&__dst[45];
      v95 = *(_OWORD *)&__dst[17];
      v96 = *(_OWORD *)&__dst[21];
      v97 = *(_OWORD *)&__dst[25];
      v98 = *(_OWORD *)&__dst[29];
      *(_OWORD *)&v92[26] = *(_OWORD *)&__dst[1];
      *(_OWORD *)&v92[42] = *(_OWORD *)&__dst[5];
      v93 = *(_OWORD *)&__dst[9];
      v94 = *(_OWORD *)&__dst[13];
      v74 = *(_OWORD *)(a3 + 400);
      v111 = *(_OWORD *)(a3 + 384);
      v112 = v74;
      v75 = *(_OWORD *)(a3 + 432);
      v113 = *(_OWORD *)(a3 + 416);
      v114 = v75;
      v76 = *(_OWORD *)(a3 + 336);
      v107 = *(_OWORD *)(a3 + 320);
      v108 = v76;
      v77 = *(_OWORD *)(a3 + 368);
      v109 = *(_OWORD *)(a3 + 352);
      v110 = v77;
      v115 = *(_QWORD *)(a3 + 448);
      v116 = v73;
      v78 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &v91, 430));
      objc_msgSend(v59, "writeData:", v78);

    }
    objc_msgSend(v59, "seekToFileOffset:", 0);
    v79 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", v30, v84));
    objc_msgSend(v59, "writeData:", v79);

    free(v30);
    objc_msgSend(v59, "closeFile");

    _Block_object_dispose(&v128, 8);
    v7 = v87;
    v24 = v90;
  }

  v91 = (void **)&v133;
  std::vector<AccelerationStructureViewerServer::AccelerationStructure>::__destroy_vector::operator()[abi:nn180100](&v91);

  return v27 != 0;
}

uint64_t ___Z37writeAccelerationStructureToGBVH5PathPN33AccelerationStructureViewerServer10DataSourceEP18ASVCameraTransformP18ASVSRenderSettingsP8NSStringPU15__autoreleasingP7NSError_block_invoke(uint64_t result, _QWORD *a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = (a2[1] - *a2) >> 5;
  return result;
}

float float2matrix(float *a1, simd_float4x4 *a2)
{
  simd_float4 v2;
  simd_float4 v3;
  simd_float4 v4;
  simd_float4 v5;
  float result;

  v2 = a2->columns[0];
  v3 = a2->columns[1];
  v2.f32[0] = *a1;
  a2->columns[0].f32[0] = *a1;
  v2.f32[1] = a1[1];
  a2->columns[0] = v2;
  v2.f32[2] = a1[2];
  a2->columns[0] = v2;
  v2.f32[3] = a1[3];
  a2->columns[0] = v2;
  v3.f32[0] = a1[4];
  a2->columns[1].i32[0] = v3.i32[0];
  v3.f32[1] = a1[5];
  a2->columns[1] = v3;
  v3.f32[2] = a1[6];
  a2->columns[1] = v3;
  v3.f32[3] = a1[7];
  a2->columns[1] = v3;
  v4 = a2->columns[2];
  v5 = a2->columns[3];
  v4.f32[0] = a1[8];
  a2->columns[2].i32[0] = v4.i32[0];
  v4.f32[1] = a1[9];
  a2->columns[2] = v4;
  v4.f32[2] = a1[10];
  a2->columns[2] = v4;
  v4.f32[3] = a1[11];
  a2->columns[2] = v4;
  result = a1[12];
  v5.f32[0] = result;
  a2->columns[3].f32[0] = result;
  v5.f32[1] = a1[13];
  a2->columns[3] = v5;
  v5.f32[2] = a1[14];
  a2->columns[3] = v5;
  v5.f32[3] = a1[15];
  a2->columns[3] = v5;
  return result;
}

void std::vector<AccelerationStructureViewerServer::AccelerationStructure>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  id *v2;
  id *v4;
  void *v5;

  v1 = *a1;
  v2 = (id *)**a1;
  if (v2)
  {
    v4 = (id *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        AccelerationStructureViewerServer::AccelerationStructure::~AccelerationStructure(v4 - 23);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t _ZNSt3__110__function6__funcIZZ37writeAccelerationStructureToGBVH5PathPN33AccelerationStructureViewerServer10DataSourceEP18ASVCameraTransformP18ASVSRenderSettingsP8NSStringPU15__autoreleasingP7NSErrorEUb_E3__0NS_9allocatorISF_EEFvmbPU22objcproto11MTLFunction11objc_objectPN27AccelerationStructureViewer20IntersectionFunctionEEED1Ev(uint64_t a1)
{

  return a1;
}

void _ZNSt3__110__function6__funcIZZ37writeAccelerationStructureToGBVH5PathPN33AccelerationStructureViewerServer10DataSourceEP18ASVCameraTransformP18ASVSRenderSettingsP8NSStringPU15__autoreleasingP7NSErrorEUb_E3__0NS_9allocatorISF_EEFvmbPU22objcproto11MTLFunction11objc_objectPN27AccelerationStructureViewer20IntersectionFunctionEEED0Ev(uint64_t a1)
{

  operator delete();
}

_QWORD *_ZNKSt3__110__function6__funcIZZ37writeAccelerationStructureToGBVH5PathPN33AccelerationStructureViewerServer10DataSourceEP18ASVCameraTransformP18ASVSRenderSettingsP8NSStringPU15__autoreleasingP7NSErrorEUb_E3__0NS_9allocatorISF_EEFvmbPU22objcproto11MTLFunction11objc_objectPN27AccelerationStructureViewer20IntersectionFunctionEEE7__cloneEv(uint64_t a1)
{
  _QWORD *v2;

  v2 = operator new(0x10uLL);
  *v2 = off_7273D8;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id _ZNKSt3__110__function6__funcIZZ37writeAccelerationStructureToGBVH5PathPN33AccelerationStructureViewerServer10DataSourceEP18ASVCameraTransformP18ASVSRenderSettingsP8NSStringPU15__autoreleasingP7NSErrorEUb_E3__0NS_9allocatorISF_EEFvmbPU22objcproto11MTLFunction11objc_objectPN27AccelerationStructureViewer20IntersectionFunctionEEE7__cloneEPNS0_6__baseISN_EE(uint64_t a1, _QWORD *a2)
{
  id result;

  *a2 = off_7273D8;
  result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void _ZNSt3__110__function6__funcIZZ37writeAccelerationStructureToGBVH5PathPN33AccelerationStructureViewerServer10DataSourceEP18ASVCameraTransformP18ASVSRenderSettingsP8NSStringPU15__autoreleasingP7NSErrorEUb_E3__0NS_9allocatorISF_EEFvmbPU22objcproto11MTLFunction11objc_objectPN27AccelerationStructureViewer20IntersectionFunctionEEE7destroyEv(uint64_t a1)
{

}

void _ZNSt3__110__function6__funcIZZ37writeAccelerationStructureToGBVH5PathPN33AccelerationStructureViewerServer10DataSourceEP18ASVCameraTransformP18ASVSRenderSettingsP8NSStringPU15__autoreleasingP7NSErrorEUb_E3__0NS_9allocatorISF_EEFvmbPU22objcproto11MTLFunction11objc_objectPN27AccelerationStructureViewer20IntersectionFunctionEEE18destroy_deallocateEv(id *a1)
{

  operator delete(a1);
}

void _ZNSt3__110__function6__funcIZZ37writeAccelerationStructureToGBVH5PathPN33AccelerationStructureViewerServer10DataSourceEP18ASVCameraTransformP18ASVSRenderSettingsP8NSStringPU15__autoreleasingP7NSErrorEUb_E3__0NS_9allocatorISF_EEFvmbPU22objcproto11MTLFunction11objc_objectPN27AccelerationStructureViewer20IntersectionFunctionEEEclEOmObOU8__strongSJ_OSM_(uint64_t a1, uint64_t a2, uint64_t a3, id *a4, uint64_t *a5)
{
  uint64_t v6;
  id v7;
  id v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  unsigned int v20;
  uint64_t v21;
  char v22;
  __int16 v23;
  int v24;
  int i;
  unsigned int v26;

  v6 = *a5;
  v7 = *a4;
  v21 = *(_QWORD *)(v6 + 48);
  v22 = *(_BYTE *)(v6 + 72);
  v23 = *(_WORD *)(v6 + 73);
  v24 = *(_DWORD *)(v6 + 76);
  v8 = objc_msgSend(*(id *)(a1 + 8), "offsetInFile");
  v9 = *(void **)(a1 + 8);
  v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &v20, 27));
  objc_msgSend(v9, "writeData:", v10);

  v11 = *(void **)(v6 + 32);
  if (v11)
  {
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "dataUsingEncoding:", 30));
    v20 = objc_msgSend(v12, "length");
    objc_msgSend(*(id *)(a1 + 8), "writeData:", v12);

  }
  else
  {
    v20 = 0;
  }
  v13 = *(_QWORD *)(v6 + 80);
  v14 = *(_QWORD *)(v6 + 88);
  for (i = (unint64_t)(v14 - v13) >> 2; v13 != v14; v13 += 4)
  {
    v15 = *(void **)(a1 + 8);
    v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", v13, 4));
    objc_msgSend(v15, "writeData:", v16);

  }
  if (v7)
  {
    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "bitcodeData"));
    v26 = objc_msgSend(v17, "length");
    objc_msgSend(*(id *)(a1 + 8), "writeData:", v17);

  }
  else
  {
    v26 = 0;
  }
  objc_msgSend(*(id *)(a1 + 8), "offsetInFile");
  objc_msgSend(*(id *)(a1 + 8), "seekToFileOffset:", v8);
  v18 = *(void **)(a1 + 8);
  v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &v20, 27));
  objc_msgSend(v18, "writeData:", v19);

  objc_msgSend(*(id *)(a1 + 8), "seekToEndOfFile");
}

void AccelerationStructureViewerServer::DataSource::getIntersectionFunctionTables(uint64_t a1, void (**a2)(_QWORD, _QWORD, _QWORD))
{
  void (**v3)(_QWORD, _QWORD, _QWORD);
  void *v4;
  _QWORD v5[3];
  _QWORD v6[3];
  void **v7;

  memset(v6, 0, sizeof(v6));
  memset(v5, 0, sizeof(v5));
  v3 = a2;
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("ASV"), 4, 0));
  ((void (**)(_QWORD, _QWORD *, void *))a2)[2](v3, v5, v4);

  v7 = (void **)v5;
  std::vector<AccelerationStructureViewer::IntersectionFunctionTable>::__destroy_vector::operator()[abi:nn180100](&v7);
  v7 = (void **)v6;
  std::vector<AccelerationStructureViewer::IntersectionFunctionTable>::__destroy_vector::operator()[abi:nn180100](&v7);
}

void AccelerationStructureViewerServer::DataSource::getIntersectionFunctions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void (**a6)(_QWORD, _QWORD, _QWORD))
{
  void (**v7)(_QWORD, _QWORD, _QWORD);
  void *v8;
  uint64_t v9;
  void **v10;

  v7 = a6;
  v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("ASV"), 4, 0, 0, 0, 0));
  ((void (**)(_QWORD, uint64_t *, void *))a6)[2](v7, &v9, v8);

  v10 = (void **)&v9;
  std::vector<AccelerationStructureViewer::IntersectionFunction>::__destroy_vector::operator()[abi:nn180100](&v10);
}

void AccelerationStructureViewerServer::DataSource::getPrimaryAccelerationStructure(uint64_t a1, void *a2)
{
  void (**v3)(id, id *, _QWORD);
  AccelerationStructureViewerServer::AccelerationStructure *v4;
  id v5[8];
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = a2;
  v4 = (AccelerationStructureViewerServer::AccelerationStructure *)(*(_QWORD *)(a1 + 184)
                                                                  + 184 * *(unsigned int *)(a1 + 176));
  switch(*((_DWORD *)v4 + 2))
  {
    case 0:
      v8 = 0;
      v9 = 0;
      v7 = 0;
      v5[0] = off_724300;
      memset(&v5[1], 0, 40);
      v6 = 0;
      v5[6] = CFSTR("Invalid Acceleration Structure");
      v3[2](v3, v5, 0);
      AccelerationStructureViewer::InstanceAccelerationStructure::~InstanceAccelerationStructure(v5);
      break;
    case 1:
      operator new();
    case 2:
      asvsAS2iasv(v4);
    case 3:
      asvsAS2pmasv(v4);
    case 4:
      operator new();
    default:
      break;
  }

}

void AccelerationStructureViewerServer::DataSource::getGeometryChildren(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, AccelerationStructureViewer::Filter *a5, void *a6)
{
  void (**v11)(id, void **, _QWORD);
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  BOOL v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  char *v32;
  int64_t v33;
  void *__p;
  char *v36;
  unint64_t v37;

  v11 = a6;
  v14 = *(_QWORD **)(a1 + 40);
  v13 = (_QWORD *)(a1 + 40);
  v12 = v14;
  if (!v14)
    goto LABEL_12;
  v15 = v13;
  do
  {
    v16 = v12[4];
    v17 = v16 >= a2;
    if (v16 >= a2)
      v18 = v12;
    else
      v18 = v12 + 1;
    if (v17)
      v15 = v12;
    v12 = (_QWORD *)*v18;
  }
  while (*v18);
  if (v15 != v13 && v15[4] <= a2)
  {
    __p = 0;
    v36 = 0;
    v37 = 0;
    v20 = v15[5];
    v21 = v15[6];
    if (v20 == v21)
    {
      v22 = 0;
    }
    else
    {
      v22 = 0;
      do
      {
        if (AccelerationStructureViewer::DataSourceFilterable::matches((AccelerationStructureViewer::DataSourceFilterable *)(*(_QWORD *)v20 + 8), a5))
        {
          if ((unint64_t)v22 >= v37)
          {
            v24 = (char *)__p;
            v25 = (v22 - (_BYTE *)__p) >> 3;
            v26 = v25 + 1;
            if ((unint64_t)(v25 + 1) >> 61)
              abort();
            v27 = v37 - (_QWORD)__p;
            if ((uint64_t)(v37 - (_QWORD)__p) >> 2 > v26)
              v26 = v27 >> 2;
            if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8)
              v28 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v28 = v26;
            if (v28)
              v28 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v28);
            else
              v29 = 0;
            v30 = (char *)(v28 + 8 * v25);
            *(_QWORD *)v30 = *(_QWORD *)v20;
            v23 = v30 + 8;
            if (v22 != v24)
            {
              do
              {
                v31 = *((_QWORD *)v22 - 1);
                v22 -= 8;
                *((_QWORD *)v30 - 1) = v31;
                v30 -= 8;
              }
              while (v22 != v24);
              v22 = (char *)__p;
            }
            __p = v30;
            v37 = v28 + 8 * v29;
            if (v22)
              operator delete(v22);
          }
          else
          {
            *(_QWORD *)v22 = *(_QWORD *)v20;
            v23 = v22 + 8;
          }
          v36 = v23;
          v22 = v23;
        }
        v20 += 8;
      }
      while (v20 != v21);
    }
    if (a3)
    {
      v32 = (char *)__p + 8 * a3;
      v33 = v22 - v32;
      if (v22 != v32)
        memmove(__p, v32, v22 - v32);
      v22 = (char *)__p + v33;
      v36 = (char *)__p + v33;
    }
    if (a4 < (v22 - (_BYTE *)__p) >> 3 && (char *)__p + 8 * a4 != v22)
      v36 = (char *)__p + 8 * a4;
    v11[2](v11, &__p, 0);
  }
  else
  {
LABEL_12:
    __p = 0;
    v36 = 0;
    v37 = 0;
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[ASVError errorWithCode:localizedDescription:](ASVError, "errorWithCode:localizedDescription:", 4, CFSTR("Invalid acceleration structure")));
    ((void (**)(id, void **, void *))v11)[2](v11, &__p, v19);

  }
  if (__p)
  {
    v36 = (char *)__p;
    operator delete(__p);
  }

}

void AccelerationStructureViewerServer::DataSource::getPrimitiveChildren(_QWORD *a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  void (**v11)(id, void **, void *);
  _QWORD *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  int8x8_t v18;
  uint8x8_t v19;
  unint64_t v20;
  _QWORD *i;
  unint64_t v22;
  int8x8_t v23;
  uint8x8_t v24;
  unint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  unint64_t v28;
  void *v29;
  void *v30;
  uint64_t v31;
  int v32;
  char *v33;
  void *__p;
  void *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  uint64_t v39;

  v11 = a7;
  v12 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(a1 + 17, a2);
  if (!v12)
    goto LABEL_36;
  v13 = *((_DWORD *)v12 + 6);
  v14 = a1[23];
  v15 = v14 + 184 * v13;
  v16 = *(_QWORD *)(v15 + 32);
  v17 = (char *)objc_msgSend(objc_retainAutorelease(*(id *)(v15 + 24)), "contents");
  v18 = (int8x8_t)a1[8];
  if (v18)
  {
    v19 = (uint8x8_t)vcnt_s8(v18);
    v19.i16[0] = vaddlv_u8(v19);
    if (v19.u32[0] > 1uLL)
    {
      v20 = a2;
      if (*(_QWORD *)&v18 <= a2)
        v20 = a2 % *(_QWORD *)&v18;
    }
    else
    {
      v20 = (*(_QWORD *)&v18 - 1) & a2;
    }
    i = *(_QWORD **)(a1[7] + 8 * v20);
    if (i)
    {
      for (i = (_QWORD *)*i; i; i = (_QWORD *)*i)
      {
        v22 = i[1];
        if (v22 == a2)
        {
          if (i[2] == a2)
            break;
        }
        else
        {
          if (v19.u32[0] > 1uLL)
          {
            if (v22 >= *(_QWORD *)&v18)
              v22 %= *(_QWORD *)&v18;
          }
          else
          {
            v22 &= *(_QWORD *)&v18 - 1;
          }
          if (v22 != v20)
            goto LABEL_19;
        }
      }
    }
  }
  else
  {
LABEL_19:
    i = 0;
  }
  v23 = (int8x8_t)a1[13];
  if (!*(_QWORD *)&v23)
    goto LABEL_36;
  v24 = (uint8x8_t)vcnt_s8(v23);
  v24.i16[0] = vaddlv_u8(v24);
  if (v24.u32[0] > 1uLL)
  {
    v25 = a2;
    if (*(_QWORD *)&v23 <= a2)
      v25 = a2 % *(_QWORD *)&v23;
  }
  else
  {
    v25 = (*(_QWORD *)&v23 - 1) & a2;
  }
  v26 = *(_QWORD **)(a1[12] + 8 * v25);
  if (!v26 || (v27 = (_QWORD *)*v26) == 0)
  {
LABEL_36:
    __p = 0;
    v35 = 0;
    v36 = 0;
    v29 = (void *)objc_claimAutoreleasedReturnValue(+[ASVError errorWithCode:localizedDescription:](ASVError, "errorWithCode:localizedDescription:", 4, CFSTR("Invalid acceleration structure")));
    v11[2](v11, &__p, v29);

    goto LABEL_37;
  }
  while (1)
  {
    v28 = v27[1];
    if (v28 == a2)
      break;
    if (v24.u32[0] > 1uLL)
    {
      if (v28 >= *(_QWORD *)&v23)
        v28 %= *(_QWORD *)&v23;
    }
    else
    {
      v28 &= *(_QWORD *)&v23 - 1;
    }
    if (v28 != v25)
      goto LABEL_36;
LABEL_35:
    v27 = (_QWORD *)*v27;
    if (!v27)
      goto LABEL_36;
  }
  if (v27[2] != a2)
    goto LABEL_35;
  if (!i || !v27)
    goto LABEL_36;
  if (a4 < *(unsigned int *)&v17[v16 + 24] && i[3])
  {
    v33 = &v17[v16];
    v31 = v14 + 184 * v13;
    objc_msgSend(objc_retainAutorelease(*(id *)(v31 + 88)), "contents");
    v37 = 0;
    v38 = 0;
    v39 = 0;
    objc_msgSend(objc_retainAutorelease(*(id *)(v31 + 72)), "contents");
    if (a4 < a4 + a5)
    {
      v32 = *((_DWORD *)v33 + 3);
      if (v32 != 2)
      {
        if (v32 != 1)
        {
          if (!v32)
            operator new();
          operator new();
        }
        operator new();
      }
      operator new();
    }
    v11[2](v11, &v37, 0);
    v30 = v37;
    if (v37)
    {
      v38 = v37;
LABEL_39:
      operator delete(v30);
    }
    goto LABEL_40;
  }
  v35 = 0;
  v36 = 0;
  __p = 0;
  v11[2](v11, &__p, 0);
LABEL_37:
  v30 = __p;
  if (__p)
  {
    v35 = __p;
    goto LABEL_39;
  }
LABEL_40:

}

void AccelerationStructureViewerServer::DataSource::getPrimitiveData(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, void *a5)
{
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  unint64_t v13;
  const __CFString *v14;
  uint64_t v15;
  void *v16;
  void (*v17)(void);
  _QWORD *v18;

  v18 = a5;
  v9 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>((_QWORD *)(a1 + 136), a2);
  if (v9)
  {
    v10 = *(_QWORD *)(a1 + 184) + 184 * *((unsigned int *)v9 + 6);
    v11 = *(_QWORD *)(v10 + 112);
    v12 = (char *)objc_msgSend(objc_retainAutorelease(*(id *)(v10 + 104)), "contents");
    v13 = *(_QWORD *)(v10 + 120);
    if (a3 <= v13)
    {
      if (a3 + a4 <= v13)
      {
        v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &v12[v11 + a3], a4));
        v17 = (void (*)(void))v18[2];
        goto LABEL_9;
      }
      v14 = CFSTR("Requested data range end is beyond primitive data bounds");
    }
    else
    {
      v14 = CFSTR("Requested data range start is beyond primitive data bounds");
    }
    v15 = 2;
  }
  else
  {
    v14 = CFSTR("Invalid acceleration structure");
    v15 = 4;
  }
  v16 = (void *)objc_claimAutoreleasedReturnValue(+[ASVError errorWithCode:localizedDescription:](ASVError, "errorWithCode:localizedDescription:", v15, v14));
  v17 = (void (*)(void))v18[2];
LABEL_9:
  v17();

}

void AccelerationStructureViewerServer::DataSource::getInstanceChildren(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, void *a6)
{
  void (**v11)(id, void **, void *);
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  BOOL v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  char *v25;
  uint64_t v26;
  char *v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  _BYTE *v36;
  char *v37;
  int64_t v38;
  void (**v40)(id, void **, void *);
  void (**v41)(AccelerationStructureViewer::Filter *__hidden);
  char v42;
  char *v43;
  char *v44;
  char *v45;
  void *__p;
  char *v47;
  unint64_t v48;

  v11 = a6;
  if (a2 == -1)
    goto LABEL_13;
  v14 = *(_QWORD **)(a1 + 16);
  v13 = (_QWORD *)(a1 + 16);
  v12 = v14;
  if (!v14)
    goto LABEL_13;
  v15 = v13;
  do
  {
    v16 = v12[4];
    v17 = v16 >= a2;
    if (v16 >= a2)
      v18 = v12;
    else
      v18 = v12 + 1;
    if (v17)
      v15 = v12;
    v12 = (_QWORD *)*v18;
  }
  while (*v18);
  if (v15 == v13 || v15[4] > a2)
  {
LABEL_13:
    __p = 0;
    v47 = 0;
    v48 = 0;
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[ASVError errorWithCode:localizedDescription:](ASVError, "errorWithCode:localizedDescription:", 4, CFSTR("Invalid acceleration structure")));
    v11[2](v11, &__p, v19);

    if (__p)
    {
      v47 = (char *)__p;
      operator delete(__p);
    }
  }
  else
  {
    v41 = off_727800;
    v42 = *(_BYTE *)(a5 + 8);
    v44 = 0;
    v45 = 0;
    v43 = 0;
    v21 = *(_QWORD *)(a5 + 16);
    v20 = *(_QWORD *)(a5 + 24);
    if (v20 != v21)
    {
      v22 = 0xAAAAAAAAAAAAAAABLL * ((v20 - v21) >> 3);
      if (v22 >= 0xAAAAAAAAAAAAAABLL)
LABEL_54:
        abort();
      v43 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v22);
      v44 = v43;
      v45 = &v43[24 * v23];
      std::vector<AccelerationStructureViewer::FilterToken>::__construct_at_end<AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*>(&v43, v21, v20);
    }
    v40 = v11;
    __p = 0;
    v47 = 0;
    v48 = 0;
    v24 = (uint64_t *)v15[5];
    if (v24 == (uint64_t *)v15[6])
    {
      v25 = 0;
    }
    else
    {
      v25 = 0;
      do
      {
        v26 = *v24;
        if (AccelerationStructureViewer::DataSourceFilterable::matches((AccelerationStructureViewer::DataSourceFilterable *)(*v24 + 8), (AccelerationStructureViewer::Filter *)&v41))
        {
          if ((unint64_t)v25 >= v48)
          {
            v28 = (char *)__p;
            v29 = (v25 - (_BYTE *)__p) >> 3;
            v30 = v29 + 1;
            if ((unint64_t)(v29 + 1) >> 61)
              goto LABEL_54;
            v31 = v48 - (_QWORD)__p;
            if ((uint64_t)(v48 - (_QWORD)__p) >> 2 > v30)
              v30 = v31 >> 2;
            if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF8)
              v32 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v32 = v30;
            if (v32)
              v32 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v32);
            else
              v33 = 0;
            v34 = (char *)(v32 + 8 * v29);
            *(_QWORD *)v34 = v26;
            v27 = v34 + 8;
            if (v25 != v28)
            {
              do
              {
                v35 = *((_QWORD *)v25 - 1);
                v25 -= 8;
                *((_QWORD *)v34 - 1) = v35;
                v34 -= 8;
              }
              while (v25 != v28);
              v25 = (char *)__p;
            }
            __p = v34;
            v48 = v32 + 8 * v33;
            if (v25)
              operator delete(v25);
          }
          else
          {
            *(_QWORD *)v25 = v26;
            v27 = v25 + 8;
          }
          v47 = v27;
          v25 = v27;
        }
        ++v24;
      }
      while (v24 != (uint64_t *)v15[6]);
    }
    v36 = __p;
    if (a3)
    {
      v37 = (char *)__p + 8 * a3;
      v38 = v25 - v37;
      if (v25 != v37)
        memmove(__p, v37, v25 - v37);
      v25 = &v36[v38];
      v47 = &v36[v38];
    }
    if (a4 < (v25 - v36) >> 3 && &v36[8 * a4] != v25)
      v47 = &v36[8 * a4];
    v40[2](v40, &__p, 0);
    if (__p)
    {
      v47 = (char *)__p;
      operator delete(__p);
    }

    v41 = off_727800;
    __p = &v43;
    std::vector<AccelerationStructureViewer::FilterToken>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
  }

}

void AccelerationStructureViewerServer::DataSource::getAccelerationStructureChildren(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  void (**v10)(id, _QWORD *, void *);
  _QWORD *v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  const __CFString *v19;
  void *v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t v25;

  v10 = a6;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v11 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>((_QWORD *)(a1 + 136), a2);
  if (!v11)
  {
    v19 = CFSTR("You can't have children of children");
    goto LABEL_23;
  }
  v12 = *((_DWORD *)v11 + 6);
  v13 = *(_QWORD *)(a1 + 184);
  v14 = *(_DWORD *)(v13 + 184 * v12 + 8);
  if (v14 != 4 && v14 != 2)
  {
    v19 = CFSTR("This acceleration structure does not support children structures.");
LABEL_23:
    v20 = (void *)objc_claimAutoreleasedReturnValue(+[ASVError errorWithCode:localizedDescription:](ASVError, "errorWithCode:localizedDescription:", 4, v19));
    ((void (**)(id, _QWORD **, void *))v10)[2](v10, &v23, v20);

LABEL_24:
    v18 = v23;
    goto LABEL_25;
  }
  v22 = a3 + a4;
  if (a3 < a3 + a4)
  {
    v16 = v13 + 184 * v12;
    v21 = (_QWORD *)(v16 + 128);
    while (2)
    {
      if (a3 < (uint64_t)(*(_QWORD *)(v16 + 136) - *v21) >> 3)
      {
        switch(*(_DWORD *)(*(_QWORD *)(*v21 + 8 * a3) + 8))
        {
          case 0:
            if (++a3 == v22)
              break;
            continue;
          case 1:
            operator new();
          case 2:
            asvsAS2iasv(*(AccelerationStructureViewerServer::AccelerationStructure **)(*v21 + 8 * a3));
          case 3:
            asvsAS2pmasv(*(AccelerationStructureViewerServer::AccelerationStructure **)(*v21 + 8 * a3));
          case 4:
            operator new();
          default:
            operator new();
        }
      }
      break;
    }
  }
  ((void (**)(id, _QWORD **, void *))v10)[2](v10, &v23, 0);
  v18 = v23;
  v17 = v24;
  if (v23 != v24)
  {
    do
    {
      if (*v18)
        (*(void (**)(_QWORD))(*(_QWORD *)*v18 + 8))(*v18);
      ++v18;
    }
    while (v18 != v17);
    goto LABEL_24;
  }
LABEL_25:
  if (v18)
  {
    v24 = v18;
    operator delete(v18);
  }

}

void AccelerationStructureViewerServer::DataSource::generateItems(AccelerationStructureViewerServer::DataSource *this)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t *v11;
  char *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _DWORD *v16;
  char *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  unsigned int v23;
  uint64_t v24;
  _DWORD *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  void *v37;
  id *v38;
  void *v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  id v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  int v52;
  std::vector<unsigned int>::pointer v53;
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  _DWORD *v60;
  char *v61;
  uint64_t v62;
  _QWORD *v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  unsigned int v67;
  uint64_t v68;
  _DWORD *v69;
  void *v70;
  uint64_t v71;
  uint64_t v72;
  void *v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t *v80;
  void *v81;
  id *v82;
  void *v83;
  uint64_t v84;
  _QWORD *v85;
  uint64_t v86;
  uint64_t v87;
  char *v88;
  id v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  int v96;
  std::vector<unsigned int>::pointer v97;
  char *v98;
  uint64_t v99;
  char *v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  char *v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  char *v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v112;
  char *v113;
  __int128 v114;
  BOOL v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unint64_t *v119;
  void *v120;
  id *v121;
  void *v122;
  uint64_t v123;
  _QWORD *v124;
  uint64_t v125;
  uint64_t v126;
  char *v127;
  id v128;
  unint64_t v129;
  unint64_t v130;
  uint64_t v131;
  uint64_t v132;
  unint64_t v133;
  unint64_t v134;
  int v135;
  std::vector<unsigned int>::pointer begin;
  char *v137;
  uint64_t v138;
  char *v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  char *v143;
  unint64_t v144;
  unint64_t v145;
  unint64_t v146;
  char *v147;
  unint64_t v148;
  unint64_t v149;
  unint64_t v151;
  char *v152;
  __int128 v153;
  BOOL v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  unint64_t *v158;
  void *v159;
  id *v160;
  void *v161;
  uint64_t v162;
  _QWORD *v163;
  uint64_t v164;
  uint64_t v165;
  char *v166;
  id v167;
  unint64_t v168;
  unint64_t v169;
  uint64_t v170;
  uint64_t v171;
  unint64_t v172;
  unint64_t v173;
  int v174;
  std::vector<unsigned int>::pointer v175;
  char *v176;
  uint64_t v177;
  char *v178;
  uint64_t v179;
  unint64_t v180;
  _DWORD *v181;
  unint64_t v182;
  unint64_t v183;
  char *v184;
  char *v185;
  unint64_t v186;
  int v187;
  unint64_t v188;
  void *v189;
  int v190;
  _DWORD *v191;
  unint64_t v192;
  unint64_t v193;
  char *v194;
  char *v195;
  unint64_t v196;
  int v197;
  unint64_t v198;
  void *v199;
  int v200;
  _DWORD *v201;
  unint64_t v202;
  unint64_t v203;
  char *v204;
  char *v205;
  unint64_t v206;
  int v207;
  unint64_t v208;
  void *v209;
  int v210;
  _DWORD *v211;
  unint64_t v212;
  unint64_t v213;
  char *v214;
  char *v215;
  unint64_t v216;
  int v217;
  unint64_t v218;
  void *v219;
  int v220;
  uint64_t v221;
  _DWORD *v222;
  uint64_t v223;
  uint64_t v224;
  char *v225;
  unsigned int v226;
  uint64_t v227;
  uint64_t v228;
  char *v229;
  unint64_t v230;
  uint64_t *v231;
  unint64_t v232;
  uint64_t v233;
  char *v234;
  char *v235;
  BOOL v236;
  uint64_t v237;
  _DWORD *v238;
  uint64_t v239;
  uint64_t v240;
  char *v241;
  unsigned int v242;
  uint64_t v243;
  char *v244;
  uint64_t v245;
  char *v246;
  unint64_t v247;
  uint64_t *v248;
  unint64_t v249;
  uint64_t v250;
  char *v251;
  char *v252;
  unint64_t v253;
  uint64_t v254;
  id *v255;
  uint64_t *v256;
  unint64_t v257;
  unint64_t v258;
  char *v259;
  unint64_t v260;
  char *v261;
  unint64_t v262;
  int *v263;
  unint64_t v264;
  char *v265;
  float *v266;
  float *v267;
  uint64_t v268;
  unint64_t v269;
  uint64_t v270;
  char *v271;
  char *v272;
  int v273;
  char *v274;
  unint64_t v275;
  uint64_t *v276;
  float *v277;
  float v278;
  float v279;
  float v280;
  unint64_t v281;
  uint64_t v282;
  id *v283;
  uint64_t *v284;
  unint64_t v285;
  unint64_t v286;
  char *v287;
  unint64_t v288;
  char *v289;
  unint64_t v290;
  int *v291;
  unint64_t v292;
  char *v293;
  float *v294;
  float *v295;
  uint64_t v296;
  unint64_t v297;
  uint64_t v298;
  char *v299;
  char *v300;
  int v301;
  char *v302;
  unint64_t v303;
  uint64_t *v304;
  float *v305;
  float v306;
  float v307;
  float v308;
  void *context;
  float *v310;
  float *v311;
  _QWORD *v312;
  _QWORD *v313;
  AccelerationStructureViewerServer::DataSource *v314;
  uint64_t v315;
  char *v316;
  id *v317;
  id *v318;
  uint64_t v319;
  unint64_t *v320;
  unint64_t *v321;
  char **v322;
  char *v323;
  uint64_t *v324;
  char *v325;
  char *v326;
  char *v327;
  uint64_t v328;
  unint64_t v329;
  unint64_t v330;
  uint64_t **v331;
  std::vector<unsigned int> v332;
  uint64_t v333;

  context = objc_autoreleasePoolPush();
  v2 = *((_QWORD *)this + 23);
  if (*((_QWORD *)this + 24) != v2)
  {
    v3 = 0;
    v4 = 16;
    do
    {
      *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)this + 136, *(_QWORD *)(v2 + v4), (_QWORD *)(v2 + v4))+ 6) = v3++;
      v2 = *((_QWORD *)this + 23);
      v5 = *((_QWORD *)this + 24);
      v4 += 184;
    }
    while (v3 < 0xD37A6F4DE9BD37A7 * ((v5 - v2) >> 3));
    if (v5 != v2)
    {
      v6 = 0;
      v310 = (float *)((char *)this + 56);
      v311 = (float *)((char *)this + 96);
      v331 = (uint64_t **)((char *)this + 32);
      v322 = (char **)((char *)this + 8);
      v323 = (char *)this + 16;
      v314 = this;
      while (2)
      {
        v7 = v2 + 184 * v6;
        v9 = *(void **)(v7 + 24);
        v8 = v7 + 24;
        v11 = (uint64_t *)(v8 + 8);
        v10 = *(_QWORD *)(v8 + 8);
        v12 = (char *)objc_msgSend(objc_retainAutorelease(v9), "contents");
        if (!v12)
          goto LABEL_286;
        v13 = *(_DWORD *)&v12[v10 + 8];
        v315 = v6;
        v316 = &v12[v10];
        v319 = v8;
        v14 = 184;
        v328 = v2;
        v324 = (uint64_t *)(v8 + 8);
        switch(v13)
        {
          case 0:
            v15 = *v11;
            v16 = (char *)objc_msgSend(objc_retainAutorelease(*(id *)v8), "contents") + v15;
            v17 = (char *)malloc_type_calloc(v16[6], 0x18uLL, 0x1000040504FFAC1uLL);
            v18 = v2 + 184 * v6;
            v21 = *(_QWORD *)(v18 + 64);
            v19 = (_QWORD *)(v18 + 64);
            v20 = v21;
            v22 = (char *)objc_msgSend(objc_retainAutorelease((id)*(v19 - 1)), "contents");
            if (v16[2] == 2)
              v23 = v16[9];
            else
              v23 = 1;
            if (v16[5])
            {
              v103 = 0;
              v104 = &v22[v20];
              v105 = v23 * (unint64_t)v16[6];
              do
              {
                v106 = v103 + 1;
                v107 = *v19 + 48 * (v103 + 1);
                if (v107 > (unint64_t)objc_msgSend((id)*(v19 - 1), "length"))
                  break;
                if ((v16[2] | 2) == 2)
                {
                  v108 = &v104[48 * v103];
                  v109 = *((int *)v108 + 1);
                  v110 = *(int *)v108 + v109;
                  if (v110 <= v105 && v110 > v109)
                  {
                    v112 = v109 + 1;
                    v113 = &v17[24 * (int)v109];
                    do
                    {
                      v114 = *(_OWORD *)&v104[48 * v103 + 12];
                      *((_QWORD *)v113 + 2) = *(_QWORD *)&v104[48 * v103 + 28];
                      *(_OWORD *)v113 = v114;
                      v113 += 24;
                      v115 = v112 >= *(int *)v108 + (uint64_t)*((int *)v108 + 1) || v112 >= v105;
                      ++v112;
                    }
                    while (!v115);
                  }
                }
                ++v103;
              }
              while (v106 < v16[5]);
            }
            v116 = v315;
            v117 = v328;
            v118 = v328 + 184 * v315;
            v119 = (unint64_t *)(v118 + 16);
            std::__hash_table<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v311, *(_QWORD *)(v118 + 16), (_QWORD *)(v118 + 16))[3] = v17;
            memset(&v332, 0, sizeof(v332));
            std::vector<AccelerationStructureViewer::IntersectionFunctionTag>::resize(&v332, v16[7]);
            v122 = *(void **)(v118 + 72);
            v121 = (id *)(v118 + 72);
            v120 = v122;
            if (!v122)
              goto LABEL_178;
            v123 = v328 + 184 * v315;
            v126 = *(_QWORD *)(v123 + 80);
            v124 = (_QWORD *)(v123 + 80);
            v125 = v126;
            v127 = (char *)objc_msgSend(objc_retainAutorelease(v120), "contents");
            v128 = objc_msgSend(*v121, "length");
            v129 = (unint64_t)v128;
            v130 = v16[6];
            if ((_DWORD)v130)
            {
              v131 = 0;
              v132 = 0;
              v133 = 0;
              v134 = 0;
              v135 = v16[3];
              begin = v332.__begin_;
              v137 = &v127[v125];
              while (1)
              {
                if (v135 == 1)
                {
                  if (v131 + *v124 + 16 <= (unint64_t)v128)
                  {
                    v140 = *(unsigned int *)&v137[v131];
                    if (v140 < v16[7])
                      ++begin[v140];
                    v139 = &v137[16 * v133 + 4];
                    goto LABEL_84;
                  }
                }
                else if (!v135 && v132 + *v124 + 48 <= (unint64_t)v128)
                {
                  v138 = *(unsigned int *)&v137[v132 + 36];
                  if (v138 < v16[7])
                    ++begin[v138];
                  v139 = &v137[v132 + 40];
LABEL_84:
                  v141 = *(unsigned int *)v139;
                  if (v134 <= v141)
                    v134 = v141;
                  v130 = v16[6];
                }
                ++v133;
                v132 += 48;
                v131 += 16;
                if (v133 >= v130)
                  goto LABEL_167;
              }
            }
            v134 = 0;
LABEL_167:
            v201 = malloc_type_calloc(v134 + 1, 4uLL, 0x100004052888210uLL);
            v202 = v16[6];
            if (!(_DWORD)v202)
            {
LABEL_177:
              std::__hash_table<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v310, *v119, v119)[3] = v201;
              v116 = v315;
              v117 = v328;
LABEL_178:
              v209 = *(void **)(v117 + 184 * v116 + 88);
              if (v209)
              {
                objc_msgSend(objc_retainAutorelease(v209), "contents");
                if (v16[7])
                {
                  v210 = v16[3];
                  if (v210 != 2)
                  {
                    if (v210 != 1)
                    {
                      if (!v210)
                        operator new();
                      operator new();
                    }
                    operator new();
                  }
                  operator new();
                }
              }
              goto LABEL_208;
            }
            v203 = 0;
            v204 = &v127[v125 + 40];
            v205 = &v127[v125 + 4];
            v206 = *v124 + 48;
            while (1)
            {
              if (v206 > v129)
                goto LABEL_177;
              v207 = v16[3];
              if (v207 == 1)
                break;
              if (!v207)
              {
                v208 = *(unsigned int *)v204;
                goto LABEL_174;
              }
LABEL_176:
              ++v203;
              v204 += 48;
              v205 += 16;
              v206 += 48;
              if (v203 >= v202)
                goto LABEL_177;
            }
            v208 = *(unsigned int *)v205;
LABEL_174:
            if (v134 >= v208)
            {
              v201[v208] = v203;
              v202 = v16[6];
            }
            goto LABEL_176;
          case 1:
            v24 = *v11;
            v25 = (char *)objc_msgSend(objc_retainAutorelease(*(id *)v8), "contents") + v24;
            v26 = malloc_type_calloc(v25[6], 0x18uLL, 0x1000040504FFAC1uLL);
            v27 = v2 + 184 * v6;
            v29 = *(void **)(v27 + 56);
            v28 = v27 + 56;
            objc_msgSend(objc_retainAutorelease(v29), "contents");
            v30 = 0;
            v31 = -1;
            do
            {
              if (++v31 >= (unint64_t)v25[5])
                break;
              v30 += 64;
              v32 = *(_QWORD *)(v28 + 8) + v30;
            }
            while (v32 <= (unint64_t)objc_msgSend(*(id *)v28, "length"));
            v33 = v6;
            v34 = v328;
            v35 = v328 + 184 * v6;
            v36 = (unint64_t *)(v35 + 16);
            std::__hash_table<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v311, *(_QWORD *)(v35 + 16), (_QWORD *)(v35 + 16))[3] = v26;
            memset(&v332, 0, sizeof(v332));
            std::vector<AccelerationStructureViewer::IntersectionFunctionTag>::resize(&v332, v25[7]);
            v39 = *(void **)(v35 + 72);
            v38 = (id *)(v35 + 72);
            v37 = v39;
            if (!v39)
              goto LABEL_136;
            v40 = v328 + 184 * v315;
            v43 = *(_QWORD *)(v40 + 80);
            v41 = (_QWORD *)(v40 + 80);
            v42 = v43;
            v44 = (char *)objc_msgSend(objc_retainAutorelease(v37), "contents");
            v45 = objc_msgSend(*v38, "length");
            v46 = (unint64_t)v45;
            v47 = v25[6];
            if ((_DWORD)v47)
            {
              v48 = 0;
              v49 = 0;
              v50 = 0;
              v51 = 0;
              v52 = v25[3];
              v53 = v332.__begin_;
              v54 = &v44[v42];
              while (1)
              {
                if (v52 == 1)
                {
                  if (v48 + *v41 + 16 <= (unint64_t)v45)
                  {
                    v57 = *(unsigned int *)&v54[v48];
                    if (v57 < v25[7])
                      ++v53[v57];
                    v56 = &v54[16 * v51 + 4];
                    goto LABEL_26;
                  }
                }
                else if (!v52 && v49 + *v41 + 48 <= (unint64_t)v45)
                {
                  v55 = *(unsigned int *)&v54[v49 + 36];
                  if (v55 < v25[7])
                    ++v53[v55];
                  v56 = &v54[v49 + 40];
LABEL_26:
                  v58 = *(unsigned int *)v56;
                  if (v50 <= v58)
                    v50 = v58;
                  v47 = v25[6];
                }
                ++v51;
                v49 += 48;
                v48 += 16;
                if (v51 >= v47)
                  goto LABEL_125;
              }
            }
            v50 = 0;
LABEL_125:
            v181 = malloc_type_calloc(v50 + 1, 4uLL, 0x100004052888210uLL);
            v182 = v25[6];
            if ((_DWORD)v182)
            {
              v183 = 0;
              v184 = &v44[v42 + 40];
              v185 = &v44[v42 + 4];
              v186 = *v41 + 48;
              while (1)
              {
                if (v186 > v46)
                  goto LABEL_135;
                v187 = v25[3];
                if (v187 == 1)
                  break;
                if (!v187)
                {
                  v188 = *(unsigned int *)v184;
                  goto LABEL_132;
                }
LABEL_134:
                ++v183;
                v184 += 48;
                v185 += 16;
                v186 += 48;
                if (v183 >= v182)
                  goto LABEL_135;
              }
              v188 = *(unsigned int *)v185;
LABEL_132:
              if (v50 >= v188)
              {
                v181[v188] = v183;
                v182 = v25[6];
              }
              goto LABEL_134;
            }
LABEL_135:
            std::__hash_table<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v310, *v36, v36)[3] = v181;
            v33 = v315;
            v34 = v328;
LABEL_136:
            v189 = *(void **)(v34 + 184 * v33 + 88);
            if (v189)
            {
              objc_msgSend(objc_retainAutorelease(v189), "contents");
              if (v25[7])
              {
                v190 = v25[3];
                if (v190 != 2)
                {
                  if (v190 != 1)
                  {
                    if (!v190)
                      operator new();
                    operator new();
                  }
                  operator new();
                }
                operator new();
              }
            }
            goto LABEL_208;
          case 2:
            v59 = *v11;
            v60 = (char *)objc_msgSend(objc_retainAutorelease(*(id *)v8), "contents") + v59;
            v61 = (char *)malloc_type_calloc(v60[6], 0x18uLL, 0x1000040504FFAC1uLL);
            v62 = v2 + 184 * v6;
            v65 = *(_QWORD *)(v62 + 64);
            v63 = (_QWORD *)(v62 + 64);
            v64 = v65;
            v66 = (char *)objc_msgSend(objc_retainAutorelease((id)*(v63 - 1)), "contents");
            if (v60[2] == 2)
              v67 = v60[9];
            else
              v67 = 1;
            if (v60[5])
            {
              v142 = 0;
              v143 = &v66[v64];
              v144 = v67 * (unint64_t)v60[6];
              do
              {
                v145 = v142 + 1;
                v146 = *v63 + 60 * (v142 + 1);
                if (v146 > (unint64_t)objc_msgSend((id)*(v63 - 1), "length"))
                  break;
                if ((v60[2] | 2) == 2)
                {
                  v147 = &v143[60 * v142];
                  v148 = *((int *)v147 + 1);
                  v149 = *(int *)v147 + v148;
                  if (v149 <= v144 && v149 > v148)
                  {
                    v151 = v148 + 1;
                    v152 = &v61[24 * (int)v148];
                    do
                    {
                      v153 = *(_OWORD *)&v143[60 * v142 + 12];
                      *((_QWORD *)v152 + 2) = *(_QWORD *)&v143[60 * v142 + 28];
                      *(_OWORD *)v152 = v153;
                      v152 += 24;
                      v154 = v151 >= *(int *)v147 + (uint64_t)*((int *)v147 + 1) || v151 >= v144;
                      ++v151;
                    }
                    while (!v154);
                  }
                }
                ++v142;
              }
              while (v145 < v60[5]);
            }
            v155 = v315;
            v156 = v328;
            v157 = v328 + 184 * v315;
            v158 = (unint64_t *)(v157 + 16);
            std::__hash_table<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v311, *(_QWORD *)(v157 + 16), (_QWORD *)(v157 + 16))[3] = v61;
            memset(&v332, 0, sizeof(v332));
            std::vector<AccelerationStructureViewer::IntersectionFunctionTag>::resize(&v332, v60[7]);
            v161 = *(void **)(v157 + 72);
            v160 = (id *)(v157 + 72);
            v159 = v161;
            if (!v161)
              goto LABEL_199;
            v162 = v328 + 184 * v315;
            v165 = *(_QWORD *)(v162 + 80);
            v163 = (_QWORD *)(v162 + 80);
            v164 = v165;
            v166 = (char *)objc_msgSend(objc_retainAutorelease(v159), "contents");
            v167 = objc_msgSend(*v160, "length");
            v168 = (unint64_t)v167;
            v169 = v60[6];
            if ((_DWORD)v169)
            {
              v170 = 0;
              v171 = 0;
              v172 = 0;
              v173 = 0;
              v174 = v60[3];
              v175 = v332.__begin_;
              v176 = &v166[v164];
              while (1)
              {
                if (v174 == 1)
                {
                  if (v170 + *v163 + 16 <= (unint64_t)v167)
                  {
                    v179 = *(unsigned int *)&v176[v170];
                    if (v179 < v60[7])
                      ++v175[v179];
                    v178 = &v176[16 * v172 + 4];
                    goto LABEL_119;
                  }
                }
                else if (!v174 && v171 + *v163 + 48 <= (unint64_t)v167)
                {
                  v177 = *(unsigned int *)&v176[v171 + 36];
                  if (v177 < v60[7])
                    ++v175[v177];
                  v178 = &v176[v171 + 40];
LABEL_119:
                  v180 = *(unsigned int *)v178;
                  if (v173 <= v180)
                    v173 = v180;
                  v169 = v60[6];
                }
                ++v172;
                v171 += 48;
                v170 += 16;
                if (v172 >= v169)
                  goto LABEL_188;
              }
            }
            v173 = 0;
LABEL_188:
            v211 = malloc_type_calloc(v173 + 1, 4uLL, 0x100004052888210uLL);
            v212 = v60[6];
            if ((_DWORD)v212)
            {
              v213 = 0;
              v214 = &v166[v164 + 40];
              v215 = &v166[v164 + 4];
              v216 = *v163 + 48;
              while (1)
              {
                if (v216 > v168)
                  goto LABEL_198;
                v217 = v60[3];
                if (v217 == 1)
                  break;
                if (!v217)
                {
                  v218 = *(unsigned int *)v214;
                  goto LABEL_195;
                }
LABEL_197:
                ++v213;
                v214 += 48;
                v215 += 16;
                v216 += 48;
                if (v213 >= v212)
                  goto LABEL_198;
              }
              v218 = *(unsigned int *)v215;
LABEL_195:
              if (v173 >= v218)
              {
                v211[v218] = v213;
                v212 = v60[6];
              }
              goto LABEL_197;
            }
LABEL_198:
            std::__hash_table<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v310, *v158, v158)[3] = v211;
            v155 = v315;
            v156 = v328;
LABEL_199:
            v219 = *(void **)(v156 + 184 * v155 + 88);
            if (v219)
            {
              objc_msgSend(objc_retainAutorelease(v219), "contents");
              if (v60[7])
              {
                v220 = v60[3];
                if (v220 != 2)
                {
                  if (v220 != 1)
                  {
                    if (!v220)
                      operator new();
                    operator new();
                  }
                  operator new();
                }
                operator new();
              }
            }
            goto LABEL_208;
          case 3:
            v68 = *v11;
            v69 = (char *)objc_msgSend(objc_retainAutorelease(*(id *)v8), "contents") + v68;
            v70 = malloc_type_calloc(v69[6], 0x18uLL, 0x1000040504FFAC1uLL);
            v71 = v2 + 184 * v6;
            v73 = *(void **)(v71 + 56);
            v72 = v71 + 56;
            objc_msgSend(objc_retainAutorelease(v73), "contents");
            v74 = 0;
            v75 = -1;
            do
            {
              if (++v75 >= (unint64_t)v69[5])
                break;
              v74 += 104;
              v76 = *(_QWORD *)(v72 + 8) + v74;
            }
            while (v76 <= (unint64_t)objc_msgSend(*(id *)v72, "length"));
            v77 = v6;
            v78 = v328;
            v79 = v328 + 184 * v6;
            v80 = (unint64_t *)(v79 + 16);
            std::__hash_table<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v311, *(_QWORD *)(v79 + 16), (_QWORD *)(v79 + 16))[3] = v70;
            memset(&v332, 0, sizeof(v332));
            std::vector<AccelerationStructureViewer::IntersectionFunctionTag>::resize(&v332, v69[7]);
            v83 = *(void **)(v79 + 72);
            v82 = (id *)(v79 + 72);
            v81 = v83;
            if (!v83)
              goto LABEL_157;
            v84 = v328 + 184 * v315;
            v87 = *(_QWORD *)(v84 + 80);
            v85 = (_QWORD *)(v84 + 80);
            v86 = v87;
            v88 = (char *)objc_msgSend(objc_retainAutorelease(v81), "contents");
            v89 = objc_msgSend(*v82, "length");
            v90 = (unint64_t)v89;
            v91 = v69[6];
            if ((_DWORD)v91)
            {
              v92 = 0;
              v93 = 0;
              v94 = 0;
              v95 = 0;
              v96 = v69[3];
              v97 = v332.__begin_;
              v98 = &v88[v86];
              while (1)
              {
                if (v96 == 1)
                {
                  if (v92 + *v85 + 16 <= (unint64_t)v89)
                  {
                    v101 = *(unsigned int *)&v98[v92];
                    if (v101 < v69[7])
                      ++v97[v101];
                    v100 = &v98[16 * v95 + 4];
                    goto LABEL_49;
                  }
                }
                else if (!v96 && v93 + *v85 + 48 <= (unint64_t)v89)
                {
                  v99 = *(unsigned int *)&v98[v93 + 36];
                  if (v99 < v69[7])
                    ++v97[v99];
                  v100 = &v98[v93 + 40];
LABEL_49:
                  v102 = *(unsigned int *)v100;
                  if (v94 <= v102)
                    v94 = v102;
                  v91 = v69[6];
                }
                ++v95;
                v93 += 48;
                v92 += 16;
                if (v95 >= v91)
                  goto LABEL_146;
              }
            }
            v94 = 0;
LABEL_146:
            v191 = malloc_type_calloc(v94 + 1, 4uLL, 0x100004052888210uLL);
            v192 = v69[6];
            if ((_DWORD)v192)
            {
              v193 = 0;
              v194 = &v88[v86 + 40];
              v195 = &v88[v86 + 4];
              v196 = *v85 + 48;
              while (1)
              {
                if (v196 > v90)
                  goto LABEL_156;
                v197 = v69[3];
                if (v197 == 1)
                  break;
                if (!v197)
                {
                  v198 = *(unsigned int *)v194;
                  goto LABEL_153;
                }
LABEL_155:
                ++v193;
                v194 += 48;
                v195 += 16;
                v196 += 48;
                if (v193 >= v192)
                  goto LABEL_156;
              }
              v198 = *(unsigned int *)v195;
LABEL_153:
              if (v94 >= v198)
              {
                v191[v198] = v193;
                v192 = v69[6];
              }
              goto LABEL_155;
            }
LABEL_156:
            std::__hash_table<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v310, *v80, v80)[3] = v191;
            v77 = v315;
            v78 = v328;
LABEL_157:
            v199 = *(void **)(v78 + 184 * v77 + 88);
            if (v199)
            {
              objc_msgSend(objc_retainAutorelease(v199), "contents");
              if (v69[7])
              {
                v200 = v69[3];
                if (v200 != 2)
                {
                  if (v200 != 1)
                  {
                    if (!v200)
                      operator new();
                    operator new();
                  }
                  operator new();
                }
                operator new();
              }
            }
LABEL_208:
            v11 = v324;
            if (v332.__begin_)
              operator delete(v332.__begin_);
            v14 = (uint64_t)v314;
            v8 = v319;
            v13 = *((_DWORD *)v316 + 2);
            v2 = v328;
LABEL_211:
            switch(v13)
            {
              case 0:
                v221 = *v11;
                v222 = (char *)objc_msgSend(objc_retainAutorelease(*(id *)v8), "contents") + v221;
                if ((v222[2] | 2) != 2)
                  goto LABEL_285;
                v223 = v2 + 184 * v315;
                v317 = (id *)(v223 + 56);
                v224 = *(_QWORD *)(v223 + 64);
                v312 = (_QWORD *)(v223 + 64);
                v225 = (char *)objc_msgSend(objc_retainAutorelease(*(id *)(v223 + 56)), "contents");
                v226 = v222[2] == 2 ? v222[9] : 1;
                if (!v222[5])
                  goto LABEL_285;
                v253 = 0;
                v326 = &v225[v224];
                v329 = v226 * (unint64_t)v222[6];
                v254 = v2 + 184 * v315;
                v255 = (id *)(v254 + 72);
                v256 = (uint64_t *)(v254 + 80);
                v320 = (unint64_t *)(v254 + 16);
                while (2)
                {
                  v257 = v253 + 1;
                  v258 = *v312 + 48 * (v253 + 1);
                  if (v258 > (unint64_t)objc_msgSend(*v317, "length"))
                    goto LABEL_285;
                  v259 = &v326[48 * v253];
                  v260 = *(int *)v259;
                  if (v260 > v222[6]
                    || (v261 = &v326[48 * v253],
                        v264 = *((int *)v261 + 1),
                        v263 = (int *)(v261 + 4),
                        v262 = v264,
                        v260 + v264 <= v264))
                  {
LABEL_264:
                    v253 = v257;
                    v14 = (uint64_t)v314;
                    if (v257 >= v222[5])
                      goto LABEL_285;
                    continue;
                  }
                  break;
                }
                v265 = &v326[48 * v253];
                v266 = (float *)(v265 + 12);
                v267 = (float *)(v265 + 24);
                break;
              case 1:
                v227 = *v11;
                v325 = (char *)objc_msgSend(objc_retainAutorelease(*(id *)v8), "contents") + v227;
                if ((*((_DWORD *)v325 + 2) | 2) == 3)
                {
                  v228 = v2 + 184 * v315;
                  objc_msgSend(objc_retainAutorelease(*(id *)(v228 + 56)), "contents");
                  objc_msgSend(objc_retainAutorelease(*(id *)(v228 + 152)), "contents");
                  if (*((_DWORD *)v325 + 5))
                    operator new();
                  v229 = *v322;
                  v14 = (uint64_t)v314;
                  if (*v322 != v323)
                  {
                    do
                    {
                      v230 = *((_QWORD *)v229 + 5);
                      v231 = (uint64_t *)*((_QWORD *)v229 + 6);
                      v232 = 126 - 2 * __clz((uint64_t)((uint64_t)v231 - v230) >> 3);
                      if (v231 == (uint64_t *)v230)
                        v233 = 0;
                      else
                        v233 = v232;
                      std::__introsort<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNode_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**,false>(v230, v231, v233, 1);
                      v234 = (char *)*((_QWORD *)v229 + 1);
                      if (v234)
                      {
                        do
                        {
                          v235 = v234;
                          v234 = *(char **)v234;
                        }
                        while (v234);
                      }
                      else
                      {
                        do
                        {
                          v235 = (char *)*((_QWORD *)v229 + 2);
                          v236 = *(_QWORD *)v235 == (_QWORD)v229;
                          v229 = v235;
                        }
                        while (!v236);
                      }
                      v229 = v235;
                    }
                    while (v235 != v323);
                  }
                }
                goto LABEL_285;
              case 2:
                v237 = *v11;
                v238 = (char *)objc_msgSend(objc_retainAutorelease(*(id *)v8), "contents") + v237;
                if ((v238[2] | 2) != 2)
                  goto LABEL_285;
                v239 = v2 + 184 * v315;
                v318 = (id *)(v239 + 56);
                v240 = *(_QWORD *)(v239 + 64);
                v313 = (_QWORD *)(v239 + 64);
                v241 = (char *)objc_msgSend(objc_retainAutorelease(*(id *)(v239 + 56)), "contents");
                v242 = v238[2] == 2 ? v238[9] : 1;
                if (!v238[5])
                  goto LABEL_285;
                v281 = 0;
                v327 = &v241[v240];
                v330 = v242 * (unint64_t)v238[6];
                v282 = v2 + 184 * v315;
                v283 = (id *)(v282 + 72);
                v284 = (uint64_t *)(v282 + 80);
                v321 = (unint64_t *)(v282 + 16);
                while (2)
                {
                  v285 = v281 + 1;
                  v286 = *v313 + 60 * (v281 + 1);
                  if (v286 <= (unint64_t)objc_msgSend(*v318, "length"))
                  {
                    v287 = &v327[60 * v281];
                    v288 = *(int *)v287;
                    if (v288 > v238[6]
                      || (v289 = &v327[60 * v281],
                          v292 = *((int *)v289 + 1),
                          v291 = (int *)(v289 + 4),
                          v290 = v292,
                          v288 + v292 <= v292))
                    {
LABEL_284:
                      v281 = v285;
                      v14 = (uint64_t)v314;
                      if (v285 >= v238[5])
                        break;
                      continue;
                    }
                    v293 = &v327[60 * v281];
                    v294 = (float *)(v293 + 12);
                    v295 = (float *)(v293 + 24);
                    while (2)
                    {
                      if (v238[2] == 2)
                        v296 = v238[9];
                      else
                        v296 = 1;
                      v297 = v290 * v296;
                      v298 = *v284;
                      v299 = (char *)objc_msgSend(objc_retainAutorelease(*v283), "contents");
                      if (v297 > v330)
                        goto LABEL_284;
                      v300 = &v299[v298];
                      v301 = v238[3];
                      if (v301 != 1)
                      {
                        if (!v301)
                        {
                          v302 = &v300[48 * v297 + 36];
LABEL_281:
                          v303 = *(unsigned int *)v302;
                          v333 = 0;
                          v304 = std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v331, 0, &v333);
                          if (v303 < (v304[6] - v304[5]) >> 3)
                          {
                            v305 = *(float **)(std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v331, *v321, (uint64_t *)v321)[5]+ 8 * v303);
                            v306 = v305[21];
                            v305[20] = fminf(v305[20], *v294);
                            v305[21] = fminf(v306, v294[1]);
                            v307 = v305[23];
                            v305[22] = fminf(v305[22], v294[2]);
                            v305[23] = fmaxf(v307, *v295);
                            v308 = v305[25];
                            v305[24] = fmaxf(v305[24], v295[1]);
                            v305[25] = fmaxf(v308, v295[2]);
                          }
                        }
                        v290 = v297 + 1;
                        if (v297 + 1 >= *(int *)v287 + (uint64_t)*v291)
                          goto LABEL_284;
                        continue;
                      }
                      break;
                    }
                    v302 = &v300[16 * v297];
                    goto LABEL_281;
                  }
                  break;
                }
LABEL_285:
                v6 = v315 + 1;
                v2 = *(_QWORD *)(v14 + 184);
                if (v315 + 1 >= 0xD37A6F4DE9BD37A7 * ((*(_QWORD *)(v14 + 192) - v2) >> 3))
                  goto LABEL_286;
                continue;
              case 3:
                v243 = *v11;
                v244 = (char *)objc_msgSend(objc_retainAutorelease(*(id *)v8), "contents") + v243;
                if ((*((_DWORD *)v244 + 2) | 2) == 3)
                {
                  v245 = v2 + 184 * v315;
                  objc_msgSend(objc_retainAutorelease(*(id *)(v245 + 56)), "contents");
                  objc_msgSend(objc_retainAutorelease(*(id *)(v245 + 152)), "contents");
                  if (*((_DWORD *)v244 + 5))
                    operator new();
                  v246 = *v322;
                  v14 = (uint64_t)v314;
                  if (*v322 != v323)
                  {
                    do
                    {
                      v247 = *((_QWORD *)v246 + 5);
                      v248 = (uint64_t *)*((_QWORD *)v246 + 6);
                      v249 = 126 - 2 * __clz((uint64_t)((uint64_t)v248 - v247) >> 3);
                      if (v248 == (uint64_t *)v247)
                        v250 = 0;
                      else
                        v250 = v249;
                      std::__introsort<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**,false>(v247, v248, v250, 1);
                      v251 = (char *)*((_QWORD *)v246 + 1);
                      if (v251)
                      {
                        do
                        {
                          v252 = v251;
                          v251 = *(char **)v251;
                        }
                        while (v251);
                      }
                      else
                      {
                        do
                        {
                          v252 = (char *)*((_QWORD *)v246 + 2);
                          v236 = *(_QWORD *)v252 == (_QWORD)v246;
                          v246 = v252;
                        }
                        while (!v236);
                      }
                      v246 = v252;
                    }
                    while (v252 != v323);
                  }
                }
                goto LABEL_285;
              default:
                goto LABEL_285;
            }
            break;
          default:
            goto LABEL_211;
        }
        break;
      }
      while (1)
      {
        if (v222[2] == 2)
          v268 = v222[9];
        else
          v268 = 1;
        v269 = v262 * v268;
        v270 = *v256;
        v271 = (char *)objc_msgSend(objc_retainAutorelease(*v255), "contents");
        if (v269 > v329)
          goto LABEL_264;
        v272 = &v271[v270];
        v273 = v222[3];
        if (v273 == 1)
          break;
        if (!v273)
        {
          v274 = &v272[48 * v269 + 36];
          goto LABEL_261;
        }
LABEL_263:
        v262 = v269 + 1;
        if (v269 + 1 >= *(int *)v259 + (uint64_t)*v263)
          goto LABEL_264;
      }
      v274 = &v272[16 * v269];
LABEL_261:
      v275 = *(unsigned int *)v274;
      v333 = 0;
      v276 = std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v331, 0, &v333);
      if (v275 < (v276[6] - v276[5]) >> 3)
      {
        v277 = *(float **)(std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v331, *v320, (uint64_t *)v320)[5]+ 8 * v275);
        v278 = v277[21];
        v277[20] = fminf(v277[20], *v266);
        v277[21] = fminf(v278, v266[1]);
        v279 = v277[23];
        v277[22] = fminf(v277[22], v266[2]);
        v277[23] = fmaxf(v279, *v267);
        v280 = v277[25];
        v277[24] = fmaxf(v277[24], v267[1]);
        v277[25] = fmaxf(v280, v267[2]);
      }
      goto LABEL_263;
    }
  }
LABEL_286:
  objc_autoreleasePoolPop(context);
}

uint64_t **std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Instance *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Instance *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Instance *>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t **a1, unint64_t a2, uint64_t **a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = v5[4];
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x40uLL);
    v7[4] = *a3;
    v7[5] = 0;
    v7[6] = 0;
    v7[7] = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)**a1;
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**,false>(unint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t *v40;
  BOOL v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t *v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t *v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t *v79;
  uint64_t v81;
  uint64_t v82;
  unint64_t v83;

  v7 = (uint64_t *)result;
LABEL_2:
  v8 = a2 - 1;
  v9 = v7;
  while (2)
  {
    v7 = v9;
    v10 = (char *)a2 - (char *)v9;
    v11 = a2 - v9;
    switch(v11)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v39 = *v9;
        if (*(_QWORD *)(*v8 + 40) < *(_QWORD *)(*v9 + 40))
        {
          *v9 = *v8;
          *v8 = v39;
        }
        return result;
      case 3uLL:
        return (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v9, v9 + 1, a2 - 1);
      case 4uLL:
        return (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v9, v9 + 1, v9 + 2, a2 - 1);
      case 5uLL:
        return (unint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v9, v9 + 1, v9 + 2, v9 + 3, a2 - 1);
      default:
        if (v10 <= 191)
        {
          v40 = v9 + 1;
          v42 = v9 == a2 || v40 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v42)
            {
              v43 = 0;
              v44 = v9;
              do
              {
                v46 = *v44;
                v45 = v44[1];
                v44 = v40;
                v47 = *(_QWORD *)(v45 + 40);
                if (v47 < *(_QWORD *)(v46 + 40))
                {
                  v48 = v43;
                  while (1)
                  {
                    *(uint64_t *)((char *)v9 + v48 + 8) = v46;
                    if (!v48)
                      break;
                    v46 = *(uint64_t *)((char *)v9 + v48 - 8);
                    v48 -= 8;
                    if (v47 >= *(_QWORD *)(v46 + 40))
                    {
                      v49 = (uint64_t *)((char *)v9 + v48 + 8);
                      goto LABEL_75;
                    }
                  }
                  v49 = v9;
LABEL_75:
                  *v49 = v45;
                }
                v40 = v44 + 1;
                v43 += 8;
              }
              while (v44 + 1 != a2);
            }
          }
          else if (!v42)
          {
            do
            {
              v82 = *v7;
              v81 = v7[1];
              v7 = v40;
              v83 = *(_QWORD *)(v81 + 40);
              if (v83 < *(_QWORD *)(v82 + 40))
              {
                do
                {
                  *v40 = v82;
                  v82 = *(v40 - 2);
                  --v40;
                }
                while (v83 < *(_QWORD *)(v82 + 40));
                *v40 = v81;
              }
              v40 = v7 + 1;
            }
            while (v7 + 1 != a2);
          }
          return result;
        }
        if (!a3)
        {
          if (v9 != a2)
          {
            v50 = (v11 - 2) >> 1;
            v51 = v50;
            do
            {
              v52 = v51;
              if (v50 >= v51)
              {
                v53 = (2 * v51) | 1;
                v54 = &v9[v53];
                v55 = *v54;
                if (2 * v52 + 2 < (uint64_t)v11)
                {
                  result = *(_QWORD *)(v55 + 40);
                  if (result < *(_QWORD *)(v54[1] + 40))
                  {
                    v55 = v54[1];
                    ++v54;
                    v53 = 2 * v52 + 2;
                  }
                }
                v56 = &v9[v52];
                v57 = *v56;
                v58 = *(_QWORD *)(*v56 + 40);
                if (*(_QWORD *)(v55 + 40) >= v58)
                {
                  do
                  {
                    v59 = v54;
                    *v56 = v55;
                    if (v50 < v53)
                      break;
                    result = (2 * v53) | 1;
                    v54 = &v9[result];
                    v60 = 2 * v53 + 2;
                    v55 = *v54;
                    if (v60 < (uint64_t)v11 && *(_QWORD *)(v55 + 40) < *(_QWORD *)(v54[1] + 40))
                    {
                      v55 = v54[1];
                      ++v54;
                      result = v60;
                    }
                    v56 = v59;
                    v53 = result;
                  }
                  while (*(_QWORD *)(v55 + 40) >= v58);
                  *v59 = v57;
                }
              }
              v51 = v52 - 1;
            }
            while (v52);
            v61 = (unint64_t)v10 >> 3;
            do
            {
              v62 = 0;
              v63 = *v9;
              v64 = v61 - 2;
              if (v61 < 2)
                v64 = v61 - 1;
              v65 = v64 >> 1;
              v66 = v9;
              do
              {
                v67 = &v66[v62];
                v70 = v67[1];
                v68 = v67 + 1;
                v69 = v70;
                v71 = (2 * v62) | 1;
                v72 = 2 * v62 + 2;
                if (v72 < v61)
                {
                  result = v68[1];
                  if (*(_QWORD *)(v69 + 40) < *(_QWORD *)(result + 40))
                  {
                    v69 = v68[1];
                    ++v68;
                    v71 = v72;
                  }
                }
                *v66 = v69;
                v66 = v68;
                v62 = v71;
              }
              while (v71 <= v65);
              if (v68 == --a2)
              {
                *v68 = v63;
              }
              else
              {
                *v68 = *a2;
                *a2 = v63;
                v73 = (char *)v68 - (char *)v9 + 8;
                if (v73 >= 9)
                {
                  v74 = (unint64_t)((v73 >> 3) - 2) >> 1;
                  v75 = &v9[v74];
                  v76 = *v75;
                  v77 = *v68;
                  v78 = *(_QWORD *)(*v68 + 40);
                  if (*(_QWORD *)(*v75 + 40) < v78)
                  {
                    do
                    {
                      v79 = v75;
                      *v68 = v76;
                      if (!v74)
                        break;
                      v74 = (v74 - 1) >> 1;
                      v75 = &v9[v74];
                      v76 = *v75;
                      v68 = v79;
                    }
                    while (*(_QWORD *)(*v75 + 40) < v78);
                    *v79 = v77;
                  }
                }
              }
            }
            while (v61-- > 2);
          }
          return result;
        }
        v12 = v11 >> 1;
        v13 = &v9[v11 >> 1];
        if ((unint64_t)v10 < 0x401)
        {
          result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(&v7[v11 >> 1], v7, a2 - 1);
        }
        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v7, &v7[v11 >> 1], a2 - 1);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v7 + 1, v13 - 1, a2 - 2);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v7 + 2, &v7[v12 + 1], a2 - 3);
          result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v13 - 1, v13, &v7[v12 + 1]);
          v14 = *v7;
          *v7 = *v13;
          *v13 = v14;
        }
        --a3;
        v15 = *v7;
        if ((a4 & 1) == 0)
        {
          v16 = *(_QWORD *)(v15 + 40);
          if (*(_QWORD *)(*(v7 - 1) + 40) < v16)
            goto LABEL_12;
          if (v16 >= *(_QWORD *)(*v8 + 40))
          {
            v31 = v7 + 1;
            do
            {
              v9 = v31;
              if (v31 >= a2)
                break;
              ++v31;
            }
            while (v16 >= *(_QWORD *)(*v9 + 40));
          }
          else
          {
            v9 = v7;
            do
            {
              v30 = v9[1];
              ++v9;
            }
            while (v16 >= *(_QWORD *)(v30 + 40));
          }
          v32 = a2;
          if (v9 < a2)
          {
            v32 = a2;
            do
              v33 = *--v32;
            while (v16 < *(_QWORD *)(v33 + 40));
          }
          if (v9 < v32)
          {
            v34 = *v9;
            v35 = *v32;
            do
            {
              *v9 = v35;
              *v32 = v34;
              do
              {
                v36 = v9[1];
                ++v9;
                v34 = v36;
              }
              while (v16 >= *(_QWORD *)(v36 + 40));
              do
              {
                v37 = *--v32;
                v35 = v37;
              }
              while (v16 < *(_QWORD *)(v37 + 40));
            }
            while (v9 < v32);
          }
          v38 = v9 - 1;
          if (v9 - 1 != v7)
            *v7 = *v38;
          a4 = 0;
          *v38 = v15;
          continue;
        }
        v16 = *(_QWORD *)(v15 + 40);
LABEL_12:
        v17 = v7;
        do
        {
          v18 = v17;
          v20 = v17[1];
          ++v17;
          v19 = v20;
        }
        while (*(_QWORD *)(v20 + 40) < v16);
        v21 = a2;
        if (v18 == v7)
        {
          v21 = a2;
          do
          {
            if (v17 >= v21)
              break;
            v23 = *--v21;
          }
          while (*(_QWORD *)(v23 + 40) >= v16);
        }
        else
        {
          do
            v22 = *--v21;
          while (*(_QWORD *)(v22 + 40) >= v16);
        }
        if (v17 < v21)
        {
          v24 = *v21;
          v25 = v17;
          v26 = v21;
          do
          {
            *v25 = v24;
            *v26 = v19;
            do
            {
              v18 = v25;
              v27 = v25[1];
              ++v25;
              v19 = v27;
            }
            while (*(_QWORD *)(v27 + 40) < v16);
            do
            {
              v28 = *--v26;
              v24 = v28;
            }
            while (*(_QWORD *)(v28 + 40) >= v16);
          }
          while (v25 < v26);
        }
        if (v18 != v7)
          *v7 = *v18;
        *v18 = v15;
        if (v17 < v21)
        {
LABEL_31:
          result = std::__introsort<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**,false>(v7, v18, a3, a4 & 1);
          a4 = 0;
          v9 = v18 + 1;
          continue;
        }
        v29 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v7, v18);
        v9 = v18 + 1;
        result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v18 + 1, a2);
        if (!(_DWORD)result)
        {
          if (v29)
            continue;
          goto LABEL_31;
        }
        a2 = v18;
        if (!v29)
          goto LABEL_2;
        return result;
    }
  }
}

uint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;

  v3 = *a2;
  v4 = *result;
  v5 = *(_QWORD *)(*a2 + 40);
  v6 = *(_QWORD *)(*result + 40);
  v7 = *a3;
  v8 = *(_QWORD *)(*a3 + 40);
  if (v5 >= v6)
  {
    if (v8 < v5)
    {
      *a2 = v7;
      *a3 = v3;
      v9 = *result;
      if (*(_QWORD *)(*a2 + 40) < *(_QWORD *)(*result + 40))
      {
        *result = *a2;
        *a2 = v9;
      }
    }
  }
  else
  {
    if (v8 >= v5)
    {
      *result = v3;
      *a2 = v4;
      if (*(_QWORD *)(*a3 + 40) >= v6)
        return result;
      *a2 = *a3;
    }
    else
    {
      *result = v7;
    }
    *a3 = v4;
  }
  return result;
}

uint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(a1, a2, a3);
  v9 = *a3;
  if (*(_QWORD *)(*a4 + 40) < *(_QWORD *)(*a3 + 40))
  {
    *a3 = *a4;
    *a4 = v9;
    v10 = *a2;
    if (*(_QWORD *)(*a3 + 40) < *(_QWORD *)(*a2 + 40))
    {
      *a2 = *a3;
      *a3 = v10;
      v11 = *a1;
      if (*(_QWORD *)(*a2 + 40) < *(_QWORD *)(*a1 + 40))
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

uint64_t *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(a1, a2, a3, a4);
  v11 = *a4;
  if (*(_QWORD *)(*a5 + 40) < *(_QWORD *)(*a4 + 40))
  {
    *a4 = *a5;
    *a5 = v11;
    v12 = *a3;
    if (*(_QWORD *)(*a4 + 40) < *(_QWORD *)(*a3 + 40))
    {
      *a3 = *a4;
      *a4 = v12;
      v13 = *a2;
      if (*(_QWORD *)(*a3 + 40) < *(_QWORD *)(*a2 + 40))
      {
        *a2 = *a3;
        *a3 = v13;
        v14 = *a1;
        if (*(_QWORD *)(*a2 + 40) < *(_QWORD *)(*a1 + 40))
        {
          *a1 = *a2;
          *a2 = v14;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;

  v4 = a2 - a1;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 1);
      v7 = *a1;
      if (*(_QWORD *)(v6 + 40) < *(_QWORD *)(*a1 + 40))
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      v8 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(a1, a1 + 1, a1 + 2);
      v9 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v10 = 0;
      v11 = 24;
      break;
  }
  while (1)
  {
    v12 = *v9;
    v13 = *v8;
    v14 = *(_QWORD *)(*v9 + 40);
    if (v14 < *(_QWORD *)(*v8 + 40))
    {
      v15 = v11;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v15) = v13;
        v16 = v15 - 8;
        if (v15 == 8)
          break;
        v13 = *(uint64_t *)((char *)a1 + v15 - 16);
        v15 -= 8;
        if (v14 >= *(_QWORD *)(v13 + 40))
        {
          v17 = (uint64_t *)((char *)a1 + v16);
          goto LABEL_12;
        }
      }
      v17 = a1;
LABEL_12:
      *v17 = v12;
      if (++v10 == 8)
        return v9 + 1 == a2;
    }
    v8 = v9;
    v11 += 8;
    if (++v9 == a2)
      return 1;
  }
}

uint64_t *std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(uint64_t **a1, unint64_t a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t *v9;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = v5[4];
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)operator new(0x40uLL);
    v9[4] = *a3;
    v9[5] = 0;
    v9[6] = 0;
    v9[7] = 0;
    std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>>>::__insert_node_at(a1, (uint64_t)v7, v6, v9);
    return v9;
  }
  return (uint64_t *)v7;
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNode_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**,false>(unint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t *v40;
  BOOL v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t *v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t *v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t *v79;
  uint64_t v81;
  uint64_t v82;
  unint64_t v83;

  v7 = (uint64_t *)result;
LABEL_2:
  v8 = a2 - 1;
  v9 = v7;
  while (2)
  {
    v7 = v9;
    v10 = (char *)a2 - (char *)v9;
    v11 = a2 - v9;
    switch(v11)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v39 = *v9;
        if (*(_QWORD *)(*v8 + 40) < *(_QWORD *)(*v9 + 40))
        {
          *v9 = *v8;
          *v8 = v39;
        }
        return result;
      case 3uLL:
        return (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v9, v9 + 1, a2 - 1);
      case 4uLL:
        return (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v9, v9 + 1, v9 + 2, a2 - 1);
      case 5uLL:
        return (unint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v9, v9 + 1, v9 + 2, v9 + 3, a2 - 1);
      default:
        if (v10 <= 191)
        {
          v40 = v9 + 1;
          v42 = v9 == a2 || v40 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v42)
            {
              v43 = 0;
              v44 = v9;
              do
              {
                v46 = *v44;
                v45 = v44[1];
                v44 = v40;
                v47 = *(_QWORD *)(v45 + 40);
                if (v47 < *(_QWORD *)(v46 + 40))
                {
                  v48 = v43;
                  while (1)
                  {
                    *(uint64_t *)((char *)v9 + v48 + 8) = v46;
                    if (!v48)
                      break;
                    v46 = *(uint64_t *)((char *)v9 + v48 - 8);
                    v48 -= 8;
                    if (v47 >= *(_QWORD *)(v46 + 40))
                    {
                      v49 = (uint64_t *)((char *)v9 + v48 + 8);
                      goto LABEL_75;
                    }
                  }
                  v49 = v9;
LABEL_75:
                  *v49 = v45;
                }
                v40 = v44 + 1;
                v43 += 8;
              }
              while (v44 + 1 != a2);
            }
          }
          else if (!v42)
          {
            do
            {
              v82 = *v7;
              v81 = v7[1];
              v7 = v40;
              v83 = *(_QWORD *)(v81 + 40);
              if (v83 < *(_QWORD *)(v82 + 40))
              {
                do
                {
                  *v40 = v82;
                  v82 = *(v40 - 2);
                  --v40;
                }
                while (v83 < *(_QWORD *)(v82 + 40));
                *v40 = v81;
              }
              v40 = v7 + 1;
            }
            while (v7 + 1 != a2);
          }
          return result;
        }
        if (!a3)
        {
          if (v9 != a2)
          {
            v50 = (v11 - 2) >> 1;
            v51 = v50;
            do
            {
              v52 = v51;
              if (v50 >= v51)
              {
                v53 = (2 * v51) | 1;
                v54 = &v9[v53];
                v55 = *v54;
                if (2 * v52 + 2 < (uint64_t)v11)
                {
                  result = *(_QWORD *)(v55 + 40);
                  if (result < *(_QWORD *)(v54[1] + 40))
                  {
                    v55 = v54[1];
                    ++v54;
                    v53 = 2 * v52 + 2;
                  }
                }
                v56 = &v9[v52];
                v57 = *v56;
                v58 = *(_QWORD *)(*v56 + 40);
                if (*(_QWORD *)(v55 + 40) >= v58)
                {
                  do
                  {
                    v59 = v54;
                    *v56 = v55;
                    if (v50 < v53)
                      break;
                    result = (2 * v53) | 1;
                    v54 = &v9[result];
                    v60 = 2 * v53 + 2;
                    v55 = *v54;
                    if (v60 < (uint64_t)v11 && *(_QWORD *)(v55 + 40) < *(_QWORD *)(v54[1] + 40))
                    {
                      v55 = v54[1];
                      ++v54;
                      result = v60;
                    }
                    v56 = v59;
                    v53 = result;
                  }
                  while (*(_QWORD *)(v55 + 40) >= v58);
                  *v59 = v57;
                }
              }
              v51 = v52 - 1;
            }
            while (v52);
            v61 = (unint64_t)v10 >> 3;
            do
            {
              v62 = 0;
              v63 = *v9;
              v64 = v61 - 2;
              if (v61 < 2)
                v64 = v61 - 1;
              v65 = v64 >> 1;
              v66 = v9;
              do
              {
                v67 = &v66[v62];
                v70 = v67[1];
                v68 = v67 + 1;
                v69 = v70;
                v71 = (2 * v62) | 1;
                v72 = 2 * v62 + 2;
                if (v72 < v61)
                {
                  result = v68[1];
                  if (*(_QWORD *)(v69 + 40) < *(_QWORD *)(result + 40))
                  {
                    v69 = v68[1];
                    ++v68;
                    v71 = v72;
                  }
                }
                *v66 = v69;
                v66 = v68;
                v62 = v71;
              }
              while (v71 <= v65);
              if (v68 == --a2)
              {
                *v68 = v63;
              }
              else
              {
                *v68 = *a2;
                *a2 = v63;
                v73 = (char *)v68 - (char *)v9 + 8;
                if (v73 >= 9)
                {
                  v74 = (unint64_t)((v73 >> 3) - 2) >> 1;
                  v75 = &v9[v74];
                  v76 = *v75;
                  v77 = *v68;
                  v78 = *(_QWORD *)(*v68 + 40);
                  if (*(_QWORD *)(*v75 + 40) < v78)
                  {
                    do
                    {
                      v79 = v75;
                      *v68 = v76;
                      if (!v74)
                        break;
                      v74 = (v74 - 1) >> 1;
                      v75 = &v9[v74];
                      v76 = *v75;
                      v68 = v79;
                    }
                    while (*(_QWORD *)(*v75 + 40) < v78);
                    *v79 = v77;
                  }
                }
              }
            }
            while (v61-- > 2);
          }
          return result;
        }
        v12 = v11 >> 1;
        v13 = &v9[v11 >> 1];
        if ((unint64_t)v10 < 0x401)
        {
          result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(&v7[v11 >> 1], v7, a2 - 1);
        }
        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v7, &v7[v11 >> 1], a2 - 1);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v7 + 1, v13 - 1, a2 - 2);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v7 + 2, &v7[v12 + 1], a2 - 3);
          result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v13 - 1, v13, &v7[v12 + 1]);
          v14 = *v7;
          *v7 = *v13;
          *v13 = v14;
        }
        --a3;
        v15 = *v7;
        if ((a4 & 1) == 0)
        {
          v16 = *(_QWORD *)(v15 + 40);
          if (*(_QWORD *)(*(v7 - 1) + 40) < v16)
            goto LABEL_12;
          if (v16 >= *(_QWORD *)(*v8 + 40))
          {
            v31 = v7 + 1;
            do
            {
              v9 = v31;
              if (v31 >= a2)
                break;
              ++v31;
            }
            while (v16 >= *(_QWORD *)(*v9 + 40));
          }
          else
          {
            v9 = v7;
            do
            {
              v30 = v9[1];
              ++v9;
            }
            while (v16 >= *(_QWORD *)(v30 + 40));
          }
          v32 = a2;
          if (v9 < a2)
          {
            v32 = a2;
            do
              v33 = *--v32;
            while (v16 < *(_QWORD *)(v33 + 40));
          }
          if (v9 < v32)
          {
            v34 = *v9;
            v35 = *v32;
            do
            {
              *v9 = v35;
              *v32 = v34;
              do
              {
                v36 = v9[1];
                ++v9;
                v34 = v36;
              }
              while (v16 >= *(_QWORD *)(v36 + 40));
              do
              {
                v37 = *--v32;
                v35 = v37;
              }
              while (v16 < *(_QWORD *)(v37 + 40));
            }
            while (v9 < v32);
          }
          v38 = v9 - 1;
          if (v9 - 1 != v7)
            *v7 = *v38;
          a4 = 0;
          *v38 = v15;
          continue;
        }
        v16 = *(_QWORD *)(v15 + 40);
LABEL_12:
        v17 = v7;
        do
        {
          v18 = v17;
          v20 = v17[1];
          ++v17;
          v19 = v20;
        }
        while (*(_QWORD *)(v20 + 40) < v16);
        v21 = a2;
        if (v18 == v7)
        {
          v21 = a2;
          do
          {
            if (v17 >= v21)
              break;
            v23 = *--v21;
          }
          while (*(_QWORD *)(v23 + 40) >= v16);
        }
        else
        {
          do
            v22 = *--v21;
          while (*(_QWORD *)(v22 + 40) >= v16);
        }
        if (v17 < v21)
        {
          v24 = *v21;
          v25 = v17;
          v26 = v21;
          do
          {
            *v25 = v24;
            *v26 = v19;
            do
            {
              v18 = v25;
              v27 = v25[1];
              ++v25;
              v19 = v27;
            }
            while (*(_QWORD *)(v27 + 40) < v16);
            do
            {
              v28 = *--v26;
              v24 = v28;
            }
            while (*(_QWORD *)(v28 + 40) >= v16);
          }
          while (v25 < v26);
        }
        if (v18 != v7)
          *v7 = *v18;
        *v18 = v15;
        if (v17 < v21)
        {
LABEL_31:
          result = std::__introsort<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNode_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**,false>(v7, v18, a3, a4 & 1);
          a4 = 0;
          v9 = v18 + 1;
          continue;
        }
        v29 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNode_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v7, v18);
        v9 = v18 + 1;
        result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNode_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(v18 + 1, a2);
        if (!(_DWORD)result)
        {
          if (v29)
            continue;
          goto LABEL_31;
        }
        a2 = v18;
        if (!v29)
          goto LABEL_2;
        return result;
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNode_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;

  v4 = a2 - a1;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 1);
      v7 = *a1;
      if (*(_QWORD *)(v6 + 40) < *(_QWORD *)(*a1 + 40))
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      v8 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,void AccelerationStructureViewerServer::DataSource::generateAccelerationStructureItems<MTLGenericBVHInstanceLeafNodeMotion_v5>(AccelerationStructureViewerServer::AccelerationStructure *)::{lambda(AccelerationStructureViewer::Instance const*,AccelerationStructureViewer::Instance const*)#1} &,AccelerationStructureViewer::Instance**>(a1, a1 + 1, a1 + 2);
      v9 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v10 = 0;
      v11 = 24;
      break;
  }
  while (1)
  {
    v12 = *v9;
    v13 = *v8;
    v14 = *(_QWORD *)(*v9 + 40);
    if (v14 < *(_QWORD *)(*v8 + 40))
    {
      v15 = v11;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v15) = v13;
        v16 = v15 - 8;
        if (v15 == 8)
          break;
        v13 = *(uint64_t *)((char *)a1 + v15 - 16);
        v15 -= 8;
        if (v14 >= *(_QWORD *)(v13 + 40))
        {
          v17 = (uint64_t *)((char *)a1 + v16);
          goto LABEL_12;
        }
      }
      v17 = a1;
LABEL_12:
      *v17 = v12;
      if (++v10 == 8)
        return v9 + 1 == a2;
    }
    v8 = v9;
    v11 += 8;
    if (++v9 == a2)
      return 1;
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,_MTLAxisAlignedBoundingBox *>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(float *a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD **v9;
  _QWORD *i;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  int8x8_t prime;
  void *v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  uint8x8_t v23;
  unint64_t v24;
  uint8x8_t v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  unint64_t v31;
  _QWORD *v33;

  v7 = *((_QWORD *)a1 + 1);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = a2;
  i[2] = *a3;
  i[3] = 0;
  v12 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v13 = a1[8];
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      prime = (int8x8_t)v16;
    else
      prime = (int8x8_t)v15;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v7 = *((_QWORD *)a1 + 1);
    }
    if (*(_QWORD *)&prime > v7)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v7)
    {
      v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (v25 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        v24 = std::__next_prime(v24);
      }
      else
      {
        v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2)
          v24 = v26;
      }
      if (*(_QWORD *)&prime <= v24)
        prime = (int8x8_t)v24;
      if (*(_QWORD *)&prime >= v7)
      {
        v7 = *((_QWORD *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v18 = operator new(8 * *(_QWORD *)&prime);
          v19 = *(_QWORD **)a1;
          *(_QWORD *)a1 = v18;
          if (v19)
            operator delete(v19);
          v20 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v20++) = 0;
          while (*(_QWORD *)&prime != v20);
          v21 = (_QWORD *)*((_QWORD *)a1 + 2);
          if (v21)
          {
            v22 = v21[1];
            v23 = (uint8x8_t)vcnt_s8(prime);
            v23.i16[0] = vaddlv_u8(v23);
            if (v23.u32[0] > 1uLL)
            {
              if (v22 >= *(_QWORD *)&prime)
                v22 %= *(_QWORD *)&prime;
            }
            else
            {
              v22 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v22) = a1 + 4;
            v27 = (_QWORD *)*v21;
            if (*v21)
            {
              do
              {
                v28 = v27[1];
                if (v23.u32[0] > 1uLL)
                {
                  if (v28 >= *(_QWORD *)&prime)
                    v28 %= *(_QWORD *)&prime;
                }
                else
                {
                  v28 &= *(_QWORD *)&prime - 1;
                }
                if (v28 != v22)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v28))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v28) = v21;
                    goto LABEL_55;
                  }
                  *v21 = *v27;
                  *v27 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v28);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v28) = v27;
                  v27 = v21;
                }
                v28 = v22;
LABEL_55:
                v21 = v27;
                v27 = (_QWORD *)*v27;
                v22 = v28;
              }
              while (v27);
            }
          }
          v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        v33 = *(_QWORD **)a1;
        *(_QWORD *)a1 = 0;
        if (v33)
          operator delete(v33);
        v7 = 0;
        *((_QWORD *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2)
        v3 = a2 % v7;
      else
        v3 = a2;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
  }
  v29 = *(_QWORD **)a1;
  v30 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v30)
  {
    *i = *v30;
LABEL_72:
    *v30 = i;
    goto LABEL_73;
  }
  *i = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = i;
  v29[v3] = a1 + 4;
  if (*i)
  {
    v31 = *(_QWORD *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v31 >= v7)
        v31 %= v7;
    }
    else
    {
      v31 &= v7 - 1;
    }
    v30 = (_QWORD *)(*(_QWORD *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
  return i;
}

void asvsAS2pmasv(AccelerationStructureViewerServer::AccelerationStructure *a1)
{
  operator new();
}

uint64_t AccelerationStructureViewerServer::DataSource::populateInstanceCount(uint64_t a1, unint64_t a2, uint64_t a3, AccelerationStructureViewer::Filter *a4)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v9;
  unint64_t v10;
  BOOL v11;
  uint64_t *v12;
  float **v13;
  float **v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float **v21;
  float *v22;

  *(_OWORD *)(a3 + 68) = xmmword_4AA430;
  *(_QWORD *)(a3 + 84) = 0x80000000800000;
  v7 = *(_QWORD *)(a1 + 16);
  result = a1 + 16;
  v6 = v7;
  if (!v7)
    goto LABEL_13;
  v9 = (_QWORD *)result;
  do
  {
    v10 = *(_QWORD *)(v6 + 32);
    v11 = v10 >= a2;
    if (v10 >= a2)
      v12 = (uint64_t *)v6;
    else
      v12 = (uint64_t *)(v6 + 8);
    if (v11)
      v9 = (_QWORD *)v6;
    v6 = *v12;
  }
  while (*v12);
  if (v9 == (_QWORD *)result || v9[4] > a2)
    goto LABEL_12;
  v14 = (float **)v9[5];
  v13 = (float **)v9[6];
  if (v14 == v13)
  {
    if (*((_BYTE *)a4 + 8))
    {
LABEL_12:
      v6 = 0;
LABEL_13:
      *(_QWORD *)(a3 + 40) = v6;
      return result;
    }
LABEL_24:
    v6 = v13 - v14;
    goto LABEL_13;
  }
  v15 = 3.4028e38;
  v16 = -3.4028e38;
  v17 = -3.4028e38;
  v18 = -3.4028e38;
  v19 = 3.4028e38;
  v20 = 3.4028e38;
  v21 = (float **)v9[5];
  do
  {
    v22 = *v21++;
    v20 = fminf(v20, v22[14]);
    *(float *)(a3 + 68) = v20;
    v19 = fminf(v19, v22[15]);
    *(float *)(a3 + 72) = v19;
    v15 = fminf(v15, v22[16]);
    *(float *)(a3 + 76) = v15;
    v18 = fmaxf(v18, v22[17]);
    *(float *)(a3 + 80) = v18;
    v17 = fmaxf(v17, v22[18]);
    *(float *)(a3 + 84) = v17;
    v16 = fmaxf(v16, v22[19]);
    *(float *)(a3 + 88) = v16;
  }
  while (v21 != v13);
  if (!*((_BYTE *)a4 + 8))
    goto LABEL_24;
  *(_QWORD *)(a3 + 40) = 0;
  do
  {
    result = AccelerationStructureViewer::DataSourceFilterable::matches((AccelerationStructureViewer::DataSourceFilterable *)(*v14 + 2), a4);
    if ((_DWORD)result)
      ++*(_QWORD *)(a3 + 40);
    ++v14;
  }
  while (v14 != (float **)v9[6]);
  return result;
}

void asvsAS2iasv(AccelerationStructureViewerServer::AccelerationStructure *a1)
{
  operator new();
}

void AccelerationStructureViewerServer::DataSource::~DataSource(AccelerationStructureViewerServer::DataSource *this)
{
  char *v2;
  char *v3;
  _QWORD *v4;
  _QWORD *v5;
  char *v6;
  char *v7;
  BOOL v8;
  uint64_t **i;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t j;
  uint64_t **k;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t m;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  void *v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  _QWORD *v41;
  _QWORD *v42;
  void *v43;
  void **v44;

  *(_QWORD *)this = off_727420;
  v2 = (char *)*((_QWORD *)this + 4);
  v3 = (char *)this + 40;
  if (v2 != (char *)this + 40)
  {
    do
    {
      v4 = (_QWORD *)*((_QWORD *)v2 + 5);
      v5 = (_QWORD *)*((_QWORD *)v2 + 6);
      if (v4 != v5)
      {
        do
        {
          if (*v4)
            (*(void (**)(_QWORD))(*(_QWORD *)*v4 + 8))(*v4);
          ++v4;
        }
        while (v4 != v5);
        v4 = (_QWORD *)*((_QWORD *)v2 + 5);
      }
      *((_QWORD *)v2 + 6) = v4;
      v6 = (char *)*((_QWORD *)v2 + 1);
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = *(char **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (char *)*((_QWORD *)v2 + 2);
          v8 = *(_QWORD *)v7 == (_QWORD)v2;
          v2 = v7;
        }
        while (!v8);
      }
      v2 = v7;
    }
    while (v7 != v3);
  }
  std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>>>::destroy(*((_QWORD **)this + 5));
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 4) = v3;
  for (i = (uint64_t **)*((_QWORD *)this + 9); i; i = (uint64_t **)*i)
    free(i[3]);
  if (*((_QWORD *)this + 10))
  {
    v10 = (_QWORD *)*((_QWORD *)this + 9);
    if (v10)
    {
      do
      {
        v11 = (_QWORD *)*v10;
        operator delete(v10);
        v10 = v11;
      }
      while (v11);
    }
    *((_QWORD *)this + 9) = 0;
    v12 = *((_QWORD *)this + 8);
    if (v12)
    {
      for (j = 0; j != v12; ++j)
        *(_QWORD *)(*((_QWORD *)this + 7) + 8 * j) = 0;
    }
    *((_QWORD *)this + 10) = 0;
  }
  for (k = (uint64_t **)*((_QWORD *)this + 14); k; k = (uint64_t **)*k)
    free(k[3]);
  if (*((_QWORD *)this + 15))
  {
    v15 = (_QWORD *)*((_QWORD *)this + 14);
    if (v15)
    {
      do
      {
        v16 = (_QWORD *)*v15;
        operator delete(v15);
        v15 = v16;
      }
      while (v16);
    }
    *((_QWORD *)this + 14) = 0;
    v17 = *((_QWORD *)this + 13);
    if (v17)
    {
      for (m = 0; m != v17; ++m)
        *(_QWORD *)(*((_QWORD *)this + 12) + 8 * m) = 0;
    }
    *((_QWORD *)this + 15) = 0;
  }
  v19 = *((_QWORD *)this + 23);
  if (*((_QWORD *)this + 24) != v19)
  {
    v20 = 0;
    v21 = 0;
    do
    {
      v22 = v19 + v20;
      v23 = *(void **)(v22 + 24);
      *(_QWORD *)(v22 + 24) = 0;

      v24 = *((_QWORD *)this + 23) + v20;
      v25 = *(void **)(v24 + 40);
      *(_QWORD *)(v24 + 40) = 0;

      v26 = *((_QWORD *)this + 23) + v20;
      v27 = *(void **)(v26 + 56);
      *(_QWORD *)(v26 + 56) = 0;

      v28 = *((_QWORD *)this + 23) + v20;
      v29 = *(void **)(v28 + 72);
      *(_QWORD *)(v28 + 72) = 0;

      v30 = *((_QWORD *)this + 23) + v20;
      v31 = *(void **)(v30 + 88);
      *(_QWORD *)(v30 + 88) = 0;

      v32 = *((_QWORD *)this + 23) + v20;
      v33 = *(void **)(v32 + 104);
      *(_QWORD *)(v32 + 104) = 0;

      v34 = *((_QWORD *)this + 23) + v20;
      v35 = *(void **)(v34 + 152);
      *(_QWORD *)(v34 + 152) = 0;

      v36 = *((_QWORD *)this + 23) + v20;
      v37 = *(void **)(v36 + 168);
      *(_QWORD *)(v36 + 168) = 0;

      ++v21;
      v19 = *((_QWORD *)this + 23);
      v20 += 184;
    }
    while (v21 < 0xD37A6F4DE9BD37A7 * ((*((_QWORD *)this + 24) - v19) >> 3));
  }
  v44 = (void **)((char *)this + 184);
  std::vector<AccelerationStructureViewerServer::AccelerationStructure>::__destroy_vector::operator()[abi:nn180100](&v44);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)this + 136);
  v38 = (_QWORD *)*((_QWORD *)this + 14);
  if (v38)
  {
    do
    {
      v39 = (_QWORD *)*v38;
      operator delete(v38);
      v38 = v39;
    }
    while (v39);
  }
  v40 = (void *)*((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = 0;
  if (v40)
    operator delete(v40);
  v41 = (_QWORD *)*((_QWORD *)this + 9);
  if (v41)
  {
    do
    {
      v42 = (_QWORD *)*v41;
      operator delete(v41);
      v41 = v42;
    }
    while (v42);
  }
  v43 = (void *)*((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (v43)
    operator delete(v43);
  std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>>>::destroy(*((_QWORD **)this + 5));
  std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>>>::destroy(*((_QWORD **)this + 2));
}

void std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>>>::destroy(_QWORD *a1)
{
  void *v2;

  if (a1)
  {
    std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::Geometry *>>>>::destroy(a1[1]);
    v2 = (void *)a1[5];
    if (v2)
    {
      a1[6] = v2;
      operator delete(v2);
    }
    operator delete(a1);
  }
}

void std::vector<AccelerationStructureViewerServer::APSUSCRayCollector>::resize(char **a1, unint64_t a2)
{
  char *v4;
  char *v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;

  v5 = *a1;
  v4 = a1[1];
  v6 = (v4 - *a1) >> 5;
  if (a2 > v6)
  {
    v7 = a1[2];
    if (a2 - v6 <= (v7 - v4) >> 5)
    {
      v24 = &v4[32 * (a2 - v6)];
      v25 = 32 * a2 - 32 * v6;
      do
      {
        *((_QWORD *)v4 + 2) = 0;
        *((_QWORD *)v4 + 3) = 0;
        *(_QWORD *)v4 = -1;
        *((_QWORD *)v4 + 1) = 0;
        v4 += 32;
        v25 -= 32;
      }
      while (v25);
      a1[1] = v24;
      return;
    }
    if (a2 >> 59)
      abort();
    v8 = v7 - v5;
    v9 = (v7 - v5) >> 4;
    if (v9 <= a2)
      v9 = a2;
    if (v8 >= 0x7FFFFFFFFFFFFFE0)
      v10 = 0x7FFFFFFFFFFFFFFLL;
    else
      v10 = v9;
    if (v10 >> 59)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v11 = (char *)operator new(32 * v10);
    v12 = &v11[32 * v6];
    v13 = &v11[32 * a2];
    v14 = 32 * a2 - 32 * v6;
    v15 = v12;
    do
    {
      *((_QWORD *)v15 + 2) = 0;
      *((_QWORD *)v15 + 3) = 0;
      *(_QWORD *)v15 = -1;
      *((_QWORD *)v15 + 1) = 0;
      v15 += 32;
      v14 -= 32;
    }
    while (v14);
    v16 = &v11[32 * v10];
    v18 = *a1;
    v17 = a1[1];
    if (v17 == *a1)
    {
      *a1 = v12;
      a1[1] = v13;
      a1[2] = v16;
      if (!v17)
        return;
    }
    else
    {
      do
      {
        *((_OWORD *)v12 - 2) = *((_OWORD *)v17 - 2);
        v19 = *((_OWORD *)v17 - 1);
        *((_QWORD *)v17 - 2) = 0;
        *((_OWORD *)v12 - 1) = v19;
        v12 -= 32;
        v17 -= 32;
      }
      while (v17 != v18);
      v20 = *a1;
      v17 = a1[1];
      *a1 = v12;
      a1[1] = v13;
      a1[2] = v16;
      if (v17 != v20)
      {
        do
        {
          v21 = v17 - 32;

          v17 = v21;
        }
        while (v21 != v20);
        v17 = v20;
      }
      if (!v17)
        return;
    }
    operator delete(v17);
    return;
  }
  if (a2 < v6)
  {
    v22 = &v5[32 * a2];
    if (v4 != v22)
    {
      do
      {
        v23 = v4 - 32;

        v4 = v23;
      }
      while (v23 != v22);
    }
    a1[1] = v22;
  }
}

void std::vector<std::mutex>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  std::mutex *v2;
  std::mutex *v4;
  void *v5;

  v1 = *a1;
  v2 = (std::mutex *)**a1;
  if (v2)
  {
    v4 = (std::mutex *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        std::mutex::~mutex(v4 - 1);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::deque<AccelerationStructureViewerServer::APSRawChunk>::~deque[abi:nn180100](uint64_t a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(void ***)(a1 + 8);
  v3 = *(void ***)(a1 + 16);
  *(_QWORD *)(a1 + 40) = 0;
  v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = *(void ***)(a1 + 16);
      v2 = (void **)(*(_QWORD *)(a1 + 8) + 8);
      *(_QWORD *)(a1 + 8) = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v5 = v4 >> 3;
  if (v5 == 1)
  {
    v6 = 64;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    v6 = 128;
LABEL_7:
    *(_QWORD *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    v9 = *(_QWORD *)(a1 + 8);
    v8 = *(_QWORD *)(a1 + 16);
    if (v8 != v9)
      *(_QWORD *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void AccelerationStructureViewerServer::Profiler::stopAPSStreaming(uint64_t a1, void *a2)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *i;
  int64x2_t *v14;
  id v15;

  v15 = a2;
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 752), "firstObject"));
  objc_msgSend(v3, "stopSampling");

  if (*(_BYTE *)(a1 + 32))
    NSLog(CFSTR("Waiting for accumulation workers to finish"));
  *(_BYTE *)(a1 + 432) = 0;
  v5 = *(_QWORD *)(a1 + 248);
  v4 = *(_QWORD *)(a1 + 256);
  if (v4 != v5)
  {
    v6 = 0;
    v7 = 0;
    do
    {
      std::thread::join((std::thread *)(v5 + v6));
      ++v7;
      v5 = *(_QWORD *)(a1 + 248);
      v4 = *(_QWORD *)(a1 + 256);
      v6 += 8;
    }
    while (v7 < (v4 - v5) >> 3);
    if (v4 != v5)
    {
      do
        std::thread::~thread((std::thread *)(v4 - 8));
      while (v4 != v5);
      v4 = v5;
    }
  }
  *(_QWORD *)(a1 + 256) = v4;
  if (*(_BYTE *)(a1 + 32))
    NSLog(CFSTR("Waiting for parser workers to finish"));
  v9 = *(_QWORD *)(a1 + 272);
  v8 = *(_QWORD *)(a1 + 280);
  if (v8 != v9)
  {
    v10 = 0;
    v11 = 0;
    do
    {
      std::thread::join((std::thread *)(v9 + v10));
      ++v11;
      v9 = *(_QWORD *)(a1 + 272);
      v8 = *(_QWORD *)(a1 + 280);
      v10 += 8;
    }
    while (v11 < (v8 - v9) >> 3);
    if (v8 != v9)
    {
      do
        std::thread::~thread((std::thread *)(v8 - 8));
      while (v8 != v9);
      v8 = v9;
    }
  }
  *(_QWORD *)(a1 + 280) = v8;
  if (*(_BYTE *)(a1 + 32))
    NSLog(CFSTR("Clearing out raw chunks"));
  if (*(_QWORD *)(a1 + 584) != *(_QWORD *)(a1 + 576))
  {
    v12 = 0;
    do
    {
      std::mutex::lock((std::mutex *)(*(_QWORD *)(a1 + 552) + (v12 << 6)));
      for (i = (_QWORD *)(*(_QWORD *)(a1 + 576) + 48 * v12); i[5]; i = (_QWORD *)(*(_QWORD *)(a1 + 576) + 48 * v12))
      {
        free(*(void **)(*(_QWORD *)(i[1] + ((i[4] >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (i[4] & 0x7FLL) + 16));
        v14 = (int64x2_t *)(*(_QWORD *)(a1 + 576) + 48 * v12);
        v14[2] = vaddq_s64(v14[2], (int64x2_t)xmmword_4A4EE0);
        std::deque<AccelerationStructureViewerServer::APSRawChunk>::__maybe_remove_front_spare[abi:nn180100]((uint64_t)v14);
      }
      std::mutex::unlock((std::mutex *)(*(_QWORD *)(a1 + 552) + (v12++ << 6)));
    }
    while (v12 < 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 584) - *(_QWORD *)(a1 + 576)) >> 4));
  }
  if (*(_BYTE *)(a1 + 32))
    NSLog(CFSTR("Clearing out free chunks"));
  std::mutex::lock((std::mutex *)(a1 + 440));
  while (*(_QWORD *)(a1 + 544))
  {
    free(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 512) + ((*(_QWORD *)(a1 + 536) >> 4) & 0xFFFFFFFFFFFFFF8))
                  + 32 * (*(_QWORD *)(a1 + 536) & 0x7FLL)
                  + 16));
    *(int64x2_t *)(a1 + 536) = vaddq_s64(*(int64x2_t *)(a1 + 536), (int64x2_t)xmmword_4A4EE0);
    std::deque<AccelerationStructureViewerServer::APSRawChunk>::__maybe_remove_front_spare[abi:nn180100](a1 + 504);
  }
  std::mutex::unlock((std::mutex *)(a1 + 440));
  if (*(_BYTE *)(a1 + 32))
    NSLog(CFSTR("Clearing out free ray buffers"));
  std::mutex::lock((std::mutex *)(a1 + 136));
  while (*(_QWORD *)(a1 + 240))
    std::deque<objc_object  {objcproto9MTLBuffer}* {__strong}>::pop_front(a1 + 200);
  std::mutex::unlock((std::mutex *)(a1 + 136));
  if (*(_BYTE *)(a1 + 32))
    NSLog(CFSTR("Streaming is no longer running"));

}

void std::__tree<std::__value_type<unsigned int,std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>>>>::destroy(a1[1]);
    std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>::~shared_ptr[abi:nn180100]((uint64_t)(a1 + 5));
    operator delete(a1);
  }
}

void std::vector<std::thread>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  std::thread *v2;
  std::thread *v4;
  void *v5;

  v1 = *a1;
  v2 = (std::thread *)**a1;
  if (v2)
  {
    v4 = (std::thread *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        std::thread::~thread(v4 - 1);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>::~shared_ptr[abi:nn180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

void std::deque<AccelerationStructureViewerServer::APSRawChunk>::__maybe_remove_front_spare[abi:nn180100](uint64_t a1)
{
  if (*(_QWORD *)(a1 + 32) >= 0x100uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(_QWORD *)(a1 + 8) += 8;
    *(_QWORD *)(a1 + 32) -= 128;
  }
}

void std::deque<objc_object  {objcproto9MTLBuffer}* {__strong}>::pop_front(uint64_t a1)
{
  int64x2_t v2;

  objc_release(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + ((*(_QWORD *)(a1 + 32) >> 6) & 0x3FFFFFFFFFFFFF8))
                     + 8 * (*(_QWORD *)(a1 + 32) & 0x1FFLL)));
  v2 = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_4A4EE0);
  *(int64x2_t *)(a1 + 32) = v2;
  if (v2.i64[0] >= 0x400uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(_QWORD *)(a1 + 8) += 8;
    *(_QWORD *)(a1 + 32) -= 512;
  }
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,AccelerationStructureViewerServer::Profiler::initAPSStreaming(objc_object  {objcproto9MTLDevice}*)::$_0>>(uint64_t a1)
{
  std::__thread_specific_ptr<std::__thread_struct> *v2;
  const void *v3;
  uint64_t v5;

  v5 = a1;
  v2 = std::__thread_local_data();
  v3 = *(const void **)a1;
  *(_QWORD *)a1 = 0;
  pthread_setspecific(v2->__key_, v3);
  AccelerationStructureViewerServer::Profiler::accumulationWorker(*(_QWORD *)(a1 + 8), *(void **)(a1 + 16), *(unsigned int *)(a1 + 24), *(unsigned int *)(a1 + 28));
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,AccelerationStructureViewerServer::Profiler::initAPSStreaming(objc_object  {objcproto9MTLDevice}*)::$_0>,std::default_delete<AccelerationStructureViewerServer::Profiler::initAPSStreaming(objc_object  {objcproto9MTLDevice}*)::$_0>>::~unique_ptr[abi:nn180100](&v5);
  return 0;
}

uint64_t *std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,AccelerationStructureViewerServer::Profiler::initAPSStreaming(objc_object  {objcproto9MTLDevice}*)::$_0>,std::default_delete<AccelerationStructureViewerServer::Profiler::initAPSStreaming(objc_object  {objcproto9MTLDevice}*)::$_0>>::~unique_ptr[abi:nn180100](uint64_t *result)
{
  uint64_t v1;

  v1 = *result;
  *result = 0;
  if (v1)
  {

    std::unique_ptr<std::__thread_struct>::reset[abi:nn180100]((std::__thread_struct **)v1);
    operator delete();
  }
  return result;
}

uint64_t std::__split_buffer<std::thread>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    std::thread::~thread((std::thread *)(i - 8));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,AccelerationStructureViewerServer::Profiler::initAPSStreaming(objc_object  {objcproto9MTLDevice}*)::$_1>>(uint64_t a1)
{
  std::__thread_specific_ptr<std::__thread_struct> *v2;
  const void *v3;
  uint64_t v5;

  v5 = a1;
  v2 = std::__thread_local_data();
  v3 = *(const void **)a1;
  *(_QWORD *)a1 = 0;
  pthread_setspecific(v2->__key_, v3);
  AccelerationStructureViewerServer::Profiler::parserWorker(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(void **)(a1 + 24));
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,AccelerationStructureViewerServer::Profiler::initAPSStreaming(objc_object  {objcproto9MTLDevice}*)::$_1>,std::default_delete<AccelerationStructureViewerServer::Profiler::initAPSStreaming(objc_object  {objcproto9MTLDevice}*)::$_1>>::~unique_ptr[abi:nn180100](&v5);
  return 0;
}

uint64_t *std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,AccelerationStructureViewerServer::Profiler::initAPSStreaming(objc_object  {objcproto9MTLDevice}*)::$_1>,std::default_delete<AccelerationStructureViewerServer::Profiler::initAPSStreaming(objc_object  {objcproto9MTLDevice}*)::$_1>>::~unique_ptr[abi:nn180100](uint64_t *result)
{
  uint64_t v1;

  v1 = *result;
  *result = 0;
  if (v1)
  {

    std::unique_ptr<std::__thread_struct>::reset[abi:nn180100]((std::__thread_struct **)v1);
    operator delete();
  }
  return result;
}

void AccelerationStructureViewerServer::Profiler::parserWorker(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  void *CFProperty;
  void *v6;
  int *v7;
  void *v8;
  id v9;
  const __CFString *v10;
  const __CFString *v11;
  const __CFString *v12;
  const __CFString *v13;
  const __CFString *v14;
  const __CFString *v15;
  const __CFString *v16;
  const __CFString *v17;
  const __CFString *v18;
  const __CFString *v19;
  uint64_t v20;
  void *v21;
  void *v22;
  void *v23;
  std::mutex *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  _BOOL4 v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  int64x2_t *v36;
  __int128 *v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  _QWORD *v42;
  uint64_t *v43;
  __int128 v44;
  _QWORD *v45;
  _QWORD *v46;
  uint64_t counter_num;
  uint64_t v48;
  unsigned int v49;
  unsigned int *v50;
  unsigned int v51;
  _QWORD *v52;
  _DWORD *v53;
  uint64_t v54;
  _DWORD *v55;
  std::__shared_weak_count *v56;
  std::unique_lock<std::mutex>::mutex_type **v57;
  std::unique_lock<std::mutex>::mutex_type *v58;
  uint64_t v59;
  _QWORD *v60;
  unsigned int v61;
  BOOL v62;
  uint64_t *v63;
  uint64_t kicks_num;
  uint64_t v65;
  unsigned int v66;
  uint64_t v67;
  std::__shared_weak_count *v68;
  uint64_t v69;
  _QWORD *v70;
  unsigned int v71;
  BOOL v72;
  uint64_t *v73;
  __n128 v74;
  std::__shared_weak_count *v75;
  unint64_t *p_shared_owners;
  unint64_t v77;
  std::__shared_weak_count *v78;
  unint64_t *v79;
  unint64_t v80;
  std::__shared_weak_count *v81;
  uint64_t v82;
  unint64_t *v83;
  unint64_t v84;
  unint64_t *v85;
  unint64_t v86;
  BOOL v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t *v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  uint64_t v96;
  uint64_t *v97;
  _DWORD *v98;
  unsigned int v99;
  unint64_t *v100;
  std::__shared_weak_count *v101;
  uint64_t v102;
  unint64_t v103;
  unint64_t v104;
  uint64_t v105;
  uint64_t v106;
  __CFString *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  unint64_t *v111;
  unint64_t v112;
  int64x2_t v113;
  unint64_t v114;
  uint64_t v115;
  std::__shared_weak_count *i;
  std::condition_variable *v117;
  unint64_t v118;
  uint64_t v119;
  uint64_t v120;
  unint64_t *v121;
  unint64_t v122;
  unint64_t v123;
  uint64_t v125;
  uint64_t v126;
  unint64_t v127;
  unsigned int v128;
  std::__shared_weak_count *v129;
  unint64_t *v130;
  unint64_t v131;
  std::__shared_weak_count *v132;
  uint64_t v133;
  uint64_t v134;
  std::__shared_weak_count *v135;
  unint64_t *v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t *v139;
  unint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  unint64_t m;
  unint64_t v145;
  unint64_t v146;
  unint64_t v147;
  unint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  unsigned int v158;
  uint64_t v159;
  _QWORD *v160;
  uint64_t v161;
  uint64_t v162;
  unint64_t v163;
  unint64_t v164;
  void **v165;
  void **v166;
  _QWORD *v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  unint64_t v171;
  unint64_t v172;
  uint64_t v173;
  void *v174;
  std::__shared_weak_count *v175;
  unint64_t *v176;
  unint64_t v177;
  unint64_t v178;
  uint64_t v179;
  uint64_t v180;
  unint64_t v181;
  uint64_t v182;
  std::__shared_weak_count *v183;
  std::__shared_weak_count *v184;
  void *v185;
  unint64_t *v186;
  std::unique_lock<std::mutex>::mutex_type **v187;
  _DWORD *v188;
  unsigned int v189;
  uint64_t v190;
  _DWORD *v192;
  _QWORD *v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  std::unique_lock<std::mutex>::mutex_type *v197;
  unsigned int v198;
  unsigned int v199;
  std::__shared_weak_count *v200;
  std::__shared_weak_count *v201;
  std::__shared_weak_count *v202;
  unsigned int v203;
  uint64_t v204;
  unsigned int v205;
  uint64_t v206;
  unint64_t *v207;
  std::mutex *v208;
  unint64_t v209;
  std::unique_lock<std::mutex>::mutex_type *v210;
  unsigned int v211;
  unsigned int v212;
  uint64_t v213;
  unsigned int v214;
  unsigned int counter_index;
  uint64_t v216;
  char v217;
  uint64_t v218;
  unint64_t v219;
  uint64_t v220;
  uint64_t v221;
  unint64_t v222;
  uint64_t v223;
  unint64_t v224;
  uint64_t v225;
  unint64_t v226;
  std::unique_lock<std::mutex> v227;
  uint64_t v228;
  std::__shared_weak_count *v229;
  std::unique_lock<std::mutex>::mutex_type *__dst;
  uint64_t v231;
  unint64_t v232;
  std::unique_lock<std::mutex> v233;
  std::condition_variable *v234;
  std::__shared_weak_count *v235;
  unsigned int v236;
  __int128 v237;
  __int128 v238;
  _QWORD v239[4];
  unsigned __int128 v240;
  uint64_t v241;
  int v242;
  uint64_t v243;
  uint64_t v244;
  int v245;
  __int128 v246;
  __int128 v247;
  int64x2_t v248;

  v4 = a3;
  if (*(_BYTE *)(a1 + 32))
    NSLog(CFSTR("Started parser worker"));
  v185 = v4;
  CFProperty = (void *)IORegistryEntryCreateCFProperty((io_registry_entry_t)objc_msgSend(v4, "acceleratorPort"), CFSTR("GPUConfigurationVariable"), 0, 0);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(CFProperty, "objectForKeyedSubscript:", CFSTR("gpu_gen")));
  v7 = (int *)objc_msgSend(v6, "unsignedIntegerValue");

  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(CFProperty, "objectForKeyedSubscript:", CFSTR("num_cores")));
  v9 = objc_msgSend(v8, "unsignedIntegerValue");

  if (v7 == &dword_10)
  {
    v17 = CFSTR("B0");
    v18 = CFSTR("G");
    v19 = CFSTR("C");
    if ((unint64_t)v9 < 0x15)
      v19 = CFSTR("S");
    if ((unint64_t)v9 >= 0xB)
    {
      v18 = v19;
      v17 = CFSTR("A0");
    }
    if ((unint64_t)v9 >= 8)
      v15 = v18;
    else
      v15 = CFSTR("P");
    if ((unint64_t)v9 >= 8)
      v16 = v17;
    else
      v16 = CFSTR("B1");
  }
  else if (v7 == (int *)((char *)&dword_C + 3))
  {
    v10 = CFSTR("A0");
    v11 = CFSTR("P");
    v12 = CFSTR("G");
    v13 = CFSTR("S");
    v14 = CFSTR("D");
    if ((unint64_t)v9 < 0x29)
    {
      v14 = CFSTR("C");
      v10 = CFSTR("B0");
    }
    if ((unint64_t)v9 < 0x15)
      v10 = CFSTR("B0");
    else
      v13 = v14;
    if ((unint64_t)v9 < 0xB)
      v10 = CFSTR("C0");
    else
      v12 = v13;
    if ((unint64_t)v9 < 8)
      v10 = CFSTR("B1");
    else
      v11 = v12;
    if ((unint64_t)v9 >= 4)
      v15 = v11;
    else
      v15 = CFSTR("M");
    if ((unint64_t)v9 >= 4)
      v16 = v10;
    else
      v16 = CFSTR("B0");
  }
  else
  {
    if ((unint64_t)v9 >= 8)
      v15 = CFSTR("G");
    else
      v15 = CFSTR("P");
    if ((unint64_t)v7 - 18 <= 0xFFFFFFFFFFFFFFF7)
    {
      v20 = agxps_gpu_invalid_handle();
      goto LABEL_44;
    }
    v16 = CFSTR("A0");
  }
  v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(&off_739608, "objectForKey:", v15));
  v22 = v21;
  if (v21)
  {
    objc_msgSend(v21, "unsignedIntegerValue");
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(&off_739630, "objectForKey:", v16));
    if (v23)
    {
      objc_msgSend(v23, "unsignedIntegerValue");
      agxps_gpu_create();
    }
    v20 = agxps_gpu_invalid_handle();

  }
  else
  {
    v20 = agxps_gpu_invalid_handle();
  }

LABEL_44:
  if (!agxps_gpu_is_valid(v20))
  {
    NSLog(CFSTR("The Acceleration Structure Viewer does not support hardware counters for this GPU"));
    exit(1);
  }
  v241 = v20;
  v242 = *(_DWORD *)(a1 + 816);
  v243 = *(_QWORD *)(a1 + 808);
  v244 = 4096;
  v245 = 0;
  v240 = 0u;
  memset(v239, 0, sizeof(v239));
  if (*(_BYTE *)(a1 + 432))
  {
    v208 = (std::mutex *)(a1 + 624);
    v24 = (std::mutex *)(a1 + 440);
    v25 = -1;
    while (2)
    {
      while (*(_QWORD *)(a1 + 584) == *(_QWORD *)(a1 + 576))
      {
LABEL_65:
        usleep(0x3E8u);
        if (!*(_BYTE *)(a1 + 432))
          goto LABEL_320;
      }
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = -1;
      while (1)
      {
        v30 = std::mutex::try_lock((std::mutex *)(*(_QWORD *)(a1 + 552) + v27));
        v31 = *(_QWORD *)(a1 + 576);
        if (v30)
          break;
LABEL_63:
        ++v28;
        v27 += 64;
        v26 += 48;
        if (v28 >= 0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 584) - v31) >> 4))
        {
          if (v29 != -1)
            goto LABEL_68;
          goto LABEL_65;
        }
      }
      v32 = *(_QWORD *)(v31 + v26 + 40);
      if (!v32)
      {
        v35 = v29;
LABEL_62:
        std::mutex::unlock((std::mutex *)(*(_QWORD *)(a1 + 552) + v27));
        v31 = *(_QWORD *)(a1 + 576);
        v29 = v35;
        goto LABEL_63;
      }
      v33 = *(_QWORD *)(*(_QWORD *)(v31 + v26 + 8) + ((*(_QWORD *)(v31 + v26 + 32) >> 4) & 0xFFFFFFFFFFFFFF8))
          + 32 * (*(_QWORD *)(v31 + v26 + 32) & 0x7FLL);
      v34 = *(_QWORD *)(v33 + 8) != *(_QWORD *)(*(_QWORD *)(a1 + 600) + 131200 * *(unsigned __int16 *)(v33 + 2) + 24)
         || v32 >= v25;
      if (v34)
        goto LABEL_58;
      if (v29 != -1)
      {
        std::mutex::unlock((std::mutex *)(*(_QWORD *)(a1 + 552) + (v29 << 6)));
        v31 = *(_QWORD *)(a1 + 576);
      }
      v25 = *(_QWORD *)(v31 + v26 + 40);
      v29 = v28;
      if (v25 != 1)
      {
LABEL_58:
        v35 = v29;
        v87 = v28 == v29;
        v29 = v28;
        if (v87)
          goto LABEL_63;
        goto LABEL_62;
      }
      v29 = v28;
LABEL_68:
      if (*(_BYTE *)(a1 + 432))
      {
        v36 = (int64x2_t *)(v31 + 48 * v29);
        v37 = (__int128 *)(*(_QWORD *)(v36->i64[1] + (((unint64_t)v36[2].i64[0] >> 4) & 0xFFFFFFFFFFFFFF8))
                         + 32 * (v36[2].i64[0] & 0x7F));
        v38 = v37[1];
        v237 = *v37;
        v238 = v38;
        v36[2] = vaddq_s64(v36[2], (int64x2_t)xmmword_4A4EE0);
        std::deque<AccelerationStructureViewerServer::APSRawChunk>::__maybe_remove_front_spare[abi:nn180100]((uint64_t)v36);
        std::mutex::unlock((std::mutex *)(*(_QWORD *)(a1 + 552) + (v29 << 6)));
        v39 = WORD1(v237);
        v40 = *(_QWORD *)(a1 + 600);
        v41 = (uint64_t *)(v40 + 131200 * WORD1(v237));
        if ((_BYTE)v237)
        {
          if (*((_QWORD *)&v237 + 1))
            agxps_aps_parser_destroy(*v41);
          v42 = (_QWORD *)(v40 + 131200 * v39);
          v42[6] = 0;
          v42[7] = 0;
          v42 += 16393;
          *v42 = 0;
          v42[1] = 0;
          *(_QWORD *)(v40 + 131200 * v39 + 131136) = 0;
          v43 = agxps_aps_parser_create(&v241);
          *v41 = (uint64_t)v43;
          if (*(_BYTE *)(a1 + 32) && !v43)
            NSLog(CFSTR("Parser is missing opaque"));
          v246 = *(_OWORD *)off_727508;
          v247 = *(_OWORD *)off_727518;
          agxps_aps_parser_set_counter_filter(*v41, &v246, 4uLL);
        }
        v44 = v238;
        if (*(_BYTE *)(a1 + 32) && (!(_QWORD)v238 || !*((_QWORD *)&v238 + 1)))
          NSLog(CFSTR("Chunk is nullptr 0x%llx or zero %zu"), v238);
        v236 = 0;
        v45 = agxps_aps_parser_parse((uint64_t (***)(_QWORD))*v41, v44, *((uint64_t *)&v44 + 1), 6, &v236);
        if (v236)
          NSLog(CFSTR("An error %d occured while parsing chunk %llu of usc %d"), v236, *((_QWORD *)&v237 + 1), v39);
        v46 = (_QWORD *)(a1 + 736);
        if (!v45 && *(_BYTE *)(a1 + 32))
          NSLog(CFSTR("Chunk %llu of usc %d does not have any opaque data"), *((_QWORD *)&v237 + 1), v39);
        counter_num = agxps_aps_profile_data_get_counter_num((uint64_t)v45);
        if (!v45 || !counter_num || v236)
        {
          if (v236)
          {
            NSLog(CFSTR("Chunk had an error"));
            v52 = (_QWORD *)(a1 + 504);
          }
          else
          {
            v52 = (_QWORD *)(a1 + 504);
            if (!v45)
              NSLog(CFSTR("Chunk is not opaque"));
          }
LABEL_308:
          if (*((_QWORD *)&v240 + 1) < 0x80uLL)
          {
            std::deque<AccelerationStructureViewerServer::APSRawChunk>::push_back(v239, (uint64_t)&v237);
          }
          else
          {
            std::mutex::lock(v24);
            if (*((_QWORD *)&v240 + 1))
            {
              v178 = v240;
              do
              {
                std::deque<AccelerationStructureViewerServer::APSRawChunk>::push_back(v52, *(_QWORD *)(v239[1] + ((v178 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v178 & 0x7F));
                v179 = *((_QWORD *)&v240 + 1) - 1;
                v178 = v240 + 1;
                v240 = __PAIR128__(*((unint64_t *)&v240 + 1), (uint64_t)v240 + 1) + __PAIR128__(-1, 0);
                if (v178 >= 0x100)
                {
                  operator delete(*(void **)v239[1]);
                  v178 = v240 - 128;
                  v239[1] += 8;
                  *(_QWORD *)&v240 = v240 - 128;
                  v179 = *((_QWORD *)&v240 + 1);
                }
              }
              while (v179);
            }
            std::deque<AccelerationStructureViewerServer::APSRawChunk>::push_back(v52, (uint64_t)&v237);
            std::mutex::unlock(v24);
          }
          v180 = WORD1(v237);
          std::mutex::lock((std::mutex *)(*(_QWORD *)(a1 + 552) + ((unint64_t)WORD1(v237) << 6)));
          ++*(_QWORD *)(v40 + 131200 * v39 + 24);
          std::mutex::unlock((std::mutex *)(*(_QWORD *)(a1 + 552) + (v180 << 6)));
          v25 = -1;
          if (!*(_BYTE *)(a1 + 432))
            goto LABEL_320;
          continue;
        }
        v48 = v40 + 131200 * v39;
        v51 = *(_DWORD *)(v48 + 8);
        v50 = (unsigned int *)(v48 + 8);
        v49 = v51;
        if (v51 == -1)
        {
          *v50 = agxps_aps_profile_data_get_counter_index(v45);
          v53 = (_DWORD *)(v40 + 131200 * v39);
          v53[3] = agxps_aps_profile_data_get_counter_index(v45);
          v53[4] = agxps_aps_profile_data_get_counter_index(v45);
          counter_index = agxps_aps_profile_data_get_counter_index(v45);
          v53[5] = counter_index;
          v46 = (_QWORD *)(a1 + 736);
          v211 = *v50;
        }
        else
        {
          v211 = v49;
          counter_index = *(_DWORD *)(v40 + 131200 * v39 + 20);
        }
        v54 = v40 + 131200 * v39;
        v212 = *(_DWORD *)(v54 + 12);
        v214 = *(_DWORD *)(v54 + 16);
        v55 = (_DWORD *)(v54 + 131160);
        v56 = (std::__shared_weak_count *)*(unsigned int *)(v54 + 131160);
        v57 = (std::unique_lock<std::mutex>::mutex_type **)(v54 + 131168);
        v58 = *(std::unique_lock<std::mutex>::mutex_type **)(v54 + 131168);
        v234 = 0;
        v235 = 0;
        v247 = 0u;
        v248 = 0u;
        v246 = 0u;
        v233.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 624);
        v233.__owns_ = 1;
        std::mutex::lock(v208);
        v187 = v57;
        v188 = v55;
        if ((_DWORD)v56 && v58)
        {
          v59 = *v46;
          if (!*v46)
            goto LABEL_106;
          v197 = v58;
          v60 = v46;
          do
          {
            v61 = *(_DWORD *)(v59 + 32);
            v62 = v61 >= v56;
            if (v61 >= v56)
              v63 = (uint64_t *)v59;
            else
              v63 = (uint64_t *)(v59 + 8);
            if (v62)
              v60 = (_QWORD *)v59;
            v59 = *v63;
          }
          while (*v63);
          if (v60 != v46 && v56 >= *((_DWORD *)v60 + 8))
          {
            v200 = v56;
            std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>::operator=[abi:nn180100](&v234, v60[5], v60[6]);
          }
          else
          {
LABEL_106:
            v197 = 0;
            v200 = 0;
          }
        }
        else
        {
          v197 = v58;
          v200 = v56;
        }
        v190 = v40;
        kicks_num = agxps_aps_profile_data_get_kicks_num((uint64_t)v45);
        if (kicks_num)
        {
          v65 = kicks_num;
          v66 = 0;
          v217 = 0;
          v67 = 0;
          v209 = -1;
          while (1)
          {
            v232 = 0;
            if (!agxps_aps_profile_data_get_kick_software_id((uint64_t)v45, &v232, v67, 1))
              goto LABEL_152;
            if (!agxps_aps_profile_data_get_kick_start((uint64_t)v45, &v231, v67, 1))
              goto LABEL_152;
            __dst = 0;
            if (!agxps_aps_profile_data_get_usc_timestamps((uint64_t)v45, &__dst, HIDWORD(v231), 1))
              goto LABEL_152;
            v68 = (std::__shared_weak_count *)HIDWORD(v232);
            v69 = *v46;
            if (*v46)
            {
              v70 = v46;
              do
              {
                v71 = *(_DWORD *)(v69 + 32);
                v72 = v71 >= HIDWORD(v232);
                if (v71 >= HIDWORD(v232))
                  v73 = (uint64_t *)v69;
                else
                  v73 = (uint64_t *)(v69 + 8);
                if (v72)
                  v70 = (_QWORD *)v69;
                v69 = *v73;
              }
              while (*v73);
              if (v70 != v46 && *((_DWORD *)v70 + 8) <= HIDWORD(v232))
                break;
            }
            if (std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>((_QWORD *)(a1 + 688), HIDWORD(v232)))
            {
              if ((v234 != 0) | v217 & 1)
              {
                v227.__m_ = __dst;
                *(_DWORD *)&v227.__owns_ = (_DWORD)v68;
                v228 = 0;
                v229 = 0;
                v74 = std::deque<std::pair<unsigned long long,std::pair<unsigned int,std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>>>>::push_back(&v246, (__n128 *)&v227);
                v75 = v229;
                if (v229)
                {
                  p_shared_owners = (unint64_t *)&v229->__shared_owners_;
                  do
                    v77 = __ldaxr(p_shared_owners);
                  while (__stlxr(v77 - 1, p_shared_owners));
LABEL_143:
                  if (!v77)
                  {
                    ((void (*)(std::__shared_weak_count *, __n128))v75->__on_zero_shared)(v75, v74);
                    std::__shared_weak_count::__release_weak(v75);
                  }
                }
                goto LABEL_145;
              }
              v78 = v235;
              v234 = 0;
              v235 = 0;
              if (v78)
              {
                v79 = (unint64_t *)&v78->__shared_owners_;
                do
                  v80 = __ldaxr(v79);
                while (__stlxr(v80 - 1, v79));
                if (!v80)
                {
                  ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
                  std::__shared_weak_count::__release_weak(v78);
                }
              }
              v217 = 1;
LABEL_151:
              v197 = __dst;
              v200 = v68;
            }
LABEL_152:
            if (++v67 == v65)
              goto LABEL_157;
          }
          if ((v234 != 0) | v217 & 1)
          {
            v82 = v70[5];
            v81 = (std::__shared_weak_count *)v70[6];
            if (v81)
            {
              v83 = (unint64_t *)&v81->__shared_owners_;
              do
                v84 = __ldxr(v83);
              while (__stxr(v84 + 1, v83));
            }
            v227.__m_ = __dst;
            *(_DWORD *)&v227.__owns_ = (_DWORD)v68;
            v228 = v82;
            v229 = v81;
            v74 = std::deque<std::pair<unsigned long long,std::pair<unsigned int,std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>>>>::push_back(&v246, (__n128 *)&v227);
            v75 = v229;
            if (v229)
            {
              v85 = (unint64_t *)&v229->__shared_owners_;
              do
                v77 = __ldaxr(v85);
              while (__stlxr(v77 - 1, v85));
              goto LABEL_143;
            }
LABEL_145:
            v86 = v209;
            v87 = v209 == -1;
            if (v209 == -1)
              v86 = (unint64_t)__dst;
            v209 = v86;
            if (v87)
              v66 = v68;
            goto LABEL_152;
          }
          std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>::operator=[abi:nn180100](&v234, v70[5], v70[6]);
          v217 = 0;
          goto LABEL_151;
        }
        v66 = 0;
        v209 = -1;
LABEL_157:
        v203 = v66;
        std::unique_lock<std::mutex>::unlock(&v233);
        v231 = 0;
        v232 = 0;
        __dst = 0;
        if (v211 != -1)
        {
          agxps_aps_profile_data_get_counter_values_num_by_index((uint64_t)v45, (uint64_t *)&v232, v211);
          agxps_aps_profile_data_get_counter_values_by_index((uint64_t)v45, &v231, v211);
          agxps_aps_profile_data_get_counter_group_metadata_by_index(v45, &__dst, v211);
        }
        v225 = 0;
        v226 = 0;
        v223 = 0;
        v224 = 0;
        v221 = 0;
        v222 = 0;
        v220 = 0;
        if (v212 != -1)
        {
          agxps_aps_profile_data_get_counter_values_num_by_index((uint64_t)v45, (uint64_t *)&v226, v212);
          if (v226)
          {
            agxps_aps_profile_data_get_counter_values_by_index((uint64_t)v45, &v225, v212);
            agxps_aps_profile_data_get_counter_group_metadata_by_index(v45, &v220, v212);
          }
        }
        if (v214 != -1)
        {
          agxps_aps_profile_data_get_counter_values_num_by_index((uint64_t)v45, (uint64_t *)&v224, v214);
          if (v224)
            agxps_aps_profile_data_get_counter_values_by_index((uint64_t)v45, &v223, v214);
        }
        if (counter_index != -1)
        {
          agxps_aps_profile_data_get_counter_values_num_by_index((uint64_t)v45, (uint64_t *)&v222, counter_index);
          if (v222)
            agxps_aps_profile_data_get_counter_values_by_index((uint64_t)v45, &v221, counter_index);
        }
        v88 = v224;
        if (v224 >= v232)
          v88 = v232;
        v232 = v88;
        if (v222 >= v226)
          v89 = v226;
        else
          v89 = v222;
        v226 = v89;
        v90 = v190 + 131200 * v39;
        v93 = *(_QWORD *)(v90 + 48);
        v91 = (unint64_t *)(v90 + 48);
        v92 = v93;
        v218 = (uint64_t)v45;
        v189 = v39;
        if (v88)
        {
          v186 = v91;
          v94 = 0;
          v95 = 0;
          v96 = v190 + 131200 * v39;
          v207 = (unint64_t *)(v96 + 131136);
          v97 = (uint64_t *)(v96 + 131184);
          v193 = (_QWORD *)(v96 + 131176);
          v192 = (_DWORD *)(v96 + 131188);
          v98 = (_DWORD *)(v96 + 131192);
          v216 = v96 + 65600;
          v99 = v39;
          v100 = (unint64_t *)(v96 + 131144);
          v213 = v190 + 131200 * v99;
          while (1)
          {
            v101 = *(std::__shared_weak_count **)(v231 + 8 * v94);
            v102 = *(_QWORD *)(v223 + 8 * v94);
            v219 = 0;
            if ((agxps_aps_profile_data_get_usc_timestamps((uint64_t)v45, &v219, *((unsigned int *)&__dst->__m_.__sig + 2 * v94 + 1), 1) & 1) == 0&& *(_BYTE *)(a1 + 32))
            {
              NSLog(CFSTR("Unable to get intersect timestamp"));
            }
            v103 = v219;
            v104 = v209;
            if (!v219)
            {
              v103 = (*v207 + *(unsigned int *)(a1 + 812)) % 0xFFFFF;
              v219 = v103;
            }
            *v207 = v103;
            if (!v234)
            {
              if (!v101)
                goto LABEL_246;
              goto LABEL_245;
            }
            v206 = v102;
            if (v219 < v209)
            {
              v105 = v209;
              v106 = v203;
              v104 = (unint64_t)v197;
              goto LABEL_183;
            }
            if (v248.i64[1])
            {
              v108 = *(_QWORD *)(*((_QWORD *)&v246 + 1) + (((unint64_t)v248.i64[0] >> 4) & 0xFFFFFFFFFFFFFF8))
                   + 32 * (v248.i8[0] & 0x7F);
              v109 = *(_QWORD *)(v108 + 16);
              v110 = *(_QWORD *)(v108 + 24);
              if (v110)
              {
                v111 = (unint64_t *)(v110 + 8);
                do
                  v112 = __ldxr(v111);
                while (__stxr(v112 + 1, v111));
              }
              v201 = (std::__shared_weak_count *)v110;
              std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>::operator=[abi:nn180100](&v234, v109, v110);
              std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>::~shared_ptr[abi:nn180100](*(_QWORD *)(*((_QWORD *)&v246 + 1) + (((unint64_t)v248.i64[0] >> 4) & 0xFFFFFFFFFFFFFF8))+ 32 * (v248.i8[0] & 0x7F)+ 16);
              v113 = vaddq_s64(v248, (int64x2_t)xmmword_4A4EE0);
              v248 = v113;
              v114 = v113.i64[0];
              if (v113.i64[0] >= 0x100uLL)
              {
                operator delete(**((void ***)&v246 + 1));
                v114 = v248.i64[0] - 128;
                *((_QWORD *)&v246 + 1) += 8;
                v248.i64[0] -= 128;
                v115 = v248.i64[1];
              }
              else
              {
                v115 = v113.i64[1];
              }
              v129 = v201;
              if (v115)
              {
                v134 = *(_QWORD *)(*((_QWORD *)&v246 + 1) + ((v114 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v114 & 0x7F);
                v105 = *(_QWORD *)v134;
                v133 = *(unsigned int *)(v134 + 8);
                v135 = *(std::__shared_weak_count **)(v134 + 24);
                if (v135)
                {
                  v195 = *(_QWORD *)v134;
                  v136 = (unint64_t *)&v135->__shared_owners_;
                  do
                    v137 = __ldxr(v136);
                  while (__stxr(v137 + 1, v136));
                  do
                    v138 = __ldaxr(v136);
                  while (__stlxr(v138 - 1, v136));
                  if (!v138)
                  {
                    v198 = v133;
                    ((void (*)(std::__shared_weak_count *))v135->__on_zero_shared)(v135);
                    std::__shared_weak_count::__release_weak(v135);
                    v133 = v198;
                    v129 = v201;
                  }
                  v105 = v195;
                }
                if (!v129)
                {
LABEL_240:
                  v200 = (std::__shared_weak_count *)v203;
                  v106 = v133;
                  goto LABEL_183;
                }
              }
              else
              {
                v133 = 0;
                v105 = -1;
                if (!v201)
                  goto LABEL_240;
              }
              v139 = (unint64_t *)&v129->__shared_owners_;
              do
                v140 = __ldaxr(v139);
              while (__stlxr(v140 - 1, v139));
              v132 = (std::__shared_weak_count *)v203;
              v200 = (std::__shared_weak_count *)v203;
              v106 = v133;
              if (!v140)
                goto LABEL_238;
            }
            else
            {
              v129 = v235;
              v234 = 0;
              v235 = 0;
              if (v129)
              {
                v130 = (unint64_t *)&v129->__shared_owners_;
                do
                  v131 = __ldaxr(v130);
                while (__stlxr(v131 - 1, v130));
                v132 = 0;
                LODWORD(v133) = 0;
                v104 = 0;
                v200 = 0;
                v106 = 0;
                v105 = -1;
                if (!v131)
                {
LABEL_238:
                  v202 = v129;
                  v199 = v133;
                  v196 = v105;
                  ((void (*)(std::__shared_weak_count *))v129->__on_zero_shared)(v129);
                  std::__shared_weak_count::__release_weak(v202);
                  v105 = v196;
                  v200 = v132;
                  v106 = v199;
                }
              }
              else
              {
                v200 = 0;
                v106 = 0;
                v104 = 0;
                v105 = -1;
              }
            }
LABEL_183:
            if (v101)
            {
              v102 = v206;
              if (v234)
              {
                if (v219 < v104)
                {
                  if (!WORD1(v237) && *(_BYTE *)(a1 + 32))
                  {
                    v183 = v200;
                    v184 = v101;
                    v107 = CFSTR("%d hasn't started yet - ignoring %llu rays");
                    goto LABEL_243;
                  }
LABEL_199:
                  v197 = (std::unique_lock<std::mutex>::mutex_type *)v104;
                  v203 = v106;
                  v104 = v105;
LABEL_245:
                  *v193 += v101;
                  *v97 = 0;
                  *v98 = 0;
                  goto LABEL_246;
                }
                v204 = v106;
                v194 = v105;
                v210 = (std::unique_lock<std::mutex>::mutex_type *)v104;
                for (i = 0; i != v101; i = (std::__shared_weak_count *)((char *)i + 1))
                {
                  v117 = v234 + 1;
                  do
                    v118 = __ldaxr((unint64_t *)v117);
                  while (__stlxr(v118 + 1, (unint64_t *)v117));
                  if (v118 < *(_QWORD *)v234[1].__cv_.__opaque)
                  {
                    v119 = WORD1(v237);
                    v120 = *(_QWORD *)&v234[1].__cv_.__opaque[8];
                    v121 = (unint64_t *)(v120 + 32 * WORD1(v237));
                    v122 = *v121;
                    v123 = v121[1];
                    if (*v121 != -1 && v122 >= v123)
                    {
                      if (*(_BYTE *)(a1 + 32))
                        NSLog(CFSTR("uscRayCollector is full (%llu/%llu)"), *v121, v123);
                    }
                    else
                    {
                      *v121 = v122 + 1;
                      if (v122 < v123)
                      {
                        v125 = *(_QWORD *)(v120 + 32 * v119 + 24) + 12 * v122;
                        v126 = *v97;
                        *(_DWORD *)(v125 + 8) = *((_DWORD *)v97 + 2);
                        *(_QWORD *)v125 = v126;
                      }
                    }
                  }
                  v127 = *(_QWORD *)v234[1].__cv_.__opaque;
                  if (v118 == v127 - 1)
                  {
                    v227.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 624);
                    v227.__owns_ = 1;
                    std::mutex::lock(v208);
                    std::condition_variable::notify_one(v234);
                    std::unique_lock<std::mutex>::unlock(&v227);
                    if (v227.__owns_)
                      std::mutex::unlock(v227.__m_);
                  }
                  else if (v118 >= v127 && *(_BYTE *)(a1 + 32))
                  {
                    NSLog(CFSTR("ray collector is over-filled (%llu/%llu) on usc %hu with worker %zu. Current encoder is %u. Next encoder is %u."), v118, v127, WORD1(v237), a2, v200, v204);
                  }
                }
                v197 = v210;
                v128 = v204;
                v102 = v206;
              }
              else
              {
                if (WORD1(v237) || !*(_BYTE *)(a1 + 32))
                  goto LABEL_199;
                v183 = v101;
                v107 = CFSTR("No collector for %llu rays");
LABEL_243:
                v194 = v105;
                v205 = v106;
                NSLog(&v107->isa, v183, v184);
                v197 = (std::unique_lock<std::mutex>::mutex_type *)v104;
                v128 = v205;
              }
              v203 = v128;
              v104 = v194;
              goto LABEL_245;
            }
            v197 = (std::unique_lock<std::mutex>::mutex_type *)v104;
            v203 = v106;
            v104 = v105;
            v102 = v206;
LABEL_246:
            if (v102)
              *v192 += v102;
            v209 = v104;
            if (v95 < v226 + v92)
            {
              v141 = 4 - 8 * v92 + 8 * v95;
              do
              {
                v227.__m_ = 0;
                if (v95 >= v92)
                {
                  v142 = *(_QWORD *)(v225 - 8 * v92 + 8 * v95);
                  v143 = *(_QWORD *)(v221 - 8 * v92 + 8 * v95);
                  if ((agxps_aps_profile_data_get_usc_timestamps(v218, &v227, *(unsigned int *)(v220 + v141), 1) & 1) == 0
                    && *(_BYTE *)(a1 + 32))
                  {
                    NSLog(CFSTR("Unable to get counter timestamp"));
                  }
                  m = (unint64_t)v227.__m_;
                }
                else
                {
                  v142 = *(_QWORD *)(v216 + 8 * v95);
                  v143 = *(_QWORD *)(v213 + 98368 + 8 * v95);
                  m = *(_QWORD *)(v213 + 8 * v95 + 64);
                  v227.__m_ = (std::unique_lock<std::mutex>::mutex_type *)m;
                }
                v145 = *(unsigned int *)(a1 + 812);
                if (!m)
                {
                  m = (*v100 + v145) % 0xFFFFF;
                  v227.__m_ = (std::unique_lock<std::mutex>::mutex_type *)m;
                  if (*(_BYTE *)(a1 + 32))
                  {
                    NSLog(CFSTR("patching missing counter usc timestamp"));
                    v145 = *(unsigned int *)(a1 + 812);
                    m = (unint64_t)v227.__m_;
                  }
                }
                v34 = v219 >= v145;
                v146 = v219 - v145;
                if (!v34)
                  v146 = 0;
                if (m >= v146)
                  break;
                *(_DWORD *)v97 += v142;
                *v98 += v143;
                *v100 = m;
                ++v95;
                v141 += 8;
              }
              while (v95 < v226 + v92);
            }
            ++v94;
            v45 = (_QWORD *)v218;
            if (v94 >= v232)
            {
              v89 = v226;
              LODWORD(v39) = v189;
              v91 = v186;
              goto LABEL_267;
            }
          }
        }
        v95 = 0;
LABEL_267:
        *v188 = (_DWORD)v200;
        *v187 = v197;
        v147 = v89 + v92 - v95;
        if (v89 + v92 <= v95)
        {
          *v91 = 0;
        }
        else
        {
          *v91 = v147;
          v148 = v92 - v95;
          if (v147 <= v89)
          {
            v156 = 0;
            v157 = v190 + 131200 * v39;
            v158 = v39;
            v159 = v157 + 65600;
            v160 = (_QWORD *)(v157 + 64);
            if (v147 <= 1)
              v161 = 1;
            else
              v161 = v89 + v92 - v95;
            v162 = v190 + 131200 * v158 + 98368;
            v163 = v95 - v89 - v92;
            do
            {
              v164 = v163 + v156 + v226;
              *(_QWORD *)(v159 + 8 * v156) = *(_QWORD *)(v225 + 8 * v164);
              *(_QWORD *)(v162 + 8 * v156) = *(_QWORD *)(v221 + 8 * (v163 + v156 + v222));
              agxps_aps_profile_data_get_usc_timestamps((uint64_t)v45, v160, *(unsigned int *)(v220 + 8 * v164 + 4), 1);
              ++v156;
              ++v160;
            }
            while (v161 != v156);
          }
          else
          {
            v149 = 0;
            v150 = 8 * v95 + 131200 * v39;
            v151 = v190 + v150;
            v152 = v190 + 98368 + v150;
            v153 = v190 + v150 + 65600;
            do
            {
              *(_QWORD *)(v190 + 131200 * v39 + 65600 + 8 * v149) = *(_QWORD *)(v153 + 8 * v149);
              *(_QWORD *)(v190 + 98368 + 131200 * v39 + 8 * v149) = *(_QWORD *)(v152 + 8 * v149);
              *(_QWORD *)(v190 + 131200 * v39 + 8 * v149 + 64) = *(_QWORD *)(v151 + 8 * v149 + 64);
              ++v149;
            }
            while (v148 != v149);
            if (v148 < v147)
            {
              v154 = v190 + 8 * v92 + 131200 * v189 - 8 * v95;
              v155 = 4;
              do
              {
                *(_QWORD *)(v154 + 65600 + v155 - 4) = *(_QWORD *)(v225 + v155 - 4);
                *(_QWORD *)(v154 + 98368 + v155 - 4) = *(_QWORD *)(v221 + v155 - 4);
                agxps_aps_profile_data_get_usc_timestamps(v218, (_QWORD *)(v154 + v155 + 60), *(unsigned int *)(v220 + v155), 1);
                v155 += 8;
                --v89;
              }
              while (v89);
            }
          }
        }
        if (v233.__owns_)
          std::mutex::unlock(v233.__m_);
        v165 = (void **)*((_QWORD *)&v246 + 1);
        v166 = (void **)v247;
        v24 = (std::mutex *)(a1 + 440);
        if ((_QWORD)v247 == *((_QWORD *)&v246 + 1))
        {
          v166 = (void **)*((_QWORD *)&v246 + 1);
        }
        else
        {
          v167 = (_QWORD *)(*((_QWORD *)&v246 + 1) + 8 * ((unint64_t)v248.i64[0] >> 7));
          v168 = *v167 + 32 * (v248.i8[0] & 0x7F);
          v169 = *(_QWORD *)(*((_QWORD *)&v246 + 1)
                           + (((unint64_t)(v248.i64[1] + v248.i64[0]) >> 4) & 0xFFFFFFFFFFFFFF8))
               + 32 * ((v248.i64[1] + v248.i64[0]) & 0x7F);
          if (v168 != v169)
          {
            do
            {
              std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>::~shared_ptr[abi:nn180100](v168 + 16);
              v168 += 32;
              if (v168 - *v167 == 4096)
              {
                v170 = v167[1];
                ++v167;
                v168 = v170;
              }
            }
            while (v168 != v169);
            v165 = (void **)*((_QWORD *)&v246 + 1);
            v166 = (void **)v247;
          }
        }
        v248.i64[1] = 0;
        v171 = (char *)v166 - (char *)v165;
        LODWORD(v39) = v189;
        v40 = v190;
        if ((unint64_t)((char *)v166 - (char *)v165) >= 0x11)
        {
          do
          {
            operator delete(*v165);
            v166 = (void **)v247;
            v165 = (void **)(*((_QWORD *)&v246 + 1) + 8);
            *((_QWORD *)&v246 + 1) = v165;
            v171 = v247 - (_QWORD)v165;
          }
          while ((_QWORD)v247 - (_QWORD)v165 > 0x10uLL);
        }
        v172 = v171 >> 3;
        if (v172 == 1)
        {
          v173 = 64;
        }
        else
        {
          if (v172 != 2)
            goto LABEL_297;
          v173 = 128;
        }
        v248.i64[0] = v173;
LABEL_297:
        if (v165 != v166)
        {
          do
          {
            v174 = *v165++;
            operator delete(v174);
          }
          while (v165 != v166);
          if ((_QWORD)v247 != *((_QWORD *)&v246 + 1))
            *(_QWORD *)&v247 = v247 + ((*((_QWORD *)&v246 + 1) - v247 + 7) & 0xFFFFFFFFFFFFFFF8);
        }
        if ((_QWORD)v246)
          operator delete((void *)v246);
        v175 = v235;
        v52 = (_QWORD *)(a1 + 504);
        if (v235)
        {
          v176 = (unint64_t *)&v235->__shared_owners_;
          do
            v177 = __ldaxr(v176);
          while (__stlxr(v177 - 1, v176));
          if (!v177)
          {
            ((void (*)(std::__shared_weak_count *))v175->__on_zero_shared)(v175);
            std::__shared_weak_count::__release_weak(v175);
          }
        }
        goto LABEL_308;
      }
      break;
    }
    std::mutex::unlock((std::mutex *)(*(_QWORD *)(a1 + 552) + (v29 << 6)));
  }
LABEL_320:
  if (*((_QWORD *)&v240 + 1))
  {
    v181 = v240;
    do
    {
      free(*(void **)(*(_QWORD *)(v239[1] + ((v181 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v181 & 0x7F) + 16));
      v182 = *((_QWORD *)&v240 + 1) - 1;
      v181 = v240 + 1;
      v240 = __PAIR128__(*((unint64_t *)&v240 + 1), (uint64_t)v240 + 1) + __PAIR128__(-1, 0);
      if (v181 >= 0x100)
      {
        operator delete(*(void **)v239[1]);
        v181 = v240 - 128;
        v239[1] += 8;
        *(_QWORD *)&v240 = v240 - 128;
        v182 = *((_QWORD *)&v240 + 1);
      }
    }
    while (v182);
  }
  if (*(_BYTE *)(a1 + 32))
    NSLog(CFSTR("Parser worker is finished"));
  std::deque<AccelerationStructureViewerServer::APSRawChunk>::~deque[abi:nn180100]((uint64_t)v239);

}

_QWORD *std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>::operator=[abi:nn180100](_QWORD *a1, uint64_t a2, uint64_t a3)
{
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  if (a3)
  {
    v4 = (unint64_t *)(a3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = (std::__shared_weak_count *)a1[1];
  *a1 = a2;
  a1[1] = a3;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return a1;
}

void std::unique_lock<std::mutex>::unlock(std::unique_lock<std::mutex> *this)
{
  if (this->__owns_)
  {
    std::mutex::unlock(this->__m_);
    this->__owns_ = 0;
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    std::deque<std::pair<unsigned long long,std::pair<unsigned int,std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>>>>::push_back();
  }
}

__n128 std::deque<std::pair<unsigned long long,std::pair<unsigned int,std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>>>>::push_back(_QWORD *a1, __n128 *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  int64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  void *v27;
  void *v28;
  unint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  __int128 v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  __int128 v39;
  __int128 v40;
  unint64_t v41;
  char *v42;
  uint64_t v43;
  char *v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  unint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t *v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  char *v61;
  char *v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  int64_t v72;
  uint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  uint64_t i;
  _QWORD *v78;
  char *v79;
  _BYTE *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  char *v87;
  uint64_t v88;
  char *v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  uint64_t *v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  __n128 *v97;
  __n128 result;
  unint64_t v99;
  char *v100;
  uint64_t v101;
  char *v102;
  uint64_t *v103;
  uint64_t v104;
  uint64_t v105;
  char *v106;
  uint64_t v107;
  char *v108;
  __int128 v109;
  __int128 v110;
  uint64_t v111;
  __int128 v112;
  uint64_t v113;
  __int128 v114;

  v4 = (char *)a1[2];
  v5 = (char *)a1[1];
  v6 = v4 - v5;
  if (v4 == v5)
    v7 = 0;
  else
    v7 = 16 * (v4 - v5) - 1;
  v8 = a1[4];
  v9 = a1[5] + v8;
  if (v7 == v9)
  {
    if (v8 >= 0x80)
    {
      a1[4] = v8 - 128;
      v12 = *(_QWORD *)v5;
      v10 = v5 + 8;
      v11 = v12;
      a1[1] = v10;
      if ((char *)a1[3] == v4)
      {
        v13 = (uint64_t)&v10[-*a1];
        if ((unint64_t)v10 <= *a1)
        {
          if (v4 == (char *)*a1)
            v41 = 1;
          else
            v41 = (uint64_t)&v4[-*a1] >> 2;
          v42 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v41);
          v44 = &v42[8 * (v41 >> 2)];
          v45 = (uint64_t *)a1[1];
          v4 = v44;
          v46 = a1[2] - (_QWORD)v45;
          if (v46)
          {
            v4 = &v44[v46 & 0xFFFFFFFFFFFFFFF8];
            v47 = 8 * (v46 >> 3);
            v48 = &v42[8 * (v41 >> 2)];
            do
            {
              v49 = *v45++;
              *(_QWORD *)v48 = v49;
              v48 += 8;
              v47 -= 8;
            }
            while (v47);
          }
          v50 = (char *)*a1;
          *a1 = v42;
          a1[1] = v44;
          a1[2] = v4;
          a1[3] = &v42[8 * v43];
          if (v50)
          {
            operator delete(v50);
            v4 = (char *)a1[2];
          }
        }
        else
        {
          v14 = v13 >> 3;
          v15 = v13 >> 3 < -1;
          v16 = (v13 >> 3) + 2;
          if (v15)
            v17 = v16;
          else
            v17 = v14 + 1;
          v18 = -(v17 >> 1);
          v19 = v17 >> 1;
          v20 = &v10[-8 * v19];
          v21 = v4 - v10;
          if (v4 == v10)
          {
            v22 = v4;
          }
          else
          {
            memmove(&v10[-8 * v19], v10, v4 - v10);
            v22 = (char *)a1[1];
          }
          v4 = &v20[v21];
          a1[1] = &v22[8 * v18];
          a1[2] = &v20[v21];
        }
      }
      *(_QWORD *)v4 = v11;
LABEL_82:
      a1[2] += 8;
LABEL_83:
      v5 = (char *)a1[1];
      v9 = a1[5] + a1[4];
      goto LABEL_84;
    }
    v23 = v6 >> 3;
    v24 = (char *)a1[3];
    v25 = (char *)*a1;
    v26 = (uint64_t)&v24[-*a1];
    if (v6 >> 3 < (unint64_t)(v26 >> 3))
    {
      v27 = operator new(0x1000uLL);
      v28 = v27;
      if (v24 == v4)
      {
        if (v25 == v5)
        {
          if (v4 == v5)
            v51 = 1;
          else
            v51 = v26 >> 2;
          v52 = 2 * v51;
          v53 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v51);
          v5 = &v53[(v52 + 6) & 0xFFFFFFFFFFFFFFF8];
          v55 = (uint64_t *)a1[1];
          v56 = v5;
          v57 = a1[2] - (_QWORD)v55;
          if (v57)
          {
            v56 = &v5[v57 & 0xFFFFFFFFFFFFFFF8];
            v58 = 8 * (v57 >> 3);
            v59 = v5;
            do
            {
              v60 = *v55++;
              *(_QWORD *)v59 = v60;
              v59 += 8;
              v58 -= 8;
            }
            while (v58);
          }
          v61 = (char *)*a1;
          *a1 = v53;
          a1[1] = v5;
          a1[2] = v56;
          a1[3] = &v53[8 * v54];
          if (v61)
          {
            operator delete(v61);
            v5 = (char *)a1[1];
          }
        }
        *((_QWORD *)v5 - 1) = v28;
        v62 = (char *)a1[1];
        v63 = (char *)a1[2];
        a1[1] = v62 - 8;
        v64 = *((_QWORD *)v62 - 1);
        a1[1] = v62;
        if (v63 == (char *)a1[3])
        {
          v65 = (uint64_t)&v62[-*a1];
          if ((unint64_t)v62 <= *a1)
          {
            if (v63 == (char *)*a1)
              v99 = 1;
            else
              v99 = (uint64_t)&v63[-*a1] >> 2;
            v100 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v99);
            v102 = &v100[8 * (v99 >> 2)];
            v103 = (uint64_t *)a1[1];
            v63 = v102;
            v104 = a1[2] - (_QWORD)v103;
            if (v104)
            {
              v63 = &v102[v104 & 0xFFFFFFFFFFFFFFF8];
              v105 = 8 * (v104 >> 3);
              v106 = &v100[8 * (v99 >> 2)];
              do
              {
                v107 = *v103++;
                *(_QWORD *)v106 = v107;
                v106 += 8;
                v105 -= 8;
              }
              while (v105);
            }
            v108 = (char *)*a1;
            *a1 = v100;
            a1[1] = v102;
            a1[2] = v63;
            a1[3] = &v100[8 * v101];
            if (v108)
            {
              operator delete(v108);
              v63 = (char *)a1[2];
            }
          }
          else
          {
            v66 = v65 >> 3;
            v15 = v65 >> 3 < -1;
            v67 = (v65 >> 3) + 2;
            if (v15)
              v68 = v67;
            else
              v68 = v66 + 1;
            v69 = -(v68 >> 1);
            v70 = v68 >> 1;
            v71 = &v62[-8 * v70];
            v72 = v63 - v62;
            if (v63 != v62)
            {
              memmove(&v62[-8 * v70], v62, v63 - v62);
              v62 = (char *)a1[1];
            }
            v63 = &v71[v72];
            a1[1] = &v62[8 * v69];
            a1[2] = &v71[v72];
          }
        }
        *(_QWORD *)v63 = v64;
      }
      else
      {
        *(_QWORD *)v4 = v27;
      }
      goto LABEL_82;
    }
    if (v24 == v25)
      v29 = 1;
    else
      v29 = v26 >> 2;
    v30 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v29);
    v32 = v31;
    v33 = &v30[8 * v23];
    *(_QWORD *)&v34 = v30;
    *((_QWORD *)&v34 + 1) = v33;
    v112 = v34;
    *(_QWORD *)&v34 = v33;
    *((_QWORD *)&v34 + 1) = &v30[8 * v31];
    v109 = v34;
    v35 = operator new(0x1000uLL);
    if (v23 == v32)
    {
      v36 = 8 * v23;
      if (v6 >= 1)
      {
        v37 = v36 >> 3;
        if (v37 >= -1)
          v38 = v37 + 1;
        else
          v38 = v37 + 2;
        v33 -= 8 * (v38 >> 1);
        *((_QWORD *)&v39 + 1) = *((_QWORD *)&v109 + 1);
        *(_QWORD *)&v40 = v112;
        *(_QWORD *)&v39 = v33;
        *((_QWORD *)&v40 + 1) = v33;
        goto LABEL_56;
      }
      v73 = v36 >> 2;
      if (v4 == v5)
        v74 = 1;
      else
        v74 = v73;
      v75 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v74);
      v33 = &v75[8 * (v74 >> 2)];
      *(_QWORD *)&v40 = v75;
      *((_QWORD *)&v40 + 1) = v33;
      *(_QWORD *)&v39 = v33;
      *((_QWORD *)&v39 + 1) = &v75[8 * v76];
      if (!v30)
        goto LABEL_56;
      v109 = v39;
      v112 = v40;
      operator delete(v30);
    }
    v39 = v109;
    v40 = v112;
LABEL_56:
    *(_QWORD *)v33 = v35;
    *(_QWORD *)&v39 = v39 + 8;
    for (i = a1[2]; i != a1[1]; i -= 8)
    {
      v78 = (_QWORD *)*((_QWORD *)&v40 + 1);
      if (*((_QWORD *)&v40 + 1) == (_QWORD)v40)
      {
        v80 = (_BYTE *)v39;
        if ((unint64_t)v39 >= *((_QWORD *)&v39 + 1))
        {
          if (*((_QWORD *)&v39 + 1) == *((_QWORD *)&v40 + 1))
            v85 = 1;
          else
            v85 = (uint64_t)(*((_QWORD *)&v39 + 1) - *((_QWORD *)&v40 + 1)) >> 2;
          v86 = 2 * v85;
          v87 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v85);
          v79 = &v87[(v86 + 6) & 0xFFFFFFFFFFFFFFF8];
          v89 = v79;
          v90 = v80 - (_BYTE *)v78;
          if (v80 != (_BYTE *)v78)
          {
            v89 = &v79[v90 & 0xFFFFFFFFFFFFFFF8];
            v91 = 8 * (v90 >> 3);
            v92 = v79;
            v93 = v78;
            do
            {
              v94 = *v93++;
              *(_QWORD *)v92 = v94;
              v92 += 8;
              v91 -= 8;
            }
            while (v91);
          }
          *(_QWORD *)&v40 = v87;
          *((_QWORD *)&v40 + 1) = v79;
          *(_QWORD *)&v39 = v89;
          *((_QWORD *)&v39 + 1) = &v87[8 * v88];
          if (v78)
          {
            v110 = v39;
            v114 = v40;
            operator delete(v78);
            v39 = v110;
            v40 = v114;
          }
        }
        else
        {
          v81 = (uint64_t)(*((_QWORD *)&v39 + 1) - v39) >> 3;
          if (v81 >= -1)
            v82 = v81 + 1;
          else
            v82 = v81 + 2;
          v83 = v82 >> 1;
          v84 = v39 + 8 * (v82 >> 1);
          v79 = (char *)(v84 - (v39 - *((_QWORD *)&v40 + 1)));
          if ((_QWORD)v39 == *((_QWORD *)&v40 + 1))
          {
            v80 = (_BYTE *)*((_QWORD *)&v40 + 1);
          }
          else
          {
            v111 = *((_QWORD *)&v39 + 1);
            v113 = v40;
            memmove((void *)(v84 - (v39 - *((_QWORD *)&v40 + 1))), *((const void **)&v40 + 1), v39 - *((_QWORD *)&v40 + 1));
            *((_QWORD *)&v39 + 1) = v111;
            *(_QWORD *)&v40 = v113;
          }
          *((_QWORD *)&v40 + 1) = v79;
          *(_QWORD *)&v39 = &v80[8 * v83];
        }
      }
      else
      {
        v79 = (char *)*((_QWORD *)&v40 + 1);
      }
      v95 = *(_QWORD *)(i - 8);
      *((_QWORD *)v79 - 1) = v95;
      *((_QWORD *)&v40 + 1) -= 8;
    }
    v96 = (char *)*a1;
    *(_OWORD *)a1 = v40;
    *((_OWORD *)a1 + 1) = v39;
    if (v96)
      operator delete(v96);
    goto LABEL_83;
  }
LABEL_84:
  v97 = (__n128 *)(*(_QWORD *)&v5[(v9 >> 4) & 0xFFFFFFFFFFFFFF8] + 32 * (v9 & 0x7F));
  v97->n128_u64[0] = a2->n128_u64[0];
  v97->n128_u32[2] = a2->n128_u32[2];
  result = a2[1];
  v97[1] = result;
  a2[1].n128_u64[0] = 0;
  a2[1].n128_u64[1] = 0;
  ++a1[5];
  return result;
}

__n128 std::deque<AccelerationStructureViewerServer::APSRawChunk>::push_back(_QWORD *a1, uint64_t a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  int64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  void *v27;
  void *v28;
  unint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  __int128 v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  __int128 v39;
  __int128 v40;
  unint64_t v41;
  char *v42;
  uint64_t v43;
  char *v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  unint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t *v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  char *v61;
  char *v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  int64_t v72;
  uint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  uint64_t i;
  _QWORD *v78;
  char *v79;
  _BYTE *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  char *v87;
  uint64_t v88;
  char *v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  uint64_t *v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  _OWORD *v97;
  __n128 result;
  __int128 v99;
  unint64_t v100;
  char *v101;
  uint64_t v102;
  char *v103;
  uint64_t *v104;
  uint64_t v105;
  uint64_t v106;
  char *v107;
  uint64_t v108;
  char *v109;
  __int128 v110;
  __int128 v111;
  uint64_t v112;
  __int128 v113;
  uint64_t v114;
  __int128 v115;

  v4 = (char *)a1[2];
  v5 = (char *)a1[1];
  v6 = v4 - v5;
  if (v4 == v5)
    v7 = 0;
  else
    v7 = 16 * (v4 - v5) - 1;
  v8 = a1[4];
  v9 = a1[5] + v8;
  if (v7 == v9)
  {
    if (v8 >= 0x80)
    {
      a1[4] = v8 - 128;
      v12 = *(_QWORD *)v5;
      v10 = v5 + 8;
      v11 = v12;
      a1[1] = v10;
      if ((char *)a1[3] == v4)
      {
        v13 = (uint64_t)&v10[-*a1];
        if ((unint64_t)v10 <= *a1)
        {
          if (v4 == (char *)*a1)
            v41 = 1;
          else
            v41 = (uint64_t)&v4[-*a1] >> 2;
          v42 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v41);
          v44 = &v42[8 * (v41 >> 2)];
          v45 = (uint64_t *)a1[1];
          v4 = v44;
          v46 = a1[2] - (_QWORD)v45;
          if (v46)
          {
            v4 = &v44[v46 & 0xFFFFFFFFFFFFFFF8];
            v47 = 8 * (v46 >> 3);
            v48 = &v42[8 * (v41 >> 2)];
            do
            {
              v49 = *v45++;
              *(_QWORD *)v48 = v49;
              v48 += 8;
              v47 -= 8;
            }
            while (v47);
          }
          v50 = (char *)*a1;
          *a1 = v42;
          a1[1] = v44;
          a1[2] = v4;
          a1[3] = &v42[8 * v43];
          if (v50)
          {
            operator delete(v50);
            v4 = (char *)a1[2];
          }
        }
        else
        {
          v14 = v13 >> 3;
          v15 = v13 >> 3 < -1;
          v16 = (v13 >> 3) + 2;
          if (v15)
            v17 = v16;
          else
            v17 = v14 + 1;
          v18 = -(v17 >> 1);
          v19 = v17 >> 1;
          v20 = &v10[-8 * v19];
          v21 = v4 - v10;
          if (v4 == v10)
          {
            v22 = v4;
          }
          else
          {
            memmove(&v10[-8 * v19], v10, v4 - v10);
            v22 = (char *)a1[1];
          }
          v4 = &v20[v21];
          a1[1] = &v22[8 * v18];
          a1[2] = &v20[v21];
        }
      }
      *(_QWORD *)v4 = v11;
LABEL_82:
      a1[2] += 8;
LABEL_83:
      v5 = (char *)a1[1];
      v9 = a1[5] + a1[4];
      goto LABEL_84;
    }
    v23 = v6 >> 3;
    v24 = (char *)a1[3];
    v25 = (char *)*a1;
    v26 = (uint64_t)&v24[-*a1];
    if (v6 >> 3 < (unint64_t)(v26 >> 3))
    {
      v27 = operator new(0x1000uLL);
      v28 = v27;
      if (v24 == v4)
      {
        if (v25 == v5)
        {
          if (v4 == v5)
            v51 = 1;
          else
            v51 = v26 >> 2;
          v52 = 2 * v51;
          v53 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v51);
          v5 = &v53[(v52 + 6) & 0xFFFFFFFFFFFFFFF8];
          v55 = (uint64_t *)a1[1];
          v56 = v5;
          v57 = a1[2] - (_QWORD)v55;
          if (v57)
          {
            v56 = &v5[v57 & 0xFFFFFFFFFFFFFFF8];
            v58 = 8 * (v57 >> 3);
            v59 = v5;
            do
            {
              v60 = *v55++;
              *(_QWORD *)v59 = v60;
              v59 += 8;
              v58 -= 8;
            }
            while (v58);
          }
          v61 = (char *)*a1;
          *a1 = v53;
          a1[1] = v5;
          a1[2] = v56;
          a1[3] = &v53[8 * v54];
          if (v61)
          {
            operator delete(v61);
            v5 = (char *)a1[1];
          }
        }
        *((_QWORD *)v5 - 1) = v28;
        v62 = (char *)a1[1];
        v63 = (char *)a1[2];
        a1[1] = v62 - 8;
        v64 = *((_QWORD *)v62 - 1);
        a1[1] = v62;
        if (v63 == (char *)a1[3])
        {
          v65 = (uint64_t)&v62[-*a1];
          if ((unint64_t)v62 <= *a1)
          {
            if (v63 == (char *)*a1)
              v100 = 1;
            else
              v100 = (uint64_t)&v63[-*a1] >> 2;
            v101 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v100);
            v103 = &v101[8 * (v100 >> 2)];
            v104 = (uint64_t *)a1[1];
            v63 = v103;
            v105 = a1[2] - (_QWORD)v104;
            if (v105)
            {
              v63 = &v103[v105 & 0xFFFFFFFFFFFFFFF8];
              v106 = 8 * (v105 >> 3);
              v107 = &v101[8 * (v100 >> 2)];
              do
              {
                v108 = *v104++;
                *(_QWORD *)v107 = v108;
                v107 += 8;
                v106 -= 8;
              }
              while (v106);
            }
            v109 = (char *)*a1;
            *a1 = v101;
            a1[1] = v103;
            a1[2] = v63;
            a1[3] = &v101[8 * v102];
            if (v109)
            {
              operator delete(v109);
              v63 = (char *)a1[2];
            }
          }
          else
          {
            v66 = v65 >> 3;
            v15 = v65 >> 3 < -1;
            v67 = (v65 >> 3) + 2;
            if (v15)
              v68 = v67;
            else
              v68 = v66 + 1;
            v69 = -(v68 >> 1);
            v70 = v68 >> 1;
            v71 = &v62[-8 * v70];
            v72 = v63 - v62;
            if (v63 != v62)
            {
              memmove(&v62[-8 * v70], v62, v63 - v62);
              v62 = (char *)a1[1];
            }
            v63 = &v71[v72];
            a1[1] = &v62[8 * v69];
            a1[2] = &v71[v72];
          }
        }
        *(_QWORD *)v63 = v64;
      }
      else
      {
        *(_QWORD *)v4 = v27;
      }
      goto LABEL_82;
    }
    if (v24 == v25)
      v29 = 1;
    else
      v29 = v26 >> 2;
    v30 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v29);
    v32 = v31;
    v33 = &v30[8 * v23];
    *(_QWORD *)&v34 = v30;
    *((_QWORD *)&v34 + 1) = v33;
    v113 = v34;
    *(_QWORD *)&v34 = v33;
    *((_QWORD *)&v34 + 1) = &v30[8 * v31];
    v110 = v34;
    v35 = operator new(0x1000uLL);
    if (v23 == v32)
    {
      v36 = 8 * v23;
      if (v6 >= 1)
      {
        v37 = v36 >> 3;
        if (v37 >= -1)
          v38 = v37 + 1;
        else
          v38 = v37 + 2;
        v33 -= 8 * (v38 >> 1);
        *((_QWORD *)&v39 + 1) = *((_QWORD *)&v110 + 1);
        *(_QWORD *)&v40 = v113;
        *(_QWORD *)&v39 = v33;
        *((_QWORD *)&v40 + 1) = v33;
        goto LABEL_56;
      }
      v73 = v36 >> 2;
      if (v4 == v5)
        v74 = 1;
      else
        v74 = v73;
      v75 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v74);
      v33 = &v75[8 * (v74 >> 2)];
      *(_QWORD *)&v40 = v75;
      *((_QWORD *)&v40 + 1) = v33;
      *(_QWORD *)&v39 = v33;
      *((_QWORD *)&v39 + 1) = &v75[8 * v76];
      if (!v30)
        goto LABEL_56;
      v110 = v39;
      v113 = v40;
      operator delete(v30);
    }
    v39 = v110;
    v40 = v113;
LABEL_56:
    *(_QWORD *)v33 = v35;
    *(_QWORD *)&v39 = v39 + 8;
    for (i = a1[2]; i != a1[1]; i -= 8)
    {
      v78 = (_QWORD *)*((_QWORD *)&v40 + 1);
      if (*((_QWORD *)&v40 + 1) == (_QWORD)v40)
      {
        v80 = (_BYTE *)v39;
        if ((unint64_t)v39 >= *((_QWORD *)&v39 + 1))
        {
          if (*((_QWORD *)&v39 + 1) == *((_QWORD *)&v40 + 1))
            v85 = 1;
          else
            v85 = (uint64_t)(*((_QWORD *)&v39 + 1) - *((_QWORD *)&v40 + 1)) >> 2;
          v86 = 2 * v85;
          v87 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v85);
          v79 = &v87[(v86 + 6) & 0xFFFFFFFFFFFFFFF8];
          v89 = v79;
          v90 = v80 - (_BYTE *)v78;
          if (v80 != (_BYTE *)v78)
          {
            v89 = &v79[v90 & 0xFFFFFFFFFFFFFFF8];
            v91 = 8 * (v90 >> 3);
            v92 = v79;
            v93 = v78;
            do
            {
              v94 = *v93++;
              *(_QWORD *)v92 = v94;
              v92 += 8;
              v91 -= 8;
            }
            while (v91);
          }
          *(_QWORD *)&v40 = v87;
          *((_QWORD *)&v40 + 1) = v79;
          *(_QWORD *)&v39 = v89;
          *((_QWORD *)&v39 + 1) = &v87[8 * v88];
          if (v78)
          {
            v111 = v39;
            v115 = v40;
            operator delete(v78);
            v39 = v111;
            v40 = v115;
          }
        }
        else
        {
          v81 = (uint64_t)(*((_QWORD *)&v39 + 1) - v39) >> 3;
          if (v81 >= -1)
            v82 = v81 + 1;
          else
            v82 = v81 + 2;
          v83 = v82 >> 1;
          v84 = v39 + 8 * (v82 >> 1);
          v79 = (char *)(v84 - (v39 - *((_QWORD *)&v40 + 1)));
          if ((_QWORD)v39 == *((_QWORD *)&v40 + 1))
          {
            v80 = (_BYTE *)*((_QWORD *)&v40 + 1);
          }
          else
          {
            v112 = *((_QWORD *)&v39 + 1);
            v114 = v40;
            memmove((void *)(v84 - (v39 - *((_QWORD *)&v40 + 1))), *((const void **)&v40 + 1), v39 - *((_QWORD *)&v40 + 1));
            *((_QWORD *)&v39 + 1) = v112;
            *(_QWORD *)&v40 = v114;
          }
          *((_QWORD *)&v40 + 1) = v79;
          *(_QWORD *)&v39 = &v80[8 * v83];
        }
      }
      else
      {
        v79 = (char *)*((_QWORD *)&v40 + 1);
      }
      v95 = *(_QWORD *)(i - 8);
      *((_QWORD *)v79 - 1) = v95;
      *((_QWORD *)&v40 + 1) -= 8;
    }
    v96 = (char *)*a1;
    *(_OWORD *)a1 = v40;
    *((_OWORD *)a1 + 1) = v39;
    if (v96)
      operator delete(v96);
    goto LABEL_83;
  }
LABEL_84:
  v97 = (_OWORD *)(*(_QWORD *)&v5[(v9 >> 4) & 0xFFFFFFFFFFFFFF8] + 32 * (v9 & 0x7F));
  result = *(__n128 *)a2;
  v99 = *(_OWORD *)(a2 + 16);
  *v97 = *(_OWORD *)a2;
  v97[1] = v99;
  ++a1[5];
  return result;
}

void AccelerationStructureViewerServer::Profiler::accumulationWorker(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  __int128 *v16;
  __int128 v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  size_t v21;
  uint64_t v22;
  size_t v23;
  uint64_t v24;
  unsigned int v25;
  void *v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  __int128 *v30;
  __int128 v31;
  size_t v32;
  uint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  id v39;
  uint64_t v40;
  id v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  __int128 v47;
  void *__dst[2];
  std::unique_lock<std::mutex> v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t v52;
  std::unique_lock<std::mutex> v53;

  v7 = a2;
  v53.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 320);
  v53.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 320));
  v39 = objc_msgSend(*(id *)(a1 + 760), "copy");
  std::unique_lock<std::mutex>::unlock(&v53);
  if (*(_BYTE *)(a1 + 32))
    NSLog(CFSTR("Started accumulation worker %d -> %d"), a3, a4, v39);
  if (*(_BYTE *)(a1 + 432))
  {
    v40 = a3;
    v41 = v7;
    v43 = a4;
    v44 = a4;
    v42 = a3;
    do
    {
      if (!objc_msgSend(v7, "isEnabled"))
        break;
      v8 = a3 >= a4;
      v9 = v44;
      if (!v8)
      {
        v10 = v40;
        while ((objc_msgSend(v7, "isEnabled") & 1) != 0)
        {
          v11 = *(unsigned int *)(*(_QWORD *)(a1 + 296) + 4 * v10);
          v51 = 0;
          v52 = 0;
          v50 = 0;
          if ((objc_msgSend(v7, "ringBufferInfoAtIndex:base:size:dataOffset:dataSize:", v11, &v52, (char *)&v51 + 4, &v51, &v50) & 1) != 0)
          {
            if (v50 && v52)
            {
              v46 = v11;
              if (v51 + v50 <= HIDWORD(v51))
              {
                v27 = 0;
                do
                {
                  v49.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 440);
                  v49.__owns_ = 1;
                  std::mutex::lock((std::mutex *)(a1 + 440));
                  v28 = *(_QWORD *)(a1 + 544);
                  if (!v28)
                  {
                    v47 = 0u;
                    *(_OWORD *)__dst = 0u;
                    __dst[0] = malloc_type_malloc(0x1000uLL, 0x2CB59ADEuLL);
                    std::deque<AccelerationStructureViewerServer::APSRawChunk>::push_back((_QWORD *)(a1 + 504), (uint64_t)&v47);
                    v28 = *(_QWORD *)(a1 + 544);
                  }
                  v29 = *(_QWORD *)(a1 + 536);
                  v30 = (__int128 *)(*(_QWORD *)(*(_QWORD *)(a1 + 512) + ((v29 >> 4) & 0xFFFFFFFFFFFFFF8))
                                   + 32 * (v29 & 0x7F));
                  v31 = v30[1];
                  v47 = *v30;
                  *(_OWORD *)__dst = v31;
                  *(_QWORD *)(a1 + 544) = v28 - 1;
                  *(_QWORD *)(a1 + 536) = v29 + 1;
                  std::deque<AccelerationStructureViewerServer::APSRawChunk>::__maybe_remove_front_spare[abi:nn180100](a1 + 504);
                  std::unique_lock<std::mutex>::unlock(&v49);
                  if (v50 - v27 >= 0x1000)
                    v32 = 4096;
                  else
                    v32 = v50 - v27;
                  memcpy(__dst[0], (const void *)(v52 + v51 + v27), v32);
                  __dst[1] = (void *)v32;
                  WORD1(v47) = v10;
                  v33 = *(_QWORD *)(a1 + 600) + 131200 * (unsigned __int16)v10;
                  LOBYTE(v47) = *(_BYTE *)(v33 + 32);
                  v34 = (unint64_t *)(v33 + 40);
                  do
                    v35 = __ldaxr(v34);
                  while (__stlxr(v35 + 1, v34));
                  *((_QWORD *)&v47 + 1) = v35;
                  v36 = WORD1(v47);
                  *(_BYTE *)(*(_QWORD *)(a1 + 600) + 131200 * WORD1(v47) + 32) = 0;
                  std::mutex::lock((std::mutex *)(*(_QWORD *)(a1 + 552) + (v36 << 6)));
                  std::deque<AccelerationStructureViewerServer::APSRawChunk>::push_back((_QWORD *)(*(_QWORD *)(a1 + 576) + 48 * v36), (uint64_t)&v47);
                  std::mutex::unlock((std::mutex *)(*(_QWORD *)(a1 + 552) + (v36 << 6)));
                  if (v49.__owns_)
                    std::mutex::unlock(v49.__m_);
                  v27 += v32;
                  v25 = v50;
                }
                while (v27 < v50);
              }
              else
              {
                v12 = 0;
                v13 = (HIDWORD(v51) - v51);
                v45 = v50 - v13;
                do
                {
                  v49.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 440);
                  v49.__owns_ = 1;
                  std::mutex::lock((std::mutex *)(a1 + 440));
                  v14 = *(_QWORD *)(a1 + 544);
                  if (!v14)
                  {
                    v47 = 0u;
                    *(_OWORD *)__dst = 0u;
                    __dst[0] = malloc_type_malloc(0x1000uLL, 0xCEB5AC8EuLL);
                    std::deque<AccelerationStructureViewerServer::APSRawChunk>::push_back((_QWORD *)(a1 + 504), (uint64_t)&v47);
                    v14 = *(_QWORD *)(a1 + 544);
                  }
                  v15 = *(_QWORD *)(a1 + 536);
                  v16 = (__int128 *)(*(_QWORD *)(*(_QWORD *)(a1 + 512) + ((v15 >> 4) & 0xFFFFFFFFFFFFFF8))
                                   + 32 * (v15 & 0x7F));
                  v17 = v16[1];
                  v47 = *v16;
                  *(_OWORD *)__dst = v17;
                  *(_QWORD *)(a1 + 544) = v14 - 1;
                  *(_QWORD *)(a1 + 536) = v15 + 1;
                  std::deque<AccelerationStructureViewerServer::APSRawChunk>::__maybe_remove_front_spare[abi:nn180100](a1 + 504);
                  std::unique_lock<std::mutex>::unlock(&v49);
                  WORD1(v47) = v10;
                  v18 = *(_QWORD *)(a1 + 600) + 131200 * (unsigned __int16)v10;
                  LOBYTE(v47) = *(_BYTE *)(v18 + 32);
                  v19 = (unint64_t *)(v18 + 40);
                  do
                    v20 = __ldaxr(v19);
                  while (__stlxr(v20 + 1, v19));
                  *((_QWORD *)&v47 + 1) = v20;
                  __dst[1] = 0;
                  if (v13 <= v12)
                  {
                    v21 = 0;
                  }
                  else
                  {
                    if (v13 - v12 >= 0x1000)
                      v21 = 4096;
                    else
                      v21 = v13 - v12;
                    memcpy(__dst[0], (const void *)(v52 + v51 + v12), v21);
                    v12 += v21;
                    __dst[1] = (void *)v21;
                  }
                  v22 = v12 - v13;
                  if (v12 >= v13)
                  {
                    if (4096 - v21 >= v45 - v22)
                      v23 = v45 - v22;
                    else
                      v23 = 4096 - v21;
                    memcpy((char *)__dst[0] + v21, (const void *)(v52 + v22), v23);
                    v12 += v23;
                    __dst[1] = (void *)(v21 + v23);
                  }
                  v24 = WORD1(v47);
                  *(_BYTE *)(*(_QWORD *)(a1 + 600) + 131200 * WORD1(v47) + 32) = 0;
                  std::mutex::lock((std::mutex *)(*(_QWORD *)(a1 + 552) + (v24 << 6)));
                  std::deque<AccelerationStructureViewerServer::APSRawChunk>::push_back((_QWORD *)(*(_QWORD *)(a1 + 576) + 48 * v24), (uint64_t)&v47);
                  std::mutex::unlock((std::mutex *)(*(_QWORD *)(a1 + 552) + (v24 << 6)));
                  if (v49.__owns_)
                    std::mutex::unlock(v49.__m_);
                  v25 = v50;
                }
                while (v12 < v50);
                v7 = v41;
              }
              v9 = v44;
              if (v25)
              {
                v37 = 0;
                while (1)
                {
                  v38 = objc_msgSend(v7, "drainRingBufferAtIndex:dataSize:", v46, v25 - v37);
                  if (!v38)
                    break;
                  v37 += v38;
                  v25 = v50;
                  if (v37 >= v50)
                    goto LABEL_53;
                }
                if (*(_BYTE *)(a1 + 32))
                  NSLog(CFSTR("Nothing drained on USC %d. Expected %d"), v10, v50 - v37);
              }
            }
            else
            {
              usleep(0x64u);
            }
          }
          else
          {
            v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "name"));
            NSLog(CFSTR("Fail, unable to retrieve ring buffer info from source %@!"), v26);

          }
LABEL_53:
          if (++v10 == v9)
            goto LABEL_56;
        }
        NSLog(CFSTR("Source is not enabled"));
      }
LABEL_56:
      LODWORD(a3) = v42;
      LODWORD(a4) = v43;
    }
    while (*(_BYTE *)(a1 + 432));
  }
  if (*(_BYTE *)(a1 + 32))
    NSLog(CFSTR("Accumulation worker is finished"));

  if (v53.__owns_)
    std::mutex::unlock(v53.__m_);

}

void AccelerationStructureViewerServer::Profiler::finishSkipFrame(uint64_t a1, void *a2)
{
  unsigned int v3;
  _QWORD *v4;
  uint64_t *v5;
  std::unique_lock<std::mutex> v6;

  v3 = objc_msgSend(a2, "globalTraceObjectID");
  v6.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 624);
  v6.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 624));
  v4 = (_QWORD *)(a1 + 688);
  v5 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>(v4, v3);
  if (v5)
    std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::erase(v4, v5);
  std::unique_lock<std::mutex>::unlock(&v6);
  if (v6.__owns_)
    std::mutex::unlock(v6.__m_);
}

void std::vector<AccelerationStructureViewerServer::APSUSCRayCollector>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  id *v2;
  id *v4;
  void *v5;
  id *v6;

  v1 = *a1;
  v2 = (id *)**a1;
  if (v2)
  {
    v4 = (id *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 4;

        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__shared_ptr_emplace<AccelerationStructureViewerServer::APSRayCollector>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_727588;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<AccelerationStructureViewerServer::APSRayCollector>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_727588;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete();
}

void std::__shared_ptr_emplace<AccelerationStructureViewerServer::APSRayCollector>::__on_zero_shared(uint64_t a1)
{
  std::condition_variable *v1;
  void **v2;

  v1 = (std::condition_variable *)(a1 + 24);
  v2 = (void **)(a1 + 88);
  std::vector<AccelerationStructureViewerServer::APSUSCRayCollector>::__destroy_vector::operator()[abi:nn180100](&v2);
  std::condition_variable::~condition_variable(v1);
}

__n128 __Block_byref_object_copy__8959(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__8960(uint64_t a1)
{
  return std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>::~shared_ptr[abi:nn180100](a1 + 48);
}

uint64_t std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>::operator=[abi:nn180100](uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

void ___ZN33AccelerationStructureViewerServer8Profiler11finishFrameEPU26objcproto15MTLCommandQueue11objc_objectPU35objcproto24MTLComputeCommandEncoder11objc_objectmP18ASVSRenderSettingsPN27AccelerationStructureViewer6SampleE_block_invoke(uint64_t a1)
{
  dispatch_queue_global_t global_queue;
  NSObject *v3;
  _QWORD v4[4];
  __int128 v5;

  global_queue = dispatch_get_global_queue(0, 0);
  v3 = objc_claimAutoreleasedReturnValue(global_queue);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = ___ZN33AccelerationStructureViewerServer8Profiler11finishFrameEPU26objcproto15MTLCommandQueue11objc_objectPU35objcproto24MTLComputeCommandEncoder11objc_objectmP18ASVSRenderSettingsPN27AccelerationStructureViewer6SampleE_block_invoke_2;
  v4[3] = &unk_727530;
  v5 = *(_OWORD *)(a1 + 32);
  dispatch_async(v3, v4);

}

void ___ZN33AccelerationStructureViewerServer8Profiler11finishFrameEPU26objcproto15MTLCommandQueue11objc_objectPU35objcproto24MTLComputeCommandEncoder11objc_objectmP18ASVSRenderSettingsPN27AccelerationStructureViewer6SampleE_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t v5;
  id *v6;
  uint64_t v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  BOOL v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  int64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  char *v29;
  void *v30;
  void *v31;
  unint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  __int128 v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  __int128 v42;
  __int128 v43;
  BOOL v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  uint64_t v55;
  void *v56;
  unint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  uint64_t *v61;
  char *v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  void *v67;
  char *v68;
  char *v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  int64_t v77;
  void *v78;
  uint64_t v79;
  unint64_t v80;
  char *v81;
  uint64_t v82;
  uint64_t i;
  _QWORD *v84;
  char *v85;
  _BYTE *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  char *v93;
  uint64_t v94;
  char *v95;
  uint64_t v96;
  uint64_t v97;
  char *v98;
  uint64_t *v99;
  uint64_t v100;
  uint64_t v101;
  void *v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  char *v106;
  uint64_t v107;
  char *v108;
  uint64_t *v109;
  uint64_t v110;
  uint64_t v111;
  char *v112;
  uint64_t v113;
  void *v114;
  unint64_t v115;
  _QWORD *v116;
  id v117;
  std::__shared_weak_count *v118;
  unint64_t *v119;
  unint64_t v120;
  uint64_t v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  uint64_t v125;
  __int128 v126;
  __int128 v127;
  uint64_t v128;
  __int128 v129;
  __int128 v130;

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 40);
  std::mutex::lock((std::mutex *)(v2 + 136));
  v3 = *(_DWORD *)(v2 + 8);
  if (v3)
  {
    v4 = 0;
    v121 = v1;
    do
    {
      v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 48) + 64) + 32 * v4;
      v7 = *(_QWORD *)(v5 + 16);
      v6 = (id *)(v5 + 16);
      if (v7)
      {
        v8 = *(char **)(v2 + 208);
        v9 = *(char **)(v2 + 216);
        v10 = v9 - v8;
        if (v9 == v8)
          v11 = 0;
        else
          v11 = ((v9 - v8) << 6) - 1;
        v12 = *(_QWORD *)(v2 + 232);
        if (v11 == *(_QWORD *)(v2 + 240) + v12)
        {
          v13 = v12 >= 0x200;
          v14 = v12 - 512;
          if (v13)
          {
            *(_QWORD *)(v2 + 232) = v14;
            v17 = *(_QWORD *)v8;
            v15 = v8 + 8;
            v16 = v17;
            *(_QWORD *)(v2 + 208) = v15;
            if (v9 == *(char **)(v2 + 224))
            {
              v18 = *(_QWORD *)(v2 + 200);
              v19 = (uint64_t)&v15[-v18];
              if ((unint64_t)v15 <= v18)
              {
                v45 = (uint64_t)&v9[-v18];
                v44 = v45 == 0;
                v46 = v45 >> 2;
                if (v44)
                  v47 = 1;
                else
                  v47 = v46;
                v48 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v47);
                v50 = &v48[8 * (v47 >> 2)];
                v51 = *(uint64_t **)(v2 + 208);
                v9 = v50;
                v52 = *(_QWORD *)(v2 + 216) - (_QWORD)v51;
                if (v52)
                {
                  v9 = &v50[v52 & 0xFFFFFFFFFFFFFFF8];
                  v53 = 8 * (v52 >> 3);
                  v54 = &v48[8 * (v47 >> 2)];
                  do
                  {
                    v55 = *v51++;
                    *(_QWORD *)v54 = v55;
                    v54 += 8;
                    v53 -= 8;
                  }
                  while (v53);
                }
                v56 = *(void **)(v2 + 200);
                *(_QWORD *)(v2 + 200) = v48;
                *(_QWORD *)(v2 + 208) = v50;
                *(_QWORD *)(v2 + 216) = v9;
                *(_QWORD *)(v2 + 224) = &v48[8 * v49];
                if (v56)
                {
                  operator delete(v56);
                  v9 = *(char **)(v2 + 216);
                }
              }
              else
              {
                v20 = v19 >> 3;
                v21 = v19 >> 3 < -1;
                v22 = (v19 >> 3) + 2;
                if (v21)
                  v23 = v22;
                else
                  v23 = v20 + 1;
                v24 = &v15[-8 * (v23 >> 1)];
                v25 = v9 - v15;
                if (v9 != v15)
                {
                  memmove(&v15[-8 * (v23 >> 1)], v15, v9 - v15);
                  v9 = *(char **)(v2 + 208);
                }
                v26 = &v9[-8 * (v23 >> 1)];
                v9 = &v24[v25];
                *(_QWORD *)(v2 + 208) = v26;
                *(_QWORD *)(v2 + 216) = &v24[v25];
              }
            }
            *(_QWORD *)v9 = v16;
            v9 = (char *)(*(_QWORD *)(v2 + 216) + 8);
            *(_QWORD *)(v2 + 216) = v9;
          }
          else
          {
            v27 = v10 >> 3;
            v28 = *(char **)(v2 + 224);
            v29 = *(char **)(v2 + 200);
            if (v10 >> 3 >= (unint64_t)((v28 - v29) >> 3))
            {
              if (v28 == v29)
                v32 = 1;
              else
                v32 = (v28 - v29) >> 2;
              v33 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v32);
              v35 = v34;
              v36 = &v33[8 * v27];
              *(_QWORD *)&v37 = v33;
              *((_QWORD *)&v37 + 1) = v36;
              v126 = v37;
              *(_QWORD *)&v37 = v36;
              *((_QWORD *)&v37 + 1) = &v33[8 * v34];
              v122 = v37;
              v38 = operator new(0x1000uLL);
              if (v27 == v35)
              {
                v39 = 8 * v27;
                if (v10 < 1)
                {
                  v78 = v38;
                  v79 = v39 >> 2;
                  if (v9 == v8)
                    v80 = 1;
                  else
                    v80 = v79;
                  v81 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v80);
                  v36 = &v81[8 * (v80 >> 2)];
                  *(_QWORD *)&v43 = v81;
                  *((_QWORD *)&v43 + 1) = v36;
                  *(_QWORD *)&v42 = v36;
                  *((_QWORD *)&v42 + 1) = &v81[8 * v82];
                  if (v33)
                  {
                    v123 = v42;
                    v127 = v43;
                    operator delete(v33);
                    v42 = v123;
                    v43 = v127;
                  }
                  v38 = v78;
                }
                else
                {
                  v40 = v39 >> 3;
                  if (v40 >= -1)
                    v41 = v40 + 1;
                  else
                    v41 = v40 + 2;
                  v36 -= 8 * (v41 >> 1);
                  *((_QWORD *)&v42 + 1) = *((_QWORD *)&v122 + 1);
                  *(_QWORD *)&v43 = v126;
                  *(_QWORD *)&v42 = v36;
                  *((_QWORD *)&v43 + 1) = v36;
                }
              }
              else
              {
                v42 = v122;
                v43 = v126;
              }
              *(_QWORD *)v36 = v38;
              *(_QWORD *)&v42 = v42 + 8;
              for (i = *(_QWORD *)(v2 + 216); i != *(_QWORD *)(v2 + 208); i -= 8)
              {
                v84 = (_QWORD *)*((_QWORD *)&v43 + 1);
                if (*((_QWORD *)&v43 + 1) == (_QWORD)v43)
                {
                  v86 = (_BYTE *)v42;
                  if ((unint64_t)v42 >= *((_QWORD *)&v42 + 1))
                  {
                    if (*((_QWORD *)&v42 + 1) == *((_QWORD *)&v43 + 1))
                      v91 = 1;
                    else
                      v91 = (uint64_t)(*((_QWORD *)&v42 + 1) - *((_QWORD *)&v43 + 1)) >> 2;
                    v92 = 2 * v91;
                    v93 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v91);
                    v85 = &v93[(v92 + 6) & 0xFFFFFFFFFFFFFFF8];
                    v95 = v85;
                    v96 = v86 - (_BYTE *)v84;
                    if (v86 != (_BYTE *)v84)
                    {
                      v95 = &v85[v96 & 0xFFFFFFFFFFFFFFF8];
                      v97 = 8 * (v96 >> 3);
                      v98 = &v93[(v92 + 6) & 0xFFFFFFFFFFFFFFF8];
                      v99 = v84;
                      do
                      {
                        v100 = *v99++;
                        *(_QWORD *)v98 = v100;
                        v98 += 8;
                        v97 -= 8;
                      }
                      while (v97);
                    }
                    *(_QWORD *)&v43 = v93;
                    *((_QWORD *)&v43 + 1) = &v93[(v92 + 6) & 0xFFFFFFFFFFFFFFF8];
                    *(_QWORD *)&v42 = v95;
                    *((_QWORD *)&v42 + 1) = &v93[8 * v94];
                    if (v84)
                    {
                      v124 = v42;
                      v129 = v43;
                      operator delete(v84);
                      v42 = v124;
                      v43 = v129;
                    }
                  }
                  else
                  {
                    v87 = (uint64_t)(*((_QWORD *)&v42 + 1) - v42) >> 3;
                    if (v87 >= -1)
                      v88 = v87 + 1;
                    else
                      v88 = v87 + 2;
                    v89 = v88 >> 1;
                    v90 = v42 + 8 * (v88 >> 1);
                    v85 = (char *)(v90 - (v42 - *((_QWORD *)&v43 + 1)));
                    if ((_QWORD)v42 == *((_QWORD *)&v43 + 1))
                    {
                      v86 = (_BYTE *)*((_QWORD *)&v43 + 1);
                    }
                    else
                    {
                      v125 = *((_QWORD *)&v42 + 1);
                      v128 = v43;
                      memmove((void *)(v90 - (v42 - *((_QWORD *)&v43 + 1))), *((const void **)&v43 + 1), v42 - *((_QWORD *)&v43 + 1));
                      *((_QWORD *)&v42 + 1) = v125;
                      *(_QWORD *)&v43 = v128;
                    }
                    *((_QWORD *)&v43 + 1) = v85;
                    *(_QWORD *)&v42 = &v86[8 * v89];
                  }
                }
                else
                {
                  v85 = (char *)*((_QWORD *)&v43 + 1);
                }
                v101 = *(_QWORD *)(i - 8);
                *((_QWORD *)v85 - 1) = v101;
                *((_QWORD *)&v43 + 1) -= 8;
              }
              v102 = *(void **)(v2 + 200);
              *(_OWORD *)(v2 + 200) = v43;
              *(_OWORD *)(v2 + 216) = v42;
              if (v102)
              {
                operator delete(v102);
                v9 = *(char **)(v2 + 216);
              }
              else
              {
                v9 = (char *)v42;
              }
            }
            else
            {
              v30 = operator new(0x1000uLL);
              v31 = v30;
              if (v28 == v9)
              {
                if (v8 == v29)
                {
                  if (v9 == v8)
                    v57 = 1;
                  else
                    v57 = (v28 - v8) >> 2;
                  v58 = 2 * v57;
                  v59 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v57);
                  v8 = &v59[(v58 + 6) & 0xFFFFFFFFFFFFFFF8];
                  v61 = *(uint64_t **)(v2 + 208);
                  v62 = v8;
                  v63 = *(_QWORD *)(v2 + 216) - (_QWORD)v61;
                  if (v63)
                  {
                    v62 = &v8[v63 & 0xFFFFFFFFFFFFFFF8];
                    v64 = 8 * (v63 >> 3);
                    v65 = &v59[(v58 + 6) & 0xFFFFFFFFFFFFFFF8];
                    do
                    {
                      v66 = *v61++;
                      *(_QWORD *)v65 = v66;
                      v65 += 8;
                      v64 -= 8;
                    }
                    while (v64);
                  }
                  v67 = *(void **)(v2 + 200);
                  *(_QWORD *)(v2 + 200) = v59;
                  *(_QWORD *)(v2 + 208) = v8;
                  *(_QWORD *)(v2 + 216) = v62;
                  *(_QWORD *)(v2 + 224) = &v59[8 * v60];
                  if (v67)
                  {
                    operator delete(v67);
                    v8 = *(char **)(v2 + 208);
                  }
                }
                *((_QWORD *)v8 - 1) = v31;
                v68 = *(char **)(v2 + 208);
                v69 = *(char **)(v2 + 216);
                *(_QWORD *)(v2 + 208) = v68 - 8;
                v70 = *((_QWORD *)v68 - 1);
                *(_QWORD *)(v2 + 208) = v68;
                if (v69 == *(char **)(v2 + 224))
                {
                  v71 = *(_QWORD *)(v2 + 200);
                  v72 = (uint64_t)&v68[-v71];
                  if ((unint64_t)v68 <= v71)
                  {
                    v103 = (uint64_t)&v69[-v71];
                    v44 = v103 == 0;
                    v104 = v103 >> 2;
                    if (v44)
                      v105 = 1;
                    else
                      v105 = v104;
                    v106 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v105);
                    v108 = &v106[8 * (v105 >> 2)];
                    v109 = *(uint64_t **)(v2 + 208);
                    v69 = v108;
                    v110 = *(_QWORD *)(v2 + 216) - (_QWORD)v109;
                    if (v110)
                    {
                      v69 = &v108[v110 & 0xFFFFFFFFFFFFFFF8];
                      v111 = 8 * (v110 >> 3);
                      v112 = &v106[8 * (v105 >> 2)];
                      do
                      {
                        v113 = *v109++;
                        *(_QWORD *)v112 = v113;
                        v112 += 8;
                        v111 -= 8;
                      }
                      while (v111);
                    }
                    v114 = *(void **)(v2 + 200);
                    *(_QWORD *)(v2 + 200) = v106;
                    *(_QWORD *)(v2 + 208) = v108;
                    *(_QWORD *)(v2 + 216) = v69;
                    *(_QWORD *)(v2 + 224) = &v106[8 * v107];
                    if (v114)
                    {
                      operator delete(v114);
                      v69 = *(char **)(v2 + 216);
                    }
                  }
                  else
                  {
                    v73 = v72 >> 3;
                    v21 = v72 >> 3 < -1;
                    v74 = (v72 >> 3) + 2;
                    if (v21)
                      v75 = v74;
                    else
                      v75 = v73 + 1;
                    v76 = &v68[-8 * (v75 >> 1)];
                    v77 = v69 - v68;
                    if (v69 != v68)
                    {
                      memmove(&v68[-8 * (v75 >> 1)], v68, v69 - v68);
                      v68 = *(char **)(v2 + 208);
                    }
                    v69 = &v76[v77];
                    *(_QWORD *)(v2 + 208) = &v68[-8 * (v75 >> 1)];
                    *(_QWORD *)(v2 + 216) = &v76[v77];
                  }
                }
                *(_QWORD *)v69 = v70;
              }
              else
              {
                *(_QWORD *)v9 = v30;
              }
              v9 = (char *)(*(_QWORD *)(v2 + 216) + 8);
              *(_QWORD *)(v2 + 216) = v9;
            }
            v1 = v121;
          }
          v8 = *(char **)(v2 + 208);
        }
        if (v9 == v8)
        {
          v116 = 0;
        }
        else
        {
          v115 = *(_QWORD *)(v2 + 240) + *(_QWORD *)(v2 + 232);
          v116 = (_QWORD *)(*(_QWORD *)&v8[(v115 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v115 & 0x1FF));
        }
        *v116 = *v6;
        ++*(_QWORD *)(v2 + 240);
        v117 = *v6;
        *v6 = 0;

        v3 = *(_DWORD *)(v2 + 8);
      }
      ++v4;
    }
    while (v4 < v3);
  }
  std::mutex::unlock((std::mutex *)(v2 + 136));
  v130 = 0uLL;
  std::shared_ptr<AccelerationStructureViewerServer::APSRayCollector>::operator=[abi:nn180100](*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 48, &v130);
  v118 = (std::__shared_weak_count *)*((_QWORD *)&v130 + 1);
  if (*((_QWORD *)&v130 + 1))
  {
    v119 = (unint64_t *)(*((_QWORD *)&v130 + 1) + 8);
    do
      v120 = __ldaxr(v119);
    while (__stlxr(v120 - 1, v119));
    if (!v120)
    {
      ((void (*)(std::__shared_weak_count *))v118->__on_zero_shared)(v118);
      std::__shared_weak_count::__release_weak(v118);
    }
  }
}

void AccelerationStructureViewerServer::Server::~Server(AccelerationStructureViewerServer::Server *this)
{
  AccelerationStructureViewerServer::Server::~Server(this);
  operator delete();
}

{
  NSObject *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  void *v8;
  void *v9;
  uint64_t i;

  *(_QWORD *)this = off_7275C0;
  *((_QWORD *)this + 1) = off_727650;
  *((_QWORD *)this + 3) = 0;
  v2 = *((id *)this + 10);
  v3 = (void *)*((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;

  v4 = 4;
  do
  {
    dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
    --v4;
  }
  while (v4);
  v5 = 4;
  do
  {
    dispatch_semaphore_signal(v2);
    --v5;
  }
  while (v5);

  v6 = -32;
  do
  {
    v7 = (_QWORD *)((char *)this + v6);
    v8 = *(void **)((char *)this + v6 + 120);
    *(_QWORD *)((char *)this + v6 + 120) = 0;

    v9 = *(void **)((char *)this + v6 + 152);
    v7[19] = 0;

    free(*(void **)((char *)this + v6 + 184));
    free(*(void **)((char *)this + v6 + 216));
    v7[23] = 0;
    v7[27] = 0;
    v6 += 8;
  }
  while (v6);
  for (i = 144; i != 112; i -= 8)

  do
  {

    i -= 8;
  }
  while (i != 80);

}

uint64_t AccelerationStructureViewerServer::Server::connect(AccelerationStructureViewerServer::Server *this, Transport *a2)
{
  *((_QWORD *)this + 3) = a2;
  return (*((uint64_t (**)(Transport *, AccelerationStructureViewerServer::Server *))a2->var0 + 2))(a2, this);
}

_QWORD *AccelerationStructureViewerServer::Server::lost(_QWORD *this, uint64_t a2)
{
  if (!a2)
  {
    this = (_QWORD *)this[4];
    if (this)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD, uint64_t))(*this + 88))(this, 0, 1);
  }
  return this;
}

void AccelerationStructureViewerServer::Server::recv(AccelerationStructureViewerServer::Server *this, char *a2, uint64_t a3, uint8x8_t a4)
{
  uint64_t v4;
  char *v5;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(void);
  uint64_t v10;
  char v11;
  BOOL v12;
  int8x8_t v13;
  int16x8_t v14;
  int v15;
  char v16;
  char v17;
  char v18;
  unint64_t v19;
  int v20;
  int v21;
  int v22;
  char v23;
  int v24;
  char v25;
  char v26;
  char v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  BOOL v32;
  uint64_t v33;
  int v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  const std::locale::facet *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  _QWORD *v51;
  _QWORD *v52;
  unint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  uint64_t v62;
  char *v63;
  _QWORD *v64;
  char *v65;
  __int128 v66;
  uint64_t v67;
  size_t v68;
  uint64_t v69;
  char *v70;
  uint64_t v71;
  void *v72;
  uint64_t v73;
  void *v74;
  void *v75;
  uint64_t v76;
  void **v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  int v84;
  char v85;
  char v86;
  int16x8_t v87;
  char v88;
  _QWORD v89[6];
  void (**v90)(AccelerationStructureViewer::Filter *__hidden);
  char v91;
  _QWORD v92[3];
  _QWORD v93[6];
  _QWORD v94[6];
  void (**v95)(AccelerationStructureViewer::Filter *__hidden);
  char v96;
  _QWORD v97[3];
  _QWORD v98[6];
  void (**v99)(AccelerationStructureViewer::Filter *__hidden);
  char v100;
  _QWORD v101[3];
  _QWORD v102[6];
  void (**v103)(AccelerationStructureViewer::Filter *__hidden);
  char v104;
  _QWORD v105[3];
  _QWORD v106[9];
  void (**v107)(AccelerationStructureViewer::Filter *__hidden);
  char locale;
  _QWORD v109[3];
  _QWORD v110[6];
  _QWORD v111[6];
  char v112[2];
  __int16 v113;
  int v114;
  uint64_t v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  _DWORD v124[2];
  char v125;
  BOOL v126;
  unsigned __int32 v127;
  char v128;
  char v129;
  char v130;
  char v131;
  char v132;
  char v133;
  int v134;
  int v135;
  char v136;
  char v137;
  int v138;
  _BYTE v139[260];
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  uint64_t v148;
  int v149;
  uint64_t v150;
  int v151;
  uint64_t v152;
  int v153;
  uint64_t v154;
  void **__src[33];
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  std::locale __dst[33];

  v5 = a2;
  switch(*a2)
  {
    case 0:
      v7 = *((_QWORD *)this + 4);
      if (!v7)
        return;
      v8 = 13;
      if (*(_QWORD *)(a2 + 1) < 0xDuLL)
        v8 = *(_QWORD *)(a2 + 1);
      *((_QWORD *)this + 5) = v8;
      v9 = *(void (**)(void))(*(_QWORD *)v7 + 40);
      goto LABEL_49;
    case 1:
    case 13:
      return;
    case 2:
      v10 = *((_QWORD *)this + 4);
      if (!v10)
        return;
      v11 = a2[1];
      v12 = a2[2] != 0;
      a4.i32[0] = *(_DWORD *)(a2 + 3);
      v14 = (int16x8_t)vmovl_u8(a4);
      v13 = (int8x8_t)vceq_s16(*(int16x4_t *)v14.i8, (int16x4_t)0x1000100010001);
      *(int16x4_t *)v14.i8 = vceq_s16(*(int16x4_t *)v14.i8, (int16x4_t)0x2000200020002);
      *(int16x4_t *)v14.i8 = vsub_s16((int16x4_t)vand_s8(*(int8x8_t *)v14.i8, (int8x8_t)0x2000200020002), (int16x4_t)vbic_s8(v13, *(int8x8_t *)v14.i8));
      v15 = a2[7];
      v16 = v15 == 1;
      if (v15 == 2)
        v16 = 2;
      v17 = a2[8];
      v18 = a2[9];
      v19 = *((_QWORD *)this + 5);
      if (v19 < 2)
      {
        v22 = 0;
        if (v19 == 1)
        {
          v21 = 0;
          v25 = 0;
          v26 = 0;
          v27 = 0;
          v20 = *(_DWORD *)(a2 + 10);
LABEL_72:
          v24 = -1;
          v23 = 1;
          goto LABEL_87;
        }
        v21 = 0;
        v20 = 0;
LABEL_71:
        v25 = 0;
        v26 = 0;
        v27 = 0;
        goto LABEL_72;
      }
      v20 = *(_DWORD *)(a2 + 10);
      v21 = *(_DWORD *)(a2 + 14);
      v22 = 0;
      if (v19 == 2)
        goto LABEL_71;
      v23 = a2[18];
      if (v19 < 4)
      {
        v25 = 0;
        v26 = 0;
        v27 = 0;
        v24 = -1;
      }
      else
      {
        v24 = *(_DWORD *)(a2 + 19);
        if (v19 == 4 || (v22 = *(_DWORD *)(a2 + 23), v19 < 8))
        {
          v25 = 0;
          v26 = 0;
          v27 = 0;
        }
        else
        {
          v25 = a2[27];
          v86 = v16;
          v88 = a2[1];
          if (a2[28] >= 7u)
            v26 = 0;
          else
            v26 = a2[28];
          if (a2[29] >= 7u)
            v27 = 0;
          else
            v27 = a2[29];
          v84 = *(_DWORD *)(a2 + 30);
          v87 = v14;
          v28 = *(_OWORD *)(a2 + 370);
          v160 = *(_OWORD *)(a2 + 354);
          v161 = v28;
          v29 = *(_OWORD *)(a2 + 402);
          v162 = *(_OWORD *)(a2 + 386);
          v163 = v29;
          v30 = *(_OWORD *)(a2 + 306);
          v156 = *(_OWORD *)(a2 + 290);
          v157 = v30;
          v31 = *(_OWORD *)(a2 + 338);
          v158 = *(_OWORD *)(a2 + 322);
          v159 = v31;
          v4 = *(_QWORD *)(a2 + 418);
          v83 = *(_DWORD *)(a2 + 426);
          *(_OWORD *)((char *)&__src[24] + 4) = *(_OWORD *)(a2 + 226);
          *(_OWORD *)((char *)&__src[26] + 4) = *(_OWORD *)(a2 + 242);
          *(_OWORD *)((char *)&__src[28] + 4) = *(_OWORD *)(a2 + 258);
          *(_OWORD *)((char *)&__src[30] + 4) = *(_OWORD *)(a2 + 274);
          *(_OWORD *)((char *)&__src[16] + 4) = *(_OWORD *)(a2 + 162);
          *(_OWORD *)((char *)&__src[18] + 4) = *(_OWORD *)(a2 + 178);
          *(_OWORD *)((char *)&__src[20] + 4) = *(_OWORD *)(a2 + 194);
          *(_OWORD *)((char *)&__src[22] + 4) = *(_OWORD *)(a2 + 210);
          *(_OWORD *)((char *)&__src[8] + 4) = *(_OWORD *)(a2 + 98);
          *(_OWORD *)((char *)&__src[10] + 4) = *(_OWORD *)(a2 + 114);
          *(_OWORD *)((char *)&__src[12] + 4) = *(_OWORD *)(a2 + 130);
          *(_OWORD *)((char *)&__src[14] + 4) = *(_OWORD *)(a2 + 146);
          *(_OWORD *)((char *)__src + 4) = *(_OWORD *)(a2 + 34);
          *(_OWORD *)((char *)&__src[2] + 4) = *(_OWORD *)(a2 + 50);
          *(_OWORD *)((char *)&__src[4] + 4) = *(_OWORD *)(a2 + 66);
          *(_OWORD *)((char *)&__src[6] + 4) = *(_OWORD *)(a2 + 82);
          v32 = v12;
          v85 = v17;
          memcpy(__dst, __src, 0x104uLL);
          LODWORD(v19) = v84;
          v17 = v85;
          v16 = v86;
          v14 = v87;
          v12 = v32;
          LODWORD(v5) = v83;
          v11 = v88;
        }
      }
LABEL_87:
      v124[0] = v20;
      v124[1] = v21;
      v125 = v11;
      v126 = v12;
      v127 = vmovn_s16(v14).u32[0];
      v128 = v16;
      v129 = v17;
      v130 = v18;
      v131 = v23;
      v132 = v25;
      v133 = 0;
      v134 = v24;
      v135 = v22;
      v136 = v26;
      v137 = v27;
      v138 = v19;
      memcpy(v139, __dst, sizeof(v139));
      v142 = v158;
      v143 = v159;
      v140 = v156;
      v141 = v157;
      v146 = v162;
      v147 = v163;
      v144 = v160;
      v145 = v161;
      v148 = v4;
      v149 = (int)v5;
      (*(void (**)(uint64_t, _DWORD *))(*(_QWORD *)v10 + 32))(v10, v124);
      return;
    case 3:
      v33 = *((_QWORD *)this + 4);
      if (v33)
      {
        v34 = *(_DWORD *)(a2 + 1);
        v35 = *(_OWORD *)(a2 + 14);
        v36 = *(_OWORD *)(a2 + 30);
        v37 = *(_OWORD *)(a2 + 46);
        v38 = *(_OWORD *)(a2 + 62);
        v39 = *(_OWORD *)(a2 + 78);
        v40 = *(_OWORD *)(a2 + 94);
        v41 = *(_OWORD *)(a2 + 110);
        v42 = *(_OWORD *)(a2 + 126);
        v112[0] = a2[5];
        v113 = 0;
        v114 = v34;
        v115 = *(_QWORD *)(a2 + 6);
        v116 = v35;
        v117 = v36;
        v118 = v37;
        v119 = v38;
        v120 = v39;
        v121 = v40;
        v122 = v41;
        v123 = v42;
        (*(void (**)(uint64_t, char *))(*(_QWORD *)v33 + 24))(v33, v112);
      }
      return;
    case 4:
      v43 = *((_QWORD *)this + 4);
      if (v43)
        (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v43 + 88))(v43, *(_QWORD *)(a2 + 1), 0);
      return;
    case 7:
      operator new();
    case 9:
      if (*((_QWORD *)this + 5) < 0xDuLL)
        goto LABEL_66;
      v50 = *(unsigned __int16 *)(a2 + 1);
      __dst[0].__locale_ = 0;
      __dst[1].__locale_ = (std::locale::__imp *)(a2 + 3);
      __dst[2].__locale_ = (std::locale::__imp *)(a3 - 3);
      LOBYTE(__dst[3].__locale_) = 0;
      LOWORD(__src[0]) = 0;
      v51 = (_QWORD *)AccelerationStructureViewer::DataSourceQueryBlobDecoder::decode((uint64_t)__dst, __src);
      v52 = v51;
      if (LOWORD(__src[0]) == 14)
      {
        if (v51)
        {
          v46 = *(_QWORD *)(*((_QWORD *)this + 4) + 8);
          if (v46)
          {
            v48 = v51[3];
            v47 = v51[4];
            __dst[0].__locale_ = (std::locale::__imp *)off_727800;
            memset(&__dst[2], 0, 24);
            LOBYTE(__dst[1].__locale_) = 0;
            v49 = v51[5];
            if (v49)
            {
              LOBYTE(__dst[1].__locale_) = *(_BYTE *)(v49 + 8);
              if (__dst != (std::locale *)v49)
                std::vector<AccelerationStructureViewer::FilterToken>::__assign_with_size[abi:nn180100]<AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*>((uint64_t *)&__dst[2], *(_QWORD *)(v49 + 16), *(_QWORD *)(v49 + 24), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(v49 + 24) - *(_QWORD *)(v49 + 16)) >> 3));
            }
            switch(v50)
            {
              case 0:
                v111[0] = _NSConcreteStackBlock;
                v111[1] = 3221225472;
                v111[2] = ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke;
                v111[3] = &__block_descriptor_48_e21_v24__0_v8__NSError_16l;
                v111[4] = this;
                v111[5] = v52;
                (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v46 + 32))(v46, v111);
                break;
              case 1:
                v110[0] = _NSConcreteStackBlock;
                v110[1] = 3221225472;
                v110[2] = ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke_2;
                v110[3] = &__block_descriptor_48_e390_v40__0_vector_AccelerationStructureViewer::IntersectionFunctionTable__std::allocator_AccelerationStructureViewer::IntersectionFunctionTable_____IntersectionFunctionTable___IntersectionFunctionTable____compressed_pair_AccelerationStructureViewer::IntersectionFunctionTable____std::allocator_AccelerationStructureViewer::IntersectionFunctionTable_____IntersectionFunctionTable___8__NSError_32l;
                v110[4] = this;
                v110[5] = v52;
                (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v46 + 16))(v46, v110);
                break;
              case 2:
                v106[0] = _NSConcreteStackBlock;
                v106[1] = 3321888768;
                v106[2] = ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke_3;
                v106[3] = &__block_descriptor_112_a8_72c42_ZTSN27AccelerationStructureViewer6FilterE_e390_v40__0_vector_AccelerationStructureViewer::IntersectionFunctionTable__std::allocator_AccelerationStructureViewer::IntersectionFunctionTable_____IntersectionFunctionTable___IntersectionFunctionTable____compressed_pair_AccelerationStructureViewer::IntersectionFunctionTable____std::allocator_AccelerationStructureViewer::IntersectionFunctionTable_____IntersectionFunctionTable___8__NSError_32l;
                v106[4] = this;
                v106[5] = v52;
                v106[6] = v46;
                v106[7] = v48;
                v106[8] = v47;
                v107 = off_727800;
                locale = (char)__dst[1].__locale_;
                memset(v109, 0, sizeof(v109));
                std::vector<AccelerationStructureViewer::FilterToken>::__init_with_size[abi:nn180100]<AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*>(v109, (uint64_t)__dst[2].__locale_, (uint64_t)__dst[3].__locale_, 0xAAAAAAAAAAAAAAABLL * ((__dst[3].__locale_ - __dst[2].__locale_) >> 3));
                (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v46 + 16))(v46, v106);
                v107 = off_727800;
                __src[0] = (void **)v109;
                goto LABEL_81;
              case 3:
                v76 = v52[2];
                v103 = off_727800;
                v104 = (char)__dst[1].__locale_;
                v77 = (void **)v105;
                memset(v105, 0, sizeof(v105));
                std::vector<AccelerationStructureViewer::FilterToken>::__init_with_size[abi:nn180100]<AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*>(v105, (uint64_t)__dst[2].__locale_, (uint64_t)__dst[3].__locale_, 0xAAAAAAAAAAAAAAABLL * ((__dst[3].__locale_ - __dst[2].__locale_) >> 3));
                v102[0] = _NSConcreteStackBlock;
                v102[1] = 3221225472;
                v102[2] = ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke_23;
                v102[3] = &__block_descriptor_48_e21_v24__0_v8__NSError_16l;
                v102[4] = this;
                v102[5] = v52;
                (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void (***)(AccelerationStructureViewer::Filter *__hidden), _QWORD *))(*(_QWORD *)v46 + 72))(v46, v76, v48, v47, &v103, v102);
                v103 = off_727800;
                goto LABEL_79;
              case 4:
                v78 = v52[2];
                v99 = off_727800;
                v100 = (char)__dst[1].__locale_;
                v77 = (void **)v101;
                memset(v101, 0, sizeof(v101));
                std::vector<AccelerationStructureViewer::FilterToken>::__init_with_size[abi:nn180100]<AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*>(v101, (uint64_t)__dst[2].__locale_, (uint64_t)__dst[3].__locale_, 0xAAAAAAAAAAAAAAABLL * ((__dst[3].__locale_ - __dst[2].__locale_) >> 3));
                v98[0] = _NSConcreteStackBlock;
                v98[1] = 3221225472;
                v98[2] = ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke_2_24;
                v98[3] = &__block_descriptor_48_e21_v24__0_v8__NSError_16l;
                v98[4] = this;
                v98[5] = v52;
                (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void (***)(AccelerationStructureViewer::Filter *__hidden), _QWORD *))(*(_QWORD *)v46 + 40))(v46, v78, v48, v47, &v99, v98);
                v99 = off_727800;
                goto LABEL_79;
              case 5:
                v79 = v52[2];
                v90 = off_727800;
                v91 = (char)__dst[1].__locale_;
                v77 = (void **)v92;
                memset(v92, 0, sizeof(v92));
                std::vector<AccelerationStructureViewer::FilterToken>::__init_with_size[abi:nn180100]<AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*>(v92, (uint64_t)__dst[2].__locale_, (uint64_t)__dst[3].__locale_, 0xAAAAAAAAAAAAAAABLL * ((__dst[3].__locale_ - __dst[2].__locale_) >> 3));
                v89[0] = _NSConcreteStackBlock;
                v89[1] = 3221225472;
                v89[2] = ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke_5;
                v89[3] = &__block_descriptor_48_e21_v24__0_v8__NSError_16l;
                v89[4] = this;
                v89[5] = v52;
                (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void (***)(AccelerationStructureViewer::Filter *__hidden), _QWORD *))(*(_QWORD *)v46 + 64))(v46, v79, v48, v47, &v90, v89);
                v90 = off_727800;
LABEL_79:
                __src[0] = v77;
                goto LABEL_81;
              case 6:
                v80 = v52[2];
                v81 = v52[6];
                v95 = off_727800;
                v96 = (char)__dst[1].__locale_;
                memset(v97, 0, sizeof(v97));
                std::vector<AccelerationStructureViewer::FilterToken>::__init_with_size[abi:nn180100]<AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*>(v97, (uint64_t)__dst[2].__locale_, (uint64_t)__dst[3].__locale_, 0xAAAAAAAAAAAAAAABLL * ((__dst[3].__locale_ - __dst[2].__locale_) >> 3));
                v94[0] = _NSConcreteStackBlock;
                v94[1] = 3221225472;
                v94[2] = ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke_3_25;
                v94[3] = &__block_descriptor_48_e21_v24__0_v8__NSError_16l;
                v94[4] = this;
                v94[5] = v52;
                (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void (***)(AccelerationStructureViewer::Filter *__hidden), _QWORD *))(*(_QWORD *)v46 + 48))(v46, v80, v81, v48, v47, &v95, v94);
                v95 = off_727800;
                __src[0] = (void **)v97;
LABEL_81:
                std::vector<AccelerationStructureViewer::FilterToken>::__destroy_vector::operator()[abi:nn180100](__src);
                break;
              case 7:
                v82 = v52[2];
                v93[0] = _NSConcreteStackBlock;
                v93[1] = 3221225472;
                v93[2] = ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke_4_26;
                v93[3] = &__block_descriptor_48_e28_v24__0__NSData_8__NSError_16l;
                v93[4] = this;
                v93[5] = v52;
                (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v46 + 56))(v46, v82, v48, v47, v93);
                break;
              default:
                break;
            }
            __dst[0].__locale_ = (std::locale::__imp *)off_727800;
            __src[0] = (void **)&__dst[2].__locale_;
            std::vector<AccelerationStructureViewer::FilterToken>::__destroy_vector::operator()[abi:nn180100](__src);
          }
          else
          {
            v73 = v51[1];
            v74 = (void *)objc_claimAutoreleasedReturnValue(+[ASVError errorWithCode:localizedDescription:](ASVError, "errorWithCode:localizedDescription:", 5, CFSTR("id<MTLAccelerationStructure> is missing")));
            AccelerationStructureViewerServer::Server::replyQueryable((uint64_t)this, 8, v73, 0, v74);

          }
          (*(void (**)(_QWORD *))(*v52 + 8))(v52);
          return;
        }
      }
      else if (v51)
      {
        (*(void (**)(_QWORD *))(*v51 + 8))(v51);
      }
LABEL_66:
      v75 = (void *)objc_claimAutoreleasedReturnValue(+[ASVError errorWithCode:localizedDescription:](ASVError, "errorWithCode:localizedDescription:", 5, CFSTR("properties is missing")));
      AccelerationStructureViewerServer::Server::replyQueryable((uint64_t)this, 8, -1, 0, v75);

      return;
    case 10:
      v53 = a2[1];
      if (v53 > 5)
        v54 = 0;
      else
        v54 = dword_4A9354[v53];
      if (v54 != *((_DWORD *)this + 18))
      {
        v69 = 4;
        do
        {
          dispatch_semaphore_wait(*((dispatch_semaphore_t *)this + 10), 0xFFFFFFFFFFFFFFFFLL);
          --v69;
        }
        while (v69);
        *((_DWORD *)this + 18) = v54;
        v70 = (char *)this + 184;
        do
        {
          free(*(void **)&v70[v69]);
          *(_QWORD *)&v70[v69] = 0;
          v69 += 8;
        }
        while (v69 != 32);
        v71 = 4;
        do
        {
          dispatch_semaphore_signal(*((dispatch_semaphore_t *)this + 10));
          --v71;
        }
        while (v71);
      }
      return;
    case 14:
      v55 = *(_QWORD *)(a2 + 1);
      v56 = *(_QWORD *)(a2 + 13);
      v57 = *(_DWORD *)(a2 + 21);
      v58 = *((_QWORD *)this + 4);
      v151 = *(_DWORD *)(a2 + 9);
      v150 = v55;
      v153 = v57;
      v152 = v56;
      v154 = *(_QWORD *)(a2 + 25);
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v58 + 72))(v58, &v150);
      return;
    case 15:
      (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 4) + 80))(*((_QWORD *)this + 4), *(unsigned int *)(a2 + 1));
      return;
    case 16:
      v59 = *(unsigned int *)(a2 + 13);
      if (40 * v59 + 17 == a3)
      {
        if ((_DWORD)v59)
        {
          v60 = 48 * v59;
          v61 = (char *)operator new(48 * v59);
          bzero(v61, 48 * ((v60 - 48) / 0x30uLL) + 48);
          v62 = 0;
          v63 = &v61[48 * ((v60 - 48) / 0x30uLL) + 48];
          v64 = v5 + 49;
          do
          {
            v65 = &v61[v62];
            v66 = *((_OWORD *)v64 - 1);
            *(_OWORD *)v65 = *((_OWORD *)v64 - 2);
            *((_OWORD *)v65 + 1) = v66;
            v67 = *v64;
            v64 += 5;
            *((_QWORD *)v65 + 4) = v67;
            v62 += 48;
          }
          while (v60 != v62);
        }
        else
        {
          v63 = 0;
          v61 = 0;
        }
        (*(void (**)(_QWORD, BOOL, _QWORD, char *, _QWORD))(**((_QWORD **)this + 4) + 104))(*((_QWORD *)this + 4), *(_DWORD *)(v5 + 1) == 1, *(_QWORD *)(v5 + 5), v61, -1431655765 * ((unint64_t)(v63 - v61) >> 4));
        if (v61)
          goto LABEL_69;
      }
      return;
    case 18:
      v68 = *(unsigned int *)(a2 + 1);
      if ((_DWORD)v68 == -1)
      {
        v61 = 0;
      }
      else
      {
        v61 = (char *)operator new((v68 + 1));
        bzero(v61, (v68 + 1));
      }
      memcpy(v61, v5 + 5, v68);
      v61[v68] = 0;
      v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", v61, 30));
      (*(void (**)(_QWORD, void *))(**((_QWORD **)this + 4) + 48))(*((_QWORD *)this + 4), v72);

LABEL_69:
      operator delete(v61);
      return;
    case 19:
      v9 = *(void (**)(void))(**((_QWORD **)this + 4) + 56);
LABEL_49:
      v9();
      return;
    default:
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>((uint64_t)"ASVPacket - type '", 18);
      LOBYTE(__dst[0].__locale_) = *v5;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>((uint64_t)__dst, 1);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>((uint64_t)"' is invalid", 12);
      std::ios_base::getloc((const std::ios_base *)((char *)&std::cout
                                                  + (unint64_t)std::cout.__vftable[-2].~basic_ostream_0));
      v44 = std::locale::use_facet(__dst, &std::ctype<char>::id);
      v45 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v44->__vftable[2].~facet_0)(v44, 10);
      std::locale::~locale(__dst);
      std::ostream::put(&std::cout, v45);
      std::ostream::flush(&std::cout);
      return;
  }
}

uint64_t AccelerationStructureViewerServer::Server::setVersion(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  char v4;
  uint64_t v5;

  result = *(_QWORD *)(a1 + 24);
  if (result)
  {
    v4 = 0;
    v5 = a2;
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, char *, uint64_t))(*(_QWORD *)result + 32))(result, a1, 0, 0, &v4, 9);
  }
  return result;
}

uint64_t AccelerationStructureViewerServer::Server::addSampler(uint64_t this, Sampler *a2)
{
  *(_QWORD *)(this + 32) = a2;
  return this;
}

uint64_t AccelerationStructureViewerServer::Server::setSamplerProperties(uint64_t result)
{
  unint64_t v1;

  if (*(_QWORD *)(result + 24))
  {
    v1 = *(_QWORD *)(result + 40);
    if (v1 >= 5)
      operator new();
    if (v1 >= 2)
      operator new();
    operator new();
  }
  return result;
}

void AccelerationStructureViewerServer::Server::receiveSample(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  unint64_t v7;
  uint64_t v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  char v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  unint64_t v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  id v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  void *v48;
  unsigned __int8 v49;
  void *v50;
  unsigned __int8 v51;
  unint64_t v52;
  void *v53;
  id v54;
  unsigned __int8 v55;
  void *v56;
  id v57;
  unsigned __int8 v58;
  void *v59;
  void *v60;
  id v61;
  unsigned __int8 v62;
  uint64_t v63;
  uint64_t v64;
  id *v65;
  void *v66;
  id v67;
  void *v68;
  id v69;
  void *v70;
  void *v71;
  void *v72;
  id v73;
  id v74;
  void *v75;
  id v76;
  id v77;
  unint64_t v78;
  void *v79;
  id v80;
  id v81;
  void *v82;
  id v83;
  id v84;
  void *v85;
  id v86;
  id v87;
  void *v88;
  id v89;
  id v90;
  id v91;
  _QWORD *v92;
  uint64_t v93;
  int v94;
  int v95;
  char v96;
  char v97;
  unint64_t v98;
  __int16 v99;
  char v100;
  unint64_t v101;
  unint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  char *v108;
  unsigned __int8 v109;
  unsigned __int8 v110;
  unsigned __int8 v111;
  unsigned __int8 v112;
  unint64_t v113;
  uint64_t v114;
  unint64_t v115;
  _QWORD v116[3];
  _QWORD v117[3];
  _QWORD v118[3];
  _QWORD v119[3];
  _QWORD v120[3];
  _QWORD v121[3];
  _QWORD v122[3];
  _QWORD v123[3];
  _QWORD v124[3];
  _QWORD v125[3];
  _QWORD v126[3];
  _QWORD v127[3];
  uint64_t v128;
  uint64_t *v129;
  uint64_t v130;
  uint64_t (*v131)(uint64_t, uint64_t);
  void (*v132)(uint64_t);
  NSObject *v133;
  uint64_t v134;
  char v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  _OWORD v144[2];
  uint64_t v145;
  char v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  _OWORD v155[2];
  uint64_t v156;
  char v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  _OWORD v166[2];
  uint64_t v167;
  char v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  __int128 v175;
  __int128 v176;
  _OWORD v177[2];
  uint64_t v178;
  char v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  _OWORD v188[2];
  _QWORD v189[4];
  uint64_t v190[72];
  _BYTE v191[24];
  _BYTE *v192;
  id v193;
  id v194;
  id v195;
  id v196;
  id v197;
  id v198;
  id v199;
  uint64_t *v200;
  uint64_t v201;
  uint64_t v202;
  unint64_t v203;
  uint64_t v204;
  unint64_t v205;
  unint64_t v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  __int128 v211;
  __int128 v212;
  __int128 v213;
  __int128 v214;
  _BYTE v215[31];
  char v216;
  unsigned __int8 v217;
  unsigned __int8 v218;
  unsigned __int8 v219;
  uint64_t v220;
  char v221;
  int v222;
  unsigned __int8 v223;
  __int16 v224;
  char v225;
  char v226;
  char v227;
  int v228;
  __int128 v229;
  __int128 v230;
  __int128 v231;
  __int128 v232;
  __int128 v233;
  __int128 v234;
  __int128 v235;
  __int128 v236;
  __int128 v237;
  __int128 v238;
  __int128 v239;
  __int128 v240;
  __int128 v241;
  __int128 v242;
  __int128 v243;
  __int128 v244;
  __int128 v245;
  __int128 v246;
  __int128 v247;
  __int128 v248;
  __int128 v249;
  __int128 v250;
  __int128 v251;
  __int128 v252;
  uint64_t v253;
  int v254;
  __int128 v255;
  __int128 v256;
  __int128 v257;
  __int128 v258;
  __int128 v259;
  __int128 v260;
  __int128 v261;
  __int128 v262;
  _BYTE v263[31];
  char v264;
  unsigned __int8 v265;
  unsigned __int8 v266;
  unsigned __int8 v267;
  uint64_t v268;
  char v269;
  int v270;
  unsigned __int8 v271;
  __int16 v272;
  char v273;
  __int128 v274;
  __int128 v275;
  __int128 v276;
  __int128 v277;
  __int128 v278;
  __int128 v279;
  __int128 v280;
  __int128 v281;
  _BYTE v282[31];
  char v283;
  unsigned __int8 v284;
  unsigned __int8 v285;
  unsigned __int8 v286;
  uint64_t v287;
  char v288;
  int v289;
  unsigned __int8 v290;
  __int128 v291;
  __int128 v292;
  __int128 v293;
  __int128 v294;
  __int128 v295;
  __int128 v296;
  __int128 v297;
  __int128 v298;
  _BYTE v299[31];
  char v300;
  unsigned __int8 v301;
  unsigned __int8 v302;
  unsigned __int8 v303;
  uint64_t v304;
  char v305;
  int v306;
  __int128 v307;
  __int128 v308;
  __int128 v309;
  __int128 v310;
  __int128 v311;
  __int128 v312;
  __int128 v313;
  __int128 v314;
  _BYTE v315[31];
  char v316;
  unsigned __int8 v317;
  unsigned __int8 v318;
  unsigned __int8 v319;
  uint64_t v320;
  char v321;
  __int128 v322;
  __int128 v323;
  __int128 v324;
  __int128 v325;
  __int128 v326;
  __int128 v327;
  __int128 v328;
  __int128 v329;
  __int128 v330;
  __int128 v331;
  __int128 v332;
  __int128 v333;
  __int128 v334;
  __int128 v335;
  __int128 v336;
  __int128 v337;
  __int128 v338;
  __int128 v339;
  __int128 v340;
  __int128 v341;
  __int128 v342;
  __int128 v343;
  __int128 v344;
  __int128 v345;

  v7 = *(_QWORD *)(a1 + 40);
  if (v7 <= 8)
    v8 = 16;
  else
    v8 = 256;
  v9 = objc_msgSend(*(id *)(a3 + 608), "width");
  v10 = v8 - 1;
  if (*(_QWORD *)(a1 + 40) >= 6uLL)
    v11 = ((v8 - ((4 * (_QWORD)v9) & (v8 - 1))) & (v8 - 1)) + 4 * (_QWORD)v9;
  else
    v11 = 4 * (_QWORD)v9;
  v12 = 16 * (_QWORD)objc_msgSend(*(id *)(a3 + 608), "width");
  v13 = 16 * (_QWORD)objc_msgSend(*(id *)(a3 + 624), "width");
  v14 = 16 * (_QWORD)objc_msgSend(*(id *)(a3 + 632), "width");
  v15 = 4 * (_QWORD)objc_msgSend(*(id *)(a3 + 640), "width");
  v16 = (unint64_t)objc_msgSend(*(id *)(a3 + 648), "width");
  v17 = *(_QWORD *)(a1 + 40);
  v18 = ((v8 - (v14 & v10)) & v10) + v14;
  v19 = ((v8 - (v15 & v10)) & v10) + v15;
  v20 = (char *)(((v8 - (v16 & v10)) & v10) + v16);
  if (v17 >= 9)
  {
    v21 = ((v8 - (v13 & v10)) & v10) + v13;
  }
  else
  {
    v20 = (char *)v16;
    v19 = v15;
    v18 = v14;
    v21 = v13;
  }
  if (v17 >= 9)
    v22 = ((v8 - (v12 & v10)) & v10) + v12;
  else
    v22 = v12;
  if (!v17 || !*(_QWORD *)(a1 + 24))
    goto LABEL_31;
  if (v17 < 3)
  {
    v38 = *(void **)(a3 + 608);
    if (v38 && *(_QWORD *)(a3 + 616) && *(_QWORD *)(a3 + 624))
    {
      v107 = v19;
      v108 = v20;
      v103 = v18;
      v104 = v11;
      v39 = (_QWORD)objc_msgSend(v38, "height") * v11;
      v114 = v22;
      v40 = (_QWORD)objc_msgSend(*(id *)(a3 + 616), "height") * v22;
      v41 = objc_msgSend(*(id *)(a3 + 624), "height");
      v101 = 0;
      v102 = 0;
      v98 = 0;
      v42 = v8 - (v39 & v10);
      v43 = v8 - (v40 & v10);
      if (v7 <= 8)
        v44 = 192;
      else
        v44 = 256;
      v45 = v39 + v44;
      v23 = 0;
      v46 = v45 + v42;
      v47 = v40 + v43;
      v24 = 0;
      v115 = v46;
      v113 = v46 + v47;
      v106 = v21;
      v37 = v46 + v47 + (_QWORD)v41 * v21;
      v109 = v46 + v47;
      v110 = v46 + v47;
      v111 = v46 + v47;
      v112 = v46 + v47;
      goto LABEL_60;
    }
LABEL_31:
    (*(void (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 32) + 88))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a3 + 8), 1);
    return;
  }
  v114 = v22;
  if (v17 > 0xA)
  {
    if (*(unsigned __int8 *)(a3 + 16) >= 7u)
      v23 = 0;
    else
      v23 = *(_BYTE *)(a3 + 16);
    if (*(unsigned __int8 *)(a3 + 17) >= 7u)
      v24 = 0;
    else
      v24 = *(_BYTE *)(a3 + 17);
    v94 = *(_DWORD *)(a3 + 24);
    v25 = *(_OWORD *)(a3 + 240);
    v342 = *(_OWORD *)(a3 + 224);
    v343 = v25;
    v26 = *(_OWORD *)(a3 + 272);
    v344 = *(_OWORD *)(a3 + 256);
    v345 = v26;
    v27 = *(_OWORD *)(a3 + 176);
    v338 = *(_OWORD *)(a3 + 160);
    v339 = v27;
    v28 = *(_OWORD *)(a3 + 208);
    v340 = *(_OWORD *)(a3 + 192);
    v341 = v28;
    v29 = *(_OWORD *)(a3 + 112);
    v334 = *(_OWORD *)(a3 + 96);
    v335 = v29;
    v30 = *(_OWORD *)(a3 + 144);
    v336 = *(_OWORD *)(a3 + 128);
    v337 = v30;
    v31 = *(_OWORD *)(a3 + 48);
    v330 = *(_OWORD *)(a3 + 32);
    v331 = v31;
    v32 = *(_OWORD *)(a3 + 80);
    v332 = *(_OWORD *)(a3 + 64);
    v333 = v32;
    v33 = *(_OWORD *)(a3 + 368);
    v326 = *(_OWORD *)(a3 + 352);
    v327 = v33;
    v34 = *(_OWORD *)(a3 + 400);
    v328 = *(_OWORD *)(a3 + 384);
    v329 = v34;
    v35 = *(_OWORD *)(a3 + 304);
    v322 = *(_OWORD *)(a3 + 288);
    v323 = v35;
    v36 = *(_OWORD *)(a3 + 336);
    v324 = *(_OWORD *)(a3 + 320);
    v325 = v36;
    v4 = *(_QWORD *)(a3 + 416);
    v37 = 582;
    v95 = *(_DWORD *)(a3 + 424);
    goto LABEL_34;
  }
  if (v17 == 10)
  {
    v24 = 0;
    v23 = 0;
    v37 = 180;
LABEL_34:
    v99 = *(_WORD *)(a3 + 434);
    v100 = *(_BYTE *)(a3 + 1);
    goto LABEL_40;
  }
  if (v17 <= 7)
  {
    v24 = 0;
    v23 = 0;
    if (v17 <= 4)
      v37 = 172;
    else
      v37 = 176;
  }
  else
  {
    v24 = 0;
    v23 = 0;
    v37 = 177;
  }
LABEL_40:
  v106 = v21;
  v107 = v19;
  v108 = v20;
  v103 = v18;
  v3 = *(_DWORD *)(a3 + 4);
  v48 = *(void **)(a3 + 608);
  if (v48)
  {
    v49 = v8 - (v37 & (v8 - 1));
    v44 = v37 + v49;
    v37 = v44 + (_QWORD)objc_msgSend(v48, "height") * v11;
    LOBYTE(v15) = 1;
  }
  else
  {
    v49 = 0;
    LOBYTE(v15) = 0;
    v44 = 0;
  }
  v104 = v11;
  v50 = *(void **)(a3 + 616);
  if (v50)
  {
    LOBYTE(v15) = v15 | 2;
    v51 = v8 - (v37 & (v8 - 1));
    v115 = v37 + v51;
    v37 = v115 + (_QWORD)objc_msgSend(v50, "height") * v114;
  }
  else
  {
    v51 = 0;
    v115 = 0;
  }
  v52 = *(_QWORD *)(a1 + 40);
  v111 = v51;
  v112 = v49;
  if (v52 < 0xB)
  {
    v56 = *(void **)(a3 + 624);
    if (v56)
    {
      v57 = objc_msgSend(v56, "height");
      LOBYTE(v15) = v15 | 4;
      v58 = v8 - (v37 & (v8 - 1));
      v113 = v37 + v58;
      v37 = v113 + (_QWORD)v57 * v106;
      v52 = *(_QWORD *)(a1 + 40);
    }
    else
    {
      v58 = 0;
      v113 = 0;
    }
    v110 = v58;
    if (v52 >= 8 && (v60 = *(void **)(a3 + 632)) != 0)
    {
      v61 = objc_msgSend(v60, "height");
      v101 = 0;
      v102 = 0;
      LOBYTE(v15) = v15 | 8;
      v62 = v8 - (v37 & (v8 - 1));
      v98 = v37 + v62;
      v37 = v98 + (_QWORD)v61 * v103;
      v109 = v62;
    }
    else
    {
      v109 = 0;
      v101 = 0;
      v102 = 0;
      v98 = 0;
    }
  }
  else
  {
    v53 = *(void **)(a3 + 640);
    if (v53)
    {
      v54 = objc_msgSend(v53, "height");
      LOBYTE(v15) = v15 | 4;
      v55 = v8 - (v37 & (v8 - 1));
      v101 = v37 + v55;
      v37 = v101 + (_QWORD)v54 * v107;
    }
    else
    {
      v55 = 0;
      v101 = 0;
    }
    v110 = v55;
    v59 = *(void **)(a3 + 648);
    if (v59)
    {
      v98 = 0;
      v113 = 0;
      LOBYTE(v15) = v15 | 8;
      v109 = v8 - (v37 & (v8 - 1));
      v102 = v37 + v109;
      v37 = v102 + (_QWORD)objc_msgSend(v59, "height") * (_QWORD)v108;
    }
    else
    {
      v109 = 0;
      v102 = 0;
      v98 = 0;
      v113 = 0;
    }
  }
LABEL_60:
  v128 = 0;
  v129 = &v128;
  v130 = 0x3032000000;
  v131 = __Block_byref_object_copy__8983;
  v132 = __Block_byref_object_dispose__8984;
  v133 = *(id *)(a1 + 80);
  dispatch_semaphore_wait(v133, 0xFFFFFFFFFFFFFFFFLL);
  v63 = 0;
  while (1)
  {
    v64 = a1 + 8 * v63;
    if (!dispatch_semaphore_wait(*(dispatch_semaphore_t *)(v64 + 88), 0))
      break;
    if (++v63 == 4)
    {
      dispatch_semaphore_signal((dispatch_semaphore_t)v129[5]);
      (*(void (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 32) + 88))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a3 + 8), 1);
      goto LABEL_87;
    }
  }
  v97 = v23;
  v105 = v44;
  v66 = *(void **)(v64 + 120);
  v65 = (id *)(v64 + 120);
  v67 = v66;
  v68 = v67;
  v96 = v24;
  if (!v67 || (unint64_t)objc_msgSend(v67, "length") < v37)
  {
    v69 = objc_msgSend(*(id *)(a1 + 48), "newBufferWithLength:options:", v37, 0);

    objc_storeStrong(v65, v69);
    v68 = v69;
  }
  v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 56), "commandBufferWithDescriptor:", *(_QWORD *)(a1 + 64)));
  objc_msgSend(v70, "setLabel:", CFSTR("ASVServer"));
  v71 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v70, "blitCommandEncoder"));
  v72 = *(void **)(a3 + 608);
  if (v72)
  {
    memset(v127, 0, sizeof(v127));
    v73 = objc_msgSend(v72, "width");
    v74 = objc_msgSend(*(id *)(a3 + 608), "height");
    v126[0] = v73;
    v126[1] = v74;
    v126[2] = 1;
    objc_msgSend(v71, "copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:", v72, 0, 0, v127, v126, v68, v105, v104, (_QWORD)objc_msgSend(*(id *)(a3 + 608), "height") * v104);
  }
  v75 = *(void **)(a3 + 616);
  if (v75)
  {
    memset(v125, 0, sizeof(v125));
    v76 = objc_msgSend(v75, "width");
    v77 = objc_msgSend(*(id *)(a3 + 616), "height");
    v124[0] = v76;
    v124[1] = v77;
    v124[2] = 1;
    objc_msgSend(v71, "copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:", v75, 0, 0, v125, v124, v68, v115, v114, (_QWORD)objc_msgSend(*(id *)(a3 + 616), "height") * v114);
  }
  v78 = *(_QWORD *)(a1 + 40);
  if (v78 < 0xB)
  {
    v85 = *(void **)(a3 + 624);
    if (v85)
    {
      memset(v119, 0, sizeof(v119));
      v86 = objc_msgSend(v85, "width");
      v87 = objc_msgSend(*(id *)(a3 + 624), "height");
      v118[0] = v86;
      v118[1] = v87;
      v118[2] = 1;
      objc_msgSend(v71, "copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:", v85, 0, 0, v119, v118, v68, v113, v106, (_QWORD)objc_msgSend(*(id *)(a3 + 624), "height") * v106);
      v78 = *(_QWORD *)(a1 + 40);
    }
    if (v78 >= 8)
    {
      v88 = *(void **)(a3 + 632);
      if (v88)
      {
        memset(v117, 0, sizeof(v117));
        v89 = objc_msgSend(v88, "width");
        v90 = objc_msgSend(*(id *)(a3 + 632), "height");
        v116[0] = v89;
        v116[1] = v90;
        v116[2] = 1;
        objc_msgSend(v71, "copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:", v88, 0, 0, v117, v116, v68, v98, v103, (_QWORD)objc_msgSend(*(id *)(a3 + 632), "height") * v103);
      }
    }
  }
  else
  {
    v79 = *(void **)(a3 + 640);
    if (v79)
    {
      memset(v123, 0, sizeof(v123));
      v80 = objc_msgSend(v79, "width");
      v81 = objc_msgSend(*(id *)(a3 + 640), "height");
      v122[0] = v80;
      v122[1] = v81;
      v122[2] = 1;
      objc_msgSend(v71, "copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:", v79, 0, 0, v123, v122, v68, v101, v107, (_QWORD)objc_msgSend(*(id *)(a3 + 640), "height") * v107);
    }
    v82 = *(void **)(a3 + 648);
    if (v82)
    {
      memset(v121, 0, sizeof(v121));
      v83 = objc_msgSend(v82, "width");
      v84 = objc_msgSend(*(id *)(a3 + 648), "height");
      v120[0] = v83;
      v120[1] = v84;
      v120[2] = 1;
      objc_msgSend(v71, "copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:", v82, 0, 0, v121, v120, v68, v102, v108, (_QWORD)objc_msgSend(*(id *)(a3 + 648), "height") * (_QWORD)v108);
    }
  }
  objc_msgSend(v71, "endEncoding");
  v189[0] = _NSConcreteStackBlock;
  v189[1] = 3321888768;
  v189[2] = ___ZN33AccelerationStructureViewerServer6Server13receiveSampleEPN27AccelerationStructureViewer7SamplerENS1_6SampleE_block_invoke;
  v189[3] = &unk_7276F8;
  v201 = a1;
  v202 = v63;
  v203 = v37;
  v91 = v68;
  v199 = v91;
  *(_OWORD *)&v215[15] = *(_OWORD *)((char *)v188 + 15);
  v213 = v186;
  v214 = v187;
  *(_OWORD *)v215 = v188[0];
  v209 = v182;
  v210 = v183;
  v211 = v184;
  v212 = v185;
  v207 = v180;
  v208 = v181;
  v216 = v15;
  v217 = v112;
  v218 = v111;
  v219 = v110;
  v220 = v178;
  v221 = v179;
  v222 = v3;
  v223 = v109;
  v224 = v99;
  v225 = v100;
  v226 = v97;
  v227 = v96;
  v228 = v94;
  v232 = v333;
  v231 = v332;
  v230 = v331;
  v229 = v330;
  v236 = v337;
  v235 = v336;
  v234 = v335;
  v233 = v334;
  v240 = v341;
  v239 = v340;
  v238 = v339;
  v237 = v338;
  v244 = v345;
  v243 = v344;
  v242 = v343;
  v241 = v342;
  v249 = v326;
  v250 = v327;
  v251 = v328;
  v252 = v329;
  v245 = v322;
  v246 = v323;
  v247 = v324;
  v248 = v325;
  v253 = v4;
  v254 = v95;
  v261 = v175;
  v262 = v176;
  *(_OWORD *)v263 = v177[0];
  *(_OWORD *)&v263[15] = *(_OWORD *)((char *)v177 + 15);
  v257 = v171;
  v258 = v172;
  v259 = v173;
  v260 = v174;
  v255 = v169;
  v256 = v170;
  v264 = v15;
  v265 = v112;
  v266 = v111;
  v267 = v110;
  v268 = v167;
  v269 = v168;
  v270 = v3;
  v271 = v109;
  v272 = v99;
  v273 = v100;
  v280 = v164;
  v281 = v165;
  *(_OWORD *)v282 = v166[0];
  *(_OWORD *)&v282[15] = *(_OWORD *)((char *)v166 + 15);
  v276 = v160;
  v277 = v161;
  v278 = v162;
  v279 = v163;
  v274 = v158;
  v275 = v159;
  v283 = v15;
  v284 = v112;
  v285 = v111;
  v286 = v110;
  v287 = v156;
  v288 = v157;
  v289 = v3;
  v290 = v109;
  v297 = v153;
  v298 = v154;
  *(_OWORD *)v299 = v155[0];
  *(_OWORD *)&v299[15] = *(_OWORD *)((char *)v155 + 15);
  v293 = v149;
  v294 = v150;
  v295 = v151;
  v296 = v152;
  v291 = v147;
  v292 = v148;
  v300 = v15;
  v301 = v112;
  v302 = v111;
  v303 = v110;
  v304 = v145;
  v305 = v146;
  v306 = v3;
  v313 = v142;
  v314 = v143;
  *(_OWORD *)v315 = v144[0];
  *(_OWORD *)&v315[15] = *(_OWORD *)((char *)v144 + 15);
  v309 = v138;
  v310 = v139;
  v311 = v140;
  v312 = v141;
  v307 = v136;
  v308 = v137;
  v316 = v15;
  v317 = v112;
  v318 = v111;
  v319 = v110;
  v320 = v134;
  v321 = v135;
  AccelerationStructureViewer::Sample::Sample(v190, a3);
  v204 = v105;
  v205 = v115;
  v206 = v113;
  v200 = &v128;
  objc_msgSend(v70, "addCompletedHandler:", v189);
  objc_msgSend(v70, "commit");

  v92 = v192;
  if (v192 == v191)
  {
    v93 = 4;
    v92 = v191;
  }
  else
  {
    if (!v192)
      goto LABEL_86;
    v93 = 5;
  }
  (*(void (**)(void))(*v92 + 8 * v93))();
LABEL_86:

LABEL_87:
  _Block_object_dispose(&v128, 8);

}

void AccelerationStructureViewerServer::Server::receiveQueryRays(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  char *v11;
  uint64_t v12;
  char *v13;
  char *v14;
  int v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  int v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  size_t v34;
  void *v35;
  _DWORD __dst[65];
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;

  if (*(_QWORD *)(a1 + 40) >= 0xBuLL && *(_QWORD *)(a1 + 24))
  {
    v34 = 400 * a6 + 17;
    v11 = (char *)malloc_type_malloc(v34, 0xA5CE70ADuLL);
    *v11 = 17;
    *(_DWORD *)(v11 + 1) = a3 == 1;
    *(_QWORD *)(v11 + 5) = a4;
    v35 = v11;
    *(_DWORD *)(v11 + 13) = a6;
    if (a6)
    {
      v12 = 0;
      v13 = v11;
      do
      {
        v14 = v13 + 405;
        v15 = *(_DWORD *)(a5 + v12 + 8);
        memcpy(__dst, (const void *)(a5 + v12 + 12), sizeof(__dst));
        v16 = *(_OWORD *)(a5 + v12 + 352);
        v41 = *(_OWORD *)(a5 + v12 + 336);
        v42 = v16;
        v17 = *(_OWORD *)(a5 + v12 + 384);
        v43 = *(_OWORD *)(a5 + v12 + 368);
        v44 = v17;
        v18 = *(_OWORD *)(a5 + v12 + 288);
        v37 = *(_OWORD *)(a5 + v12 + 272);
        v38 = v18;
        v19 = *(_OWORD *)(a5 + v12 + 320);
        v39 = *(_OWORD *)(a5 + v12 + 304);
        v40 = v19;
        v20 = *(_DWORD *)(a5 + v12 + 408);
        v21 = *(_QWORD *)(a5 + v12 + 400);
        *(_DWORD *)(v13 + 17) = v15;
        v22 = *(_OWORD *)&__dst[53];
        *(_OWORD *)(v13 + 213) = *(_OWORD *)&__dst[49];
        *(_OWORD *)(v13 + 229) = v22;
        v23 = *(_OWORD *)&__dst[61];
        *(_OWORD *)(v13 + 245) = *(_OWORD *)&__dst[57];
        *(_OWORD *)(v13 + 261) = v23;
        v24 = *(_OWORD *)&__dst[37];
        *(_OWORD *)(v13 + 149) = *(_OWORD *)&__dst[33];
        *(_OWORD *)(v13 + 165) = v24;
        v25 = *(_OWORD *)&__dst[45];
        *(_OWORD *)(v13 + 181) = *(_OWORD *)&__dst[41];
        *(_OWORD *)(v13 + 197) = v25;
        v26 = *(_OWORD *)&__dst[21];
        *(_OWORD *)(v13 + 85) = *(_OWORD *)&__dst[17];
        *(_OWORD *)(v13 + 101) = v26;
        v27 = *(_OWORD *)&__dst[29];
        *(_OWORD *)(v13 + 117) = *(_OWORD *)&__dst[25];
        *(_OWORD *)(v13 + 133) = v27;
        v28 = *(_OWORD *)&__dst[5];
        *(_OWORD *)(v13 + 21) = *(_OWORD *)&__dst[1];
        *(_OWORD *)(v13 + 37) = v28;
        v29 = *(_OWORD *)&__dst[13];
        *(_OWORD *)(v13 + 53) = *(_OWORD *)&__dst[9];
        *(_OWORD *)(v13 + 69) = v29;
        v30 = v42;
        *(_OWORD *)(v13 + 341) = v41;
        *(_OWORD *)(v13 + 357) = v30;
        v31 = v44;
        *(_OWORD *)(v13 + 373) = v43;
        *(_OWORD *)(v13 + 389) = v31;
        v32 = v38;
        *(_OWORD *)(v13 + 277) = v37;
        *(_OWORD *)(v13 + 293) = v32;
        v33 = v40;
        *(_OWORD *)(v13 + 309) = v39;
        *(_OWORD *)(v13 + 325) = v33;
        *(_QWORD *)(v13 + 405) = v21;
        v12 += 416;
        v13 += 400;
        *((_DWORD *)v14 + 2) = v20;
      }
      while (416 * a6 != v12);
    }
    (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, void *, size_t))(**(_QWORD **)(a1 + 24) + 32))(*(_QWORD *)(a1 + 24), a1, 0, 0, v35, v34);
    free(v35);
  }
}

void AccelerationStructureViewerServer::Server::receiveGBVH(AccelerationStructureViewerServer::Server *this, uint64_t a2, NSData *a3, NSError *a4)
{
  NSData *v7;
  NSError *v8;
  NSError *v9;
  char *v10;
  char *v11;
  NSData *v12;

  v7 = a3;
  v8 = a4;
  v9 = v8;
  if (*((_QWORD *)this + 5) >= 0xDuLL && *((_QWORD *)this + 3))
  {
    if (v8)
      operator new();
    v10 = (char *)-[NSData length](v7, "length") + 10;
    v11 = (char *)malloc_type_malloc((size_t)v10, 0x2ACE4629uLL);
    *v11 = 20;
    *(_QWORD *)(v11 + 1) = a2;
    v11[9] = 0;
    v12 = objc_retainAutorelease(v7);
    memcpy(v11 + 10, -[NSData bytes](v12, "bytes"), -[NSData length](v12, "length"));
    (*(void (**)(_QWORD, AccelerationStructureViewerServer::Server *, _QWORD, _QWORD, char *, char *))(**((_QWORD **)this + 3) + 32))(*((_QWORD *)this + 3), this, 0, 0, v11, v10);
    free(v11);
  }

}

void AccelerationStructureViewerServer::Server::pause(AccelerationStructureViewerServer::Server *this, Sampler *a2, NSError *a3)
{
  if (*((_QWORD *)this + 5) >= 7uLL)
    AccelerationStructureViewerServer::Server::replyQueryable((uint64_t)this, 11, -1, 0, a3);
}

_QWORD *AccelerationStructureViewerServer::Server::resume(_QWORD *this, Sampler *a2)
{
  _QWORD *v2;
  char v3;

  if (this[5] >= 7uLL)
  {
    v2 = this;
    this = (_QWORD *)this[3];
    if (this)
    {
      v3 = 12;
      return (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD *, _QWORD, _QWORD, char *, uint64_t))(*this + 32))(this, v2, 0, 0, &v3, 1);
    }
  }
  return this;
}

uint64_t AccelerationStructureViewerServer::Server::teardown(AccelerationStructureViewerServer::Server *this, Sampler *a2, NSError *a3)
{
  uint64_t result;

  result = *((_QWORD *)this + 3);
  if (result)
  {
    *((_QWORD *)this + 3) = 0;
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  }
  return result;
}

void `non-virtual thunk to'AccelerationStructureViewerServer::Server::~Server(AccelerationStructureViewerServer::Server *this)
{
  AccelerationStructureViewerServer::Server::~Server((AccelerationStructureViewerServer::Server *)((char *)this - 8));
}

{
  AccelerationStructureViewerServer::Server::~Server((AccelerationStructureViewerServer::Server *)((char *)this - 8));
  operator delete();
}

uint64_t `non-virtual thunk to'AccelerationStructureViewerServer::Server::addSampler(uint64_t this, Sampler *a2)
{
  *(_QWORD *)(this + 24) = a2;
  return this;
}

uint64_t `non-virtual thunk to'AccelerationStructureViewerServer::Server::setSamplerProperties(uint64_t a1)
{
  return AccelerationStructureViewerServer::Server::setSamplerProperties(a1 - 8);
}

void `non-virtual thunk to'AccelerationStructureViewerServer::Server::receiveGBVH(AccelerationStructureViewerServer::Server *this, uint64_t a2, NSData *a3, NSError *a4)
{
  AccelerationStructureViewerServer::Server::receiveGBVH((AccelerationStructureViewerServer::Server *)((char *)this - 8), a2, a3, a4);
}

void `non-virtual thunk to'AccelerationStructureViewerServer::Server::receiveSample(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AccelerationStructureViewerServer::Server::receiveSample(a1 - 8, a2, a3);
}

void `non-virtual thunk to'AccelerationStructureViewerServer::Server::receiveQueryRays(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  AccelerationStructureViewerServer::Server::receiveQueryRays(a1 - 8, a2, a3, a4, a5, a6);
}

uint64_t `non-virtual thunk to'AccelerationStructureViewerServer::Server::setVersion(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  char v4;
  uint64_t v5;

  result = *(_QWORD *)(a1 + 16);
  if (result)
  {
    v4 = 0;
    v5 = a2;
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, char *, uint64_t))(*(_QWORD *)result + 32))(result, a1 - 8, 0, 0, &v4, 9);
  }
  return result;
}

void `non-virtual thunk to'AccelerationStructureViewerServer::Server::pause(AccelerationStructureViewerServer::Server *this, Sampler *a2, NSError *a3)
{
  if (*((_QWORD *)this + 4) >= 7uLL)
    AccelerationStructureViewerServer::Server::replyQueryable((uint64_t)this - 8, 11, -1, 0, a3);
}

_QWORD *`non-virtual thunk to'AccelerationStructureViewerServer::Server::resume(_QWORD *this, Sampler *a2)
{
  _QWORD *v2;
  char v3;

  if (this[4] >= 7uLL)
  {
    v2 = this;
    this = (_QWORD *)this[2];
    if (this)
    {
      v3 = 12;
      return (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD *, _QWORD, _QWORD, char *, uint64_t))(*this + 32))(this, v2 - 1, 0, 0, &v3, 1);
    }
  }
  return this;
}

uint64_t `non-virtual thunk to'AccelerationStructureViewerServer::Server::teardown(AccelerationStructureViewerServer::Server *this, Sampler *a2, NSError *a3)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  if (result)
  {
    *((_QWORD *)this + 2) = 0;
    return (*(uint64_t (**)(uint64_t, char *, NSError *))(*(_QWORD *)result + 40))(result, (char *)this - 8, a3);
  }
  return result;
}

void AccelerationStructureViewerServer::Server::replyQueryable(uint64_t a1, char a2, uint64_t a3, uint64_t *a4, void *a5)
{
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  char v14;
  _QWORD v15[2];
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  char *v21;
  uint64_t v22;
  _QWORD v23[2];
  uint64_t v24;

  v9 = a5;
  v14 = a2;
  if (!a4)
    operator new();
  v10 = *a4;
  v11 = *(_QWORD *)(a1 + 40);
  v23[0] = off_724120;
  v23[1] = v11;
  v24 = 0;
  (*(void (**)(uint64_t *, _QWORD *))(v10 + 16))(a4, v23);
  v12 = v24;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  if (v24 == -9)
  {
    v13 = 0;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)&v20, v24 + 9);
    v13 = v20;
  }
  v15[1] = *(_QWORD *)(a1 + 40);
  v15[0] = off_724168;
  v17 = 0;
  v16 = 0;
  v18 = v13 + 9;
  v19 = v12;
  (*(void (**)(uint64_t *, _QWORD *))(*a4 + 16))(a4, v15);
  if (v17 || v16 != v19)
    operator new();
  *v13 = v14;
  *(_QWORD *)(v13 + 1) = a3;
  (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, char *, uint64_t))(**(_QWORD **)(a1 + 24) + 32))(*(_QWORD *)(a1 + 24), a1, 0, 0, v13, v12 + 9);
  if (v20)
  {
    v21 = v20;
    operator delete(v20);
  }

}

uint64_t __Block_byref_object_copy__8983(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__8984(uint64_t a1)
{

}

void ___ZN33AccelerationStructureViewerServer6Server13receiveSampleEPN27AccelerationStructureViewer7SamplerENS1_6SampleE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  dispatch_queue_global_t global_queue;
  NSObject *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  _QWORD v30[4];
  _QWORD v31[72];
  _BYTE v32[24];
  _BYTE *v33;
  id v34;
  id v35;
  id v36;
  id v37;
  id v38;
  id v39;
  id v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  __int128 v46;
  _BYTE v47[582];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  int v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  char v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  _BYTE v92[28];

  v2 = *(_QWORD *)(a1 + 704);
  global_queue = dispatch_get_global_queue(0, 0);
  v4 = objc_claimAutoreleasedReturnValue(global_queue);
  v30[0] = _NSConcreteStackBlock;
  v30[1] = 3321888768;
  v30[2] = ___ZN33AccelerationStructureViewerServer6Server13receiveSampleEPN27AccelerationStructureViewer7SamplerENS1_6SampleE_block_invoke_2;
  v30[3] = &unk_7276C0;
  v42 = v2;
  v43 = *(_QWORD *)(a1 + 712);
  v44 = *(_QWORD *)(a1 + 720);
  v40 = *(id *)(a1 + 688);
  memcpy(v47, (const void *)(a1 + 752), sizeof(v47));
  v5 = *(_OWORD *)(a1 + 1478);
  v56 = *(_OWORD *)(a1 + 1462);
  v57 = v5;
  v58 = *(_OWORD *)(a1 + 1494);
  v59 = *(_DWORD *)(a1 + 1510);
  v6 = *(_OWORD *)(a1 + 1414);
  v52 = *(_OWORD *)(a1 + 1398);
  v53 = v6;
  v7 = *(_OWORD *)(a1 + 1446);
  v54 = *(_OWORD *)(a1 + 1430);
  v55 = v7;
  v8 = *(_OWORD *)(a1 + 1350);
  v48 = *(_OWORD *)(a1 + 1334);
  v49 = v8;
  v9 = *(_OWORD *)(a1 + 1382);
  v50 = *(_OWORD *)(a1 + 1366);
  v51 = v9;
  v10 = *(_OWORD *)(a1 + 1658);
  v68 = *(_OWORD *)(a1 + 1642);
  v69 = v10;
  v70 = *(_OWORD *)(a1 + 1674);
  v11 = *(_OWORD *)(a1 + 1594);
  v64 = *(_OWORD *)(a1 + 1578);
  v65 = v11;
  v12 = *(_OWORD *)(a1 + 1626);
  v66 = *(_OWORD *)(a1 + 1610);
  v67 = v12;
  v13 = *(_OWORD *)(a1 + 1530);
  v60 = *(_OWORD *)(a1 + 1514);
  v61 = v13;
  v14 = *(_OWORD *)(a1 + 1562);
  v62 = *(_OWORD *)(a1 + 1546);
  v63 = v14;
  v71 = *(_BYTE *)(a1 + 1690);
  v15 = *(_OWORD *)(a1 + 1835);
  v80 = *(_OWORD *)(a1 + 1819);
  v81 = v15;
  v82 = *(_OWORD *)(a1 + 1851);
  v16 = *(_OWORD *)(a1 + 1771);
  v76 = *(_OWORD *)(a1 + 1755);
  v77 = v16;
  v17 = *(_OWORD *)(a1 + 1803);
  v78 = *(_OWORD *)(a1 + 1787);
  v79 = v17;
  v18 = *(_OWORD *)(a1 + 1707);
  v72 = *(_OWORD *)(a1 + 1691);
  v73 = v18;
  v19 = *(_OWORD *)(a1 + 1739);
  v74 = *(_OWORD *)(a1 + 1723);
  v75 = v19;
  v20 = *(_OWORD *)(a1 + 2011);
  v91 = *(_OWORD *)(a1 + 1995);
  *(_OWORD *)v92 = v20;
  *(_OWORD *)&v92[12] = *(_OWORD *)(a1 + 2023);
  v21 = *(_OWORD *)(a1 + 1947);
  v87 = *(_OWORD *)(a1 + 1931);
  v88 = v21;
  v22 = *(_OWORD *)(a1 + 1979);
  v89 = *(_OWORD *)(a1 + 1963);
  v90 = v22;
  v23 = *(_OWORD *)(a1 + 1883);
  v83 = *(_OWORD *)(a1 + 1867);
  v84 = v23;
  v24 = *(_OWORD *)(a1 + 1915);
  v85 = *(_OWORD *)(a1 + 1899);
  v86 = v24;
  AccelerationStructureViewer::Sample::Sample(v31, a1 + 32);
  v45 = *(_QWORD *)(a1 + 728);
  v46 = *(_OWORD *)(a1 + 736);
  v41 = *(_QWORD *)(a1 + 696);
  dispatch_async(v4, v30);

  v28 = v33;
  if (v33 == v32)
  {
    v29 = 4;
    v28 = v32;
    goto LABEL_5;
  }
  if (v33)
  {
    v29 = 5;
LABEL_5:
    (*(void (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v28 + 8 * v29))(v28, v25, v26, v27);
  }

}

intptr_t ___ZN33AccelerationStructureViewerServer6Server13receiveSampleEPN27AccelerationStructureViewer7SamplerENS1_6SampleE_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _OWORD *v5;
  uint64_t v6;
  char *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  void (*v15)(void);
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  size_t v20;
  void *v21;
  size_t v22;
  size_t v23;
  unint64_t v24;
  _OWORD *v25;
  unint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  int v83;
  char v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  uint64_t v91;

  v2 = *(_QWORD *)(a1 + 704);
  v3 = *(_QWORD *)(v2 + 40);
  if (v3 >= 3)
  {
    v4 = *(_QWORD *)(a1 + 712);
    v5 = *(_OWORD **)(v2 + 8 * v4 + 152);
    if (v3 <= 0xA)
    {
      v16 = 177;
      v17 = 172;
      if (v3 > 4)
        v17 = 176;
      if (v3 <= 7)
        v16 = v17;
      if (v3 == 10)
        v6 = 180;
      else
        v6 = v16;
    }
    else
    {
      v6 = 582;
    }
    v18 = *(_QWORD *)(a1 + 720);
    if (!v5 || *(_QWORD *)(v2 + 8 * v4 + 216) < v18)
    {
      v5 = malloc_type_malloc(*(_QWORD *)(a1 + 720), 0xA6CF1B3FuLL);
      v19 = v2 + 8 * *(_QWORD *)(a1 + 712);
      *(_QWORD *)(v19 + 152) = v5;
      *(_QWORD *)(v19 + 216) = *(_QWORD *)(a1 + 720);
      v4 = *(_QWORD *)(a1 + 712);
    }
    v20 = v18 - v6;
    v21 = *(void **)(v2 + 8 * v4 + 184);
    if (!v21)
    {
      v22 = compression_encode_scratch_buffer_size((compression_algorithm)*(_DWORD *)(v2 + 72));
      v21 = malloc_type_malloc(v22, 0x5BF8808CuLL);
      *(_QWORD *)(v2 + 8 * *(_QWORD *)(a1 + 712) + 184) = v21;
    }
    v23 = compression_encode_buffer((uint8_t *)v5 + v6, *(_QWORD *)(a1 + 720) - v6, (const uint8_t *)objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 688)), "contents") + v6, v20, v21, (compression_algorithm)*(_DWORD *)(v2 + 72));
    if (*(_DWORD *)(v2 + 72) && v23)
    {
      v24 = *(_QWORD *)(v2 + 40);
      if (v24 >= 0xB)
      {
        memcpy(v5, (const void *)(a1 + 752), 0x246uLL);
        goto LABEL_43;
      }
      if (v24 == 10)
      {
        v36 = *(_OWORD *)(a1 + 1334);
        v37 = *(_OWORD *)(a1 + 1350);
        v38 = *(_OWORD *)(a1 + 1382);
        v5[2] = *(_OWORD *)(a1 + 1366);
        v5[3] = v38;
        *v5 = v36;
        v5[1] = v37;
        v39 = *(_OWORD *)(a1 + 1398);
        v40 = *(_OWORD *)(a1 + 1414);
        v41 = *(_OWORD *)(a1 + 1446);
        v5[6] = *(_OWORD *)(a1 + 1430);
        v5[7] = v41;
        v5[4] = v39;
        v5[5] = v40;
        v42 = *(_OWORD *)(a1 + 1462);
        v43 = *(_OWORD *)(a1 + 1478);
        v44 = *(_OWORD *)(a1 + 1494);
        *((_DWORD *)v5 + 44) = *(_DWORD *)(a1 + 1510);
      }
      else
      {
        if (v24 < 8)
        {
          if (v24 < 5)
          {
            v78 = *(_OWORD *)(a1 + 1867);
            v79 = *(_OWORD *)(a1 + 1899);
            v5[1] = *(_OWORD *)(a1 + 1883);
            v5[2] = v79;
            *v5 = v78;
            v80 = *(_OWORD *)(a1 + 1915);
            v81 = *(_OWORD *)(a1 + 1931);
            v82 = *(_OWORD *)(a1 + 1963);
            v5[5] = *(_OWORD *)(a1 + 1947);
            v5[6] = v82;
            v5[3] = v80;
            v5[4] = v81;
            v70 = *(_OWORD *)(a1 + 1979);
            v71 = *(_OWORD *)(a1 + 1995);
            v72 = *(_OWORD *)(a1 + 2011);
            *(_OWORD *)((char *)v5 + 156) = *(_OWORD *)(a1 + 2023);
          }
          else
          {
            v65 = *(_OWORD *)(a1 + 1691);
            v66 = *(_OWORD *)(a1 + 1723);
            v5[1] = *(_OWORD *)(a1 + 1707);
            v5[2] = v66;
            *v5 = v65;
            v67 = *(_OWORD *)(a1 + 1739);
            v68 = *(_OWORD *)(a1 + 1755);
            v69 = *(_OWORD *)(a1 + 1787);
            v5[5] = *(_OWORD *)(a1 + 1771);
            v5[6] = v69;
            v5[3] = v67;
            v5[4] = v68;
            v70 = *(_OWORD *)(a1 + 1803);
            v71 = *(_OWORD *)(a1 + 1819);
            v72 = *(_OWORD *)(a1 + 1835);
            v5[10] = *(_OWORD *)(a1 + 1851);
          }
          v5[8] = v71;
          v5[9] = v72;
          v5[7] = v70;
LABEL_43:
          v83 = *(_DWORD *)(v2 + 72);
          if (v83 > 2048)
          {
            if (v83 == 2818)
            {
              v84 = 5;
              goto LABEL_52;
            }
            if (v83 == 2049)
            {
              v84 = 3;
              goto LABEL_52;
            }
          }
          else
          {
            if (v83 == 256)
            {
              v84 = 2;
              goto LABEL_52;
            }
            if (v83 == 774)
            {
              v84 = 4;
LABEL_52:
              *((_BYTE *)v5 + 163) = v84;
            }
          }
          *(_QWORD *)((char *)v5 + 164) = v20;
LABEL_54:
          *(_BYTE *)v5 = 1;
          *(_QWORD *)((char *)v5 + 1) = *(_QWORD *)(a1 + 40);
          *((_BYTE *)v5 + 157) = *(_BYTE *)(a1 + 464);
          *((_BYTE *)v5 + 158) = *(_BYTE *)(a1 + 466);
          *(_DWORD *)((char *)v5 + 9) = *(_DWORD *)(a1 + 468);
          *(_DWORD *)((char *)v5 + 141) = objc_msgSend(*(id *)(a1 + 640), "width");
          *(_DWORD *)((char *)v5 + 145) = objc_msgSend(*(id *)(a1 + 640), "height");
          *(_DWORD *)((char *)v5 + 149) = *(_DWORD *)(a1 + 472);
          *(_DWORD *)((char *)v5 + 153) = *(_DWORD *)(a1 + 476);
          v85 = *(_OWORD *)(a1 + 496);
          v86 = *(_OWORD *)(a1 + 512);
          v87 = *(_OWORD *)(a1 + 528);
          *(_OWORD *)((char *)v5 + 13) = *(_OWORD *)(a1 + 480);
          *(_OWORD *)((char *)v5 + 29) = v85;
          *(_OWORD *)((char *)v5 + 45) = v86;
          *(_OWORD *)((char *)v5 + 61) = v87;
          v88 = *(_OWORD *)(a1 + 560);
          v89 = *(_OWORD *)(a1 + 576);
          v90 = *(_OWORD *)(a1 + 592);
          *(_OWORD *)((char *)v5 + 77) = *(_OWORD *)(a1 + 544);
          *(_OWORD *)((char *)v5 + 93) = v88;
          *(_OWORD *)((char *)v5 + 109) = v89;
          *(_OWORD *)((char *)v5 + 125) = v90;
          v91 = *(_QWORD *)(v2 + 24);
          if (v91)
          {
            v15 = *(void (**)(void))(*(_QWORD *)v91 + 32);
            goto LABEL_56;
          }
          goto LABEL_57;
        }
        v51 = *(_OWORD *)(a1 + 1514);
        v52 = *(_OWORD *)(a1 + 1530);
        v53 = *(_OWORD *)(a1 + 1562);
        v5[2] = *(_OWORD *)(a1 + 1546);
        v5[3] = v53;
        *v5 = v51;
        v5[1] = v52;
        v54 = *(_OWORD *)(a1 + 1578);
        v55 = *(_OWORD *)(a1 + 1594);
        v56 = *(_OWORD *)(a1 + 1626);
        v5[6] = *(_OWORD *)(a1 + 1610);
        v5[7] = v56;
        v5[4] = v54;
        v5[5] = v55;
        v42 = *(_OWORD *)(a1 + 1642);
        v43 = *(_OWORD *)(a1 + 1658);
        v44 = *(_OWORD *)(a1 + 1674);
        *((_BYTE *)v5 + 176) = *(_BYTE *)(a1 + 1690);
      }
      v5[9] = v43;
      v5[10] = v44;
      v5[8] = v42;
      goto LABEL_43;
    }
    v25 = objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 688)), "contents");
    v5 = v25;
    v26 = *(_QWORD *)(v2 + 40);
    if (v26 < 0xB)
    {
      if (v26 == 10)
      {
        v27 = *(_OWORD *)(a1 + 1334);
        v28 = *(_OWORD *)(a1 + 1350);
        v29 = *(_OWORD *)(a1 + 1382);
        v25[2] = *(_OWORD *)(a1 + 1366);
        v25[3] = v29;
        *v25 = v27;
        v25[1] = v28;
        v30 = *(_OWORD *)(a1 + 1398);
        v31 = *(_OWORD *)(a1 + 1414);
        v32 = *(_OWORD *)(a1 + 1446);
        v25[6] = *(_OWORD *)(a1 + 1430);
        v25[7] = v32;
        v25[4] = v30;
        v25[5] = v31;
        v33 = *(_OWORD *)(a1 + 1462);
        v34 = *(_OWORD *)(a1 + 1478);
        v35 = *(_OWORD *)(a1 + 1494);
        *((_DWORD *)v25 + 44) = *(_DWORD *)(a1 + 1510);
      }
      else
      {
        if (v26 < 8)
        {
          if (v26 < 5)
          {
            v73 = *(_OWORD *)(a1 + 1867);
            v74 = *(_OWORD *)(a1 + 1899);
            v25[1] = *(_OWORD *)(a1 + 1883);
            v25[2] = v74;
            *v25 = v73;
            v75 = *(_OWORD *)(a1 + 1915);
            v76 = *(_OWORD *)(a1 + 1931);
            v77 = *(_OWORD *)(a1 + 1963);
            v25[5] = *(_OWORD *)(a1 + 1947);
            v25[6] = v77;
            v25[3] = v75;
            v25[4] = v76;
            v62 = *(_OWORD *)(a1 + 1979);
            v63 = *(_OWORD *)(a1 + 1995);
            v64 = *(_OWORD *)(a1 + 2011);
            *(_OWORD *)((char *)v25 + 156) = *(_OWORD *)(a1 + 2023);
          }
          else
          {
            v57 = *(_OWORD *)(a1 + 1691);
            v58 = *(_OWORD *)(a1 + 1723);
            v25[1] = *(_OWORD *)(a1 + 1707);
            v25[2] = v58;
            *v25 = v57;
            v59 = *(_OWORD *)(a1 + 1739);
            v60 = *(_OWORD *)(a1 + 1755);
            v61 = *(_OWORD *)(a1 + 1787);
            v25[5] = *(_OWORD *)(a1 + 1771);
            v25[6] = v61;
            v25[3] = v59;
            v25[4] = v60;
            v62 = *(_OWORD *)(a1 + 1803);
            v63 = *(_OWORD *)(a1 + 1819);
            v64 = *(_OWORD *)(a1 + 1835);
            v25[10] = *(_OWORD *)(a1 + 1851);
          }
          v25[8] = v63;
          v25[9] = v64;
          v25[7] = v62;
          goto LABEL_40;
        }
        v45 = *(_OWORD *)(a1 + 1514);
        v46 = *(_OWORD *)(a1 + 1530);
        v47 = *(_OWORD *)(a1 + 1562);
        v25[2] = *(_OWORD *)(a1 + 1546);
        v25[3] = v47;
        *v25 = v45;
        v25[1] = v46;
        v48 = *(_OWORD *)(a1 + 1578);
        v49 = *(_OWORD *)(a1 + 1594);
        v50 = *(_OWORD *)(a1 + 1626);
        v25[6] = *(_OWORD *)(a1 + 1610);
        v25[7] = v50;
        v25[4] = v48;
        v25[5] = v49;
        v33 = *(_OWORD *)(a1 + 1642);
        v34 = *(_OWORD *)(a1 + 1658);
        v35 = *(_OWORD *)(a1 + 1674);
        *((_BYTE *)v25 + 176) = *(_BYTE *)(a1 + 1690);
      }
      v25[9] = v34;
      v25[10] = v35;
      v25[8] = v33;
    }
    else
    {
      memcpy(v25, (const void *)(a1 + 752), 0x246uLL);
    }
LABEL_40:
    *((_BYTE *)v5 + 163) = 1;
    *(_QWORD *)((char *)v5 + 164) = v20;
    goto LABEL_54;
  }
  v7 = (char *)objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 688)), "contents");
  *v7 = 1;
  *(_QWORD *)(v7 + 1) = *(_QWORD *)(a1 + 40);
  v7[157] = *(_BYTE *)(a1 + 464);
  v7[158] = *(_BYTE *)(a1 + 466);
  *(_DWORD *)(v7 + 9) = *(_DWORD *)(a1 + 468);
  *(_DWORD *)(v7 + 141) = objc_msgSend(*(id *)(a1 + 640), "width");
  *(_DWORD *)(v7 + 145) = objc_msgSend(*(id *)(a1 + 640), "height");
  *(_DWORD *)(v7 + 149) = *(_DWORD *)(a1 + 472);
  *(_DWORD *)(v7 + 153) = *(_DWORD *)(a1 + 476);
  v8 = *(_OWORD *)(a1 + 496);
  v9 = *(_OWORD *)(a1 + 512);
  v10 = *(_OWORD *)(a1 + 528);
  *(_OWORD *)(v7 + 13) = *(_OWORD *)(a1 + 480);
  *(_OWORD *)(v7 + 29) = v8;
  *(_OWORD *)(v7 + 45) = v9;
  *(_OWORD *)(v7 + 61) = v10;
  v11 = *(_OWORD *)(a1 + 560);
  v12 = *(_OWORD *)(a1 + 576);
  v13 = *(_OWORD *)(a1 + 592);
  *(_OWORD *)(v7 + 77) = *(_OWORD *)(a1 + 544);
  *(_OWORD *)(v7 + 93) = v11;
  *(_OWORD *)(v7 + 109) = v12;
  *(_OWORD *)(v7 + 125) = v13;
  *(int64x2_t *)(v7 + 159) = vaddq_s64(*(int64x2_t *)(a1 + 728), vdupq_n_s64(0xFFFFFFFFFFFFFF49));
  *(_QWORD *)(v7 + 175) = *(_QWORD *)(a1 + 744) - 183;
  v14 = *(_QWORD *)(v2 + 24);
  if (v14)
  {
    v15 = *(void (**)(void))(*(_QWORD *)v14 + 32);
LABEL_56:
    v15();
  }
LABEL_57:
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v2 + 8 * *(_QWORD *)(a1 + 712) + 88));
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 696) + 8) + 40));
}

id *std::vector<AccelerationStructureViewer::FilterToken>::__assign_with_size[abi:nn180100]<AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*>(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void (***v12)(_QWORD);
  void (***v13)(_QWORD);
  void (**v14)(_QWORD);
  BOOL v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  id *result;
  id *v23;
  id *v24;
  id *v25;
  id *v26;
  uint64_t (**v27)(id *);

  v8 = a1[2];
  v9 = *a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *a1) >> 3) < a4)
  {
    if (v9)
    {
      v10 = a1[1];
      v11 = (void *)*a1;
      if (v10 != v9)
      {
        v12 = (void (***)(_QWORD))(v10 - 24);
        v13 = (void (***)(_QWORD))(v10 - 24);
        do
        {
          v14 = *v13;
          v13 -= 3;
          (*v14)(v12);
          v15 = v12 == (void (***)(_QWORD))v9;
          v12 = v13;
        }
        while (!v15);
        v11 = (void *)*a1;
      }
      a1[1] = v9;
      operator delete(v11);
      v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0xAAAAAAAAAAAAAAALL)
      abort();
    v16 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    v17 = 2 * v16;
    if (2 * v16 <= a4)
      v17 = a4;
    if (v16 >= 0x555555555555555)
      v18 = 0xAAAAAAAAAAAAAAALL;
    else
      v18 = v17;
    std::vector<AccelerationStructureViewer::FilterToken>::__vallocate[abi:nn180100](a1, v18);
    v19 = a1;
    v20 = a2;
    return (id *)std::vector<AccelerationStructureViewer::FilterToken>::__construct_at_end<AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*>(v19, v20, a3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - v9) >> 3) < a4)
  {
    v21 = a2 + 8 * ((a1[1] - v9) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<AccelerationStructureViewer::FilterToken *,AccelerationStructureViewer::FilterToken *,AccelerationStructureViewer::FilterToken *>(a2, v21, v9);
    v19 = a1;
    v20 = v21;
    return (id *)std::vector<AccelerationStructureViewer::FilterToken>::__construct_at_end<AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*>(v19, v20, a3);
  }
  result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<AccelerationStructureViewer::FilterToken *,AccelerationStructureViewer::FilterToken *,AccelerationStructureViewer::FilterToken *>(a2, a3, v9);
  v23 = result;
  v24 = (id *)a1[1];
  if (v24 != result)
  {
    v25 = v24 - 3;
    v26 = v24 - 3;
    do
    {
      v27 = (uint64_t (**)(id *))*v26;
      v26 -= 3;
      result = (id *)(*v27)(v25);
      v15 = v25 == v23;
      v25 = v26;
    }
    while (!v15);
  }
  a1[1] = (uint64_t)v23;
  return result;
}

void ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke(uint64_t a1, uint64_t *a2, void *a3)
{
  AccelerationStructureViewerServer::Server::replyQueryable(*(_QWORD *)(a1 + 32), 8, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8), a2, a3);
}

void ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke_2(uint64_t a1, uint64_t *a2, void *a3)
{
  id v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  void (**v18)(AccelerationStructureViewer::DataSourceArray *__hidden);
  __int128 v19;
  __int128 v20;
  __int128 v21;

  v5 = a3;
  v6 = *(_QWORD *)(a1 + 32);
  v18 = off_7241B0;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v7 = *a2;
  if (*a2 != a2[1])
  {
    v8 = 0;
    do
    {
      if ((unint64_t)v8 >= (unint64_t)v20)
      {
        v10 = (_QWORD *)v19;
        v11 = (uint64_t)((uint64_t)v8 - v19) >> 3;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61)
          abort();
        v13 = v20 - v19;
        if ((uint64_t)(v20 - v19) >> 2 > v12)
          v12 = v13 >> 2;
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
          v14 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v14 = v12;
        if (v14)
          v14 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v14);
        else
          v15 = 0;
        v16 = (_QWORD *)(v14 + 8 * v11);
        *v16 = v7;
        v9 = v16 + 1;
        if (v8 != v10)
        {
          do
          {
            v17 = *--v8;
            *--v16 = v17;
          }
          while (v8 != v10);
          v8 = (_QWORD *)v19;
        }
        *(_QWORD *)&v19 = v16;
        *(_QWORD *)&v20 = v14 + 8 * v15;
        if (v8)
          operator delete(v8);
      }
      else
      {
        *v8 = v7;
        v9 = v8 + 1;
      }
      *((_QWORD *)&v19 + 1) = v9;
      v7 += 32;
      v8 = v9;
    }
    while (v7 != a2[1]);
  }
  AccelerationStructureViewerServer::Server::replyQueryable(v6, 8, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8), (uint64_t *)&v18, v5);
  AccelerationStructureViewer::DataSourceArray::~DataSourceArray((AccelerationStructureViewer::DataSourceArray *)&v18);

}

void ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke_3(uint64_t a1, uint64_t *a2, void *a3)
{
  id v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  _QWORD v20[6];
  void (**v21)(AccelerationStructureViewer::Filter *__hidden);
  char v22;
  char *v23;
  char *v24;
  char *v25;
  char **v26;

  v5 = a3;
  v6 = *(_QWORD *)(a1 + 32);
  if (v5)
  {
    AccelerationStructureViewerServer::Server::replyQueryable(*(_QWORD *)(a1 + 32), 8, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8), 0, v5);
  }
  else
  {
    v7 = *a2;
    v8 = *(_QWORD *)(a1 + 40);
    v9 = *(_QWORD *)(v8 + 16);
    while (1)
    {
      if (v7 == a2[1])
      {
        v10 = *(_QWORD *)(v8 + 8);
        v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("id<MTLIntersectionFunctionTable> 0x%llx does not exist"), v9));
        v12 = (void *)objc_claimAutoreleasedReturnValue(+[ASVError errorWithCode:localizedDescription:](ASVError, "errorWithCode:localizedDescription:", 6, v11));
        AccelerationStructureViewerServer::Server::replyQueryable(v6, 8, v10, 0, v12);

        goto LABEL_12;
      }
      if (*(_QWORD *)(v7 + 16) == v9)
        break;
      v7 += 32;
    }
    v13 = *(_QWORD *)(a1 + 48);
    v14 = *(_QWORD *)(a1 + 56);
    v15 = *(_QWORD *)(a1 + 64);
    v21 = off_727800;
    v22 = *(_BYTE *)(a1 + 80);
    v24 = 0;
    v25 = 0;
    v23 = 0;
    v16 = *(_QWORD *)(a1 + 88);
    v17 = *(_QWORD *)(a1 + 96);
    if (v17 != v16)
    {
      v18 = 0xAAAAAAAAAAAAAAABLL * ((v17 - v16) >> 3);
      if (v18 >= 0xAAAAAAAAAAAAAABLL)
        abort();
      v23 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v18);
      v24 = v23;
      v25 = &v23[24 * v19];
      std::vector<AccelerationStructureViewer::FilterToken>::__construct_at_end<AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*>(&v23, v16, v17);
      v8 = *(_QWORD *)(a1 + 40);
    }
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472;
    v20[2] = ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke_4;
    v20[3] = &__block_descriptor_48_e21_v24__0_v8__NSError_16l;
    v20[4] = v6;
    v20[5] = v8;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void (***)(AccelerationStructureViewer::Filter *__hidden), _QWORD *))(*(_QWORD *)v13 + 24))(v13, v7, v14, v15, &v21, v20);
    v21 = off_727800;
    v26 = &v23;
    std::vector<AccelerationStructureViewer::FilterToken>::__destroy_vector::operator()[abi:nn180100]((void ***)&v26);
  }
LABEL_12:

}

void ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke_23(uint64_t a1, uint64_t **a2, void *a3)
{
  id v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void (**v19)(AccelerationStructureViewer::DataSourceArray *__hidden);
  __int128 v20;
  __int128 v21;
  __int128 v22;

  v5 = a3;
  v18 = *(_QWORD *)(a1 + 32);
  v19 = off_7241B0;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v6 = *a2;
  if (*a2 != a2[1])
  {
    v7 = 0;
    do
    {
      v8 = *v6;
      if ((unint64_t)v7 >= (unint64_t)v21)
      {
        v10 = (_QWORD *)v20;
        v11 = (uint64_t)((uint64_t)v7 - v20) >> 3;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61)
          abort();
        v13 = v21 - v20;
        if ((uint64_t)(v21 - v20) >> 2 > v12)
          v12 = v13 >> 2;
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
          v14 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v14 = v12;
        if (v14)
          v14 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v14);
        else
          v15 = 0;
        v16 = (_QWORD *)(v14 + 8 * v11);
        *v16 = v8;
        v9 = v16 + 1;
        if (v7 != v10)
        {
          do
          {
            v17 = *--v7;
            *--v16 = v17;
          }
          while (v7 != v10);
          v7 = (_QWORD *)v20;
        }
        *(_QWORD *)&v20 = v16;
        *(_QWORD *)&v21 = v14 + 8 * v15;
        if (v7)
          operator delete(v7);
      }
      else
      {
        *v7 = v8;
        v9 = v7 + 1;
      }
      *((_QWORD *)&v20 + 1) = v9;
      ++v6;
      v7 = v9;
    }
    while (v6 != a2[1]);
  }
  AccelerationStructureViewerServer::Server::replyQueryable(v18, 8, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8), (uint64_t *)&v19, v5);
  AccelerationStructureViewer::DataSourceArray::~DataSourceArray((AccelerationStructureViewer::DataSourceArray *)&v19);

}

void ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke_2_24(uint64_t a1, uint64_t **a2, void *a3)
{
  id v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void (**v19)(AccelerationStructureViewer::DataSourceArray *__hidden);
  __int128 v20;
  __int128 v21;
  __int128 v22;

  v5 = a3;
  v18 = *(_QWORD *)(a1 + 32);
  v19 = off_7241B0;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v6 = *a2;
  if (*a2 != a2[1])
  {
    v7 = 0;
    do
    {
      v8 = *v6;
      if ((unint64_t)v7 >= (unint64_t)v21)
      {
        v10 = (_QWORD *)v20;
        v11 = (uint64_t)((uint64_t)v7 - v20) >> 3;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61)
          abort();
        v13 = v21 - v20;
        if ((uint64_t)(v21 - v20) >> 2 > v12)
          v12 = v13 >> 2;
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
          v14 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v14 = v12;
        if (v14)
          v14 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v14);
        else
          v15 = 0;
        v16 = (_QWORD *)(v14 + 8 * v11);
        *v16 = v8;
        v9 = v16 + 1;
        if (v7 != v10)
        {
          do
          {
            v17 = *--v7;
            *--v16 = v17;
          }
          while (v7 != v10);
          v7 = (_QWORD *)v20;
        }
        *(_QWORD *)&v20 = v16;
        *(_QWORD *)&v21 = v14 + 8 * v15;
        if (v7)
          operator delete(v7);
      }
      else
      {
        *v7 = v8;
        v9 = v7 + 1;
      }
      *((_QWORD *)&v20 + 1) = v9;
      ++v6;
      v7 = v9;
    }
    while (v6 != a2[1]);
  }
  AccelerationStructureViewerServer::Server::replyQueryable(v18, 8, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8), (uint64_t *)&v19, v5);
  AccelerationStructureViewer::DataSourceArray::~DataSourceArray((AccelerationStructureViewer::DataSourceArray *)&v19);

}

void ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke_3_25(uint64_t a1, uint64_t **a2, void *a3)
{
  id v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void (**v19)(AccelerationStructureViewer::DataSourceArray *__hidden);
  __int128 v20;
  __int128 v21;
  __int128 v22;

  v5 = a3;
  v18 = *(_QWORD *)(a1 + 32);
  v19 = off_7241B0;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v6 = *a2;
  if (*a2 != a2[1])
  {
    v7 = 0;
    do
    {
      v8 = *v6;
      if ((unint64_t)v7 >= (unint64_t)v21)
      {
        v10 = (_QWORD *)v20;
        v11 = (uint64_t)((uint64_t)v7 - v20) >> 3;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61)
          abort();
        v13 = v21 - v20;
        if ((uint64_t)(v21 - v20) >> 2 > v12)
          v12 = v13 >> 2;
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
          v14 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v14 = v12;
        if (v14)
          v14 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v14);
        else
          v15 = 0;
        v16 = (_QWORD *)(v14 + 8 * v11);
        *v16 = v8;
        v9 = v16 + 1;
        if (v7 != v10)
        {
          do
          {
            v17 = *--v7;
            *--v16 = v17;
          }
          while (v7 != v10);
          v7 = (_QWORD *)v20;
        }
        *(_QWORD *)&v20 = v16;
        *(_QWORD *)&v21 = v14 + 8 * v15;
        if (v7)
          operator delete(v7);
      }
      else
      {
        *v7 = v8;
        v9 = v7 + 1;
      }
      *((_QWORD *)&v20 + 1) = v9;
      ++v6;
      v7 = v9;
    }
    while (v6 != a2[1]);
  }
  AccelerationStructureViewerServer::Server::replyQueryable(v18, 8, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8), (uint64_t *)&v19, v5);
  AccelerationStructureViewer::DataSourceArray::~DataSourceArray((AccelerationStructureViewer::DataSourceArray *)&v19);

}

void ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke_4_26(uint64_t a1, void *a2)
{
  uint64_t v2;
  uint64_t v3;
  id v4;
  id v5;
  char *v6;
  id v7;
  uint64_t v8;
  id v9;
  unint64_t v10[3];

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  memset(v10, 0, sizeof(v10));
  v4 = a2;
  v5 = objc_msgSend(v4, "length");
  if (v5 == (id)-9)
  {
    v6 = 0;
  }
  else
  {
    std::vector<unsigned char>::__append(v10, (size_t)v5 + 9);
    v6 = (char *)v10[0];
  }
  v7 = objc_retainAutorelease(v4);
  memcpy(v6 + 9, objc_msgSend(v7, "bytes"), (size_t)objc_msgSend(v7, "length"));
  *v6 = 8;
  *(_QWORD *)(v6 + 1) = v3;
  v8 = *(_QWORD *)(v2 + 24);
  v9 = objc_msgSend(v7, "length");

  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, char *, uint64_t))(*(_QWORD *)v8 + 32))(v8, v2, 0, 0, v6, (uint64_t)v9 + 9);
  operator delete(v6);
}

void ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke_5(uint64_t a1, uint64_t **a2, void *a3)
{
  id v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void (**v19)(AccelerationStructureViewer::DataSourceArray *__hidden);
  __int128 v20;
  __int128 v21;
  __int128 v22;

  v5 = a3;
  v18 = *(_QWORD *)(a1 + 32);
  v19 = off_7241B0;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v6 = *a2;
  if (*a2 != a2[1])
  {
    v7 = 0;
    do
    {
      v8 = *v6;
      if ((unint64_t)v7 >= (unint64_t)v21)
      {
        v10 = (_QWORD *)v20;
        v11 = (uint64_t)((uint64_t)v7 - v20) >> 3;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61)
          abort();
        v13 = v21 - v20;
        if ((uint64_t)(v21 - v20) >> 2 > v12)
          v12 = v13 >> 2;
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
          v14 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v14 = v12;
        if (v14)
          v14 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v14);
        else
          v15 = 0;
        v16 = (_QWORD *)(v14 + 8 * v11);
        *v16 = v8;
        v9 = v16 + 1;
        if (v7 != v10)
        {
          do
          {
            v17 = *--v7;
            *--v16 = v17;
          }
          while (v7 != v10);
          v7 = (_QWORD *)v20;
        }
        *(_QWORD *)&v20 = v16;
        *(_QWORD *)&v21 = v14 + 8 * v15;
        if (v7)
          operator delete(v7);
      }
      else
      {
        *v7 = v8;
        v9 = v7 + 1;
      }
      *((_QWORD *)&v20 + 1) = v9;
      ++v6;
      v7 = v9;
    }
    while (v6 != a2[1]);
  }
  AccelerationStructureViewerServer::Server::replyQueryable(v18, 8, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8), (uint64_t *)&v19, v5);
  AccelerationStructureViewer::DataSourceArray::~DataSourceArray((AccelerationStructureViewer::DataSourceArray *)&v19);

}

uint64_t std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  const std::locale::facet *v9;
  uint64_t v10;
  BOOL v11;
  size_t v12;
  size_t v13;
  std::locale::__imp *p_b;
  uint64_t v15;
  uint64_t v16;
  std::locale *v17;
  uint64_t v18;
  _BYTE v20[16];
  std::locale __b;
  size_t v22;
  int64_t v23;

  std::ostream::sentry::sentry(v20, &std::cout);
  if (v20[0])
  {
    v4 = (char *)&std::cout + (unint64_t)std::cout.__vftable[-2].~basic_ostream_0;
    v5 = *((_QWORD *)v4 + 5);
    v6 = a1 + a2;
    if ((*((_DWORD *)v4 + 2) & 0xB0) == 0x20)
      v7 = a1 + a2;
    else
      v7 = a1;
    v8 = *((_DWORD *)v4 + 36);
    if (v8 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)&std::cout
                                                  + (unint64_t)std::cout.__vftable[-2].~basic_ostream_0));
      v9 = std::locale::use_facet(&__b, &std::ctype<char>::id);
      v8 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 32);
      std::locale::~locale(&__b);
      *((_DWORD *)v4 + 36) = v8;
      if (!v5)
      {
LABEL_30:
        std::ios_base::clear((std::ios_base *)((char *)&std::cout + (unint64_t)std::cout.__vftable[-2].~basic_ostream_0), *(_DWORD *)((char *)&std::cout + (unint64_t)std::cout.__vftable[-2].~basic_ostream_0 + 32) | 5);
        return std::ostream::sentry::~sentry(v20);
      }
    }
    else if (!v5)
    {
      goto LABEL_30;
    }
    v10 = *((_QWORD *)v4 + 3);
    v11 = v10 <= a2;
    v12 = v10 - a2;
    if (v11)
      v13 = 0;
    else
      v13 = v12;
    if (v7 - a1 >= 1
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5 + 96))(v5, a1, v7 - a1) != v7 - a1)
    {
      goto LABEL_30;
    }
    if ((uint64_t)v13 >= 1)
    {
      if (v13 >= 0x7FFFFFFFFFFFFFF8)
        abort();
      if (v13 >= 0x17)
      {
        v15 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v13 | 7) != 0x17)
          v15 = v13 | 7;
        v16 = v15 + 1;
        p_b = (std::locale::__imp *)operator new(v15 + 1);
        v22 = v13;
        v23 = v16 | 0x8000000000000000;
        __b.__locale_ = p_b;
      }
      else
      {
        HIBYTE(v23) = v13;
        p_b = (std::locale::__imp *)&__b;
      }
      memset(p_b, v8, v13);
      *((_BYTE *)p_b + v13) = 0;
      v17 = v23 >= 0 ? &__b : (std::locale *)__b.__locale_;
      v18 = (*(uint64_t (**)(uint64_t, std::locale *, size_t))(*(_QWORD *)v5 + 96))(v5, v17, v13);
      if (SHIBYTE(v23) < 0)
        operator delete(__b.__locale_);
      if (v18 != v13)
        goto LABEL_30;
    }
    if (v6 - v7 >= 1
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5 + 96))(v5, v7, v6 - v7) != v6 - v7)
    {
      goto LABEL_30;
    }
    *((_QWORD *)v4 + 3) = 0;
  }
  return std::ostream::sentry::~sentry(v20);
}

_QWORD *__copy_helper_block_a8_72c42_ZTSN27AccelerationStructureViewer6FilterE(_QWORD *result, uint64_t a2)
{
  char v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_BYTE *)(a2 + 80);
  result[11] = 0;
  v3 = result + 11;
  result[9] = off_727800;
  *((_BYTE *)result + 80) = v2;
  result[12] = 0;
  result[13] = 0;
  v4 = *(_QWORD *)(a2 + 88);
  v5 = *(_QWORD *)(a2 + 96);
  if (v5 != v4)
  {
    std::vector<AccelerationStructureViewer::FilterToken>::__vallocate[abi:nn180100](result + 11, 0xAAAAAAAAAAAAAAABLL * ((v5 - v4) >> 3));
    return std::vector<AccelerationStructureViewer::FilterToken>::__construct_at_end<AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*>(v3, v4, v5);
  }
  return result;
}

void __destroy_helper_block_a8_72c42_ZTSN27AccelerationStructureViewer6FilterE(uint64_t a1)
{
  void **v1;

  *(_QWORD *)(a1 + 72) = off_727800;
  v1 = (void **)(a1 + 88);
  std::vector<AccelerationStructureViewer::FilterToken>::__destroy_vector::operator()[abi:nn180100](&v1);
}

void ___ZN33AccelerationStructureViewerServer6Server4recvEPvm_block_invoke_4(uint64_t a1, uint64_t *a2, void *a3)
{
  id v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  void (**v18)(AccelerationStructureViewer::DataSourceArray *__hidden);
  __int128 v19;
  __int128 v20;
  __int128 v21;

  v5 = a3;
  v6 = *(_QWORD *)(a1 + 32);
  v18 = off_7241B0;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v7 = *a2;
  if (*a2 != a2[1])
  {
    v8 = 0;
    do
    {
      if ((unint64_t)v8 >= (unint64_t)v20)
      {
        v10 = (_QWORD *)v19;
        v11 = (uint64_t)((uint64_t)v8 - v19) >> 3;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61)
          abort();
        v13 = v20 - v19;
        if ((uint64_t)(v20 - v19) >> 2 > v12)
          v12 = v13 >> 2;
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
          v14 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v14 = v12;
        if (v14)
          v14 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v14);
        else
          v15 = 0;
        v16 = (_QWORD *)(v14 + 8 * v11);
        *v16 = v7;
        v9 = v16 + 1;
        if (v8 != v10)
        {
          do
          {
            v17 = *--v8;
            *--v16 = v17;
          }
          while (v8 != v10);
          v8 = (_QWORD *)v19;
        }
        *(_QWORD *)&v19 = v16;
        *(_QWORD *)&v20 = v14 + 8 * v15;
        if (v8)
          operator delete(v8);
      }
      else
      {
        *v8 = v7;
        v9 = v8 + 1;
      }
      *((_QWORD *)&v19 + 1) = v9;
      v7 += 152;
      v8 = v9;
    }
    while (v7 != a2[1]);
  }
  AccelerationStructureViewerServer::Server::replyQueryable(v6, 8, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8), (uint64_t *)&v18, v5);
  AccelerationStructureViewer::DataSourceArray::~DataSourceArray((AccelerationStructureViewer::DataSourceArray *)&v18);

}

id *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<AccelerationStructureViewer::FilterToken *,AccelerationStructureViewer::FilterToken *,AccelerationStructureViewer::FilterToken *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  id *v5;

  if (a1 != a2)
  {
    v4 = a1;
    v5 = (id *)(a3 + 16);
    do
    {
      *((_DWORD *)v5 - 2) = *(_DWORD *)(v4 + 8);
      objc_storeStrong(v5, *(id *)(v4 + 16));
      v4 += 24;
      v5 += 3;
    }
    while (v4 != a2);
    return v5 - 2;
  }
  return (id *)a3;
}

void std::__function::__func<AccelerationStructureViewerServer::Intersector::Intersector(AccelerationStructureViewerServer::IntersectorType,objc_object  {objcproto9MTLDevice}*,objc_object  {objcproto10MTLLibrary}*,AccelerationStructureViewerServer::DataSource *,AccelerationStructureViewer::IntersectionFunctionTable *)::$_0,std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>,void ()(unsigned long,BOOL,objc_object  {objcproto11MTLFunction}*,AccelerationStructureViewerServer::DataSource::IntersectionFunction *)>::~__func()
{
  operator delete();
}

__n128 std::__function::__func<AccelerationStructureViewerServer::Intersector::Intersector(AccelerationStructureViewerServer::IntersectorType,objc_object  {objcproto9MTLDevice}*,objc_object  {objcproto10MTLLibrary}*,AccelerationStructureViewerServer::DataSource *,AccelerationStructureViewer::IntersectionFunctionTable *)::$_0,std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>,void ()(unsigned long,BOOL,objc_object  {objcproto11MTLFunction}*,AccelerationStructureViewerServer::DataSource::IntersectionFunction *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = off_727838;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<AccelerationStructureViewerServer::Intersector::Intersector(AccelerationStructureViewerServer::IntersectorType,objc_object  {objcproto9MTLDevice}*,objc_object  {objcproto10MTLLibrary}*,AccelerationStructureViewerServer::DataSource *,AccelerationStructureViewer::IntersectionFunctionTable *)::$_0,std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>,void ()(unsigned long,BOOL,objc_object  {objcproto11MTLFunction}*,AccelerationStructureViewerServer::DataSource::IntersectionFunction *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = off_727838;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<AccelerationStructureViewerServer::Intersector::Intersector(AccelerationStructureViewerServer::IntersectorType,objc_object  {objcproto9MTLDevice}*,objc_object  {objcproto10MTLLibrary}*,AccelerationStructureViewerServer::DataSource *,AccelerationStructureViewer::IntersectionFunctionTable *)::$_0,std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>,void ()(unsigned long,BOOL,objc_object  {objcproto11MTLFunction}*,AccelerationStructureViewerServer::DataSource::IntersectionFunction *)>::operator()(_QWORD *a1, uint64_t a2, unsigned __int8 *a3, id *a4, uint64_t *a5)
{
  int v6;
  uint64_t v7;
  id v8;
  void *v9;
  _DWORD *i;
  _DWORD *v11;
  uint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  unint64_t v16;
  _DWORD *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  int v24;
  id *v25;
  id **v26;
  id *v27;
  id *v28;
  unsigned __int8 v29;
  id v30;

  v6 = *a3;
  v7 = *a5;
  v8 = *a4;
  v9 = v8;
  if (v8)
  {
    v30 = v8;
    v11 = *(_DWORD **)(v7 + 80);
    for (i = *(_DWORD **)(v7 + 88); v11 != i; ++v11)
    {
      v12 = a1[3];
      v13 = *(char **)v12;
      v14 = *(char **)(v12 + 8);
      if (*(char **)v12 == v14)
      {
        v15 = *(char **)v12;
      }
      else
      {
        v15 = *(char **)v12;
        while (*(_DWORD *)v15 != *v11)
        {
          v15 += 4;
          if (v15 == v14)
          {
            v15 = *(char **)(v12 + 8);
            break;
          }
        }
      }
      if (v15 == v14)
      {
        v16 = *(_QWORD *)(v12 + 16);
        if ((unint64_t)v14 >= v16)
        {
          v18 = (v14 - v13) >> 2;
          v19 = v18 + 1;
          if ((unint64_t)(v18 + 1) >> 62)
            abort();
          v20 = v16 - (_QWORD)v13;
          if (v20 >> 1 > v19)
            v19 = v20 >> 1;
          if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFFCLL)
            v21 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v21 = v19;
          if (v21)
          {
            v21 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v21);
            v13 = *(char **)v12;
            v14 = *(char **)(v12 + 8);
          }
          else
          {
            v22 = 0;
          }
          v23 = (_DWORD *)(v21 + 4 * v18);
          *v23 = *v11;
          v17 = v23 + 1;
          while (v14 != v13)
          {
            v24 = *((_DWORD *)v14 - 1);
            v14 -= 4;
            *--v23 = v24;
          }
          *(_QWORD *)v12 = v23;
          *(_QWORD *)(v12 + 8) = v17;
          *(_QWORD *)(v12 + 16) = v21 + 4 * v22;
          if (v13)
            operator delete(v13);
        }
        else
        {
          *(_DWORD *)v14 = *v11;
          v17 = v14 + 4;
        }
        *(_QWORD *)(v12 + 8) = v17;
        i = *(_DWORD **)(v7 + 88);
      }
    }
    if (v6)
    {
      v27 = (id *)a1[2];
      v26 = (id **)(a1 + 2);
      v25 = v27;
    }
    else
    {
      v28 = (id *)a1[1];
      v26 = (id **)(a1 + 1);
      v25 = v28;
    }
    v29 = objc_msgSend(*v25, "containsObject:", v30);
    v9 = v30;
    if ((v29 & 1) == 0)
    {
      objc_msgSend(**v26, "addObject:", v30);
      v9 = v30;
    }
  }

}

uint64_t std::vector<TargetBlock>::push_back[abi:nn180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v4 = a1[2];
  v5 = a1[1];
  if (v5 >= v4)
  {
    v8 = (uint64_t)(v5 - *a1) >> 7;
    if ((unint64_t)(v8 + 1) >> 57)
      abort();
    v9 = v4 - *a1;
    v10 = v9 >> 6;
    if (v9 >> 6 <= (unint64_t)(v8 + 1))
      v10 = v8 + 1;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFF80)
      v11 = 0x1FFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v17 = a1 + 2;
    if (v11)
    {
      if (v11 >> 57)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v12 = (char *)operator new(v11 << 7);
    }
    else
    {
      v12 = 0;
    }
    v13 = v12;
    v14 = &v12[128 * v8];
    v16 = &v12[128 * v11];
    std::allocator<TargetBlock>::construct[abi:nn180100]<TargetBlock,TargetBlock>((uint64_t)v14, a2);
    v15 = v14 + 128;
    std::vector<TargetBlock>::__swap_out_circular_buffer(a1, &v13);
    v7 = a1[1];
    result = std::__split_buffer<TargetBlock>::~__split_buffer((uint64_t)&v13);
  }
  else
  {
    result = std::allocator<TargetBlock>::construct[abi:nn180100]<TargetBlock,TargetBlock>(a1[1], a2);
    v7 = v5 + 128;
  }
  a1[1] = v7;
  return result;
}

uint64_t *std::vector<ALUTargetBlockInfo>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = *result;
  v2 = result[1];
  v4 = a2[1];
  if (v2 != *result)
  {
    v5 = 0;
    do
    {
      v6 = v4 + v5;
      v7 = v2 + v5;
      *(_QWORD *)(v6 - 32) = *(_QWORD *)(v2 + v5 - 32);
      *(_QWORD *)(v6 - 24) = 0;
      *(_QWORD *)(v6 - 16) = 0;
      *(_QWORD *)(v6 - 8) = 0;
      *(_OWORD *)(v6 - 24) = *(_OWORD *)(v2 + v5 - 24);
      *(_QWORD *)(v6 - 8) = *(_QWORD *)(v2 + v5 - 8);
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      v5 -= 32;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  v8 = *result;
  *result = v4;
  a2[1] = v8;
  v9 = result[1];
  result[1] = a2[2];
  a2[2] = v9;
  v10 = result[2];
  result[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<ALUTargetBlockInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    *(_QWORD *)(a1 + 16) = v2 - 32;
    v4 = *(void **)(v2 - 24);
    if (v4)
    {
      *(_QWORD *)(v2 - 16) = v4;
      operator delete(v4);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 32;
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *llvm::agxclauseanalyzer::AnalyzerInput::InstIteratorImpl<llvm::agxclauseanalyzer::AnalyzerInput>::operator++(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v4;
  char v5;

  (*(void (**)(uint64_t *__return_ptr, _QWORD, _QWORD))(*(_QWORD *)*a1 + 24))(&v4, *a1, a1[1]);
  v2 = v4;
  if ((v5 & 1) != 0)
  {
    ++a1[1];
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  }
  else
  {
    a1[1] += *(_QWORD *)(v4 + 16);
  }
  return a1;
}

uint64_t std::vector<TargetBlock>::__base_destruct_at_end[abi:nn180100](uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t i;

  v3 = result;
  for (i = *(_QWORD *)(result + 8); i != a2; i -= 128)
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(i - 40);
    std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table(i - 88);
    result = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(i - 128);
  }
  *(_QWORD *)(v3 + 8) = a2;
  return result;
}

void std::vector<TargetBlock>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<TargetBlock>::__base_destruct_at_end[abi:nn180100]((uint64_t)v2, (uint64_t)*v2);
    operator delete(**a1);
  }
}

uint64_t std::allocator<TargetBlock>::construct[abi:nn180100]<TargetBlock,TargetBlock>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v3 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__hash_table(a1, (uint64_t *)a2);
  v4 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(v3 + 40) = v4;
  *(_QWORD *)(v3 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  v5 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(v3 + 56) = v5;
  v6 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(v3 + 64) = v6;
  *(_DWORD *)(v3 + 72) = *(_DWORD *)(a2 + 72);
  if (v6)
  {
    v7 = *(_QWORD *)(v5 + 8);
    v8 = *(_QWORD *)(v3 + 48);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v7 %= v8;
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(_QWORD *)(v4 + 8 * v7) = v3 + 56;
    *(_QWORD *)(a2 + 56) = 0;
    *(_QWORD *)(a2 + 64) = 0;
  }
  *(_QWORD *)(v3 + 80) = *(_QWORD *)(a2 + 80);
  return std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__hash_table(v3 + 88, (uint64_t *)(a2 + 88));
}

uint64_t *std::vector<TargetBlock>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = result;
  v5 = *result;
  v4 = result[1];
  v6 = a2[1];
  while (v4 != v5)
  {
    v6 -= 128;
    v4 -= 128;
    result = (uint64_t *)std::allocator<TargetBlock>::construct[abi:nn180100]<TargetBlock,TargetBlock>(v6, v4);
  }
  a2[1] = v6;
  v7 = *v3;
  *v3 = v6;
  a2[1] = v7;
  v8 = v3[1];
  v3[1] = a2[2];
  a2[2] = v8;
  v9 = v3[2];
  v3[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<TargetBlock>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 128;
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(i - 40);
    std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table(i - 88);
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(i - 128);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::__emplace_unique_key_args<unsigned long long,unsigned long long &,unsigned long &>(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD *v11;
  _QWORD *i;
  unint64_t v13;
  _QWORD *v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;

  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v4 = a2;
      if (v9 <= a2)
        v4 = a2 % v9;
    }
    else
    {
      v4 = (v9 - 1) & a2;
    }
    v11 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
    if (v11)
    {
      for (i = (_QWORD *)*v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == a2)
        {
          if (i[2] == a2)
            return;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v4)
            break;
        }
      }
    }
  }
  v14 = operator new(0x20uLL);
  v14[1] = a2;
  v14[2] = a3;
  v14[3] = a4;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    v17 = 1;
    if (v9 >= 3)
      v17 = (v9 & (v9 - 1)) != 0;
    v18 = v17 | (2 * v9);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v20);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v9 <= a2)
        v4 = a2 % v9;
      else
        v4 = a2;
    }
    else
    {
      v4 = (v9 - 1) & a2;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v22)
  {
    *v14 = *v22;
LABEL_38:
    *v22 = v14;
    goto LABEL_39;
  }
  v23 = *(_QWORD *)(a1 + 16);
  *v14 = v23;
  *(_QWORD *)(a1 + 16) = v14;
  *(_QWORD *)(v21 + 8 * v4) = a1 + 16;
  if (v23)
  {
    v24 = *(_QWORD *)(v23 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v24 >= v9)
        v24 %= v9;
    }
    else
    {
      v24 &= v9 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v24);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
}

uint64_t llvm::Expected<std::vector<llvm::iterator_range<llvm::agxclauseanalyzer::AnalyzerInput::InstIteratorImpl<llvm::agxclauseanalyzer::AnalyzerInput const>>>>::~Expected(uint64_t a1)
{
  char v2;
  void *v3;

  v2 = *(_BYTE *)(a1 + 24);
  v3 = *(void **)a1;
  if ((v2 & 1) != 0)
  {
    *(_QWORD *)a1 = 0;
    if (v3)
      (*(void (**)(void *))(*(_QWORD *)v3 + 8))(v3);
  }
  else if (v3)
  {
    *(_QWORD *)(a1 + 8) = v3;
    operator delete(v3);
  }
  return a1;
}

void std::vector<llvm::Error>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = *((_QWORD *)v4 - 1);
        v4 -= 8;
        v6 = v7;
        if (v7)
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::allocator<TargetClause>::destroy[abi:nn180100](uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(_QWORD *)(a1 + 72) = v2;
    operator delete(v2);
  }
  return std::__hash_table<std::__hash_value_type<unsigned int,DrawDurationInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DrawDurationInfo>>>::~__hash_table(a1 + 24);
}

uint64_t TargetClauseAnalysis::GetTargetBlocks(TargetClauseAnalysis *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *i;
  uint64_t v5;
  int *v6;
  int *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  unint64_t v11;
  size_t v12;
  char *v13;
  unsigned int *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  _DWORD *v21;
  _DWORD **v22;
  unint64_t v23;
  _DWORD *v24;
  _DWORD *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  BOOL v29;
  unint64_t v30;
  uint64_t v31;
  _DWORD *v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  unsigned int v37;
  unint64_t v38;
  __int128 v39;
  char *v40;
  uint64_t *v41;
  size_t v42;
  unint64_t v43;
  uint8x8_t v44;
  uint64_t **v45;
  uint64_t *j;
  unint64_t v47;
  char *v48;
  float v49;
  float v50;
  _BOOL8 v51;
  unint64_t v52;
  unint64_t v53;
  size_t v54;
  uint64_t v55;
  _QWORD *v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint8x8_t v60;
  void **v61;
  _QWORD *v62;
  unint64_t v63;
  float v64;
  float v65;
  _BOOL8 v66;
  unint64_t v67;
  unint64_t v68;
  size_t v69;
  uint64_t v70;
  _QWORD *v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int *v75;
  unsigned int v76;
  uint64_t v77;
  uint64_t v78;
  int *v79;
  int v80;
  unsigned int v82;
  unsigned int v83;
  int v84;
  unsigned int v85;
  unsigned int **v86;
  unsigned int *v87;
  unsigned int *v88;
  unsigned int v89;
  uint64_t *k;
  char *v92;
  char *v93;
  void *v94;
  void *v95;
  char *v97;
  uint64_t *v98;
  uint64_t v99;
  uint64_t v100;
  __int128 v101;
  unsigned int *v102;
  char *v103;
  size_t v104;
  __int128 v105;
  __int128 v106;
  int v107;
  __int128 v108;
  __int128 v109;
  int v110;

  v108 = 0u;
  v109 = 0u;
  v110 = 1065353216;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)&v108, (unint64_t)(float)*((unsigned int *)this + 62));
  v2 = *(_QWORD *)this;
  v3 = *((_QWORD *)this + 1);
  while (v2 != v3)
  {
    for (i = *(uint64_t **)(v2 + 40); i; i = (uint64_t *)*i)
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)&v108, *((_DWORD *)i + 4), *((_DWORD *)i + 4));
    v2 += 88;
  }
  v5 = v109;
  if (!(_QWORD)v109)
    goto LABEL_157;
  do
  {
    v6 = (int *)*((_QWORD *)this + 17);
    v7 = (int *)*((_QWORD *)this + 18);
    if (v6 == v7)
    {
      v8 = 0;
    }
    else
    {
      v8 = 0;
      do
      {
        v9 = *v6++;
        if (v9 == -1)
          ++v8;
      }
      while (v6 != v7);
    }
    v10 = *((_QWORD *)this + 32);
    v11 = v10 - v8;
    if (v10 == v8)
    {
      v12 = 0;
      v13 = 0;
      v97 = 0;
    }
    else
    {
      if (v11 >> 62
        || (v12 = (size_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v10 - v8),
            bzero((void *)v12, 4 * v10 - 4 * v8),
            v11 >= 0xAAAAAAAAAAAAAABLL))
      {
LABEL_158:
        abort();
      }
      v13 = (char *)operator new(24 * v11);
      bzero(v13, 24 * ((24 * v11 - 24) / 0x18) + 24);
      v97 = &v13[24 * ((24 * v11 - 24) / 0x18) + 24];
    }
    v98 = (uint64_t *)v5;
    v14 = (unsigned int *)(v5 + 16);
    v15 = *(_QWORD *)this;
    v100 = *((_QWORD *)this + 1);
    v103 = v13;
    v104 = v12;
    v102 = v14;
    if (*(_QWORD *)this != v100)
    {
      do
      {
        v16 = *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,DrawDurationInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DrawDurationInfo>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v15 + 24, *v14, v14)+ 6);
        if (v16)
        {
          v17 = *((_QWORD *)this + 17);
          v18 = *(unsigned int *)(v17 + 4 * *(_QWORD *)v15);
          v19 = *(unsigned int *)(v17 + 4 * (*(_QWORD *)(v15 + 8) + *(_QWORD *)v15));
          if (v18 < v19)
          {
            do
            {
              *(_DWORD *)(v12 + 4 * v18) += v16;
              v20 = &v13[24 * v18];
              v22 = (_DWORD **)(v20 + 8);
              v21 = (_DWORD *)*((_QWORD *)v20 + 1);
              v23 = *((_QWORD *)v20 + 2);
              if ((unint64_t)v21 >= v23)
              {
                v25 = *(_DWORD **)v20;
                v26 = ((uint64_t)v21 - *(_QWORD *)v20) >> 2;
                v27 = v26 + 1;
                if ((unint64_t)(v26 + 1) >> 62)
                  goto LABEL_158;
                v28 = v23 - (_QWORD)v25;
                if (v28 >> 1 > v27)
                  v27 = v28 >> 1;
                v29 = (unint64_t)v28 >= 0x7FFFFFFFFFFFFFFCLL;
                v30 = 0x3FFFFFFFFFFFFFFFLL;
                if (!v29)
                  v30 = v27;
                if (v30)
                {
                  v30 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v30);
                  v21 = *v22;
                  v25 = *(_DWORD **)v20;
                }
                else
                {
                  v31 = 0;
                }
                v32 = (_DWORD *)(v30 + 4 * v26);
                *v32 = *(_DWORD *)(v15 + 16);
                v24 = v32 + 1;
                while (v21 != v25)
                {
                  v33 = *--v21;
                  *--v32 = v33;
                }
                *(_QWORD *)v20 = v32;
                *v22 = v24;
                *((_QWORD *)v20 + 2) = v30 + 4 * v31;
                if (v25)
                  operator delete(v25);
              }
              else
              {
                *v21 = *(_DWORD *)(v15 + 16);
                v24 = v21 + 1;
              }
              *v22 = v24;
              ++v18;
              v13 = v103;
              v12 = v104;
            }
            while (v18 != v19);
          }
        }
        v15 += 88;
        v14 = v102;
      }
      while (v15 != v100);
    }
    v35 = *((_QWORD *)this + 28);
    v34 = *((_QWORD *)this + 29);
    v99 = v34;
    while (v35 != v34)
    {
      v36 = *(_DWORD *)(v35 + 84) - *(_DWORD *)(v35 + 80);
      v37 = v36 + 1;
      if (v36 == -1)
      {
        v38 = 0;
        v39 = 0uLL;
      }
      else
      {
        v12 = 4 * (v36 + 1);
        v40 = (char *)operator new(v12);
        v38 = (unint64_t)&v40[4 * v37];
        bzero(v40, 4 * v37);
        *(_QWORD *)&v39 = v40;
        *((_QWORD *)&v39 + 1) = v38;
      }
      v41 = (uint64_t *)(v35 + 40);
      v42 = *v102;
      v43 = *(_QWORD *)(v35 + 48);
      if (v43)
      {
        v44 = (uint8x8_t)vcnt_s8((int8x8_t)v43);
        v44.i16[0] = vaddlv_u8(v44);
        if (v44.u32[0] > 1uLL)
        {
          v12 = *v102;
          if (v43 <= v42)
            v12 = v42 % v43;
        }
        else
        {
          v12 = ((_DWORD)v43 - 1) & v42;
        }
        v45 = *(uint64_t ***)(*v41 + 8 * v12);
        if (v45)
        {
          for (j = *v45; j; j = (uint64_t *)*j)
          {
            v47 = j[1];
            if (v47 == v42)
            {
              if (*((_DWORD *)j + 4) == (_DWORD)v42)
              {
                v12 = v104;
                goto LABEL_82;
              }
            }
            else
            {
              if (v44.u32[0] > 1uLL)
              {
                if (v47 >= v43)
                  v47 %= v43;
              }
              else
              {
                v47 &= v43 - 1;
              }
              if (v47 != v12)
                break;
            }
          }
        }
      }
      v101 = v39;
      v48 = (char *)operator new(0x30uLL);
      *(_QWORD *)v48 = 0;
      *((_QWORD *)v48 + 1) = v42;
      *((_DWORD *)v48 + 4) = *v102;
      *(_OWORD *)(v48 + 24) = v101;
      *((_QWORD *)v48 + 5) = v38;
      v49 = (float)(unint64_t)(*(_QWORD *)(v35 + 64) + 1);
      v50 = *(float *)(v35 + 72);
      if (!v43 || (float)(v50 * (float)v43) < v49)
      {
        v51 = (v43 & (v43 - 1)) != 0;
        if (v43 < 3)
          v51 = 1;
        v52 = v51 | (2 * v43);
        v53 = vcvtps_u32_f32(v49 / v50);
        if (v52 <= v53)
          v54 = v53;
        else
          v54 = v52;
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(v35 + 40, v54);
        v43 = *(_QWORD *)(v35 + 48);
        if ((v43 & (v43 - 1)) != 0)
        {
          if (v43 <= v42)
            v12 = v42 % v43;
          else
            v12 = v42;
        }
        else
        {
          v12 = ((_DWORD)v43 - 1) & v42;
        }
      }
      v55 = *v41;
      v56 = *(_QWORD **)(*v41 + 8 * v12);
      if (v56)
      {
        *(_QWORD *)v48 = *v56;
        v12 = v104;
LABEL_80:
        *v56 = v48;
        goto LABEL_81;
      }
      *(_QWORD *)v48 = *(_QWORD *)(v35 + 56);
      *(_QWORD *)(v35 + 56) = v48;
      *(_QWORD *)(v55 + 8 * v12) = v35 + 56;
      v12 = v104;
      if (*(_QWORD *)v48)
      {
        v57 = *(_QWORD *)(*(_QWORD *)v48 + 8);
        if ((v43 & (v43 - 1)) != 0)
        {
          if (v57 >= v43)
            v57 %= v43;
        }
        else
        {
          v57 &= v43 - 1;
        }
        v56 = (_QWORD *)(*v41 + 8 * v57);
        goto LABEL_80;
      }
LABEL_81:
      ++*(_QWORD *)(v35 + 64);
      *(_QWORD *)&v39 = 0;
LABEL_82:
      if ((_QWORD)v39)
        operator delete((void *)v39);
      v58 = *v102;
      v59 = *(_QWORD *)(v35 + 48);
      if (v59)
      {
        v60 = (uint8x8_t)vcnt_s8((int8x8_t)v59);
        v60.i16[0] = vaddlv_u8(v60);
        if (v60.u32[0] > 1uLL)
        {
          v38 = *v102;
          if (v59 <= v58)
            v38 = v58 % v59;
        }
        else
        {
          v38 = ((_DWORD)v59 - 1) & v58;
        }
        v61 = *(void ***)(*v41 + 8 * v38);
        if (v61)
        {
          v62 = *v61;
          if (*v61)
          {
            do
            {
              v63 = v62[1];
              if (v63 == v58)
              {
                if (*((_DWORD *)v62 + 4) == (_DWORD)v58)
                  goto LABEL_122;
              }
              else
              {
                if (v60.u32[0] > 1uLL)
                {
                  if (v63 >= v59)
                    v63 %= v59;
                }
                else
                {
                  v63 &= v59 - 1;
                }
                if (v63 != v38)
                  break;
              }
              v62 = (_QWORD *)*v62;
            }
            while (v62);
          }
        }
      }
      v62 = operator new(0x30uLL);
      *v62 = 0;
      v62[1] = v58;
      *((_DWORD *)v62 + 4) = *v102;
      v62[4] = 0;
      v62[5] = 0;
      v62[3] = 0;
      v64 = (float)(unint64_t)(*(_QWORD *)(v35 + 64) + 1);
      v65 = *(float *)(v35 + 72);
      if (!v59 || (float)(v65 * (float)v59) < v64)
      {
        v66 = (v59 & (v59 - 1)) != 0;
        if (v59 < 3)
          v66 = 1;
        v67 = v66 | (2 * v59);
        v68 = vcvtps_u32_f32(v64 / v65);
        if (v67 <= v68)
          v69 = v68;
        else
          v69 = v67;
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(v35 + 40, v69);
        v59 = *(_QWORD *)(v35 + 48);
        if ((v59 & (v59 - 1)) != 0)
        {
          if (v59 <= v58)
            v38 = v58 % v59;
          else
            v38 = v58;
        }
        else
        {
          v38 = ((_DWORD)v59 - 1) & v58;
        }
      }
      v70 = *v41;
      v71 = *(_QWORD **)(*v41 + 8 * v38);
      if (v71)
      {
        *v62 = *v71;
LABEL_120:
        *v71 = v62;
        goto LABEL_121;
      }
      *v62 = *(_QWORD *)(v35 + 56);
      *(_QWORD *)(v35 + 56) = v62;
      *(_QWORD *)(v70 + 8 * v38) = v35 + 56;
      if (*v62)
      {
        v72 = *(_QWORD *)(*v62 + 8);
        if ((v59 & (v59 - 1)) != 0)
        {
          if (v72 >= v59)
            v72 %= v59;
        }
        else
        {
          v72 &= v59 - 1;
        }
        v71 = (_QWORD *)(*v41 + 8 * v72);
        goto LABEL_120;
      }
LABEL_121:
      ++*(_QWORD *)(v35 + 64);
LABEL_122:
      v73 = *(unsigned int *)(v35 + 80);
      v74 = *(unsigned int *)(v35 + 84);
      v75 = (int *)(v12 + 4 * v73);
      v13 = v103;
      v76 = 0;
      if (v75 == (int *)(v12 + 4 * v74 + 4))
      {
        LODWORD(v78) = 0;
      }
      else
      {
        v77 = 4 * v74 - 4 * v73 + 4;
        v78 = v77;
        v79 = v75;
        do
        {
          v80 = *v79++;
          v76 += v80;
          v78 -= 4;
        }
        while (v78);
        do
        {
          if (*v75++)
            LODWORD(v78) = v78 + 1;
          v77 -= 4;
        }
        while (v77);
      }
      if (v78 <= 1)
        v82 = 1;
      else
        v82 = v78;
      *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v35 + 88, *v102, v102)+ 5) = v76 / v82;
      v105 = 0u;
      v106 = 0u;
      v107 = 1065353216;
      v83 = *(_DWORD *)(v35 + 80);
      if (v83 <= *(_DWORD *)(v35 + 84))
      {
        do
        {
          v84 = *(_DWORD *)(v12 + 4 * v83);
          v85 = v83;
          if (v84)
          {
            *(_DWORD *)(v62[3] + 4 * (v83 - *(_DWORD *)(v35 + 80))) = v84;
            v86 = (unsigned int **)&v103[24 * v83];
            v87 = *v86;
            v88 = v86[1];
            while (v87 != v88)
            {
              v89 = *(_DWORD *)(*((_QWORD *)this + 17) + 4 * *(_QWORD *)(*(_QWORD *)this + 88 * *v87));
              if (v89 >= *(_DWORD *)(v35 + 80) && v89 <= *(_DWORD *)(v35 + 84))
                std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)&v105, *v87, *v87);
              ++v87;
            }
          }
          v83 = v85 + 1;
        }
        while (v85 + 1 <= *(_DWORD *)(v35 + 84));
        for (k = (uint64_t *)v106; k; k = (uint64_t *)*k)
          std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(v35, *((_DWORD *)k + 4), *((_DWORD *)k + 4));
      }
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v105);
      v35 += 128;
      v34 = v99;
    }
    if (v13)
    {
      v92 = v97;
      if (v97 != v13)
      {
        v93 = v97;
        do
        {
          v95 = (void *)*((_QWORD *)v93 - 3);
          v93 -= 24;
          v94 = v95;
          if (v95)
          {
            *((_QWORD *)v92 - 2) = v94;
            operator delete(v94);
          }
          v92 = v93;
        }
        while (v93 != v13);
      }
      operator delete(v13);
    }
    if (v12)
      operator delete((void *)v12);
    v5 = *v98;
  }
  while (*v98);
LABEL_157:
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v108);
  return (uint64_t)this + 224;
}

