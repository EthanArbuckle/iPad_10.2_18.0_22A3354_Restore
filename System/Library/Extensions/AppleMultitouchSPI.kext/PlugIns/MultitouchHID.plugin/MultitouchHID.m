uint64_t MultitouchHIDClass::_setProperty(MultitouchHIDClass *this, void *a2, const __CFString *a3, const void *a4)
{
  return (*(uint64_t (**)(_QWORD, void *, const __CFString *))(**((_QWORD **)this + 1) + 88))(*((_QWORD *)this + 1), a2, a3);
}

uint64_t MultitouchHIDClass::setProperty(MultitouchHIDClass *this, const __CFString *a2, const void *a3)
{
  uint64_t result;

  result = *((_QWORD *)this + 6);
  if (result)
    return (*(uint64_t (**)(uint64_t, const __CFString *, const void *))(*(_QWORD *)result + 568))(result, a2, a3);
  return result;
}

void MTSimpleEventDispatcher::recordHIDEvent(uint64_t a1, uint64_t a2, int a3)
{
  const __CFArray *Children;
  const __CFArray *v6;
  CFIndex v7;
  uint64_t v8;
  const void *ValueAtIndex;
  unsigned int Type;

  if (a2 && a3 <= 5)
  {
    Children = (const __CFArray *)IOHIDEventGetChildren();
    if (Children)
    {
      v6 = Children;
      if (CFArrayGetCount(Children) >= 1)
      {
        v7 = 0;
        v8 = (a3 + 1);
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v6, v7);
          (*(void (**)(uint64_t, const void *, uint64_t))(*(_QWORD *)a1 + 56))(a1, ValueAtIndex, v8);
          ++v7;
        }
        while (v7 < CFArrayGetCount(v6));
      }
    }
    Type = IOHIDEventGetType();
    if (Type <= 0x2A)
      *(CFAbsoluteTime *)(a1 + 8 * Type + 80) = CFAbsoluteTimeGetCurrent();
  }
}

void MTEmbeddedStats::resetTouchState(MTEmbeddedStats *this)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  NSObject *v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD v13[5];
  std::__shared_weak_count *v14;

  v1 = *(_QWORD *)this;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  v5 = *(NSObject **)(v1 + 8);
  v13[0] = MEMORY[0x24BDAC760];
  v13[1] = 3321888768;
  v13[2] = ___ZN15MTEmbeddedStats15resetTouchStateEv_block_invoke;
  v13[3] = &__block_descriptor_48_e8_32c47_ZTSNSt3__110shared_ptrI19MTEmbeddedStatsImplEE_e5_v8__0l;
  v13[4] = v1;
  v14 = v2;
  if (v2)
  {
    v6 = (unint64_t *)&v2->__shared_owners_;
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  dispatch_async(v5, v13);
  v8 = v14;
  if (!v14)
    goto LABEL_11;
  v9 = (unint64_t *)&v14->__shared_owners_;
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    if (!v2)
      return;
  }
  else
  {
LABEL_11:
    if (!v2)
      return;
  }
  v11 = (unint64_t *)&v2->__shared_owners_;
  do
    v12 = __ldaxr(v11);
  while (__stlxr(v12 - 1, v11));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t MTHandStatistics::processHandState(MTHandStatistics *this, MTPathStates *a2, int a3, char a4)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  unsigned int *v15;
  unsigned int v16;
  float32x2_t *v18;
  unsigned int v19;
  _BYTE *v20;
  _BOOL8 v21;
  _BOOL8 v22;
  BOOL v23;
  BOOL v24;
  __n128 v25;
  __n128 v26;
  unsigned int *v27;
  int8x8_t v28;
  int8x8_t v29;
  uint64_t v30;
  int v32;
  uint64_t v35;
  _BOOL4 v36;

  v5 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
  *((_QWORD *)this + 2) = v5;
  MTHandStatistics::clear(this, 1);
  if ((*((_DWORD *)this + 41) - 1000) <= 0xBB7)
  {
    v6 = *((_DWORD *)a2 + 97);
    v7 = *((_QWORD *)a2 + 35);
    v8 = *(_BYTE *)(v7 + 600 * v6 + 581) && *(_BYTE *)(v7 + 600 * v6 + 582) == 0;
    *((_BYTE *)this + 304) = v8;
    if (*((_BYTE *)this + 305))
    {
      if (*((unsigned __int8 *)this + 190) + *((unsigned __int8 *)this + 187) >= 4
        && *((unsigned __int8 *)this + 299) <= 2u)
      {
        *((_QWORD *)this + 32) = 0;
        *(_DWORD *)((char *)this + 214) = 0;
        *((_WORD *)this + 109) = 0;
      }
    }
  }
  *((_DWORD *)this + 40) = *((_DWORD *)a2 + 90);
  v9 = *((_QWORD *)a2 + 44);
  if (v9)
    LOBYTE(v9) = *(_BYTE *)(v9 + 3) != 0;
  *((_BYTE *)this + 222) = v9;
  v10 = 1;
  v11 = 1181;
  do
  {
    v12 = *((_QWORD *)a2 + 35);
    v13 = v12 + v11;
    v14 = (_DWORD *)(v12 + v11 - 541);
    v15 = (unsigned int *)(v12 + v11 - 537);
    v16 = *v15;
    if (v10 == *v14 && (int)v16 >= 1)
    {
      v18 = (float32x2_t *)(v13 - 581);
      v19 = v16 - 3;
      (*(void (**)(MTHandStatistics *, uint64_t, BOOL, BOOL))(*(_QWORD *)this + 16))(this, v13 - 581, v16 < 7, v16 - 3 < 2);
      if (MTParserPath::isFingerOrRestingContact((MTParserPath *)(v13 - 581))
        || MTParserPath::isStylusContact((MTParserPath *)(v13 - 581)))
      {
        v20 = (_BYTE *)(v12 + v11);
        v36 = (*(_DWORD *)(v20 - 441) - 3) <= 1
           && MTParserPath::wasFingerOrRestingContact((MTParserPath *)(v13 - 581));
        v35 = v13 - 365;
        v21 = v16 < 7;
        v22 = v19 < 2;
        v23 = (float)((float)(*(float *)(v20 - 45) * 3.0) + 6.0) >= *((float *)a2 + 76);
        v24 = MTParserPath::fingerLiftoffNearEdge(v18, *((const MTSurfaceDimensions **)a2 + 5), *((double *)a2 + 1) - *((double *)a2 + 2));
        if (*v15 == 7)
          v27 = (unsigned int *)(v20 - 437);
        else
          v27 = (unsigned int *)(v20 - 533);
        v25.n128_u32[0] = *(_DWORD *)(v20 - 489);
        v26.n128_u32[0] = *(_DWORD *)(v20 - 485);
        HIBYTE(v32) = a4;
        BYTE2(v32) = v24;
        BYTE1(v32) = v23;
        LOBYTE(v32) = *v20;
        (*(void (**)(MTHandStatistics *, _QWORD, _QWORD, uint64_t, _BOOL8, _BOOL8, _BOOL4, BOOL, __n128, __n128, float, int))(*(_QWORD *)this + 24))(this, *v14, *v27, v35, v21, v22, v36, *(double *)(v20 - 349) >= *(double *)(v20 - 357), v25, v26, *(float *)(v20 - 465), v32);
        v28 = (int8x8_t)vrev64_s32(*(int32x2_t *)(v20 - 301));
        *((_DWORD *)this + 56) &= HIDWORD(*(_QWORD *)(v20 - 301));
        v29 = *(int8x8_t *)((char *)this + 228);
        LODWORD(v30) = vorr_s8(v29, v28).u32[0];
        HIDWORD(v30) = vand_s8(v29, v28).i32[1];
        *(_QWORD *)((char *)this + 228) = v30;
        *((_DWORD *)this + 59) &= *(_DWORD *)(v20 - 293);
      }
      else
      {
        (*(void (**)(MTHandStatistics *, uint64_t, BOOL, BOOL))(*(_QWORD *)this + 40))(this, v13 - 581, v16 < 7, v19 < 2);
      }
    }
    ++v10;
    v11 += 600;
  }
  while (v10 != 32);
  (*(void (**)(MTHandStatistics *))(*(_QWORD *)this + 48))(this);
  *((_DWORD *)this + 77) = *((_DWORD *)a2 + 81);
  if (*((_BYTE *)this + 209))
    *((_BYTE *)this + 316) = 1;
  if (!*((_BYTE *)this + 202) && !*((_BYTE *)this + 203))
    return 0;
  *((_DWORD *)this + 43) = MTHandStatistics::makeCollectionEventMask(this, a3);
  return 1;
}

uint64_t MTPathStatesBasic::flushStuckContacts(MTPathStatesBasic *this)
{
  char v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double v6;

  v2 = 0;
  v3 = 632;
  v4 = 31;
  do
  {
    v5 = *((_QWORD *)this + 35);
    if (MTContact_isActive())
    {
      v6 = *((double *)this + 1);
      if (*(double *)(v5 + v3) != v6)
      {
        MTParserPath::flushLiftoffAt((MTParserPath *)(*((_QWORD *)this + 35) + v3 - 32), v6);
        v2 = 1;
      }
    }
    v3 += 600;
    --v4;
  }
  while (v4);
  return v2 & 1;
}

void MTHandMotion::clear(MTHandMotion *this)
{
  MTHandMotion::clearHandMotion(this, 1);
}

uint64_t MTSimpleHIDManager::cleanupBootloadPowerAssertion(MTSimpleHIDManager *this)
{
  NSObject *v2;
  uint64_t v3;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *((_QWORD *)this + 13);
    v5 = 136315906;
    v6 = "";
    v7 = 2080;
    v8 = "MTSimpleHIDManager::";
    v9 = 2080;
    v10 = "cleanupBootloadPowerAssertion";
    v11 = 2048;
    v12 = v3;
    _os_log_impl(&dword_231071000, v2, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s [generation: %llu]", (uint8_t *)&v5, 0x2Au);
  }
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 520))(this);
  return (*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 504))(this);
}

uint64_t MTSimpleHIDManager::forwardNotificationEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a3 + 208))(a3, a1, a2);
}

uint64_t MTSimpleHIDManager::setPropertyInternal(uint64_t *a1, int a2, CFTypeRef cf, int a4)
{
  CFTypeID v8;
  _BOOL8 v9;
  CFTypeID v10;
  _BOOL8 v11;
  CFTypeID v12;
  _BOOL8 v13;
  CFTypeID v14;
  _BOOL8 v15;
  CFTypeID v16;
  _BOOL8 v17;
  CFTypeID v18;
  _BOOL4 v19;
  uint64_t result;
  CFTypeID v21;
  CFTypeID v22;
  uint64_t v23;
  uint64_t v24;
  float v25;
  float v26;
  float v27;
  int v28;
  uint64_t v29;
  void (*v30)(uint64_t *, uint64_t, uint64_t);
  uint64_t *v31;
  _BOOL4 v32;
  NSObject *v33;
  int v34;
  int v35;
  NSObject *v36;
  const char *v37;
  char v38;
  int v39;
  int v40;
  unint64_t Length;
  NSObject *v42;
  NSObject *v43;
  uint32_t v44;
  int v45;
  int v46;
  int v47;
  int v48;
  _BOOL8 v49;
  int Value;
  uint64_t v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  NSObject *v56;
  int v57;
  int PowerOffSuppressed;
  NSObject *v59;
  unsigned int v60;
  uint64_t v61;
  int v62;
  int v63;
  NSObject *v64;
  int v65;
  uint64_t VendorDefinedEvent;
  const void *v67;
  NSObject *v68;
  int v69;
  int v70;
  double v71;
  _BYTE valuePtr[32];
  _BYTE v73[32];
  uint64_t v74;

  v74 = *MEMORY[0x24BDAC8D0];
  if (cf)
  {
    v8 = CFGetTypeID(cf);
    v9 = v8 == CFBooleanGetTypeID();
    v10 = CFGetTypeID(cf);
    v11 = v10 == CFNumberGetTypeID();
    v12 = CFGetTypeID(cf);
    v13 = v12 == CFDataGetTypeID();
    v14 = CFGetTypeID(cf);
    v15 = v14 == CFStringGetTypeID();
    v16 = CFGetTypeID(cf);
    v17 = v16 == CFArrayGetTypeID();
    v18 = CFGetTypeID(cf);
    v19 = v18 == CFDictionaryGetTypeID();
  }
  else
  {
    v17 = 0;
    v13 = 0;
    v9 = 0;
    v11 = 0;
    v15 = 0;
    v19 = 0;
  }
  result = 0;
  switch(a2)
  {
    case 1:
    case 2:
      result = 0;
      *(_DWORD *)valuePtr = 0;
      if (v11)
        return CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, valuePtr) != 0;
      return result;
    case 3:
      v21 = CFGetTypeID(cf);
      LODWORD(result) = v21 == CFArrayGetTypeID() && CFArrayGetCount((CFArrayRef)cf) > 0;
      return v9 | result;
    case 4:
      return v9 | result;
    case 5:
    case 25:
    case 70:
    case 74:
      return v9;
    case 6:
      v22 = CFGetTypeID(cf);
      return v22 == CFStringGetTypeID();
    case 7:
      if (!v9)
        return 0;
      _printHIDEvents = CFBooleanGetValue((CFBooleanRef)cf) != 0;
      return 1;
    case 9:
      result = 0;
      LOWORD(v71) = 0;
      if (!v11)
        return result;
      result = CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt16Type, &v71);
      if (!(_DWORD)result)
        return result;
      *((_DWORD *)a1 + 33) = LOWORD(v71);
      v23 = a1[14];
      if (v23)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v23 + 24))(v23);
      }
      else
      {
        v54 = 16;
        if (!*((_BYTE *)a1 + 122))
          v54 = 24;
        if (LODWORD(a1[v54]) != 255 && !*((_BYTE *)a1 + 80))
        {
          (*(void (**)(uint64_t *))(*a1 + 440))(a1);
          v55 = *a1;
          if (*((_BYTE *)a1 + 122))
            (*(void (**)(uint64_t *, _QWORD, _QWORD))(v55 + 432))(a1, *((unsigned __int16 *)a1 + 64), LOWORD(v71));
          else
            (*(void (**)(uint64_t *, _QWORD, _QWORD))(v55 + 464))(a1, *((unsigned __int16 *)a1 + 96), LOWORD(v71));
        }
      }
      *(_OWORD *)valuePtr = xmmword_2310BDC14;
      *(_OWORD *)&valuePtr[16] = unk_2310BDC24;
      *(_OWORD *)v73 = xmmword_2310BDC34;
      *(_OWORD *)&v73[16] = unk_2310BDC44;
      (*(void (**)(_BYTE *__return_ptr, uint64_t *))(*a1 + 168))(valuePtr, a1);
      *(_DWORD *)valuePtr = LOWORD(v71);
      goto LABEL_124;
    case 10:
      result = 0;
      LOWORD(v71) = 0;
      if (!v11)
        return result;
      result = CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt16Type, &v71);
      if (!(_DWORD)result)
        return result;
      *(_OWORD *)valuePtr = xmmword_2310BDC14;
      *(_OWORD *)&valuePtr[16] = unk_2310BDC24;
      *(_OWORD *)v73 = xmmword_2310BDC34;
      *(_OWORD *)&v73[16] = unk_2310BDC44;
      (*(void (**)(_BYTE *__return_ptr, uint64_t *))(*a1 + 168))(valuePtr, a1);
      *(_DWORD *)&valuePtr[4] = LOWORD(v71);
      goto LABEL_124;
    case 11:
      result = 0;
      valuePtr[0] = 0;
      if (!v11)
        return result;
      result = CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt8Type, valuePtr);
      if (!(_DWORD)result)
        return result;
      *((_BYTE *)a1 + 136) = valuePtr[0];
      v24 = 16;
      if (!*((_BYTE *)a1 + 122))
        v24 = 24;
      if (LODWORD(a1[v24]) != 255)
        (*(void (**)(uint64_t *))(*a1 + 448))(a1);
      return 1;
    case 12:
      v71 = 0.0;
      if (!v11)
        return 0;
      result = CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, &v71);
      if (!(_DWORD)result)
        return result;
      *(_OWORD *)valuePtr = xmmword_2310BDC14;
      *(_OWORD *)&valuePtr[16] = unk_2310BDC24;
      *(_OWORD *)v73 = xmmword_2310BDC34;
      *(_OWORD *)&v73[16] = unk_2310BDC44;
      (*(void (**)(_BYTE *__return_ptr, uint64_t *))(*a1 + 168))(valuePtr, a1);
      v25 = v71;
      *(float *)&valuePtr[12] = v25;
      goto LABEL_124;
    case 13:
      v71 = 0.0;
      if (!v11)
        return 0;
      result = CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, &v71);
      if (!(_DWORD)result)
        return result;
      *(_OWORD *)valuePtr = xmmword_2310BDC14;
      *(_OWORD *)&valuePtr[16] = unk_2310BDC24;
      *(_OWORD *)v73 = xmmword_2310BDC34;
      *(_OWORD *)&v73[16] = unk_2310BDC44;
      (*(void (**)(_BYTE *__return_ptr, uint64_t *))(*a1 + 168))(valuePtr, a1);
      v26 = v71;
      *(float *)&valuePtr[16] = v26;
      goto LABEL_124;
    case 14:
      v71 = 0.0;
      if (!v11)
        return 0;
      result = CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, &v71);
      if (!(_DWORD)result)
        return result;
      *(_OWORD *)valuePtr = xmmword_2310BDC14;
      *(_OWORD *)&valuePtr[16] = unk_2310BDC24;
      *(_OWORD *)v73 = xmmword_2310BDC34;
      *(_OWORD *)&v73[16] = unk_2310BDC44;
      (*(void (**)(_BYTE *__return_ptr, uint64_t *))(*a1 + 168))(valuePtr, a1);
      v27 = v71;
      *(float *)&valuePtr[20] = v27;
LABEL_124:
      (*(void (**)(uint64_t *, _BYTE *))(*a1 + 176))(a1, valuePtr);
      return 1;
    case 18:
      result = 0;
      LOWORD(v71) = 0;
      if (!v11)
        return result;
      result = CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt16Type, &v71);
      if (!(_DWORD)result)
        return result;
      v28 = *((_DWORD *)a1 + 32);
      v29 = LOWORD(v71);
      *((_DWORD *)a1 + 32) = LOWORD(v71);
      if (v28 != 255 && (_DWORD)v29 == 255)
      {
        v30 = *(void (**)(uint64_t *, uint64_t, uint64_t))(*a1 + 408);
        v31 = a1;
        v29 = 0;
LABEL_96:
        v53 = 0;
        goto LABEL_104;
      }
      if (v28 == 255 && (_DWORD)v29 != 255)
      {
        v30 = *(void (**)(uint64_t *, uint64_t, uint64_t))(*a1 + 408);
        v31 = a1;
        v29 = 2;
        goto LABEL_96;
      }
      v53 = *((unsigned __int16 *)a1 + 66);
      v30 = *(void (**)(uint64_t *, uint64_t, uint64_t))(*a1 + 432);
      v31 = a1;
LABEL_104:
      v30(v31, v29, v53);
      v56 = MTLoggingPlugin();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
      {
        v57 = *((_DWORD *)a1 + 32);
        *(_DWORD *)valuePtr = 136316162;
        *(_QWORD *)&valuePtr[4] = "";
        *(_WORD *)&valuePtr[12] = 2080;
        *(_QWORD *)&valuePtr[14] = "MTSimpleHIDManager::";
        *(_WORD *)&valuePtr[22] = 2080;
        *(_QWORD *)&valuePtr[24] = "setPropertyInternal";
        *(_WORD *)v73 = 1024;
        *(_DWORD *)&v73[2] = v28;
        *(_WORD *)&v73[6] = 1024;
        *(_DWORD *)&v73[8] = v57;
        _os_log_impl(&dword_231071000, v56, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s detection mode: %d->%d\n", valuePtr, 0x2Cu);
      }
      return 1;
    case 20:
      v32 = (CFTypeRef)*MEMORY[0x24BDBD270] == cf && v9;
      if (!v32 || *((_DWORD *)a1 + 32) == 255)
        return 0;
      v33 = MTLoggingPlugin();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)valuePtr = 136315650;
        *(_QWORD *)&valuePtr[4] = "";
        *(_WORD *)&valuePtr[12] = 2080;
        *(_QWORD *)&valuePtr[14] = "MTSimpleHIDManager::";
        *(_WORD *)&valuePtr[22] = 2080;
        *(_QWORD *)&valuePtr[24] = "setPropertyInternal";
        _os_log_impl(&dword_231071000, v33, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Resetting prox", valuePtr, 0x20u);
      }
      (*(void (**)(uint64_t *))(*a1 + 80))(a1);
      LODWORD(v71) = MTSwapInt32HostToDevice();
      (*(void (**)(uint64_t *))(*a1 + 80))(a1);
      v34 = MTDeviceSetReport();
      if (!v34)
        return 0;
      v35 = v34;
      v36 = MTLoggingPlugin();
      if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        return 0;
      *(_DWORD *)valuePtr = 136315906;
      *(_QWORD *)&valuePtr[4] = "[Error] ";
      *(_WORD *)&valuePtr[12] = 2080;
      *(_QWORD *)&valuePtr[14] = "MTSimpleHIDManager::";
      *(_WORD *)&valuePtr[22] = 2080;
      *(_QWORD *)&valuePtr[24] = "setPropertyInternal";
      *(_WORD *)v73 = 1024;
      *(_DWORD *)&v73[2] = v35;
      v37 = "[HID] [MT] %s%s%s Error 0x%08X resetting prox";
      goto LABEL_90;
    case 21:
      if (!v9)
        return 0;
      v38 = (CFTypeRef)*MEMORY[0x24BDBD270] == cf ? 8 : 9;
      LOBYTE(v71) = v38;
      (*(void (**)(uint64_t *))(*a1 + 80))(a1);
      v39 = MTDeviceSetReport();
      if (!v39)
        return 0;
      v40 = v39;
      v36 = MTLoggingPlugin();
      if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        return 0;
      *(_DWORD *)valuePtr = 136315906;
      *(_QWORD *)&valuePtr[4] = "[Error] ";
      *(_WORD *)&valuePtr[12] = 2080;
      *(_QWORD *)&valuePtr[14] = "MTSimpleHIDManager::";
      *(_WORD *)&valuePtr[22] = 2080;
      *(_QWORD *)&valuePtr[24] = "setPropertyInternal";
      *(_WORD *)v73 = 1024;
      *(_DWORD *)&v73[2] = v40;
      v37 = "[HID] [MT] %s%s%s Error 0x%08x setting rHOST_EVENT_NOTIFICATION";
      goto LABEL_90;
    case 37:
      if (!v13)
        return 0;
      CFDataGetBytePtr((CFDataRef)cf);
      Length = CFDataGetLength((CFDataRef)cf);
      if (Length > 1)
      {
        (*(void (**)(uint64_t *))(*a1 + 80))(a1);
        result = MTDeviceSendExternalMessage();
        if (!(_DWORD)result)
          return result;
        v52 = result;
        v36 = MTLoggingPlugin();
        result = os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
        if (!(_DWORD)result)
          return result;
        *(_DWORD *)valuePtr = 136315906;
        *(_QWORD *)&valuePtr[4] = "[Error] ";
        *(_WORD *)&valuePtr[12] = 2080;
        *(_QWORD *)&valuePtr[14] = "MTSimpleHIDManager::";
        *(_WORD *)&valuePtr[22] = 2080;
        *(_QWORD *)&valuePtr[24] = "setPropertyInternal";
        *(_WORD *)v73 = 1024;
        *(_DWORD *)&v73[2] = v52;
        v37 = "[HID] [MT] %s%s%s Error 0x%08X sending external message";
LABEL_90:
        v43 = v36;
        v44 = 38;
      }
      else
      {
        v42 = MTLoggingPlugin();
        result = os_log_type_enabled(v42, OS_LOG_TYPE_ERROR);
        if (!(_DWORD)result)
          return result;
        *(_DWORD *)valuePtr = 136316162;
        *(_QWORD *)&valuePtr[4] = "[Error] ";
        *(_WORD *)&valuePtr[12] = 2080;
        *(_QWORD *)&valuePtr[14] = "MTSimpleHIDManager::";
        *(_WORD *)&valuePtr[22] = 2080;
        *(_QWORD *)&valuePtr[24] = "setPropertyInternal";
        *(_WORD *)v73 = 2048;
        *(_QWORD *)&v73[2] = Length;
        *(_WORD *)&v73[10] = 2048;
        *(_QWORD *)&v73[12] = 2;
        v37 = "[HID] [MT] %s%s%s Message length (%ld) is smaller than message type size (%lu)";
        v43 = v42;
        v44 = 52;
      }
      _os_log_impl(&dword_231071000, v43, OS_LOG_TYPE_ERROR, v37, valuePtr, v44);
      return 0;
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 46:
    case 47:
    case 49:
    case 51:
    case 54:
    case 55:
    case 56:
    case 57:
    case 60:
    case 61:
    case 62:
    case 63:
    case 66:
    case 67:
    case 69:
    case 81:
    case 84:
    case 85:
      return v11;
    case 43:
      result = 0;
      LOWORD(v71) = 0;
      if (!v11)
        return result;
      result = CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt16Type, &v71);
      if (!(_DWORD)result)
        return result;
      v45 = *((_DWORD *)a1 + 48);
      v46 = LOBYTE(v71);
      *((_DWORD *)a1 + 48) = LOBYTE(v71);
      if (v45 == v46 && !a4)
        return 1;
      (*(void (**)(uint64_t *))(*a1 + 80))(a1);
      if (MTDeviceSupportsTapToWake()
        && ((*(void (**)(uint64_t *))(*a1 + 80))(a1), (MTDeviceUseContextualPower() & 1) == 0))
      {
        v47 = *((_DWORD *)a1 + 48);
        if (v47 == 255)
        {
          v48 = 254;
          goto LABEL_108;
        }
      }
      else
      {
        v47 = *((_DWORD *)a1 + 48);
      }
      if (v47 != 252)
        goto LABEL_109;
      v48 = 255;
LABEL_108:
      *((_DWORD *)a1 + 48) = v48;
LABEL_109:
      (*(void (**)(uint64_t *))(*a1 + 80))(a1);
      if (MTDeviceNeedsFirstPowerOffSuppressed() && (*((_DWORD *)a1 + 48) - 253) <= 2)
      {
        (*(void (**)(uint64_t *))(*a1 + 80))(a1);
        PowerOffSuppressed = MTDeviceNotifyFirstPowerOffSuppressed();
        v59 = MTLoggingPlugin();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)valuePtr = 136315906;
          *(_QWORD *)&valuePtr[4] = "";
          *(_WORD *)&valuePtr[12] = 2080;
          *(_QWORD *)&valuePtr[14] = "MTSimpleHIDManager::";
          *(_WORD *)&valuePtr[22] = 2080;
          *(_QWORD *)&valuePtr[24] = "setPropertyInternal";
          *(_WORD *)v73 = 1024;
          *(_DWORD *)&v73[2] = PowerOffSuppressed;
          _os_log_impl(&dword_231071000, v59, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Suppressed first power off on boot - driver notified: 0x%x\n", valuePtr, 0x26u);
        }
        result = 0;
        *((_DWORD *)a1 + 48) = v45;
        return result;
      }
      v60 = LOWORD(v71) & 0x100;
      v61 = a1[14];
      if (v61)
      {
        (*(void (**)(uint64_t, _QWORD, BOOL))(*(_QWORD *)v61 + 16))(v61, *((unsigned int *)a1 + 48), v60 != 0);
      }
      else
      {
        (*(void (**)(uint64_t *))(*a1 + 80))(a1);
        v62 = MTDevicePowerControlSupported();
        v63 = *((_DWORD *)a1 + 48);
        if (v62)
        {
          if ((v63 - 253) >= 2)
          {
            if (v63 == 255)
            {
              (*(void (**)(uint64_t *, _QWORD, _QWORD))(*a1 + 408))(a1, 0, 0);
            }
            else
            {
              (*(void (**)(uint64_t *, uint64_t, BOOL))(*a1 + 416))(a1, 2, v60 != 0);
              if (v45 == 255 || *((_BYTE *)a1 + 80))
              {
                v68 = MTLoggingPlugin();
                if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
                {
                  v69 = *((_DWORD *)a1 + 48);
                  v70 = *((_DWORD *)a1 + 33);
                  *(_DWORD *)valuePtr = 136316162;
                  *(_QWORD *)&valuePtr[4] = "";
                  *(_WORD *)&valuePtr[12] = 2080;
                  *(_QWORD *)&valuePtr[14] = "MTSimpleHIDManager::";
                  *(_WORD *)&valuePtr[22] = 2080;
                  *(_QWORD *)&valuePtr[24] = "setPropertyInternal";
                  *(_WORD *)v73 = 1024;
                  *(_DWORD *)&v73[2] = v69;
                  *(_WORD *)&v73[6] = 1024;
                  *(_DWORD *)&v73[8] = v70;
                  _os_log_impl(&dword_231071000, v68, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Skip sending touch mode %d, orientation %d. Device not on", valuePtr, 0x2Cu);
                }
              }
              else
              {
                (*(void (**)(uint64_t *, _QWORD, _QWORD))(*a1 + 464))(a1, *((unsigned __int16 *)a1 + 96), *((unsigned __int16 *)a1 + 66));
              }
            }
          }
          else
          {
            (*(void (**)(uint64_t *, _QWORD, _QWORD))(*a1 + 464))(a1, (unsigned __int16)*((_DWORD *)a1 + 48), *((unsigned __int16 *)a1 + 66));
            (*(void (**)(uint64_t *, uint64_t, BOOL))(*a1 + 416))(a1, 1, v60 != 0);
          }
        }
        else
        {
          (*(void (**)(uint64_t *, _QWORD, _QWORD))(*a1 + 464))(a1, (unsigned __int16)*((_DWORD *)a1 + 48), *((unsigned __int16 *)a1 + 66));
        }
        v64 = MTLoggingPlugin();
        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
        {
          v65 = *((_DWORD *)a1 + 48);
          *(_DWORD *)valuePtr = 136316418;
          *(_QWORD *)&valuePtr[4] = "";
          *(_WORD *)&valuePtr[12] = 2080;
          *(_QWORD *)&valuePtr[14] = "MTSimpleHIDManager::";
          *(_WORD *)&valuePtr[22] = 2080;
          *(_QWORD *)&valuePtr[24] = "setPropertyInternal";
          *(_WORD *)v73 = 1024;
          *(_DWORD *)&v73[2] = v45;
          *(_WORD *)&v73[6] = 1024;
          *(_DWORD *)&v73[8] = v65;
          *(_WORD *)&v73[12] = 1024;
          *(_DWORD *)&v73[14] = v60 >> 8;
          _os_log_impl(&dword_231071000, v64, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s touch mode: %d->%d fromButton=%d\n", valuePtr, 0x32u);
        }
      }
      if (*((_DWORD *)a1 + 39) == 4)
      {
        valuePtr[0] = *((_DWORD *)a1 + 48);
        mach_absolute_time();
        VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
        if (VendorDefinedEvent)
        {
          v67 = (const void *)VendorDefinedEvent;
          (*(void (**)(uint64_t *, uint64_t, _QWORD))(*a1 + 136))(a1, VendorDefinedEvent, 0);
          CFRelease(v67);
        }
      }
      return 1;
    case 44:
    case 45:
    case 59:
    case 64:
    case 65:
    case 68:
    case 78:
      return v15;
    case 48:
    case 50:
    case 76:
      return v17;
    case 52:
    case 53:
      return v13;
    case 58:
      LODWORD(result) = v9;
      return v19 | result;
    case 71:
      return v19 | result;
    case 72:
      if (!v9)
        return 0;
      v49 = CFBooleanGetValue((CFBooleanRef)cf) != 0;
      (*(void (**)(uint64_t, _BOOL8))(*(_QWORD *)a1[4] + 72))(a1[4], v49);
      return 1;
    case 75:
      result = 0;
      *(_DWORD *)valuePtr = 0;
      if (!v11)
        return result;
      Value = CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, valuePtr);
      result = 0;
      if (!Value || *(_DWORD *)valuePtr > 1u)
        return result;
      v51 = a1[14];
      if (v51)
        *(_DWORD *)(v51 + 32) = *(_DWORD *)valuePtr;
      return 1;
    case 86:
      if (!v9)
        return 0;
      (*(void (**)(uint64_t *))(*a1 + 80))(a1);
      MTDeviceSetBinaryFiltersProperty();
      return 1;
    default:
      return result;
  }
}

void MTSimpleHIDManager::setFieldDetectionStatus(dispatch_object_t *this)
{
  NSObject *v2;
  NSObject *v3;
  _QWORD block[5];

  if (*((_DWORD *)this + 41))
  {
    dispatch_retain(this[22]);
    dispatch_retain(this[23]);
    v3 = this[22];
    v2 = this[23];
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 0x40000000;
    block[2] = ___ZN18MTSimpleHIDManager23setFieldDetectionStatusEv_block_invoke;
    block[3] = &__block_descriptor_tmp_184;
    block[4] = this;
    dispatch_group_async(v2, v3, block);
  }
}

uint64_t MTSimpleHIDManager::setPowerState(uint64_t a1, unsigned int a2, int a3)
{
  NSObject *v6;
  const char *v7;
  uint64_t v8;
  NSObject *v9;
  int v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 112))
    MTSimpleHIDManager::setPowerState();
  v6 = MTLoggingPlugin();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 2)
      v7 = "<UNKNOWN>";
    else
      v7 = off_24FFF1C08[a2];
    v11 = 136316418;
    v12 = "";
    v13 = 2080;
    v14 = "MTSimpleHIDManager::";
    v15 = 2080;
    v16 = "setPowerState";
    v17 = 1024;
    v18 = a2;
    v19 = 2082;
    v20 = v7;
    v21 = 1024;
    v22 = a3;
    _os_log_impl(&dword_231071000, v6, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s [powerState:%d(%{public}s), deferUntilBootload:%d]", (uint8_t *)&v11, 0x36u);
  }
  if (a3)
  {
    v8 = 0;
    *(_BYTE *)(a1 + 80) = 1;
    *(_DWORD *)(a1 + 84) = a2;
  }
  else
  {
    *(_BYTE *)(a1 + 80) = 0;
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 80))(a1);
    v8 = MTDevicePowerSetState();
    v9 = MTLoggingPlugin();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v11 = 136315906;
      v12 = "";
      v13 = 2080;
      v14 = "MTSimpleHIDManager::";
      v15 = 2080;
      v16 = "setPowerState";
      v17 = 1024;
      v18 = v8;
      _os_log_impl(&dword_231071000, v9, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s MTDevicePowerSetState result: 0x%x", (uint8_t *)&v11, 0x26u);
    }
  }
  return v8;
}

uint64_t MTSimpleHIDManager::setOrientation(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  return MTDeviceSetReport();
}

uint64_t MTSimpleEmbeddedHIDManager::resetDevice(MTEmbeddedStatsImpl ****this)
{
  unsigned int v2;
  uint64_t v3;
  NSObject *v4;
  int v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  int v15;
  _DWORD __b[130];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  MTParser::deviceWillReset(this[26]);
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v32 = 0u;
  v31 = 0u;
  v30 = 0u;
  v29 = 0u;
  v28 = 0u;
  v27 = 0u;
  v26 = 0u;
  v25 = 0u;
  v24 = 0u;
  v23 = 0u;
  v22 = 0u;
  v21 = 0u;
  v20 = 0u;
  v19 = 0u;
  v18 = 0u;
  v17 = 0u;
  __b[129] = 1;
  memset(__b, 170, 0x204uLL);
  ((void (*)(MTEmbeddedStatsImpl ****))(*this)[10])(this);
  v2 = MTDeviceIssueDriverRequest();
  if (v2)
    v3 = v2;
  else
    v3 = __b[0];
  v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136316162;
    v7 = "";
    v8 = 2080;
    v9 = "";
    v10 = 2080;
    v11 = "resetDevice";
    v12 = 1024;
    v13 = v3;
    v14 = 1024;
    v15 = __b[0];
    _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s [result:0x%08x, requestResult.status:0x%08x]", (uint8_t *)&v6, 0x2Cu);
  }
  return v3;
}

uint64_t MTSimpleHIDManager::setProperty(MTSimpleHIDManager *this, const __CFString *a2, const void *a3, uint64_t a4)
{
  const __CFString *v8;
  const void *v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeID v12;
  uint64_t Value;
  int v14;
  NSObject *v15;
  CFNumberRef v16;
  CFNumberRef v17;
  int v19;
  unsigned __int16 valuePtr;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  if (MTSimpleHIDManager::propertyTypeFromString((uint64_t)a2, a2) == 18 && !*((_BYTE *)this + 122))
  {
    valuePtr = -21846;
    if (a3)
    {
      v12 = CFGetTypeID(a3);
      if (v12 == CFNumberGetTypeID())
      {
        Value = CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt16Type, &valuePtr);
        if ((_DWORD)Value)
        {
          v14 = MTSimpleHIDManager::translateInputDetectionMode(Value, valuePtr);
          v19 = v14;
          v15 = MTLoggingPlugin();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            v22 = "";
            v23 = 2080;
            v24 = "MTSimpleHIDManager::";
            v25 = 2080;
            v26 = "setProperty";
            v27 = 1024;
            v28 = valuePtr;
            v29 = 1024;
            v30 = v14;
            _os_log_impl(&dword_231071000, v15, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Converting input detection mode (%d) to touch mode (%d) because prox is absent", buf, 0x2Cu);
          }
          v16 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberSInt16Type, &v19);
          if (v16)
          {
            v17 = v16;
            v11 = (*(uint64_t (**)(MTSimpleHIDManager *, const __CFString *, CFNumberRef, uint64_t))(*(_QWORD *)this + 392))(this, CFSTR("TouchDetectionMode"), v16, a4);
            CFRelease(v17);
            return v11;
          }
          return 0;
        }
      }
    }
  }
  if (a3)
  {
    if (a2)
    {
      if (!(_DWORD)a4)
      {
        v9 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), a2);
        if (v9)
        {
          if (CFEqual(v9, a3))
            return 0;
        }
      }
    }
  }
  v10 = MTSimpleHIDManager::propertyTypeFromString((uint64_t)a2, v8);
  if (!(*(unsigned int (**)(MTSimpleHIDManager *, uint64_t, const void *, uint64_t))(*(_QWORD *)this + 400))(this, v10, a3, a4))return 0;
  CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 5), a2, a3);
  return 1;
}

uint64_t MTSimpleHIDManager::setProperty(CFDateFormatterRef *this, const __CFString *a2, const void *a3)
{
  const __CFAllocator *v6;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v8;
  CFTimeZoneRef v9;
  CFTimeZoneRef v10;
  __CFDateFormatter *v11;
  CFAbsoluteTime Current;
  CFStringRef StringWithAbsoluteTime;
  CFStringRef v14;

  if ((*((unsigned int (**)(CFDateFormatterRef *))*this + 59))(this))
  {
    v6 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 3, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (Mutable)
    {
      v8 = Mutable;
      if (this[9])
      {
        v9 = CFTimeZoneCopySystem();
        if (v9)
        {
          v10 = v9;
          CFDateFormatterSetProperty(this[9], (CFStringRef)*MEMORY[0x24BDBD340], v9);
          CFRelease(v10);
        }
        v11 = this[9];
        Current = CFAbsoluteTimeGetCurrent();
        StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(v6, v11, Current);
        if (StringWithAbsoluteTime)
        {
          v14 = StringWithAbsoluteTime;
          CFDictionarySetValue(v8, CFSTR("set time"), StringWithAbsoluteTime);
          CFDictionarySetValue(v8, CFSTR("key"), a2);
          CFDictionarySetValue(v8, CFSTR("value"), a3);
          CFArrayAppendValue(this[6], v8);
          while (CFArrayGetCount(this[6]) > *((unsigned __int16 *)this + 28))
            CFArrayRemoveValueAtIndex(this[6], 0);
          CFRelease(v14);
        }
      }
      CFRelease(v8);
    }
  }
  return (*((uint64_t (**)(CFDateFormatterRef *, const __CFString *, const void *, _QWORD))*this + 49))(this, a2, a3, 0);
}

uint64_t MTEmbeddedStatsImpl::updateOpenRows(MTEmbeddedStatsImpl *this)
{
  int OpenRows;
  int v3;
  NSObject *v4;
  uint64_t v5;
  NSObject *v7;
  const char *v8;
  NSObject *v9;
  os_log_type_t v10;
  uint32_t v11;
  NSObject *v12;
  uint8_t buf[4];
  _BYTE v14[18];
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  OpenRows = MTDeviceGetOpenRows();
  if (OpenRows == -536870201)
  {
    MTDeviceGetDeviceID();
    v7 = MTLoggingPlugin();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)v14 = 0;
      v8 = "Skipping open rows logging: not supported (deviceID 0x%llX)";
      v9 = v7;
      v10 = OS_LOG_TYPE_DEBUG;
      v11 = 12;
LABEL_10:
      _os_log_impl(&dword_231071000, v9, v10, v8, buf, v11);
    }
    return 0;
  }
  v3 = OpenRows;
  if (OpenRows)
  {
    MTDeviceGetDeviceID();
    v12 = MTLoggingPlugin();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)v14 = v3;
      *(_WORD *)&v14[4] = 2048;
      *(_QWORD *)&v14[6] = 0;
      v8 = "Couldn't read open rows: error 0x%08X (deviceID 0x%llX)";
      v9 = v12;
      v10 = OS_LOG_TYPE_ERROR;
      v11 = 18;
      goto LABEL_10;
    }
    return 0;
  }
  MTDeviceGetDeviceID();
  v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    v5 = *((_QWORD *)this + 262);
    *(_DWORD *)buf = 134218496;
    *(_QWORD *)v14 = 0;
    *(_WORD *)&v14[8] = 2048;
    *(_QWORD *)&v14[10] = v5;
    v15 = 2048;
    v16 = 0;
    _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_DEBUG, "Open rows collected: current 0x%016llX, previous 0x%016llX (deviceID 0x%llX)", buf, 0x20u);
  }
  *((_QWORD *)this + 262) = *((_QWORD *)this + 262);
  return 1;
}

void MTSimpleEventDispatcher::dispatchEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int Type;
  const __CFArray *Children;
  CFIndex Count;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t HIDService;
  NSObject *v15;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  uint64_t IntegerValue;
  __int16 v20;
  _BYTE v21[14];
  __int16 v22;
  _BOOL4 v23;
  __int16 v24;
  _BOOL4 v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  if (a2 && *(_QWORD *)(a1 + 24) && *(_QWORD *)(a1 + 16))
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
    MTDeviceGetDeviceID();
    Type = IOHIDEventGetType();
    Children = (const __CFArray *)IOHIDEventGetChildren();
    if (Children)
      Count = CFArrayGetCount(Children);
    else
      Count = 0;
    if (Type == 11 && ((IOHIDEventGetIntegerValue() & 2) != 0 || (IOHIDEventGetIntegerValue() & 0x80) != 0))
    {
      MTDeviceGetDeviceID();
      v9 = MTLoggingPlugin();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134219520;
        v17 = Count;
        v18 = 2048;
        IntegerValue = IOHIDEventGetIntegerValue();
        v20 = 2048;
        *(_QWORD *)v21 = IOHIDEventGetIntegerValue();
        *(_WORD *)&v21[8] = 1024;
        *(_DWORD *)&v21[10] = (IOHIDEventGetIntegerValue() >> 7) & 1;
        v22 = 1024;
        v23 = IOHIDEventGetIntegerValue() == 1;
        v24 = 1024;
        v25 = IOHIDEventGetIntegerValue() == 1;
        v26 = 2048;
        v27 = 0;
        _os_log_impl(&dword_231071000, v9, OS_LOG_TYPE_DEFAULT, "Dispatching event with %ld children, _eventMask=0x%lx _childEventMask=0x%lx Cancel=%d Touching=%d inRange=%d (deviceID 0x%llX)", buf, 0x3Cu);
      }
    }
    v10 = mach_continuous_time();
    v11 = *(_QWORD *)(a1 + 32);
    v12 = *(_QWORD *)(a1 + 40);
    v13 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24);
    HIDService = MTSimpleHIDManager::getHIDService(*(MultitouchHIDClass ***)(a1 + 16));
    v13(v11, v12, HIDService, a2, a3);
    v15 = MTLoggingPlugin();
    if (os_signpost_enabled(v15))
    {
      *(_DWORD *)buf = 134349824;
      v17 = v10;
      v18 = 2048;
      IntegerValue = 0;
      v20 = 1024;
      *(_DWORD *)v21 = Type;
      *(_WORD *)&v21[4] = 2048;
      *(_QWORD *)&v21[6] = Count;
      _os_signpost_emit_with_name_impl(&dword_231071000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Multitouch Event Dispatch", "%{public, signpost.description:begin_time}llu mtDeviceID=%llu eventType=%u children=%lu", buf, 0x26u);
    }
  }
}

uint64_t MultitouchHIDClass::_copyProperty(MultitouchHIDClass *this, void *a2, const __CFString *a3)
{
  return (*(uint64_t (**)(_QWORD, void *))(**((_QWORD **)this + 1) + 80))(*((_QWORD *)this + 1), a2);
}

uint64_t MTSimpleHIDManager::handleNotificationEvent(unsigned __int8 *a1, uint64_t a2, int a3)
{
  uint64_t v4;
  int v5;
  NSObject *v6;
  const char *v7;
  const __CFAllocator *v8;
  uint64_t VendorDefinedEvent;
  const void *v10;
  io_registry_entry_t Service;
  CFTypeRef CFProperty;
  const void *v13;
  CFTypeID v14;
  CFTypeID TypeID;
  const void *v16;
  uint64_t v18;
  const void *v19;
  const void *Subscription;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  const void *v24;
  const void *v25;
  uint64_t v26;
  const void *v27;
  _BYTE buf[12];
  __int16 v30;
  const char *v31;
  __int16 v32;
  const char *v33;
  uint64_t v34;

  v4 = 0;
  v34 = *MEMORY[0x24BDAC8D0];
  if (a3 <= 102)
  {
    switch(a3)
    {
      case 2:
LABEL_14:
        v4 = 1;
        (*(void (**)(unsigned __int8 *, uint64_t))(*(_QWORD *)a1 + 592))(a1, 1);
        return v4;
      case 3:
      case 4:
      case 7:
        return v4;
      case 5:
        (*(void (**)(unsigned __int8 *))(*(_QWORD *)a1 + 264))(a1);
        v8 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
        mach_absolute_time();
        VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
        if (VendorDefinedEvent)
        {
          v10 = (const void *)VendorDefinedEvent;
          (*(void (**)(unsigned __int8 *, uint64_t, _QWORD))(*(_QWORD *)a1 + 136))(a1, VendorDefinedEvent, 0);
          CFRelease(v10);
        }
        (*(void (**)(unsigned __int8 *))(*(_QWORD *)a1 + 80))(a1);
        Service = MTDeviceGetService();
        *(_QWORD *)buf = 0;
        CFProperty = IORegistryEntryCreateCFProperty(Service, CFSTR("QueryIOReporterOnBoot"), v8, 0);
        if (CFProperty)
        {
          v13 = CFProperty;
          v14 = CFGetTypeID(CFProperty);
          TypeID = CFBooleanGetTypeID();
          v16 = (const void *)*MEMORY[0x24BDBD270];
          CFRelease(v13);
          if (v14 == TypeID && v13 == v16)
          {
            v18 = IOReportCopyChannelsForDriver();
            if (v18)
            {
              v19 = (const void *)v18;
              if (IOReportGetChannelCount()
                && (IOReportPrune() & 1) == 0
                && IOReportGetChannelCount())
              {
                Subscription = (const void *)IOReportCreateSubscription();
              }
              else
              {
                Subscription = 0;
              }
              CFRelease(v19);
              if (Subscription)
                CFRelease(Subscription);
            }
          }
        }
        return 1;
      case 6:
        v21 = MTLoggingPlugin();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "";
          v30 = 2080;
          v31 = "MTSimpleHIDManager::";
          v32 = 2080;
          v33 = "handleNotificationEvent";
          _os_log_impl(&dword_231071000, v21, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s device killed", buf, 0x20u);
        }
        return 1;
      case 8:
        v22 = 128;
        if (!a1[122])
          v22 = 192;
        if (*(_DWORD *)&a1[v22] != 255)
          (*(void (**)(unsigned __int8 *, uint64_t))(*(_QWORD *)a1 + 592))(a1, 1);
        mach_absolute_time();
        v4 = 1;
        v23 = IOHIDEventCreateVendorDefinedEvent();
        if (!v23)
          return v4;
        v24 = (const void *)v23;
        (*(void (**)(unsigned __int8 *, uint64_t, _QWORD))(*(_QWORD *)a1 + 136))(a1, v23, 0);
        v25 = v24;
        break;
      default:
        switch(a3)
        {
          case 26:
            v5 = (*(uint64_t (**)(unsigned __int8 *))(*(_QWORD *)a1 + 344))(a1);
            if (a1[121] == v5)
              return 1;
            a1[121] = v5;
            if (!v5)
              return 1;
            goto LABEL_14;
          case 32:
            mach_absolute_time();
            v26 = IOHIDEventCreateVendorDefinedEvent();
            if (v26)
              goto LABEL_47;
            return 1;
          case 33:
            if (!a1[123])
              return 0;
            v4 = 1;
            a1[124] = 1;
            (*(void (**)(unsigned __int8 *, const __CFString *, _QWORD))(*(_QWORD *)a1 + 568))(a1, CFSTR("FilteredClientsAvailable"), *MEMORY[0x24BDBD270]);
            if (!a1[125])
            {
              a1[125] = 1;
              (*(void (**)(unsigned __int8 *))(*(_QWORD *)a1 + 80))(a1);
              MTRegisterFullFrameCallback();
            }
            return v4;
          case 34:
            if (!a1[123])
              return 0;
            a1[124] = 0;
            (*(void (**)(unsigned __int8 *, const __CFString *, _QWORD))(*(_QWORD *)a1 + 568))(a1, CFSTR("FilteredClientsAvailable"), *MEMORY[0x24BDBD268]);
            if (a1[125])
            {
              a1[125] = 0;
              (*(void (**)(unsigned __int8 *))(*(_QWORD *)a1 + 80))(a1);
              MTUnregisterFullFrameCallback();
            }
            break;
          default:
            return v4;
        }
        return 1;
    }
LABEL_48:
    CFRelease(v25);
    return 1;
  }
  if (a3 > 331)
  {
    if (a3 == 332)
    {
      (*(void (**)(unsigned __int8 *))(*(_QWORD *)a1 + 272))(a1);
      return 1;
    }
    if (a3 == 333)
    {
      a1[127] = 1;
      v6 = MTLoggingPlugin();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "";
        v30 = 2080;
        v31 = "MTSimpleHIDManager::";
        v32 = 2080;
        v33 = "handleNotificationEvent";
        v7 = "[HID] [MT] %s%s%s Sending Touch System Ready notification";
        goto LABEL_42;
      }
LABEL_43:
      mach_absolute_time();
      v26 = IOHIDEventCreateVendorDefinedEvent();
      if (!v26)
        return 1;
LABEL_47:
      v27 = (const void *)v26;
      (*(void (**)(unsigned __int8 *, uint64_t, _QWORD))(*(_QWORD *)a1 + 136))(a1, v26, 0);
      v25 = v27;
      goto LABEL_48;
    }
  }
  else
  {
    if (a3 == 103)
    {
      (*(void (**)(unsigned __int8 *, uint64_t))(*(_QWORD *)a1 + 592))(a1, 1);
      a1[127] = 0;
      v6 = MTLoggingPlugin();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "";
        v30 = 2080;
        v31 = "MTSimpleHIDManager::";
        v32 = 2080;
        v33 = "handleNotificationEvent";
        v7 = "[HID] [MT] %s%s%s Touch System Ready = false";
        goto LABEL_42;
      }
      goto LABEL_43;
    }
    if (a3 == 104)
    {
      v4 = 1;
      (*(void (**)(unsigned __int8 *, uint64_t))(*(_QWORD *)a1 + 592))(a1, 1);
      (*(void (**)(unsigned __int8 *))(*(_QWORD *)a1 + 80))(a1);
      if ((MTDeviceSupportsTouchReadyNotification() & 1) == 0)
      {
        a1[127] = 1;
        v6 = MTLoggingPlugin();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "";
          v30 = 2080;
          v31 = "MTSimpleHIDManager::";
          v32 = 2080;
          v33 = "handleNotificationEvent";
          v7 = "[HID] [MT] %s%s%s Sending Touch System Ready notification on UI Unlock";
LABEL_42:
          _os_log_impl(&dword_231071000, v6, OS_LOG_TYPE_DEFAULT, v7, buf, 0x20u);
          goto LABEL_43;
        }
        goto LABEL_43;
      }
    }
  }
  return v4;
}

uint64_t MTLoggingPlugin()
{
  if (MTLoggingPlugin_onceToken != -1)
    dispatch_once(&MTLoggingPlugin_onceToken, &__block_literal_global_4);
  return MTLoggingPlugin___logObj;
}

uint64_t MTSimpleHIDManager::shouldRecordProperty(MTSimpleHIDManager *this, const __CFString *a2)
{
  return 1;
}

uint64_t MTSimpleHIDManager::getMTDevice(MTSimpleHIDManager *this)
{
  return *((_QWORD *)this + 3);
}

uint64_t MTSimpleHIDManager::propertyTypeFromString(uint64_t this, const __CFString *a2)
{
  const __CFString *v2;

  if (this)
  {
    v2 = (const __CFString *)this;
    if (CFStringCompare((CFStringRef)this, CFSTR("PrimaryUsagePage"), 0))
    {
      if (CFStringCompare(v2, CFSTR("PrimaryUsage"), 0))
      {
        if (CFStringCompare(v2, CFSTR("PrintHIDEvents"), 0))
        {
          if (CFStringCompare(v2, CFSTR("GraphicsOrientation"), 0))
          {
            if (CFStringCompare(v2, CFSTR("TouchHand"), 0))
            {
              if (CFStringCompare(v2, CFSTR("WristState"), 0))
              {
                if (CFStringCompare(v2, CFSTR("EllipseTipGain"), 0))
                {
                  if (CFStringCompare(v2, CFSTR("FingerTipOffsetUpwards"), 0))
                  {
                    if (CFStringCompare(v2, CFSTR("FingerTipOffsetLeftwards"), 0))
                    {
                      if (CFStringCompare(v2, CFSTR("HysteresisRadiusPixels"), 0))
                      {
                        if (CFStringCompare(v2, CFSTR("CrownFilterRect"), 0))
                        {
                          if (CFStringCompare(v2, CFSTR("InputDetectionMode"), 0))
                          {
                            if (CFStringCompare(v2, CFSTR("CriticalErrors"), 0))
                            {
                              if (CFStringCompare(v2, CFSTR("QuantizationDPI"), 0))
                              {
                                if (CFStringCompare(v2, CFSTR("ReceiverProximityReset"), 0))
                                {
                                  if (CFStringCompare(v2, CFSTR("MuonEnabled"), 0))
                                  {
                                    if (CFStringCompare(v2, CFSTR("NotificationCenterGestureMode"), 0))
                                    {
                                      if (CFStringCompare(v2, CFSTR("NotificationCenterAltGestureMode"), 0))
                                      {
                                        if (CFStringCompare(v2, CFSTR("DeviceUsagePairs"), 0))
                                        {
                                          if (CFStringCompare(v2, CFSTR("Built-In"), 0))
                                          {
                                            if (CFStringCompare(v2, CFSTR("DisplayIntegrated"), 0))
                                            {
                                              if (CFStringCompare(v2, CFSTR("PhysicalDeviceUniqueID"), 0))
                                              {
                                                if (CFStringCompare(v2, CFSTR("DeviceIsReady"), 0))
                                                {
                                                  if (CFStringCompare(v2, CFSTR("MotionActivityInterested"), 0))
                                                  {
                                                    if (CFStringCompare(v2, CFSTR("MotionActivityDispatch"), 0))
                                                    {
                                                      if (CFStringCompare(v2, CFSTR("CopyAllProperties"), 0))
                                                      {
                                                        if (CFStringCompare(v2, CFSTR("AppKitActuateWithID"), 0))
                                                        {
                                                          if (CFStringCompare(v2, CFSTR("MTGestureConfiguration"), 0))
                                                          {
                                                            if (CFStringCompare(v2, CFSTR("MTGestureConfigurationOverride"), 0))
                                                            {
                                                              if (CFStringCompare(v2, CFSTR("ReloadActuations"), 0))
                                                              {
                                                                if (CFStringCompare(v2, CFSTR("SendClickThresholdInfo"), 0))
                                                                {
                                                                  if (CFStringCompare(v2, CFSTR("DisableClickWaveformAdaptation"), 0))
                                                                  {
                                                                    if (CFStringCompare(v2, CFSTR("DisableForceThresholdAdaptation"), 0))
                                                                    {
                                                                      if (CFStringCompare(v2, CFSTR("FlipLeftAndRightEdgeGestures"), 0))
                                                                      {
                                                                        if (CFStringCompare(v2, CFSTR("ScrollMomentumDispatchRate"), 0))
                                                                        {
                                                                          if (CFStringCompare(v2, CFSTR("ExternalMessage"), 0))
                                                                          {
                                                                            if (CFStringCompare(v2, CFSTR("MaxDigitizerPressureValue"), 0))
                                                                            {
                                                                              if (CFStringCompare(v2, CFSTR("MinDigitizerPressureValue"), 0))
                                                                              {
                                                                                if (CFStringCompare(v2, CFSTR("AccurateMaxDigitizerPressureValue"), 0))
                                                                                {
                                                                                  if (CFStringCompare(v2, CFSTR("ExtendedMaxDigitizerPressureValue"), 0))
                                                                                  {
                                                                                    if (CFStringCompare(v2, CFSTR("DigitizerPressureDynamicRange"), 0))
                                                                                    {
                                                                                      if (CFStringCompare(v2, CFSTR("TouchDetectionMode"), 0))
                                                                                      {
                                                                                        if (CFStringCompare(v2, CFSTR("HIDScrollAccelerationType"), 0))
                                                                                        {
                                                                                          if (CFStringCompare(v2, CFSTR("HIDPointerAccelerationType"), 0))
                                                                                          {
                                                                                            if (CFStringCompare(v2, CFSTR("HIDAccelCurves"), 0))
                                                                                            {
                                                                                              if (CFStringCompare(v2, CFSTR("HIDPointerReportRate"), 0))
                                                                                              {
                                                                                                if (CFStringCompare(v2, CFSTR("HIDScrollAccelCurves"), 0))
                                                                                                {
                                                                                                  if (CFStringCompare(v2, CFSTR("HIDScrollResolution"), 0))
                                                                                                  {
                                                                                                    if (CFStringCompare(v2, CFSTR("HIDScrollAccelerationTable"), 0))
                                                                                                    {
                                                                                                      if (CFStringCompare(v2, CFSTR("HIDPointerAccelerationTable"), 0))
                                                                                                      {
                                                                                                        if (CFStringCompare(v2, CFSTR("HIDPointerResolution"), 0))
                                                                                                        {
                                                                                                          if (CFStringCompare(v2, CFSTR("HIDPointerAccelerationTargetRateUs"), 0))
                                                                                                          {
                                                                                                            if (CFStringCompare(v2, CFSTR("HIDTrackpadAcceleration"), 0))
                                                                                                            {
                                                                                                              if (CFStringCompare(v2, CFSTR("HIDTrackpadScrollAcceleration"), 0))
                                                                                                              {
                                                                                                                if (CFStringCompare(v2, CFSTR("HIDMouseScrollAcceleration"), 0))
                                                                                                                {
                                                                                                                  if (CFStringCompare(v2, CFSTR("HIDDisallowRemappingOfPrimaryClick"), 0))
                                                                                                                  {
                                                                                                                    if (CFStringCompare(v2, CFSTR("SupportsGestureScrolling"), 0))
                                                                                                                    {
                                                                                                                      if (CFStringCompare(v2, CFSTR("MTEventSource"), 0))
                                                                                                                      {
                                                                                                                        if (CFStringCompare(v2, CFSTR("Transport"), 0))
                                                                                                                        {
                                                                                                                          if (CFStringCompare(v2, CFSTR("VendorID"), 0))
                                                                                                                          {
                                                                                                                            if (CFStringCompare(v2, CFSTR("VendorIDSource"), 0))
                                                                                                                            {
                                                                                                                              if (CFStringCompare(v2, CFSTR("ProductID"), 0))
                                                                                                                              {
                                                                                                                                if (CFStringCompare(v2, CFSTR("VersionNumber"), 0))
                                                                                                                                {
                                                                                                                                  if (CFStringCompare(v2, CFSTR("Manufacturer"), 0))
                                                                                                                                  {
                                                                                                                                    if (CFStringCompare(v2, CFSTR("Product"), 0))
                                                                                                                                    {
                                                                                                                                      if (CFStringCompare(v2, CFSTR("LocationID"), 0))
                                                                                                                                      {
                                                                                                                                        if (CFStringCompare(v2, CFSTR("CountryCode"), 0))
                                                                                                                                        {
                                                                                                                                          if (CFStringCompare(v2, CFSTR("SerialNumber"), 0))
                                                                                                                                          {
                                                                                                                                            if (CFStringCompare(v2, CFSTR("ReportInterval"), 0))
                                                                                                                                            {
                                                                                                                                              if (CFStringCompare(v2, CFSTR("DispatchAllHIDEvents"), 0))
                                                                                                                                              {
                                                                                                                                                if (CFStringCompare(v2, CFSTR("ServicePluginDebug"), 0))
                                                                                                                                                {
                                                                                                                                                  if (CFStringCompare(v2, CFSTR("FilteredClientsAvailable"), 0))
                                                                                                                                                  {
                                                                                                                                                    if (CFStringCompare(v2, CFSTR("MTModeSwitcherDebugProfile"), 0))
                                                                                                                                                    {
                                                                                                                                                      if (CFStringCompare(v2, CFSTR("SupportedGestures"), 0))
                                                                                                                                                      {
                                                                                                                                                        if (CFStringCompare(v2, CFSTR("SurfaceDimensions"), 0))
                                                                                                                                                        {
                                                                                                                                                          if (CFStringCompare(v2, CFSTR("DeviceTypeHint"), 0))
                                                                                                                                                          {
                                                                                                                                                            if (CFStringCompare(v2, CFSTR("NeedsHostState"), 0))
                                                                                                                                                            {
                                                                                                                                                              if (CFStringCompare(v2, CFSTR("HostStateNotification"), 0))
                                                                                                                                                              {
                                                                                                                                                                if (CFStringCompare(v2, CFSTR("HIDPointerAccelerationMultiplier"), 0))
                                                                                                                                                                {
                                                                                                                                                                  if (CFStringCompare(v2, CFSTR("DeviceOpenedByEventSystem"), 0))
                                                                                                                                                                  {
                                                                                                                                                                    if (CFStringCompare(v2, CFSTR("MouseButtonMode"), 0))
                                                                                                                                                                    {
                                                                                                                                                                      if (CFStringCompare(v2, CFSTR("HIDScrollReportRate"), 0))
                                                                                                                                                                      {
                                                                                                                                                                        if (CFStringCompare(v2, CFSTR("MaxHoverHeight"), 0))
                                                                                                                                                                        {
                                                                                                                                                                          if (CFStringCompare(v2, CFSTR("HoverDisabled"), 0))
                                                                                                                                                                            return 0;
                                                                                                                                                                          else
                                                                                                                                                                            return 86;
                                                                                                                                                                        }
                                                                                                                                                                        else
                                                                                                                                                                        {
                                                                                                                                                                          return 85;
                                                                                                                                                                        }
                                                                                                                                                                      }
                                                                                                                                                                      else
                                                                                                                                                                      {
                                                                                                                                                                        return 84;
                                                                                                                                                                      }
                                                                                                                                                                    }
                                                                                                                                                                    else
                                                                                                                                                                    {
                                                                                                                                                                      return 83;
                                                                                                                                                                    }
                                                                                                                                                                  }
                                                                                                                                                                  else
                                                                                                                                                                  {
                                                                                                                                                                    return 82;
                                                                                                                                                                  }
                                                                                                                                                                }
                                                                                                                                                                else
                                                                                                                                                                {
                                                                                                                                                                  return 81;
                                                                                                                                                                }
                                                                                                                                                              }
                                                                                                                                                              else
                                                                                                                                                              {
                                                                                                                                                                return 80;
                                                                                                                                                              }
                                                                                                                                                            }
                                                                                                                                                            else
                                                                                                                                                            {
                                                                                                                                                              return 79;
                                                                                                                                                            }
                                                                                                                                                          }
                                                                                                                                                          else
                                                                                                                                                          {
                                                                                                                                                            return 78;
                                                                                                                                                          }
                                                                                                                                                        }
                                                                                                                                                        else
                                                                                                                                                        {
                                                                                                                                                          return 77;
                                                                                                                                                        }
                                                                                                                                                      }
                                                                                                                                                      else
                                                                                                                                                      {
                                                                                                                                                        return 76;
                                                                                                                                                      }
                                                                                                                                                    }
                                                                                                                                                    else
                                                                                                                                                    {
                                                                                                                                                      return 75;
                                                                                                                                                    }
                                                                                                                                                  }
                                                                                                                                                  else
                                                                                                                                                  {
                                                                                                                                                    return 74;
                                                                                                                                                  }
                                                                                                                                                }
                                                                                                                                                else
                                                                                                                                                {
                                                                                                                                                  return 73;
                                                                                                                                                }
                                                                                                                                              }
                                                                                                                                              else
                                                                                                                                              {
                                                                                                                                                return 72;
                                                                                                                                              }
                                                                                                                                            }
                                                                                                                                            else
                                                                                                                                            {
                                                                                                                                              return 69;
                                                                                                                                            }
                                                                                                                                          }
                                                                                                                                          else
                                                                                                                                          {
                                                                                                                                            return 68;
                                                                                                                                          }
                                                                                                                                        }
                                                                                                                                        else
                                                                                                                                        {
                                                                                                                                          return 67;
                                                                                                                                        }
                                                                                                                                      }
                                                                                                                                      else
                                                                                                                                      {
                                                                                                                                        return 66;
                                                                                                                                      }
                                                                                                                                    }
                                                                                                                                    else
                                                                                                                                    {
                                                                                                                                      return 65;
                                                                                                                                    }
                                                                                                                                  }
                                                                                                                                  else
                                                                                                                                  {
                                                                                                                                    return 64;
                                                                                                                                  }
                                                                                                                                }
                                                                                                                                else
                                                                                                                                {
                                                                                                                                  return 63;
                                                                                                                                }
                                                                                                                              }
                                                                                                                              else
                                                                                                                              {
                                                                                                                                return 62;
                                                                                                                              }
                                                                                                                            }
                                                                                                                            else
                                                                                                                            {
                                                                                                                              return 61;
                                                                                                                            }
                                                                                                                          }
                                                                                                                          else
                                                                                                                          {
                                                                                                                            return 60;
                                                                                                                          }
                                                                                                                        }
                                                                                                                        else
                                                                                                                        {
                                                                                                                          return 59;
                                                                                                                        }
                                                                                                                      }
                                                                                                                      else
                                                                                                                      {
                                                                                                                        return 70;
                                                                                                                      }
                                                                                                                    }
                                                                                                                    else
                                                                                                                    {
                                                                                                                      return 58;
                                                                                                                    }
                                                                                                                  }
                                                                                                                  else
                                                                                                                  {
                                                                                                                    return 57;
                                                                                                                  }
                                                                                                                }
                                                                                                                else
                                                                                                                {
                                                                                                                  return 55;
                                                                                                                }
                                                                                                              }
                                                                                                              else
                                                                                                              {
                                                                                                                return 56;
                                                                                                              }
                                                                                                            }
                                                                                                            else
                                                                                                            {
                                                                                                              return 47;
                                                                                                            }
                                                                                                          }
                                                                                                          else
                                                                                                          {
                                                                                                            return 46;
                                                                                                          }
                                                                                                        }
                                                                                                        else
                                                                                                        {
                                                                                                          return 54;
                                                                                                        }
                                                                                                      }
                                                                                                      else
                                                                                                      {
                                                                                                        return 53;
                                                                                                      }
                                                                                                    }
                                                                                                    else
                                                                                                    {
                                                                                                      return 52;
                                                                                                    }
                                                                                                  }
                                                                                                  else
                                                                                                  {
                                                                                                    return 51;
                                                                                                  }
                                                                                                }
                                                                                                else
                                                                                                {
                                                                                                  return 50;
                                                                                                }
                                                                                              }
                                                                                              else
                                                                                              {
                                                                                                return 49;
                                                                                              }
                                                                                            }
                                                                                            else
                                                                                            {
                                                                                              return 48;
                                                                                            }
                                                                                          }
                                                                                          else
                                                                                          {
                                                                                            return 45;
                                                                                          }
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                          return 44;
                                                                                        }
                                                                                      }
                                                                                      else
                                                                                      {
                                                                                        return 43;
                                                                                      }
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                      return 42;
                                                                                    }
                                                                                  }
                                                                                  else
                                                                                  {
                                                                                    return 41;
                                                                                  }
                                                                                }
                                                                                else
                                                                                {
                                                                                  return 40;
                                                                                }
                                                                              }
                                                                              else
                                                                              {
                                                                                return 39;
                                                                              }
                                                                            }
                                                                            else
                                                                            {
                                                                              return 38;
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            return 37;
                                                                          }
                                                                        }
                                                                        else
                                                                        {
                                                                          return 17;
                                                                        }
                                                                      }
                                                                      else
                                                                      {
                                                                        return 34;
                                                                      }
                                                                    }
                                                                    else
                                                                    {
                                                                      return 33;
                                                                    }
                                                                  }
                                                                  else
                                                                  {
                                                                    return 32;
                                                                  }
                                                                }
                                                                else
                                                                {
                                                                  return 31;
                                                                }
                                                              }
                                                              else
                                                              {
                                                                return 30;
                                                              }
                                                            }
                                                            else
                                                            {
                                                              return 29;
                                                            }
                                                          }
                                                          else
                                                          {
                                                            return 28;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          return 27;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        return 26;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      return 36;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    return 35;
                                                  }
                                                }
                                                else
                                                {
                                                  return 25;
                                                }
                                              }
                                              else
                                              {
                                                return 6;
                                              }
                                            }
                                            else
                                            {
                                              return 5;
                                            }
                                          }
                                          else
                                          {
                                            return 4;
                                          }
                                        }
                                        else
                                        {
                                          return 3;
                                        }
                                      }
                                      else
                                      {
                                        return 23;
                                      }
                                    }
                                    else
                                    {
                                      return 22;
                                    }
                                  }
                                  else
                                  {
                                    return 21;
                                  }
                                }
                                else
                                {
                                  return 20;
                                }
                              }
                              else
                              {
                                return 19;
                              }
                            }
                            else
                            {
                              return 24;
                            }
                          }
                          else
                          {
                            return 18;
                          }
                        }
                        else
                        {
                          return 16;
                        }
                      }
                      else
                      {
                        return 15;
                      }
                    }
                    else
                    {
                      return 14;
                    }
                  }
                  else
                  {
                    return 13;
                  }
                }
                else
                {
                  return 12;
                }
              }
              else
              {
                return 11;
              }
            }
            else
            {
              return 10;
            }
          }
          else
          {
            return 9;
          }
        }
        else
        {
          return 7;
        }
      }
      else
      {
        return 2;
      }
    }
    else
    {
      return 1;
    }
  }
  return this;
}

uint64_t MTSimpleEmbeddedHIDManager::setPropertyInternal(uint64_t *a1, int a2, CFTypeRef cf, int a4)
{
  CFTypeID v8;
  _BOOL4 v9;
  MTParser *v10;
  unint64_t v11;
  double v12;
  float v13;
  double v15;
  int valuePtr;

  if (cf)
  {
    v8 = CFGetTypeID(cf);
    v9 = v8 == CFNumberGetTypeID();
  }
  else
  {
    v9 = 0;
  }
  if (a2 == 15)
  {
    v15 = 0.0;
    if (v9 && CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, &v15))
    {
      v13 = v15;
      *(float *)(*(_QWORD *)(a1[26] + 64) + 104) = v13;
      return 1;
    }
  }
  else if (a2 == 19)
  {
    valuePtr = 0;
    if (v9)
    {
      if (CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, &valuePtr))
      {
        if ((*(uint64_t (**)(uint64_t *))(*a1 + 624))(a1))
        {
          v10 = (MTParser *)(*(uint64_t (**)(uint64_t *))(*a1 + 624))(a1);
          LODWORD(v11) = valuePtr;
          v12 = 25.4 / (double)v11;
          *(float *)&v12 = v12;
          MTParser::updatePixelResolution_mm(v10, v12);
        }
        return 1;
      }
    }
  }
  return MTSimpleHIDManager::setPropertyInternal(a1, a2, cf, a4);
}

uint64_t MTSimpleEventDispatcher::handleEvent(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  a1[7] = a2;
  result = (*(uint64_t (**)(_QWORD *))(*a1 + 32))(a1);
  if ((_DWORD)result)
    result = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t))(*a1 + 40))(a1, a2, a3);
  a1[7] = 0;
  return result;
}

void MTPathStates::clear(MTPathStates *this)
{
  MTPathStatesBasic::clear(this);
  if ((*((_DWORD *)this + 6) - 1000) <= 0xBB7)
  {
    *((_WORD *)this + 186) = 0;
    *((_DWORD *)this + 107) = 0;
    *((_BYTE *)this + 444) = 0;
    *((_BYTE *)this + 492) = 0;
    *((_DWORD *)this + 102) = 0;
    *(_OWORD *)((char *)this + 376) = 0u;
    *(_OWORD *)((char *)this + 392) = 0u;
    *((_QWORD *)this + 52) = 0;
    *((_BYTE *)this + 424) = 0;
    *((_OWORD *)this + 28) = 0u;
    *((_OWORD *)this + 29) = 0u;
    *((_QWORD *)this + 60) = 0;
    *((_DWORD *)this + 122) = 0;
    *((_QWORD *)this + 63) = 0;
    *((_QWORD *)this + 64) = 0;
    *((_QWORD *)this + 62) = 0x7FF0000000000000;
    MTRestZoneIntegrator::clear((float32x2_t *)this + 65);
  }
  *((_DWORD *)this + 92) = 0;
}

uint64_t MTPathStatesBasic::unpackContactFrame(double *a1, uint64_t a2, uint64_t a3, double a4)
{
  uint64_t v7;

  v7 = *((_QWORD *)a1 + 1);
  a1[1] = a4;
  *((_QWORD *)a1 + 2) = v7;
  MTPathStatesBasic::clearExistingPathLiftoffsAndMasks((MTPathStatesBasic *)a1);
  if (a2)
    MTPathStatesBasic::expandAndFilterPackedContacts((uint64_t)a1, a2, a3);
  return MTPathStatesBasic::flushStuckContacts((MTPathStatesBasic *)a1);
}

uint64_t MTForceManagerLite::clearState(uint64_t this)
{
  *(_BYTE *)(this + 1) = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  return this;
}

uint64_t MTParser::clear(_QWORD *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  MTHandStatistics *v9;
  MTHandMotion *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  MTEmbeddedStats *v14;
  uint64_t v15;
  uint64_t ChordTableForHand;

  v7 = a1[6];
  if (v7)
  {
    MTAbsoluteTimeGetCurrent();
    *(_QWORD *)(v7 + 40) = v8;
  }
  if (a2 && a3)
    MTParser::handleContactFrame((uint64_t)a1, 0, 0, 0.0, a4, a2, a3, 0);
  v9 = (MTHandStatistics *)a1[6];
  if (v9)
    MTHandStatistics::clear(v9, 0);
  v10 = (MTHandMotion *)a1[7];
  if (v10)
    MTHandMotion::clear(v10);
  v11 = a1[8];
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 16))(v11);
  v12 = a1[25];
  if (v12)
    MTForceManagement::clearState(v12, 0);
  v13 = a1[27];
  if (v13)
    MTForceManagerLite::clearState(v13);
  v14 = (MTEmbeddedStats *)a1[28];
  if (v14)
    MTEmbeddedStats::resetTouchState(v14);
  v15 = a1[9];
  if (v15)
  {
    ChordTableForHand = MTGestureConfig::getChordTableForHand(v15, 1);
    if (ChordTableForHand)
      (*(void (**)(uint64_t))(*(_QWORD *)ChordTableForHand + 16))(ChordTableForHand);
  }
  return MTTapDragManager::clearState((uint64_t)(a1 + 10));
}

uint64_t MTSimpleHIDManager::setPowerStateWithReset(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v6;
  const char *v7;
  NSObject *v8;
  double v10;
  BOOL v11;
  unsigned int ResetOnLockMs;
  double v13;
  double v14;
  double v15;
  BOOL v16;
  NSObject *v17;
  NSObject *v18;
  const char *v20;
  uint64_t v21;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  _BYTE v29[14];
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 112))
    MTSimpleHIDManager::setPowerStateWithReset();
  v6 = MTLoggingPlugin();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 2)
      v7 = "<UNKNOWN>";
    else
      v7 = off_24FFF1C08[(int)a2];
    *(_DWORD *)buf = 136316418;
    v23 = "";
    v24 = 2080;
    v25 = "MTSimpleHIDManager::";
    v26 = 2080;
    v27 = "setPowerStateWithReset";
    v28 = 1024;
    *(_DWORD *)v29 = a2;
    *(_WORD *)&v29[4] = 2082;
    *(_QWORD *)&v29[6] = v7;
    v30 = 1024;
    v31 = a3;
    _os_log_impl(&dword_231071000, v6, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s [powerState:%d(%{public}s), triggeredFromButton:%d]", buf, 0x36u);
  }
  if ((_DWORD)a2 != 1
    || ((*(void (**)(uint64_t))(*(_QWORD *)a1 + 80))(a1), MTDevicePowerGetState() | 0xAAAAAAAA))
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 80))(a1);
    v10 = *(double *)(a1 + 64);
    if (MTDeviceShouldResetOnButton())
      v11 = a3 == 0;
    else
      v11 = 0;
    if (v11
      || ((_DWORD)a2 != 2
        ? (ResetOnLockMs = MTDeviceGetResetOnLockMs())
        : (ResetOnLockMs = MTDeviceGetResetOnUnlockMs()),
          (v13 = (double)ResetOnLockMs / 1000.0, MTAbsoluteTimeGetCurrent(), v15 = v14 - v10, v13 > 0.0)
        ? (v16 = v15 <= v13)
        : (v16 = 1),
          v16))
    {
      v17 = MTLoggingPlugin();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v23 = "";
        v24 = 2080;
        v25 = "MTSimpleHIDManager::";
        v26 = 2080;
        v27 = "setPowerStateWithReset";
        _os_log_impl(&dword_231071000, v17, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Setting device power without reset", buf, 0x20u);
      }
      return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 408))(a1, a2, 0);
    }
    else
    {
      v18 = MTLoggingPlugin();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        if (a2 > 2)
          v20 = "<UNKNOWN>";
        else
          v20 = off_24FFF1C08[(int)a2];
        *(_DWORD *)buf = 136315906;
        v23 = "";
        v24 = 2080;
        v25 = "MTSimpleHIDManager::";
        v26 = 2080;
        v27 = "setPowerStateWithReset";
        v28 = 2082;
        *(_QWORD *)v29 = v20;
        _os_log_impl(&dword_231071000, v18, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Resetting device before setting power state to %{public}s", buf, 0x2Au);
      }
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 480))(a1, 30);
      MTAbsoluteTimeGetCurrent();
      *(_QWORD *)(a1 + 64) = v21;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 408))(a1, a2, 1);
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 424))(a1);
    }
  }
  else
  {
    v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v23 = "";
      v24 = 2080;
      v25 = "MTSimpleHIDManager::";
      v26 = 2080;
      v27 = "setPowerStateWithReset";
      _os_log_impl(&dword_231071000, v8, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Turning on and waiting for the device to be ready before going to sleep.", buf, 0x20u);
    }
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 408))(a1, 2, 0);
  }
}

uint64_t MTParser::deviceWillReset(MTEmbeddedStatsImpl ***this)
{
  return MTEmbeddedStats::deviceWillReset(this[28]);
}

uint64_t MTSimpleHIDManager::restoreDevicePropertiesToDevice(MTSimpleHIDManager *this)
{
  const __CFString *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  uint64_t result;

  if (*((_BYTE *)this + 122))
    v2 = CFSTR("InputDetectionMode");
  else
    v2 = CFSTR("TouchDetectionMode");
  v3 = (const void *)(*(uint64_t (**)(MTSimpleHIDManager *, const __CFString *))(*(_QWORD *)this + 560))(this, v2);
  (*(void (**)(MTSimpleHIDManager *, const __CFString *, const void *, uint64_t))(*(_QWORD *)this + 392))(this, v2, v3, 1);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)(*(uint64_t (**)(MTSimpleHIDManager *, const __CFString *))(*(_QWORD *)this + 560))(this, CFSTR("GraphicsOrientation"));
  (*(void (**)(MTSimpleHIDManager *, const __CFString *, const void *, uint64_t))(*(_QWORD *)this + 392))(this, CFSTR("GraphicsOrientation"), v4, 1);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)(*(uint64_t (**)(MTSimpleHIDManager *, const __CFString *))(*(_QWORD *)this + 560))(this, CFSTR("WristState"));
  (*(void (**)(MTSimpleHIDManager *, const __CFString *, const void *, uint64_t))(*(_QWORD *)this + 392))(this, CFSTR("WristState"), v5, 1);
  if (v5)
    CFRelease(v5);
  result = (*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 368))(this);
  if ((*((_BYTE *)this + 160) & 0x20) != 0)
    return (*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 352))(this);
  return result;
}

uint64_t MTSimpleHIDManager::setTouchMode(MTSimpleHIDManager *this, int a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  NSObject *v10;
  uint8_t buf[4];
  int v13;
  __int16 v14;
  int v15;
  __int16 v16;
  char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  v6 = MTDeviceSetTouchMode();
  v7 = v6;
  if ((_DWORD)v6 != -536870201 && (_DWORD)v6 != 0)
  {
    (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
    MTDeviceGetDeviceID();
    v10 = MTLoggingPlugin();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67110146;
      v13 = a2;
      v14 = 1024;
      v15 = a3;
      v16 = 2082;
      v17 = mach_error_string(v7);
      v18 = 1024;
      v19 = v7;
      v20 = 2048;
      v21 = 0;
      _os_log_impl(&dword_231071000, v10, OS_LOG_TYPE_ERROR, "Error trying to set mode to 0x%x and orientation to 0x%x: %{public}s (0x%x) (deviceID 0x%llX)", buf, 0x28u);
    }
  }
  return v7;
}

uint64_t MTSimpleHIDManager::deviceDidBootload(MTSimpleHIDManager *this)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t result;
  uint8_t buf[4];
  const char *v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  MTDeviceGetDeviceID();
  v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    v8 = 0;
    _os_log_impl(&dword_231071000, v2, OS_LOG_TYPE_DEFAULT, "device bootloaded (deviceID 0x%llX)", buf, 0xCu);
  }
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 488))(this);
  (*(void (**)(MTSimpleHIDManager *, uint64_t))(*(_QWORD *)this + 592))(this, 1);
  *((_QWORD *)this + 18) = 0;
  *((_BYTE *)this + 152) = 0;
  MTAbsoluteTimeGetCurrent();
  *((_QWORD *)this + 8) = v3;
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 304))(this);
  v4 = *((_QWORD *)this + 14);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 32))(v4);
  }
  else if (*((_BYTE *)this + 80))
  {
    (*(void (**)(MTSimpleHIDManager *, _QWORD, _QWORD))(*(_QWORD *)this + 408))(this, *((unsigned int *)this + 21), 0);
  }
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  if ((MTDeviceDriverIsReady() & 1) == 0)
  {
    v5 = MTLoggingPlugin();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v8 = "";
      v9 = 2080;
      v10 = "MTSimpleHIDManager::";
      v11 = 2080;
      v12 = "deviceDidBootload";
      _os_log_impl(&dword_231071000, v5, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Driver is still not ready", buf, 0x20u);
    }
  }
  result = (*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 328))(this);
  if ((result & 1) == 0)
  {
    (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
    result = MTDeviceDriverIsReady();
    if ((_DWORD)result)
      return (*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 320))(this);
  }
  return result;
}

__n128 MTSimpleEmbeddedHIDManager::copyTipOffsetParameters@<Q0>(MTSimpleEmbeddedHIDManager *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  __int128 v3;
  __n128 result;
  __int128 v5;

  v2 = *(_QWORD *)(*((_QWORD *)this + 26) + 64);
  v3 = *(_OWORD *)(v2 + 196);
  *(_OWORD *)a2 = *(_OWORD *)(v2 + 180);
  *(_OWORD *)(a2 + 16) = v3;
  result = *(__n128 *)(v2 + 212);
  v5 = *(_OWORD *)(v2 + 228);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v5;
  return result;
}

MTInterferenceMonitor *MTSimpleEmbeddedHIDManager::deviceDidBootload(MTInterferenceMonitor **this)
{
  MTInterferenceMonitor *result;

  MTSimpleHIDManager::deviceDidBootload((MTSimpleHIDManager *)this);
  result = this[27];
  if (result)
    return (MTInterferenceMonitor *)MTInterferenceMonitor::restoreStateToDevice(result);
  return result;
}

CFDictionaryRef MTSimpleEmbeddedHIDManager::copyProperty(CFDictionaryRef *this, const __CFString *a2)
{
  double valuePtr;

  if (MTSimpleHIDManager::propertyTypeFromString((uint64_t)a2, a2) != 15)
    return MTSimpleHIDManager::copyProperty(this, a2);
  valuePtr = *(float *)(*((_QWORD *)this[26] + 8) + 104);
  return CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberDoubleType, &valuePtr);
}

uint64_t MTSimpleHIDManager::dispatchEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFArray *Children;
  uint64_t v7;

  IOHIDEventGetIntegerValue();
  IOHIDEventGetIntegerValue();
  IOHIDEventGetIntegerValue();
  IOHIDEventGetIntegerValue();
  Children = (const __CFArray *)IOHIDEventGetChildren();
  if (Children)
    CFArrayGetCount(Children);
  IOHIDEventGetIntegerValue();
  kdebug_trace();
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 96))(v7, a2, a3);
  return kdebug_trace();
}

void ___ZN15MTEmbeddedStats15resetTouchStateEv_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  bzero((void *)(v1 + 24), 0x800uLL);
  *(_WORD *)(v1 + 16) = 0;
}

void MTSimpleEmbeddedHIDManager::resetGestureParser(MTSimpleEmbeddedHIDManager *this, int a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *v6;
  CFTypeRef v7;
  CFTypeRef cf;

  if (a2)
  {
    v7 = 0;
    cf = 0;
    v5 = (_QWORD *)*((_QWORD *)this + 26);
    if (v5)
    {
      MTParser::clear(v5, (uint64_t)&cf, (uint64_t *)&v7, a4);
      if (cf)
      {
        (*(void (**)(MTSimpleEmbeddedHIDManager *, CFTypeRef, _QWORD))(*(_QWORD *)this + 136))(this, cf, 0);
        CFRelease(cf);
      }
      if (v7)
      {
        (*(void (**)(MTSimpleEmbeddedHIDManager *, CFTypeRef, _QWORD))(*(_QWORD *)this + 136))(this, v7, 0);
        CFRelease(v7);
      }
    }
  }
  else
  {
    v6 = (_QWORD *)*((_QWORD *)this + 26);
    if (v6)
      MTParser::clear(v6, 0, 0, a4);
  }
}

void MTParser::handleContactFrame(uint64_t a1, uint64_t a2, uint64_t a3, double a4, uint64_t a5, uint64_t a6, uint64_t *a7, double *a8)
{
  uint64_t v15;
  char hasTriggeredFluidDock;
  MTChordCycling *ChordTableForHand;
  MTChordCycling *v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  double v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int CommittedFingerCount;
  uint64_t v28;
  MTForceManagement *v29;
  _BOOL4 isForceButtonActivated;
  uint64_t v31;
  char v32;
  int v33;
  int v34;
  int ActiveDegreesOfFreedomMask;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  float v40;
  uint64_t HIDCollectionEventsForHand;
  BOOL v42;
  char v43;
  MTForceManagerLite *v44;
  uint64_t v45;
  uint8_t buf[4];
  uint64_t v47;
  __int16 v48;
  uint64_t *v49;
  __int16 v50;
  uint64_t v51;
  __int16 v52;
  uint64_t v53;
  __int16 v54;
  uint64_t v55;
  __int16 v56;
  uint64_t v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  if (!a6 || !a7 || !*(_QWORD *)(a1 + 64) || !*(_QWORD *)(a1 + 56) || !*(_QWORD *)(a1 + 48))
  {
    MTDeviceGetDeviceID();
    v19 = MTLoggingPlugin();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      v21 = *(_QWORD *)(a1 + 56);
      v20 = *(_QWORD *)(a1 + 64);
      v22 = *(_QWORD *)(a1 + 48);
      *(_DWORD *)buf = 134219264;
      v47 = a6;
      v48 = 2048;
      v49 = a7;
      v50 = 2048;
      v51 = v20;
      v52 = 2048;
      v53 = v21;
      v54 = 2048;
      v55 = v22;
      v56 = 2048;
      v57 = 0;
      _os_log_impl(&dword_231071000, v19, OS_LOG_TYPE_DEBUG, "[HID] Aborting handling : %p %p %p %p %p (deviceID 0x%llX)", buf, 0x3Eu);
    }
LABEL_12:
    v23 = 0.0;
    if (!a8)
      return;
    goto LABEL_13;
  }
  v15 = *(_QWORD *)(a1 + 72);
  if (v15)
  {
    hasTriggeredFluidDock = 1;
    ChordTableForHand = (MTChordCycling *)MTGestureConfig::getChordTableForHand(v15, 1);
    v18 = ChordTableForHand;
    if (*(int *)(a1 + 104) <= 2)
    {
      if (ChordTableForHand)
        hasTriggeredFluidDock = MTChordCycling::hasTriggeredFluidDock(ChordTableForHand);
      else
        hasTriggeredFluidDock = 0;
    }
  }
  else
  {
    v18 = 0;
    hasTriggeredFluidDock = *(_DWORD *)(a1 + 104) > 2;
  }
  v24 = *(_QWORD *)(a1 + 64);
  if ((*(_DWORD *)(a1 + 32) - 1000) <= 0xBB7)
  {
    if (v18)
    {
      *(_DWORD *)(v24 + 416) = MTChordTable::getMinThumbSpecificFingerCount(v18);
      v25 = *(_QWORD *)(a1 + 64);
      *(_BYTE *)(v25 + 412) = MTChordTable::hasTwoFingerOrientationEvents(v18);
      v26 = *(_QWORD *)(a1 + 64);
      CommittedFingerCount = MTChordCycling::getCommittedFingerCount(v18);
      v24 = *(_QWORD *)(a1 + 64);
    }
    else
    {
      CommittedFingerCount = 0;
      *(_DWORD *)(v24 + 416) = 0;
      *(_BYTE *)(v24 + 412) = 1;
      v26 = v24;
    }
    *(_DWORD *)(v26 + 420) = CommittedFingerCount;
  }
  v28 = *(_QWORD *)(a1 + 48);
  if (v28)
    LODWORD(v28) = (__PAIR64__(*(unsigned __int8 *)(v28 + 186), *(unsigned __int8 *)(v28 + 195))
                  - *(unsigned __int8 *)(v28 + 186)) >> 32;
  *(_DWORD *)(v24 + 368) = v28;
  v29 = *(MTForceManagement **)(a1 + 200);
  if (v29)
  {
    isForceButtonActivated = MTForceManagement::isForceButtonActivated(v29);
    MTPathStates::updateDragDisplacements_mm((MTPathStates *)v24, isForceButtonActivated);
    v31 = *(_QWORD *)(a1 + 200);
    if (v18)
      v32 = MTChordCycling::shouldBlockClicks(v18, *(const MTHandStatistics **)(a1 + 48), *(const MTHandMotion **)(a1 + 56)) ^ 1;
    else
      v32 = 1;
    *(_BYTE *)(v31 + 592) = v32;
    v24 = *(_QWORD *)(a1 + 64);
  }
  v33 = MTPathStatesBasic::unpackContactFrame((double *)v24, a2, a3, a4);
  if (a2)
    v34 = 0;
  else
    v34 = v33;
  if (!MTHandStatistics::processHandState(*(MTHandStatistics **)(a1 + 48), *(MTPathStates **)(a1 + 64), v34, hasTriggeredFluidDock))goto LABEL_51;
  if (v18)
    ActiveDegreesOfFreedomMask = MTChordIntegrating::getActiveDegreesOfFreedomMask((MTChordCycling *)((char *)v18 + 408), *(const MTHandStatistics **)(a1 + 48), v18);
  else
    ActiveDegreesOfFreedomMask = 0;
  v36 = *(_QWORD *)(a1 + 48);
  v37 = *(unsigned __int8 *)(v36 + 191);
  if ((*(_BYTE *)(v36 + 168) & 0x20) != 0)
  {
    v37 += *(unsigned __int8 *)(v36 + 193);
    v38 = *(unsigned __int8 *)(v36 + 188) + *(unsigned __int8 *)(v36 + 186);
    v39 = *(unsigned __int8 *)(v36 + 189) + *(unsigned __int8 *)(v36 + 187);
  }
  else
  {
    v38 = *(unsigned __int8 *)(v36 + 186);
    v39 = *(unsigned __int8 *)(v36 + 187);
  }
  v40 = a4 - *(double *)(v36 + 56);
  MTHandMotion::processHandMotion(*(float32x2_t **)(a1 + 56), *(const MTPathStates **)(a1 + 64), v37, v38, v39, v40, ActiveDegreesOfFreedomMask, *(unsigned __int16 *)(v36 + 296));
  HIDCollectionEventsForHand = MTParser::createHIDCollectionEventsForHand((MTParser *)a1, *(const MTPathStates **)(a1 + 64), *(const MTHandStatistics **)(a1 + 48), *(const MTHandMotion **)(a1 + 56), *(_DWORD *)(*(_QWORD *)(a1 + 56) + 140) | *(_DWORD *)(*(_QWORD *)(a1 + 48) + 172), a4);
  *a7 = HIDCollectionEventsForHand;
  if (*(_QWORD *)(a1 + 224))
  {
    MTEmbeddedStats::handlePaths(*(MTEmbeddedStats **)(a1 + 224), *(const MTPathStates **)(a1 + 64));
    HIDCollectionEventsForHand = *a7;
  }
  if (v18 && HIDCollectionEventsForHand)
  {
    if (a2)
      v42 = 0;
    else
      v42 = (int)a3 < 1;
    v43 = v42;
    MTParser::handleForceHIDEvents(a1, a7, v43);
    (*(void (**)(MTChordCycling *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)v18 + 32))(v18, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *a7);
    if (*(int *)(a1 + 104) >= 1
      && *(unsigned __int8 *)(*(_QWORD *)(a1 + 48) + 211)
       + *(unsigned __int8 *)(*(_QWORD *)(a1 + 48) + 186) <= *(unsigned __int8 *)(a1 + 128))
    {
      goto LABEL_60;
    }
LABEL_51:
    HIDCollectionEventsForHand = *a7;
  }
  if (HIDCollectionEventsForHand)
  {
    if (MTDeviceSupportsForce())
    {
      v44 = *(MTForceManagerLite **)(a1 + 216);
      if (v44)
        MTForceManagerLite::updatePaths(v44, *(const MTPathStates **)(a1 + 64));
    }
  }
  if (!*(_QWORD *)(a1 + 72))
    goto LABEL_12;
  if (*a7)
    goto LABEL_12;
  v45 = *(_QWORD *)(a1 + 48);
  if (*(_BYTE *)(v45 + 186))
  {
    if (*(unsigned __int8 *)(v45 + 211) + *(unsigned __int8 *)(v45 + 186) > *(unsigned __int8 *)(a1 + 128))
      goto LABEL_12;
  }
LABEL_60:
  if (a8)
  {
    v23 = MTParser::autoReleaseTapAndAHalfDrag((MTParser *)a1, a7, a4);
LABEL_13:
    *a8 = v23;
  }
}

void MTHandMotion::clearHandMotion(MTHandMotion *this, int a2)
{
  char v2;
  NSObject *v8;

  v2 = a2;
  if (a2)
  {
    *((_DWORD *)this + 61) = 0;
    *((_DWORD *)this + 62) = 0;
    *((_OWORD *)this + 10) = 0u;
    *((_OWORD *)this + 11) = 0u;
  }
  *((_DWORD *)this + 35) = 0;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_DWORD *)this + 60) = 0;
  *(_OWORD *)((char *)this + 284) = 0u;
  *(_OWORD *)((char *)this + 300) = 0u;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)((char *)this + 252) = _Q0;
  *((_DWORD *)this + 67) = 1065353216;
  __asm { FMOV            V0.2S, #1.0 }
  *((_QWORD *)this + 34) = _Q0;
  *((_BYTE *)this + 280) = 0;
  *((_DWORD *)this + 29) = 0;
  *((_BYTE *)this + 376) = 0;
  *((_QWORD *)this + 46) = 0;
  MTFingerToPathMap::clearFingerPathMappings(this);
  v8 = MTLoggingPlugin();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    MTHandMotion::clearHandMotion(v2, v8);
}

uint64_t MTForceConfigGetTypeID()
{
  uint64_t result;

  result = __kMTForceConfigTypeID;
  if (!__kMTForceConfigTypeID)
  {
    pthread_once(&__forceConfigTypeInit, (void (*)(void))__MTForceConfigRegister);
    return __kMTForceConfigTypeID;
  }
  return result;
}

uint64_t __MTForceConfigRegister()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  __kMTForceConfigTypeID = result;
  return result;
}

uint64_t MTForceConfigCreate(int a1, int a2)
{
  uint64_t Instance;
  __n128 v5;
  uint64_t v6;

  if (!__kMTForceConfigTypeID)
    pthread_once(&__forceConfigTypeInit, (void (*)(void))__MTForceConfigRegister);
  Instance = _CFRuntimeCreateInstance();
  v6 = Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 16) = 1;
    *(_DWORD *)(Instance + 20) = a2;
    *(_DWORD *)(Instance + 24) = a1;
    *(_BYTE *)(Instance + 28) = 0;
    *(_QWORD *)(Instance + 160) = 0;
    *(_QWORD *)(Instance + 168) = 0;
    _MTForceConfigGenerateDefaultParams(Instance, v5);
  }
  return v6;
}

double _MTForceConfigGenerateDefaultParams(uint64_t a1, __n128 a2)
{
  switch(*(_DWORD *)(a1 + 24))
  {
    case 1:
      *(_BYTE *)(a1 + 29) = 2;
      goto LABEL_5;
    case 2:
      *(_BYTE *)(a1 + 29) = 2;
      *(_OWORD *)(a1 + 32) = xmmword_2310BCCA0;
      a2 = (__n128)xmmword_2310BCCB0;
      goto LABEL_7;
    case 5:
    case 0x10:
      *(_BYTE *)(a1 + 29) = 3;
      *(_OWORD *)(a1 + 32) = xmmword_2310BCC70;
      *(_QWORD *)(a1 + 48) = 0x437F000043960000;
      *(_OWORD *)(a1 + 96) = xmmword_2310BCC80;
      a2.n128_u64[0] = 0x500000006;
      *(_QWORD *)(a1 + 112) = 0x500000006;
      return a2.n128_f64[0];
    case 0xA:
    case 0xC:
      *(_WORD *)(a1 + 28) = 513;
LABEL_5:
      *(_OWORD *)(a1 + 32) = xmmword_2310BCC70;
      a2 = (__n128)xmmword_2310BCC80;
LABEL_7:
      *(__n128 *)(a1 + 96) = a2;
      break;
    case 0xB:
      *(_WORD *)(a1 + 28) = 513;
      a2.n128_u64[0] = 0;
      *(_OWORD *)(a1 + 32) = xmmword_2310BCC90;
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
      break;
    case 0x11:
      *(_BYTE *)(a1 + 29) = 3;
      *(_OWORD *)(a1 + 32) = xmmword_2310BCC70;
      *(_QWORD *)(a1 + 48) = 0x437F000043960000;
      *(_OWORD *)(a1 + 96) = xmmword_2310BCC80;
      a2.n128_u64[0] = 0x500000006;
      *(_QWORD *)(a1 + 112) = 0x500000006;
      *(_BYTE *)(a1 + 169) = 1;
      break;
    default:
      return a2.n128_f64[0];
  }
  return a2.n128_f64[0];
}

uint64_t MTForceConfigGetBehavior(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t MTForceConfigGetNumStages(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 29);
}

uint64_t MTForceConfigIsContinuous(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 28);
}

uint64_t MTForceConfigSetIsContinuous(uint64_t result, char a2)
{
  *(_BYTE *)(result + 28) = a2;
  return result;
}

BOOL MTForceConfigSetActuationsForStage(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned int v3;

  v3 = *(unsigned __int8 *)(a1 + 29);
  if (v3 > a2)
    *(_QWORD *)(a1 + 8 * a2 + 96) = a3;
  return v3 > a2;
}

uint64_t MTForceConfigGetActuationsForStage(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(a1 + 8 * a2 + 96);
}

uint64_t MTForceConfigShouldSkipActivationForStage(uint64_t a1, unsigned int a2)
{
  return *(unsigned __int8 *)(a1 + a2 + 160);
}

uint64_t MTForceConfigShouldSkipReleaseForStage(uint64_t a1, unsigned int a2)
{
  return *(unsigned __int8 *)(a1 + a2 + 168);
}

float MTForceConfigGetThresholdsForStage(uint64_t a1, unsigned int a2)
{
  return *(float *)(a1 + 8 * a2 + 32);
}

double __MTForceConfigInit(_OWORD *a1)
{
  double result;

  if (a1)
  {
    result = 0.0;
    a1[9] = 0u;
    a1[10] = 0u;
    a1[7] = 0u;
    a1[8] = 0u;
    a1[5] = 0u;
    a1[6] = 0u;
    a1[3] = 0u;
    a1[4] = 0u;
    a1[1] = 0u;
    a1[2] = 0u;
  }
  return result;
}

uint64_t MultitouchHIDClass::_probe(MultitouchHIDClass *this, void *a2, const __CFDictionary *a3, unsigned int a4, int *a5)
{
  return (*(uint64_t (**)(_QWORD, void *, const __CFDictionary *))(**((_QWORD **)this + 1) + 40))(*((_QWORD *)this + 1), a2, a3);
}

uint64_t MultitouchHIDClass::_start(MultitouchHIDClass *this, void *a2, const __CFDictionary *a3)
{
  return (*(uint64_t (**)(_QWORD, void *, const __CFDictionary *))(**((_QWORD **)this + 1) + 48))(*((_QWORD *)this + 1), a2, a3);
}

uint64_t MultitouchHIDClass::_stop(MultitouchHIDClass *this, void *a2)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 56))(*((_QWORD *)this + 1));
}

uint64_t MultitouchHIDClass::_open(MultitouchHIDClass *this, void *a2)
{
  return (*(uint64_t (**)(_QWORD, void *))(**((_QWORD **)this + 1) + 64))(*((_QWORD *)this + 1), a2);
}

uint64_t MultitouchHIDClass::_close(MultitouchHIDClass *this, void *a2)
{
  return (*(uint64_t (**)(_QWORD, void *))(**((_QWORD **)this + 1) + 72))(*((_QWORD *)this + 1), a2);
}

uint64_t MultitouchHIDClass::_setEventCallback(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 96))(*(_QWORD *)(a1 + 8));
}

uint64_t MultitouchHIDClass::_scheduleWithDispatchQueue(MultitouchHIDClass *this, void *a2, dispatch_queue_s *a3)
{
  return (*(uint64_t (**)(_QWORD, void *))(**((_QWORD **)this + 1) + 104))(*((_QWORD *)this + 1), a2);
}

uint64_t MultitouchHIDClass::_unscheduleFromDispatchQueue(MultitouchHIDClass *this, void *a2, dispatch_queue_s *a3)
{
  return (*(uint64_t (**)(_QWORD, void *))(**((_QWORD **)this + 1) + 112))(*((_QWORD *)this + 1), a2);
}

uint64_t MultitouchHIDClass::_copyEvent(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 120))(*(_QWORD *)(a1 + 8));
}

uint64_t MultitouchHIDClass::_setOutputEvent(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 128))(*(_QWORD *)(a1 + 8));
}

void MultitouchHIDClass::MultitouchHIDClass(MultitouchHIDClass *this)
{
  uint64_t v1;

  MultitouchIOHIDIUnknown::MultitouchIOHIDIUnknown(this, &MultitouchHIDClass::sIOCFPlugInInterfaceV1);
  *(_QWORD *)v1 = &off_24FFF02D8;
  *(_QWORD *)(v1 + 32) = &MultitouchHIDClass::sIOHIDServiceInterface2;
  *(_QWORD *)(v1 + 40) = v1;
  *(_DWORD *)(v1 + 56) = 0;
  *(_QWORD *)(v1 + 48) = 0;
  *(_QWORD *)(v1 + 72) = 0;
  *(_QWORD *)(v1 + 80) = 0;
  *(_QWORD *)(v1 + 64) = 0;
}

{
  uint64_t v1;

  MultitouchIOHIDIUnknown::MultitouchIOHIDIUnknown(this, &MultitouchHIDClass::sIOCFPlugInInterfaceV1);
  *(_QWORD *)v1 = &off_24FFF02D8;
  *(_QWORD *)(v1 + 32) = &MultitouchHIDClass::sIOHIDServiceInterface2;
  *(_QWORD *)(v1 + 40) = v1;
  *(_DWORD *)(v1 + 56) = 0;
  *(_QWORD *)(v1 + 48) = 0;
  *(_QWORD *)(v1 + 72) = 0;
  *(_QWORD *)(v1 + 80) = 0;
  *(_QWORD *)(v1 + 64) = 0;
}

void MultitouchHIDClass::~MultitouchHIDClass(MultitouchHIDClass *this)
{
  *(_QWORD *)this = &off_24FFF02D8;
  MultitouchHIDClass::stop(this);
  MultitouchIOHIDIUnknown::~MultitouchIOHIDIUnknown(this);
}

{
  MultitouchHIDClass::~MultitouchHIDClass(this);
  JUMPOUT(0x2348D0034);
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

uint64_t MultitouchHIDClass::getHIDService(MultitouchHIDClass *this)
{
  return (uint64_t)this + 32;
}

uint64_t MultitouchHIDClass::alloc(MultitouchHIDClass *this)
{
  uint64_t v1;
  uint64_t result;

  v1 = operator new();
  MultitouchIOHIDIUnknown::MultitouchIOHIDIUnknown((MultitouchIOHIDIUnknown *)v1, &MultitouchHIDClass::sIOCFPlugInInterfaceV1);
  *(_QWORD *)v1 = &off_24FFF02D8;
  *(_QWORD *)(v1 + 32) = &MultitouchHIDClass::sIOHIDServiceInterface2;
  *(_QWORD *)(v1 + 40) = v1;
  *(_DWORD *)(v1 + 56) = 0;
  *(_QWORD *)(v1 + 48) = 0;
  *(_QWORD *)(v1 + 72) = 0;
  *(_QWORD *)(v1 + 80) = 0;
  result = v1 + 16;
  *(_QWORD *)(v1 + 64) = 0;
  return result;
}

void sub_231077084(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10A1C40B9A1DDB6);
  _Unwind_Resume(a1);
}

uint64_t MultitouchHIDClass::queryInterface(MultitouchHIDClass *this, CFUUIDBytes a2, void **a3)
{
  CFUUIDRef v5;
  const __CFAllocator *v6;
  CFUUIDRef v7;
  CFUUIDRef v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  CFUUIDRef v13;

  v5 = CFUUIDCreateFromUUIDBytes(0, a2);
  v6 = (const __CFAllocator *)*MEMORY[0x24BDBD260];
  v7 = CFUUIDGetConstantUUIDWithBytes((CFAllocatorRef)*MEMORY[0x24BDBD260], 0, 0, 0, 0, 0, 0, 0, 0, 0xC0u, 0, 0, 0, 0, 0, 0, 0x46u);
  if (CFEqual(v5, v7)
    || (v8 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu), CFEqual(v5, v8)))
  {
    v9 = (char *)this + 16;
    v10 = *(_QWORD *)this;
LABEL_4:
    *a3 = v9;
    (*(void (**)(MultitouchHIDClass *))(v10 + 24))(this);
    goto LABEL_5;
  }
  v13 = CFUUIDGetConstantUUIDWithBytes(v6, 0x6Fu, 0xE2u, 0x2Au, 0xBFu, 0x68u, 0xB9u, 0x11u, 0xDBu, 0xA7u, 0x1Fu, 0, 0x16u, 0xCBu, 0xC1u, 0x10u, 0xF7u);
  if (CFEqual(v5, v13))
  {
    v9 = (char *)this + 32;
    v10 = *(_QWORD *)this;
    goto LABEL_4;
  }
  *a3 = 0;
LABEL_5:
  if (*a3)
    v11 = 0;
  else
    v11 = 2147483652;
  CFRelease(v5);
  return v11;
}

uint64_t MultitouchHIDClass::probe(MultitouchHIDClass *this, const __CFDictionary *a2, int a3, int *a4)
{
  if (a3)
    return 0;
  else
    return 3758097090;
}

uint64_t MultitouchHIDClass::start(MultitouchHIDClass *this, const __CFDictionary *a2, io_object_t a3)
{
  int v5;
  unsigned int *v6;
  const void *v7;
  uint64_t v8;
  io_object_t v9;
  int ParserType;
  int ParserOptions;
  uint64_t Manager;
  const void *v13;
  MultitouchHIDClass *v14;
  int v15;
  _BYTE *v16;
  NSObject *v18;

  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 10) = MTDeviceCreateFromService();
  v5 = MTDeviceEnableBinaryFilters();
  if (MTDeviceStart())
  {
    v6 = (unsigned int *)*((_QWORD *)this + 6);
    if (v6)
    {
      MTSimpleHIDManager::release(v6);
      *((_QWORD *)this + 6) = 0;
    }
    v7 = (const void *)*((_QWORD *)this + 10);
    if (v7)
    {
      CFRelease(v7);
      *((_QWORD *)this + 10) = 0;
    }
    v8 = 3758097084;
    v9 = *((_DWORD *)this + 14);
    if (v9)
    {
      IOObjectRelease(v9);
      *((_DWORD *)this + 14) = 0;
    }
    return v8;
  }
  ParserType = MTDeviceGetParserType();
  ParserOptions = MTDeviceGetParserOptions();
  if (ParserType <= 999)
  {
    switch(ParserType)
    {
      case 1:
        Manager = MTSimpleEmbeddedHIDManager::createManager((uint64_t)this, *((const void **)this + 10), 1, ParserOptions);
        goto LABEL_27;
      case 2:
        Manager = MTSimpleEmbeddedHIDManagerV2::createManager((uint64_t)this, *((const void **)this + 10), 2, ParserOptions);
        goto LABEL_27;
      case 4:
        Manager = MTSimpleEmbeddedStylusHIDManager::createManager((uint64_t)this, *((const void **)this + 10), 4, ParserOptions);
        goto LABEL_27;
    }
  }
  else if (ParserType > 1999)
  {
    if (ParserType == 2000)
    {
      Manager = (uint64_t)MTMouseHIDManager::createManager((uint64_t)this, *((const void **)this + 10), 2000, ParserOptions);
      goto LABEL_27;
    }
    if (ParserType == 2001)
    {
      Manager = (uint64_t)MTMouseEmbeddedHIDManager::createManager((uint64_t)this, *((const void **)this + 10), 2001, ParserOptions);
      goto LABEL_27;
    }
  }
  else
  {
    if (ParserType == 1000)
    {
      v13 = (const void *)*((_QWORD *)this + 10);
      v14 = this;
      v15 = 1000;
LABEL_26:
      Manager = (uint64_t)MTTrackpadHIDManager::createManager((uint64_t)v14, v13, v15, ParserOptions);
      goto LABEL_27;
    }
    if (ParserType == 1001)
    {
      Manager = MTTrackpadEmbeddedHIDManager::createManager((uint64_t)this, *((const void **)this + 10), 1001, ParserOptions);
LABEL_27:
      *((_QWORD *)this + 6) = Manager;
      *((_DWORD *)this + 14) = a3;
      IOObjectRetain(a3);
      v16 = (_BYTE *)*((_QWORD *)this + 6);
      if (v16)
      {
        v16[123] = v5 == 0;
        (*(void (**)(_BYTE *))(*(_QWORD *)v16 + 528))(v16);
      }
      return 0;
    }
  }
  if ((ParserType - 3000) <= 0x3E7)
  {
    v13 = (const void *)*((_QWORD *)this + 10);
    v14 = this;
    v15 = ParserType;
    goto LABEL_26;
  }
  v8 = 3758097084;
  v18 = MTLoggingPlugin();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    MultitouchHIDClass::start(ParserType, v18);
  return v8;
}

uint64_t MultitouchHIDClass::stop(MultitouchHIDClass *this)
{
  uint64_t v2;
  NSObject *v3;
  io_object_t v4;

  v2 = *((_QWORD *)this + 6);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 536))(v2);
    MTSimpleHIDManager::release(*((unsigned int **)this + 6));
    *((_QWORD *)this + 6) = 0;
  }
  *((_QWORD *)this + 8) = 0;
  v3 = *((_QWORD *)this + 9);
  if (v3)
  {
    dispatch_release(v3);
    *((_QWORD *)this + 9) = 0;
  }
  if (*((_QWORD *)this + 10))
  {
    MTDeviceStop();
    CFRelease(*((CFTypeRef *)this + 10));
    *((_QWORD *)this + 10) = 0;
  }
  v4 = *((_DWORD *)this + 14);
  if (v4)
  {
    IOObjectRelease(v4);
    *((_DWORD *)this + 14) = 0;
  }
  return 0;
}

uint64_t MultitouchHIDClass::open(MultitouchHIDClass *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 6);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 544))(result);
  return result;
}

uint64_t MultitouchHIDClass::close(MultitouchHIDClass *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 6);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 552))(result);
  return result;
}

uint64_t MultitouchHIDClass::copyProperty(MultitouchHIDClass *this, const __CFString *a2)
{
  uint64_t result;

  result = *((_QWORD *)this + 6);
  if (result)
    return (*(uint64_t (**)(uint64_t, const __CFString *))(*(_QWORD *)result + 560))(result, a2);
  return result;
}

_QWORD *MultitouchHIDClass::setEventCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *result;

  result = *(_QWORD **)(a1 + 48);
  if (result)
    return MTSimpleHIDManager::setEventCallback((uint64_t)result, a2, a3, a4);
  return result;
}

uint64_t MultitouchHIDClass::scheduleWithDispatchQueue(uint64_t this, dispatch_queue_s *a2)
{
  uint64_t v3;
  uint64_t MultitouchDispatchSource;

  if (*(_QWORD *)(this + 48))
  {
    v3 = this;
    if (*(_QWORD *)(this + 80) && MTDeviceIsRunning() && !*(_QWORD *)(v3 + 72))
    {
      MultitouchDispatchSource = MTDeviceCreateMultitouchDispatchSource();
      *(_QWORD *)(v3 + 64) = a2;
      *(_QWORD *)(v3 + 72) = MultitouchDispatchSource;
    }
    return (*(uint64_t (**)(_QWORD, dispatch_queue_s *))(**(_QWORD **)(v3 + 48) + 576))(*(_QWORD *)(v3 + 48), a2);
  }
  return this;
}

void MultitouchHIDClass::unscheduleFromDispatchQueue(MultitouchHIDClass *this, dispatch_queue_s *a2)
{
  uint64_t v3;
  NSObject *v4;

  v3 = *((_QWORD *)this + 6);
  if (v3)
  {
    (*(void (**)(uint64_t, dispatch_queue_s *))(*(_QWORD *)v3 + 584))(v3, a2);
    v4 = *((_QWORD *)this + 9);
    if (v4)
    {
      dispatch_source_cancel(v4);
      dispatch_release(*((dispatch_object_t *)this + 9));
      *((_QWORD *)this + 9) = 0;
    }
    *((_QWORD *)this + 8) = 0;
  }
}

uint64_t MultitouchHIDClass::copyEvent(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 48);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 608))(result);
  return result;
}

uint64_t MultitouchHIDClass::setOutputEvent(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 48);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 600))(v1);
  else
    return 3758097112;
}

uint64_t IOHIDPlugInFactory(uint64_t a1, const void *a2)
{
  CFUUIDRef v4;
  const void *v5;
  CFTypeRef v6;
  void *v7;
  void *v8;
  uint64_t (*v9)(MultitouchHIDClass *);
  void *v10;
  void *v11;
  uint64_t (*v12)(MultitouchHIDClass *);
  uint64_t (*v14)(MultitouchHIDClass *);
  uint8_t buf[4];
  void *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v4 = CFUUIDGetConstantUUIDWithBytes(0, 5u, 0x16u, 0xB5u, 0x63u, 0xB1u, 0x5Bu, 0x11u, 0xDAu, 0x96u, 0xEBu, 0, 0x14u, 0x51u, 0x97u, 0x58u, 0xEFu);
  if (!CFEqual(a2, v4))
    return 0;
  if (!os_variant_allows_internal_security_policies()
    || (v5 = (const void *)IOHIDPreferencesCopyDomain(), (v6 = (id)CFMakeCollectable(v5)) == 0)
    || (v7 = (void *)v6, objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)
    || objc_msgSend(v7, "count") != 2)
  {
LABEL_19:
    v9 = 0;
    goto LABEL_20;
  }
  v8 = (void *)objc_msgSend(v7, "objectAtIndexedSubscript:", 0);
  objc_opt_class();
  v9 = 0;
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    if ((objc_msgSend(v8, "hasPrefix:", CFSTR("/System/Library")) & 1) != 0
      || objc_msgSend(v8, "hasPrefix:", CFSTR("/AppleInternal/Library")))
    {
      v10 = (void *)objc_msgSend(v7, "objectAtIndexedSubscript:", 1);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v11 = dlopen((const char *)objc_msgSend(v8, "UTF8String"), 5);
        if (v11)
        {
          v12 = (uint64_t (*)(MultitouchHIDClass *))dlsym(v11, (const char *)objc_msgSend(v10, "UTF8String"));
          if (v12)
          {
            v9 = v12;
            if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138543362;
              v16 = v7;
              _os_log_impl(&dword_231071000, MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT, "Using plugin override: %{public}@", buf, 0xCu);
            }
            goto LABEL_20;
          }
          if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
            IOHIDPlugInFactory_cold_2();
        }
        else if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
        {
          IOHIDPlugInFactory_cold_1();
        }
      }
    }
    goto LABEL_19;
  }
LABEL_20:
  v14 = MultitouchHIDClass::alloc;
  if (v9)
    v14 = v9;
  return ((uint64_t (*)(uint64_t, const void *))v14)(a1, a2);
}

void MultitouchIOHIDIUnknown::factoryAddRef(MultitouchIOHIDIUnknown *this)
{
  const __CFUUID *v2;

  if (!MultitouchIOHIDIUnknown::factoryRefCount++)
  {
    v2 = CFUUIDGetConstantUUIDWithBytes(0, 0xCu, 0xB0u, 0xFBu, 0xB9u, 0x15u, 0xEAu, 0x11u, 0xDBu, 0xA9u, 0x3Cu, 0, 0x14u, 0x51u, 0xD4u, 0x71u, 0x83u);
    CFPlugInAddInstanceForFactory(v2);
  }
}

void MultitouchIOHIDIUnknown::factoryRelease(MultitouchIOHIDIUnknown *this)
{
  int v1;
  const __CFUUID *v2;

  v1 = MultitouchIOHIDIUnknown::factoryRefCount--;
  if (MultitouchIOHIDIUnknown::factoryRefCount)
  {
    if (v1 <= 0)
      MultitouchIOHIDIUnknown::factoryRefCount = 0;
  }
  else
  {
    v2 = CFUUIDGetConstantUUIDWithBytes(0, 0xCu, 0xB0u, 0xFBu, 0xB9u, 0x15u, 0xEAu, 0x11u, 0xDBu, 0xA9u, 0x3Cu, 0, 0x14u, 0x51u, 0xD4u, 0x71u, 0x83u);
    CFPlugInRemoveInstanceForFactory(v2);
  }
}

void MultitouchIOHIDIUnknown::MultitouchIOHIDIUnknown(MultitouchIOHIDIUnknown *this, void *a2)
{
  *(_QWORD *)this = off_24FFF0388;
  *((_DWORD *)this + 2) = 1;
  *((_QWORD *)this + 2) = a2;
  *((_QWORD *)this + 3) = this;
  MultitouchIOHIDIUnknown::factoryAddRef(this);
}

void MultitouchIOHIDIUnknown::~MultitouchIOHIDIUnknown(MultitouchIOHIDIUnknown *this)
{
  *(_QWORD *)this = off_24FFF0388;
  MultitouchIOHIDIUnknown::factoryRelease(this);
}

uint64_t MultitouchIOHIDIUnknown::addRef(MultitouchIOHIDIUnknown *this)
{
  uint64_t v1;

  v1 = (*((_DWORD *)this + 2) + 1);
  *((_DWORD *)this + 2) = v1;
  return v1;
}

uint64_t MultitouchIOHIDIUnknown::release(MultitouchIOHIDIUnknown *this)
{
  int v1;
  uint64_t v2;

  v1 = *((_DWORD *)this + 2);
  v2 = (v1 - 1);
  if (v1 == 1)
  {
    *((_DWORD *)this + 2) = 0;
    (*(void (**)(MultitouchIOHIDIUnknown *))(*(_QWORD *)this + 8))(this);
  }
  else
  {
    *((_DWORD *)this + 2) = v2;
  }
  return v2;
}

uint64_t MultitouchIOHIDIUnknown::genericQueryInterface(MultitouchIOHIDIUnknown *this, void *a2, CFUUIDBytes a3, void **a4)
{
  return (*(uint64_t (**)(_QWORD, void *, _QWORD, _QWORD))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1), a2, *(_QWORD *)&a3.byte0, *(_QWORD *)&a3.byte8);
}

uint64_t MultitouchIOHIDIUnknown::genericAddRef(MultitouchIOHIDIUnknown *this, void *a2)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 24))(*((_QWORD *)this + 1));
}

uint64_t MultitouchIOHIDIUnknown::genericRelease(MultitouchIOHIDIUnknown *this, void *a2)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 32))(*((_QWORD *)this + 1));
}

void OUTLINED_FUNCTION_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

uint64_t mt_PrintHIDEvent(uint64_t result, int a2)
{
  uint64_t v3;
  const __CFArray *Children;
  int v5;
  int v6;
  int v7;
  int v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  uint64_t IntegerValue;
  const char *v16;
  char ScrollMomentum;
  char v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  __int16 v25;
  int v26;
  const char *v27;
  uint64_t v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  int v35;
  float v36;
  float v37;
  float v38;
  int v39;
  double v40;
  double v41;
  double v42;
  double v43;
  uint64_t v44;
  int v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  int v52;
  unsigned __int16 v53;
  __int16 v54;
  int v55;
  double v56;
  double v57;
  double v58;
  double v59;
  double v60;
  double v61;
  int v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  double v68;
  int v69;
  unsigned int v70;
  double v71;
  float v72;
  int v73;
  double v74;
  float v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  CFIndex v81;
  unsigned int v82;
  const void *ValueAtIndex;

  if (result)
  {
    v3 = result;
    Children = (const __CFArray *)IOHIDEventGetChildren();
    switch(IOHIDEventGetType())
    {
      case 1u:
        objc_msgSend(CFSTR("\n"), "stringByPaddingToLength:withString:startingAtIndex:", a2 + 1, CFSTR("\t"), 0);
        IOHIDEventGetVendorDefinedData();
        goto LABEL_157;
      case 2u:
        if (a2 >= 1)
        {
          v5 = a2;
          do
          {
            putchar(9);
            --v5;
          }
          while (v5);
        }
        IOHIDEventGetIntegerValue();
        printf("Button Mask: 0x%08X\n");
        goto LABEL_157;
      case 3u:
        IOHIDEventGetIntegerValue();
        IOHIDEventGetIntegerValue();
        if (a2 >= 1)
        {
          v80 = a2;
          do
          {
            putchar(9);
            --v80;
          }
          while (v80);
        }
        IOHIDEventGetIntegerValue();
        IOHIDEventGetIntegerValue();
        printf("Keyboard: (usagePage:0x%04X usage:0x%04X%s) %s %s\n");
        goto LABEL_157;
      case 4u:
        if (a2 >= 1)
        {
          v6 = a2;
          do
          {
            putchar(9);
            --v6;
          }
          while (v6);
        }
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        printf("Translation: %fx, %fy");
        goto LABEL_44;
      case 5u:
        if (a2 >= 1)
        {
          v7 = a2;
          do
          {
            putchar(9);
            --v7;
          }
          while (v7);
        }
        IOHIDEventGetFloatValue();
        printf("Rotation: %f");
        goto LABEL_44;
      case 6u:
        if (a2 >= 1)
        {
          v8 = a2;
          do
          {
            putchar(9);
            --v8;
          }
          while (v8);
        }
        IOHIDEventGetFloatValue();
        v10 = v9;
        IOHIDEventGetFloatValue();
        v12 = v11;
        IOHIDEventGetFloatValue();
        v14 = v13;
        IntegerValue = IOHIDEventGetIntegerValue();
        v16 = " isPixels";
        if (!IntegerValue)
          v16 = "";
        printf("Scroll: (%f, %f, %f) %s", v10, v12, v14, v16);
        mt_PrintEventPhase();
        ScrollMomentum = IOHIDEventGetScrollMomentum();
        v18 = ScrollMomentum;
        if ((ScrollMomentum & 1) != 0)
        {
          printf(" PhaseMomentumContinue");
          if ((v18 & 2) == 0)
          {
LABEL_24:
            if ((v18 & 0x10) == 0)
              goto LABEL_25;
            goto LABEL_128;
          }
        }
        else if ((ScrollMomentum & 2) == 0)
        {
          goto LABEL_24;
        }
        printf(" PhaseMomentumStart");
        if ((v18 & 0x10) == 0)
        {
LABEL_25:
          if ((v18 & 4) == 0)
            goto LABEL_26;
          goto LABEL_129;
        }
LABEL_128:
        printf(" PhaseMomentumInterrupted");
        if ((v18 & 4) == 0)
        {
LABEL_26:
          if ((v18 & 8) == 0)
            goto LABEL_148;
          goto LABEL_130;
        }
LABEL_129:
        printf(" PhaseMomentumEnd");
        if ((v18 & 8) == 0)
          goto LABEL_148;
LABEL_130:
        printf(" PhaseMomentumWillBegin");
LABEL_148:
        putchar(10);
        goto LABEL_157;
      case 7u:
        if (a2 >= 1)
        {
          v19 = a2;
          do
          {
            putchar(9);
            --v19;
          }
          while (v19);
        }
        IOHIDEventGetFloatValue();
        printf("Scale Event: %f");
        goto LABEL_44;
      case 9u:
        if (a2 >= 1)
        {
          v21 = a2;
          do
          {
            putchar(9);
            --v21;
          }
          while (v21);
        }
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        printf("Velocity: %f, %f\n");
        goto LABEL_157;
      case 0xAu:
        if (a2 >= 1)
        {
          v22 = a2;
          do
          {
            putchar(9);
            --v22;
          }
          while (v22);
        }
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        printf("Orientation: %fr, %fa");
LABEL_44:
        if ((IOHIDEventGetEventFlags() & 1) == 0)
          printf(" (Relative) ");
        goto LABEL_147;
      case 0xBu:
        if (IOHIDEventGetIntegerValue())
        {
          mt_PrintDigitizerHandEvent(v3, a2);
        }
        else if (gPrintHIDShowPathEvents)
        {
          mt_PrintDigitizerPathEvent(v3, a2);
        }
        goto LABEL_157;
      case 0xCu:
        IOHIDEventGetFloatValue();
        if (a2 >= 1)
        {
          v23 = a2;
          do
          {
            putchar(9);
            --v23;
          }
          while (v23);
        }
        printf("ALS Event (level: %f)\n");
        goto LABEL_157;
      case 0xDu:
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        if (a2 >= 1)
        {
          v24 = a2;
          do
          {
            putchar(9);
            --v24;
          }
          while (v24);
        }
        printf("Accelerometer Event (X: %f  Y: %f  Z: %f)\n");
        goto LABEL_157;
      case 0xEu:
        v25 = IOHIDEventGetIntegerValue();
        if (a2 >= 1)
        {
          v26 = a2;
          do
          {
            putchar(9);
            --v26;
          }
          while (v26);
        }
        printf("Proximity Event (");
        if ((v25 & 8) != 0)
        {
          printf(" Edge Stradding,");
          if ((v25 & 0x20) == 0)
          {
LABEL_61:
            if ((v25 & 0x10) == 0)
              goto LABEL_62;
            goto LABEL_133;
          }
        }
        else if ((v25 & 0x20) == 0)
        {
          goto LABEL_61;
        }
        printf(" Finger Touch,");
        if ((v25 & 0x10) == 0)
        {
LABEL_62:
          if ((v25 & 4) == 0)
            goto LABEL_63;
          goto LABEL_134;
        }
LABEL_133:
        printf(" Flat Finger Clasp,");
        if ((v25 & 4) == 0)
        {
LABEL_63:
          if ((v25 & 1) == 0)
            goto LABEL_64;
          goto LABEL_135;
        }
LABEL_134:
        printf(" Irregualar Objects,");
        if ((v25 & 1) == 0)
        {
LABEL_64:
          if ((v25 & 2) == 0)
            goto LABEL_65;
          goto LABEL_136;
        }
LABEL_135:
        printf(" Large Body Contact,");
        if ((v25 & 2) == 0)
        {
LABEL_65:
          if ((v25 & 0x40) == 0)
            goto LABEL_66;
          goto LABEL_137;
        }
LABEL_136:
        printf(" Large Body Farfield,");
        if ((v25 & 0x40) == 0)
        {
LABEL_66:
          if ((v25 & 0x80) == 0)
            goto LABEL_67;
          goto LABEL_138;
        }
LABEL_137:
        printf(" Receiver Proximity,");
        if ((v25 & 0x80) == 0)
        {
LABEL_67:
          if ((v25 & 0x100) == 0)
            goto LABEL_68;
          goto LABEL_139;
        }
LABEL_138:
        printf(" Small Objects Hovering,");
        if ((v25 & 0x100) == 0)
        {
LABEL_68:
          if ((v25 & 0x200) == 0)
            goto LABEL_69;
          goto LABEL_140;
        }
LABEL_139:
        printf(" Crude Receiver Proximity,");
        if ((v25 & 0x200) == 0)
        {
LABEL_69:
          if ((v25 & 0x400) == 0)
            goto LABEL_71;
          goto LABEL_70;
        }
LABEL_140:
        printf(" Receiver Proximity Monitoring,");
        if ((v25 & 0x400) != 0)
LABEL_70:
          printf(" Crude Receiver Proximity Monitoring,");
LABEL_71:
        v27 = ")";
LABEL_85:
        puts(v27);
LABEL_157:
        if (Children && CFArrayGetCount(Children) >= 1)
        {
          v81 = 0;
          v82 = 1;
          do
          {
            ValueAtIndex = CFArrayGetValueAtIndex(Children, v81);
            mt_PrintHIDEvent(ValueAtIndex, (a2 + 1));
            v81 = v82;
          }
          while (CFArrayGetCount(Children) > v82++);
        }
        result = fflush((FILE *)*MEMORY[0x24BDAC8E8]);
        break;
      case 0x10u:
        v28 = IOHIDEventGetIntegerValue();
        IOHIDEventGetFloatValue();
        v30 = v29;
        IOHIDEventGetFloatValue();
        v32 = v31;
        IOHIDEventGetFloatValue();
        v34 = v33;
        if (a2 >= 1)
        {
          v35 = a2;
          do
          {
            putchar(9);
            --v35;
          }
          while (v35);
        }
        v36 = v34;
        v37 = v32;
        v38 = v30;
        printf("Nav Swipe:");
        goto LABEL_144;
      case 0x11u:
        if (a2 >= 1)
        {
          v39 = a2;
          do
          {
            putchar(9);
            --v39;
          }
          while (v39);
        }
        IOHIDEventGetFloatValue();
        v41 = v40;
        IOHIDEventGetFloatValue();
        v43 = v42;
        v44 = IOHIDEventGetIntegerValue();
        printf("Mouse: %fx, %fy (buttonmask: 0x%08lX)", v41, v43, v44);
        if ((IOHIDEventGetEventFlags() & 1) == 0)
          printf(" (Relative) ");
        goto LABEL_148;
      case 0x16u:
        if (a2 >= 1)
        {
          v45 = a2;
          do
          {
            putchar(9);
            --v45;
          }
          while (v45);
        }
        v27 = "Zoom Toggle";
        goto LABEL_85;
      case 0x17u:
        v28 = IOHIDEventGetIntegerValue();
        IOHIDEventGetFloatValue();
        v47 = v46;
        IOHIDEventGetFloatValue();
        v49 = v48;
        IOHIDEventGetFloatValue();
        v51 = v50;
        if (a2 >= 1)
        {
          v52 = a2;
          do
          {
            putchar(9);
            --v52;
          }
          while (v52);
        }
        v36 = v51;
        v37 = v49;
        v38 = v47;
        printf("Dock Swipe:");
        goto LABEL_144;
      case 0x18u:
        v53 = IOHIDEventGetIntegerValue();
        v54 = IOHIDEventGetIntegerValue();
        if (a2 >= 1)
        {
          v55 = a2;
          do
          {
            putchar(9);
            --v55;
          }
          while (v55);
        }
        printf("Symbolic Hot Key: %d", v53);
        if (v54)
        {
          printf(" (CGSHotKey)");
        }
        else if (v53 == 1)
        {
          printf(" (DictionaryApp)");
        }
        goto LABEL_147;
      case 0x1Bu:
        v28 = IOHIDEventGetIntegerValue();
        IOHIDEventGetFloatValue();
        v57 = v56;
        IOHIDEventGetFloatValue();
        v59 = v58;
        IOHIDEventGetFloatValue();
        v61 = v60;
        if (a2 >= 1)
        {
          v62 = a2;
          do
          {
            putchar(9);
            --v62;
          }
          while (v62);
        }
        printf("Fluid Touch Gesture:");
        if (IOHIDEventGetType() == 27)
        {
          switch((unsigned __int16)IOHIDEventGetIntegerValue())
          {
            case 1u:
              printf(" NotifCntrPrimary");
              break;
            case 2u:
              printf(" NotifCntrSecondary");
              break;
            case 3u:
              printf(" DockPrimary");
              break;
            case 4u:
              printf(" DockSecondary");
              break;
            case 5u:
              printf(" NavPrimary");
              break;
            case 6u:
              printf(" NavSecondary");
              break;
            default:
              goto LABEL_142;
          }
        }
        else
        {
LABEL_142:
          printf(" Flavor=0x%08X");
        }
        v36 = v61;
        v37 = v59;
        v38 = v57;
        goto LABEL_144;
      case 0x1Cu:
        v28 = IOHIDEventGetIntegerValue();
        IOHIDEventGetFloatValue();
        v64 = v63;
        IOHIDEventGetFloatValue();
        v66 = v65;
        IOHIDEventGetFloatValue();
        v68 = v67;
        if (a2 >= 1)
        {
          v69 = a2;
          do
          {
            putchar(9);
            --v69;
          }
          while (v69);
        }
        v36 = v68;
        v37 = v66;
        v38 = v64;
        printf("Boundary Scroll:");
LABEL_144:
        mt_PrintEventMotion();
        printf(" %+.2f%% (%+.2f%%, %+.2f%%)", (float)(v38 * 100.0), (float)(v37 * 100.0), (float)(v36 * 100.0));
        mt_PrintSwipeMask(v28);
        goto LABEL_147;
      case 0x20u:
        v70 = IOHIDEventGetIntegerValue();
        IOHIDEventGetFloatValue();
        v72 = v71;
        v73 = IOHIDEventGetIntegerValue();
        IOHIDEventGetFloatValue();
        v75 = v74;
        if (a2 >= 1)
        {
          v76 = a2;
          do
          {
            putchar(9);
            --v76;
          }
          while (v76);
        }
        printf("Force Gesture: %+.2f%% (stage %u) lean=%.2f", (float)(v72 * 100.0), v73, v75);
        printf(" - ");
        if (v70 > 0x11)
          printf("Some Behavior");
        else
          printf(off_24FFF03C0[v70]);
        printf(" - ");
        goto LABEL_147;
      case 0x26u:
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        IOHIDEventGetIntegerValue();
        if (a2 >= 1)
        {
          v77 = a2;
          do
          {
            putchar(9);
            --v77;
          }
          while (v77);
        }
        printf("Keyboard Brightness Event (current level: %f, target level: %f, ramp length: %llul)\n");
        goto LABEL_157;
      case 0x29u:
        IOHIDEventGetTimeStamp();
        if (!dword_255EB3D0C)
          mach_timebase_info((mach_timebase_info_t)&machAbsoluteTimeToTimeNano_sTimebaseInfo);
        IOHIDEventGetIntegerValue();
        IOHIDEventGetIntegerValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetDoubleValue();
        if (a2 >= 1)
        {
          v78 = a2;
          do
          {
            putchar(9);
            --v78;
          }
          while (v78);
        }
        printf("ForceStage Event: TS:%llu stage:%u transition:%s nextThresh:%0.2f pressedThresh:%0.2f releasedThresh:%0.2f force:%0.2f forceVel:%0.2f\n");
        goto LABEL_147;
      case 0x2Au:
        IOHIDEventGetTimeStamp();
        if (!dword_255EB3D0C)
          mach_timebase_info((mach_timebase_info_t)&machAbsoluteTimeToTimeNano_sTimebaseInfo);
        IOHIDEventGetIntegerValue();
        IOHIDEventGetIntegerValue();
        IOHIDEventGetIntegerValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetIntegerValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetDoubleValue();
        if (a2 >= 1)
        {
          v79 = a2;
          do
          {
            putchar(9);
            --v79;
          }
          while (v79);
        }
        printf("TouchSensitiveButton Event: (usagePage:0x%04X usage:0x%04X) TS:%llu touch:%d pos:(%0.2f,%0.2f) posDelta:(%0.4f,%0.4f) mask:0x%x majorRadius:%0.2f minorRadius:%0.2f - ");
LABEL_147:
        mt_PrintEventPhase();
        goto LABEL_148;
      default:
        if (a2 >= 1)
        {
          v20 = a2;
          do
          {
            putchar(9);
            --v20;
          }
          while (v20);
        }
        IOHIDEventGetType();
        printf("Other Event: 0x%08X\n");
        goto LABEL_157;
    }
  }
  return result;
}

uint64_t mt_PrintDigitizerHandEvent(uint64_t a1, int a2)
{
  int IntegerValue;
  __int16 EventFlags;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  int v10;

  IntegerValue = IOHIDEventGetIntegerValue();
  EventFlags = IOHIDEventGetEventFlags();
  if (IOHIDEventGetIntegerValue() == 1 && (IntegerValue & 1) != 0)
    putchar(10);
  if (a2 >= 1)
  {
    do
    {
      putchar(9);
      --a2;
    }
    while (a2);
  }
  IOHIDEventGetFloatValue();
  v6 = v5;
  IOHIDEventGetFloatValue();
  v8 = v7;
  IOHIDEventGetFloatValue();
  printf("Hand Event (%6.3fx, %6.3fy)  force=%3.0fg\tMask: 0x%08X", v6, v8, v9, IntegerValue);
  if (IOHIDEventGetIntegerValue() == 1)
    printf(", InRange ");
  else
    printf(", OutOfRange ");
  if (IOHIDEventGetIntegerValue() == 1)
    printf(" Touching");
  else
    printf(" UnTouch");
  if ((IntegerValue & 2) != 0)
  {
    printf("  dTouch");
    if ((IntegerValue & 4) == 0)
    {
LABEL_14:
      if ((IntegerValue & 0x40) == 0)
        goto LABEL_15;
      goto LABEL_44;
    }
  }
  else if ((IntegerValue & 4) == 0)
  {
    goto LABEL_14;
  }
  printf("  dPosition");
  if ((IntegerValue & 0x40) == 0)
  {
LABEL_15:
    if ((IntegerValue & 0x80) == 0)
      goto LABEL_16;
    goto LABEL_45;
  }
LABEL_44:
  printf(" dAttribute");
  if ((IntegerValue & 0x80) == 0)
  {
LABEL_16:
    if ((IntegerValue & 0x200) == 0)
      goto LABEL_17;
    goto LABEL_46;
  }
LABEL_45:
  printf("  Cancel");
  if ((IntegerValue & 0x200) == 0)
  {
LABEL_17:
    if ((IntegerValue & 0x400) == 0)
      goto LABEL_18;
    goto LABEL_47;
  }
LABEL_46:
  printf("  Resting");
  if ((IntegerValue & 0x400) == 0)
  {
LABEL_18:
    if ((IntegerValue & 0x800) == 0)
      goto LABEL_19;
    goto LABEL_48;
  }
LABEL_47:
  printf("  FromEdgeFlat");
  if ((IntegerValue & 0x800) == 0)
  {
LABEL_19:
    if ((IntegerValue & 0x4000) == 0)
      goto LABEL_20;
    goto LABEL_49;
  }
LABEL_48:
  printf("  FromEdgeTip");
  if ((IntegerValue & 0x4000) == 0)
  {
LABEL_20:
    if ((IntegerValue & 0x8000) == 0)
      goto LABEL_21;
    goto LABEL_50;
  }
LABEL_49:
  printf("  EdgePressPending");
  if ((IntegerValue & 0x8000) == 0)
  {
LABEL_21:
    if ((IntegerValue & 0x1000) == 0)
      goto LABEL_22;
    goto LABEL_51;
  }
LABEL_50:
  printf("  EdgePressActive");
  if ((IntegerValue & 0x1000) == 0)
  {
LABEL_22:
    if ((IntegerValue & 0x2000) == 0)
      goto LABEL_23;
    goto LABEL_52;
  }
LABEL_51:
  printf("  FromCorner");
  if ((IntegerValue & 0x2000) == 0)
  {
LABEL_23:
    if ((IntegerValue & 0x40000) == 0)
      goto LABEL_25;
    goto LABEL_24;
  }
LABEL_52:
  printf("  SwipePending");
  if ((IntegerValue & 0x40000) != 0)
LABEL_24:
    printf("  SwipeLocked");
LABEL_25:
  if ((IntegerValue & 0xF000000) == 0)
    goto LABEL_31;
  if ((IntegerValue & 0x1000000) != 0)
  {
    printf("  SwipeUP");
    if ((IntegerValue & 0x2000000) == 0)
    {
LABEL_28:
      if ((IntegerValue & 0x4000000) == 0)
        goto LABEL_29;
      goto LABEL_59;
    }
  }
  else if ((IntegerValue & 0x2000000) == 0)
  {
    goto LABEL_28;
  }
  printf("  SwipeDOWN");
  if ((IntegerValue & 0x4000000) == 0)
  {
LABEL_29:
    if ((IntegerValue & 0x8000000) == 0)
      goto LABEL_31;
    goto LABEL_30;
  }
LABEL_59:
  printf("  SwipeLEFT");
  if ((IntegerValue & 0x8000000) != 0)
LABEL_30:
    printf("  SwipeRIGHT");
LABEL_31:
  if ((IntegerValue & 0x100) != 0)
    printf("   GestureStarted");
  if ((IntegerValue & 8) != 0)
    printf("   GestureEnded");
  v10 = IOHIDEventGetIntegerValue();
  if (v10)
    printf(" GenerationCount=%u", v10);
  if ((EventFlags & 0x20) == 0)
  {
    if ((EventFlags & 0x800) == 0)
      goto LABEL_39;
LABEL_55:
    printf(" (Extrapolated)");
    if ((EventFlags & 0x4000) == 0)
      return putchar(10);
    goto LABEL_40;
  }
  printf(" (Interpolated)");
  if ((EventFlags & 0x800) != 0)
    goto LABEL_55;
LABEL_39:
  if ((EventFlags & 0x4000) != 0)
LABEL_40:
    printf(" (Low Confidence Estimation)");
  return putchar(10);
}

uint64_t mt_PrintDigitizerPathEvent(uint64_t a1, int a2)
{
  unsigned int IntegerValue;
  __int16 EventFlags;
  int v6;
  uint64_t v7;
  int v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  float v19;
  double v20;
  float v21;
  double v22;
  float v23;
  double v24;
  float v25;

  IntegerValue = IOHIDEventGetIntegerValue();
  EventFlags = IOHIDEventGetEventFlags();
  if (a2 >= 1)
  {
    v6 = a2;
    do
    {
      putchar(9);
      --v6;
    }
    while (v6);
  }
  v7 = IntegerValue;
  IOHIDEventGetIntegerValue();
  IOHIDEventGetIntegerValue();
  IOHIDEventGetFloatValue();
  IOHIDEventGetFloatValue();
  IOHIDEventGetFloatValue();
  IOHIDEventGetFloatValue();
  if (IntegerValue)
  {
    IOHIDEventGetIntegerValue();
    printf("Path#%d: F%d (%6.9fx,%6.9fy,) ZA=%5.3f ZD=%5.3f GC=%ld");
  }
  else
  {
    IOHIDEventGetFloatValue();
    IOHIDEventGetIntegerValue();
    printf("Path#%d: F%d (%6.9fx,%6.9fy,%6.9fz) ZA=%5.3f ZD=%5.3f GC=%ld");
  }
  v8 = IOHIDEventGetIntegerValue();
  printf(" Mask=0x%08X", v8);
  if ((v8 & 2) != 0)
  {
    printf(" (%s", "dTouch");
    if ((v8 & 4) == 0)
    {
      if ((v8 & 0x40) != 0)
      {
LABEL_41:
        printf(", %s");
        goto LABEL_43;
      }
LABEL_25:
      if ((v8 & 0x20) != 0)
      {
LABEL_44:
        printf(", %s");
        goto LABEL_45;
      }
LABEL_26:
      if ((v8 & 0x80) != 0)
      {
LABEL_46:
        printf(", %s");
        goto LABEL_47;
      }
LABEL_27:
      if ((v8 & 0x200) != 0)
      {
LABEL_48:
        printf(", %s");
        goto LABEL_49;
      }
LABEL_28:
      if ((v8 & 0x400) != 0)
      {
LABEL_50:
        printf(", %s");
        goto LABEL_51;
      }
LABEL_29:
      if ((v8 & 0x800) != 0)
      {
LABEL_52:
        printf(", %s");
        goto LABEL_53;
      }
LABEL_30:
      if ((v8 & 0x4000) != 0)
      {
LABEL_54:
        printf(", %s");
        goto LABEL_55;
      }
LABEL_31:
      if ((v8 & 0x8000) != 0)
      {
LABEL_56:
        printf(", %s");
        goto LABEL_57;
      }
LABEL_32:
      if ((v8 & 0x1000) != 0)
      {
LABEL_58:
        printf(", %s");
        goto LABEL_59;
      }
LABEL_33:
      if ((v8 & 0x2000) != 0)
      {
LABEL_60:
        printf(", %s");
        goto LABEL_61;
      }
LABEL_34:
      if ((v8 & 0x40000) != 0)
      {
LABEL_62:
        printf(", %s");
        goto LABEL_63;
      }
LABEL_35:
      if ((v8 & 0x100) != 0)
      {
LABEL_64:
        printf(", %s");
        goto LABEL_65;
      }
LABEL_36:
      if ((v8 & 8) == 0)
        goto LABEL_67;
      goto LABEL_66;
    }
    printf(", %s");
LABEL_40:
    if ((v8 & 0x40) != 0)
      goto LABEL_41;
    goto LABEL_25;
  }
  if ((v8 & 4) != 0)
  {
    printf(" (%s");
    goto LABEL_40;
  }
  if ((v8 & 0x40) != 0)
  {
    printf(" (%s");
LABEL_43:
    if ((v8 & 0x20) != 0)
      goto LABEL_44;
    goto LABEL_26;
  }
  if ((v8 & 0x20) != 0)
  {
    printf(" (%s");
LABEL_45:
    if ((v8 & 0x80) != 0)
      goto LABEL_46;
    goto LABEL_27;
  }
  if ((v8 & 0x80) != 0)
  {
    printf(" (%s");
LABEL_47:
    if ((v8 & 0x200) != 0)
      goto LABEL_48;
    goto LABEL_28;
  }
  if ((v8 & 0x200) != 0)
  {
    printf(" (%s");
LABEL_49:
    if ((v8 & 0x400) != 0)
      goto LABEL_50;
    goto LABEL_29;
  }
  if ((v8 & 0x400) != 0)
  {
    printf(" (%s");
LABEL_51:
    if ((v8 & 0x800) != 0)
      goto LABEL_52;
    goto LABEL_30;
  }
  if ((v8 & 0x800) != 0)
  {
    printf(" (%s");
LABEL_53:
    if ((v8 & 0x4000) != 0)
      goto LABEL_54;
    goto LABEL_31;
  }
  if ((v8 & 0x4000) != 0)
  {
    printf(" (%s");
LABEL_55:
    if ((v8 & 0x8000) != 0)
      goto LABEL_56;
    goto LABEL_32;
  }
  if ((v8 & 0x8000) != 0)
  {
    printf(" (%s");
LABEL_57:
    if ((v8 & 0x1000) != 0)
      goto LABEL_58;
    goto LABEL_33;
  }
  if ((v8 & 0x1000) != 0)
  {
    printf(" (%s");
LABEL_59:
    if ((v8 & 0x2000) != 0)
      goto LABEL_60;
    goto LABEL_34;
  }
  if ((v8 & 0x2000) != 0)
  {
    printf(" (%s");
LABEL_61:
    if ((v8 & 0x40000) != 0)
      goto LABEL_62;
    goto LABEL_35;
  }
  if ((v8 & 0x40000) != 0)
  {
    printf(" (%s");
LABEL_63:
    if ((v8 & 0x100) != 0)
      goto LABEL_64;
    goto LABEL_36;
  }
  if ((v8 & 0x100) != 0)
  {
    printf(" (%s");
LABEL_65:
    if ((v8 & 8) == 0)
      goto LABEL_67;
LABEL_66:
    printf(", %s");
    goto LABEL_67;
  }
  if ((v8 & 8) == 0)
    goto LABEL_68;
  printf(" (%s");
LABEL_67:
  putchar(41);
LABEL_68:
  if ((IOHIDEventGetPhase() & 0x80) != 0)
    printf(" MayBegin");
  if (IOHIDEventGetIntegerValue() == 1)
    printf(" InRange");
  else
    printf(" OutOfRange");
  if (IOHIDEventGetIntegerValue() == 1)
    printf(" Touching");
  else
    printf(" UnTouch");
  if ((EventFlags & 0x20) != 0)
  {
    printf(" Interpolated");
    if ((EventFlags & 0x800) == 0)
    {
LABEL_78:
      if ((EventFlags & 0x4000) == 0)
        goto LABEL_80;
      goto LABEL_79;
    }
  }
  else if ((EventFlags & 0x800) == 0)
  {
    goto LABEL_78;
  }
  printf(" Extrapolated");
  if ((EventFlags & 0x4000) != 0)
LABEL_79:
    printf(" Low Confidence Estimation");
LABEL_80:
  if (!IOHIDEventIsAbsolute())
    printf(" Relative");
  putchar(10);
  if (a2 >= 1)
  {
    do
    {
      putchar(9);
      --a2;
    }
    while (a2);
  }
  IOHIDEventGetFloatValue();
  if (v7)
  {
    v10 = v9;
    IOHIDEventGetFloatValue();
    v12 = v11;
    IOHIDEventGetFloatValue();
    v14 = v13;
    IOHIDEventGetFloatValue();
    v16 = v15;
    IOHIDEventGetFloatValue();
    return printf("\tangle=%6.3f minorRadius=%5.4f  majorRadius=%5.4f radiusAccuracy=%5.4f force=%3.0fg\n", v10, v12, v14, v16, v17);
  }
  else
  {
    v19 = v9 * 180.0 / 3.14159265;
    IOHIDEventGetFloatValue();
    v21 = v20 * 180.0 / 3.14159265;
    IOHIDEventGetFloatValue();
    v23 = v22 * 180.0 / 3.14159265;
    IOHIDEventGetFloatValue();
    v25 = v24;
    putchar(9);
    printf("altitude=%.1f°", v19);
    mt_PrintStylusMask(a1, 0x8000);
    printf(" azimuth=%.1f°", v21);
    mt_PrintStylusMask(a1, 0x10000);
    printf(" roll=%.1f°", v23);
    mt_PrintStylusMask(a1, 0x800000);
    printf(" pressure=%.1fg", v25);
    mt_PrintStylusMask(a1, 1024);
    return putchar(10);
  }
}

uint64_t mt_PrintEventPhase()
{
  uint64_t result;
  char v1;

  result = IOHIDEventGetPhase();
  v1 = result;
  if ((result & 0x80) != 0)
  {
    result = printf(" PhaseMayBegin");
    if ((v1 & 1) == 0)
    {
LABEL_3:
      if ((v1 & 2) == 0)
        goto LABEL_4;
      goto LABEL_9;
    }
  }
  else if ((result & 1) == 0)
  {
    goto LABEL_3;
  }
  result = printf(" PhaseBegan");
  if ((v1 & 2) == 0)
  {
LABEL_4:
    if ((v1 & 4) == 0)
      goto LABEL_5;
    goto LABEL_10;
  }
LABEL_9:
  result = printf(" PhaseChanged");
  if ((v1 & 4) == 0)
  {
LABEL_5:
    if ((v1 & 8) == 0)
      return result;
    return printf(" PhaseCancelled");
  }
LABEL_10:
  result = printf(" PhaseEnded");
  if ((v1 & 8) != 0)
    return printf(" PhaseCancelled");
  return result;
}

uint64_t mt_PrintRawHIDEvent(uint64_t result)
{
  unint64_t TimeStamp;
  unsigned int v2;
  double v3;
  double v4;
  double v5;
  double v6;
  float v7;
  double v8;
  float v9;
  double v10;
  float v11;
  double v12;
  float v13;
  double v14;
  float v15;
  double v16;
  float v17;
  double v18;
  float v19;
  double v20;
  float v21;
  char IntegerValue;
  char v23;
  char v24;
  int v25;
  char v26;
  char v27;
  int v28;
  int v29;
  int v30;
  const __CFArray *v31;
  CFIndex i;
  const void *ValueAtIndex;
  float v34;
  float v35;
  float v36;
  unint64_t v37;

  if (result)
  {
    if (IOHIDEventGetType() == 11 && IOHIDEventGetIntegerValue() != 3)
    {
      TimeStamp = IOHIDEventGetTimeStamp();
      v2 = dword_255EB3D0C;
      if (!dword_255EB3D0C)
      {
        mach_timebase_info((mach_timebase_info_t)&machAbsoluteTimeToTimeNano_sTimebaseInfo);
        v2 = dword_255EB3D0C;
      }
      v37 = TimeStamp / v2 * machAbsoluteTimeToTimeNano_sTimebaseInfo / 0x3E8;
      IOHIDEventGetFloatValue();
      *(float *)&v3 = v3;
      v36 = *(float *)&v3;
      IOHIDEventGetFloatValue();
      *(float *)&v4 = v4;
      v35 = *(float *)&v4;
      IOHIDEventGetFloatValue();
      *(float *)&v5 = v5;
      v34 = *(float *)&v5;
      IOHIDEventGetFloatValue();
      v7 = v6;
      IOHIDEventGetFloatValue();
      v9 = v8;
      IOHIDEventGetFloatValue();
      v11 = v10;
      IOHIDEventGetFloatValue();
      v13 = v12;
      IOHIDEventGetFloatValue();
      v15 = v14;
      IOHIDEventGetFloatValue();
      v17 = v16;
      IOHIDEventGetFloatValue();
      v19 = v18;
      IOHIDEventGetFloatValue();
      v21 = v20;
      IntegerValue = IOHIDEventGetIntegerValue();
      v23 = IOHIDEventGetIntegerValue();
      v24 = IOHIDEventGetIntegerValue();
      v25 = IOHIDEventGetIntegerValue();
      v26 = IOHIDEventGetIntegerValue();
      v27 = IOHIDEventGetIntegerValue();
      v28 = IOHIDEventGetIntegerValue();
      v29 = IOHIDEventGetIntegerValue();
      v30 = IOHIDEventGetIntegerValue();
      printf("path,%llu,%d,%d,%d,%d,%f,%f,%d,%d,0x%X,%f,%f,%d,%d,%f,%f,%f,%f,%f,%f,%f\n", v37, v30, IntegerValue, v23, v24, v36, v35, v26, v27, v25, v34, v7, v28, v29, v9, v11, v13, v15,
        v17,
        v19,
        v21);
    }
    result = IOHIDEventGetChildren();
    if (result)
    {
      v31 = (const __CFArray *)result;
      result = CFArrayGetCount((CFArrayRef)result);
      if (result >= 1)
      {
        for (i = 0; i < result; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v31, i);
          mt_PrintRawHIDEvent(ValueAtIndex);
          result = CFArrayGetCount(v31);
        }
      }
    }
  }
  return result;
}

uint64_t mt_PrintStylusMask(uint64_t a1, int a2)
{
  int IntegerValue;
  int v4;
  uint64_t result;

  IntegerValue = IOHIDEventGetIntegerValue();
  v4 = IOHIDEventGetIntegerValue();
  result = IOHIDEventGetIntegerValue();
  if ((result & a2) != 0)
  {
    printf(" (%s", "estimated");
    if ((IntegerValue & a2) != 0)
      printf(", %s");
    goto LABEL_6;
  }
  if ((IntegerValue & a2) != 0)
  {
    printf(" (%s");
LABEL_6:
    if ((v4 & a2) != 0)
      printf(", %s");
    return putchar(41);
  }
  if ((v4 & a2) != 0)
  {
    printf(" (%s");
    return putchar(41);
  }
  return result;
}

uint64_t mt_PrintEventMotion()
{
  int IntegerValue;
  uint64_t result;

  if (IOHIDEventGetType() == 16
    || IOHIDEventGetType() == 23
    || IOHIDEventGetType() == 27
    || IOHIDEventGetType() == 28)
  {
    IntegerValue = (unsigned __int16)IOHIDEventGetIntegerValue();
    switch(IntegerValue)
    {
      case 1:
        result = printf(" Horiz");
        break;
      case 2:
        result = printf(" Vert");
        break;
      case 3:
        result = printf(" Scale");
        break;
      case 4:
        result = printf(" Rotate");
        break;
      case 5:
        result = printf(" Tap");
        break;
      case 6:
        result = printf(" DoubleTap");
        break;
      case 7:
        result = printf(" FromLeftEdge");
        break;
      case 8:
        result = printf(" OffLeftEdge");
        break;
      case 9:
        result = printf(" FromRightEdge");
        break;
      case 10:
        result = printf(" OffRightEdge");
        break;
      case 11:
        result = printf(" FromTopEdge");
        break;
      case 12:
        result = printf(" OffTopEdge");
        break;
      case 13:
        result = printf(" FromBottomEdge");
        break;
      case 14:
        result = printf(" OffBottomEdge");
        break;
      default:
        return printf(" Motion=0x%08X", IntegerValue);
    }
  }
  else
  {
    IntegerValue = 0;
    return printf(" Motion=0x%08X", IntegerValue);
  }
  return result;
}

uint64_t mt_PrintSwipeMask(uint64_t result)
{
  char v1;

  v1 = result;
  if ((result & 1) != 0)
  {
    result = printf(" [SwipeUp]");
    if ((v1 & 2) == 0)
    {
LABEL_3:
      if ((v1 & 4) == 0)
        goto LABEL_4;
      goto LABEL_12;
    }
  }
  else if ((result & 2) == 0)
  {
    goto LABEL_3;
  }
  result = printf(" [SwipeDown]");
  if ((v1 & 4) == 0)
  {
LABEL_4:
    if ((v1 & 8) == 0)
      goto LABEL_5;
    goto LABEL_13;
  }
LABEL_12:
  result = printf(" [SwipeLeft]");
  if ((v1 & 8) == 0)
  {
LABEL_5:
    if ((v1 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_14;
  }
LABEL_13:
  result = printf(" [SwipeRight]");
  if ((v1 & 0x10) == 0)
  {
LABEL_6:
    if ((v1 & 0x20) == 0)
      goto LABEL_7;
    goto LABEL_15;
  }
LABEL_14:
  result = printf(" [ScaleExpand]");
  if ((v1 & 0x20) == 0)
  {
LABEL_7:
    if ((v1 & 0x40) == 0)
      goto LABEL_8;
    goto LABEL_16;
  }
LABEL_15:
  result = printf(" [ScaleContract]");
  if ((v1 & 0x40) == 0)
  {
LABEL_8:
    if ((v1 & 0x80) == 0)
      return result;
    return printf(" [RotateCCW]");
  }
LABEL_16:
  result = printf(" [RotateCW]");
  if (v1 < 0)
    return printf(" [RotateCCW]");
  return result;
}

double mt_MachAbsoluteTimeToSeconds(unint64_t a1)
{
  double v2;
  unint64_t v3;
  unint64_t v4;

  if (dword_255EB3CFC)
  {
    v2 = *(double *)&mt_MachAbsoluteTimeToSeconds_timebaseFraction;
  }
  else
  {
    mach_timebase_info((mach_timebase_info_t)&mt_MachAbsoluteTimeToSeconds_sTimebaseInfo);
    LODWORD(v3) = mt_MachAbsoluteTimeToSeconds_sTimebaseInfo;
    LODWORD(v4) = dword_255EB3CFC;
    v2 = (double)v3 * 0.000000001 / (double)v4;
    mt_MachAbsoluteTimeToSeconds_timebaseFraction = *(_QWORD *)&v2;
  }
  return v2 * (double)a1;
}

float invertRadiusSmoothing(int8x16_t a1, float a2, int8x16_t a3, int8x16_t a4)
{
  float v4;
  double v5;
  int8x16_t v6;

  if (a2 != 0.0)
  {
    *(float *)a4.i32 = (float)(*(float *)a1.i32 - a2) / a2;
    v4 = fabsf(*(float *)a4.i32);
    v5 = v4;
    if (*(float *)a3.i32 * 0.125 <= v4)
    {
      *(double *)a3.i64 = (float)(*(float *)a3.i32 + 1.0);
      if (*(double *)a3.i64 * 0.0625 <= v5)
      {
        if (*(double *)a3.i64 * 0.125 > v5)
        {
          *(float *)a1.i32 = (*(float *)a4.i32 / (*(double *)a3.i64 * 0.5) + 1.0) * a2;
          return *(float *)a1.i32;
        }
        a3.i32[0] = 0.25;
        if (v4 >= 0.25)
          return *(float *)a1.i32;
        a1.i64[0] = 0x8000000080000000;
        a1.i64[1] = 0x8000000080000000;
        *(float *)a1.i32 = *(float *)vbslq_s8(a1, a3, a4).i32 + 1.0;
      }
      else
      {
        a1.i32[0] = 0.125;
        v6.i64[0] = 0x8000000080000000;
        v6.i64[1] = 0x8000000080000000;
        *(float *)a1.i32 = *(float *)vbslq_s8(v6, a1, a4).i32 + 1.0;
      }
    }
    else
    {
      *(float *)a1.i32 = (float)(*(float *)a4.i32 / *(float *)a3.i32) + 1.0;
    }
    *(float *)a1.i32 = *(float *)a1.i32 * a2;
  }
  return *(float *)a1.i32;
}

float mthm_ComputeFingerEllipseTipOffset_mm(int *a1, uint64_t a2, float32x2_t *a3, float *a4, int8x16_t a5, double a6, int8x16_t a7, int8x16_t a8)
{
  int v11;
  float v13;
  float v14;
  float v15;
  __int32 v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  int v32;
  float32x2_t v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;

  if (a1[1])
    v11 = -1;
  else
    v11 = 1;
  if (!*((_BYTE *)a1 + 44) || a3[5].f32[0] == 0.0 && a3[5].f32[1] == 0.0)
  {
    v13 = a3[7].f32[1];
    v14 = a3[8].f32[0];
    v15 = a3[7].f32[0];
  }
  else
  {
    a5.i32[0] = a3[7].i32[1];
    v16 = a1[12];
    a7.i32[0] = v16;
    v13 = invertRadiusSmoothing(a5, a4[15], a7, a8);
    v17.i32[0] = a3[8].i32[0];
    v18.i32[0] = v16;
    v14 = invertRadiusSmoothing(v17, a4[16], v18, v19);
    v20.i32[0] = a3[7].i32[0];
    v21.i32[0] = v16;
    v15 = invertRadiusSmoothing(v20, a4[14], v21, v22);
  }
  v23 = *a1;
  v24 = (float)v11;
  v25 = 0.0;
  switch(*a1)
  {
    case 0:
      goto LABEL_25;
    case 1:
      v25 = -(float)(*((float *)a1 + 5) * v24);
      goto LABEL_19;
    case 2:
      v15 = v15 + 3.14159265;
      v25 = *((float *)a1 + 5) * v24;
      goto LABEL_19;
    case 3:
      if (v15 < 1.57079633)
      {
        v26 = v15 + 3.14159265;
        v15 = v26;
      }
      v25 = -*((float *)a1 + 4);
      goto LABEL_19;
    case 4:
      if (v15 > 1.57079633)
      {
        v27 = v15 + 3.14159265;
        v15 = v27;
      }
      v25 = *((float *)a1 + 4);
      goto LABEL_19;
    default:
      v25 = 0.0;
LABEL_19:
      v28 = *((float *)a1 + 8);
      if (v14 > v28)
        v28 = v14;
      v29 = *((float *)a1 + 6) + v28;
      if (v13 > v29)
      {
        v30 = v13 - v29;
        if (v30 > *((float *)a1 + 7))
          v30 = *((float *)a1 + 7);
        v31 = *((float *)a1 + 3) * v30;
        v25 = v25 + (float)(v31 * __sincosf_stret(v15).__cosval);
      }
LABEL_25:
      v32 = *((unsigned __int8 *)a1 + 40);
      __asm { FMOV            V1.2S, #1.0 }
      v38 = vminnm_f32(vmaxnm_f32(a3[4], 0), _D1);
      v39 = MTSurfaceDimensions::convertSurfaceFractionToMillimeters(a2, vminnm_f32(v38, vsub_f32(_D1, v38)).f32[0]);
      v40 = *((float *)a1 + 15);
      if ((v23 - 1) > 1)
      {
        v41 = 1.0;
        v42 = *((float *)a1 + 14);
        if (v42 != 0.0)
          v41 = fmin((float)(v39 / v42), 1.0);
      }
      else
      {
        v41 = 1.0;
        if (v40 != 0.0)
          v41 = fmin((float)(v39 / v40), 1.0);
      }
      v43 = fabsf(v25);
      if (v32)
        v43 = v25;
      return v43 * v41;
  }
}

void mthm_ComputeFingerEllipseTipOffsetFromPressure_mm(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(float *)(a3 + 60) > (float)(*(float *)(a1 + 24) + *(float *)(a1 + 32)))
    __sincosf_stret(*(float *)(a3 + 56));
}

uint64_t MTSimpleEmbeddedStylusHIDManager::createManager(uint64_t a1, const void *a2, int a3, int a4)
{
  uint64_t v8;

  v8 = operator new();
  *(_OWORD *)v8 = 0u;
  *(_OWORD *)(v8 + 16) = 0u;
  *(_OWORD *)(v8 + 32) = 0u;
  *(_OWORD *)(v8 + 48) = 0u;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 112) = 0u;
  *(_OWORD *)(v8 + 128) = 0u;
  *(_OWORD *)(v8 + 144) = 0u;
  *(_OWORD *)(v8 + 160) = 0u;
  *(_OWORD *)(v8 + 176) = 0u;
  *(_OWORD *)(v8 + 192) = 0u;
  *(_OWORD *)(v8 + 208) = 0u;
  *(_QWORD *)(v8 + 224) = 0;
  MTSimpleHIDManager::MTSimpleHIDManager((MTSimpleHIDManager *)v8);
  *(_QWORD *)v8 = &off_24FFF0460;
  MTSimpleEmbeddedHIDManager::initialize((MTModeSwitcher *)v8, a1, a2, a3, a4);
  return v8;
}

void sub_23107A53C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10A1C40E945ADD8);
  _Unwind_Resume(a1);
}

uint64_t MTSimpleEmbeddedStylusHIDManager::wasScheduledOnDispatchQueue(MTSimpleEmbeddedStylusHIDManager *this, NSObject *a2)
{
  IONotificationPort **v4;

  v4 = (IONotificationPort **)*((_QWORD *)this + 25);
  if (v4)
    MTSLGLogger::registerControlInterface(v4, a2);
  return MTSimpleHIDManager::wasScheduledOnDispatchQueue(this, a2);
}

void MTSimpleEmbeddedStylusHIDManager::wasUnscheduledFromDispatchQueue(NSObject **this, dispatch_queue_s *a2)
{
  MTSLGLogger *v3;

  MTSimpleHIDManager::wasUnscheduledFromDispatchQueue(this, a2);
  v3 = (MTSLGLogger *)this[25];
  if (v3)
    MTSLGLogger::unregisterControlInterface(v3);
}

uint64_t MTSimpleEmbeddedStylusHIDManager::setDeviceUsages(MTSimpleEmbeddedStylusHIDManager *this)
{
  const __CFAllocator *v2;
  __CFDictionary *Mutable;
  CFNumberRef v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  __CFArray *v8;
  __CFArray *v9;
  int IsBuiltIn;
  uint64_t v11;
  uint64_t v12;
  int v14;
  int valuePtr;

  v14 = 32;
  valuePtr = 13;
  v2 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v4 = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
  if (v4)
  {
    v5 = v4;
    (*(void (**)(MTSimpleEmbeddedStylusHIDManager *, const __CFString *, CFNumberRef))(*(_QWORD *)this + 568))(this, CFSTR("PrimaryUsagePage"), v4);
    if (Mutable)
      CFDictionaryAddValue(Mutable, CFSTR("DeviceUsagePage"), v5);
    CFRelease(v5);
  }
  v6 = CFNumberCreate(v2, kCFNumberSInt32Type, &v14);
  if (v6)
  {
    v7 = v6;
    (*(void (**)(MTSimpleEmbeddedStylusHIDManager *, const __CFString *, CFNumberRef))(*(_QWORD *)this + 568))(this, CFSTR("PrimaryUsage"), v6);
    if (Mutable)
      CFDictionaryAddValue(Mutable, CFSTR("DeviceUsage"), v7);
    CFRelease(v7);
  }
  v8 = CFArrayCreateMutable(v2, 2, MEMORY[0x24BDBD690]);
  if (v8)
  {
    v9 = v8;
    if (Mutable)
      CFArrayAppendValue(v8, Mutable);
    (*(void (**)(MTSimpleEmbeddedStylusHIDManager *, const __CFString *, __CFArray *))(*(_QWORD *)this + 568))(this, CFSTR("DeviceUsagePairs"), v9);
    CFRelease(v9);
  }
  if (Mutable)
    CFRelease(Mutable);
  (*(void (**)(MTSimpleEmbeddedStylusHIDManager *))(*(_QWORD *)this + 80))(this);
  IsBuiltIn = MTDeviceIsBuiltIn();
  v11 = *MEMORY[0x24BDBD270];
  if (IsBuiltIn)
    v12 = *MEMORY[0x24BDBD270];
  else
    v12 = *MEMORY[0x24BDBD268];
  (*(void (**)(MTSimpleEmbeddedStylusHIDManager *, const __CFString *, uint64_t))(*(_QWORD *)this + 568))(this, CFSTR("Built-In"), v12);
  return (*(uint64_t (**)(MTSimpleEmbeddedStylusHIDManager *, const __CFString *, uint64_t))(*(_QWORD *)this + 568))(this, CFSTR("DisplayIntegrated"), v11);
}

uint64_t MTSimpleEmbeddedStylusHIDManager::setPluginDefaultProperties(MTSimpleEmbeddedStylusHIDManager *this)
{
  CFNumberRef v2;
  CFNumberRef v3;
  int valuePtr;

  MTSimpleEmbeddedHIDManager::setPluginDefaultProperties(this);
  (*(void (**)(MTSimpleEmbeddedStylusHIDManager *))(*(_QWORD *)this + 80))(this);
  valuePtr = MTDeviceGetMaxHoverHeightValue();
  v2 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberSInt32Type, &valuePtr);
  if (v2)
  {
    v3 = v2;
    (*(void (**)(MTSimpleEmbeddedStylusHIDManager *, const __CFString *, CFNumberRef))(*(_QWORD *)this + 568))(this, CFSTR("MaxHoverHeight"), v2);
    CFRelease(v3);
  }
  return (*(uint64_t (**)(MTSimpleEmbeddedStylusHIDManager *, const __CFString *, _QWORD))(*(_QWORD *)this + 568))(this, CFSTR("HoverDisabled"), *MEMORY[0x24BDBD268]);
}

const char *MTSimpleEmbeddedStylusHIDManager::getName(MTSimpleEmbeddedStylusHIDManager *this)
{
  return "MTSimpleEmbeddedStylusHIDManager";
}

unsigned int *MTSimpleEmbeddedStylusHIDManager::createEventDispatcher(MTSimpleEmbeddedStylusHIDManager *this)
{
  const void *v2;
  unsigned int *Dispatcher;

  v2 = (const void *)(*(uint64_t (**)(MTSimpleEmbeddedStylusHIDManager *))(*(_QWORD *)this + 80))(this);
  Dispatcher = (unsigned int *)MTSimpleEmbeddedStylusEventDispatcher::createDispatcher(this, v2);
  (*(void (**)(MTSimpleEmbeddedStylusHIDManager *, unsigned int *))(*(_QWORD *)this + 128))(this, Dispatcher);
  return MTSimpleEventDispatcher::release(Dispatcher);
}

uint64_t MTSimpleEmbeddedStylusHIDManager::setInputDetectionModeForOrientation(MTSimpleEmbeddedStylusHIDManager *this)
{
  return 0;
}

uint64_t MTSimpleEmbeddedStylusHIDManager::setTouchMode(MTSimpleEmbeddedStylusHIDManager *this)
{
  (*(void (**)(MTSimpleEmbeddedStylusHIDManager *))(*(_QWORD *)this + 80))(this);
  MTDeviceUpdateUILockState();
  return 0;
}

void MTSimpleEmbeddedStylusHIDManager::sendHighNoiseEnvironmentDetection(MTSimpleEmbeddedStylusHIDManager *this, int a2)
{
  NSObject *v4;
  const char *v5;
  uint64_t VendorDefinedEvent;
  const void *v7;
  _BYTE buf[22];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  (*(void (**)(MTSimpleEmbeddedStylusHIDManager *))(*(_QWORD *)this + 80))(this);
  MTDeviceGetDeviceID();
  v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = "exited";
    if (a2)
      v5 = "entered";
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = v5;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = 0;
    _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_DEFAULT, "Sending high-noise environment %{public}s (deviceID 0x%llX)", buf, 0x16u);
  }
  *(_QWORD *)&buf[8] = 0;
  *(_QWORD *)&buf[1] = 0;
  buf[0] = a2;
  mach_absolute_time();
  VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
  if (VendorDefinedEvent)
  {
    v7 = (const void *)VendorDefinedEvent;
    (*(void (**)(MTSimpleEmbeddedStylusHIDManager *, uint64_t, _QWORD))(*(_QWORD *)this + 136))(this, VendorDefinedEvent, 0);
    CFRelease(v7);
  }
}

void MTSimpleEmbeddedStylusHIDManager::~MTSimpleEmbeddedStylusHIDManager(MTSimpleEmbeddedStylusHIDManager *this)
{
  MTSimpleHIDManager::~MTSimpleHIDManager(this);
  JUMPOUT(0x2348D0034);
}

uint64_t MTSimpleEmbeddedStylusHIDManager::setPowerState()
{
  return 0;
}

uint64_t MTSimpleEmbeddedStylusHIDManager::setPowerStateWithReset()
{
  return 0;
}

MTFingerToPathMap *MTHandMotion::MTHandMotion(MTFingerToPathMap *a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6)
{
  uint64_t v12;

  MTFingerToPathMap::MTFingerToPathMap(a1, 1);
  *(_QWORD *)v12 = &off_24FFF0700;
  *(_QWORD *)(v12 + 120) = a2;
  *(_DWORD *)(v12 + 128) = a3;
  *(_DWORD *)(v12 + 132) = a4;
  *(_DWORD *)(v12 + 380) = a5;
  *(_QWORD *)(v12 + 384) = a6;
  MTParameterFactory::initMotionExtractionParams(v12 + 144);
  MTHandMotion::clearHandMotion(a1, 1);
  return a1;
}

void sub_23107AAFC(_Unwind_Exception *a1)
{
  MTFingerToPathMap *v1;

  MTFingerToPathMap::~MTFingerToPathMap(v1);
  _Unwind_Resume(a1);
}

void MTHandMotion::~MTHandMotion(MTHandMotion *this)
{
  MTFingerToPathMap::~MTFingerToPathMap(this);
  JUMPOUT(0x2348D0034);
}

uint64_t MTHandMotion::printExtractedMotion(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t i;
  int v7;

  printf("%s %dM/%d fingers, %d<-->%d\n", *(const char **)(a1 + 384), a3, a2, *(_DWORD *)(a1 + 80), *(_DWORD *)(a1 + 88));
  for (i = 3; i != 8; ++i)
  {
    v7 = *(_DWORD *)(a1 + 4 * i);
    if (v7)
      printf("\tF%d %5.2fx %5.2fy %5.2fvx %5.2fvy\n", i - 2, *(float *)(a4 + 96 * v7 + 32), *(float *)(a4 + 96 * v7 + 36), *(float *)(a4 + 96 * v7 + 40), *(float *)(a4 + 96 * v7 + 44));
  }
  return printf("\t%4.2fdx %4.2fdy %4.2fds %4.2fdr | %5.3f/%5.3fvx %5.3f/%5.3fvy %5.3f/%5.3fvs %5.3f/%5.3fvr\n", *(float *)(a1 + 192), *(float *)(a1 + 196), *(float *)(a1 + 200), *(float *)(a1 + 204), *(float *)(a1 + 284), *(float *)(a1 + 208), *(float *)(a1 + 288), *(float *)(a1 + 212), *(float *)(a1 + 292), *(float *)(a1 + 216), *(float *)(a1 + 296), *(float *)(a1 + 220));
}

uint64_t MTHandMotion::outermostFingersAreWidelySeparated(MTHandMotion *this, unsigned int a2)
{
  float v2;
  float v3;

  v2 = *((float *)this + 90);
  v3 = 0.0;
  if (v2 > 40.0)
  {
    v3 = 1.0;
    if (v2 < 50.0)
      v3 = (float)(v2 + -40.0) / 10.0;
  }
  if ((float)(v3 * *((float *)this + 93)) > 0.9)
    return 1;
  if (v3 >= 1.0)
    return a2;
  return 0;
}

float MTHandMotion::scalingFromDotProduct(float a1, float a2, float a3, float a4, float a5, float a6)
{
  return (float)((float)(a2 * a6) + (float)(a5 * a1)) - (float)((float)(a2 * a4) + (float)(a3 * a1));
}

float MTHandMotion::rotationFromVectorProduct(float a1, float a2, float a3, float a4, float a5, float a6)
{
  return (float)((float)(a5 * a2) - (float)(a6 * a1)) - (float)((float)(a3 * a2) - (float)(a4 * a1));
}

float MTHandMotion::computeSeparation_mm(float *a1, uint64_t a2, uint64_t a3)
{
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float result;

  v3 = *(float *)(a3 + 68);
  v4 = *(float *)(a3 + 72);
  v5 = *(float *)(a2 + 68);
  v6 = *(float *)(a2 + 72);
  v7 = v4 - v6;
  v8 = vabds_f32(v4, v6);
  a1[88] = v8;
  if (v8 > a1[89])
    a1[89] = v8;
  v9 = v3 - v5;
  a1[87] = sqrtf((float)(v7 * v7) + (float)(v9 * v9));
  result = sqrtf((float)((float)(v7 * 0.5) * (float)(v7 * 0.5)) + (float)(v9 * v9));
  a1[90] = result;
  return result;
}

float MTHandMotion::computeSeparationVector(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v3;

  v3 = *(float *)(a3 + 32) - *(float *)(a2 + 32);
  atan2f(-(float)(*(float *)(a3 + 36) - *(float *)(a2 + 36)), v3);
  return v3;
}

float MTHandMotion::computeInnerOuterSpeedSymmetry(uint64_t a1, float *a2, float *a3)
{
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float result;
  float v12;
  BOOL v13;
  float v14;

  v3 = a2[134];
  v4 = a2[132];
  v5 = a2[133];
  v6 = sqrtf((float)(v4 * v4) + (float)(v5 * v5));
  v7 = 1.0;
  if (v6 > 0.0)
  {
    v8 = a3[132];
    v9 = a3[133];
    v10 = sqrtf((float)(v8 * v8) + (float)(v9 * v9));
    if (v10 > 0.0)
      v7 = (float)((float)(v5 * v9) + (float)(v4 * v8)) / (float)(v6 * v10);
  }
  result = 0.0;
  if (v3 > 20.0)
  {
    v12 = -1.0;
    if (v7 >= 0.0)
      v12 = 1.0;
    v13 = v7 <= 0.5;
    v14 = 1.5;
    if (v13)
      v14 = v12;
    return (float)(sqrtf(v3 * a3[134]) / (float)((float)((float)(v3 + a3[134]) * 0.5) + 1.0)) * v14;
  }
  return result;
}

void MTHandMotion::extractHandMotion(MTHandMotion *this, const MTPathStates *a2, const MTParserPath *a3, const MTParserPath *a4, int a5)
{
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  float32x2_t v13;
  int v14;
  float32x2_t v15;
  int v16;
  int v17;
  int v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  uint64_t v25;
  __n128 v26;
  unsigned int v27;
  int v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float32x2_t v34;
  float32x2_t v35;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  uint64_t v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  if (*((double *)a2 + 1) - *((double *)a2 + 2) == 0.0)
  {
    v10 = MTLoggingPlugin();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11 = *((_QWORD *)a2 + 1);
      MTAbsoluteTimeGetCurrent();
      *(_DWORD *)buf = 136316162;
      v37 = "[Error] ";
      v38 = 2080;
      v39 = "";
      v40 = 2080;
      v41 = "extractHandMotion";
      v42 = 2048;
      v43 = v11;
      v44 = 2048;
      v45 = v12;
      _os_log_impl(&dword_231071000, v10, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Frame interval is zero! currentTimestamp = %g, currentHostTimestamp = %g", buf, 0x34u);
    }
  }
  v13 = *(float32x2_t *)((char *)a3 + 432);
  v14 = *((_DWORD *)a3 + 91);
  v15 = *(float32x2_t *)((char *)a4 + 432);
  v16 = *((_DWORD *)a4 + 91);
  *(_QWORD *)((char *)this + 348) = 0;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_DWORD *)this + 91) = *((_DWORD *)this + 90);
  *((_DWORD *)this + 90) = 0;
  v17 = *((_DWORD *)a3 + 10);
  if (v17)
  {
    *((float32x2_t *)this + 26) = vadd_f32(*(float32x2_t *)((char *)a3 + 500), 0);
    *((float32x2_t *)this + 21) = vadd_f32(v13, *(float32x2_t *)((char *)a3 + 56));
    if (a5)
    {
      if (*((_DWORD *)a3 + 34) && (v14 & 4) != 0)
      {
        *((float *)this + 48) = *((float *)a3 + 112) + 0.0;
        *((float *)this + 49) = *((float *)a3 + 113) + 0.0;
      }
    }
  }
  v18 = *((_DWORD *)a4 + 10);
  if (v17 == v18 || !v18)
  {
    *((_QWORD *)this + 22) = 0;
    return;
  }
  v19 = *((float *)a4 + 14) - *((float *)a3 + 14);
  v20 = *((float *)a4 + 15) - *((float *)a3 + 15);
  v21 = sqrtf((float)(v20 * v20) + (float)(v19 * v19));
  v22 = atan2f(-v20, v19);
  v23 = *((float *)a3 + 125);
  v24 = *((float *)a3 + 126);
  v35 = *(float32x2_t *)((char *)a4 + 500);
  MTHandMotion::computeSeparation_mm((float *)this, (uint64_t)a3 + 24, (uint64_t)a4 + 24);
  *((float *)this + 44) = v21;
  *((float *)this + 45) = v22;
  *((float32x2_t *)this + 21) = vmul_f32(vadd_f32(*(float32x2_t *)((char *)this + 168), vadd_f32(v15, *(float32x2_t *)((char *)a4 + 56))), (float32x2_t)0x3F0000003F000000);
  v26.n128_u64[0] = (unint64_t)vmul_f32(vadd_f32(v35, *(float32x2_t *)((char *)this + 208)), (float32x2_t)0x3F0000003F000000);
  *((_QWORD *)this + 26) = v26.n128_u64[0];
  v27 = *((_DWORD *)this + 22);
  if (*((_DWORD *)this + 20) == 1)
  {
    if (v27 != 1)
      goto LABEL_17;
  }
  else if (v27 != 1)
  {
    goto LABEL_21;
  }
  v27 = *((_DWORD *)this + 20);
LABEL_17:
  if (v27 > 0xF)
    v28 = 0;
  else
    v28 = *((_DWORD *)this + v27 + 2);
  *((_BYTE *)this + 280) = MTHandMotion::computeInnerOuterSpeedSymmetry(v25, (float *)(*((_QWORD *)a2 + 35) + 600 * *((int *)this + 3)), (float *)(*((_QWORD *)a2 + 35) + 600 * v28)) > 0.85;
LABEL_21:
  if (v21 > 0.0)
  {
    v26.n128_f32[0] = v20 / v21;
    *((float *)this + 54) = vmlas_n_f32(vmuls_lane_f32(v20 / v21, v35, 1), v19 / v21, v35.f32[0])
                          - (float)((float)(v24 * (float)(v20 / v21)) + (float)(v23 * (float)(v19 / v21)));
    *((float *)this + 55) = vmlas_n_f32(-(float)(v35.f32[1] * (float)(v19 / v21)), v20 / v21, v35.f32[0])
                          - (float)((float)(v23 * (float)(v20 / v21)) - (float)(v24 * (float)(v19 / v21)));
    if (a5 && *((_DWORD *)a4 + 34) && *((_DWORD *)a3 + 34) && ((v14 | v16) & 4) != 0)
    {
      v29 = *((float *)a3 + 38) - *((float *)a4 + 38);
      v30 = *((float *)a3 + 39) - *((float *)a4 + 39);
      v31 = sqrtf((float)(v30 * v30) + (float)(v29 * v29));
      v32 = *((float *)a3 + 112);
      v33 = *((float *)a3 + 113);
      v34 = *(float32x2_t *)((char *)a4 + 448);
      *((float32x2_t *)this + 24) = vmul_f32(vadd_f32(v34, *(float32x2_t *)((char *)this + 192)), (float32x2_t)0x3F0000003F000000);
      v26.n128_f32[0] = vmlas_n_f32(-(float)(v34.f32[1] * (float)(v19 / v21)), v26.n128_f32[0], v34.f32[0])
                      - (float)((float)(v32 * v26.n128_f32[0]) - (float)(v33 * (float)(v19 / v21)));
      *((float *)this + 50) = v21 - v31;
      *((float *)this + 51) = v26.n128_f32[0];
    }
    if ((*((_DWORD *)a3 + 11) - 3) <= 1
      && (*((_DWORD *)a3 + 35) - 3) <= 1
      && MTParserPath::isFingerContact(a3)
      && *((unsigned __int8 *)this + 101) >= 3u)
    {
      MTHandMotion::combineCentralFingerScaleRotate((uint64_t)this, a2, a3);
    }
    if (*((_BYTE *)this + 138)
      || *((_DWORD *)this + 20) != 1 && *((_DWORD *)this + 22) != 1 && *((_BYTE *)this + 139)
      || *((unsigned __int8 *)this + 101) > 2u
      || *((_BYTE *)this + 376))
    {
      MTHandMotion::extractFastestFingerTranslation((_BOOL8)this, a2, v26);
    }
  }
}

uint64_t MTHandMotion::combineCentralFingerScaleRotate(uint64_t this, const MTPathStates *a2, const MTParserPath *a3)
{
  int v3;
  uint64_t v6;
  int v7;
  float v8;
  float v9;
  float v10;
  float v11;
  unsigned int v12;
  uint64_t v13;
  float *v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;

  v3 = *(_DWORD *)(this + 80) + 1;
  if (v3 < *(_DWORD *)(this + 88))
  {
    v6 = this;
    v7 = 0;
    v8 = *((float *)a3 + 125);
    v9 = *((float *)a3 + 126);
    v10 = 0.0;
    v11 = 0.0;
    do
    {
      if (v3 <= 0xF)
      {
        v12 = *(_DWORD *)(v6 + 4 * v3 + 8);
        if ((int)v12 >= 1)
        {
          v13 = *((_QWORD *)a2 + 35);
          this = v13 + 600 * v12;
          if ((*(_DWORD *)(this + 44) - 3) <= 1
            && (*(_DWORD *)(v13 + 600 * v12 + 140) - 3) <= 1)
          {
            this = MTParserPath::isFingerContact((MTParserPath *)this);
            if ((_DWORD)this)
            {
              v14 = (float *)(v13 + 600 * v12);
              v15 = v14[14] - *((float *)a3 + 14);
              v16 = v14[15] - *((float *)a3 + 15);
              v17 = v14[38] - *((float *)a3 + 38);
              v18 = sqrtf((float)(v16 * v16) + (float)(v15 * v15));
              v10 = v10
                  + (float)(v18
                          - sqrtf((float)((float)(v14[39] - *((float *)a3 + 39)) * (float)(v14[39] - *((float *)a3 + 39)))+ (float)(v17 * v17)));
              v11 = v11
                  + (float)((float)((float)(v14[126] * (float)(v16 / v18)) + (float)(v14[125] * (float)(v15 / v18)))
                          - (float)((float)(v9 * (float)(v16 / v18)) + (float)(v8 * (float)(v15 / v18))));
              ++v7;
            }
          }
        }
      }
      ++v3;
    }
    while (v3 < *(_DWORD *)(v6 + 88));
    if (v7 > 0)
    {
      v19 = v10 / (float)v7;
      v20 = v11 / (float)v7;
      v21 = *(float *)(v6 + 200);
      if (fabsf(v19) > fabsf(v21))
        *(float *)(v6 + 200) = (float)(v19 + v21) * 0.5;
      v22 = *(float *)(v6 + 216);
      if (fabsf(v20) > fabsf(v22))
        *(float *)(v6 + 216) = (float)(v20 + v22) * 0.5;
    }
  }
  return this;
}

BOOL MTHandMotion::extractFastestFingerTranslation(_BOOL8 this, const MTPathStates *a2, __n128 a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float32x2_t v7;
  float32x2_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  int v13;
  float v14;
  __n128 v15;
  float32x2_t v16;
  __n128 v17;

  v4 = this;
  v5 = 0;
  v6 = this + 12;
  v7 = 0;
  a3.n128_u32[0] = 0;
  v17 = a3;
  v8 = 0;
  do
  {
    v9 = *(_DWORD *)(v6 + v5);
    if ((int)v9 >= 1)
    {
      v10 = *((_QWORD *)a2 + 35);
      if ((*(_DWORD *)(v10 + 600 * v9 + 44) - 3) <= 1)
      {
        this = MTParserPath::isFingerContact((MTParserPath *)(v10 + 600 * v9));
        if (this)
        {
          v11 = v10 + 600 * v9;
          v12 = *(float *)(v11 + 536) + 0.5;
          v13 = *(_DWORD *)(v4 + 128);
          if (v13 >= 1000 && v5 == 16 && v13 <= 0x7CF)
          {
            v14 = (float)(v12 * 0.5) * 0.5;
            if (*(unsigned __int8 *)(v4 + 101) > 4u)
              v12 = v12 * 0.5;
            else
              v14 = *(float *)(v11 + 536) + 0.5;
          }
          else
          {
            v14 = *(float *)(v11 + 536) + 0.5;
          }
          v15 = v17;
          v15.n128_f32[0] = v17.n128_f32[0] + v12;
          v17 = v15;
          v7 = vmla_n_f32(v7, *(float32x2_t *)(v11 + 448), v14);
          v8 = vmla_n_f32(v8, *(float32x2_t *)(v11 + 500), v14);
        }
      }
    }
    v5 += 4;
  }
  while (v5 != 20);
  if (v17.n128_f32[0] > 0.0)
  {
    v16 = (float32x2_t)vdup_lane_s32((int32x2_t)v17.n128_u64[0], 0);
    v7 = vdiv_f32(v7, v16);
    v8 = vdiv_f32(v8, v16);
  }
  *(float32x2_t *)(v4 + 192) = v7;
  *(float32x2_t *)(v4 + 208) = v8;
  return this;
}

float MTHandMotion::getSpeedSymmetry(MTHandMotion *this, float a2, int a3)
{
  float v4;

  switch(a3)
  {
    case 1:
      v4 = *((float *)this + 68);
      return powf(v4, a2);
    case 2:
      v4 = *((float *)this + 67);
      return powf(v4, a2);
    case 4:
      v4 = *((float *)this + 66);
      return powf(v4, a2);
    case 7:
      return 1.0 - powf(*((float *)this + 65), a2);
    default:
      if ((*((_DWORD *)this + 32) - 1000) > 0x3E7)
        v4 = *((float *)this + 64);
      else
        v4 = *((float *)this + 65);
      return powf(v4, a2);
  }
}

uint64_t MTHandMotion::fastest1FingerMask(MTHandMotion *this, const MTPathStates *a2, float *a3)
{
  uint64_t v5;
  uint64_t v6;
  char *v7;
  unsigned int v8;
  uint64_t v9;
  float v10;

  v5 = 0;
  v6 = 0;
  v7 = (char *)this + 12;
  do
  {
    v8 = *(_DWORD *)&v7[4 * v5];
    if ((int)v8 >= 1)
    {
      v9 = *((_QWORD *)a2 + 35);
      if ((*(_DWORD *)(v9 + 600 * v8 + 44) - 3) <= 1
        && MTParserPath::isFingerContact((MTParserPath *)(v9 + 600 * v8))
        && !*(_BYTE *)(v9 + 600 * v8 + 581))
      {
        v10 = *(float *)(v9 + 600 * v8 + 536);
        if (v10 > *a3)
        {
          v6 = (1 << v5);
          *a3 = v10;
        }
      }
    }
    ++v5;
  }
  while (v5 != 5);
  return v6;
}

uint64_t MTHandMotion::fastest2FpairMask(MTHandMotion *this, const MTPathStates *a2)
{
  uint64_t v3;
  char *v4;
  float v5;
  float v6;
  float v7;
  unsigned int v8;
  uint64_t v9;
  float v10;
  unsigned int v12;

  v3 = 0;
  v4 = (char *)this + 16;
  v5 = 0.0;
  v6 = 0.0;
  v7 = 0.0;
  do
  {
    v8 = *(_DWORD *)&v4[4 * v3];
    if ((int)v8 >= 1)
    {
      v9 = *((_QWORD *)a2 + 35);
      if ((*(_DWORD *)(v9 + 600 * v8 + 44) - 3) <= 1)
      {
        MTParserPath::isFingerContact((MTParserPath *)(v9 + 600 * v8));
        switch((int)v3)
        {
          case 0:
            v7 = v7 + *(float *)(v9 + 600 * v8 + 536);
            break;
          case 1:
            v10 = *(float *)(v9 + 600 * v8 + 536);
            v7 = v7 + v10;
            goto LABEL_8;
          case 2:
            v10 = *(float *)(v9 + 600 * v8 + 536);
            v5 = v5 + v10;
LABEL_8:
            v6 = v6 + v10;
            break;
          case 3:
            v5 = v5 + *(float *)(v9 + 600 * v8 + 536);
            break;
          default:
            break;
        }
      }
    }
    ++v3;
  }
  while (v3 != 4);
  if (v5 <= v6 || v5 <= v7)
    v12 = 6;
  else
    v12 = 24;
  if (v6 <= v5 || v6 <= v7)
    return v12;
  else
    return 12;
}

void MTHandMotion::computeSpeedSymmetry(MTHandMotion *this, const MTPathStates *a2, unsigned int a3, float a4, float a5)
{
  uint64_t v9;
  char *v10;
  float v11;
  float v12;
  float v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  float v17;
  float v18;

  v9 = 0;
  v10 = (char *)this + 12;
  v11 = 0.0;
  v12 = 0.0;
  v13 = 1.0;
  do
  {
    v14 = *(_DWORD *)&v10[4 * v9];
    if ((int)v14 >= 1)
    {
      v15 = *((_QWORD *)a2 + 35);
      v16 = v15 + 600 * v14;
      if ((*(_DWORD *)(v16 + 44) - 3) <= 1)
      {
        v17 = *(float *)(v16 + 536);
        if (MTParserPath::isFingerContact((MTParserPath *)(v15 + 600 * v14)))
        {
          v18 = v17 + 1.0;
          if (((a3 >> v9) & 1) != 0)
          {
            v13 = v13 * v18;
            v12 = v12 + v18;
            v11 = v11 + 1.0;
          }
          else if (a4 > 0.0 && !*(_BYTE *)(v15 + 600 * v14 + 581) && v18 <= a4)
          {
            v13 = v13 * powf(1.0 - (float)(v18 / a4), a5);
          }
        }
      }
    }
    ++v9;
  }
  while (v9 != 5);
  if (v11 > 0.0)
    pow(v13, 1.0 / v11);
}

void MTHandMotion::computeSpeedSymmetries(MTHandMotion *this, const MTPathStates *a2, unsigned int a3)
{
  int v6;
  int v7;
  unsigned __int16 v8;
  float v9;
  int v10;
  unsigned __int16 v11;
  int v12;
  int v13;
  float v14;

  MTHandMotion::computeSpeedSymmetry(this, a2, 0x1Fu, 0.0, 1.0);
  *((_DWORD *)this + 64) = v6;
  MTHandMotion::computeSpeedSymmetry(this, a2, a3, 0.0, 1.0);
  *((_DWORD *)this + 65) = v7;
  v14 = 0.0;
  v8 = MTHandMotion::fastest1FingerMask(this, a2, &v14);
  v9 = v14;
  MTHandMotion::computeSpeedSymmetry(this, a2, v8, v14, 1.0);
  *((_DWORD *)this + 68) = v10;
  v11 = MTHandMotion::fastest2FpairMask(this, a2);
  MTHandMotion::computeSpeedSymmetry(this, a2, v11, v9, 2.0);
  *((_DWORD *)this + 67) = v12;
  MTHandMotion::computeSpeedSymmetry(this, a2, 0x1Eu, v9, 2.0);
  *((_DWORD *)this + 66) = v13;
}

void MTHandMotion::computeThreeFingerWithThumbSpeedSymmetry(MTHandMotion *this, const MTPathStates *a2)
{
  *((float *)this + 69) = MTPathStates::get_3F_IncludingThumbSpeedSymmetry(a2);
}

float MTHandMotion::computeTrackpadDominanceWeights(MTHandMotion *this, float *a2, float *a3)
{
  float result;
  unsigned int v4;
  int v5;
  float v6;
  float v7;
  float v8;

  if (!*((_BYTE *)this + 138)
    && ((result = *((float *)this + 87), *((_DWORD *)this + 20) == 1)
     || *((_DWORD *)this + 22) == 1
     || !*((_BYTE *)this + 139))
    && (v4 = *((unsigned __int8 *)this + 101), v4 <= 2))
  {
    *a2 = 0.45;
    *a3 = 0.45;
  }
  else
  {
    result = *((float *)this + 90);
    v4 = *((unsigned __int8 *)this + 101);
    *a2 = 0.45;
    *a3 = 0.45;
    if (v4 == 5)
      goto LABEL_7;
  }
  if (*((_DWORD *)this + 20) != 1 && *((_DWORD *)this + 22) != 1)
  {
    if (v4 >= 3)
    {
      v5 = 1036831949;
      goto LABEL_17;
    }
    if (result <= 55.0)
    {
      if (result <= 35.0)
      {
LABEL_23:
        result = *((float *)this + 58);
        if (result < 0.0)
        {
          v7 = *((float *)this + 57);
          if (v7 > 0.0)
          {
            v8 = fabsf(*((float *)this + 56)) + fabsf(*((float *)this + 59));
            result = v7 - result;
            if (result > 0.0 && v8 < result)
            {
              result = *a2 / (float)(2.0 - (float)((float)(v8 / result) * (float)(v8 / result)));
              *a2 = result;
            }
          }
        }
        return result;
      }
      v6 = (float)((float)(result + -35.0) / 20.0) + 0.45;
    }
    else
    {
      v6 = 1.45;
    }
    *a2 = v6;
    *a3 = v6;
    goto LABEL_23;
  }
  if (v4 < 4)
  {
    v5 = 1075629261;
    goto LABEL_17;
  }
  if (!*((_BYTE *)this + 280))
  {
LABEL_7:
    v5 = 1069128090;
LABEL_17:
    *(_DWORD *)a2 = v5;
    *(_DWORD *)a3 = v5;
  }
  return result;
}

uint64_t MTHandMotion::computeMouseDominanceWeights(uint64_t this, float *a2, float *a3)
{
  *a2 = 1.1;
  *a3 = 1.2;
  if (*(_DWORD *)(this + 80) == 1 || *(_DWORD *)(this + 88) == 1)
  {
    *a2 = 1.4;
    *a3 = 1.6;
  }
  return this;
}

void MTHandMotion::clipMotionToDominantAxes(float32x2_t *this, double a2, int a3)
{
  float v6;
  float v7;
  double v8;
  float32x2_t v9;
  float32x2_t v10;
  float64x2_t v11;
  float32x2_t v12;
  float v13;
  unsigned int v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float v18;
  float *v19;
  int v20;
  int v21;
  int v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  BOOL v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  unsigned int v36;
  unsigned int v37;

  v6 = 1.0 - exp(-a2 / this[18].f32[0]);
  if (this[17].i8[2]
    || this[10].i32[0] != 1 && this[11].i32[0] != 1 && this[17].i8[3]
    || (v7 = 1.0, this[12].u8[5] >= 3u))
  {
    v7 = this[32].f32[0];
  }
  v8 = 1.0 - v6;
  v9 = this[26];
  v10 = this[27];
  v11 = vmlaq_n_f64(vcvtq_f64_f32(vmul_n_f32(v9, v6)), vcvtq_f64_f32(this[28]), v8);
  this[31].i32[1] = 1065353216;
  v12 = vcvt_f32_f64(vmlaq_n_f64(vcvtq_f64_f32(vmul_n_f32(vmul_n_f32(v10, v7), v6)), vcvtq_f64_f32(this[29]), v8));
  this[28] = vcvt_f32_f64(v11);
  this[29] = v12;
  v13 = (float)(sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v9, v9).i32[1]), v9.f32[0], v9.f32[0])) * v6)
      + v8 * this[30].f32[0];
  this[30].f32[0] = v13;
  v36 = 1065353216;
  v37 = 1065353216;
  v14 = this[16].i32[0] - 2000;
  if (v14 > 0x3E7)
  {
    MTHandMotion::computeTrackpadDominanceWeights((MTHandMotion *)this, (float *)&v37, (float *)&v36);
    v15 = (float32x2_t)__PAIR64__(v36, v37);
  }
  else if (this[10].i32[0] == 1 || this[11].i32[0] == 1)
  {
    v15 = (float32x2_t)0x3FCCCCCD3FB33333;
  }
  else
  {
    v15 = (float32x2_t)0x3F99999A3F8CCCCDLL;
  }
  v16 = vabs_f32(v12);
  v17 = vmul_f32(v16, v15);
  if (v17.f32[0] <= v17.f32[1])
    v18 = v17.f32[1];
  else
    v18 = v17.f32[0];
  v19 = (float *)&this[35] + 1;
  *(_OWORD *)&this[35].i32[1] = *(_OWORD *)this[28].f32;
  if (!a3)
  {
    if (this[47].i8[0])
      a3 = 3;
    else
      a3 = 0;
  }
  if (v18 < v13)
  {
    if (v13 > 0.0)
      this[31].f32[1] = v18 / v13;
    if (this[19].i8[1])
      *(float32x2_t *)((char *)&this[36] + 4) = 0;
    if (!this[19].i8[0])
      goto LABEL_49;
    if ((a3 & 4) == 0)
      this[25].i32[0] = 0;
    if ((a3 & 8) != 0)
      goto LABEL_49;
LABEL_43:
    this[25].i32[1] = 0;
    goto LABEL_49;
  }
  if (v18 > 0.0)
    this[31].f32[1] = v13 / v18;
  v20 = this[19].u8[1];
  if (this[19].i8[1])
    *(float32x2_t *)((char *)&this[35] + 4) = 0;
  v21 = this[19].u8[0];
  if ((a3 & 3) == 0 && this[19].i8[0])
    this[24] = 0;
  if (a3)
    v22 = 1;
  else
    v22 = 2;
  if (v17.f32[0] <= (float)(v17.f32[1] * (float)v22))
  {
    if (v17.f32[1] > (float)(v17.f32[0] * (float)v22))
    {
      if (v20)
        this[36].i32[1] = 0;
      if (v21)
        this[25].i32[0] = 0;
    }
  }
  else
  {
    if (v20)
      this[37].i32[0] = 0;
    if (v21)
      goto LABEL_43;
  }
LABEL_49:
  v23 = *v19;
  v24 = fabsf(*v19);
  if (v14 <= 0x3E7)
  {
    v25 = fabsf(this[36].f32[0]);
    if (v24 <= (float)(v25 * 2.4751))
    {
      if (v25 > (float)(v24 * 2.4751))
        this[24].i32[0] = 0;
    }
    else
    {
      this[24].i32[1] = 0;
    }
    v26 = fabsf(this[24].f32[0]);
    v27 = fabsf(this[24].f32[1]);
    if (v26 <= (float)(v27 * 2.4751))
    {
      if (v27 > (float)(v26 * 2.4751))
        this[24].i32[0] = 0;
    }
    else
    {
      this[24].i32[1] = 0;
    }
  }
  v28 = this[18].f32[1];
  v29 = 0.0;
  v30 = v24 < v28;
  v31 = 0.0;
  if (!v30)
  {
    if (v23 <= 0.0)
      v31 = v23 + v28;
    else
      v31 = v23 - v28;
  }
  this[35].f32[1] = v31;
  v32 = this[36].f32[0];
  if (fabsf(v32) >= v28)
  {
    if (v32 <= 0.0)
      v29 = v28 + v32;
    else
      v29 = v32 - v28;
  }
  this[36].f32[0] = v29;
  v33 = this[36].f32[1];
  v16.i32[0] = 0;
  v34 = 0.0;
  if (fabsf(v33) >= v28)
  {
    if (v33 <= 0.0)
      v34 = v28 + v33;
    else
      v34 = v33 - v28;
  }
  this[36].f32[1] = v34;
  v35 = this[37].f32[0];
  if (fabsf(v35) >= v28)
  {
    if (v35 <= 0.0)
      v16.f32[0] = v28 + v35;
    else
      v16.f32[0] = v35 - v28;
  }
  this[37].i32[0] = v16.i32[0];
  MTHandMotion::convertPixelDeltasTo_mm_s((MTHandMotion *)this, a2, *(double *)&v16);
  MTHandMotion::convertPixelVelocitiesTo_mm_s((MTHandMotion *)this);
}

void MTHandMotion::convertPixelDeltasTo_mm_s(MTHandMotion *this, double a2, double a3)
{
  double v3;
  int v5;
  int v6;

  v3 = a2;
  LODWORD(a2) = *((_DWORD *)this + 48);
  LODWORD(a3) = *((_DWORD *)this + 49);
  MTSurfaceDimensions::convertPixelDeltasToMillimetersPerSecond(a2, a3, v3);
  *((_DWORD *)this + 79) = v5;
  *((_DWORD *)this + 80) = v6;
  *((float *)this + 81) = MTSurfaceDimensions::convertPixelDeltaToMillimetersPerSecond(*((MTSurfaceDimensions **)this + 15), *((float *)this + 50), v3);
  *((float *)this + 82) = MTSurfaceDimensions::convertPixelDeltaToMillimetersPerSecond(*((MTSurfaceDimensions **)this + 15), *((float *)this + 51), v3);
}

void MTHandMotion::convertPixelVelocitiesTo_mm_s(MTHandMotion *this)
{
  *((float *)this + 83) = MTSurfaceDimensions::convertPixelVelocityToMillimetersPerSecond(*((MTSurfaceDimensions **)this + 15), *((float *)this + 52));
  *((float *)this + 84) = MTSurfaceDimensions::convertPixelVelocityToMillimetersPerSecond(*((MTSurfaceDimensions **)this + 15), *((float *)this + 53));
  *((float *)this + 85) = MTSurfaceDimensions::convertPixelVelocityToMillimetersPerSecond(*((MTSurfaceDimensions **)this + 15), *((float *)this + 54));
  *((float *)this + 86) = MTSurfaceDimensions::convertPixelVelocityToMillimetersPerSecond(*((MTSurfaceDimensions **)this + 15), *((float *)this + 55));
}

float32x2_t MTHandMotion::updateFastestFingerSpeed(uint64_t a1, uint64_t a2)
{
  double v4;
  float v5;
  float v6;
  long double v7;
  float v8;
  long double v9;
  float64x2_t v10;
  float32x2_t result;
  long double v17;
  float v18;

  v4 = *(double *)(a2 + 8) - *(double *)(a2 + 16);
  v5 = 0.0;
  if (v4 <= 0.025)
    v5 = *(float *)(a1 + 368);
  v6 = *(float *)(a2 + 304);
  v7 = v4 / 0.00800000038;
  v8 = pow(dbl_2310BCE70[v6 > v5], v4 / 0.00800000038);
  *(float *)(a1 + 368) = (float)(v6 * (float)(1.0 - v8)) + (float)(v8 * v5);
  v17 = exp2(-v7);
  LODWORD(v18) = *(_QWORD *)(a2 + 316);
  v9 = pow(0.949999988, v7);
  v10.f64[0] = v17;
  v10.f64[1] = v9;
  result = vcvt_f32_f64(v10);
  __asm { FMOV            V2.2S, #1.0 }
  *(float32x2_t *)(a1 + 244) = vmla_f32(vmul_n_f32(vsub_f32(_D2, result), v18), *(float32x2_t *)(a1 + 244), result);
  return result;
}

uint64_t MTHandMotion::makeCollectionEventMask(uint64_t a1, uint64_t a2)
{
  _DWORD *v2;
  uint64_t v3;
  int v4;
  int v6;

  v2 = (_DWORD *)(*(_QWORD *)(a2 + 280) + 644);
  v3 = 31;
  do
  {
    v4 = v2[80];
    if ((*v2 - 5) < 0xFFFFFFFE || (v2[80] & 4) == 0)
    {
      if ((v4 & 0x2000) == 0)
        goto LABEL_8;
    }
    else
    {
      *(_DWORD *)(a1 + 140) |= 4u;
      if ((v4 & 0x2000) == 0)
      {
LABEL_8:
        if ((v4 & 0x800) == 0)
          goto LABEL_9;
        goto LABEL_13;
      }
    }
    *(_DWORD *)(a1 + 140) |= 0x2000u;
    if ((v4 & 0x800) == 0)
    {
LABEL_9:
      if ((v4 & 0x40000) == 0)
        goto LABEL_16;
      goto LABEL_14;
    }
LABEL_13:
    *(_DWORD *)(a1 + 140) |= 0x800u;
    if ((v4 & 0x40000) == 0)
      goto LABEL_16;
LABEL_14:
    v6 = v4 & 0x6000000 | v4 & 0x8000000 | *(_DWORD *)(a1 + 140) | 0x40000;
    *(_DWORD *)(a1 + 140) = v6;
    if ((v4 & 0x1000000) != 0)
      *(_DWORD *)(a1 + 140) = v6 | 0x1000000;
LABEL_16:
    if ((v4 & 0x40) != 0)
    {
      *(_DWORD *)(a1 + 140) |= 0x40u;
      if ((v4 & 0x4000) == 0)
      {
LABEL_18:
        if ((v4 & 0x8000) == 0)
          goto LABEL_20;
LABEL_19:
        *(_DWORD *)(a1 + 140) |= 0x8000u;
        goto LABEL_20;
      }
    }
    else if ((v4 & 0x4000) == 0)
    {
      goto LABEL_18;
    }
    *(_DWORD *)(a1 + 140) |= 0x4000u;
    if ((v4 & 0x8000) != 0)
      goto LABEL_19;
LABEL_20:
    v2 += 150;
    --v3;
  }
  while (v3);
  return *(unsigned int *)(a1 + 140);
}

uint64_t MTHandMotion::processHandMotion(float32x2_t *this, const MTPathStates *a2, int a3, int a4, int a5, float a6, int a7, unsigned int a8)
{
  float v15;
  int v16;
  float v17;
  float v18;
  float v19;
  BOOL v21;
  uint64_t InnermostTouchingPath;
  const MTParserPath *OutermostTouchingPath;
  MTHandMotion *v24;
  const MTPathStates *v25;
  const MTParserPath *v26;
  int v27;
  double v28;
  uint64_t CollectionEventMask;
  uint64_t InnermostInRangePath;

  if ((this[16].i32[0] - 1000) <= 0xBB7)
  {
    v15 = MTPathStates::restingTranslationCertainty(a2);
    this[46].f32[1] = v15;
    if (!a7)
    {
      v16 = *((unsigned __int8 *)a2 + 444);
      if (*((_DWORD *)a2 + 96) - v16 == 2)
      {
        v17 = this[45].f32[0];
        v18 = 0.0;
        if (v17 > 40.0)
        {
          v18 = 1.0;
          if (v17 < 50.0)
            v18 = (float)(v17 + -40.0) / 10.0;
        }
        v19 = v15 * v18;
        v21 = v18 >= 1.0 && v16 != 0;
        if (v19 > 0.9)
          v21 = 1;
      }
      else
      {
        v21 = 0;
      }
      this[47].i8[0] = v21;
    }
  }
  MTFingerToPathMap::updateFingerPathMappings((uint64_t)this, a2);
  if (a3 < 1)
  {
    MTHandMotion::clearHandMotion((MTHandMotion *)this, 0);
    CollectionEventMask = 0;
    this[44].i32[1] = 0;
  }
  else
  {
    this[17].i32[1] = 0;
    MTHandMotion::updateFastestFingerSpeed((uint64_t)this, (uint64_t)a2);
    MTHandMotion::computeSpeedSymmetries((MTHandMotion *)this, a2, a8);
    this[34].f32[1] = MTPathStates::get_3F_IncludingThumbSpeedSymmetry(a2);
    if (a4 > a5)
    {
      this[28] = 0;
      this[29] = 0;
    }
    if (a4)
    {
      InnermostTouchingPath = MTFingerToPathMap::getInnermostTouchingPath((MTFingerToPathMap *)this, a2);
      OutermostTouchingPath = (const MTParserPath *)MTFingerToPathMap::getOutermostTouchingPath((MTFingerToPathMap *)this, a2);
      v24 = (MTHandMotion *)this;
      v25 = a2;
      v26 = (const MTParserPath *)InnermostTouchingPath;
      v27 = 1;
    }
    else
    {
      InnermostInRangePath = MTFingerToPathMap::getInnermostInRangePath((MTFingerToPathMap *)this, a2);
      OutermostTouchingPath = (const MTParserPath *)MTFingerToPathMap::getOutermostInRangePath((MTFingerToPathMap *)this, a2);
      v24 = (MTHandMotion *)this;
      v25 = a2;
      v26 = (const MTParserPath *)InnermostInRangePath;
      v27 = 0;
    }
    MTHandMotion::extractHandMotion(v24, v25, v26, OutermostTouchingPath, v27);
    MTHandMotion::clipMotionToDominantAxes(this, *((double *)a2 + 1) - *((double *)a2 + 2), a7);
    if (this[24].f32[0] != 0.0 || this[24].f32[1] != 0.0 || this[25].f32[0] != 0.0 || this[25].f32[1] != 0.0)
      this[20] = *(float32x2_t *)((char *)a2 + 8);
    CollectionEventMask = MTHandMotion::makeCollectionEventMask((uint64_t)this, (uint64_t)a2);
    this[17].i32[1] = CollectionEventMask;
  }
  MTPathStatesBasic::calculateCentroidOfPaths((uint64_t)a2, this + 23, v28);
  return CollectionEventMask;
}

uint64_t MTHandMotion::storeFeedbackFromMouse(uint64_t result, float a2, float a3)
{
  *(float *)(result + 108) = a2;
  *(float *)(result + 112) = a3;
  return result;
}

float MTHandMotion::getMouseMotionFeedback(MTHandMotion *this, int a2)
{
  float v2;
  float v3;
  float v4;

  if (a2 == 1)
  {
    v2 = *((float *)this + 27);
    v3 = *((float *)this + 28) * 0.8;
    v4 = 0.7;
    return v3 + (float)(v2 * v4);
  }
  if (!a2)
  {
    v2 = *((float *)this + 27);
    v3 = *((float *)this + 28) * 0.7;
    v4 = 0.8;
    return v3 + (float)(v2 * v4);
  }
  return hypotf(*((float *)this + 27), *((float *)this + 28));
}

uint64_t MTHandMotion::storeFeedbackFromButton(uint64_t this, float a2)
{
  *(float *)(this + 116) = a2;
  return this;
}

float MTHandMotion::getButtonMotionFeedback(MTHandMotion *this)
{
  return *((float *)this + 29);
}

uint64_t MTHandStatistics::MTHandStatistics(uint64_t a1, int a2, uint64_t a3, int a4, int a5)
{
  *(_DWORD *)(a1 + 24) = a2;
  *(_QWORD *)a1 = &off_24FFF0738;
  *(_DWORD *)(a1 + 164) = a4;
  *(_DWORD *)(a1 + 168) = a5;
  *(_QWORD *)(a1 + 32) = a3;
  *(_QWORD *)(a1 + 40) = 0;
  MTHandStatistics::clear((MTHandStatistics *)a1, 0);
  return a1;
}

{
  *(_DWORD *)(a1 + 24) = a2;
  *(_QWORD *)a1 = &off_24FFF0738;
  *(_DWORD *)(a1 + 164) = a4;
  *(_DWORD *)(a1 + 168) = a5;
  *(_QWORD *)(a1 + 32) = a3;
  *(_QWORD *)(a1 + 40) = 0;
  MTHandStatistics::clear((MTHandStatistics *)a1, 0);
  return a1;
}

double MTHandStatistics::clear(MTHandStatistics *this, int a2)
{
  char v2;
  uint64_t v3;
  char v4;
  double result;

  if (a2)
  {
    *((_BYTE *)this + 203) = *((_BYTE *)this + 202);
    *((_WORD *)this + 77) = *((_WORD *)this + 76);
    *((_WORD *)this + 79) = *((_WORD *)this + 78);
    *((_BYTE *)this + 192) = *((_BYTE *)this + 191);
    *((_BYTE *)this + 187) = *((_BYTE *)this + 186);
    *((_BYTE *)this + 194) = *((_BYTE *)this + 193);
    *((_BYTE *)this + 189) = *((_BYTE *)this + 188);
    v2 = *((_BYTE *)this + 298);
    *((_BYTE *)this + 299) = v2;
    *((_BYTE *)this + 303) = v2;
    *((_BYTE *)this + 190) = *((_BYTE *)this + 211);
    *((_DWORD *)this + 78) = *((_DWORD *)this + 77);
    v3 = *((_QWORD *)this + 33);
    v4 = *((_BYTE *)this + 316);
  }
  else
  {
    v4 = 0;
    *(_WORD *)((char *)this + 305) = 0;
    *((_DWORD *)this + 51) = 0;
    *((_BYTE *)this + 203) = 0;
    *((_BYTE *)this + 192) = 0;
    *((_BYTE *)this + 187) = 0;
    *((_BYTE *)this + 194) = 0;
    *(_WORD *)((char *)this + 189) = 0;
    *((_WORD *)this + 77) = 0;
    *((_WORD *)this + 79) = 0;
    *((_BYTE *)this + 299) = 0;
    *((_BYTE *)this + 303) = 0;
    *((_DWORD *)this + 78) = 0;
    *((_OWORD *)this + 3) = 0u;
    *((_OWORD *)this + 4) = 0u;
    *((_OWORD *)this + 5) = 0u;
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 7) = 0u;
    *((_OWORD *)this + 8) = 0u;
    *((_QWORD *)this + 18) = 0;
    *((_WORD *)this + 92) = 0;
    *((_QWORD *)this + 22) = 0;
    *(_DWORD *)((char *)this + 197) = 0;
    *(_QWORD *)((char *)this + 212) = 0;
    *((_QWORD *)this + 32) = 0;
    *((_QWORD *)this + 33) = 0;
    v3 = 0;
    *((_QWORD *)this + 35) = 0;
    *((_QWORD *)this + 36) = 0;
  }
  *((_QWORD *)this + 34) = v3;
  *((_BYTE *)this + 317) = v4;
  *(_WORD *)((char *)this + 201) = 0;
  *((_BYTE *)this + 191) = 0;
  *((_BYTE *)this + 186) = 0;
  *((_BYTE *)this + 193) = 0;
  *((_BYTE *)this + 188) = 0;
  *((_DWORD *)this + 77) = 0;
  *(_WORD *)((char *)this + 195) = 0;
  *((_WORD *)this + 76) = 0;
  *((_WORD *)this + 78) = 0;
  *((_WORD *)this + 110) = 0;
  *((_BYTE *)this + 222) = 0;
  *(_QWORD *)&result = 0xFFFFFFFFLL;
  *((_OWORD *)this + 14) = xmmword_2310BCE80;
  *((_DWORD *)this + 40) = 0;
  *((_DWORD *)this + 52) = 0;
  *((_DWORD *)this + 43) = 0;
  *((_WORD *)this + 148) = 0;
  *((_WORD *)this + 150) = 0;
  *((_BYTE *)this + 298) = 0;
  *((_BYTE *)this + 302) = 0;
  *((_BYTE *)this + 304) = 0;
  *((_BYTE *)this + 316) = 0;
  return result;
}

void MTHandStatistics::~MTHandStatistics(MTHandStatistics *this)
{
  *(_QWORD *)this = &off_24FFF0738;
  MTHandStatistics::clear(this, 0);
}

{
  *(_QWORD *)this = &off_24FFF0738;
  MTHandStatistics::clear(this, 0);
}

{
  *(_QWORD *)this = &off_24FFF0738;
  MTHandStatistics::clear(this, 0);
  JUMPOUT(0x2348D0034);
}

uint64_t MTHandStatistics::clearConsecutiveCounts(uint64_t this)
{
  *(_DWORD *)(this + 214) = 0;
  *(_WORD *)(this + 218) = 0;
  return this;
}

uint64_t MTHandStatistics::rollBackSubsetBoundary(uint64_t this)
{
  *(_QWORD *)(this + 256) = 0;
  *(_DWORD *)(this + 214) = 0;
  *(_WORD *)(this + 218) = 0;
  return this;
}

uint64_t MTHandStatistics::updateCumulativeMaxStats(uint64_t this)
{
  unsigned int v1;
  unsigned int v2;
  uint64_t v3;
  unsigned int v4;
  double v5;

  if (*(_DWORD *)(this + 224) == -1)
    *(_DWORD *)(this + 224) = 0;
  if (*(_DWORD *)(this + 232) == -1)
    *(_DWORD *)(this + 232) = 0;
  if (*(_DWORD *)(this + 236) == -1)
    *(_DWORD *)(this + 236) = 0;
  v1 = *(unsigned __int8 *)(this + 186);
  if (*(_BYTE *)(this + 186))
  {
    if (v1 > *(unsigned __int8 *)(this + 197))
      *(_BYTE *)(this + 197) = v1;
    v2 = *(unsigned __int8 *)(this + 195);
    if (v2 > *(unsigned __int8 *)(this + 198))
      *(_BYTE *)(this + 198) = v2;
    if (v1 >= 2)
    {
      v3 = *(_QWORD *)(this + 8);
      *(_QWORD *)(this + 112) = v3;
      if (v1 == 5)
        *(_QWORD *)(this + 120) = v3;
    }
  }
  v4 = *(unsigned __int8 *)(this + 191);
  if (*(_BYTE *)(this + 191))
  {
    if (v4 > *(unsigned __int8 *)(this + 199))
      *(_BYTE *)(this + 199) = v4;
  }
  else if (!*(_BYTE *)(this + 192))
  {
    *(_BYTE *)(this + 197) = 0;
    *(_DWORD *)(this + 204) = 0;
    *(_BYTE *)(this + 200) = *(_BYTE *)(this + 199);
    *(_BYTE *)(this + 199) = 0;
    *(_QWORD *)(this + 64) = 0;
  }
  if (!*(_BYTE *)(this + 195))
    *(_BYTE *)(this + 198) = 0;
  if (*(unsigned __int8 *)(this + 298) != *(unsigned __int8 *)(this + 299))
    *(_QWORD *)(this + 280) = *(_QWORD *)(this + 8);
  v5 = *(double *)(this + 272);
  if (*(double *)(this + 264) < v5)
    *(double *)(this + 264) = v5;
  if (*(_WORD *)(this + 214) == 2 && *(_WORD *)(this + 220) == 7)
  {
    *(_QWORD *)(this + 256) = 0;
    *(_DWORD *)(this + 214) = 0;
    *(_WORD *)(this + 218) = 0;
  }
  return this;
}

uint64_t MTHandStatistics::updateStatsWithPath(uint64_t this, const MTParserPath *a2, int a3, int a4)
{
  uint64_t v6;
  char *v7;

  v6 = this;
  if (a3)
  {
    ++*(_BYTE *)(this + 202);
    if (MTParserPath::isEdgeContact(a2))
      ++*(_BYTE *)(v6 + 208);
    if (MTParserPath::isUnidentifiedContact(a2))
      ++*(_BYTE *)(v6 + 209);
    this = MTParserPath::wasFingerContact(a2);
    if ((_DWORD)this)
    {
      this = MTParserPath::isPalmContact(a2);
      if ((_DWORD)this)
        ++*(_BYTE *)(v6 + 210);
    }
  }
  if (a4)
  {
    if (*((_DWORD *)a2 + 11) == 7)
      v7 = (char *)a2 + 144;
    else
      v7 = (char *)a2 + 48;
    *(_WORD *)(v6 + 220) |= 1 << (*(_DWORD *)v7 - 1);
  }
  return this;
}

uint64_t MTHandStatistics::updateStatsWithFingerPath(uint64_t result, int a2, int a3, uint64_t a4, int a5, int a6, int a7, int a8, float a9, float a10, float a11, char a12, char a13, char a14)
{
  double v14;
  double v15;
  double v16;
  double v17;
  uint64_t v18;

  if (a5 && (a12 & 1) == 0)
  {
    ++*(_BYTE *)(result + 191);
    *(_WORD *)(result + 152) |= 1 << (a3 - 1);
    if (a3 != 1)
      ++*(_BYTE *)(result + 196);
    if (*(double *)(result + 64) == 0.0)
      *(_QWORD *)(result + 64) = *(_QWORD *)a4;
  }
  if (a6)
  {
    if ((a12 & 1) != 0)
    {
      ++*(_BYTE *)(result + 211);
      if (a3 == 1)
        *(_QWORD *)(result + 104) = *(_QWORD *)(a4 + 16);
    }
    else
    {
      ++*(_BYTE *)(result + 186);
      if (*(float *)(result + 204) < a11)
        *(float *)(result + 204) = a11;
      if (a3 != 1)
      {
        ++*(_BYTE *)(result + 195);
        v17 = *(double *)(a4 + 16);
        if (v17 > *(double *)(result + 96))
          *(double *)(result + 96) = v17;
      }
    }
    if ((a7 & 1) != 0
      || (*(_QWORD *)(result + 88) = *(_QWORD *)(result + 80),
          v18 = *(_QWORD *)(a4 + 16),
          *(_QWORD *)(result + 72) = *(_QWORD *)a4,
          *(_QWORD *)(result + 80) = v18,
          *(_DWORD *)(result + 176) = a2,
          *(_BYTE *)(result + 187)))
    {
      if ((a12 & 1) != 0)
        return result;
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 32))(result);
    }
    *(_QWORD *)(result + 56) = v18;
    if ((a12 & 1) == 0)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 32))(result);
  }
  else
  {
    if (a7)
    {
      *(_WORD *)(result + 218) = 0;
      v14 = *(double *)(result + 128);
      if (v14 < *(double *)(result + 80))
        *(_DWORD *)(result + 214) = 0;
      v15 = *(double *)(a4 + 40);
      if (v14 < v15)
      {
        *(double *)(result + 128) = v15;
        *(_DWORD *)(result + 180) = a2;
        *(_BYTE *)(result + 184) = a3 == 1;
        *(_BYTE *)(result + 185) = a14;
        *(_QWORD *)(result + 240) = *(_QWORD *)(result + 248);
        *(float *)(result + 248) = a9;
        *(float *)(result + 252) = a10;
      }
      ++*(_WORD *)(result + 216);
      if (a3 != 1 || *(_BYTE *)(result + 187) == 5)
        ++*(_WORD *)(result + 214);
    }
    if (a8)
    {
      v16 = *(double *)(a4 + 48);
      if (*(double *)(result + 136) < v16)
        *(double *)(result + 136) = v16;
    }
  }
  return result;
}

uint64_t MTHandStatistics::updateSubsetStatsWithFingerPath(uint64_t result, uint64_t a2, char a3, uint64_t a4, char a5, int a6, char a7)
{
  __int16 v7;
  double v8;
  double v9;
  signed int v11;
  signed int *v12;
  unsigned int v13;
  signed int v14;
  unsigned int v15;
  BOOL v16;
  BOOL v17;
  int v19;
  double v20;
  double v21;
  BOOL v22;

  if ((a5 & 1) == 0)
  {
    v7 = *(_WORD *)(result + 218);
    if (!v7)
      *(_WORD *)(result + 212) = *(unsigned __int8 *)(result + 190) + *(unsigned __int8 *)(result + 187);
    *(_WORD *)(result + 218) = v7 + 1;
  }
  v8 = *(double *)(a4 + 16);
  v9 = *(double *)(result + 128);
  if (v8 > v9 && v8 < v9 + 0.02)
  {
    v11 = 0;
    *(_DWORD *)(result + 214) = 0;
    *(_WORD *)(result + 218) = 0;
  }
  else
  {
    v11 = *(unsigned __int16 *)(result + 218);
  }
  v12 = (signed int *)&MTHandStatistics::kMinClutchingSubsetSizeFrom4F;
  v13 = v11 + *(unsigned __int16 *)(result + 212);
  if (v13 != 4)
    v12 = (signed int *)&MTHandStatistics::kMinClutchingSubsetSizeFrom5F;
  if (v8 <= v9
    || *(double *)(result + 256) >= v9
    || *(_BYTE *)(result + 299)
    && !*(_BYTE *)(result + 304)
    && ((v14 = *v12, v15 = *(unsigned __int16 *)(result + 214), v14 <= (int)v15) ? (v16 = v14 <= v11) : (v16 = 0),
        v16 ? (v17 = v13 >= 4) : (v17 = 0),
        !v17 || (a7 & 1) != 0 || v15 <= 1 && *(_BYTE *)(result + 185)))
  {
    v9 = *(double *)(result + 256);
    if ((*(_DWORD *)(result + 164) - 2000) <= 0x3E7 && v8 - v9 > 0.5)
    {
      v9 = *(double *)(a4 + 8);
      *(double *)(result + 256) = v9;
    }
  }
  else
  {
    *(double *)(result + 256) = v9;
    *(_BYTE *)(result + 304) = 1;
  }
  if (v8 >= v9 || (*(_DWORD *)(result + 164) - 1000) <= 0x3E7)
  {
    ++*(_BYTE *)(result + 298);
    v19 = 1 << (a3 - 1);
    *(_WORD *)(result + 296) |= v19;
    v20 = *(double *)(result + 264);
    v21 = *(double *)(a4 + 16);
    v22 = v20 <= v9 || v21 < v20;
    if (v22 || *(_BYTE *)(result + 304))
    {
      *(double *)(result + 264) = v21;
      *(_BYTE *)(result + 304) = 0;
    }
    if (a6)
    {
      ++*(_BYTE *)(result + 302);
      *(_WORD *)(result + 300) |= v19;
    }
  }
  return result;
}

uint64_t MTHandStatistics::updateStatsWithNonFingerPath(uint64_t result, _DWORD *a2, int a3, int a4)
{
  int v4;
  int *v5;
  int v6;

  v4 = a2[11];
  v5 = a2 + 36;
  if (v4 != 7)
    v5 = a2 + 12;
  v6 = *v5;
  if (v6 != 15)
  {
    if (v4 == 1)
    {
      ++*(_BYTE *)(result + 201);
      if (!a3)
      {
LABEL_6:
        if (!a4)
          return result;
        goto LABEL_7;
      }
    }
    else if (!a3)
    {
      goto LABEL_6;
    }
    ++*(_BYTE *)(result + 193);
    *(_WORD *)(result + 156) |= 1 << (v6 - 1);
    if (!a4)
      return result;
LABEL_7:
    ++*(_BYTE *)(result + 188);
  }
  return result;
}

uint64_t MTHandStatistics::makeCollectionEventMask(MTHandStatistics *this, int a2)
{
  int v2;
  _BOOL4 v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;

  v2 = *((_DWORD *)this + 42);
  v3 = (v2 & 0x10) == 0 || *((unsigned __int8 *)this + 193) > *((unsigned __int8 *)this + 194);
  if (!*((_BYTE *)this + 186))
  {
    if (!*((_BYTE *)this + 187))
      goto LABEL_6;
LABEL_9:
    v4 = 2;
    if ((v2 & 0x20) != 0)
      goto LABEL_21;
    goto LABEL_10;
  }
  if (!*((_BYTE *)this + 187))
    goto LABEL_9;
LABEL_6:
  if ((v2 & 0x20) != 0)
  {
    if (*((_BYTE *)this + 189) && !*((_BYTE *)this + 188))
      v4 = 2;
    else
      v4 = 0;
    goto LABEL_21;
  }
  v4 = 0;
LABEL_10:
  if (!*((_BYTE *)this + 191) && *((_BYTE *)this + 192))
  {
    v5 = v3 ? v4 | 0x80 : v4;
    if (*((unsigned __int8 *)this + 209) + *((unsigned __int8 *)this + 208) < *((unsigned __int8 *)this
                                                                                             + 202))
      v4 = v5;
  }
LABEL_21:
  LODWORD(v6) = v4 | 0x80;
  if (a2)
    v6 = v6;
  else
    v6 = v4;
  v7 = *((unsigned __int16 *)this + 76);
  v8 = *((unsigned __int16 *)this + 77);
  if (*((_WORD *)this + 76))
  {
    if (!*((_WORD *)this + 77))
      goto LABEL_30;
    if ((v2 & 0x20) == 0)
    {
      if (v7 == v8)
        return v6;
      return v6 | 0x20;
    }
  }
  else
  {
    if (*((_WORD *)this + 77))
      goto LABEL_30;
    if ((v2 & 0x20) == 0)
      return v6;
    v8 = 0;
  }
  if (*((_WORD *)this + 79))
  {
    if (*((_WORD *)this + 78))
      goto LABEL_31;
  }
  else if (!*((_WORD *)this + 78))
  {
    goto LABEL_31;
  }
LABEL_30:
  v6 = v6 | 1;
LABEL_31:
  if (v7 != v8 || (v2 & 0x20) != 0 && *((unsigned __int16 *)this + 78) != *((unsigned __int16 *)this + 79))
    return v6 | 0x20;
  return v6;
}

uint64_t MTParser::MTParser(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5)
{
  uint64_t *v7;
  uint64_t v8;
  const void *v9;
  uint64_t IsBuiltIn;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t TouchSizeIdentifier;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;

  *(_QWORD *)a1 = &off_24FFF07B8;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 24) = a2;
  *(_DWORD *)(a1 + 32) = a3;
  *(_DWORD *)(a1 + 36) = a4;
  *(_QWORD *)(a1 + 40) = a5;
  *(_OWORD *)(a1 + 48) = 0u;
  v7 = (uint64_t *)(a1 + 48);
  v8 = a1 + 80;
  *(_OWORD *)(a1 + 64) = 0u;
  MTDragManagerEventQueue::MTDragManagerEventQueue((MTDragManagerEventQueue *)(a1 + 80));
  *(_QWORD *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  v9 = *(const void **)(a1 + 24);
  if (v9)
    CFRetain(v9);
  if (*(_QWORD *)(a1 + 40))
  {
    IsBuiltIn = MTDeviceIsBuiltIn();
    v11 = operator new();
    v12 = *(_QWORD *)(a1 + 40);
    v13 = *(unsigned int *)(a1 + 32);
    v14 = *(unsigned int *)(a1 + 36);
    TouchSizeIdentifier = MTDeviceGetTouchSizeIdentifier();
    MTPathStates::MTPathStates(v11, v12, v13, v14, IsBuiltIn, TouchSizeIdentifier);
    *(_QWORD *)(a1 + 64) = v11;
    if (a2 && MTDeviceSupportsForce())
    {
      if ((*(_DWORD *)(a1 + 32) - 1000) > 0x7CF)
      {
        v19 = operator new();
        MTForceManagerLite::MTForceManagerLite(v19, *(_QWORD *)(a1 + 40), *(unsigned int *)(a1 + 32), *(unsigned int *)(a1 + 36), a2);
        *(_QWORD *)(a1 + 216) = v19;
      }
      else
      {
        v16 = operator new();
        MTForceManagement::MTForceManagement(v16);
        *(_QWORD *)(a1 + 200) = v16;
        if (MTDeviceSupportsActuation())
        {
          v17 = operator new();
          MTActuatorManagement::MTActuatorManagement(v17, *(_QWORD *)(a1 + 24));
          *(_QWORD *)(a1 + 208) = v17;
        }
        v18 = *(_QWORD *)(a1 + 200);
        *(_QWORD *)(*(_QWORD *)(a1 + 64) + 352) = v18;
        *(_QWORD *)(a1 + 96) = v18;
      }
    }
    v20 = operator new();
    MTHandStatistics::MTHandStatistics(v20, 1, (uint64_t)"Right", *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 36));
    *v7 = v20;
    v21 = operator new();
    MTHandMotion::MTHandMotion(v21, *(_QWORD *)(a1 + 40), *(unsigned int *)(a1 + 32), *(unsigned int *)(a1 + 36), 1, "Right");
    *(_QWORD *)(a1 + 56) = v21;
    if ((*(_DWORD *)(a1 + 32) - 1000) <= 0x7CF)
    {
      v22 = (_QWORD *)operator new();
      MTPListGestureConfig::MTPListGestureConfig(v22, *(unsigned int *)(a1 + 32), *(unsigned int *)(a1 + 36), IsBuiltIn, v8);
      *(_QWORD *)(a1 + 72) = v22;
    }
  }
  *(_QWORD *)(a1 + 16) = 0;
  v23 = MTEmbeddedStats::create(a2);
  std::shared_ptr<MTEmbeddedStats>::reset[abi:ne180100]<MTEmbeddedStats,void>((_QWORD *)(a1 + 224), (uint64_t)v23);
  if (!*(_QWORD *)(a1 + 224))
    syslog(3, "MultitouchHID: failed to construct MTEmbeddedStats");
  MTParser::clear((_QWORD *)a1, 0, 0, v24);
  return a1;
}

void sub_23107D070(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x2348D0034](v2, 0x1020C405EDD67E7);
  std::shared_ptr<MTEmbeddedStats>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void std::shared_ptr<MTEmbeddedStats>::reset[abi:ne180100]<MTEmbeddedStats,void>(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  __int128 v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  __int128 v7;

  std::shared_ptr<MTEmbeddedStats>::shared_ptr[abi:ne180100]<MTEmbeddedStats,void>(&v7, a2);
  v3 = (std::__shared_weak_count *)a1[1];
  v4 = v7;
  *(_QWORD *)&v7 = *a1;
  *((_QWORD *)&v7 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void MTParser::~MTParser(MTParser *this)
{
  uint64_t v2;
  const void *v3;
  const void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  MTForceManagement *v9;
  MTActuatorManagement *v10;
  uint64_t v11;

  *(_QWORD *)this = &off_24FFF07B8;
  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    *((_QWORD *)this + 9) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 3);
  if (v3)
  {
    CFRelease(v3);
    *((_QWORD *)this + 3) = 0;
  }
  v4 = (const void *)*((_QWORD *)this + 2);
  if (v4)
  {
    CFRelease(v4);
    *((_QWORD *)this + 2) = 0;
  }
  v5 = *((_QWORD *)this + 6);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = *((_QWORD *)this + 7);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  v7 = *((_QWORD *)this + 8);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  v8 = *((_QWORD *)this + 5);
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  v9 = (MTForceManagement *)*((_QWORD *)this + 25);
  if (v9)
  {
    MTForceManagement::~MTForceManagement(v9);
    MEMORY[0x2348D0034]();
  }
  v10 = (MTActuatorManagement *)*((_QWORD *)this + 26);
  if (v10)
  {
    MTActuatorManagement::~MTActuatorManagement(v10);
    MEMORY[0x2348D0034]();
  }
  v11 = *((_QWORD *)this + 27);
  if (v11)
    MEMORY[0x2348D0034](v11, 0x1020C40774E108FLL);
  std::shared_ptr<MTEmbeddedStats>::~shared_ptr[abi:ne180100]((uint64_t)this + 224);
}

{
  MTParser::~MTParser(this);
  JUMPOUT(0x2348D0034);
}

uint64_t MTParser::retain(uint64_t this)
{
  unsigned int *v1;
  unsigned int v3;

  v1 = (unsigned int *)(this + 8);
  if (!atomic_load((unsigned int *)(this + 8)))
    MTParser::retain();
  do
    v3 = __ldaxr(v1);
  while (__stlxr(v3 + 1, v1));
  return this;
}

unsigned int *MTParser::release(unsigned int *this)
{
  unsigned int *v1;
  unsigned int v3;
  unsigned int v4;

  v1 = this + 2;
  if (!atomic_load(this + 2))
    MTParser::release();
  do
  {
    v3 = __ldaxr(v1);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, v1));
  if (!v4)
    return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)this + 8))(this);
  return this;
}

uint64_t MTParser::createParserForMTDevice(uint64_t a1, unsigned int a2, int a3)
{
  float v6;
  float v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (MTDeviceGetSensorSurfaceDimensions())
  {
    v6 = 75.0;
    v7 = 50.0;
  }
  else
  {
    v7 = (float)0x1B4E81Bu;
    v6 = (float)0x1B4E81Bu;
  }
  if (a2 < 0x3E8)
  {
    if (a2 == 4)
    {
      v9 = operator new();
      MTSurfaceDimensions::MTSurfaceDimensions(v9, 0.0, 0.0, v7, v6, 0.0127, 0.0127);
    }
    else
    {
      v9 = operator new();
      if (a2 == 2)
        MTSurfaceDimensions::MTSurfaceDimensions(v9, 0.0, 0.0, v7, v6, 0.028222, 0.028222);
      else
        MTSurfaceDimensions::MTSurfaceDimensions(v9, 0.0, 0.0, v7, v6, 0.15875, 0.15875);
    }
  }
  else
  {
    v8 = operator new();
    v9 = v8;
    if (a2 - 3000 > 0x3E7)
      MTSurfaceDimensions::MTSurfaceDimensions(v8, 0.0, 0.0, v7, v6, 0.0635, 0.0635);
    else
      MTSurfaceDimensions::MTSurfaceDimensions(v8, 0.0, 0.0, v7, v6, 0.15875, 0.15875);
  }
  v10 = operator new();
  MTParser::MTParser(v10, a1, a2, a3, v9);
  return v10;
}

void sub_23107D55C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x1081C4003DAF236);
  _Unwind_Resume(a1);
}

void MTParser::createMotionAxisChildEvents(uint64_t a1, uint64_t a2, float *a3)
{
  uint64_t TranslationEvent;
  const void *v5;
  uint64_t VelocityEvent;
  const void *v7;
  uint64_t PolarOrientationEvent;
  const void *v9;
  uint64_t v10;
  const void *v11;

  if (a3[48] != 0.0 || a3[49] != 0.0)
  {
    TranslationEvent = IOHIDEventCreateTranslationEvent();
    if (TranslationEvent)
    {
      v5 = (const void *)TranslationEvent;
      IOHIDEventAppendEvent();
      CFRelease(v5);
    }
  }
  if (a3[71] != 0.0 || a3[72] != 0.0)
  {
    VelocityEvent = IOHIDEventCreateVelocityEvent();
    if (VelocityEvent)
    {
      v7 = (const void *)VelocityEvent;
      IOHIDEventAppendEvent();
      CFRelease(v7);
    }
  }
  if (a3[50] != 0.0 || a3[51] != 0.0)
  {
    PolarOrientationEvent = IOHIDEventCreatePolarOrientationEvent();
    if (PolarOrientationEvent)
    {
      v9 = (const void *)PolarOrientationEvent;
      IOHIDEventAppendEvent();
      CFRelease(v9);
    }
    v10 = IOHIDEventCreatePolarOrientationEvent();
    if (v10)
    {
      v11 = (const void *)v10;
      IOHIDEventAppendEvent();
      CFRelease(v11);
    }
  }
}

void MTParser::createDigitizerChildEventForPath(uint64_t a1, int a2, MTParserPath *this, uint64_t a4, char a5, int a6)
{
  uint64_t v8;
  float v9;
  float v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  int isStylusContact;
  const void *DigitizerStylusEventWithPolarOrientation;
  uint64_t VendorDefinedEvent;
  const void *v25;
  uint64_t v26;
  __int16 v27;
  uint64_t VelocityEvent;
  const void *v29;
  uint64_t v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  const void *DigitizerFingerEventWithQuality;

  v8 = *(_QWORD *)(a1 + 64);
  if (v8 && *(_BYTE *)(v8 + 144))
  {
    v9 = *((float *)this + 109);
    v10 = *((float *)this + 108);
  }
  else
  {
    v10 = 0.0;
    v9 = 0.0;
  }
  if ((*((_DWORD *)this + 11) - 3) < 2)
    v11 = a6 ^ 1;
  else
    v11 = 0;
  v12 = *(_QWORD *)(a1 + 40);
  MTParserPath::getQuantizedMinorRadius_mm(this);
  MTSurfaceDimensions::convertMillimetersToSurfaceFraction(v12, 0.0);
  v13 = *(_QWORD *)(a1 + 40);
  MTParserPath::getQuantizedMajorRadius_mm(this);
  MTSurfaceDimensions::convertMillimetersToSurfaceFraction(v13, 0.0);
  v14 = v10 + *((float *)this + 100);
  v15 = v9 + *((float *)this + 101);
  MTSurfaceDimensions::convertPixelsToSurfaceFraction(*(_QWORD *)(a1 + 40), v14);
  MTDeviceGetExtendedMaxDigitizerPressureValue();
  isStylusContact = MTParserPath::isStylusContact(this);
  MTDeviceNotifyWorkInterval();
  if (isStylusContact)
  {
    _H0 = *((_WORD *)this + 55);
    __asm { FCVT            D2, H0 }
    DigitizerStylusEventWithPolarOrientation = (const void *)IOHIDEventCreateDigitizerStylusEventWithPolarOrientation();
    IOHIDEventSetFloatValue();
    IOHIDEventSetFloatValue();
    IOHIDEventSetFloatValue();
    IOHIDEventSetFloatValue();
    IOHIDEventSetIntegerValue();
    IOHIDEventSetIntegerValue();
    IOHIDEventSetIntegerValue();
    if ((*((_WORD *)this + 54) & 0x2000) != 0)
      IOHIDEventSetIntegerValue();
    if (*((_BYTE *)this + 488))
    {
      VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
      if (VendorDefinedEvent)
      {
        v25 = (const void *)VendorDefinedEvent;
        IOHIDEventAppendEvent();
        CFRelease(v25);
      }
    }
  }
  else
  {
    MTContact_getEllipseOrientationDegrees();
    DigitizerStylusEventWithPolarOrientation = (const void *)IOHIDEventCreateDigitizerFingerEventWithQuality();
    IOHIDEventSetIntegerValue();
  }
  if (DigitizerStylusEventWithPolarOrientation)
  {
    v26 = *(_QWORD *)(a1 + 40);
    MTParserPath::getQuantizedRadiusAccuracy_mm(this);
    MTSurfaceDimensions::convertMillimetersToSurfaceFraction(v26, 0.0);
    IOHIDEventSetFloatValue();
    IOHIDEventGetPhase();
    v27 = *((_WORD *)this + 54);
    if ((v27 & 0x4000) != 0)
      IOHIDEventSetPhase();
    if (!v11)
      goto LABEL_34;
    if (MTDeviceShouldDispatchNormalizedVelocity())
    {
      MTSurfaceDimensions::convertPixelsToSurfaceFraction(*(_QWORD *)(a1 + 40), *((float *)this + 16));
    }
    else if (*(_DWORD *)(a1 + 32) != 1001)
    {
LABEL_24:
      if (MTDeviceShouldDispatchRelativeCoordinates())
      {
        if ((a5 & 4) != 0)
        {
          v30 = *(_QWORD *)(a1 + 64);
          v31 = 0.0;
          if (v30)
          {
            v32 = 0.0;
            if (*(_BYTE *)(v30 + 144))
            {
              v32 = *((float *)this + 110);
              v31 = *((float *)this + 111);
            }
          }
          else
          {
            v32 = 0.0;
          }
          v33 = v31 + *((float *)this + 103);
          v34 = v14 - (float)(v32 + *((float *)this + 102));
          v35 = v15 - v33;
          MTSurfaceDimensions::convertPixelDeltaToMillimeters(*(MTSurfaceDimensions **)(a1 + 40), v34, 0);
          MTSurfaceDimensions::convertPixelDeltaToMillimeters(*(MTSurfaceDimensions **)(a1 + 40), v35, 1);
        }
        MTContact_getEllipseOrientationDegrees();
        DigitizerFingerEventWithQuality = (const void *)IOHIDEventCreateDigitizerFingerEventWithQuality();
        IOHIDEventGetEventFlags();
        IOHIDEventSetEventFlags();
        IOHIDEventSetFloatValue();
        if ((v27 & 0x4000) != 0)
          IOHIDEventSetPhase();
        IOHIDEventSetIntegerValue();
        IOHIDEventAppendEvent();
        CFRelease(DigitizerFingerEventWithQuality);
      }
LABEL_34:
      IOHIDEventAppendEvent();
      CFRelease(DigitizerStylusEventWithPolarOrientation);
      return;
    }
    VelocityEvent = IOHIDEventCreateVelocityEvent();
    if (VelocityEvent)
    {
      v29 = (const void *)VelocityEvent;
      IOHIDEventAppendEvent();
      CFRelease(v29);
    }
    goto LABEL_24;
  }
}

void MTParser::createDigitizerPathChildEvents(uint64_t a1, int a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7;
  uint64_t v8;
  int *v9;
  int v10;
  MTParserPath *v12;
  int v13;
  unsigned int v14;
  _BOOL4 v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  _BOOL4 v19;
  int v20;
  int v21;
  int v22;
  int v23;
  char v24;
  int v25;
  char v26;
  int isStylusContact;
  int v28;
  BOOL v29;
  int v30;
  char v31;
  BOOL v32;
  BOOL v33;
  char v34;
  unsigned int v38;

  v7 = 964;
  v8 = 31;
  v38 = *(_DWORD *)(a1 + 36);
  do
  {
    v9 = (int *)(*(_QWORD *)(a3 + 280) + v7);
    v10 = *(v9 - 79);
    if ((*(v9 - 81) - 32) >= 0xFFFFFFE1 && v10 != 15)
    {
      v12 = (MTParserPath *)(v9 - 91);
      v13 = *v9;
      v14 = v10 - 1;
      v15 = v10 != 0;
      v16 = *(v9 - 55) - 1;
      v17 = *(v9 - 80) - 5;
      v18 = *(v9 - 56) - 5;
      v20 = (v38 >> 5) & 1;
      if (v14 > 4)
        v20 = 1;
      v29 = __CFADD__(v18, 2);
      v19 = v14 > 4;
      v21 = v19 & (a4 >> 7);
      if (v29)
        v22 = v19 & (a4 >> 7);
      else
        v22 = 1;
      if (v16 > 4)
        v22 = 1;
      if (v14 < 5)
        v22 = 1;
      if (v22)
        v23 = v21;
      else
        v23 = v15;
      if (v23)
        v24 = v13 | 0x83;
      else
        v24 = v13;
      if (v16 < 5)
        v25 = 1;
      else
        v25 = v20;
      if (v17 < 0xFFFFFFFE)
        v25 = 1;
      if (v25)
        v26 = v24;
      else
        v26 = v24 | 3;
      isStylusContact = MTParserPath::isStylusContact(v12);
      v28 = MTParserPath::wasStylusContact(v12);
      if (v17 >= 0xFFFFFFFE)
      {
        if (v14 < 5)
          v31 = 1;
        else
          v31 = isStylusContact;
        if ((v31 & 1) != 0)
        {
LABEL_53:
          MTParser::createDigitizerChildEventForPath(a1, a2, v12, a6, v26, v23);
          goto LABEL_54;
        }
      }
      else
      {
        v29 = v14 >= 5 && v16 >= 5;
        if (v29)
          v30 = isStylusContact;
        else
          v30 = 1;
        if (((v30 | v28) & 1) != 0)
          goto LABEL_53;
      }
      if ((v38 & 0x20) != 0)
        goto LABEL_53;
      v32 = (a4 & 0x80) != 0 && v17 >= 0xFFFFFFFE;
      v33 = v32 && v14 >= 5;
      v34 = v33 ? isStylusContact : 1;
      if ((((v34 & 1) == 0) | v23) == 1)
        goto LABEL_53;
    }
LABEL_54:
    v7 += 600;
    --v8;
  }
  while (v8);
}

uint64_t MTParser::createHIDCollectionEventsForHand(MTParser *this, const MTPathStates *a2, const MTHandStatistics *a3, const MTHandMotion *a4, unsigned int a5, double a6)
{
  uint64_t v11;
  uint64_t DigitizerEvent;
  uint64_t v13;
  const __CFArray *Children;
  const __CFArray *v15;
  uint64_t v16;

  v11 = mach_absolute_time();
  MTDeviceGetDeviceTimestampOffset();
  if ((*((_DWORD *)a3 + 42) & 0x20) != 0)
  {
    if (*((unsigned __int16 *)a3 + 78) | *((unsigned __int16 *)a3 + 76)
      || *((unsigned __int16 *)a3 + 79) | *((unsigned __int16 *)a3 + 77))
    {
      goto LABEL_9;
    }
  }
  else if (*((_WORD *)a3 + 76) || *((_WORD *)a3 + 77))
  {
    goto LABEL_9;
  }
  if (!*((_BYTE *)a3 + 202))
    return 0;
LABEL_9:
  MTSurfaceDimensions::convertPixelsToSurfaceFraction(*((_QWORD *)this + 5), *((float *)a4 + 46));
  DigitizerEvent = IOHIDEventCreateDigitizerEvent();
  if (DigitizerEvent)
  {
    MTParser::createDigitizerPathChildEvents((uint64_t)this, DigitizerEvent, (uint64_t)a2, a5, v13, v11);
    Children = (const __CFArray *)IOHIDEventGetChildren();
    if (Children)
    {
      v15 = Children;
      if (CFArrayGetCount(Children) >= 1)
      {
        v16 = 0;
        while (!CFArrayGetValueAtIndex(v15, 0) || IOHIDEventGetType() != 11)
        {
          if (++v16 >= CFArrayGetCount(v15))
            return DigitizerEvent;
        }
        IOHIDEventGetIntegerValue();
        IOHIDEventSetIntegerValue();
      }
    }
  }
  return DigitizerEvent;
}

void MTParser::handleForceHIDEvents(uint64_t a1, uint64_t *a2, char a3)
{
  const MTPathStates *v5;
  uint64_t v6;
  CFDictionaryRef *v8;
  uint64_t v9;
  uint64_t v10;
  _BOOL4 isForceButtonActivated;
  NSObject *v12;
  uint64_t v13;
  uint8_t buf[4];
  uint64_t *v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (a2 && (v5 = *(const MTPathStates **)(a1 + 64)) != 0)
  {
    v6 = *(_QWORD *)(a1 + 200);
    if (v6)
    {
      v8 = *(CFDictionaryRef **)(a1 + 208);
      if (v8)
      {
        if (MTForceManagement::actuateForceAndHIDEvents(v6, v5, v8, *a2, a3))
        {
          v9 = *(_QWORD *)(a1 + 48);
          if (v9)
          {
            MTAbsoluteTimeGetCurrent();
            *(_QWORD *)(v9 + 48) = v10;
          }
          isForceButtonActivated = MTForceManagement::isForceButtonActivated(*(MTForceManagement **)(a1 + 200));
          MTParser::setDivingButtonState((MTParser *)a1, isForceButtonActivated);
          MTDragManagerEventQueue::forceButtonChange(a1 + 80, *a2);
        }
      }
    }
  }
  else
  {
    MTDeviceGetDeviceID();
    v12 = MTLoggingPlugin();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      v13 = *(_QWORD *)(a1 + 64);
      *(_DWORD *)buf = 134218496;
      v15 = a2;
      v16 = 2048;
      v17 = v13;
      v18 = 2048;
      v19 = 0;
      _os_log_impl(&dword_231071000, v12, OS_LOG_TYPE_DEBUG, "[HID] Skipping : No base event or path states : %p %p (deviceID 0x%llX)", buf, 0x20u);
    }
  }
}

uint64_t MTParser::setDivingButtonState(MTParser *this, int a2)
{
  uint64_t result;
  uint64_t v5;

  result = *((_QWORD *)this + 8);
  if (result)
    result = MTPathStates::setDivingButtonState(result, a2);
  v5 = *((_QWORD *)this + 6);
  if (v5)
  {
    if (*(unsigned __int8 *)(v5 + 305) != a2)
      *(_QWORD *)(v5 + 288) = *(_QWORD *)(v5 + 8);
    *(_BYTE *)(v5 + 305) = a2;
  }
  return result;
}

uint64_t MTParser::createEmptyHIDCollectionEvent(MTParser *this)
{
  mach_absolute_time();
  return IOHIDEventCreateDigitizerEvent();
}

double MTParser::autoReleaseTapAndAHalfDrag(MTParser *a1, _QWORD *a2, double a3)
{
  double v3;
  uint64_t EmptyHIDCollectionEvent;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t ChordTableForHand;
  int v12;

  v3 = 0.0;
  if (a2)
  {
    if (*((_QWORD *)a1 + 9))
    {
      EmptyHIDCollectionEvent = *((_QWORD *)a1 + 2);
      if (EmptyHIDCollectionEvent
        || (EmptyHIDCollectionEvent = MTParser::createEmptyHIDCollectionEvent(a1),
            (*((_QWORD *)a1 + 2) = EmptyHIDCollectionEvent) != 0))
      {
        v8 = *((_QWORD *)a1 + 6);
        if (v8)
        {
          v9 = MTDragManagerEventQueue::serviceEventQueue((uint64_t)a1 + 80, EmptyHIDCollectionEvent, *((_QWORD *)a1 + 9), *(unsigned __int8 *)(v8 + 211) + *(unsigned __int8 *)(v8 + 186), a3);
          if (IOHIDEventGetChildren())
          {
            v10 = *((_QWORD *)a1 + 7);
            if (v10)
            {
              MTSurfaceDimensions::convertPixelsToSurfaceFraction(*((_QWORD *)a1 + 5), *(float *)(v10 + 184));
              IOHIDEventSetFloatValue();
              IOHIDEventSetFloatValue();
            }
            mach_absolute_time();
            IOHIDEventSetTimeStamp();
            *a2 = *((_QWORD *)a1 + 2);
            *((_QWORD *)a1 + 2) = 0;
          }
          ChordTableForHand = MTGestureConfig::getChordTableForHand(*((_QWORD *)a1 + 9), 1);
          if (ChordTableForHand)
            v12 = v9;
          else
            v12 = 0;
          if (v12 == 1)
            return *(float *)(ChordTableForHand + 372);
        }
      }
    }
  }
  return v3;
}

float MTParser::updateSurfaceDimensions(MTParser *this)
{
  float result;
  float v3;
  float v4;
  float *v5;
  MTPathStates *v6;

  if (MTDeviceGetSensorSurfaceDimensions())
  {
    v3 = 75.0;
    v4 = 50.0;
  }
  else
  {
    v4 = (float)0x1B4E81Bu;
    v3 = (float)0x1B4E81Bu;
  }
  v5 = (float *)*((_QWORD *)this + 5);
  if (v5)
    result = MTSurfaceDimensions::updateScreenBounds_mm(v5, 0.0, 0.0, v4, v3);
  v6 = (MTPathStates *)*((_QWORD *)this + 8);
  if (v6)
    return MTPathStates::updateSurfaceDimensions(v6);
  return result;
}

uint64_t MTParser::processForceHIDEvents(uint64_t a1, const MTPathStates *a2)
{
  MTForceManagerLite *v2;

  v2 = *(MTForceManagerLite **)(a1 + 216);
  if (v2)
    MTForceManagerLite::updatePaths(v2, a2);
  return 1;
}

uint64_t MTParser::getNonRestingFingerCount(MTParser *this, int a2)
{
  uint64_t v2;
  unsigned int v3;
  int v4;

  v2 = *((_QWORD *)this + 6);
  if (!v2)
    return 0;
  v3 = *(unsigned __int8 *)(v2 + 186);
  if (a2)
  {
    if (v3 <= *(unsigned __int8 *)(v2 + 195))
      v4 = 0;
    else
      v4 = -1;
  }
  else
  {
    v4 = 0;
  }
  return v4 + v3;
}

void MTParser::handleFrameHeader(uint64_t a1, _OWORD *a2)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 224);
  if (v2)
    MTEmbeddedStats::handleFrameHeader(v2, a2);
}

uint64_t MTParser::systemForceResponseEnabledChanged(MTParser *this)
{
  uint64_t result;
  uint64_t v3;

  result = *((_QWORD *)this + 3);
  if (result)
  {
    v3 = *((_QWORD *)this + 25);
    if (v3)
    {
      result = MTDeviceGetSystemForceResponseEnabled();
      *(_BYTE *)(v3 + 594) = result;
    }
  }
  return result;
}

uint64_t MTParser::setHostClickControlEnabled(uint64_t this, char a2)
{
  int v2;

  if (*(_QWORD *)(this + 24))
  {
    this = *(_QWORD *)(this + 200);
    if (this)
    {
      v2 = *(unsigned __int8 *)(this + 595);
      *(_BYTE *)(this + 595) = a2;
      if (v2)
      {
        if ((a2 & 1) == 0)
          return MTForceManagement::clearState(this, 1);
      }
    }
  }
  return this;
}

BOOL MTParser::getHostClickControlEnabled(MTParser *this)
{
  uint64_t v1;

  return *((_QWORD *)this + 3) && (v1 = *((_QWORD *)this + 25)) != 0 && *(_BYTE *)(v1 + 595) != 0;
}

uint64_t MTParser::alwaysGenerateNotificationCenterGestures(MTParser *this, int a2)
{
  uint64_t result;
  int v4;

  result = *((_QWORD *)this + 9);
  if (result)
  {
    result = MTGestureConfig::getChordTableForHand(result, 1);
    if (result)
    {
      if (a2)
        v4 = 32;
      else
        v4 = 128;
      *(_DWORD *)(result + 24) = *(_DWORD *)(result + 24) & 0xFFFFFF5F | v4;
    }
  }
  return result;
}

uint64_t MTParser::alwaysGenerateNotificationCenterAltGestures(MTParser *this, int a2)
{
  uint64_t result;
  int v4;

  result = *((_QWORD *)this + 9);
  if (result)
  {
    result = MTGestureConfig::getChordTableForHand(result, 1);
    if (result)
    {
      if (a2)
        v4 = 256;
      else
        v4 = 128;
      *(_DWORD *)(result + 24) = *(_DWORD *)(result + 24) & 0xFFFFFE7F | v4;
    }
  }
  return result;
}

float MTParser::updatePixelResolution_mm(MTParser *this, double a2)
{
  float32x2_t *v3;
  MTPathStates *v4;

  v3 = (float32x2_t *)*((_QWORD *)this + 5);
  if (v3)
    LODWORD(a2) = MTSurfaceDimensions::updatePixelResolution_mm(v3, *(float32x2_t *)&a2, *(float32_t *)&a2).u32[0];
  v4 = (MTPathStates *)*((_QWORD *)this + 8);
  if (v4)
    *(float *)&a2 = MTPathStates::updateResolutionDependentParams(v4);
  return *(float *)&a2;
}

uint64_t MTParser::feedbackMomentumTimerStatus(uint64_t a1, int a2, char a3)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 72);
  if (result)
  {
    result = MTGestureConfig::getChordTableForHand(result, 1);
    if (result)
    {
      *(_DWORD *)(result + 1276) = a2;
      *(_BYTE *)(result + 1272) = a3;
    }
  }
  return result;
}

void MTForceManagement::~MTForceManagement(MTForceManagement *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void **v7;

  MTForceClickHistory::~MTForceClickHistory((MTForceManagement *)((char *)this + 512));
  v7 = (void **)((char *)this + 464);
  std::vector<MTForceThresholding>::__destroy_vector::operator()[abi:ne180100](&v7);
  v7 = (void **)((char *)this + 264);
  std::vector<std::vector<MTForceBehavior>>::__destroy_vector::operator()[abi:ne180100](&v7);
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 16);
  if (v3)
  {
    *((_QWORD *)this + 17) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 13);
  if (v4)
  {
    *((_QWORD *)this + 14) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 10);
  if (v5)
  {
    *((_QWORD *)this + 11) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 7);
  if (v6)
  {
    *((_QWORD *)this + 8) = v6;
    operator delete(v6);
  }
}

void std::vector<MTForceThresholding>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void (***v2)(_QWORD);
  void (***v4)(_QWORD);
  void *v5;
  void (***v6)(_QWORD);
  BOOL v7;

  v1 = *a1;
  v2 = (void (***)(_QWORD))**a1;
  if (v2)
  {
    v4 = (void (***)(_QWORD))v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 59;
      do
      {
        (**v6)(v6);
        v7 = v6 == v2;
        v6 -= 59;
      }
      while (!v7);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::vector<MTForceBehavior>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;
  void **v6;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        v6 = v4;
        std::vector<MTForceBehavior>::__destroy_vector::operator()[abi:ne180100](&v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<MTForceBehavior>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 18;
        std::allocator<MTForceBehavior>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<MTForceBehavior>::destroy[abi:ne180100](uint64_t a1, _QWORD *a2)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v3 = (void *)a2[15];
  if (v3)
  {
    a2[16] = v3;
    operator delete(v3);
  }
  v4 = (void *)a2[12];
  if (v4)
  {
    a2[13] = v4;
    operator delete(v4);
  }
  v5 = (void *)a2[9];
  if (v5)
  {
    a2[10] = v5;
    operator delete(v5);
  }
  v6 = (void *)a2[6];
  if (v6)
  {
    a2[7] = v6;
    operator delete(v6);
  }
  v7 = (void *)a2[3];
  if (v7)
  {
    a2[4] = v7;
    operator delete(v7);
  }
}

uint64_t std::shared_ptr<MTEmbeddedStats>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

_QWORD *std::shared_ptr<MTEmbeddedStats>::shared_ptr[abi:ne180100]<MTEmbeddedStats,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_24FFF07E8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_23107EAF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<MTEmbeddedStats>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<MTEmbeddedStats *,std::shared_ptr<MTEmbeddedStats>::__shared_ptr_default_delete<MTEmbeddedStats,MTEmbeddedStats>,std::allocator<MTEmbeddedStats>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2348D0034);
}

uint64_t std::__shared_ptr_pointer<MTEmbeddedStats *,std::shared_ptr<MTEmbeddedStats>::__shared_ptr_default_delete<MTEmbeddedStats,MTEmbeddedStats>,std::allocator<MTEmbeddedStats>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
  {
    std::shared_ptr<MTEmbeddedStats>::~shared_ptr[abi:ne180100](result);
    JUMPOUT(0x2348D0034);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<MTEmbeddedStats *,std::shared_ptr<MTEmbeddedStats>::__shared_ptr_default_delete<MTEmbeddedStats,MTEmbeddedStats>,std::allocator<MTEmbeddedStats>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
    return 1;
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3))
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  return 0;
}

uint64_t std::unique_ptr<MTEmbeddedStats>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    std::shared_ptr<MTEmbeddedStats>::~shared_ptr[abi:ne180100](result);
    JUMPOUT(0x2348D0034);
  }
  return result;
}

MTPathStates *MTPathStates::MTPathStates(MTPathStates *a1, uint64_t a2, unsigned int a3, unsigned int a4, char a5, int a6)
{
  uint64_t v7;

  v7 = MTPathStatesBasic::MTPathStatesBasic((uint64_t)a1, a2, a3, a4, a5, a6);
  *(_QWORD *)v7 = &off_24FFF0860;
  MTRestZoneIntegrator::MTRestZoneIntegrator(v7 + 520, *(_QWORD *)(v7 + 40), *(unsigned int *)(v7 + 24), *(unsigned int *)(v7 + 28));
  (*(void (**)(MTPathStates *))(*(_QWORD *)a1 + 16))(a1);
  (*(void (**)(MTPathStates *))(*(_QWORD *)a1 + 24))(a1);
  MTPathStates::updateSurfaceDimensions(a1);
  *((_QWORD *)a1 + 44) = 0;
  return a1;
}

void sub_23107ECA8(_Unwind_Exception *a1)
{
  MTPathStatesBasic *v1;

  MTPathStatesBasic::~MTPathStatesBasic(v1);
  _Unwind_Resume(a1);
}

float MTPathStates::updateSurfaceDimensions(MTPathStates *this)
{
  uint64_t AppIntegerValue;
  uint64_t v3;
  float v4;
  float v5;
  float v6;
  float v7;
  unsigned __int8 v9;
  unsigned __int8 v10;

  if ((*((_DWORD *)this + 6) - 1000) <= 0xBB7)
  {
    v10 = 0;
    AppIntegerValue = MTPreferencesGetAppIntegerValue(CFSTR("ThumbZoneHeight"), CFSTR("com.apple.MultitouchSupport"), &v10);
    v9 = 0;
    v3 = MTPreferencesGetAppIntegerValue(CFSTR("ThumbZoneHeightRatio"), CFSTR("com.apple.MultitouchSupport"), &v9);
    MTSurfaceDimensions::convertSurfaceFractionToMillimeters(*((_QWORD *)this + 5), 0.0);
    *((float *)this + 110) = v4;
    if (v9)
    {
      v5 = (double)v3 / 100.0;
    }
    else
    {
      v5 = v4 / 76.0;
      v6 = sqrtf(v4 / 76.0);
      if (v5 < 1.0)
        v5 = v6;
    }
    *((float *)this + 109) = v5;
    v7 = v5 * 12.0;
    if (v10)
      v7 = (float)AppIntegerValue;
    *((float *)this + 108) = v7;
  }
  return MTParameterFactory::updatePathFilterParamsWithNewSurfaceDimensions((uint64_t)this + 48, *((_QWORD *)this + 5));
}

void MTPathStates::~MTPathStates(MTPathStates *this)
{
  *(_QWORD *)this = &off_24FFF0860;
  *((_QWORD *)this + 44) = 0;
  MTRestZoneIntegrator::~MTRestZoneIntegrator((MTPathStates *)((char *)this + 520));
  MTPathStatesBasic::~MTPathStatesBasic(this);
}

{
  *(_QWORD *)this = &off_24FFF0860;
  *((_QWORD *)this + 44) = 0;
  MTRestZoneIntegrator::~MTRestZoneIntegrator((MTPathStates *)((char *)this + 520));
  MTPathStatesBasic::~MTPathStatesBasic(this);
}

{
  *(_QWORD *)this = &off_24FFF0860;
  *((_QWORD *)this + 44) = 0;
  MTRestZoneIntegrator::~MTRestZoneIntegrator((MTPathStates *)((char *)this + 520));
  MTPathStatesBasic::~MTPathStatesBasic(this);
  JUMPOUT(0x2348D0034);
}

double MTPathStates::initializeParams(MTPathStates *this)
{
  MTPathStatesBasic::initializeParams(this);
  return MTParameterFactory::initForceFilterParams((_OWORD *)this + 21);
}

float MTPathStates::updateResolutionDependentParams(MTPathStates *this)
{
  return MTParameterFactory::updatePathFilterParamsWithNewSurfaceDimensions((uint64_t)this + 48, *((_QWORD *)this + 5));
}

uint64_t MTPathStates::setDivingButtonState(uint64_t this, int a2)
{
  if (*(unsigned __int8 *)(this + 372) != a2)
  {
    *(_QWORD *)(this + 400) = *(_QWORD *)(this + 8);
    *(_DWORD *)(this + 408) = *(_DWORD *)(this + 388);
    *(_BYTE *)(this + 424) = 0;
  }
  *(_BYTE *)(this + 372) = a2;
  return this;
}

float MTPathStates::getThumbRestingZoneAdaptiveBase(MTPathStates *this)
{
  return *((float *)this + 108);
}

float MTPathStates::getThumbRestingOrPolarZoneHeight(MTPathStates *this)
{
  return *((float *)this + 109) * 1.8 * *((float *)this + 108);
}

float MTPathStates::getMaxThumbRestingHeight(MTPathStates *this)
{
  return *((float *)this + 110) * flt_2310BCFF8[*((_BYTE *)this + 373) == 0];
}

float MTPathStates::restingTranslationCertainty(MTPathStates *this)
{
  if (*((_BYTE *)this + 372))
    return 1.0;
  else
    return MTRestZoneIntegrator::translationDominance((MTPathStates *)((char *)this + 520), *((_BYTE *)this + 444) == 0);
}

BOOL MTPathStates::isContactOnDivingButton(uint64_t a1, uint64_t a2, double a3)
{
  float v5;
  float v6;
  double v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;

  v5 = a3;
  if (v5 == 0.0)
  {
    v7 = 0.0;
  }
  else
  {
    v6 = fabsf(v5);
    v7 = 1.0;
    if (v6 < 0.2)
      v7 = (float)(v6 / 0.2);
  }
  v8 = *(float *)(a1 + 432);
  v9 = *(float *)(a2 + 60);
  v10 = 0.0;
  if (v9 > 8.0)
  {
    v10 = 1.0;
    if (v9 < 18.0)
      v10 = (float)(v9 + -8.0) / 10.0;
  }
  v11 = pow(v7, 0.75);
  v12 = (float)(v8 + v11) + (float)((float)(v11 + 6.0) * v10);
  MTSurfaceDimensions::convertSurfaceFractionToMillimeters(*(_QWORD *)(a1 + 40), *(float *)(a2 + 32));
  return v13 < v12;
}

uint64_t MTPathStates::countFingersOnDivingButton(MTPathStates *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  float v6;
  uint64_t v7;
  uint64_t v8;
  float v9;
  uint64_t v10;
  _BOOL4 v11;
  _DWORD *v12;
  int v13;
  float v14;
  _DWORD *v15;
  float v16;
  double v17;
  uint64_t v18;
  double v19;
  int v20;
  uint64_t v21;
  int32x2_t v22;
  float *v23;
  uint64_t v24;
  uint64_t v25;
  float *v26;
  MTParserPath *v27;
  float v28;
  float v29;

  *((_DWORD *)this + 96) = 0;
  v2 = 644;
  v3 = 31;
  do
  {
    v4 = *((_QWORD *)this + 35);
    if ((*(_DWORD *)(v4 + v2) - 3) <= 1
      && MTParserPath::isFingerOrRestingContact((MTParserPath *)(v4 + v2 - 44)))
    {
      ++*((_DWORD *)this + 96);
    }
    v2 += 600;
    --v3;
  }
  while (v3);
  v5 = 0;
  v6 = 1000.0;
  v7 = 1;
  v8 = 984;
  v9 = 1000.0;
  do
  {
    v10 = *((_QWORD *)this + 35);
    v11 = *((_QWORD *)this + 44)
       && MTParserPath::isValidClickSource((MTParserPath *)(v10 + v8 - 384))
       && v7 == *(_DWORD *)(*((_QWORD *)this + 44) + 256);
    v12 = (_DWORD *)(v10 + v8 - 340);
    if ((*v12 - 3) > 1)
      goto LABEL_26;
    if (!MTParserPath::isFingerOrRestingContact((MTParserPath *)(v10 + v8 - 384)))
    {
      if (!MTParserPath::isEdgeContact((MTParserPath *)(v10 + v8 - 384)))
        goto LABEL_26;
      v13 = *((int *)this + 96) < 2 || v11;
      if (v13 != 1)
        goto LABEL_26;
    }
    v14 = *(float *)(v10 + v8 - 288);
    v15 = (_DWORD *)(v10 + v8 - 336);
    if (*v12 == 7)
      v15 = (_DWORD *)(v10 + v8 - 240);
    if (*v15 != 1)
      v14 = v14 + *(float *)(v10 + v8);
    if (v14 < v9)
    {
      v16 = v14;
      v5 = v3;
      LODWORD(v3) = v7;
      goto LABEL_27;
    }
    if (v14 < v6)
    {
      v16 = v9;
      v9 = v14;
      v5 = v7;
    }
    else
    {
LABEL_26:
      v16 = v9;
      v9 = v6;
    }
LABEL_27:
    ++v7;
    v8 += 600;
    v6 = v9;
    v9 = v16;
  }
  while (v7 != 32);
  *((_DWORD *)this + 97) = v3;
  *((_QWORD *)this + 47) = 0;
  if ((_DWORD)v3)
  {
    v17 = *((double *)this + 1);
    v18 = *((_QWORD *)this + 35);
    v19 = v17;
    if ((*(_DWORD *)(v18 + 600 * (int)v3 + 44) - 3) <= 1)
      v19 = *(double *)(v18 + 600 * (int)v3 + 232);
    if (v5 && (*(_DWORD *)(v18 + 600 * v5 + 44) - 3) <= 1)
      v17 = *(double *)(v18 + 600 * v5 + 232);
    if (MTPathStates::isContactOnDivingButton((uint64_t)this, v18 + 600 * (int)v3 + 24, v17 - v19))
    {
      ++*((_DWORD *)this + 94);
      if (MTParserPath::isEdgeContact((MTParserPath *)(v18 + 600 * (int)v3)))
        ++*((_DWORD *)this + 95);
    }
    if (v5)
    {
      v20 = *((_DWORD *)this + 94);
      if (v20 >= 1)
      {
        v21 = *((_QWORD *)this + 35);
        v22 = vcgt_f32((float32x2_t)0x4198000041F00000, vabd_f32(*(float32x2_t *)(v18 + 600 * (int)v3 + 92), *(float32x2_t *)(v21 + 600 * v5 + 92)));
        if ((v22.i32[1] & v22.i32[0] & 1) != 0)
        {
          *((_DWORD *)this + 94) = v20 + 1;
          if (MTParserPath::isEdgeContact((MTParserPath *)(v21 + 600 * v5)))
            ++*((_DWORD *)this + 95);
        }
      }
    }
    *((_BYTE *)this + 373) = 0;
    v23 = (float *)(v18 + 600 * (int)v3 + 96);
    v24 = 696;
    v25 = 1;
    while (1)
    {
      if (v3 == v25)
        goto LABEL_48;
      v26 = (float *)(*((_QWORD *)this + 35) + v24);
      if ((*((_DWORD *)v26 - 13) - 3) > 1)
        goto LABEL_48;
      v27 = (MTParserPath *)(v26 - 24);
      v28 = *v26;
      v29 = *v23;
      if (!MTParserPath::isPalmContact((MTParserPath *)(v26 - 24)))
        break;
      if (v28 < v29)
        goto LABEL_47;
LABEL_48:
      ++v25;
      v24 += 600;
      if (v25 == 32)
        return *((unsigned int *)this + 94);
    }
    if (!MTParserPath::isEdgeContact(v27) || v28 >= v29)
      goto LABEL_48;
LABEL_47:
    *((_BYTE *)this + 373) = 1;
    goto LABEL_48;
  }
  return 0;
}

uint64_t MTPathStates::updateDivingBoardDisplacements(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  double v5;
  double v6;

  v1 = this;
  *(_QWORD *)(this + 392) = 0;
  v2 = 1;
  v3 = 832;
  do
  {
    v4 = *(_QWORD *)(v1 + 280);
    if ((*(_DWORD *)(v4 + v3 - 188) - 3) <= 1)
    {
      this = MTParserPath::isFingerContact((MTParserPath *)(v4 + v3 - 232));
      if ((_DWORD)this)
      {
        if (v2 != *(_DWORD *)(v1 + 388))
        {
          v5 = *(double *)(v4 + v3);
          v6 = *(double *)(v1 + 392);
          if (v6 == 0.0 || v5 < v6)
            *(double *)(v1 + 392) = v5;
        }
      }
    }
    ++v2;
    v3 += 600;
  }
  while (v2 != 32);
  return this;
}

void MTPathStates::checkForRestingThumb(MTPathStates *this)
{
  int v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  double v6;
  int v7;
  int *v8;
  int *v9;
  int v10;
  double v11;
  _BOOL4 v12;
  float v13;
  float v14;
  int v15;
  char v16;
  char v17;
  BOOL v18;
  float v20;
  _BOOL4 v22;
  _BOOL4 v23;
  double v24;
  double v25;
  uint64_t v26;
  float v27;
  char v28;
  char v29;

  v2 = *((unsigned __int8 *)this + 444);
  *((_BYTE *)this + 444) = 0;
  MTPathStates::updateDivingBoardDisplacements((uint64_t)this);
  MTRestZoneIntegrator::integrateRestingZoneMotion((float32x2_t *)this + 65, this, *((_DWORD *)this + 96));
  v3 = *((_DWORD *)this + 97);
  if ((int)v3 < 1)
    return;
  v4 = *((_QWORD *)this + 35);
  v5 = v4 + 600 * v3;
  v6 = *(double *)(v5 + 232);
  v7 = *(_DWORD *)(v5 + 44);
  v8 = (int *)(v5 + 144);
  v9 = (int *)(v5 + 48);
  if (v7 == 7)
    v9 = v8;
  v10 = *v9;
  v11 = *((double *)this + 49);
  v12 = v11 > 0.0;
  v13 = v11 - v6;
  v14 = fabsf(v13);
  if (v11 <= 0.0)
    v14 = 0.0;
  *((float *)this + 190) = v14;
  v15 = *((_DWORD *)this + 104);
  if (v15 >= 1 && v10 == 1)
  {
    *((_BYTE *)this + 764) = *((_DWORD *)this + 96) >= v15;
  }
  else
  {
    *((_BYTE *)this + 764) = 0;
    if (v11 > 0.0 && v10 != 1)
    {
      v17 = 0;
      v18 = 0;
      v12 = *((_DWORD *)this + 96) < 3;
      goto LABEL_23;
    }
    if (v10 != 1)
    {
      v17 = 0;
      v18 = 0;
      goto LABEL_23;
    }
  }
  if (!*((_BYTE *)this + 412) && *((_DWORD *)this + 96) == 2)
  {
    v16 = v11 <= 0.0;
    v17 = 1;
LABEL_31:
    v22 = v12;
    goto LABEL_32;
  }
  if (MTRestZoneIntegrator::shouldDoBiPolarIntegration((MTPathStates *)((char *)this + 520), v2 == 0))
  {
    v18 = 0;
  }
  else
  {
    MTSurfaceDimensions::convertPixelsToMillimeters(*((_QWORD *)this + 5), *(float *)(v4 + 600 * v3 + 56));
    v18 = v20 < (float)(*((float *)this + 110) * flt_2310BCFF8[*((_BYTE *)this + 373) == 0]);
  }
  v17 = 1;
LABEL_23:
  v16 = !v12;
  if (!v12 || v18)
    goto LABEL_31;
  v16 = 0;
  v22 = *((_DWORD *)this + 94) == 1 && v10 != 1;
LABEL_32:
  if (*((_BYTE *)this + 372))
    v23 = v12;
  else
    v23 = 0;
  if (*((_BYTE *)this + 424))
  {
    v24 = *((double *)this + 1);
  }
  else
  {
    v24 = *((double *)this + 1);
    if (v24 - *((double *)this + 50) < 0.1)
    {
      if (*((_BYTE *)this + 372))
        v17 = 1;
      if ((v17 & 1) == 0)
        *(_BYTE *)(v4 + 600 * v3 + 584) = 0;
      *((_BYTE *)this + 424) = 1;
    }
  }
  v25 = *((double *)this + 49);
  if (v6 > v25)
    v25 = v6;
  if (v24 - v25 == 0.0)
  {
    v26 = v4 + 600 * v3;
    MTSurfaceDimensions::convertPixelsToMillimeters(*((_QWORD *)this + 5), *(float *)(v26 + 56));
    *(_BYTE *)(v26 + 585) = v27 > (float)(*((float *)this + 110) * flt_2310BCFF8[*((_BYTE *)this + 373) == 0]);
  }
  if (v22 && MTRestZoneIntegrator::isLockedOnTranslate((MTPathStates *)((char *)this + 520)))
  {
    if (*(_BYTE *)(v4 + 600 * v3 + 585))
      v28 = v23;
    else
      v28 = 1;
    if ((v28 & 1) == 0)
      goto LABEL_58;
    goto LABEL_55;
  }
  if (v23)
LABEL_55:
    *(_BYTE *)(v4 + 600 * v3 + 584) = 1;
  if (v22 && !*(_BYTE *)(v4 + 600 * v3 + 585))
    goto LABEL_65;
LABEL_58:
  if (*((_BYTE *)this + 372))
  {
    if (!v12)
      return;
    goto LABEL_65;
  }
  if (*(_BYTE *)(v4 + 600 * v3 + 584))
    v29 = v16;
  else
    v29 = 1;
  if ((v29 & 1) == 0)
  {
LABEL_65:
    if (*((int *)this + 96) < 5 || *((int *)this + 104) <= 0)
      *((_BYTE *)this + 444) = 1;
  }
}

uint64_t MTPathStates::fixupCurledUnderThumbIdentity(MTPathStates *this)
{
  uint64_t v1;
  int v2;
  int v3;
  int v4;
  int v5;
  char v6;
  int v7;
  uint64_t v8;
  float *v9;
  uint64_t result;
  float v11;
  uint64_t v12;
  float v13;
  uint64_t v14;
  _DWORD *v15;
  int v16;
  int v17;
  uint64_t v18;
  _DWORD *v19;
  int v20;
  int v21;
  uint64_t v22;
  _DWORD *v23;
  int v24;
  uint64_t i;
  int v26;

  v1 = 0;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = *((_QWORD *)this + 35);
  v9 = (float *)(v8 + 96);
  do
  {
    result = (*((_DWORD *)v9 - 13) - 1);
    if (result <= 5)
    {
      result = *((unsigned int *)v9 - 12);
      if ((result - 1) <= 4)
      {
        if (!v2 || *(v9 - 1) < *(float *)(v8 + 600 * v2 + 92))
          v2 = v1;
        if (!v3 || *(v9 - 1) > *(float *)(v8 + 600 * v3 + 92))
          v3 = v1;
        if (v4)
        {
          if (*v9 >= *(float *)(v8 + 600 * v4 + 96))
          {
            if (!v5 || *v9 < *(float *)(v8 + 600 * v5 + 96))
              v5 = v1;
            goto LABEL_18;
          }
          v5 = v4;
        }
        else
        {
          v5 = 0;
        }
        v4 = v1;
LABEL_18:
        ++v7;
        result = (_DWORD)result == 1;
        v6 |= result;
      }
    }
    v9 += 150;
    ++v1;
  }
  while (v1 != 32);
  if (v4)
  {
    v11 = *(float *)(v8 + 600 * v3 + 92) - *(float *)(v8 + 600 * v2 + 92);
    if (v11 > 19.0)
    {
      v12 = v8 + 600 * v4;
      if (v4 == v2 || v4 == v3)
      {
        if (!((*(_BYTE *)(v12 + 583) == 0) | v6 & 1))
        {
          v15 = (_DWORD *)(v8 + 600 * v4 + 48);
          goto LABEL_38;
        }
      }
      else
      {
        v13 = (float)(v11 / (float)(v7 - 1)) + -7.0;
        if (v13 < 2.0)
          v13 = 2.0;
        if (v13 > 16.0)
          v13 = 16.0;
        if (*(_BYTE *)(v12 + 583) || *(float *)(v8 + 600 * v4 + 96) < (float)(*(float *)(v8 + 600 * v5 + 96) - v13))
        {
          *(_BYTE *)(v12 + 583) = 1;
          v14 = v8 + 600 * v4;
          v17 = *(_DWORD *)(v14 + 48);
          v15 = (_DWORD *)(v14 + 48);
          v16 = v17;
          if (v17 != 1)
          {
            v18 = v8 + 600 * v2;
            v21 = *(_DWORD *)(v18 + 48);
            v19 = (_DWORD *)(v18 + 48);
            v20 = v21;
            if ((v6 & 1) == 0 || v20 == 1 || *(_DWORD *)(v8 + 600 * v3 + 48) == 1)
            {
              v22 = v8 + 600 * v3;
              v24 = *(_DWORD *)(v22 + 48);
              v23 = (_DWORD *)(v22 + 48);
              if (v20 >= v24)
                *v23 = v16;
              else
                *v19 = v16;
LABEL_38:
              *v15 = 1;
            }
          }
        }
      }
    }
  }
  for (i = 0; i != 32; ++i)
  {
    if ((*(_DWORD *)(v8 + 44) - 1) <= 5 && v4 != i)
    {
      v26 = *(_DWORD *)(v8 + 48);
      if (v26 >= 1 && v26 <= 5)
        *(_BYTE *)(v8 + 583) = 0;
    }
    v8 += 600;
  }
  return result;
}

uint64_t MTPathStates::checkForFingersInZones(MTPathStates *this)
{
  uint64_t result;

  result = MTPathStatesBasic::checkForFingersInZones((uint64_t)this);
  if ((*((_DWORD *)this + 6) - 1000) <= 0xBB7 && *((int *)this + 94) >= 1)
    *((_DWORD *)this + 81) |= 0x10000u;
  return result;
}

double MTPathStates::forwardFirmwareDistributedForces(MTPathStates *this, float a2)
{
  int v3;
  float *v4;
  float *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  MTForceFilter *v9;
  float v10;
  uint64_t v11;
  float v12;
  float v14;
  float v15;
  double result;

  v3 = 0;
  v4 = (float *)*((_QWORD *)this + 35);
  *((_QWORD *)this + 45) = 0;
  v5 = (float *)((char *)this + 336);
  v6 = -31;
  v7 = 896;
  do
  {
    v8 = *((_QWORD *)this + 35);
    v9 = (MTForceFilter *)(v8 + v7);
    if ((*(_DWORD *)(v8 + v7 - 252) - 1) > 5)
    {
      MTForceFilter::clear(v9);
    }
    else
    {
      v10 = *((float *)v9 - 55);
      *((float *)this + 90) = v10 + *((float *)this + 90);
      if (MTParserPath::isValidClickSource((MTForceFilter *)((char *)v9 - 296)))
        *((float *)this + 91) = v10 + *((float *)this + 91);
      v11 = v8 + v7;
      v12 = hypotf(*(float *)(v11 - 196), *(float *)(v11 - 192));
      MTForceFilter::updateForceFilter(v11, v5, v10, v12, *((double *)this + 1) - *((double *)this + 2));
      ++v3;
    }
    v7 += 600;
  }
  while (!__CFADD__(v6++, 1));
  if (v3 <= 0)
    return MTForceFilter::clear((MTForceFilter *)(v4 + 74));
  v14 = *((float *)this + 91);
  v15 = hypotf(v4[25], v4[26]);
  MTForceFilter::updateForceFilter((uint64_t)(v4 + 74), v5, v14, v15, *((double *)this + 1) - *((double *)this + 2));
  return result;
}

BOOL MTPathStates::hasFastestLowpassPeakFingerSpeed(MTPathStates *this, int a2)
{
  int v4;
  float v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v4 = 0;
  v5 = 0.0;
  v6 = -31;
  v7 = 932;
  do
  {
    v8 = *((_QWORD *)this + 35);
    if (MTParserPath::isFingerContact((MTParserPath *)(v8 + v7 - 332))
      && (*(_DWORD *)(v8 + v7 - 288) - 3) <= 1
      && *(float *)(v8 + v7) > v5)
    {
      v4 = v6 + 32;
      v5 = *(float *)(v8 + v7);
    }
    v7 += 600;
  }
  while (!__CFADD__(v6++, 1));
  return v4 == a2;
}

float MTPathStates::sumOfLowpassPeakFingerSpeeds(MTPathStates *this)
{
  float v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = 0.0;
  v3 = 932;
  v4 = 31;
  do
  {
    v5 = *((_QWORD *)this + 35);
    if (MTParserPath::isFingerContact((MTParserPath *)(v5 + v3 - 332))
      && (*(_DWORD *)(v5 + v3 - 288) - 3) <= 1)
    {
      v2 = v2 + *(float *)(v5 + v3);
    }
    v3 += 600;
    --v4;
  }
  while (v4);
  return v2;
}

float MTPathStates::getPrePixelatedPositionFromPostPixelatedPosition(MTPathStates *this, int a2)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21;
  float v22;
  void (**v24)(MTSurfaceDimensions *__hidden);
  __int128 v25;
  __int128 v26;
  _QWORD __dst[38];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;

  memcpy(__dst, &unk_2310BD068, 0x128uLL);
  v4 = *((_QWORD *)this + 35);
  __dst[0] = &off_24FFF08D0;
  v5 = v4 + 600 * a2;
  memcpy(&__dst[1], (const void *)(v5 + 8), 0x11CuLL);
  __dst[37] = &off_24FFF2F50;
  v7 = *(_OWORD *)(v5 + 320);
  v6 = *(_OWORD *)(v5 + 336);
  v28 = *(_OWORD *)(v5 + 304);
  v29 = v7;
  v30 = v6;
  v8 = *(_OWORD *)(v5 + 400);
  v9 = *(_OWORD *)(v5 + 352);
  v10 = *(_OWORD *)(v5 + 368);
  v33 = *(_OWORD *)(v5 + 384);
  v34 = v8;
  v31 = v9;
  v32 = v10;
  v11 = *(_OWORD *)(v5 + 464);
  v13 = *(_OWORD *)(v5 + 416);
  v12 = *(_OWORD *)(v5 + 432);
  v37 = *(_OWORD *)(v5 + 448);
  v38 = v11;
  v35 = v13;
  v36 = v12;
  v14 = *(_OWORD *)(v5 + 528);
  v16 = *(_OWORD *)(v5 + 480);
  v15 = *(_OWORD *)(v5 + 496);
  v41 = *(_OWORD *)(v5 + 512);
  v42 = v14;
  v39 = v16;
  v40 = v15;
  v18 = *(_OWORD *)(v5 + 560);
  v17 = *(_OWORD *)(v5 + 576);
  v19 = *(_OWORD *)(v5 + 544);
  v46 = *(_QWORD *)(v5 + 592);
  v44 = v18;
  v45 = v17;
  v43 = v19;
  v20 = *((_QWORD *)this + 5);
  v24 = &off_24FFF1098;
  v21 = *(_OWORD *)(v20 + 24);
  v25 = *(_OWORD *)(v20 + 8);
  v26 = v21;
  v22 = MTSurfaceDimensions::convertPixelsToSurfaceFraction((uint64_t)&v24, *(float *)&__dst[7]);
  MTSurfaceDimensions::~MTSurfaceDimensions((MTSurfaceDimensions *)&v24);
  MTParserPath::~MTParserPath((MTParserPath *)__dst);
  return v22;
}

void sub_23107FD58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  MTSurfaceDimensions::~MTSurfaceDimensions((MTSurfaceDimensions *)&a9);
  MTParserPath::~MTParserPath((MTParserPath *)&a14);
  _Unwind_Resume(a1);
}

uint64_t MTPathStates::getMaxDisplacement_mm(uint64_t this)
{
  float *v1;
  float v2;
  uint64_t v3;

  v1 = (float *)(*(_QWORD *)(this + 280) + 952);
  v2 = 0.0;
  v3 = 31;
  do
  {
    if (*v1 > v2)
      v2 = *v1;
    v1 += 150;
    --v3;
  }
  while (v3);
  return this;
}

void MTPathStates::updateDragDisplacements_mm(MTPathStates *this, int a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  float *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  float updated;
  float v13;
  _OWORD v14[8];
  int v15;

  v4 = (char *)this + 48;
  v5 = 952;
  v6 = 31;
  do
  {
    v7 = (float *)(*((_QWORD *)this + 35) + v5);
    v8 = *((_OWORD *)v4 + 7);
    v14[6] = *((_OWORD *)v4 + 6);
    v14[7] = v8;
    v15 = *((_DWORD *)v4 + 32);
    v9 = *((_OWORD *)v4 + 3);
    v14[2] = *((_OWORD *)v4 + 2);
    v14[3] = v9;
    v10 = *((_OWORD *)v4 + 5);
    v14[4] = *((_OWORD *)v4 + 4);
    v14[5] = v10;
    v11 = *((_OWORD *)v4 + 1);
    v14[0] = *(_OWORD *)v4;
    v14[1] = v11;
    updated = MTParserPath::updateHysteresisDragCenter_mm(v7 - 88, (uint64_t)v14);
    v13 = 0.0;
    if (a2)
      v13 = updated + *v7;
    *v7 = v13;
    v5 += 600;
    --v6;
  }
  while (v6);
}

uint64_t MTPathStates::tasksPrePixelatedPositions(MTPathStates *this, float a2)
{
  uint64_t v3;

  v3 = *((_QWORD *)this + 44);
  if (v3 && *(_BYTE *)(v3 + 595))
  {
    MTPathStates::forwardFirmwareDistributedForces(this, a2);
    MTForceManagement::analyzeAndManageStrongestForces(*((MTForceManagement **)this + 44), this);
  }
  if ((*((_DWORD *)this + 6) - 1000) <= 0xBB7 && (*((_BYTE *)this + 28) & 2) != 0)
  {
    MTPathStates::checkForRestingThumbFromPalmRestingHand(this);
    MTPathStates::checkForLonelyHighRestingThumb(this);
    MTPathStates::fixupCurledUnderThumbIdentity(this);
    MTPathStates::countFingersOnDivingButton(this);
  }
  return MTPathStatesBasic::tasksPrePixelatedPositions(this);
}

void MTPathStates::checkForRestingThumbFromPalmRestingHand(MTPathStates *this)
{
  unsigned int *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  MTParserPath *v7;
  int v8;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  double v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  MTParserPath *v22;
  unsigned int v23;
  unsigned int v24;
  int v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  unint64_t v29;
  BOOL *v30;
  uint64x2_t v31;
  uint64x2_t v32;
  int v33;
  int v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  BOOL *v39;
  uint64x2_t v40;
  uint64x2_t v41;

  *((_QWORD *)this + 60) = *((_QWORD *)this + 59);
  v2 = (unsigned int *)((char *)this + 448);
  *((_BYTE *)this + 492) = 0;
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 31) = xmmword_2310BD030;
  v3 = -31;
  v4 = 1186;
  do
  {
    v5 = *((_QWORD *)this + 35);
    v6 = v5 + v4;
    if (*(_DWORD *)(v5 + v4 - 542))
    {
      v7 = (MTParserPath *)(v6 - 586);
      v8 = *(_DWORD *)(v6 - 534);
      if (v8 == -1)
      {
        if (MTParserPath::isPalmContact(v7))
        {
          ++*((_DWORD *)this + 116);
        }
        else if (MTParserPath::isThumbContact(v7))
        {
          *v2 = v3 + 32;
        }
        else if (*(_BYTE *)(v5 + v4))
        {
          *((_DWORD *)this + 114) = v3 + 32;
        }
        else if (MTParserPath::isFingerContact(v7))
        {
          ++*((_DWORD *)this + 118);
        }
      }
      else if (v8 == 1)
      {
        if (MTParserPath::isPalmContact(v7))
        {
          ++*((_DWORD *)this + 117);
        }
        else if (MTParserPath::isThumbContact(v7))
        {
          *((_DWORD *)this + 113) = v3 + 32;
        }
        else if (*(_BYTE *)(v5 + v4))
        {
          *((_DWORD *)this + 115) = v3 + 32;
        }
        else if (MTParserPath::isFingerContact(v7))
        {
          ++*((_DWORD *)this + 119);
        }
      }
    }
    v4 += 600;
  }
  while (!__CFADD__(v3++, 1));
  v10 = *((_DWORD *)this + 119);
  if (v10 + *((_DWORD *)this + 118) >= 1)
  {
    v11 = 856;
    v12 = 31;
    do
    {
      v13 = *((_QWORD *)this + 35);
      if (*(_DWORD *)(v13 + v11 - 212) && MTParserPath::isFingerContact((MTParserPath *)(v13 + v11 - 256)))
      {
        v14 = *(double *)(v13 + v11 - 24);
        v15 = fmin(*((double *)this + 62), v14);
        v16 = fmax(*((double *)this + 63), v14);
        *((double *)this + 62) = v15;
        *((double *)this + 63) = v16;
        *((double *)this + 64) = fmax(*((double *)this + 64), *(double *)(v13 + v11));
      }
      v11 += 600;
      --v12;
    }
    while (v12);
    if (*((_DWORD *)this + 113) || *v2)
      *((_BYTE *)this + 492) = *((double *)this + 63) - *((double *)this + 62) < *(double *)&qword_255EB3C00;
    v10 = *((_DWORD *)this + 119);
  }
  if (!v10 && !*((_DWORD *)this + 118) && (*((int *)this + 120) >= 1 || *((int *)this + 121) > 0))
  {
    v17 = 644;
    v18 = 31;
    do
    {
      v19 = *((_QWORD *)this + 35);
      if (*(_DWORD *)(v19 + v17))
        MTParserPath::clearPathSpeedSymmetries((MTParserPath *)(v19 + v17 - 44));
      v17 += 600;
      --v18;
    }
    while (v18);
    *((_DWORD *)this + 122) = 0;
  }
  v20 = *((_DWORD *)this + 114);
  if ((v20 || *((_DWORD *)this + 115))
    && *((_DWORD *)this + 119) + *((_DWORD *)this + 118) >= 2
    && *((_BYTE *)this + 492)
    && (v20 && !*((_DWORD *)this + 116) || (v20 = *((_DWORD *)this + 115)) != 0 && !*((_DWORD *)this + 117))
    && v20 >= 1)
  {
    v21 = *((_QWORD *)this + 35);
    if (*(_DWORD *)(v21 + 600 * v20 + 44))
    {
      v22 = (MTParserPath *)(v21 + 600 * v20);
      *((_BYTE *)v22 + 586) = 0;
      MTParserPath::clearPathSpeedSymmetries(v22);
    }
  }
  v23 = *((_DWORD *)this + 113);
  v24 = v23;
  if (!v23)
    goto LABEL_68;
  v25 = *((_DWORD *)this + 117);
  if (v25 < 1 || *((_DWORD *)this + 119))
    goto LABEL_68;
  if (*((int *)this + 118) <= 0 && !*v2)
    return;
  v26 = *((_DWORD *)this + 116);
  if (v25 > v26)
  {
    v27 = *((_QWORD *)this + 35);
    goto LABEL_62;
  }
  if (v25 != v26)
  {
LABEL_68:
    v28 = *v2;
    goto LABEL_69;
  }
  v27 = *((_QWORD *)this + 35);
  v28 = *((_DWORD *)this + 112);
  if (*(float *)(v27 + 600 * (int)v23 + 96) > *(float *)(v27 + 600 * (int)v28 + 96))
  {
LABEL_62:
    v29 = 0;
    v30 = (BOOL *)(v27 + 1186);
    v31 = (uint64x2_t)vdupq_n_s64(0x1FuLL);
    do
    {
      v32 = (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v29), (int8x16_t)xmmword_2310BD040);
      if ((vmovn_s64((int64x2_t)vcgtq_u64(v31, v32)).u8[0] & 1) != 0)
        *v30 = v23 - 1 == v29;
      if ((vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x1FuLL), v32)).i32[1] & 1) != 0)
        v30[600] = v23 - 2 == v29;
      v29 += 2;
      v30 += 1200;
    }
    while (v29 != 32);
    goto LABEL_68;
  }
LABEL_69:
  if (v28)
  {
    v33 = *((_DWORD *)this + 116);
    if (v33 >= 1 && !*((_DWORD *)this + 118) && (v23 || *((int *)this + 119) >= 1))
    {
      v34 = *((_DWORD *)this + 117);
      if (v33 <= v34)
      {
        if (v33 != v34)
          return;
        v35 = *((_QWORD *)this + 35);
        if (*(float *)(v35 + 600 * (int)v28 + 96) <= *(float *)(v35 + 600 * (int)v24 + 96))
          return;
      }
      else
      {
        v35 = *((_QWORD *)this + 35);
      }
      v36 = 0;
      v37 = v28 - 2;
      v38 = v28 - 1;
      v39 = (BOOL *)(v35 + 1186);
      v40 = (uint64x2_t)vdupq_n_s64(0x1FuLL);
      do
      {
        v41 = (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v36), (int8x16_t)xmmword_2310BD040);
        if ((vmovn_s64((int64x2_t)vcgtq_u64(v40, v41)).u8[0] & 1) != 0)
          *v39 = v38 == v36;
        if ((vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x1FuLL), v41)).i32[1] & 1) != 0)
          v39[600] = v37 == v36;
        v36 += 2;
        v39 += 1200;
      }
      while (v36 != 32);
    }
  }
}

void MTPathStates::checkForLonelyHighRestingThumb(MTPathStates *this)
{
  unsigned int v1;

  v1 = *((_DWORD *)this + 112);
  if (v1 && !*((_DWORD *)this + 116) && *((_DWORD *)this + 119) + *((_DWORD *)this + 118) == 1
    || (v1 = *((_DWORD *)this + 113)) != 0
    && !*((_DWORD *)this + 117)
    && *((_DWORD *)this + 118) + *((_DWORD *)this + 119) == 1)
  {
    MTPathStates::assignLonelyHighRestingThumb(this, v1);
  }
}

void MTPathStates::tasksFilterAndPixelatePositions(uint64_t *a1, uint64_t a2, int a3, int8x16_t a4, double a5, int8x16_t a6, int8x16_t a7)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  uint64_t v11;
  unint64_t v12;
  unsigned int v13;
  uint64_t v14;
  NSObject *v15;
  uint8_t buf[4];
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (a3 >= 1)
  {
    v8 = (uint64_t)(a1 + 6);
    v9 = (uint64_t)a1 + 180;
    v10 = (unsigned int *)(a2 + 16);
    v11 = a3;
    a4.i64[0] = 67109120;
    do
    {
      v13 = *v10;
      v10 += 24;
      v12 = v13;
      if ((v13 & 0x80000000) != 0 || (v14 = a1[35], 0x2FC962FC962FC963 * ((a1[36] - v14) >> 3) <= v12))
      {
        v15 = MTLoggingPlugin();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          v17 = v12;
          _os_log_error_impl(&dword_231071000, v15, OS_LOG_TYPE_ERROR, "Invalid path_id %d, dropping contact", buf, 8u);
        }
      }
      else
      {
        MTParserPath::filterContactForScreenUI(v14 + 600 * v12, (uint64_t)a1, a1[5], v8, v9, a4, a5, a6, a7);
      }
      --v11;
    }
    while (v11);
  }
}

void MTPathStates::assignLonelyHighRestingThumb(MTPathStates *this, unsigned int a2)
{
  uint64_t v5;
  double v6;
  NSObject *v7;
  double v8;
  double v9;
  double v10;
  const char *v11;
  double v12;
  double v13;
  NSObject *v14;
  unint64_t v15;
  BOOL *v16;
  uint64x2_t v17;
  uint64x2_t v18;
  int v19;
  const char *v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  unsigned int v26;
  __int16 v27;
  double v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  double v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  double v38;
  __int16 v39;
  uint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  v5 = *((_QWORD *)this + 35);
  v6 = *(double *)(v5 + 600 * (int)a2 + 232);
  v7 = MTLoggingPlugin();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    v8 = *((double *)this + 1);
    v9 = v8 - v6;
    v10 = *(float *)(v5 + 600 * (int)a2 + 396);
    if (*((_BYTE *)this + 492))
      v11 = "Yes";
    else
      v11 = "No";
    v12 = v8 - *((double *)this + 64);
    v19 = 136317698;
    v20 = "[Debug] ";
    v21 = 2080;
    v22 = "";
    v23 = 2080;
    v24 = "assignLonelyHighRestingThumb";
    v25 = 1024;
    v26 = a2;
    v27 = 2048;
    v28 = v9;
    v29 = 2048;
    v30 = qword_255EB3BF8;
    v31 = 2048;
    v32 = v10;
    v33 = 2048;
    v34 = 0x4000000000000000;
    v35 = 2080;
    v36 = v11;
    v37 = 2048;
    v38 = v12;
    v39 = 2048;
    v40 = qword_255EB3C00;
    _os_log_impl(&dword_231071000, v7, OS_LOG_TYPE_DEBUG, "[HID] [MT] %s%s%s [MTZoom] Thumb path P%d: Touch duration = %.3f sec (> %.3f sec for RT), Discounted distance = %.3f mm (< %.3f mm for RT), Thumb touched down with finger = %s (No for RT) , Time since last finger liftoff = %.3f sec (> %.3f sec for RT)", (uint8_t *)&v19, 0x6Cu);
  }
  v13 = *((double *)this + 1);
  if (*(double *)&qword_255EB3BF8 < v13 - v6
    && *(float *)(v5 + 600 * (int)a2 + 396) < 2.0
    && !*((_BYTE *)this + 492)
    && v13 - *((double *)this + 64) > *(double *)&qword_255EB3C00)
  {
    v14 = MTLoggingPlugin();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      v19 = 136315906;
      v20 = "[Debug] ";
      v21 = 2080;
      v22 = "";
      v23 = 2080;
      v24 = "assignLonelyHighRestingThumb";
      v25 = 1024;
      v26 = a2;
      _os_log_impl(&dword_231071000, v14, OS_LOG_TYPE_DEBUG, "[HID] [MT] %s%s%s [MTZoom] Marking thumb path P%d as resting thumb", (uint8_t *)&v19, 0x26u);
    }
    v15 = 0;
    v16 = (BOOL *)(*((_QWORD *)this + 35) + 1186);
    v17 = (uint64x2_t)vdupq_n_s64(0x1FuLL);
    do
    {
      v18 = (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v15), (int8x16_t)xmmword_2310BD040);
      if ((vmovn_s64((int64x2_t)vcgtq_u64(v17, v18)).u8[0] & 1) != 0)
        *v16 = a2 - 1 == v15;
      if ((vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x1FuLL), v18)).i32[1] & 1) != 0)
        v16[600] = a2 - 2 == v15;
      v15 += 2;
      v16 += 1200;
    }
    while (v15 != 32);
  }
}

uint64_t MTPathStates::setRestingThumbFromPalmRestingHand(uint64_t this, unsigned int a2)
{
  unint64_t v2;
  BOOL *v3;
  uint64x2_t v4;
  uint64x2_t v5;

  v2 = 0;
  v3 = (BOOL *)(*(_QWORD *)(this + 280) + 1186);
  v4 = (uint64x2_t)vdupq_n_s64(0x1FuLL);
  do
  {
    v5 = (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v2), (int8x16_t)xmmword_2310BD040);
    if ((vmovn_s64((int64x2_t)vcgtq_u64(v4, v5)).u8[0] & 1) != 0)
      *v3 = a2 - 1 == v2;
    if ((vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x1FuLL), v5)).i32[1] & 1) != 0)
      v3[600] = a2 - 2 == v2;
    v2 += 2;
    v3 += 1200;
  }
  while (v2 != 32);
  return this;
}

uint64_t MTPathStates::tasksPostPixelatedPositions(MTPathStates *this)
{
  uint64_t v2;
  uint64_t i;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if ((*((_DWORD *)this + 6) - 1000) <= 0xBB7)
  {
    if ((*((_BYTE *)this + 28) & 2) != 0)
      MTPathStates::checkForRestingThumb(this);
    v2 = *((_QWORD *)this + 35) + 644;
    for (i = 1; i != 32; ++i)
    {
      if (*(_DWORD *)v2)
      {
        if (*((_BYTE *)this + 444) && i == *((_DWORD *)this + 97))
        {
          *(_BYTE *)(v2 + 538) = *(_BYTE *)(v2 + 537);
          *(_BYTE *)(v2 + 537) = 1;
        }
        else
        {
          *(_BYTE *)(v2 + 538) = *(_BYTE *)(v2 + 537);
          *(_BYTE *)(v2 + 537) = 0;
        }
      }
      v2 += 600;
    }
    if (!*((_DWORD *)this + 119) && !*((_DWORD *)this + 118) || !*((_DWORD *)this + 117) && !*((_DWORD *)this + 116))
    {
      MTPathStates::updateHRTDiscountedDisplacement_mm(this);
      MTPathStates::breakOutOfRestingThumbForLargeDiscountedDisplacement(this);
    }
    MTPathStates::updateSpeedSymmetriesOfAllPaths(this);
    MTPathStates::breakOutOfRestingThumbBasedOnSymmetry((uint64_t)this);
    v4 = 644;
    v5 = 31;
    do
    {
      v6 = *((_QWORD *)this + 35);
      if (*(_DWORD *)(v6 + v4))
        MTParserPath::rejectRestingThumbFromRestingHand(v6 + v4 - 44);
      v4 += 600;
      --v5;
    }
    while (v5);
  }
  return MTPathStatesBasic::tasksPostPixelatedPositions(this);
}

float MTPathStates::updateHRTDiscountedDisplacement_mm(MTPathStates *this)
{
  float result;

  if ((*((_DWORD *)this + 6) - 1000) <= 0xBB7)
  {
    result = fmax((float)((float)(MTPathStates::getHighRestingThumbDisplacement(this) + *((float *)this + 122)) + -0.14), 0.0);
    *((float *)this + 122) = result;
  }
  return result;
}

double MTPathStates::breakOutOfRestingThumbForLargeDiscountedDisplacement(MTPathStates *this)
{
  int v2;
  uint64_t v3;
  MTParserPath *v4;
  double result;

  v2 = *((_DWORD *)this + 114);
  if (v2 || (v2 = *((_DWORD *)this + 115)) != 0)
  {
    v3 = *((_QWORD *)this + 35);
    v4 = (MTParserPath *)(v3 + 600 * v2);
    if (!*((_DWORD *)v4 + 11) || (LODWORD(result) = *((_DWORD *)this + 122), *(float *)&result > 8.0))
    {
      *(_BYTE *)(v3 + 600 * v2 + 586) = 0;
      return MTParserPath::clearPathSpeedSymmetries(v4);
    }
  }
  return result;
}

void MTPathStates::updateSpeedSymmetriesOfAllPaths(MTPathStates *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  float *v5;
  MTParserPath *v6;
  uint64_t v7;

  v2 = 1;
  v3 = 672;
  do
  {
    v4 = *((_QWORD *)this + 35);
    v5 = (float *)(v4 + v3);
    if (v2 == *(_DWORD *)(v4 + v3 - 32) && *v5 > 0.0)
    {
      v6 = (MTParserPath *)(v5 - 18);
      if ((MTParserPath::isFingerOrRestingContact((MTParserPath *)(v5 - 18))
         || MTParserPath::isThumbAlongEdgeContact(v6))
        && (*(_DWORD *)(v4 + v3 - 28) - 3) <= 1)
      {
        MTPathStates::computePathAndFingerSpeedSymmetries(this, v2);
      }
    }
    v7 = *((_QWORD *)this + 35) + v3;
    if ((*(_DWORD *)(v7 - 28) - 3) >= 2)
      MTParserPath::clearPathSpeedSymmetries((MTParserPath *)(v7 - 72));
    ++v2;
    v3 += 600;
  }
  while (v2 != 32);
}

uint64_t MTPathStates::breakOutOfRestingThumbBasedOnSymmetry(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  float v3;

  v1 = *(_QWORD *)(this + 280) + 644;
  v2 = 31;
  do
  {
    if (*(_DWORD *)v1)
    {
      if (*(_BYTE *)(v1 + 537))
      {
        v3 = *(float *)(v1 + 544);
        if (v3 < *(float *)(v1 + 548))
          v3 = *(float *)(v1 + 548);
        if (v3 > 0.765 && !*(_BYTE *)(this + 372))
        {
          *(_BYTE *)(v1 + 538) = *(_BYTE *)(v1 + 537);
          *(_BYTE *)(v1 + 537) = 0;
        }
      }
      if (*(_BYTE *)(v1 + 542))
      {
        if (*(float *)(v1 + 552) > 0.87)
          *(_BYTE *)(v1 + 542) = 0;
      }
    }
    v1 += 600;
    --v2;
  }
  while (v2);
  return this;
}

void MTPathStates::computePathAndFingerSpeedSymmetries(MTPathStates *this, int a2)
{
  float v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  float *v14;
  float *v15;
  float *v16;
  int64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  float *v22;
  uint64_t v23;
  float *v24;
  float *v25;
  float *v26;
  int64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char *v31;
  float *v32;
  int v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  float *v38;
  uint64_t v39;
  float v40;
  float v41;
  void *v42;
  float v43;
  float v44;
  _QWORD *v45;
  float v46;
  void *v47;
  void *v48;
  uint64_t v49;
  void *v50;
  void *v51;
  uint64_t v52;
  void *v53;
  void *v54;
  uint64_t v55;
  void *v56;
  void *v57;
  uint64_t v58;
  void *v59;
  void *v60;
  uint64_t v61;
  float *v62;
  uint64_t v63;
  uint64_t v64;
  void *__src;
  _BYTE *v66;
  uint64_t v67;
  void *__p;
  float *v69;
  unint64_t v70;
  float *v71;
  float *v72;
  unint64_t v73;
  char v74[16];

  v73 = 0;
  *(_QWORD *)v74 = 0;
  v71 = 0;
  v72 = 0;
  v4 = 0.0;
  v5 = 1;
  __p = 0;
  v69 = 0;
  v70 = 0;
  do
  {
    v6 = *((_QWORD *)this + 35);
    v7 = v6 + 600 * v5;
    v9 = *(_DWORD *)(v7 + 40);
    v8 = (_DWORD *)(v7 + 40);
    if (v5 == v9
      && *(float *)(v6 + 600 * v5 + 72) > 0.0
      && (MTParserPath::isFingerOrRestingContact((MTParserPath *)(v6 + 600 * v5))
       || MTParserPath::isThumbAlongEdgeContact((MTParserPath *)(v6 + 600 * v5)))
      && (*(_DWORD *)(v6 + 600 * v5 + 44) - 3) <= 1)
    {
      if (*v8 == a2)
      {
        v10 = v6 + 600 * v5;
        v4 = *(float *)(v10 + 536);
        *(_QWORD *)v74 = *(_QWORD *)(v10 + 528);
      }
      else
      {
        v11 = v6 + 600 * v5;
        v12 = *(_QWORD *)(v11 + 528);
        v13 = *(_DWORD *)(v11 + 536);
        v14 = v72;
        if ((unint64_t)v72 >= v73)
        {
          v16 = v71;
          v17 = ((char *)v72 - (char *)v71) >> 3;
          v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 61)
            std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
          v19 = v73 - (_QWORD)v71;
          if ((uint64_t)(v73 - (_QWORD)v71) >> 2 > v18)
            v18 = v19 >> 2;
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
            v20 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v20 = v18;
          if (v20)
          {
            v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTPoint>>((uint64_t)&v73, v20);
            v16 = v71;
            v14 = v72;
          }
          else
          {
            v21 = 0;
          }
          v22 = (float *)&v21[8 * v17];
          *(_QWORD *)v22 = v12;
          v15 = v22 + 2;
          if (v14 != v16)
          {
            do
            {
              v23 = *((_QWORD *)v14 - 1);
              v14 -= 2;
              *((_QWORD *)v22 - 1) = v23;
              v22 -= 2;
            }
            while (v14 != v16);
            v16 = v71;
          }
          v71 = v22;
          v72 = v15;
          v73 = (unint64_t)&v21[8 * v20];
          if (v16)
            operator delete(v16);
        }
        else
        {
          *(_QWORD *)v72 = v12;
          v15 = v14 + 2;
        }
        v72 = v15;
        v24 = v69;
        if ((unint64_t)v69 >= v70)
        {
          v26 = (float *)__p;
          v27 = ((char *)v69 - (_BYTE *)__p) >> 2;
          v28 = v27 + 1;
          if ((unint64_t)(v27 + 1) >> 62)
            std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
          v29 = v70 - (_QWORD)__p;
          if ((uint64_t)(v70 - (_QWORD)__p) >> 1 > v28)
            v28 = v29 >> 1;
          if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFFCLL)
            v30 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v30 = v28;
          if (v30)
          {
            v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v70, v30);
            v26 = (float *)__p;
            v24 = v69;
          }
          else
          {
            v31 = 0;
          }
          v32 = (float *)&v31[4 * v27];
          *(_DWORD *)v32 = v13;
          v25 = v32 + 1;
          while (v24 != v26)
          {
            v33 = *((_DWORD *)v24-- - 1);
            *((_DWORD *)v32-- - 1) = v33;
          }
          __p = v32;
          v69 = v25;
          v70 = (unint64_t)&v31[4 * v30];
          if (v26)
            operator delete(v26);
        }
        else
        {
          *(_DWORD *)v69 = v13;
          v25 = v24 + 1;
        }
        v69 = v25;
      }
    }
    ++v5;
  }
  while (v5 != 32);
  v34 = 126 - 2 * __clz(((char *)v69 - (_BYTE *)__p) >> 2);
  if (v69 == __p)
    v35 = 0;
  else
    v35 = v34;
  std::__introsort<std::_ClassicAlgPolicy,std::greater<float> &,float *,false>((float *)__p, v69, (uint64_t)&__src, v35, 1);
  v36 = 126 - 2 * __clz(((char *)v72 - (char *)v71) >> 3);
  if (v72 == v71)
    v37 = 0;
  else
    v37 = v36;
  std::__introsort<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *,false>((uint64_t)v71, v72, (uint64_t)&__src, v37, 1);
  __src = 0;
  v66 = 0;
  v67 = 0;
  std::vector<MTPoint>::__init_with_size[abi:ne180100]<MTPoint*,MTPoint*>(&__src, v71, (uint64_t)v72, ((char *)v72 - (char *)v71) >> 3);
  std::vector<MTPoint>::insert((uint64_t)&__src, (char *)__src, v74);
  v60 = 0;
  v61 = 0;
  v59 = 0;
  std::vector<MTPoint>::__init_with_size[abi:ne180100]<MTPoint*,MTPoint*>(&v59, __src, (uint64_t)v66, (v66 - (_BYTE *)__src) >> 3);
  MTPathStates::getCosineThetas((float **)&v59, &v62);
  v38 = v62;
  v39 = v63;
  v63 = 0;
  v64 = 0;
  v62 = 0;
  if (v59)
  {
    v60 = v59;
    operator delete(v59);
  }
  v40 = 0.0;
  v41 = 0.0;
  if (v4 > 10.0)
  {
    v56 = 0;
    v57 = 0;
    v58 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v56, __p, (uint64_t)v69, ((char *)v69 - (_BYTE *)__p) >> 2);
    v53 = 0;
    v54 = 0;
    v55 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v53, v38, v39, (v39 - (uint64_t)v38) >> 2);
    v42 = v56;
    if (v57 != v56)
    {
      v43 = sqrtf(v4 * *(float *)v56);
      v44 = 1.0;
      if (v54 != v53)
        v44 = *(float *)v53;
      v40 = (float)(v43 / (float)((float)((float)(v4 + *(float *)v56) * 0.5) + 1.0)) * v44;
    }
    if (v53)
    {
      v54 = v53;
      operator delete(v53);
      v42 = v56;
    }
    if (v42)
    {
      v57 = v42;
      operator delete(v42);
    }
    v50 = 0;
    v51 = 0;
    v52 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v50, __p, (uint64_t)v69, ((char *)v69 - (_BYTE *)__p) >> 2);
    v47 = 0;
    v48 = 0;
    v49 = 0;
    v45 = std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v47, v38, v39, (v39 - (uint64_t)v38) >> 2);
    MTPathStates::compute_3F_path_speed_symmetry(v4, (uint64_t)v45, &v50);
    v41 = v46;
    if (v47)
    {
      v48 = v47;
      operator delete(v47);
    }
    if (v50)
    {
      v51 = v50;
      operator delete(v50);
    }
  }
  MTParserPath::setPathSpeedSymmetries((float *)(*((_QWORD *)this + 35) + 600 * a2), v40, v41);
  if (__src)
  {
    v66 = __src;
    operator delete(__src);
  }
  if (v38)
    operator delete(v38);
  if (__p)
  {
    v69 = (float *)__p;
    operator delete(__p);
  }
  if (v71)
  {
    v72 = v71;
    operator delete(v71);
  }
}

void sub_231080FC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32)
{
  void *v32;
  uint64_t v33;
  void *v35;

  if (__p)
    operator delete(__p);
  if (a28)
    operator delete(a28);
  if (v32)
    operator delete(v32);
  if (a31)
    operator delete(a31);
  v35 = *(void **)(v33 - 152);
  if (v35)
  {
    *(_QWORD *)(v33 - 144) = v35;
    operator delete(v35);
  }
  _Unwind_Resume(exception_object);
}

float MTPathStates::getHighRestingThumbDisplacement(MTPathStates *this)
{
  int v1;
  uint64_t v2;
  float32x2_t v3;

  v1 = *((_DWORD *)this + 114);
  if (!v1)
  {
    v1 = *((_DWORD *)this + 115);
    if (!v1)
      return 0.0;
  }
  v2 = *((_QWORD *)this + 35) + 600 * (int)(float)v1;
  v3 = vsub_f32(*(float32x2_t *)(v2 + 92), *(float32x2_t *)(v2 + 188));
  return sqrtf(vaddv_f32(vmul_f32(v3, v3)));
}

char *std::vector<MTPoint>::insert(uint64_t a1, char *__src, char *a3)
{
  char *v3;
  char *v4;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  void *__p[2];
  __int128 v27;
  uint64_t v28;

  v3 = a3;
  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v8 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    v13 = *(char **)a1;
    *(_OWORD *)__p = 0u;
    v27 = 0u;
    v14 = ((v6 - v13) >> 3) + 1;
    if (v14 >> 61)
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    v15 = __src - v13;
    v16 = (__src - v13) >> 3;
    v17 = v7 - (_QWORD)v13;
    if (v17 >> 2 > v14)
      v14 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v14;
    v28 = a1 + 16;
    if (v18)
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTPoint>>(a1 + 16, v18);
    else
      v19 = 0;
    v20 = &v19[8 * v16];
    __p[0] = v19;
    __p[1] = v20;
    *(_QWORD *)&v27 = v20;
    *((_QWORD *)&v27 + 1) = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4)
          v22 = 1;
        else
          v22 = v15 >> 2;
        v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTPoint>>(v8, v22);
        v20 = &v23[8 * (v22 >> 2)];
        __p[0] = v23;
        __p[1] = v20;
        *((_QWORD *)&v27 + 1) = &v23[8 * v24];
        if (v19)
          operator delete(v19);
      }
      else
      {
        v21 = v16 + 2;
        if (v16 >= -1)
          v21 = v16 + 1;
        v20 -= 8 * (v21 >> 1);
        __p[1] = v20;
      }
    }
    *(_QWORD *)v20 = *(_QWORD *)v3;
    *(_QWORD *)&v27 = v20 + 8;
    v4 = std::vector<MTPoint>::__swap_out_circular_buffer((void **)a1, (uint64_t)__p, v4);
    if ((void *)v27 != __p[1])
      *(_QWORD *)&v27 = v27 + (((unint64_t)__p[1] - v27 + 7) & 0xFFFFFFFFFFFFFFF8);
    if (__p[0])
      operator delete(__p[0]);
  }
  else if (__src == v6)
  {
    *(_QWORD *)__src = *(_QWORD *)a3;
    *(_QWORD *)(a1 + 8) = __src + 8;
  }
  else
  {
    v9 = __src + 8;
    v10 = v6 - 8;
    v11 = *(_QWORD **)(a1 + 8);
    while (v10 < v6)
    {
      v12 = *(_QWORD *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(_QWORD *)(a1 + 8) = v11;
    if (v6 != v9)
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    if (v4 <= v3)
      v3 += 8 * (*(_QWORD *)(a1 + 8) > (unint64_t)v3);
    *(_QWORD *)v4 = *(_QWORD *)v3;
  }
  return v4;
}

void sub_2310812D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MTPathStates::getCosineThetas(float **a1@<X1>, float **a2@<X8>)
{
  _QWORD *v2;
  float *v3;
  float *v4;
  float *v7;
  float *v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float *v16;
  float *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  float *v23;
  int v24;

  a2[2] = 0;
  v2 = a2 + 2;
  *a2 = 0;
  a2[1] = 0;
  v3 = *a1;
  v4 = a1[1];
  if (*a1 != v4)
  {
    v7 = 0;
    do
    {
      v8 = v3;
      v3 += 2;
      if (v3 == v4)
      {
        v16 = v7;
      }
      else
      {
        v4 = v3;
        do
        {
          v9 = *v8;
          v10 = v8[1];
          v11 = sqrtf((float)(v9 * v9) + (float)(v10 * v10));
          v12 = 1.0;
          if (v11 > 0.0)
          {
            v13 = *v4;
            v14 = v4[1];
            v15 = sqrtf((float)(v13 * v13) + (float)(v14 * v14));
            if (v15 > 0.0)
              v12 = (float)((float)(v10 * v14) + (float)(v9 * v13)) / (float)(v11 * v15);
          }
          if ((unint64_t)v7 >= *v2)
          {
            v17 = *a2;
            v18 = v7 - *a2;
            v19 = v18 + 1;
            if ((unint64_t)(v18 + 1) >> 62)
              std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
            v20 = *v2 - (_QWORD)v17;
            if (v20 >> 1 > v19)
              v19 = v20 >> 1;
            if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFFCLL)
              v21 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v21 = v19;
            if (v21)
            {
              v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v2, v21);
              v17 = *a2;
              v7 = a2[1];
            }
            else
            {
              v22 = 0;
            }
            v23 = (float *)&v22[4 * v18];
            *v23 = v12;
            v16 = v23 + 1;
            while (v7 != v17)
            {
              v24 = *((_DWORD *)v7-- - 1);
              *((_DWORD *)v23-- - 1) = v24;
            }
            *a2 = v23;
            a2[1] = v16;
            a2[2] = (float *)&v22[4 * v21];
            if (v17)
              operator delete(v17);
          }
          else
          {
            *v7 = v12;
            v16 = v7 + 1;
          }
          a2[1] = v16;
          v4 += 2;
          v7 = v16;
        }
        while (v4 != a1[1]);
      }
      v7 = v16;
    }
    while (v3 != v4);
  }
}

void sub_2310814A8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

float MTPathStates::compute_2F_path_speed_symmetry(float a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  float *v4;
  float v5;
  float v6;
  float v7;

  v4 = *(float **)a3;
  if (*(_QWORD *)(a3 + 8) == *(_QWORD *)a3)
    return 0.0;
  v5 = sqrtf(*v4 * a1);
  v6 = (float)(*v4 + a1) * 0.5;
  v7 = 1.0;
  if (*(_QWORD *)(a4 + 8) != *(_QWORD *)a4)
    v7 = **(float **)a4;
  return (float)(v5 / (float)(v6 + 1.0)) * v7;
}

void MTPathStates::compute_3F_path_speed_symmetry(float a1, uint64_t a2, _QWORD *a3)
{
  if (a3[1] - *a3 >= 5uLL)
    cbrtf((float)(*(float *)*a3 * a1) * *(float *)(*a3 + 4));
}

float MTPathStates::get_3F_IncludingThumbSpeedSymmetry(MTPathStates *this)
{
  uint64_t v2;
  uint64_t i;
  uint64_t v4;

  v2 = 1;
  for (i = 1192; ; i += 600)
  {
    v4 = *((_QWORD *)this + 35);
    if (v2 == *(_DWORD *)(v4 + i - 552)
      && *(float *)(v4 + i - 520) > 0.0
      && MTParserPath::isThumbContact((MTParserPath *)(v4 + i - 592))
      && (*(_DWORD *)(v4 + i - 548) - 3) <= 1)
    {
      break;
    }
    if (++v2 == 32)
      return 0.0;
  }
  return *(float *)(v4 + i);
}

void std::vector<MTPoint>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_24FFEFE50, MEMORY[0x24BEDAAF0]);
}

void sub_2310816A4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8B8] + 16);
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<MTPoint>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a2);
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x24BEDB748], MEMORY[0x24BEDABB8]);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(4 * a2);
}

float *std::__introsort<std::_ClassicAlgPolicy,std::greater<float> &,float *,false>(float *result, float *a2, uint64_t a3, uint64_t a4, char a5)
{
  float *v8;
  float *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  float *v15;
  float v16;
  float *v17;
  char v18;
  BOOL v19;
  float v20;
  float v21;
  float v22;
  float v23;
  int v24;
  float v25;
  float v26;
  float v27;
  int v28;
  float v29;
  float v30;
  int v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  int v41;
  float v42;
  int v43;
  float v44;
  float v45;
  int v46;
  float v47;
  float v48;
  float v49;
  float v50;
  int v51;
  float v52;
  float v53;
  float v54;
  int v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float *v61;
  BOOL v63;
  uint64_t v64;
  float *v65;
  float v66;
  float v67;
  uint64_t v68;
  float *v69;
  float v70;
  float v71;
  float *v72;

  v8 = result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (2)
  {
    v8 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = a2 - v9;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v20 = *(a2 - 1);
        v21 = *v9;
        if (v20 > *v9)
        {
          *v9 = v20;
          *(a2 - 1) = v21;
        }
        return result;
      case 3uLL:
        v22 = v9[1];
        v23 = *(a2 - 1);
        if (v22 <= v23)
          v24 = *((_DWORD *)a2 - 1);
        else
          v24 = *((_DWORD *)v9 + 1);
        if (v22 > v23)
          v22 = *(a2 - 1);
        *(a2 - 1) = v22;
        *((_DWORD *)v9 + 1) = v24;
        v25 = *(a2 - 1);
        if (v25 <= *v9)
          v26 = *v9;
        else
          v26 = *(a2 - 1);
        if (v25 > *v9)
          v25 = *v9;
        *(a2 - 1) = v25;
        v28 = *(_DWORD *)v9;
        v27 = v9[1];
        if (v26 <= v27)
        {
          v28 = *((_DWORD *)v9 + 1);
          v27 = v26;
        }
        *(_DWORD *)v9 = v28;
        v9[1] = v27;
        return result;
      case 4uLL:
        v30 = v9[1];
        v29 = v9[2];
        if (*v9 <= v29)
          v31 = *((_DWORD *)v9 + 2);
        else
          v31 = *(_DWORD *)v9;
        if (*v9 <= v29)
          v29 = *v9;
        v9[2] = v29;
        *(_DWORD *)v9 = v31;
        v32 = *(a2 - 1);
        if (v30 <= v32)
          v33 = *(a2 - 1);
        else
          v33 = v30;
        if (v30 <= v32)
          v32 = v30;
        *(a2 - 1) = v32;
        v34 = *v9;
        if (*v9 <= v33)
          v35 = v33;
        else
          v35 = *v9;
        if (*v9 > v33)
          v34 = v33;
        *v9 = v35;
        v9[1] = v34;
        v36 = v9[2];
        v37 = *(a2 - 1);
        if (v36 <= v37)
          v38 = *(a2 - 1);
        else
          v38 = v9[2];
        if (v36 > v37)
          v36 = *(a2 - 1);
        *(a2 - 1) = v36;
        v39 = v9[1];
        if (v39 <= v38)
          v40 = v38;
        else
          v40 = v9[1];
        if (v39 > v38)
          v39 = v38;
        v9[1] = v40;
        v9[2] = v39;
        return result;
      case 5uLL:
        v41 = *(_DWORD *)v9;
        v42 = v9[1];
        if (*v9 <= v42)
          v43 = *((_DWORD *)v9 + 1);
        else
          v43 = *(_DWORD *)v9;
        if (*v9 > v42)
          v41 = *((_DWORD *)v9 + 1);
        *(_DWORD *)v9 = v43;
        *((_DWORD *)v9 + 1) = v41;
        v44 = v9[3];
        v45 = *(a2 - 1);
        if (v44 <= v45)
          v46 = *((_DWORD *)a2 - 1);
        else
          v46 = *((_DWORD *)v9 + 3);
        if (v44 > v45)
          v44 = *(a2 - 1);
        *(a2 - 1) = v44;
        *((_DWORD *)v9 + 3) = v46;
        v47 = *(a2 - 1);
        v48 = v9[2];
        if (v47 <= v48)
          v49 = v9[2];
        else
          v49 = *(a2 - 1);
        if (v47 > v48)
          v47 = v9[2];
        *(a2 - 1) = v47;
        v51 = *((_DWORD *)v9 + 2);
        v50 = v9[3];
        v52 = v9[1];
        if (v49 <= v50)
        {
          v51 = *((_DWORD *)v9 + 3);
          v50 = v49;
        }
        *((_DWORD *)v9 + 2) = v51;
        v9[3] = v50;
        v53 = *(a2 - 1);
        if (v52 <= v53)
          v54 = *(a2 - 1);
        else
          v54 = v52;
        if (v52 <= v53)
          v53 = v52;
        *(a2 - 1) = v53;
        v55 = *(_DWORD *)v9;
        v57 = v9[2];
        v56 = v9[3];
        if (v56 <= *v9)
          v58 = *v9;
        else
          v58 = v9[3];
        if (v56 > *v9)
          v56 = *v9;
        if (v58 <= v57)
        {
          v55 = *((_DWORD *)v9 + 2);
          v57 = v58;
        }
        if (v56 <= v54)
          v59 = v54;
        else
          v59 = v56;
        if (v56 > v54)
          v56 = v54;
        if (v59 <= v57)
          v54 = v57;
        *(_DWORD *)v9 = v55;
        v9[1] = v54;
        if (v59 <= v57)
          v60 = v59;
        else
          v60 = v57;
        v9[2] = v60;
        v9[3] = v56;
        return result;
      default:
        if (v12 > 95)
        {
          if (v11 == 1)
          {
            if (v9 != a2)
              return std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *,float *>(v9, a2, a2, a3);
            return result;
          }
          v14 = v13 >> 1;
          v15 = &v9[v13 >> 1];
          if ((unint64_t)v12 < 0x201)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(&v9[v13 >> 1], v9, a2 - 1);
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(v9, &v9[v13 >> 1], a2 - 1);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(v9 + 1, v15 - 1, a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(v9 + 2, &v9[v14 + 1], a2 - 3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(v15 - 1, v15, &v9[v14 + 1]);
            v16 = *v9;
            *v9 = *v15;
            *v15 = v16;
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          if (*(v9 - 1) <= *v9)
          {
            result = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,float *,std::greater<float> &>(v9, a2);
            v9 = result;
            goto LABEL_17;
          }
LABEL_12:
          v17 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,float *,std::greater<float> &>(v9, a2);
          if ((v18 & 1) == 0)
            goto LABEL_15;
          v19 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(v9, v17);
          v9 = v17 + 1;
          result = (float *)std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(v17 + 1, a2);
          if (!(_DWORD)result)
          {
            v10 = v11 + 1;
            if (v19)
              continue;
LABEL_15:
            result = (float *)std::__introsort<std::_ClassicAlgPolicy,std::greater<float> &,float *,false>(v8, v17, a3, -v11, a5 & 1);
            v9 = v17 + 1;
LABEL_17:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }
          a4 = -v11;
          a2 = v17;
          if (v19)
            return result;
          goto LABEL_2;
        }
        v61 = v9 + 1;
        v63 = v9 == a2 || v61 == a2;
        if ((a5 & 1) != 0)
        {
          if (!v63)
          {
            v64 = 0;
            v65 = v9;
            do
            {
              v67 = *v65;
              v66 = v65[1];
              v65 = v61;
              if (v66 > v67)
              {
                v68 = v64;
                while (1)
                {
                  *(float *)((char *)v9 + v68 + 4) = v67;
                  if (!v68)
                    break;
                  v67 = *(float *)((char *)v9 + v68 - 4);
                  v68 -= 4;
                  if (v66 <= v67)
                  {
                    v69 = (float *)((char *)v9 + v68 + 4);
                    goto LABEL_117;
                  }
                }
                v69 = v9;
LABEL_117:
                *v69 = v66;
              }
              v61 = v65 + 1;
              v64 += 4;
            }
            while (v65 + 1 != a2);
          }
        }
        else if (!v63)
        {
          do
          {
            v71 = *v8;
            v70 = v8[1];
            v8 = v61;
            if (v70 > v71)
            {
              v72 = v61;
              do
              {
                *v72 = v71;
                v71 = *(v72 - 2);
                --v72;
              }
              while (v70 > v71);
              *v72 = v70;
            }
            ++v61;
          }
          while (v8 + 1 != a2);
        }
        return result;
    }
  }
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(float *a1, float *a2, float *a3)
{
  float v3;
  float v4;
  float v5;
  float v6;

  v3 = *a2;
  v4 = *a1;
  v5 = *a3;
  if (*a2 > *a1)
  {
    if (v5 > v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    if (*a3 <= v4)
      return 1;
    *a2 = *a3;
    *a3 = v4;
    return 2;
  }
  if (v5 > v3)
  {
    *a2 = v5;
    *a3 = v3;
    v6 = *a1;
    if (*a2 <= *a1)
      return 1;
    *a1 = *a2;
    *a2 = v6;
    return 2;
  }
  return 0;
}

float *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,float *,std::greater<float> &>(float *a1, float *a2)
{
  float v2;
  float *v3;
  float v4;
  float *v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;

  v2 = *a1;
  if (*a1 <= *(a2 - 1))
  {
    v5 = a1 + 1;
    do
    {
      v3 = v5;
      if (v5 >= a2)
        break;
      ++v5;
    }
    while (v2 <= *v3);
  }
  else
  {
    v3 = a1;
    do
    {
      v4 = v3[1];
      ++v3;
    }
    while (v2 <= v4);
  }
  if (v3 < a2)
  {
    do
      v6 = *--a2;
    while (v2 > v6);
  }
  if (v3 < a2)
  {
    v7 = *v3;
    v8 = *a2;
    do
    {
      *v3 = v8;
      *a2 = v7;
      do
      {
        v9 = v3[1];
        ++v3;
        v7 = v9;
      }
      while (v2 <= v9);
      do
      {
        v10 = *--a2;
        v8 = v10;
      }
      while (v2 > v10);
    }
    while (v3 < a2);
  }
  if (v3 - 1 != a1)
    *a1 = *(v3 - 1);
  *(v3 - 1) = v2;
  return v3;
}

float *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,float *,std::greater<float> &>(float *a1, float *a2)
{
  uint64_t v2;
  float v3;
  float v4;
  float *v5;
  float *v6;
  float v7;
  float v8;
  float v9;
  float *v10;
  unint64_t v11;
  float v12;
  float v13;

  v2 = 0;
  v3 = *a1;
  do
    v4 = a1[++v2];
  while (v4 > v3);
  v5 = &a1[v2];
  v6 = &a1[v2 - 1];
  if (v2 == 1)
  {
    do
    {
      if (v5 >= a2)
        break;
      v8 = *--a2;
    }
    while (v8 <= v3);
  }
  else
  {
    do
      v7 = *--a2;
    while (v7 <= v3);
  }
  if (v5 < a2)
  {
    v9 = *a2;
    v10 = a2;
    v11 = (unint64_t)v5;
    do
    {
      *(float *)v11 = v9;
      *v10 = v4;
      do
      {
        v12 = *(float *)(v11 + 4);
        v11 += 4;
        v4 = v12;
      }
      while (v12 > v3);
      do
      {
        v13 = *--v10;
        v9 = v13;
      }
      while (v13 <= v3);
    }
    while (v11 < (unint64_t)v10);
    v6 = (float *)(v11 - 4);
  }
  if (v6 != a1)
    *a1 = *v6;
  *v6 = v3;
  return v6;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(float *a1, float *a2)
{
  _BOOL8 v2;
  float v3;
  float v4;
  float *v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float *v12;
  int v13;
  uint64_t v14;
  float v15;
  float v16;
  uint64_t v17;
  uint64_t v18;
  float *v19;
  float v20;
  float v21;
  int v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  int v32;
  float v33;
  float v34;
  float v35;
  float v36;
  int v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;

  v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      v3 = *(a2 - 1);
      v4 = *a1;
      if (v3 > *a1)
      {
        *a1 = v3;
        *(a2 - 1) = v4;
      }
      break;
    case 3:
      v20 = a1[1];
      v21 = *(a2 - 1);
      if (v20 <= v21)
        v22 = *((_DWORD *)a2 - 1);
      else
        v22 = *((_DWORD *)a1 + 1);
      if (v20 > v21)
        v20 = *(a2 - 1);
      *(a2 - 1) = v20;
      *((_DWORD *)a1 + 1) = v22;
      v23 = *(a2 - 1);
      if (v23 <= *a1)
        v24 = *a1;
      else
        v24 = *(a2 - 1);
      if (v23 > *a1)
        v23 = *a1;
      *(a2 - 1) = v23;
      v26 = *a1;
      v25 = a1[1];
      if (v24 <= v25)
      {
        v26 = a1[1];
        v25 = v24;
      }
      *a1 = v26;
      a1[1] = v25;
      break;
    case 4:
      v48 = a1[1];
      v47 = a1[2];
      if (*a1 <= v47)
        v49 = a1[2];
      else
        v49 = *a1;
      if (*a1 <= v47)
        v47 = *a1;
      a1[2] = v47;
      *a1 = v49;
      v50 = *(a2 - 1);
      if (v48 <= v50)
        v51 = *(a2 - 1);
      else
        v51 = v48;
      if (v48 <= v50)
        v50 = v48;
      *(a2 - 1) = v50;
      v52 = *a1;
      if (*a1 <= v51)
        v53 = v51;
      else
        v53 = *a1;
      if (*a1 > v51)
        v52 = v51;
      *a1 = v53;
      a1[1] = v52;
      v54 = a1[2];
      v55 = *(a2 - 1);
      if (v54 <= v55)
        v56 = *(a2 - 1);
      else
        v56 = a1[2];
      if (v54 > v55)
        v54 = *(a2 - 1);
      *(a2 - 1) = v54;
      v57 = a1[1];
      if (v57 <= v56)
        v58 = v56;
      else
        v58 = a1[1];
      if (v57 > v56)
        v57 = v56;
      a1[1] = v58;
      a1[2] = v57;
      break;
    case 5:
      v27 = *a1;
      v28 = a1[1];
      if (*a1 <= v28)
        v29 = a1[1];
      else
        v29 = *a1;
      if (*a1 > v28)
        v27 = a1[1];
      *a1 = v29;
      a1[1] = v27;
      v30 = a1[3];
      v31 = *(a2 - 1);
      if (v30 <= v31)
        v32 = *((_DWORD *)a2 - 1);
      else
        v32 = *((_DWORD *)a1 + 3);
      if (v30 > v31)
        v30 = *(a2 - 1);
      *(a2 - 1) = v30;
      *((_DWORD *)a1 + 3) = v32;
      v33 = *(a2 - 1);
      v34 = a1[2];
      if (v33 <= v34)
        v35 = a1[2];
      else
        v35 = *(a2 - 1);
      if (v33 > v34)
        v33 = a1[2];
      *(a2 - 1) = v33;
      v37 = *((_DWORD *)a1 + 2);
      v36 = a1[3];
      v38 = a1[1];
      if (v35 <= v36)
      {
        v37 = *((_DWORD *)a1 + 3);
        v36 = v35;
      }
      *((_DWORD *)a1 + 2) = v37;
      a1[3] = v36;
      v39 = *(a2 - 1);
      if (v38 <= v39)
        v40 = *(a2 - 1);
      else
        v40 = v38;
      if (v38 <= v39)
        v39 = v38;
      *(a2 - 1) = v39;
      v41 = *a1;
      v43 = a1[2];
      v42 = a1[3];
      if (v42 <= *a1)
        v44 = *a1;
      else
        v44 = a1[3];
      if (v42 > *a1)
        v42 = *a1;
      if (v44 <= v43)
      {
        v41 = a1[2];
        v43 = v44;
      }
      if (v42 <= v40)
        v45 = v40;
      else
        v45 = v42;
      if (v42 > v40)
        v42 = v40;
      if (v45 <= v43)
        v40 = v43;
      *a1 = v41;
      a1[1] = v40;
      if (v45 <= v43)
        v46 = v45;
      else
        v46 = v43;
      a1[2] = v46;
      a1[3] = v42;
      break;
    default:
      v5 = a1 + 2;
      v6 = a1[2];
      v8 = *a1;
      v7 = a1[1];
      if (v7 <= v6)
        v9 = a1[2];
      else
        v9 = a1[1];
      if (v7 <= v6)
        v6 = a1[1];
      if (v6 <= v8)
        v10 = *a1;
      else
        v10 = v6;
      if (v6 > v8)
        v6 = *a1;
      *v5 = v6;
      if (v10 <= v9)
        v11 = v9;
      else
        v11 = v8;
      if (v10 > v9)
        v10 = v9;
      *a1 = v11;
      a1[1] = v10;
      v12 = a1 + 3;
      if (a1 + 3 == a2)
      {
LABEL_29:
        v2 = 1;
      }
      else
      {
        v13 = 0;
        v14 = 12;
        while (1)
        {
          v15 = *v12;
          v16 = *v5;
          if (*v12 > *v5)
          {
            v17 = v14;
            while (1)
            {
              *(float *)((char *)a1 + v17) = v16;
              v18 = v17 - 4;
              if (v17 == 4)
                break;
              v16 = *(float *)((char *)a1 + v17 - 8);
              v17 -= 4;
              if (v15 <= v16)
              {
                v19 = (float *)((char *)a1 + v18);
                goto LABEL_27;
              }
            }
            v19 = a1;
LABEL_27:
            *v19 = v15;
            if (++v13 == 8)
              break;
          }
          v5 = v12;
          v14 += 4;
          if (++v12 == a2)
            goto LABEL_29;
        }
        v2 = v12 + 1 == a2;
      }
      break;
  }
  return v2;
}

float *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *,float *>(float *a1, float *a2, float *a3, uint64_t a4)
{
  float *v6;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  float *v12;
  float *v13;
  float *v14;
  float v15;
  uint64_t v16;
  uint64_t v17;
  float v18;
  float *v19;
  float *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  float *v25;
  float v26;
  float v27;
  float *v28;

  if (a1 != a2)
  {
    v6 = a2;
    v8 = (char *)a2 - (char *)a1;
    v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 5)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    v13 = v6;
    if (v6 != a3)
    {
      v14 = v6;
      do
      {
        v15 = *v14;
        if (*v14 > *a1)
        {
          *v14 = *a1;
          *a1 = v15;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 5)
    {
      v16 = (unint64_t)v8 >> 2;
      do
      {
        v17 = 0;
        v18 = *a1;
        v19 = a1;
        do
        {
          v20 = v19;
          v19 += v17 + 1;
          v21 = 2 * v17;
          v17 = (2 * v17) | 1;
          v22 = v21 + 2;
          if (v22 < v16 && *v19 > v19[1])
          {
            ++v19;
            v17 = v22;
          }
          *v20 = *v19;
        }
        while (v17 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v19 == --v6)
        {
          *v19 = v18;
        }
        else
        {
          *v19 = *v6;
          *v6 = v18;
          v23 = (char *)v19 - (char *)a1 + 4;
          if (v23 >= 5)
          {
            v24 = (((unint64_t)v23 >> 2) - 2) >> 1;
            v25 = &a1[v24];
            v26 = *v25;
            v27 = *v19;
            if (*v25 > *v19)
            {
              do
              {
                v28 = v25;
                *v19 = v26;
                if (!v24)
                  break;
                v24 = (v24 - 1) >> 1;
                v25 = &a1[v24];
                v26 = *v25;
                v19 = v28;
              }
              while (*v25 > v27);
              *v28 = v27;
            }
          }
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(uint64_t result, uint64_t a2, uint64_t a3, float *a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float v10;
  float v11;
  float *v12;
  uint64_t v13;
  uint64_t v14;

  if (a3 >= 2)
  {
    v4 = (uint64_t)a4 - result;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 2)
    {
      v6 = v4 >> 1;
      v7 = (v4 >> 1) + 1;
      v8 = (float *)(result + 4 * v7);
      v9 = v6 + 2;
      if (v9 < a3 && *v8 > v8[1])
      {
        ++v8;
        v7 = v9;
      }
      v10 = *v8;
      v11 = *a4;
      if (*v8 <= *a4)
      {
        do
        {
          v12 = v8;
          *a4 = v10;
          if (v5 < v7)
            break;
          v13 = 2 * v7;
          v7 = (2 * v7) | 1;
          v8 = (float *)(result + 4 * v7);
          v14 = v13 + 2;
          if (v14 < a3 && *v8 > v8[1])
          {
            ++v8;
            v7 = v14;
          }
          v10 = *v8;
          a4 = v12;
        }
        while (*v8 <= v11);
        *v12 = v11;
      }
    }
  }
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *,false>(uint64_t result, float *a2, uint64_t a3, uint64_t a4, char a5)
{
  float *v8;
  float *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  float *v15;
  uint64_t v16;
  float *v17;
  char v18;
  BOOL v19;
  float v20;
  float v21;

  v8 = (float *)result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (2)
  {
    v8 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = ((char *)a2 - (char *)v9) >> 3;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v20 = *v9;
        v21 = v9[1];
        if (sqrtf((float)(*(a2 - 1) * *(a2 - 1)) + (float)(*(a2 - 2) * *(a2 - 2))) > sqrtf((float)(v21 * v21)+ (float)(v20 * v20)))
        {
          *(_QWORD *)v9 = *((_QWORD *)a2 - 1);
          *(a2 - 2) = v20;
          *(a2 - 1) = v21;
        }
        return result;
      case 3uLL:
        return std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v9, v9 + 2, a2 - 2);
      case 4uLL:
        return std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v9, v9 + 2, v9 + 4, (uint64_t)(a2 - 2));
      case 5uLL:
        return std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v9, v9 + 2, v9 + 4, v9 + 6, (uint64_t)(a2 - 2));
      default:
        if (v12 <= 191)
        {
          if ((a5 & 1) != 0)
            return (uint64_t)std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v9, a2);
          else
            return (uint64_t)std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v9, a2);
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = &v9[2 * (v13 >> 1)];
          if ((unint64_t)v12 < 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(&v9[2 * (v13 >> 1)], v9, a2 - 2);
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v9, &v9[2 * (v13 >> 1)], a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v9 + 2, v15 - 2, a2 - 4);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v9 + 4, &v9[2 * v14 + 2], a2 - 6);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v15 - 2, v15, &v9[2 * v14 + 2]);
            v16 = *(_QWORD *)v9;
            *(_QWORD *)v9 = *(_QWORD *)v15;
            *(_QWORD *)v15 = v16;
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          if (sqrtf((float)(*(v9 - 1) * *(v9 - 1)) + (float)(*(v9 - 2) * *(v9 - 2))) <= sqrtf((float)(v9[1] * v9[1])+ (float)(*v9 * *v9)))
          {
            result = (uint64_t)std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,MTPoint *,MTPointVelocityGreaterThan &>(v9, (unint64_t)a2);
            v9 = (float *)result;
            goto LABEL_17;
          }
LABEL_12:
          v17 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,MTPoint *,MTPointVelocityGreaterThan &>(v9, (unint64_t)a2);
          if ((v18 & 1) == 0)
            goto LABEL_15;
          v19 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v9, v17);
          v9 = v17 + 2;
          result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v17 + 2, a2);
          if (!(_DWORD)result)
          {
            v10 = v11 + 1;
            if (v19)
              continue;
LABEL_15:
            result = std::__introsort<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *,false>(v8, v17, a3, -v11, a5 & 1);
            v9 = v17 + 2;
LABEL_17:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }
          a4 = -v11;
          a2 = v17;
          if (v19)
            return result;
          goto LABEL_2;
        }
        if (v9 != a2)
          return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *,MTPoint *>(v9, a2, a2, a3);
        return result;
    }
  }
}

float *std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(float *result, float *a2)
{
  float *v2;
  uint64_t v3;
  float *v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  uint64_t v10;
  float v11;
  float *v12;

  if (result != a2)
  {
    v2 = result + 2;
    if (result + 2 != a2)
    {
      v3 = 0;
      v4 = result;
      do
      {
        v5 = v4[2];
        v6 = v4[3];
        v7 = *v4;
        v8 = v4[1];
        v4 = v2;
        v9 = sqrtf((float)(v6 * v6) + (float)(v5 * v5));
        if (v9 > sqrtf((float)(v8 * v8) + (float)(v7 * v7)))
        {
          v10 = v3;
          while (1)
          {
            *(_QWORD *)((char *)result + v10 + 8) = *(_QWORD *)((char *)result + v10);
            if (!v10)
              break;
            v11 = sqrtf((float)(*(float *)((char *)result + v10 - 4) * *(float *)((char *)result + v10 - 4))+ (float)(*(float *)((char *)result + v10 - 8) * *(float *)((char *)result + v10 - 8)));
            v10 -= 8;
            if (v9 <= v11)
            {
              v12 = (float *)((char *)result + v10 + 8);
              goto LABEL_10;
            }
          }
          v12 = result;
LABEL_10:
          *v12 = v5;
          v12[1] = v6;
        }
        v2 = v4 + 2;
        v3 += 8;
      }
      while (v4 + 2 != a2);
    }
  }
  return result;
}

float *std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(float *result, float *a2)
{
  float *v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float *v8;
  uint64_t v9;

  if (result != a2)
  {
    while (result + 2 != a2)
    {
      v3 = result[2];
      v4 = result[3];
      v5 = *result;
      v6 = result[1];
      v2 = result + 2;
      result += 2;
      v7 = sqrtf((float)(v4 * v4) + (float)(v3 * v3));
      if (v7 > sqrtf((float)(v6 * v6) + (float)(v5 * v5)))
      {
        do
        {
          v8 = v2;
          v9 = *((_QWORD *)v2 - 1);
          v2 -= 2;
          *(_QWORD *)v8 = v9;
        }
        while (v7 > sqrtf((float)(*(v8 - 3) * *(v8 - 3)) + (float)(*(v8 - 4) * *(v8 - 4))));
        *v2 = v3;
        v2[1] = v4;
      }
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(float *a1, float *a2, float *a3)
{
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;

  v3 = *a2;
  v4 = a2[1];
  v5 = sqrtf((float)(v4 * v4) + (float)(v3 * v3));
  v7 = *a1;
  v6 = a1[1];
  v8 = sqrtf((float)(v6 * v6) + (float)(v7 * v7));
  v9 = sqrtf((float)(a3[1] * a3[1]) + (float)(*a3 * *a3));
  if (v5 > v8)
  {
    if (v9 > v5)
    {
      *(_QWORD *)a1 = *(_QWORD *)a3;
      *a3 = v7;
      a3[1] = v6;
      return 1;
    }
    *(_QWORD *)a1 = *(_QWORD *)a2;
    *a2 = v7;
    a2[1] = v6;
    if (sqrtf((float)(a3[1] * a3[1]) + (float)(*a3 * *a3)) <= v8)
      return 1;
    *(_QWORD *)a2 = *(_QWORD *)a3;
    *a3 = v7;
    a3[1] = v6;
    return 2;
  }
  if (v9 > v5)
  {
    *(_QWORD *)a2 = *(_QWORD *)a3;
    *a3 = v3;
    a3[1] = v4;
    v10 = *a1;
    v11 = a1[1];
    if (sqrtf((float)(a2[1] * a2[1]) + (float)(*a2 * *a2)) <= sqrtf((float)(v11 * v11) + (float)(v10 * v10)))
      return 1;
    *(_QWORD *)a1 = *(_QWORD *)a2;
    *a2 = v10;
    a2[1] = v11;
    return 2;
  }
  return 0;
}

float *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,MTPoint *,MTPointVelocityGreaterThan &>(float *a1, unint64_t a2)
{
  float v2;
  float v3;
  float v4;
  float *v5;
  float v6;
  float v7;
  float *v8;
  float v9;
  float v10;
  float v11;
  float v12;
  int v13;
  float v14;
  float v15;
  float v16;

  v2 = *a1;
  v3 = a1[1];
  v4 = sqrtf((float)(v3 * v3) + (float)(*a1 * *a1));
  if (v4 <= sqrtf((float)(*(float *)(a2 - 4) * *(float *)(a2 - 4)) + (float)(*(float *)(a2 - 8) * *(float *)(a2 - 8))))
  {
    v8 = a1 + 2;
    do
    {
      v5 = v8;
      if ((unint64_t)v8 >= a2)
        break;
      v9 = sqrtf((float)(v8[1] * v8[1]) + (float)(*v8 * *v8));
      v8 += 2;
    }
    while (v4 <= v9);
  }
  else
  {
    v5 = a1;
    do
    {
      v6 = v5[2];
      v7 = v5[3];
      v5 += 2;
    }
    while (v4 <= sqrtf((float)(v7 * v7) + (float)(v6 * v6)));
  }
  if ((unint64_t)v5 < a2)
  {
    do
    {
      v10 = *(float *)(a2 - 8);
      v11 = *(float *)(a2 - 4);
      a2 -= 8;
    }
    while (v4 > sqrtf((float)(v11 * v11) + (float)(v10 * v10)));
  }
  if ((unint64_t)v5 < a2)
  {
    v12 = *v5;
    do
    {
      v13 = *((_DWORD *)v5 + 1);
      *(_QWORD *)v5 = *(_QWORD *)a2;
      *(float *)a2 = v12;
      *(_DWORD *)(a2 + 4) = v13;
      do
      {
        v12 = v5[2];
        v14 = v5[3];
        v5 += 2;
      }
      while (v4 <= sqrtf((float)(v14 * v14) + (float)(v12 * v12)));
      do
      {
        v15 = *(float *)(a2 - 8);
        v16 = *(float *)(a2 - 4);
        a2 -= 8;
      }
      while (v4 > sqrtf((float)(v16 * v16) + (float)(v15 * v15)));
    }
    while ((unint64_t)v5 < a2);
  }
  if (v5 - 2 != a1)
    *(_QWORD *)a1 = *((_QWORD *)v5 - 1);
  *(v5 - 2) = v2;
  *(v5 - 1) = v3;
  return v5;
}

float *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,MTPoint *,MTPointVelocityGreaterThan &>(float *a1, unint64_t a2)
{
  uint64_t v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float *v8;
  float v9;
  float v10;
  float v11;
  float v12;
  unint64_t v13;
  float *v14;
  int v15;
  float v16;
  float v17;
  float v18;

  v2 = 0;
  v3 = *a1;
  v4 = a1[1];
  v5 = sqrtf((float)(v4 * v4) + (float)(*a1 * *a1));
  do
  {
    v6 = a1[v2 + 2];
    v7 = sqrtf((float)(a1[v2 + 3] * a1[v2 + 3]) + (float)(v6 * v6));
    v2 += 2;
  }
  while (v7 > v5);
  v8 = &a1[v2];
  if (v2 == 2)
  {
    do
    {
      if ((unint64_t)v8 >= a2)
        break;
      v11 = *(float *)(a2 - 8);
      v12 = *(float *)(a2 - 4);
      a2 -= 8;
    }
    while (sqrtf((float)(v12 * v12) + (float)(v11 * v11)) <= v5);
  }
  else
  {
    do
    {
      v9 = *(float *)(a2 - 8);
      v10 = *(float *)(a2 - 4);
      a2 -= 8;
    }
    while (sqrtf((float)(v10 * v10) + (float)(v9 * v9)) <= v5);
  }
  if ((unint64_t)v8 >= a2)
  {
    v14 = &a1[v2];
  }
  else
  {
    v13 = a2;
    v14 = v8;
    do
    {
      v15 = *((_DWORD *)v14 + 1);
      *(_QWORD *)v14 = *(_QWORD *)v13;
      *(float *)v13 = v6;
      *(_DWORD *)(v13 + 4) = v15;
      do
      {
        v6 = v14[2];
        v16 = v14[3];
        v14 += 2;
      }
      while (sqrtf((float)(v16 * v16) + (float)(v6 * v6)) > v5);
      do
      {
        v17 = *(float *)(v13 - 8);
        v18 = *(float *)(v13 - 4);
        v13 -= 8;
      }
      while (sqrtf((float)(v18 * v18) + (float)(v17 * v17)) <= v5);
    }
    while ((unint64_t)v14 < v13);
  }
  if (v14 - 2 != a1)
    *(_QWORD *)a1 = *((_QWORD *)v14 - 1);
  *(v14 - 2) = v3;
  *(v14 - 1) = v4;
  return v14 - 2;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(float *a1, float *a2)
{
  uint64_t v4;
  _BOOL8 result;
  float v6;
  float v7;
  float *v8;
  float *v9;
  uint64_t v10;
  int v11;
  float v12;
  float v13;
  float v14;
  uint64_t v15;
  float v16;
  float *v17;

  v4 = ((char *)a2 - (char *)a1) >> 3;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *a1;
      v7 = a1[1];
      if (sqrtf((float)(*(a2 - 1) * *(a2 - 1)) + (float)(*(a2 - 2) * *(a2 - 2))) > sqrtf((float)(v7 * v7)+ (float)(v6 * v6)))
      {
        *(_QWORD *)a1 = *((_QWORD *)a2 - 1);
        *(a2 - 2) = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(a1, a1 + 2, a1 + 4, (uint64_t)(a2 - 2));
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(a1, a1 + 2, a1 + 4, a1 + 6, (uint64_t)(a2 - 2));
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(a1, a1 + 2, a1 + 4);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    v13 = v9[1];
    v14 = sqrtf((float)(v13 * v13) + (float)(v12 * v12));
    if (v14 > sqrtf((float)(v8[1] * v8[1]) + (float)(*v8 * *v8)))
    {
      v15 = v10;
      while (1)
      {
        *(_QWORD *)((char *)a1 + v15 + 24) = *(_QWORD *)((char *)a1 + v15 + 16);
        if (v15 == -16)
          break;
        v16 = sqrtf((float)(*(float *)((char *)a1 + v15 + 12) * *(float *)((char *)a1 + v15 + 12))+ (float)(*(float *)((char *)a1 + v15 + 8) * *(float *)((char *)a1 + v15 + 8)));
        v15 -= 8;
        if (v14 <= v16)
        {
          v17 = (float *)((char *)a1 + v15 + 24);
          goto LABEL_12;
        }
      }
      v17 = a1;
LABEL_12:
      *v17 = v12;
      v17[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 8;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(float *a1, float *a2, float *a3, uint64_t a4)
{
  uint64_t result;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;

  result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(a1, a2, a3);
  v9 = *a3;
  v10 = a3[1];
  if (sqrtf((float)(*(float *)(a4 + 4) * *(float *)(a4 + 4)) + (float)(*(float *)a4 * *(float *)a4)) > sqrtf((float)(v10 * v10) + (float)(v9 * v9)))
  {
    *(_QWORD *)a3 = *(_QWORD *)a4;
    *(float *)a4 = v9;
    *(float *)(a4 + 4) = v10;
    v11 = *a2;
    v12 = a2[1];
    if (sqrtf((float)(a3[1] * a3[1]) + (float)(*a3 * *a3)) > sqrtf((float)(v12 * v12) + (float)(v11 * v11)))
    {
      *(_QWORD *)a2 = *(_QWORD *)a3;
      *a3 = v11;
      a3[1] = v12;
      v13 = *a1;
      v14 = a1[1];
      if (sqrtf((float)(a2[1] * a2[1]) + (float)(*a2 * *a2)) > sqrtf((float)(v14 * v14) + (float)(v13 * v13)))
      {
        *(_QWORD *)a1 = *(_QWORD *)a2;
        *a2 = v13;
        a2[1] = v14;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(float *a1, float *a2, float *a3, float *a4, uint64_t a5)
{
  uint64_t result;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;

  result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(a1, a2, a3, (uint64_t)a4);
  v11 = *a4;
  v12 = a4[1];
  if (sqrtf((float)(*(float *)(a5 + 4) * *(float *)(a5 + 4)) + (float)(*(float *)a5 * *(float *)a5)) > sqrtf((float)(v12 * v12) + (float)(v11 * v11)))
  {
    *(_QWORD *)a4 = *(_QWORD *)a5;
    *(float *)a5 = v11;
    *(float *)(a5 + 4) = v12;
    v13 = *a3;
    v14 = a3[1];
    if (sqrtf((float)(a4[1] * a4[1]) + (float)(*a4 * *a4)) > sqrtf((float)(v14 * v14) + (float)(v13 * v13)))
    {
      *(_QWORD *)a3 = *(_QWORD *)a4;
      *a4 = v13;
      a4[1] = v14;
      v15 = *a2;
      v16 = a2[1];
      if (sqrtf((float)(a3[1] * a3[1]) + (float)(*a3 * *a3)) > sqrtf((float)(v16 * v16) + (float)(v15 * v15)))
      {
        *(_QWORD *)a2 = *(_QWORD *)a3;
        *a3 = v15;
        a3[1] = v16;
        v17 = *a1;
        v18 = a1[1];
        if (sqrtf((float)(a2[1] * a2[1]) + (float)(*a2 * *a2)) > sqrtf((float)(v18 * v18) + (float)(v17 * v17)))
        {
          *(_QWORD *)a1 = *(_QWORD *)a2;
          *a2 = v17;
          a2[1] = v18;
        }
      }
    }
  }
  return result;
}

float *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *,MTPoint *>(float *a1, float *a2, float *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  float *v12;
  float *v13;
  float *v14;
  float v15;
  float v16;
  uint64_t v17;
  float *v18;
  int v19;
  float v20;
  float *v21;

  if (a1 != a2)
  {
    v8 = (char *)a2 - (char *)a1;
    v9 = ((char *)a2 - (char *)a1) >> 3;
    if ((char *)a2 - (char *)a1 >= 9)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[2 * v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>((uint64_t)a1, a4, v9, v12);
        v12 -= 2;
        --v11;
      }
      while (v11);
    }
    v13 = a2;
    if (a2 != a3)
    {
      v14 = a2;
      do
      {
        v15 = *v14;
        v16 = v14[1];
        if (sqrtf((float)(v16 * v16) + (float)(v15 * v15)) > sqrtf((float)(a1[1] * a1[1]) + (float)(*a1 * *a1)))
        {
          *(_QWORD *)v14 = *(_QWORD *)a1;
          *a1 = v15;
          a1[1] = v16;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>((uint64_t)a1, a4, v9, a1);
        }
        v14 += 2;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 9)
    {
      v17 = (unint64_t)v8 >> 3;
      v18 = a2 - 2;
      do
      {
        v20 = *a1;
        v19 = *((_DWORD *)a1 + 1);
        v21 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(a1, a4, v17);
        if (v18 == v21)
        {
          *v21 = v20;
          *((_DWORD *)v21 + 1) = v19;
        }
        else
        {
          *(_QWORD *)v21 = *(_QWORD *)v18;
          *v18 = v20;
          *((_DWORD *)v18 + 1) = v19;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>((uint64_t)a1, (uint64_t)(v21 + 2), a4, ((char *)(v21 + 2) - (char *)a1) >> 3);
        }
        v18 -= 2;
      }
      while (v17-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(uint64_t result, uint64_t a2, uint64_t a3, float *a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;
  float *v13;
  uint64_t v14;
  uint64_t v15;

  if (a3 >= 2)
  {
    v4 = (uint64_t)a4 - result;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 3)
    {
      v6 = v4 >> 2;
      v7 = (v4 >> 2) + 1;
      v8 = (float *)(result + 8 * v7);
      v9 = v6 + 2;
      if (v9 < a3
        && sqrtf((float)(v8[1] * v8[1]) + (float)(*v8 * *v8)) > sqrtf((float)(v8[3] * v8[3]) + (float)(v8[2] * v8[2])))
      {
        v8 += 2;
        v7 = v9;
      }
      v10 = *a4;
      v11 = a4[1];
      v12 = sqrtf((float)(v11 * v11) + (float)(v10 * v10));
      if (sqrtf((float)(v8[1] * v8[1]) + (float)(*v8 * *v8)) <= v12)
      {
        do
        {
          v13 = v8;
          *(_QWORD *)a4 = *(_QWORD *)v8;
          if (v5 < v7)
            break;
          v14 = 2 * v7;
          v7 = (2 * v7) | 1;
          v8 = (float *)(result + 8 * v7);
          v15 = v14 + 2;
          if (v15 < a3
            && sqrtf((float)(v8[1] * v8[1]) + (float)(*v8 * *v8)) > sqrtf((float)(v8[3] * v8[3]) + (float)(v8[2] * v8[2])))
          {
            v8 += 2;
            v7 = v15;
          }
          a4 = v13;
        }
        while (sqrtf((float)(v8[1] * v8[1]) + (float)(*v8 * *v8)) <= v12);
        *v13 = v10;
        v13[1] = v11;
      }
    }
  }
  return result;
}

float *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(float *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float *v6;
  uint64_t v7;
  uint64_t v8;

  v3 = 0;
  v4 = a3 - 2;
  if (a3 < 2)
    v4 = a3 - 1;
  v5 = v4 >> 1;
  do
  {
    v6 = result;
    result += 2 * v3 + 2;
    v7 = 2 * v3;
    v3 = (2 * v3) | 1;
    v8 = v7 + 2;
    if (v8 < a3
      && sqrtf((float)(result[1] * result[1]) + (float)(*result * *result)) > sqrtf((float)(result[3] * result[3])+ (float)(result[2] * result[2])))
    {
      result += 2;
      v3 = v8;
    }
    *(_QWORD *)v6 = *(_QWORD *)result;
  }
  while (v3 <= v5);
  return result;
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  float *v5;
  float *v6;
  float v7;
  float v8;
  float v9;
  float *v10;

  if (a4 >= 2)
  {
    v4 = (unint64_t)(a4 - 2) >> 1;
    v5 = (float *)(result + 8 * v4);
    v7 = *(float *)(a2 - 8);
    v8 = *(float *)(a2 - 4);
    v6 = (float *)(a2 - 8);
    v9 = sqrtf((float)(v8 * v8) + (float)(v7 * v7));
    if (sqrtf((float)(v5[1] * v5[1]) + (float)(*v5 * *v5)) > v9)
    {
      do
      {
        v10 = v5;
        *(_QWORD *)v6 = *(_QWORD *)v5;
        if (!v4)
          break;
        v4 = (v4 - 1) >> 1;
        v5 = (float *)(result + 8 * v4);
        v6 = v10;
      }
      while (sqrtf((float)(v5[1] * v5[1]) + (float)(*v5 * *v5)) > v9);
      *v10 = v7;
      v10[1] = v8;
    }
  }
  return result;
}

_QWORD *std::vector<MTPoint>::__init_with_size[abi:ne180100]<MTPoint*,MTPoint*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<MTPoint>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_2310831F4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<MTPoint>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTPoint>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

char *std::vector<MTPoint>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  void *v14;
  void *v15;

  v5 = *(char **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v7 = *(char **)(a2 + 8);
    do
    {
      v9 = *((_QWORD *)v8 - 1);
      v8 -= 8;
      *((_QWORD *)v7 - 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v10 = a1[1];
  v11 = *(_QWORD *)(a2 + 16);
  v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    v7 = *(char **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v11 + v12;
  v13 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v13;
  v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v14;
  v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v15;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

_QWORD *std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_231083370(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<float>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 62)
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

uint64_t MTParserPath::MTParserPath(uint64_t a1, int a2, int a3, uint64_t a4)
{
  MTForceFilter *v5;

  *(_QWORD *)a1 = &off_24FFF08D0;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = a3;
  *(_QWORD *)(a1 + 16) = a4;
  MTForceFilter::MTForceFilter((MTForceFilter *)(a1 + 296));
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  MTForceFilter::clear(v5);
  *(_QWORD *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 588) = 0;
  *(_QWORD *)(a1 + 592) = 0;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_QWORD *)(a1 + 574) = 0;
  *(_DWORD *)(a1 + 583) = 0;
  *(int32x2_t *)(a1 + 480) = vdup_n_s32(0x7FC00000u);
  return a1;
}

void sub_231083488(_Unwind_Exception *a1)
{
  MTForceFilter *v1;

  MTForceFilter::~MTForceFilter(v1);
  _Unwind_Resume(a1);
}

int32x2_t MTParserPath::clear(MTParserPath *this)
{
  char *v1;
  int32x2_t result;

  *(_OWORD *)((char *)this + 24) = 0u;
  v1 = (char *)this + 24;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  MTForceFilter::clear((MTParserPath *)((char *)this + 296));
  *((_QWORD *)v1 + 32) = 0;
  *((_DWORD *)v1 + 66) = 0;
  *((_DWORD *)v1 + 141) = 0;
  *((_QWORD *)v1 + 71) = 0;
  *(_OWORD *)(v1 + 328) = 0u;
  *(_OWORD *)(v1 + 344) = 0u;
  *(_OWORD *)(v1 + 360) = 0u;
  *(_OWORD *)(v1 + 376) = 0u;
  *(_OWORD *)(v1 + 392) = 0u;
  *(_OWORD *)(v1 + 408) = 0u;
  *(_OWORD *)(v1 + 424) = 0u;
  *(_OWORD *)(v1 + 440) = 0u;
  *(_OWORD *)(v1 + 488) = 0u;
  *(_OWORD *)(v1 + 504) = 0u;
  *(_OWORD *)(v1 + 520) = 0u;
  *(_OWORD *)(v1 + 536) = 0u;
  *(_QWORD *)(v1 + 550) = 0;
  *(_DWORD *)(v1 + 559) = 0;
  result = vdup_n_s32(0x7FC00000u);
  *((int32x2_t *)v1 + 57) = result;
  return result;
}

void MTParserPath::~MTParserPath(MTParserPath *this)
{
  *(_QWORD *)this = &off_24FFF08D0;
  MTForceFilter::~MTForceFilter((MTParserPath *)((char *)this + 296));
}

{
  *(_QWORD *)this = &off_24FFF08D0;
  MTForceFilter::~MTForceFilter((MTParserPath *)((char *)this + 296));
}

{
  *(_QWORD *)this = &off_24FFF08D0;
  MTForceFilter::~MTForceFilter((MTParserPath *)((char *)this + 296));
  JUMPOUT(0x2348D0034);
}

double MTParserPath::clearTimestamps(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)(a2 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  return result;
}

uint64_t MTParserPath::updateCurPrevContactsWith(MTParserPath *this, __int128 *a2, uint64_t a3, float *a4, double a5)
{
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  int v14;
  double v15;

  *(_OWORD *)((char *)this + 152) = *(_OWORD *)((char *)this + 56);
  *(_OWORD *)((char *)this + 168) = *(_OWORD *)((char *)this + 72);
  *(_OWORD *)((char *)this + 184) = *(_OWORD *)((char *)this + 88);
  *(_OWORD *)((char *)this + 200) = *(_OWORD *)((char *)this + 104);
  *(_OWORD *)((char *)this + 120) = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)((char *)this + 136) = *(_OWORD *)((char *)this + 40);
  v9 = *a2;
  *(_OWORD *)((char *)this + 40) = a2[1];
  *(_OWORD *)((char *)this + 24) = v9;
  v10 = a2[4];
  v11 = a2[5];
  v12 = a2[3];
  *(_OWORD *)((char *)this + 56) = a2[2];
  *(_OWORD *)((char *)this + 104) = v11;
  *(_OWORD *)((char *)this + 88) = v10;
  *(_OWORD *)((char *)this + 72) = v12;
  if ((*((_DWORD *)this + 2) - 1000) <= 0xBB7)
  {
    if (!*((_DWORD *)this + 35))
    {
      v13 = *(_QWORD *)((char *)this + 92);
      *(_QWORD *)((char *)this + 388) = v13;
      *((_QWORD *)this + 47) = v13;
    }
    v14 = *((_DWORD *)this + 12);
    if ((v14 - 2) > 3)
    {
      if (v14 != 13 && *((_BYTE *)this + 586))
        *((_DWORD *)this + 12) = 14;
    }
    else
    {
      *((_BYTE *)this + 586) = 0;
    }
  }
  if ((*((_DWORD *)this + 11) - 1) <= 2)
    *(_QWORD *)((char *)this + 356) = *(_QWORD *)((char *)this + 92);
  MTParserPath::updatePathStageTimestamps((uint64_t)this, a5);
  MTParserPath::updateTotalDiscountedDistance((uint64_t)this, v15);
  return MTParserPath::updateZonesAndEdges((uint64_t)this, a3, a4, a5);
}

uint64_t MTParserPath::rejectRestingThumbFromRestingHand(uint64_t this)
{
  int v1;

  v1 = *(_DWORD *)(this + 48);
  if ((v1 - 2) > 3)
  {
    if (v1 != 13 && *(_BYTE *)(this + 586) != 0)
      *(_DWORD *)(this + 48) = 14;
  }
  else
  {
    *(_BYTE *)(this + 586) = 0;
  }
  return this;
}

uint64_t MTParserPath::updatePathStageTimestamps(uint64_t this, double a2)
{
  int v2;
  int v3;
  BOOL v5;
  int v6;
  double *v7;
  unsigned int v8;

  v2 = *(_DWORD *)(this + 44);
  if (v2 == 1)
  {
    *(double *)(this + 216) = a2;
LABEL_14:
    *(double *)(this + 224) = a2;
    goto LABEL_15;
  }
  v3 = *(_DWORD *)(this + 140);
  if (v3 == 7 || v3 == 0)
    *(double *)(this + 216) = a2;
  if (v3)
    v5 = v2 < v3;
  else
    v5 = 1;
  if (v5)
    goto LABEL_14;
LABEL_15:
  v6 = *(_DWORD *)(this + 140);
  if (v2 == 2)
  {
    if (v6 == 2)
      return this;
    v7 = (double *)(this + 240);
    goto LABEL_30;
  }
  if (v6 == 2)
    *(double *)(this + 248) = a2;
  v8 = v6 - 6;
  if ((v2 - 3) <= 2 && v8 <= 0xFFFFFFFC)
    *(double *)(this + 232) = a2;
  if (v2 >= 5)
  {
    if (*(double *)(this + 232) >= *(double *)(this + 256))
      *(double *)(this + 256) = a2;
    if (v2 == 7)
    {
      v7 = (double *)(this + 264);
LABEL_30:
      *v7 = a2;
    }
  }
  return this;
}

uint64_t MTParserPath::updateTotalDiscountedDistance(uint64_t this, double a2)
{
  float32x2_t v2;
  float v3;

  if ((*(_DWORD *)(this + 8) - 1000) <= 0xBB7)
  {
    if ((*(_DWORD *)(this + 140) - 3) > 1 || (*(_DWORD *)(this + 44) - 3) > 1)
    {
      *(_DWORD *)(this + 396) = 0;
    }
    else
    {
      v2 = vsub_f32(*(float32x2_t *)(this + 92), *(float32x2_t *)(this + 188));
      v3 = sqrtf(vaddv_f32(vmul_f32(v2, v2)));
      if (v3 > 0.14)
        *(float *)(this + 396) = (float)(v3 + -0.14) + *(float *)(this + 396);
    }
  }
  return this;
}

uint64_t MTParserPath::updateZonesAndEdges(uint64_t a1, uint64_t a2, float *a3, double a4)
{
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t result;
  int v16;
  float v17;
  float v18;
  float v19;
  uint64_t v20;

  v8 = MTSurfaceDimensions::convertSurfaceFractionToMillimeters(a2, 1.0);
  v10 = v9;
  v11 = MTSurfaceDimensions::convertSurfaceFractionToMillimeters(a2, *(float *)(a1 + 56));
  v13 = v12;
  result = MTParserPath::computeZonesAndEdgesMask(v11, v12, v8, v10, v14, a3);
  *(_DWORD *)(a1 + 280) = result;
  if (*(double *)(a1 + 256) == a4)
    *(_DWORD *)(a1 + 288) = result;
  v16 = *(_DWORD *)(a1 + 44);
  if ((v16 - 1) <= 2)
  {
    if (v16 == 1 || (*(_DWORD *)(a1 + 140) - 1) >= 6)
    {
      *(_DWORD *)(a1 + 284) = result;
    }
    else
    {
      *(_DWORD *)(a1 + 284) |= result;
      v17 = v11 + (float)(v11 - MTSurfaceDimensions::convertPixelsToMillimeters(a2, *(float *)(a1 + 152))) * -2.5;
      v19 = v13 + (float)(v13 - v18) * -2.5;
      result = MTParserPath::computeZonesAndEdgesMask(v17, v19, v8, v10, v20, a3);
      *(_DWORD *)(a1 + 284) |= result;
    }
  }
  return result;
}

uint64_t MTParserPath::computeZonesAndEdgesMask(float a1, float a2, float a3, float a4, uint64_t a5, float *a6)
{
  double v8;
  long double v9;
  long double v10;
  float v11;
  long double v12;
  double v13;
  double v14;
  double v15;
  _BOOL4 v16;
  _BOOL4 v17;
  _BOOL4 v18;
  _BOOL4 v19;
  unsigned int v20;
  float v25;
  BOOL v26;
  int v27;
  float v29;
  BOOL v30;
  unsigned int v31;
  double v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;

  v8 = a6[1];
  v35 = a6[2];
  v36 = a6[3];
  v38 = a6[4];
  v39 = a6[7];
  v37 = a6[5];
  v40 = a6[6];
  v34 = a4 - a2;
  v9 = (float)(a4 - a2);
  v10 = a2;
  v11 = a3 - a1;
  v12 = (float)(a3 - a1);
  v33 = hypot(a2, a1);
  v13 = hypot(v10, v12);
  v14 = hypot(v9, a1);
  v15 = hypot(v9, v12);
  v16 = v33 > v8;
  v17 = v13 > v8;
  if (a2 > v35)
  {
    v16 = 1;
    v17 = 1;
  }
  v18 = v14 > v8;
  v19 = v15 > v8;
  if (v34 > v35)
  {
    v18 = 1;
    v19 = 1;
  }
  if (v11 > v36)
  {
    v17 = 1;
    v19 = 1;
  }
  if (a1 > v36)
    v16 = 1;
  v20 = !v16;
  if (a1 > v36)
    v18 = 1;
  if (!v17)
    v20 |= 2u;
  if (!v18)
    v20 |= 4u;
  if (!v19)
    v20 |= 8u;
  if (a1 < v37)
    v20 |= 0x10u;
  if (v11 < v37)
    v20 |= 0x20u;
  if (a2 < v38)
    v20 |= 0x40u;
  if (v34 < v38)
    v20 |= 0x80u;
  if (a1 < v39)
    v20 |= 0x1000u;
  if (v11 < v39)
    v20 |= 0x2000u;
  if (a2 < v40)
    v20 |= 0x4000u;
  if (v34 < v40)
    v20 |= 0x8000u;
  if (v33 < v8 && (v20 & 0x50) != 0)
    v20 |= 0x100u;
  if (v13 < v8 && (v20 & 0x60) != 0)
    v20 |= 0x200u;
  if (v14 < v8 && (v20 & 0x90) != 0)
    v20 |= 0x400u;
  if (v15 < v8 && (v20 & 0xA0) != 0)
    v20 |= 0x800u;
  v25 = a4 / 3.0;
  v26 = v11 <= (float)(a3 / 3.0) || a1 <= (float)(a3 / 3.0);
  v27 = v20 | 0x20000;
  if (v26)
    v27 = v20;
  if (v34 > v25 && a2 > v25)
    v20 = v27;
  v29 = a4 * 0.25;
  v30 = v11 <= (float)(a3 * 0.25) || a1 <= (float)(a3 * 0.25);
  v31 = v20 | 0x40000;
  if (v30)
    v31 = v20;
  if (a2 <= v29)
    v31 = v20;
  if (v34 > v29)
    return v31;
  else
    return v20;
}

float MTParserPath::getAverageVelocity_mm_s(MTParserPath *this)
{
  float v1;
  float v2;
  float v3;
  float v4;

  v1 = *((float *)this + 29) * *((float *)this + 29);
  v2 = 0.5;
  v3 = v1 * 0.5;
  if (v1 > 1.0)
    v3 = 0.5;
  v4 = *((float *)this + 53) * *((float *)this + 53);
  if (v4 <= 1.0)
    v2 = v4 * 0.5;
  return (float)(*((float *)this + 49) * v2) + (float)(v3 * *((float *)this + 25));
}

float MTParserPath::getDisplacement_mm(MTParserPath *this)
{
  return *((float *)this + 23) - *((float *)this + 94);
}

float MTParserPath::updateHysteresisDragCenter_mm(float *a1, uint64_t a2)
{
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;

  v2 = a1[89];
  v3 = a1[90];
  v4 = a1[23];
  v5 = *(float *)(a2 + 56);
  if ((float)(v4 - v2) <= v5)
  {
    if ((float)(v4 - v2) >= (float)-v5)
    {
      v9 = a1[89];
      goto LABEL_10;
    }
    v6 = (float)(int)(float)(v4 + v5);
    v7 = -1.0;
  }
  else
  {
    v6 = (float)(int)(float)(v4 - v5);
    v7 = 1.0;
  }
  v8 = v6 + v7;
  if (a1[47] == v6)
    v9 = v8;
  else
    v9 = v6;
  a1[89] = v9;
  v5 = *(float *)(a2 + 56);
LABEL_10:
  v10 = a1[24];
  if ((float)(v10 - v3) <= v5)
  {
    v13 = v3;
    if ((float)(v10 - v3) >= (float)-v5)
      return sqrtf((float)((float)(v3 - v13) * (float)(v3 - v13)) + (float)((float)(v2 - v9) * (float)(v2 - v9)));
    v11 = (float)(int)(float)(v10 + v5);
    v12 = -1.0;
  }
  else
  {
    v11 = (float)(int)(float)(v10 - v5);
    v12 = 1.0;
  }
  v13 = v11 + v12;
  if (a1[48] != v11)
    v13 = v11;
  a1[90] = v13;
  return sqrtf((float)((float)(v3 - v13) * (float)(v3 - v13)) + (float)((float)(v2 - v9) * (float)(v2 - v9)));
}

uint64_t MTParserPath::applyMinimumIncrementHysteresis(MTParserPath *this, float a2, float *a3, float a4, float a5)
{
  float v5;
  float v6;
  float v7;
  float v8;

  v5 = a2 - *a3;
  if (v5 <= a5)
  {
    if (v5 >= (float)-a5)
      return 0;
    v6 = (float)(int)(float)(a2 + a5);
    v7 = -1.0;
  }
  else
  {
    v6 = (float)(int)(float)(a2 - a5);
    v7 = 1.0;
  }
  v8 = v6 + v7;
  if (v6 == a4)
    v6 = v8;
  *a3 = v6;
  return 1;
}

BOOL MTParserPath::wasFingerOrRestingContact(MTParserPath *this)
{
  return (*((_DWORD *)this + 36) - 1) < 5;
}

float MTParserPath::getQuantizedMinorRadius_mm(MTParserPath *this)
{
  uint64_t v1;

  v1 = 548;
  if (*((float *)this + 141) == 0.0)
    v1 = 88;
  return *(float *)((char *)this + v1);
}

float MTParserPath::getQuantizedMajorRadius_mm(MTParserPath *this)
{
  uint64_t v1;

  v1 = 552;
  if (*((float *)this + 141) == 0.0)
    v1 = 84;
  return *(float *)((char *)this + v1);
}

float MTParserPath::getQuantizedRadiusAccuracy_mm(MTParserPath *this)
{
  return *((float *)this + 141);
}

BOOL MTParserPath::wasFingerContact(MTParserPath *this)
{
  return ((*((_DWORD *)this + 2) - 1000) > 0xBB7 || !*((_BYTE *)this + 582))
      && (*((_DWORD *)this + 36) - 1) < 5;
}

BOOL MTParserPath::isFingerOrRestingContact(MTParserPath *this)
{
  uint64_t v1;

  v1 = 48;
  if (*((_DWORD *)this + 11) == 7)
    v1 = 144;
  return (*(_DWORD *)((char *)this + v1) - 1) < 5;
}

BOOL MTParserPath::isThumbAlongEdgeContact(MTParserPath *this)
{
  uint64_t v1;

  v1 = 48;
  if (*((_DWORD *)this + 11) == 7)
    v1 = 144;
  return *(_DWORD *)((char *)this + v1) == 14;
}

uint64_t MTParserPath::isStylusContact(MTParserPath *this)
{
  return (*((unsigned __int16 *)this + 54) >> 12) & 1;
}

uint64_t MTParserPath::wasStylusContact(MTParserPath *this)
{
  return (*((unsigned __int16 *)this + 102) >> 12) & 1;
}

BOOL MTParserPath::isThumbContact(MTParserPath *this)
{
  uint64_t v1;

  v1 = 48;
  if (*((_DWORD *)this + 11) == 7)
    v1 = 144;
  return *(_DWORD *)((char *)this + v1) == 1;
}

BOOL MTParserPath::isFingerContact(MTParserPath *this)
{
  uint64_t v2;

  if ((*((_DWORD *)this + 2) - 1000) <= 0xBB7 && *((_BYTE *)this + 581))
    return 0;
  v2 = 48;
  if (*((_DWORD *)this + 11) == 7)
    v2 = 144;
  return (*(_DWORD *)((char *)this + v2) - 1) < 5;
}

BOOL MTParserPath::isPalmContact(MTParserPath *this)
{
  uint64_t v1;

  v1 = 48;
  if (*((_DWORD *)this + 11) == 7)
    v1 = 144;
  return (*(_DWORD *)((char *)this + v1) - 6) < 6;
}

BOOL MTParserPath::isPalmHeelContact(MTParserPath *this)
{
  uint64_t v1;

  v1 = 48;
  if (*((_DWORD *)this + 11) == 7)
    v1 = 144;
  return (*(_DWORD *)((_BYTE *)this + v1) & 0xFFFFFFFE) == 6;
}

BOOL MTParserPath::isEdgeContact(MTParserPath *this)
{
  uint64_t v1;

  v1 = 48;
  if (*((_DWORD *)this + 11) == 7)
    v1 = 144;
  return (*(_DWORD *)((char *)this + v1) - 12) < 3;
}

BOOL MTParserPath::isEdgeContactTyping(MTParserPath *this)
{
  uint64_t v1;

  v1 = 48;
  if (*((_DWORD *)this + 11) == 7)
    v1 = 144;
  return *(_DWORD *)((char *)this + v1) == 13;
}

BOOL MTParserPath::isBottomOrTopContact(MTParserPath *this)
{
  return (*((_BYTE *)this + 281) & 0xC0) != 0;
}

BOOL MTParserPath::isSideContact(MTParserPath *this)
{
  return (*((_BYTE *)this + 281) & 0x30) != 0;
}

uint64_t MTParserPath::isBottomContact(MTParserPath *this)
{
  return (*((unsigned __int8 *)this + 281) >> 6) & 1;
}

BOOL MTParserPath::isUnidentifiedContact(MTParserPath *this)
{
  uint64_t v1;

  v1 = 48;
  if (*((_DWORD *)this + 11) == 7)
    v1 = 144;
  return *(_DWORD *)((char *)this + v1) == 0;
}

BOOL MTParserPath::isValidForceSource(MTParserPath *this)
{
  return (*((_DWORD *)this + 11) - 1) < 6;
}

uint64_t MTParserPath::isValidEdgeStraddleClick(MTParserPath *this)
{
  unsigned int v1;
  _BOOL4 v2;
  uint64_t v3;
  int v4;
  int v5;

  v1 = *((_DWORD *)this + 70);
  v2 = (v1 & 0x3000) == 0;
  if ((v1 & 0xC000) != 0)
    v2 = 1;
  v3 = 48;
  if (*((_DWORD *)this + 11) == 7)
    v3 = 144;
  v4 = *(_DWORD *)((char *)this + v3);
  if (v4 == 13)
  {
    v5 = (v1 >> 14) & 1;
    return v2 & v5;
  }
  if ((v4 - 12) <= 2)
  {
    v5 = 1;
    return v2 & v5;
  }
  return 0;
}

uint64_t MTParserPath::isValidClickSource(MTParserPath *this)
{
  int v1;
  uint64_t v2;
  int v3;
  uint64_t result;

  v1 = *((_DWORD *)this + 11);
  v2 = 48;
  if (v1 == 7)
    v2 = 144;
  v3 = *(_DWORD *)((char *)this + v2);
  if ((v3 - 1) < 5 || v3 == 14)
    return (v1 - 3) < 2;
  result = MTParserPath::isValidEdgeStraddleClick(this);
  if ((_DWORD)result)
    return (v1 - 3) < 2;
  return result;
}

BOOL MTParserPath::fingerLiftoffNearEdge(float32x2_t *this, const MTSurfaceDimensions *a2, double a3)
{
  float v3;
  float32x2_t v4;

  if ((this[5].i32[1] - 3) < 2
    || (this[17].i32[1] - 3) > 1
    || (this[1].i32[0] - 1000) <= 0xBB7 && this[72].i8[6]
    || (this[18].i32[0] - 1) > 4)
  {
    return 0;
  }
  v3 = (float)(this[67].f32[0] * 3.0) * a3 + 1.2;
  v4 = vcvt_f32_f64(vmlaq_n_f64(vcvtq_f64_f32(this[19]), vcvtq_f64_f32(this[20]), a3));
  return MTSurfaceDimensions::minDistanceToEdge_mm((float *)a2, 1, 1, v4.f32[0], v4.f32[1]) < v3;
}

uint64_t MTParserPath::flushLiftoffAt(MTParserPath *this, double a2)
{
  double v3;

  *(_OWORD *)((char *)this + 152) = *(_OWORD *)((char *)this + 56);
  *(_OWORD *)((char *)this + 168) = *(_OWORD *)((char *)this + 72);
  *(_OWORD *)((char *)this + 184) = *(_OWORD *)((char *)this + 88);
  *(_OWORD *)((char *)this + 200) = *(_OWORD *)((char *)this + 104);
  *(_OWORD *)((char *)this + 120) = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)((char *)this + 136) = *(_OWORD *)((char *)this + 40);
  *((double *)this + 4) = a2;
  *((_DWORD *)this + 11) = 7;
  *((_QWORD *)this + 14) = 0;
  *((_WORD *)this + 54) = 0;
  *((_QWORD *)this + 9) = 0;
  MTParserPath::updatePathStageTimestamps((uint64_t)this, a2);
  MTParserPath::updateTotalDiscountedDistance((uint64_t)this, v3);
  return MTParserPath::constructPathChangeEventMask(this);
}

uint64_t MTParserPath::constructPathChangeEventMask(MTParserPath *this)
{
  float v2;
  int v3;
  unsigned int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  uint64_t FlagsEventMaskBits;
  int v12;
  uint64_t result;

  v2 = *((float *)this + 18);
  if (v2 > 0.0)
  {
    v3 = *((_DWORD *)this + 11);
    if (v3 == 1)
      goto LABEL_13;
    if (*((float *)this + 42) == 0.0)
      goto LABEL_7;
  }
  if (v2 == 0.0 && (*((_DWORD *)this + 11) == 7 || *((float *)this + 42) > 0.0))
  {
LABEL_7:
    v3 = 1;
  }
  else
  {
    v3 = *((_DWORD *)this + 12);
    if (v3)
    {
      if (v3 == *((_DWORD *)this + 36) && *((_DWORD *)this + 13) == *((_DWORD *)this + 37))
        v3 = 0;
      else
        v3 = 32;
    }
  }
LABEL_13:
  v4 = *((unsigned __int16 *)this + 54);
  v5 = v3 & 0xFFFFD7FF | ((*((_WORD *)this + 54) & 1) << 11) & 0xDFFF | (((v4 >> 1) & 1) << 13);
  if ((v4 & 0x100) != 0)
    v6 = 134479872;
  else
    v6 = 0x40000;
  v7 = v6 & 0xF8FFFFFF | ((((unsigned __int16)(v4 & 0x400) >> 10) & 1) << 25) & 0xFAFFFFFF | ((((unsigned __int16)(v4 & 0x200) >> 9) & 1) << 26) | ((((unsigned __int16)(v4 & 0x800) >> 11) & 1) << 24) | v5;
  if ((v4 & 4) != 0)
    v5 = v7;
  v8 = v5 | (v4 << 8) & 0xC000;
  v9 = *((_DWORD *)this + 11);
  if (v9 < 3)
  {
    if (v9 == 2 && *((_DWORD *)this + 35) == 4)
      v8 |= 2u;
  }
  else
  {
    v10 = *((_DWORD *)this + 35);
    if (v10 < 3)
    {
      v8 |= 2u;
      if ((v9 - 3) > 1)
        goto LABEL_32;
      goto LABEL_30;
    }
    if (v9 < 5)
    {
LABEL_30:
      if (v10 > 4)
        v8 |= 2u;
      goto LABEL_32;
    }
    if (v10 < 5)
      v8 |= 2u;
  }
LABEL_32:
  if ((*((_BYTE *)this + 368) || *((_BYTE *)this + 369))
    && (*((float *)this + 102) != *((float *)this + 100) || *((float *)this + 103) != *((float *)this + 101)))
  {
    v8 |= 4u;
    *((_QWORD *)this + 34) = *((_QWORD *)this + 4);
  }
  if (*((_BYTE *)this + 371) && *((float *)this + 19) != *((float *)this + 43))
    v8 |= 0x40u;
  if ((*((_DWORD *)this + 2) - 1000) <= 0xBB7 && *((_BYTE *)this + 581))
    v8 |= 0x200u;
  FlagsEventMaskBits = MTParserPath::generateFlagsEventMaskBits((uint64_t)this, (uint64_t)this + 24);
  v12 = FlagsEventMaskBits;
  if ((_DWORD)FlagsEventMaskBits == MTParserPath::generateFlagsEventMaskBits(FlagsEventMaskBits, (uint64_t)this + 120))result = v12 | v8;
  else
    result = v12 | v8 | 0x40u;
  *((_DWORD *)this + 91) = result;
  return result;
}

void MTParserPath::detectSustainedHoverAtEdge(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v5;
  uint64_t v6;
  double v7;
  float v8;
  float v9;
  float v10;
  BOOL v11;
  double v12;
  double v13;
  double v14;
  double v15;
  float v16;
  BOOL v17;

  v5 = MTSurfaceDimensions::convertMillimetersToSurfaceFraction(a3, 4.0);
  v6 = 248;
  if (*(_DWORD *)(a1 + 44) == 2)
    v6 = 32;
  v7 = *(double *)(a1 + v6);
  v8 = *(float *)(a1 + 56);
  v9 = *(float *)(a1 + 84);
  v10 = *(float *)(a2 + 40);
  v11 = v9 > v10 && (float)((float)(v9 - v10) / (float)(*(float *)(a2 + 44) - v10)) > 0.5;
  v12 = v7 - *(double *)(a1 + 240);
  v13 = v8;
  v14 = fabs(v8);
  v15 = fabs(v13 + -1.0);
  if (v14 < v15)
    v15 = v14;
  v16 = v15;
  v17 = v5 > v16;
  if (v12 <= 2.0)
    v17 = 0;
  *(_BYTE *)(a1 + 580) |= v17 && v11;
}

void MTParserPath::computeDebounceTimeInstability(uint64_t a1, uint64_t a2, double a3)
{
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  MTSLGLogger *v10;
  const __CFString *v11;

  v5 = a3;
  if (v5 <= 0.0)
  {
    v8 = 1.0;
    v7 = 0.2;
  }
  else
  {
    v6 = *(float *)(a2 + 84);
    v7 = 0.0;
    v8 = 0.0;
    if (v6 > v5)
      v8 = (float)(v6 - v5) / v6;
    v9 = *(float *)(a2 + 88);
    if (v9 > v5)
      v7 = (float)((float)(v9 - v5) / v9) * 0.2;
  }
  v10 = *(MTSLGLogger **)(a1 + 16);
  if (v10)
  {
    if (MTSLGLogger::isSLGEnabled(v10))
    {
      v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::computeDebounceTimeInstability] time_in_range = %.2f early_strong_debounce = %.2f late_weak_debounce = %.2f"), *(_QWORD *)&a3, v8, v7);
      MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v11);
      CFRelease(v11);
    }
  }
}

float MTParserPath::computeZSignalInstability(uint64_t a1, uint64_t a2, float *a3, int a4, double a5)
{
  float v10;
  float v11;
  float v12;
  MTSLGLogger *v13;
  const __CFString *v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  double v22;
  float v23;
  MTSLGLogger *v24;
  const __CFString *v25;
  MTSLGLogger *v26;
  const __CFString *v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float32x2_t v32;
  float v33;
  float v34;
  double v35;
  float v36;
  float v37;
  double v38;
  float v39;
  MTSLGLogger *v40;
  const __CFString *v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  MTSLGLogger *v52;
  const __CFString *v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  MTSLGLogger *v60;
  const __CFString *v61;
  MTSLGLogger *v62;
  const __CFString *v63;
  MTSLGLogger *v64;
  const __CFString *v65;
  float v67;

  v10 = *(float *)(a1 + 72);
  v11 = *(float *)(a1 + 168);
  if (v10 <= v11)
    v12 = *(float *)(a1 + 168);
  else
    v12 = *(float *)(a1 + 72);
  v13 = *(MTSLGLogger **)(a1 + 16);
  if (v13 && MTSLGLogger::isSLGEnabled(v13))
  {
    v14 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::computeZSignalInstability] cur_proximityZsignal_total = %.2f prev_proximityZsignal_total = %.2f max_denom_zarea = %.2f"), v10, v11, v12);
    MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v14);
    CFRelease(v14);
  }
  v15 = 1.0;
  if (v12 > 0.0)
  {
    v16 = v10 - v11;
    v17 = fabsf((float)(v16 * 100.0) / v12);
    if (a4)
      v18 = a3[4];
    else
      v18 = 1.0;
    v19 = v18 * a3[2];
    v20 = 0.0;
    if (v17 > v19)
    {
      v21 = v18 * a3[3];
      v20 = 1.0;
      if (v17 < v21)
        v20 = (float)(v17 - v19) / (float)(v21 - v19);
    }
    v22 = v20;
    v23 = pow(v20, 1.5);
    v24 = *(MTSLGLogger **)(a1 + 16);
    if (v24 && MTSLGLogger::isSLGEnabled(v24))
    {
      v25 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::computeZSignalInstability] delta_zarea = %.2f percent_delta_zarea = %.2f slid_stabilization_factor = %.2f linear_zinstability = %.2f squared_zinstability = %.2f"), v16, v17, v18, *(_QWORD *)&v22, v23);
      MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v25);
      CFRelease(v25);
    }
    if (a4)
    {
      if (v10 < *(float *)(a1 + 572))
      {
        v26 = *(MTSLGLogger **)(a1 + 16);
        v23 = 0.0;
        if (v26)
        {
          if (MTSLGLogger::isSLGEnabled(v26))
          {
            v27 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::computeZSignalInstability] already sliding but current ZArea %.2f is below long term average %.2f SET squared_zinstability = 0"), v10, *(float *)(a1 + 572));
            MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v27);
            CFRelease(v27);
          }
        }
      }
    }
    v28 = a5;
    v29 = 0.0;
    if (v28 < 0.5)
      v29 = (float)(0.5 - v28) + (float)(0.5 - v28);
    if (v28 > 0.0)
      v30 = v29;
    else
      v30 = 1.0;
    v31 = (float)((float)(a3[7] + -1.0) * v30) + 1.0;
    v32 = vabd_f32(*(float32x2_t *)(a1 + 84), *(float32x2_t *)(a1 + 180));
    v33 = v32.f32[1];
    v67 = v32.f32[0];
    if (v32.f32[0] <= v32.f32[1])
      v32.f32[0] = v32.f32[1];
    v34 = v31 * a3[5];
    v35 = 0.0;
    if (v32.f32[0] > v34)
      v35 = (float)((float)(v32.f32[0] - v34) / (float)((float)(v31 * a3[6]) - v34));
    v36 = pow(v35, 1.5);
    v37 = *(float *)(a1 + 568);
    v38 = 0.25;
    if (v37 >= v36)
    {
      if (v10 < *(float *)(a1 + 572))
        v38 = 0.5;
      else
        v38 = 0.75;
    }
    v39 = pow(v38, (*(double *)(a2 + 8) - *(double *)(a2 + 16)) / 0.00800000038);
    *(float *)(a1 + 568) = (float)((float)(1.0 - v39) * v36) + (float)(v39 * v37);
    v40 = *(MTSLGLogger **)(a1 + 16);
    if (v40 && MTSLGLogger::isSLGEnabled(v40))
    {
      v41 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::computeZSignalInstability] time_stabilization_factor = %.2f delta_major_radius_mm = %.2f delta_minor_radius_mm = %.2f radius_instability = %.2f squared_radius_instability = %.2f radius_instability_alpha = %.2f"), v31, v67, v33, *(_QWORD *)&v35, v36, *(_QWORD *)&v38);
      MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v41);
      CFRelease(v41);
    }
    v42 = *(float *)(a1 + 84);
    v43 = a3[10];
    v44 = 0.0;
    v45 = 0.0;
    if (v42 > v43)
      v45 = (float)(v42 - v43) / (float)(a3[11] - v43);
    v46 = *(float *)(a1 + 88);
    v47 = a3[8];
    if (v46 > v47)
      v44 = (float)(v46 - v47) / (float)(a3[9] - v47);
    v48 = *(float *)(a1 + 568);
    MTContact_getEllipseEccentricity();
    v50 = a3[12];
    v51 = 0.0;
    if (v49 > v50)
      v51 = (float)(v49 - v50) / (float)(a3[13] - v50);
    v52 = *(MTSLGLogger **)(a1 + 16);
    if (v52 && MTSLGLogger::isSLGEnabled(v52))
    {
      v53 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::computeZSignalInstability] major_radius_too_big = %.2f minor_radius_too_big = %.2f eccentricity_too_big = %.2f"), v45, v44, v51);
      MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v53);
      CFRelease(v53);
    }
    v54 = *(float *)(a1 + 576);
    v55 = a3[9];
    v56 = 0.0;
    if (v54 > v55)
      v56 = (float)(v54 - v55) / (float)((float)(a3[11] + 0.5) - v55);
    if (v48 <= v51)
      v57 = v51;
    else
      v57 = v48;
    if (v44 <= v45)
      v58 = v45;
    else
      v58 = v44;
    if (v57 <= v58)
      v59 = v58;
    else
      v59 = v57;
    v60 = *(MTSLGLogger **)(a1 + 16);
    if (v60)
    {
      if (MTSLGLogger::isSLGEnabled(v60))
      {
        v61 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::computeZSignalInstability] ellipse_instability = %.2f"), v59);
        MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v61);
        CFRelease(v61);
      }
      v62 = *(MTSLGLogger **)(a1 + 16);
      if (v59 <= v56)
        v59 = v56;
      if (v62)
      {
        if (MTSLGLogger::isSLGEnabled(v62))
        {
          v63 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::computeZSignalInstability K39] ellipse_instability = %.2f"), v59);
          MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v63);
          CFRelease(v63);
        }
        v64 = *(MTSLGLogger **)(a1 + 16);
        if (v23 <= v59)
          v15 = v59;
        else
          v15 = v23;
        if (v64 && MTSLGLogger::isSLGEnabled(v64))
        {
          v65 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::computeZSignalInstability] shape_instability = %.2f"), v15);
          MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v65);
          CFRelease(v65);
        }
        return v15;
      }
    }
    else if (v59 <= v56)
    {
      v59 = v56;
    }
    if (v23 <= v59)
      return v59;
    else
      return v23;
  }
  return v15;
}

void MTParserPath::bypassUpToHysteresisOfMotion(MTParserPath *this, float a2, float *a3, float a4)
{
  float v4;
  float v5;

  v4 = *a3;
  v5 = a2 - *a3;
  if (v5 <= a4)
  {
    if (v5 < (float)-a4)
      a2 = v4 - a4;
  }
  else
  {
    a2 = v4 + a4;
  }
  *a3 = a2;
}

void MTParserPath::pullHysteresisCenterHidingUnstablePixelDeltasXY(float a1, float a2, float a3, float a4, uint64_t a5, float *a6, float *a7)
{
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;

  v7 = a6[1];
  v8 = (float)(v7 * a3) * *a6;
  v9 = (float)(v7 * a4) * *a6;
  v10 = a7[1];
  v11 = a1 - *a7;
  if (v11 < (float)-v8)
    a1 = *a7 - v8;
  if (v11 > v8)
    a1 = *a7 + v8;
  *a7 = a1;
  if ((float)(a2 - v10) <= v9)
  {
    if ((float)(a2 - v10) < (float)-v9)
      a2 = v10 - v9;
  }
  else
  {
    a2 = v9 + v10;
  }
  a7[1] = a2;
}

void MTParserPath::pullHysteresisCenterCancelingEllipseTipMotion(float *a1, uint64_t a2, float *a3, MTSurfaceDimensions *this, float a5, int8x16_t a6, int8x16_t a7, float a8, int8x16_t a9, float a10)
{
  int8x16_t v10;
  float v15;
  float v16;
  int v17;
  float v18;
  float v19;
  int8x16_t v20;
  float v21;
  int v22;
  float v23;
  float v24;
  float v25;
  int8x16_t v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  __int32 v38;

  v15 = *a3;
  *(float *)a7.i32 = *(float *)a7.i32 - *(float *)a9.i32;
  *(float *)v10.i32 = a8 - a10;
  if (*(_BYTE *)(a2 + 43))
  {
    *(float *)a7.i32 = *(float *)a7.i32 + a1[118];
    *(float *)v10.i32 = *(float *)v10.i32 + a1[119];
  }
  v16 = a3[1];
  *(float *)a9.i32 = a5 - v15;
  v17 = *(unsigned __int8 *)(a2 + 40);
  v18 = fabsf(*(float *)a7.i32);
  if (!*(_BYTE *)(a2 + 40) || (float)(*(float *)a9.i32 * *(float *)a7.i32) < 0.0)
  {
    if (*(float *)a9.i32 <= v18)
    {
      if (*(float *)a9.i32 >= (float)-v18)
      {
        *a3 = a5;
        *(float *)a9.i32 = v18 - fabsf(*(float *)a9.i32);
        v20.i64[0] = 0x8000000080000000;
        v20.i64[1] = 0x8000000080000000;
        a9.i32[0] = vbslq_s8(v20, a9, a7).u32[0];
        goto LABEL_11;
      }
      v19 = v15 - v18;
    }
    else
    {
      v19 = v15 + v18;
    }
    *a3 = v19;
    a9.i32[0] = 0;
LABEL_11:
    a1[118] = *(float *)a9.i32;
  }
  v21 = *(float *)a6.i32 - v16;
  v22 = *(unsigned __int8 *)(a2 + 41);
  v23 = fabsf(*(float *)v10.i32);
  if (*(_BYTE *)(a2 + 41) && (float)(v21 * *(float *)v10.i32) >= 0.0)
  {
    if (v21 != 0.0)
    {
      v24 = *(float *)(a2 + 36);
      if (v24 >= (float)(*(float *)v10.i32 / v21))
        v24 = *(float *)v10.i32 / v21;
      a3[1] = v16 - (float)(v21 * v24);
    }
  }
  else
  {
    if (v21 <= v23)
    {
      if (v21 >= (float)-v23)
      {
        a3[1] = *(float *)a6.i32;
        *(float *)a6.i32 = v23 - fabsf(v21);
        v26.i64[0] = 0x8000000080000000;
        v26.i64[1] = 0x8000000080000000;
        *((_DWORD *)a1 + 119) = vbslq_s8(v26, a6, v10).u32[0];
        goto LABEL_24;
      }
      v25 = v16 - v23;
    }
    else
    {
      v25 = v16 + v23;
    }
    a3[1] = v25;
    a1[119] = 0.0;
  }
LABEL_24:
  v27 = a1[24];
  v28 = a1[98];
  if (!v17 || (float)(*(float *)a7.i32 * (float)(a1[23] - a1[97])) < 0.0)
  {
    v38 = v10.i32[0];
    v29 = MTSurfaceDimensions::convertPixelDeltaToMillimeters(this, v18, 0);
    v10.i32[0] = v38;
    v30 = a1[23];
    v31 = a1[97];
    v32 = v30 - v31;
    if ((float)(v30 - v31) < (float)-v29)
      v30 = v31 - v29;
    v33 = v29 + v31;
    if (v32 > v29)
      v34 = v33;
    else
      v34 = v30;
    a1[97] = v34;
    v22 = *(unsigned __int8 *)(a2 + 41);
  }
  if (!v22 || (float)(*(float *)v10.i32 * (float)(v27 - v28)) < 0.0)
  {
    v35 = MTSurfaceDimensions::convertPixelDeltaToMillimeters(this, v23, 1);
    v36 = a1[24];
    v37 = a1[98];
    if ((float)(v36 - v37) <= v35)
    {
      if ((float)(v36 - v37) < (float)-v35)
        v36 = v37 - v35;
    }
    else
    {
      v36 = v35 + v37;
    }
    a1[98] = v36;
  }
}

float MTParserPath::pullHysteresisCenterCancelingEllipseTipMotionFromPressure(uint64_t a1, double a2, float a3, double a4, float a5, double a6, float a7, uint64_t a8, uint64_t a9)
{
  float v9;
  float v10;
  float v11;
  float v12;
  float result;

  v9 = *(float *)(a9 + 4);
  v10 = a3 - v9;
  v11 = vabds_f32(a5, a7);
  if ((float)(a5 - a7) < 0.0 && v10 > 0.0 || (float)(a5 - a7) > 0.0 && v10 < 0.0)
  {
    if (v11 <= *(float *)(a1 + 524))
      v11 = *(float *)(a1 + 524);
    if (v10 <= v11)
    {
      if (v10 >= (float)-v11)
      {
        *(float *)(a9 + 4) = a3;
        goto LABEL_13;
      }
      v12 = -2.0;
    }
    else
    {
      v12 = 2.0;
    }
    *(float *)(a9 + 4) = v9 + (float)(v11 * v12);
    MTParserPath::pullHysteresisCenterCancelingEllipseTipMotionFromPressure(MTHMFingerTipOffsetParameters const&,MTPoint,MTPoint&,MTPoint,MTPoint,MTSurfaceDimensions)::alpha = 1065353216;
  }
LABEL_13:
  result = (float)(v11
                 * *(float *)&MTParserPath::pullHysteresisCenterCancelingEllipseTipMotionFromPressure(MTHMFingerTipOffsetParameters const&,MTPoint,MTPoint&,MTPoint,MTPoint,MTSurfaceDimensions)::alpha)
         + (1.0
          - *(float *)&MTParserPath::pullHysteresisCenterCancelingEllipseTipMotionFromPressure(MTHMFingerTipOffsetParameters const&,MTPoint,MTPoint&,MTPoint,MTPoint,MTSurfaceDimensions)::alpha)
         * *(float *)(a1 + 524);
  *(float *)(a1 + 524) = result;
  return result;
}

uint64_t MTParserPath::applyAbsolutePixelHysteresis(float a1, float a2, float a3, float a4, float a5, uint64_t a6, float *a7)
{
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  int v12;
  float v13;
  float v14;
  float v15;
  float v16;
  int v17;

  v7 = a1 - *a7;
  v8 = -a5;
  if (v7 <= a5)
  {
    if (v7 >= v8)
    {
      v12 = 0;
      goto LABEL_9;
    }
    v9 = (float)(int)(float)(a1 + a5);
    v10 = -1.0;
  }
  else
  {
    v9 = (float)(int)(float)(a1 - a5);
    v10 = 1.0;
  }
  v11 = v9 + v10;
  if (a3 == v9)
    v9 = v11;
  *a7 = v9;
  v12 = 1;
LABEL_9:
  v13 = a2 - a7[1];
  if (v13 <= a5)
  {
    if (v13 >= v8)
    {
      v17 = 0;
      return v12 | v17;
    }
    v14 = (float)(int)(float)(a2 + a5);
    v15 = -1.0;
  }
  else
  {
    v14 = (float)(int)(float)(a2 - a5);
    v15 = 1.0;
  }
  v16 = v14 + v15;
  if (a4 == v14)
    v14 = v16;
  a7[1] = v14;
  v17 = 1;
  return v12 | v17;
}

uint64_t MTParserPath::applyAbsoluteForceHysteresis(float a1, float a2, uint64_t a3, float *a4, float *a5)
{
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;

  v5 = a5[30];
  v6 = 0.0;
  if (v5 < a1)
  {
    v7 = a5[31];
    v6 = 1.0;
    if (v7 > a1)
      v6 = (float)(a1 - v5) / (float)(v7 - v5);
  }
  v8 = a5[28] + (float)((float)(a5[29] - a5[28]) * v6);
  v9 = a1 - *a4;
  if (v9 <= v8)
  {
    if (v9 >= (float)-v8)
      return 0;
    v10 = (float)(int)(float)(v8 + a1);
    v11 = -1.0;
  }
  else
  {
    v10 = (float)(int)(float)(a1 - v8);
    v11 = 1.0;
  }
  v12 = v10 + v11;
  if (v10 == a2)
    v10 = v12;
  *a4 = v10;
  return 1;
}

void MTParserPath::updateAngularHysteresisCenter(MTParserPath *this, float *a2, float a3, float a4)
{
  double v6;
  double v7;
  double v8;
  float v9;
  double v10;
  double v11;

  if (a4 >= 0.0)
  {
    v6 = a4;
    v7 = a3;
    v8 = fmod(a3 - *(float *)this + 3.14159265, 6.28318531);
    if (v8 < 0.0)
      v8 = v8 + 6.28318531;
    v9 = v8 + -3.14159265;
    if (v9 <= a4)
    {
      if (v9 >= (float)-a4)
        return;
      v10 = v7 + v6;
    }
    else
    {
      v10 = v7 - v6;
    }
    v11 = fmod(v10 + 3.14159265, 6.28318531);
    if (v11 < 0.0)
      v11 = v11 + 6.28318531;
    a3 = v11 + -3.14159265;
  }
  *(float *)this = a3;
}

float32_t MTParserPath::weakenDampedVelocity(float32x2_t *this, float a2)
{
  float32_t result;

  this[66] = vmul_n_f32(this[66], a2);
  result = this[67].f32[0] * a2;
  this[67].f32[0] = result;
  return result;
}

void MTParserPath::updateDampedVelocity(uint64_t a1, uint64_t a2, uint64_t a3, float a4)
{
  float v5;
  float v6;
  double v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;

  v5 = *(float *)(a1 + 508);
  v6 = *(float *)(a3 + 72);
  v7 = *(double *)(a2 + 8) - *(double *)(a2 + 16);
  if (v7 > 0.025 || *(_BYTE *)(a3 + 101) && (*(_DWORD *)(a1 + 44) - 1) <= 2)
  {
    v8 = *(float *)(a1 + 528) * 0.0;
    v9 = *(float *)(a1 + 532) * 0.0;
  }
  else
  {
    v8 = *(float *)(a1 + 528);
    if (*(_DWORD *)(a2 + 320))
    {
      v8 = v8 * 0.5;
      v9 = *(float *)(a1 + 532) * 0.5;
    }
    else
    {
      v9 = *(float *)(a1 + 532);
    }
  }
  v10 = v5 * a4;
  if (v10 >= v6)
    v11 = v10 - v6;
  else
    v11 = 0.0;
  v12 = v11 / v5;
  if (v5 <= 0.0)
    v13 = 0.0;
  else
    v13 = v12;
  v14 = exp2(v7 / -0.00800000038);
  v15 = *(float *)(a1 + 104);
  v16 = (float)((float)(1.0 - v14) * (float)(v13 * *(float *)(a1 + 100))) + (float)(v14 * v8);
  *(float *)(a1 + 528) = v16;
  v17 = (float)((float)(1.0 - v14) * (float)(v13 * v15)) + (float)(v14 * v9);
  *(float *)(a1 + 532) = v17;
  *(float *)(a1 + 536) = hypotf(v16, v17);
}

float MTParserPath::computeDivingButtonChangeInstability(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v3;
  float result;
  float v5;
  int v6;
  int v7;
  _BOOL4 v8;
  int v9;
  _BOOL4 v10;
  uint64_t v11;
  double v12;
  double v13;
  BOOL v14;
  int v15;
  float v16;
  float v17;

  v3 = *(double *)(a2 + 8) - *(double *)(a2 + 400);
  result = 1.0;
  if (v3 > 0.0)
  {
    v5 = *(float *)(a3 + 88);
    result = 0.0;
    if (v5 > v3)
      result = (float)(v5 - v3) / v5;
  }
  v6 = *(_DWORD *)(a1 + 40);
  if (*(_BYTE *)(a3 + 99))
  {
    v7 = *(_DWORD *)(a2 + 408);
    v8 = v6 == v7;
    if (*(_DWORD *)(a2 + 384) == 1)
      v8 = 0;
    v9 = *(unsigned __int8 *)(a2 + 372);
    if (v6 != v7)
      v8 = 1;
    v14 = v9 == 0;
    v10 = v9 == 0;
    v11 = *(_QWORD *)(a2 + 352);
    v12 = 0.5;
    v13 = 0.25;
    if (!v14)
    {
      v13 = 0.5;
      v12 = 1.0;
    }
    v14 = v11 == 0;
    if (v11)
      v15 = v8;
    else
      v15 = 1;
    v16 = v13 * result;
    if (!v14)
      v8 = 1;
    if (!v15)
      result = v16;
    v17 = v12 * result;
    if (!v8)
      result = v17;
    if (v6 != v7)
      return dbl_2310BD350[v10] * result;
  }
  else if (v6 != *(_DWORD *)(a2 + 388))
  {
    return result * 0.15;
  }
  return result;
}

void MTParserPath::isStuckOnDivingRegion(MTParserPath *this, const MTPathStates *a2)
{
  int v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float ThumbRestingOrPolarZoneHeight;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;

  if (*((_DWORD *)this + 10) == *((_DWORD *)a2 + 97)
    && *((_DWORD *)a2 + 94) == 1
    && !(*((_DWORD *)a2 + 96) - 1 + *((_DWORD *)a2 + 95)))
  {
    if (((v4 = *((_DWORD *)this + 12), !*((_DWORD *)a2 + 104)) || *((int *)a2 + 105) <= 2)
      && (*((_BYTE *)a2 + 28) & 0x80) == 0
      || v4 == 1)
    {
      v5 = *((float *)this + 23) - *((float *)this + 97);
      v6 = (float)(*((float *)this + 24) - *((float *)this + 98))
         * (float)(*((float *)this + 24) - *((float *)this + 98));
      MTSurfaceDimensions::convertSurfaceFractionToMillimeters(*((_QWORD *)a2 + 5), *((float *)this + 14));
      v8 = v7;
      ThumbRestingOrPolarZoneHeight = MTPathStates::getThumbRestingOrPolarZoneHeight(a2);
      v10 = 1.0;
      if (v8 > 0.0)
      {
        v10 = 0.0;
        if (v8 < ThumbRestingOrPolarZoneHeight)
          v10 = (float)(ThumbRestingOrPolarZoneHeight - v8) / ThumbRestingOrPolarZoneHeight;
      }
      v11 = 0.0;
      if (v4 == 1)
        v11 = 1.0;
      v12 = v10 * v11;
      v13 = *((float *)this + 21);
      if (v13 <= 8.0)
      {
        if (v12 <= 0.0)
          v12 = 0.0;
      }
      else if (v13 >= 13.0)
      {
        if (v12 <= 1.0)
          v12 = 1.0;
      }
      else
      {
        v14 = (float)(v13 + -8.0) / 5.0;
        if (v12 <= v14)
          v12 = v14;
      }
      v15 = (float)(v10 * 6.0) * v12;
      v16 = v15 + 0.2;
      if (!*((_BYTE *)a2 + 372))
        v16 = v15;
      if (v16 > 0.0 && (float)(v6 + (float)(v5 * v5)) < (float)(v16 * v16))
        pow((float)(v16 * 0.5), 1.5);
    }
  }
}

float *MTParserPath::setPathSpeedSymmetries(float *this, float a2, float a3)
{
  float v3;

  this[147] = a2;
  this[148] = a3;
  v3 = fabsf(a2);
  if (v3 < a3)
    v3 = a3;
  if (v3 < this[149])
    v3 = this[149];
  this[149] = v3;
  return this;
}

double MTParserPath::clearPathSpeedSymmetries(MTParserPath *this)
{
  double result;

  *((_DWORD *)this + 147) = 0;
  result = 0.0;
  *((_QWORD *)this + 74) = 0;
  return result;
}

float MTParserPath::measureInstability(uint64_t a1, uint64_t a2, uint64_t a3, float *a4)
{
  double v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  double v15;
  float v16;
  float v17;
  double v18;
  float v19;
  MTSLGLogger *v20;
  const __CFString *v21;
  float v22;
  MTSLGLogger *v23;
  const __CFString *v24;
  float v25;
  float v26;
  float v27;
  float v28;
  NSObject *v29;
  float v30;
  float v31;
  uint64_t v32;
  int v33;
  float v34;
  float v35;
  MTSLGLogger *v36;
  const __CFString *v37;
  float v38;
  float v39;
  float v40;
  MTSLGLogger *v41;
  const __CFString *v42;
  int v44;
  float32x2_t v45;
  uint8_t buf[4];
  int v47;
  __int16 v48;
  double v49;
  __int16 v50;
  double v51;
  __int16 v52;
  double v53;
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  v8 = *(double *)(a1 + 32) - *(double *)(a1 + 224);
  if ((*(_DWORD *)(a1 + 8) - 1000) >= 0xBB8)
  {
    v15 = (*(double *)(a2 + 8) - *(double *)(a2 + 16)) / 0.00800000038;
    v11 = 0.0;
  }
  else
  {
    v45 = *(float32x2_t *)(a1 + 92);
    v9 = hypotf(v45.f32[0] - *(float *)(a1 + 376), v45.f32[1] - *(float *)(a1 + 380));
    if (v9 > *(float *)(a1 + 384))
      *(float *)(a1 + 384) = v9;
    v10 = *(float *)(a1 + 84);
    v11 = 0.0;
    v12 = (float)(v10 + -8.0) * 0.125;
    if (v10 >= 16.0)
      v12 = 1.0;
    if (v10 > 8.0)
      v13 = v12;
    else
      v13 = 0.0;
    v14 = v13 * -0.1 + 0.9;
    v15 = (*(double *)(a2 + 8) - *(double *)(a2 + 16)) / 0.00800000038;
    v16 = pow(v14, v15);
    *(float32x2_t *)(a1 + 388) = vmla_n_f32(vmul_n_f32(v45, 1.0 - v16), *(float32x2_t *)(a1 + 388), v16);
    if ((*(_BYTE *)(a2 + 28) & 2) != 0)
      v11 = MTParserPath::computeDivingButtonChangeInstability(a1, a2, a3);
  }
  v17 = dbl_2310BD360[v8 > *(float *)(a3 + 92)];
  v18 = v17;
  v19 = pow(v17, v15);
  *(float *)(a1 + 572) = (float)(*(float *)(a1 + 72) * (float)(1.0 - v19)) + (float)(v19 * *(float *)(a1 + 572));
  v20 = *(MTSLGLogger **)(a1 + 16);
  if (v20 && MTSLGLogger::isSLGEnabled(v20))
  {
    v21 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::measureInstability] zarea_alpha = %.2f _longTermZarea = %.2f"), *(_QWORD *)&v18, *(float *)(a1 + 572));
    MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v21);
    CFRelease(v21);
  }
  v22 = pow(0.949999988, (*(double *)(a2 + 8) - *(double *)(a2 + 16)) / 0.00800000038);
  *(float *)(a1 + 576) = (float)(*(float *)(a1 + 84) * (float)(1.0 - v22)) + (float)(v22 * *(float *)(a1 + 576));
  v23 = *(MTSLGLogger **)(a1 + 16);
  if (v23 && MTSLGLogger::isSLGEnabled(v23))
  {
    v24 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::measureInstability K39 filtering] _longTermMajorEllipseRadius = %.2f"), *(float *)(a1 + 576));
    MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v24);
    CFRelease(v24);
  }
  v25 = MTParserPath::computeZSignalInstability(a1, a2, (float *)a3, *(unsigned __int8 *)(a1 + 368), v8);
  v26 = 0.0;
  v27 = 0.0;
  if (!*(_BYTE *)(a1 + 368))
  {
    MTParserPath::computeDebounceTimeInstability(a1, a3, v8);
    v27 = v28;
    v29 = MTLoggingPlugin();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
    {
      v44 = *(_DWORD *)(a1 + 40);
      *(_DWORD *)buf = 67109888;
      v47 = v44;
      v48 = 2048;
      v49 = v25;
      v50 = 2048;
      v51 = v27;
      v52 = 2048;
      v53 = v8;
      _os_log_debug_impl(&dword_231071000, v29, OS_LOG_TYPE_DEBUG, "\tDHML:  P%d Wating for slide, ZInstability=%f, TimeInstability=%f (from dtstart=%lfs)", buf, 0x26u);
    }
  }
  v30 = 0.0;
  if ((*(_DWORD *)(a1 + 8) - 1000) <= 0xBB7)
  {
    if ((*(_BYTE *)(a2 + 28) & 2) != 0 && !*(_BYTE *)(a1 + 370))
    {
      MTParserPath::isStuckOnDivingRegion((MTParserPath *)a1, (const MTPathStates *)a2);
      v26 = v31;
    }
    if ((*(_DWORD *)(a2 + 24) - 1000) <= 0x3E7)
    {
      v32 = 48;
      if (*(_DWORD *)(a1 + 44) == 7)
        v32 = 144;
      if ((*(_DWORD *)(a1 + v32) | 4) == 5 && *(int *)(a2 + 384) >= 5 && !*(_BYTE *)(a1 + 368))
      {
        v33 = MTPathStatesBasic::numFingerSlidWhileEngaged((MTPathStatesBasic *)a2);
        v30 = v33 >= 3 ? 0.0 : 0.3;
        if (v33 < 3)
          v11 = v11 + v11;
      }
    }
    if (*(_BYTE *)(a3 + 100)
      && !*(_BYTE *)(a1 + 368)
      && *(int *)(a2 + 384) >= 5
      && (int)MTPathStatesBasic::numFingerSlidWhileEngaged((MTPathStatesBasic *)a2) >= 3)
    {
      v25 = v25 * 0.5;
      v27 = v27 * 0.5;
    }
  }
  if (a4)
  {
    if (v25 <= v30)
      v34 = v30;
    else
      v34 = v25;
    if (v27 <= v11)
      v35 = v11;
    else
      v35 = v27;
    if (v34 <= v35)
      v34 = v35;
    *a4 = v34;
  }
  v36 = *(MTSLGLogger **)(a1 + 16);
  if (v36 && MTSLGLogger::isSLGEnabled(v36))
  {
    v37 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::measureInstability INSTABILITY] instability_ contactZShape = %.2f divingButtonZone = %.2f restingHand = %.2f touchTimeDebounce = %.2f buttonTimeDebounce = %.2f "), v25, v26, v30, v27, v11);
    MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v37);
    CFRelease(v37);
  }
  if (v25 <= v26)
    v38 = v26;
  else
    v38 = v25;
  if (v38 < v30)
    v38 = v30;
  if (v27 <= v11)
    v39 = v11;
  else
    v39 = v27;
  if (v38 <= v39)
    v40 = v39;
  else
    v40 = v38;
  v41 = *(MTSLGLogger **)(a1 + 16);
  if (v41 && MTSLGLogger::isSLGEnabled(v41))
  {
    v42 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::measureInstability] total instability = %.2f"), v40);
    MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v42);
    CFRelease(v42);
  }
  return v40;
}

void MTParserPath::filterContactForScreenUI(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int8x16_t a6, double a7, int8x16_t a8, int8x16_t a9)
{
  uint64_t v14;
  float v15;
  uint64_t v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  int v25;
  _BOOL4 v26;
  uint64_t v27;
  double v28;
  int8x16_t v29;
  uint64_t v30;
  _BOOL4 v31;
  float v32;
  int v33;
  _BOOL4 v34;
  float v35;
  int8x16_t v36;
  __int128 v37;
  float v38;
  double v39;
  float v40;
  MTSLGLogger *v41;
  float v42;
  float v43;
  const __CFString *v44;
  float v45;
  const __CFString *v46;
  float *v47;
  MTSLGLogger *v48;
  const __CFString *v49;
  MTSLGLogger *v50;
  const __CFString *v51;
  unsigned int v52;
  uint64_t v53;
  float v54;
  float v55;
  const __CFString *v56;
  uint64_t v58;
  NSObject *v59;
  uint64_t v60;
  NSObject *v61;
  char v62;
  MTSLGLogger *v63;
  const __CFString *v64;
  char v65;
  char v66;
  uint64_t v67;
  uint64_t v68;
  float v69;
  float v70;
  uint64_t v71;
  float v72;
  float v73;
  int v74;
  float v75;
  float *v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  _DWORD *v82;
  int8x16_t v83;
  float v84;
  void (**v85)(MTSurfaceDimensions *__hidden);
  __int128 v86;
  __int128 v87;
  void (**v88)(MTSurfaceDimensions *__hidden);
  int8x16_t v89;
  __int128 v90;
  float v91[3];

  v14 = a1 + 24;
  v15 = mthm_ComputeFingerEllipseTipOffset_mm((int *)a5, a3, (float32x2_t *)(a1 + 24), (float *)(a1 + 120), a6, a7, a8, a9);
  *(float *)&v16 = MTSurfaceDimensions::convertMillimetersToPixels(a3, v15);
  v83.i64[0] = v16;
  v84 = v17;
  if (*(_BYTE *)(a5 + 52))
  {
    mthm_ComputeFingerEllipseTipOffsetFromPressure_mm(a5, a3, v14);
    v19 = MTSurfaceDimensions::convertMillimetersToPixels(a3, v18);
    v21 = v20;
  }
  else
  {
    v21 = 0.0;
    v19 = 0.0;
  }
  v22 = MTSurfaceDimensions::convertSurfaceFractionToPixels(a3, *(float *)(a1 + 56));
  v24 = v23;
  v91[0] = 0.0;
  v25 = *(_DWORD *)(a1 + 44);
  v82 = (_DWORD *)(a1 + 44);
  v26 = v25 < 3
     || !*(_DWORD *)(a1 + 140)
     || v25 >= 5 && *(_BYTE *)(a1 + 368)
     || v25 == 3 && *(_BYTE *)(a4 + 101) != 0;
  if (*(_BYTE *)(a4 + 98))
  {
    MTParserPath::detectSustainedHoverAtEdge(a1, a4, a3);
    v26 = (*(unsigned __int8 *)(a1 + 580) | v26) != 0;
  }
  *(_QWORD *)(a1 + 556) = *(_QWORD *)(a1 + 548);
  MTParserPath::correctAndQuantizeRadius(a1, a4);
  if (!*(_BYTE *)(a4 + 80))
  {
    v30 = a2;
    goto LABEL_15;
  }
  v30 = a2;
  if (*(float *)(a1 + 64) != 0.0)
  {
LABEL_15:
    v31 = 0;
    goto LABEL_16;
  }
  v31 = *(float *)(a1 + 68) == 0.0;
LABEL_16:
  v32 = *(float *)(a4 + 76);
  if (v32 <= 0.0 || (!*(_BYTE *)(a1 + 368) ? (v33 = 1) : (v33 = v26), ((v33 | v31) & 1) != 0))
  {
    v34 = 0;
  }
  else
  {
    v28 = *(double *)(a1 + 272);
    v34 = *(double *)(a1 + 32) - v28 > v32;
  }
  if (!v26 && !v31 && !v34)
  {
    if (*(_BYTE *)(a4 + 97))
    {
      v29.i32[0] = *(_DWORD *)(a1 + 464);
      v35 = *(float *)(a1 + 468);
      v88 = &off_24FFF1098;
      v37 = *(_OWORD *)(a3 + 24);
      v89 = *(int8x16_t *)(a3 + 8);
      v36 = v89;
      v90 = v37;
      *(float *)v36.i32 = v24;
      MTParserPath::pullHysteresisCenterCancelingEllipseTipMotion((float *)a1, a5, (float *)(a1 + 416), (MTSurfaceDimensions *)&v88, v22, v36, v83, v84, v29, v35);
      MTSurfaceDimensions::~MTSurfaceDimensions((MTSurfaceDimensions *)&v88);
    }
    if (*(_BYTE *)(a5 + 52))
    {
      v29.i32[0] = *(_DWORD *)(a1 + 512);
      v38 = *(float *)(a1 + 516);
      v85 = &off_24FFF1098;
      v86 = *(_OWORD *)(a3 + 8);
      v87 = *(_OWORD *)(a3 + 24);
      *(float *)&v28 = v19;
      MTParserPath::pullHysteresisCenterCancelingEllipseTipMotionFromPressure(a1, COERCE_DOUBLE(__PAIR64__(DWORD1(v87), LODWORD(v22))), v24, v28, v21, *(double *)v29.i64, v38, v27, a1 + 416);
      MTSurfaceDimensions::~MTSurfaceDimensions((MTSurfaceDimensions *)&v85);
    }
    v40 = MTParserPath::measureInstability(a1, v30, a4, v91);
    v41 = *(MTSLGLogger **)(a1 + 16);
    if (v41)
    {
      v43 = *(float *)a4;
      v42 = *(float *)(a4 + 4);
      v41 = (MTSLGLogger *)MTSLGLogger::isSLGEnabled(v41);
      if ((_DWORD)v41)
      {
        v44 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::filterContactForScreenUI INSTABILITY] pixel_instability (equivalent) = %.2f pixel_deltas2hide = %.2f cur_position = (%.2f, %.2f)  _hysteresisCenter = (%.2f, %.2f)"), v40, (float)((float)(v40 * v42) * v43), v22, v24, *(float *)(a1 + 416), *(float *)(a1 + 420));
        MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v44);
        CFRelease(v44);
      }
    }
    if (*(_DWORD *)a5 != 1 || !*(_BYTE *)(a4 + 128))
      goto LABEL_54;
    *(float *)&v39 = v22;
    v45 = MTSurfaceDimensions::distanceToTopEdge_mm(a3, v39, v24);
    v41 = *(MTSLGLogger **)(a1 + 16);
    if (v41)
    {
      v41 = (MTSLGLogger *)MTSLGLogger::isSLGEnabled(v41);
      if ((_DWORD)v41)
      {
        v46 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::filterContactForScreenUI] distance to bottom edge = %.2f\n"), v45);
        MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v46);
        CFRelease(v46);
      }
    }
    if (v45 < 5.0)
    {
      v47 = (float *)(a1 + 416);
      MTParserPath::pullHysteresisCenterHidingUnstablePixelDeltasXY(v22, v24, v40, v40 / 5.0, (uint64_t)v41, (float *)a4, (float *)(a1 + 416));
      v48 = *(MTSLGLogger **)(a1 + 16);
      if (!v48)
      {
        v54 = *(float *)(a1 + 416);
        v55 = *(float *)(a1 + 420);
LABEL_82:
        v62 = MTParserPath::applyAbsolutePixelHysteresis(v22, v24, *(float *)(a1 + 152), *(float *)(a1 + 156), *(float *)(a4 + 56), (uint64_t)v48, v47);
        v63 = *(MTSLGLogger **)(a1 + 16);
        if (v63)
        {
          v63 = (MTSLGLogger *)MTSLGLogger::isSLGEnabled(v63);
          if ((_DWORD)v63)
          {
            v64 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::filterContactForScreenUI] after applying absolute pixel hysteresis:  cur_position = (%.2f, %.2f) _previousContact = (%.2f, %.2f) _hysteresisCenter = (%.2f, %.2f)"), v22, v24, *(float *)(a1 + 152), *(float *)(a1 + 156), *(float *)(a1 + 416), *(float *)(a1 + 420));
            MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v64);
            CFRelease(v64);
          }
        }
        v65 = *(_BYTE *)(a1 + 368) | v62;
        *(_BYTE *)(a1 + 368) = v65;
        if (*(_BYTE *)(a1 + 581))
          v66 = 0;
        else
          v66 = *(_BYTE *)(a1 + 370) | v62;
        *(_BYTE *)(a1 + 370) = v66;
        *(_BYTE *)(a1 + 369) = v65;
        MTParserPath::pullHysteresisCenterHidingUnstablePixelDeltasXY(v22, v24, v91[0], v91[0], (uint64_t)v63, (float *)a4, (float *)(a1 + 424));
        v60 = MTParserPath::applyAbsolutePixelHysteresis(v22, v24, *(float *)(a1 + 152), *(float *)(a1 + 156), *(float *)(a4 + 56), v67, (float *)(a1 + 424));
        *(_BYTE *)(a1 + 369) |= v60;
        if (*(_BYTE *)(a5 + 42))
        {
          v68 = *(_QWORD *)(a1 + 432);
          *(_QWORD *)(a1 + 440) = v68;
          v69 = (float)(int)*(float *)&v68;
          v70 = (float)(int)*((float *)&v68 + 1);
          MTParserPath::pullHysteresisCenterHidingUnstablePixelDeltasXY(*(float *)v83.i32, v84, v40, v40, v60, (float *)a4, (float *)(a1 + 432));
          v60 = MTParserPath::applyAbsolutePixelHysteresis(*(float *)v83.i32, v84, v69, v70, *(float *)(a4 + 56), v71, (float *)(a1 + 432));
        }
        v72 = *(float *)(a1 + 416);
        *(float *)(a1 + 448) = v72 - v54;
        v73 = *(float *)(a1 + 420);
        *(float *)(a1 + 452) = v73 - v55;
        *(float *)(a1 + 456) = (float)(v72 - v54) + *(float *)(a1 + 456);
        *(float *)(a1 + 460) = (float)(v73 - v55) + *(float *)(a1 + 460);
        if (*(_BYTE *)(a1 + 368) || *(_BYTE *)(a1 + 369))
        {
          *(_QWORD *)(a1 + 408) = *(_QWORD *)(a1 + 400);
          *(float *)(a1 + 400) = (float)(int)v72;
          *(float *)(a1 + 404) = (float)(int)v73;
        }
        goto LABEL_93;
      }
      if (MTSLGLogger::isSLGEnabled(v48))
      {
        v49 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::pullHysteresisCenterHidingUnstablePixelDeltas] reduce pixel hysteresis instability to %.2f %.2f for unstable within %.2fmm of bottom edge\n"), v40, (float)(v40 / 5.0), 0x4014000000000000);
        MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v49);
        CFRelease(v49);
      }
    }
    else
    {
LABEL_54:
      MTParserPath::pullHysteresisCenterHidingUnstablePixelDeltasXY(v22, v24, v40, v40, (uint64_t)v41, (float *)a4, (float *)(a1 + 416));
    }
    v48 = *(MTSLGLogger **)(a1 + 16);
    v47 = (float *)(a1 + 416);
    v54 = *(float *)(a1 + 416);
    v55 = *(float *)(a1 + 420);
    if (v48)
    {
      v48 = (MTSLGLogger *)MTSLGLogger::isSLGEnabled(v48);
      if ((_DWORD)v48)
      {
        v56 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("[Hysteresis debugging MTParserPath::filterContactForScreenUI] pulled_hysteresis_center = (%.2f, %.2f)"), *(float *)(a1 + 416), *(float *)(a1 + 420));
        MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v56);
        CFRelease(v56);
      }
    }
    goto LABEL_82;
  }
  v50 = *(MTSLGLogger **)(a1 + 16);
  if (v50 && MTSLGLogger::isSLGEnabled(v50))
  {
    v51 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("Hysteresis debugging [MTParserPath::filterContactForScreenUI] reset_from_stage = %1d reset_from_zero_velocity = %1d, reset_from_pause = %1d\n"), v26, v31, v34);
    MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v51);
    CFRelease(v51);
  }
  *(float *)(a1 + 416) = v22;
  *(float *)(a1 + 420) = v24;
  *(float *)(a1 + 424) = v22;
  *(float *)(a1 + 428) = v24;
  *(_QWORD *)(a1 + 408) = *(_QWORD *)(a1 + 400);
  *(float *)(a1 + 400) = (float)(int)v22;
  *(float *)(a1 + 404) = (float)(int)v24;
  if (*(_BYTE *)(a5 + 42))
  {
    *(_QWORD *)(a1 + 440) = *(_QWORD *)(a1 + 432);
    *(_DWORD *)(a1 + 432) = v83.i32[0];
    *(float *)(a1 + 436) = v84;
  }
  *(_QWORD *)(a1 + 448) = 0;
  *(_QWORD *)(a1 + 456) = 0;
  *(_DWORD *)(a1 + 572) = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 576) = *(_DWORD *)(a1 + 84);
  v52 = *(_DWORD *)(a1 + 8) - 1000;
  if (v52 <= 0xBB7)
  {
    v53 = *(_QWORD *)(a1 + 92);
    *(_QWORD *)(a1 + 388) = v53;
    *(_QWORD *)(a1 + 376) = v53;
  }
  if (!*(_BYTE *)(a5 + 43))
  {
LABEL_51:
    if (v26)
      goto LABEL_52;
    goto LABEL_65;
  }
  if (v26 || v31)
  {
    *(_QWORD *)(a1 + 472) = 0;
    *(_QWORD *)(a1 + 520) = 0;
    goto LABEL_51;
  }
  *(float32x2_t *)(a1 + 472) = vadd_f32(*(float32x2_t *)(a1 + 472), vsub_f32((float32x2_t)__PAIR64__(LODWORD(v84), v83.u32[0]), *(float32x2_t *)(a1 + 464)));
  if (v26)
  {
LABEL_52:
    *(_WORD *)(a1 + 368) = 0;
    *(_BYTE *)(a1 + 370) = 0;
    if (v52 <= 0xBB7)
    {
      *(_DWORD *)(a1 + 384) = 0;
      *(_WORD *)(a1 + 584) = 0;
    }
LABEL_74:
    *(_BYTE *)(a1 + 581) = 0;
    goto LABEL_75;
  }
LABEL_65:
  if (v34)
  {
    if (v52 > 0xBB7)
    {
      *(_WORD *)(a1 + 368) = 0;
      *(_BYTE *)(a1 + 370) = 0;
    }
    else
    {
      v58 = 48;
      if (*(_DWORD *)(a1 + 44) == 7)
        v58 = 144;
      if (*(_DWORD *)(a1 + v58) == 1 && *(int *)(v30 + 420) >= 2 && *(int *)(v30 + 384) > 1)
        goto LABEL_75;
      *(_WORD *)(a1 + 368) = 0;
      *(_BYTE *)(a1 + 370) = 0;
      *(_DWORD *)(a1 + 384) = 0;
    }
    goto LABEL_74;
  }
LABEL_75:
  if (*(int *)(a1 + 48) <= 5 && *(int *)(a1 + 144) < 6)
  {
    v61 = MTLoggingPlugin();
    v60 = os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG);
    v40 = 0.0;
    if ((_DWORD)v60)
      MTParserPath::filterContactForScreenUI(a1, (uint64_t)v82, v61);
  }
  else
  {
    v59 = MTLoggingPlugin();
    v60 = os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG);
    v40 = 0.0;
    if ((_DWORD)v60)
      MTParserPath::filterContactForScreenUI(a1, (int *)(a1 + 48), v59);
  }
LABEL_93:
  *(_BYTE *)(a1 + 371) = MTParserPath::applyAbsoluteForceHysteresis(*(float *)(a1 + 76), *(float *)(a1 + 172), v60, (float *)(a1 + 372), (float *)a4);
  *(float *)(a1 + 76) = (float)(int)*(float *)(a1 + 372);
  *(_DWORD *)(a1 + 464) = v83.i32[0];
  *(float *)(a1 + 468) = v84;
  if (*(_BYTE *)(a5 + 52))
  {
    *(float *)(a1 + 512) = v19;
    *(float *)(a1 + 516) = v21;
  }
  *(float32x2_t *)(a1 + 56) = vcvt_f32_s32(vcvt_s32_f32(*(float32x2_t *)(a1 + 416)));
  *(float *)(a1 + 64) = MTSurfaceDimensions::convertSurfaceFractionVelocityToPixelsPerSecond(a3, *(float *)(a1 + 64));
  *(_DWORD *)(a1 + 68) = v74;
  *(_QWORD *)(a1 + 500) = *(_QWORD *)(a1 + 64);
  *(float *)(a1 + 508) = hypotf(*(float *)(a1 + 100), *(float *)(a1 + 104));
  if (*(_BYTE *)(a4 + 101) && (*v82 - 1) <= 2)
  {
    *(_QWORD *)(a1 + 500) = 0;
    *(_DWORD *)(a1 + 508) = 0;
  }
  v75 = 1.0 - v40;
  if ((float)(1.0 - v40) < 0.0)
    v75 = 0.0;
  MTParserPath::updateDampedVelocity(a1, v30, a4, v75);
  *(_BYTE *)(a1 + 488) = 0;
  v77 = *(float *)(a1 + 112);
  *(float *)(a1 + 492) = v77;
  *(_DWORD *)(a1 + 496) = *(_DWORD *)(a1 + 80);
  v78 = *(float *)(a4 + 64);
  if (v78 >= 0.0)
  {
    v79 = v78 * 0.0174532925;
    MTParserPath::updateAngularHysteresisCenter((MTParserPath *)(a1 + 480), v76, v77, v79);
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 480);
    *(_BYTE *)(a1 + 488) = 1;
  }
  v80 = *(float *)(a4 + 68);
  if (v80 >= 0.0)
  {
    v81 = v80 * 0.0174532925;
    MTParserPath::updateAngularHysteresisCenter((MTParserPath *)(a1 + 484), v76, *(float *)(a1 + 80), v81);
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(a1 + 484);
    *(_BYTE *)(a1 + 488) = 1;
  }
}

void sub_231086400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  MTSurfaceDimensions::~MTSurfaceDimensions((MTSurfaceDimensions *)&a26);
  _Unwind_Resume(a1);
}

void MTParserPath::correctAndQuantizeRadius(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  int8x16_t v9;
  float v11;
  float v12;
  float v13;
  float v16;
  float v17;
  float v18;
  float v19;

  if (*(_BYTE *)(a2 + 102))
  {
    v3 = *(_DWORD *)(a1 + 44) - 1;
    if (v3 <= 5 && (*(_DWORD *)(a1 + 140) - 1) >= 6)
    {
      _D1 = (float32x2_t)vrev64_s32(*(int32x2_t *)(a1 + 84));
    }
    else
    {
      __asm { FMOV            V2.2D, #0.5 }
      v9 = (int8x16_t)vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)(a1 + 84)), _Q2);
      _D1 = vcvt_f32_f64(vmlaq_f64((float64x2_t)vextq_s8(v9, v9, 8uLL), _Q2, vcvtq_f64_f32(*(float32x2_t *)(a1 + 540))));
    }
    *(float32x2_t *)(a1 + 540) = _D1;
    v12 = 0.0;
    v13 = 0.0;
    if (v3 <= 3)
    {
      _S0 = *(float *)(a2 + 104);
      __asm { FMLA            S3, S0, V1.S[1]; float }
      v16 = fmaxf(_S3, 2.0);
      v17 = vmlas_n_f32(*(float *)(a2 + 108), _S0, _D1.f32[0]);
      v12 = _QuantizedRadius(fmaxf(v17, 2.0), *(float *)(a1 + 556), v17, _S3);
      v13 = _QuantizedRadius(v16, *(float *)(a1 + 560), v18, v19);
    }
    *(float *)(a1 + 548) = v12;
    *(float *)(a1 + 552) = v13;
    v11 = 1.0;
  }
  else
  {
    v11 = 0.0;
  }
  *(float *)(a1 + 564) = v11;
}

float _QuantizedRadius(float a1, float a2, float a3, float a4)
{
  float v6;
  int v7;
  double v8;
  int v9;
  _BOOL4 v10;

  if (a1 == 0.0)
    return 0.0;
  if (a1 >= 2.0)
    v6 = a1;
  else
    v6 = 2.0;
  v7 = (int)(float)((float)(v6 + -2.0) * 0.5);
  v8 = fmodf(v6 + -2.0, 2.0);
  if (v6 <= a2 || v8 <= 1.334)
  {
    v10 = v6 < a2;
    if (v8 <= 0.666)
      v10 = 0;
    v9 = v10 + v7;
  }
  else
  {
    v9 = v7 + 1;
  }
  return (float)((float)v9 * 2.0) + 2.0;
}

BOOL MTParserPath::stableAndMoved(MTParserPath *this)
{
  if (!*((_BYTE *)this + 368) && !*((_BYTE *)this + 369))
    return 0;
  if (*((float *)this + 102) == *((float *)this + 100))
    return *((float *)this + 103) != *((float *)this + 101);
  return 1;
}

uint64_t MTParserPath::generateFlagsEventMaskBits(uint64_t a1, uint64_t a2)
{
  int v2;
  unsigned int v3;
  int v4;
  int v5;

  v2 = *(unsigned __int16 *)(a2 + 84);
  v3 = v2 & 0xFE7;
  if ((v2 & 0x100) != 0)
    v4 = 134479872;
  else
    v4 = 0x40000;
  if (v3 >= 0x800)
    v5 = (v3 << 15) & 0x2000000 | ((((unsigned __int16)(v2 & 0xFE7) >> 9) & 1) << 26) | v4 | (v2 << 12) & 0x2000 | ((v2 & 1) << 11) | 0x1000000;
  else
    v5 = (v3 << 15) & 0x2000000 | ((((unsigned __int16)(v2 & 0xFE7) >> 9) & 1) << 26) | v4 | (v2 << 12) & 0x2000 | ((v2 & 1) << 11);
  if ((v2 & 4) == 0)
    v5 = (v2 << 12) & 0x2000 | ((v2 & 1) << 11);
  return v5 | (v2 << 8) & 0xC000u;
}

uint64_t MTInputDeviceManagement::MTInputDeviceManagement(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = &off_24FFF0900;
  *(_QWORD *)(result + 8) = a2;
  *(_QWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 40) = 0;
  return result;
}

{
  *(_QWORD *)result = &off_24FFF0900;
  *(_QWORD *)(result + 8) = a2;
  *(_QWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 40) = 0;
  return result;
}

void MTInputDeviceManagement::~MTInputDeviceManagement(MTInputDeviceManagement *this)
{
  JUMPOUT(0x2348D0034);
}

void MTInputDeviceManagement::scheduleOnDispatchQueue(MTInputDeviceManagement *this, NSObject *a2)
{
  io_registry_entry_t Service;
  CFTypeRef CFProperty;
  const void *v6;
  CFTypeID v7;
  CFTypeRef v8;
  uint64_t v9;
  const void *v10;
  IONotificationPortRef v11;
  IONotificationPort *v12;
  const __CFDictionary *v13;
  NSObject *v14;
  const char *v15;
  unsigned int *v16;
  kern_return_t v17;
  NSObject *v18;
  uint64_t v19;
  void *v20;
  int v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  kern_return_t v28;
  __int16 v29;
  uint64_t v30;
  const __CFString *v31;
  CFTypeRef v32;
  _QWORD v33[2];
  _QWORD v34[3];

  v34[2] = *MEMORY[0x24BDAC8D0];
  Service = MTDeviceGetService();
  if (!Service)
  {
    v14 = MTLoggingPlugin();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      return;
    v21 = 136315650;
    v22 = "[Error] ";
    v23 = 2080;
    v24 = "";
    v25 = 2080;
    v26 = "scheduleOnDispatchQueue";
    v15 = "[HID] [MT] %s%s%s Could not get service";
    goto LABEL_13;
  }
  CFProperty = IORegistryEntryCreateCFProperty(Service, CFSTR("SerialNumber"), (CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
  if (!CFProperty)
    goto LABEL_11;
  v6 = CFProperty;
  v7 = CFGetTypeID(CFProperty);
  if (v7 != CFStringGetTypeID())
  {
    CFRelease(v6);
    goto LABEL_11;
  }
  v8 = (id)CFMakeCollectable(v6);
  if (!v8)
  {
LABEL_11:
    v14 = MTLoggingPlugin();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      return;
    v21 = 136315650;
    v22 = "[Error] ";
    v23 = 2080;
    v24 = "";
    v25 = 2080;
    v26 = "scheduleOnDispatchQueue";
    v15 = "[HID] [MT] %s%s%s Could not get serial number key (cannot match AMD and DM)";
    goto LABEL_13;
  }
  v32 = v8;
  v33[0] = CFSTR("IOPropertyMatch");
  v31 = CFSTR("SerialNumber");
  v9 = objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v32, &v31, 1);
  v33[1] = CFSTR("IONameMatch");
  v34[0] = v9;
  v34[1] = CFSTR("AppleDeviceManagementHIDEventService");
  v10 = (const void *)objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v34, v33, 2);
  v11 = IONotificationPortCreate(0);
  *((_QWORD *)this + 2) = v11;
  if (!v11)
  {
    v14 = MTLoggingPlugin();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      return;
    v21 = 136315650;
    v22 = "[Error] ";
    v23 = 2080;
    v24 = "";
    v25 = 2080;
    v26 = "scheduleOnDispatchQueue";
    v15 = "[HID] [MT] %s%s%s Could not create notification port";
LABEL_13:
    _os_log_impl(&dword_231071000, v14, OS_LOG_TYPE_ERROR, v15, (uint8_t *)&v21, 0x20u);
    return;
  }
  v12 = v11;
  if (v10)
    v13 = (const __CFDictionary *)CFRetain(v10);
  else
    v13 = 0;
  v16 = (unsigned int *)((char *)this + 24);
  v17 = IOServiceAddMatchingNotification(v12, "IOServiceFirstMatch", v13, (IOServiceMatchingCallback)MTInputDeviceManagement::DeviceManagerMatchedCallback, this, (io_iterator_t *)this + 6);
  if (v17 || (v20 = (void *)*v16, !(_DWORD)v20))
  {
    v18 = MTLoggingPlugin();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v19 = *v16;
      v21 = 136316162;
      v22 = "[Error] ";
      v23 = 2080;
      v24 = "";
      v25 = 2080;
      v26 = "scheduleOnDispatchQueue";
      v27 = 1024;
      v28 = v17;
      v29 = 2048;
      v30 = v19;
      _os_log_impl(&dword_231071000, v18, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Could not create notification port: 0x%08x (deviceIterator: 0x%08jx)", (uint8_t *)&v21, 0x30u);
    }
    IONotificationPortDestroy(*((IONotificationPortRef *)this + 2));
    *((_QWORD *)this + 2) = 0;
  }
  else
  {
    MTInputDeviceManagement::DeviceManagerMatchedCallback(this, v20);
    IONotificationPortSetDispatchQueue(*((IONotificationPortRef *)this + 2), a2);
  }
}

void MTInputDeviceManagement::DeviceManagerMatchedCallback(MTInputDeviceManagement *this, void *a2)
{
  io_iterator_t v2;
  void *v4;
  const __CFAllocator *v5;
  io_registry_entry_t v6;
  io_object_t v7;
  NSObject *v8;
  CFMutableDictionaryRef properties;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  uint64_t v16;

  v2 = a2;
  v16 = *MEMORY[0x24BDAC8D0];
  v4 = (void *)MEMORY[0x2348D0388]();
  if (IOIteratorIsValid(v2))
  {
    v5 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    do
    {
      v6 = IOIteratorNext(v2);
      if (!v6)
        break;
      v7 = v6;
      properties = 0;
      if (IORegistryEntryCreateCFProperties(v6, &properties, v5, 0) || !properties)
      {
        v8 = MTLoggingPlugin();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v11 = "[Error] ";
          v12 = 2080;
          v13 = "";
          v14 = 2080;
          v15 = "DeviceManagerMatchedCallback";
          _os_log_impl(&dword_231071000, v8, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Could not retrieve the service properties", buf, 0x20u);
        }
      }
      else
      {
        MTInputDeviceManagement::publishService(this, properties);
        CFRelease(properties);
      }
      IOObjectRelease(v7);
    }
    while (IOIteratorIsValid(v2));
  }
  objc_autoreleasePoolPop(v4);
}

void MTInputDeviceManagement::unscheduleFromDispatchQueue(MTInputDeviceManagement *this, dispatch_queue_t queue)
{
  io_object_t v3;
  IONotificationPort *v4;

  dispatch_assert_queue_not_V2(queue);
  if (*((_QWORD *)this + 5))
    MTInputDeviceManagement::unpublishService(this);
  v3 = *((_DWORD *)this + 6);
  if (v3)
  {
    IOObjectRelease(v3);
    *((_DWORD *)this + 6) = 0;
  }
  v4 = (IONotificationPort *)*((_QWORD *)this + 2);
  if (v4)
  {
    IONotificationPortDestroy(v4);
    *((_QWORD *)this + 2) = 0;
  }
}

void MTInputDeviceManagement::unpublishService(MTInputDeviceManagement *this)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  const char *v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *((_QWORD *)this + 5);
    v4 = 136315906;
    v5 = "";
    v6 = 2080;
    v7 = "";
    v8 = 2080;
    v9 = "unpublishService";
    v10 = 2114;
    v11 = v3;
    _os_log_impl(&dword_231071000, v2, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Unpublishing device with connection UUID %{public}@", (uint8_t *)&v4, 0x2Au);
  }
  objc_msgSend((id)objc_msgSend(MEMORY[0x24BE1A0D8], "sharedClient"), "destroyConnectionWithUUID:", *((_QWORD *)this + 5));
  CFRelease(*((CFTypeRef *)this + 5));
  *((_QWORD *)this + 5) = 0;
}

void MTInputDeviceManagement::publishService(MTInputDeviceManagement *this, __CFDictionary *a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  const char *v11;
  int v12;
  uint64_t v13;
  const void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t i;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  const __CFString *v32;
  const __CFString *v33;
  const __CFString *v34;
  const __CFString *v35;
  uint64_t v36;
  MTInputDeviceManagement *v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  _QWORD v42[6];
  _QWORD v43[6];
  uint8_t buf[4];
  const char *v45;
  __int16 v46;
  const char *v47;
  __int16 v48;
  const char *v49;
  __int16 v50;
  uint64_t v51;
  __int16 v52;
  uint64_t v53;
  __int16 v54;
  const void *v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)this + 5))
    MTInputDeviceManagement::unpublishService(this);
  v4 = (void *)-[__CFDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", CFSTR("MTFW Version"));
  if (!v4 || !objc_msgSend(v4, "intValue"))
  {
    *(_DWORD *)buf = 0;
    MTDeviceGetVersion();
    -[__CFDictionary setObject:forKeyedSubscript:](a2, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", 0), CFSTR("MTFW Version"));
  }
  v5 = -[__CFDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", CFSTR("SerialNumber"));
  if (!v5)
  {
    v10 = MTLoggingPlugin();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136315650;
    v45 = "[Error] ";
    v46 = 2080;
    v47 = "";
    v48 = 2080;
    v49 = "publishService";
    v11 = "[HID] [MT] %s%s%s Could not get a service identifier";
LABEL_27:
    _os_log_impl(&dword_231071000, v10, OS_LOG_TYPE_ERROR, v11, buf, 0x20u);
    return;
  }
  v6 = v5;
  v7 = (void *)-[__CFDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", CFSTR("Transport"));
  if ((objc_msgSend(v7, "isEqualToString:", CFSTR("AID")) & 1) != 0)
  {
    v8 = 7;
    v9 = 3;
  }
  else if ((objc_msgSend(v7, "isEqualToString:", CFSTR("USB")) & 1) != 0)
  {
    v8 = 0;
    v9 = 6;
  }
  else
  {
    v12 = objc_msgSend(v7, "isEqualToString:", CFSTR("Bluetooth"));
    if (v12)
      v9 = 2;
    else
      v9 = 11;
    if (v12)
      v8 = 2;
    else
      v8 = 17;
  }
  v13 = objc_msgSend((id)objc_msgSend(MEMORY[0x24BE1A0D8], "sharedClient"), "createConnectionWithType:andIdentifier:", v9, v6);
  if (!v13)
  {
    v10 = MTLoggingPlugin();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136315650;
    v45 = "[Error] ";
    v46 = 2080;
    v47 = "";
    v48 = 2080;
    v49 = "publishService";
    v11 = "[HID] [MT] %s%s%s Could not create CoreAccessories connection";
    goto LABEL_27;
  }
  v14 = (const void *)v13;
  v15 = objc_msgSend((id)objc_msgSend(MEMORY[0x24BE1A0D8], "sharedClient"), "createEndpointWithTransportType:andProtocol:andIdentifier:andDataOutHandler:forConnectionWithUUID:publishConnection:", v8, 1, 0, 0, v13, 0);
  if (!v15)
  {
    v10 = MTLoggingPlugin();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136315650;
    v45 = "[Error] ";
    v46 = 2080;
    v47 = "";
    v48 = 2080;
    v49 = "publishService";
    v11 = "[HID] [MT] %s%s%s Could not create CoreAccessories endpoint";
    goto LABEL_27;
  }
  v36 = v15;
  if (-[__CFDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", CFSTR("SerialNumber")))
    v35 = (const __CFString *)-[__CFDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", CFSTR("SerialNumber"));
  else
    v35 = &stru_24FFF39D0;
  if (-[__CFDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", CFSTR("Product")))
    v34 = (const __CFString *)-[__CFDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", CFSTR("Product"));
  else
    v34 = &stru_24FFF39D0;
  if (-[__CFDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", CFSTR("Manufacturer")))
    v33 = (const __CFString *)-[__CFDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", CFSTR("Manufacturer"));
  else
    v33 = CFSTR("Apple Inc.");
  v37 = this;
  v16 = (void *)-[__CFDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", CFSTR("HardwareID"));
  v31 = v6;
  if (v16)
    v32 = (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%04X"), objc_msgSend(v16, "unsignedIntegerValue"));
  else
    v32 = &stru_24FFF39D0;
  v17 = (void *)objc_msgSend(MEMORY[0x24BDD16A8], "stringWithCapacity:", 20);
  v38 = 0u;
  v39 = 0u;
  v40 = 0u;
  v41 = 0u;
  v18 = objc_msgSend(&unk_24FFF9708, "countByEnumeratingWithState:objects:count:", &v38, buf, 16);
  if (v18)
  {
    v19 = v18;
    v20 = *(_QWORD *)v39;
    do
    {
      for (i = 0; i != v19; ++i)
      {
        if (*(_QWORD *)v39 != v20)
          objc_enumerationMutation(&unk_24FFF9708);
        v22 = -[__CFDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v38 + 1) + 8 * i));
        if (v22)
        {
          v23 = (void *)v22;
          if (objc_msgSend(v17, "length"))
            objc_msgSend(v17, "appendString:", CFSTR("."));
          objc_msgSend(v17, "appendString:", objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%04X"), objc_msgSend(v23, "unsignedIntegerValue")));
        }
      }
      v19 = objc_msgSend(&unk_24FFF9708, "countByEnumeratingWithState:objects:count:", &v38, buf, 16);
    }
    while (v19);
  }
  v24 = *MEMORY[0x24BE1A118];
  v25 = *MEMORY[0x24BE1A108];
  v42[0] = *MEMORY[0x24BE1A118];
  v42[1] = v25;
  v43[0] = v34;
  v43[1] = v33;
  v26 = *MEMORY[0x24BE1A0F8];
  v42[2] = *MEMORY[0x24BE1A138];
  v42[3] = v26;
  v43[2] = v35;
  v43[3] = v17;
  v27 = *MEMORY[0x24BE1A110];
  v42[4] = *MEMORY[0x24BE1A100];
  v42[5] = v27;
  v43[4] = v32;
  v43[5] = &stru_24FFF39D0;
  v28 = (void *)objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v43, v42, 6);
  objc_msgSend((id)objc_msgSend(MEMORY[0x24BE1A0D8], "sharedClient"), "setAccessoryInfo:forEndpointWithUUID:", v28, v36);
  v29 = MTLoggingPlugin();
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    v30 = objc_msgSend(v28, "objectForKeyedSubscript:", v24);
    *(_DWORD *)buf = 136316418;
    v45 = "";
    v46 = 2080;
    v47 = "";
    v48 = 2080;
    v49 = "publishService";
    v50 = 2114;
    v51 = v31;
    v52 = 2114;
    v53 = v30;
    v54 = 2114;
    v55 = v14;
    _os_log_impl(&dword_231071000, v29, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Publishing device %{public}@ (%{public}@) with connection UUID %{public}@", buf, 0x3Eu);
  }
  objc_msgSend((id)objc_msgSend(MEMORY[0x24BE1A0D8], "sharedClient"), "publishConnectionWithUUID:", v14);
  *((_QWORD *)v37 + 5) = CFRetain(v14);
}

unint64_t MTChordTable::areChordFingersContiguous(MTChordTable *this)
{
  return (0xD101D1DFuLL >> (this & 0x1F)) & 1;
}

uint64_t MTChordTable::MTChordTable(uint64_t a1, int a2, uint64_t a3)
{
  *(_QWORD *)a1 = off_24FFF0930;
  *(_DWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) = 8654537;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_OWORD *)(a1 + 60) = 0u;
  *(_OWORD *)(a1 + 76) = 0u;
  *(_OWORD *)(a1 + 92) = 0u;
  *(_OWORD *)(a1 + 108) = 0u;
  *(_OWORD *)(a1 + 124) = 0u;
  *(_OWORD *)(a1 + 140) = 0u;
  *(_OWORD *)(a1 + 156) = 0u;
  *(_OWORD *)(a1 + 172) = 0u;
  *(_OWORD *)(a1 + 188) = 0u;
  *(_OWORD *)(a1 + 204) = 0u;
  *(_OWORD *)(a1 + 220) = 0u;
  *(_OWORD *)(a1 + 236) = 0u;
  *(_OWORD *)(a1 + 252) = 0u;
  *(_DWORD *)(a1 + 364) = 0;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 268) = 0u;
  *(_OWORD *)(a1 + 284) = 0u;
  *(_OWORD *)(a1 + 300) = 0u;
  *(_OWORD *)(a1 + 316) = 0u;
  *(_OWORD *)(a1 + 332) = 0u;
  *(_OWORD *)(a1 + 348) = 0u;
  MTChordTable::clearAllChordsInTable((MTChordTable *)a1);
  return a1;
}

void sub_2310873D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v10;
  uint64_t i;

  for (i = 344; i != 8; i -= 24)
  {
    a10 = (void **)(v10 + i);
    std::vector<MTChordGestureSet>::__destroy_vector::operator()[abi:ne180100](&a10);
  }
  _Unwind_Resume(a1);
}

void MTChordTable::clearAllChordsInTable(MTChordTable *this)
{
  uint64_t i;
  char *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;

  (*(void (**)(MTChordTable *))(*(_QWORD *)this + 16))(this);
  for (i = 0; i != 14; ++i)
  {
    v3 = (char *)this + 24 * i;
    v6 = *((_QWORD *)v3 + 5);
    v5 = v3 + 40;
    v4 = v6;
    v7 = *(v5 - 1);
    if (v6 != v7)
    {
      do
      {
        v4 -= 240;
        std::allocator<MTChordGestureSet>::destroy[abi:ne180100]((uint64_t)this + 24 * i + 48, v4);
      }
      while (v4 != v7);
    }
    *v5 = v7;
  }
}

void MTChordTable::~MTChordTable(MTChordTable *this)
{
  uint64_t i;
  void **v3;

  *(_QWORD *)this = off_24FFF0930;
  for (i = 344; i != 8; i -= 24)
  {
    v3 = (void **)((char *)this + i);
    std::vector<MTChordGestureSet>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
}

{
  uint64_t i;
  void **v3;

  *(_QWORD *)this = off_24FFF0930;
  for (i = 344; i != 8; i -= 24)
  {
    v3 = (void **)((char *)this + i);
    std::vector<MTChordGestureSet>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
}

{
  uint64_t i;
  void **v3;

  *(_QWORD *)this = off_24FFF0930;
  for (i = 344; i != 8; i -= 24)
  {
    v3 = (void **)((char *)this + i);
    std::vector<MTChordGestureSet>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
  MEMORY[0x2348D0034](this, 0x10B1C40610187EELL);
}

uint64_t MTChordTable::getFingerMaskForLookup(MTChordTable *this, MTHandStatistics *a2)
{
  int v2;
  char *v3;
  unsigned __int16 *v4;

  v2 = *((_DWORD *)this + 7);
  v3 = (char *)a2 + 296;
  if (v2 == 2)
    v3 = (char *)a2 + 220;
  if (v2 == 1)
    v4 = (unsigned __int16 *)((char *)a2 + 300);
  else
    v4 = (unsigned __int16 *)v3;
  return *v4;
}

uint64_t MTChordTable::fingerComboToChordSpecifier(MTChordTable *this, char a2)
{
  int8x16_t v2;
  unsigned int v3;

  if ((a2 & 0x1F) == 0)
    return 0;
  v2.i64[0] = 0x100000001;
  v2.i64[1] = 0x100000001;
  v3 = vaddvq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(a2), (uint32x4_t)xmmword_2310BD3B0), v2));
  if ((a2 & 1) != 0)
    return v3 + 5;
  else
    return v3;
}

char *MTChordTable::getChordVectForCombo(MTChordTable *this, char a2)
{
  int8x16_t v2;
  int v3;
  unsigned int v4;
  char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int v12;
  int v13;
  BOOL v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unsigned int v21;
  int v22;

  if ((a2 & 0x1F) == 0)
    return (char *)this + 32;
  v2.i64[0] = 0x100000001;
  v2.i64[1] = 0x100000001;
  v3 = vaddvq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(a2), (uint32x4_t)xmmword_2310BD3B0), v2));
  v4 = v3 + 5;
  if ((a2 & 1) == 0)
    v4 = v3;
  if (!v4)
    return (char *)this + 32;
  v5 = (char *)this + 24 * v4;
  v7 = *((_QWORD *)v5 + 4);
  v8 = *((_QWORD *)v5 + 5);
  v6 = v5 + 32;
  v9 = v8 - v7;
  if (!v9)
  {
LABEL_10:
    if (v4 - 5 <= 4)
    {
      v15 = (char *)this + 24 * v4 - 96;
      v16 = *((_QWORD *)v15 + 4);
      v17 = *((_QWORD *)v15 + 5);
      v6 = v15 + 32;
      v18 = v17 - v16;
      if (v18)
      {
        v19 = 0;
        v20 = 0xEEEEEEEEEEEEEEEFLL * (v18 >> 4);
        v21 = 1;
        while (1)
        {
          v22 = *(_DWORD *)(v16 + 240 * v19 + 232);
          if (!v22 || (*((_DWORD *)this + 6) & v22) != 0)
            break;
          v19 = v21;
          v14 = v20 > v21++;
          if (!v14)
            return (char *)this + 32;
        }
        return v6;
      }
    }
    return (char *)this + 32;
  }
  v10 = 0;
  v11 = 0xEEEEEEEEEEEEEEEFLL * (v9 >> 4);
  v12 = 1;
  while (1)
  {
    v13 = *(_DWORD *)(v7 + 240 * v10 + 232);
    if (!v13 || (*((_DWORD *)this + 6) & v13) != 0)
      return v6;
    v10 = v12;
    v14 = v11 > v12++;
    if (!v14)
      goto LABEL_10;
  }
}

uint64_t MTChordTable::hasTwoFingerOrientationEvents(MTChordTable *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  unsigned int v5;
  MTChordGestureSet *v6;
  int v7;

  v2 = *((_QWORD *)this + 10);
  v1 = *((_QWORD *)this + 11);
  if (v1 == v2)
    return 0;
  v4 = 0;
  v5 = 1;
  while (1)
  {
    v6 = (MTChordGestureSet *)(v2 + 240 * v4);
    v7 = *((_DWORD *)v6 + 58);
    if (v7 && (*((_DWORD *)this + 6) & v7) == 0)
      goto LABEL_7;
    if ((MTChordGestureSet::hasEnabledOrientationEvents(v6, this) & 1) != 0)
      return 1;
    v2 = *((_QWORD *)this + 10);
    v1 = *((_QWORD *)this + 11);
LABEL_7:
    v4 = v5;
    if (0xEEEEEEEEEEEEEEEFLL * ((v1 - v2) >> 4) <= v5++)
      return 0;
  }
}

uint64_t MTChordTable::getMinThumbSpecificFingerCount(MTChordTable *this)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  MTChordGestureSet *v10;
  int v11;

  v2 = 6;
  while (1)
  {
    v3 = (char *)this + 24 * v2;
    v6 = *((_QWORD *)v3 + 4);
    v5 = (uint64_t *)(v3 + 32);
    v4 = v6;
    v7 = v5[1];
    if (v7 != v6)
      break;
LABEL_9:
    if (++v2 == 10)
      return 0;
  }
  v8 = 0;
  v9 = 1;
  while (1)
  {
    v10 = (MTChordGestureSet *)(v4 + 240 * v8);
    v11 = *((_DWORD *)v10 + 58);
    if (v11 && (*((_DWORD *)this + 6) & v11) == 0)
      goto LABEL_8;
    if (!MTChordGestureSet::isEmpty(v10))
      return (v2 - 4);
    v7 = v5[1];
    v4 = *v5;
LABEL_8:
    v8 = v9;
    if (0xEEEEEEEEEEEEEEEFLL * ((v7 - v4) >> 4) <= v9++)
      goto LABEL_9;
  }
}

uint64_t MTChordTable::findMatchingChord(MTChordTable *this, char a2, int a3)
{
  char *ChordVectForCombo;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  unint64_t v10;
  float v11;
  uint64_t v12;
  int v13;
  int v14;
  _BOOL4 v15;
  int v16;
  uint64_t v17;
  float v18;

  ChordVectForCombo = MTChordTable::getChordVectForCombo(this, a2);
  v6 = *(_QWORD *)ChordVectForCombo;
  v7 = *((_QWORD *)ChordVectForCombo + 1);
  result = 0;
  v9 = v7 - v6;
  if (v9)
  {
    v10 = 0xEEEEEEEEEEEEEEEFLL * (v9 >> 4);
    v11 = 3.4028e38;
    v12 = 1;
    do
    {
      if (*(_QWORD *)(v6 + 160) == *(_QWORD *)(v6 + 168))
        v13 = (*(unsigned __int16 *)(v6 + 120) >> 6) & 1;
      else
        v13 = 0;
      v14 = *(_DWORD *)(v6 + 232);
      if (v14)
        v15 = (*((_DWORD *)this + 6) & v14) != 0;
      else
        v15 = 1;
      v16 = !v15 | v13 ^ a3;
      if (v11 <= 0.0)
        v17 = result;
      else
        v17 = v6;
      if (v11 <= 0.0)
        v18 = v11;
      else
        v18 = 0.0;
      if (!v16)
      {
        result = v17;
        v11 = v18;
      }
      v6 += 240;
    }
    while (v10 > v12++);
  }
  return result;
}

MTChordGestureSet *MTChordTable::copyChordIntoTable(MTChordTable *this, MTChordGestureSet *a2)
{
  unsigned int v2;
  uint64_t v3;
  char *v4;
  unint64_t v5;
  MTChordGestureSet *v6;
  uint64_t *v7;
  uint64_t v8;

  v2 = *((_DWORD *)a2 + 56);
  v3 = *((_QWORD *)this + 2);
  *((_DWORD *)a2 + 51) = *((_DWORD *)this + 2);
  *((_QWORD *)a2 + 26) = v3;
  if (v2 <= 0xD)
  {
    v4 = (char *)this + 24 * v2;
    v6 = (MTChordGestureSet *)*((_QWORD *)v4 + 5);
    v5 = *((_QWORD *)v4 + 6);
    v7 = (uint64_t *)(v4 + 40);
    if ((unint64_t)v6 >= v5)
    {
      v8 = std::vector<MTChordGestureSet>::__push_back_slow_path<MTChordGestureSet const&>((uint64_t *)this + 3 * v2 + 4, a2);
    }
    else
    {
      MTChordGestureSet::MTChordGestureSet(v6, a2);
      v8 = (uint64_t)v6 + 240;
      *v7 = (uint64_t)v6 + 240;
    }
    *v7 = v8;
    return (MTChordGestureSet *)(v8 - 240);
  }
  return a2;
}

void sub_2310879A0(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;

  *v2 = v1;
  _Unwind_Resume(a1);
}

void std::vector<MTChordGestureSet>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 240;
        std::allocator<MTChordGestureSet>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<MTChordGestureSet>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void **v8;

  v8 = (void **)(a2 + 160);
  std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100](&v8);
  v3 = *(void **)(a2 + 128);
  if (v3)
  {
    *(_QWORD *)(a2 + 136) = v3;
    operator delete(v3);
  }
  v4 = *(void **)(a2 + 96);
  if (v4)
  {
    *(_QWORD *)(a2 + 104) = v4;
    operator delete(v4);
  }
  v5 = *(void **)(a2 + 64);
  if (v5)
  {
    *(_QWORD *)(a2 + 72) = v5;
    operator delete(v5);
  }
  v6 = *(void **)(a2 + 32);
  if (v6)
  {
    *(_QWORD *)(a2 + 40) = v6;
    operator delete(v6);
  }
  v7 = *(void **)a2;
  if (*(_QWORD *)a2)
  {
    *(_QWORD *)(a2 + 8) = v7;
    operator delete(v7);
  }
}

void std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<MTSlideGesture>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<MTSlideGesture>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;

  v3 = *a1;
  v2 = a1[1];
  if (v2 != *a1)
  {
    v4 = a1[1];
    do
    {
      v6 = *(void **)(v4 - 160);
      v4 -= 160;
      v5 = v6;
      if (v6)
      {
        *(_QWORD *)(v2 - 152) = v5;
        operator delete(v5);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

uint64_t std::vector<MTChordGestureSet>::__push_back_slow_path<MTChordGestureSet const&>(uint64_t *a1, const MTChordGestureSet *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  void *v13;
  MTChordGestureSet *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 4);
  v5 = v4 + 1;
  if (v4 + 1 > 0x111111111111111)
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xEEEEEEEEEEEEEEEFLL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x88888888888888)
    v9 = 0x111111111111111;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTChordGestureSet>>(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = (MTChordGestureSet *)&v10[240 * v4];
  v16 = &v10[240 * v9];
  MTChordGestureSet::MTChordGestureSet(v14, a2);
  v15 = (char *)v14 + 240;
  std::vector<MTChordGestureSet>::__swap_out_circular_buffer(a1, &v13);
  v11 = a1[1];
  std::__split_buffer<MTChordGestureSet>::~__split_buffer(&v13);
  return v11;
}

void sub_231087C3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  std::__split_buffer<MTChordGestureSet>::~__split_buffer(&a9);
  _Unwind_Resume(a1);
}

uint64_t std::vector<MTChordGestureSet>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MTChordGestureSet>,std::reverse_iterator<MTChordGestureSet*>,std::reverse_iterator<MTChordGestureSet*>,std::reverse_iterator<MTChordGestureSet*>>((uint64_t)(a1 + 2), a1[1], (const MTChordGestureSet *)a1[1], *a1, (const MTChordGestureSet *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<MTChordGestureSet>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x111111111111112)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(240 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MTChordGestureSet>,std::reverse_iterator<MTChordGestureSet*>,std::reverse_iterator<MTChordGestureSet*>,std::reverse_iterator<MTChordGestureSet*>>(uint64_t a1, uint64_t a2, const MTChordGestureSet *a3, uint64_t a4, const MTChordGestureSet *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  const MTChordGestureSet *v9;
  uint64_t v10;
  _QWORD v12[3];
  unint64_t v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0xAAAAAAAAAAAAAA00;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    v9 = a3;
    do
    {
      v9 = (const MTChordGestureSet *)((char *)v9 - 240);
      MTChordGestureSet::MTChordGestureSet((MTChordGestureSet *)(v7 - 240), v9);
      v7 = *((_QWORD *)&v15 + 1) - 240;
      *((_QWORD *)&v15 + 1) -= 240;
    }
    while (v9 != a5);
    v10 = v15;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTChordGestureSet>,std::reverse_iterator<MTChordGestureSet*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

void sub_231087DB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTChordGestureSet>,std::reverse_iterator<MTChordGestureSet*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTChordGestureSet>,std::reverse_iterator<MTChordGestureSet*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<MTChordGestureSet>,std::reverse_iterator<MTChordGestureSet*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<MTChordGestureSet>,std::reverse_iterator<MTChordGestureSet*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<MTChordGestureSet>::destroy[abi:ne180100](v3, v1);
      v1 += 240;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<MTChordGestureSet>::~__split_buffer(void **a1)
{
  std::__split_buffer<MTChordGestureSet>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<MTChordGestureSet>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 240;
    std::allocator<MTChordGestureSet>::destroy[abi:ne180100](v4, i - 240);
  }
}

BOOL MTChordCycling::slideGestureOngoing(MTChordCycling *this, double a2)
{
  return *((_DWORD *)this + 158) && *((_BYTE *)this + 672) && *((_BYTE *)this + 675) == 0;
}

BOOL MTGestureConfig::slideOrDragOngoing(MTGestureConfig *this, double a2, int a3)
{
  uint64_t v6;

  v6 = *((_QWORD *)this + 7);
  return v6 && ((*(uint64_t (**)(uint64_t, double))(*(_QWORD *)v6 + 40))(v6, a2) & 1) != 0
      || MTTapDragManager::shouldSustainDrag(*((MTTapDragManager **)this + 9), a2, a3);
}

MTChordGestureSet *MTGestureConfig::copyChordIntoHandTable(uint64_t a1, int a2, MTChordGestureSet *a3)
{
  MTChordTable *v3;

  if (a2 == 1 && (v3 = *(MTChordTable **)(a1 + 56)) != 0)
    return MTChordTable::copyChordIntoTable(v3, a3);
  else
    return a3;
}

uint64_t MTGestureConfig::getChordTableForHand(uint64_t a1, int a2)
{
  if (a2 == 1)
    return *(_QWORD *)(a1 + 56);
  else
    return 0;
}

void MTGestureConfig::~MTGestureConfig(MTGestureConfig *this)
{
  MTChordTable *v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24FFF0970;
  v2 = (MTChordTable *)*((_QWORD *)this + 7);
  if (v2)
  {
    MTChordTable::clearAllChordsInTable(v2);
    v3 = *((_QWORD *)this + 7);
    if (v3)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
      *((_QWORD *)this + 7) = 0;
    }
  }
  v4 = *((_QWORD *)this + 8);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
    *((_QWORD *)this + 8) = 0;
  }
  std::__tree<std::__value_type<std::string,std::vector<MTActionEvent>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<MTActionEvent>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<MTActionEvent>>>>::destroy((uint64_t)this + 32, *((_QWORD **)this + 5));
  std::__tree<std::__value_type<std::string,MTGestureMotionParams>,std::__map_value_compare<std::string,std::__value_type<std::string,MTGestureMotionParams>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MTGestureMotionParams>>>::destroy((uint64_t)this + 8, *((char **)this + 2));
}

{
  MTGestureConfig::~MTGestureConfig(this);
  JUMPOUT(0x2348D0034);
}

void MTGestureConfig::clearAllChords(MTGestureConfig *this)
{
  MTChordTable *v1;

  v1 = (MTChordTable *)*((_QWORD *)this + 7);
  if (v1)
    MTChordTable::clearAllChordsInTable(v1);
}

_QWORD *MTGestureConfig::MTGestureConfig(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;

  a1[2] = 0;
  a1[1] = a1 + 2;
  *a1 = &off_24FFF0970;
  a1[3] = 0;
  a1[5] = 0;
  a1[4] = a1 + 5;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = a5;
  mtgp_InitUSBKeyNames();
  if ((a2 - 1000) > 0x3E7)
  {
    v8 = operator new();
    if ((a2 - 2000) > 0x3E7)
      MTChordCyclingTrackpad::MTChordCyclingTrackpad(v8, 1, (uint64_t)"Right", a1[9], a4, a2);
    else
      MTChordCycling::MTChordCycling(v8, 1, "Right", a1[9], a4, a2);
  }
  else
  {
    v8 = operator new();
    MTChordCyclingTrackpad::MTChordCyclingTrackpad(v8, 1, (uint64_t)"Right", a1[9], a4, a2);
  }
  a1[7] = v8;
  return a1;
}

void sub_231088188(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char **v4;
  _QWORD **v5;

  MEMORY[0x2348D0034](v3, 0x10B1C406AFB875BLL);
  std::__tree<std::__value_type<std::string,std::vector<MTActionEvent>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<MTActionEvent>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<MTActionEvent>>>>::destroy(v2, *v5);
  std::__tree<std::__value_type<std::string,MTGestureMotionParams>,std::__map_value_compare<std::string,std::__value_type<std::string,MTGestureMotionParams>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MTGestureMotionParams>>>::destroy(v1, *v4);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<std::string,MTGestureMotionParams>,std::__map_value_compare<std::string,std::__value_type<std::string,MTGestureMotionParams>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MTGestureMotionParams>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,MTGestureMotionParams>,std::__map_value_compare<std::string,std::__value_type<std::string,MTGestureMotionParams>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MTGestureMotionParams>>>::destroy(a1, *(_QWORD *)a2);
    std::__tree<std::__value_type<std::string,MTGestureMotionParams>,std::__map_value_compare<std::string,std::__value_type<std::string,MTGestureMotionParams>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MTGestureMotionParams>>>::destroy(a1, *((_QWORD *)a2 + 1));
    if (a2[55] < 0)
      operator delete(*((void **)a2 + 4));
    operator delete(a2);
  }
}

void std::__tree<std::__value_type<std::string,std::vector<MTActionEvent>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<MTActionEvent>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<MTActionEvent>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::vector<MTActionEvent>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<MTActionEvent>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<MTActionEvent>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,std::vector<MTActionEvent>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<MTActionEvent>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<MTActionEvent>>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<MTActionEvent>>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<MTActionEvent>>,0>(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

double mtgp_InitUSBKeyNames()
{
  double result;

  gUSBKeyNames = (uint64_t)CFSTR("NULL");
  *(_QWORD *)algn_255EB3D28 = CFSTR("ErrorRollOver");
  qword_255EB3D30 = (uint64_t)CFSTR("POSTFail");
  unk_255EB3D38 = CFSTR("ErrorUndefined");
  qword_255EB3D40 = (uint64_t)CFSTR("A");
  unk_255EB3D48 = CFSTR("B");
  qword_255EB3D50 = (uint64_t)CFSTR("C");
  unk_255EB3D58 = CFSTR("D");
  qword_255EB3D60 = (uint64_t)CFSTR("E");
  unk_255EB3D68 = CFSTR("F");
  qword_255EB3D70 = (uint64_t)CFSTR("G");
  unk_255EB3D78 = CFSTR("H");
  qword_255EB3D80 = (uint64_t)CFSTR("I");
  unk_255EB3D88 = CFSTR("J");
  qword_255EB3D90 = (uint64_t)CFSTR("K");
  unk_255EB3D98 = CFSTR("L");
  qword_255EB3DA0 = (uint64_t)CFSTR("M");
  unk_255EB3DA8 = CFSTR("N");
  qword_255EB3DB0 = (uint64_t)CFSTR("O");
  unk_255EB3DB8 = CFSTR("P");
  qword_255EB3DC0 = (uint64_t)CFSTR("Q");
  unk_255EB3DC8 = CFSTR("R");
  qword_255EB3DD0 = (uint64_t)CFSTR("S");
  unk_255EB3DD8 = CFSTR("T");
  qword_255EB3DE0 = (uint64_t)CFSTR("U");
  unk_255EB3DE8 = CFSTR("V");
  qword_255EB3DF0 = (uint64_t)CFSTR("W");
  unk_255EB3DF8 = CFSTR("X");
  qword_255EB3E00 = (uint64_t)CFSTR("Y");
  unk_255EB3E08 = CFSTR("Z");
  qword_255EB3E10 = (uint64_t)CFSTR("1");
  unk_255EB3E18 = CFSTR("2");
  qword_255EB3E20 = (uint64_t)CFSTR("3");
  unk_255EB3E28 = CFSTR("4");
  qword_255EB3E30 = (uint64_t)CFSTR("5");
  unk_255EB3E38 = CFSTR("6");
  qword_255EB3E40 = (uint64_t)CFSTR("7");
  unk_255EB3E48 = CFSTR("8");
  qword_255EB3E50 = (uint64_t)CFSTR("9");
  unk_255EB3E58 = CFSTR("0");
  qword_255EB3E60 = (uint64_t)CFSTR("Enter");
  unk_255EB3E68 = CFSTR("Escape");
  qword_255EB3E70 = (uint64_t)CFSTR("BackSpace");
  unk_255EB3E78 = CFSTR("Tab");
  qword_255EB3E80 = (uint64_t)CFSTR("Space");
  unk_255EB3E88 = CFSTR("-");
  qword_255EB3E90 = (uint64_t)CFSTR("=");
  unk_255EB3E98 = CFSTR("[");
  qword_255EB3EA0 = (uint64_t)CFSTR("]");
  unk_255EB3EA8 = CFSTR("\\");
  qword_255EB3EB0 = (uint64_t)CFSTR("#");
  unk_255EB3EB8 = CFSTR(";");
  qword_255EB3EC0 = (uint64_t)CFSTR("'");
  qword_255EB3ED0 = (uint64_t)CFSTR(",");
  unk_255EB3ED8 = CFSTR(".");
  qword_255EB3EE0 = (uint64_t)CFSTR("/");
  unk_255EB3EE8 = CFSTR("CapsLock");
  qword_255EB3EF0 = (uint64_t)CFSTR("F1");
  unk_255EB3EF8 = CFSTR("F2");
  qword_255EB3F00 = (uint64_t)CFSTR("F3");
  unk_255EB3F08 = CFSTR("F4");
  qword_255EB3F10 = (uint64_t)CFSTR("F5");
  unk_255EB3F18 = CFSTR("F6");
  qword_255EB3F20 = (uint64_t)CFSTR("F7");
  qword_255EB3F28 = (uint64_t)CFSTR("F8");
  qword_255EB3F30 = (uint64_t)CFSTR("F9");
  qword_255EB3F38 = (uint64_t)CFSTR("F10");
  qword_255EB3F40 = (uint64_t)CFSTR("F11");
  qword_255EB3F48 = (uint64_t)CFSTR("F12");
  qword_255EB3F50 = (uint64_t)CFSTR("PrintScreen");
  qword_255EB3F58 = (uint64_t)CFSTR("ScrollLock");
  qword_255EB3F60 = (uint64_t)CFSTR("Pause");
  qword_255EB3F68 = (uint64_t)CFSTR("Insert");
  qword_255EB3F70 = (uint64_t)CFSTR("Home");
  qword_255EB3F78 = (uint64_t)CFSTR("PageUp");
  qword_255EB3F80 = (uint64_t)CFSTR("Delete");
  qword_255EB3F88 = (uint64_t)CFSTR("End");
  qword_255EB3F90 = (uint64_t)CFSTR("PageDown");
  qword_255EB3F98 = (uint64_t)CFSTR("Right");
  qword_255EB3FA0 = (uint64_t)CFSTR("Left");
  qword_255EB3FA8 = (uint64_t)CFSTR("Down");
  qword_255EB3FB0 = (uint64_t)CFSTR("Up");
  qword_255EB3FB8 = (uint64_t)CFSTR("NumLock");
  qword_255EB3FC0 = (uint64_t)CFSTR("Numpad/");
  qword_255EB3FC8 = (uint64_t)CFSTR("Numpad*");
  qword_255EB3FD0 = (uint64_t)CFSTR("Numpad-");
  qword_255EB3FD8 = (uint64_t)CFSTR("Numpad+");
  qword_255EB3FE0 = (uint64_t)CFSTR("NumpadEnter");
  qword_255EB3FE8 = (uint64_t)CFSTR("Numpad1");
  qword_255EB3FF0 = (uint64_t)CFSTR("Numpad2");
  qword_255EB3FF8 = (uint64_t)CFSTR("Numpad3");
  qword_255EB4000 = (uint64_t)CFSTR("Numpad4");
  qword_255EB4008 = (uint64_t)CFSTR("Numpad5");
  qword_255EB4010 = (uint64_t)CFSTR("Numpad6");
  qword_255EB4018 = (uint64_t)CFSTR("Numpad7");
  qword_255EB4020 = (uint64_t)CFSTR("Numpad8");
  qword_255EB4028 = (uint64_t)CFSTR("Numpad9");
  qword_255EB4030 = (uint64_t)CFSTR("Numpad0");
  qword_255EB4038 = (uint64_t)CFSTR("Numpad.");
  qword_255EB4040 = (uint64_t)CFSTR("NonUS\\|");
  qword_255EB4048 = (uint64_t)CFSTR("Application");
  qword_255EB4050 = (uint64_t)CFSTR("Power");
  qword_255EB4058 = (uint64_t)CFSTR("Keypad=");
  qword_255EB4060 = (uint64_t)CFSTR("F13");
  qword_255EB4068 = (uint64_t)CFSTR("F14");
  qword_255EB4070 = (uint64_t)CFSTR("F15");
  qword_255EB4078 = (uint64_t)CFSTR("F16");
  qword_255EB4080 = (uint64_t)CFSTR("F17");
  qword_255EB4088 = (uint64_t)CFSTR("F18");
  qword_255EB4090 = (uint64_t)CFSTR("F19");
  qword_255EB4098 = (uint64_t)CFSTR("F20");
  qword_255EB40A0 = (uint64_t)CFSTR("F21");
  qword_255EB40A8 = (uint64_t)CFSTR("F22");
  qword_255EB40B0 = (uint64_t)CFSTR("F23");
  qword_255EB40B8 = (uint64_t)CFSTR("F24");
  qword_255EB40C0 = (uint64_t)CFSTR("Execute");
  qword_255EB40C8 = (uint64_t)CFSTR("Help");
  qword_255EB40D0 = (uint64_t)CFSTR("Menu");
  qword_255EB40D8 = (uint64_t)CFSTR("Select");
  qword_255EB40E0 = (uint64_t)CFSTR("Stop");
  qword_255EB40E8 = (uint64_t)CFSTR("Again");
  qword_255EB40F0 = (uint64_t)CFSTR("Undo");
  qword_255EB40F8 = (uint64_t)CFSTR("Cut");
  qword_255EB4100 = (uint64_t)CFSTR("Copy");
  qword_255EB4108 = (uint64_t)CFSTR("Paste");
  qword_255EB4110 = (uint64_t)CFSTR("Find");
  qword_255EB4118 = (uint64_t)CFSTR("Mute");
  qword_255EB4120 = (uint64_t)CFSTR("VolumeUp");
  qword_255EB4128 = (uint64_t)CFSTR("VolumeDown");
  qword_255EB4130 = (uint64_t)CFSTR("LockingCapsLock");
  qword_255EB4138 = (uint64_t)CFSTR("LockingNumLock");
  qword_255EB4140 = (uint64_t)CFSTR("LockingScrollLock");
  qword_255EB4148 = (uint64_t)CFSTR("Keypad,");
  qword_255EB4150 = (uint64_t)CFSTR("Keypad=");
  qword_255EB4158 = (uint64_t)CFSTR("International1");
  qword_255EB4160 = (uint64_t)CFSTR("International2");
  qword_255EB4168 = (uint64_t)CFSTR("International3");
  qword_255EB4170 = (uint64_t)CFSTR("International4");
  qword_255EB4178 = (uint64_t)CFSTR("International5");
  qword_255EB4180 = (uint64_t)CFSTR("International6");
  qword_255EB4188 = (uint64_t)CFSTR("International7");
  qword_255EB4190 = (uint64_t)CFSTR("International8");
  qword_255EB4198 = (uint64_t)CFSTR("International9");
  qword_255EB41A0 = (uint64_t)CFSTR("LANG1");
  qword_255EB41A8 = (uint64_t)CFSTR("LANG2");
  qword_255EB41B0 = (uint64_t)CFSTR("LANG3");
  qword_255EB41B8 = (uint64_t)CFSTR("LANG4");
  qword_255EB41C0 = (uint64_t)CFSTR("LANG5");
  qword_255EB41C8 = (uint64_t)CFSTR("LANG6");
  qword_255EB41D0 = (uint64_t)CFSTR("LANG7");
  qword_255EB41D8 = (uint64_t)CFSTR("LANG8");
  qword_255EB41E0 = (uint64_t)CFSTR("LANG9");
  qword_255EB41E8 = (uint64_t)CFSTR("AlternateErase");
  qword_255EB41F0 = (uint64_t)CFSTR("SysReq_Attention");
  qword_255EB41F8 = (uint64_t)CFSTR("Cancel");
  qword_255EB4200 = (uint64_t)CFSTR("Clear");
  qword_255EB4208 = (uint64_t)CFSTR("Prior");
  qword_255EB4210 = (uint64_t)CFSTR("Return");
  qword_255EB4218 = (uint64_t)CFSTR("Separator");
  qword_255EB4220 = (uint64_t)CFSTR("Out");
  qword_255EB4228 = (uint64_t)CFSTR("Oper");
  qword_255EB4230 = (uint64_t)CFSTR("Clear_Again");
  qword_255EB4238 = (uint64_t)CFSTR("CrSel_Props");
  qword_255EB4240 = (uint64_t)CFSTR("ExSel");
  qword_255EB4418 = 0;
  result = 0.0;
  xmmword_255EB43F8 = 0u;
  unk_255EB4408 = 0u;
  xmmword_255EB43D8 = 0u;
  unk_255EB43E8 = 0u;
  xmmword_255EB43B8 = 0u;
  unk_255EB43C8 = 0u;
  xmmword_255EB4398 = 0u;
  unk_255EB43A8 = 0u;
  xmmword_255EB4378 = 0u;
  unk_255EB4388 = 0u;
  xmmword_255EB4358 = 0u;
  unk_255EB4368 = 0u;
  xmmword_255EB4338 = 0u;
  unk_255EB4348 = 0u;
  xmmword_255EB4318 = 0u;
  unk_255EB4328 = 0u;
  xmmword_255EB42F8 = 0u;
  unk_255EB4308 = 0u;
  xmmword_255EB42D8 = 0u;
  unk_255EB42E8 = 0u;
  xmmword_255EB42B8 = 0u;
  unk_255EB42C8 = 0u;
  xmmword_255EB4298 = 0u;
  unk_255EB42A8 = 0u;
  xmmword_255EB4278 = 0u;
  unk_255EB4288 = 0u;
  xmmword_255EB4258 = 0u;
  unk_255EB4268 = 0u;
  xmmword_255EB4248 = 0u;
  qword_255EB4420 = (uint64_t)CFSTR("LeftCtrl");
  qword_255EB4428 = (uint64_t)CFSTR("LeftShift");
  qword_255EB4430 = (uint64_t)CFSTR("LeftAlt");
  qword_255EB4438 = (uint64_t)CFSTR("LeftGUI");
  qword_255EB4440 = (uint64_t)CFSTR("RightCtrl");
  qword_255EB4448 = (uint64_t)CFSTR("RightShift");
  qword_255EB4450 = (uint64_t)CFSTR("RightAlt");
  qword_255EB4458 = (uint64_t)CFSTR("RightGUI");
  xmmword_255EB4460 = 0u;
  xmmword_255EB4470 = 0u;
  xmmword_255EB4480 = 0u;
  xmmword_255EB4490 = 0u;
  xmmword_255EB44A0 = 0u;
  xmmword_255EB44B0 = 0u;
  xmmword_255EB44C0 = 0u;
  xmmword_255EB44D0 = 0u;
  xmmword_255EB44E0 = 0u;
  xmmword_255EB44F0 = 0u;
  xmmword_255EB4500 = 0u;
  xmmword_255EB4510 = 0u;
  return result;
}

uint64_t MTAppendGestureStartedToCollectionEvent()
{
  IOHIDEventGetIntegerValue();
  IOHIDEventSetIntegerValue();
  return 0;
}

uint64_t MTAppendGestureEndedToCollectionEvent()
{
  IOHIDEventGetIntegerValue();
  IOHIDEventSetIntegerValue();
  return 0;
}

uint64_t MTAppendChordMotionCodeToCollectionEvent()
{
  IOHIDEventSetIntegerValue();
  return 0;
}

uint64_t MTAppendAbsoluteMouseEvent()
{
  return 0;
}

uint64_t MTAppendRelativeMouseEvent()
{
  uint64_t MouseEvent;
  const void *v1;

  mach_absolute_time();
  MouseEvent = IOHIDEventCreateMouseEvent();
  if (MouseEvent)
  {
    v1 = (const void *)MouseEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendMouseButtonEvent()
{
  uint64_t ButtonEvent;
  const void *v1;

  mach_absolute_time();
  ButtonEvent = IOHIDEventCreateButtonEvent();
  if (ButtonEvent)
  {
    v1 = (const void *)ButtonEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendVelocityEvent()
{
  uint64_t VelocityEvent;
  const void *v1;

  mach_absolute_time();
  VelocityEvent = IOHIDEventCreateVelocityEvent();
  if (VelocityEvent)
  {
    v1 = (const void *)VelocityEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendTranslationEvent(uint64_t a1, int a2)
{
  uint64_t TranslationEvent;
  const void *v4;

  mach_absolute_time();
  TranslationEvent = IOHIDEventCreateTranslationEvent();
  v4 = (const void *)TranslationEvent;
  if (a2 <= 15)
  {
    if (a2 != 2)
    {
      if (a2 == 8)
      {
        if (!TranslationEvent)
          return 0;
        goto LABEL_15;
      }
LABEL_10:
      if (!TranslationEvent)
        return 0;
      goto LABEL_15;
    }
    if (!TranslationEvent)
      return 0;
    goto LABEL_15;
  }
  if (a2 != 16)
  {
    if (a2 == 32)
    {
      if (!TranslationEvent)
        return 0;
      goto LABEL_15;
    }
    goto LABEL_10;
  }
  if (TranslationEvent)
  {
LABEL_15:
    IOHIDEventSetPhase();
    IOHIDEventAppendEvent();
    CFRelease(v4);
  }
  return 0;
}

uint64_t MTAppendFluidSwipeEvent(double a1, float a2, uint64_t a3, int a4)
{
  uint64_t FluidTouchGestureEvent;
  const void *v6;

  switch(a4)
  {
    case 27:
      mach_absolute_time();
      FluidTouchGestureEvent = IOHIDEventCreateFluidTouchGestureEvent();
      break;
    case 23:
      mach_absolute_time();
      FluidTouchGestureEvent = IOHIDEventCreateDockSwipeEvent();
      break;
    case 16:
      mach_absolute_time();
      FluidTouchGestureEvent = IOHIDEventCreateNavigationSwipeEvent();
      break;
    default:
      return 0;
  }
  v6 = (const void *)FluidTouchGestureEvent;
  if (FluidTouchGestureEvent)
  {
    IOHIDEventSetPhase();
    if (a2 != 0.0)
      MTAppendVelocityEvent();
    IOHIDEventAppendEvent();
    CFRelease(v6);
  }
  return 0;
}

uint64_t MTAppendSwipeEvent()
{
  uint64_t SwipeEvent;
  const void *v1;

  mach_absolute_time();
  SwipeEvent = IOHIDEventCreateSwipeEvent();
  if (SwipeEvent)
  {
    v1 = (const void *)SwipeEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendForceGestureEvent()
{
  uint64_t result;
  const void *v1;

  if (!IOHIDEventGetIntegerValue())
    return 3758097090;
  mach_absolute_time();
  result = IOHIDEventCreateForceEvent();
  if (result)
  {
    v1 = (const void *)result;
    IOHIDEventSetPhase();
    IOHIDEventAppendEvent();
    CFRelease(v1);
    return 0;
  }
  return result;
}

uint64_t MTAppendKeyboardEvent()
{
  uint64_t KeyboardEvent;
  const void *v1;

  mach_absolute_time();
  KeyboardEvent = IOHIDEventCreateKeyboardEvent();
  if (KeyboardEvent)
  {
    v1 = (const void *)KeyboardEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendKeystrokeEvent()
{
  MTAppendKeyboardEvent();
  MTAppendKeyboardEvent();
  return 0;
}

uint64_t MTAppendModifierKeyEvent(uint64_t a1, char a2)
{
  if ((a2 & 2) != 0)
  {
    MTAppendKeyboardEvent();
    if ((a2 & 1) == 0)
    {
LABEL_3:
      if ((a2 & 4) == 0)
        goto LABEL_4;
LABEL_9:
      MTAppendKeyboardEvent();
      if ((a2 & 8) == 0)
        return 0;
      goto LABEL_5;
    }
  }
  else if ((a2 & 1) == 0)
  {
    goto LABEL_3;
  }
  MTAppendKeyboardEvent();
  if ((a2 & 4) != 0)
    goto LABEL_9;
LABEL_4:
  if ((a2 & 8) != 0)
LABEL_5:
    MTAppendKeyboardEvent();
  return 0;
}

uint64_t MTAppendZoomToggleEvent()
{
  uint64_t ZoomToggleEvent;
  const void *v1;

  mach_absolute_time();
  ZoomToggleEvent = IOHIDEventCreateZoomToggleEvent();
  if (ZoomToggleEvent)
  {
    v1 = (const void *)ZoomToggleEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendShowDefinitionEvent()
{
  uint64_t SymbolicHotKeyEvent;
  const void *v1;

  mach_absolute_time();
  SymbolicHotKeyEvent = IOHIDEventCreateSymbolicHotKeyEvent();
  if (SymbolicHotKeyEvent)
  {
    v1 = (const void *)SymbolicHotKeyEvent;
    IOHIDEventSetPhase();
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendBoundaryScrollEvent()
{
  uint64_t BoundaryScrollEvent;
  const void *v1;

  mach_absolute_time();
  BoundaryScrollEvent = IOHIDEventCreateBoundaryScrollEvent();
  if (BoundaryScrollEvent)
  {
    v1 = (const void *)BoundaryScrollEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendScrollEvent()
{
  uint64_t ScrollEvent;
  const void *v1;

  mach_absolute_time();
  ScrollEvent = IOHIDEventCreateScrollEvent();
  if (ScrollEvent)
  {
    v1 = (const void *)ScrollEvent;
    IOHIDEventSetPhase();
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendMomentumEnableEvent()
{
  uint64_t VendorDefinedEvent;
  const void *v1;

  mach_absolute_time();
  VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
  if (VendorDefinedEvent)
  {
    v1 = (const void *)VendorDefinedEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendOrientationEvent()
{
  uint64_t PolarOrientationEvent;
  const void *v1;
  uint64_t v2;
  const void *v3;

  mach_absolute_time();
  PolarOrientationEvent = IOHIDEventCreatePolarOrientationEvent();
  if (PolarOrientationEvent)
  {
    v1 = (const void *)PolarOrientationEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  mach_absolute_time();
  v2 = IOHIDEventCreatePolarOrientationEvent();
  if (v2)
  {
    v3 = (const void *)v2;
    IOHIDEventSetPhase();
    IOHIDEventAppendEvent();
    CFRelease(v3);
  }
  return 0;
}

uint64_t MTAppendOrientationEventWithTranslation(uint64_t a1, int a2)
{
  uint64_t PolarOrientationEvent;
  const void *v4;
  uint64_t v5;
  const void *v6;

  mach_absolute_time();
  PolarOrientationEvent = IOHIDEventCreatePolarOrientationEvent();
  if (PolarOrientationEvent)
  {
    v4 = (const void *)PolarOrientationEvent;
    IOHIDEventAppendEvent();
    CFRelease(v4);
  }
  mach_absolute_time();
  v5 = IOHIDEventCreatePolarOrientationEvent();
  if (v5)
  {
    v6 = (const void *)v5;
    IOHIDEventSetPhase();
    MTAppendTranslationEvent((uint64_t)v6, a2);
    IOHIDEventAppendEvent();
    CFRelease(v6);
  }
  return 0;
}

uint64_t MTAppendZoomRotateTranslateEvent(double a1, double a2, float a3, uint64_t a4, int a5, int a6, int a7, int a8, int a9)
{
  _BOOL4 v9;
  int v10;
  int v11;
  int v12;
  uint64_t RotationEvent;
  const void *v14;
  uint64_t ScaleEvent;
  const void *v16;
  uint64_t TranslationEvent;
  const void *v18;

  if (a3 <= 0.0)
  {
    v9 = a5 == 16 || a5 == 32;
    goto LABEL_13;
  }
  v9 = a5 == 16 || a5 == 32;
  if ((float)((float)a7 / a3) == 0.0)
  {
LABEL_13:
    if (MTAppendZoomRotateTranslateEvent_rotate_in_progress)
      v10 = v9;
    else
      v10 = 0;
    if (!a6)
      goto LABEL_7;
    goto LABEL_17;
  }
  v10 = 1;
  if (!a6)
  {
LABEL_7:
    if (MTAppendZoomRotateTranslateEvent_zoom_in_progress)
      v11 = v9;
    else
      v11 = 0;
    goto LABEL_18;
  }
LABEL_17:
  v11 = 1;
LABEL_18:
  if (a9 | a8)
  {
    v12 = 1;
  }
  else if (MTAppendZoomRotateTranslateEvent_translate_in_progress)
  {
    v12 = v9;
  }
  else
  {
    v12 = 0;
  }
  if (v10)
  {
    mach_absolute_time();
    RotationEvent = IOHIDEventCreateRotationEvent();
    if (RotationEvent)
    {
      v14 = (const void *)RotationEvent;
      IOHIDEventSetPhase();
      IOHIDEventAppendEvent();
      CFRelease(v14);
      MTAppendZoomRotateTranslateEvent_rotate_in_progress = !v9;
    }
  }
  if (v11)
  {
    mach_absolute_time();
    ScaleEvent = IOHIDEventCreateScaleEvent();
    if (ScaleEvent)
    {
      v16 = (const void *)ScaleEvent;
      IOHIDEventSetPhase();
      IOHIDEventAppendEvent();
      CFRelease(v16);
      MTAppendZoomRotateTranslateEvent_zoom_in_progress = !v9;
    }
  }
  if (v12)
  {
    mach_absolute_time();
    TranslationEvent = IOHIDEventCreateTranslationEvent();
    if (TranslationEvent)
    {
      v18 = (const void *)TranslationEvent;
      IOHIDEventSetPhase();
      IOHIDEventAppendEvent();
      CFRelease(v18);
      MTAppendZoomRotateTranslateEvent_translate_in_progress = !v9;
    }
  }
  return 0;
}

float MTHIDGetFullScalePixelDistance()
{
  return 500.0;
}

uint64_t MTSimpleEmbeddedHIDManagerV2::createManager(uint64_t a1, const void *a2, int a3, int a4)
{
  uint64_t v8;

  v8 = operator new();
  *(_OWORD *)v8 = 0u;
  *(_OWORD *)(v8 + 16) = 0u;
  *(_OWORD *)(v8 + 32) = 0u;
  *(_OWORD *)(v8 + 48) = 0u;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 112) = 0u;
  *(_OWORD *)(v8 + 128) = 0u;
  *(_OWORD *)(v8 + 144) = 0u;
  *(_OWORD *)(v8 + 160) = 0u;
  *(_OWORD *)(v8 + 176) = 0u;
  *(_OWORD *)(v8 + 192) = 0u;
  *(_OWORD *)(v8 + 208) = 0u;
  *(_QWORD *)(v8 + 224) = 0;
  MTSimpleHIDManager::MTSimpleHIDManager((MTSimpleHIDManager *)v8);
  *(_QWORD *)v8 = &off_24FFF09A8;
  MTSimpleEmbeddedHIDManager::initialize((MTModeSwitcher *)v8, a1, a2, a3, a4);
  return v8;
}

void sub_231089CC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10A1C40E945ADD8);
  _Unwind_Resume(a1);
}

void MTSimpleEmbeddedHIDManagerV2::setDeviceDefaultProperties(MTSimpleEmbeddedHIDManagerV2 *this)
{
  io_registry_entry_t Service;
  CFTypeRef CFProperty;
  const void *v4;
  CFTypeID v5;

  (*(void (**)(MTSimpleEmbeddedHIDManagerV2 *))(*(_QWORD *)this + 80))(this);
  Service = MTDeviceGetService();
  if (Service)
  {
    CFProperty = IORegistryEntryCreateCFProperty(Service, CFSTR("PhysicalDeviceUniqueID"), (CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
    if (CFProperty)
    {
      v4 = CFProperty;
      v5 = CFGetTypeID(CFProperty);
      if (v5 == CFStringGetTypeID())
        (*(void (**)(MTSimpleEmbeddedHIDManagerV2 *, const __CFString *, const void *))(*(_QWORD *)this
                                                                                                 + 568))(this, CFSTR("PhysicalDeviceUniqueID"), v4);
      CFRelease(v4);
    }
  }
  MTSimpleHIDManager::setDeviceDefaultProperties(this);
}

uint64_t MTSimpleEmbeddedHIDManagerV2::setPowerState()
{
  return 0;
}

uint64_t MTSimpleEmbeddedHIDManagerV2::setInputDetectionModeForOrientation(MTSimpleEmbeddedHIDManagerV2 *this)
{
  return 0;
}

uint64_t MTSimpleEmbeddedHIDManagerV2::setTouchMode(MTSimpleEmbeddedHIDManagerV2 *this)
{
  return 0;
}

uint64_t MTSimpleEmbeddedHIDManagerV2::setOrientation(MTSimpleEmbeddedHIDManagerV2 *this)
{
  return 0;
}

const char *MTSimpleEmbeddedHIDManagerV2::getName(MTSimpleEmbeddedHIDManagerV2 *this)
{
  return "MTSimpleEmbeddedHIDManagerV2";
}

void MTSimpleEmbeddedHIDManagerV2::~MTSimpleEmbeddedHIDManagerV2(MTSimpleEmbeddedHIDManagerV2 *this)
{
  MTSimpleHIDManager::~MTSimpleHIDManager(this);
  JUMPOUT(0x2348D0034);
}

uint64_t MTSimpleEmbeddedHIDManagerV2::setPowerStateWithReset()
{
  return 0;
}

void MTActionEvent::MTActionEvent(MTActionEvent *this)
{
  *(_QWORD *)this = 0;
}

{
  *(_QWORD *)this = 0;
}

void MTActionEvent::MTActionEvent(MTActionEvent *this, __int16 a2, int a3, __int16 a4)
{
  *(_WORD *)this = a2;
  *((_WORD *)this + 1) = a4;
  *((_DWORD *)this + 1) = a3;
}

{
  *(_WORD *)this = a2;
  *((_WORD *)this + 1) = a4;
  *((_DWORD *)this + 1) = a3;
}

void MTActionEvent::MTActionEvent(MTActionEvent *this, const MTActionEvent *a2)
{
  *(_DWORD *)this = *(_DWORD *)a2;
  *((_DWORD *)this + 1) = *((_DWORD *)a2 + 1);
}

{
  *(_DWORD *)this = *(_DWORD *)a2;
  *((_DWORD *)this + 1) = *((_DWORD *)a2 + 1);
}

_DWORD *MTActionEvent::operator=(_DWORD *result, _DWORD *a2)
{
  if (result != a2)
  {
    *result = *a2;
    result[1] = a2[1];
  }
  return result;
}

uint64_t MTActionEvent::getModifierMaskFromKeyCode(MTActionEvent *this)
{
  if ((*((_WORD *)this + 1) & 0xFFF8) == 0xE0)
    return (1 << *((_WORD *)this + 1));
  else
    return 0;
}

uint64_t MTActionEvent::deriveGestureStartedType(MTActionEvent *this)
{
  if ((*(_WORD *)this & 0xFFFE) == 0x46)
    return 33;
  else
    return 0;
}

uint64_t MTActionEvent::deriveGestureEndedType(MTActionEvent *this)
{
  return 32 * ((*(_WORD *)this & 0xFFFE) == 70);
}

uint64_t MTActionEvent::deriveFluidIOHIDEventType(MTActionEvent *this)
{
  int v1;

  v1 = *(unsigned __int16 *)this;
  if ((v1 - 36) < 3)
    return dword_2310BD478[(__int16)(v1 - 36)];
  if (v1 == 39)
    return 27;
  return 0;
}

uint64_t MTActionEvent::deriveFlavorForFluidIOHIDEventType(MTActionEvent *this)
{
  int v1;
  unsigned int v2;
  char v3;

  v1 = *(unsigned __int16 *)this;
  v2 = v1 - 37;
  if (v1 == 36)
    v3 = 5;
  else
    v3 = 0;
  if (v2 < 3)
    v3 = 0x200010003uLL >> (16 * v2);
  return v3 & 7;
}

void MTDragManagerEventQueue::MTDragManagerEventQueue(MTDragManagerEventQueue *this)
{
  uint64_t v1;

  MTTapDragManager::MTTapDragManager(this);
  *(_QWORD *)v1 = off_24FFF0C48;
  *(_QWORD *)(v1 + 104) = 0;
  *(_DWORD *)(v1 + 112) = 0;
}

{
  uint64_t v1;

  MTTapDragManager::MTTapDragManager(this);
  *(_QWORD *)v1 = off_24FFF0C48;
  *(_QWORD *)(v1 + 104) = 0;
  *(_DWORD *)(v1 + 112) = 0;
}

uint64_t MTDragManagerEventQueue::dispatchModifierUpdates(uint64_t result, uint64_t a2, int a3, int a4, unsigned int a5, int a6)
{
  unsigned int v7;
  uint64_t v11;
  int v12;
  int v13;

  if (a5 <= 0xF)
  {
    v7 = a5;
    v11 = result;
    do
    {
      v12 = 1 << v7;
      if (((1 << v7) & a3) != 0)
      {
        if (a4)
          v13 = *(_DWORD *)(v11 + 108) & ~v12;
        else
          v13 = *(_DWORD *)(v11 + 108) | v12;
        *(_DWORD *)(v11 + 108) = v13;
        if (v7 > 7)
          result = MTAppendMouseButtonEvent();
        else
          result = MTAppendModifierKeyEvent(a2, v12);
      }
      v7 += a6;
    }
    while (v7 < 0x10);
  }
  return result;
}

uint64_t MTDragManagerEventQueue::autoInsertModifierEvents(uint64_t result, uint64_t a2, unsigned __int16 *a3, int a4)
{
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  int v9;
  _DWORD *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;

  v5 = result;
  if (!a3)
  {
    v10 = (_DWORD *)(result + 104);
    v8 = *(_DWORD *)(result + 112);
    if (!((unsigned __int16)v8 | *(_WORD *)(result + 104)))
      return result;
    v11 = 0;
    v12 = (v8 | *(_DWORD *)(result + 104)) & ~a4;
    goto LABEL_15;
  }
  v6 = *((_DWORD *)a3 + 1);
  v7 = *a3;
  if ((v7 - 129) <= 1)
  {
    v8 = 0;
    v9 = 1 << a3[1];
    if ((a3[1] & 0xFFF8) != 0xE0)
      v9 = 0;
    if (v7 != 130)
      goto LABEL_12;
LABEL_10:
    v13 = 0;
    v14 = *(_DWORD *)(result + 112);
    v15 = *(_DWORD *)(result + 108) & ~v9;
    *(_DWORD *)(result + 108) = v15;
    v8 = v14 & ~v9;
    v16 = ~v15;
    v12 = v6;
    goto LABEL_13;
  }
  v9 = 0;
  if (v7 == 66)
    goto LABEL_10;
  v8 = *((_DWORD *)a3 + 1);
LABEL_12:
  v17 = *(_DWORD *)(result + 112);
  v18 = *(_DWORD *)(result + 108) | v9;
  *(_DWORD *)(result + 108) = v18;
  v16 = ~v18;
  v13 = v6 & ~v18;
  v12 = v17 & ~(v9 | v6);
LABEL_13:
  v11 = v16 & a4 | v13;
  if (!v9)
  {
    v10 = (_DWORD *)(result + 104);
    v12 |= *(_DWORD *)(result + 104) & ~(v6 | a4);
LABEL_15:
    *v10 = a4;
  }
  *(_DWORD *)(result + 112) = v8 & ~v12;
  if ((_WORD)v12)
    result = MTDragManagerEventQueue::dispatchModifierUpdates(result, a2, v12, 1, 0xFu, -1);
  if ((_WORD)v11)
    return MTDragManagerEventQueue::dispatchModifierUpdates(v5, a2, v11, 0, 0, 1);
  return result;
}

uint64_t MTDragManagerEventQueue::dispatchFluid(uint64_t a1, unsigned __int16 *a2, uint64_t a3, float a4, float a5)
{
  MTForceManagement *v10;
  double v11;
  int v12;
  int v13;

  v10 = *(MTForceManagement **)(a1 + 16);
  if (!v10 || !MTForceManagement::whichForceButtonActivated(v10))
    MTDragManagerEventQueue::autoInsertModifierEvents(a1, a3, a2, 0);
  v12 = 27;
  v13 = 16;
  switch(*a2)
  {
    case '$':
      goto LABEL_7;
    case '%':
      v12 = 23;
      break;
    case '&':
    case '\'':
      break;
    default:
      v13 = 0;
LABEL_7:
      v12 = v13;
      break;
  }
  *(float *)&v11 = a4;
  return MTAppendFluidSwipeEvent(v11, a5, a3, v12);
}

uint64_t MTDragManagerEventQueue::dispatch(MTTapDragManager *a1, unsigned __int16 *a2, uint64_t a3, int a4, int *a5, float *a6)
{
  int v12;
  uint64_t result;
  double v14;
  double v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  float v23;
  uint64_t v24;
  int v25;
  unsigned __int16 v26;
  unsigned __int16 v27;
  int v28;

  v12 = MTTapDragManager::dragHandModifiers(a1);
  MTAppendChordMotionCodeToCollectionEvent();
  result = MTDragManagerEventQueue::autoInsertModifierEvents((uint64_t)a1, a3, a2, v12);
  v16 = *a2;
  if (v16 == 32)
    return MTAppendGestureEndedToCollectionEvent();
  if (v16 == 33)
    return MTAppendGestureStartedToCollectionEvent();
  if ((v16 - 35) <= 4)
  {
    v17 = 27;
    v18 = 16;
    switch(*a2)
    {
      case '$':
        goto LABEL_18;
      case '%':
        v17 = 23;
        break;
      case '&':
      case '\'':
        break;
      default:
        v18 = 0;
LABEL_18:
        v17 = v18;
        break;
    }
    LODWORD(v14) = 0;
    return MTAppendFluidSwipeEvent(v14, 0.0, a3, v17);
  }
  if ((v16 & 0x80) == 0)
  {
    if ((v16 & 0x40) == 0 || (v16 - 65) < 2)
      return result;
    switch(v16)
    {
      case 'I':
        return MTAppendZoomToggleEvent();
      case 'H':
        v27 = a2[1];
        v28 = *((_DWORD *)a1 + 27);
        v26 = 66;
        MTDragManagerEventQueue::autoInsertModifierEvents((uint64_t)a1, a3, &v26, v12);
        v26 = 65;
        MTDragManagerEventQueue::autoInsertModifierEvents((uint64_t)a1, a3, &v26, v12);
        v26 = 66;
        return MTDragManagerEventQueue::autoInsertModifierEvents((uint64_t)a1, a3, &v26, v12);
      case 'C':
        v27 = a2[1];
        v28 = *((_DWORD *)a1 + 27);
        v26 = 66;
        return MTDragManagerEventQueue::autoInsertModifierEvents((uint64_t)a1, a3, &v26, v12);
    }
    if ((~v16 & 0x44) != 0)
      return result;
    if (a5)
    {
      if (v16 != 70)
      {
        if (v16 == 78)
          return MTAppendBoundaryScrollEvent();
        if (v16 != 71)
          return MTAppendRelativeMouseEvent();
        v19 = a5[2];
        v20 = a5[3];
        v21 = *a5;
        v22 = a5[1];
        *(float *)&v14 = *a6;
        *(float *)&v15 = a6[1];
        v23 = a6[2];
        v24 = a3;
        v25 = a4;
        return MTAppendZoomRotateTranslateEvent(v14, v15, v23, v24, v25, v19, v20, v21, v22);
      }
    }
    else
    {
      if (!a4)
        return result;
      if (v16 == 71)
      {
        *(float *)&v14 = *a6;
        *(float *)&v15 = a6[1];
        v23 = a6[2];
        v24 = a3;
        v25 = a4;
        v19 = 0;
        v20 = 0;
        v21 = 0;
        v22 = 0;
        return MTAppendZoomRotateTranslateEvent(v14, v15, v23, v24, v25, v19, v20, v21, v22);
      }
      if (v16 != 70)
        return result;
    }
    return MTAppendScrollEvent();
  }
  switch(*a2)
  {
    case 0x81u:
    case 0x82u:
      result = MTAppendKeyboardEvent();
      break;
    case 0x85u:
      result = MTAppendSwipeEvent();
      break;
    case 0x86u:
      return result;
    case 0x8Cu:
      result = MTAppendShowDefinitionEvent();
      break;
    default:
      result = MTAppendKeystrokeEvent();
      break;
  }
  return result;
}

uint64_t MTGesture::dispatchEvents(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  uint64_t v9;
  uint64_t result;
  unsigned int v20;

  v9 = *a1;
  if (a1[1] == *a1)
    return 0;
  result = 0;
  v20 = 0;
  do
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, double))(*(_QWORD *)a2 + 24))(a2, v9 + 8 * result, a3, a4, a5, a6, a7, a8, a9);
    v9 = *a1;
    result = ++v20;
  }
  while (v20 < (unint64_t)((a1[1] - *a1) >> 3));
  return result;
}

uint64_t MTDragManagerEventQueue::enableAutoReleaseOfMultiFingerDrag(uint64_t this)
{
  if ((*(_BYTE *)(this + 109) & 1) != 0)
    *(_DWORD *)(this + 104) |= 0x100u;
  return this;
}

uint64_t MTDragManagerEventQueue::forceButtonChange(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t result;
  uint64_t v6;

  v4 = MTTapDragManager::dragHandModifiers((MTTapDragManager *)a1);
  v6 = 0;
  MTDragManagerEventQueue::autoInsertModifierEvents(a1, a2, (unsigned __int16 *)&v6, v4);
  result = (**(uint64_t (***)(uint64_t))a1)(a1);
  if ((_DWORD)result)
  {
    if (*(int *)(a1 + 24) >= 2)
      *(_BYTE *)(a1 + 9) = 1;
  }
  return result;
}

uint64_t MTDragManagerEventQueue::ready2autoReleaseModifiers(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 112) | *(_DWORD *)(a1 + 104))
    return (*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, a3) ^ 1;
  else
    return 0;
}

uint64_t MTDragManagerEventQueue::serviceEventQueue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5)
{
  if (*(_DWORD *)(a1 + 24) == 1)
    return MTTapDragManager::sendWaitingClickAtHalfTimeout(a1, a2, a4, a5) ^ 1;
  if (*(_DWORD *)(a1 + 108)
    && *(_DWORD *)(a1 + 112) | *(_DWORD *)(a1 + 104)
    && ((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 16))(a3, a4) & 1) == 0)
  {
    MTDragManagerEventQueue::autoInsertModifierEvents(a1, a2, 0, 0);
    if (((**(uint64_t (***)(uint64_t))a1)(a1) & 1) == 0)
      MTTapDragManager::clearCycle(a1);
  }
  return *(_DWORD *)(a1 + 108) != 0;
}

uint64_t MTDragManagerEventQueue::startMomentum(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)(a1 + 1268) = a3;
  *(_BYTE *)(a1 + 1264) = 1;
  return MTAppendMomentumEnableEvent();
}

uint64_t MTDragManagerEventQueue::stopMomentum(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)(a1 + 1268) = a3;
  *(_BYTE *)(a1 + 1264) = 0;
  return MTAppendMomentumEnableEvent();
}

uint64_t MTDragManagerEventQueue::isButton1Pending(MTDragManagerEventQueue *this)
{
  return *((_BYTE *)this + 109) & 1;
}

uint64_t MTDragManagerEventQueue::getLastModifiersFromHand(MTDragManagerEventQueue *this)
{
  return *((unsigned int *)this + 26);
}

uint64_t MTTrackpadEmbeddedHIDManager::createManager(uint64_t a1, const void *a2, int a3, int a4)
{
  uint64_t v8;

  v8 = operator new();
  *(_OWORD *)v8 = 0u;
  *(_OWORD *)(v8 + 16) = 0u;
  *(_OWORD *)(v8 + 32) = 0u;
  *(_OWORD *)(v8 + 48) = 0u;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 112) = 0u;
  *(_OWORD *)(v8 + 128) = 0u;
  *(_OWORD *)(v8 + 144) = 0u;
  *(_OWORD *)(v8 + 160) = 0u;
  *(_OWORD *)(v8 + 176) = 0u;
  *(_OWORD *)(v8 + 192) = 0u;
  *(_OWORD *)(v8 + 208) = 0u;
  *(_OWORD *)(v8 + 224) = 0u;
  *(_OWORD *)(v8 + 240) = 0u;
  *(_OWORD *)(v8 + 256) = 0u;
  *(_OWORD *)(v8 + 272) = 0u;
  *(_OWORD *)(v8 + 288) = 0u;
  *(_OWORD *)(v8 + 304) = 0u;
  *(_OWORD *)(v8 + 320) = 0u;
  *(_OWORD *)(v8 + 336) = 0u;
  *(_OWORD *)(v8 + 352) = 0u;
  MTSimpleHIDManager::MTSimpleHIDManager((MTSimpleHIDManager *)v8);
  *(_QWORD *)v8 = &off_24FFF0D08;
  *(_BYTE *)(v8 + 354) = 0;
  *(_WORD *)(v8 + 352) = 0;
  *(_DWORD *)(v8 + 356) = 0;
  MTTrackpadHIDManager::initialize((MTModeSwitcher *)v8, a1, a2, a3, a4);
  return v8;
}

void sub_23108AA14(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10A1C40397AE834);
  _Unwind_Resume(a1);
}

uint64_t MTTrackpadEmbeddedHIDManager::initialize(MTModeSwitcher *a1, uint64_t a2, CFTypeRef cf, int a4, int a5)
{
  *((_BYTE *)a1 + 354) = 0;
  *((_WORD *)a1 + 176) = 0;
  *((_DWORD *)a1 + 89) = 0;
  return MTTrackpadHIDManager::initialize(a1, a2, cf, a4, a5);
}

void MTTrackpadEmbeddedHIDManager::finalize(MTTrackpadEmbeddedHIDManager *this)
{
  unsigned int *v2;

  v2 = (unsigned int *)*((_QWORD *)this + 45);
  if (v2)
  {
    MTPowerLogger::release(v2);
    *((_QWORD *)this + 45) = 0;
  }
  MTTrackpadHIDManager::finalize(this);
}

unsigned int *MTTrackpadEmbeddedHIDManager::createEventDispatcher(MTTrackpadEmbeddedHIDManager *this)
{
  const void *v2;
  unsigned int *Dispatcher;

  v2 = (const void *)(*(uint64_t (**)(MTTrackpadEmbeddedHIDManager *))(*(_QWORD *)this + 80))(this);
  Dispatcher = (unsigned int *)MTTrackpadEmbeddedEventDispatcher::createDispatcher(this, v2);
  (*(void (**)(MTTrackpadEmbeddedHIDManager *, unsigned int *))(*(_QWORD *)this + 128))(this, Dispatcher);
  return MTSimpleEventDispatcher::release(Dispatcher);
}

const void *MTTrackpadEmbeddedHIDManager::setDeviceAccelerationData(MTTrackpadEmbeddedHIDManager *this, CFDictionaryRef theDict)
{
  const void *Value;

  Value = CFDictionaryGetValue(theDict, CFSTR("HIDPointerAccelerationMultiplier"));
  if (Value)
    (*(void (**)(MTTrackpadEmbeddedHIDManager *, const __CFString *, const void *))(*(_QWORD *)this + 568))(this, CFSTR("HIDPointerAccelerationMultiplier"), Value);
  return MTTrackpadHIDManager::setDeviceAccelerationData(this, theDict);
}

void MTTrackpadEmbeddedHIDManager::setPluginDefaultProperties(MTTrackpadEmbeddedHIDManager *this)
{
  io_registry_entry_t Service;
  CFTypeRef CFProperty;
  const void *v4;
  CFTypeID v5;
  MTPowerLogger *v6;

  MTTrackpadHIDManager::setPluginDefaultProperties(this);
  if ((*(uint64_t (**)(MTTrackpadEmbeddedHIDManager *))(*(_QWORD *)this + 80))(this))
  {
    Service = MTDeviceGetService();
    if (Service)
    {
      CFProperty = IORegistryEntryCreateCFProperty(Service, CFSTR("NeedsHostState"), (CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
      if (CFProperty)
      {
        v4 = CFProperty;
        v5 = CFGetTypeID(CFProperty);
        if (v5 == CFBooleanGetTypeID())
        {
          (*(void (**)(MTTrackpadEmbeddedHIDManager *, const __CFString *, const void *))(*(_QWORD *)this + 568))(this, CFSTR("NeedsHostState"), v4);
          if (v4 == (const void *)*MEMORY[0x24BDBD270])
          {
            v6 = (MTPowerLogger *)operator new();
            MTPowerLogger::MTPowerLogger(v6, "TrackpadEmbedded");
            *((_QWORD *)this + 45) = v6;
          }
        }
        CFRelease(v4);
      }
    }
  }
}

void sub_23108AC0C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10E1C4071CB0F12);
  _Unwind_Resume(a1);
}

uint64_t MTTrackpadEmbeddedHIDManager::getUserPrefs(uint64_t a1, _QWORD *a2)
{
  *a2 = &MTTrackpadEmbeddedHIDManager::getUserPrefs(mt_UserPreference const**)::prefs;
  return 6;
}

uint64_t MTTrackpadEmbeddedHIDManager::setDeviceDefaultProperties(MTTrackpadEmbeddedHIDManager *this)
{
  if ((*((_BYTE *)this + 160) & 0x20) != 0)
    (*(void (**)(MTTrackpadEmbeddedHIDManager *))(*(_QWORD *)this + 352))(this);
  *((_BYTE *)this + 126) = 1;
  return (*(uint64_t (**)(MTTrackpadEmbeddedHIDManager *))(*(_QWORD *)this + 744))(this);
}

CFNumberRef MTTrackpadEmbeddedHIDManager::copyProperty(CFDictionaryRef *this, const __CFString *a2)
{
  const __CFString *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  const void *Value;
  const void *v8;
  uint64_t v10;

  v3 = MTTrackpadEmbeddedHIDManager::renameUserFacingKeys((MTTrackpadEmbeddedHIDManager *)this, a2);
  v10 = 0;
  v4 = (*((uint64_t (**)(CFDictionaryRef *, uint64_t *))*this + 105))(this, &v10);
  if (!v4)
    return MTTrackpadHIDManager::copyProperty((MTTrackpadHIDManager *)this, v3);
  v5 = v4;
  for (i = 0; ; i += 16)
  {
    if (CFStringCompare(v3, *(CFStringRef *)(v10 + i), 0) == kCFCompareEqualTo)
    {
      Value = CFDictionaryGetValue(this[43], v3);
      if (Value)
        break;
    }
    if (!--v5)
      return MTTrackpadHIDManager::copyProperty((MTTrackpadHIDManager *)this, v3);
  }
  v8 = Value;
  CFRetain(Value);
  return (CFNumberRef)v8;
}

const __CFString *MTTrackpadEmbeddedHIDManager::renameUserFacingKeys(MTTrackpadEmbeddedHIDManager *this, CFStringRef theString1)
{
  if (CFStringCompare(theString1, CFSTR("TapToClickEnabled"), 0) == kCFCompareEqualTo)
    return CFSTR("Clicking");
  if (CFStringCompare(theString1, CFSTR("TwoFingersSecondaryClickEnabled"), 0) == kCFCompareEqualTo)
    return CFSTR("TrackpadRightClick");
  if (CFStringCompare(theString1, CFSTR("DoubleTapToDragEnabled"), 0) == kCFCompareEqualTo)
    return CFSTR("Dragging");
  if (CFStringCompare(theString1, CFSTR("DragLockEnabled"), 0) == kCFCompareEqualTo)
    return CFSTR("DragLock");
  if (CFStringCompare(theString1, CFSTR("PrimaryTrackpadCanBeDisabled"), 0))
    return theString1;
  return CFSTR("USBMouseStopsTrackpad");
}

uint64_t MTTrackpadEmbeddedHIDManager::setProperty(MTTrackpadEmbeddedHIDManager *this, const __CFString *a2, const void *a3)
{
  const __CFString *v5;

  v5 = MTTrackpadEmbeddedHIDManager::renameUserFacingKeys(this, a2);
  return MTTrackpadHIDManager::setProperty((CFTypeRef *)this, v5, a3);
}

uint64_t MTTrackpadEmbeddedHIDManager::setPropertyInternal(uint64_t a1, int a2, CFTypeRef cf, int a4)
{
  CFTypeID v8;
  NSObject *v9;
  uint64_t result;
  CFTypeID v11;
  CFTypeID v12;
  io_registry_entry_t Service;
  CFTypeID v14;
  int v15;
  const void *Value;
  const void *v17;
  CFTypeID v18;
  BOOL v19;
  int v20;
  const void *v21;
  const void *v22;
  CFTypeID v23;
  BOOL v24;
  int v25;
  const __CFNumber *v26;
  const __CFNumber *v27;
  CFTypeID v28;
  int v29;
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  const char *v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  if (a2 > 78)
  {
    switch(a2)
    {
      case 'O':
        if (!cf)
          return 0;
        v8 = CFGetTypeID(cf);
        if (v8 != CFBooleanGetTypeID())
          goto LABEL_21;
        return 1;
      case 'P':
        if (!cf)
          return 0;
LABEL_21:
        v14 = CFGetTypeID(cf);
        if (v14 != CFDictionaryGetTypeID())
          return 0;
        v15 = *(unsigned __int8 *)(a1 + 353);
        Value = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("DigitizerSurfaceCovered"));
        v19 = Value
           && (v17 = Value, v18 = CFGetTypeID(Value), v18 == CFBooleanGetTypeID())
           && v17 == (const void *)*MEMORY[0x24BDBD270];
        *(_BYTE *)(a1 + 353) = v19;
        v20 = *(unsigned __int8 *)(a1 + 354);
        v21 = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("ScreenOn"));
        v24 = !v21
           || (v22 = v21, v23 = CFGetTypeID(v21), v23 != CFBooleanGetTypeID())
           || v22 != (const void *)*MEMORY[0x24BDBD270];
        *(_BYTE *)(a1 + 354) = v24;
        v25 = *(_DWORD *)(a1 + 356);
        LOWORD(v29) = 0;
        v26 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("DeviceOrientation"));
        if (v26)
        {
          v27 = v26;
          v28 = CFGetTypeID(v26);
          if (v28 == CFNumberGetTypeID())
          {
            if (CFNumberGetValue(v27, kCFNumberSInt16Type, &v29))
              *(_DWORD *)(a1 + 356) = (unsigned __int16)v29;
          }
        }
        if (v15 == *(unsigned __int8 *)(a1 + 353)
          && v20 == *(unsigned __int8 *)(a1 + 354)
          && v25 == *(_DWORD *)(a1 + 356)
          && (a4 & 1) == 0
          && *(_BYTE *)(a1 + 352))
        {
          return 1;
        }
        if (MTTrackpadEmbeddedHIDManager::setHostState((MTTrackpadEmbeddedHIDManager *)a1))
        {
          result = 0;
          *(_BYTE *)(a1 + 353) = v15;
          *(_BYTE *)(a1 + 354) = v20;
          *(_DWORD *)(a1 + 356) = v25;
        }
        else
        {
          result = 1;
          *(_BYTE *)(a1 + 352) = 1;
        }
        return result;
      case 'Q':
        if (!cf)
          return MTTrackpadHIDManager::setPropertyInternal((MTSimpleHIDManager *)a1, a2, cf, a4);
        v11 = CFGetTypeID(cf);
        if (v11 == CFNumberGetTypeID())
          return 1;
        goto LABEL_15;
      case 'R':
        if (!cf)
          return MTTrackpadHIDManager::setPropertyInternal((MTSimpleHIDManager *)a1, a2, cf, a4);
LABEL_15:
        v12 = CFGetTypeID(cf);
        if (v12 == CFBooleanGetTypeID())
        {
          (*(void (**)(uint64_t))(*(_QWORD *)a1 + 80))(a1);
          Service = MTDeviceGetService();
          IORegistryEntrySetCFProperty(Service, CFSTR("DeviceOpenedByEventSystem"), cf);
        }
        return MTTrackpadHIDManager::setPropertyInternal((MTSimpleHIDManager *)a1, a2, cf, a4);
      default:
        return MTTrackpadHIDManager::setPropertyInternal((MTSimpleHIDManager *)a1, a2, cf, a4);
    }
  }
  if (a2 == 9)
  {
    v9 = MTLoggingPlugin();
    result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    goto LABEL_26;
  }
  if (a2 == 18)
  {
    v9 = MTLoggingPlugin();
    result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    goto LABEL_26;
  }
  if (a2 != 43)
    return MTTrackpadHIDManager::setPropertyInternal((MTSimpleHIDManager *)a1, a2, cf, a4);
  v9 = MTLoggingPlugin();
  result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
  if ((_DWORD)result)
  {
LABEL_26:
    v29 = 136315650;
    v30 = "[Error] ";
    v31 = 2080;
    v32 = "MTTrackpadEmbeddedHIDManager::";
    v33 = 2080;
    v34 = "setPropertyInternal";
    _os_log_impl(&dword_231071000, v9, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unsupported", (uint8_t *)&v29, 0x20u);
    return 0;
  }
  return result;
}

uint64_t MTTrackpadEmbeddedHIDManager::setHostState(MTTrackpadEmbeddedHIDManager *this)
{
  int v2;
  int v3;
  int v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  MTPowerLogger *v8;
  int v9;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v2 = *((unsigned __int8 *)this + 353);
  v3 = *((unsigned __int8 *)this + 354);
  v4 = *((_DWORD *)this + 89);
  v5 = MTLoggingPlugin();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136316674;
    v12 = "";
    v13 = 2080;
    v14 = "MTTrackpadEmbeddedHIDManager::";
    v15 = 2080;
    v16 = "setHostState";
    v17 = 1024;
    v18 = 0;
    v19 = 1024;
    v20 = v2;
    v21 = 1024;
    v22 = v3;
    v23 = 1024;
    v24 = v4;
    _os_log_impl(&dword_231071000, v5, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Host state - graphics orientation: %u, cover closed: %u, display off: %u, device orientation: %u", buf, 0x38u);
  }
  (*(void (**)(MTTrackpadEmbeddedHIDManager *))(*(_QWORD *)this + 80))(this);
  v6 = MTDeviceSetReport();
  if ((_DWORD)v6)
  {
    v7 = MTLoggingPlugin();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v12 = "[Error] ";
      v13 = 2080;
      v14 = "MTTrackpadEmbeddedHIDManager::";
      v15 = 2080;
      v16 = "setHostState";
      v17 = 1024;
      v18 = v6;
      _os_log_impl(&dword_231071000, v7, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Error 0x%08X setting host state", buf, 0x26u);
    }
  }
  else
  {
    v8 = (MTPowerLogger *)*((_QWORD *)this + 45);
    if (v8)
    {
      if (*((_BYTE *)this + 353))
      {
        v9 = 3;
      }
      else if (*((_BYTE *)this + 354))
      {
        v9 = 2;
      }
      else
      {
        v9 = 1;
      }
      MTPowerLogger::transitionTo(v8, v9);
    }
  }
  return v6;
}

uint64_t MTTrackpadEmbeddedHIDManager::setOrientation(MTTrackpadEmbeddedHIDManager *this)
{
  NSObject *v1;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v1 = MTLoggingPlugin();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315650;
    v4 = "[Error] ";
    v5 = 2080;
    v6 = "MTTrackpadEmbeddedHIDManager::";
    v7 = 2080;
    v8 = "setOrientation";
    _os_log_impl(&dword_231071000, v1, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unsupported", (uint8_t *)&v3, 0x20u);
  }
  return 3758097095;
}

uint64_t MTTrackpadEmbeddedHIDManager::setPowerState()
{
  NSObject *v0;
  int v2;
  const char *v3;
  __int16 v4;
  const char *v5;
  __int16 v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v0 = MTLoggingPlugin();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
  {
    v2 = 136315650;
    v3 = "[Error] ";
    v4 = 2080;
    v5 = "MTTrackpadEmbeddedHIDManager::";
    v6 = 2080;
    v7 = "setPowerState";
    _os_log_impl(&dword_231071000, v0, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unsupported", (uint8_t *)&v2, 0x20u);
  }
  return 3758097095;
}

uint64_t MTTrackpadEmbeddedHIDManager::setPowerStateWithReset()
{
  NSObject *v0;
  int v2;
  const char *v3;
  __int16 v4;
  const char *v5;
  __int16 v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v0 = MTLoggingPlugin();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
  {
    v2 = 136315650;
    v3 = "[Error] ";
    v4 = 2080;
    v5 = "MTTrackpadEmbeddedHIDManager::";
    v6 = 2080;
    v7 = "setPowerStateWithReset";
    _os_log_impl(&dword_231071000, v0, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unsupported", (uint8_t *)&v2, 0x20u);
  }
  return 3758097095;
}

void MTTrackpadEmbeddedHIDManager::wasScheduledOnDispatchQueue(MTTrackpadEmbeddedHIDManager *this, NSObject *a2)
{
  MTPowerLogger *v4;

  v4 = (MTPowerLogger *)*((_QWORD *)this + 45);
  if (v4)
    MTPowerLogger::scheduleOnDispatchQueue(v4, a2);
  MTTrackpadHIDManager::wasScheduledOnDispatchQueue((MTInputDeviceManagement **)this, a2);
}

void MTTrackpadEmbeddedHIDManager::wasUnscheduledFromDispatchQueue(io_object_t *this, dispatch_queue_s *a2)
{
  dispatch_object_t *v4;

  MTTrackpadHIDManager::wasUnscheduledFromDispatchQueue(this, a2);
  v4 = (dispatch_object_t *)*((_QWORD *)this + 45);
  if (v4)
    MTPowerLogger::unscheduleFromDispatchQueue(v4, a2);
}

uint64_t MTTrackpadEmbeddedHIDManager::handleContactFrame(MTTrackpadHIDManager *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6)
{
  MTPowerLogger *v12;

  v12 = (MTPowerLogger *)*((_QWORD *)this + 45);
  if (v12 && !*((_BYTE *)this + 354))
  {
    if ((_DWORD)a4)
      MTPowerLogger::transitionTo(v12, 0);
    else
      MTPowerLogger::transitionToDelayed((uint64_t)v12, 1, 0x77359400uLL);
  }
  return MTTrackpadHIDManager::handleContactFrame(this, a6, a2, a3, a4, a5);
}

void MTTrackpadEmbeddedHIDManager::~MTTrackpadEmbeddedHIDManager(MTTrackpadEmbeddedHIDManager *this)
{
  MTSimpleHIDManager::~MTSimpleHIDManager(this);
  JUMPOUT(0x2348D0034);
}

void MTSlideGesture::MTSlideGesture(MTSlideGesture *this)
{
  *((_QWORD *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 10) = 1065353216;
  *(_QWORD *)((char *)this + 44) = 0;
  *(_QWORD *)((char *)this + 60) = 0;
  *(_QWORD *)((char *)this + 52) = 0;
  *((_BYTE *)this + 68) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_DWORD *)this + 34) = 0;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 19) = 0;
}

{
  *((_QWORD *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 10) = 1065353216;
  *(_QWORD *)((char *)this + 44) = 0;
  *(_QWORD *)((char *)this + 60) = 0;
  *(_QWORD *)((char *)this + 52) = 0;
  *((_BYTE *)this + 68) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_DWORD *)this + 34) = 0;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 19) = 0;
}

double MTSlideGesture::clearIntegrationState(MTSlideGesture *this)
{
  double result;

  *((_BYTE *)this + 68) = 0;
  *((_QWORD *)this + 18) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_DWORD *)this + 30) = 0;
  return result;
}

uint64_t MTSlideGesture::MTSlideGesture(uint64_t a1, int a2, int a3, __int128 *a4, uint64_t *a5, float a6, float a7)
{
  __int128 v13;
  int v14;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  std::vector<MTActionEvent>::__init_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>((_QWORD *)a1, *a5, a5[1], (a5[1] - *a5) >> 3);
  *(_DWORD *)(a1 + 24) = 16;
  *(_DWORD *)(a1 + 28) = a3;
  *(_DWORD *)(a1 + 32) = a2;
  v13 = *a4;
  *(_OWORD *)(a1 + 52) = a4[1];
  *(_OWORD *)(a1 + 36) = v13;
  *(float *)(a1 + 152) = a6;
  *(float *)(a1 + 156) = a7;
  *(_BYTE *)(a1 + 68) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  if ((a2 & 0x1000000) != 0)
    v14 = -1;
  else
    v14 = 1;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_DWORD *)(a1 + 136) = 0;
  if ((a2 & 3) != 0 || a7 > 0.0)
    *(float *)(a1 + 124) = (float)v14;
  if ((a2 & 0xC) != 0 || a7 > 0.0)
    *(float *)(a1 + 128) = (float)v14;
  if ((a2 & 0x30) != 0)
    *(float *)(a1 + 132) = (float)v14;
  if ((a2 & 0xC0) != 0)
    *(float *)(a1 + 136) = (float)v14;
  return a1;
}

{
  return MTSlideGesture::MTSlideGesture(a1, a2, a3, a4, a5, a6, a7);
}

void MTSlideGesture::MTSlideGesture(MTSlideGesture *this, const MTSlideGesture *a2)
{
  __int128 v4;
  uint64_t i;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  std::vector<MTActionEvent>::__init_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>(this, *(_QWORD *)a2, *((_QWORD *)a2 + 1), (uint64_t)(*((_QWORD *)a2 + 1) - *(_QWORD *)a2) >> 3);
  *((_DWORD *)this + 6) = *((_DWORD *)a2 + 6);
  *((_DWORD *)this + 7) = *((_DWORD *)a2 + 7);
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  v4 = *(_OWORD *)((char *)a2 + 36);
  *(_OWORD *)((char *)this + 52) = *(_OWORD *)((char *)a2 + 52);
  *(_OWORD *)((char *)this + 36) = v4;
  *((_QWORD *)this + 19) = *((_QWORD *)a2 + 19);
  if (this != a2)
    std::vector<MTActionEvent>::__assign_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>(this, *(_DWORD **)a2, *((_DWORD **)a2 + 1), (uint64_t)(*((_QWORD *)a2 + 1) - *(_QWORD *)a2) >> 3);
  *((_BYTE *)this + 68) = 0;
  *((_QWORD *)this + 18) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_DWORD *)this + 30) = 0;
  for (i = 124; i != 140; i += 4)
    *(_DWORD *)((char *)this + i) = *(_DWORD *)((char *)a2 + i);
}

void sub_23108BA48(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MTSlideGesture::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;

  if (a1 != a2)
  {
    MTGesture::operator=(a1, a2);
    v4 = 0;
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
    v5 = *(_OWORD *)(a2 + 36);
    *(_OWORD *)(a1 + 52) = *(_OWORD *)(a2 + 52);
    *(_OWORD *)(a1 + 36) = v5;
    *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
    *(_BYTE *)(a1 + 68) = 0;
    *(_QWORD *)(a1 + 144) = 0;
    *(_OWORD *)(a1 + 72) = 0u;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_DWORD *)(a1 + 120) = 0;
    do
    {
      *(_DWORD *)(a1 + 124 + v4) = *(_DWORD *)(a2 + 124 + v4);
      v4 += 4;
    }
    while (v4 != 16);
  }
  return a1;
}

uint64_t MTGesture::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    std::vector<MTActionEvent>::__assign_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>((_QWORD *)a1, *(_DWORD **)a2, *(_DWORD **)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  }
  return a1;
}

uint64_t MTSlideGesture::getDegreesOfFreedomMask(uint64_t this)
{
  uint64_t v1;
  unint64_t v2;
  float v3;
  int v4;

  v1 = this;
  v2 = 0;
  LODWORD(this) = 0;
  do
  {
    v3 = *(float *)(v1 + 4 * v2 + 124);
    if (v3 == 0.0)
    {
      if (*(_QWORD *)v1 == *(_QWORD *)(v1 + 8)
        || **(_WORD **)v1 != 71
        || v2 > 1
        || (v3 = 1.0, *(double *)(v1 + 144) <= 0.0))
      {
        v3 = 0.0;
      }
    }
    v4 = 1 << v2;
    if (v3 == 0.0)
      v4 = 0;
    this = v4 | this;
    ++v2;
  }
  while (v2 != 4);
  return this;
}

float MTSlideGesture::relativeSensitivity(MTSlideGesture *this, unsigned int a2)
{
  float result;

  result = *((float *)this + (int)a2 + 31);
  if (result == 0.0)
  {
    if (*(_QWORD *)this == *((_QWORD *)this + 1))
      return 0.0;
    if (**(_WORD **)this != 71)
      return 0.0;
    if (a2 > 1)
      return 0.0;
    result = 1.0;
    if (*((double *)this + 18) <= 0.0)
      return 0.0;
  }
  return result;
}

uint64_t MTSlideGesture::sendSlideKeys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, double a8)
{
  int v14;
  double v15;
  int v16;
  BOOL v17;
  int v18;
  const MTActionEvent *v19;
  uint64_t result;
  unint64_t v21;
  __int128 v22;

  v14 = *(unsigned __int8 *)(a6 + 264);
  v22 = *(_OWORD *)(a3 + 168);
  MTChordIntegrating::sendSlidePreamble(a6, a2, a3, a4, a5, a1, 8u, a8);
  v15 = *(double *)(a2 + 8);
  *(double *)(a1 + 144) = v15;
  v16 = *(_DWORD *)(a1 + 32);
  if ((v16 & 0x23000) != 0)
  {
    if ((v16 & 0x20000) != 0)
    {
      v18 = *(_DWORD *)(a6 + 280);
      if (v18 < 0)
      {
        v19 = *(const MTActionEvent **)a1;
        if (*(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && *(_WORD *)v19 == 129)
        {
          v21 = 0xAAAAAAAAAAAAAAAALL;
          MTActionEvent::MTActionEvent((MTActionEvent *)&v21, v19);
          LOWORD(v21) = 130;
          *(_DWORD *)(a6 + 280) = -*(_DWORD *)(a6 + 280);
          (*(void (**)(uint64_t, unint64_t *, uint64_t, _QWORD, _QWORD, __int128 *, _QWORD, _QWORD, double))(*(_QWORD *)a4 + 24))(a4, &v21, a5, 0, 0, &v22, *(unsigned __int8 *)(a1 + 32), *(unsigned int *)(a6 + 224), *(double *)(a2 + 8));
          return 1;
        }
        *(_BYTE *)(a6 + 267) = 1;
      }
      *(_DWORD *)(a6 + 280) = -v18;
      goto LABEL_21;
    }
    if ((v16 & 0x2000) != 0)
    {
      if (*(_DWORD *)(a6 + 284) != v16)
        goto LABEL_21;
      return 0;
    }
  }
  else
  {
    if (v14)
      v17 = 1;
    else
      v17 = (*(_DWORD *)(a1 + 32) & 0x4000) == 0;
    if (v17 || v15 - *(double *)(a6 + 240) >= *(double *)&qword_255EB3C70)
    {
      *(_DWORD *)(a6 + 284) = *(_DWORD *)(a1 + 32);
      if (a7 >= 1)
      {
        a7 = (unsigned __int16)a7;
        goto LABEL_22;
      }
      return 0;
    }
  }
  *(_BYTE *)(a6 + 267) = 1;
LABEL_21:
  *(_DWORD *)(a6 + 284) = v16;
  a7 = 1;
  do
  {
LABEL_22:
    result = MTGesture::dispatchEvents((uint64_t *)a1, a4, a5, 0, 0, (uint64_t)&v22, *(unsigned __int8 *)(a1 + 32), *(unsigned int *)(a6 + 224), *(double *)(a2 + 8));
    --a7;
  }
  while (a7);
  return result;
}

uint64_t MTSlideGesture::sendSlideMickeys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int32x4_t *a7, double a8)
{
  uint64_t v15;
  double v16;
  __int128 v18;

  if (MTChordIntegrating::sendSlidePreamble(a6, a2, a3, a4, a5, a1, 8u, a8))
    v15 = 2;
  else
    v15 = 8;
  v18 = *(_OWORD *)(a3 + 168);
  MTChordIntegrating::updateMomentumMickeys(a6, a7, (double *)a2);
  v16 = *(double *)(a2 + 8);
  *(double *)(a1 + 144) = v16;
  return MTGesture::dispatchEvents((uint64_t *)a1, a4, a5, v15, (uint64_t)a7, (uint64_t)&v18, *(unsigned __int8 *)(a1 + 32), *(unsigned int *)(a6 + 224), v16);
}

float MTSlideGesture::cumulativeMotionMagnitude(MTSlideGesture *this)
{
  int v1;

  if (*(_QWORD *)this != *((_QWORD *)this + 1)
    && ((**(_WORD **)this & 0x80) != 0 || (v1 = **(unsigned __int16 **)this, (v1 - 35) < 5) || v1 == 67))
  {
    return fabsf(*((float *)this + 22));
  }
  else
  {
    return (float)(hypotf(*((float *)this + 24), *((float *)this + 25)) + fabsf(*((float *)this + 26)))
         + fabsf(*((float *)this + 27));
  }
}

uint64_t MTSlideGesture::decayAxisIntegrator(uint64_t result, uint64_t a2, float *a3, double a4, float a5)
{
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;

  v5 = *(float *)(result + 52);
  if (!*(_BYTE *)(a2 + 264))
    v5 = v5 * 1.7;
  v6 = a5 * 0.00282;
  v7 = a4 * 0.3;
  if (v6 >= v7)
    v7 = v6;
  v8 = (float)(v7 + 1.0) * v5;
  if (v8 > 0.0)
  {
    v9 = *a3;
    if (*a3 <= v8)
    {
      v10 = 0.0;
      if (v9 < (float)-v8)
        v10 = v8 + v9;
    }
    else
    {
      v10 = v9 - v8;
    }
    *a3 = v10;
  }
  return result;
}

float MTSlideGesture::inactivityExtraCommitMultiplier(MTSlideGesture *this, double a2, double *a3)
{
  double v3;

  v3 = fmin(sqrt(a2), 5.0);
  *a3 = v3;
  return 7.50000048 / (v3 + 7.50000048);
}

uint64_t MTSlideGesture::squelchCommitMultiplierForDirectionReversals(uint64_t this, int a2, float *a3, float *a4)
{
  float v4;
  uint64_t v5;
  _DWORD *v6;
  float v7;
  float v8;

  v4 = *a3;
  v5 = this + 4 * a2;
  v7 = *(float *)(v5 + 96);
  v6 = (_DWORD *)(v5 + 96);
  v8 = v7;
  if ((float)(*a3 * v7) < 0.0)
  {
    if (fabsf(v4) <= fabsf(v8))
    {
      *a4 = 1.0;
    }
    else
    {
      *a3 = v4 + v8;
      *v6 = 0;
    }
  }
  return this;
}

uint64_t MTSlideGesture::integrateAxisMotion(uint64_t result, uint64_t a2, MTHandMotion *this, uint64_t a4, uint64_t a5, int a6, double a7, float a8)
{
  double v8;
  uint64_t v10;
  int v11;
  uint64_t v12;
  float v13;
  float v14;
  float v15;
  _QWORD *v16;
  float v17;
  float *v18;
  float v19;
  float MouseMotionFeedback;

  v8 = a7;
  v10 = result;
  v11 = *((_DWORD *)this + 32);
  v12 = result + 4 * a6;
  if (!*(_BYTE *)(a5 + 264))
  {
    if (v11 < 2000 || v11 > 0xBB7)
    {
      v14 = *(float *)(result + 40);
    }
    else
    {
      if (*(double *)(a2 + 8) - *(double *)(a2 + 56) > a7)
        goto LABEL_17;
      v8 = fmin(sqrt(a7), 5.0);
      v13 = 7.50000048 / (v8 + 7.50000048);
      v14 = *(float *)(result + 40) * v13;
      v15 = *(float *)(v12 + 96);
      if ((float)(v15 * a8) < 0.0)
      {
        if (fabsf(a8) <= fabsf(v15))
        {
          v14 = 1.0;
        }
        else
        {
          a8 = v15 + a8;
          *(_DWORD *)(v12 + 96) = 0;
        }
      }
    }
    if (*(_BYTE *)(a4 + 28))
    {
      if (*(int *)(a4 + 24) >= 3 && *(_DWORD *)(a5 + 216) == 1)
      {
        v16 = *(_QWORD **)(a5 + 160);
        if (*(_QWORD *)(a5 + 168) - (_QWORD)v16 == 160 && *v16 != v16[1] && *(_WORD *)*v16 == 68)
          v14 = v14 * 0.06;
      }
    }
    a8 = a8
       * (float)(v14
               * (float)((float)((float)(*((float *)this + 63) * -1.4) + 1.0)
                       * (float)((float)(*((float *)this + 63) * -1.4) + 1.0)));
  }
LABEL_17:
  v17 = *((float *)this + 93);
  if (!*(_BYTE *)(a2 + 211))
    v17 = 1.0;
  v19 = *(float *)(v12 + 96);
  v18 = (float *)(v12 + 96);
  *v18 = v19 + (float)(a8 * v17);
  if ((v11 - 2000) <= 0x3E7)
  {
    MouseMotionFeedback = MTHandMotion::getMouseMotionFeedback(this, a6);
    return MTSlideGesture::decayAxisIntegrator(v10, a5, v18, v8, MouseMotionFeedback);
  }
  return result;
}

float MTSlideGesture::decayRecentDisplacement(MTSlideGesture *this, const MTHandStatistics *a2)
{
  float v3;
  float result;

  v3 = pow(0.939999998, (*((double *)a2 + 1) - *((double *)a2 + 2)) / 0.00800000038);
  result = *((float *)this + 28) * v3;
  *((float *)this + 28) = result;
  return result;
}

float MTSlideGesture::recordCommittedDisplacement(MTSlideGesture *this, float a2)
{
  float result;

  result = fabsf(a2) + *((float *)this + 28);
  *((float *)this + 28) = result;
  return result;
}

uint64_t MTSlideGesture::thresholdAxisMotion(MTSlideGesture *this, const MTHandStatistics *a2, const MTHandMotion *a3, int a4)
{
  float v4;
  float *v5;
  float v6;
  uint64_t v7;
  float v8;

  v4 = *((float *)this + 9);
  v5 = (float *)((char *)this + 4 * a4);
  v6 = v5[24];
  v7 = (int)(float)(v6 / v4);
  v8 = v4 * (float)(int)v7;
  v5[24] = v6 - v8;
  *((float *)this + 28) = *((float *)this + 28) + fabsf(v8);
  return v7;
}

void MTSlideGesture::suppressVelocityFromMouseFeeback(MTSlideGesture *this, int a2, const MTHandMotion *a3, float a4)
{
  MTHandMotion::getMouseMotionFeedback(a3, a2);
  MTHandMotion::getButtonMotionFeedback(a3);
}

float MTSlideGesture::accelerateAxisMotion(MTSlideGesture *this, int a2, const MTHandStatistics *a3, const MTHandMotion *a4, float a5, int a6)
{
  float *v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;

  switch(a2)
  {
    case 0:
      v11 = (float *)((char *)a4 + 316);
      goto LABEL_7;
    case 1:
      v11 = (float *)((char *)a4 + 320);
      goto LABEL_7;
    case 2:
      v11 = (float *)((char *)a4 + 324);
      goto LABEL_7;
    case 3:
      v11 = (float *)((char *)a4 + 328);
LABEL_7:
      v12 = *v11;
      break;
    default:
      v12 = 0.0;
      break;
  }
  v13 = *((float *)this + a2 + 31);
  if (v13 == 0.0)
  {
    if (*(_QWORD *)this == *((_QWORD *)this + 1)
      || **(_WORD **)this != 71
      || a2 > 1
      || (v13 = 1.0, *((double *)this + 18) <= 0.0))
    {
      v13 = 0.0;
    }
  }
  v14 = (float)(v12 * v13) * a5;
  if ((*((_DWORD *)a4 + 32) - 2000) <= 0x3E7)
    MTSlideGesture::suppressVelocityFromMouseFeeback(this, a2, a4, v14);
  v15 = 0.0;
  if (v14 != 0.0)
  {
    v15 = (*((double *)a3 + 1) - *((double *)a3 + 2)) * v14;
    if (a6)
    {
      if (a2 > 1)
        v16 = fabsf(v14);
      else
        v16 = sqrtf((float)(*((float *)a4 + 84) * *((float *)a4 + 84)) + (float)(*((float *)a4 + 83)
                                                                               * *((float *)a4 + 83)));
      v17 = *((float *)this + 11);
      v18 = 1.0;
      if (v17 < v16 && v17 > 0.0)
      {
        v19 = *((float *)this + 12);
        if (v19 > 0.0)
          v18 = powf(v16 / v17, v19);
      }
      return v18 * v15;
    }
  }
  return v15;
}

float MTSlideGesture::increasingSigmoidFromTdiff(MTSlideGesture *this, double a2, double a3, int a4)
{
  float v4;
  float v5;
  float v6;
  int v7;
  float v8;

  v4 = 0.0;
  if (a2 != 0.0)
  {
    v4 = 1.0;
    if (a3 != 0.0)
    {
      v5 = a3;
      v6 = a2;
      if (a4 >= 2)
      {
        v7 = a4 - 1;
        do
        {
          v5 = v5 * a3;
          v6 = v6 * a2;
          --v7;
        }
        while (v7);
      }
      v8 = v6 / (float)(v6 + v5);
      v4 = 1.0;
      if (v8 <= 1.0)
      {
        v4 = v8;
        if (v8 < 0.0)
          return 0.0;
      }
    }
  }
  return v4;
}

BOOL MTSlideGesture::canOverrideLockOn(MTSlideGesture *this, const MTSlideGesture *a2)
{
  unsigned int v3;
  float v4;

  v3 = (*((_DWORD *)a2 + 8) >> 9) & 7;
  v4 = *((float *)a2 + 28);
  if ((float)(v4 + MTSlideGesture::cumulativeMotionMagnitude(a2)) >= 3.0 || v3 == 0)
    return 0;
  if (*(_QWORD *)this == *((_QWORD *)this + 1) || **(_WORD **)this != 133)
    return v3 < ((*((_DWORD *)this + 8) >> 9) & 7u);
  return 1;
}

BOOL MTSlideGesture::canPunishSomeMoving(MTSlideGesture *this, uint64_t a2, uint64_t a3)
{
  const MTSlideGesture *v4;
  float v7;

  if ((*((_DWORD *)this + 8) & 0x8000E00) == 0)
    return 0;
  if (*(_BYTE *)(a3 + 264))
  {
    v4 = *(const MTSlideGesture **)(a3 + 272);
    if (v4)
    {
      if (*(double *)(a2 + 8) - *(double *)(a3 + 256) >= *(double *)&qword_255EB3BF0)
      {
        if (v4 != this)
          return MTSlideGesture::canOverrideLockOn(this, v4);
        v7 = *((float *)this + 28);
        if ((float)(v7 + MTSlideGesture::cumulativeMotionMagnitude(this)) >= 3.0
          || *(_DWORD *)(a3 + 216) >= 4u && *(_QWORD *)this != *((_QWORD *)this + 1) && **(_WORD **)this == 70)
        {
          return MTSlideGesture::canOverrideLockOn(this, v4);
        }
      }
    }
  }
  return 1;
}

float MTSlideGesture::someMovingMultiplier(MTSlideGesture *this, uint64_t a2, MTHandMotion *a3, uint64_t a4)
{
  unsigned int v8;
  float SpeedSymmetry;
  _WORD *v10;
  _WORD *v11;
  BOOL v12;
  _BOOL8 canPunishSomeMoving;
  float v14;
  float v15;
  float v16;

  v8 = *((_DWORD *)this + 8);
  SpeedSymmetry = 0.0;
  if ((v8 & 0x100) == 0 || *((_BYTE *)a3 + 376))
  {
    v10 = *(_WORD **)this;
    v11 = (_WORD *)*((_QWORD *)this + 1);
    if (*(_WORD **)this == v11
      || ((*v10 & 0xFFFE) == 0x46 ? (v12 = *(_BYTE *)(a2 + 305) == 0) : (v12 = 1),
          v12 || *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) < 4))
    {
      canPunishSomeMoving = MTSlideGesture::canPunishSomeMoving(this, a2, a4);
      SpeedSymmetry = 1.0;
      if (canPunishSomeMoving)
      {
        if ((v8 & 0x8000000) != 0)
        {
          v14 = 0.8;
          if (v10 != v11 && *(_DWORD *)(a4 + 216) == 2)
            v14 = flt_2310BD4E8[(unsigned __int16)(*v10 - 35) < 5u];
          SpeedSymmetry = MTHandMotion::getSpeedSymmetry(a3, v14, 0);
          v8 = *((_DWORD *)this + 8);
        }
        if ((v8 & 0xE00) != 0)
        {
          v15 = 0.9;
          if (*(_DWORD *)(a4 + 216) == 3)
            v15 = 2.0;
          v16 = MTHandMotion::getSpeedSymmetry(a3, v15, (v8 >> 9) & 7);
          if (SpeedSymmetry < v16 || SpeedSymmetry == 1.0)
            SpeedSymmetry = v16;
          v8 = *((_DWORD *)this + 8);
        }
        if ((v8 & 0xE00) == 0x800 && *(_BYTE *)(a2 + 186) == 5)
          return SpeedSymmetry
               * MTSlideGesture::increasingSigmoidFromTdiff((MTSlideGesture *)canPunishSomeMoving, *(double *)(a2 + 8) - *(double *)(a2 + 80) - (*(double *)(a2 + 8) - *(double *)(a2 + 56)), *(double *)&qword_255EB3BE0, 2);
      }
    }
  }
  return SpeedSymmetry;
}

float MTSlideGesture::integrateManipulativeGesture(uint64_t a1, unsigned __int8 *a2, MTHandMotion *a3, uint64_t a4, uint64_t a5, double a6, float a7)
{
  float v14;
  unint64_t i;
  int v16;
  float v17;
  float v18;

  v14 = MTSlideGesture::someMovingMultiplier((MTSlideGesture *)a1, (uint64_t)a2, a3, a5);
  for (i = 0; i != 4; ++i)
  {
    if (*(float *)(a1 + 4 * i + 124) != 0.0
      || *(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && **(_WORD **)a1 == 71 && i <= 1 && *(double *)(a1 + 144) > 0.0)
    {
      if (*(_BYTE *)(a5 + 264))
        v16 = (*(_BYTE *)(a1 + 34) & 0x80) == 0 || a2[302] <= (a2[186] >> 1);
      else
        v16 = 0;
      v17 = MTSlideGesture::accelerateAxisMotion((MTSlideGesture *)a1, i, (const MTHandStatistics *)a2, a3, a7, v16);
      MTSlideGesture::integrateAxisMotion(a1, (uint64_t)a2, a3, a4, a5, i, a6, v14 * v17);
    }
  }
  v18 = *(float *)(a1 + 112);
  return v18 + MTSlideGesture::cumulativeMotionMagnitude((MTSlideGesture *)a1);
}

uint64_t MTSlideGesture::fireManipulativeGesture(uint64_t result, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, double a7)
{
  MTSlideGesture *v8;
  uint64_t v9;
  int v10;
  float v11;
  float v12;
  int v13;
  float v14;
  int v15;
  int32x2_t v16;
  int32x4_t v17;

  v8 = (MTSlideGesture *)result;
  v9 = 0;
  v10 = 0;
  v17.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v17.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v11 = *(float *)(result + 36);
  do
  {
    v12 = *(float *)(result + v9 * 4 + 96);
    v13 = (int)(float)(v12 / v11);
    v14 = v11 * (float)v13;
    *(float *)(result + v9 * 4 + 96) = v12 - v14;
    *(float *)(result + 112) = *(float *)(result + 112) + fabsf(v14);
    v17.i32[v9] = v13;
    if (v13 >= 0)
      v15 = (int)(float)(v12 / v11);
    else
      v15 = -v13;
    v10 += v15;
    ++v9;
  }
  while (v9 != 4);
  if ((*(_BYTE *)(result + 35) & 2) == 0
    || *(_BYTE *)(a6 + 264)
    || (*(_DWORD *)(a3 + 128) - 2000) <= 0x3E7 && a2[298] < a2[186]
    || (v16 = vabs_s32(*(int32x2_t *)v17.i8),
        (vcgt_u32((uint32x2_t)v16, (uint32x2_t)vdup_lane_s32(v16, 1)).u8[0] & 1) == 0))
  {
    if (*(_QWORD *)result == *(_QWORD *)(result + 8) || **(_WORD **)result != 68 || !a2[222])
    {
      if (v10)
      {
        result = MTSlideGesture::sendSlideMickeys(result, (uint64_t)a2, a3, a4, a5, a6, &v17, a7);
        if ((int)result >= 1)
        {
          result = MTChordIntegrating::resetMostIntegrators(a6, v8);
          *(_DWORD *)(a6 + 288) += v10;
        }
      }
    }
  }
  return result;
}

float MTSlideGesture::integrateFluidGesture(MTSlideGesture *this, const MTHandStatistics *a2, const MTHandMotion *a3, MTChordIntegrating *a4, float a5)
{
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  uint64_t i;
  float v16;
  float v17;
  float MouseMotionFeedback;
  float v19;
  unint64_t j;
  float *v21;
  float v22;
  float v23;
  BOOL v24;
  float v25;
  float v26;
  float v28;
  float v29;
  float v30;

  v10 = MTSlideGesture::someMovingMultiplier(this, (uint64_t)a2, a3, (uint64_t)a4);
  *((_DWORD *)this + 20) = 0;
  if (*((float *)this + 39) <= 0.0)
  {
    v13 = 0.0;
    for (i = 33; i != 35; ++i)
    {
      if (*((float *)this + i) != 0.0)
      {
        v16 = MTSlideGesture::accelerateAxisMotion(this, i - 31, a2, a3, a5, 0);
        v17 = MTSlideGesture::accelerateAxisMotion(this, i - 31, a2, a3, a5, 1);
        v13 = *((float *)this + 20) + (float)(v16 * v10);
        *((float *)this + 20) = v13;
        *((float *)this + 22) = *((float *)this + 22) + (float)(v17 * v10);
      }
    }
  }
  else
  {
    MTSlideGesture::integrateMotionWithinArc(this, a2, a3, a5, 0);
    v12 = v11;
    MTSlideGesture::integrateMotionWithinArc(this, a2, a3, a5, 1);
    v13 = *((float *)this + 20) + (float)(v12 * v10);
    *((float *)this + 20) = v13;
    *((float *)this + 22) = *((float *)this + 22) + (float)(v14 * v10);
  }
  *((float *)this + 23) = v13 + *((float *)this + 23);
  if (!*((_BYTE *)a4 + 264))
  {
    MouseMotionFeedback = MTHandMotion::getMouseMotionFeedback(a3, 0);
    MTSlideGesture::decayAxisIntegrator((uint64_t)this, (uint64_t)a4, (float *)this + 23, 0.0, MouseMotionFeedback);
    v19 = MTHandMotion::getMouseMotionFeedback(a3, 0);
    MTSlideGesture::decayAxisIntegrator((uint64_t)this, (uint64_t)a4, (float *)this + 22, 0.0, v19);
  }
  for (j = 0; j != 4; ++j)
  {
    v21 = (float *)((char *)this + 4 * j);
    if (v21[31] != 0.0
      || *(_QWORD *)this != *((_QWORD *)this + 1) && **(_WORD **)this == 71 && j <= 1 && *((double *)this + 18) > 0.0)
    {
      v21[24] = v10 * MTSlideGesture::accelerateAxisMotion(this, j, a2, a3, a5, 0);
    }
  }
  v22 = *((float *)this + 21);
  v23 = *((float *)this + 23);
  v24 = (float)(v22 * v23) < 0.0;
  v25 = fabsf(v23);
  v26 = fabsf(v22);
  if (v24 || v25 > v26)
    *((float *)this + 21) = v23;
  v28 = (float)(*((float *)this + 20) / *((float *)this + 15)) / (*((double *)a2 + 1) - *((double *)a2 + 2));
  MTChordIntegrating::momentumFilterAlpha(a4, a2, fabsf(*((float *)this + 30)) < fabsf(v28));
  *((float *)this + 30) = (float)((float)(1.0 - v29) * v28) + (float)(v29 * *((float *)this + 30));
  v30 = *((float *)this + 28);
  return v30 + MTSlideGesture::cumulativeMotionMagnitude(this);
}

void MTSlideGesture::integrateMotionWithinArc(MTSlideGesture *this, const MTHandStatistics *a2, const MTHandMotion *a3, float a4, int a5)
{
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  MTSlideGesture *v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;

  v9 = *((float *)this + 31);
  if (v9 == 0.0)
  {
    if (*(_QWORD *)this == *((_QWORD *)this + 1) || **(_WORD **)this != 71 || (v9 = 1.0, *((double *)this + 18) <= 0.0))
      v9 = 0.0;
  }
  v10 = *((float *)a3 + 79) * v9;
  v11 = *((float *)this + 32);
  if (v11 == 0.0)
  {
    if (*(_QWORD *)this == *((_QWORD *)this + 1)
      || **(_WORD **)this != 71
      || (v11 = 1.0, *((double *)this + 18) <= 0.0))
    {
      v11 = 0.0;
    }
  }
  v12 = (float)(*((float *)a3 + 80) * v11) * a4;
  v13 = sqrtf((float)(*((float *)a3 + 84) * *((float *)a3 + 84)) + (float)(*((float *)a3 + 83) * *((float *)a3 + 83)));
  if ((*((_DWORD *)a3 + 32) - 2000) <= 0x3E7)
  {
    MTSlideGesture::suppressVelocityFromMouseFeeback(this, 0, a3, v10 * a4);
    MTSlideGesture::suppressVelocityFromMouseFeeback(v14, 0, a3, v12);
  }
  if (v13 != 0.0)
  {
    v15 = atan2f(-*((float *)a3 + 84), *((float *)a3 + 83)) + (float)(a4 + -1.0) * 1.57079633;
    if (a5)
    {
      v16 = *((float *)this + 11);
      if (v16 < v13 && v16 > 0.0)
      {
        v17 = *((float *)this + 12);
        if (v17 > 0.0)
          powf(v13 / v16, v17);
      }
    }
    v18 = *((float *)this + 38);
    v19 = *((float *)this + 39);
    v20 = cosf(v15 - v18);
    v21 = cosf(v19 * 0.5);
    if (v20 > v21 || v20 < (float)-v21)
      __sincosf_stret(v18);
  }
}

uint64_t MTSlideGesture::updateFluidPeak(uint64_t this)
{
  float v1;
  float v2;
  BOOL v3;
  float v4;
  float v5;

  v1 = *(float *)(this + 84);
  v2 = *(float *)(this + 92);
  v3 = (float)(v1 * v2) < 0.0;
  v4 = fabsf(v2);
  v5 = fabsf(v1);
  if (v3 || v4 > v5)
    *(float *)(this + 84) = v2;
  return this;
}

float MTSlideGesture::updateFluidMomentum(MTSlideGesture *this, const MTHandStatistics *a2, MTChordIntegrating *a3, float a4)
{
  float v6;
  float result;

  MTChordIntegrating::momentumFilterAlpha(a3, a2, fabsf(*((float *)this + 30)) < fabsf(a4));
  result = (float)((float)(1.0 - v6) * a4) + (float)(v6 * *((float *)this + 30));
  *((float *)this + 30) = result;
  return result;
}

uint64_t MTSlideGesture::cumulativeSwipeToDiscreteDelta(MTSlideGesture *this)
{
  int v1;
  float v2;
  float v3;
  float v4;
  uint64_t v5;
  float v6;
  float v7;
  float v8;

  v1 = *((_DWORD *)this + 18);
  if (!v1)
  {
    *((_DWORD *)this + 19) = 0;
    v7 = *((float *)this + 22);
    v8 = *((float *)this + 9);
    if (v7 <= v8)
    {
      if (v7 >= (float)-v8)
        return 0;
      v5 = 0xFFFFFFFFLL;
    }
    else
    {
      v5 = 1;
    }
    *((_DWORD *)this + 18) = v5;
    return v5;
  }
  v2 = *((float *)this + 19);
  v3 = *((float *)this + 22);
  v4 = *((float *)this + 9);
  if (v1 < 1)
  {
    if (v2 >= (float)(v3 + v4))
      v2 = v3 + v4;
    *((float *)this + 19) = v2;
    if (v3 > v2)
    {
      v5 = 1;
      *((_DWORD *)this + 18) = 1;
      v6 = v3 - v4;
      goto LABEL_13;
    }
    return 0;
  }
  if (v2 <= (float)(v3 - v4))
    v2 = v3 - v4;
  *((float *)this + 19) = v2;
  if (v3 >= v2)
    return 0;
  v5 = 0xFFFFFFFFLL;
  *((_DWORD *)this + 18) = -1;
  v6 = v3 + v4;
LABEL_13:
  *((float *)this + 19) = v6;
  return v5;
}

float MTSlideGesture::peakSwipePercentage(MTSlideGesture *this)
{
  return *((float *)this + 21) / *((float *)this + 15);
}

float MTSlideGesture::fluidSwipePercentage(MTSlideGesture *this)
{
  return *((float *)this + 23) / *((float *)this + 15);
}

float MTSlideGesture::fluidMomentumPercentage_s(MTSlideGesture *this, int a2)
{
  float result;

  result = 0.0;
  if (a2)
    return *((float *)this + 30);
  return result;
}

uint64_t MTSlideGesture::hasSufficientFluidMomentum(MTSlideGesture *this, const MTHandStatistics *a2, int a3)
{
  float v3;
  _WORD *v4;
  _WORD *v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  _BOOL4 v11;
  float v12;
  float v13;
  float v14;
  int v15;
  _BOOL4 v16;

  v3 = *((float *)this + 15);
  v4 = *(_WORD **)this;
  v5 = (_WORD *)*((_QWORD *)this + 1);
  v6 = 1.0;
  v7 = 0.8;
  v8 = *((float *)this + 23) / v3;
  if (*(_WORD **)this != v5 && (*v4 & 0xFFFE) == 0x26)
  {
    v9 = 0.0;
    if (a3)
      v9 = *((float *)this + 30);
    v6 = 0.25;
    if ((float)(v8 * v9) >= 0.0)
      v6 = 1.0;
    v7 = 0.6;
  }
  v10 = 0.0;
  if (a3)
    v10 = *((float *)this + 30);
  v11 = v4 != v5 && (*v4 & 0xFFFE) == 38;
  v12 = v8 + (float)((float)(v6 * *((float *)this + 16)) * v10);
  v13 = fabsf(v12);
  v14 = v7 * fabsf(*((float *)this + 21) / v3);
  v15 = !v11;
  if (*((unsigned __int8 *)this + 32) - 1 > 1)
    v15 = 1;
  v16 = (float)(v8 * v12) > 0.0 && v13 > 0.5;
  if (v13 < v14)
    v16 = 0;
  if (v12 >= 0.0)
    v15 = 1;
  return v16 & v15;
}

float MTSlideGesture::fluidDOFPercentageDeltas(MTSlideGesture *this)
{
  return *((float *)this + 24) / *((float *)this + 15);
}

uint64_t MTSlideGesture::fireFluidGesture(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, MTChordIntegrating *this, double a7)
{
  uint64_t v13;
  int v14;
  float v15;
  float v16;
  float v17;
  const float *v18;

  v13 = result;
  v14 = *((unsigned __int8 *)this + 264);
  if (!*((_BYTE *)this + 264) || !*(_BYTE *)(result + 68))
  {
    v15 = fabsf(*(float *)(result + 92));
    if (v15 <= *(float *)(result + 56))
      return result;
    *(float *)(result + 112) = v15 + *(float *)(result + 112);
    *(_DWORD *)(result + 92) = *(_DWORD *)(result + 80);
    if (!v14)
      MTChordIntegrating::resetMostIntegrators((uint64_t)this, (MTSlideGesture *)result);
  }
  result = MTChordIntegrating::sendSlidePreamble((uint64_t)this, a2, a3, a4, a5, v13, 8u, a7);
  if (*(float *)(v13 + 80) != 0.0)
  {
    v16 = *(float *)(v13 + 92);
    v17 = *(float *)(v13 + 60);
    MTSlideGesture::cumulativeSwipeToDiscreteDelta((MTSlideGesture *)v13);
    *((_DWORD *)this + 71) = *(unsigned __int8 *)(v13 + 32);
    *(_QWORD *)(v13 + 144) = *(_QWORD *)(a2 + 8);
    if (*(_QWORD *)(v13 + 8) == *(_QWORD *)v13)
      std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
    v18 = (const float *)(v13 + 60);
    vld1q_dup_f32(v18);
    result = (*(uint64_t (**)(uint64_t, float, float))(*(_QWORD *)a4 + 32))(a4, v16 / v17, 0.0);
    *(_BYTE *)(v13 + 68) = 1;
  }
  return result;
}

float MTSlideGesture::integrateCommandGesture(uint64_t a1, const MTHandStatistics *a2, MTHandMotion *a3, uint64_t a4, float a5)
{
  float v10;
  float v11;
  float MouseMotionFeedback;
  float v13;
  unint64_t i;

  v10 = MTSlideGesture::someMovingMultiplier((MTSlideGesture *)a1, (uint64_t)a2, a3, a4);
  if (*(float *)(a1 + 156) <= 0.0)
  {
    for (i = 0; i != 4; ++i)
    {
      if (*(float *)(a1 + 4 * i + 124) != 0.0
        || *(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && **(_WORD **)a1 == 71 && i <= 1 && *(double *)(a1 + 144) > 0.0)
      {
        *(float *)(a1 + 88) = *(float *)(a1 + 88)
                            + (float)(MTSlideGesture::accelerateAxisMotion((MTSlideGesture *)a1, i, a2, a3, a5, 1) * v10);
      }
    }
  }
  else
  {
    MTSlideGesture::integrateMotionWithinArc((MTSlideGesture *)a1, a2, a3, a5, 1);
    *(float *)(a1 + 88) = *(float *)(a1 + 88) + (float)(v11 * v10);
  }
  if ((*((_DWORD *)a3 + 32) - 2000) <= 0x3E7)
  {
    MouseMotionFeedback = MTHandMotion::getMouseMotionFeedback(a3, 0);
    MTSlideGesture::decayAxisIntegrator(a1, a4, (float *)(a1 + 88), 0.0, MouseMotionFeedback);
  }
  if (*(float *)(a1 + 88) < 0.0)
    *(_DWORD *)(a1 + 88) = 0;
  v13 = *(float *)(a1 + 112);
  return v13 + MTSlideGesture::cumulativeMotionMagnitude((MTSlideGesture *)a1);
}

uint64_t MTSlideGesture::fireCommandGesture(uint64_t result, MTHandStatistics *a2, MTHandMotion *a3, uint64_t a4, uint64_t a5, MTChordIntegrating *this, double a7)
{
  float v8;
  float v9;
  int v10;
  float *v16;

  v8 = *(float *)(result + 36);
  v9 = *(float *)(result + 88);
  v10 = (int)(float)(v9 / v8);
  if (v10 >= 1)
  {
    v16 = (float *)result;
    if (*((_BYTE *)this + 264))
    {
      if ((*(_BYTE *)(result + 33) & 0x40) != 0)
      {
        result = MTChordIntegrating::waitForFastShotVerification(this, a2, a3);
        v9 = v16[22];
        if ((_DWORD)result)
        {
          if (v9 > 30.0)
            v16[22] = 30.0;
          return result;
        }
      }
    }
    else
    {
      v10 = 1;
    }
    v16[22] = v9 - (float)((float)v10 * v8);
    v16[28] = fabsf(v8 * (float)v10) + v16[28];
    result = MTSlideGesture::sendSlideKeys((uint64_t)v16, (uint64_t)a2, (uint64_t)a3, a4, a5, (uint64_t)this, (__int16)v10, a7);
    if ((int)result >= 1)
      return MTChordIntegrating::resetMostIntegrators((uint64_t)this, (MTSlideGesture *)v16);
  }
  return result;
}

BOOL MTSlideGesture::isLockedOutByTriggeredSlide(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  const MTSlideGesture *v5;
  unsigned int v6;
  _BOOL8 result;

  v5 = *(const MTSlideGesture **)(a3 + 272);
  if (!v5)
    return 0;
  v6 = *((_DWORD *)v5 + 8);
  if ((v6 & 0x1000) != 0)
    return 1;
  if (v5 == (const MTSlideGesture *)a1)
    return 0;
  if ((v6 & 0x2000) != 0 && (*(_BYTE *)(a1 + 33) & 0x20) == 0)
    return 1;
  if ((v6 & 0x8000) == 0
    && ((v6 & 0x40000) == 0 || *(_BYTE *)(a3 + 265))
    && ((v6 & 0x20000) == 0 || (*(_DWORD *)(a3 + 280) & 0x80000000) == 0))
  {
    return (v6 & 0x10000) != 0
        && *(_DWORD *)(a1 + 32) >> ((*(_DWORD *)(a1 + 32) & 0x55) == 0) != *((_DWORD *)v5 + 8) >> ((*((_DWORD *)v5 + 8) & 0x55) == 0);
  }
  if ((a4 & 1) != 0)
    return 1;
  if (MTSlideGesture::canOverrideLockOn((MTSlideGesture *)a1, v5))
    return 0;
  result = 1;
  if ((v6 & 0x8000000) == 0 && ((v6 >> 9) & 7) - 1 <= 2)
    return *(double *)(a2 + 8) - *(double *)(a3 + 256) >= *(double *)&qword_255EB3BF0;
  return result;
}

uint64_t MTSlideGesture::isActiveEdgeSlide(unsigned __int16 **a1, uint64_t a2, uint64_t a3)
{
  int v3;
  BOOL v4;
  unsigned int v5;
  double v6;
  int v7;
  int v8;
  BOOL v9;
  BOOL v10;
  char v11;
  BOOL v12;

  v3 = *((_DWORD *)a1 + 8);
  if ((v3 & 0x200000) == 0)
    return 0;
  v4 = ((_DWORD)a1[4] & 3) == 0;
  v5 = *(_DWORD *)(a2 + 228);
  if ((v3 & 3) == 0)
    v5 = *(_DWORD *)(a2 + 224);
  v6 = *(double *)(a2 + 8) - *(double *)(a3 + 248);
  if (v6 <= *(double *)&qword_255EB3BF8)
    v4 = 0;
  if (*a1 == a1[1])
    return 1;
  v7 = v3 & (v5 >> 4) & 0xF;
  v8 = **a1;
  v9 = v6 > *(double *)&qword_255EB3BD8 || v7 == 0;
  v10 = v9;
  if ((v8 != 78 || !v10)
    && (!(v3 & (*(_DWORD *)(a2 + 224) >> 12) & 2 | v7) ? (v11 = 1) : (v11 = v4),
        (v8 & 0xFFFE) == 0x26 ? (v12 = *(_QWORD *)(a3 + 272) == (_QWORD)a1) : (v12 = 1),
        v12 || (v11 & 1) == 0))
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

uint64_t MTSlideGesture::isBlocked(unsigned __int16 **a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  int v8;
  unsigned int v9;
  BOOL v10;
  int v11;
  float v13;
  _BOOL4 v15;

  v8 = *((_DWORD *)a1 + 8);
  if (*(_BYTE *)(a2 + 316))
  {
    v9 = *(unsigned __int8 *)(a2 + 186);
    if (*(_BYTE *)(a2 + 317))
      v10 = 0;
    else
      v10 = v9 > 1;
    if (v10)
      return 1;
  }
  else
  {
    v9 = *(unsigned __int8 *)(a2 + 186);
  }
  if (*a1 == a1[1])
    return 1;
  v11 = **a1;
  if (!**a1 || *((float *)a1 + 9) == 0.0 || (v8 & 0x100000) != 0 && !*(_BYTE *)(a4 + 264))
    return 1;
  if ((v8 & 0x4000000) != 0 && *(double *)(a2 + 8) - *(double *)(a4 + 248) >= *(double *)&qword_255EB3BE8)
    return 1;
  if ((v8 & 0x200000) != 0)
  {
    if ((MTSlideGesture::isActiveEdgeSlide(a1, a2, a4) & 1) != 0)
      goto LABEL_45;
    return 1;
  }
  if (v11 == 70)
  {
    if (!*(_BYTE *)(a4 + 264)
      && *(_DWORD *)(a4 + 216) == 2
      && ((*(_BYTE *)(a2 + 224) & 0xC0) != 0
       || *(_BYTE *)(a3 + 136) && (*(_BYTE *)(a2 + 228) & 0x20) != 0
       || *(_BYTE *)(a3 + 137) && (*(_BYTE *)(a2 + 228) & 0x10) != 0)
      && *(double *)(a2 + 8) - *(double *)(a4 + 248) < *(double *)&qword_255EB3BD8)
    {
      return 1;
    }
  }
  else if (v11 == 68
         && !*(_BYTE *)(a4 + 264)
         && *(_DWORD *)(a4 + 216) == 1
         && *(double *)(a2 + 8) - *(double *)(a4 + 248) < *(double *)&qword_255EB3BD0)
  {
    if ((a5 & 1) != 0 || (v8 & 3) == 0)
    {
      if (*(_BYTE *)(a3 + 136) && (*(_BYTE *)(a2 + 224) & 0x20) != 0
        || *(_BYTE *)(a3 + 137) && (*(_BYTE *)(a2 + 224) & 0x10) != 0)
      {
        return 1;
      }
    }
    else if (*(_BYTE *)(a3 + 136) && (*(_BYTE *)(a2 + 229) & 0x20) != 0
           || *(_BYTE *)(a3 + 137) && (*(_BYTE *)(a2 + 229) & 0x10) != 0)
    {
      return 1;
    }
  }
LABEL_45:
  if (*(_BYTE *)(a4 + 267)
    || (*(_WORD *)(a4 + 228) & 0x1000) != 0 && *(double *)(a2 + 8) - *(double *)(a2 + 128) < *(double *)&qword_255EB3BE0
    || MTSlideGesture::isLockedOutByTriggeredSlide((uint64_t)a1, a2, a4, 0))
  {
    return 1;
  }
  v15 = *(unsigned __int16 ***)(a4 + 272) != a1 && v8 < 0;
  v13 = (double)v9 * 25.0;
  return *(float *)(a2 + 160) < v13 && v15;
}

float MTSlideGesture::integrateGesture(MTSlideGesture *this, const MTHandStatistics *a2, const MTHandMotion *a3, const MTDragManagerEventQueue *a4, MTChordIntegrating *a5, double a6)
{
  float v12;
  int v13;

  v12 = pow(0.939999998, (*((double *)a2 + 1) - *((double *)a2 + 2)) / 0.00800000038);
  *((float *)this + 28) = *((float *)this + 28) * v12;
  if (*(_QWORD *)this == *((_QWORD *)this + 1))
    return MTSlideGesture::integrateManipulativeGesture((uint64_t)this, (unsigned __int8 *)a2, a3, (uint64_t)a4, (uint64_t)a5, a6, (float)*((int *)a5 + 70));
  v13 = **(unsigned __int16 **)this;
  if (v13 == 67 || (v13 & 0x80) != 0)
    return MTSlideGesture::integrateCommandGesture((uint64_t)this, a2, a3, (uint64_t)a5, (float)*((int *)a5 + 70));
  if ((v13 - 35) > 4)
    return MTSlideGesture::integrateManipulativeGesture((uint64_t)this, (unsigned __int8 *)a2, a3, (uint64_t)a4, (uint64_t)a5, a6, (float)*((int *)a5 + 70));
  else
    return MTSlideGesture::integrateFluidGesture(this, a2, a3, a5, (float)*((int *)a5 + 70));
}

uint64_t MTSlideGesture::fireGesture(uint64_t result, MTHandStatistics *a2, MTHandMotion *a3, uint64_t a4, uint64_t a5, MTChordIntegrating *this, double a7)
{
  int v7;

  if (*(_QWORD *)result == *(_QWORD *)(result + 8))
    return MTSlideGesture::fireManipulativeGesture(result, (unsigned __int8 *)a2, (uint64_t)a3, a4, a5, (uint64_t)this, a7);
  v7 = **(unsigned __int16 **)result;
  if (v7 == 67 || (v7 & 0x80) != 0)
    return MTSlideGesture::fireCommandGesture(result, a2, a3, a4, a5, this, a7);
  if ((v7 - 35) > 4)
    return MTSlideGesture::fireManipulativeGesture(result, (unsigned __int8 *)a2, (uint64_t)a3, a4, a5, (uint64_t)this, a7);
  else
    return MTSlideGesture::fireFluidGesture(result, (uint64_t)a2, (uint64_t)a3, a4, a5, this, a7);
}

void std::vector<MTActionEvent>::__init_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>(_QWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v7;
  uint64_t v8;

  if (a4)
  {
    std::vector<MTPoint>::__vallocate[abi:ne180100](a1, a4);
    v7 = a1[1];
    if (a2 != a3)
    {
      v8 = 0;
      do
      {
        MTActionEvent::MTActionEvent((MTActionEvent *)(v7 + v8), (const MTActionEvent *)(a2 + v8));
        v8 += 8;
      }
      while (a2 + v8 != a3);
      v7 += v8;
    }
    a1[1] = v7;
  }
}

void sub_23108DA6C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("vector");
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_24FFEFE58, MEMORY[0x24BEDAB00]);
}

void sub_23108DAE4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8C0] + 16);
  return result;
}

void std::vector<MTActionEvent>::__assign_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>(_QWORD *a1, _DWORD *a2, _DWORD *a3, unint64_t a4)
{
  _DWORD *v6;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  _DWORD *v13;
  char *v14;
  uint64_t v15;
  _BYTE *v16;
  unint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  int64_t v21;
  char *v22;
  char *v23;

  v6 = a2;
  v8 = a1[2];
  v9 = (_DWORD *)*a1;
  if (a4 > (v8 - *a1) >> 3)
  {
    if (v9)
    {
      a1[1] = v9;
      operator delete(v9);
      v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 61)
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 2;
    if (v8 >> 2 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    std::vector<MTPoint>::__vallocate[abi:ne180100](a1, v11);
    v13 = (_DWORD *)a1[1];
    v12 = (void **)(a1 + 1);
    v9 = v13;
    v14 = (char *)v13;
    if (v6 != a3)
    {
      v15 = 0;
      do
      {
        MTActionEvent::MTActionEvent((MTActionEvent *)&v9[v15], (const MTActionEvent *)&v6[v15]);
        v15 += 2;
      }
      while (&v6[v15] != a3);
      v14 = (char *)&v9[v15];
    }
LABEL_23:
    v21 = v14 - (char *)v9;
    goto LABEL_28;
  }
  v12 = (void **)(a1 + 1);
  v16 = (_BYTE *)a1[1];
  v17 = (v16 - (_BYTE *)v9) >> 3;
  if (v17 < a4)
  {
    v18 = &a2[2 * v17];
    if (v16 != (_BYTE *)v9)
    {
      v19 = 8 * v17;
      do
      {
        MTActionEvent::operator=(v9, v6);
        v6 += 2;
        v9 += 2;
        v19 -= 8;
      }
      while (v19);
      v9 = *v12;
    }
    v14 = (char *)v9;
    if (v18 != a3)
    {
      v20 = 0;
      do
      {
        MTActionEvent::MTActionEvent((MTActionEvent *)&v9[v20], (const MTActionEvent *)&v18[v20]);
        v20 += 2;
      }
      while (&v18[v20] != a3);
      v14 = (char *)&v9[v20];
    }
    goto LABEL_23;
  }
  v22 = (char *)*a1;
  if (a2 != a3)
  {
    v23 = (char *)*a1;
    do
    {
      MTActionEvent::operator=(v23, v6);
      v6 += 2;
      v23 += 8;
      v22 += 8;
    }
    while (v6 != a3);
  }
  v21 = v22 - (char *)v9;
LABEL_28:
  *v12 = (char *)v9 + v21;
}

void sub_23108DCA8(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  *v1 = v2;
  _Unwind_Resume(a1);
}

float MTSurfaceDimensions::MTSurfaceDimensions(uint64_t a1, float result, float a3, float a4, float a5, float a6, float a7)
{
  *(_QWORD *)a1 = &off_24FFF1098;
  *(float *)(a1 + 8) = result;
  *(float *)(a1 + 12) = a3;
  *(float *)(a1 + 16) = a4;
  *(float *)(a1 + 20) = a5;
  *(float *)(a1 + 32) = a6;
  *(float *)(a1 + 36) = a7;
  if (a6 > 0.0 && a7 > 0.0)
  {
    result = a4 / a6;
    *(float *)(a1 + 24) = a4 / a6;
    *(float *)(a1 + 28) = a5 / a7;
  }
  return result;
}

{
  *(_QWORD *)a1 = &off_24FFF1098;
  *(float *)(a1 + 8) = result;
  *(float *)(a1 + 12) = a3;
  *(float *)(a1 + 16) = a4;
  *(float *)(a1 + 20) = a5;
  *(float *)(a1 + 32) = a6;
  *(float *)(a1 + 36) = a7;
  if (a6 > 0.0 && a7 > 0.0)
  {
    result = a4 / a6;
    *(float *)(a1 + 24) = a4 / a6;
    *(float *)(a1 + 28) = a5 / a7;
  }
  return result;
}

float32x2_t MTSurfaceDimensions::deriveScreenPixelsFromResolution(float32x2_t *a1, float32x2_t result, float32_t a3)
{
  if (result.f32[0] > 0.0 && a3 > 0.0)
  {
    result.f32[1] = a3;
    result = vdiv_f32(a1[2], result);
    a1[3] = result;
  }
  return result;
}

void MTSurfaceDimensions::~MTSurfaceDimensions(MTSurfaceDimensions *this)
{
  JUMPOUT(0x2348D0034);
}

float32x2_t MTSurfaceDimensions::updatePixelResolution_mm(float32x2_t *a1, float32x2_t result, float32_t a3)
{
  a1[4].i32[0] = result.i32[0];
  a1[4].f32[1] = a3;
  if (result.f32[0] > 0.0 && a3 > 0.0)
  {
    result.f32[1] = a3;
    result = vdiv_f32(a1[2], result);
    a1[3] = result;
  }
  return result;
}

float MTSurfaceDimensions::updateScreenBounds_mm(float *a1, float a2, float a3, float a4, float a5)
{
  float result;
  float v6;

  a1[2] = a2;
  a1[3] = a3;
  a1[4] = a4;
  a1[5] = a5;
  result = a1[8];
  if (result > 0.0)
  {
    v6 = a1[9];
    if (v6 > 0.0)
    {
      result = a4 / result;
      a1[6] = result;
      a1[7] = a5 / v6;
    }
  }
  return result;
}

float MTSurfaceDimensions::minDistanceToEdge_mm(float *a1, int a2, int a3, float a4, float a5)
{
  float v6;
  float v7;
  float result;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;

  v7 = a1[4];
  v6 = a1[5];
  if (v7 <= v6)
    result = a1[5];
  else
    result = a1[4];
  if (!a2)
  {
    if (!a3)
      return result;
    goto LABEL_12;
  }
  v9 = a4 / a1[6];
  v10 = (1.0 - v9) * v7;
  if (result > v10)
    result = (1.0 - v9) * v7;
  v11 = v7 * v9;
  if (v11 < result)
    result = v11;
  if (a3)
  {
LABEL_12:
    v12 = a5 / a1[7];
    if ((float)(v6 * v12) < result)
      result = v6 * v12;
    v13 = (1.0 - v12) * v6;
    if (result > v13)
      return v13;
  }
  return result;
}

float MTSurfaceDimensions::convertPixelsToSurfaceFraction(uint64_t a1, float a2)
{
  return a2 / *(float *)(a1 + 24);
}

float MTSurfaceDimensions::distanceToTopEdge_mm(uint64_t a1, double a2, float a3)
{
  return (1.0 - (float)(a3 / *(float *)(a1 + 28))) * *(float *)(a1 + 20);
}

float MTSurfaceDimensions::distanceToBottomEdge_mm(uint64_t a1, double a2, float a3)
{
  return (float)(a3 / *(float *)(a1 + 28)) * *(float *)(a1 + 20);
}

float MTSurfaceDimensions::distanceToRightEdge_mm(uint64_t a1, float a2)
{
  return (1.0 - (float)(a2 / *(float *)(a1 + 24))) * *(float *)(a1 + 16);
}

float MTSurfaceDimensions::distanceToLeftEdge_mm(uint64_t a1, float a2)
{
  return (float)(a2 / *(float *)(a1 + 24)) * *(float *)(a1 + 16);
}

float MTSurfaceDimensions::convertPixelDeltaToMillimeters(MTSurfaceDimensions *this, float a2, int a3)
{
  uint64_t v3;

  v3 = 32;
  if (a3)
    v3 = 36;
  return *(float *)((char *)this + v3) * a2;
}

float MTSurfaceDimensions::convertPixelVelocityToMillimetersPerSecond(MTSurfaceDimensions *this, float a2)
{
  return (float)((float)(*((float *)this + 8) + *((float *)this + 9)) * a2) * 0.5;
}

float MTSurfaceDimensions::convertPixelDeltaToMillimetersPerSecond(MTSurfaceDimensions *this, float a2, double a3)
{
  float v4;
  NSObject *v5;
  int v7;
  const char *v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  double v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  if (a3 != 0.0)
    return (float)((float)(*((float *)this + 8) + *((float *)this + 9)) * a2) / (a3 + a3);
  v5 = MTLoggingPlugin();
  v4 = 0.0;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    v7 = 136315906;
    v8 = "[Error] ";
    v9 = 2080;
    v10 = "";
    v11 = 2080;
    v12 = "convertPixelDeltaToMillimetersPerSecond";
    v13 = 2048;
    v14 = a3;
    _os_log_impl(&dword_231071000, v5, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected frame interval %g, setting velocity to 0.0", (uint8_t *)&v7, 0x2Au);
  }
  return v4;
}

void MTSurfaceDimensions::convertPixelDeltasToMillimetersPerSecond(double a1, double a2, double a3)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  double v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (a3 == 0.0)
  {
    v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315906;
      v6 = "[Error] ";
      v7 = 2080;
      v8 = "";
      v9 = 2080;
      v10 = "convertPixelDeltasToMillimetersPerSecond";
      v11 = 2048;
      v12 = a3;
      _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected frame interval %g, setting velocity to 0.0", (uint8_t *)&v5, 0x2Au);
    }
  }
}

float MTSurfaceDimensions::convertPixelsToMillimeters(uint64_t a1, float a2)
{
  return a2 * *(float *)(a1 + 32);
}

float MTSurfaceDimensions::convertMillimetersToPixels(uint64_t a1, float a2)
{
  return a2 * (float)(*(float *)(a1 + 24) / *(float *)(a1 + 16));
}

float MTSurfaceDimensions::convertMillimetersToSurfaceFraction(uint64_t a1, float a2)
{
  return a2 / *(float *)(a1 + 16);
}

float MTSurfaceDimensions::convertSurfaceFractionToPixels(uint64_t a1, float a2)
{
  return a2 * *(float *)(a1 + 24);
}

float MTSurfaceDimensions::convertSurfaceFractionToMillimeters(uint64_t a1, float a2)
{
  return a2 * *(float *)(a1 + 16);
}

float MTSurfaceDimensions::convertSurfaceFractionVelocityToPixelsPerSecond(uint64_t a1, float a2)
{
  return a2 * *(float *)(a1 + 24);
}

MTSimpleHIDManager *MTMouseEmbeddedHIDManager::createManager(uint64_t a1, const void *a2, int a3, int a4)
{
  MTSimpleHIDManager *v8;

  v8 = (MTSimpleHIDManager *)operator new();
  *(_OWORD *)v8 = 0u;
  *((_OWORD *)v8 + 1) = 0u;
  *((_OWORD *)v8 + 2) = 0u;
  *((_OWORD *)v8 + 3) = 0u;
  *((_OWORD *)v8 + 4) = 0u;
  *((_OWORD *)v8 + 5) = 0u;
  *((_OWORD *)v8 + 6) = 0u;
  *((_OWORD *)v8 + 7) = 0u;
  *((_OWORD *)v8 + 8) = 0u;
  *((_OWORD *)v8 + 9) = 0u;
  *((_OWORD *)v8 + 10) = 0u;
  *((_OWORD *)v8 + 11) = 0u;
  *((_OWORD *)v8 + 12) = 0u;
  *((_OWORD *)v8 + 13) = 0u;
  *((_OWORD *)v8 + 14) = 0u;
  *((_OWORD *)v8 + 15) = 0u;
  *((_OWORD *)v8 + 16) = 0u;
  *((_OWORD *)v8 + 17) = 0u;
  *((_OWORD *)v8 + 18) = 0u;
  *((_OWORD *)v8 + 19) = 0u;
  *((_OWORD *)v8 + 20) = 0u;
  *((_OWORD *)v8 + 21) = 0u;
  *((_OWORD *)v8 + 22) = 0u;
  *((_OWORD *)v8 + 23) = 0u;
  *((_OWORD *)v8 + 24) = 0u;
  MTSimpleHIDManager::MTSimpleHIDManager(v8);
  *(_QWORD *)v8 = &off_24FFF10C8;
  MTMouseHIDManager::initialize(v8, a1, a2, a3, a4);
  return v8;
}

void sub_23108E25C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10A1C40899DFB1ALL);
  _Unwind_Resume(a1);
}

unsigned int *MTMouseEmbeddedHIDManager::createEventDispatcher(MTMouseEmbeddedHIDManager *this)
{
  const void *v2;
  unsigned int *Dispatcher;

  v2 = (const void *)(*(uint64_t (**)(MTMouseEmbeddedHIDManager *))(*(_QWORD *)this + 80))(this);
  Dispatcher = (unsigned int *)MTMouseEmbeddedEventDispatcher::createDispatcher(this, v2);
  (*(void (**)(MTMouseEmbeddedHIDManager *, unsigned int *))(*(_QWORD *)this + 128))(this, Dispatcher);
  return MTSimpleEventDispatcher::release(Dispatcher);
}

uint64_t MTMouseEmbeddedHIDManager::getUserPrefs(uint64_t a1, _QWORD *a2)
{
  *a2 = 0;
  return 0;
}

uint64_t MTMouseEmbeddedHIDManager::setDeviceDefaultProperties(MTMouseEmbeddedHIDManager *this)
{
  if ((*((_BYTE *)this + 160) & 0x20) != 0)
    (*(void (**)(MTMouseEmbeddedHIDManager *))(*(_QWORD *)this + 352))(this);
  *((_BYTE *)this + 126) = 1;
  return (*(uint64_t (**)(MTMouseEmbeddedHIDManager *))(*(_QWORD *)this + 744))(this);
}

const void *MTMouseEmbeddedHIDManager::setDeviceAccelerationData(MTMouseEmbeddedHIDManager *this, CFDictionaryRef theDict)
{
  const void *Value;

  Value = CFDictionaryGetValue(theDict, CFSTR("HIDPointerAccelerationMultiplier"));
  if (Value)
    (*(void (**)(MTMouseEmbeddedHIDManager *, const __CFString *, const void *))(*(_QWORD *)this + 568))(this, CFSTR("HIDPointerAccelerationMultiplier"), Value);
  return MTTrackpadHIDManager::setDeviceAccelerationData(this, theDict);
}

uint64_t MTMouseEmbeddedHIDManager::setPropertyInternal(MTSimpleHIDManager *a1, int a2, const __CFString *cf, int a4)
{
  CFTypeID v8;
  CFTypeID v9;
  __CFDictionary *Mutable;
  __CFDictionary *v11;
  io_registry_entry_t Service;
  kern_return_t v13;
  NSObject *v14;
  uint64_t result;
  int v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  kern_return_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  if (a2 == 83)
  {
    if (cf)
      goto LABEL_7;
    return MTTrackpadHIDManager::setPropertyInternal(a1, a2, cf, a4);
  }
  if (a2 != 81 || !cf)
    return MTTrackpadHIDManager::setPropertyInternal(a1, a2, cf, a4);
  v8 = CFGetTypeID(cf);
  if (v8 == CFNumberGetTypeID())
    return 1;
LABEL_7:
  v9 = CFGetTypeID(cf);
  if (v9 != CFStringGetTypeID()
    || CFStringCompare(cf, CFSTR("TwoButton"), 0)
    && CFStringCompare(cf, CFSTR("TwoButtonSwapped"), 0)
    && CFStringCompare(cf, CFSTR("OneButton"), 0))
  {
    return MTTrackpadHIDManager::setPropertyInternal(a1, a2, cf, a4);
  }
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 1, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
    return MTTrackpadHIDManager::setPropertyInternal(a1, a2, cf, a4);
  v11 = Mutable;
  CFDictionarySetValue(Mutable, CFSTR("MouseButtonMode"), cf);
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 80))(a1);
  Service = MTDeviceGetService();
  v13 = IORegistryEntrySetCFProperty(Service, CFSTR("MouseUserPreferences"), v11);
  CFRelease(v11);
  if (!v13)
    return 1;
  v14 = MTLoggingPlugin();
  result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  if ((_DWORD)result)
  {
    v16 = 136315906;
    v17 = "[Error] ";
    v18 = 2080;
    v19 = "";
    v20 = 2080;
    v21 = "setPropertyInternal";
    v22 = 1024;
    v23 = v13;
    _os_log_impl(&dword_231071000, v14, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Could not set mouse user preferences on the driver 0x%08X", (uint8_t *)&v16, 0x26u);
    return 0;
  }
  return result;
}

void MTMouseEmbeddedHIDManager::~MTMouseEmbeddedHIDManager(MTMouseEmbeddedHIDManager *this)
{
  MTSimpleHIDManager::~MTSimpleHIDManager(this);
  JUMPOUT(0x2348D0034);
}

void MTSLGLogger::MTSLGLogger(MTSLGLogger *this)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
}

{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
}

void MTSLGLogger::~MTSLGLogger(MTSLGLogger *this)
{
  MTSLGLogger::unregisterControlInterface(this);
  if (*(_QWORD *)this)
    dlclose(*(void **)this);
}

void MTSLGLogger::unregisterControlInterface(MTSLGLogger *this)
{
  io_object_t v2;
  IONotificationPort *v3;

  v2 = *((_DWORD *)this + 6);
  if (v2)
  {
    IOObjectRelease(v2);
    *((_DWORD *)this + 6) = 0;
  }
  v3 = (IONotificationPort *)*((_QWORD *)this + 2);
  if (v3)
  {
    IONotificationPortDestroy(v3);
    *((_QWORD *)this + 2) = 0;
  }
  MTSLGLogger::removeControlService(this);
  *((_QWORD *)this + 1) = 0;
}

uint64_t MTSLGLogger::createLogger(MTSLGLogger *this)
{
  uint64_t v1;

  if (!MGGetBoolAnswer())
    return 0;
  v1 = operator new();
  *(_QWORD *)(v1 + 8) = 0;
  *(_QWORD *)(v1 + 16) = 0;
  *(_QWORD *)v1 = 0;
  *(_DWORD *)(v1 + 24) = 0;
  *(_QWORD *)(v1 + 32) = 0;
  *(_QWORD *)(v1 + 40) = 0;
  if ((MTSLGLogger::prepare((MTSLGLogger *)v1) & 1) == 0)
  {
    MTSLGLogger::~MTSLGLogger((MTSLGLogger *)v1);
    MEMORY[0x2348D0034]();
    return 0;
  }
  return v1;
}

uint64_t MTSLGLogger::prepare(MTSLGLogger *this)
{
  uint64_t result;
  NSObject *v3;
  uint8_t v4[16];

  result = (uint64_t)dlopen((const char *)objc_msgSend(CFSTR("/System/Library/PrivateFrameworks/StudyLog.framework/StudyLog"), "UTF8String"), 1);
  *(_QWORD *)this = result;
  if (result)
  {
    if (MTSLGLogger::prepare(void)::onceToken != -1)
      dispatch_once(&MTSLGLogger::prepare(void)::onceToken, &__block_literal_global);
    if (SLGLogClass)
    {
      v3 = MTLoggingPlugin();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v4 = 0;
        _os_log_impl(&dword_231071000, v3, OS_LOG_TYPE_DEFAULT, "StudyLog logger: prepared", v4, 2u);
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void MTSLGLogger::registerControlInterface(IONotificationPort **this, NSObject *a2)
{
  NSObject *v4;
  IONotificationPort *v5;
  IONotificationPort *v6;
  const __CFDictionary *v7;
  io_iterator_t *v8;
  kern_return_t v9;
  NSObject *v10;
  NSObject *v11;
  uint8_t v12[16];

  v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v12 = 0;
    _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_DEFAULT, "StudyLog logger: register for control interface", v12, 2u);
  }
  MTSLGLogger::unregisterControlInterface((MTSLGLogger *)this);
  this[1] = (IONotificationPort *)a2;
  v5 = IONotificationPortCreate(0);
  this[2] = v5;
  if (v5)
  {
    IONotificationPortSetDispatchQueue(v5, a2);
    v6 = this[2];
    v7 = IOServiceNameMatching("AppleMultitouchDevice");
    v8 = (io_iterator_t *)(this + 3);
    v9 = IOServiceAddMatchingNotification(v6, "IOServiceFirstMatch", v7, (IOServiceMatchingCallback)MTSLGLoggerControlServiceMatchedCallback, this, (io_iterator_t *)this + 6);
    if (v9 || !*v8)
    {
      v10 = MTLoggingPlugin();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        MTSLGLogger::registerControlInterface((unsigned int *)this + 6, v9, v10);
      IONotificationPortDestroy(this[2]);
      this[2] = 0;
    }
    else
    {
      MTSLGLoggerControlServiceMatchedCallback((MTSLGLogger *)this, *v8);
    }
  }
  else
  {
    v11 = MTLoggingPlugin();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      MTSLGLogger::registerControlInterface();
  }
}

uint64_t MTSLGLoggerControlServiceMatchedCallback(MTSLGLogger *a1, io_iterator_t iterator)
{
  uint64_t result;
  const __CFAllocator *v4;
  io_object_t v5;
  const __CFArray *CFProperty;
  const __CFArray *v7;
  CFIndex v8;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *Value;
  const __CFNumber *v11;
  uint64_t valuePtr;

  result = IOIteratorIsValid(iterator);
  if ((_DWORD)result)
  {
    v4 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    do
    {
      result = IOIteratorNext(iterator);
      if (!(_DWORD)result)
        break;
      v5 = result;
      CFProperty = (const __CFArray *)IORegistryEntryCreateCFProperty(result, CFSTR("DeviceUsagePairs"), v4, 0);
      if (CFProperty)
      {
        v7 = CFProperty;
        if (CFArrayGetCount(CFProperty) < 1)
        {
LABEL_12:
          CFRelease(v7);
        }
        else
        {
          v8 = 0;
          while (1)
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v7, v8);
            Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("DeviceUsagePage"));
            v11 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("DeviceUsage"));
            valuePtr = 0;
            CFNumberGetValue(Value, kCFNumberSInt32Type, (char *)&valuePtr + 4);
            CFNumberGetValue(v11, kCFNumberSInt32Type, &valuePtr);
            if (HIDWORD(valuePtr) == 13 && (_DWORD)valuePtr == 0)
              break;
            if (++v8 >= CFArrayGetCount(v7))
              goto LABEL_12;
          }
          CFRelease(v7);
          MTSLGLogger::addControlService(a1);
        }
      }
      IOObjectRelease(v5);
      result = IOIteratorIsValid(iterator);
    }
    while ((_DWORD)result);
  }
  return result;
}

void MTSLGLogger::removeControlService(MTSLGLogger *this)
{
  NSObject *v2;

  if (*((_QWORD *)this + 4))
  {
    MTDeviceStop();
    MTDeviceRelease();
    *((_QWORD *)this + 4) = 0;
  }
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    dispatch_source_cancel(v2);
    *((_QWORD *)this + 5) = 0;
  }
}

void MTSLGLogger::addControlService(MTSLGLogger *this)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  uint64_t MultitouchDispatchSource;
  NSObject *v6;
  int v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  uint8_t v11[16];

  v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v11 = 0;
    _os_log_impl(&dword_231071000, v2, OS_LOG_TYPE_DEFAULT, "StudyLog logger: control interface service appeared", v11, 2u);
  }
  MTSLGLogger::removeControlService(this);
  v3 = MTDeviceCreateFromService();
  *((_QWORD *)this + 4) = v3;
  if (!v3)
  {
    v6 = MTLoggingPlugin();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      MTSLGLogger::addControlService();
    goto LABEL_16;
  }
  v4 = MTDeviceStart();
  if (v4)
  {
    v7 = v4;
    v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      MTSLGLogger::addControlService(v7, v8);
    goto LABEL_16;
  }
  MultitouchDispatchSource = MTDeviceCreateMultitouchDispatchSource();
  *((_QWORD *)this + 5) = MultitouchDispatchSource;
  if (!MultitouchDispatchSource)
  {
    v9 = MTLoggingPlugin();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      MTSLGLogger::addControlService();
    goto LABEL_16;
  }
  if ((MTRegisterProcessedFrameCallback() & 1) == 0)
  {
    v10 = MTLoggingPlugin();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      MTSLGLogger::addControlService();
LABEL_16:
    MTSLGLogger::removeControlService(this);
  }
}

void MTSLGLoggerProcessedFrameCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  uint64_t v6;

  if (*(_DWORD *)(a2 + 3128))
  {
    v5 = 0;
    v6 = a2 + 3136;
    do
    {
      MTSLGLogger::logImages(a3, *(_QWORD *)(v6 + 8 * v5) + 40, *(_QWORD *)(v6 + 8 * v5));
      ++v5;
    }
    while (v5 < *(unsigned int *)(a2 + 3128));
  }
}

void *MTSLGLogger::isSLGEnabled(MTSLGLogger *this)
{
  SEL v1;
  SEL v2;
  void *result;

  v1 = NSSelectorFromString(CFSTR("sharedInstance"));
  v2 = NSSelectorFromString(CFSTR("isEnabled"));
  result = (void *)objc_msgSend((id)SLGLogClass, "performSelector:", v1);
  if (result)
    return (void *)(objc_msgSend(result, "performSelector:", v2) != 0);
  return result;
}

MTSLGLogger *MTSLGLogger::logString(MTSLGLogger *this, const __CFString *a2)
{
  SEL v3;
  MTSLGLogger *result;
  MTSLGLogger *v5;

  v3 = NSSelectorFromString(CFSTR("sharedInstance"));
  result = (MTSLGLogger *)NSSelectorFromString(CFSTR("log:"));
  if (a2 && SLGLogClass)
  {
    v5 = result;
    result = (MTSLGLogger *)MTSLGLogger::isSLGEnabled(result);
    if ((_DWORD)result)
      return (MTSLGLogger *)objc_msgSend((id)objc_msgSend((id)SLGLogClass, "performSelector:", v3), "performSelector:withObject:", v5, a2);
  }
  return result;
}

void MTSLGLogger::logPaths(uint64_t a1, uint64_t a2, unsigned int a3)
{
  SEL v5;
  MTSLGLogger *v6;
  MTSLGLogger *v7;
  void *v8;
  void *PathsDescriptor;
  const void *v10;

  v5 = NSSelectorFromString(CFSTR("sharedInstance"));
  v6 = (MTSLGLogger *)NSSelectorFromString(CFSTR("log:"));
  if (a3)
  {
    if (a2)
    {
      if (SLGLogClass)
      {
        v7 = v6;
        if (MTSLGLogger::isSLGEnabled(v6))
        {
          v8 = (void *)MEMORY[0x2348D0388]();
          PathsDescriptor = MTSLGLogger::createPathsDescriptor((uint64_t)v8, a2, a3);
          if (PathsDescriptor)
          {
            v10 = PathsDescriptor;
            objc_msgSend((id)objc_msgSend((id)SLGLogClass, "performSelector:", v5), "performSelector:withObject:", v7, PathsDescriptor);
            CFRelease(v10);
          }
          objc_autoreleasePoolPop(v8);
        }
      }
    }
  }
}

void *MTSLGLogger::createPathsDescriptor(uint64_t a1, uint64_t a2, unsigned int a3)
{
  void *v3;
  uint64_t v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  uint64_t v23;
  _QWORD v25[22];
  _QWORD v26[24];

  v3 = 0;
  v26[22] = *MEMORY[0x24BDAC8D0];
  if (a3 && a2 && SLGLogClass)
  {
    v3 = (void *)objc_opt_new();
    v6 = 0;
    do
    {
      v25[0] = CFSTR("frame_number");
      v26[0] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithLong:", *(_QWORD *)(a2 + v6));
      v25[1] = CFSTR("device_timestamp");
      v7 = *(double *)(a2 + v6 + 8);
      *(float *)&v7 = v7;
      v26[1] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v7);
      v25[2] = CFSTR("path_id");
      v26[2] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", *(unsigned int *)(a2 + v6 + 16));
      v25[3] = CFSTR("path_stage");
      v26[3] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", *(unsigned int *)(a2 + v6 + 20));
      v25[4] = CFSTR("finger_id");
      v26[4] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", *(unsigned int *)(a2 + v6 + 24));
      v25[5] = CFSTR("hand_id");
      v26[5] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", *(unsigned int *)(a2 + v6 + 28));
      v25[6] = CFSTR("position_x");
      LODWORD(v8) = *(_DWORD *)(a2 + v6 + 32);
      v26[6] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v8);
      v25[7] = CFSTR("position_y");
      LODWORD(v9) = *(_DWORD *)(a2 + v6 + 36);
      v26[7] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v9);
      v25[8] = CFSTR("velocity_x");
      LODWORD(v10) = *(_DWORD *)(a2 + v6 + 40);
      v26[8] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v10);
      v25[9] = CFSTR("velocity_y");
      LODWORD(v11) = *(_DWORD *)(a2 + v6 + 44);
      v26[9] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v11);
      v25[10] = CFSTR("proximity");
      LODWORD(v12) = *(_DWORD *)(a2 + v6 + 48);
      v26[10] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v12);
      v25[11] = CFSTR("force");
      LODWORD(v13) = *(_DWORD *)(a2 + v6 + 52);
      v26[11] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v13);
      v25[12] = CFSTR("orientation");
      LODWORD(v14) = *(_DWORD *)(a2 + v6 + 56);
      v26[12] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v14);
      v25[13] = CFSTR("major_radius_mm");
      LODWORD(v15) = *(_DWORD *)(a2 + v6 + 60);
      v26[13] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v15);
      v25[14] = CFSTR("minor_radius_mm");
      LODWORD(v16) = *(_DWORD *)(a2 + v6 + 64);
      v26[14] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v16);
      v25[15] = CFSTR("position_mm_x");
      LODWORD(v17) = *(_DWORD *)(a2 + v6 + 68);
      v26[15] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v17);
      v25[16] = CFSTR("position_mm_y");
      LODWORD(v18) = *(_DWORD *)(a2 + v6 + 72);
      v26[16] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v18);
      v25[17] = CFSTR("velocity_mm_s_x");
      LODWORD(v19) = *(_DWORD *)(a2 + v6 + 76);
      v26[17] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v19);
      v25[18] = CFSTR("velocity_mm_s_y");
      LODWORD(v20) = *(_DWORD *)(a2 + v6 + 80);
      v26[18] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v20);
      v25[19] = CFSTR("path_flags");
      v26[19] = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("0x%x"), *(unsigned __int16 *)(a2 + v6 + 84));
      v25[20] = CFSTR("tilt");
      LODWORD(v21) = *(_DWORD *)(a2 + v6 + 88);
      v26[20] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v21);
      v25[21] = CFSTR("zdensity");
      LODWORD(v22) = *(_DWORD *)(a2 + v6 + 92);
      v26[21] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v22);
      v23 = objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v26, v25, 22);
      objc_msgSend(v3, "setObject:forKey:", v23, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("path%d"), *(unsigned int *)(a2 + v6 + 16)));
      v6 += 96;
    }
    while (96 * a3 != v6);
  }
  return v3;
}

void MTSLGLogger::logImages(uint64_t a1, uint64_t a2, uint64_t a3)
{
  SEL v5;
  MTSLGLogger *v6;
  MTSLGLogger *v7;
  void *v8;
  uint64_t ImageDictionary;

  v5 = NSSelectorFromString(CFSTR("sharedInstance"));
  v6 = (MTSLGLogger *)NSSelectorFromString(CFSTR("log:"));
  if (a3)
  {
    if (a2)
    {
      if (SLGLogClass)
      {
        v7 = v6;
        if (MTSLGLogger::isSLGEnabled(v6))
        {
          v8 = (void *)MEMORY[0x2348D0388]();
          ImageDictionary = MTSLGLogger::createImageDictionary((uint64_t)v8, a2, a3);
          if (ImageDictionary)
            objc_msgSend((id)objc_msgSend((id)SLGLogClass, "performSelector:", v5), "performSelector:withObject:", v7, ImageDictionary);
          objc_autoreleasePoolPop(v8);
        }
      }
    }
  }
}

uint64_t MTSLGLogger::createImageDictionary(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  void *v5;
  double v6;
  _QWORD v7[11];
  _QWORD v8[12];

  v8[11] = *MEMORY[0x24BDAC8D0];
  result = objc_msgSend(MEMORY[0x24BDBCE50], "dataWithBytesNoCopy:length:freeWhenDone:", a2, 2 * *(__int16 *)(a3 + 16) * (uint64_t)*(__int16 *)(a3 + 18), 0);
  if (result)
  {
    v5 = (void *)result;
    v7[0] = CFSTR("frame_number");
    v8[0] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithLong:", *(_QWORD *)a3);
    v7[1] = CFSTR("device_timestamp");
    v6 = *(double *)(a3 + 8);
    *(float *)&v6 = v6;
    v8[1] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v6);
    v7[2] = CFSTR("width");
    v8[2] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithShort:", *(__int16 *)(a3 + 16));
    v7[3] = CFSTR("height");
    v8[3] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithShort:", *(__int16 *)(a3 + 18));
    v7[4] = CFSTR("image_region_mask");
    v8[4] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", *(unsigned int *)(a3 + 20));
    v7[5] = CFSTR("processing_step_mask");
    v8[5] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", *(unsigned int *)(a3 + 24));
    v7[6] = CFSTR("valid_pixel_ceiling");
    v8[6] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", *(unsigned int *)(a3 + 28));
    v7[7] = CFSTR("valid_pixel_floor");
    v8[7] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", *(unsigned int *)(a3 + 32));
    v7[8] = CFSTR("fullscale_range");
    v8[8] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedShort:", *(unsigned __int16 *)(a3 + 36));
    v7[9] = CFSTR("row0_at_bottom");
    v8[9] = objc_msgSend(MEMORY[0x24BDD1518], "numberWithBool:", *(unsigned __int8 *)(a3 + 38));
    v7[10] = CFSTR("image");
    v8[10] = objc_msgSend(v5, "base64EncodedStringWithOptions:", 0);
    return objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v8, v7, 11);
  }
  return result;
}

Class ___ZN11MTSLGLogger7prepareEv_block_invoke()
{
  Class result;

  result = NSClassFromString(CFSTR("SLGLog"));
  SLGLogClass = (uint64_t)result;
  return result;
}

void OUTLINED_FUNCTION_0_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

double MTPListGestureConfig::MTPListGestureConfig(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v5;
  double result;

  v5 = MTGestureConfig::MTGestureConfig(a1, a2, a3, a4, a5);
  *v5 = &off_24FFF14D8;
  result = 0.0;
  *((_OWORD *)v5 + 5) = 0u;
  *((_OWORD *)v5 + 6) = 0u;
  v5[14] = 0;
  return result;
}

{
  _QWORD *v5;
  double result;

  v5 = MTGestureConfig::MTGestureConfig(a1, a2, a3, a4, a5);
  *v5 = &off_24FFF14D8;
  result = 0.0;
  *((_OWORD *)v5 + 5) = 0u;
  *((_OWORD *)v5 + 6) = 0u;
  v5[14] = 0;
  return result;
}

void MTPListGestureConfig::~MTPListGestureConfig(MTPListGestureConfig *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  *(_QWORD *)this = &off_24FFF14D8;
  v2 = (const void *)*((_QWORD *)this + 10);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 10) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 11);
  if (v3)
  {
    CFRelease(v3);
    *((_QWORD *)this + 11) = 0;
  }
  v4 = (const void *)*((_QWORD *)this + 12);
  if (v4)
  {
    CFRelease(v4);
    *((_QWORD *)this + 12) = 0;
  }
  v5 = (const void *)*((_QWORD *)this + 13);
  if (v5)
  {
    CFRelease(v5);
    *((_QWORD *)this + 13) = 0;
  }
  v6 = (const void *)*((_QWORD *)this + 14);
  if (v6)
  {
    CFRelease(v6);
    *((_QWORD *)this + 14) = 0;
  }
  MTGestureConfig::~MTGestureConfig(this);
}

{
  MTPListGestureConfig::~MTPListGestureConfig(this);
  JUMPOUT(0x2348D0034);
}

void MTPListGestureConfig::setParseErrorString(MTPListGestureConfig *this, CFStringRef theString)
{
  const __CFString *v3;
  const char *CStringPtr;

  v3 = (const __CFString *)*((_QWORD *)this + 14);
  if (v3 != theString)
  {
    if (v3)
      CFRelease(v3);
    *((_QWORD *)this + 14) = theString;
    if (theString)
    {
      CStringPtr = CFStringGetCStringPtr(theString, 0);
      printf("%s", CStringPtr);
    }
  }
}

CFComparisonResult MTPListGestureConfig::eventTypeCFStringToCode(MTPListGestureConfig *this, CFStringRef theString1)
{
  CFComparisonResult result;

  if (!theString1)
    return 0;
  if (CFStringCompare(theString1, CFSTR("Mouse Point"), 1uLL) == kCFCompareEqualTo)
    return 68;
  if (CFStringCompare(theString1, CFSTR("Mouse Down"), 1uLL) == kCFCompareEqualTo)
    return 65;
  if (CFStringCompare(theString1, CFSTR("Mouse Up"), 1uLL) == kCFCompareEqualTo)
    return 66;
  if (CFStringCompare(theString1, CFSTR("Mouse Click"), 1uLL) == kCFCompareEqualTo)
    return 67;
  if (CFStringCompare(theString1, CFSTR("Mouse Double Click"), 1uLL) == kCFCompareEqualTo)
    return 72;
  if (CFStringCompare(theString1, CFSTR("Mouse Drag"), 1uLL) == kCFCompareEqualTo)
    return 69;
  if (CFStringCompare(theString1, CFSTR("Scroll"), 1uLL) == kCFCompareEqualTo)
    return 70;
  if (CFStringCompare(theString1, CFSTR("Scroll To Edge"), 1uLL) == kCFCompareEqualTo)
    return 78;
  if (CFStringCompare(theString1, CFSTR("Orientation"), 1uLL) == kCFCompareEqualTo)
    return 71;
  if (CFStringCompare(theString1, CFSTR("Zoom Toggle"), 1uLL) == kCFCompareEqualTo)
    return 73;
  if (CFStringCompare(theString1, CFSTR("Key Down"), 1uLL) == kCFCompareEqualTo)
    return 129;
  if (CFStringCompare(theString1, CFSTR("Key Up"), 1uLL) == kCFCompareEqualTo)
    return 130;
  if (CFStringCompare(theString1, CFSTR("Key Stroke"), 1uLL) == kCFCompareEqualTo)
    return 128;
  if (CFStringCompare(theString1, CFSTR("Swipe"), 1uLL) == kCFCompareEqualTo)
    return 133;
  if (CFStringCompare(theString1, CFSTR("Fluid Navigation"), 1uLL) == kCFCompareEqualTo)
    return 36;
  if (CFStringCompare(theString1, CFSTR("Fluid Dock"), 1uLL) == kCFCompareEqualTo)
    return 37;
  if (CFStringCompare(theString1, CFSTR("Fluid Notification"), 1uLL) == kCFCompareEqualTo)
    return 38;
  if (CFStringCompare(theString1, CFSTR("Fluid Notification Alt"), 1uLL) == kCFCompareEqualTo)
    return 39;
  if (CFStringCompare(theString1, CFSTR("Show Definition"), 1uLL) == kCFCompareEqualTo)
    return 140;
  if (CFStringCompare(theString1, CFSTR("Key Consumer App"), 1uLL) == kCFCompareEqualTo
    || CFStringCompare(theString1, CFSTR("Symbolic Hotkey"), 1uLL) == kCFCompareEqualTo)
  {
    return 134;
  }
  if (CFStringCompare(theString1, CFSTR("System"), 1uLL) == kCFCompareEqualTo)
    return 135;
  if (CFStringCompare(theString1, CFSTR("Gesture Ended"), 1uLL) == kCFCompareEqualTo)
    return 32;
  if (CFStringCompare(theString1, CFSTR("Gesture Started"), 1uLL) == kCFCompareEqualTo)
    return 33;
  result = CFStringCompare(theString1, CFSTR("Window Move"), 1uLL);
  if (result)
  {
    CFStringCompare(theString1, CFSTR("Window Size"), 1uLL);
    return 0;
  }
  return result;
}

uint64_t MTPListGestureConfig::keyCodeCFStringToCode(MTPListGestureConfig *this, CFStringRef theString1)
{
  uint64_t v3;
  const __CFString *v4;

  v3 = 0;
  while (1)
  {
    v4 = (const __CFString *)gUSBKeyNames[v3];
    if (v4)
    {
      if (CFStringCompare(theString1, v4, 1uLL) == kCFCompareEqualTo)
        break;
    }
    if (++v3 == 256)
    {
      LOWORD(v3) = 0;
      return (unsigned __int16)v3;
    }
  }
  return (unsigned __int16)v3;
}

uint64_t MTPListGestureConfig::modifiersCFStringToMask(MTPListGestureConfig *this, const __CFString *cf)
{
  CFTypeID v3;
  unsigned int v4;

  if (!cf)
    return 0;
  v3 = CFGetTypeID(cf);
  if (v3 != CFStringGetTypeID())
    return 0;
  if (CFStringFind(cf, CFSTR("Shift"), 1uLL).location == -1)
    v4 = 0;
  else
    v4 = 34;
  if (CFStringFind(cf, CFSTR("Cmd"), 1uLL).location != -1)
    v4 |= 0x88u;
  if (CFStringFind(cf, CFSTR("Alt"), 1uLL).location != -1)
    v4 |= 0x44u;
  if (CFStringFind(cf, CFSTR("Ctrl"), 1uLL).location != -1)
    v4 |= 0x11u;
  if (CFStringFind(cf, CFSTR("Button1"), 1uLL).location != -1)
    v4 |= 0x100u;
  if (CFStringFind(cf, CFSTR("Button2"), 1uLL).location != -1)
    v4 |= 0x200u;
  if (CFStringFind(cf, CFSTR("Button3"), 1uLL).location != -1)
    v4 |= 0x400u;
  if (CFStringFind(cf, CFSTR("Button4"), 1uLL).location != -1)
    v4 |= 0x800u;
  if (CFStringFind(cf, CFSTR("Button5"), 1uLL).location != -1)
    v4 |= 0x1000u;
  if (CFStringFind(cf, CFSTR("Button6"), 1uLL).location != -1)
    v4 |= 0x2000u;
  if (CFStringFind(cf, CFSTR("Button7"), 1uLL).location == -1)
    return v4;
  else
    return v4 | 0x4000;
}

void MTPListGestureConfig::parseCreateActionEvent(MTPListGestureConfig *a1, CFTypeRef cf, uint64_t a3)
{
  CFTypeID v6;
  const __CFString *Value;
  const __CFString *v8;
  CFTypeID v9;
  MTPListGestureConfig *TypeID;
  int v11;
  __int16 v12;
  const __CFString *v13;
  const __CFString *v14;
  CFTypeID v15;
  MTPListGestureConfig *v16;
  int v17;
  const __CFString *v18;
  CFTypeID v19;
  const __CFString *v20;
  const __CFString *v21;
  const __CFString *v22;
  CFTypeID v23;
  MTPListGestureConfig *v24;
  __int16 v25;
  CFTypeID v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  int valuePtr;
  __int16 v31;

  if (!cf || (v6 = CFGetTypeID(cf), v6 != CFDictionaryGetTypeID()))
  {
    v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ Action Event not a CFDictionary\n"), CFSTR("ERROR in PListGestureParser:"));
LABEL_11:
    MTPListGestureConfig::setParseErrorString(a1, v18);
    return;
  }
  v31 = 0;
  valuePtr = 0;
  Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("EventType"));
  if (!Value
    || (v8 = Value,
        v9 = CFGetTypeID(Value),
        TypeID = (MTPListGestureConfig *)CFStringGetTypeID(),
        (MTPListGestureConfig *)v9 != TypeID))
  {
    v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ Action Event missing '%@' key\n"), CFSTR("ERROR in PListGestureParser:"), CFSTR("EventType"));
    goto LABEL_11;
  }
  v11 = MTPListGestureConfig::eventTypeCFStringToCode(TypeID, v8);
  if (!v11)
  {
    v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ Unknown or unsupported %@ '%@'\n"), CFSTR("ERROR in PListGestureParser:"), CFSTR("EventType"), v8);
    goto LABEL_11;
  }
  v12 = v11;
  v13 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("Modifiers"));
  if (!v13)
    goto LABEL_17;
  v14 = v13;
  v15 = CFGetTypeID(v13);
  v16 = (MTPListGestureConfig *)CFStringGetTypeID();
  if ((MTPListGestureConfig *)v15 == v16)
  {
    v17 = MTPListGestureConfig::modifiersCFStringToMask(v16, v14);
    valuePtr = v17;
    goto LABEL_15;
  }
  v19 = CFGetTypeID(v14);
  if (v19 == CFNumberGetTypeID())
  {
    CFNumberGetValue((CFNumberRef)v14, kCFNumberSInt32Type, &valuePtr);
    v17 = valuePtr;
LABEL_15:
    if (v17)
      goto LABEL_17;
  }
  v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ Modifier '%@' not recognized\n"), CFSTR("ERROR in PListGestureParser:"), v14);
  MTPListGestureConfig::setParseErrorString(a1, v20);
LABEL_17:
  v21 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("KeyCode"));
  if (!v21)
    goto LABEL_22;
  v22 = v21;
  v23 = CFGetTypeID(v21);
  v24 = (MTPListGestureConfig *)CFStringGetTypeID();
  if ((MTPListGestureConfig *)v23 != v24)
  {
    v26 = CFGetTypeID(v22);
    if (v26 == CFNumberGetTypeID())
    {
      CFNumberGetValue((CFNumberRef)v22, kCFNumberSInt16Type, &v31);
      v25 = v31;
      goto LABEL_23;
    }
LABEL_22:
    v25 = 0;
    goto LABEL_23;
  }
  v25 = MTPListGestureConfig::keyCodeCFStringToCode(v24, v22);
  v31 = v25;
LABEL_23:
  v29 = 0xAAAAAAAAAAAAAAAALL;
  MTActionEvent::MTActionEvent((MTActionEvent *)&v29, v12, valuePtr, v25);
  v27 = *(_QWORD *)(a3 + 8);
  if (v27 >= *(_QWORD *)(a3 + 16))
  {
    v28 = std::vector<MTActionEvent>::__push_back_slow_path<MTActionEvent const&>(a3, (const MTActionEvent *)&v29);
  }
  else
  {
    MTActionEvent::MTActionEvent(*(MTActionEvent **)(a3 + 8), (const MTActionEvent *)&v29);
    v28 = v27 + 8;
    *(_QWORD *)(a3 + 8) = v27 + 8;
  }
  *(_QWORD *)(a3 + 8) = v28;
}

void sub_23108FDA0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void MTPListGestureConfig::lookupOrParseActionEvents(CFDictionaryRef *a1, CFDictionaryRef theDict, _QWORD *a3)
{
  const void *Value;
  const void *v6;
  CFTypeID v7;
  const __CFArray *v8;
  const __CFArray *v9;
  CFTypeID v10;
  CFIndex Count;
  CFIndex v12;
  CFIndex i;
  const void *ValueAtIndex;
  const __CFString *v15;

  a3[1] = *a3;
  Value = CFDictionaryGetValue(theDict, CFSTR("Action"));
  if (Value)
  {
    v6 = Value;
    v7 = CFGetTypeID(Value);
    if (v7 == CFStringGetTypeID())
    {
      v8 = (const __CFArray *)CFDictionaryGetValue(a1[13], v6);
      if (v8 && (v9 = v8, v10 = CFGetTypeID(v8), v10 == CFArrayGetTypeID()))
      {
        Count = CFArrayGetCount(v9);
        if (Count >= 1)
        {
          v12 = Count;
          for (i = 0; i != v12; ++i)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(v9, i);
            MTPListGestureConfig::parseCreateActionEvent((MTPListGestureConfig *)a1, ValueAtIndex, (uint64_t)a3);
          }
        }
      }
      else
      {
        v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ Action '%@' has no event array\n"), CFSTR("ERROR in PListGestureParser:"), v6);
        MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)a1, v15);
      }
    }
  }
}

uint64_t MTPListGestureConfig::parseGestureMotionCode(MTPListGestureConfig *this, CFDictionaryRef theDict)
{
  const __CFString *Value;
  const __CFString *v4;
  CFTypeID v5;
  uint64_t v6;
  const __CFString *v7;

  if (!theDict
    || (Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("Motion"))) == 0
    || (v4 = Value, v5 = CFGetTypeID(Value), v5 != CFStringGetTypeID()))
  {
    v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ Gesture's '%@' key missing\n"), CFSTR("ERROR in PListGestureParser:"), CFSTR("Motion"));
LABEL_32:
    MTPListGestureConfig::setParseErrorString(this, v7);
    return 0;
  }
  if (CFStringCompare(v4, CFSTR("Tap"), 1uLL) == kCFCompareEqualTo)
    return 12288;
  if (CFStringCompare(v4, CFSTR("DroppedFingerTap"), 1uLL) == kCFCompareEqualTo)
    return 24576;
  if (CFStringCompare(v4, CFSTR("DoubleTap"), 1uLL) == kCFCompareEqualTo)
    return 28672;
  if (CFStringCompare(v4, CFSTR("Hold"), 1uLL) == kCFCompareEqualTo)
    return 4096;
  if (CFStringCompare(v4, CFSTR("Lift"), 1uLL) == kCFCompareEqualTo)
    return 0x2000;
  if (CFStringCompare(v4, CFSTR("Translate"), 1uLL) == kCFCompareEqualTo)
    return 15;
  if (CFStringCompare(v4, CFSTR("Horizontal"), 1uLL) == kCFCompareEqualTo)
    return 3;
  if (CFStringCompare(v4, CFSTR("Vertical"), 1uLL) == kCFCompareEqualTo)
    return 12;
  if (CFStringCompare(v4, CFSTR("Down"), 1uLL) == kCFCompareEqualTo)
    return 8;
  if (CFStringCompare(v4, CFSTR("Up"), 1uLL) == kCFCompareEqualTo)
    return 4;
  if (CFStringCompare(v4, CFSTR("Left"), 1uLL) == kCFCompareEqualTo)
    return 2;
  v6 = 1;
  if (CFStringCompare(v4, CFSTR("Right"), 1uLL))
  {
    if (CFStringCompare(v4, CFSTR("LowerLeft"), 1uLL) == kCFCompareEqualTo)
      return 10;
    if (CFStringCompare(v4, CFSTR("LowerRight"), 1uLL) == kCFCompareEqualTo)
      return 9;
    if (CFStringCompare(v4, CFSTR("UpperLeft"), 1uLL) == kCFCompareEqualTo)
      return 6;
    if (CFStringCompare(v4, CFSTR("UpperRight"), 1uLL) == kCFCompareEqualTo)
      return 5;
    if (CFStringCompare(v4, CFSTR("Scale"), 1uLL) == kCFCompareEqualTo)
      return 48;
    if (CFStringCompare(v4, CFSTR("Expand"), 1uLL) == kCFCompareEqualTo)
      return 16;
    if (CFStringCompare(v4, CFSTR("Contract"), 1uLL) == kCFCompareEqualTo)
      return 32;
    if (CFStringCompare(v4, CFSTR("Rotate"), 1uLL) == kCFCompareEqualTo)
      return 192;
    if (CFStringCompare(v4, CFSTR("RotateLeft"), 1uLL) == kCFCompareEqualTo)
      return 64;
    if (CFStringCompare(v4, CFSTR("RotateRight"), 1uLL) == kCFCompareEqualTo)
      return 128;
    if (CFStringCompare(v4, CFSTR("Scale+Rotate"), 1uLL) == kCFCompareEqualTo)
      return 240;
    if (CFStringCompare(v4, CFSTR("Translate+Scale"), 1uLL) == kCFCompareEqualTo)
      return 63;
    if (CFStringCompare(v4, CFSTR("Translate+Rotate"), 1uLL) == kCFCompareEqualTo)
      return 207;
    if (CFStringCompare(v4, CFSTR("Translate+Scale+Rotate"), 1uLL) == kCFCompareEqualTo)
      return 255;
    v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ Unrecognized gesture %@ '%@'\n"), CFSTR("ERROR in PListGestureParser:"), CFSTR("Motion"), v4);
    goto LABEL_32;
  }
  return v6;
}

uint64_t MTPListGestureConfig::parseFloatValue(MTPListGestureConfig *this, CFDictionaryRef theDict, const __CFString *key, float *a4, const __CFString *a5)
{
  uint64_t result;
  const __CFNumber *v10;
  CFTypeID v11;
  const __CFString *v12;

  result = (uint64_t)CFDictionaryGetValue(theDict, key);
  if (result)
  {
    v10 = (const __CFNumber *)result;
    v11 = CFGetTypeID((CFTypeRef)result);
    if (v11 == CFNumberGetTypeID())
    {
      if (CFNumberGetValue(v10, kCFNumberFloat32Type, a4))
        return 1;
      v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ Corrupt %@ value in %@\n"), CFSTR("ERROR in PListGestureParser:"), key, a5);
    }
    else
    {
      v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ %@ value should be a number in %@\n"), CFSTR("ERROR in PListGestureParser:"), key, a5);
    }
    MTPListGestureConfig::setParseErrorString(this, v12);
    return 0;
  }
  return result;
}

MTPListGestureConfig *MTPListGestureConfig::parseMotionSensitivity(MTPListGestureConfig *result, const __CFDictionary *a2, uint64_t a3)
{
  MTPListGestureConfig *v5;
  float v6;
  const __CFString *v7;
  float v8;
  int v9;
  float v10;
  int v11;
  int v12;
  float v13;
  int v14;
  float v15;
  float v16;
  uint64_t v17;
  float v18;
  float v19;
  float v20;
  float v21;
  uint64_t v22;

  if (a2)
  {
    v5 = result;
    v22 = 0;
    v21 = 0.0635;
    v19 = 1.0;
    v20 = 400.0;
    if (MTPListGestureConfig::parseFloatValue(result, a2, CFSTR("Resolution_dpi"), &v20, CFSTR("Motion Sensitivity")))
    {
      if (v20 != 0.0)
      {
        v6 = 25.4 / v20;
        v21 = v6;
      }
    }
    else if ((MTPListGestureConfig::parseFloatValue(v5, a2, CFSTR("Resolution_mm"), &v21, CFSTR("Motion Sensitivity")) & 1) == 0)
    {
      puts("Missing resolution_dpi/mm key!");
      v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ Missing %@ value for Motion Sensitivity\n"), CFSTR("ERROR in PListGestureParser:"), CFSTR("Resolution_mm"));
      MTPListGestureConfig::setParseErrorString(v5, v7);
    }
    MTPListGestureConfig::parseFloatValue(v5, a2, CFSTR("CommitMultiplier"), &v19, CFSTR("Motion Sensitivity"));
    MTPListGestureConfig::parseFloatValue(v5, a2, CFSTR("CommitMultiplier"), &v19, CFSTR("Motion Sensitivity"));
    MTPListGestureConfig::parseFloatValue(v5, a2, CFSTR("AccelPower"), (float *)&v22 + 1, CFSTR("Motion Sensitivity"));
    MTPListGestureConfig::parseFloatValue(v5, a2, CFSTR("AccelThresh"), (float *)&v22, CFSTR("Motion Sensitivity"));
    v8 = v21;
    v9 = v22;
    v10 = v19;
    v11 = HIDWORD(v22);
    v18 = 0.0;
    v12 = 0;
    if (MTPListGestureConfig::parseFloatValue(v5, a2, CFSTR("FrameDecay_mm"), &v18, CFSTR("Motion Sensitivity")))v13 = v18;
    else
      v13 = 0.0;
    v17 = 0;
    v16 = 0.01;
    result = (MTPListGestureConfig *)MTPListGestureConfig::parseFloatValue(v5, a2, CFSTR("FluidAnimationStartThreshold_mm"), (float *)&v17 + 1, CFSTR("Motion Sensitivity"));
    if ((_DWORD)result
      && (result = (MTPListGestureConfig *)MTPListGestureConfig::parseFloatValue(v5, a2, CFSTR("FluidSwipeCompleteThreshold_mm"), (float *)&v17, CFSTR("Motion Sensitivity")), (_DWORD)result))
    {
      result = (MTPListGestureConfig *)MTPListGestureConfig::parseFloatValue(v5, a2, CFSTR("FluidSwipeInertiaTime_s"), &v16, CFSTR("Motion Sensitivity"));
      v14 = 0;
      v15 = 0.0;
      if ((_DWORD)result)
      {
        v12 = HIDWORD(v17);
        v14 = v17;
        v15 = v16;
      }
    }
    else
    {
      v14 = 0;
      v15 = 0.0;
    }
    *(float *)a3 = v8;
    *(float *)(a3 + 4) = v10;
    *(_DWORD *)(a3 + 8) = v9;
    *(_DWORD *)(a3 + 12) = v11;
    *(float *)(a3 + 16) = v13;
    *(_DWORD *)(a3 + 20) = v12;
    *(_DWORD *)(a3 + 24) = v14;
    *(float *)(a3 + 28) = v15;
  }
  return result;
}

uint64_t MTPListGestureConfig::extractMotionSensitivity(CFDictionaryRef *a1, CFDictionaryRef theDict, _QWORD *a3)
{
  uint64_t result;
  const void *v6;
  CFTypeID v7;
  const __CFDictionary *Value;
  const __CFDictionary *v9;
  CFTypeID v10;
  MTPListGestureConfig *v11;
  const __CFDictionary *v12;
  CFTypeID v13;
  const __CFString *v14;

  *a3 = 0x3F80000000000000;
  a3[2] = 0;
  a3[3] = 0;
  a3[1] = 0;
  result = (uint64_t)CFDictionaryGetValue(theDict, CFSTR("Sensitivity"));
  if (result)
  {
    v6 = (const void *)result;
    v7 = CFGetTypeID((CFTypeRef)result);
    if (v7 == CFStringGetTypeID())
    {
      Value = (const __CFDictionary *)CFDictionaryGetValue(a1[12], v6);
      if (Value)
      {
        v9 = Value;
        v10 = CFGetTypeID(Value);
        if (v10 == CFDictionaryGetTypeID())
        {
          v11 = (MTPListGestureConfig *)a1;
          v12 = v9;
LABEL_8:
          MTPListGestureConfig::parseMotionSensitivity(v11, v12, (uint64_t)a3);
          return 1;
        }
      }
      v14 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ Motion Sensitivity dictionary '%@' not found in library\n"), CFSTR("ERROR in PListGestureParser:"), v6);
      MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)a1, v14);
    }
    else
    {
      v13 = CFGetTypeID(v6);
      if (v13 == CFDictionaryGetTypeID())
      {
        v11 = (MTPListGestureConfig *)a1;
        v12 = (const __CFDictionary *)v6;
        goto LABEL_8;
      }
    }
    return 0;
  }
  return result;
}

uint64_t MTPListGestureConfig::extractGestureCategory(MTPListGestureConfig *this, CFDictionaryRef theDict)
{
  const __CFString *Value;
  const __CFString *v4;
  CFTypeID v5;
  uint64_t v6;
  const __CFString *v7;

  Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("Category"));
  if (!Value)
    return 0;
  v4 = Value;
  v5 = CFGetTypeID(Value);
  if (v5 != CFStringGetTypeID())
    return 0;
  v6 = 1;
  if (CFStringCompare(v4, CFSTR("OneFingerPoint"), 1uLL))
  {
    if (CFStringCompare(v4, CFSTR("FiveFingerPoint"), 1uLL) == kCFCompareEqualTo)
      return 2;
    if (CFStringCompare(v4, CFSTR("TwoFingerDrag"), 1uLL) == kCFCompareEqualTo)
      return 4;
    if (CFStringCompare(v4, CFSTR("AlreadyMouse"), 1uLL) == kCFCompareEqualTo)
      return 16;
    if (CFStringCompare(v4, CFSTR("ScrollPan"), 1uLL) == kCFCompareEqualTo)
      return 64;
    if (CFStringCompare(v4, CFSTR("TwoFingerScroll"), 1uLL) == kCFCompareEqualTo)
      return 128;
    if (CFStringCompare(v4, CFSTR("TwoFingerNotificationCenter"), 1uLL) == kCFCompareEqualTo)
      return 32;
    if (CFStringCompare(v4, CFSTR("TwoFingerNotificationCenterAlt"), 1uLL) == kCFCompareEqualTo)
      return 256;
    v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ Gesture Category '%@' not supported\n"), CFSTR("ERROR in PListGestureParser:"), v4);
    MTPListGestureConfig::setParseErrorString(this, v7);
    return 0;
  }
  return v6;
}

void MTPListGestureConfig::parseGesture(CFDictionaryRef *a1, const __CFDictionary *a2, void **a3, __int128 *a4)
{
  unsigned int v8;
  const __CFString *Value;
  const __CFString *v10;
  CFTypeID v11;
  CFIndex location;
  CFIndex v13;
  CFIndex v14;
  __int16 v15;
  const __CFString *v16;
  const __CFNumber *v17;
  const __CFNumber *v18;
  CFTypeID v19;
  __int16 v20;
  int v21;
  char v22;
  float v23;
  float v24;
  const __CFString *v25;
  const __CFString *v26;
  CFTypeID v27;
  CFIndex v28;
  CFIndex v29;
  CFIndex v30;
  CFIndex v31;
  CFIndex v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  const __CFString *v36;
  const __CFString *v37;
  const __CFString *v38;
  CFTypeID v39;
  const __CFString *v40;
  void **v41;
  const __CFNumber *v42;
  const __CFNumber *v43;
  CFTypeID v44;
  __int16 v45;
  _QWORD *v46;
  __int128 v47;
  __int128 v48;
  int GestureCategory;
  char *v50;
  uint64_t v51;
  const void *v52;
  const __CFString *v53;
  CFIndex v54;
  CFIndex v55;
  CFIndex v56;
  CFIndex v57;
  CFIndex v58;
  CFIndex v59;
  CFIndex v60;
  CFIndex v61;
  CFIndex v62;
  CFIndex v63;
  CFIndex v64;
  CFIndex v65;
  CFIndex v66;
  _OWORD valuePtr[10];
  __int128 v68;
  __int128 v69;
  char *v70;
  char *v71;
  uint64_t v72;

  if (a2)
  {
    v70 = 0;
    v71 = 0;
    v72 = 0;
    MTPListGestureConfig::lookupOrParseActionEvents(a1, a2, &v70);
    v8 = MTPListGestureConfig::parseGestureMotionCode((MTPListGestureConfig *)a1, a2);
    switch((unsigned __int16)(v8 >> 12) | (unsigned __int16)(16 * v8))
    {
      case 0:
        break;
      case 1:
        Value = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("Trigger"));
        v10 = Value;
        if (Value && (v11 = CFGetTypeID(Value), v11 == CFStringGetTypeID()))
        {
          location = CFStringFind(v10, CFSTR("BeginSlide"), 1uLL).location;
          v13 = CFStringFind(v10, CFSTR("MayBegin"), 1uLL).location;
          v14 = CFStringFind(v10, CFSTR("TimeHeld"), 1uLL).location;
          if (location == -1)
            v15 = 1;
          else
            v15 = 9;
          if (v13 != -1)
            v15 |= 0x100u;
          if (v14 != -1)
            v15 |= 4u;
        }
        else
        {
          v15 = 1;
        }
        *((_WORD *)a3 + 60) = v15;
        v42 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("HoldTime"));
        v43 = v42;
        if (v42 && (v44 = CFGetTypeID(v42), v44 == CFNumberGetTypeID()))
        {
          LOWORD(valuePtr[0]) = 0;
          CFNumberGetValue(v43, kCFNumberSInt16Type, valuePtr);
          v45 = valuePtr[0];
        }
        else
        {
          v45 = 350;
        }
        *((_WORD *)a3 + 61) = v45;
        v46 = a3 + 12;
        if (a3 + 12 != (void **)&v70)
          goto LABEL_81;
        break;
      case 2:
        *((_WORD *)a3 + 76) = 2;
        v17 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("StopTime"));
        v18 = v17;
        if (v17 && (v19 = CFGetTypeID(v17), v19 == CFNumberGetTypeID()))
        {
          LOWORD(valuePtr[0]) = 0;
          CFNumberGetValue(v18, kCFNumberSInt16Type, valuePtr);
          v20 = valuePtr[0];
        }
        else
        {
          v20 = 200;
        }
        *((_WORD *)a3 + 77) = v20;
        v46 = a3 + 16;
        if (a3 + 16 != (void **)&v70)
LABEL_81:
          std::vector<MTActionEvent>::__assign_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>(v46, v70, v71, (v71 - v70) >> 3);
        break;
      case 3:
        *((_WORD *)a3 + 12) = 3;
        if (&v70 != (char **)a3)
          goto LABEL_74;
        break;
      case 6:
        *((_WORD *)a3 + 28) = 3;
        v41 = a3 + 4;
        goto LABEL_73;
      case 7:
        *((_WORD *)a3 + 44) = 3;
        v41 = a3 + 8;
LABEL_73:
        a3 = v41;
        if (v41 != (void **)&v70)
LABEL_74:
          std::vector<MTActionEvent>::__assign_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>(a3, v70, v71, (v71 - v70) >> 3);
        break;
      default:
        v21 = v8;
        if (v8 == 128 || v8 == 32)
          v21 = v8 | 0x1000000;
        v22 = v8 - 1;
        v23 = 0.0;
        v24 = 0.0;
        if ((v8 - 1) <= 0xBu)
        {
          v23 = flt_2310BD628[v22];
          v24 = flt_2310BD658[v22];
        }
        v25 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("Trigger"));
        v26 = v25;
        if (v25)
        {
          v27 = CFGetTypeID(v25);
          if (v27 == CFStringGetTypeID())
          {
            v66 = CFStringFind(v26, CFSTR("OnceOnly"), 1uLL).location;
            v65 = CFStringFind(v26, CFSTR("OncePerDirection"), 1uLL).location;
            v64 = CFStringFind(v26, CFSTR("OnceIfQuick"), 1uLL).location;
            v63 = CFStringFind(v26, CFSTR("OnlyIfQuick"), 1uLL).location;
            v62 = CFStringFind(v26, CFSTR("OnlyFromEdge"), 1uLL).location;
            v61 = CFStringFind(v26, CFSTR("IfWidelySeparatedFingers"), 1uLL).location;
            v60 = CFStringFind(v26, CFSTR("OnlyIfAllMoving"), 1uLL).location;
            v59 = CFStringFind(v26, CFSTR("OnlyIfFourMoving"), 1uLL).location;
            v58 = CFStringFind(v26, CFSTR("OnlyIfSomeMoving"), 1uLL).location;
            v57 = CFStringFind(v26, CFSTR("OnlyIfTwoMoving"), 1uLL).location;
            v56 = CFStringFind(v26, CFSTR("OnlyIfOneMoving"), 1uLL).location;
            v55 = CFStringFind(v26, CFSTR("RequiresForce"), 1uLL).location;
            v54 = CFStringFind(v26, CFSTR("WaitForQuick"), 1uLL).location;
            v28 = CFStringFind(v26, CFSTR("ToggleAlongAxis"), 1uLL).location;
            v29 = CFStringFind(v26, CFSTR("Momentum"), 1uLL).location;
            v30 = CFStringFind(v26, CFSTR("LowCommitSensitivity"), 1uLL).location;
            v31 = CFStringFind(v26, CFSTR("AccelOnlyIfSomeResting"), 1uLL).location;
            v32 = CFStringFind(v26, CFSTR("Repetitive"), 1uLL).location;
            v33 = v21 | 0x1000;
            if (v66 == -1)
              v33 = v21;
            if (v65 != -1)
              v33 |= 0x2000u;
            if (v64 != -1)
              v33 |= 0x4000u;
            if (v63 != -1)
              v33 |= 0x4000000u;
            if (v62 != -1)
              v33 |= 0x200000u;
            if (v61 != -1)
              v33 |= 0x100u;
            if (v60 != -1)
              v33 |= 0x8000000u;
            if (v59 != -1)
              v33 = v33 & 0xFFFFF1FF | 0x800;
            if (v58 != -1)
              v33 |= 0xE00u;
            v34 = v33 & 0xFFFFF1FF;
            if (v57 != -1)
              v33 = v33 & 0xFFFFF1FF | 0x400;
            v35 = v34 | 0x200;
            if (v56 != -1)
              v33 = v35;
            if (v55 != -1)
              v33 |= 0x80000000;
            if (v54 != -1)
              v33 |= 0x2000000u;
            if (v28 != -1)
              v33 |= 0x20000u;
            if (v29 != -1)
              v33 |= 0x400000u;
            if (v30 != -1)
              v33 |= 0x80000u;
            if (v31 == -1)
              v21 = v33;
            else
              v21 = v33 | 0x800000;
            if (v32 == -1 && !v21)
            {
              v36 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ Unknown Retriggering Option '%@'\n"), CFSTR("ERROR in PListGestureParser:"), v26);
              MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)a1, v36);
              v21 = 0;
            }
          }
        }
        v37 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("Locking"));
        v38 = v37;
        if (v37)
        {
          v39 = CFGetTypeID(v37);
          if (v39 == CFStringGetTypeID())
          {
            if (CFStringCompare(v38, CFSTR("LockOnAxis"), 1uLL))
            {
              if (CFStringCompare(v38, CFSTR("LockOnFirst"), 1uLL))
              {
                if (CFStringCompare(v38, CFSTR("LockOnFirstUntilPause"), 1uLL))
                {
                  if (CFStringCompare(v38, CFSTR("LockOnThrow"), 1uLL))
                  {
                    if (CFStringCompare(v38, CFSTR("LockNever"), 1uLL))
                    {
                      v40 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ Unknown Trigger Stick Option '%@'\n"), CFSTR("ERROR in PListGestureParser:"), v38);
                      MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)a1, v40);
                    }
                  }
                  else
                  {
                    v21 |= 0x400000u;
                  }
                }
                else
                {
                  v21 |= 0x40000u;
                }
              }
              else
              {
                v21 |= 0x8000u;
              }
            }
            else
            {
              v21 |= 0x10000u;
            }
          }
        }
        v47 = a4[1];
        v68 = *a4;
        v69 = v47;
        if ((MTPListGestureConfig::extractMotionSensitivity(a1, a2, &v68) & 1) == 0)
        {
          v48 = a4[1];
          v68 = *a4;
          v69 = v48;
        }
        if (*(float *)&v68 == 0.0)
        {
          v52 = CFDictionaryGetValue(a2, CFSTR("Action"));
          v53 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ No motion %@ for %@ gesture\n"), CFSTR("ERROR in PListGestureParser:"), CFSTR("Sensitivity"), v52);
          MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)a1, v53);
        }
        else
        {
          GestureCategory = MTPListGestureConfig::extractGestureCategory((MTPListGestureConfig *)a1, a2);
          valuePtr[8] = xmmword_2310BD5F0;
          valuePtr[9] = unk_2310BD600;
          valuePtr[2] = xmmword_2310BD590;
          valuePtr[3] = unk_2310BD5A0;
          valuePtr[4] = xmmword_2310BD5B0;
          memset(&valuePtr[5], 255, 48);
          memset(valuePtr, 170, 32);
          MTSlideGesture::MTSlideGesture((uint64_t)valuePtr, v21, GestureCategory, &v68, (uint64_t *)&v70, v24, v23);
          v50 = (char *)a3[21];
          if (v50 >= a3[22])
          {
            v51 = std::vector<MTSlideGesture>::__push_back_slow_path<MTSlideGesture const&>((uint64_t *)a3 + 20, (const MTSlideGesture *)valuePtr);
          }
          else
          {
            MTSlideGesture::MTSlideGesture((MTSlideGesture *)a3[21], (const MTSlideGesture *)valuePtr);
            v51 = (uint64_t)(v50 + 160);
            a3[21] = v50 + 160;
          }
          a3[21] = (void *)v51;
          if (*(_QWORD *)&valuePtr[0])
          {
            *((_QWORD *)&valuePtr[0] + 1) = *(_QWORD *)&valuePtr[0];
            operator delete(*(void **)&valuePtr[0]);
          }
        }
        break;
    }
    if (v70)
    {
      v71 = v70;
      operator delete(v70);
    }
  }
  else
  {
    v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ NULL chord or gesture dictionary\n"), CFSTR("ERROR in PListGestureParser:"));
    MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)a1, v16);
  }
}

void sub_231091154(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  uint64_t v26;
  void *v28;

  if (__p)
    operator delete(__p);
  v28 = *(void **)(v26 - 128);
  if (v28)
  {
    *(_QWORD *)(v26 - 120) = v28;
    operator delete(v28);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MTPListGestureConfig::extractChordTransitions(MTPListGestureConfig *this, CFDictionaryRef theDict)
{
  const __CFString *Value;
  const __CFString *v3;
  CFTypeID v4;
  __int16 v5;
  __int16 v6;
  unsigned __int16 v7;
  CFIndex location;
  unsigned __int16 v9;

  if (theDict)
  {
    Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("Transitions"));
    if (Value && (v3 = Value, v4 = CFGetTypeID(Value), v4 == CFStringGetTypeID()))
    {
      v5 = CFStringFind(v3, CFSTR("MultiFingerDrag"), 1uLL).location != -1;
      if (CFStringFind(v3, CFSTR("FromFewerIfPause"), 1uLL).location == -1)
        v6 = v5 << 8;
      else
        v6 = ((v5 & 1) << 8) | 4;
      if (CFStringFind(v3, CFSTR("ToFewerAfterSlightDelay"), 1uLL).location != -1)
        v6 |= 0x90u;
      if (CFStringFind(v3, CFSTR("FromMoreWithSlightIntegrationDelay"), 1uLL).location != -1)
        v6 |= 0x1001u;
      if (CFStringFind(v3, CFSTR("ToMoreFingers"), 1uLL).location != -1)
        v6 |= 0x20u;
      if (CFStringFind(v3, CFSTR("ToMoreIfPause"), 1uLL).location != -1)
        v6 |= 0x40u;
      v7 = v6 | (CFStringFind(v3, CFSTR("FromMoreFingers"), 1uLL).location != -1);
      if (CFStringFind(v3, CFSTR("FromPausedPoint"), 1uLL).location != -1)
        v7 |= 0x800u;
      if (CFStringFind(v3, CFSTR("FromRestingPoint"), 1uLL).location != -1)
        v7 |= 8u;
      if (CFStringFind(v3, CFSTR("IsRestingPoint"), 1uLL).location != -1)
        v7 |= 0x80u;
      if (CFStringFind(v3, CFSTR("ToFewerFingers"), 1uLL).location != -1)
        v7 |= 0x10u;
      location = CFStringFind(v3, CFSTR("FromFewerFingers"), 1uLL).location;
      v9 = v7 | 2;
      if (location == -1)
        return v7;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 0;
  }
  return v9;
}

void MTPListGestureConfig::parseGestureSet(MTPListGestureConfig *this, const __CFString *a2, CFTypeRef cf, MTChordGestureSet *a4)
{
  CFTypeID v8;
  MTPListGestureConfig *GestureCategory;
  const __CFArray *Value;
  uint64_t v11;
  const __CFArray *v12;
  CFTypeID v13;
  CFIndex Count;
  CFIndex v15;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const __CFString *v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;

  if (!cf || (v8 = CFGetTypeID(cf), v8 != CFDictionaryGetTypeID()))
  {
    v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ No dictionary for gesture set '%@'\n"), a4, CFSTR("ERROR in PListGestureParser:"), a2);
LABEL_13:
    MTPListGestureConfig::setParseErrorString(this, v18);
    return;
  }
  v19 = 0x3F80000000000000uLL;
  v20 = 0;
  v21 = 0;
  MTPListGestureConfig::extractMotionSensitivity((CFDictionaryRef *)this, (CFDictionaryRef)cf, &v19);
  GestureCategory = (MTPListGestureConfig *)MTPListGestureConfig::extractGestureCategory(this, (CFDictionaryRef)cf);
  if ((_DWORD)GestureCategory)
    *((_DWORD *)a4 + 58) = (_DWORD)GestureCategory;
  *((_WORD *)a4 + 114) |= MTPListGestureConfig::extractChordTransitions(GestureCategory, (CFDictionaryRef)cf);
  Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("Gestures"));
  if (!Value || (v12 = Value, v13 = CFGetTypeID(Value), v13 != CFArrayGetTypeID()))
  {
    v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ No %@ array for gesture set '%@'\n"), v11, CFSTR("ERROR in PListGestureParser:"), CFSTR("Gestures"), a2);
    goto LABEL_13;
  }
  Count = CFArrayGetCount(v12);
  if (Count >= 1)
  {
    v15 = Count;
    for (i = 0; i != v15; ++i)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v12, i);
      MTPListGestureConfig::parseGesture((CFDictionaryRef *)this, ValueAtIndex, (void **)a4, &v19);
    }
  }
}

uint64_t MTPListGestureConfig::parseChordSpecifier(MTPListGestureConfig *this, CFStringRef theString1)
{
  uint64_t v3;

  if (CFStringCompare(theString1, CFSTR("Pengrip"), 1uLL) == kCFCompareEqualTo)
    return 10;
  if (CFStringCompare(theString1, CFSTR("Fist"), 1uLL) == kCFCompareEqualTo)
    return 12;
  if (CFStringCompare(theString1, CFSTR("Palm"), 1uLL) == kCFCompareEqualTo)
    return 13;
  v3 = 1;
  if (CFStringCompare(theString1, CFSTR("1 Finger"), 1uLL))
  {
    if (CFStringCompare(theString1, CFSTR("2 Fingers"), 1uLL))
    {
      if (CFStringCompare(theString1, CFSTR("3 Fingers"), 1uLL))
      {
        if (CFStringCompare(theString1, CFSTR("4 Fingers"), 1uLL))
        {
          if (CFStringCompare(theString1, CFSTR("Thumb"), 1uLL))
          {
            if (CFStringCompare(theString1, CFSTR("1 Finger + Thumb"), 1uLL))
            {
              if (CFStringCompare(theString1, CFSTR("2 Fingers + Thumb"), 1uLL))
              {
                if (CFStringCompare(theString1, CFSTR("3 Fingers + Thumb"), 1uLL))
                {
                  if (CFStringCompare(theString1, CFSTR("4 Fingers + Thumb"), 1uLL))
                    return 0;
                  else
                    return 9;
                }
                else
                {
                  return 8;
                }
              }
              else
              {
                return 7;
              }
            }
            else
            {
              return 6;
            }
          }
          else
          {
            return 5;
          }
        }
        else
        {
          return 4;
        }
      }
      else
      {
        return 3;
      }
    }
    else
    {
      return 2;
    }
  }
  return v3;
}

uint64_t MTPListGestureConfig::parseHandIdentity(MTPListGestureConfig *this, const __CFString *a2)
{
  return 1;
}

void MTPListGestureConfig::parseChordGestureSetAndCopyIntoTable(CFDictionaryRef *this, CFTypeRef cf, const __CFString *a3)
{
  CFTypeID v6;
  CFTypeID TypeID;
  CFTypeID v8;
  const __CFString *Value;
  const __CFString *v10;
  CFTypeID v11;
  MTPListGestureConfig *GestureCategory;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  const char *CStringPtr;
  MTChordGestureSet *v17;
  const __CFString *v18;
  const __CFString *v19;
  CFTypeID v20;
  const void *v21;
  const void *v22;
  CFTypeID v23;
  const __CFString *v24;
  const __CFString *v25;
  const __CFString *v26;
  void **v27;
  void *v28[2];
  __int128 v29;
  void *v30[2];
  __int128 v31;
  void *v32[2];
  __int128 v33;
  void *v34[2];
  __int128 v35;
  __int128 __p;
  __int128 v37;
  _OWORD v38[5];
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  if (cf)
  {
    v6 = CFGetTypeID(cf);
    TypeID = CFDictionaryGetTypeID();
    if (a3)
    {
      if (v6 == TypeID)
      {
        v8 = CFGetTypeID(a3);
        if (v8 == CFStringGetTypeID())
        {
          Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("Chord"));
          if (Value && (v10 = Value, v11 = CFGetTypeID(Value), v11 == CFStringGetTypeID()))
          {
            GestureCategory = (MTPListGestureConfig *)MTPListGestureConfig::extractGestureCategory((MTPListGestureConfig *)this, (CFDictionaryRef)cf);
            v13 = MTPListGestureConfig::parseChordSpecifier(GestureCategory, v10);
            if ((_DWORD)v13)
            {
              v14 = v13;
              *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
              *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
              v38[3] = v15;
              v38[4] = v15;
              v38[1] = v15;
              v38[2] = v15;
              v37 = v15;
              v38[0] = v15;
              __p = v15;
              *(_OWORD *)v34 = v15;
              v35 = v15;
              *(_OWORD *)v32 = v15;
              v33 = v15;
              *(_OWORD *)v30 = v15;
              v31 = v15;
              *(_OWORD *)v28 = v15;
              v29 = v15;
              CStringPtr = CFStringGetCStringPtr(v10, 0);
              MTChordGestureSet::MTChordGestureSet(v28, v14, 0, GestureCategory, CStringPtr);
              v17 = MTGestureConfig::copyChordIntoHandTable((uint64_t)this, 1, (MTChordGestureSet *)v28);
              v18 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("Gesture Set"));
              v19 = v18;
              if (v18 && (v20 = CFGetTypeID(v18), v20 == CFStringGetTypeID()))
              {
                v21 = CFDictionaryGetValue(this[11], v19);
                v22 = v21;
                if (v21 && (v23 = CFGetTypeID(v21), v23 == CFDictionaryGetTypeID()))
                {
                  MTPListGestureConfig::parseGestureSet((MTPListGestureConfig *)this, v19, v22, v17);
                }
                else
                {
                  v26 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ No dictionary for '%@' Gesture Set\n"), CFSTR("ERROR in PListGestureParser:"), v19);
                  MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)this, v26);
                }
              }
              else
              {
                v25 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ No Gesture Set for '%@' Chord\n"), CFSTR("ERROR in PListGestureParser:"), v10);
                MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)this, v25);
              }
              v27 = (void **)v38;
              std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100](&v27);
              if ((_QWORD)__p)
              {
                *((_QWORD *)&__p + 1) = __p;
                operator delete((void *)__p);
              }
              if (v34[0])
              {
                v34[1] = v34[0];
                operator delete(v34[0]);
              }
              if (v32[0])
              {
                v32[1] = v32[0];
                operator delete(v32[0]);
              }
              if (v30[0])
              {
                v30[1] = v30[0];
                operator delete(v30[0]);
              }
              if (v28[0])
              {
                v28[1] = v28[0];
                operator delete(v28[0]);
              }
            }
          }
          else
          {
            v24 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ Chord Dictionary Missing '%@' Key\n"), CFSTR("ERROR in PListGestureParser:"), CFSTR("Chord"));
            MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)this, v24);
          }
        }
      }
    }
  }
}

void sub_231091A2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  MTChordGestureSet::~MTChordGestureSet((MTChordGestureSet *)va);
  _Unwind_Resume(a1);
}

void MTChordGestureSet::~MTChordGestureSet(MTChordGestureSet *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void **v7;

  v7 = (void **)((char *)this + 160);
  std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100](&v7);
  v2 = (void *)*((_QWORD *)this + 16);
  if (v2)
  {
    *((_QWORD *)this + 17) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 12);
  if (v3)
  {
    *((_QWORD *)this + 13) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 8);
  if (v4)
  {
    *((_QWORD *)this + 9) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 4);
  if (v5)
  {
    *((_QWORD *)this + 5) = v5;
    operator delete(v5);
  }
  v6 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v6;
    operator delete(v6);
  }
}

void MTPListGestureConfig::parseChordMappingsForHand(MTPListGestureConfig *this, const __CFString *cf, const __CFDictionary *a3)
{
  CFTypeID v6;
  const __CFString *v7;
  CFTypeID v8;
  const __CFArray *Value;
  const __CFArray *v10;
  CFTypeID v11;
  CFIndex Count;
  CFIndex v13;
  CFIndex i;
  const void *ValueAtIndex;
  const __CFString *v16;
  const __CFString *v17;
  const __CFString *v18;
  CFTypeID v19;
  uint64_t ChordTableForHand;
  uint64_t v21;

  if (!cf
    || (v6 = CFGetTypeID(cf), v6 != CFStringGetTypeID())
    || CFStringCompare(cf, CFSTR("Right"), 1uLL) && CFStringCompare(cf, CFSTR("Any"), 1uLL))
  {
    v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ '%@' Hand not recognized or supported\n"), CFSTR("ERROR in PListGestureParser:"), cf);
LABEL_6:
    MTPListGestureConfig::setParseErrorString(this, v7);
    return;
  }
  if (!a3 || (v8 = CFGetTypeID(a3), v8 != CFDictionaryGetTypeID()))
  {
    v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ Missing chord dictionary for '%@' Hand\n"), CFSTR("ERROR in PListGestureParser:"), cf);
    goto LABEL_6;
  }
  Value = (const __CFArray *)CFDictionaryGetValue(a3, CFSTR("Chords"));
  if (Value && (v10 = Value, v11 = CFGetTypeID(Value), v11 == CFArrayGetTypeID()))
  {
    Count = CFArrayGetCount(v10);
    if (Count >= 1)
    {
      v13 = Count;
      for (i = 0; i != v13; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v10, i);
        MTPListGestureConfig::parseChordGestureSetAndCopyIntoTable((CFDictionaryRef *)this, ValueAtIndex, cf);
      }
    }
  }
  else
  {
    v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%@ Could not find '%@' array for '%@' Hand\n"), CFSTR("ERROR in PListGestureParser:"), CFSTR("Chords"), cf);
    MTPListGestureConfig::setParseErrorString(this, v16);
  }
  v17 = (const __CFString *)CFDictionaryGetValue(a3, CFSTR("LookupBySubset"));
  if (v17)
  {
    v18 = v17;
    v19 = CFGetTypeID(v17);
    if (v19 == CFStringGetTypeID())
    {
      ChordTableForHand = MTGestureConfig::getChordTableForHand((uint64_t)this, 1);
      if (ChordTableForHand)
      {
        v21 = ChordTableForHand;
        if (CFStringCompare(v18, CFSTR("SyncedFingers"), 1uLL) == kCFCompareEqualTo)
          *(_DWORD *)(v21 + 28) = 0;
        if (CFStringCompare(v18, CFSTR("TouchingFingers"), 1uLL) == kCFCompareEqualTo)
          *(_DWORD *)(v21 + 28) = 2;
        if (CFStringCompare(v18, CFSTR("MovingFingers"), 1uLL) == kCFCompareEqualTo)
          *(_DWORD *)(v21 + 28) = 1;
      }
    }
  }
}

void MTPListGestureConfig::parseChordMappingPreferences(MTPListGestureConfig *this, CFTypeRef cf)
{
  CFTypeID v4;
  CFIndex Count;
  const void **v6;
  const void **v7;
  const void **v8;
  const __CFDictionary **v9;
  const __CFString *v10;
  const __CFString *v11;
  const __CFDictionary *v12;

  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFDictionaryGetTypeID())
    {
      Count = CFDictionaryGetCount((CFDictionaryRef)cf);
      v6 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
      v7 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
      CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, v6, v7);
      if (Count >= 1)
      {
        v8 = v6;
        v9 = (const __CFDictionary **)v7;
        do
        {
          v11 = (const __CFString *)*v8++;
          v10 = v11;
          v12 = *v9++;
          MTPListGestureConfig::parseChordMappingsForHand(this, v10, v12);
          --Count;
        }
        while (Count);
      }
      free(v6);
      free(v7);
    }
  }
}

void MTPListGestureConfig::setChordMappingsDictionary(MTPListGestureConfig *this, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = (CFTypeRef)*((_QWORD *)this + 10);
  if (v3 != cf)
  {
    if (v3)
    {
      CFRelease(v3);
      *((_QWORD *)this + 10) = 0;
    }
    if (cf)
    {
      *((_QWORD *)this + 10) = cf;
      CFRetain(cf);
    }
  }
}

void MTPListGestureConfig::setGestureSetsDictionary(MTPListGestureConfig *this, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = (CFTypeRef)*((_QWORD *)this + 11);
  if (v3 != cf)
  {
    if (v3)
    {
      CFRelease(v3);
      *((_QWORD *)this + 11) = 0;
    }
    if (cf)
    {
      *((_QWORD *)this + 11) = cf;
      CFRetain(cf);
    }
  }
}

void MTPListGestureConfig::setMotionSensitivitiesDictionary(MTPListGestureConfig *this, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = (CFTypeRef)*((_QWORD *)this + 12);
  if (v3 != cf)
  {
    if (v3)
    {
      CFRelease(v3);
      *((_QWORD *)this + 12) = 0;
    }
    if (cf)
    {
      *((_QWORD *)this + 12) = cf;
      CFRetain(cf);
    }
  }
}

void MTPListGestureConfig::setActionEventsDictionary(MTPListGestureConfig *this, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = (CFTypeRef)*((_QWORD *)this + 13);
  if (v3 != cf)
  {
    if (v3)
    {
      CFRelease(v3);
      *((_QWORD *)this + 13) = 0;
    }
    if (cf)
    {
      *((_QWORD *)this + 13) = cf;
      CFRetain(cf);
    }
  }
}

BOOL MTPListGestureConfig::parseCreateGestureConfig(MTPListGestureConfig *this, const __CFString **a2)
{
  const void *v4;
  const void *v5;
  CFTypeID v6;
  const void *v7;
  CFTypeID v8;
  const void *v9;
  CFTypeID v10;
  const void *v11;
  CFTypeID v12;
  const __CFAllocator *v13;
  const char *v14;
  const __CFString *v15;
  const __CFString *v16;

  v4 = (const void *)*((_QWORD *)this + 14);
  if (v4)
  {
    CFRelease(v4);
    *((_QWORD *)this + 14) = 0;
  }
  v5 = (const void *)*((_QWORD *)this + 10);
  if (!v5 || (v6 = CFGetTypeID(v5), v6 != CFDictionaryGetTypeID()))
  {
    v13 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v14 = "PListGestureParser ABORT: Chord Mappings dictionary missing\n";
LABEL_16:
    v15 = CFStringCreateWithCString(v13, v14, 0);
    MTPListGestureConfig::setParseErrorString(this, v15);
    goto LABEL_17;
  }
  v7 = (const void *)*((_QWORD *)this + 13);
  if (!v7 || (v8 = CFGetTypeID(v7), v8 != CFDictionaryGetTypeID()))
  {
    v13 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v14 = "PListGestureParser ABORT: Action Events dictionary missing\n";
    goto LABEL_16;
  }
  v9 = (const void *)*((_QWORD *)this + 12);
  if (!v9 || (v10 = CFGetTypeID(v9), v10 != CFDictionaryGetTypeID()))
  {
    v13 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v14 = "PListGestureParser ABORT: Motion Sensitivities dictionary missing\n";
    goto LABEL_16;
  }
  v11 = (const void *)*((_QWORD *)this + 11);
  if (!v11 || (v12 = CFGetTypeID(v11), v12 != CFDictionaryGetTypeID()))
  {
    v13 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v14 = "PListGestureParser ABORT: Gesture Sets dictionary missing\n";
    goto LABEL_16;
  }
  MTPListGestureConfig::parseChordMappingPreferences(this, *((CFTypeRef *)this + 10));
LABEL_17:
  v16 = (const __CFString *)*((_QWORD *)this + 14);
  if (a2 && v16)
  {
    *a2 = v16;
    *((_QWORD *)this + 14) = 0;
  }
  return v16 == 0;
}

void MTPListGestureConfig::releaseParsedDictionaries(MTPListGestureConfig *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  v2 = (const void *)*((_QWORD *)this + 10);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 10) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 11);
  if (v3)
  {
    CFRelease(v3);
    *((_QWORD *)this + 11) = 0;
  }
  v4 = (const void *)*((_QWORD *)this + 13);
  if (v4)
  {
    CFRelease(v4);
    *((_QWORD *)this + 13) = 0;
  }
  v5 = (const void *)*((_QWORD *)this + 12);
  if (v5)
  {
    CFRelease(v5);
    *((_QWORD *)this + 12) = 0;
  }
}

void MTPListGestureConfig::addActionEventToDictionary(MTPListGestureConfig *this, __CFDictionary *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const __CFString *a6)
{
  const __CFAllocator *v11;
  __CFArray *Mutable;
  __CFDictionary *v13;

  v11 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD690]);
  v13 = CFDictionaryCreateMutable(v11, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  CFDictionaryAddValue(v13, CFSTR("EventType"), a3);
  if (a4)
    CFDictionaryAddValue(v13, CFSTR("Modifiers"), a4);
  if (a5)
    CFDictionaryAddValue(v13, CFSTR("KeyCode"), a5);
  CFArrayAppendValue(Mutable, v13);
  CFDictionaryAddValue(this, a2, Mutable);
  CFRelease(Mutable);
  CFRelease(v13);
}

void MTPListGestureConfig::addGestureToArray(MTPListGestureConfig *this, __CFArray *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const __CFString *a6, const __CFString *a7, const __CFString *a8, const void *a9)
{
  __CFDictionary *Mutable;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  CFDictionaryAddValue(Mutable, CFSTR("Action"), a2);
  CFDictionaryAddValue(Mutable, CFSTR("Motion"), a3);
  if (a4)
    CFDictionaryAddValue(Mutable, CFSTR("Sensitivity"), a4);
  if (a5)
    CFDictionaryAddValue(Mutable, CFSTR("Trigger"), a5);
  if (a6)
    CFDictionaryAddValue(Mutable, CFSTR("Locking"), a6);
  if (a7 && a8)
    CFDictionaryAddValue(Mutable, a7, a8);
  CFArrayAppendValue(this, Mutable);
  CFRelease(Mutable);
}

void MTPListGestureConfig::addChordMappingToArray(MTPListGestureConfig *this, __CFArray *a2, const __CFString *a3, const __CFString *a4)
{
  __CFDictionary *Mutable;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  CFDictionaryAddValue(Mutable, CFSTR("Chord"), a2);
  CFDictionaryAddValue(Mutable, CFSTR("Gesture Set"), a3);
  CFArrayAppendValue(this, Mutable);
  CFRelease(Mutable);
}

uint64_t std::vector<MTActionEvent>::__push_back_slow_path<MTActionEvent const&>(uint64_t a1, const MTActionEvent *a2)
{
  const MTActionEvent *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  void *__p[2];
  char *v14;
  char *v15;
  uint64_t v16;

  v3 = *(const MTActionEvent **)a1;
  v4 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 61)
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  v7 = a1 + 16;
  v8 = *(_QWORD *)(a1 + 16) - (_QWORD)v3;
  if (v8 >> 2 > v5)
    v5 = v8 >> 2;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
    v9 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v9 = v5;
  v16 = a1 + 16;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTPoint>>(v7, v9);
  else
    v10 = 0;
  __p[0] = v10;
  __p[1] = &v10[8 * v4];
  v15 = &v10[8 * v9];
  MTActionEvent::MTActionEvent((MTActionEvent *)__p[1], a2);
  v14 = (char *)__p[1] + 8;
  std::vector<MTActionEvent>::__swap_out_circular_buffer((const MTActionEvent **)a1, __p);
  v11 = *(_QWORD *)(a1 + 8);
  if (v14 != __p[1])
    v14 += ((char *)__p[1] - (char *)v14 + 7) & 0xFFFFFFFFFFFFFFF8;
  if (__p[0])
    operator delete(__p[0]);
  return v11;
}

void sub_231092484(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::vector<MTActionEvent>::__swap_out_circular_buffer(const MTActionEvent **a1, _QWORD *a2)
{
  const MTActionEvent *v4;
  const MTActionEvent *v5;
  const MTActionEvent *v6;
  const MTActionEvent *v7;
  const MTActionEvent *v8;
  const MTActionEvent *v9;

  v5 = *a1;
  v4 = a1[1];
  v6 = (const MTActionEvent *)a2[1];
  while (v4 != v5)
  {
    v4 = (const MTActionEvent *)((char *)v4 - 8);
    MTActionEvent::MTActionEvent((const MTActionEvent *)((char *)v6 - 8), v4);
  }
  a2[1] = v6;
  v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = (const MTActionEvent *)a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = (const MTActionEvent *)a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

uint64_t std::vector<MTSlideGesture>::__push_back_slow_path<MTSlideGesture const&>(uint64_t *a1, const MTSlideGesture *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v13;
  MTSlideGesture *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 5);
  v5 = v4 + 1;
  if (v4 + 1 > 0x199999999999999)
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 5);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0xCCCCCCCCCCCCCCLL)
    v9 = 0x199999999999999;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTSlideGesture>>(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = (MTSlideGesture *)&v10[160 * v4];
  v16 = &v10[160 * v9];
  MTSlideGesture::MTSlideGesture(v14, a2);
  v15 = (char *)v14 + 160;
  std::vector<MTSlideGesture>::__swap_out_circular_buffer(a1, &v13);
  v11 = a1[1];
  std::__split_buffer<MTSlideGesture>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_231092638(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__split_buffer<MTSlideGesture>::~__split_buffer((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::vector<MTSlideGesture>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MTSlideGesture>,std::reverse_iterator<MTSlideGesture*>,std::reverse_iterator<MTSlideGesture*>,std::reverse_iterator<MTSlideGesture*>>((uint64_t)(a1 + 2), a1[1], (const MTSlideGesture *)a1[1], *a1, (const MTSlideGesture *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<MTSlideGesture>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x19999999999999ALL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(160 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MTSlideGesture>,std::reverse_iterator<MTSlideGesture*>,std::reverse_iterator<MTSlideGesture*>,std::reverse_iterator<MTSlideGesture*>>(uint64_t a1, uint64_t a2, const MTSlideGesture *a3, uint64_t a4, const MTSlideGesture *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  const MTSlideGesture *v9;
  uint64_t v10;
  _QWORD v12[3];
  unint64_t v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0xAAAAAAAAAAAAAA00;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    v9 = a3;
    do
    {
      v9 = (const MTSlideGesture *)((char *)v9 - 160);
      MTSlideGesture::MTSlideGesture((MTSlideGesture *)(v7 - 160), v9);
      v7 = *((_QWORD *)&v15 + 1) - 160;
      *((_QWORD *)&v15 + 1) -= 160;
    }
    while (v9 != a5);
    v10 = v15;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,std::reverse_iterator<MTSlideGesture*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

void sub_2310927AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,std::reverse_iterator<MTSlideGesture*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,std::reverse_iterator<MTSlideGesture*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,std::reverse_iterator<MTSlideGesture*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,std::reverse_iterator<MTSlideGesture*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)v1;
    if (*(_QWORD *)v1)
    {
      *(_QWORD *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 160;
  }
}

uint64_t std::__split_buffer<MTSlideGesture>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<MTSlideGesture>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<MTSlideGesture>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    v5 = *(void **)(v2 - 160);
    *(_QWORD *)(a1 + 16) = v2 - 160;
    if (v5)
    {
      *(_QWORD *)(v2 - 152) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 160;
    }
  }
}

void MTChordGestureSet::MTChordGestureSet(MTChordGestureSet *this)
{
  *((_DWORD *)this + 58) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *(_OWORD *)((char *)this + 169) = 0u;
  *(_QWORD *)((char *)this + 204) = 0;
  *(_QWORD *)((char *)this + 220) = 0;
  *(_QWORD *)((char *)this + 212) = 0;
  *((_WORD *)this + 114) = 0;
}

{
  *((_DWORD *)this + 58) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *(_OWORD *)((char *)this + 169) = 0u;
  *(_QWORD *)((char *)this + 204) = 0;
  *(_QWORD *)((char *)this + 220) = 0;
  *(_QWORD *)((char *)this + 212) = 0;
  *((_WORD *)this + 114) = 0;
}

uint64_t MTChordGestureSet::MTChordGestureSet(uint64_t a1, signed int a2, __int16 a3, int a4, char *__src)
{
  int32x2_t v6;
  char *v7;

  *(_DWORD *)(a1 + 204) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_QWORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 224) = a2;
  *(_WORD *)(a1 + 228) = a3;
  *(_DWORD *)(a1 + 232) = a4;
  if ((a2 - 1) <= 3)
  {
    *(_DWORD *)(a1 + 216) = a2;
    *(_DWORD *)(a1 + 220) = a2;
    goto LABEL_9;
  }
  if (a2 <= 9)
  {
    v6 = vadd_s32(vdup_n_s32(a2), (int32x2_t)0xFFFFFFFBFFFFFFFCLL);
LABEL_7:
    *(int32x2_t *)(a1 + 216) = v6;
    goto LABEL_9;
  }
  if (a2 <= 0xD)
  {
    v6 = (int32x2_t)0x400000005;
    goto LABEL_7;
  }
  *(_QWORD *)(a1 + 216) = 0;
LABEL_9:
  v7 = (char *)(a1 + 184);
  if (__src)
    strncpy(v7, __src, 0x13uLL);
  else
    *v7 = 0;
  return a1;
}

void MTChordGestureSet::MTChordGestureSet(MTChordGestureSet *this, const MTChordGestureSet *a2)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  std::vector<MTActionEvent>::__init_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>(this, *(_QWORD *)a2, *((_QWORD *)a2 + 1), (uint64_t)(*((_QWORD *)a2 + 1) - *(_QWORD *)a2) >> 3);
  v4 = *((_DWORD *)a2 + 6);
  v5 = *((_DWORD *)a2 + 7);
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 6) = v4;
  *((_DWORD *)this + 7) = v5;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  std::vector<MTActionEvent>::__init_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>((_QWORD *)this + 4, *((_QWORD *)a2 + 4), *((_QWORD *)a2 + 5), (uint64_t)(*((_QWORD *)a2 + 5) - *((_QWORD *)a2 + 4)) >> 3);
  v6 = *((_DWORD *)a2 + 14);
  v7 = *((_DWORD *)a2 + 15);
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 14) = v6;
  *((_DWORD *)this + 15) = v7;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  std::vector<MTActionEvent>::__init_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>((_QWORD *)this + 8, *((_QWORD *)a2 + 8), *((_QWORD *)a2 + 9), (uint64_t)(*((_QWORD *)a2 + 9) - *((_QWORD *)a2 + 8)) >> 3);
  v8 = *((_DWORD *)a2 + 22);
  v9 = *((_DWORD *)a2 + 23);
  *((_QWORD *)this + 12) = 0;
  *((_DWORD *)this + 22) = v8;
  *((_DWORD *)this + 23) = v9;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  std::vector<MTActionEvent>::__init_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>((_QWORD *)this + 12, *((_QWORD *)a2 + 12), *((_QWORD *)a2 + 13), (uint64_t)(*((_QWORD *)a2 + 13) - *((_QWORD *)a2 + 12)) >> 3);
  v10 = *((_DWORD *)a2 + 30);
  v11 = *((_DWORD *)a2 + 31);
  *((_QWORD *)this + 16) = 0;
  *((_DWORD *)this + 30) = v10;
  *((_DWORD *)this + 31) = v11;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 18) = 0;
  std::vector<MTActionEvent>::__init_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>((_QWORD *)this + 16, *((_QWORD *)a2 + 16), *((_QWORD *)a2 + 17), (uint64_t)(*((_QWORD *)a2 + 17) - *((_QWORD *)a2 + 16)) >> 3);
  *((_DWORD *)this + 38) = *((_DWORD *)a2 + 38);
  *((_DWORD *)this + 39) = *((_DWORD *)a2 + 39);
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_DWORD *)this + 51) = *((_DWORD *)a2 + 51);
  *((_QWORD *)this + 26) = *((_QWORD *)a2 + 26);
  *((_QWORD *)this + 27) = *((_QWORD *)a2 + 27);
  *((_DWORD *)this + 56) = *((_DWORD *)a2 + 56);
  *((_WORD *)this + 114) = *((_WORD *)a2 + 114);
  *((_DWORD *)this + 58) = *((_DWORD *)a2 + 58);
  if (this != a2)
    std::vector<MTSlideGesture>::__assign_with_size[abi:ne180100]<MTSlideGesture*,MTSlideGesture*>((uint64_t)this + 160, *((MTSlideGesture **)a2 + 20), *((MTSlideGesture **)a2 + 21), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((_QWORD *)a2 + 21) - *((_QWORD *)a2 + 20)) >> 5));
  strncpy((char *)this + 184, (const char *)a2 + 184, 0x13uLL);
}

void sub_231092B78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  void **v3;
  void **v4;
  void **v5;
  void **v6;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  va_list va;

  va_start(va, a2);
  std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  v8 = *v6;
  if (*v6)
  {
    *(_QWORD *)(v2 + 136) = v8;
    operator delete(v8);
  }
  v9 = *v5;
  if (*v5)
  {
    *(_QWORD *)(v2 + 104) = v9;
    operator delete(v9);
  }
  v10 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v2 + 72) = v10;
    operator delete(v10);
  }
  v11 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v2 + 40) = v11;
    operator delete(v11);
  }
  v12 = *(void **)v2;
  if (*(_QWORD *)v2)
  {
    *(_QWORD *)(v2 + 8) = v12;
    operator delete(v12);
  }
  _Unwind_Resume(a1);
}

uint64_t MTChordGestureSet::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    *(_DWORD *)(a1 + 204) = *(_DWORD *)(a2 + 204);
    *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 208);
    *(_QWORD *)(a1 + 216) = *(_QWORD *)(a2 + 216);
    *(_DWORD *)(a1 + 224) = *(_DWORD *)(a2 + 224);
    *(_WORD *)(a1 + 228) = *(_WORD *)(a2 + 228);
    *(_DWORD *)(a1 + 232) = *(_DWORD *)(a2 + 232);
    strncpy((char *)(a1 + 184), (const char *)(a2 + 184), 0x13uLL);
    MTGesture::operator=(a1, a2);
    MTGesture::operator=(a1 + 32, a2 + 32);
    MTGesture::operator=(a1 + 64, a2 + 64);
    MTGesture::operator=(a1 + 96, a2 + 96);
    MTGesture::operator=(a1 + 128, a2 + 128);
    std::vector<MTSlideGesture>::__assign_with_size[abi:ne180100]<MTSlideGesture*,MTSlideGesture*>(a1 + 160, *(MTSlideGesture **)(a2 + 160), *(MTSlideGesture **)(a2 + 168), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a2 + 168) - *(_QWORD *)(a2 + 160)) >> 5));
  }
  return a1;
}

uint64_t MTChordGestureSet::chordGestureSetEquals(MTChordGestureSet *this, const MTChordGestureSet *a2)
{
  if (MTGesture::gestureEquals((uint64_t *)this, (uint64_t *)a2)
    && MTGesture::gestureEquals((uint64_t *)this + 4, (uint64_t *)a2 + 4)
    && MTGesture::gestureEquals((uint64_t *)this + 8, (uint64_t *)a2 + 8)
    && MTGesture::gestureEquals((uint64_t *)this + 12, (uint64_t *)a2 + 12)
    && MTGesture::gestureEquals((uint64_t *)this + 16, (uint64_t *)a2 + 16))
  {
    return MTChordGestureSet::chordSlidesEqual(this, a2);
  }
  else
  {
    return 0;
  }
}

uint64_t MTGesture::gestureEquals(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;

  if (*((unsigned __int16 *)a1 + 12) != *((unsigned __int16 *)a2 + 12))
    return 0;
  if (*((unsigned __int16 *)a1 + 13) != *((unsigned __int16 *)a2 + 13))
    return 0;
  if (*((_DWORD *)a1 + 7) != *((_DWORD *)a2 + 7))
    return 0;
  v2 = *a1;
  v3 = a1[1];
  v4 = (v3 - *a1) >> 3;
  v5 = *a2;
  if (v4 != (a2[1] - *a2) >> 3)
    return 0;
  if (v3 != v2)
  {
    v6 = 0;
    v7 = 1;
    result = 1;
    while (*(unsigned __int16 *)(v2 + 8 * v6) == *(unsigned __int16 *)(v5 + 8 * v6))
    {
      v9 = v2 + 8 * v6;
      v10 = v5 + 8 * v6;
      if (*(unsigned __int16 *)(v9 + 2) != *(unsigned __int16 *)(v10 + 2)
        || *(_DWORD *)(v9 + 4) != *(_DWORD *)(v10 + 4))
      {
        break;
      }
      v6 = v7;
      if (v4 <= v7++)
        return result;
    }
    return 0;
  }
  return 1;
}

uint64_t MTChordGestureSet::chordSlidesEqual(MTChordGestureSet *this, const MTChordGestureSet *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v6;
  unsigned int v7;
  uint64_t result;

  v2 = *((_QWORD *)this + 20);
  v3 = *((_QWORD *)this + 21);
  if (v3 - v2 != *((_QWORD *)a2 + 21) - *((_QWORD *)a2 + 20))
    return 0;
  if (v3 == v2)
    return 1;
  v6 = 0;
  v7 = 1;
  do
  {
    result = MTSlideGesture::slideEquals((MTSlideGesture *)(v2 + 160 * v6), (const MTSlideGesture *)(*((_QWORD *)a2 + 20) + 160 * v6));
    if ((result & 1) == 0)
      break;
    v6 = v7;
    v2 = *((_QWORD *)this + 20);
  }
  while (0xCCCCCCCCCCCCCCCDLL * ((*((_QWORD *)this + 21) - v2) >> 5) > v7++);
  return result;
}

uint64_t MTSlideGesture::slideEquals(MTSlideGesture *this, const MTSlideGesture *a2)
{
  uint64_t result;

  result = MTGesture::gestureEquals((uint64_t *)this, (uint64_t *)a2);
  if ((_DWORD)result)
    return *((_DWORD *)this + 8) == *((_DWORD *)a2 + 8)
        && *((float *)this + 38) == *((float *)a2 + 38)
        && *((float *)this + 39) == *((float *)a2 + 39)
        && *((float *)this + 9) == *((float *)a2 + 9)
        && *((float *)this + 10) == *((float *)a2 + 10)
        && *((float *)this + 13) == *((float *)a2 + 13)
        && *((float *)this + 11) == *((float *)a2 + 11)
        && *((float *)this + 12) == *((float *)a2 + 12)
        && *((float *)this + 14) == *((float *)a2 + 14)
        && *((float *)this + 15) == *((float *)a2 + 15)
        && *((float *)this + 16) == *((float *)a2 + 16);
  return result;
}

BOOL MTChordGestureSet::isEmpty(MTChordGestureSet *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unsigned int v5;
  uint64_t v6;
  _WORD *v8;
  _WORD *v9;
  _WORD *v10;
  unsigned __int16 *v12;

  v1 = *((_QWORD *)this + 20);
  v2 = *((_QWORD *)this + 21) - v1;
  if (v2)
  {
    v3 = 0;
    v4 = 0xCCCCCCCCCCCCCCCDLL * (v2 >> 5);
    v5 = 1;
    do
    {
      v6 = v1 + 160 * v3;
      if (*(_QWORD *)v6 != *(_QWORD *)(v6 + 8))
      {
        if (**(_WORD **)v6)
          return 0;
      }
      v3 = v5;
    }
    while (v4 > v5++);
  }
  if (*(_QWORD *)this != *((_QWORD *)this + 1) && **(_WORD **)this)
    return 0;
  v8 = (_WORD *)*((_QWORD *)this + 4);
  if (v8 != *((_WORD **)this + 5))
  {
    if (*v8)
      return 0;
  }
  v9 = (_WORD *)*((_QWORD *)this + 8);
  if (v9 != *((_WORD **)this + 9))
  {
    if (*v9)
      return 0;
  }
  v10 = (_WORD *)*((_QWORD *)this + 12);
  if (v10 != *((_WORD **)this + 13))
  {
    if (*v10)
      return 0;
  }
  v12 = (unsigned __int16 *)*((_QWORD *)this + 16);
  return v12 == *((unsigned __int16 **)this + 17) || *v12 == 0;
}

uint64_t MTChordGestureSet::hasEnabledOrientationEvents(MTChordGestureSet *this, const MTChordTable *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unsigned int i;
  uint64_t v7;
  int v8;
  BOOL v9;

  v2 = *((_QWORD *)this + 20);
  v3 = *((_QWORD *)this + 21) - v2;
  if (!v3)
    return 0;
  v4 = 0;
  v5 = 0xCCCCCCCCCCCCCCCDLL * (v3 >> 5);
  for (i = 1; ; ++i)
  {
    v7 = v2 + 160 * v4;
    v8 = *(_DWORD *)(v7 + 28);
    v9 = v8 && (*((_DWORD *)a2 + 6) & v8) == 0;
    if (!v9 && *(_QWORD *)v7 != *(_QWORD *)(v7 + 8) && **(_WORD **)v7 == 71)
      break;
    v4 = i;
    if (v5 <= i)
      return 0;
  }
  return 1;
}

uint64_t MTChordGestureSet::hasEnabledFluidNavigation(MTChordGestureSet *this, const MTChordTable *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unsigned int i;
  uint64_t v7;
  int v8;
  BOOL v9;

  v2 = *((_QWORD *)this + 20);
  v3 = *((_QWORD *)this + 21) - v2;
  if (!v3)
    return 0;
  v4 = 0;
  v5 = 0xCCCCCCCCCCCCCCCDLL * (v3 >> 5);
  for (i = 1; ; ++i)
  {
    v7 = v2 + 160 * v4;
    v8 = *(_DWORD *)(v7 + 28);
    v9 = v8 && (*((_DWORD *)a2 + 6) & v8) == 0;
    if (!v9 && *(_QWORD *)v7 != *(_QWORD *)(v7 + 8) && **(_WORD **)v7 == 36)
      break;
    v4 = i;
    if (v5 <= i)
      return 0;
  }
  return 1;
}

uint64_t MTChordGestureSet::hasEnabledFluidDock(MTChordGestureSet *this, const MTChordTable *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unsigned int i;
  uint64_t v7;
  int v8;
  BOOL v9;

  v2 = *((_QWORD *)this + 20);
  v3 = *((_QWORD *)this + 21) - v2;
  if (!v3)
    return 0;
  v4 = 0;
  v5 = 0xCCCCCCCCCCCCCCCDLL * (v3 >> 5);
  for (i = 1; ; ++i)
  {
    v7 = v2 + 160 * v4;
    v8 = *(_DWORD *)(v7 + 28);
    v9 = v8 && (*((_DWORD *)a2 + 6) & v8) == 0;
    if (!v9 && *(_QWORD *)v7 != *(_QWORD *)(v7 + 8) && **(_WORD **)v7 == 37)
      break;
    v4 = i;
    if (v5 <= i)
      return 0;
  }
  return 1;
}

uint64_t MTChordGestureSet::hasActiveEdgeSlide(MTChordGestureSet *this, const MTHandStatistics *a2, const MTChordCycling *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  char isActiveEdgeSlide;
  void **v16;
  void *v17[4];
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *__p;
  void *v25;
  _QWORD v26[32];

  v26[31] = *MEMORY[0x24BDAC8D0];
  v6 = *((_DWORD *)this + 58);
  if (v6 && (*((_DWORD *)a3 + 6) & v6) == 0)
    return 0;
  v8 = *((_QWORD *)this + 20);
  v7 = *((_QWORD *)this + 21);
  if (v7 == v8)
    return 0;
  v9 = 0;
  v10 = 1;
  while (1)
  {
    v11 = v8 + 160 * v9;
    v12 = *(_DWORD *)(v11 + 28);
    if (v12 && (*((_DWORD *)a3 + 6) & v12) == 0)
      goto LABEL_19;
    MTChordIntegrating::MTChordIntegrating((MTChordIntegrating *)v17, this);
    isActiveEdgeSlide = MTSlideGesture::isActiveEdgeSlide((unsigned __int16 **)v11, (uint64_t)a2, (uint64_t)v17);
    v16 = (void **)v26;
    std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100](&v16);
    if (__p)
    {
      v25 = __p;
      operator delete(__p);
    }
    if (v22)
    {
      v23 = v22;
      operator delete(v22);
    }
    if (v20)
    {
      v21 = v20;
      operator delete(v20);
    }
    if (v18)
    {
      v19 = v18;
      operator delete(v18);
    }
    if (v17[0])
    {
      v17[1] = v17[0];
      operator delete(v17[0]);
    }
    if ((isActiveEdgeSlide & 1) != 0)
      return 1;
    v8 = *((_QWORD *)this + 20);
    v7 = *((_QWORD *)this + 21);
LABEL_19:
    v9 = v10;
    if (0xCCCCCCCCCCCCCCCDLL * ((v7 - v8) >> 5) <= v10++)
      return 0;
  }
}

void sub_231093348(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  MTChordGestureSet::~MTChordGestureSet((MTChordGestureSet *)va);
  _Unwind_Resume(a1);
}

BOOL MTChordGestureSet::chk4MinChordMotion(MTChordGestureSet *this, const MTHandMotion *a2)
{
  _BOOL8 result;

  result = 1;
  if (*((float *)a2 + 48) == 0.0 && *((float *)a2 + 49) == 0.0 && *((float *)a2 + 50) == 0.0)
    return *((float *)a2 + 51) != 0.0;
  return result;
}

BOOL MTChordGestureSet::chk4ChordPause(MTChordGestureSet *this, const MTHandStatistics *a2, const MTHandMotion *a3, double a4, double a5, float a6)
{
  double v6;
  float v7;

  v6 = *(double *)&qword_255EB3BF8;
  LOWORD(a6) = *((_WORD *)this + 77);
  v7 = (float)LODWORD(a6) * 0.001;
  if (v7 != 0.0)
    v6 = v7;
  return v6 < a4 || *((double *)a2 + 1) - *((double *)a3 + 20) > v6;
}

BOOL MTChordGestureSet::chk4ChordTimein(MTChordGestureSet *this, const MTHandStatistics *a2)
{
  int v2;
  double v3;
  unsigned int v5;
  double v6;
  float v7;

  if (*((unsigned __int8 *)a2 + 196) > *((unsigned __int8 *)a2 + 195))
    return 0;
  if ((*((_WORD *)this + 60) & 4) == 0)
    return 0;
  v2 = *((unsigned __int8 *)a2 + 186);
  if (v2 != *((unsigned __int8 *)a2 + 197))
    return 0;
  if (*((_DWORD *)this + 54) != v2)
    return 0;
  v3 = *((double *)a2 + 10);
  if ((*((_WORD *)this + 114) & 0x100) == 0 && v3 - *((double *)a2 + 33) > *(double *)&gTimingPrefs)
    return 0;
  HIWORD(v5) = WORD1(qword_255EB3BF8);
  v6 = *(double *)&qword_255EB3BF8 + *(double *)&gTimingPrefs;
  LOWORD(v5) = *((_WORD *)this + 61);
  v7 = (float)v5 * 0.001;
  if (v7 != 0.0)
    v6 = v7;
  if (v3 <= *((double *)a2 + 16))
    v3 = *((double *)a2 + 16);
  return *((double *)a2 + 1) - v3 >= v6;
}

uint64_t MTChordGestureSet::isChordReadyToIntegrate(MTChordGestureSet *this, const MTHandStatistics *a2, float32x4_t *a3)
{
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(a3[12])))) & 1) != 0
    || MTChordGestureSet::chk4ChordTimein(this, a2))
  {
    return 1;
  }
  else
  {
    return HIBYTE(*((unsigned __int16 *)this + 60)) & 1;
  }
}

void std::vector<MTSlideGesture>::__assign_with_size[abi:ne180100]<MTSlideGesture*,MTSlideGesture*>(uint64_t a1, MTSlideGesture *a2, MTSlideGesture *a3, unint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  MTSlideGesture *v12;
  MTSlideGesture *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  void *v19;

  v8 = a1 + 16;
  v9 = *(_QWORD *)a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 5) < a4)
  {
    std::vector<MTSlideGesture>::__vdeallocate((uint64_t *)a1);
    if (a4 > 0x199999999999999)
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    v10 = 0x999999999999999ALL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 5);
    if (v10 <= a4)
      v10 = a4;
    if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 5) >= 0xCCCCCCCCCCCCCCLL)
      v11 = 0x199999999999999;
    else
      v11 = v10;
    std::vector<MTSlideGesture>::__vallocate[abi:ne180100]((_QWORD *)a1, v11);
    v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<MTSlideGesture>,MTSlideGesture*,MTSlideGesture*,MTSlideGesture*>(v8, a2, a3, *(MTSlideGesture **)(a1 + 8));
    goto LABEL_11;
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((*(_QWORD *)(a1 + 8) - v9) >> 5) < a4)
  {
    v13 = (MTSlideGesture *)((char *)a2 + 32 * ((*(_QWORD *)(a1 + 8) - v9) >> 5));
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,MTSlideGesture *,MTSlideGesture *,MTSlideGesture *,0>((uint64_t)a2, (uint64_t)v13, v9);
    v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<MTSlideGesture>,MTSlideGesture*,MTSlideGesture*,MTSlideGesture*>(v8, v13, a3, *(MTSlideGesture **)(a1 + 8));
LABEL_11:
    *(_QWORD *)(a1 + 8) = v12;
    return;
  }
  std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,MTSlideGesture *,MTSlideGesture *,MTSlideGesture *,0>((uint64_t)a2, (uint64_t)a3, v9);
  v15 = v14;
  v16 = *(_QWORD *)(a1 + 8);
  if (v16 != v14)
  {
    v17 = *(_QWORD *)(a1 + 8);
    do
    {
      v19 = *(void **)(v17 - 160);
      v17 -= 160;
      v18 = v19;
      if (v19)
      {
        *(_QWORD *)(v16 - 152) = v18;
        operator delete(v18);
      }
      v16 = v17;
    }
    while (v17 != v15);
  }
  *(_QWORD *)(a1 + 8) = v15;
}

void sub_23109364C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_231093654(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<MTSlideGesture>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<MTSlideGesture>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *std::vector<MTSlideGesture>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x19999999999999ALL)
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTSlideGesture>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[160 * v4];
  return result;
}

MTSlideGesture *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<MTSlideGesture>,MTSlideGesture*,MTSlideGesture*,MTSlideGesture*>(uint64_t a1, MTSlideGesture *a2, MTSlideGesture *a3, MTSlideGesture *this)
{
  MTSlideGesture *v4;
  const MTSlideGesture *v6;
  _QWORD v8[3];
  unint64_t v9;
  MTSlideGesture *v10;
  MTSlideGesture *v11;

  v4 = this;
  v10 = this;
  v11 = this;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0xAAAAAAAAAAAAAA00;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      MTSlideGesture::MTSlideGesture(v4, v6);
      v6 = (const MTSlideGesture *)((char *)v6 + 160);
      v4 = (MTSlideGesture *)((char *)v11 + 160);
      v11 = (MTSlideGesture *)((char *)v11 + 160);
    }
    while (v6 != a3);
  }
  LOBYTE(v9) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,MTSlideGesture*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_231093774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,MTSlideGesture*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,MTSlideGesture*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,MTSlideGesture*>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,MTSlideGesture*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void *v5;

  v1 = **(_QWORD **)(a1 + 16);
  v2 = **(_QWORD **)(a1 + 8);
  if (v1 != v2)
  {
    v3 = **(_QWORD **)(a1 + 16);
    do
    {
      v5 = *(void **)(v3 - 160);
      v3 -= 160;
      v4 = v5;
      if (v5)
      {
        *(_QWORD *)(v1 - 152) = v4;
        operator delete(v4);
      }
      v1 = v3;
    }
    while (v3 != v2);
  }
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,MTSlideGesture *,MTSlideGesture *,MTSlideGesture *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a1;
  if (a1 != a2)
  {
    do
    {
      MTSlideGesture::operator=(a3, v4);
      v4 += 160;
      a3 += 160;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

void MTChordIntegrating::MTChordIntegrating(MTChordIntegrating *this)
{
  MTChordIntegrating *v1;

  MTChordGestureSet::MTChordGestureSet(this);
  MTChordIntegrating::clearIntegrationState(v1);
}

void sub_23109388C(_Unwind_Exception *a1)
{
  MTChordGestureSet *v1;

  MTChordGestureSet::~MTChordGestureSet(v1);
  _Unwind_Resume(a1);
}

uint64_t MTChordIntegrating::clearIntegrationState(MTChordIntegrating *this)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;

  *((_QWORD *)this + 34) = 0;
  *((_QWORD *)this + 31) = 0;
  *((_QWORD *)this + 32) = 0;
  *((_QWORD *)this + 30) = 0;
  *((_DWORD *)this + 66) = 0;
  *((_DWORD *)this + 70) = 1;
  *(_OWORD *)((char *)this + 284) = 0u;
  *(_OWORD *)((char *)this + 300) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  v2 = *((_QWORD *)this + 20);
  if (*((_QWORD *)this + 21) != v2)
  {
    v3 = 0;
    v4 = 1;
    do
    {
      MTSlideGesture::clearIntegrationState((MTSlideGesture *)(v2 + 160 * v3));
      v3 = v4;
      v2 = *((_QWORD *)this + 20);
    }
    while (0xCCCCCCCCCCCCCCCDLL * ((*((_QWORD *)this + 21) - v2) >> 5) > v4++);
  }
  *((_DWORD *)this + 98) = 0;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *((_QWORD *)this + 50) = 0;
  return MTChordIntegrating::resetMostIntegrators((uint64_t)this, 0);
}

void MTChordIntegrating::MTChordIntegrating(MTChordIntegrating *this, const MTChordGestureSet *a2)
{
  MTChordIntegrating *v2;

  MTChordGestureSet::MTChordGestureSet(this, a2);
  MTChordIntegrating::clearIntegrationState(v2);
}

void sub_231093984(_Unwind_Exception *a1)
{
  MTChordGestureSet *v1;

  MTChordGestureSet::~MTChordGestureSet(v1);
  _Unwind_Resume(a1);
}

MTChordIntegrating *MTChordIntegrating::operator=(MTChordIntegrating *a1, uint64_t a2)
{
  if (a1 != (MTChordIntegrating *)a2)
  {
    MTChordGestureSet::operator=((uint64_t)a1, a2);
    MTChordIntegrating::clearIntegrationState(a1);
  }
  return a1;
}

void MTChordIntegrating::nullify(void **this)
{
  void **v2;
  void *v3[4];
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *__p;
  void *v11;
  _QWORD v12[11];

  v12[10] = *MEMORY[0x24BDAC8D0];
  MTChordGestureSet::MTChordGestureSet((MTChordGestureSet *)v3);
  if (v3 != this)
  {
    MTChordGestureSet::operator=((uint64_t)this, (uint64_t)v3);
    MTChordIntegrating::clearIntegrationState((MTChordIntegrating *)this);
  }
  v2 = (void **)v12;
  std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100](&v2);
  if (__p)
  {
    v11 = __p;
    operator delete(__p);
  }
  if (v8)
  {
    v9 = v8;
    operator delete(v8);
  }
  if (v6)
  {
    v7 = v6;
    operator delete(v6);
  }
  if (v4)
  {
    v5 = v4;
    operator delete(v4);
  }
  if (v3[0])
  {
    v3[1] = v3[0];
    operator delete(v3[0]);
  }
}

void sub_231093AB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  _Unwind_Resume(exception_object);
}

BOOL MTChordIntegrating::hasChordStabilized(MTChordIntegrating *this, const MTHandStatistics *a2, const MTHandMotion *a3)
{
  unsigned int v3;
  BOOL v5;

  if (*((_BYTE *)this + 264))
    return 1;
  v3 = *((unsigned __int8 *)a2 + 186);
  if (v3 == 5)
    return 1;
  v5 = *((unsigned __int8 *)a2 + 196) <= *((unsigned __int8 *)a2 + 195) && *((_BYTE *)a2 + 201) == 0;
  return v5
      && ((*((_WORD *)this + 114) & 0x100) == 0
       || sqrtf((float)(*((float *)a3 + 84) * *((float *)a3 + 84)) + (float)(*((float *)a3 + 83) * *((float *)a3 + 83))) <= 100.0)
      && *((double *)a2 + 1) - *((double *)a2 + 10) >= (double)v3 * 0.0100000007
      || *((double *)a2 + 1) - *((double *)a2 + 10) >= (double)v3 * 0.0200000014;
}

uint64_t MTChordIntegrating::getActiveDegreesOfFreedomMask(MTChordIntegrating *this, const MTHandStatistics *a2, const MTChordCycling *a3)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  int v11;

  if (!*((_BYTE *)this + 264))
    return 0;
  v4 = *((_QWORD *)this + 20);
  if (*((_QWORD *)this + 21) == v4)
    return 0;
  v7 = 0;
  v8 = 0;
  v9 = 1;
  do
  {
    v10 = v4 + 160 * v7;
    v11 = *(_DWORD *)(v10 + 28);
    if ((!v11 || (*((_DWORD *)a3 + 6) & v11) != 0)
      && !MTSlideGesture::isLockedOutByTriggeredSlide(v10, (uint64_t)a2, (uint64_t)this, 1))
    {
      v8 = MTSlideGesture::getDegreesOfFreedomMask(v10) | v8;
    }
    v7 = v9;
    v4 = *((_QWORD *)this + 20);
  }
  while (0xCCCCCCCCCCCCCCCDLL * ((*((_QWORD *)this + 21) - v4) >> 5) > v9++);
  return v8;
}

double MTChordIntegrating::beginChordIntegration(double *a1, uint64_t a2)
{
  double result;

  MTChordIntegrating::clearIntegrationState((MTChordIntegrating *)a1);
  result = *(double *)(a2 + 80);
  a1[30] = result;
  return result;
}

void MTChordIntegrating::endChordIntegration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(_DWORD *)(a1 + 224))
  {
    if (*(_BYTE *)(a1 + 264))
    {
      MTChordIntegrating::sendLiftSlideEvents(a1, a2, a3, a3 + 168, a4, a5);
    }
    else if (*(_BYTE *)(a1 + 266))
    {
      if (*(_QWORD *)(a1 + 104) == *(_QWORD *)(a1 + 96))
        std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
      (*(void (**)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, double))(**(_QWORD **)(a5 + 392)
                                                                                                 + 24))(*(_QWORD *)(a5 + 392), *(_QWORD *)(a1 + 96), a4, 32, 0, a3 + 168, 0x2000, *(double *)(a2 + 8));
      *(_BYTE *)(a1 + 266) = 0;
    }
    MTChordIntegrating::clearIntegrationState((MTChordIntegrating *)a1);
    MTChordIntegrating::nullify((void **)a1);
  }
}

void MTChordIntegrating::sendLiftSlideEvents(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v11;
  _WORD *v12;
  _QWORD *v13;
  uint64_t v14;
  double v15;
  char v16;
  unsigned int v17;
  uint64_t v18;
  double v19;
  uint64_t v20;
  MTActionEvent *v21;
  int v22;
  __int16 v23;
  _QWORD *v24;
  _WORD *v25;
  unint64_t v26;

  if (!*(_BYTE *)(a1 + 264))
    return;
  v11 = *(_DWORD *)(a1 + 216);
  if (v11 < 2)
  {
    v16 = 0;
  }
  else
  {
    v12 = *(_WORD **)(a1 + 96);
    if (v12 == *(_WORD **)(a1 + 104)
      || *v12 != 65
      || (v13 = *(_QWORD **)(a1 + 160), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a1 + 168) - (_QWORD)v13) >> 5) > 2)
      || *v13 == v13[1]
      || *(_WORD *)*v13 != 69
      || ((v14 = *(_QWORD *)(a1 + 272)) == 0 ? (v15 = 0.0) : (v15 = *(double *)(v14 + 144)),
          *(double *)(a2 + 8) - v15 >= *(double *)&qword_255EB3C18))
    {
      v16 = 0;
    }
    else
    {
      MTDragManagerEventQueue::stopMomentum(a6, a5, 4);
      MTTapDragManager::sustainMultiFingerDrag(*(_QWORD *)(a6 + 392), a2);
      if (!*(_BYTE *)(a1 + 264))
        return;
      v16 = 1;
    }
    v11 = *(_DWORD *)(a1 + 216);
  }
  if (v11 == 1 && *(_QWORD *)a1 != *(_QWORD *)(a1 + 8) && **(_WORD **)a1 == 65)
  {
    if (*(_BYTE *)(a2 + 186))
    {
      v17 = *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186);
      if (v17 >= *(unsigned __int8 *)(a2 + 190) + *(unsigned __int8 *)(a2 + 187))
        goto LABEL_28;
      v18 = *(_QWORD *)(a6 + 392);
      if (v17 > *(unsigned __int8 *)(v18 + 48))
        goto LABEL_28;
    }
    else
    {
      v18 = *(_QWORD *)(a6 + 392);
    }
    v19 = *(double *)(a2 + 8);
    if (*(int *)(v18 + 24) <= 1)
      v19 = 0.0;
    *(double *)(v18 + 80) = v19;
  }
LABEL_28:
  if ((v16 & 1) == 0)
  {
    v20 = *(_QWORD *)(a1 + 272);
    if (v20)
    {
      v21 = *(MTActionEvent **)v20;
      if (*(_QWORD *)v20 == *(_QWORD *)(v20 + 8))
        std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
      if (*(unsigned __int16 *)v21 - 35 > 4)
      {
        v22 = MTActionEvent::deriveGestureEndedType(v21);
        if (v22)
        {
          v23 = v22;
          v24 = *(_QWORD **)(a1 + 272);
          if (*v24 != v24[1] && (*(_WORD *)*v24 & 0xFFFE) == 0x46)
            (*(void (**)(_QWORD, double))(**(_QWORD **)(a6 + 392) + 24))(*(_QWORD *)(a6 + 392), *(double *)(a2 + 8));
          v26 = 0xAAAAAAAAAAAAAAAALL;
          MTActionEvent::MTActionEvent((MTActionEvent *)&v26, v23, 0, 0);
          (*(void (**)(_QWORD, unint64_t *, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD, double))(**(_QWORD **)(a6 + 392) + 24))(*(_QWORD *)(a6 + 392), &v26, a5, 0, 0, a4, 0x2000, *(unsigned int *)(a1 + 224), *(double *)(a2 + 8));
        }
      }
      else
      {
        MTChordIntegrating::possiblyStartFluidMomentum((_QWORD *)a1, (const MTHandStatistics *)a2, a5, a6);
      }
    }
    if (*(_WORD *)(a1 + 152))
    {
      v25 = *(_WORD **)(a1 + 128);
      if (v25 != *(_WORD **)(a1 + 136))
      {
        if (*v25)
          MTGesture::dispatchEvents((uint64_t *)(a1 + 128), *(_QWORD *)(a6 + 392), a5, 16, 0, a4, 0x2000, *(unsigned int *)(a1 + 224), *(double *)(a2 + 8));
      }
    }
  }
}

uint64_t MTChordIntegrating::possiblyStartFluidMomentum(_QWORD *a1, const MTHandStatistics *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v8;
  char v9;
  unsigned int v10;
  uint64_t *v11;
  float v12;
  int hasSufficientFluidMomentum;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float v17;
  int v18;
  int v19;
  int v20;
  _DWORD v25[4];

  v5 = a1[20];
  v4 = a1[21];
  if (v4 == v5)
  {
    v9 = 0;
  }
  else
  {
    v8 = 0;
    v9 = 0;
    v10 = 1;
    do
    {
      v11 = (uint64_t *)(v5 + 160 * v8);
      if (*((_BYTE *)v11 + 68))
      {
        v12 = MTSlideGesture::fluidSwipePercentage((MTSlideGesture *)(v5 + 160 * v8));
        hasSufficientFluidMomentum = MTSlideGesture::hasSufficientFluidMomentum((MTSlideGesture *)(v5 + 160 * v8), a2, v11 == (uint64_t *)a1[34]);
        v14 = *v11;
        if (v11[1] == *v11)
          std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
        v15 = *(_QWORD *)(a4 + 392);
        if (hasSufficientFluidMomentum)
          v16 = 16;
        else
          v16 = 32;
        v17 = MTSlideGesture::fluidMomentumPercentage_s((MTSlideGesture *)(v5 + 160 * v8), v11 == (uint64_t *)a1[34]);
        v25[0] = MTSlideGesture::fluidDOFPercentageDeltas((MTSlideGesture *)(v5 + 160 * v8));
        v25[1] = v18;
        v25[2] = v19;
        v25[3] = v20;
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _DWORD *, _QWORD, float, float))(*(_QWORD *)v15 + 32))(v15, v14, a3, v16, 0, v25, *(unsigned __int8 *)(v5 + 160 * v8 + 32), v12, v17);
        v5 = a1[20];
        v4 = a1[21];
        v9 = 1;
      }
      v8 = v10;
    }
    while (0xCCCCCCCCCCCCCCCDLL * ((v4 - v5) >> 5) > v10++);
  }
  return v9 & 1;
}

uint64_t MTChordIntegrating::commit2Chord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int16 a6, double a7)
{
  int v12;
  _WORD *v13;
  _QWORD *v14;
  uint64_t result;
  _WORD *v16;
  unint64_t v17;
  __int128 v18;

  *(_BYTE *)(a1 + 264) = 1;
  *(_QWORD *)(a1 + 256) = *(_QWORD *)(a2 + 8);
  v18 = *(_OWORD *)(a3 + 168);
  v12 = *(_DWORD *)(a1 + 216);
  if (v12 != 1)
  {
    if (v12 >= 2)
    {
      v13 = *(_WORD **)(a1 + 96);
      if (v13 != *(_WORD **)(a1 + 104) && *v13 == 65)
      {
        v14 = *(_QWORD **)(a1 + 160);
        if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a1 + 168) - (_QWORD)v14) >> 5) <= 2
          && *v14 != v14[1]
          && *(_WORD *)*v14 == 69)
        {
          *(_BYTE *)(a4 + 28) = 1;
          goto LABEL_5;
        }
      }
    }
LABEL_13:
    MTTapDragManager::sendPendingMultiFingerTap(a4, a5, a2, a3, 0, a7);
    MTTapDragManager::clearCycle(a4);
    goto LABEL_14;
  }
  if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8) || **(_WORD **)a1 != 65)
    goto LABEL_13;
  if (*(_DWORD *)(a4 + 24) == 2)
LABEL_5:
    MTTapDragManager::setCycleState(a4, 3);
LABEL_14:
  result = *(_QWORD *)(a1 + 272);
  if (!result)
    goto LABEL_23;
  if (*(_BYTE *)(a1 + 266))
  {
    if (*(_QWORD *)(result + 8) == *(_QWORD *)result)
      goto LABEL_28;
    if (**(_WORD **)result != 70)
    {
      if (*(_QWORD *)(a1 + 104) == *(_QWORD *)(a1 + 96))
        goto LABEL_28;
      (*(void (**)(uint64_t, double))(*(_QWORD *)a4 + 24))(a4, *(double *)(a2 + 8));
      *(_BYTE *)(a1 + 266) = 0;
      result = *(_QWORD *)(a1 + 272);
    }
  }
  if (*(_QWORD *)(result + 8) == *(_QWORD *)result)
LABEL_28:
    std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
  result = MTActionEvent::deriveGestureStartedType(*(MTActionEvent **)result);
  if ((_DWORD)result)
  {
    v17 = 0xAAAAAAAAAAAAAAAALL;
    MTActionEvent::MTActionEvent((MTActionEvent *)&v17, result, 0, 0);
    result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, uint64_t, _QWORD, __int128 *, uint64_t, _QWORD, double))(*(_QWORD *)a4 + 24))(a4, &v17, a5, 2, 0, &v18, 4096, *(unsigned int *)(a1 + 224), *(double *)(a2 + 8));
  }
LABEL_23:
  if ((*(_WORD *)(a1 + 120) & a6) != 0)
  {
    v16 = *(_WORD **)(a1 + 96);
    if (v16 != *(_WORD **)(a1 + 104))
    {
      if (*v16)
        return MTGesture::dispatchEvents((uint64_t *)(a1 + 96), a4, a5, 2, 0, (uint64_t)&v18, 4096, *(unsigned int *)(a1 + 224), *(double *)(a2 + 8));
    }
  }
  return result;
}

uint64_t MTChordIntegrating::sendSlidePreamble(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int16 a7, double a8)
{
  unsigned int v13;
  unsigned int v14;
  BOOL v15;
  BOOL v16;
  uint64_t v17;
  uint64_t result;
  int v19;
  uint64_t v20;
  uint64_t v21;
  __int16 v22;
  _QWORD *v23;
  __int16 v24;
  unint64_t v25;
  __int128 v26;

  v26 = *(_OWORD *)(a3 + 168);
  ++*(_DWORD *)(a1 + 300);
  v13 = *(unsigned __int8 *)(a2 + 186);
  *(_DWORD *)(a1 + 292) = v13;
  v14 = *(_DWORD *)(a1 + 296);
  if (!v14
    || (v14 < v13 ? (v15 = *(double *)(a2 + 8) - *(double *)(a2 + 80) <= *(double *)&qword_255EB3BD0) : (v15 = 1),
        v15 ? (v16 = v13 > 1) : (v16 = 0),
        !v16))
  {
    *(_DWORD *)(a1 + 296) = v13;
  }
  if (!*(_BYTE *)(a1 + 264))
  {
    *(_QWORD *)(a1 + 272) = a6;
    MTChordIntegrating::commit2Chord(a1, a2, a3, a4, a5, a7, a8);
    result = 1;
    if (!a6)
      return result;
    goto LABEL_34;
  }
  v17 = *(_QWORD *)(a1 + 272);
  if (v17 == a6)
    goto LABEL_17;
  result = 0;
  if (a6 && v17)
  {
    if (*(_QWORD *)(v17 + 8) == *(_QWORD *)v17)
      std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
    v19 = MTActionEvent::deriveGestureStartedType(*(MTActionEvent **)v17);
    if (*(_QWORD *)(a6 + 8) != *(_QWORD *)a6)
    {
      if (v19 == MTActionEvent::deriveGestureStartedType(*(MTActionEvent **)a6))
      {
LABEL_17:
        result = 0;
        goto LABEL_31;
      }
      v20 = *(_QWORD *)(a1 + 272);
      if (*(_QWORD *)(v20 + 8) != *(_QWORD *)v20)
      {
        if (MTActionEvent::deriveGestureEndedType(*(MTActionEvent **)v20))
        {
          v25 = 0xAAAAAAAAAAAAAAAALL;
          v21 = *(_QWORD *)(a1 + 272);
          if (*(_QWORD *)(v21 + 8) == *(_QWORD *)v21)
            goto LABEL_37;
          v22 = MTActionEvent::deriveGestureEndedType(*(MTActionEvent **)v21);
          MTActionEvent::MTActionEvent((MTActionEvent *)&v25, v22, 0, 0);
          (*(void (**)(uint64_t, unint64_t *, uint64_t, uint64_t, _QWORD, __int128 *, uint64_t, _QWORD, double))(*(_QWORD *)a4 + 24))(a4, &v25, a5, 16, 0, &v26, 0x2000, *(unsigned int *)(a1 + 224), *(double *)(a2 + 8));
          v23 = *(_QWORD **)(a1 + 272);
          if (*v23 != v23[1] && (*(_WORD *)*v23 & 0xFFFE) == 0x46)
            (*(void (**)(uint64_t, double))(*(_QWORD *)a4 + 24))(a4, *(double *)(a2 + 8));
        }
        if (*(_QWORD *)(a6 + 8) != *(_QWORD *)a6)
        {
          if (!MTActionEvent::deriveGestureStartedType(*(MTActionEvent **)a6))
          {
LABEL_30:
            result = 1;
            goto LABEL_31;
          }
          v25 = 0xAAAAAAAAAAAAAAAALL;
          if (*(_QWORD *)(a6 + 8) != *(_QWORD *)a6)
          {
            v24 = MTActionEvent::deriveGestureStartedType(*(MTActionEvent **)a6);
            MTActionEvent::MTActionEvent((MTActionEvent *)&v25, v24, 0, 0);
            (*(void (**)(uint64_t, unint64_t *, uint64_t, uint64_t, _QWORD, __int128 *, uint64_t, _QWORD, double))(*(_QWORD *)a4 + 24))(a4, &v25, a5, 2, 0, &v26, 0x2000, *(unsigned int *)(a1 + 224), *(double *)(a2 + 8));
            goto LABEL_30;
          }
        }
      }
    }
LABEL_37:
    std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
  }
LABEL_31:
  if (*(_QWORD *)(a1 + 272) != a6)
  {
    *(_DWORD *)(a1 + 392) = 0;
    *(_OWORD *)(a1 + 360) = 0u;
    *(_OWORD *)(a1 + 376) = 0u;
    *(_OWORD *)(a1 + 328) = 0u;
    *(_OWORD *)(a1 + 344) = 0u;
    *(_OWORD *)(a1 + 312) = 0u;
  }
  *(_QWORD *)(a1 + 272) = a6;
  if (a6)
  {
LABEL_34:
    if (*(_BYTE *)(a1 + 265))
      *(_BYTE *)(a1 + 265) = 0;
  }
  return result;
}

double MTChordIntegrating::clearMomentumFilters(MTChordIntegrating *this)
{
  double result;

  *((_DWORD *)this + 98) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  return result;
}

uint64_t MTChordIntegrating::resetMostIntegrators(uint64_t this, MTSlideGesture *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;

  v3 = *(_QWORD *)(this + 160);
  v2 = *(_QWORD *)(this + 168);
  if (v2 != v3)
  {
    v4 = 0;
    v5 = 1;
    do
    {
      if ((MTSlideGesture *)(v3 + 160 * v4) != a2)
      {
        v6 = v3 + 160 * v4;
        *(_DWORD *)(v6 + 120) = 0;
        *(_OWORD *)(v6 + 80) = 0uLL;
        *(_OWORD *)(v6 + 96) = 0uLL;
        v3 = *(_QWORD *)(this + 160);
        v2 = *(_QWORD *)(this + 168);
      }
      v4 = v5;
    }
    while (0xCCCCCCCCCCCCCCCDLL * ((v2 - v3) >> 5) > v5++);
  }
  return this;
}

BOOL MTChordIntegrating::momentumHistoryTimedOut(MTChordIntegrating *this, double a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 34);
  return !v2 || a2 - *(double *)(v2 + 144) > 0.100000001;
}

void MTChordIntegrating::momentumFilterAlpha(MTChordIntegrating *this, const MTHandStatistics *a2, int a3)
{
  double v3;

  v3 = (*((double *)a2 + 1) - *((double *)a2 + 2)) / 0.00800000038;
  if (a3)
  {
    exp2(v3 * -2.0);
    pow(0.800000012, v3);
  }
  else
  {
    pow(0.850000024, v3);
  }
}

float MTChordIntegrating::filteredMomentumSquared(MTChordIntegrating *this)
{
  return (float)(*((float *)this + 91) * *((float *)this + 91)) + (float)(*((float *)this + 90) * *((float *)this + 90));
}

double MTChordIntegrating::decayMomentumFilters(MTChordIntegrating *this, const MTHandStatistics *a2)
{
  uint64_t v2;
  double result;
  int32x4_t v4;

  v2 = *((_QWORD *)this + 34);
  if (v2)
  {
    result = *((double *)a2 + 1);
    if (result != *(double *)(v2 + 144))
    {
      v4 = 0uLL;
      *(_QWORD *)&result = MTChordIntegrating::updateMomentumMickeys((uint64_t)this, &v4, (double *)a2).u64[0];
    }
  }
  return result;
}

float32x4_t MTChordIntegrating::updateMomentumMickeys(uint64_t a1, int32x4_t *a2, double *a3)
{
  float32x4_t *v6;
  uint64_t v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  long double v13;
  float v14;
  float v15;
  float v16;
  _BOOL4 v17;
  MTChordIntegrating *v18;
  float v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t result;
  float32x4_t v23;
  float v24;
  float v25;
  float v26;

  v6 = (float32x4_t *)(a1 + 360);
  v7 = *(_QWORD *)(a1 + 272);
  if (v7 && a3[1] - *(double *)(v7 + 144) <= 0.100000001)
  {
    v11 = *(float *)(a1 + 392);
    v10 = *(float *)(a1 + 376);
    v9 = *(float *)(a1 + 380);
    v8 = *(float *)(a1 + 360);
    v26 = *(float *)(a1 + 364);
  }
  else
  {
    *(_DWORD *)(a1 + 392) = 0;
    *(_OWORD *)(a1 + 360) = 0u;
    *(_OWORD *)(a1 + 376) = 0u;
    *(_OWORD *)(a1 + 328) = 0u;
    *(_OWORD *)(a1 + 344) = 0u;
    *(_OWORD *)(a1 + 312) = 0u;
    v26 = 0.0;
    v8 = 0.0;
    v9 = 0.0;
    v10 = 0.0;
    v11 = 0.0;
  }
  *(int32x4_t *)(a1 + 328) = *a2;
  v12 = hypot((double)a2->i32[0], (double)a2->i32[1]);
  v13 = (a3[1] - a3[2]) / 0.00800000038;
  v14 = pow(dbl_2310BD6F0[v11 < (float)(v12 + v12)], v13);
  *(float *)(a1 + 392) = (float)((float)(1.0 - v14) * v12) + (float)(v14 * v11);
  v15 = hypotf(v10, v9);
  v16 = pow(dbl_2310BD700[v15 < (float)(v12 + v12)], v13);
  v25 = v16;
  v24 = 1.0 - v16;
  v17 = hypotf(v8, v26) < v12;
  MTChordIntegrating::momentumFilterAlpha(v18, (const MTHandStatistics *)a3, v17);
  v20 = vcvtq_f32_s32(*a2);
  v21 = vmlaq_n_f32(vmulq_n_f32(v20, 1.0 - v19), *v6, v19);
  result = (float32x4_t)vbicq_s8((int8x16_t)v21, (int8x16_t)vcltzq_f32(vmulq_f32(v21, v20)));
  v23 = vmlaq_n_f32(vmulq_n_f32(v20, v24), v6[1], v25);
  *v6 = result;
  v6[1] = v23;
  return result;
}

BOOL MTChordIntegrating::significantMomentumMickeys(MTChordIntegrating *this, float a2)
{
  return (float)((float)(*((float *)this + 91) * *((float *)this + 91))
               + (float)(*((float *)this + 90) * *((float *)this + 90))) >= (float)(a2 * a2);
}

uint64_t MTChordIntegrating::switchingVerticalToHorizontal(int32x2_t *this, float a2, int a3)
{
  int v3;
  int v4;
  int32x2_t v5;
  unsigned __int8 v6;

  if (a3)
    *(_OWORD *)this[43].i8 = *(_OWORD *)this[41].i8;
  v3 = this[43].i32[0];
  if (v3 < 0)
    v3 = -v3;
  v4 = this[43].i32[1];
  if (v4 < 0)
    v4 = -v4;
  if (v3 >= (2 * v4))
  {
    v6 = 0;
  }
  else
  {
    v5 = vabs_s32(this[41]);
    v6 = vcgt_u32((uint32x2_t)v5, (uint32x2_t)vdup_lane_s32(v5, 1)).u8[0];
  }
  return v6 & 1;
}

uint64_t MTChordIntegrating::markMomentumPause(MTChordIntegrating *this, const MTHandStatistics *a2)
{
  MTChordIntegrating::markMomentumPause(this, a2, 3.0, (double *)this + 40);
  return MTChordIntegrating::markMomentumPause(this, a2, 3.5, (double *)this + 39);
}

uint64_t MTChordIntegrating::markMomentumPause(MTChordIntegrating *this, const MTHandStatistics *a2, float a3, double *a4)
{
  float v6;
  float v7;
  int v9;
  int v10;
  float v11;
  float v12;
  float v13;
  float v14;
  uint64_t result;
  BOOL v16;

  v6 = *((float *)this + 98) * a3;
  if (v6 >= 1.0)
    v7 = v6;
  else
    v7 = 1.0;
  if ((float)((float)(*((float *)this + 91) * *((float *)this + 91))
             + (float)(*((float *)this + 90) * *((float *)this + 90))) <= v7)
    goto LABEL_10;
  v9 = *((_DWORD *)this + 82);
  v10 = *((_DWORD *)this + 83);
  v11 = hypot((double)v9, (double)v10);
  v12 = *((float *)this + 94);
  v13 = *((float *)this + 95);
  v14 = hypotf(v12, v13);
  result = 0;
  v16 = (float)(v11 * v11) <= v7 || (float)(v14 * v14) <= v7;
  if (!v16 && (float)((float)((float)(v13 * (float)v10) + (float)(v12 * (float)v9)) / (float)(v14 * v11)) < -0.5)
  {
LABEL_10:
    *a4 = *((double *)a2 + 1);
    return 1;
  }
  return result;
}

BOOL MTChordIntegrating::recentMomentumPause(MTChordIntegrating *this, const MTHandStatistics *a2, int a3)
{
  uint64_t v3;
  double v4;
  uint64_t *v5;

  v3 = 312;
  if (a3)
    v3 = 320;
  v4 = *((double *)a2 + 1) - *(double *)((char *)this + v3);
  v5 = &qword_255EB3BD0;
  if (a3)
    v5 = &qword_255EB3BD8;
  return v4 < *(double *)v5;
}

uint64_t MTChordIntegrating::possiblyStartMomentum(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  _WORD *v6;
  int v10;
  float v11;
  float v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  int v16;
  unsigned int v17;
  float v18;
  unsigned int v19;
  uint64_t v20;

  if (!*(_BYTE *)(a1 + 264))
    return 0;
  v5 = *(_QWORD *)(a1 + 272);
  if (!v5)
    return 0;
  if ((*(_BYTE *)(v5 + 34) & 0x40) == 0)
    return 0;
  v6 = *(_WORD **)v5;
  if (*(_QWORD *)v5 == *(_QWORD *)(v5 + 8))
    return 0;
  v10 = (unsigned __int16)*v6;
  if (v10 == 69)
  {
    v13 = *(unsigned __int8 *)(a2 + 186);
    v14 = *(unsigned __int8 *)(a2 + 211) + v13;
    if (v14
      && (float)((float)(*(float *)(a1 + 364) * *(float *)(a1 + 364))
               + (float)(*(float *)(a1 + 360) * *(float *)(a1 + 360))) >= 25.0)
    {
      if (v14 != 1 || v13 <= *(unsigned __int8 *)(a2 + 195))
      {
        MTDragManagerEventQueue::startMomentum(a4, a3, 4);
        goto LABEL_36;
      }
      MTDragManagerEventQueue::stopMomentum(a4, a3, 4);
      return 0;
    }
    goto LABEL_11;
  }
  if (v10 != 70
    || (v11 = *(float *)(a1 + 360), v12 = *(float *)(a1 + 364), (float)((float)(v12 * v12) + (float)(v11 * v11)) < 25.0))
  {
LABEL_11:
    if (*v6 == 68
      && *(double *)(a2 + 8) - *(double *)(a4 + 1240) > *(double *)&qword_255EB3BF8
      && (float)((float)(*(float *)(a1 + 364) * *(float *)(a1 + 364))
               + (float)(*(float *)(a1 + 360) * *(float *)(a1 + 360))) >= 64.0)
    {
      MTDragManagerEventQueue::startMomentum(a4, a3, 2);
LABEL_36:
      MTAppendRelativeMouseEvent();
      return 1;
    }
    return 0;
  }
  v15 = (int)(float)-v11;
  v16 = (int)(float)-v12;
  if (v15 >= 0)
    v17 = (int)(float)-v11;
  else
    v17 = -v15;
  v18 = (float)v17;
  if (v16 >= 0)
    v19 = v16;
  else
    v19 = -v16;
  if ((float)((float)v19 * 3.0) >= v18)
  {
    if ((float)(v18 * 3.0) < (float)v19)
      v15 = 0;
  }
  else
  {
    v16 = 0;
  }
  if ((float)((float)((float)v16 * (float)v16) + (float)((float)v15 * (float)v15)) < 25.0
    || *(double *)(a2 + 8) - *(double *)(a1 + 400) <= 0.05)
  {
    return 1;
  }
  v20 = 1;
  MTAppendMomentumEnableEvent();
  MTAppendScrollEvent();
  if (*(_BYTE *)(a4 + 1264))
    MTDragManagerEventQueue::stopMomentum(a4, a3, 1);
  *(_QWORD *)(a1 + 400) = *(_QWORD *)(a2 + 8);
  *(_DWORD *)(a4 + 1268) = 1;
  *(_BYTE *)(a4 + 1264) = 1;
  return v20;
}

uint64_t MTChordIntegrating::clearMickeysSinceLastTouchdown(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  _DWORD *v4;
  unsigned int v5;

  *(_DWORD *)(this + 288) = 0;
  v1 = *(_QWORD *)(this + 160);
  v2 = *(_QWORD *)(this + 168) - v1;
  if (v2)
  {
    v3 = 0xCCCCCCCCCCCCCCCDLL * (v2 >> 5);
    v4 = (_DWORD *)(v1 + 112);
    v5 = 1;
    do
    {
      *v4 = 0;
      v4 += 40;
    }
    while (v3 > v5++);
  }
  return this;
}

BOOL MTChordIntegrating::waitForFastShotVerification(MTChordIntegrating *this, const MTHandStatistics *a2, const MTHandMotion *a3)
{
  double v3;

  if (*((_DWORD *)this + 75) != 1)
    return 0;
  v3 = *((double *)a2 + 1) - *((double *)a2 + 7);
  if (v3 < 0.135000005)
    return 1;
  if (v3 >= 0.230000004)
    return 0;
  if (!*((_BYTE *)a2 + 186))
    return 1;
  return *((unsigned __int8 *)a2 + 191) > *((unsigned __int8 *)a2 + 186);
}

uint64_t MTChordIntegrating::continueChordIntegration(MTChordGestureSet *this, MTHandStatistics *a2, const MTHandMotion *a3, uint64_t a4, uint64_t a5, double a6, double a7, float a8)
{
  uint64_t v12;
  double v13;
  uint64_t result;
  double v15;
  double v16;
  int v17;
  double v18;
  double v19;
  double v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  float v25;
  unsigned int v26;
  const MTHandMotion *v27;
  unsigned __int16 **v28;
  int v29;
  const MTHandMotion *v30;
  float v31;
  _BOOL4 canPunishSomeMoving;
  BOOL v33;
  unsigned __int16 **v34;
  uint64_t v35;
  float v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  BOOL v40;
  _BOOL4 v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t v46;
  int v47;
  double v48;
  uint64_t v49;
  double v50;
  _WORD *v51;
  uint64_t v52;
  uint64_t v53;
  float *v55;
  int v56;
  unsigned __int16 **v57;

  v12 = *((_QWORD *)this + 34);
  if (v12)
    v13 = *(double *)(v12 + 144);
  else
    v13 = 0.0;
  result = MTChordGestureSet::chk4ChordPause(this, a2, a3, *((double *)a2 + 1) - v13, v13, a8);
  if ((_DWORD)result)
  {
    v15 = *((double *)a2 + 1);
    if (*((_BYTE *)this + 265))
    {
      v16 = *((double *)this + 38);
    }
    else
    {
      *((double *)this + 38) = v15;
      v16 = v15;
    }
    *((_BYTE *)this + 265) = 1;
    if (v15 - v16 > 0.120000005)
      *((_BYTE *)this + 267) = 0;
  }
  v17 = *((_DWORD *)this + 58);
  if (v17 && (*(_DWORD *)(a5 + 24) & v17) == 0)
    goto LABEL_83;
  v18 = *((double *)a2 + 1);
  v19 = *(double *)(a5 + 1240);
  if ((*((_WORD *)this + 60) & 0x100) != 0 && !*((_BYTE *)this + 266) && !*((_BYTE *)this + 264))
  {
    result = *(_QWORD *)(a5 + 392);
    if ((!*(_BYTE *)(result + 28) || *(int *)(result + 24) <= 2)
      && v18 - *((double *)this + 31) > *(double *)&qword_255EB3BE0)
    {
      if (*((_QWORD *)this + 13) == *((_QWORD *)this + 12))
        std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
      result = (*(uint64_t (**)(uint64_t, double))(*(_QWORD *)result + 24))(result, *((double *)a2 + 1));
      *((_BYTE *)this + 266) = 1;
    }
  }
  v20 = v18 - v19;
  if (!*((_BYTE *)this + 264))
  {
    result = MTChordIntegrating::hasChordStabilized(this, a2, a3);
    if ((_DWORD)result)
    {
      result = MTChordGestureSet::chk4ChordTimein(this, a2);
      if ((_DWORD)result)
        result = MTChordIntegrating::sendSlidePreamble((uint64_t)this, (uint64_t)a2, (uint64_t)a3, *(_QWORD *)(a5 + 392), a4, 0, 4u, v20);
    }
  }
  v21 = *((_QWORD *)this + 20);
  if (*((_QWORD *)this + 21) == v21)
    goto LABEL_83;
  v52 = a4;
  v53 = 0;
  v22 = 0;
  v55 = 0;
  v23 = 0;
  v57 = 0;
  v56 = 0;
  v24 = 0;
  v25 = 0.0;
  v26 = 1;
  v27 = a3;
  do
  {
    v28 = (unsigned __int16 **)(v21 + 160 * v22);
    v29 = *((_DWORD *)v28 + 7);
    if (!v29 || (*(_DWORD *)(a5 + 24) & v29) != 0)
    {
      v30 = v27;
      if ((MTSlideGesture::isBlocked((unsigned __int16 **)(v21 + 160 * v22), (uint64_t)a2, (uint64_t)v27, (uint64_t)this, *(_BYTE *)(a5 + 400)) & 1) != 0)
      {
        v27 = v30;
        goto LABEL_40;
      }
      v31 = MTSlideGesture::integrateGesture((MTSlideGesture *)(v21 + 160 * v22), a2, v30, *(const MTDragManagerEventQueue **)(a5 + 392), this, *((double *)a2 + 1) - *(double *)(a5 + 1232));
      canPunishSomeMoving = MTSlideGesture::canPunishSomeMoving((MTSlideGesture *)(v21 + 160 * v22), (uint64_t)a2, (uint64_t)this);
      v33 = v31 < v25;
      if (v31 >= v25)
        v25 = v31;
      v34 = v57;
      if (!v33)
        v34 = (unsigned __int16 **)(v21 + 160 * v22);
      v57 = v34;
      if (*v28 == v28[1] || **v28 - 35 > 4)
      {
        v37 = v23;
        v27 = a3;
        v28 = (unsigned __int16 **)v55;
      }
      else
      {
        v27 = a3;
        if (!v53 || (v35 = v53, fabsf(*(float *)(v21 + 160 * v22 + 80)) > fabsf(*(float *)(v53 + 80))))
          v35 = v21 + 160 * v22;
        v53 = v35;
        if (v23)
        {
          v36 = fabsf(*(float *)(v21 + 160 * v22 + 92));
          if (v36 <= fabsf(*(float *)(v23 + 92)))
          {
            v38 = v56;
            if (v55 && v36 <= fabsf(v55[23]))
            {
              v37 = v23;
              v28 = (unsigned __int16 **)v55;
            }
            else
            {
              v37 = v23;
            }
            goto LABEL_39;
          }
          v37 = v21 + 160 * v22;
          v28 = (unsigned __int16 **)v23;
        }
        else
        {
          v37 = v21 + 160 * v22;
          v28 = 0;
        }
      }
      v38 = v56;
LABEL_39:
      v56 = v38 + canPunishSomeMoving;
      ++v24;
      v23 = v37;
      v55 = (float *)v28;
    }
LABEL_40:
    v22 = v26;
    v21 = *((_QWORD *)this + 20);
    v39 = *((_QWORD *)this + 21);
    v40 = 0xCCCCCCCCCCCCCCCDLL * ((v39 - v21) >> 5) > v26++;
  }
  while (v40);
  v41 = 0;
  if (v23)
  {
    v42 = v24;
    if (v53 == v23)
      v41 = !v55 || (float)(fabsf(*(float *)(v23 + 92)) - *(float *)(v23 + 56)) > fabsf(v55[23]);
  }
  else
  {
    v42 = v24;
  }
  result = MTChordIntegrating::hasChordStabilized(this, a2, v27);
  if (!(_DWORD)result || v42 < 1)
    goto LABEL_83;
  result = *((_QWORD *)this + 34);
  if (!v23 || result)
    goto LABEL_66;
  if (v57 == (unsigned __int16 **)v23)
    goto LABEL_62;
  if (!v57)
    goto LABEL_76;
  if (*v57 == v57[1] || **v57 - 35 > 4)
  {
LABEL_66:
    if (v42 >= 2 && v56 >= 1 && v57)
    {
      if (v25 <= 0.2 && *((double *)a2 + 1) - *((double *)this + 31) <= *(double *)&qword_255EB3BE8)
        goto LABEL_83;
      v43 = *(_QWORD *)(a5 + 392);
      result = (uint64_t)v57;
LABEL_70:
      result = MTSlideGesture::fireGesture(result, a2, a3, v43, v52, this, v20);
      goto LABEL_83;
    }
    if (result && *(_QWORD *)result != *(_QWORD *)(result + 8) && **(unsigned __int16 **)result - 35 <= 4)
    {
      v43 = *(_QWORD *)(a5 + 392);
      if (v53)
        result = v53;
      goto LABEL_70;
    }
LABEL_76:
    if (v39 != v21)
    {
      v44 = 0;
      v45 = 1;
      do
      {
        v46 = v21 + 160 * v44;
        v47 = *(_DWORD *)(v46 + 28);
        if (!v47 || (*(_DWORD *)(a5 + 24) & v47) != 0)
        {
          result = MTSlideGesture::isBlocked((unsigned __int16 **)v46, (uint64_t)a2, (uint64_t)a3, (uint64_t)this, *(_BYTE *)(a5 + 400));
          if ((result & 1) == 0)
            result = MTSlideGesture::fireGesture(v46, a2, a3, *(_QWORD *)(a5 + 392), v52, this, v20);
        }
        v44 = v45;
        v21 = *((_QWORD *)this + 20);
        v40 = 0xCCCCCCCCCCCCCCCDLL * ((*((_QWORD *)this + 21) - v21) >> 5) > v45++;
      }
      while (v40);
    }
    goto LABEL_83;
  }
LABEL_62:
  if (v41)
  {
    v43 = *(_QWORD *)(a5 + 392);
    result = v23;
    goto LABEL_70;
  }
LABEL_83:
  v48 = *((double *)a2 + 1);
  v49 = *((_QWORD *)this + 34);
  if (v49)
  {
    v50 = *(double *)(v49 + 144);
    if (v48 - v50 < v48 - *(double *)(a5 + 1232))
    {
      *(double *)(a5 + 1232) = v50;
      v51 = *(_WORD **)v49;
      if (*(_QWORD *)v49 != *(_QWORD *)(v49 + 8))
      {
        if ((*v51 & 0xFFFE) == 0x46)
          *(double *)(a5 + 1240) = v50;
        if ((unsigned __int16)*v51 - 35 <= 4)
          *(double *)(a5 + 1248) = v50;
      }
    }
  }
  else if (v48 < v48 - *(double *)(a5 + 1232))
  {
    *(_QWORD *)(a5 + 1232) = 0;
  }
  return result;
}

void MTSimpleEventDispatcher::MTSimpleEventDispatcher(MTSimpleEventDispatcher *this)
{
  *(_QWORD *)this = &off_24FFF1518;
  atomic_store(1u, (unsigned int *)this + 2);
}

{
  *(_QWORD *)this = &off_24FFF1518;
  atomic_store(1u, (unsigned int *)this + 2);
}

uint64_t MTSimpleEventDispatcher::createDispatcher(MTSimpleHIDManager *a1, const void *a2)
{
  uint64_t v4;

  v4 = operator new();
  *(_QWORD *)v4 = &off_24FFF1518;
  atomic_store(1u, (unsigned int *)(v4 + 8));
  MTSimpleEventDispatcher::initialize(v4, a1, a2);
  return v4;
}

void MTSimpleEventDispatcher::initialize(uint64_t a1, MTSimpleHIDManager *this, const void *a3)
{
  io_registry_entry_t Service;
  const __CFBoolean *CFProperty;
  const __CFBoolean *v7;
  CFTypeID v8;

  *(_QWORD *)(a1 + 16) = this;
  MTSimpleHIDManager::retain((uint64_t)this);
  *(_QWORD *)(a1 + 48) = CFRetain(a3);
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 424) = MTPreferencesGetAppBooleanValue(CFSTR("DispatchAllHIDEvents"), CFSTR("com.apple.MultitouchSupport"), 0);
  *(_BYTE *)(a1 + 64) = 0;
  Service = MTDeviceGetService();
  CFProperty = (const __CFBoolean *)IORegistryEntryCreateCFProperty(Service, CFSTR("MTHIDDevice"), (CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
  if (CFProperty)
  {
    v7 = CFProperty;
    v8 = CFGetTypeID(CFProperty);
    if (v8 == CFBooleanGetTypeID())
      *(_BYTE *)(a1 + 64) = CFBooleanGetValue(v7) != 0;
    CFRelease(v7);
  }
  *(_QWORD *)(a1 + 72) = 0;
}

uint64_t MTSimpleEventDispatcher::getMTDevice(MTSimpleEventDispatcher *this)
{
  return *((_QWORD *)this + 6);
}

uint64_t MTSimpleEventDispatcher::getOwner(MTSimpleEventDispatcher *this)
{
  return *((_QWORD *)this + 2);
}

void MTSimpleEventDispatcher::~MTSimpleEventDispatcher(MTSimpleEventDispatcher *this)
{
  JUMPOUT(0x2348D0034);
}

unsigned int *MTSimpleEventDispatcher::finalize(MTSimpleEventDispatcher *this)
{
  NSObject *v2;
  const void *v3;
  unsigned int *result;

  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    dispatch_release(v2);
    *((_QWORD *)this + 9) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 6);
  if (v3)
  {
    CFRelease(v3);
    *((_QWORD *)this + 6) = 0;
  }
  result = MTSimpleHIDManager::release(*((unsigned int **)this + 2));
  *((_QWORD *)this + 2) = 0;
  return result;
}

uint64_t MTSimpleEventDispatcher::retain(uint64_t this)
{
  unsigned int *v1;
  unsigned int v3;

  v1 = (unsigned int *)(this + 8);
  if (!atomic_load((unsigned int *)(this + 8)))
    MTSimpleEventDispatcher::retain();
  do
    v3 = __ldaxr(v1);
  while (__stlxr(v3 + 1, v1));
  return this;
}

unsigned int *MTSimpleEventDispatcher::release(unsigned int *this)
{
  unsigned int *v1;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;

  v1 = this + 2;
  if (!atomic_load(this + 2))
    MTSimpleEventDispatcher::release();
  v3 = (uint64_t)this;
  do
  {
    v4 = __ldaxr(v1);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, v1));
  if (!v5)
  {
    (*(void (**)(unsigned int *))(*(_QWORD *)this + 24))(this);
    return (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return this;
}

uint64_t MTSimpleEventDispatcher::setDispatchAllHIDEvents(uint64_t this, char a2)
{
  *(_BYTE *)(this + 424) = a2;
  return this;
}

uint64_t MTSimpleEventDispatcher::shouldDispatchAllHIDEvents(MTSimpleEventDispatcher *this)
{
  return *((unsigned __int8 *)this + 424);
}

void MTSimpleEventDispatcher::setHIDDispatchQueue(MTSimpleEventDispatcher *this, dispatch_object_t object)
{
  NSObject *v4;

  if (object)
    dispatch_retain(object);
  v4 = *((_QWORD *)this + 9);
  if (v4)
    dispatch_release(v4);
  *((_QWORD *)this + 9) = object;
}

uint64_t MTSimpleEventDispatcher::getHIDDispatchQueue(MTSimpleEventDispatcher *this)
{
  return *((_QWORD *)this + 9);
}

_QWORD *MTSimpleEventDispatcher::setEventCallback(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  result[3] = a2;
  result[4] = a3;
  result[5] = a4;
  return result;
}

uint64_t MTSimpleEventDispatcher::shouldDispatchEvent()
{
  return 1;
}

__CFDictionary *MTSimpleEventDispatcher::copyDebugData(MTSimpleEventDispatcher *this)
{
  const __CFAllocator *v2;
  __CFDictionary *Mutable;
  CFDateFormatterRef v4;
  __CFDateFormatter *v5;
  CFTimeZoneRef v6;
  CFTimeZoneRef v7;
  uint64_t v8;
  char *v9;
  double v10;
  CFStringRef StringWithAbsoluteTime;
  CFStringRef v12;
  const void *Name;

  v2 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 43, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (Mutable)
  {
    v4 = CFDateFormatterCreate(v2, 0, kCFDateFormatterShortStyle, kCFDateFormatterFullStyle);
    if (v4)
    {
      v5 = v4;
      v6 = CFTimeZoneCopySystem();
      if (v6)
      {
        v7 = v6;
        CFDateFormatterSetProperty(v5, (CFStringRef)*MEMORY[0x24BDBD340], v6);
        CFRelease(v7);
      }
      v8 = 0;
      v9 = (char *)this + 80;
      do
      {
        v10 = *(double *)&v9[8 * v8];
        if (v10 > 0.0)
        {
          StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(v2, v5, v10);
          if (StringWithAbsoluteTime)
          {
            v12 = StringWithAbsoluteTime;
            Name = (const void *)IOHIDEventTypeGetName();
            CFDictionarySetValue(Mutable, Name, v12);
            CFRelease(v12);
          }
        }
        ++v8;
      }
      while (v8 != 43);
      CFRelease(v5);
    }
  }
  return Mutable;
}

uint64_t MTSimpleEmbeddedEventDispatcher::markEventDispatchAllMode(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return IOHIDEventSetIntegerValue();
  return result;
}

uint64_t MTSimpleEmbeddedEventDispatcher::createDispatcher(MTSimpleHIDManager *a1, const void *a2)
{
  uint64_t v4;

  v4 = operator new();
  *(_OWORD *)v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_OWORD *)(v4 + 96) = 0u;
  *(_OWORD *)(v4 + 112) = 0u;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 144) = 0u;
  *(_OWORD *)(v4 + 160) = 0u;
  *(_OWORD *)(v4 + 176) = 0u;
  *(_OWORD *)(v4 + 192) = 0u;
  *(_OWORD *)(v4 + 208) = 0u;
  *(_OWORD *)(v4 + 224) = 0u;
  *(_OWORD *)(v4 + 240) = 0u;
  *(_OWORD *)(v4 + 256) = 0u;
  *(_OWORD *)(v4 + 272) = 0u;
  *(_OWORD *)(v4 + 288) = 0u;
  *(_OWORD *)(v4 + 304) = 0u;
  *(_OWORD *)(v4 + 320) = 0u;
  *(_OWORD *)(v4 + 336) = 0u;
  *(_OWORD *)(v4 + 352) = 0u;
  *(_OWORD *)(v4 + 368) = 0u;
  *(_OWORD *)(v4 + 384) = 0u;
  *(_OWORD *)(v4 + 400) = 0u;
  *(_OWORD *)(v4 + 416) = 0u;
  *(_QWORD *)v4 = &off_24FFF1518;
  atomic_store(1u, (unsigned int *)(v4 + 8));
  *(_QWORD *)v4 = &off_24FFF15A8;
  MTSimpleEventDispatcher::initialize(v4, a1, a2);
  return v4;
}

uint64_t MTSimpleEmbeddedEventDispatcher::shouldDispatchEvent(_BYTE *a1, uint64_t a2)
{
  uint64_t v4;

  if ((IOHIDEventGetIntegerValue() & 0xF0FB17FFLL) != 0
    || (IOHIDEventGetIntegerValue() & 1) != 0
    || (IOHIDEventGetIntegerValue() & 2) != 0
    || IOHIDEventConformsTo()
    || IOHIDEventConformsTo())
  {
    return 1;
  }
  v4 = 1;
  if (!IOHIDEventConformsTo())
  {
    if (a1[424])
      (*(void (**)(_BYTE *, uint64_t))(*(_QWORD *)a1 + 112))(a1, a2);
    else
      return 0;
  }
  return v4;
}

uint64_t MTSimpleEmbeddedStylusEventDispatcher::createDispatcher(MTSimpleHIDManager *a1, const void *a2)
{
  uint64_t v4;

  v4 = operator new();
  *(_OWORD *)v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_OWORD *)(v4 + 96) = 0u;
  *(_OWORD *)(v4 + 112) = 0u;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 144) = 0u;
  *(_OWORD *)(v4 + 160) = 0u;
  *(_OWORD *)(v4 + 176) = 0u;
  *(_OWORD *)(v4 + 192) = 0u;
  *(_OWORD *)(v4 + 208) = 0u;
  *(_OWORD *)(v4 + 224) = 0u;
  *(_OWORD *)(v4 + 240) = 0u;
  *(_OWORD *)(v4 + 256) = 0u;
  *(_OWORD *)(v4 + 272) = 0u;
  *(_OWORD *)(v4 + 288) = 0u;
  *(_OWORD *)(v4 + 304) = 0u;
  *(_OWORD *)(v4 + 320) = 0u;
  *(_OWORD *)(v4 + 336) = 0u;
  *(_OWORD *)(v4 + 352) = 0u;
  *(_OWORD *)(v4 + 368) = 0u;
  *(_OWORD *)(v4 + 384) = 0u;
  *(_OWORD *)(v4 + 400) = 0u;
  *(_OWORD *)(v4 + 416) = 0u;
  *(_QWORD *)v4 = &off_24FFF1518;
  atomic_store(1u, (unsigned int *)(v4 + 8));
  *(_QWORD *)v4 = &off_24FFF1648;
  MTSimpleEventDispatcher::initialize(v4, a1, a2);
  return v4;
}

uint64_t MTSimpleEmbeddedStylusEventDispatcher::shouldDispatchEvent()
{
  return 1;
}

void MTSimpleEmbeddedEventDispatcher::~MTSimpleEmbeddedEventDispatcher(MTSimpleEmbeddedEventDispatcher *this)
{
  JUMPOUT(0x2348D0034);
}

void MTSimpleEmbeddedStylusEventDispatcher::~MTSimpleEmbeddedStylusEventDispatcher(MTSimpleEmbeddedStylusEventDispatcher *this)
{
  JUMPOUT(0x2348D0034);
}

uint64_t MTPreferencesGetAppIntegerValue(const __CFString *a1, const __CFString *a2, unsigned __int8 *a3)
{
  uint64_t v4;
  const __CFString *v5;
  const __CFString *v6;
  CFTypeID v7;
  SInt32 IntValue;
  unsigned __int8 Value;
  uint64_t valuePtr;

  valuePtr = 0;
  if (a3)
    *a3 = 0;
  v4 = 0;
  if (a1 && a2)
  {
    v5 = (const __CFString *)IOHIDPreferencesCopyDomain();
    if (v5)
    {
      v6 = v5;
      v7 = CFGetTypeID(v5);
      if (v7 == CFStringGetTypeID())
      {
        IntValue = CFStringGetIntValue(v6);
        valuePtr = IntValue;
        Value = IntValue != 0;
        if (!a3)
          goto LABEL_14;
      }
      else if (v7 == CFNumberGetTypeID() && !CFNumberIsFloatType((CFNumberRef)v6))
      {
        Value = CFNumberGetValue((CFNumberRef)v6, kCFNumberCFIndexType, &valuePtr);
        if (!a3)
          goto LABEL_14;
      }
      else
      {
        Value = 0;
        if (!a3)
        {
LABEL_14:
          CFRelease(v6);
          return valuePtr;
        }
      }
      *a3 = Value;
      goto LABEL_14;
    }
    return 0;
  }
  return v4;
}

BOOL MTPreferencesGetAppBooleanValue(const __CFString *a1, const __CFString *a2, unsigned __int8 *a3)
{
  _BOOL8 v4;
  const __CFString *v5;
  const __CFString *v6;
  CFTypeID v7;
  Boolean Value;
  int valuePtr;

  if (a3)
    *a3 = 0;
  v4 = 0;
  if (a1 && a2)
  {
    v5 = (const __CFString *)IOHIDPreferencesCopyDomain();
    if (v5)
    {
      v6 = v5;
      v7 = CFGetTypeID(v5);
      if (v7 == CFStringGetTypeID())
      {
        v4 = 1;
        if (CFStringCompare(v6, CFSTR("true"), 1uLL) == kCFCompareEqualTo)
          goto LABEL_19;
        Value = 1;
        if (CFStringCompare(v6, CFSTR("YES"), 1uLL) == kCFCompareEqualTo)
        {
          v4 = 1;
          if (!a3)
            goto LABEL_23;
          goto LABEL_22;
        }
        if (CFStringCompare(v6, CFSTR("false"), 1uLL) == kCFCompareEqualTo
          || CFStringCompare(v6, CFSTR("NO"), 1uLL) == kCFCompareEqualTo)
        {
          v4 = 0;
          goto LABEL_19;
        }
      }
      else if (v7 == CFNumberGetTypeID())
      {
        if (!CFNumberIsFloatType((CFNumberRef)v6))
        {
          valuePtr = -1431655766;
          Value = CFNumberGetValue((CFNumberRef)v6, kCFNumberIntType, &valuePtr);
          v4 = valuePtr != 0;
          if (!a3)
            goto LABEL_23;
          goto LABEL_22;
        }
      }
      else if (v7 == CFBooleanGetTypeID())
      {
        v4 = v6 == (const __CFString *)*MEMORY[0x24BDBD270];
LABEL_19:
        Value = 1;
        if (!a3)
          goto LABEL_23;
        goto LABEL_22;
      }
      v4 = 0;
      Value = 0;
      if (!a3)
      {
LABEL_23:
        CFRelease(v6);
        return v4;
      }
LABEL_22:
      *a3 = Value;
      goto LABEL_23;
    }
    return 0;
  }
  return v4;
}

_QWORD *MTTrackpadEventDispatcher::createDispatcher(MTSimpleHIDManager *a1, const void *a2)
{
  _QWORD *v4;

  v4 = (_QWORD *)operator new();
  bzero(v4, 0x220uLL);
  MTSimpleEventDispatcher::MTSimpleEventDispatcher((MTSimpleEventDispatcher *)v4);
  *v4 = &off_24FFF1700;
  v4[58] = v4 + 59;
  v4[59] = 0;
  v4[60] = 0;
  v4[61] = v4 + 61;
  v4[62] = v4 + 61;
  v4[63] = 0;
  *((_DWORD *)v4 + 134) = 1114636288;
  MTTrackpadEventDispatcher::initialize((uint64_t)v4, a1, a2);
  return v4;
}

void sub_231095DE4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10A1C4052F3E7C6);
  _Unwind_Resume(a1);
}

void MTTrackpadEventDispatcher::initialize(uint64_t a1, MTSimpleHIDManager *a2, const void *a3)
{
  *(_DWORD *)(a1 + 428) = 0;
  *(_BYTE *)(a1 + 432) = 0;
  *(_DWORD *)(a1 + 436) = 0;
  *(_BYTE *)(a1 + 440) = 0;
  *(_BYTE *)(a1 + 512) = 0;
  *(_DWORD *)(a1 + 516) = 0;
  *(_QWORD *)(a1 + 520) = 0;
  *(_BYTE *)(a1 + 532) = 0;
  *(_DWORD *)(a1 + 536) = 1114636288;
  *(_QWORD *)(a1 + 448) = 0;
  *(_BYTE *)(a1 + 540) = 1;
  *(_BYTE *)(a1 + 541) = MTPreferencesGetAppBooleanValue(CFSTR("NoPointing"), CFSTR("com.apple.MultitouchSupport"), 0);
  *(_DWORD *)(a1 + 456) = 6;
  *(_DWORD *)(a1 + 528) = 0;
  MTSimpleEventDispatcher::initialize(a1, a2, a3);
}

uint64_t MTTrackpadEventDispatcher::handleEvent(dispatch_object_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t Event;
  uint64_t v7;
  int v8;
  char v9;
  char v10;
  double v11;
  double v12;
  double v13;
  double v14;
  uint64_t IntegerValue;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  double v21;
  float v22;
  double v23;
  float v24;
  double v25;
  float v26;
  unsigned int v27;
  const __CFArray *Children;
  const __CFArray *v29;
  CFIndex Count;
  CFIndex v31;
  CFIndex v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t result;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  float v47;

  a1[7] = (dispatch_object_t)a2;
  if (IOHIDEventGetType() != 11 || IOHIDEventGetIntegerValue() != 1)
  {
LABEL_44:
    result = ((uint64_t (*)(dispatch_object_t *, uint64_t))(*a1)[4].isa)(a1, a2);
    if ((_DWORD)result)
      result = ((uint64_t (*)(dispatch_object_t *, uint64_t, uint64_t))(*a1)[5].isa)(a1, a2, a3);
    goto LABEL_46;
  }
  Event = IOHIDEventGetEvent();
  v7 = IOHIDEventGetEvent();
  v46 = IOHIDEventGetEvent();
  v45 = IOHIDEventGetEvent();
  v44 = IOHIDEventGetEvent();
  v43 = IOHIDEventGetEvent();
  v42 = IOHIDEventGetEvent();
  v41 = IOHIDEventGetEvent();
  v40 = IOHIDEventGetEvent();
  v39 = IOHIDEventGetEvent();
  v8 = IOHIDEventConformsTo();
  v37 = IOHIDEventConformsTo();
  v38 = v8;
  v36 = IOHIDEventConformsTo();
  ((void (*)(dispatch_object_t *))(*a1)[14].isa)(a1);
  v9 = MTTrackpadEventDispatcher::checkForMomentumCancellation(a1);
  if (v8 | v37)
    v10 = v9;
  else
    v10 = 1;
  v47 = NAN;
  if (Event)
  {
    IOHIDEventGetFloatValue();
    v12 = v11;
    IOHIDEventGetFloatValue();
    v14 = v13;
    IntegerValue = IOHIDEventGetIntegerValue();
    if ((MTTrackpadEventDispatcher::checkForMomentumInitiation((uint64_t)a1, a2, &v47) & 1) == 0
      && !*((_BYTE *)a1 + 541))
    {
      v16 = v12;
      v17 = v14;
      v18 = (int)v16;
      v19 = (int)v17;
      v20 = mach_absolute_time();
      ((void (*)(dispatch_object_t *, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*a1)[19].isa)(a1, v18, v19, IntegerValue, v20, 0);
    }
  }
  if (v7)
  {
    IOHIDEventGetFloatValue();
    v22 = v21;
    IOHIDEventGetFloatValue();
    v24 = v23;
    IOHIDEventGetFloatValue();
    v26 = v25;
    v27 = MTTrackpadEventDispatcher::checkForMomentumInitiation((uint64_t)a1, a2, &v47);
    ((void (*)(dispatch_object_t *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, float))(*a1)[18].isa)(a1, (int)v22, (int)v24, (int)v26, 0, 0, 0, v47);
    if (v27)
    {
      if ((*((_DWORD *)a1 + 132) - 1) <= 2)
        ((void (*)(dispatch_object_t *, _QWORD, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD, float))(*a1)[18].isa)(a1, 0, 0, 0, 1, 0, 0, 60.0);
      goto LABEL_15;
    }
    if (!*((_BYTE *)a1 + 540))
LABEL_15:
      IOHIDEventRemoveEvent();
  }
  if ((v10 & 1) == 0)
  {
    Children = (const __CFArray *)IOHIDEventGetChildren();
    if (Children)
    {
      v29 = Children;
      Count = CFArrayGetCount(Children);
      if (Count >= 1)
      {
        v31 = Count;
        v32 = 0;
        while (1)
        {
          CFArrayGetValueAtIndex(v29, v32);
          if (IOHIDEventGetType() == 2)
            break;
          if (IOHIDEventGetType() == 3)
          {
            IOHIDEventGetIntegerValue();
            IOHIDEventGetIntegerValue();
            MTSimpleEventDispatcher::getMTDevice((MTSimpleEventDispatcher *)a1);
            MTDeviceDispatchKeyboardEvent();
            goto LABEL_24;
          }
LABEL_25:
          if (v31 == ++v32)
            goto LABEL_26;
        }
        v33 = IOHIDEventGetIntegerValue();
        v34 = mach_absolute_time();
        ((void (*)(dispatch_object_t *, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD))(*a1)[19].isa)(a1, 0, 0, v33, v34, 0);
LABEL_24:
        usleep(0x1770u);
        goto LABEL_25;
      }
    }
  }
LABEL_26:
  if (v7)
    goto LABEL_44;
  if (Event)
    goto LABEL_44;
  if (*((_BYTE *)a1 + 424))
    goto LABEL_44;
  if (v46)
    goto LABEL_44;
  if (v45)
    goto LABEL_44;
  if (v44)
    goto LABEL_44;
  if (v43)
    goto LABEL_44;
  if (v42)
    goto LABEL_44;
  if (v41)
    goto LABEL_44;
  if (v40)
    goto LABEL_44;
  if (v39)
    goto LABEL_44;
  if (v38)
    goto LABEL_44;
  if (v37)
    goto LABEL_44;
  if (v36)
    goto LABEL_44;
  if (IOHIDEventGetIntegerValue())
    goto LABEL_44;
  if ((IOHIDEventGetIntegerValue() & 1) != 0)
    goto LABEL_44;
  if ((IOHIDEventGetIntegerValue() & 2) != 0)
    goto LABEL_44;
  result = IOHIDEventConformsTo();
  if ((_DWORD)result)
    goto LABEL_44;
LABEL_46:
  a1[7] = 0;
  return result;
}

uint64_t MTTrackpadEventDispatcher::checkForMomentumCancellation(dispatch_object_t *a1)
{
  const void *MomentumEnableEvent;
  int *context;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  float v8;
  float v9;
  unint64_t v10;
  uint64_t v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  NSObject *v17;
  uint64_t v18;
  _BYTE buf[12];
  __int16 v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  double v26;
  __int16 v27;
  double v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  MomentumEnableEvent = getMomentumEnableEvent();
  if (!a1[56])
    return 0;
  if (MomentumEnableEvent)
  {
    *(_QWORD *)buf = 0;
    IOHIDEventGetVendorDefinedData();
  }
  if (!IOHIDEventConformsTo()
    && !IOHIDEventConformsTo()
    && !IOHIDEventConformsTo())
  {
    return 0;
  }
  if (!IOHIDEventConformsTo())
  {
    v18 = 1;
    MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer((MTTrackpadEventDispatcher *)a1, 1);
    return v18;
  }
  context = (int *)dispatch_get_context(a1[56]);
  if (!context)
    return 0;
  v4 = (uint64_t)context;
  v5 = context[8];
  if (IOHIDEventGetIntegerValue() != v5 || *(_DWORD *)v4 == 1)
    return 0;
  v6 = *(_QWORD *)(v4 + 72);
  v7 = *(_QWORD *)(v4 + 48);
  v8 = 0.0;
  v9 = 0.0;
  if (v6 < (*(_QWORD *)(v4 + 56) - v7) >> 2)
    v9 = (float)*(int *)(v7 + 4 * v6);
  v10 = *(_QWORD *)(v4 + 112);
  v11 = *(_QWORD *)(v4 + 88);
  if (v10 < (*(_QWORD *)(v4 + 96) - v11) >> 2)
    v8 = (float)*(int *)(v11 + 4 * v10);
  v12 = hypotf(v9, v8);
  v13 = v9 + (double)IOHIDEventGetIntegerValue() * 0.25;
  v14 = v8 + (double)IOHIDEventGetIntegerValue() * 0.25;
  v15 = hypotf(v13, v14);
  if (v12 > 0.0 && v15 > v12)
  {
    v16 = v12 / v15;
    v13 = v16 * v13;
    v14 = v16 * v14;
  }
  *(float *)(v4 + 24) = v13;
  *(float *)(v4 + 28) = v14;
  MTTrackpadEventDispatcher::generateMomentumDeltas((uint64_t)a1, v4);
  v17 = MTLoggingPlugin();
  v18 = 0;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136316162;
    *(_QWORD *)&buf[4] = "";
    v21 = 2080;
    v22 = "";
    v23 = 2080;
    v24 = "checkForMomentumCancellation";
    v25 = 2048;
    v26 = v13;
    v27 = 2048;
    v28 = v14;
    _os_log_impl(&dword_231071000, v17, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Adjusted point/drag momentum %4.1fx %4.1fy\n", buf, 0x34u);
    return 0;
  }
  return v18;
}

const void *MTTrackpadEventDispatcher::checkForMomentumInitiation(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  const void *result;

  result = getMomentumEnableEvent();
  *a3 = 1114636288;
  if (result)
  {
    IOHIDEventGetVendorDefinedData();
    return 0;
  }
  return result;
}

BOOL MTTrackpadEventDispatcher::isStdScrollInProgress(MTTrackpadEventDispatcher *this, int a2)
{
  return (a2 - 1) < 3;
}

uint64_t MTTrackpadEventDispatcher::handleParserDisabled(uint64_t this)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  int v4;
  const char *v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(this + 516) == 1)
  {
    v1 = this;
    v2 = MTLoggingPlugin();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      v4 = 136315650;
      v5 = "[Debug] ";
      v6 = 2080;
      v7 = "";
      v8 = 2080;
      v9 = "handleParserDisabled";
      _os_log_impl(&dword_231071000, v2, OS_LOG_TYPE_DEBUG, "[HID] [MT] %s%s%s Trackpad has been disabled with button down. Dispatching button up event", (uint8_t *)&v4, 0x20u);
    }
    v3 = mach_absolute_time();
    return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)v1 + 152))(v1, 0, 0, 0, v3, 0);
  }
  return this;
}

_DWORD *MTTrackpadEventDispatcher::updateFingerStats(MTTrackpadEventDispatcher *this)
{
  _DWORD *result;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t NonRestingFingerCount;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  int v30;
  _QWORD __dst[38];
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;

  result = (_DWORD *)MTSimpleEventDispatcher::getOwner(this);
  if (result)
  {
    result = (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)result + 864))(result);
    if (result)
    {
      v3 = result;
      v4 = *((_QWORD *)result + 6);
      if (v4)
        LODWORD(v4) = *(double *)(v4 + 8) - *((double *)result + 19) == 0.0;
      if ((int)result[26] > 1)
        v5 = 1;
      else
        v5 = v4;
      if (!*((_DWORD *)this + 129))
      {
        NonRestingFingerCount = MTParser::getNonRestingFingerCount((MTParser *)result, (result[9] >> 1) & 1);
        v7 = (*(uint64_t (**)(MTTrackpadEventDispatcher *))(*(_QWORD *)this + 168))(this);
        v8 = v3[6];
        if (v8)
          v9 = *(_DWORD *)(v8 + 308);
        else
          v9 = 0;
        v10 = *((_DWORD *)this + 109);
        v11 = v3[8];
        if (v11)
        {
          v12 = v3[25];
          if (v12)
          {
            v13 = *(_DWORD *)(v12 + 256);
            if (v13 >= 1)
            {
              memcpy(__dst, &unk_2310BD830, 0x128uLL);
              v14 = *(_QWORD *)(v11 + 280);
              __dst[0] = &off_24FFF08D0;
              v15 = v14 + 600 * v13;
              memcpy(&__dst[1], (const void *)(v15 + 8), 0x11CuLL);
              __dst[37] = &off_24FFF2F50;
              v17 = *(_OWORD *)(v15 + 320);
              v16 = *(_OWORD *)(v15 + 336);
              v32 = *(_OWORD *)(v15 + 304);
              v33 = v17;
              v34 = v16;
              v18 = *(_OWORD *)(v15 + 400);
              v19 = *(_OWORD *)(v15 + 352);
              v20 = *(_OWORD *)(v15 + 368);
              v37 = *(_OWORD *)(v15 + 384);
              v38 = v18;
              v36 = v20;
              v35 = v19;
              v21 = *(_OWORD *)(v15 + 448);
              v23 = *(_OWORD *)(v15 + 416);
              v22 = *(_OWORD *)(v15 + 432);
              v42 = *(_OWORD *)(v15 + 464);
              v41 = v21;
              v39 = v23;
              v40 = v22;
              v24 = *(_OWORD *)(v15 + 512);
              v26 = *(_OWORD *)(v15 + 480);
              v25 = *(_OWORD *)(v15 + 496);
              v46 = *(_OWORD *)(v15 + 528);
              v45 = v24;
              v43 = v26;
              v44 = v25;
              v28 = *(_OWORD *)(v15 + 560);
              v27 = *(_OWORD *)(v15 + 576);
              v29 = *(_OWORD *)(v15 + 544);
              v50 = *(_QWORD *)(v15 + 592);
              v49 = v27;
              v47 = v29;
              v48 = v28;
              v9 = __dst[35];
              MTParserPath::~MTParserPath((MTParserPath *)__dst);
            }
          }
        }
        v30 = (*(uint64_t (**)(MTTrackpadEventDispatcher *))(*(_QWORD *)this + 176))(this);
        (*(void (**)(MTTrackpadEventDispatcher *, uint64_t))(*(_QWORD *)this + 120))(this, NonRestingFingerCount);
        (*(void (**)(MTTrackpadEventDispatcher *, BOOL))(*(_QWORD *)this + 128))(this, (v9 & v10) != 0);
        if (v7 != (*(unsigned int (**)(MTTrackpadEventDispatcher *))(*(_QWORD *)this + 168))(this))
          return (_DWORD *)(*(uint64_t (**)(MTTrackpadEventDispatcher *, uint64_t))(*(_QWORD *)this + 136))(this, v5);
        result = (_DWORD *)(*(uint64_t (**)(MTTrackpadEventDispatcher *))(*(_QWORD *)this + 176))(this);
        if ((v30 ^ result | v5) == 1)
          return (_DWORD *)(*(uint64_t (**)(MTTrackpadEventDispatcher *, uint64_t))(*(_QWORD *)this + 136))(this, v5);
      }
    }
  }
  return result;
}

uint64_t MTTrackpadEventDispatcher::updateClickState(uint64_t this, char a2)
{
  _DWORD *v2;
  _BYTE *v3;

  v2 = (_DWORD *)this;
  if (*(_BYTE *)(this + 432))
  {
    *(_BYTE *)(this + 512) = 0;
    if ((a2 & 1) != 0)
      return this;
    v3 = (_BYTE *)(this + 512);
    this = (*(uint64_t (**)(uint64_t))(*(_QWORD *)this + 168))(this);
    if ((_DWORD)this == 2)
      *v3 = 1;
  }
  else
  {
    if (!*(_DWORD *)(this + 436))
      return this;
    *(_BYTE *)(this + 512) = 0;
    if ((a2 & 1) != 0)
      return this;
    v3 = (_BYTE *)(this + 512);
  }
  if (v2[109])
  {
    this = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v2 + 176))(v2);
    if ((_DWORD)this)
      *v3 = 1;
  }
  return this;
}

uint64_t MTTrackpadEventDispatcher::getHIDPhaseFromScrollPhase(MTTrackpadEventDispatcher *this, unsigned int a2)
{
  if (a2 > 9)
    return 0;
  else
    return gScrollPhaseToHIDPhase[a2];
}

uint64_t MTTrackpadEventDispatcher::getNextScrollPhase(MTTrackpadEventDispatcher *this, unsigned int a2, int a3)
{
  if (a2 > 9)
    return 0;
  else
    return gNextScrollPhaseForPhase[2 * a2 + a3];
}

void MTTrackpadEventDispatcher::setScrollMomentumDispatchRate(MTTrackpadEventDispatcher *this, float a2)
{
  int v4;
  NSObject *v5;
  double v6;
  int v7;
  const char *v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  double v14;
  __int16 v15;
  double v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v4 = 1114636288;
  if (a2 >= 60.0 && (v4 = 1140457472, a2 <= 500.0))
    *((float *)this + 134) = a2;
  else
    *((_DWORD *)this + 134) = v4;
  v5 = MTLoggingPlugin();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *((float *)this + 134);
    v7 = 136316162;
    v8 = "";
    v9 = 2080;
    v10 = "";
    v11 = 2080;
    v12 = "setScrollMomentumDispatchRate";
    v13 = 2048;
    v14 = a2;
    v15 = 2048;
    v16 = v6;
    _os_log_impl(&dword_231071000, v5, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Requested value %f -> set value %f", (uint8_t *)&v7, 0x34u);
  }
}

float *MTTrackpadEventDispatcher::dispatchMomentumScrollStartStopEvent(float *this, char a2, uint64_t a3)
{
  if ((a2 & 1) == 0)
    return (float *)(*(uint64_t (**)(float *, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t, uint64_t, float))(*(_QWORD *)this + 144))(this, 0, 0, 0, 0, 1, a3, this[134]);
  return this;
}

void MTTrackpadEventDispatcher::dispatchPointingEvent(MTTrackpadEventDispatcher *this, int a2, int a3, int a4, unint64_t a5, int a6)
{
  int v7;
  int v8;
  int v9;
  unsigned int v11;
  uint64_t RelativePointerEvent;
  const void *v13;

  v7 = a3 | a2;
  if (a6)
  {
    if (!v7 && *((_DWORD *)this + 131) == a4)
      return;
    *((_DWORD *)this + 131) = a4;
    v8 = a4;
    a4 = *((_DWORD *)this + 130);
  }
  else
  {
    if (!v7 && *((_DWORD *)this + 130) == a4)
      return;
    *((_DWORD *)this + 130) = a4;
    v8 = *((_DWORD *)this + 131);
  }
  v9 = v8 | a4;
  if ((v9 & 1) == 0 || *((_BYTE *)this + 512) == 0)
    v11 = v9;
  else
    v11 = v9 & 0xFFFFFFFC | 2;
  RelativePointerEvent = IOHIDEventCreateRelativePointerEvent();
  if (RelativePointerEvent)
  {
    v13 = (const void *)RelativePointerEvent;
    (*(void (**)(MTTrackpadEventDispatcher *, uint64_t, _QWORD))(*(_QWORD *)this + 40))(this, RelativePointerEvent, 0);
    CFRelease(v13);
  }
  *((_DWORD *)this + 129) = v11;
}

void MTTrackpadEventDispatcher::dispatchScrollEvent(MTTrackpadEventDispatcher *this, int a2, int a3, int a4, int a5, int a6, float a7, int a8)
{
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  BOOL v16;
  NSObject *v17;
  const __CFAllocator *v18;
  uint64_t ScrollEvent;
  const void *v20;
  CFNumberRef v21;
  CFNumberRef v22;
  float valuePtr;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  const char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  valuePtr = a7;
  if (!*((_BYTE *)this + 540))
    return;
  if (!a6)
  {
    v13 = *((unsigned int *)this + 132);
    if (v13 >= 0xA)
    {
      v14 = 0;
      *((_DWORD *)this + 132) = 0;
    }
    else
    {
      v14 = gNextScrollPhaseForPhase[2 * v13 + ((a3 | a2 | a4) != 0)];
      *((_DWORD *)this + 132) = v14;
      if (v14 > 9)
        return;
    }
    v15 = gScrollPhaseToHIDPhase[v14];
LABEL_12:
    if (!v15)
      return;
    goto LABEL_23;
  }
  if (!*((_BYTE *)this + 532))
    return;
  v11 = *((unsigned int *)this + 114);
  if (v11 >= 0xA)
  {
    v12 = 0;
    *((_DWORD *)this + 114) = 0;
  }
  else
  {
    v12 = gNextScrollPhaseForPhase[2 * v11 + ((a3 | a2 | a4) != 0)];
    *((_DWORD *)this + 114) = v12;
    if (v12 > 9)
      return;
  }
  v15 = gScrollPhaseToHIDPhase[v12];
  v16 = v12 == 9 || v12 == 4;
  if (!v16 || !a8)
    goto LABEL_12;
  v17 = MTLoggingPlugin();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315650;
    v25 = "";
    v26 = 2080;
    v27 = "";
    v28 = 2080;
    v29 = "dispatchScrollEvent";
    _os_log_impl(&dword_231071000, v17, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Momentum interrupted", buf, 0x20u);
  }
LABEL_23:
  v18 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  mach_absolute_time();
  ScrollEvent = IOHIDEventCreateScrollEvent();
  if (ScrollEvent)
  {
    v20 = (const void *)ScrollEvent;
    if (a6)
    {
      IOHIDEventSetScrollMomentum();
      v21 = CFNumberCreate(v18, kCFNumberFloatType, &valuePtr);
      if (v21)
      {
        v22 = v21;
        _IOHIDEventSetAttachment();
        CFRelease(v22);
      }
    }
    else
    {
      IOHIDEventSetPhase();
      if (*((_BYTE *)this + 532) && a5 && *((_DWORD *)this + 132) == 4)
        IOHIDEventSetScrollMomentum();
    }
    (*(void (**)(MTTrackpadEventDispatcher *, const void *, _QWORD))(*(_QWORD *)this + 40))(this, v20, 0);
    CFRelease(v20);
  }
}

void MTTrackpadEventDispatcher::recordHIDEvent(uint64_t **a1, uint64_t a2, int a3)
{
  const __CFArray *Children;
  const __CFArray *v6;
  CFIndex v7;
  uint64_t v8;
  const void *ValueAtIndex;
  int Type;
  int Phase;
  uint64_t **v12;
  uint64_t **v13;
  CFAbsoluteTime Current;
  CFAbsoluteTime *v15;
  uint64_t *v16;
  uint64_t **v17;
  uint64_t *v18;
  uint64_t v19;
  __int16 IntegerValue;
  CFAbsoluteTime v21;
  _DWORD *v22;
  uint64_t *v23;
  unint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int *v28;

  if (a2 && a3 <= 5)
  {
    Children = (const __CFArray *)IOHIDEventGetChildren();
    if (Children)
    {
      v6 = Children;
      if (CFArrayGetCount(Children) >= 1)
      {
        v7 = 0;
        v8 = (a3 + 1);
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v6, v7);
          ((void (*)(uint64_t **, const void *, uint64_t))(*a1)[7])(a1, ValueAtIndex, v8);
          ++v7;
        }
        while (v7 < CFArrayGetCount(v6));
      }
    }
    Type = IOHIDEventGetType();
    v27 = Type;
    Phase = IOHIDEventGetPhase();
    if (Type <= 0x2A && (!Phase || (Phase & 1) != 0) && Type <= 0x1C)
    {
      if (((1 << Type) & 0x4003F2) != 0)
      {
        v12 = a1 + 58;
        v28 = &v27;
        v13 = std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v12, &v27, (uint64_t)&std::piecewise_construct, &v28);
        Current = CFAbsoluteTimeGetCurrent();
        v15 = (CFAbsoluteTime *)operator new(0x18uLL);
        v15[2] = Current;
        v16 = v13[5];
        v13 += 5;
        *(_QWORD *)v15 = v16;
        *((_QWORD *)v15 + 1) = v13;
        v16[1] = (uint64_t)v15;
        *v13 = (uint64_t *)v15;
        v13[2] = (uint64_t *)((char *)v13[2] + 1);
        v28 = &v27;
        if ((unint64_t)std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v12, &v27, (uint64_t)&std::piecewise_construct, &v28)[7] >= 0x65)
        {
          do
          {
            v28 = &v27;
            v17 = std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v12, &v27, (uint64_t)&std::piecewise_construct, &v28);
            v18 = v17[6];
            v19 = *v18;
            *(_QWORD *)(v19 + 8) = v18[1];
            *(_QWORD *)v18[1] = v19;
            v17[7] = (uint64_t *)((char *)v17[7] - 1);
            operator delete(v18);
            v28 = &v27;
          }
          while ((unint64_t)std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v12, &v27, (uint64_t)&std::piecewise_construct, &v28)[7] > 0x64);
        }
      }
      else if (((1 << Type) & 0x18810000) != 0)
      {
        IntegerValue = 0;
        v21 = CFAbsoluteTimeGetCurrent();
        if (Type > 26 || Type == 16 || Type == 23)
          IntegerValue = IOHIDEventGetIntegerValue();
        v22 = operator new(0x20uLL);
        v22[4] = Type;
        *((_WORD *)v22 + 10) = IntegerValue;
        *((_WORD *)v22 + 11) = 0;
        *((CFAbsoluteTime *)v22 + 3) = v21;
        v23 = a1[61];
        *(_QWORD *)v22 = v23;
        *((_QWORD *)v22 + 1) = a1 + 61;
        v23[1] = (uint64_t)v22;
        a1[61] = (uint64_t *)v22;
        v24 = (unint64_t)a1[63] + 1;
        a1[63] = (uint64_t *)v24;
        if (v24 >= 0x3E9)
        {
          do
          {
            v25 = a1[62];
            v26 = *v25;
            *(_QWORD *)(v26 + 8) = v25[1];
            *(_QWORD *)v25[1] = v26;
            a1[63] = (uint64_t *)(v24 - 1);
            operator delete(v25);
            v24 = (unint64_t)a1[63];
          }
          while (v24 > 0x3E8);
        }
      }
    }
  }
}

uint64_t MTTrackpadEventDispatcher::shouldRecordAsGesture(MTTrackpadEventDispatcher *this, unsigned int a2)
{
  return (a2 < 0x1D) & (0x18810000u >> a2);
}

uint64_t MTTrackpadEventDispatcher::shouldRecord(MTTrackpadEventDispatcher *this, unsigned int a2)
{
  return (a2 < 0x17) & (0x4003F2u >> a2);
}

__CFDictionary *MTTrackpadEventDispatcher::copyDebugData(MTTrackpadEventDispatcher *this)
{
  const __CFAllocator *v2;
  CFDateFormatterRef v3;
  __CFDateFormatter *v4;
  CFTimeZoneRef v5;
  CFTimeZoneRef v6;
  char *v7;
  char *v8;
  const CFArrayCallBacks *v9;
  __int128 v10;
  __CFArray *Mutable;
  BOOL v12;
  char *v13;
  uint64_t i;
  CFStringRef StringWithAbsoluteTime;
  const void *Name;
  char *v17;
  char *v18;
  CFMutableArrayRef v19;
  __CFArray *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  CFStringRef v24;
  CFStringRef v25;
  uint64_t v26;
  CFStringRef v27;
  CFStringRef v28;
  MTTrackpadEventDispatcher *v30;
  __CFDictionary *theDict;
  _QWORD v32[3];
  _OWORD v33[2];

  v2 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 43, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (theDict)
  {
    v3 = CFDateFormatterCreate(v2, 0, kCFDateFormatterShortStyle, kCFDateFormatterFullStyle);
    if (v3)
    {
      v4 = v3;
      v5 = CFTimeZoneCopySystem();
      if (v5)
      {
        v6 = v5;
        CFDateFormatterSetProperty(v4, (CFStringRef)*MEMORY[0x24BDBD340], v5);
        CFRelease(v6);
      }
      v7 = (char *)*((_QWORD *)this + 58);
      v30 = this;
      v8 = (char *)this + 472;
      if (v7 != (char *)this + 472)
      {
        v9 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
        do
        {
          *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v33[0] = v10;
          v33[1] = v10;
          LODWORD(v33[0]) = *((_DWORD *)v7 + 8);
          std::list<double>::list((_QWORD *)v33 + 1, (uint64_t)(v7 + 40));
          memset(v32, 170, sizeof(v32));
          std::list<double>::list(v32, (uint64_t)v33 + 8);
          Mutable = CFArrayCreateMutable(v2, 100, v9);
          if (Mutable)
            v12 = v32[2] == 0;
          else
            v12 = 1;
          if (!v12)
          {
            v13 = v8;
            for (i = v32[1]; (_QWORD *)i != v32; i = *(_QWORD *)(i + 8))
            {
              StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(v2, v4, *(CFAbsoluteTime *)(i + 16));
              if (StringWithAbsoluteTime)
              {
                CFArrayAppendValue(Mutable, StringWithAbsoluteTime);
                CFRelease(StringWithAbsoluteTime);
              }
            }
            Name = (const void *)IOHIDEventTypeGetName();
            v8 = v13;
            v9 = (const CFArrayCallBacks *)MEMORY[0x24BDBD690];
            CFDictionarySetValue(theDict, Name, Mutable);
            CFRelease(Mutable);
          }
          std::__list_imp<double>::clear(v32);
          std::__list_imp<double>::clear((_QWORD *)v33 + 1);
          v17 = (char *)*((_QWORD *)v7 + 1);
          if (v17)
          {
            do
            {
              v18 = v17;
              v17 = *(char **)v17;
            }
            while (v17);
          }
          else
          {
            do
            {
              v18 = (char *)*((_QWORD *)v7 + 2);
              v12 = *(_QWORD *)v18 == (_QWORD)v7;
              v7 = v18;
            }
            while (!v12);
          }
          v7 = v18;
        }
        while (v18 != v8);
      }
      v19 = CFArrayCreateMutable(v2, 1000, MEMORY[0x24BDBD690]);
      if (v19)
      {
        v20 = v19;
        v21 = (char *)this + 488;
        v22 = *((_QWORD *)v30 + 62);
        if ((MTTrackpadEventDispatcher *)v22 != (MTTrackpadEventDispatcher *)((char *)v30 + 488))
        {
          do
          {
            v23 = *(unsigned __int16 *)(v22 + 20);
            v24 = CFDateFormatterCreateStringWithAbsoluteTime(v2, v4, *(CFAbsoluteTime *)(v22 + 24));
            if (v24)
            {
              v25 = v24;
              v26 = IOHIDEventTypeGetName();
              v27 = CFStringCreateWithFormat(v2, 0, CFSTR("%@ (%u) @ %@"), v26, v23, v25);
              if (v27)
              {
                v28 = v27;
                CFArrayAppendValue(v20, v27);
                CFRelease(v28);
              }
              CFRelease(v25);
            }
            v22 = *(_QWORD *)(v22 + 8);
          }
          while ((char *)v22 != v21);
        }
        CFDictionarySetValue(theDict, CFSTR("Gesture events"), v20);
        CFRelease(v20);
      }
      CFRelease(v4);
    }
  }
  return theDict;
}

void sub_2310975E0(_Unwind_Exception *a1)
{
  _QWORD *v1;

  std::__list_imp<double>::clear(v1);
  _Unwind_Resume(a1);
}

float MTTrackpadEventDispatcher::momentumDecayRateAlpha(int a1, float a2, float a3, float a4)
{
  float v5;
  float v6;
  float v7;
  float v8;
  double v9;
  double v10;
  double v11;
  float v12;
  float v13;
  float v14;
  double v15;
  double v16;

  if (a1 == 2)
  {
    if (a4 <= 0.0)
    {
      v16 = a4 / 0.00800000038;
      v15 = 0.85;
      return pow(v15, v16);
    }
    v12 = hypotf(a2, a3) / a4;
    v9 = 1.0;
    if (v12 > 0.0)
    {
      v9 = 0.0;
      if (v12 < 500.0)
        v9 = (float)((float)(500.0 - v12) / 500.0);
    }
    v10 = 0.95;
    v11 = -0.1;
  }
  else if (a1 == 4)
  {
    if (a4 <= 0.0)
    {
      v16 = a4 / 0.00800000038;
      v15 = 0.9;
      return pow(v15, v16);
    }
    v5 = hypotf(a2, a3) / a4;
    v6 = 0.0;
    if (v5 > 2000.0)
    {
      v6 = 1.0;
      if (v5 < 3000.0)
        v6 = (float)(v5 + -2000.0) / 1000.0;
    }
    v7 = 1.0;
    if (v5 > 0.0)
    {
      v7 = 0.0;
      if (v5 < 250.0)
        v7 = (float)(250.0 - v5) / 250.0;
    }
    if (v6 >= v7)
      v8 = v6;
    else
      v8 = v7;
    v9 = v8;
    v10 = 0.98;
    v11 = -0.08;
  }
  else
  {
    if (a4 <= 0.0)
    {
      v16 = a4 / 0.00800000038;
      v15 = 0.975;
      return pow(v15, v16);
    }
    v13 = hypotf(a2, a3) / a4;
    v9 = 1.0;
    if (v13 > 0.0)
    {
      v9 = 0.0;
      if (v13 < 250.0)
        v9 = (float)((float)(250.0 - v13) / 250.0);
    }
    v10 = 0.975;
    v11 = -0.065;
  }
  v14 = v10 + v9 * v11;
  v15 = v14;
  v16 = a4 / 0.00800000038;
  return pow(v15, v16);
}

void MTTrackpadEventDispatcher::startMomentumTimerForEvent(uint64_t a1, uint64_t a2, int a3, float *a4)
{
  uint64_t Event;
  char *v8;
  float v9;
  _BOOL4 v11;
  float v12;
  uint64_t Owner;
  uint64_t v14;
  double v15;
  unsigned int v17;
  float v19;
  float IntegerValue;
  float v23;
  NSObject *v24;
  const char *v25;
  int v26;
  float v27;
  float v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  float v33;
  NSObject *v34;
  float v35;
  dispatch_time_t v36;
  NSObject *v37;
  _QWORD handler[5];
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;
  __int16 v45;
  double v46;
  __int16 v47;
  double v48;
  __int16 v49;
  _BOOL4 v50;
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  Event = IOHIDEventGetEvent();
  if (!(Event | IOHIDEventGetEvent()))
    return;
  v8 = (char *)operator new();
  *((_OWORD *)v8 + 3) = 0u;
  *((_OWORD *)v8 + 4) = 0u;
  *((_DWORD *)v8 + 20) = 1015580809;
  *(_OWORD *)(v8 + 88) = 0u;
  *(_OWORD *)(v8 + 104) = 0u;
  *((_DWORD *)v8 + 30) = 1015580809;
  *((_OWORD *)v8 + 8) = 0u;
  *((_OWORD *)v8 + 9) = 0u;
  *((_DWORD *)v8 + 40) = 1015580809;
  *(_OWORD *)(v8 + 168) = 0u;
  *(_OWORD *)(v8 + 184) = 0u;
  *((_DWORD *)v8 + 50) = 1015580809;
  *((_QWORD *)v8 + 5) = a1;
  MTSimpleEventDispatcher::retain(a1);
  *(_DWORD *)v8 = a3;
  *((_QWORD *)v8 + 1) = 0x400199999999999ALL;
  v9 = *(float *)(a1 + 536);
  v11 = fabsf(v9 + -60.0) > 0.05 && a3 == 1;
  v8[208] = v11;
  v12 = 1.0 / v9;
  *((float *)v8 + 40) = v12;
  *((float *)v8 + 50) = v12;
  *(_WORD *)(v8 + 209) = 0;
  *((_DWORD *)v8 + 59) = 0;
  Owner = MTSimpleEventDispatcher::getOwner((MTSimpleEventDispatcher *)a1);
  v14 = *(_QWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)Owner + 864))(Owner) + 48);
  if (v14)
    v15 = *(double *)(v14 + 8) - *(double *)(v14 + 16);
  else
    v15 = 0.0;
  if (v15 > 0.1 || v15 < 0.001)
    v15 = 0.01;
  if (a3 == 1)
  {
    *(float *)&v17 = 0.0166666675 / v15;
    *((_DWORD *)v8 + 59) = 3;
    _D0 = v17 | 0x3F00000000000000;
    v19 = 0.016667;
  }
  else
  {
    v19 = v15;
    __asm { FMOV            V0.2S, #1.0 }
  }
  *((float *)v8 + 20) = v19;
  *((float *)v8 + 30) = v19;
  *((_QWORD *)v8 + 2) = _D0;
  if (Event)
  {
    *((_DWORD *)v8 + 8) = 0;
    IntegerValue = (float)IOHIDEventGetIntegerValue();
    *((float *)v8 + 6) = IntegerValue;
    v23 = (float)IOHIDEventGetIntegerValue();
    *((float *)v8 + 7) = v23;
    v24 = MTLoggingPlugin();
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      goto LABEL_25;
    *(_DWORD *)buf = 136316418;
    v40 = "";
    v41 = 2080;
    v42 = "";
    v43 = 2080;
    v44 = "startMomentumTimerForEvent";
    v45 = 2048;
    v46 = IntegerValue;
    v47 = 2048;
    v48 = v23;
    v49 = 1024;
    v50 = v11;
    v25 = "[HID] [MT] %s%s%s Starting Momentum Scroll %.0fx %.0fy %u\n";
  }
  else
  {
    v26 = IOHIDEventGetIntegerValue();
    *((_DWORD *)v8 + 8) = v26;
    v27 = (float)IOHIDEventGetIntegerValue();
    *((float *)v8 + 6) = v27;
    v28 = (float)IOHIDEventGetIntegerValue();
    *((float *)v8 + 7) = v28;
    v24 = MTLoggingPlugin();
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      goto LABEL_25;
    *(_DWORD *)buf = 136316418;
    v40 = "";
    v41 = 2080;
    v42 = "";
    v43 = 2080;
    v44 = "startMomentumTimerForEvent";
    v45 = 2048;
    v46 = v27;
    v47 = 2048;
    v48 = v28;
    v49 = 1024;
    v50 = v26;
    v25 = "[HID] [MT] %s%s%s Starting Momentum Point/Drag %.0fx %.0fy w/ buttons %d\n";
  }
  _os_log_impl(&dword_231071000, v24, OS_LOG_TYPE_DEFAULT, v25, buf, 0x3Au);
LABEL_25:
  MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer((MTTrackpadEventDispatcher *)a1, 1);
  v29 = MTSimpleEventDispatcher::getOwner((MTSimpleEventDispatcher *)a1);
  if (v29)
  {
    v30 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v29 + 864))(v29);
    if (v30)
      MTParser::feedbackMomentumTimerStatus(v30, a3, 1);
  }
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1))
  {
    v31 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
    *(_QWORD *)(a1 + 448) = dispatch_source_create(MEMORY[0x24BDACA18], 0, 0, v31);
  }
  MTTrackpadEventDispatcher::generateMomentumDeltas(a1, (uint64_t)v8);
  v32 = 160;
  if (!v8[208])
    v32 = 80;
  v33 = *(float *)&v8[v32];
  *a4 = 1.0 / v33;
  v34 = *(NSObject **)(a1 + 448);
  if (v34)
  {
    v35 = v33 * 1000000000.0;
    v36 = dispatch_time(0, (uint64_t)(float)(v33 * 1000000000.0));
    dispatch_source_set_timer(v34, v36, (unint64_t)v35, 0);
    dispatch_set_context(*(dispatch_object_t *)(a1 + 448), v8);
    v37 = *(NSObject **)(a1 + 448);
    handler[0] = MEMORY[0x24BDAC760];
    handler[1] = 0x40000000;
    handler[2] = ___ZN25MTTrackpadEventDispatcher26startMomentumTimerForEventEP12__IOHIDEvent17MTMomentumSubTypeRf_block_invoke;
    handler[3] = &__block_descriptor_tmp;
    handler[4] = a1;
    dispatch_source_set_event_handler(v37, handler);
    dispatch_resume(*(dispatch_object_t *)(a1 + 448));
  }
}

void MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(MTTrackpadEventDispatcher *this, uint64_t a2)
{
  NSObject *v2;
  void *context;
  void *v6;
  uint64_t Owner;
  uint64_t v8;
  unsigned int *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  v2 = *((_QWORD *)this + 56);
  if (v2)
  {
    context = dispatch_get_context(*((dispatch_object_t *)this + 56));
    if (context)
    {
      v6 = context;
      Owner = MTSimpleEventDispatcher::getOwner(this);
      if (Owner)
      {
        v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)Owner + 864))(Owner);
        if (v8)
          MTParser::feedbackMomentumTimerStatus(v8, *(_DWORD *)v6, 0);
      }
      if (*(_DWORD *)v6 == 1)
        (*(void (**)(MTTrackpadEventDispatcher *, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t, uint64_t, float))(*(_QWORD *)this + 144))(this, 0, 0, 0, 0, 1, a2, *((float *)this + 134));
      v9 = (unsigned int *)*((_QWORD *)v6 + 5);
      v10 = (void *)*((_QWORD *)v6 + 21);
      if (v10)
      {
        *((_QWORD *)v6 + 22) = v10;
        operator delete(v10);
      }
      v11 = (void *)*((_QWORD *)v6 + 16);
      if (v11)
      {
        *((_QWORD *)v6 + 17) = v11;
        operator delete(v11);
      }
      v12 = (void *)*((_QWORD *)v6 + 11);
      if (v12)
      {
        *((_QWORD *)v6 + 12) = v12;
        operator delete(v12);
      }
      v13 = (void *)*((_QWORD *)v6 + 6);
      if (v13)
      {
        *((_QWORD *)v6 + 7) = v13;
        operator delete(v13);
      }
      MEMORY[0x2348D0034](v6, 0x1030C40A19E2114);
      v2 = *((_QWORD *)this + 56);
    }
    else
    {
      v9 = 0;
    }
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 56));
    *((_QWORD *)this + 56) = 0;
    if (v9)
      MTSimpleEventDispatcher::release(v9);
  }
}

void MTTrackpadEventDispatcher::generateMomentumDeltas(uint64_t a1, uint64_t a2)
{
  int v3;
  std::__wrap_iter<int *>::iterator_type v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  std::__wrap_iter<int *>::iterator_type v8;
  uint64_t v9;

  v3 = a1;
  MTTrackpadEventDispatcher::generateFrameIntervalMomentumDeltas(a1, (unsigned int *)a2);
  if (*(_BYTE *)(a2 + 208))
  {
    v4 = MTTrackpadEventDispatcher::smoothTails(v3, (std::vector<int> *)(a2 + 48), (std::vector<int> *)(a2 + 88), *(_DWORD *)(a2 + 236));
    MTTrackpadEventDispatcher::interpolateFrameIntervalMomentumDeltas((uint64_t)v4, (float *)(a2 + 48), a2 + 128);
    MTTrackpadEventDispatcher::interpolateFrameIntervalMomentumDeltas(v5, (float *)(a2 + 88), a2 + 168);
    v6 = *(_DWORD *)(a2 + 236);
    if (v6)
      v7 = (float)(roundf((float)(*(float *)(a2 + 80) / *(float *)(a2 + 160)) * (float)(v6 + 1))
                               + -1.0);
    else
      v7 = 0;
    v8 = MTTrackpadEventDispatcher::smoothTails(v3, (std::vector<int> *)(a2 + 128), (std::vector<int> *)(a2 + 168), v7);
    MTTrackpadEventDispatcher::smoothBody((uint64_t)v8, (int **)(a2 + 128));
    MTTrackpadEventDispatcher::smoothBody(v9, (int **)(a2 + 168));
  }
}

void ___ZN25MTTrackpadEventDispatcher26startMomentumTimerForEventEP12__IOHIDEvent17MTMomentumSubTypeRf_block_invoke(uint64_t a1, dispatch_source_s *a2)
{
  MTTrackpadEventDispatcher::momentumCallbackFunction(*(NSObject **)(*(_QWORD *)(a1 + 32) + 448), a2);
}

void MTTrackpadEventDispatcher::momentumCallbackFunction(NSObject *this, dispatch_source_s *a2)
{
  unsigned int *context;
  unsigned int *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  BOOL v20;
  _BOOL4 v21;
  float v22;
  uint64_t v23;
  float v24;
  float v25;
  dispatch_time_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  float v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  context = (unsigned int *)dispatch_get_context(this);
  if (context)
  {
    v4 = context;
    if (*((_BYTE *)context + 208))
    {
      v5 = *((_QWORD *)context + 19);
      v6 = v5 + 1;
      v7 = *((_QWORD *)context + 16);
      v8 = *((_QWORD *)context + 17) - v7;
      if (v5 >= v8 >> 2)
        v9 = 0;
      else
        v9 = *(unsigned int *)(v7 + 4 * v5);
      v13 = *((float *)context + 40);
      v14 = v8 >> 2;
      if (v6 <= v5)
        v15 = *((_QWORD *)context + 19);
      else
        v15 = v5 + 1;
      *((_QWORD *)context + 19) = v15;
      v16 = *((_QWORD *)context + 24);
      v17 = *((_QWORD *)context + 21);
      v18 = (*((_QWORD *)context + 22) - v17) >> 2;
      if (v16 >= v18)
        v19 = 0;
      else
        v19 = *(unsigned int *)(v17 + 4 * v16);
      if (v16 + 1 >= v16)
        ++v16;
      *((_QWORD *)context + 24) = v16;
      v20 = v15 >= v14 && v16 >= v18;
      v21 = v20;
      if (!v20 && *((_BYTE *)context + 210))
      {
        if ((float)(v13 * (float)(v5 + 2)) >= *((float *)context + 56))
        {
          v22 = (float)v6;
          *((_WORD *)context + 104) = 256;
          v23 = *((_QWORD *)context + 27);
          *((_QWORD *)context + 9) = v23;
          *((_QWORD *)context + 14) = v23;
          v24 = *((float *)context + 20);
          v25 = (float)(v24 * (float)(unint64_t)(v23 + 1)) - (float)(v13 * v22);
          *((float *)context + 57) = v25 / v24;
          *((float *)context + 58) = v25;
          v26 = dispatch_walltime(0, (uint64_t)(float)(v25 * 1000000000.0));
          dispatch_source_set_timer(this, v26, (unint64_t)(float)(*((float *)v4 + 20) * 1000000000.0), 0);
        }
        v21 = 0;
      }
    }
    else
    {
      v10 = *((_QWORD *)context + 9);
      v11 = *((_QWORD *)context + 6);
      v12 = *((_QWORD *)context + 7) - v11;
      if (v10 >= v12 >> 2)
        v9 = 0;
      else
        v9 = *(unsigned int *)(v11 + 4 * v10);
      v27 = v12 >> 2;
      if (v10 + 1 >= v10)
        ++v10;
      *((_QWORD *)context + 9) = v10;
      v28 = *((_QWORD *)context + 14);
      v29 = *((_QWORD *)context + 11);
      v30 = (*((_QWORD *)context + 12) - v29) >> 2;
      if (v28 >= v30)
        v19 = 0;
      else
        v19 = *(unsigned int *)(v29 + 4 * v28);
      if (v28 + 1 >= v28)
        ++v28;
      *((_QWORD *)context + 14) = v28;
      v21 = v10 >= v27 && v28 >= v30;
      if (*((_BYTE *)context + 209))
      {
        v32 = *((float *)context + 57);
        v13 = *((float *)context + 58);
        LODWORD(v9) = llroundf(v32 * (float)(int)v9);
        LODWORD(v19) = llroundf(v32 * (float)(int)v19);
        *((_BYTE *)context + 209) = 0;
      }
      else
      {
        v13 = *((float *)context + 20);
      }
    }
    if (v9 | v19)
      v33 = 1;
    else
      v33 = v21;
    if (*v4 == 1)
    {
      if (v33)
        (*(void (**)(_QWORD, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, float))(**((_QWORD **)v4 + 5)
                                                                                                 + 144))(*((_QWORD *)v4 + 5), v9, v19, 0, 0, 1, 0, 1.0 / v13);
    }
    else if (v33)
    {
      v34 = *((_QWORD *)v4 + 5);
      v35 = v4[8];
      v36 = mach_absolute_time();
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v34 + 152))(v34, v9, v19, v35, v36, 0);
    }
    if (v21)
      MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(*((MTTrackpadEventDispatcher **)v4 + 5), 0);
  }
}

void MTTrackpadEventDispatcher::wasUnscheduledFromDispatchQueue(MTTrackpadEventDispatcher *this, dispatch_queue_s *a2)
{
  MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1);
}

uint64_t MTTrackpadEventDispatcher::generateFrameIntervalMomentumDeltas(uint64_t a1, unsigned int *a2)
{
  void **v3;
  void **v4;
  float v5;
  float v6;
  float v7;
  double v8;
  uint64_t v9;
  uint64_t result;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  unsigned int v19;
  unsigned int v20;
  float v21;
  float v22;
  float v23;
  float v24;
  int v25;
  int v26;
  BOOL v27;
  float v28;
  float v29;
  unsigned int v30;
  unsigned int v31;
  float v32;
  _BOOL4 v33;
  unint64_t v34;
  char *v35;
  _DWORD *v36;
  char *v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  char *v42;
  unsigned int *v43;
  unsigned int v44;
  unint64_t v45;
  char *v46;
  _DWORD *v47;
  char *v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  char *v53;
  unsigned int *v54;
  unsigned int v55;
  double v56;
  uint64_t v57;
  uint64_t v58;
  BOOL v59;
  uint64_t v60;
  uint64_t v61;

  v3 = (void **)(a2 + 12);
  *((_QWORD *)a2 + 7) = *((_QWORD *)a2 + 6);
  *((_QWORD *)a2 + 9) = 0;
  v4 = (void **)(a2 + 22);
  *((_QWORD *)a2 + 12) = *((_QWORD *)a2 + 11);
  *((_QWORD *)a2 + 14) = 0;
  v5 = *((float *)a2 + 20);
  v6 = *((float *)a2 + 6);
  v7 = *((float *)a2 + 7);
  v8 = *((double *)a2 + 1);
  v61 = (uint64_t)(a2 + 16);
  v9 = (uint64_t)(a2 + 26);
  LODWORD(result) = *a2;
  v11 = 0.0;
  v12 = 0.0;
  do
  {
    v13 = MTTrackpadEventDispatcher::momentumDecayRateAlpha(result, v6, v7, v5);
    v6 = v6 * v13;
    v7 = v7 * v13;
    v14 = *((float *)a2 + 4);
    v15 = v6 * v14;
    v16 = v7 * v14;
    if (*((_BYTE *)a2 + 208) && !*((_BYTE *)a2 + 210))
    {
      v17 = fabsf(v16 / v5);
      if (fabsf(v15 / v5) <= 320.0 && v17 <= 320.0)
      {
        v58 = *((_QWORD *)a2 + 6);
        v57 = *((_QWORD *)a2 + 7);
        *((_BYTE *)a2 + 210) = 1;
        v60 = v57 - v58;
        v59 = v60 == 0;
        v60 >>= 2;
        *((_QWORD *)a2 + 27) = v60;
        *((float *)a2 + 56) = *((float *)a2 + 20) * (float)(unint64_t)(v60 + 1);
        if (v59)
          *((_BYTE *)a2 + 208) = 0;
      }
    }
    v19 = llroundf(v15);
    v20 = llroundf(v16);
    v21 = fabsf(v15);
    v22 = fabsf(v16);
    v23 = v12 + v15;
    v24 = v11 + v16;
    v25 = (int)v23;
    v26 = (int)v24;
    v27 = v21 < 1.0 && v22 < 1.0;
    v28 = v23 - (float)(int)v23;
    v29 = v24 - (float)(int)v24;
    if (v27)
      v30 = v25;
    else
      v30 = v19;
    if (v27)
      v31 = v26;
    else
      v31 = v20;
    if (v27)
      v12 = v28;
    if (v27)
      v11 = v29;
    if (v8 <= 0.0)
    {
      v33 = 1;
    }
    else
    {
      v32 = *((float *)a2 + 5);
      v33 = v21 < v32 && v22 < v32;
    }
    v35 = (char *)*((_QWORD *)a2 + 7);
    v34 = *((_QWORD *)a2 + 8);
    if ((unint64_t)v35 >= v34)
    {
      v37 = (char *)*v3;
      v38 = (v35 - (_BYTE *)*v3) >> 2;
      v39 = v38 + 1;
      if ((unint64_t)(v38 + 1) >> 62)
        std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
      v40 = v34 - (_QWORD)v37;
      if (v40 >> 1 > v39)
        v39 = v40 >> 1;
      if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFFCLL)
        v41 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v41 = v39;
      if (v41)
      {
        v42 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v61, v41);
        v37 = (char *)*((_QWORD *)a2 + 6);
        v35 = (char *)*((_QWORD *)a2 + 7);
      }
      else
      {
        v42 = 0;
      }
      v43 = (unsigned int *)&v42[4 * v38];
      *v43 = v30;
      v36 = v43 + 1;
      while (v35 != v37)
      {
        v44 = *((_DWORD *)v35 - 1);
        v35 -= 4;
        *--v43 = v44;
      }
      *((_QWORD *)a2 + 6) = v43;
      *((_QWORD *)a2 + 7) = v36;
      *((_QWORD *)a2 + 8) = &v42[4 * v41];
      if (v37)
        operator delete(v37);
    }
    else
    {
      *(_DWORD *)v35 = v30;
      v36 = v35 + 4;
    }
    *((_QWORD *)a2 + 7) = v36;
    v46 = (char *)*((_QWORD *)a2 + 12);
    v45 = *((_QWORD *)a2 + 13);
    if ((unint64_t)v46 >= v45)
    {
      v48 = (char *)*v4;
      v49 = (v46 - (_BYTE *)*v4) >> 2;
      v50 = v49 + 1;
      if ((unint64_t)(v49 + 1) >> 62)
        std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
      v51 = v45 - (_QWORD)v48;
      if (v51 >> 1 > v50)
        v50 = v51 >> 1;
      if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFFCLL)
        v52 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v52 = v50;
      if (v52)
      {
        v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v9, v52);
        v48 = (char *)*((_QWORD *)a2 + 11);
        v46 = (char *)*((_QWORD *)a2 + 12);
      }
      else
      {
        v53 = 0;
      }
      v54 = (unsigned int *)&v53[4 * v49];
      *v54 = v31;
      v47 = v54 + 1;
      while (v46 != v48)
      {
        v55 = *((_DWORD *)v46 - 1);
        v46 -= 4;
        *--v54 = v55;
      }
      *((_QWORD *)a2 + 11) = v54;
      *((_QWORD *)a2 + 12) = v47;
      *((_QWORD *)a2 + 13) = &v53[4 * v52];
      if (v48)
        operator delete(v48);
    }
    else
    {
      *(_DWORD *)v46 = v31;
      v47 = v46 + 4;
    }
    *((_QWORD *)a2 + 12) = v47;
    result = *a2;
    v56 = 0.0;
    if ((_DWORD)result == 1)
      v56 = v5;
    v8 = v8 - v56;
  }
  while (!v33);
  return result;
}

void MTTrackpadEventDispatcher::smoothBody(uint64_t a1, int **a2)
{
  int *v3;
  int *v4;
  __int32 *v5;
  int *v6;
  unint64_t v7;
  uint64_t v8;
  char v9;

  if (a2)
  {
    v3 = *a2;
    v4 = a2[1];
    if (v4 != *a2)
    {
      if (*v3)
      {
        v5 = wmemchr(*a2, 0, v4 - *a2);
        if (v5)
          v6 = v5;
        else
          v6 = v4;
        if (**a2 < 1)
        {
          std::__sort<std::__less<int,int> &,int *>();
        }
        else
        {
          v7 = 126 - 2 * __clz(v6 - v3);
          if (v6 == v3)
            v8 = 0;
          else
            v8 = v7;
          std::__introsort<std::_ClassicAlgPolicy,std::greater<int> &,int *,false>(v3, v6, (uint64_t)&v9, v8, 1);
        }
      }
    }
  }
}

std::__wrap_iter<int *>::iterator_type MTTrackpadEventDispatcher::smoothTails(int a1, std::vector<int> *a2, std::vector<int> *a3, unsigned int a4)
{
  int v7;
  int v8;

  v7 = MTTrackpadEventDispatcher::forceCurveTailToMonotonicallyDecrease(a1, a2, a4);
  v8 = MTTrackpadEventDispatcher::forceCurveTailToMonotonicallyDecrease(v7, a3, a4);
  return MTTrackpadEventDispatcher::equalizeCurveLengths(v8, a2, a3);
}

std::__wrap_iter<int *>::iterator_type MTTrackpadEventDispatcher::forceCurveTailToMonotonicallyDecrease(int a1, std::vector<int> *this, unsigned int a3)
{
  int *end;
  std::vector<int>::pointer begin;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  std::vector<int>::const_iterator v11;
  std::vector<int>::size_type v12;
  std::__wrap_iter<int *>::iterator_type result;
  uint64_t v14;
  int *v15;
  std::vector<int>::const_iterator v16;
  std::vector<int>::const_iterator v17;
  std::vector<int>::value_type v18;
  std::vector<int>::value_type v19;
  std::vector<int>::value_type v20;
  std::vector<int>::value_type __x;

  if (this)
  {
    begin = this->__begin_;
    end = this->__end_;
    if (end == this->__begin_)
    {
      v8 = 0;
      v10 = -1;
      begin = this->__end_;
    }
    else
    {
      v7 = 0;
      v8 = 0;
      v9 = 0;
      v10 = -1;
      do
      {
        v11.__i_ = &begin[v7];
        if (*v11.__i_)
        {
          if (v8 <= v9)
            v8 = v9;
          v12 = v8 - v9;
          __x = 0;
          result = std::vector<int>::insert(this, v11, v12, &__x).__i_;
          v9 = 0;
          v7 += v12;
          begin = this->__begin_;
          end = this->__end_;
          v10 = v7;
        }
        else
        {
          ++v9;
        }
        ++v7;
      }
      while (v7 < end - begin);
    }
    v14 = v10;
    v15 = &begin[v10 + 1];
    if (v15 != end)
      this->__end_ = v15;
    if (v10 != -1 && v8 < a3)
    {
      v16.__i_ = &this->__begin_[v10 + 1];
      v20 = 0;
      std::vector<int>::insert(this, v16, a3, &v20);
      v17.__i_ = &this->__begin_[v14 + 1 + a3];
      if (*this->__begin_ < 1)
        v18 = -1;
      else
        v18 = 1;
      v19 = v18;
      return std::vector<int>::insert(this, v17, &v19).__i_;
    }
  }
  return result;
}

std::__wrap_iter<int *>::iterator_type MTTrackpadEventDispatcher::equalizeCurveLengths(int a1, std::vector<int> *this, std::vector<int> *a3)
{
  const int *end;
  uint64_t v5;
  uint64_t v6;
  std::vector<int>::const_iterator v8;
  std::vector<int>::const_iterator v9;
  std::vector<int>::size_type v10;
  std::__wrap_iter<int *>::iterator_type result;
  std::vector<int>::value_type v12;
  std::vector<int>::value_type __x;

  if (this && a3)
  {
    end = this->__end_;
    v5 = (char *)end - (char *)this->__begin_;
    if (v5 >> 2 <= (unint64_t)(a3->__end_ - a3->__begin_))
      v6 = a3->__end_ - a3->__begin_;
    else
      v6 = v5 >> 2;
    __x = 0;
    v8.__i_ = end;
    std::vector<int>::insert(this, v8, v6 - (v5 >> 2), &__x);
    v9.__i_ = a3->__end_;
    v10 = v6 - (v9.__i_ - a3->__begin_);
    v12 = 0;
    return std::vector<int>::insert(a3, v9, v10, &v12).__i_;
  }
  return result;
}

std::vector<int>::iterator std::vector<int>::insert(std::vector<int> *this, std::vector<int>::const_iterator __position, std::vector<int>::size_type __n, std::vector<int>::const_reference __x)
{
  int *i;
  int *v5;
  std::__compressed_pair<int *> *p_end_cap;
  int *v9;
  int *value;
  const int *v11;
  std::vector<int>::pointer begin;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int *v17;
  uint64_t v18;
  unint64_t v19;
  std::vector<int>::size_type v20;
  int *v21;
  const int *v22;
  const int *v23;
  int *v24;
  int v25;
  std::vector<int>::size_type v26;
  int *v27;
  int *v28;
  std::vector<int>::size_type v29;
  int *v30;
  std::__split_buffer<int> __p;

  i = (int *)__position.__i_;
  if (__n)
  {
    v5 = (int *)__x;
    value = this->__end_cap_.__value_;
    p_end_cap = &this->__end_cap_;
    v9 = value;
    v11 = p_end_cap[-1].__value_;
    if (__n <= value - v11)
    {
      v18 = (char *)v11 - (char *)__position.__i_;
      if (__n <= v11 - __position.__i_)
      {
        v21 = p_end_cap[-1].__value_;
        v20 = __n;
      }
      else
      {
        v19 = 0;
        v20 = v18 >> 2;
        v21 = (int *)&v11[__n - (v18 >> 2)];
        do
        {
          v11[v19 / 4] = *__x;
          v19 += 4;
        }
        while (4 * __n - 4 * v20 != v19);
        this->__end_ = v21;
        if (v11 == __position.__i_)
          return (std::vector<int>::iterator)i;
      }
      v22 = &__position.__i_[__n];
      v23 = &v21[-__n];
      v24 = v21;
      if (v23 < v11)
      {
        v24 = v21;
        do
        {
          v25 = *v23++;
          *v24++ = v25;
        }
        while (v23 < v11);
      }
      this->__end_ = v24;
      if (v21 != v22)
        memmove(&v21[-(v21 - v22)], __position.__i_, (char *)v21 - (char *)v22);
      if (i <= v5)
      {
        if (this->__end_ <= v5)
          v26 = 0;
        else
          v26 = __n;
        v5 += v26;
      }
      v27 = i;
      do
      {
        *v27++ = *v5;
        --v20;
      }
      while (v20);
    }
    else
    {
      begin = this->__begin_;
      memset(&__p, 0, 32);
      v13 = __n + v11 - begin;
      if (v13 >> 62)
        std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
      v14 = __position.__i_ - begin;
      v15 = (char *)v9 - (char *)begin;
      if (v15 >> 1 > v13)
        v13 = v15 >> 1;
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL)
        v16 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v16 = v13;
      __p.__end_cap_.__value_ = (std::allocator<int> *)p_end_cap;
      if (v16)
        v17 = (int *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, v16);
      else
        v17 = 0;
      v28 = &v17[v14];
      __p.__first_ = v17;
      __p.__begin_ = v28;
      __p.__end_cap_.__value_ = &v17[v16];
      v29 = 4 * __n;
      v30 = &v28[__n];
      do
      {
        *v28++ = *v5;
        v29 -= 4;
      }
      while (v29);
      __p.__end_ = v30;
      i = std::vector<int>::__swap_out_circular_buffer(this, &__p, i);
      if (__p.__end_ != __p.__begin_)
        __p.__end_ = (std::__split_buffer<int>::pointer)((char *)__p.__end_
                                                       + (((char *)__p.__begin_ - (char *)__p.__end_ + 3) & 0xFFFFFFFFFFFFFFFCLL));
      if (__p.__first_)
        operator delete(__p.__first_);
    }
  }
  return (std::vector<int>::iterator)i;
}

void sub_231098928(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

std::vector<int>::iterator std::vector<int>::insert(std::vector<int> *this, std::vector<int>::const_iterator __position, std::vector<int>::value_type *__x)
{
  int *i;
  const int *end;
  std::__compressed_pair<int *> *p_end_cap;
  int *v8;
  int *value;
  std::__wrap_iter<const int *>::iterator_type v10;
  const int *v11;
  int *v12;
  int v13;
  std::vector<int>::pointer begin;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int *v19;
  std::__split_buffer<int> __p;

  i = (int *)__position.__i_;
  end = this->__end_;
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  v8 = value;
  if (end >= value)
  {
    begin = this->__begin_;
    memset(&__p, 0, 32);
    v15 = end - begin + 1;
    if (v15 >> 62)
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    v16 = __position.__i_ - begin;
    v17 = (char *)v8 - (char *)begin;
    if (v17 >> 1 > v15)
      v15 = v17 >> 1;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL)
      v18 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v18 = v15;
    __p.__end_cap_.__value_ = (std::allocator<int> *)p_end_cap;
    if (v18)
      v19 = (int *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, v18);
    else
      v19 = 0;
    __p.__first_ = v19;
    __p.__begin_ = &v19[v16];
    __p.__end_ = __p.__begin_;
    __p.__end_cap_.__value_ = &v19[v18];
    std::__split_buffer<int>::push_back(&__p, __x);
    i = std::vector<int>::__swap_out_circular_buffer(this, &__p, i);
    if (__p.__end_ != __p.__begin_)
      __p.__end_ = (std::__split_buffer<int>::pointer)((char *)__p.__end_
                                                     + (((char *)__p.__begin_ - (char *)__p.__end_ + 3) & 0xFFFFFFFFFFFFFFFCLL));
    if (__p.__first_)
      operator delete(__p.__first_);
  }
  else if (__position.__i_ == end)
  {
    *__position.__i_ = *__x;
    this->__end_ = (std::vector<int>::pointer)(__position.__i_ + 1);
  }
  else
  {
    v10 = __position.__i_ + 1;
    v11 = end - 1;
    v12 = (int *)end;
    while (v11 < end)
    {
      v13 = *v11++;
      *v12++ = v13;
    }
    this->__end_ = v12;
    if (end != v10)
      memmove((void *)&end[-(end - v10)], __position.__i_, (char *)end - (char *)v10);
    *i = *__x;
  }
  return (std::vector<int>::iterator)i;
}

void sub_231098AD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MTTrackpadEventDispatcher::interpolateFrameIntervalMomentumDeltas(uint64_t a1, float *a2, uint64_t a3)
{
  unsigned int *v3;
  float v4;
  float v5;
  unint64_t v6;
  unsigned int v7;
  int v10;
  float v11;
  _QWORD *v12;
  float v13;
  float v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  int v20;
  float v21;
  unsigned int v22;
  unsigned int *v23;
  unsigned int *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  unsigned int *v30;
  unsigned int v31;
  float v32;

  v3 = *(unsigned int **)a3;
  *(_QWORD *)(a3 + 8) = *(_QWORD *)a3;
  *(_QWORD *)(a3 + 24) = 0;
  v4 = a2[8];
  v5 = *(float *)(a3 + 32);
  v6 = (uint64_t)(*((_QWORD *)a2 + 1) - *(_QWORD *)a2) >> 2;
  v7 = (float)((float)(v4 * (float)v6) / v5);
  if (v7)
  {
    v10 = 0;
    v11 = v5 / v4;
    v12 = (_QWORD *)(a3 + 16);
    v13 = 0.0;
    do
    {
      v32 = NAN;
      v14 = modff((float)((float)v10 / (float)((float)v7 + -1.0)) * (float)(v6 - 1), &v32);
      v15 = v32;
      v16 = *(_QWORD *)a2;
      v17 = (uint64_t)(*((_QWORD *)a2 + 1) - *(_QWORD *)a2) >> 2;
      if (v17 <= v15)
LABEL_26:
        std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
      v18 = (v15 + 1);
      v19 = *(_DWORD *)(v16 + 4 * v15);
      if (v6 <= v18)
      {
        v20 = 0;
      }
      else
      {
        if (v17 <= v18)
          goto LABEL_26;
        v20 = *(_DWORD *)(v16 + 4 * v18);
      }
      v21 = v13 + (float)(v11 * (float)((float)(v14 * (float)v20) + (float)((float)v19 * (float)(1.0 - v14))));
      v22 = llroundf(v21);
      if ((unint64_t)v3 >= *v12)
      {
        v24 = *(unsigned int **)a3;
        v25 = ((uint64_t)v3 - *(_QWORD *)a3) >> 2;
        v26 = v25 + 1;
        if ((unint64_t)(v25 + 1) >> 62)
          std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
        v27 = *v12 - (_QWORD)v24;
        if (v27 >> 1 > v26)
          v26 = v27 >> 1;
        if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFFCLL)
          v28 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v28 = v26;
        if (v28)
        {
          v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v12, v28);
          v24 = *(unsigned int **)a3;
          v3 = *(unsigned int **)(a3 + 8);
        }
        else
        {
          v29 = 0;
        }
        v30 = (unsigned int *)&v29[4 * v25];
        *v30 = v22;
        v23 = v30 + 1;
        while (v3 != v24)
        {
          v31 = *--v3;
          *--v30 = v31;
        }
        *(_QWORD *)a3 = v30;
        *(_QWORD *)(a3 + 8) = v23;
        *(_QWORD *)(a3 + 16) = &v29[4 * v28];
        if (v24)
          operator delete(v24);
      }
      else
      {
        *v3 = v22;
        v23 = v3 + 1;
      }
      v13 = v21 - (float)(int)roundf(v21);
      *(_QWORD *)(a3 + 8) = v23;
      ++v10;
      v3 = v23;
    }
    while (v10 != v7);
  }
}

const void *getMomentumEnableEvent()
{
  const __CFArray *Children;
  const __CFArray *v1;
  CFIndex Count;
  CFIndex v3;
  CFIndex v4;
  const void *ValueAtIndex;

  if (!IOHIDEventConformsTo())
    return 0;
  Children = (const __CFArray *)IOHIDEventGetChildren();
  if (!Children)
    return 0;
  v1 = Children;
  Count = CFArrayGetCount(Children);
  if (Count < 1)
    return 0;
  v3 = Count;
  v4 = 0;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v1, v4);
    if (IOHIDEventGetType() == 1
      && IOHIDEventGetIntegerValue() == 65280
      && IOHIDEventGetIntegerValue() == 1)
    {
      break;
    }
    if (v3 == ++v4)
      return 0;
  }
  return ValueAtIndex;
}

void MTTrackpadEventDispatcher::~MTTrackpadEventDispatcher(MTTrackpadEventDispatcher *this)
{
  *(_QWORD *)this = &off_24FFF1700;
  std::__list_imp<double>::clear((_QWORD *)this + 61);
  std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy((uint64_t)this + 464, *((_QWORD **)this + 59));
  MTSimpleEventDispatcher::~MTSimpleEventDispatcher(this);
}

{
  *(_QWORD *)this = &off_24FFF1700;
  std::__list_imp<double>::clear((_QWORD *)this + 61);
  std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy((uint64_t)this + 464, *((_QWORD **)this + 59));
  MTSimpleEventDispatcher::~MTSimpleEventDispatcher(this);
  JUMPOUT(0x2348D0034);
}

uint64_t MTTrackpadEventDispatcher::setActivePathCount(uint64_t this, int a2)
{
  *(_DWORD *)(this + 428) = a2;
  return this;
}

uint64_t MTTrackpadEventDispatcher::setSecondaryClickRegionIsActive(uint64_t this, int a2)
{
  *(_BYTE *)(this + 440) = a2 != 0;
  return this;
}

uint64_t MTTrackpadEventDispatcher::getSecondaryClickEnabled(MTTrackpadEventDispatcher *this)
{
  return *((unsigned __int8 *)this + 432);
}

uint64_t MTTrackpadEventDispatcher::getActivePathCount(MTTrackpadEventDispatcher *this)
{
  return *((unsigned int *)this + 107);
}

uint64_t MTTrackpadEventDispatcher::secondaryClickRegionIsActive(MTTrackpadEventDispatcher *this)
{
  return *((unsigned __int8 *)this + 440);
}

_QWORD *std::__list_imp<double>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;

  if (result[2])
  {
    v1 = result;
    result = (_QWORD *)result[1];
    v2 = *v1;
    v3 = *result;
    *(_QWORD *)(v3 + 8) = *(_QWORD *)(*v1 + 8);
    **(_QWORD **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        v4 = (_QWORD *)result[1];
        operator delete(result);
        result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

void std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy(a1, a2[1]);
    std::__list_imp<double>::clear(a2 + 5);
    operator delete(a2);
  }
}

uint64_t **std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  uint64_t **v8;
  uint64_t **v9;
  unsigned int v10;
  unsigned int v11;
  _DWORD *v12;
  _QWORD v14[2];
  unint64_t v15;

  v7 = a1 + 1;
  v6 = a1[1];
  v8 = a1 + 1;
  v9 = a1 + 1;
  if (v6)
  {
    v10 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v11 = *((_DWORD *)v6 + 8);
        if (v10 >= v11)
          break;
        v6 = *v9;
        v8 = v9;
        if (!*v9)
          goto LABEL_9;
      }
      if (v11 >= v10)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    v15 = 0xAAAAAAAAAAAAAAAALL;
    v12 = operator new(0x40uLL);
    v14[1] = v7;
    v12[8] = **a4;
    *((_QWORD *)v12 + 5) = v12 + 10;
    *((_QWORD *)v12 + 6) = v12 + 10;
    *((_QWORD *)v12 + 7) = 0;
    LOBYTE(v15) = 1;
    std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::__insert_node_at(a1, (uint64_t)v9, v8, (uint64_t *)v12);
    v14[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,std::list<double>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,std::list<double>>,void *>>>>::reset[abi:ne180100]((uint64_t)v14, 0);
    return (uint64_t **)v12;
  }
  return v9;
}

uint64_t *std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,std::list<double>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,std::list<double>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  v2 = *(_QWORD **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__list_imp<double>::clear(v2 + 5);
    operator delete(v2);
  }
}

_QWORD *std::list<double>::list(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;

  *a1 = a1;
  a1[1] = a1;
  a1[2] = 0;
  v3 = *(_QWORD *)(a2 + 8);
  if (v3 != a2)
  {
    v5 = 1;
    v6 = a1;
    do
    {
      v7 = operator new(0x18uLL);
      v7[2] = *(_QWORD *)(v3 + 16);
      *v7 = v6;
      v7[1] = a1;
      v6[1] = v7;
      *a1 = v7;
      a1[2] = v5;
      v3 = *(_QWORD *)(v3 + 8);
      ++v5;
      v6 = v7;
    }
    while (v3 != a2);
  }
  return a1;
}

void sub_2310992E0(_Unwind_Exception *a1)
{
  _QWORD *v1;

  std::__list_imp<double>::clear(v1);
  _Unwind_Resume(a1);
}

int *std::__introsort<std::_ClassicAlgPolicy,std::greater<int> &,int *,false>(int *result, int *a2, uint64_t a3, uint64_t a4, char a5)
{
  int *v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int *v15;
  int v16;
  int *v17;
  char v18;
  BOOL v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int *v61;
  BOOL v63;
  uint64_t v64;
  int *v65;
  int v66;
  int v67;
  uint64_t v68;
  int *v69;
  int v70;
  int v71;

  v8 = result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (2)
  {
    v8 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = a2 - v9;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v20 = *(a2 - 1);
        v21 = *v9;
        if (v20 > *v9)
        {
          *v9 = v20;
          *(a2 - 1) = v21;
        }
        return result;
      case 3uLL:
        v22 = v9[1];
        v23 = *(a2 - 1);
        if (v22 <= v23)
          v24 = *(a2 - 1);
        else
          v24 = v9[1];
        if (v22 >= v23)
          v22 = *(a2 - 1);
        *(a2 - 1) = v22;
        v9[1] = v24;
        v25 = *(a2 - 1);
        if (v25 <= *v9)
          v26 = *v9;
        else
          v26 = *(a2 - 1);
        if (v25 >= *v9)
          v25 = *v9;
        *(a2 - 1) = v25;
        v28 = *v9;
        v27 = v9[1];
        if (v26 <= v27)
          v28 = v9[1];
        if (v26 < v27)
          v27 = v26;
        *v9 = v28;
        v9[1] = v27;
        return result;
      case 4uLL:
        v30 = v9[1];
        v29 = v9[2];
        if (*v9 <= v29)
          v31 = v9[2];
        else
          v31 = *v9;
        if (*v9 < v29)
          v29 = *v9;
        v9[2] = v29;
        *v9 = v31;
        v32 = *(a2 - 1);
        if (v30 <= v32)
          v33 = *(a2 - 1);
        else
          v33 = v30;
        if (v30 < v32)
          v32 = v30;
        *(a2 - 1) = v32;
        v34 = *v9;
        if (*v9 <= v33)
          v35 = v33;
        else
          v35 = *v9;
        if (v34 >= v33)
          v34 = v33;
        *v9 = v35;
        v9[1] = v34;
        v36 = v9[2];
        v37 = *(a2 - 1);
        if (v36 <= v37)
          v38 = *(a2 - 1);
        else
          v38 = v9[2];
        if (v36 >= v37)
          v36 = *(a2 - 1);
        *(a2 - 1) = v36;
        v39 = v9[1];
        if (v39 <= v38)
          v40 = v38;
        else
          v40 = v9[1];
        if (v39 >= v38)
          v39 = v38;
        v9[1] = v40;
        v9[2] = v39;
        return result;
      case 5uLL:
        v41 = *v9;
        v42 = v9[1];
        if (*v9 <= v42)
          v43 = v9[1];
        else
          v43 = *v9;
        if (v41 >= v42)
          v41 = v9[1];
        *v9 = v43;
        v9[1] = v41;
        v44 = v9[3];
        v45 = *(a2 - 1);
        if (v44 <= v45)
          v46 = *(a2 - 1);
        else
          v46 = v9[3];
        if (v44 >= v45)
          v44 = *(a2 - 1);
        *(a2 - 1) = v44;
        v9[3] = v46;
        v47 = *(a2 - 1);
        v48 = v9[2];
        if (v47 <= v48)
          v49 = v9[2];
        else
          v49 = *(a2 - 1);
        if (v47 >= v48)
          v47 = v9[2];
        *(a2 - 1) = v47;
        v51 = v9[2];
        v50 = v9[3];
        v52 = v9[1];
        if (v49 <= v50)
          v51 = v9[3];
        if (v49 < v50)
          v50 = v49;
        v9[2] = v51;
        v9[3] = v50;
        v53 = *(a2 - 1);
        if (v52 <= v53)
          v54 = *(a2 - 1);
        else
          v54 = v52;
        if (v52 < v53)
          v53 = v52;
        *(a2 - 1) = v53;
        v55 = *v9;
        v57 = v9[2];
        v56 = v9[3];
        if (v56 <= *v9)
          v58 = *v9;
        else
          v58 = v9[3];
        if (v56 >= v55)
          v56 = *v9;
        if (v58 <= v57)
          v55 = v9[2];
        if (v58 < v57)
          v57 = v58;
        if (v56 <= v54)
          v59 = v54;
        else
          v59 = v56;
        if (v56 >= v54)
          v56 = v54;
        if (v59 <= v57)
          v54 = v57;
        *v9 = v55;
        v9[1] = v54;
        if (v59 >= v57)
          v60 = v57;
        else
          v60 = v59;
        v9[2] = v60;
        v9[3] = v56;
        return result;
      default:
        if (v12 > 95)
        {
          if (v11 == 1)
          {
            if (v9 != a2)
              return std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *,int *>(v9, a2, a2, a3);
            return result;
          }
          v14 = v13 >> 1;
          v15 = &v9[v13 >> 1];
          if ((unint64_t)v12 < 0x201)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(&v9[v13 >> 1], v9, a2 - 1);
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v9, &v9[v13 >> 1], a2 - 1);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v9 + 1, v15 - 1, a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v9 + 2, &v9[v14 + 1], a2 - 3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v15 - 1, v15, &v9[v14 + 1]);
            v16 = *v9;
            *v9 = *v15;
            *v15 = v16;
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          if (*(v9 - 1) <= *v9)
          {
            result = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,int *,std::greater<int> &>(v9, a2);
            v9 = result;
            goto LABEL_17;
          }
LABEL_12:
          v17 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,int *,std::greater<int> &>(v9, a2);
          if ((v18 & 1) == 0)
            goto LABEL_15;
          v19 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v9, v17);
          v9 = v17 + 1;
          result = (int *)std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v17 + 1, a2);
          if (!(_DWORD)result)
          {
            v10 = v11 + 1;
            if (v19)
              continue;
LABEL_15:
            result = (int *)std::__introsort<std::_ClassicAlgPolicy,std::greater<int> &,int *,false>(v8, v17, a3, -v11, a5 & 1);
            v9 = v17 + 1;
LABEL_17:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }
          a4 = -v11;
          a2 = v17;
          if (v19)
            return result;
          goto LABEL_2;
        }
        v61 = v9 + 1;
        v63 = v9 == a2 || v61 == a2;
        if ((a5 & 1) != 0)
        {
          if (!v63)
          {
            v64 = 0;
            v65 = v9;
            do
            {
              v67 = *v65;
              v66 = v65[1];
              v65 = v61;
              if (v66 > v67)
              {
                v68 = v64;
                while (1)
                {
                  *(int *)((char *)v9 + v68 + 4) = v67;
                  if (!v68)
                    break;
                  v67 = *(int *)((char *)v9 + v68 - 4);
                  v68 -= 4;
                  if (v66 <= v67)
                  {
                    v69 = (int *)((char *)v9 + v68 + 4);
                    goto LABEL_123;
                  }
                }
                v69 = v9;
LABEL_123:
                *v69 = v66;
              }
              v61 = v65 + 1;
              v64 += 4;
            }
            while (v65 + 1 != a2);
          }
        }
        else if (!v63)
        {
          do
          {
            v71 = *v8;
            v70 = v8[1];
            v8 = v61;
            if (v70 > v71)
            {
              do
              {
                *v61 = v71;
                v71 = *(v61 - 2);
                --v61;
              }
              while (v70 > v71);
              *v61 = v70;
            }
            v61 = v8 + 1;
          }
          while (v8 + 1 != a2);
        }
        return result;
    }
  }
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(int *a1, int *a2, int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;

  v3 = *a2;
  v4 = *a1;
  v5 = *a3;
  if (*a2 > *a1)
  {
    if (v5 > v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    if (*a3 <= v4)
      return 1;
    *a2 = *a3;
    *a3 = v4;
    return 2;
  }
  if (v5 > v3)
  {
    *a2 = v5;
    *a3 = v3;
    v6 = *a1;
    if (*a2 <= *a1)
      return 1;
    *a1 = *a2;
    *a2 = v6;
    return 2;
  }
  return 0;
}

int *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,int *,std::greater<int> &>(int *a1, int *a2)
{
  int v2;
  int *v3;
  int v4;
  int *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;

  v2 = *a1;
  if (*a1 <= *(a2 - 1))
  {
    v5 = a1 + 1;
    do
    {
      v3 = v5;
      if (v5 >= a2)
        break;
      ++v5;
    }
    while (v2 <= *v3);
  }
  else
  {
    v3 = a1;
    do
    {
      v4 = v3[1];
      ++v3;
    }
    while (v2 <= v4);
  }
  if (v3 < a2)
  {
    do
      v6 = *--a2;
    while (v2 > v6);
  }
  if (v3 < a2)
  {
    v7 = *v3;
    v8 = *a2;
    do
    {
      *v3 = v8;
      *a2 = v7;
      do
      {
        v9 = v3[1];
        ++v3;
        v7 = v9;
      }
      while (v2 <= v9);
      do
      {
        v10 = *--a2;
        v8 = v10;
      }
      while (v2 > v10);
    }
    while (v3 < a2);
  }
  if (v3 - 1 != a1)
    *a1 = *(v3 - 1);
  *(v3 - 1) = v2;
  return v3;
}

int *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,int *,std::greater<int> &>(int *a1, int *a2)
{
  uint64_t v2;
  int v3;
  int v4;
  int *v5;
  int *v6;
  int v7;
  int v8;
  int v9;
  int *v10;
  int *v11;
  int v12;
  int v13;

  v2 = 0;
  v3 = *a1;
  do
    v4 = a1[++v2];
  while (v4 > v3);
  v5 = &a1[v2];
  v6 = &a1[v2 - 1];
  if (v2 == 1)
  {
    do
    {
      if (v5 >= a2)
        break;
      v8 = *--a2;
    }
    while (v8 <= v3);
  }
  else
  {
    do
      v7 = *--a2;
    while (v7 <= v3);
  }
  if (v5 < a2)
  {
    v9 = *a2;
    v10 = a2;
    v11 = v5;
    do
    {
      *v11 = v9;
      *v10 = v4;
      do
      {
        v12 = v11[1];
        ++v11;
        v4 = v12;
      }
      while (v12 > v3);
      do
      {
        v13 = *--v10;
        v9 = v13;
      }
      while (v13 <= v3);
    }
    while (v11 < v10);
    v6 = v11 - 1;
  }
  if (v6 != a1)
    *a1 = *v6;
  *v6 = v3;
  return v6;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(_DWORD *a1, int *a2)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  int *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int *v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;

  v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      v3 = *(a2 - 1);
      v4 = *a1;
      if (v3 > *a1)
      {
        *a1 = v3;
        *(a2 - 1) = v4;
      }
      return 1;
    case 3:
      v20 = a1[1];
      v21 = *(a2 - 1);
      if (v20 <= v21)
        v22 = *(a2 - 1);
      else
        v22 = a1[1];
      if (v20 >= v21)
        v20 = *(a2 - 1);
      *(a2 - 1) = v20;
      a1[1] = v22;
      v23 = *(a2 - 1);
      if (v23 <= *a1)
        v24 = *a1;
      else
        v24 = *(a2 - 1);
      if (v23 >= *a1)
        v23 = *a1;
      *(a2 - 1) = v23;
      v26 = *a1;
      v25 = a1[1];
      if (v24 <= v25)
        v26 = a1[1];
      if (v24 < v25)
        v25 = v24;
      *a1 = v26;
      a1[1] = v25;
      return 1;
    case 4:
      v48 = a1[1];
      v47 = a1[2];
      if (*a1 <= v47)
        v49 = a1[2];
      else
        v49 = *a1;
      if (*a1 < v47)
        v47 = *a1;
      a1[2] = v47;
      *a1 = v49;
      v50 = *(a2 - 1);
      if (v48 <= v50)
        v51 = *(a2 - 1);
      else
        v51 = v48;
      if (v48 < v50)
        v50 = v48;
      *(a2 - 1) = v50;
      v52 = *a1;
      if (*a1 <= v51)
        v53 = v51;
      else
        v53 = *a1;
      if (v52 >= v51)
        v52 = v51;
      *a1 = v53;
      a1[1] = v52;
      v54 = a1[2];
      v55 = *(a2 - 1);
      if (v54 <= v55)
        v56 = *(a2 - 1);
      else
        v56 = a1[2];
      if (v54 >= v55)
        v54 = *(a2 - 1);
      *(a2 - 1) = v54;
      v57 = a1[1];
      if (v57 <= v56)
        v58 = v56;
      else
        v58 = a1[1];
      if (v57 >= v56)
        v57 = v56;
      a1[1] = v58;
      a1[2] = v57;
      return 1;
    case 5:
      v27 = *a1;
      v28 = a1[1];
      if (*a1 <= v28)
        v29 = a1[1];
      else
        v29 = *a1;
      if (v27 >= v28)
        v27 = a1[1];
      *a1 = v29;
      a1[1] = v27;
      v30 = a1[3];
      v31 = *(a2 - 1);
      if (v30 <= v31)
        v32 = *(a2 - 1);
      else
        v32 = a1[3];
      if (v30 >= v31)
        v30 = *(a2 - 1);
      *(a2 - 1) = v30;
      a1[3] = v32;
      v33 = *(a2 - 1);
      v34 = a1[2];
      if (v33 <= v34)
        v35 = a1[2];
      else
        v35 = *(a2 - 1);
      if (v33 >= v34)
        v33 = a1[2];
      *(a2 - 1) = v33;
      v37 = a1[2];
      v36 = a1[3];
      v38 = a1[1];
      if (v35 <= v36)
        v37 = a1[3];
      if (v35 < v36)
        v36 = v35;
      a1[2] = v37;
      a1[3] = v36;
      v39 = *(a2 - 1);
      if (v38 <= v39)
        v40 = *(a2 - 1);
      else
        v40 = v38;
      if (v38 < v39)
        v39 = v38;
      *(a2 - 1) = v39;
      v41 = *a1;
      v43 = a1[2];
      v42 = a1[3];
      if (v42 <= *a1)
        v44 = *a1;
      else
        v44 = a1[3];
      if (v42 >= v41)
        v42 = *a1;
      if (v44 <= v43)
        v41 = a1[2];
      if (v44 < v43)
        v43 = v44;
      if (v42 <= v40)
        v45 = v40;
      else
        v45 = v42;
      if (v42 >= v40)
        v42 = v40;
      if (v45 <= v43)
        v40 = v43;
      *a1 = v41;
      a1[1] = v40;
      if (v45 >= v43)
        v46 = v43;
      else
        v46 = v45;
      a1[2] = v46;
      a1[3] = v42;
      return 1;
    default:
      v6 = a1 + 2;
      v5 = a1[2];
      v8 = *a1;
      v7 = a1[1];
      if (v7 <= v5)
        v9 = a1[2];
      else
        v9 = a1[1];
      if (v7 < v5)
        v5 = a1[1];
      if (v5 <= v8)
        v10 = *a1;
      else
        v10 = v5;
      if (v5 >= v8)
        v5 = *a1;
      *v6 = v5;
      if (v10 <= v9)
        v11 = v9;
      else
        v11 = v8;
      if (v10 >= v9)
        v10 = v9;
      *a1 = v11;
      a1[1] = v10;
      v12 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v13 = 0;
      v14 = 12;
      break;
  }
  while (1)
  {
    v15 = *v12;
    v16 = *v6;
    if (*v12 > v16)
    {
      v17 = v14;
      while (1)
      {
        *(_DWORD *)((char *)a1 + v17) = v16;
        v18 = v17 - 4;
        if (v17 == 4)
          break;
        v16 = *(_DWORD *)((char *)a1 + v17 - 8);
        v17 -= 4;
        if (v15 <= v16)
        {
          v19 = (_DWORD *)((char *)a1 + v18);
          goto LABEL_27;
        }
      }
      v19 = a1;
LABEL_27:
      *v19 = v15;
      if (++v13 == 8)
        return v12 + 1 == a2;
    }
    v6 = v12;
    v14 += 4;
    if (++v12 == a2)
      return 1;
  }
}

int *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *,int *>(int *a1, int *a2, int *a3, uint64_t a4)
{
  int *v6;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int *v12;
  int *v13;
  int *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int *v19;
  int *v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  unint64_t v25;
  int *v26;
  int v27;
  int v28;
  int *v29;

  if (a1 != a2)
  {
    v6 = a2;
    v8 = (char *)a2 - (char *)a1;
    v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 5)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    v13 = v6;
    if (v6 != a3)
    {
      v14 = v6;
      do
      {
        v15 = *v14;
        if (*v14 > *a1)
        {
          *v14 = *a1;
          *a1 = v15;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 5)
    {
      v16 = (unint64_t)v8 >> 2;
      do
      {
        v17 = 0;
        v18 = *a1;
        v19 = a1;
        do
        {
          v20 = &v19[v17 + 1];
          v21 = (2 * v17) | 1;
          v17 = 2 * v17 + 2;
          if (v17 >= v16)
          {
            v22 = *v20;
            v17 = v21;
          }
          else
          {
            v22 = *v20;
            v23 = v20[1];
            if (*v20 >= v23)
              v22 = v20[1];
            if (*v20 <= v23)
              v17 = v21;
            else
              ++v20;
          }
          *v19 = v22;
          v19 = v20;
        }
        while (v17 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v20 == --v6)
        {
          *v20 = v18;
        }
        else
        {
          *v20 = *v6;
          *v6 = v18;
          v24 = (char *)v20 - (char *)a1 + 4;
          if (v24 >= 5)
          {
            v25 = (((unint64_t)v24 >> 2) - 2) >> 1;
            v26 = &a1[v25];
            v27 = *v26;
            v28 = *v20;
            if (*v26 > *v20)
            {
              do
              {
                v29 = v26;
                *v20 = v27;
                if (!v25)
                  break;
                v25 = (v25 - 1) >> 1;
                v26 = &a1[v25];
                v27 = *v26;
                v20 = v29;
              }
              while (*v26 > v28);
              *v29 = v28;
            }
          }
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(uint64_t result, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int *v13;
  uint64_t v14;
  int v15;

  if (a3 >= 2)
  {
    v4 = (uint64_t)a4 - result;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 2)
    {
      v6 = v4 >> 1;
      v7 = (v4 >> 1) + 1;
      v8 = (int *)(result + 4 * v7);
      v9 = v6 + 2;
      if (v9 >= a3)
      {
        v10 = *v8;
      }
      else
      {
        v10 = *v8;
        v11 = v8[1];
        if (*v8 >= v11)
          v10 = v8[1];
        if (*v8 > v11)
        {
          ++v8;
          v7 = v9;
        }
      }
      v12 = *a4;
      if (v10 <= *a4)
      {
        do
        {
          v13 = v8;
          *a4 = v10;
          if (v5 < v7)
            break;
          v14 = (2 * v7) | 1;
          v8 = (int *)(result + 4 * v14);
          v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            v10 = *v8;
            v7 = v14;
          }
          else
          {
            v10 = *v8;
            v15 = v8[1];
            if (*v8 >= v15)
              v10 = v8[1];
            if (*v8 <= v15)
              v7 = v14;
            else
              ++v8;
          }
          a4 = v13;
        }
        while (v10 <= v12);
        *v13 = v12;
      }
    }
  }
  return result;
}

std::vector<int>::pointer std::vector<int>::__swap_out_circular_buffer(std::vector<int> *this, std::__split_buffer<int> *__v, std::vector<int>::pointer __p)
{
  int *begin;
  std::vector<int>::pointer v6;
  int *v7;
  std::vector<int>::pointer v8;
  int v9;
  int *end;
  std::__split_buffer<int>::pointer v11;
  int64_t v12;
  int *v13;
  int *v14;
  int *value;

  begin = __v->__begin_;
  v6 = this->__begin_;
  v7 = begin;
  if (this->__begin_ != __p)
  {
    v8 = __p;
    v7 = __v->__begin_;
    do
    {
      v9 = *--v8;
      *--v7 = v9;
    }
    while (v8 != v6);
  }
  __v->__begin_ = v7;
  end = this->__end_;
  v11 = __v->__end_;
  v12 = (char *)end - (char *)__p;
  if (end != __p)
  {
    memmove(__v->__end_, __p, (char *)end - (char *)__p);
    v7 = __v->__begin_;
  }
  __v->__end_ = (std::__split_buffer<int>::pointer)((char *)v11 + v12);
  v13 = this->__begin_;
  this->__begin_ = v7;
  __v->__begin_ = v13;
  v14 = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = v14;
  value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
  return begin;
}

void std::__split_buffer<int>::push_back(std::__split_buffer<int> *this, std::__split_buffer<int>::value_type *__x)
{
  std::__split_buffer<int>::pointer end;
  std::__split_buffer<int>::pointer begin;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  int64_t v14;
  int *v15;
  unint64_t v16;
  int *v17;
  uint64_t v18;
  int *v19;
  std::__split_buffer<int>::pointer v20;
  uint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  int v24;
  std::__split_buffer<int>::pointer first;

  end = this->__end_;
  if (end == this->__end_cap_.__value_)
  {
    begin = this->__begin_;
    v6 = (char *)begin - (char *)this->__first_;
    if (begin <= this->__first_)
    {
      if (end == this->__first_)
        v16 = 1;
      else
        v16 = ((char *)end - (char *)this->__first_) >> 1;
      v17 = (int *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)this->__end_cap_.__value_, v16);
      v19 = (int *)((char *)v17 + (v16 & 0xFFFFFFFFFFFFFFFCLL));
      v20 = this->__begin_;
      end = v19;
      v21 = (char *)this->__end_ - (char *)v20;
      if (v21)
      {
        end = (int *)((char *)v19 + (v21 & 0xFFFFFFFFFFFFFFFCLL));
        v22 = 4 * (v21 >> 2);
        v23 = (int *)((char *)v17 + (v16 & 0xFFFFFFFFFFFFFFFCLL));
        do
        {
          v24 = *v20++;
          *v23++ = v24;
          v22 -= 4;
        }
        while (v22);
      }
      first = this->__first_;
      this->__first_ = v17;
      this->__begin_ = v19;
      this->__end_ = end;
      this->__end_cap_.__value_ = &v17[v18];
      if (first)
      {
        operator delete(first);
        end = this->__end_;
      }
    }
    else
    {
      v7 = v6 >> 2;
      v8 = v6 >> 2 < -1;
      v9 = (v6 >> 2) + 2;
      if (v8)
        v10 = v9;
      else
        v10 = v7 + 1;
      v11 = -(v10 >> 1);
      v12 = v10 >> 1;
      v13 = &begin[-v12];
      v14 = (char *)end - (char *)begin;
      if (end != begin)
      {
        memmove(&begin[-v12], begin, (char *)end - (char *)begin);
        end = this->__begin_;
      }
      v15 = &end[v11];
      end = (int *)((char *)v13 + v14);
      this->__begin_ = v15;
    }
  }
  *end = *__x;
  this->__end_ = end + 1;
}

_QWORD *MTMouseEventDispatcher::createDispatcher(MTSimpleHIDManager *a1, const void *a2)
{
  _QWORD *v4;

  v4 = (_QWORD *)operator new();
  bzero(v4, 0x220uLL);
  MTSimpleEventDispatcher::MTSimpleEventDispatcher((MTSimpleEventDispatcher *)v4);
  v4[58] = v4 + 59;
  v4[59] = 0;
  v4[60] = 0;
  v4[61] = v4 + 61;
  v4[62] = v4 + 61;
  v4[63] = 0;
  *((_DWORD *)v4 + 134) = 1114636288;
  *v4 = &off_24FFF17E8;
  MTTrackpadEventDispatcher::initialize((uint64_t)v4, a1, a2);
  return v4;
}

void sub_23109A0E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10A1C4052F3E7C6);
  _Unwind_Resume(a1);
}

BOOL MTMouseEventDispatcher::shouldDispatchEvent(uint64_t a1)
{
  uint64_t v1;

  if (*(_BYTE *)(a1 + 424)
    || (IOHIDEventGetIntegerValue() & 0x100) != 0
    || (IOHIDEventGetIntegerValue() & 8) != 0
    || IOHIDEventConformsTo()
    || IOHIDEventConformsTo()
    || IOHIDEventConformsTo()
    || IOHIDEventConformsTo()
    || IOHIDEventConformsTo()
    || IOHIDEventConformsTo())
  {
    return 1;
  }
  v1 = 1;
  if (!IOHIDEventConformsTo())
    return IOHIDEventConformsTo() != 0;
  return v1;
}

void MTMouseEventDispatcher::dispatchEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFArray *Children;
  const __CFArray *v7;
  CFIndex Count;
  unint64_t v9;

  if (a2)
  {
    if (!*(_BYTE *)(a1 + 424))
    {
      Children = (const __CFArray *)IOHIDEventGetChildren();
      if (Children)
      {
        v7 = Children;
        Count = CFArrayGetCount(Children);
        if (Count >= 1)
        {
          v9 = Count + 1;
          do
          {
            CFArrayGetValueAtIndex(v7, v9 - 2);
            if (!IOHIDEventConformsTo()
              && !IOHIDEventConformsTo()
              && !IOHIDEventConformsTo()
              && !IOHIDEventConformsTo()
              && !IOHIDEventConformsTo()
              && !IOHIDEventConformsTo()
              && !IOHIDEventConformsTo()
              && !IOHIDEventConformsTo())
            {
              IOHIDEventRemoveEvent();
            }
            --v9;
          }
          while (v9 > 1);
        }
      }
    }
  }
  MTSimpleEventDispatcher::dispatchEvent(a1, a2, a3);
}

void MTMouseEventDispatcher::~MTMouseEventDispatcher(MTMouseEventDispatcher *this)
{
  *(_QWORD *)this = &off_24FFF1700;
  std::__list_imp<double>::clear((_QWORD *)this + 61);
  std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy((uint64_t)this + 464, *((_QWORD **)this + 59));
  MTSimpleEventDispatcher::~MTSimpleEventDispatcher(this);
}

{
  *(_QWORD *)this = &off_24FFF1700;
  std::__list_imp<double>::clear((_QWORD *)this + 61);
  std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy((uint64_t)this + 464, *((_QWORD **)this + 59));
  MTSimpleEventDispatcher::~MTSimpleEventDispatcher(this);
  JUMPOUT(0x2348D0034);
}

void MTSimpleHIDManager::MTSimpleHIDManager(MTSimpleHIDManager *this)
{
  *(_QWORD *)this = off_24FFF18D0;
  *((_QWORD *)this + 8) = 0;
  *((_BYTE *)this + 80) = 0;
  *((_DWORD *)this + 21) = 1;
  *((_DWORD *)this + 22) = 0;
  *(_WORD *)((char *)this + 123) = 0;
  *((_BYTE *)this + 125) = 0;
  atomic_store(1u, (unsigned int *)this + 2);
  *((_WORD *)this + 28) = 100;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
}

uint64_t MTSimpleHIDManager::initialize(MTModeSwitcher *a1, uint64_t a2, CFTypeRef cf, int a4, int a5)
{
  const __CFAllocator *v6;
  MTSLGLogger *Mutable;
  MTSimpleHIDManager *v8;

  *((_QWORD *)a1 + 2) = a2;
  *((_DWORD *)a1 + 39) = a4;
  *((_DWORD *)a1 + 40) = a5;
  *((_QWORD *)a1 + 3) = CFRetain(cf);
  *((_QWORD *)a1 + 4) = 0;
  *((_QWORD *)a1 + 21) = 0;
  *((_QWORD *)a1 + 22) = dispatch_queue_create("com.apple.MultitouchSupport.control-requests", 0);
  *((_QWORD *)a1 + 23) = dispatch_group_create();
  (*(void (**)(MTModeSwitcher *))(*(_QWORD *)a1 + 104))(a1);
  _printHIDEvents = 0;
  *((_DWORD *)a1 + 48) = 255;
  *((_QWORD *)a1 + 16) = 255;
  *((_BYTE *)a1 + 136) = 0;
  *((_DWORD *)a1 + 41) = 0;
  *((_BYTE *)a1 + 126) = 0;
  *((_BYTE *)a1 + 121) = (*(uint64_t (**)(MTModeSwitcher *))(*(_QWORD *)a1 + 344))(a1);
  *((_BYTE *)a1 + 121) = (*(uint64_t (**)(MTModeSwitcher *))(*(_QWORD *)a1 + 344))(a1);
  *((_QWORD *)a1 + 18) = 0;
  *((_BYTE *)a1 + 152) = 0;
  v6 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  *((_QWORD *)a1 + 5) = Mutable;
  *((_QWORD *)a1 + 25) = MTSLGLogger::createLogger(Mutable);
  *((_QWORD *)a1 + 6) = CFArrayCreateMutable(v6, *((unsigned __int16 *)a1 + 28), MEMORY[0x24BDBD690]);
  *((_QWORD *)a1 + 9) = CFDateFormatterCreate(v6, 0, kCFDateFormatterShortStyle, kCFDateFormatterFullStyle);
  *((_QWORD *)a1 + 14) = MTModeSwitcher::createModeSwitcher(a1, v8);
  return (*(uint64_t (**)(MTModeSwitcher *, uint64_t))(*(_QWORD *)a1 + 336))(a1, 1);
}

uint64_t MTSimpleHIDManager::start(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 280))(this);
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 48))(this);
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 64))(this);
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 144))(this);
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 288))(this);
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 152))(this);
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 88))(this);
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 296))(this);
  return 1;
}

uint64_t MTSimpleHIDManager::stop(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 56))(this);
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 96))(this);
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 72))(this);
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 56))(this);
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 160))(this);
  return (*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 112))(this);
}

void MTSimpleHIDManager::finalize(MTSimpleHIDManager *this)
{
  uint64_t v2;
  MTSLGLogger *v3;
  const void *v4;
  const void *v5;
  NSObject *v6;
  const void *v7;
  const void *v8;

  v2 = *((_QWORD *)this + 14);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *((_QWORD *)this + 14) = 0;
  v3 = (MTSLGLogger *)*((_QWORD *)this + 25);
  if (v3)
  {
    MTSLGLogger::~MTSLGLogger(v3);
    MEMORY[0x2348D0034]();
  }
  dispatch_group_wait(*((dispatch_group_t *)this + 23), 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(*((dispatch_object_t *)this + 23));
  *((_QWORD *)this + 23) = 0;
  dispatch_release(*((dispatch_object_t *)this + 22));
  *((_QWORD *)this + 22) = 0;
  v4 = (const void *)*((_QWORD *)this + 3);
  if (v4)
  {
    CFRelease(v4);
    *((_QWORD *)this + 3) = 0;
  }
  v5 = (const void *)*((_QWORD *)this + 5);
  if (v5)
  {
    CFRelease(v5);
    *((_QWORD *)this + 5) = 0;
  }
  v6 = *((_QWORD *)this + 21);
  if (v6)
  {
    dispatch_release(v6);
    *((_QWORD *)this + 21) = 0;
  }
  v7 = (const void *)*((_QWORD *)this + 6);
  if (v7)
  {
    CFRelease(v7);
    *((_QWORD *)this + 6) = 0;
  }
  v8 = (const void *)*((_QWORD *)this + 9);
  if (v8)
  {
    CFRelease(v8);
    *((_QWORD *)this + 9) = 0;
  }
  *((_QWORD *)this + 2) = 0;
}

uint64_t MTSimpleHIDManager::openManager(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 32))(this);
  return 1;
}

uint64_t MTSimpleHIDManager::closeManager(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *, uint64_t))(*(_QWORD *)this + 592))(this, 1);
  return (*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 40))(this);
}

uint64_t MTSimpleHIDManager::retain(uint64_t this)
{
  unsigned int *v1;
  unsigned int v3;

  v1 = (unsigned int *)(this + 8);
  if (!atomic_load((unsigned int *)(this + 8)))
    MTSimpleHIDManager::retain();
  do
    v3 = __ldaxr(v1);
  while (__stlxr(v3 + 1, v1));
  return this;
}

unsigned int *MTSimpleHIDManager::release(unsigned int *this)
{
  unsigned int *v1;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;

  v1 = this + 2;
  if (!atomic_load(this + 2))
    MTSimpleHIDManager::release();
  v3 = (uint64_t)this;
  do
  {
    v4 = __ldaxr(v1);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, v1));
  if (!v5)
  {
    (*(void (**)(unsigned int *))(*(_QWORD *)this + 24))(this);
    return (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return this;
}

uint64_t MTSimpleHIDManager::wasScheduledOnDispatchQueue(MTSimpleHIDManager *this, dispatch_object_t object)
{
  NSObject *v4;

  if (object)
    dispatch_retain(object);
  v4 = *((_QWORD *)this + 21);
  if (v4)
    dispatch_release(v4);
  *((_QWORD *)this + 21) = object;
  return (*(uint64_t (**)(_QWORD, dispatch_object_t))(**((_QWORD **)this + 4) + 88))(*((_QWORD *)this + 4), object);
}

uint64_t MTSimpleHIDManager::wasUnscheduledFromDispatchQueue(NSObject **this, dispatch_queue_s *a2)
{
  NSObject *v4;

  ((void (*)(NSObject **))(*this)[61].isa)(this);
  v4 = this[21];
  if (v4)
  {
    dispatch_release(v4);
    this[21] = 0;
  }
  (*((void (**)(NSObject *, dispatch_queue_s *))this[4]->isa + 8))(this[4], a2);
  return (*((uint64_t (**)(NSObject *, NSObject *))this[4]->isa + 11))(this[4], this[21]);
}

uint64_t MTSimpleHIDManager::getHIDDispatchQueue(MTSimpleHIDManager *this)
{
  return *((_QWORD *)this + 21);
}

uint64_t MTSimpleHIDManager::registerDeviceNotifications(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  return MTRegisterNotificationEventCallback();
}

uint64_t MTSimpleHIDManager::unregisterDeviceNotifications(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  return MTUnregisterNotificationEventCallback();
}

uint64_t MTSimpleHIDManager::registerExternalMessages(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  return MTRegisterExternalMessageCallback();
}

uint64_t MTSimpleHIDManager::forwardExternalMessage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a5 + 216))(a5, a1, a2, a3, a4);
}

uint64_t MTSimpleHIDManager::unregisterExternalMessages(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  return MTUnregisterExternalMessageCallback();
}

uint64_t MTSimpleHIDManager::registerDeviceDataCallbacks(MTSimpleHIDManager *this)
{
  uint64_t result;

  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  MTRegisterContactFrameCallbackWithRefcon();
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  MTDeviceSetInputDetectionCallbackTriggerMask();
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  MTRegisterInputDetectionCallback();
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  result = MTRegisterFrameHeaderCallback();
  if (*((_QWORD *)this + 25))
  {
    (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
    return MTRegisterImageCallbackWithRefcon();
  }
  return result;
}

uint64_t MTSimpleHIDManager::forwardContactFrame(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a5 + 184))(a5, a1, a2, a3, a4);
}

uint64_t MTSimpleHIDManager::forwardInputDetectionState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a5 + 200))(a5, a1, a2, a3, a4);
}

uint64_t MTSimpleHIDManager::forwardFrameHeader(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a3 + 224))(a3, a1, a2);
}

uint64_t MTSimpleHIDManager::forwardImageEntry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a4 + 232))(a4, a1, a2, a3);
}

uint64_t MTSimpleHIDManager::unregisterDeviceDataCallbacks(MTSimpleHIDManager *this)
{
  uint64_t result;

  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  MTUnregisterContactFrameCallback();
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  result = MTUnregisterInputDetectionCallback();
  if (*((_QWORD *)this + 25))
  {
    (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
    result = MTUnregisterImageCallback();
  }
  if (*((_BYTE *)this + 125))
  {
    *((_BYTE *)this + 125) = 0;
    (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
    return MTUnregisterFullFrameCallback();
  }
  return result;
}

uint64_t MTSimpleHIDManager::forwardFullFrame(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a4 + 240))(a4, a1, a2, a3);
}

void MTSimpleHIDManager::registerSystemCallbacks(MTSimpleHIDManager *this)
{
  __CFNotificationCenter *DarwinNotifyCenter;
  __CFNotificationCenter *v3;
  __CFNotificationCenter *v4;

  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver(DarwinNotifyCenter, this, (CFNotificationCallback)MTSimpleHIDManager::fieldOnNotificationCenterCallback, CFSTR("com.apple.stockholm.field.on"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  v3 = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver(v3, this, (CFNotificationCallback)MTSimpleHIDManager::fieldOffNotificationCenterCallback, CFSTR("com.apple.stockholm.field.off"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  v4 = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver(v4, this, (CFNotificationCallback)MTSimpleHIDManager::fieldOffNotificationCenterCallback, CFSTR("com.apple.stockholm.field.suspended"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
}

uint64_t MTSimpleHIDManager::fieldOnNotificationCenterCallback(MTSimpleHIDManager *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  return (*(uint64_t (**)(__CFNotificationCenter *, uint64_t))(*(_QWORD *)a2 + 456))(a2, 1);
}

uint64_t MTSimpleHIDManager::fieldOffNotificationCenterCallback(MTSimpleHIDManager *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  return (*(uint64_t (**)(__CFNotificationCenter *, uint64_t))(*(_QWORD *)a2 + 456))(a2, 2);
}

void MTSimpleHIDManager::unregisterSystemCallbacks(MTSimpleHIDManager *this)
{
  __CFNotificationCenter *DarwinNotifyCenter;
  __CFNotificationCenter *v3;
  __CFNotificationCenter *v4;

  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver(DarwinNotifyCenter, this, CFSTR("com.apple.stockholm.field.on"), 0);
  v3 = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver(v3, this, CFSTR("com.apple.stockholm.field.off"), 0);
  v4 = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver(v4, this, CFSTR("com.apple.stockholm.field.suspended"), 0);
}

unsigned int *MTSimpleHIDManager::createEventDispatcher(MTSimpleHIDManager *this)
{
  const void *v2;
  unsigned int *Dispatcher;

  v2 = (const void *)(*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  Dispatcher = (unsigned int *)MTSimpleEventDispatcher::createDispatcher(this, v2);
  (*(void (**)(MTSimpleHIDManager *, unsigned int *))(*(_QWORD *)this + 128))(this, Dispatcher);
  return MTSimpleEventDispatcher::release(Dispatcher);
}

uint64_t MTSimpleHIDManager::destroyEventDispatcher(MTSimpleHIDManager *this)
{
  return (*(uint64_t (**)(MTSimpleHIDManager *, _QWORD))(*(_QWORD *)this + 128))(this, 0);
}

uint64_t MTSimpleHIDManager::getEventDispatcher(MTSimpleHIDManager *this)
{
  return *((_QWORD *)this + 4);
}

unsigned int *MTSimpleHIDManager::setEventDispatcher(MTSimpleHIDManager *this, MTSimpleEventDispatcher *a2)
{
  unsigned int *result;
  BOOL v5;

  result = (unsigned int *)*((_QWORD *)this + 4);
  if (result)
    v5 = result == (unsigned int *)a2;
  else
    v5 = 1;
  if (!v5)
    result = MTSimpleEventDispatcher::release(result);
  *((_QWORD *)this + 4) = a2;
  if (a2)
    return (unsigned int *)MTSimpleEventDispatcher::retain((uint64_t)a2);
  return result;
}

void MTSimpleHIDManager::issueWakeEvent(MTSimpleHIDManager *this)
{
  const void *KeyboardEvent;
  const void *v3;

  mach_absolute_time();
  KeyboardEvent = (const void *)IOHIDEventCreateKeyboardEvent();
  (*(void (**)(MTSimpleHIDManager *, const void *, _QWORD))(*(_QWORD *)this + 136))(this, KeyboardEvent, 0);
  CFRelease(KeyboardEvent);
  mach_absolute_time();
  v3 = (const void *)IOHIDEventCreateKeyboardEvent();
  (*(void (**)(MTSimpleHIDManager *, const void *, _QWORD))(*(_QWORD *)this + 136))(this, v3, 0);
  CFRelease(v3);
}

uint64_t MTSimpleHIDManager::initializeGestureParser(MTSimpleHIDManager *this)
{
  return (*(uint64_t (**)(MTSimpleHIDManager *, _QWORD))(*(_QWORD *)this + 592))(this, 0);
}

uint64_t MTSimpleHIDManager::setPluginDefaultProperties(MTSimpleHIDManager *this)
{
  uint64_t v2;
  uint64_t v3;

  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 312))(this);
  v2 = *MEMORY[0x24BDBD268];
  if (_printHIDEvents)
    v3 = *MEMORY[0x24BDBD270];
  else
    v3 = *MEMORY[0x24BDBD268];
  (*(void (**)(MTSimpleHIDManager *, const __CFString *, uint64_t))(*(_QWORD *)this + 568))(this, CFSTR("PrintHIDEvents"), v3);
  return (*(uint64_t (**)(MTSimpleHIDManager *, const __CFString *, uint64_t))(*(_QWORD *)this + 568))(this, CFSTR("MotionActivityInterested"), v2);
}

void MTSimpleHIDManager::setDeviceDefaultProperties(MTSimpleHIDManager *this)
{
  const __CFAllocator *v2;
  CFNumberRef v3;
  CFNumberRef v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  char v10;
  __int16 v11;
  __int16 v12;
  __int16 valuePtr;

  if (*((_BYTE *)this + 122))
  {
    valuePtr = 0;
    v2 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberSInt16Type, &valuePtr);
    if (!v3)
      goto LABEL_7;
    v4 = v3;
    (*(void (**)(MTSimpleHIDManager *, const __CFString *, CFNumberRef))(*(_QWORD *)this + 568))(this, CFSTR("InputDetectionMode"), v3);
  }
  else
  {
    v12 = 0;
    v2 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberSInt16Type, &v12);
    if (!v5)
      goto LABEL_7;
    v4 = v5;
    (*(void (**)(MTSimpleHIDManager *, const __CFString *, CFNumberRef))(*(_QWORD *)this + 568))(this, CFSTR("TouchDetectionMode"), v5);
  }
  CFRelease(v4);
LABEL_7:
  v11 = 1;
  v6 = CFNumberCreate(v2, kCFNumberSInt16Type, &v11);
  if (v6)
  {
    v7 = v6;
    (*(void (**)(MTSimpleHIDManager *, const __CFString *, CFNumberRef))(*(_QWORD *)this + 568))(this, CFSTR("GraphicsOrientation"), v6);
    CFRelease(v7);
  }
  v10 = 0;
  v8 = CFNumberCreate(v2, kCFNumberSInt8Type, &v10);
  if (v8)
  {
    v9 = v8;
    (*(void (**)(MTSimpleHIDManager *, const __CFString *, CFNumberRef))(*(_QWORD *)this + 568))(this, CFSTR("WristState"), v8);
    CFRelease(v9);
  }
  if ((*((_BYTE *)this + 160) & 0x20) != 0)
    (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 352))(this);
  *((_BYTE *)this + 126) = 1;
}

uint64_t MTSimpleHIDManager::devicePropertiesBecameAvailable(MTSimpleHIDManager *this)
{
  CFNumberRef v2;
  BOOL v3;
  CFNumberRef v4;
  CFNumberRef v5;
  __int16 valuePtr;

  v2 = (CFNumberRef)(*(uint64_t (**)(MTSimpleHIDManager *, const __CFString *))(*(_QWORD *)this + 560))(this, CFSTR("InputDetectionMode"));
  if (*((_BYTE *)this + 122))
    v3 = v2 == 0;
  else
    v3 = 0;
  if (!v3)
  {
    if (!v2)
      return (*(uint64_t (**)(MTSimpleHIDManager *, uint64_t))(*(_QWORD *)this + 336))(this, 1);
    goto LABEL_9;
  }
  valuePtr = 0;
  v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberSInt16Type, &valuePtr);
  if (v4)
  {
    v5 = v4;
    (*(void (**)(MTSimpleHIDManager *, const __CFString *, CFNumberRef))(*(_QWORD *)this + 568))(this, CFSTR("InputDetectionMode"), v4);
    v2 = v5;
LABEL_9:
    CFRelease(v2);
  }
  return (*(uint64_t (**)(MTSimpleHIDManager *, uint64_t))(*(_QWORD *)this + 336))(this, 1);
}

uint64_t MTSimpleHIDManager::setDeviceUsages(MTSimpleHIDManager *this)
{
  unsigned int v2;
  _BOOL4 v4;
  int IsBuiltIn;
  const __CFAllocator *v6;
  __CFDictionary *Mutable;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  __CFDictionary *v12;
  CFNumberRef v13;
  CFNumberRef v14;
  int v15;
  CFNumberRef v16;
  CFNumberRef v17;
  __CFDictionary *v18;
  CFNumberRef v19;
  CFNumberRef v20;
  CFNumberRef v21;
  CFNumberRef v22;
  __CFDictionary *v23;
  CFNumberRef v24;
  CFNumberRef v25;
  CFNumberRef v26;
  CFNumberRef v27;
  __CFArray *v28;
  __CFArray *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int valuePtr;

  v2 = *((_DWORD *)this + 39);
  v4 = v2 < 0x3E8 || v2 - 3000 < 0x3E8;
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  IsBuiltIn = MTDeviceIsBuiltIn();
  valuePtr = 13;
  v6 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v8 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
  if (v8)
  {
    v9 = v8;
    (*(void (**)(MTSimpleHIDManager *, const __CFString *, CFNumberRef))(*(_QWORD *)this + 568))(this, CFSTR("PrimaryUsagePage"), v8);
    if (Mutable)
      CFDictionaryAddValue(Mutable, CFSTR("DeviceUsagePage"), v9);
    CFRelease(v9);
  }
  valuePtr = 12;
  v10 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
  if (v10)
  {
    v11 = v10;
    (*(void (**)(MTSimpleHIDManager *, const __CFString *, CFNumberRef))(*(_QWORD *)this + 568))(this, CFSTR("PrimaryUsage"), v10);
    if (Mutable)
      CFDictionaryAddValue(Mutable, CFSTR("DeviceUsage"), v11);
    CFRelease(v11);
  }
  if (v4)
  {
    v12 = CFDictionaryCreateMutable(v6, 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    valuePtr = 13;
    v13 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
    if (v13)
    {
      v14 = v13;
      if (v12)
        CFDictionaryAddValue(v12, CFSTR("DeviceUsagePage"), v13);
      CFRelease(v14);
    }
    if (IsBuiltIn)
      v15 = 4;
    else
      v15 = 5;
    valuePtr = v15;
    v16 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
    if (v16)
    {
      v17 = v16;
      if (v12)
        CFDictionaryAddValue(v12, CFSTR("DeviceUsage"), v16);
      (*(void (**)(MTSimpleHIDManager *, const __CFString *, CFNumberRef))(*(_QWORD *)this + 568))(this, CFSTR("PrimaryUsage"), v17);
      CFRelease(v17);
    }
  }
  else
  {
    v12 = 0;
  }
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  if (MTDeviceGetSensorRegionOfType())
  {
    v18 = 0;
  }
  else
  {
    *((_BYTE *)this + 122) = 1;
    v18 = CFDictionaryCreateMutable(v6, 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (v18)
    {
      valuePtr = 65280;
      v19 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
      if (v19)
      {
        v20 = v19;
        CFDictionaryAddValue(v18, CFSTR("DeviceUsagePage"), v19);
        CFRelease(v20);
      }
      valuePtr = 8;
      v21 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
      if (v21)
      {
        v22 = v21;
        CFDictionaryAddValue(v18, CFSTR("DeviceUsage"), v21);
        CFRelease(v22);
      }
    }
  }
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  if (MTDeviceSupportsForce())
  {
    v23 = CFDictionaryCreateMutable(v6, 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (v23)
    {
      valuePtr = 65280;
      v24 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
      if (v24)
      {
        v25 = v24;
        CFDictionaryAddValue(v23, CFSTR("DeviceUsagePage"), v24);
        CFRelease(v25);
      }
      valuePtr = 19;
      v26 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
      if (v26)
      {
        v27 = v26;
        CFDictionaryAddValue(v23, CFSTR("DeviceUsage"), v26);
        CFRelease(v27);
      }
    }
  }
  else
  {
    v23 = 0;
  }
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  MTDeviceGetFamilyID();
  v28 = CFArrayCreateMutable(v6, 2, MEMORY[0x24BDBD690]);
  if (v28)
  {
    v29 = v28;
    if (Mutable)
      CFArrayAppendValue(v28, Mutable);
    if (v12)
      CFArrayAppendValue(v29, v12);
    if (v18)
      CFArrayAppendValue(v29, v18);
    if (v23)
      CFArrayAppendValue(v29, v23);
    (*(void (**)(MTSimpleHIDManager *, const __CFString *, __CFArray *))(*(_QWORD *)this + 568))(this, CFSTR("DeviceUsagePairs"), v29);
    CFRelease(v29);
  }
  if (Mutable)
    CFRelease(Mutable);
  if (v12)
    CFRelease(v12);
  if (v18)
    CFRelease(v18);
  if (v23)
    CFRelease(v23);
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  v30 = MTDeviceIsBuiltIn();
  v31 = *MEMORY[0x24BDBD270];
  v32 = *MEMORY[0x24BDBD268];
  if (v30)
    v33 = *MEMORY[0x24BDBD270];
  else
    v33 = *MEMORY[0x24BDBD268];
  (*(void (**)(MTSimpleHIDManager *, const __CFString *, uint64_t))(*(_QWORD *)this + 568))(this, CFSTR("Built-In"), v33);
  if ((v4 & IsBuiltIn) != 0)
    v34 = v31;
  else
    v34 = v32;
  return (*(uint64_t (**)(MTSimpleHIDManager *, const __CFString *, uint64_t))(*(_QWORD *)this + 568))(this, CFSTR("DisplayIntegrated"), v34);
}

void MTSimpleHIDManager::enableReportingOfAllInputs(dispatch_object_t *this)
{
  NSObject *v2;
  NSObject *v3;
  _QWORD block[5];

  dispatch_retain(this[22]);
  dispatch_retain(this[23]);
  v3 = this[22];
  v2 = this[23];
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 0x40000000;
  block[2] = ___ZN18MTSimpleHIDManager26enableReportingOfAllInputsEv_block_invoke;
  block[3] = &__block_descriptor_tmp_0;
  block[4] = this;
  dispatch_group_async(v2, v3, block);
}

void ___ZN18MTSimpleHIDManager26enableReportingOfAllInputsEv_block_invoke(uint64_t a1)
{
  dispatch_object_t *v1;

  v1 = *(dispatch_object_t **)(a1 + 32);
  ((void (*)(dispatch_object_t *))(*v1)[45].isa)(v1);
  dispatch_release(v1[23]);
  dispatch_release(v1[22]);
}

void MTSimpleHIDManager::_enableReportingOfAllInputs(MTSimpleHIDManager *this)
{
  int Report;
  int v3;
  NSObject *v4;
  const char *v5;
  NSObject *v6;
  uint32_t v7;
  int v8;
  int v9;
  NSObject *v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  Report = MTDeviceGetReport();
  if (Report)
  {
    v3 = Report;
    v4 = MTLoggingPlugin();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136315906;
    v12 = "[Error] ";
    v13 = 2080;
    v14 = "MTSimpleHIDManager::";
    v15 = 2080;
    v16 = "_enableReportingOfAllInputs";
    v17 = 1024;
    v18 = v3;
    v5 = "[HID] [MT] %s%s%s Error 0x%08X getting detection options";
    v6 = v4;
    v7 = 38;
    goto LABEL_7;
  }
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  v8 = MTDeviceSetReport();
  if (v8)
  {
    v9 = v8;
    v10 = MTLoggingPlugin();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316162;
      v12 = "[Error] ";
      v13 = 2080;
      v14 = "MTSimpleHIDManager::";
      v15 = 2080;
      v16 = "_enableReportingOfAllInputs";
      v17 = 1024;
      v18 = v9;
      v19 = 1024;
      v20 = 9;
      v5 = "[HID] [MT] %s%s%s Error 0x%08X setting detection options to 0x%02X";
      v6 = v10;
      v7 = 44;
LABEL_7:
      _os_log_impl(&dword_231071000, v6, OS_LOG_TYPE_ERROR, v5, buf, v7);
    }
  }
}

void ___ZN18MTSimpleHIDManager23setFieldDetectionStatusEv_block_invoke(uint64_t a1)
{
  dispatch_object_t *v1;

  v1 = *(dispatch_object_t **)(a1 + 32);
  ((void (*)(dispatch_object_t *))(*v1)[47].isa)(v1);
  dispatch_release(v1[23]);
  dispatch_release(v1[22]);
}

uint64_t MTSimpleHIDManager::_setFieldDetectionStatus(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  return MTDeviceSetReport();
}

uint64_t MTSimpleHIDManager::deviceIsReady(MTSimpleHIDManager *this)
{
  return *((unsigned __int8 *)this + 120);
}

uint64_t MTSimpleHIDManager::setDeviceIsReady(MTSimpleHIDManager *this, int a2)
{
  _QWORD *v2;

  *((_BYTE *)this + 120) = a2;
  v2 = (_QWORD *)MEMORY[0x24BDBD270];
  if (!a2)
    v2 = (_QWORD *)MEMORY[0x24BDBD268];
  return (*(uint64_t (**)(MTSimpleHIDManager *, const __CFString *, _QWORD))(*(_QWORD *)this + 568))(this, CFSTR("DeviceIsReady"), *v2);
}

BOOL MTSimpleHIDManager::checkForParserDisabled(MTSimpleHIDManager *this)
{
  io_registry_entry_t Service;
  CFTypeRef CFProperty;
  _BOOL8 v4;

  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  if (!MTDeviceGetService())
    return 0;
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  Service = MTDeviceGetService();
  CFProperty = IORegistryEntryCreateCFProperty(Service, CFSTR("ParserDisabled"), (CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
  v4 = CFProperty == (CFTypeRef)*MEMORY[0x24BDBD270];
  if (CFProperty)
    CFRelease(CFProperty);
  return v4;
}

BOOL MTSimpleHIDManager::propertyIsPublishedOnDriver(uint64_t a1, int a2)
{
  return a2 == 16 || (a2 - 59) < 0xB;
}

CFDictionaryRef MTSimpleHIDManager::copyProperty(CFDictionaryRef *this, const __CFString *a2)
{
  uint64_t v4;
  uint64_t v5;
  const __CFAllocator *v6;
  CFNumberType v7;
  const __CFAllocator *v8;
  __CFDictionary *CFProperty;
  unint64_t v10;
  CFNumberRef v11;
  unint64_t v12;
  CFNumberRef v13;
  const __CFString *v14;
  float v15;
  CFNumberRef v16;
  CFNumberRef v17;
  const __CFAllocator *v18;
  const __CFDictionary *Copy;
  __CFDictionary *Value;
  const __CFDictionary *v21;
  io_registry_entry_t Service;
  const __CFAllocator *v24;
  __CFDictionary *Mutable;
  CFArrayRef v26;
  CFArrayRef v27;
  const void *v28;
  const void *v29;
  CFNumberRef v30;
  unsigned int v31;
  unsigned int valuePtr;
  int v33;
  double v34[2];
  float v35;
  float v36;

  v4 = MTSimpleHIDManager::propertyTypeFromString((uint64_t)a2, a2);
  v5 = v4;
  if ((int)v4 <= 25)
  {
    if ((_DWORD)v4 == 13)
    {
      (*((void (**)(double *__return_ptr, CFDictionaryRef *))*this + 21))(v34, this);
      v15 = v35;
    }
    else
    {
      if ((_DWORD)v4 != 14)
      {
        if ((_DWORD)v4 == 24)
        {
          LODWORD(v34[0]) = 0;
          (*((void (**)(CFDictionaryRef *))*this + 10))(this);
          if (!MTDeviceGetCriticalErrors())
          {
            v6 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
            v7 = kCFNumberSInt32Type;
            goto LABEL_15;
          }
        }
LABEL_17:
        v18 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
        Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x24BDBD240], this[5]);
        Value = (__CFDictionary *)CFDictionaryGetValue(Copy, a2);
        if (Value)
        {
          CFProperty = Value;
          CFRetain(Value);
        }
        else
        {
          (*((void (**)(CFDictionaryRef *))*this + 10))(this);
          Service = MTDeviceGetService();
          CFProperty = (__CFDictionary *)IORegistryEntryCreateCFProperty(Service, a2, v18, 0);
          if (CFProperty)
          {
            if ((*((unsigned int (**)(CFDictionaryRef *, uint64_t))*this + 48))(this, v5))
              (*((void (**)(CFDictionaryRef *, const __CFString *, _QWORD, uint64_t))*this + 49))(this, a2, 0, 1);
          }
        }
        v21 = Copy;
        goto LABEL_20;
      }
      (*((void (**)(double *__return_ptr, CFDictionaryRef *))*this + 21))(v34, this);
      v15 = v36;
    }
    v34[0] = v15;
    v6 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v7 = kCFNumberDoubleType;
LABEL_15:
    v16 = CFNumberCreate(v6, v7, v34);
    if (v16)
    {
      v17 = v16;
      CFDictionarySetValue(this[5], a2, v16);
      CFRelease(v17);
    }
    goto LABEL_17;
  }
  if ((_DWORD)v4 != 26)
  {
    if ((_DWORD)v4 == 73)
    {
      v24 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 3, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
      if (!Mutable)
        goto LABEL_17;
      CFProperty = Mutable;
      CFDictionarySetValue(Mutable, CFSTR("Service properties"), this[5]);
      v26 = CFArrayCreateCopy(v24, this[6]);
      if (v26)
      {
        v27 = v26;
        CFDictionarySetValue(CFProperty, CFSTR("Recent set properties"), v26);
        CFRelease(v27);
      }
      v28 = (const void *)(*(uint64_t (**)(CFDictionaryRef))(*(_QWORD *)this[4] + 104))(this[4]);
      if (v28)
      {
        v29 = v28;
        CFDictionarySetValue(CFProperty, CFSTR("Event dispatch"), v28);
        CFRelease(v29);
      }
      LODWORD(v34[0]) = 0;
      (*((void (**)(CFDictionaryRef *))*this + 10))(this);
      if (MTDeviceGetCriticalErrors())
        return CFProperty;
      v30 = CFNumberCreate(v24, kCFNumberSInt32Type, v34);
      if (!v30)
        return CFProperty;
      v13 = v30;
      v14 = CFSTR("Critical errors");
    }
    else
    {
      if ((_DWORD)v4 != 77)
        goto LABEL_17;
      v33 = 0;
      LODWORD(v34[0]) = 0;
      (*((void (**)(CFDictionaryRef *))*this + 10))(this);
      if (MTDeviceGetSensorSurfaceDimensions())
        goto LABEL_17;
      v8 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
      CFProperty = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
      LODWORD(v10) = LODWORD(v34[0]);
      valuePtr = vcvtd_n_s64_f64((double)v10 / 100.0, 0x10uLL);
      v11 = CFNumberCreate(v8, kCFNumberSInt32Type, &valuePtr);
      CFDictionarySetValue(CFProperty, CFSTR("Width"), v11);
      CFRelease(v11);
      LODWORD(v12) = v33;
      v31 = vcvtd_n_s64_f64((double)v12 / 100.0, 0x10uLL);
      v13 = CFNumberCreate(v8, kCFNumberSInt32Type, &v31);
      v14 = CFSTR("Height");
    }
    CFDictionarySetValue(CFProperty, v14, v13);
    v21 = v13;
LABEL_20:
    CFRelease(v21);
    return CFProperty;
  }
  return CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x24BDBD240], this[5]);
}

uint64_t MTSimpleHIDManager::translateInputDetectionMode(uint64_t a1, unsigned int a2)
{
  unsigned int v3;

  if (a2 <= 6)
  {
    if (((1 << a2) & 9) != 0)
      return 0;
    if (((1 << a2) & 0x12) != 0)
      return 2;
    if (((1 << a2) & 0x60) != 0)
      return 1;
  }
  if (a2 == 254)
    v3 = 254;
  else
    v3 = 255;
  if (a2 == 253)
    return 253;
  else
    return v3;
}

BOOL MTSimpleHIDManager::touchPowered(MTSimpleHIDManager *this)
{
  uint64_t v1;

  v1 = 128;
  if (!*((_BYTE *)this + 122))
    v1 = 192;
  return *(_DWORD *)((char *)this + v1) != 255;
}

uint64_t MTSimpleHIDManager::resetDevice(MTSimpleHIDManager *this)
{
  return 3758097095;
}

const char *MTSimpleHIDManager::powerStateToStr(unsigned int a1)
{
  if (a1 > 2)
    return "<UNKNOWN>";
  else
    return off_24FFF1C08[a1];
}

uint64_t MTSimpleHIDManager::setupBootloadPowerAssertion(MTSimpleHIDManager *this, uint64_t a2)
{
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  int v8;
  const char *v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v8 = 136315650;
    v9 = "";
    v10 = 2080;
    v11 = "MTSimpleHIDManager::";
    v12 = 2080;
    v13 = "setupBootloadPowerAssertion";
    _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s ", (uint8_t *)&v8, 0x20u);
  }
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 488))(this);
  v5 = MTLoggingPlugin();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *((_QWORD *)this + 13) + 1;
    *((_QWORD *)this + 13) = v6;
    v8 = 136315906;
    v9 = "";
    v10 = 2080;
    v11 = "MTSimpleHIDManager::";
    v12 = 2080;
    v13 = "setupBootloadPowerAssertion";
    v14 = 2048;
    v15 = v6;
    _os_log_impl(&dword_231071000, v5, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s [generation: %llu]", (uint8_t *)&v8, 0x2Au);
  }
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 496))(this);
  return (*(uint64_t (**)(MTSimpleHIDManager *, uint64_t, _QWORD))(*(_QWORD *)this + 512))(this, a2, *((_QWORD *)this + 13));
}

void MTSimpleHIDManager::takeBootloadPowerAssertion(IOPMAssertionID *this)
{
  int *v1;
  IOReturn v2;
  NSObject *v3;
  NSObject *v4;
  int v5;
  const char *v6;
  NSObject *v7;
  os_log_type_t v8;
  uint32_t v9;
  int v10;
  int v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  IOReturn v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v1 = (int *)(this + 22);
  v2 = IOPMAssertionCreateWithName(CFSTR("PreventUserIdleSystemSleep"), 0xFFu, CFSTR("MT.bootload"), this + 22);
  v3 = MTLoggingPlugin();
  v4 = v3;
  if (v2)
  {
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      return;
    v5 = *v1;
    v11 = 136316162;
    v12 = "[Error] ";
    v13 = 2080;
    v14 = "MTSimpleHIDManager::";
    v15 = 2080;
    v16 = "takeBootloadPowerAssertion";
    v17 = 1024;
    v18 = v5;
    v19 = 1024;
    v20 = v2;
    v6 = "[HID] [MT] %s%s%s Failed to take power assertion %u: 0x%08x";
    v7 = v4;
    v8 = OS_LOG_TYPE_ERROR;
    v9 = 44;
  }
  else
  {
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      return;
    v10 = *v1;
    v11 = 136315906;
    v12 = "";
    v13 = 2080;
    v14 = "MTSimpleHIDManager::";
    v15 = 2080;
    v16 = "takeBootloadPowerAssertion";
    v17 = 1024;
    v18 = v10;
    v6 = "[HID] [MT] %s%s%s Took power assertion %u";
    v7 = v4;
    v8 = OS_LOG_TYPE_DEFAULT;
    v9 = 38;
  }
  _os_log_impl(&dword_231071000, v7, v8, v6, (uint8_t *)&v11, v9);
}

void MTSimpleHIDManager::releaseBootloadPowerAssertion(MTSimpleHIDManager *this)
{
  IOPMAssertionID v2;
  IOReturn v3;
  NSObject *v4;
  int v5;
  int v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  IOReturn v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v2 = *((_DWORD *)this + 22);
  if (v2)
  {
    v3 = IOPMAssertionRelease(v2);
    v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *((_DWORD *)this + 22);
      v6 = 136316162;
      v7 = "";
      v8 = 2080;
      v9 = "MTSimpleHIDManager::";
      v10 = 2080;
      v11 = "releaseBootloadPowerAssertion";
      v12 = 1024;
      v13 = v5;
      v14 = 1024;
      v15 = v3;
      _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Released power assertion %u: 0x%08x", (uint8_t *)&v6, 0x2Cu);
    }
    *((_DWORD *)this + 22) = 0;
  }
}

void MTSimpleHIDManager::startBootloadPowerAssertionTimer(dispatch_queue_t *this, unsigned int a2, uint64_t a3)
{
  dispatch_source_t v6;
  NSObject *v7;
  dispatch_time_t v8;
  NSObject *v9;
  NSObject *v10;
  _QWORD v11[6];
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  unsigned int v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v6 = dispatch_source_create(MEMORY[0x24BDACA18], 0, 0, this[21]);
  this[12] = v6;
  if (v6)
  {
    v7 = v6;
    v8 = dispatch_time(0, (uint64_t)((double)a2 * 1000000000.0));
    dispatch_source_set_timer(v7, v8, 0xFFFFFFFFFFFFFFFFLL, 0);
    v9 = this[12];
    v11[0] = MEMORY[0x24BDAC760];
    v11[1] = 0x40000000;
    v11[2] = ___ZN18MTSimpleHIDManager32startBootloadPowerAssertionTimerEjy_block_invoke;
    v11[3] = &__block_descriptor_tmp_218;
    v11[4] = this;
    v11[5] = a3;
    dispatch_source_set_event_handler(v9, v11);
    dispatch_resume(this[12]);
    v10 = MTLoggingPlugin();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v13 = "";
      v14 = 2080;
      v15 = "MTSimpleHIDManager::";
      v16 = 2080;
      v17 = "startBootloadPowerAssertionTimer";
      v18 = 1024;
      v19 = a2;
      _os_log_impl(&dword_231071000, v10, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Started bootload power assertion timer (%us)", buf, 0x26u);
    }
  }
}

void ___ZN18MTSimpleHIDManager32startBootloadPowerAssertionTimerEjy_block_invoke(uint64_t a1)
{
  _QWORD *v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  const char *v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)(a1 + 32);
  v3 = MTLoggingPlugin();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    v4 = *(_QWORD *)(a1 + 40);
    v5 = v2[13];
    v7 = 136316162;
    v8 = "[Error] ";
    v9 = 2080;
    v10 = "MTSimpleHIDManager::";
    v11 = 2080;
    v12 = "startBootloadPowerAssertionTimer_block_invoke";
    v13 = 2048;
    v14 = v4;
    v15 = 2048;
    v16 = v5;
    _os_log_impl(&dword_231071000, v3, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Bootload timer expired [generation = %llu, _bootloadPowerAssertion.generation = %llu]", (uint8_t *)&v7, 0x34u);
  }
  if (*(_QWORD *)(a1 + 40) == v2[13])
  {
    (*(void (**)(_QWORD *))(*v2 + 488))(v2);
    v6 = v2[14];
    if (v6)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
  }
}

void MTSimpleHIDManager::cancelBootloadPowerAssertionTimer(dispatch_source_t *this)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (this[12])
  {
    v2 = MTLoggingPlugin();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315650;
      v4 = "";
      v5 = 2080;
      v6 = "MTSimpleHIDManager::";
      v7 = 2080;
      v8 = "cancelBootloadPowerAssertionTimer";
      _os_log_impl(&dword_231071000, v2, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Cancelling bootload power assertion timer", (uint8_t *)&v3, 0x20u);
    }
    dispatch_source_cancel(this[12]);
    dispatch_release(this[12]);
    this[12] = 0;
  }
}

_DWORD *MTSimpleHIDManager::updateFieldDetectStatus(_DWORD *result, int a2)
{
  if (result[41] != a2)
  {
    result[41] = a2;
    return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)result + 368))(result);
  }
  return result;
}

uint64_t MTSimpleHIDManager::setWristState(MTSimpleHIDManager *this)
{
  return 0;
}

uint64_t MTSimpleHIDManager::setInputDetectionModeForOrientation(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  return MTDeviceSetInputDetectionModeForOrientation();
}

const char *MTSimpleHIDManager::getName(MTSimpleHIDManager *this)
{
  return "MTSimpleHIDManager";
}

uint64_t MTSimpleHIDManager::getHIDService(MultitouchHIDClass **this)
{
  return MultitouchHIDClass::getHIDService(this[2]);
}

_QWORD *MTSimpleHIDManager::setEventCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *result;

  result = *(_QWORD **)(a1 + 32);
  if (result)
    return MTSimpleEventDispatcher::setEventCallback(result, a2, a3, a4);
  return result;
}

double MTSimpleHIDManager::getSurfacePixelDimensions(MTSimpleHIDManager *this)
{
  NSObject *v1;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v1 = MTLoggingPlugin();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315650;
    v4 = "[Error] ";
    v5 = 2080;
    v6 = "MTSimpleHIDManager::";
    v7 = 2080;
    v8 = "getSurfacePixelDimensions";
    _os_log_impl(&dword_231071000, v1, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s using getSurfacePixelDimensions()", (uint8_t *)&v3, 0x20u);
  }
  return 320.0;
}

double MTSimpleHIDManager::getSurfaceBounds_mm(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this);
  MTDeviceGetSensorSurfaceDimensions();
  return 0.0;
}

uint64_t MTSimpleHIDManager::handleFullFrame(uint64_t result)
{
  if (*(_BYTE *)(result + 124))
    return MTDeviceInjectFrame();
  return result;
}

uint64_t MTSimpleHIDManager::handleContactFrameEntry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, double a7)
{
  kdebug_trace();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, double))(*(_QWORD *)a1 + 192))(a1, a2, a3, a4, a5, a6, a7);
}

uint64_t MTSimpleHIDManager::handleInputDetectionState(_BYTE *a1, uint64_t a2, unsigned int a3, int a4, int a5)
{
  int v9;
  uint64_t ProximtyEvent;
  const void *v11;
  NSObject *v12;
  int v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  unsigned int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  if (a1[122])
  {
    v9 = a3 & 0x41 | (((a3 >> 5) & 1) << 8) | (a3 >> 2) & 0x200;
    mach_absolute_time();
    ProximtyEvent = IOHIDEventCreateProximtyEvent();
    if (ProximtyEvent)
    {
      v11 = (const void *)ProximtyEvent;
      (*(void (**)(_BYTE *, uint64_t, _QWORD))(*(_QWORD *)a1 + 136))(a1, ProximtyEvent, 0);
      v12 = MTLoggingPlugin();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        v14 = 136316674;
        v15 = "";
        v16 = 2080;
        v17 = "MTSimpleHIDManager::";
        v18 = 2080;
        v19 = "handleInputDetectionState";
        v20 = 1024;
        v21 = v9;
        v22 = 1024;
        v23 = a3;
        v24 = 1024;
        v25 = a4;
        v26 = 1024;
        v27 = a5;
        _os_log_impl(&dword_231071000, v12, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Dispatching proximity event [0x%X] - detected inputs %u, receiver value %d, farfield value %d", (uint8_t *)&v14, 0x38u);
      }
      CFRelease(v11);
    }
  }
  return 1;
}

uint64_t MTSimpleHIDManager::handleExternalMessage(uint64_t a1, CFTypeRef cf, const void *a3, __int16 a4, unsigned int a5)
{
  NSObject *global_queue;
  uint64_t result;
  void *v12;
  uint64_t VendorDefinedEvent;
  const void *v14;
  _QWORD block[5];

  if ((a4 & 0xFFFE) == 0x1000)
  {
    CFRetain(cf);
    global_queue = dispatch_get_global_queue(0, 0);
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 0x40000000;
    block[2] = ___ZN18MTSimpleHIDManager21handleExternalMessageEP10__MTDevicePhtj_block_invoke;
    block[3] = &__block_descriptor_tmp_220;
    block[4] = cf;
    dispatch_async(global_queue, block);
    return 0;
  }
  else
  {
    result = (uint64_t)malloc_type_malloc(a5 + 2, 0xF8AE8F29uLL);
    if (result)
    {
      v12 = (void *)result;
      *(_WORD *)result = a4;
      memcpy((void *)(result + 2), a3, a5);
      mach_absolute_time();
      VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
      if (VendorDefinedEvent)
      {
        v14 = (const void *)VendorDefinedEvent;
        (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 136))(a1, VendorDefinedEvent, 0);
        CFRelease(v14);
      }
      free(v12);
      return 1;
    }
  }
  return result;
}

void ___ZN18MTSimpleHIDManager21handleExternalMessageEP10__MTDevicePhtj_block_invoke(uint64_t a1)
{
  int updated;
  int v3;
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  updated = MTDeviceUpdateDynamicCalibration();
  if (updated)
  {
    v3 = updated;
    v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = 136315906;
      v6 = "";
      v7 = 2080;
      v8 = "MTSimpleHIDManager::";
      v9 = 2080;
      v10 = "handleExternalMessage_block_invoke";
      v11 = 1024;
      v12 = v3;
      _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s MTDeviceUpdateDynamicCalibration failed with error code 0x%X", (uint8_t *)&v5, 0x26u);
    }
  }
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

uint64_t MTSimpleHIDManager::handleFrameHeader()
{
  return 0;
}

uint64_t MTSimpleHIDManager::fieldSuspendedNotificationCenterCallback(MTSimpleHIDManager *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  return (*(uint64_t (**)(__CFNotificationCenter *, uint64_t))(*(_QWORD *)a2 + 456))(a2, 3);
}

uint64_t MTSimpleHIDManager::setOutputEvent(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 136))(a1, a2, 0);
  return 0;
}

uint64_t MTSimpleHIDManager::copyEvent(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t result;
  int IntegerValue;
  int v6;
  int v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  result = 0;
  v19 = *MEMORY[0x24BDAC8D0];
  if (a2 == 1 && a3)
  {
    IntegerValue = IOHIDEventGetIntegerValue();
    v6 = IOHIDEventGetIntegerValue();
    if (IntegerValue != 65376)
      return 0;
    v7 = v6;
    v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136316162;
      v10 = "";
      v11 = 2080;
      v12 = "MTSimpleHIDManager::";
      v13 = 2080;
      v14 = "copyEvent";
      v15 = 1024;
      v16 = 65376;
      v17 = 1024;
      v18 = v7;
      _os_log_impl(&dword_231071000, v8, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s copyEvent requested for usagePage: %u, usage: %u", (uint8_t *)&v9, 0x2Cu);
    }
    if (v7 == 9)
    {
      LOBYTE(v9) = *(_BYTE *)(a1 + 127);
      mach_absolute_time();
      return IOHIDEventCreateVendorDefinedEvent();
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL MTSimpleHIDManager::touchFramesAllowed(MTSimpleHIDManager *this)
{
  uint64_t v1;

  v1 = 128;
  if (!*((_BYTE *)this + 122))
    v1 = 192;
  return (*(_DWORD *)((char *)this + v1) - 256) < 0xFFFFFFFD;
}

uint64_t ___ZL23queryIOReporterChannelsj_block_invoke()
{
  return ~(IOReportChannelGetCategories() >> 4) & 0x10;
}

MTSimpleHIDManager *MTTrackpadHIDManager::createManager(uint64_t a1, const void *a2, int a3, int a4)
{
  MTSimpleHIDManager *v8;

  v8 = (MTSimpleHIDManager *)operator new();
  *(_OWORD *)v8 = 0u;
  *((_OWORD *)v8 + 1) = 0u;
  *((_OWORD *)v8 + 2) = 0u;
  *((_OWORD *)v8 + 3) = 0u;
  *((_OWORD *)v8 + 4) = 0u;
  *((_OWORD *)v8 + 5) = 0u;
  *((_OWORD *)v8 + 6) = 0u;
  *((_OWORD *)v8 + 7) = 0u;
  *((_OWORD *)v8 + 8) = 0u;
  *((_OWORD *)v8 + 9) = 0u;
  *((_OWORD *)v8 + 10) = 0u;
  *((_OWORD *)v8 + 11) = 0u;
  *((_OWORD *)v8 + 12) = 0u;
  *((_OWORD *)v8 + 13) = 0u;
  *((_OWORD *)v8 + 14) = 0u;
  *((_OWORD *)v8 + 15) = 0u;
  *((_OWORD *)v8 + 16) = 0u;
  *((_OWORD *)v8 + 17) = 0u;
  *((_OWORD *)v8 + 18) = 0u;
  *((_OWORD *)v8 + 19) = 0u;
  *((_OWORD *)v8 + 20) = 0u;
  *((_OWORD *)v8 + 21) = 0u;
  MTSimpleHIDManager::MTSimpleHIDManager(v8);
  *(_QWORD *)v8 = &off_24FFF1F78;
  MTTrackpadHIDManager::initialize(v8, a1, a2, a3, a4);
  return v8;
}

void sub_23109CF04(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10A1C40E75266F5);
  _Unwind_Resume(a1);
}

uint64_t MTTrackpadHIDManager::initialize(MTModeSwitcher *a1, uint64_t a2, CFTypeRef cf, int a4, int a5)
{
  uint64_t v10;
  uint64_t v11;

  *((_QWORD *)a1 + 42) = 0;
  *((_WORD *)a1 + 104) = 0;
  *((_BYTE *)a1 + 210) = 0;
  *((_QWORD *)a1 + 35) = 0;
  if ((a4 - 1000) <= 0x3E7)
  {
    v10 = (*(uint64_t (**)(MTModeSwitcher *))(*(_QWORD *)a1 + 848))(a1);
    (*(void (**)(MTModeSwitcher *, CFTypeRef, uint64_t))(*(_QWORD *)a1 + 856))(a1, cf, v10);
  }
  *((_DWORD *)a1 + 72) = 0;
  *((_QWORD *)a1 + 37) = 0;
  *((_DWORD *)a1 + 76) = 0;
  *((_QWORD *)a1 + 39) = 0;
  *((_QWORD *)a1 + 40) = 0;
  if (a4 == 2001 || a4 == 1001)
  {
    v11 = operator new();
    MTInputDeviceManagement::MTInputDeviceManagement(v11, (uint64_t)cf);
    *((_QWORD *)a1 + 41) = v11;
  }
  return MTSimpleHIDManager::initialize(a1, a2, cf, a4, a5);
}

void sub_23109D004(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10E1C406FE0ECE6);
  _Unwind_Resume(a1);
}

void MTTrackpadHIDManager::finalize(MTTrackpadHIDManager *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 41);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    *((_QWORD *)this + 41) = 0;
  }
  MTSimpleHIDManager::finalize(this);
}

void MTTrackpadHIDManager::setDeviceUsages(MTTrackpadHIDManager *this)
{
  MTTrackpadHIDManager *v2;
  MTTrackpadHIDManager *v3;

  MTSimpleHIDManager::setDeviceUsages(this);
  v2 = (MTTrackpadHIDManager *)(*(uint64_t (**)(MTTrackpadHIDManager *, const __CFString *))(*(_QWORD *)this + 560))(this, CFSTR("DeviceUsagePairs"));
  if (v2)
  {
    v3 = v2;
    MTTrackpadHIDManager::appendDeviceUsagePairs(v2, (__CFArray *)0xFF00, 1);
    MTTrackpadHIDManager::appendDeviceUsagePairs(v3, (__CFArray *)0xFF00, 12);
    MTTrackpadHIDManager::appendDeviceUsagePairs(v3, (__CFArray *)1, 1);
    MTTrackpadHIDManager::appendDeviceUsagePairs(v3, (__CFArray *)1, 2);
    MTTrackpadHIDManager::appendDeviceUsagePairs(v3, (__CFArray *)0xD, 5);
    MTSimpleHIDManager::setProperty(this, CFSTR("DeviceUsagePairs"), v3, 1);
    CFRelease(v3);
  }
}

void MTTrackpadHIDManager::appendDeviceUsagePairs(MTTrackpadHIDManager *this, __CFArray *a2, int a3)
{
  const __CFAllocator *v4;
  __CFDictionary *Mutable;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  BOOL v9;
  int v11;
  int valuePtr;

  v11 = a3;
  valuePtr = (int)a2;
  if (this)
  {
    v4 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    v6 = CFNumberCreate(v4, kCFNumberSInt32Type, &valuePtr);
    v7 = CFNumberCreate(v4, kCFNumberSInt32Type, &v11);
    v8 = v7;
    if (v6)
      v9 = v7 == 0;
    else
      v9 = 1;
    if (v9 || Mutable == 0)
    {
      if (!v6)
      {
        if (!v7)
          goto LABEL_13;
        goto LABEL_12;
      }
    }
    else
    {
      CFDictionaryAddValue(Mutable, CFSTR("DeviceUsagePage"), v6);
      CFDictionaryAddValue(Mutable, CFSTR("DeviceUsage"), v8);
      CFArrayAppendValue(this, Mutable);
    }
    CFRelease(v6);
    if (!v8)
    {
LABEL_13:
      if (Mutable)
        CFRelease(Mutable);
      return;
    }
LABEL_12:
    CFRelease(v8);
    goto LABEL_13;
  }
}

uint64_t MTTrackpadHIDManager::stop(MTTrackpadHIDManager *this)
{
  const void *v2;

  v2 = (const void *)*((_QWORD *)this + 43);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 43) = 0;
  }
  MTTrackpadHIDManager::unregisterForPowerNotifications((io_object_t *)this);
  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 816))(this);
  return MTSimpleHIDManager::stop(this);
}

uint64_t MTTrackpadHIDManager::unregisterForPowerNotifications(io_object_t *this)
{
  uint64_t result;
  IONotificationPort *v3;

  result = MTSimpleHIDManager::getHIDDispatchQueue((MTSimpleHIDManager *)this);
  if (result)
  {
    if (this[76])
    {
      IODeregisterForSystemPower(this + 76);
      this[76] = 0;
    }
    v3 = (IONotificationPort *)*((_QWORD *)this + 37);
    if (v3)
    {
      IONotificationPortDestroy(v3);
      *((_QWORD *)this + 37) = 0;
    }
    result = this[72];
    if ((_DWORD)result)
    {
      result = IOServiceClose(result);
      this[72] = 0;
    }
  }
  return result;
}

uint64_t MTTrackpadHIDManager::dispatchRelativePointerEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1);
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)result + 152))(result, a3, a4, a5, a6, 1);
  return result;
}

uint64_t MTTrackpadHIDManager::forwardRelativePointerData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a6 + 616))(a6, a1, a2, a3, a4, a5);
}

uint64_t MTTrackpadHIDManager::registerDeviceDataCallbacks(MTTrackpadHIDManager *this)
{
  MTSimpleHIDManager::registerDeviceDataCallbacks(this);
  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
  MTRegisterRelativePointerCallback();
  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
  return MTRegisterButtonStateCallback();
}

uint64_t MTTrackpadHIDManager::forwardButtonState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a4 + 760))(a4, a1, a2, a3);
}

uint64_t MTTrackpadHIDManager::unregisterDeviceDataCallbacks(MTTrackpadHIDManager *this)
{
  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
  MTUnregisterButtonStateCallback();
  return MTSimpleHIDManager::unregisterDeviceDataCallbacks(this);
}

unsigned int *MTTrackpadHIDManager::createEventDispatcher(MTTrackpadHIDManager *this)
{
  const void *v2;
  unsigned int *Dispatcher;

  v2 = (const void *)(*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
  Dispatcher = (unsigned int *)MTTrackpadEventDispatcher::createDispatcher(this, v2);
  (*(void (**)(MTTrackpadHIDManager *, unsigned int *))(*(_QWORD *)this + 128))(this, Dispatcher);
  return MTSimpleEventDispatcher::release(Dispatcher);
}

uint64_t MTTrackpadHIDManager::createGestureParser(MTTrackpadHIDManager *this)
{
  uint64_t v2;
  uint64_t result;

  v2 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
  result = MTParser::createParserForMTDevice(v2, *((_DWORD *)this + 39), *((_DWORD *)this + 40));
  *((_QWORD *)this + 42) = result;
  return result;
}

uint64_t MTTrackpadHIDManager::initializeGestureParser(MTTrackpadHIDManager *this)
{
  *((_BYTE *)this + 208) = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 648))(this);
  return (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 672))(this);
}

unsigned int *MTTrackpadHIDManager::destroyGestureParser(unsigned int **this)
{
  unsigned int *result;

  MTTrackpadHIDManager::cancelOutstandingTapAndAHalfCallbackTimer((MTTrackpadHIDManager *)this);
  (*((void (**)(unsigned int **))*this + 10))(this);
  MTDeviceSetPickButtonShouldSendSecondaryClick();
  result = this[42];
  if (result)
  {
    result = MTParser::release(result);
    this[42] = 0;
  }
  return result;
}

void MTTrackpadHIDManager::cancelOutstandingTapAndAHalfCallbackTimer(MTTrackpadHIDManager *this)
{
  NSObject *v1;
  void *context;

  v1 = *((_QWORD *)this + 35);
  if (v1)
  {
    context = dispatch_get_context(*((dispatch_object_t *)this + 35));
    if (context)
    {
      free(context);
      v1 = *((_QWORD *)this + 35);
    }
    dispatch_source_cancel(v1);
    dispatch_release(*((dispatch_object_t *)this + 35));
    *((_QWORD *)this + 35) = 0;
  }
}

uint64_t MTTrackpadHIDManager::getGestureParser(MTTrackpadHIDManager *this)
{
  return *((_QWORD *)this + 42);
}

__n128 MTTrackpadHIDManager::copyTipOffsetParameters@<Q0>(MTTrackpadHIDManager *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  __int128 v3;
  __n128 result;
  __int128 v5;

  v2 = *(_QWORD *)(*((_QWORD *)this + 42) + 64);
  v3 = *(_OWORD *)(v2 + 196);
  *(_OWORD *)a2 = *(_OWORD *)(v2 + 180);
  *(_OWORD *)(a2 + 16) = v3;
  result = *(__n128 *)(v2 + 212);
  v5 = *(_OWORD *)(v2 + 228);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v5;
  return result;
}

__n128 MTTrackpadHIDManager::setTipOffsetParameters(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  __n128 result;
  __int128 v4;
  __int128 v5;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 336) + 64);
  result = *(__n128 *)a2;
  v4 = *(_OWORD *)(a2 + 16);
  v5 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v2 + 228) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v2 + 212) = v5;
  *(_OWORD *)(v2 + 196) = v4;
  *(__n128 *)(v2 + 180) = result;
  return result;
}

MTParser *MTTrackpadHIDManager::resetGestureParser(MTTrackpadHIDManager *this, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  _QWORD *v9;
  MTParser *result;
  CFTypeRef v11;
  CFTypeRef cf;

  if (a2)
  {
    v11 = 0;
    cf = 0;
    v5 = *((_QWORD *)this + 42);
    if (v5)
    {
      v7 = (**(uint64_t (***)(uint64_t))(v5 + 80))(v5 + 80);
      v8 = *((_QWORD *)this + 42);
      if (v7)
        *(_BYTE *)(v8 + 89) = 1;
      MTParser::clear((_QWORD *)v8, (uint64_t)&cf, (uint64_t *)&v11, v6);
      if (cf)
      {
        (*(void (**)(MTTrackpadHIDManager *, CFTypeRef, _QWORD))(*(_QWORD *)this + 136))(this, cf, 0);
        CFRelease(cf);
      }
      if (v11)
      {
        (*(void (**)(MTTrackpadHIDManager *, CFTypeRef, _QWORD))(*(_QWORD *)this + 136))(this, v11, 0);
        CFRelease(v11);
      }
    }
  }
  else
  {
    v9 = (_QWORD *)*((_QWORD *)this + 42);
    if (v9)
      MTParser::clear(v9, 0, 0, a4);
  }
  result = (MTParser *)*((_QWORD *)this + 42);
  if (result)
  {
    if ((*((_BYTE *)this + 160) & 2) != 0)
      return (MTParser *)MTParser::setDivingButtonState(result, 0);
  }
  return result;
}

uint64_t MTTrackpadHIDManager::cancelCurrentTapAndAHalfDrag(MTTrackpadHIDManager *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 42);
  if (result)
  {
    result = (**(uint64_t (***)(uint64_t))(result + 80))(result + 80);
    if ((_DWORD)result)
      *(_BYTE *)(*((_QWORD *)this + 42) + 89) = 1;
  }
  return result;
}

uint64_t MTTrackpadHIDManager::startNotificationCenterMonitoring(dispatch_object_t *this, int a2)
{
  NSObject *HIDDispatchQueue;
  dispatch_source_t v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t result;
  MTParser *v10;
  _QWORD v11[5];
  _QWORD handler[5];

  ((void (*)(dispatch_object_t *))(*this)[102].isa)(this);
  HIDDispatchQueue = MTSimpleHIDManager::getHIDDispatchQueue((MTSimpleHIDManager *)this);
  v5 = dispatch_source_create(MEMORY[0x24BDAC9F8], a2, 0x80000000uLL, HIDDispatchQueue);
  this[39] = v5;
  if (v5)
  {
    MTSimpleHIDManager::retain((uint64_t)this);
    v6 = MEMORY[0x24BDAC760];
    v7 = this[39];
    handler[0] = MEMORY[0x24BDAC760];
    handler[1] = 0x40000000;
    handler[2] = ___ZN20MTTrackpadHIDManager33startNotificationCenterMonitoringEi_block_invoke;
    handler[3] = &__block_descriptor_tmp_1;
    handler[4] = this;
    dispatch_source_set_event_handler(v7, handler);
    v8 = this[39];
    v11[0] = v6;
    v11[1] = 0x40000000;
    v11[2] = ___ZN20MTTrackpadHIDManager33startNotificationCenterMonitoringEi_block_invoke_4;
    v11[3] = &__block_descriptor_tmp_5;
    v11[4] = this;
    dispatch_source_set_cancel_handler(v8, v11);
    dispatch_resume(this[39]);
  }
  result = ((uint64_t (*)(dispatch_object_t *))(*this)[108].isa)(this);
  if (result)
  {
    v10 = (MTParser *)((uint64_t (*)(dispatch_object_t *))(*this)[108].isa)(this);
    return MTParser::alwaysGenerateNotificationCenterGestures(v10, *((unsigned __int8 *)this + 242));
  }
  return result;
}

uint64_t ___ZN20MTTrackpadHIDManager33startNotificationCenterMonitoringEi_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  int v4;
  const char *v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 32);
  v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 136315650;
    v5 = "";
    v6 = 2080;
    v7 = "MTTrackpadHIDManager::";
    v8 = 2080;
    v9 = "startNotificationCenterMonitoring_block_invoke";
    _os_log_impl(&dword_231071000, v2, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s NotificationCenter process died.", (uint8_t *)&v4, 0x20u);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 800))(v1);
}

uint64_t MTTrackpadHIDManager::startNotificationCenterAltMonitoring(dispatch_object_t *this, int a2)
{
  NSObject *HIDDispatchQueue;
  dispatch_source_t v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t result;
  MTParser *v10;
  _QWORD v11[5];
  _QWORD handler[5];

  ((void (*)(dispatch_object_t *))(*this)[103].isa)(this);
  HIDDispatchQueue = MTSimpleHIDManager::getHIDDispatchQueue((MTSimpleHIDManager *)this);
  v5 = dispatch_source_create(MEMORY[0x24BDAC9F8], a2, 0x80000000uLL, HIDDispatchQueue);
  this[40] = v5;
  if (v5)
  {
    MTSimpleHIDManager::retain((uint64_t)this);
    v6 = MEMORY[0x24BDAC760];
    v7 = this[40];
    handler[0] = MEMORY[0x24BDAC760];
    handler[1] = 0x40000000;
    handler[2] = ___ZN20MTTrackpadHIDManager36startNotificationCenterAltMonitoringEi_block_invoke;
    handler[3] = &__block_descriptor_tmp_6;
    handler[4] = this;
    dispatch_source_set_event_handler(v7, handler);
    v8 = this[40];
    v11[0] = v6;
    v11[1] = 0x40000000;
    v11[2] = ___ZN20MTTrackpadHIDManager36startNotificationCenterAltMonitoringEi_block_invoke_7;
    v11[3] = &__block_descriptor_tmp_8;
    v11[4] = this;
    dispatch_source_set_cancel_handler(v8, v11);
    dispatch_resume(this[40]);
  }
  result = ((uint64_t (*)(dispatch_object_t *))(*this)[108].isa)(this);
  if (result)
  {
    v10 = (MTParser *)((uint64_t (*)(dispatch_object_t *))(*this)[108].isa)(this);
    return MTParser::alwaysGenerateNotificationCenterAltGestures(v10, *((unsigned __int8 *)this + 242));
  }
  return result;
}

uint64_t ___ZN20MTTrackpadHIDManager36startNotificationCenterAltMonitoringEi_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  int v4;
  const char *v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 32);
  v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 136315650;
    v5 = "";
    v6 = 2080;
    v7 = "MTTrackpadHIDManager::";
    v8 = 2080;
    v9 = "startNotificationCenterAltMonitoring_block_invoke";
    _os_log_impl(&dword_231071000, v2, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s NotificationCenterAlt process died.", (uint8_t *)&v4, 0x20u);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 808))(v1);
}

uint64_t MTTrackpadHIDManager::stopNotificationCenterMonitoring(MTTrackpadHIDManager *this)
{
  uint64_t result;
  MTParser *v3;

  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 816))(this);
  result = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 864))(this);
  if (result)
  {
    v3 = (MTParser *)(*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 864))(this);
    return MTParser::alwaysGenerateNotificationCenterGestures(v3, 0);
  }
  return result;
}

uint64_t MTTrackpadHIDManager::stopNotificationCenterAltMonitoring(MTTrackpadHIDManager *this)
{
  uint64_t result;
  MTParser *v3;

  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 824))(this);
  result = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 864))(this);
  if (result)
  {
    v3 = (MTParser *)(*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 864))(this);
    return MTParser::alwaysGenerateNotificationCenterGestures(v3, 0);
  }
  return result;
}

void MTTrackpadHIDManager::cancelNotificationCenterSource(MTTrackpadHIDManager *this)
{
  NSObject *v2;

  v2 = *((_QWORD *)this + 39);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 39));
    *((_QWORD *)this + 39) = 0;
  }
}

void MTTrackpadHIDManager::cancelNotificationCenterAltSource(MTTrackpadHIDManager *this)
{
  NSObject *v2;

  v2 = *((_QWORD *)this + 40);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 40));
    *((_QWORD *)this + 40) = 0;
  }
}

uint64_t MTTrackpadHIDManager::getForceSourceForBehavior(MTTrackpadHIDManager *this, unsigned int a2)
{
  uint64_t v3;

  v3 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this);
  if (a2 > 0x11)
    return 0;
  if (((1 << a2) & 0x31C22) != 0)
    return 34;
  if (a2 != 2)
    return 0;
  if (*(_BYTE *)(v3 + 6))
    return 134;
  return 0;
}

uint64_t MTTrackpadHIDManager::getUserPrefs(uint64_t a1, _QWORD *a2)
{
  *a2 = &MTTrackpadHIDManager::getUserPrefs(mt_UserPreference const**)::prefs;
  return 32;
}

unint64_t MTTrackpadHIDManager::isUserPref(MTTrackpadHIDManager *this, const __CFString *a2, BOOL *a3)
{
  unint64_t result;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  CFComparisonResult v9;
  CFStringRef *v10;

  if (a3)
    *a3 = 0;
  if (!a2)
    return 0;
  v10 = 0;
  result = (*(uint64_t (**)(MTTrackpadHIDManager *, CFStringRef **))(*(_QWORD *)this + 840))(this, &v10);
  if (!result)
    return result;
  v6 = result;
  v7 = 0;
  if (CFStringCompare(a2, *v10, 0))
  {
    v8 = 2;
    while (v6 - 1 != v7)
    {
      v9 = CFStringCompare(a2, v10[v8], 0);
      v8 += 2;
      ++v7;
      if (v9 == kCFCompareEqualTo)
      {
        result = v6 > v7;
        if (a3)
          goto LABEL_13;
        return result;
      }
    }
    return 0;
  }
  result = 1;
  if (a3)
LABEL_13:
    *a3 = (BOOL)v10[2 * v7 + 1];
  return result;
}

BOOL MTTrackpadHIDManager::shouldRecordProperty(MTTrackpadHIDManager *this, const __CFString *a2)
{
  const __CFString *v3;

  return (MTTrackpadHIDManager::isUserPref(this, a2, 0) & 1) != 0
      || MTSimpleHIDManager::propertyTypeFromString((uint64_t)a2, v3) == 17;
}

uint64_t MTTrackpadHIDManager::setProperty(CFTypeRef *this, const __CFString *a2, const void *a3)
{
  io_registry_entry_t Service;
  kern_return_t v7;
  kern_return_t v8;
  NSObject *v9;
  BOOL v11;
  uint8_t buf[4];
  kern_return_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v11 = 0;
  if (MTTrackpadHIDManager::isUserPref((MTTrackpadHIDManager *)this, a2, &v11))
  {
    (*((void (**)(CFTypeRef *, const __CFString *, const void *))*this + 85))(this, a2, a3);
    (*((void (**)(CFTypeRef *))*this + 84))(this);
    if (v11)
    {
      (*((void (**)(CFTypeRef *))*this + 10))(this);
      Service = MTDeviceGetService();
      v7 = IORegistryEntrySetCFProperty(Service, CFSTR("TrackpadUserPreferences"), this[43]);
      if (v7)
      {
        v8 = v7;
        (*((void (**)(CFTypeRef *))*this + 10))(this);
        MTDeviceGetDeviceID();
        v9 = MTLoggingPlugin();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109376;
          v13 = v8;
          v14 = 2048;
          v15 = 0;
          _os_log_impl(&dword_231071000, v9, OS_LOG_TYPE_ERROR, "Could not set trackpad user preferences on the driver 0x%08X (deviceID 0x%llX)", buf, 0x12u);
        }
      }
    }
  }
  return MTSimpleHIDManager::setProperty((CFDateFormatterRef *)this, a2, a3);
}

uint64_t MTTrackpadHIDManager::setPropertyInternal(MTSimpleHIDManager *a1, int a2, CFTypeRef cf, int a4)
{
  CFTypeID v8;
  _BOOL4 v9;
  NSObject *HIDDispatchQueue;
  const void *Value;
  const __CFNumber *v12;
  const __CFNumber *v13;
  CFTypeID v14;
  BOOL v15;
  CFTypeID v16;
  _QWORD *v17;
  CFTypeID v18;
  CFDictionaryRef *v19;
  int v20;
  int v21;
  _BOOL4 v22;
  _BOOL4 v23;
  _BOOL4 v24;
  const void *v25;
  const void *v26;
  const void *v27;
  CFTypeID v28;
  CFTypeID v30;
  uint64_t result;
  int v32;
  CFTypeID v33;
  uint64_t v34;
  const __CFNumber *v35;
  const __CFNumber *v36;
  CFTypeID v37;
  const __CFArray *v38;
  const __CFArray *v39;
  CFTypeID v40;
  CFIndex Count;
  CFIndex v42;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v44;
  CFTypeID v45;
  const __CFNumber *v46;
  const __CFNumber *v47;
  CFTypeID v48;
  const void *v49;
  unsigned int Behavior;
  uint64_t v51;
  int v52;
  __int128 v53;
  uint64_t v54;
  CFTypeID v55;
  CFTypeID v56;
  CFTypeID v57;
  MTTrackpadEventDispatcher *v58;
  uint64_t v59;
  char v60;
  MTForceManagement *v61;
  char v62;
  CFTypeID v63;
  NSObject *v64;
  int v65;
  float v66;
  _QWORD block[5];
  _QWORD v68[5];
  int v69;
  _QWORD v70[5];
  _QWORD v71[5];
  int v72;
  _BYTE valuePtr[32];
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  uint64_t v81;

  v81 = *MEMORY[0x24BDAC8D0];
  if (cf)
  {
    v8 = CFGetTypeID(cf);
    v9 = v8 == CFDictionaryGetTypeID();
  }
  else
  {
    v9 = 0;
  }
  HIDDispatchQueue = MTSimpleHIDManager::getHIDDispatchQueue(a1);
  switch(a2)
  {
    case 22:
      if (!v9)
        return MTSimpleHIDManager::setPropertyInternal((uint64_t *)a1, a2, cf, a4);
      Value = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("AlwaysGenerateNotificationCenterGesture"));
      v12 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("ClientPID"));
      if (!Value)
        return MTSimpleHIDManager::setPropertyInternal((uint64_t *)a1, a2, cf, a4);
      v13 = v12;
      v14 = CFGetTypeID(Value);
      if (v14 == CFBooleanGetTypeID()
        && (Value == (const void *)*MEMORY[0x24BDBD270] ? (v15 = v13 == 0) : (v15 = 1),
            !v15 && (v16 = CFGetTypeID(v13), v16 == CFNumberGetTypeID())))
      {
        *(_DWORD *)valuePtr = -1431655766;
        CFNumberGetValue(v13, kCFNumberSInt32Type, valuePtr);
        if (!HIDDispatchQueue)
          return 0;
        MTSimpleHIDManager::retain((uint64_t)a1);
        v71[0] = MEMORY[0x24BDAC760];
        v71[1] = 0x40000000;
        v71[2] = ___ZN20MTTrackpadHIDManager19setPropertyInternalE18_MTHIDPropertyTypePKvb_block_invoke;
        v71[3] = &__block_descriptor_tmp_79;
        v71[4] = a1;
        v72 = *(_DWORD *)valuePtr;
        v17 = v71;
      }
      else
      {
        v55 = CFGetTypeID(Value);
        if (v55 != CFBooleanGetTypeID() || Value != (const void *)*MEMORY[0x24BDBD268])
          return MTSimpleHIDManager::setPropertyInternal((uint64_t *)a1, a2, cf, a4);
        if (!HIDDispatchQueue)
          return 0;
        MTSimpleHIDManager::retain((uint64_t)a1);
        v70[0] = MEMORY[0x24BDAC760];
        v70[1] = 0x40000000;
        v70[2] = ___ZN20MTTrackpadHIDManager19setPropertyInternalE18_MTHIDPropertyTypePKvb_block_invoke_2;
        v70[3] = &__block_descriptor_tmp_80;
        v70[4] = a1;
        v17 = v70;
      }
      goto LABEL_89;
    case 23:
      if (!v9)
        return MTSimpleHIDManager::setPropertyInternal((uint64_t *)a1, a2, cf, a4);
      v25 = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("AlwaysGenerateNotificationCenterAltGesture"));
      v26 = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("ClientPID"));
      if (!v25)
        return MTSimpleHIDManager::setPropertyInternal((uint64_t *)a1, a2, cf, a4);
      v27 = v26;
      v28 = CFGetTypeID(v25);
      if (v28 == CFBooleanGetTypeID() && v25 == (const void *)*MEMORY[0x24BDBD270] && v27 != 0)
      {
        v30 = CFGetTypeID(v27);
        if (v30 == CFNumberGetTypeID())
        {
          *(_DWORD *)valuePtr = -1431655766;
          CFNumberGetValue((CFNumberRef)v27, kCFNumberSInt32Type, valuePtr);
          if (!HIDDispatchQueue)
            return 0;
          MTSimpleHIDManager::retain((uint64_t)a1);
          v68[0] = MEMORY[0x24BDAC760];
          v68[1] = 0x40000000;
          v68[2] = ___ZN20MTTrackpadHIDManager19setPropertyInternalE18_MTHIDPropertyTypePKvb_block_invoke_3;
          v68[3] = &__block_descriptor_tmp_83;
          v68[4] = a1;
          v69 = *(_DWORD *)valuePtr;
          v17 = v68;
LABEL_89:
          dispatch_async(HIDDispatchQueue, v17);
          return 0;
        }
      }
      v56 = CFGetTypeID(v25);
      if (v56 == CFBooleanGetTypeID() && v25 == (const void *)*MEMORY[0x24BDBD268])
      {
        if (!HIDDispatchQueue)
          return 0;
        MTSimpleHIDManager::retain((uint64_t)a1);
        block[0] = MEMORY[0x24BDAC760];
        block[1] = 0x40000000;
        block[2] = ___ZN20MTTrackpadHIDManager19setPropertyInternalE18_MTHIDPropertyTypePKvb_block_invoke_4;
        block[3] = &__block_descriptor_tmp_84;
        block[4] = a1;
        v17 = block;
        goto LABEL_89;
      }
      return MTSimpleHIDManager::setPropertyInternal((uint64_t *)a1, a2, cf, a4);
    case 27:
      if (cf)
      {
        v18 = CFGetTypeID(cf);
        *(_DWORD *)valuePtr = 0;
        if (v18 == CFNumberGetTypeID())
        {
          if ((*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 864))(a1))
          {
            if (CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, valuePtr))
            {
              v19 = *(CFDictionaryRef **)((*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 864))(a1)
                                        + 208);
              if (v19)
              {
                v20 = *(_DWORD *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 848))(a1) + 60);
                v21 = *(unsigned __int8 *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 848))(a1)
                                         + 64);
                if (*(_QWORD *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 864))(a1) + 48))
                {
                  v22 = v21 != 0;
                  v23 = v20 == 0;
                  v24 = !*(_BYTE *)(*(_QWORD *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 864))(a1)
                                              + 48)
                                  + 186)
                     || v23;
                  if (!v22 && !v24)
                    MTActuatorManagement::actuateWaveformID(v19, *(int *)valuePtr, 1.0, 1.0);
                }
              }
            }
          }
        }
      }
      return 0;
    case 30:
      result = *(_QWORD *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 864))(a1) + 208);
      if (!result)
        return result;
      MTActuatorManagement::reloadActuations((MTActuatorManagement *)result);
      return 0;
    default:
      if ((a2 & 0xFFFFFFFE) != 0x1C)
      {
        switch(a2)
        {
          case 31:
            (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 80))(a1);
            result = MTDeviceSupportsForce();
            if (!(_DWORD)result)
              return result;
            v54 = *(_QWORD *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 864))(a1) + 200);
            *(_BYTE *)(v54 + 216) = CFBooleanGetValue((CFBooleanRef)cf) != 0;
            return 1;
          case 32:
            (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 80))(a1);
            result = MTDeviceSupportsForce();
            if (!(_DWORD)result)
              return result;
            v61 = *(MTForceManagement **)((*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 864))(a1)
                                        + 200);
            v62 = CFBooleanGetValue((CFBooleanRef)cf) != 0;
            MTForceManagement::setDisableClickWaveformAdaptation(v61, v62);
            return 1;
          case 33:
            (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 80))(a1);
            result = MTDeviceSupportsForce();
            if (!(_DWORD)result)
              return result;
            v59 = *(_QWORD *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 864))(a1) + 200);
            v60 = CFBooleanGetValue((CFBooleanRef)cf) != 0;
            MTForceManagement::setDisableForceThresholdAdaptation(v59, v60);
            return 1;
          case 34:
            if (cf)
            {
              v63 = CFGetTypeID(cf);
              if (v63 == CFBooleanGetTypeID())
              {
                *((_BYTE *)a1 + 209) = *MEMORY[0x24BDBD270] == (_QWORD)cf;
                (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 672))(a1);
              }
            }
            return 0;
          default:
            if (a2 != 17)
              return MTSimpleHIDManager::setPropertyInternal((uint64_t *)a1, a2, cf, a4);
            if (cf)
            {
              v57 = CFGetTypeID(cf);
              v66 = 0.0;
              if (v57 == CFNumberGetTypeID()
                && CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, &v66)
                && (*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 120))(a1))
              {
                v58 = (MTTrackpadEventDispatcher *)(*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 120))(a1);
                MTTrackpadEventDispatcher::setScrollMomentumDispatchRate(v58, v66);
                return 1;
              }
            }
            else
            {
              v66 = 0.0;
            }
            v64 = MTLoggingPlugin();
            result = os_log_type_enabled(v64, OS_LOG_TYPE_ERROR);
            if (!(_DWORD)result)
              return result;
            *(_DWORD *)valuePtr = 136315650;
            *(_QWORD *)&valuePtr[4] = "[Error] ";
            *(_WORD *)&valuePtr[12] = 2080;
            *(_QWORD *)&valuePtr[14] = "MTTrackpadHIDManager::";
            *(_WORD *)&valuePtr[22] = 2080;
            *(_QWORD *)&valuePtr[24] = "setPropertyInternal";
            _os_log_impl(&dword_231071000, v64, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Could not perform set property on Scroll Momentum Dispatch Rate", valuePtr, 0x20u);
            break;
        }
        return 0;
      }
      (*(void (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 80))(a1);
      v32 = MTDeviceSupportsForce();
      result = 0;
      if (cf)
      {
        if (v32)
        {
          result = (*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 864))(a1);
          if (result)
          {
            if (!*(_BYTE *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 848))(a1) + 64))
            {
              v33 = CFGetTypeID(cf);
              if (v33 == CFDictionaryGetTypeID())
              {
                v34 = *(_QWORD *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 864))(a1) + 200);
                v66 = 0.0;
                v35 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("Version"));
                if (v35)
                {
                  v36 = v35;
                  v37 = CFGetTypeID(v35);
                  if (v37 == CFNumberGetTypeID())
                  {
                    if (CFNumberGetValue(v36, kCFNumberSInt32Type, &v66))
                    {
                      if (LODWORD(v66) == 1)
                      {
                        v38 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("Behaviors"));
                        v39 = v38;
                        if (v38)
                        {
                          v40 = CFGetTypeID(v38);
                          if (v40 == CFArrayGetTypeID())
                          {
                            Count = CFArrayGetCount(v39);
                            if (a2 == 28)
                              MTForceBehaviorConfiguration::clearNonDefaultBehaviors((MTForceBehaviorConfiguration *)(v34 + 264));
                            if (Count >= 1)
                            {
                              v42 = 0;
                              while (1)
                              {
                                ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v39, v42);
                                v44 = ValueAtIndex;
                                if (!ValueAtIndex)
                                  goto LABEL_68;
                                v45 = CFGetTypeID(ValueAtIndex);
                                if (v45 != CFDictionaryGetTypeID())
                                  goto LABEL_68;
                                v46 = (const __CFNumber *)CFDictionaryGetValue(v44, CFSTR("BehaviorID"));
                                v47 = v46;
                                v65 = -1431655766;
                                if (!v46)
                                  goto LABEL_68;
                                v48 = CFGetTypeID(v46);
                                if (v48 != CFNumberGetTypeID() || !CFNumberGetValue(v47, kCFNumberSInt32Type, &v65))
                                  goto LABEL_68;
                                v49 = (const void *)MTForceConfigCreate(v65, 0);
                                Behavior = MTForceConfigGetBehavior((uint64_t)v49);
                                v51 = (*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)a1 + 848))(a1);
                                if (Behavior > 0x11)
                                  goto LABEL_76;
                                if (((1 << Behavior) & 0x31C22) == 0)
                                  break;
                                v52 = 34;
                                if (v49)
                                  goto LABEL_62;
LABEL_68:
                                if (Count == ++v42)
                                  return 0;
                              }
                              if (Behavior == 2)
                              {
                                if (*(_BYTE *)(v51 + 6))
                                  v52 = 134;
                                else
                                  v52 = 0;
                                if (!v49)
                                  goto LABEL_68;
LABEL_62:
                                if (v52)
                                {
                                  *(_QWORD *)&v53 = 0xAAAAAAAAAAAAAAAALL;
                                  *((_QWORD *)&v53 + 1) = 0xAAAAAAAAAAAAAAAALL;
                                  v79 = v53;
                                  v80 = v53;
                                  v77 = v53;
                                  v78 = v53;
                                  v75 = v53;
                                  v76 = v53;
                                  *(_OWORD *)&valuePtr[16] = v53;
                                  v74 = v53;
                                  *(_OWORD *)valuePtr = v53;
                                  forceBehaviorFromForceConfig((uint64_t)v49, v52, (uint64_t)valuePtr);
                                  if (a2 == 28)
                                    MTForceBehaviorConfiguration::pushBehavior((MTForceBehaviorConfiguration *)(v34 + 264), (const MTForceBehavior *)valuePtr);
                                  else
                                    MTForceManagement::setOverrideBehavior((MTForceManagement *)v34, (const MTForceBehavior *)valuePtr);
                                  MTForceBehavior::~MTForceBehavior((MTForceBehavior *)valuePtr);
                                }
                              }
                              else
                              {
LABEL_76:
                                if (!v49)
                                  goto LABEL_68;
                              }
                              CFRelease(v49);
                              goto LABEL_68;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            return 0;
          }
        }
      }
      return result;
  }
}

void sub_23109E840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  MTForceBehavior::~MTForceBehavior((MTForceBehavior *)&a33);
  _Unwind_Resume(a1);
}

void forceBehaviorFromForceConfig(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  int Behavior;
  int NumStages;
  __int128 v8;
  int i;
  float ThresholdsForStage;
  float v11;
  float v12;
  uint64_t ActuationsForStage;

  Behavior = MTForceConfigGetBehavior(a1);
  NumStages = MTForceConfigGetNumStages(a1);
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)a3 = v8;
  *(_OWORD *)(a3 + 16) = v8;
  *(_OWORD *)(a3 + 32) = v8;
  *(_OWORD *)(a3 + 48) = v8;
  *(_OWORD *)(a3 + 64) = v8;
  *(_OWORD *)(a3 + 80) = v8;
  *(_OWORD *)(a3 + 96) = v8;
  *(_OWORD *)(a3 + 112) = v8;
  *(_OWORD *)(a3 + 128) = v8;
  MTForceBehavior::MTForceBehavior((MTForceBehavior *)a3);
  *(_BYTE *)(a3 + 12) = MTForceConfigIsContinuous(a1);
  *(_DWORD *)a3 = Behavior;
  *(_DWORD *)(a3 + 4) = a2;
  if (NumStages)
  {
    for (i = 0; i != NumStages; ++i)
    {
      ThresholdsForStage = MTForceConfigGetThresholdsForStage(a1, i);
      v12 = v11;
      ActuationsForStage = MTForceConfigGetActuationsForStage(a1, i);
      MTForceBehavior::addStage((MTForceBehavior *)a3, i, ActuationsForStage, ThresholdsForStage, v12);
      if (MTForceConfigShouldSkipActivationForStage(a1, i))
        MTForceBehavior::addSkippedActivationStage((_QWORD *)a3, i);
      if (MTForceConfigShouldSkipReleaseForStage(a1, i))
        MTForceBehavior::addSkippedReleaseStage((_QWORD *)a3, i);
    }
  }
}

void sub_23109EA2C(_Unwind_Exception *a1)
{
  MTForceBehavior *v1;

  MTForceBehavior::~MTForceBehavior(v1);
  _Unwind_Resume(a1);
}

void MTForceBehavior::~MTForceBehavior(MTForceBehavior *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v2 = (void *)*((_QWORD *)this + 15);
  if (v2)
  {
    *((_QWORD *)this + 16) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 12);
  if (v3)
  {
    *((_QWORD *)this + 13) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 9);
  if (v4)
  {
    *((_QWORD *)this + 10) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 6);
  if (v5)
  {
    *((_QWORD *)this + 7) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 3);
  if (v6)
  {
    *((_QWORD *)this + 4) = v6;
    operator delete(v6);
  }
}

const char *MTTrackpadHIDManager::getName(MTTrackpadHIDManager *this)
{
  return "MTTrackpadHIDManager";
}

uint64_t MTTrackpadHIDManager::handleContactFrame(MTTrackpadHIDManager *this, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;
  double v13;
  CFTypeRef v14;
  CFTypeRef cf;

  if (*((double *)this + 18) == a2 && *((unsigned __int8 *)this + 152) == a6)
  {
    printf("%s: ignoring duplicate frame #%qu @ %f\n", "MTTrackpadHIDManager", a6, a2);
    return 0;
  }
  if (*((_BYTE *)this + 121))
    return 0;
  *((double *)this + 18) = a2;
  *((_BYTE *)this + 152) = a6;
  MTTrackpadHIDManager::cancelOutstandingTapAndAHalfCallbackTimer(this);
  v14 = 0;
  cf = 0;
  v13 = 0.0;
  kdebug_trace();
  v12 = *((_QWORD *)this + 42);
  if (v12 && !*((_BYTE *)this + 208))
    MTParser::handleContactFrame(v12, a4, a5, a2, a6, (uint64_t)&cf, (uint64_t *)&v14, &v13);
  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 656))(this);
  if (v13 > 0.0)
    MTTrackpadHIDManager::scheduleTapAndAHalfCallbackTimer((dispatch_object_t *)this, a2, v13);
  if (cf)
  {
    (*(void (**)(MTTrackpadHIDManager *, CFTypeRef, _QWORD))(*(_QWORD *)this + 136))(this, cf, 0);
    CFRelease(cf);
  }
  if (v14)
  {
    (*(void (**)(MTTrackpadHIDManager *, CFTypeRef, _QWORD))(*(_QWORD *)this + 136))(this, v14, 0);
    CFRelease(v14);
  }
  kdebug_trace();
  return 1;
}

void MTTrackpadHIDManager::scheduleTapAndAHalfCallbackTimer(dispatch_object_t *this, double a2, double a3)
{
  double *v6;
  NSObject *HIDDispatchQueue;
  dispatch_source_t v8;
  NSObject *v9;
  dispatch_time_t v10;
  NSObject *v11;
  _QWORD handler[5];

  MTTrackpadHIDManager::cancelOutstandingTapAndAHalfCallbackTimer((MTTrackpadHIDManager *)this);
  v6 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
  *v6 = a2;
  v6[1] = a3;
  *((_QWORD *)v6 + 2) = this;
  HIDDispatchQueue = MTSimpleHIDManager::getHIDDispatchQueue((MTSimpleHIDManager *)this);
  v8 = dispatch_source_create(MEMORY[0x24BDACA18], 0, 0, HIDDispatchQueue);
  this[35] = v8;
  if (v8)
  {
    v9 = v8;
    v10 = dispatch_time(0, (uint64_t)(v6[1] * 1000000000.0));
    dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_set_context(this[35], v6);
    v11 = this[35];
    handler[0] = MEMORY[0x24BDAC760];
    handler[1] = 0x40000000;
    handler[2] = ___ZN20MTTrackpadHIDManager32scheduleTapAndAHalfCallbackTimerEdd_block_invoke;
    handler[3] = &__block_descriptor_tmp_95;
    handler[4] = this;
    dispatch_source_set_event_handler(v11, handler);
    dispatch_resume(this[35]);
  }
}

uint64_t MTTrackpadHIDManager::handleInputDetectionState()
{
  return 0;
}

uint64_t MTTrackpadHIDManager::handleNotificationEvent(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  MTActuatorManagement *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  MTTrackpadEventDispatcher *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v19;
  uint64_t v20;
  MTActuatorManagement *v21;
  MTParser *v22;
  uint64_t v23;
  char v24;

  v4 = 1;
  switch(a3)
  {
    case 5:
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 264))(a1);
      v5 = *(MTActuatorManagement **)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 864))(a1) + 208);
      if (v5)
        MTActuatorManagement::reclaimHostClickControl(v5);
      goto LABEL_42;
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 14:
    case 15:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
      goto LABEL_10;
    case 12:
      goto LABEL_42;
    case 13:
      v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 648))(a1);
      if (*(unsigned __int8 *)(a1 + 208) == v8)
        goto LABEL_42;
      *(_BYTE *)(a1 + 208) = v8;
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 672))(a1);
      if (!*(_BYTE *)(a1 + 208))
        goto LABEL_42;
      goto LABEL_30;
    case 16:
      v9 = *(_QWORD *)(a1 + 336);
      if (v9)
      {
        v10 = *(_QWORD *)(v9 + 48);
        if (v10)
        {
          MTAbsoluteTimeGetCurrent();
          *(_QWORD *)(v10 + 48) = v11;
          v9 = *(_QWORD *)(a1 + 336);
        }
        if (*(int *)(v9 + 104) >= 2 && (**(unsigned int (***)(uint64_t))(v9 + 80))(v9 + 80))
          *(_BYTE *)(*(_QWORD *)(a1 + 336) + 89) = 1;
      }
      if (!(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1))
        goto LABEL_9;
      v12 = (MTTrackpadEventDispatcher *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1);
      if (!*((_QWORD *)v12 + 56))
        goto LABEL_9;
      v4 = 1;
      MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(v12, 1);
      goto LABEL_42;
    case 17:
      v13 = *(_QWORD *)(a1 + 336);
      if (!v13)
        goto LABEL_42;
      v14 = *(_QWORD *)(v13 + 48);
      if (v14)
      {
        MTAbsoluteTimeGetCurrent();
        *(_QWORD *)(v14 + 48) = v15;
      }
      goto LABEL_9;
    case 18:
      goto LABEL_7;
    case 19:
      goto LABEL_6;
    case 26:
      v16 = *(unsigned __int8 *)(a1 + 121);
      v4 = MTSimpleHIDManager::handleNotificationEvent((unsigned __int8 *)a1, a2, 26);
      v17 = *(unsigned __int8 *)(a1 + 121);
      if (v17 != v16 && v17 != 0)
      {
LABEL_30:
        v19 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1);
        if (v19)
          (*(void (**)(uint64_t))(*(_QWORD *)v19 + 184))(v19);
      }
      goto LABEL_42;
    case 27:
      v20 = *(_QWORD *)(a1 + 336);
      if (v20)
      {
        v21 = *(MTActuatorManagement **)(v20 + 208);
        if (v21)
          MTActuatorManagement::systemActuationsEnabledChanged(v21);
      }
      goto LABEL_42;
    case 28:
      v22 = *(MTParser **)(a1 + 336);
      if (v22)
        MTParser::systemForceResponseEnabledChanged(v22);
      goto LABEL_42;
    case 29:
      v23 = *(_QWORD *)(a1 + 336);
      if (!v23)
        goto LABEL_42;
      v24 = 1;
      goto LABEL_41;
    case 30:
      v23 = *(_QWORD *)(a1 + 336);
      if (!v23)
        goto LABEL_42;
      v24 = 0;
LABEL_41:
      MTParser::setHostClickControlEnabled(v23, v24);
      goto LABEL_42;
    default:
      if (a3 == 118)
      {
LABEL_7:
        *(_DWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 848))(a1) + 40) = 0;
      }
      else
      {
        if (a3 != 119)
        {
LABEL_10:
          v4 = MTSimpleHIDManager::handleNotificationEvent((unsigned __int8 *)a1, a2, a3);
          goto LABEL_42;
        }
LABEL_6:
        *(_DWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 848))(a1) + 40) = 2;
      }
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 712))(a1);
      v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 80))(a1);
      v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 848))(a1);
      SaveSurfaceOrientationForDevice(v6, *(_DWORD *)(v7 + 40), 0);
LABEL_9:
      v4 = 1;
LABEL_42:
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 656))(a1);
      return v4;
  }
}

void SaveSurfaceOrientationForDevice(uint64_t a1, int a2, int a3)
{
  const __CFAllocator *v5;
  CFNumberRef v6;
  const void *SavedNameForDevice;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  CFMutableDictionaryRef MutableCopy;
  BOOL v11;
  BOOL v12;
  CFTypeID v14;
  int valuePtr;

  if (!a1)
    return;
  IOHIDPreferencesSynchronize();
  valuePtr = a2;
  v5 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberSInt32Type, &valuePtr);
  SavedNameForDevice = (const void *)mt_CreateSavedNameForDevice();
  v8 = (const __CFDictionary *)IOHIDPreferencesCopy();
  if (v8)
  {
    v9 = v8;
    MutableCopy = CFDictionaryCreateMutableCopy(v5, 0, v8);
    CFRelease(v9);
LABEL_7:
    v11 = v6 != 0;
    if (v6)
      v12 = SavedNameForDevice == 0;
    else
      v12 = 1;
    if (!v12 && MutableCopy != 0)
    {
      v14 = CFGetTypeID(MutableCopy);
      if (v14 == CFDictionaryGetTypeID())
      {
        if (a3)
          CFDictionaryRemoveValue(MutableCopy, SavedNameForDevice);
        else
          CFDictionarySetValue(MutableCopy, SavedNameForDevice, v6);
        IOHIDPreferencesSet();
        IOHIDPreferencesSynchronize();
      }
      CFRelease(MutableCopy);
      CFRelease(SavedNameForDevice);
LABEL_27:
      CFRelease(v6);
      return;
    }
    if (MutableCopy)
      CFRelease(MutableCopy);
    goto LABEL_17;
  }
  if (!a3)
  {
    MutableCopy = CFDictionaryCreateMutable(v5, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    goto LABEL_7;
  }
  v11 = v6 != 0;
LABEL_17:
  if (SavedNameForDevice)
    CFRelease(SavedNameForDevice);
  if (v11)
    goto LABEL_27;
}

void MTTrackpadHIDManager::wasScheduledOnDispatchQueue(MTInputDeviceManagement **this, NSObject *a2)
{
  MTActuatorManagement *v4;
  MTInputDeviceManagement *v5;

  v4 = *(MTActuatorManagement **)((*((uint64_t (**)(MTInputDeviceManagement **))*this + 108))(this) + 208);
  if (v4)
    MTActuatorManagement::scheduleOnDispatchQueue(v4, a2);
  v5 = this[41];
  if (v5)
    MTInputDeviceManagement::scheduleOnDispatchQueue(v5, a2);
  MTSimpleHIDManager::wasScheduledOnDispatchQueue((MTSimpleHIDManager *)this, a2);
  MTTrackpadHIDManager::registerForPowerNotifications((MTTrackpadHIDManager *)this);
}

void MTTrackpadHIDManager::registerForPowerNotifications(MTTrackpadHIDManager *this)
{
  io_connect_t v2;
  IONotificationPort *v3;
  NSObject *HIDDispatchQueue;

  if (MTSimpleHIDManager::getHIDDispatchQueue(this))
  {
    v2 = IORegisterForSystemPower(this, (IONotificationPortRef *)this + 37, (IOServiceInterestCallback)MTTrackpadHIDManager::handlePowerNotification, (io_object_t *)this + 76);
    *((_DWORD *)this + 72) = v2;
    if (v2)
    {
      v3 = (IONotificationPort *)*((_QWORD *)this + 37);
      HIDDispatchQueue = MTSimpleHIDManager::getHIDDispatchQueue(this);
      IONotificationPortSetDispatchQueue(v3, HIDDispatchQueue);
    }
    else
    {
      puts("MultitouchHID::registerForSleepWakeNotifications() - IORegisterForSystemPower failed");
    }
  }
}

void MTTrackpadHIDManager::wasUnscheduledFromDispatchQueue(io_object_t *this, dispatch_queue_s *a2)
{
  MTInputDeviceManagement *v4;
  MTActuatorManagement *v5;

  MTTrackpadHIDManager::unregisterForPowerNotifications(this);
  MTSimpleHIDManager::wasUnscheduledFromDispatchQueue((NSObject **)this, a2);
  v4 = (MTInputDeviceManagement *)*((_QWORD *)this + 41);
  if (v4)
    MTInputDeviceManagement::unscheduleFromDispatchQueue(v4, (dispatch_queue_t)a2);
  v5 = *(MTActuatorManagement **)((*(uint64_t (**)(io_object_t *))(*(_QWORD *)this + 864))(this) + 208);
  if (v5)
    MTActuatorManagement::unscheduleFromDispatchQueue(v5, (dispatch_queue_t)a2);
}

void MTTrackpadHIDManager::handlePowerNotification(MTTrackpadHIDManager *this, void *a2, int a3, intptr_t notificationID, void *a5)
{
  uint64_t v7;
  IOReturn v8;
  mach_error_t v9;
  NSObject *v10;
  int v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  if (this)
  {
    if (a3 != -536870288)
    {
      if (a3 != -536870272)
        return;
      v7 = *((_QWORD *)this + 42);
      if (v7 && (**(unsigned int (***)(uint64_t, void *))(v7 + 80))(v7 + 80, a2))
        *(_BYTE *)(*((_QWORD *)this + 42) + 89) = 1;
    }
    v8 = IOAllowPowerChange(*((_DWORD *)this + 72), notificationID);
    if (v8)
    {
      v9 = v8;
      v10 = MTLoggingPlugin();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        v11 = 136315906;
        v12 = "[Error] ";
        v13 = 2080;
        v14 = "MTTrackpadHIDManager::";
        v15 = 2080;
        v16 = "handlePowerNotification";
        v17 = 2082;
        v18 = mach_error_string(v9);
        _os_log_impl(&dword_231071000, v10, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s IOAllowPowerChange failed with return %{public}s", (uint8_t *)&v11, 0x2Au);
      }
    }
  }
}

void ___ZN20MTTrackpadHIDManager32scheduleTapAndAHalfCallbackTimerEdd_block_invoke(uint64_t a1, dispatch_source_s *a2)
{
  MTTrackpadHIDManager::_tapAndAHalfTimerCallbackFunction(*(NSObject **)(*(_QWORD *)(a1 + 32) + 280), a2);
}

void MTTrackpadHIDManager::_tapAndAHalfTimerCallbackFunction(NSObject *this, dispatch_source_s *a2)
{
  void *context;
  MTParser **v3;
  double v4;
  double v5;
  double v6;
  double v7;
  CFTypeRef cf;

  context = dispatch_get_context(this);
  if (context)
  {
    v3 = (MTParser **)*((_QWORD *)context + 2);
    if (v3)
    {
      v5 = *(double *)context;
      v4 = *((double *)context + 1);
      MTTrackpadHIDManager::cancelOutstandingTapAndAHalfCallbackTimer(*((MTTrackpadHIDManager **)context + 2));
      cf = 0;
      v6 = v4 + v5;
      v7 = MTParser::autoReleaseTapAndAHalfDrag(v3[42], &cf, v6);
      if (cf)
      {
        (*((void (**)(MTParser **, CFTypeRef, _QWORD))*v3 + 17))(v3, cf, 0);
        CFRelease(cf);
      }
      if (v7 > 0.0)
        MTTrackpadHIDManager::scheduleTapAndAHalfCallbackTimer((MTTrackpadHIDManager *)v3, v6, v7);
    }
  }
}

uint64_t MTTrackpadHIDManager::checkForDisablers(MTTrackpadHIDManager *this)
{
  io_registry_entry_t Service;
  const __CFAllocator *v3;
  CFTypeRef CFProperty;
  io_registry_entry_t v5;
  CFTypeRef v6;
  io_registry_entry_t v7;
  CFTypeRef v8;
  CFTypeID v9;
  CFTypeID v10;
  CFTypeID v11;
  uint64_t v12;

  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
  if (!MTDeviceGetService())
    return 0;
  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
  Service = MTDeviceGetService();
  v3 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  CFProperty = IORegistryEntryCreateCFProperty(Service, CFSTR("DisablingMouseAttached"), (CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
  v5 = MTDeviceGetService();
  v6 = IORegistryEntryCreateCFProperty(v5, CFSTR("DisablingMouseKeysEnabled"), v3, 0);
  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
  v7 = MTDeviceGetService();
  v8 = IORegistryEntryCreateCFProperty(v7, CFSTR("DisablerPresent"), v3, 0);
  if (CFProperty
    && (v9 = CFGetTypeID(CFProperty), v9 == CFBooleanGetTypeID())
    && CFBooleanGetValue((CFBooleanRef)CFProperty)
    || v6 && (v10 = CFGetTypeID(v6), v10 == CFBooleanGetTypeID()) && CFBooleanGetValue((CFBooleanRef)v6)
    || v8 && (v11 = CFGetTypeID(v8), v11 == CFBooleanGetTypeID()) && CFBooleanGetValue((CFBooleanRef)v8))
  {
    v12 = 1;
    if (!CFProperty)
      goto LABEL_16;
    goto LABEL_15;
  }
  v12 = 0;
  if (CFProperty)
LABEL_15:
    CFRelease(CFProperty);
LABEL_16:
  if (v6)
    CFRelease(v6);
  if (v8)
    CFRelease(v8);
  return v12;
}

BOOL mthid_CFGetBoolValueWithDefault(const void *a1, uint64_t a2)
{
  CFTypeID v3;
  CFTypeID v4;
  int valuePtr;

  valuePtr = 0;
  if (a1)
  {
    v3 = CFGetTypeID(a1);
    if (v3 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)a1))
    {
      return 1;
    }
    else
    {
      v4 = CFGetTypeID(a1);
      return v4 == CFNumberGetTypeID()
          && CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, &valuePtr)
          && valuePtr != 0;
    }
  }
  return a2;
}

uint64_t mthid_CFGetUInt32ValueWithDefault(const void *a1, uint64_t a2)
{
  CFTypeID v4;
  unsigned int valuePtr;

  valuePtr = 0;
  if (a1)
  {
    v4 = CFGetTypeID(a1);
    if (v4 == CFNumberGetTypeID())
    {
      if (CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, &valuePtr) == 1)
        return valuePtr;
      else
        return a2;
    }
  }
  return a2;
}

BOOL mthid_CFDictionaryGetBoolValue(const __CFDictionary *a1, const __CFString *a2)
{
  return mthid_CFDictionaryGetBoolValueWithDefault(a1, a2, 0);
}

BOOL mthid_CFDictionaryGetBoolValueWithDefault(const __CFDictionary *a1, const __CFString *a2, uint64_t a3)
{
  const void *Value;

  if (!a1 || !a2)
    return a3;
  Value = CFDictionaryGetValue(a1, a2);
  return mthid_CFGetBoolValueWithDefault(Value, a3);
}

uint64_t mthid_CFDictionaryGetInt32Property(const __CFDictionary *a1, const __CFString *a2)
{
  return mthid_CFDictionaryGetInt32PropertyWithDefault(a1, a2, 0);
}

uint64_t mthid_CFDictionaryGetInt32PropertyWithDefault(const __CFDictionary *a1, const __CFString *a2, uint64_t a3)
{
  const void *Value;

  if (!a1 || !a2)
    return a3;
  Value = CFDictionaryGetValue(a1, a2);
  return mthid_CFGetUInt32ValueWithDefault(Value, a3);
}

_BYTE *MTTrackpadHIDManager::handlePendingConfigUpdate(_BYTE *this)
{
  _BYTE *v1;

  if (this[210])
  {
    v1 = this;
    this = (_BYTE *)(*(uint64_t (**)(_BYTE *))(*(_QWORD *)this + 664))(this);
    if ((_DWORD)this)
      return (_BYTE *)(*(uint64_t (**)(_BYTE *))(*(_QWORD *)v1 + 672))(v1);
  }
  return this;
}

BOOL MTTrackpadHIDManager::shouldUpdateHIDManagerConfig(MTTrackpadHIDManager *this)
{
  uint64_t v2;
  MTForceManagement *v3;

  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
  return !MTDeviceSupportsForce()
      || (v2 = *((_QWORD *)this + 42)) == 0
      || (v3 = *(MTForceManagement **)(v2 + 200)) == 0
      || !MTForceManagement::isForceButtonActivated(v3);
}

void MTTrackpadHIDManager::updateHIDManagerConfig(MTTrackpadHIDManager *this)
{
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;
  uint8_t buf[4];
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 664))(this) & 1) != 0)
  {
    (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
    if (MTDeviceGetService())
    {
      v2 = *((_QWORD *)this + 42);
      if (v2)
      {
        if (*(_QWORD *)(v2 + 72))
        {
          *((_BYTE *)this + 210) = 0;
          (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
          MTDeviceGetDeviceID();
          v3 = MTLoggingPlugin();
          if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 134217984;
            v6 = 0;
            _os_log_impl(&dword_231071000, v3, OS_LOG_TYPE_DEBUG, "HID Manager updating config (deviceID 0x%llX)", buf, 0xCu);
          }
          (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 696))(this);
          (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 704))(this);
          (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 712))(this);
          (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 800))(this);
        }
      }
    }
  }
  else
  {
    (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
    MTDeviceGetDeviceID();
    v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      v6 = 0;
      _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_DEBUG, "HID Manager has pending config update (deviceID 0x%llX)", buf, 0xCu);
    }
    *((_BYTE *)this + 210) = 1;
  }
}

void MTTrackpadHIDManager::determineSurfaceOrientationSettings(MTTrackpadHIDManager *this)
{
  uint64_t v2;
  const __CFNumber *v3;
  _BOOL4 AppBooleanValue;
  CFTypeID v5;
  int Value;
  int v9;
  uint64_t v10;
  const void *SavedNameForDevice;
  const __CFDictionary *v12;
  const __CFDictionary *v13;
  BOOL v14;
  const __CFNumber *v15;
  CFTypeID v16;
  const __CFNumber *v17;
  CFTypeID v18;
  int valuePtr;
  int v20;

  if ((*((_BYTE *)this + 160) & 8) != 0)
  {
    v2 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this);
    if (!(*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this))
    {
      *(_DWORD *)(v2 + 44) = 0;
      goto LABEL_19;
    }
    IOHIDPreferencesSynchronize();
    v3 = (const __CFNumber *)IOHIDPreferencesCopy();
    valuePtr = 0;
    AppBooleanValue = MTPreferencesGetAppBooleanValue(CFSTR("ForceAutoOrientation"), CFSTR("com.apple.MultitouchSupport"), 0);
    if (v3 && (v5 = CFGetTypeID(v3), v5 == CFNumberGetTypeID()))
    {
      Value = CFNumberGetValue(v3, kCFNumberSInt32Type, &valuePtr);
      if (valuePtr == 1 && Value != 0 || AppBooleanValue)
      {
        v9 = 1;
        goto LABEL_15;
      }
    }
    else if (AppBooleanValue)
    {
      v9 = 1;
      if (!v3)
        goto LABEL_16;
      goto LABEL_15;
    }
    v9 = 0;
    if (!v3)
    {
LABEL_16:
      *(_DWORD *)(v2 + 44) = v9;
      if (v9)
      {
LABEL_20:
        if (!(*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this))
        {
          LODWORD(v15) = 0;
          goto LABEL_42;
        }
        IOHIDPreferencesSynchronize();
        SavedNameForDevice = (const void *)mt_CreateSavedNameForDevice();
        v12 = (const __CFDictionary *)IOHIDPreferencesCopy();
        v13 = v12;
        if (SavedNameForDevice)
          v14 = v12 == 0;
        else
          v14 = 1;
        if (v14)
        {
          LODWORD(v15) = 0;
          if (!v12)
          {
            if (!SavedNameForDevice)
              goto LABEL_42;
            goto LABEL_41;
          }
          goto LABEL_40;
        }
        v16 = CFGetTypeID(v12);
        if (v16 != CFDictionaryGetTypeID())
          goto LABEL_39;
        v17 = (const __CFNumber *)CFDictionaryGetValue(v13, SavedNameForDevice);
        v15 = v17;
        v20 = 0;
        if (!v17)
          goto LABEL_40;
        v18 = CFGetTypeID(v17);
        if (v18 == CFNumberGetTypeID() && CFNumberGetValue(v15, kCFNumberSInt32Type, &v20))
        {
          if ((v20 & 0xFFFFFFFD) != 0)
            LODWORD(v15) = 0;
          else
            LODWORD(v15) = v20;
        }
        else
        {
LABEL_39:
          LODWORD(v15) = 0;
        }
LABEL_40:
        CFRelease(v13);
        if (SavedNameForDevice)
LABEL_41:
          CFRelease(SavedNameForDevice);
LABEL_42:
        *(_DWORD *)(v2 + 40) = (_DWORD)v15;
        return;
      }
LABEL_19:
      v10 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
      SaveSurfaceOrientationForDevice(v10, 0, 1);
      goto LABEL_20;
    }
LABEL_15:
    CFRelease(v3);
    goto LABEL_16;
  }
}

const __CFDictionary *MTTrackpadHIDManager::setPreferenceDefaults(const __CFDictionary *result, uint64_t a2)
{
  const __CFDictionary *v2;
  io_registry_entry_t Service;
  const __CFAllocator *v4;
  BOOL v5;
  const void *Value;
  CFTypeID v7;
  const void *v8;
  const void *v9;
  _BOOL4 v10;
  const void *v11;
  io_registry_entry_t v12;
  CFMutableDictionaryRef properties;

  if (a2)
  {
    v2 = result;
    properties = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
    Service = MTDeviceGetService();
    v4 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    if (IORegistryEntryCreateCFProperties(Service, &properties, (CFAllocatorRef)*MEMORY[0x24BDBD240], 0))
      v5 = 1;
    else
      v5 = properties == 0;
    if (!v5)
    {
      Value = CFDictionaryGetValue(properties, CFSTR("TrackpadUserPreferences"));
      if (Value || (Value = CFDictionaryGetValue(properties, CFSTR("MultitouchPreferences"))) != 0)
      {
        v7 = CFGetTypeID(Value);
        if (v7 == CFDictionaryGetTypeID())
        {
          v8 = (const void *)*((_QWORD *)v2 + 43);
          if (v8)
            CFRelease(v8);
          *((_QWORD *)v2 + 43) = CFDictionaryCreateMutableCopy(v4, 0, (CFDictionaryRef)Value);
        }
      }
      CFRelease(properties);
    }
    result = (const __CFDictionary *)*((_QWORD *)v2 + 43);
    if (result)
    {
      v9 = CFDictionaryGetValue(result, CFSTR("USBMouseStopsTrackpad"));
      v10 = mthid_CFGetBoolValueWithDefault(v9, 0);
      result = (const __CFDictionary *)*((_QWORD *)v2 + 43);
      if (result)
      {
        v11 = CFDictionaryGetValue(result, CFSTR("MouseKeysStopsTrackpad"));
        result = (const __CFDictionary *)mthid_CFGetBoolValueWithDefault(v11, 0);
      }
      if ((v10 | result) == 1)
      {
        v12 = MTDeviceGetService();
        return (const __CFDictionary *)IORegistryEntrySetCFProperty(v12, CFSTR("TrackpadUserPreferences"), *((CFTypeRef *)v2 + 43));
      }
    }
  }
  return result;
}

void MTTrackpadHIDManager::updatePreferences(MTTrackpadHIDManager *this, const __CFString *a2, const void *a3)
{
  __CFDictionary *v3;

  if (a3 && a2)
  {
    v3 = (__CFDictionary *)*((_QWORD *)this + 43);
    if (v3)
      CFDictionarySetValue(v3, a2, a3);
  }
}

BOOL MTTrackpadHIDManager::determineHIDManagerSettings(MTTrackpadHIDManager *this)
{
  uint64_t v2;
  const __CFDictionary *v3;
  const void *Value;
  _BOOL4 v5;
  const void *v6;
  _BOOL4 v7;
  BOOL v8;
  const void *v9;
  uint64_t v10;
  const void *v11;
  _BOOL4 v12;
  BOOL v13;
  const void *v14;
  int v15;
  const void *v16;
  const void *v17;
  _BOOL4 v18;
  BOOL v19;
  const void *v20;
  const void *v21;
  int v22;
  int v23;
  const void *v24;
  const void *v25;
  _BOOL4 v26;
  BOOL v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  const void *v37;
  const void *v38;
  const void *v39;
  const void *v40;
  const void *v41;
  const void *v42;
  const void *v43;
  const void *v44;
  int v45;
  char v46;
  const void *v47;
  const void *v48;
  const void *v49;
  const void *v50;
  const void *v51;
  BOOL AppBooleanValue;
  _BOOL8 result;

  v2 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this);
  v3 = (const __CFDictionary *)*((_QWORD *)this + 43);
  if (v3)
  {
    Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 43), CFSTR("TrackpadBasicMode"));
    v5 = mthid_CFGetBoolValueWithDefault(Value, 0);
    *(_OWORD *)v2 = 0u;
    *(_OWORD *)(v2 + 16) = 0u;
    *(_OWORD *)(v2 + 32) = 0u;
    *(_OWORD *)(v2 + 48) = 0u;
    *(_DWORD *)(v2 + 64) = 0;
    *(_BYTE *)v2 = 1;
    if (v5)
    {
      *(_WORD *)(v2 + 12) = 257;
      v6 = CFDictionaryGetValue(v3, CFSTR("TrackpadScroll"));
      v7 = mthid_CFGetBoolValueWithDefault(v6, 0);
      v8 = 0;
      if (v7)
      {
        v9 = CFDictionaryGetValue(v3, CFSTR("TrackpadHorizScroll"));
        v8 = mthid_CFGetBoolValueWithDefault(v9, 0);
      }
      *(_BYTE *)(v2 + 14) = v8;
      *(_BYTE *)(v2 + 34) = v8;
    }
    else
    {
      v11 = CFDictionaryGetValue(v3, CFSTR("Clicking"));
      v12 = mthid_CFGetBoolValueWithDefault(v11, 0);
      v13 = 0;
      *(_BYTE *)(v2 + 1) = v12;
      *(_BYTE *)(v2 + 37) = v12;
      if (v12)
      {
        v14 = CFDictionaryGetValue(v3, CFSTR("Dragging"));
        v13 = mthid_CFGetBoolValueWithDefault(v14, 0);
      }
      *(_BYTE *)(v2 + 2) = v13;
      v15 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 720))(this);
      if (v15)
      {
        v16 = CFDictionaryGetValue(v3, CFSTR("TrackpadThreeFingerDrag"));
        LOBYTE(v15) = mthid_CFGetBoolValueWithDefault(v16, 0);
      }
      *(_BYTE *)(v2 + 5) = v15;
      v17 = CFDictionaryGetValue(v3, CFSTR("DragLock"));
      v18 = mthid_CFGetBoolValueWithDefault(v17, 0);
      v19 = 0;
      if (v18)
      {
        if (*(_BYTE *)(v2 + 2))
          v19 = 1;
        else
          v19 = *(_BYTE *)(v2 + 5) != 0;
      }
      *(_BYTE *)(v2 + 3) = v19;
      v20 = CFDictionaryGetValue(v3, CFSTR("TrackpadTwoFingerFromRightEdgeSwipeGesture"));
      *(_BYTE *)(v2 + 30) = mthid_CFGetUInt32ValueWithDefault(v20, 3) == 3;
      v21 = CFDictionaryGetValue(v3, CFSTR("TrackpadRightClick"));
      *(_BYTE *)(v2 + 6) = mthid_CFGetBoolValueWithDefault(v21, 0);
      *(_BYTE *)(v2 + 31) = *((_BYTE *)this + 209);
      v22 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 728))(this);
      v23 = 0;
      if (v22)
      {
        v24 = CFDictionaryGetValue(v3, CFSTR("TrackpadCornerSecondaryClick"));
        v23 = mthid_CFGetUInt32ValueWithDefault(v24, 0);
      }
      *(_DWORD *)(v2 + 8) = v23;
      *(_WORD *)(v2 + 12) = 257;
      v25 = CFDictionaryGetValue(v3, CFSTR("TrackpadScroll"));
      v26 = mthid_CFGetBoolValueWithDefault(v25, 0);
      v27 = 0;
      if (v26)
      {
        v28 = CFDictionaryGetValue(v3, CFSTR("TrackpadHorizScroll"));
        v27 = mthid_CFGetBoolValueWithDefault(v28, 0);
      }
      *(_BYTE *)(v2 + 14) = v27;
      v29 = CFDictionaryGetValue(v3, CFSTR("TrackpadMomentumScroll"));
      *(_BYTE *)(v2 + 32) = mthid_CFGetBoolValueWithDefault(v29, 0);
      v30 = CFDictionaryGetValue(v3, CFSTR("TrackpadPinch"));
      *(_BYTE *)(v2 + 16) = mthid_CFGetBoolValueWithDefault(v30, 0);
      v31 = CFDictionaryGetValue(v3, CFSTR("TrackpadRotate"));
      *(_BYTE *)(v2 + 17) = mthid_CFGetBoolValueWithDefault(v31, 0);
      v32 = CFDictionaryGetValue(v3, CFSTR("TrackpadTwoFingerDoubleTapGesture"));
      *(_BYTE *)(v2 + 18) = mthid_CFGetUInt32ValueWithDefault(v32, 0) == 1;
      v33 = CFDictionaryGetValue(v3, CFSTR("TrackpadThreeFingerTapGesture"));
      *(_BYTE *)(v2 + 19) = mthid_CFGetUInt32ValueWithDefault(v33, 2) == 2;
      v34 = CFDictionaryGetValue(v3, CFSTR("HIDScrollZoomModifierMask"));
      *(_BYTE *)(v2 + 35) = mthid_CFGetUInt32ValueWithDefault(v34, 0) != 0;
      (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 736))(this);
      v35 = CFDictionaryGetValue(v3, CFSTR("TrackpadThreeFingerHorizSwipeGesture"));
      *(_BYTE *)(v2 + 21) = mthid_CFGetUInt32ValueWithDefault(v35, 0) == 1;
      v36 = CFDictionaryGetValue(v3, CFSTR("TrackpadThreeFingerVertSwipeGesture"));
      *(_BYTE *)(v2 + 20) = mthid_CFGetUInt32ValueWithDefault(v36, 0) == 1;
      v37 = CFDictionaryGetValue(v3, CFSTR("TrackpadThreeFingerHorizSwipeGesture"));
      *(_BYTE *)(v2 + 25) = mthid_CFGetUInt32ValueWithDefault(v37, 0) == 2;
      v38 = CFDictionaryGetValue(v3, CFSTR("TrackpadThreeFingerVertSwipeGesture"));
      *(_BYTE *)(v2 + 24) = mthid_CFGetUInt32ValueWithDefault(v38, 0) == 2;
      v39 = CFDictionaryGetValue(v3, CFSTR("TrackpadFourFingerHorizSwipeGesture"));
      *(_BYTE *)(v2 + 23) = mthid_CFGetUInt32ValueWithDefault(v39, 0) == 1;
      v40 = CFDictionaryGetValue(v3, CFSTR("TrackpadFourFingerVertSwipeGesture"));
      *(_BYTE *)(v2 + 22) = mthid_CFGetUInt32ValueWithDefault(v40, 0) == 1;
      v41 = CFDictionaryGetValue(v3, CFSTR("TrackpadFourFingerHorizSwipeGesture"));
      *(_BYTE *)(v2 + 27) = mthid_CFGetUInt32ValueWithDefault(v41, 0) == 2;
      v42 = CFDictionaryGetValue(v3, CFSTR("TrackpadFourFingerVertSwipeGesture"));
      *(_BYTE *)(v2 + 26) = mthid_CFGetUInt32ValueWithDefault(v42, 0) == 2;
      v43 = CFDictionaryGetValue(v3, CFSTR("TrackpadFourFingerPinchGesture"));
      *(_BYTE *)(v2 + 28) = mthid_CFGetUInt32ValueWithDefault(v43, 0) == 2;
      v44 = CFDictionaryGetValue(v3, CFSTR("TrackpadFiveFingerPinchGesture"));
      v45 = mthid_CFGetUInt32ValueWithDefault(v44, 0);
      v46 = 0;
      *(_BYTE *)(v2 + 29) = v45 == 2;
      if (*((_DWORD *)this + 39) != 1001)
        v46 = *(_BYTE *)(v2 + 14);
      *(_BYTE *)(v2 + 34) = v46;
      v47 = CFDictionaryGetValue(v3, CFSTR("FirstClickThreshold"));
      *(_DWORD *)(v2 + 48) = mthid_CFGetUInt32ValueWithDefault(v47, 1);
      v48 = CFDictionaryGetValue(v3, CFSTR("SecondClickThreshold"));
      *(_DWORD *)(v2 + 52) = mthid_CFGetUInt32ValueWithDefault(v48, 1);
      v49 = CFDictionaryGetValue(v3, CFSTR("ActuationStrength"));
      *(_DWORD *)(v2 + 56) = mthid_CFGetUInt32ValueWithDefault(v49, 1);
      v50 = CFDictionaryGetValue(v3, CFSTR("ActuateDetents"));
      *(_DWORD *)(v2 + 60) = mthid_CFGetUInt32ValueWithDefault(v50, 1);
      v51 = CFDictionaryGetValue(v3, CFSTR("ForceSuppressed"));
      *(_BYTE *)(v2 + 64) = mthid_CFGetBoolValueWithDefault(v51, 0);
    }
  }
  else
  {
    v10 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
    (*(void (**)(MTTrackpadHIDManager *, uint64_t, uint64_t))(*(_QWORD *)this + 856))(this, v10, v2);
  }
  AppBooleanValue = 1;
  if ((*((_BYTE *)this + 160) & 4) == 0)
    AppBooleanValue = MTPreferencesGetAppBooleanValue(CFSTR("ScrollMomentum"), CFSTR("com.apple.MultitouchSupport"), 0);
  *(_BYTE *)(v2 + 33) = AppBooleanValue;
  *(_BYTE *)(v2 + 15) = 1;
  *(_BYTE *)(v2 + 4) = MTPreferencesGetAppBooleanValue(CFSTR("PointerInertia"), CFSTR("com.apple.MultitouchSupport"), 0);
  result = MTPreferencesGetAppBooleanValue(CFSTR("SymmetricZoom"), CFSTR("com.apple.MultitouchSupport"), 0);
  *(_BYTE *)(v2 + 36) = result;
  return result;
}

void MTTrackpadHIDManager::createPointClickTapDragCombo(MTTrackpadHIDManager *this, __CFDictionary *a2, const __CFString *a3, int a4, int a5, int a6, int a7, int a8)
{
  const __CFAllocator *v16;
  MTPListGestureConfig *Mutable;
  CFMutableDictionaryRef v18;
  BOOL v19;
  __CFDictionary *v20;
  const __CFString *v21;
  __CFString *v22;
  const __CFString *v23;
  MTPListGestureConfig *v24;
  const __CFString *v25;
  const void *v26;

  v16 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD690]);
  v18 = CFDictionaryCreateMutable(v16, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (Mutable)
    v19 = v18 == 0;
  else
    v19 = 1;
  if (!v19)
  {
    v20 = v18;
    if (*(_BYTE *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this) + 4))
      v21 = CFSTR("Momentum AccelOnlyIfSomeResting");
    else
      v21 = CFSTR("AccelOnlyIfSomeResting");
    if (a6)
    {
      MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Point"), CFSTR("Translate"), CFSTR("Resting Accel Tracking"), v21, 0, 0, 0, v26);
      v22 = CFSTR("Primary Down");
    }
    else
    {
      if (!a5)
      {
        if (!a4)
        {
LABEL_16:
          if (a7)
          {
            MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Click"), CFSTR("DroppedFingerTap"), 0, 0, 0, 0, 0, v26);
            if (!a8)
              goto LABEL_19;
          }
          else if (!a8)
          {
LABEL_19:
            CFDictionaryAddValue(v20, CFSTR("Gestures"), Mutable);
            CFDictionaryAddValue(v20, CFSTR("Transitions"), CFSTR("ToMoreIfPause FromRestingPoint FromMoreFingers FromMoreWithSlightIntegrationDelay"));
            CFDictionaryAddValue(a2, a3, v20);
            CFRelease(Mutable);
            CFRelease(v20);
            return;
          }
          MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Zoom Toggle"), CFSTR("DoubleTap"), 0, 0, 0, 0, 0, v26);
          goto LABEL_19;
        }
        v22 = CFSTR("Point");
        v23 = CFSTR("Translate");
        v25 = CFSTR("Resting Accel Tracking");
        v24 = Mutable;
LABEL_15:
        MTPListGestureConfig::addGestureToArray(v24, (__CFArray *)v22, v23, v25, v21, 0, 0, 0, v26);
        goto LABEL_16;
      }
      MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Point"), CFSTR("Translate"), CFSTR("Resting Accel Tracking"), v21, 0, 0, 0, v26);
      v22 = CFSTR("Click");
    }
    v23 = CFSTR("Tap");
    v24 = Mutable;
    v25 = 0;
    v21 = 0;
    goto LABEL_15;
  }
}

void MTTrackpadHIDManager::createScrollZoomCombo(MTTrackpadHIDManager *this, __CFDictionary *a2, const __CFString *a3)
{
  _BYTE *v6;
  const __CFAllocator *v7;
  MTPListGestureConfig *Mutable;
  CFMutableDictionaryRef v9;
  BOOL v10;
  __CFDictionary *v11;
  const __CFString *v12;
  int v13;
  const __CFString *v14;
  const __CFString *v15;
  const __CFString *v16;
  const __CFString *v17;
  const __CFString *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;

  v6 = (_BYTE *)(*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this);
  v7 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD690]);
  v9 = CFDictionaryCreateMutable(v7, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (Mutable)
    v10 = v9 == 0;
  else
    v10 = 1;
  if (v10)
    return;
  v11 = v9;
  if (v6[15] && v6[14] || v6[35])
  {
    v12 = CFSTR("IfWidelySeparatedFingers AccelOnlyIfSomeResting");
  }
  else
  {
    v12 = CFSTR("IfWidelySeparatedFingers AccelOnlyIfSomeResting");
    if (!v6[16] && !v6[17])
      v12 = CFSTR("AccelOnlyIfSomeResting");
  }
  MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Point"), CFSTR("Translate"), CFSTR("Resting Accel Tracking"), v12, CFSTR("LockOnFirst"), 0, 0, v19);
  v13 = v6[12];
  if (v6[13])
  {
    if (*(_BYTE *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this) + 33))
      v14 = CFSTR("Momentum");
    else
      v14 = CFSTR("Repetitive");
    if (v13)
      v15 = CFSTR("Translate");
    else
      v15 = CFSTR("Horizontal");
LABEL_27:
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Scroll"), v15, CFSTR("Scrolling"), v14, CFSTR("LockOnFirst"), CFSTR("Category"), CFSTR("TwoFingerScroll"), v20);
    goto LABEL_28;
  }
  if (v6[12])
  {
    if (*(_BYTE *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this) + 33))
      v14 = CFSTR("Momentum");
    else
      v14 = CFSTR("Repetitive");
    v15 = CFSTR("Vertical");
    goto LABEL_27;
  }
LABEL_28:
  if (v6[13] || v6[12])
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Scroll"), CFSTR("Hold"), 0, CFSTR("MayBegin"), 0, CFSTR("Category"), CFSTR("TwoFingerScroll"), v20);
  if (*(_BYTE *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this) + 30))
  {
    if (v6[31])
      v16 = CFSTR("Right");
    else
      v16 = CFSTR("Left");
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Fluid Notification"), v16, CFSTR("Edge Swipe"), CFSTR("OnlyIfAllMoving OnlyFromEdge"), CFSTR("LockOnFirstUntilPause"), CFSTR("Category"), CFSTR("TwoFingerScroll"), v20);
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Fluid Notification"), CFSTR("Horizontal"), CFSTR("Edge Swipe"), CFSTR("OnlyIfAllMoving"), CFSTR("LockOnFirstUntilPause"), CFSTR("Category"), CFSTR("TwoFingerNotificationCenter"), v21);
    if (*(_BYTE *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this) + 33))
      v17 = CFSTR("Momentum");
    else
      v17 = CFSTR("Repetitive");
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Scroll"), CFSTR("Vertical"), CFSTR("Scrolling"), v17, CFSTR("LockOnFirst"), CFSTR("Category"), CFSTR("TwoFingerNotificationCenter"), v22);
  }
  if (v6[1] && v6[6])
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Secondary Click"), CFSTR("Tap"), 0, 0, 0, 0, 0, v20);
  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
  MTDeviceSetPickButtonShouldSendSecondaryClick();
  if (v6[16])
  {
    if (v6[17])
      v18 = CFSTR("Scale+Rotate");
    else
      v18 = CFSTR("Scale");
    goto LABEL_48;
  }
  if (v6[17])
  {
    v18 = CFSTR("Rotate");
LABEL_48:
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Orientation"), v18, CFSTR("Zooming"), CFSTR("Repetitive"), CFSTR("LockOnFirst"), 0, 0, v20);
  }
  if (v6[18])
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Zoom Toggle"), CFSTR("DoubleTap"), 0, 0, 0, 0, 0, v20);
  if (v6[37])
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Click"), CFSTR("DroppedFingerTap"), 0, 0, 0, 0, 0, v20);
  CFDictionaryAddValue(v11, CFSTR("Gestures"), Mutable);
  CFDictionaryAddValue(v11, CFSTR("Transitions"), CFSTR("ToMoreIfPause ToFewerAfterSlightDelay FromRestingPoint FromFewerFingers FromMoreFingers FromMoreWithSlightIntegrationDelay"));
  CFDictionarySetValue(a2, a3, v11);
  CFRelease(Mutable);
  CFRelease(v11);
}

void MTTrackpadHIDManager::createRestingSwipeOrDockCombo(_DWORD *a1, __CFDictionary *a2, const void *a3, int a4, int a5, int a6, int a7, int a8, unsigned __int8 a9, unsigned __int8 a10, unsigned __int8 a11, unsigned __int8 a12, unsigned __int8 a13, char a14)
{
  const __CFAllocator *v16;
  MTPListGestureConfig *Mutable;
  CFMutableDictionaryRef v18;
  BOOL v19;
  _DWORD *v20;
  int v21;
  const __CFString *v22;
  __CFString *MutableCopy;
  const __CFString *v24;
  const __CFString *v25;
  __CFString *v26;
  __CFString *v27;
  int v28;
  const __CFString *v29;
  const __CFString *v30;
  int v31;
  int v32;
  const __CFString *v33;
  const void *v34;
  const void *v35;
  __CFDictionary *theDict;

  v16 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD690]);
  v18 = CFDictionaryCreateMutable(v16, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (Mutable)
    v19 = v18 == 0;
  else
    v19 = 1;
  if (v19)
    return;
  theDict = v18;
  if (a5)
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Click"), CFSTR("DroppedFingerTap"), 0, 0, 0, 0, 0, v34);
  v20 = a1;
  v21 = a8;
  if (a1[39] != 1001)
  {
    if (*(_BYTE *)((*(uint64_t (**)(_DWORD *))(*(_QWORD *)a1 + 848))(a1) + 4))
      v22 = CFSTR("Momentum OnlyIfOneMoving AccelOnlyIfSomeResting");
    else
      v22 = CFSTR("OnlyIfOneMoving AccelOnlyIfSomeResting");
    MutableCopy = CFStringCreateMutableCopy(v16, 256, v22);
    v24 = MutableCopy;
    if ((a8 & 1) == 0 && (a9 & 1) == 0 && (a10 & 1) == 0 && (a11 & 1) == 0 && (a12 & 1) == 0 && (a6 & 1) == 0)
      CFStringAppend(MutableCopy, CFSTR(" OnlyIfAllMoving"));
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Point"), CFSTR("Translate"), CFSTR("Resting Accel Tracking"), v24, CFSTR("LockOnFirst"), 0, 0, v34);
    CFRelease(v24);
    v20 = a1;
  }
  if ((a6 & 1) != 0 || a7)
  {
    if (*(_BYTE *)((*(uint64_t (**)(_DWORD *))(*(_QWORD *)v20 + 848))(v20) + 33))
      v25 = CFSTR("Momentum");
    else
      v25 = CFSTR("Repetitive");
    v26 = CFStringCreateMutableCopy(v16, 256, v25);
    v27 = v26;
    v28 = a10 | a11 | a9;
    if (a7)
    {
      CFStringAppend(v26, CFSTR(" OnlyIfTwoMoving"));
      if (((v28 | a6 ^ 1) & 1) == 0)
      {
        if (a4 == 5)
          v29 = CFSTR(" OnlyIfFourMoving");
        else
          v29 = CFSTR(" OnlyIfAllMoving");
        goto LABEL_33;
      }
    }
    else if (v28)
    {
      v29 = CFSTR(" OnlyIfSomeMoving");
LABEL_33:
      CFStringAppend(v27, v29);
    }
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Scroll"), CFSTR("Translate"), CFSTR("Scrolling"), v27, CFSTR("LockOnFirst"), 0, 0, v34);
    CFRelease(v27);
    v21 = a8;
  }
  if (a4 == 5)
    v30 = CFSTR(" OnlyIfFourMoving");
  else
    v30 = CFSTR(" OnlyIfAllMoving");
  if (v21 && !a10)
  {
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Fluid Navigation"), CFSTR("Horizontal"), CFSTR("Swipe"), v30, CFSTR("LockOnFirstUntilPause"), 0, 0, v34);
    v31 = a13;
    v32 = a12;
    if (!a9 || (a11 & 1) != 0)
      goto LABEL_46;
    goto LABEL_45;
  }
  v31 = a13;
  v32 = a12;
  if (a9 && (a11 & 1) == 0)
  {
LABEL_45:
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Fluid Navigation"), CFSTR("Vertical"), CFSTR("Swipe"), v30, CFSTR("LockOnFirstUntilPause"), 0, 0, v34);
LABEL_46:
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Fluid Navigation"), CFSTR("Tap"), 0, 0, 0, 0, 0, v34);
  }
  if (a10)
  {
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Fluid Dock"), CFSTR("Horizontal"), CFSTR("Swipe"), v30, CFSTR("LockOnFirstUntilPause"), 0, 0, v34);
    if (!a11)
    {
LABEL_49:
      if (!v32)
        goto LABEL_50;
      goto LABEL_54;
    }
  }
  else if (!a11)
  {
    goto LABEL_49;
  }
  MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Fluid Dock"), CFSTR("Vertical"), CFSTR("Swipe"), v30, CFSTR("LockOnFirstUntilPause"), 0, 0, v34);
  if (!v32)
  {
LABEL_50:
    if ((a10 & 1) != 0)
      goto LABEL_56;
    goto LABEL_55;
  }
LABEL_54:
  MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Fluid Dock"), CFSTR("Scale"), CFSTR("Polar Swipe"), CFSTR(" OnlyIfAllMoving"), CFSTR("LockOnFirstUntilPause"), 0, 0, v34);
  MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Fluid Dock"), CFSTR("Rotate"), CFSTR("Polar Swipe"), CFSTR(" OnlyIfAllMoving"), CFSTR("LockOnFirstUntilPause"), 0, 0, v35);
  if ((a10 & 1) != 0)
  {
LABEL_56:
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Fluid Dock"), CFSTR("Tap"), 0, 0, 0, 0, 0, v34);
    goto LABEL_57;
  }
LABEL_55:
  if (a11)
    goto LABEL_56;
LABEL_57:
  if (v31)
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Zoom Toggle"), CFSTR("DoubleTap"), 0, 0, 0, 0, 0, v34);
  if (a14)
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Show Definition"), CFSTR("Tap"), 0, 0, 0, 0, 0, v34);
  if (a4 == 5)
  {
    v33 = CFSTR("IsRestingPoint");
  }
  else if ((a4 - 1) > 3)
  {
    v33 = CFSTR("ToMoreFingers FromFewerFingers ToFewerFingers FromMoreFingers FromMoreWithSlightIntegrationDelay");
  }
  else
  {
    v33 = off_24FFF22F8[a4 - 1];
  }
  CFDictionaryAddValue(theDict, CFSTR("Transitions"), v33);
  CFDictionaryAddValue(theDict, CFSTR("Gestures"), Mutable);
  CFDictionaryAddValue(a2, a3, theDict);
  CFRelease(Mutable);
  CFRelease(theDict);
}

void MTTrackpadHIDManager::activateHIDManagerSettings(MTTrackpadHIDManager *this)
{
  const void *v2;
  __CFDictionary *v3;
  const __CFAllocator *v4;
  const CFDictionaryKeyCallBacks *v5;
  const CFDictionaryValueCallBacks *v6;
  __CFDictionary *Mutable;
  __CFDictionary *v8;
  MTPListGestureConfig *v9;
  unsigned __int8 *v10;
  const __CFString *v11;
  const __CFString *v12;
  const __CFString *v13;
  const __CFString *v14;
  const __CFString *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  _BOOL4 v20;
  int v21;
  int v22;
  const __CFString *v23;
  const __CFString *v24;
  uint64_t v25;
  uint64_t v26;
  _BYTE *v27;
  unsigned __int8 v28;
  char v29;
  char v30;
  unsigned int v31;
  int v32;
  int v33;
  uint64_t v34;
  const void *v35;
  __int128 v36;
  int v37;
  uint64_t v38;
  const void *v39;
  __int128 v40;
  BOOL v41;
  uint64_t v42;
  uint64_t v43;
  MTActuatorManagement *v44;
  uint64_t v45;
  _QWORD *v46;
  __CFArray *v47;
  __CFArray *v48;
  _BOOL4 v49;
  __CFDictionary *v50;
  const void *v51;
  CFTypeRef cf;
  __int128 v53;
  void *v54[2];
  __int128 v55;
  void *v56[2];
  void *v57[2];
  __int128 v58;
  void *v59[2];
  void *__p[2];
  __int128 v61;
  __CFString *v62;

  v2 = (const void *)(*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 624))(this);
  v3 = (__CFDictionary *)(*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 632))(this);
  cf = (CFTypeRef)(*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 640))(this);
  v4 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v5 = (const CFDictionaryKeyCallBacks *)MEMORY[0x24BDBD6A0];
  v6 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v8 = CFDictionaryCreateMutable(v4, 2, v5, v6);
  v9 = CFArrayCreateMutable(v4, 0, MEMORY[0x24BDBD690]);
  v10 = (unsigned __int8 *)(*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this);
  MTTrackpadHIDManager::createPointClickTapDragCombo(this, v3, CFSTR("1F Point, Click & Drag"), *v10, v10[1], v10[2], v10[37], v10[16]);
  MTPListGestureConfig::addChordMappingToArray(v9, (__CFArray *)CFSTR("1 Finger"), CFSTR("1F Point, Click & Drag"), v11);
  if (*((_WORD *)v10 + 6) || v10[16] || v10[17] || v10[15] && v10[14] || v10[1] && v10[6])
  {
    v12 = CFSTR("Scroll, Zoom & Rotate, Secondary Click");
    MTTrackpadHIDManager::createScrollZoomCombo(this, v3, CFSTR("Scroll, Zoom & Rotate, Secondary Click"));
  }
  else
  {
    v12 = CFSTR("Resting 2F Point");
    MTTrackpadHIDManager::createRestingSwipeOrDockCombo(this, v3, CFSTR("Resting 2F Point"), 1, v10[37], 0, 0, 0, 0, 0, 0, 0, v10[18], 0);
  }
  MTPListGestureConfig::addChordMappingToArray(v9, (__CFArray *)CFSTR("2 Fingers"), v12, v13);
  if (v10[5])
  {
    v15 = CFSTR("Drag & Click");
    goto LABEL_30;
  }
  if (v10[24] || v10[25])
    v16 = 3;
  else
    v16 = 0;
  v17 = v10[20];
  if (!v10[34])
  {
    v18 = 0;
LABEL_28:
    v19 = 0;
    goto LABEL_29;
  }
  if (!v10[20])
  {
    if (v10[21])
    {
      v18 = 0;
    }
    else
    {
      if (v10[24])
        v20 = 1;
      else
        v20 = v10[25] != 0;
      v18 = !v20;
    }
    if (!v10[21])
    {
      if (v10[24])
        v49 = 1;
      else
        v49 = v10[25] != 0;
      v17 = 0;
      v19 = !v49;
      goto LABEL_29;
    }
    v17 = 0;
    goto LABEL_28;
  }
  v18 = 0;
  v19 = 0;
  v17 = 1;
LABEL_29:
  v15 = CFSTR("Resting 3F Swipe");
  MTTrackpadHIDManager::createRestingSwipeOrDockCombo(this, v3, CFSTR("Resting 3F Swipe"), v16, v10[37] != 0, v18, v19, v10[21], v17 != 0, v10[25], v10[24] != 0, 0, 0, v10[19]);
LABEL_30:
  MTPListGestureConfig::addChordMappingToArray(v9, (__CFArray *)CFSTR("3 Fingers"), v15, v14);
  v21 = v10[27];
  if (!v10[26])
  {
    v22 = 1;
    if (!v10[27])
      goto LABEL_34;
    v21 = 1;
  }
  v22 = 3;
LABEL_34:
  MTTrackpadHIDManager::createRestingSwipeOrDockCombo(this, v3, CFSTR("Resting 4F Dock Operations"), v22, v10[37], v10[34], v10[34], v10[23], v10[22], v21 != 0, v10[26] != 0, v10[28], 0, 0);
  MTPListGestureConfig::addChordMappingToArray(v9, (__CFArray *)CFSTR("4 Fingers"), CFSTR("Resting 4F Dock Operations"), v23);
  MTTrackpadHIDManager::createRestingSwipeOrDockCombo(this, v3, CFSTR("Resting T4F Dock Operations"), v22, v10[37], v10[34], v10[34], v10[23], v10[22], v10[27], v10[26], v10[29], 0, 0);
  MTPListGestureConfig::addChordMappingToArray(v9, (__CFArray *)CFSTR("4 Fingers + Thumb"), CFSTR("Resting T4F Dock Operations"), v24);
  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 744))(this);
  CFDictionaryAddValue(v8, CFSTR("Chords"), v9);
  CFDictionaryAddValue(Mutable, CFSTR("Right"), v8);
  v62 = 0;
  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
  if (MTDeviceSupportsForce())
    *(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 42) + 200) + 597) = 1;
  (*(void (**)(MTTrackpadHIDManager *, uint64_t))(*(_QWORD *)this + 592))(this, 1);
  MTParser::clear(*((_QWORD **)this + 42), 0, 0, v25);
  MTGestureConfig::clearAllChords(*(MTGestureConfig **)(*((_QWORD *)this + 42) + 72));
  MTPListGestureConfig::setMotionSensitivitiesDictionary(*(MTPListGestureConfig **)(*((_QWORD *)this + 42) + 72), v2);
  MTPListGestureConfig::setGestureSetsDictionary(*(MTPListGestureConfig **)(*((_QWORD *)this + 42) + 72), v3);
  MTPListGestureConfig::setActionEventsDictionary(*(MTPListGestureConfig **)(*((_QWORD *)this + 42) + 72), cf);
  MTPListGestureConfig::setChordMappingsDictionary(*(MTPListGestureConfig **)(*((_QWORD *)this + 42) + 72), Mutable);
  MTPListGestureConfig::parseCreateGestureConfig(*(MTPListGestureConfig **)(*((_QWORD *)this + 42) + 72), (const __CFString **)&v62);
  v26 = *((_QWORD *)this + 42);
  v27 = *(_BYTE **)(v26 + 56);
  v28 = v10[30];
  if (v28)
  {
    v28 = v10[31] != 0;
    v29 = v10[31] ^ 1;
  }
  else
  {
    v29 = 0;
  }
  v27[136] = v29;
  v27[137] = v28;
  v27[138] = 0;
  v27[139] = v10[36];
  v30 = *(_BYTE *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this) + 2);
  if (v30)
    v30 = *(_BYTE *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this) + 3) != 0;
  *(_BYTE *)(v26 + 88) = v30;
  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
  if (MTDeviceSupportsForce())
  {
    v50 = Mutable;
    v51 = v2;
    if (*((_DWORD *)v10 + 12) >= 3u)
      v31 = 1;
    else
      v31 = *((_DWORD *)v10 + 12);
    if (*((_DWORD *)v10 + 13) >= 3u)
      v32 = 1;
    else
      v32 = *((_DWORD *)v10 + 13);
    MTForceBehaviorConfiguration::clearBehaviors((MTForceBehaviorConfiguration *)(*(_QWORD *)(*((_QWORD *)this + 42)
                                                                                            + 200)
                                                                                + 264));
    if (v10[64])
      v33 = 1;
    else
      v33 = 5;
    v34 = MTForceConfigCreate(v33, 0);
    if (v34)
    {
      v35 = (const void *)v34;
      *(_QWORD *)&v36 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v36 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)__p = v36;
      v61 = v36;
      v58 = v36;
      *(_OWORD *)v59 = v36;
      *(_OWORD *)v56 = v36;
      *(_OWORD *)v57 = v36;
      *(_OWORD *)v54 = v36;
      v55 = v36;
      v53 = v36;
      forceBehaviorFromForceConfig(v34, 34, (uint64_t)&v53);
      MTForceBehaviorConfiguration::addDefaultBehavior((MTForceBehaviorConfiguration *)(*(_QWORD *)(*((_QWORD *)this + 42) + 200) + 264), (const MTForceBehavior *)&v53);
      CFRelease(v35);
      if (__p[1])
      {
        *(void **)&v61 = __p[1];
        operator delete(__p[1]);
      }
      if (v59[0])
      {
        v59[1] = v59[0];
        operator delete(v59[0]);
      }
      if (v57[1])
      {
        *(void **)&v58 = v57[1];
        operator delete(v57[1]);
      }
      if (v56[0])
      {
        v56[1] = v56[0];
        operator delete(v56[0]);
      }
      if (v54[1])
      {
        *(void **)&v55 = v54[1];
        operator delete(v54[1]);
      }
    }
    v37 = *(unsigned __int8 *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this) + 6);
    v38 = MTForceConfigCreate(2, 0);
    if (v38)
    {
      v39 = (const void *)v38;
      if (v37)
      {
        *(_QWORD *)&v40 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v40 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)__p = v40;
        v61 = v40;
        v58 = v40;
        *(_OWORD *)v59 = v40;
        *(_OWORD *)v56 = v40;
        *(_OWORD *)v57 = v40;
        *(_OWORD *)v54 = v40;
        v55 = v40;
        v53 = v40;
        forceBehaviorFromForceConfig(v38, 134, (uint64_t)&v53);
        MTForceBehaviorConfiguration::addDefaultBehavior((MTForceBehaviorConfiguration *)(*(_QWORD *)(*((_QWORD *)this + 42) + 200) + 264), (const MTForceBehavior *)&v53);
        if (__p[1])
        {
          *(void **)&v61 = __p[1];
          operator delete(__p[1]);
        }
        if (v59[0])
        {
          v59[1] = v59[0];
          operator delete(v59[0]);
        }
        if (v57[1])
        {
          *(void **)&v58 = v57[1];
          operator delete(v57[1]);
        }
        if (v56[0])
        {
          v56[1] = v56[0];
          operator delete(v56[0]);
        }
        if (v54[1])
        {
          *(void **)&v55 = v54[1];
          operator delete(v54[1]);
        }
      }
      CFRelease(v39);
    }
    LOBYTE(v53) = -86;
    (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
    v41 = (MTDeviceSupportsSilentClick() || (_BYTE)v53) && *((_DWORD *)v10 + 14) == 0;
    v42 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 864))(this);
    MTForceManagement::setFirstStageClickPreference(*(_QWORD *)(v42 + 200), v31);
    v43 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 864))(this);
    MTForceManagement::setSecondStageClickPreference(*(_QWORD *)(v43 + 200), v32);
    *(_BYTE *)(*(_QWORD *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 864))(this) + 200)
             + 593) = v41;
    *(_BYTE *)(*(_QWORD *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 864))(this) + 200)
             + 596) = v10[64];
    *(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 42) + 200) + 597) = 0;
    v44 = *(MTActuatorManagement **)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 864))(this)
                                   + 208);
    v45 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 864))(this);
    MTActuatorManagement::setFirmwareClicks(v44, v31, *(unsigned __int8 *)(*(_QWORD *)(v45 + 200) + 593));
    Mutable = v50;
    v2 = v51;
  }
  v46 = (_QWORD *)MEMORY[0x24BDBD270];
  if (!v10[15])
    v46 = (_QWORD *)MEMORY[0x24BDBD268];
  (*(void (**)(MTTrackpadHIDManager *, const __CFString *, _QWORD))(*(_QWORD *)this + 568))(this, CFSTR("SupportsGestureScrolling"), *v46);
  (*(void (**)(MTTrackpadHIDManager *, const __CFString *, const __CFString *))(*(_QWORD *)this + 568))(this, CFSTR("DeviceTypeHint"), CFSTR("Trackpad"));
  v47 = CFArrayCreateMutable(v4, 0, MEMORY[0x24BDBD690]);
  v48 = v47;
  if (v10[15])
    CFArrayAppendValue(v47, CFSTR("Scroll"));
  if (v10[16])
    CFArrayAppendValue(v48, CFSTR("Scale"));
  if (v10[17])
    CFArrayAppendValue(v48, CFSTR("Rotate"));
  CFArrayAppendValue(v48, CFSTR("Translate"));
  CFArrayAppendValue(v48, CFSTR("TapToClick"));
  CFArrayAppendValue(v48, CFSTR("TwoFingersSecondaryClick"));
  CFArrayAppendValue(v48, CFSTR("DragLock"));
  CFArrayAppendValue(v48, CFSTR("DoubleTapToDrag"));
  (*(void (**)(MTTrackpadHIDManager *, const __CFString *, __CFArray *))(*(_QWORD *)this + 568))(this, CFSTR("SupportedGestures"), v48);
  CFRelease(v48);
  if (v62)
  {
    CFShow(v62);
    CFRelease(v62);
    v62 = 0;
  }
  CFRelease(v2);
  CFRelease(v3);
  CFRelease(cf);
  CFRelease(v9);
  CFRelease(v8);
  CFRelease(Mutable);
}

void sub_2310A1A00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  MTForceBehavior::~MTForceBehavior((MTForceBehavior *)va);
  _Unwind_Resume(a1);
}

uint64_t MTTrackpadHIDManager::updateEventDispatcherSettings(MTTrackpadHIDManager *this)
{
  uint64_t result;
  unsigned int v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  uint64_t v10;
  char v11;

  result = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 120))(this);
  if (result)
  {
    v3 = *(_DWORD *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this) + 8);
    v4 = *(_DWORD *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this) + 40);
    v5 = v3 & 0xFFFFFFFA | 4;
    if ((v3 & 1) == 0)
      v5 = v3;
    if ((v3 & 2) != 0)
      v5 = v5 & 0xFFFFFFF5 | 8;
    if (v4 == 2)
      v6 = v5;
    else
      v6 = v3;
    v7 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 120))(this);
    *(_BYTE *)(v7 + 432) = *(_BYTE *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this)
                                    + 6);
    *(_DWORD *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 120))(this) + 436) = v6;
    v8 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 120))(this);
    v9 = *(_BYTE *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this) + 33);
    if (v9)
      v9 = *(_BYTE *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this) + 32) != 0;
    *(_BYTE *)(v8 + 532) = v9;
    v10 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 120))(this);
    result = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this);
    v11 = *(_BYTE *)(result + 15);
    if (v11)
    {
      result = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this);
      v11 = *(_BYTE *)(result + 14) != 0;
    }
    *(_BYTE *)(v10 + 540) = v11;
  }
  return result;
}

BOOL MTTrackpadHIDManager::hwSupports3FDrag(MTTrackpadHIDManager *this)
{
  io_registry_entry_t Service;
  const __CFBoolean *CFProperty;
  const __CFBoolean *v3;
  CFTypeID v4;
  _BOOL8 v5;

  if ((*((_BYTE *)this + 160) & 2) != 0)
    return 1;
  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
  Service = MTDeviceGetService();
  CFProperty = (const __CFBoolean *)IORegistryEntryCreateCFProperty(Service, CFSTR("TrackpadThreeFingerDrag"), (CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
  if (!CFProperty)
    return 0;
  v3 = CFProperty;
  v4 = CFGetTypeID(CFProperty);
  v5 = v4 == CFBooleanGetTypeID() && CFBooleanGetValue(v3) != 0;
  CFRelease(v3);
  return v5;
}

BOOL MTTrackpadHIDManager::hwSupportsSecondaryClickCorners(MTTrackpadHIDManager *this)
{
  io_registry_entry_t Service;
  const __CFBoolean *CFProperty;
  const __CFBoolean *v3;
  CFTypeID v4;
  _BOOL8 v5;

  if ((*((_BYTE *)this + 160) & 2) != 0)
    return 1;
  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
  Service = MTDeviceGetService();
  CFProperty = (const __CFBoolean *)IORegistryEntryCreateCFProperty(Service, CFSTR("TrackpadSecondaryClickCorners"), (CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
  if (!CFProperty)
    return 0;
  v3 = CFProperty;
  v4 = CFGetTypeID(CFProperty);
  v5 = v4 == CFBooleanGetTypeID() && CFBooleanGetValue(v3) != 0;
  CFRelease(v3);
  return v5;
}

uint64_t MTTrackpadHIDManager::getTrackpadSettings(MTTrackpadHIDManager *this)
{
  return (uint64_t)this + 212;
}

uint64_t MTTrackpadHIDManager::initDefaultTrackpadSettings(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    *(_DWORD *)(a3 + 64) = 0;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 688))(result);
    *(_BYTE *)a3 = 1;
    *(_QWORD *)(a3 + 12) = 0x101010101010101;
    *(_DWORD *)(a3 + 24) = 16843009;
    *(_DWORD *)(a3 + 27) = 16843009;
    *(_WORD *)(a3 + 31) = 256;
  }
  return result;
}

uint64_t MTTrackpadHIDManager::setPluginDefaultProperties(MTTrackpadHIDManager *this)
{
  io_registry_entry_t Service;
  BOOL v3;
  CFMutableDictionaryRef properties;

  MTSimpleHIDManager::setPluginDefaultProperties(this);
  if ((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this))
  {
    Service = MTDeviceGetService();
    if (Service)
    {
      properties = 0;
      if (IORegistryEntryCreateCFProperties(Service, &properties, (CFAllocatorRef)*MEMORY[0x24BDBD240], 0))
        v3 = 1;
      else
        v3 = properties == 0;
      if (!v3)
      {
        (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 832))(this);
        CFRelease(properties);
      }
    }
  }
  return (*(uint64_t (**)(MTTrackpadHIDManager *, const __CFString *, _QWORD))(*(_QWORD *)this + 568))(this, CFSTR("MTEventSource"), *MEMORY[0x24BDBD270]);
}

const void *MTTrackpadHIDManager::setDeviceAccelerationData(MTTrackpadHIDManager *this, CFDictionaryRef theDict)
{
  const void *Value;
  const void *v5;
  const void *v6;
  const void *v7;
  const __CFNumber *v8;
  const __CFNumber *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *result;
  unint64_t valuePtr;

  Value = CFDictionaryGetValue(theDict, CFSTR("HIDScrollAccelerationType"));
  if (Value)
    (*(void (**)(MTTrackpadHIDManager *, const __CFString *, const void *))(*(_QWORD *)this + 568))(this, CFSTR("HIDScrollAccelerationType"), Value);
  v5 = CFDictionaryGetValue(theDict, CFSTR("HIDPointerAccelerationType"));
  if (v5)
    (*(void (**)(MTTrackpadHIDManager *, const __CFString *, const void *))(*(_QWORD *)this + 568))(this, CFSTR("HIDPointerAccelerationType"), v5);
  v6 = CFDictionaryGetValue(theDict, CFSTR("HIDAccelCurves"));
  if (v6)
    (*(void (**)(MTTrackpadHIDManager *, const __CFString *, const void *))(*(_QWORD *)this + 568))(this, CFSTR("HIDAccelCurves"), v6);
  v7 = CFDictionaryGetValue(theDict, CFSTR("HIDScrollAccelCurves"));
  if (v7)
    (*(void (**)(MTTrackpadHIDManager *, const __CFString *, const void *))(*(_QWORD *)this + 568))(this, CFSTR("HIDScrollAccelCurves"), v7);
  v8 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("HIDPointerReportRate"));
  if (v8)
  {
    v9 = v8;
    valuePtr = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(v8, kCFNumberIntType, &valuePtr);
    (*(void (**)(MTTrackpadHIDManager *, const __CFString *, const __CFNumber *))(*(_QWORD *)this + 568))(this, CFSTR("HIDPointerReportRate"), v9);
  }
  v10 = CFDictionaryGetValue(theDict, CFSTR("HIDScrollResolution"));
  if (v10)
    (*(void (**)(MTTrackpadHIDManager *, const __CFString *, const void *))(*(_QWORD *)this + 568))(this, CFSTR("HIDScrollResolution"), v10);
  v11 = CFDictionaryGetValue(theDict, CFSTR("HIDScrollAccelerationTable"));
  if (v11)
    (*(void (**)(MTTrackpadHIDManager *, const __CFString *, const void *))(*(_QWORD *)this + 568))(this, CFSTR("HIDScrollAccelerationTable"), v11);
  v12 = CFDictionaryGetValue(theDict, CFSTR("HIDPointerAccelerationTable"));
  if (v12)
    (*(void (**)(MTTrackpadHIDManager *, const __CFString *, const void *))(*(_QWORD *)this + 568))(this, CFSTR("HIDPointerAccelerationTable"), v12);
  v13 = CFDictionaryGetValue(theDict, CFSTR("HIDDisallowRemappingOfPrimaryClick"));
  if (v13)
    (*(void (**)(MTTrackpadHIDManager *, const __CFString *, const void *))(*(_QWORD *)this + 568))(this, CFSTR("HIDDisallowRemappingOfPrimaryClick"), v13);
  result = CFDictionaryGetValue(theDict, CFSTR("HIDPointerResolution"));
  if (result)
    return (const void *)(*(uint64_t (**)(MTTrackpadHIDManager *, const __CFString *, const void *))(*(_QWORD *)this + 568))(this, CFSTR("HIDPointerResolution"), result);
  return result;
}

uint64_t MTTrackpadHIDManager::setDeviceDefaultProperties(MTTrackpadHIDManager *this)
{
  MTSimpleHIDManager::setDeviceDefaultProperties(this);
  return (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 744))(this);
}

uint64_t MTTrackpadHIDManager::restoreDevicePropertiesToDevice(MTTrackpadHIDManager *this)
{
  MTSimpleHIDManager::restoreDevicePropertiesToDevice(this);
  return (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 744))(this);
}

void MTTrackpadHIDManager::activateDeviceSurfaceOrientation(dispatch_object_t *this)
{
  NSObject *v2;
  NSObject *v3;
  _QWORD block[7];
  _QWORD v5[3];
  int v6;
  _QWORD v7[3];
  int v8;

  if (((_BYTE)this[20] & 8) != 0)
  {
    v7[0] = 0;
    v7[1] = v7;
    v7[2] = 0x2000000000;
    v8 = -1431655766;
    v8 = *(_DWORD *)(((uint64_t (*)(dispatch_object_t *))(*this)[106].isa)(this) + 40);
    v5[0] = 0;
    v5[1] = v5;
    v5[2] = 0x2000000000;
    v6 = -1431655766;
    v6 = *(_DWORD *)(((uint64_t (*)(dispatch_object_t *))(*this)[106].isa)(this) + 44);
    dispatch_retain(this[22]);
    dispatch_retain(this[23]);
    v3 = this[22];
    v2 = this[23];
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 0x40000000;
    block[2] = ___ZN20MTTrackpadHIDManager32activateDeviceSurfaceOrientationEv_block_invoke;
    block[3] = &unk_24FFF1F48;
    block[5] = v5;
    block[6] = this;
    block[4] = v7;
    dispatch_group_async(v2, v3, block);
    _Block_object_dispose(v5, 8);
    _Block_object_dispose(v7, 8);
  }
}

void sub_2310A213C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void ___ZN20MTTrackpadHIDManager32activateDeviceSurfaceOrientationEv_block_invoke(_QWORD *a1)
{
  dispatch_object_t *v1;

  v1 = (dispatch_object_t *)a1[6];
  ((void (*)(dispatch_object_t *, _QWORD, _QWORD))(*v1)[94].isa)(v1, *(unsigned int *)(*(_QWORD *)(a1[4] + 8) + 24), *(unsigned int *)(*(_QWORD *)(a1[5] + 8) + 24));
  dispatch_release(v1[23]);
  dispatch_release(v1[22]);
}

void MTTrackpadHIDManager::_activateDeviceSurfaceOrientation(uint64_t a1, int a2, int a3)
{
  int v6;
  int v7;
  NSObject *v8;
  int v9;
  int v10;
  NSObject *v11;
  int v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 80))(a1);
  v6 = MTDeviceSetSurfaceOrientation();
  if (v6)
  {
    v7 = v6;
    v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v12 = 136316162;
      v13 = "[Error] ";
      v14 = 2080;
      v15 = "MTTrackpadHIDManager::";
      v16 = 2080;
      v17 = "_activateDeviceSurfaceOrientation";
      v18 = 1024;
      v19 = a2;
      v20 = 1024;
      v21 = v7;
      _os_log_impl(&dword_231071000, v8, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s setting surface orientation to %d returned 0x%08X", (uint8_t *)&v12, 0x2Cu);
    }
  }
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 80))(a1);
  v9 = MTDeviceSetSurfaceOrientationMode();
  if (v9)
  {
    v10 = v9;
    v11 = MTLoggingPlugin();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v12 = 136316162;
      v13 = "[Error] ";
      v14 = 2080;
      v15 = "MTTrackpadHIDManager::";
      v16 = 2080;
      v17 = "_activateDeviceSurfaceOrientation";
      v18 = 1024;
      v19 = a3;
      v20 = 1024;
      v21 = v10;
      _os_log_impl(&dword_231071000, v11, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s setting surface orientation mode to %d returned 0x%08X", (uint8_t *)&v12, 0x2Cu);
    }
  }
}

uint64_t MTTrackpadHIDManager::handleButtonState(uint64_t a1, uint64_t a2, int a3)
{
  MTParser *v4;

  v4 = *(MTParser **)(a1 + 336);
  if (v4 && (*(_BYTE *)(a1 + 160) & 2) != 0)
    MTParser::setDivingButtonState(v4, a3 != 0);
  return 1;
}

uint64_t MTTrackpadHIDManager::forwardScreenSaverLaunchedNotification(MTTrackpadHIDManager *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  return (*(uint64_t (**)(__CFNotificationCenter *, MTTrackpadHIDManager *, __CFNotificationCenter *, void *, const __CFString *, const void *))(*(_QWORD *)a2 + 768))(a2, this, a2, a3, a4, a5);
}

uint64_t MTTrackpadHIDManager::handleScreenSaverLaunchedNotification(MTTrackpadHIDManager *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  uint64_t v7;

  v7 = *((_QWORD *)this + 42);
  if (v7
    && (**(unsigned int (***)(uint64_t, __CFNotificationCenter *, void *, const __CFString *, const void *, const __CFDictionary *))(v7 + 80))(v7 + 80, a2, a3, a4, a5, a6))
  {
    *(_BYTE *)(*((_QWORD *)this + 42) + 89) = 1;
  }
  return 1;
}

uint64_t MTTrackpadHIDManager::forwardSurfaceOrientationChangedNotification(MTTrackpadHIDManager *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  return (*(uint64_t (**)(__CFNotificationCenter *, MTTrackpadHIDManager *, __CFNotificationCenter *, void *, const __CFString *, const void *))(*(_QWORD *)a2 + 776))(a2, this, a2, a3, a4, a5);
}

uint64_t MTTrackpadHIDManager::handleSurfaceOrientationChangedNotification(MTTrackpadHIDManager *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  (*(void (**)(MTTrackpadHIDManager *, __CFNotificationCenter *, void *, const __CFString *, const void *, const __CFDictionary *))(*(_QWORD *)this + 736))(this, a2, a3, a4, a5, a6);
  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 744))(this);
  (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 712))(this);
  return 1;
}

__CFDictionary *MTTrackpadHIDManager::createDefaultMotionSensitivitiesDictionary(MTTrackpadHIDManager *this)
{
  const __CFAllocator *v1;
  const CFDictionaryKeyCallBacks *v2;
  const CFDictionaryValueCallBacks *v3;
  __CFDictionary *Mutable;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  __CFDictionary *v8;
  __CFDictionary *v9;
  BOOL v10;
  CFNumberRef v11;
  CFNumberRef v12;
  CFNumberRef v13;
  __CFDictionary *v14;
  __CFDictionary *v15;
  CFNumberRef v16;
  CFNumberRef v17;
  CFNumberRef v18;
  CFNumberRef v19;
  __CFDictionary *v20;
  __CFDictionary *v21;
  CFNumberRef v22;
  CFNumberRef v23;
  __CFDictionary *v24;
  __CFDictionary *v25;
  CFNumberRef v26;
  CFNumberRef v27;
  CFNumberRef v28;
  __CFDictionary *v29;
  __CFDictionary *v30;
  CFNumberRef v31;
  CFNumberRef v32;
  CFNumberRef v33;
  CFNumberRef v34;
  CFNumberRef v35;
  CFNumberRef v36;
  __CFDictionary *v37;
  __CFDictionary *v38;
  CFNumberRef v39;
  CFNumberRef v40;
  CFNumberRef v41;
  CFNumberRef v42;
  CFNumberRef v43;
  CFNumberRef v44;
  __CFDictionary *v45;
  __CFDictionary *v46;
  CFNumberRef v47;
  CFNumberRef v48;
  CFNumberRef v49;
  CFNumberRef v50;
  CFNumberRef v51;
  CFNumberRef v52;
  __CFDictionary *v53;
  __CFDictionary *v54;
  CFNumberRef v55;
  CFNumberRef v56;
  CFNumberRef v57;
  CFNumberRef v58;
  CFNumberRef v59;
  CFNumberRef v60;
  __CFDictionary *v61;
  __CFDictionary *v62;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int valuePtr;

  v1 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v2 = (const CFDictionaryKeyCallBacks *)MEMORY[0x24BDBD6A0];
  v3 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v72 = 1094713344;
  valuePtr = 1137180672;
  v71 = 1031127695;
  v5 = CFNumberCreate(v1, kCFNumberFloat32Type, &valuePtr);
  v6 = CFNumberCreate(v1, kCFNumberFloat32Type, &v72);
  v7 = CFNumberCreate(v1, kCFNumberFloat32Type, &v71);
  v8 = CFDictionaryCreateMutable(v1, 0, v2, v3);
  v9 = v8;
  if (v5)
    v10 = v8 == 0;
  else
    v10 = 1;
  if (v10)
  {
    if (!v5)
    {
      if (!v6)
        goto LABEL_9;
      goto LABEL_8;
    }
  }
  else
  {
    CFDictionaryRemoveAllValues(v8);
    CFDictionaryAddValue(v9, CFSTR("Resolution_dpi"), v5);
    CFDictionaryAddValue(v9, CFSTR("AccelThresh"), v6);
    CFDictionaryAddValue(v9, CFSTR("AccelPower"), v7);
    CFDictionaryAddValue(Mutable, CFSTR("Resting Accel Tracking"), v9);
  }
  CFRelease(v5);
  if (v6)
LABEL_8:
    CFRelease(v6);
LABEL_9:
  if (v7)
    CFRelease(v7);
  if (v9)
    CFRelease(v9);
  v71 = 0;
  v11 = CFNumberCreate(v1, kCFNumberFloat32Type, &valuePtr);
  v12 = CFNumberCreate(v1, kCFNumberFloat32Type, &v72);
  v13 = CFNumberCreate(v1, kCFNumberFloat32Type, &v71);
  v14 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v15 = v14;
  if (v11 && v14)
  {
    CFDictionaryRemoveAllValues(v14);
    CFDictionaryAddValue(v15, CFSTR("Resolution_dpi"), v11);
    CFDictionaryAddValue(v15, CFSTR("AccelThresh"), v12);
    CFDictionaryAddValue(v15, CFSTR("AccelPower"), v13);
    CFDictionaryAddValue(Mutable, CFSTR("Tracking"), v15);
  }
  else if (!v11)
  {
    goto LABEL_20;
  }
  CFRelease(v11);
LABEL_20:
  if (v12)
    CFRelease(v12);
  if (v13)
    CFRelease(v13);
  if (v15)
    CFRelease(v15);
  v70 = valuePtr;
  v69 = 1045220557;
  v16 = CFNumberCreate(v1, kCFNumberFloat32Type, &v70);
  v17 = CFNumberCreate(v1, kCFNumberFloat32Type, &v72);
  v18 = CFNumberCreate(v1, kCFNumberFloat32Type, &v71);
  v19 = CFNumberCreate(v1, kCFNumberFloat32Type, &v69);
  v20 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v21 = v20;
  if (v16 && v20)
  {
    CFDictionaryRemoveAllValues(v20);
    CFDictionaryAddValue(v21, CFSTR("Resolution_dpi"), v16);
    CFDictionaryAddValue(v21, CFSTR("AccelThresh"), v17);
    CFDictionaryAddValue(v21, CFSTR("AccelPower"), v18);
    CFDictionaryAddValue(v21, CFSTR("CommitMultiplier"), v19);
    CFDictionaryAddValue(Mutable, CFSTR("Scrolling"), v21);
  }
  else if (!v16)
  {
    goto LABEL_31;
  }
  CFRelease(v16);
LABEL_31:
  if (v17)
    CFRelease(v17);
  if (v18)
    CFRelease(v18);
  if (v19)
    CFRelease(v19);
  if (v21)
    CFRelease(v21);
  v68 = v70;
  v69 = 1032268546;
  v22 = CFNumberCreate(v1, kCFNumberFloat32Type, &v68);
  v23 = CFNumberCreate(v1, kCFNumberFloat32Type, &v69);
  v24 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v25 = v24;
  if (v22 && v24)
  {
    CFDictionaryRemoveAllValues(v24);
    CFDictionaryAddValue(v25, CFSTR("Resolution_dpi"), v22);
    CFDictionaryAddValue(v25, CFSTR("CommitMultiplier"), v23);
    CFDictionaryAddValue(v25, CFSTR("Acceleration"), CFSTR("System"));
    CFDictionaryAddValue(Mutable, CFSTR("Zooming"), v25);
  }
  else if (!v22)
  {
    goto LABEL_44;
  }
  CFRelease(v22);
LABEL_44:
  if (v23)
    CFRelease(v23);
  if (v25)
    CFRelease(v25);
  v67 = 1077936128;
  v71 = 1036831949;
  v72 = 1097859072;
  v26 = CFNumberCreate(v1, kCFNumberFloat32Type, &v67);
  v27 = CFNumberCreate(v1, kCFNumberFloat32Type, &v72);
  v28 = CFNumberCreate(v1, kCFNumberFloat32Type, &v71);
  v29 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v30 = v29;
  if (v26 && v27 && v28 && v29)
  {
    CFDictionaryRemoveAllValues(v29);
    CFDictionaryAddValue(v30, CFSTR("Resolution_mm"), v26);
    CFDictionaryAddValue(v30, CFSTR("AccelThresh"), v27);
    CFDictionaryAddValue(v30, CFSTR("AccelPower"), v28);
    CFDictionaryAddValue(Mutable, CFSTR("Command"), v30);
  }
  else if (!v26)
  {
    goto LABEL_55;
  }
  CFRelease(v26);
LABEL_55:
  if (v27)
    CFRelease(v27);
  if (v28)
    CFRelease(v28);
  if (v30)
    CFRelease(v30);
  v71 = 1045220557;
  v72 = 1097859072;
  v66 = 0x40000000;
  v67 = 1086324736;
  v64 = 1056964608;
  v65 = 1115815936;
  v31 = CFNumberCreate(v1, kCFNumberFloat32Type, &v67);
  v32 = CFNumberCreate(v1, kCFNumberFloat32Type, &v72);
  v33 = CFNumberCreate(v1, kCFNumberFloat32Type, &v71);
  v34 = CFNumberCreate(v1, kCFNumberFloat32Type, &v66);
  v35 = CFNumberCreate(v1, kCFNumberFloat32Type, &v65);
  v36 = CFNumberCreate(v1, kCFNumberFloat32Type, &v64);
  v37 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v38 = v37;
  if (v31 && v32 && v33 && v34 && v35 && v36)
  {
    CFDictionaryRemoveAllValues(v37);
    CFDictionaryAddValue(v38, CFSTR("Resolution_mm"), v31);
    CFDictionaryAddValue(v38, CFSTR("AccelThresh"), v32);
    CFDictionaryAddValue(v38, CFSTR("AccelPower"), v33);
    CFDictionaryAddValue(v38, CFSTR("FluidAnimationStartThreshold_mm"), v34);
    CFDictionaryAddValue(v38, CFSTR("FluidSwipeCompleteThreshold_mm"), v35);
    CFDictionaryAddValue(v38, CFSTR("FluidSwipeInertiaTime_s"), v36);
    CFDictionaryAddValue(Mutable, CFSTR("Swipe"), v38);
  }
  else if (!v31)
  {
    goto LABEL_70;
  }
  CFRelease(v31);
LABEL_70:
  if (v32)
    CFRelease(v32);
  if (v33)
    CFRelease(v33);
  if (v34)
    CFRelease(v34);
  if (v35)
    CFRelease(v35);
  if (v36)
    CFRelease(v36);
  if (v38)
    CFRelease(v38);
  v71 = 1045220557;
  v72 = 1097859072;
  v66 = 1077936128;
  v67 = 1090519040;
  v64 = 1056964608;
  v65 = 1107296256;
  v39 = CFNumberCreate(v1, kCFNumberFloat32Type, &v67);
  v40 = CFNumberCreate(v1, kCFNumberFloat32Type, &v72);
  v41 = CFNumberCreate(v1, kCFNumberFloat32Type, &v71);
  v42 = CFNumberCreate(v1, kCFNumberFloat32Type, &v66);
  v43 = CFNumberCreate(v1, kCFNumberFloat32Type, &v65);
  v44 = CFNumberCreate(v1, kCFNumberFloat32Type, &v64);
  v45 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v46 = v45;
  if (v39 && v40 && v41 && v42 && v43 && v44)
  {
    CFDictionaryRemoveAllValues(v45);
    CFDictionaryAddValue(v46, CFSTR("Resolution_mm"), v39);
    CFDictionaryAddValue(v46, CFSTR("AccelThresh"), v40);
    CFDictionaryAddValue(v46, CFSTR("AccelPower"), v41);
    CFDictionaryAddValue(v46, CFSTR("FluidAnimationStartThreshold_mm"), v42);
    CFDictionaryAddValue(v46, CFSTR("FluidSwipeCompleteThreshold_mm"), v43);
    CFDictionaryAddValue(v46, CFSTR("FluidSwipeInertiaTime_s"), v44);
    CFDictionaryAddValue(Mutable, CFSTR("Polar Swipe"), v46);
  }
  else if (!v39)
  {
    goto LABEL_91;
  }
  CFRelease(v39);
LABEL_91:
  if (v40)
    CFRelease(v40);
  if (v41)
    CFRelease(v41);
  if (v42)
    CFRelease(v42);
  if (v43)
    CFRelease(v43);
  if (v44)
    CFRelease(v44);
  if (v46)
    CFRelease(v46);
  v71 = 1045220557;
  v72 = 1097859072;
  v66 = 0x40000000;
  v67 = 1077936128;
  v64 = 1050253722;
  v65 = 1106247680;
  v47 = CFNumberCreate(v1, kCFNumberFloat32Type, &v67);
  v48 = CFNumberCreate(v1, kCFNumberFloat32Type, &v72);
  v49 = CFNumberCreate(v1, kCFNumberFloat32Type, &v71);
  v50 = CFNumberCreate(v1, kCFNumberFloat32Type, &v66);
  v51 = CFNumberCreate(v1, kCFNumberFloat32Type, &v65);
  v52 = CFNumberCreate(v1, kCFNumberFloat32Type, &v64);
  v53 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v54 = v53;
  if (v47 && v48 && v49 && v50 && v51 && v52)
  {
    CFDictionaryRemoveAllValues(v53);
    CFDictionaryAddValue(v54, CFSTR("Resolution_mm"), v47);
    CFDictionaryAddValue(v54, CFSTR("AccelThresh"), v48);
    CFDictionaryAddValue(v54, CFSTR("AccelPower"), v49);
    CFDictionaryAddValue(v54, CFSTR("FluidAnimationStartThreshold_mm"), v50);
    CFDictionaryAddValue(v54, CFSTR("FluidSwipeCompleteThreshold_mm"), v51);
    CFDictionaryAddValue(v54, CFSTR("FluidSwipeInertiaTime_s"), v52);
    CFDictionaryAddValue(Mutable, CFSTR("Edge Swipe"), v54);
  }
  else if (!v47)
  {
    goto LABEL_112;
  }
  CFRelease(v47);
LABEL_112:
  if (v48)
    CFRelease(v48);
  if (v49)
    CFRelease(v49);
  if (v50)
    CFRelease(v50);
  if (v51)
    CFRelease(v51);
  if (v52)
    CFRelease(v52);
  if (v54)
    CFRelease(v54);
  v66 = 1077936128;
  v67 = 1077936128;
  v71 = 1045220557;
  v72 = 1097859072;
  v64 = 1050253722;
  v65 = 1106247680;
  v55 = CFNumberCreate(v1, kCFNumberFloat32Type, &v67);
  v56 = CFNumberCreate(v1, kCFNumberFloat32Type, &v72);
  v57 = CFNumberCreate(v1, kCFNumberFloat32Type, &v71);
  v58 = CFNumberCreate(v1, kCFNumberFloat32Type, &v66);
  v59 = CFNumberCreate(v1, kCFNumberFloat32Type, &v65);
  v60 = CFNumberCreate(v1, kCFNumberFloat32Type, &v64);
  v61 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v62 = v61;
  if (v55 && v56 && v57 && v58 && v59 && v60)
  {
    CFDictionaryRemoveAllValues(v61);
    CFDictionaryAddValue(v62, CFSTR("Resolution_mm"), v55);
    CFDictionaryAddValue(v62, CFSTR("AccelThresh"), v56);
    CFDictionaryAddValue(v62, CFSTR("AccelPower"), v57);
    CFDictionaryAddValue(v62, CFSTR("FluidAnimationStartThreshold_mm"), v58);
    CFDictionaryAddValue(v62, CFSTR("FluidSwipeCompleteThreshold_mm"), v59);
    CFDictionaryAddValue(v62, CFSTR("FluidSwipeInertiaTime_s"), v60);
    CFDictionaryAddValue(Mutable, CFSTR("Edge Scroll"), v62);
  }
  else if (!v55)
  {
    goto LABEL_133;
  }
  CFRelease(v55);
LABEL_133:
  if (v56)
    CFRelease(v56);
  if (v57)
    CFRelease(v57);
  if (v58)
    CFRelease(v58);
  if (v59)
    CFRelease(v59);
  if (v60)
    CFRelease(v60);
  if (v62)
    CFRelease(v62);
  return Mutable;
}

CFNumberRef MTTrackpadHIDManager::copyProperty(MTTrackpadHIDManager *this, const __CFString *a2)
{
  int v4;
  CFDictionaryRef v5;
  const __CFDictionary *v6;
  CFTypeID v7;
  const __CFAllocator *v8;
  CFIndex Count;
  __CFDictionary *MutableCopy;
  __CFDictionary *Mutable;
  _BOOL4 HostClickControlEnabled;
  const void **v13;
  uint64_t v14;
  CFNumberRef v15;
  CFNumberRef v16;
  uint64_t v17;
  int v19;
  _DWORD v20[2];
  char valuePtr;

  v4 = MTSimpleHIDManager::propertyTypeFromString((uint64_t)a2, a2);
  if (v4 != 17)
  {
    if (v4 == 73)
    {
      v5 = MTSimpleHIDManager::copyProperty((CFDictionaryRef *)this, a2);
      if (!v5)
        return 0;
      v6 = v5;
      v7 = CFGetTypeID(v5);
      if (v7 != CFDictionaryGetTypeID())
        return v6;
      v8 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
      Count = CFDictionaryGetCount(v6);
      MutableCopy = CFDictionaryCreateMutableCopy(v8, Count + 1, v6);
      CFDictionarySetValue(MutableCopy, CFSTR("Trackpad HID pref"), *((const void **)this + 43));
      if (*((_QWORD *)this + 42))
      {
        Mutable = CFDictionaryCreateMutable(v8, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
        HostClickControlEnabled = MTParser::getHostClickControlEnabled(*((MTParser **)this + 42));
        v13 = (const void **)MEMORY[0x24BDBD270];
        if (!HostClickControlEnabled)
          v13 = (const void **)MEMORY[0x24BDBD268];
        CFDictionarySetValue(Mutable, CFSTR("Parser"), *v13);
        valuePtr = -86;
        v20[1] = -1431655766;
        (*(void (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 80))(this);
        MTDeviceGetMTActuator();
        MTActuatorGetReport();
        CFDictionarySetValue(MutableCopy, CFSTR("Host Click Mode"), Mutable);
        CFRelease(Mutable);
      }
      v14 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 120))(this);
      if (v14)
      {
        v20[0] = *(_DWORD *)(v14 + 536);
        v15 = CFNumberCreate(v8, kCFNumberFloatType, v20);
        if (v15)
        {
          v16 = v15;
          CFDictionarySetValue(MutableCopy, CFSTR("Scroll Momentum Dispatch Rate"), v15);
          CFRelease(v16);
        }
      }
      CFRelease(v6);
      return MutableCopy;
    }
    return MTSimpleHIDManager::copyProperty((CFDictionaryRef *)this, a2);
  }
  v17 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 120))(this);
  if (!v17)
    return MTSimpleHIDManager::copyProperty((CFDictionaryRef *)this, a2);
  v19 = *(_DWORD *)(v17 + 536);
  return CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberFloatType, &v19);
}

MTPListGestureConfig *MTTrackpadHIDManager::createDefaultActionEventsDictionary(MTTrackpadHIDManager *this)
{
  MTPListGestureConfig *Mutable;
  const __CFString *v2;
  const __CFString *v3;
  const __CFString *v4;
  const __CFString *v5;
  const __CFString *v6;
  const __CFString *v7;
  const __CFString *v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  const __CFString *v12;
  const __CFString *v13;
  const __CFString *v14;
  const __CFString *v15;
  const __CFString *v16;
  const __CFString *v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *v20;
  const __CFString *v21;
  const __CFString *v22;
  const __CFString *v23;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Point"), CFSTR("Mouse Point"), 0, 0, v2);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Drag"), CFSTR("Mouse Drag"), CFSTR("Button1"), 0, v3);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Click"), CFSTR("Mouse Click"), CFSTR("Button1"), 0, v4);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Double Click"), CFSTR("Mouse Double Click"), CFSTR("Button1"), 0, v5);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Primary Down"), CFSTR("Mouse Down"), CFSTR("Button1"), 0, v6);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Primary Up"), CFSTR("Mouse Up"), CFSTR("Button1"), 0, v7);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Secondary Click"), CFSTR("Mouse Click"), CFSTR("Button2"), 0, v8);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Scroll"), CFSTR("Scroll"), 0, 0, v9);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Scroll To Edge"), CFSTR("Scroll To Edge"), 0, 0, v10);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Orientation"), CFSTR("Orientation"), 0, 0, v11);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Zoom Toggle"), CFSTR("Zoom Toggle"), 0, 0, v12);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Gesture Started"), CFSTR("Gesture Started"), 0, 0, v13);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Gesture Ended"), CFSTR("Gesture Ended"), 0, 0, v14);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Fluid Navigation"), CFSTR("Fluid Navigation"), 0, 0, v15);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Fluid Notification"), CFSTR("Fluid Notification"), 0, 0, v16);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Fluid Notification Alt"), CFSTR("Fluid Notification Alt"), 0, 0, v17);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Fluid Dock"), CFSTR("Fluid Dock"), 0, 0, v18);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Show Definition"), CFSTR("Show Definition"), 0, 0, v19);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Swipe Left"), CFSTR("Swipe"), 0, 0, v20);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Swipe Right"), CFSTR("Swipe"), 0, 0, v21);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Swipe Up"), CFSTR("Swipe"), 0, 0, v22);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Swipe Down"), CFSTR("Swipe"), 0, 0, v23);
  return Mutable;
}

__CFDictionary *MTTrackpadHIDManager::createDefaultGestureSetsDictionary(MTTrackpadHIDManager *this)
{
  const __CFAllocator *v2;
  const CFDictionaryKeyCallBacks *v3;
  const CFDictionaryValueCallBacks *v4;
  __CFDictionary *Mutable;
  CFMutableArrayRef v6;
  __CFDictionary *v7;
  BOOL v8;
  __CFDictionary *v9;
  MTPListGestureConfig *v10;
  CFMutableDictionaryRef v11;
  BOOL v12;
  __CFDictionary *v13;
  MTPListGestureConfig *v14;
  CFMutableDictionaryRef v15;
  BOOL v16;
  __CFDictionary *v17;
  MTPListGestureConfig *v18;
  CFMutableDictionaryRef v19;
  BOOL v20;
  __CFDictionary *v21;
  MTPListGestureConfig *v22;
  CFMutableDictionaryRef v23;
  __CFDictionary *v24;
  const __CFString *v25;
  MTPListGestureConfig *v26;
  CFMutableDictionaryRef v27;
  __CFDictionary *v28;
  MTPListGestureConfig *v29;
  CFMutableDictionaryRef v30;
  __CFDictionary *v31;
  MTPListGestureConfig *v32;
  CFMutableDictionaryRef v33;
  __CFDictionary *v34;
  MTPListGestureConfig *v35;
  CFMutableDictionaryRef v36;
  __CFDictionary *v37;
  MTPListGestureConfig *v38;
  CFMutableDictionaryRef v39;
  __CFDictionary *v40;
  const void *v42;
  const void *v43;
  const void *v44;
  const void *v45;
  const void *v46;
  const void *v47;
  const void *v48;
  const void *v49;
  const void *v50;
  const void *v51;
  int valuePtr;

  v2 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x24BDBD6A0];
  v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v6 = CFArrayCreateMutable(v2, 0, MEMORY[0x24BDBD690]);
  v7 = CFDictionaryCreateMutable(v2, 0, v3, v4);
  if (v6)
    v8 = v7 == 0;
  else
    v8 = 1;
  if (!v8)
  {
    v9 = v7;
    CFDictionaryAddValue(v7, CFSTR("Gestures"), v6);
    CFDictionaryAddValue(v9, CFSTR("Transitions"), CFSTR("ToMoreFingers FromFewerFingers FromMoreFingers"));
    CFDictionaryAddValue(Mutable, CFSTR("None"), v9);
    CFRelease(v6);
    CFRelease(v9);
  }
  v10 = CFArrayCreateMutable(v2, 0, MEMORY[0x24BDBD690]);
  v11 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (v10)
    v12 = v11 == 0;
  else
    v12 = 1;
  if (!v12)
  {
    v13 = v11;
    MTPListGestureConfig::addGestureToArray(v10, (__CFArray *)CFSTR("Point"), CFSTR("Translate"), CFSTR("Tracking"), CFSTR("Repetitive"), 0, 0, 0, v42);
    CFDictionaryAddValue(v13, CFSTR("Gestures"), v10);
    CFDictionaryAddValue(v13, CFSTR("Transitions"), CFSTR("ToMoreFingers FromMoreFingers FromMoreWithSlightIntegrationDelay AccelOnlyIfSomeResting"));
    CFDictionaryAddValue(Mutable, CFSTR("Point"), v13);
    CFRelease(v10);
    CFRelease(v13);
  }
  v14 = CFArrayCreateMutable(v2, 0, MEMORY[0x24BDBD690]);
  v15 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (v14)
    v16 = v15 == 0;
  else
    v16 = 1;
  if (!v16)
  {
    v17 = v15;
    MTPListGestureConfig::addGestureToArray(v14, (__CFArray *)CFSTR("Point"), CFSTR("Translate"), CFSTR("Tracking"), CFSTR("Repetitive"), 0, 0, 0, v42);
    MTPListGestureConfig::addGestureToArray(v14, (__CFArray *)CFSTR("Click"), CFSTR("Tap"), 0, 0, 0, 0, 0, v43);
    CFDictionaryAddValue(v17, CFSTR("Gestures"), v14);
    CFDictionaryAddValue(v17, CFSTR("Transitions"), CFSTR("ToMoreFingers FromMoreFingers FromMoreWithSlightIntegrationDelay AccelOnlyIfSomeResting"));
    CFDictionaryAddValue(Mutable, CFSTR("Point & Click"), v17);
    CFRelease(v14);
    CFRelease(v17);
  }
  v18 = CFArrayCreateMutable(v2, 0, MEMORY[0x24BDBD690]);
  v19 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (v18)
    v20 = v19 == 0;
  else
    v20 = 1;
  if (!v20)
  {
    v21 = v19;
    MTPListGestureConfig::addGestureToArray(v18, (__CFArray *)CFSTR("Point"), CFSTR("Translate"), CFSTR("Tracking"), CFSTR("Repetitive"), 0, 0, 0, v42);
    MTPListGestureConfig::addGestureToArray(v18, (__CFArray *)CFSTR("Primary Down"), CFSTR("Tap"), 0, 0, 0, 0, 0, v44);
    CFDictionaryAddValue(v21, CFSTR("Gestures"), v18);
    CFDictionaryAddValue(v21, CFSTR("Transitions"), CFSTR("ToMoreFingers FromMoreFingers FromMoreWithSlightIntegrationDelay"));
    CFDictionaryAddValue(Mutable, CFSTR("Point, Click & Drag"), v21);
    CFRelease(v18);
    CFRelease(v21);
  }
  v22 = CFArrayCreateMutable(v2, 0, MEMORY[0x24BDBD690]);
  v23 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (v22)
  {
    v24 = v23;
    if (v23)
    {
      if (*(_BYTE *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this) + 1))
      {
        if (!*(_BYTE *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this) + 19))
          MTPListGestureConfig::addGestureToArray(v22, (__CFArray *)CFSTR("Click"), CFSTR("Tap"), 0, 0, 0, 0, 0, v42);
        MTPListGestureConfig::addGestureToArray(v22, (__CFArray *)CFSTR("Click"), CFSTR("DroppedFingerTap"), 0, 0, 0, 0, 0, v42);
      }
      if (*(_BYTE *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(_QWORD *)this + 848))(this) + 19))
        MTPListGestureConfig::addGestureToArray(v22, (__CFArray *)CFSTR("Show Definition"), CFSTR("Tap"), 0, 0, 0, 0, 0, v42);
      valuePtr = 1138819072;
      v25 = (const __CFString *)CFNumberCreate(v2, kCFNumberFloat32Type, &valuePtr);
      MTPListGestureConfig::addGestureToArray(v22, (__CFArray *)CFSTR("Primary Down"), CFSTR("Hold"), 0, CFSTR("TimeHeld BeginSlide"), 0, CFSTR("HoldTime"), v25, v42);
      CFRelease(v25);
      MTPListGestureConfig::addGestureToArray(v22, (__CFArray *)CFSTR("Drag"), CFSTR("Translate"), CFSTR("Scrolling"), CFSTR("Momentum"), 0, 0, 0, v45);
      MTPListGestureConfig::addGestureToArray(v22, (__CFArray *)CFSTR("Primary Up"), CFSTR("Lift"), 0, 0, 0, 0, 0, v46);
      CFDictionaryAddValue(v24, CFSTR("Gestures"), v22);
      CFDictionaryAddValue(v24, CFSTR("Transitions"), CFSTR("ToFewerFingers FromFewerIfPause MultiFingerDrag "));
      CFDictionaryAddValue(Mutable, CFSTR("Drag & Click"), v24);
      CFRelease(v22);
      CFRelease(v24);
    }
  }
  v26 = CFArrayCreateMutable(v2, 0, MEMORY[0x24BDBD690]);
  v27 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (v26)
  {
    v28 = v27;
    if (v27)
    {
      MTPListGestureConfig::addGestureToArray(v26, (__CFArray *)CFSTR("Scroll"), CFSTR("Translate"), CFSTR("Scrolling"), CFSTR("Repetitive"), 0, 0, 0, v42);
      CFDictionaryAddValue(v28, CFSTR("Gestures"), v26);
      CFDictionaryAddValue(v28, CFSTR("Transitions"), CFSTR("ToFewerFingers FromFewerIfPause"));
      CFDictionaryAddValue(Mutable, CFSTR("Scroll"), v28);
      CFRelease(v26);
      CFRelease(v28);
    }
  }
  v29 = CFArrayCreateMutable(v2, 0, MEMORY[0x24BDBD690]);
  v30 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (v29)
  {
    v31 = v30;
    if (v30)
    {
      MTPListGestureConfig::addGestureToArray(v29, (__CFArray *)CFSTR("Scroll"), CFSTR("Translate"), CFSTR("Scrolling"), CFSTR("Repetitive"), 0, 0, 0, v42);
      MTPListGestureConfig::addGestureToArray(v29, (__CFArray *)CFSTR("Secondary Click"), CFSTR("Tap"), 0, 0, 0, 0, 0, v47);
      CFDictionaryAddValue(v31, CFSTR("Gestures"), v29);
      CFDictionaryAddValue(v31, CFSTR("Transitions"), CFSTR("ToFewerFingers FromFewerIfPause"));
      CFDictionaryAddValue(Mutable, CFSTR("Scroll & Secondary Click"), v31);
      CFRelease(v29);
      CFRelease(v31);
    }
  }
  v32 = CFArrayCreateMutable(v2, 0, MEMORY[0x24BDBD690]);
  v33 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (v32)
  {
    v34 = v33;
    if (v33)
    {
      MTPListGestureConfig::addGestureToArray(v32, (__CFArray *)CFSTR("Scroll"), CFSTR("Translate"), CFSTR("Scrolling"), CFSTR("Repetitive"), CFSTR("LockOnFirst"), 0, 0, v42);
      MTPListGestureConfig::addGestureToArray(v32, (__CFArray *)CFSTR("Orientation"), CFSTR("Scale+Rotate"), CFSTR("Zooming"), CFSTR("Repetitive"), CFSTR("LockOnFirst"), 0, 0, v48);
      CFDictionaryAddValue(v34, CFSTR("Gestures"), v32);
      CFDictionaryAddValue(v34, CFSTR("Transitions"), CFSTR("ToFewerFingers FromFewerIfPause"));
      CFDictionaryAddValue(Mutable, CFSTR("Scroll, Zoom & Rotate"), v34);
      CFRelease(v32);
      CFRelease(v34);
    }
  }
  v35 = CFArrayCreateMutable(v2, 0, MEMORY[0x24BDBD690]);
  v36 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (v35)
  {
    v37 = v36;
    if (v36)
    {
      MTPListGestureConfig::addGestureToArray(v35, (__CFArray *)CFSTR("Orientation"), CFSTR("Scale+Rotate"), CFSTR("Zooming"), CFSTR("Repetitive"), 0, 0, 0, v42);
      CFDictionaryAddValue(v37, CFSTR("Gestures"), v35);
      CFDictionaryAddValue(v37, CFSTR("Transitions"), CFSTR("ToFewerFingers FromFewerFingers"));
      CFDictionaryAddValue(Mutable, CFSTR("Zoom & Rotate"), v37);
      CFRelease(v35);
      CFRelease(v37);
    }
  }
  v38 = CFArrayCreateMutable(v2, 0, MEMORY[0x24BDBD690]);
  v39 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (v38)
  {
    v40 = v39;
    if (v39)
    {
      MTPListGestureConfig::addGestureToArray(v38, (__CFArray *)CFSTR("Swipe Left"), CFSTR("Left"), CFSTR("Swipe"), CFSTR("OncePerDirection OnlyIfAllMoving"), 0, 0, 0, v42);
      MTPListGestureConfig::addGestureToArray(v38, (__CFArray *)CFSTR("Swipe Right"), CFSTR("Right"), CFSTR("Swipe"), CFSTR("OncePerDirection OnlyIfAllMoving"), 0, 0, 0, v49);
      MTPListGestureConfig::addGestureToArray(v38, (__CFArray *)CFSTR("Swipe Up"), CFSTR("Up"), CFSTR("Swipe"), CFSTR("OncePerDirection OnlyIfAllMoving"), 0, 0, 0, v50);
      MTPListGestureConfig::addGestureToArray(v38, (__CFArray *)CFSTR("Swipe Down"), CFSTR("Down"), CFSTR("Swipe"), CFSTR("OncePerDirection OnlyIfAllMoving"), 0, 0, 0, v51);
      CFDictionaryAddValue(v40, CFSTR("Transitions"), CFSTR("FromMoreFingers ToMoreFingers ToFewerAfterSlightDelay FromFewerFingers FromMoreWithSlightIntegrationDelay"));
      CFDictionaryAddValue(v40, CFSTR("Gestures"), v38);
      CFDictionaryAddValue(Mutable, CFSTR("Swipes"), v40);
      CFRelease(v38);
      CFRelease(v40);
    }
  }
  return Mutable;
}

void MTTrackpadHIDManager::~MTTrackpadHIDManager(MTTrackpadHIDManager *this)
{
  MTSimpleHIDManager::~MTSimpleHIDManager(this);
  JUMPOUT(0x2348D0034);
}

void MTForceBehavior::addSkippedActivationStage(_QWORD *a1, int a2)
{
  uint64_t v4;
  unint64_t v5;
  char *v6;
  _DWORD *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  int v16;

  v4 = (uint64_t)(a1 + 8);
  v5 = a1[8];
  v6 = (char *)a1[7];
  if ((unint64_t)v6 >= v5)
  {
    v8 = (char *)a1[6];
    v9 = (v6 - v8) >> 2;
    if ((unint64_t)(v9 + 1) >> 62)
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    v10 = v5 - (_QWORD)v8;
    v11 = (uint64_t)(v5 - (_QWORD)v8) >> 1;
    if (v11 <= v9 + 1)
      v11 = v9 + 1;
    if (v10 >= 0x7FFFFFFFFFFFFFFCLL)
      v12 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v12);
      v8 = (char *)a1[6];
      v6 = (char *)a1[7];
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[4 * v9];
    v15 = &v13[4 * v12];
    *(_DWORD *)v14 = a2;
    v7 = v14 + 4;
    while (v6 != v8)
    {
      v16 = *((_DWORD *)v6 - 1);
      v6 -= 4;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    a1[6] = v14;
    a1[7] = v7;
    a1[8] = v15;
    if (v8)
      operator delete(v8);
  }
  else
  {
    *(_DWORD *)v6 = a2;
    v7 = v6 + 4;
  }
  a1[7] = v7;
}

void MTForceBehavior::addSkippedReleaseStage(_QWORD *a1, int a2)
{
  uint64_t v4;
  unint64_t v5;
  char *v6;
  _DWORD *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  int v16;

  v4 = (uint64_t)(a1 + 11);
  v5 = a1[11];
  v6 = (char *)a1[10];
  if ((unint64_t)v6 >= v5)
  {
    v8 = (char *)a1[9];
    v9 = (v6 - v8) >> 2;
    if ((unint64_t)(v9 + 1) >> 62)
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    v10 = v5 - (_QWORD)v8;
    v11 = (uint64_t)(v5 - (_QWORD)v8) >> 1;
    if (v11 <= v9 + 1)
      v11 = v9 + 1;
    if (v10 >= 0x7FFFFFFFFFFFFFFCLL)
      v12 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v12);
      v8 = (char *)a1[9];
      v6 = (char *)a1[10];
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[4 * v9];
    v15 = &v13[4 * v12];
    *(_DWORD *)v14 = a2;
    v7 = v14 + 4;
    while (v6 != v8)
    {
      v16 = *((_DWORD *)v6 - 1);
      v6 -= 4;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    a1[9] = v14;
    a1[10] = v7;
    a1[11] = v15;
    if (v8)
      operator delete(v8);
  }
  else
  {
    *(_DWORD *)v6 = a2;
    v7 = v6 + 4;
  }
  a1[10] = v7;
}

_QWORD *MTMouseEmbeddedEventDispatcher::createDispatcher(MTSimpleHIDManager *a1, const void *a2)
{
  _QWORD *v4;

  v4 = (_QWORD *)operator new();
  bzero(v4, 0x220uLL);
  MTSimpleEventDispatcher::MTSimpleEventDispatcher((MTSimpleEventDispatcher *)v4);
  v4[58] = v4 + 59;
  v4[59] = 0;
  v4[60] = 0;
  v4[61] = v4 + 61;
  v4[62] = v4 + 61;
  v4[63] = 0;
  *((_DWORD *)v4 + 134) = 1114636288;
  *v4 = &off_24FFF2328;
  MTTrackpadEventDispatcher::initialize((uint64_t)v4, a1, a2);
  return v4;
}

void sub_2310A4358(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10A1C4052F3E7C6);
  _Unwind_Resume(a1);
}

void MTMouseEmbeddedEventDispatcher::dispatchPointingEvent(MTMouseEmbeddedEventDispatcher *this, int a2, int a3, int a4, unint64_t a5, char a6)
{
  BOOL v11;
  unsigned int v12;
  NSObject *v13;
  NSObject *v14;
  int v15;
  const char *v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  unsigned int v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  if ((a6 & 1) != 0)
  {
    if (*((_BYTE *)this + 512))
      v11 = (a4 & 1) == 0;
    else
      v11 = 1;
    if (v11)
      v12 = a4;
    else
      v12 = a4 & 0xFFFFFFFC | 2;
    if (v12 != *((_DWORD *)this + 129))
    {
      v13 = MTLoggingPlugin();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        v15 = 136315906;
        v16 = "";
        v17 = 2080;
        v18 = "MTMouseEmbeddedEventDispatcher::";
        v19 = 2080;
        v20 = "dispatchPointingEvent";
        v21 = 1024;
        v22 = v12;
        _os_log_impl(&dword_231071000, v13, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Dispatching Pointer event from FW with button 0x%08x", (uint8_t *)&v15, 0x26u);
      }
    }
    MTTrackpadEventDispatcher::dispatchPointingEvent(this, a2, a3, a4, a5, 1);
  }
  else
  {
    v14 = MTLoggingPlugin();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v15 = 136315650;
      v16 = "[Error] ";
      v17 = 2080;
      v18 = "MTMouseEmbeddedEventDispatcher::";
      v19 = 2080;
      v20 = "dispatchPointingEvent";
      _os_log_impl(&dword_231071000, v14, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected request to dispatch a Pointer event. Ignoring.", (uint8_t *)&v15, 0x20u);
    }
  }
}

uint64_t MTMouseEmbeddedEventDispatcher::shouldDispatchPointerEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const __CFArray *Children;
  CFIndex Count;
  NSObject *v8;
  unsigned int v9;
  _BOOL4 v10;
  _BOOL4 v11;
  const char *v12;
  _BOOL4 v13;
  int v15;
  const char *v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  CFIndex v22;
  __int16 v23;
  unsigned int v24;
  __int16 v25;
  _BOOL4 v26;
  __int16 v27;
  _BOOL4 v28;
  __int16 v29;
  const char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  Children = (const __CFArray *)IOHIDEventGetChildren();
  if (Children)
    Count = CFArrayGetCount(Children);
  else
    Count = 0;
  if ((IOHIDEventGetIntegerValue() & 2) != 0
    || (IOHIDEventGetIntegerValue() & 0x80) != 0
    || a4 && (IOHIDEventGetPhase() & 0xD) != 0)
  {
    v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = (IOHIDEventGetIntegerValue() >> 7) & 1;
      v10 = IOHIDEventGetIntegerValue() == 1;
      v15 = 136316930;
      v16 = "";
      v11 = IOHIDEventGetIntegerValue() == 1;
      v17 = 2080;
      v18 = "MTMouseEmbeddedEventDispatcher::";
      v19 = 2080;
      v20 = "shouldDispatchPointerEvent";
      v21 = 2048;
      v12 = "no";
      v22 = Count;
      if (a4)
        v12 = "yes";
      v23 = 1024;
      v24 = v9;
      v25 = 1024;
      v26 = v10;
      v27 = 1024;
      v28 = v11;
      v29 = 2082;
      v30 = v12;
      _os_log_impl(&dword_231071000, v8, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Dispatching Pointer event with digitizer (%lu contacts, cancel=%d, touching=%d, inrange=%d), scroll? %{public}s", (uint8_t *)&v15, 0x46u);
    }
  }
  v13 = IOHIDEventGetIntegerValue()
     || (IOHIDEventGetIntegerValue() & 2) != 0
     || (a4 | IOHIDEventGetIntegerValue() & 1) != 0;
  return *(_BYTE *)(a1 + 424) || v13;
}

void MTMouseEmbeddedEventDispatcher::handleEvent(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t Children;
  const __CFAllocator *v7;
  const __CFArray *v8;
  const __CFArray *Copy;
  CFIndex Count;
  uint64_t RelativePointerEvent;
  const void *v12;
  CFIndex v13;
  const void *v14;
  const void *ValueAtIndex;
  int Type;
  NSObject *v17;
  uint64_t IntegerValue;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  uint32_t v25;
  NSObject *v26;
  uint64_t v27;
  NSObject *v28;
  unsigned int v29;
  uint64_t v30;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  uint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  if (IOHIDEventGetType() != 11)
  {
    v28 = MTLoggingPlugin();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v32 = "[Error] ";
      v33 = 2080;
      v34 = "MTMouseEmbeddedEventDispatcher::";
      v35 = 2080;
      v36 = "handleEvent";
      v37 = 1024;
      LODWORD(v38) = IOHIDEventGetType();
      _os_log_impl(&dword_231071000, v28, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected event type: %u Eating it.", buf, 0x26u);
    }
  }
  Children = IOHIDEventGetChildren();
  v7 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  if (Children)
  {
    v8 = (const __CFArray *)IOHIDEventGetChildren();
    Copy = CFArrayCreateCopy(v7, v8);
    Count = CFArrayGetCount(Copy);
  }
  else
  {
    Copy = 0;
    Count = 0;
  }
  mach_absolute_time();
  RelativePointerEvent = IOHIDEventCreateRelativePointerEvent();
  if (RelativePointerEvent)
  {
    v12 = (const void *)RelativePointerEvent;
    v30 = a1;
    v29 = a3;
    if (Count >= 1)
    {
      v13 = 0;
      v14 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(Copy, v13);
        Type = IOHIDEventGetType();
        if (Type != 11)
          break;
LABEL_24:
        if (Count == ++v13)
          goto LABEL_29;
      }
      if (Type == 6)
      {
        if (v14)
        {
          v17 = MTLoggingPlugin();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315650;
            v32 = "[Debug] ";
            v33 = 2080;
            v34 = "MTMouseEmbeddedEventDispatcher::";
            v35 = 2080;
            v36 = "handleEvent";
            _os_log_impl(&dword_231071000, v17, OS_LOG_TYPE_DEBUG, "[HID] [MT] %s%s%s Multiple scroll events. Merging.", buf, 0x20u);
          }
          IOHIDEventGetFloatValue();
          IOHIDEventGetFloatValue();
          IOHIDEventSetFloatValue();
          IOHIDEventGetFloatValue();
          IOHIDEventGetFloatValue();
          IOHIDEventSetFloatValue();
          IOHIDEventGetFloatValue();
          IOHIDEventGetFloatValue();
          IOHIDEventSetFloatValue();
          IOHIDEventGetPhase();
          IOHIDEventSetPhase();
        }
        else
        {
          v14 = (const void *)IOHIDEventCreateCopy();
          IOHIDEventAppendEvent();
        }
        goto LABEL_23;
      }
      if (IOHIDEventGetType() == 1)
      {
        IntegerValue = IOHIDEventGetIntegerValue();
        v19 = IOHIDEventGetIntegerValue();
        v20 = MTLoggingPlugin();
        v21 = v20;
        if (IntegerValue != 65280 || v19 != 1)
        {
          if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            goto LABEL_23;
          *(_DWORD *)buf = 136316162;
          v32 = "[Error] ";
          v33 = 2080;
          v34 = "MTMouseEmbeddedEventDispatcher::";
          v35 = 2080;
          v36 = "handleEvent";
          v37 = 2048;
          v38 = IntegerValue;
          v39 = 2048;
          v40 = v19;
          v22 = v21;
          v23 = OS_LOG_TYPE_ERROR;
          v24 = "[HID] [MT] %s%s%s Unexpected vendor-defined child event with usage page %lu and usage %lu. Eating it";
          v25 = 52;
          goto LABEL_21;
        }
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315650;
          v32 = "[Debug] ";
          v33 = 2080;
          v34 = "MTMouseEmbeddedEventDispatcher::";
          v35 = 2080;
          v36 = "handleEvent";
          v22 = v21;
          v23 = OS_LOG_TYPE_DEBUG;
          v24 = "[HID] [MT] %s%s%s Vendor-defined Momentum event. Ignoring.";
          v25 = 32;
LABEL_21:
          _os_log_impl(&dword_231071000, v22, v23, v24, buf, v25);
        }
      }
      else
      {
        v26 = MTLoggingPlugin();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          v32 = "[Error] ";
          v33 = 2080;
          v34 = "MTMouseEmbeddedEventDispatcher::";
          v35 = 2080;
          v36 = "handleEvent";
          v37 = 2114;
          v38 = (uint64_t)ValueAtIndex;
          v22 = v26;
          v23 = OS_LOG_TYPE_ERROR;
          v24 = "[HID] [MT] %s%s%s Unexpected child event: %{public}@. Eating it";
          v25 = 42;
          goto LABEL_21;
        }
      }
LABEL_23:
      IOHIDEventRemoveEvent();
      goto LABEL_24;
    }
    v14 = 0;
LABEL_29:
    IOHIDEventAppendEvent();
    if ((MTMouseEmbeddedEventDispatcher::shouldDispatchPointerEvent(v30, v27, a2, (uint64_t)v14) & 1) != 0)
      MTSimpleEventDispatcher::dispatchEvent(v30, (uint64_t)v12, v29);
    CFRelease(v12);
    if (Copy)
      goto LABEL_32;
  }
  else
  {
    v14 = 0;
    if (Copy)
LABEL_32:
      CFRelease(Copy);
  }
  if (v14)
    CFRelease(v14);
}

void MTMouseEmbeddedEventDispatcher::~MTMouseEmbeddedEventDispatcher(MTMouseEmbeddedEventDispatcher *this)
{
  *(_QWORD *)this = &off_24FFF1700;
  std::__list_imp<double>::clear((_QWORD *)this + 61);
  std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy((uint64_t)this + 464, *((_QWORD **)this + 59));
  MTSimpleEventDispatcher::~MTSimpleEventDispatcher(this);
}

{
  *(_QWORD *)this = &off_24FFF1700;
  std::__list_imp<double>::clear((_QWORD *)this + 61);
  std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy((uint64_t)this + 464, *((_QWORD **)this + 59));
  MTSimpleEventDispatcher::~MTSimpleEventDispatcher(this);
  JUMPOUT(0x2348D0034);
}

void MTTelemetryAnalyticsReporter::MTTelemetryAnalyticsReporter(MTTelemetryAnalyticsReporter *this)
{
  *(_QWORD *)this = 0;
  *((_BYTE *)this + 8) = 0;
}

{
  *(_QWORD *)this = 0;
  *((_BYTE *)this + 8) = 0;
}

void MTTelemetryAnalyticsReporter::~MTTelemetryAnalyticsReporter(MTTelemetryAnalyticsReporter *this)
{
  MTTelemetryAnalyticsReporter::stop(this);
}

{
  MTTelemetryAnalyticsReporter::stop(this);
}

uint64_t MTTelemetryAnalyticsReporter::stop(MTTelemetryAnalyticsReporter *this)
{
  const void *v2;
  uint64_t v3;

  v2 = *(const void **)this;
  if (v2)
  {
    if (*((_BYTE *)this + 8))
    {
      if (MTUnregisterFullFrameCallback())
        v3 = 0;
      else
        v3 = 3758097084;
      v2 = *(const void **)this;
    }
    else
    {
      v3 = 0;
    }
    CFRelease(v2);
    *(_QWORD *)this = 0;
  }
  else
  {
    v3 = 0;
  }
  *((_BYTE *)this + 8) = 0;
  return v3;
}

uint64_t MTTelemetryAnalyticsReporter::start(uint64_t a1, CFTypeRef cf)
{
  uint64_t v2;

  if (*(_BYTE *)(a1 + 8))
    return 0;
  v2 = 3758097086;
  if (!cf)
    return 3758097090;
  *(_QWORD *)a1 = CFRetain(cf);
  if (MTRegisterFullFrameCallback())
  {
    v2 = 0;
    *(_BYTE *)(a1 + 8) = 1;
  }
  return v2;
}

uint64_t MTTelemetryAnalyticsReporter::processTelemetryReport(uint64_t result, unsigned __int8 *a2, int a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v8[2];
  _QWORD v9[2];
  _QWORD v10[5];
  _QWORD v11[5];
  _QWORD v12[2];
  _QWORD v13[4];

  v13[2] = *MEMORY[0x24BDAC8D0];
  if (result)
  {
    if (a2)
    {
      v5 = *a2;
      result = MTDeviceGetSATelemetryReportID();
      if (a3 == 17 && v5 == (_DWORD)result && a2[15])
      {
        if (a2[12])
        {
          objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@.%@"), CFSTR("com.apple.multitouch"), CFSTR("baseline.inversion"));
          v12[0] = CFSTR("Lockscreen_Status");
          v6 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", a2[11]);
          v12[1] = CFSTR("Touch_Frequency");
          v13[0] = v6;
          v13[1] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedChar:", a2[9]);
          objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v13, v12, 2);
          result = AnalyticsSendEventLazy();
        }
        if (a2[13])
        {
          objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@.%@"), CFSTR("com.apple.multitouch"), CFSTR("baseline.adaptation"));
          v10[0] = CFSTR("AdaptationInterval");
          v11[0] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", *(unsigned int *)(a2 + 1));
          v10[1] = CFSTR("FreqDuringAdaptation");
          v11[1] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedChar:", a2[9]);
          v10[2] = CFSTR("Lockscreen_Status");
          v11[2] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", a2[11]);
          v10[3] = CFSTR("TimeSinceLastAdapt");
          v11[3] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", *(unsigned int *)(a2 + 5));
          v10[4] = CFSTR("Touching");
          v11[4] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", a2[10]);
          objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v11, v10, 5);
          result = AnalyticsSendEventLazy();
        }
        if (a2[14])
        {
          objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@.%@"), CFSTR("com.apple.multitouch"), CFSTR("dtn.allcolumnscovered"));
          v8[0] = CFSTR("Lockscreen_Status");
          v7 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", a2[11]);
          v8[1] = CFSTR("Touch_Frequency");
          v9[0] = v7;
          v9[1] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedChar:", a2[9]);
          objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v9, v8, 2);
          return AnalyticsSendEventLazy();
        }
      }
    }
  }
  return result;
}

uint64_t ___ZL18sendAnalyticsEventP8NSStringP12NSDictionaryIS0_P8NSObjectE_block_invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

const char *MTMouseHIDManager::getName(MTMouseHIDManager *this)
{
  return "MTMouseHIDManager";
}

MTSimpleHIDManager *MTMouseHIDManager::createManager(uint64_t a1, const void *a2, int a3, int a4)
{
  MTSimpleHIDManager *v8;

  v8 = (MTSimpleHIDManager *)operator new();
  *(_OWORD *)v8 = 0u;
  *((_OWORD *)v8 + 1) = 0u;
  *((_OWORD *)v8 + 2) = 0u;
  *((_OWORD *)v8 + 3) = 0u;
  *((_OWORD *)v8 + 4) = 0u;
  *((_OWORD *)v8 + 5) = 0u;
  *((_OWORD *)v8 + 6) = 0u;
  *((_OWORD *)v8 + 7) = 0u;
  *((_OWORD *)v8 + 8) = 0u;
  *((_OWORD *)v8 + 9) = 0u;
  *((_OWORD *)v8 + 10) = 0u;
  *((_OWORD *)v8 + 11) = 0u;
  *((_OWORD *)v8 + 12) = 0u;
  *((_OWORD *)v8 + 13) = 0u;
  *((_OWORD *)v8 + 14) = 0u;
  *((_OWORD *)v8 + 15) = 0u;
  *((_OWORD *)v8 + 16) = 0u;
  *((_OWORD *)v8 + 17) = 0u;
  *((_OWORD *)v8 + 18) = 0u;
  *((_OWORD *)v8 + 19) = 0u;
  *((_OWORD *)v8 + 20) = 0u;
  *((_OWORD *)v8 + 21) = 0u;
  *((_OWORD *)v8 + 22) = 0u;
  *((_OWORD *)v8 + 23) = 0u;
  *((_OWORD *)v8 + 24) = 0u;
  MTSimpleHIDManager::MTSimpleHIDManager(v8);
  *(_QWORD *)v8 = &off_24FFF24D0;
  MTMouseHIDManager::initialize(v8, a1, a2, a3, a4);
  return v8;
}

void sub_2310A5288(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10A1C40899DFB1ALL);
  _Unwind_Resume(a1);
}

uint64_t MTMouseHIDManager::initialize(MTModeSwitcher *a1, uint64_t a2, const void *a3, int a4, int a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  *(_QWORD *)((char *)a1 + 364) = 0;
  MTAbsoluteTimeGetCurrent();
  *((_QWORD *)a1 + 47) = v10;
  *((_DWORD *)a1 + 96) = 0;
  MTAbsoluteTimeGetCurrent();
  *((_QWORD *)a1 + 49) = v11;
  v12 = (*(uint64_t (**)(MTModeSwitcher *))(*(_QWORD *)a1 + 880))(a1);
  (*(void (**)(MTModeSwitcher *, const void *, uint64_t))(*(_QWORD *)a1 + 888))(a1, a3, v12);
  return MTTrackpadHIDManager::initialize(a1, a2, a3, a4, a5);
}

uint64_t MTMouseHIDManager::registerDeviceDataCallbacks(MTMouseHIDManager *this)
{
  MTTrackpadHIDManager::registerDeviceDataCallbacks(this);
  (*(void (**)(MTMouseHIDManager *))(*(_QWORD *)this + 80))(this);
  MTRegisterTrackingCallback();
  (*(void (**)(MTMouseHIDManager *))(*(_QWORD *)this + 80))(this);
  return MTRegisterFrameProcessingEntryExitCallback();
}

uint64_t MTMouseHIDManager::forwardTrackingDataForMotionFilter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a5 + 896))(a5, a1, a2, a3, a4);
}

uint64_t MTMouseHIDManager::forwardFrameProcessingEntryExit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a5 + 904))(a5, a1, a2, a3, a4);
}

uint64_t MTMouseHIDManager::unregisterDeviceDataCallbacks(MTMouseHIDManager *this)
{
  (*(void (**)(MTMouseHIDManager *))(*(_QWORD *)this + 80))(this);
  MTUnregisterFrameProcessingEntryExitCallback();
  (*(void (**)(MTMouseHIDManager *))(*(_QWORD *)this + 80))(this);
  MTUnregisterTrackingCallback();
  return MTTrackpadHIDManager::unregisterDeviceDataCallbacks(this);
}

unsigned int *MTMouseHIDManager::createEventDispatcher(MTMouseHIDManager *this)
{
  const void *v2;
  unsigned int *Dispatcher;

  v2 = (const void *)(*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 80))(this);
  Dispatcher = (unsigned int *)MTMouseEventDispatcher::createDispatcher(this, v2);
  (*(void (**)(MTMouseHIDManager *, unsigned int *))(*(_QWORD *)this + 128))(this, Dispatcher);
  return MTSimpleEventDispatcher::release(Dispatcher);
}

void MTMouseHIDManager::setDeviceUsages(MTMouseHIDManager *this)
{
  const __CFArray *v2;
  const __CFArray *v3;
  CFIndex v4;
  CFIndex v5;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v7;
  const __CFNumber *Value;
  const __CFNumber *v9;
  const __CFNumber *v10;
  int v12;
  int valuePtr;

  MTTrackpadHIDManager::setDeviceUsages(this);
  v2 = (const __CFArray *)(*(uint64_t (**)(MTMouseHIDManager *, const __CFString *))(*(_QWORD *)this + 560))(this, CFSTR("DeviceUsagePairs"));
  if (v2)
  {
    v3 = v2;
    if (CFArrayGetCount(v2) >= 1)
    {
      v4 = 0;
      v5 = -1;
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v3, v4);
        if (ValueAtIndex)
        {
          v7 = ValueAtIndex;
          v12 = -1431655766;
          valuePtr = -1431655766;
          Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("DeviceUsagePage"));
          v9 = (const __CFNumber *)CFDictionaryGetValue(v7, CFSTR("DeviceUsage"));
          if (Value)
          {
            v10 = v9;
            if (v9)
            {
              CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
              CFNumberGetValue(v10, kCFNumberSInt32Type, &v12);
              if (v12 == 12 && valuePtr == 65280)
                v5 = v4;
            }
          }
        }
        ++v4;
      }
      while (v4 < CFArrayGetCount(v3));
      if ((v5 & 0x8000000000000000) == 0)
        CFArrayRemoveValueAtIndex(v3, v5);
    }
    MTTrackpadHIDManager::setProperty(this, CFSTR("DeviceUsagePairs"), v3, 1);
    CFRelease(v3);
  }
}

uint64_t MTMouseHIDManager::getUserPrefs(uint64_t a1, _QWORD *a2)
{
  *a2 = &MTMouseHIDManager::getUserPrefs(mt_UserPreference const**)::prefs;
  return 6;
}

uint64_t MTMouseHIDManager::determineHIDManagerSettings(MTMouseHIDManager *this)
{
  uint64_t v2;
  const __CFDictionary *v3;
  CFTypeID v4;
  uint64_t result;
  uint64_t v6;
  BOOL v7;

  v2 = (*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 880))(this);
  v3 = (const __CFDictionary *)*((_QWORD *)this + 43);
  if (v3 && (v4 = CFGetTypeID(*((CFTypeRef *)this + 43)), v4 == CFDictionaryGetTypeID()))
  {
    *(_WORD *)(v2 + 8) = 0;
    *(_QWORD *)v2 = 0;
    *(_BYTE *)v2 = mthid_CFDictionaryGetBoolValue(v3, CFSTR("MouseHorizontalScroll"));
    *(_BYTE *)(v2 + 1) = mthid_CFDictionaryGetBoolValue(v3, CFSTR("MouseVerticalScroll"));
    *(_BYTE *)(v2 + 3) = mthid_CFDictionaryGetInt32Property(v3, CFSTR("MouseTwoFingerHorizSwipeGesture")) == 1;
    *(_BYTE *)(v2 + 4) = mthid_CFDictionaryGetInt32Property(v3, CFSTR("MouseTwoFingerHorizSwipeGesture")) == 2;
    *(_WORD *)(v2 + 5) = mthid_CFDictionaryGetInt32Property(v3, CFSTR("MouseOneFingerDoubleTapGesture")) == 1;
    *(_BYTE *)(v2 + 7) = mthid_CFDictionaryGetInt32Property(v3, CFSTR("MouseTwoFingerDoubleTapGesture")) == 3;
    result = mthid_CFDictionaryGetBoolValue(v3, CFSTR("MouseMomentumScroll"));
    *(_BYTE *)(v2 + 9) = result;
    if (*(_BYTE *)(v2 + 4))
    {
      result = MTPreferencesGetAppBooleanValue(CFSTR("EnableMouseNavSwipes"), CFSTR("com.apple.MultitouchSupport"), 0);
      if ((_DWORD)result)
        *(_WORD *)(v2 + 3) = 1;
    }
  }
  else
  {
    v6 = (*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 80))(this);
    result = (*(uint64_t (**)(MTMouseHIDManager *, uint64_t, uint64_t))(*(_QWORD *)this + 888))(this, v6, v2);
  }
  v7 = 1;
  if ((*((_BYTE *)this + 160) & 4) == 0)
  {
    result = MTPreferencesGetAppBooleanValue(CFSTR("ScrollMomentum"), CFSTR("com.apple.MultitouchSupport"), 0);
    v7 = (_DWORD)result == 1;
  }
  *(_BYTE *)(v2 + 8) = v7;
  *(_BYTE *)(v2 + 2) = 1;
  return result;
}

void MTMouseHIDManager::activateHIDManagerSettings(MTMouseHIDManager *this)
{
  const void *v2;
  const __CFAllocator *v3;
  const CFDictionaryKeyCallBacks *v4;
  const CFDictionaryValueCallBacks *v5;
  __CFDictionary *Mutable;
  __CFDictionary *v7;
  MTPListGestureConfig *v8;
  unsigned __int8 *v9;
  const __CFString *v10;
  const __CFString *v11;
  const __CFString *v12;
  uint64_t v13;
  _QWORD *v14;
  __CFArray *v15;
  __CFArray *v16;
  __int16 v17;
  int v18;
  int v19;
  const void *v20;
  const void *v21;
  CFTypeRef obj;

  v21 = (const void *)(*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 624))(this);
  v2 = (const void *)(*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 632))(this);
  v20 = (const void *)(*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 640))(this);
  v3 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v4 = (const CFDictionaryKeyCallBacks *)MEMORY[0x24BDBD6A0];
  v5 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v7 = CFDictionaryCreateMutable(v3, 2, v4, v5);
  v8 = CFArrayCreateMutable(v3, 0, MEMORY[0x24BDBD690]);
  v9 = (unsigned __int8 *)(*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 880))(this);
  v17 = 0;
  (*(void (**)(MTMouseHIDManager *, const void *, const __CFString *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int16))(*(_QWORD *)this + 872))(this, v2, CFSTR("One Finger"), *v9, v9[1], v9[5], 0, 0, v17);
  LOWORD(v18) = *(_WORD *)(v9 + 3);
  (*(void (**)(MTMouseHIDManager *, const void *, const __CFString *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, int))(*(_QWORD *)this + 872))(this, v2, CFSTR("Two Fingers"), *v9, v9[1], 0, 0, v9[7], v18);
  LOWORD(v19) = 0;
  (*(void (**)(MTMouseHIDManager *, const void *, const __CFString *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, int))(*(_QWORD *)this + 872))(this, v2, CFSTR("Three Fingers"), *v9, v9[1], 0, v9[6], 0, v19);
  CFDictionaryAddValue(v7, CFSTR("LookupBySubset"), CFSTR("TouchingFingers"));
  MTPListGestureConfig::addChordMappingToArray(v8, (__CFArray *)CFSTR("1 Finger"), CFSTR("One Finger"), v10);
  MTPListGestureConfig::addChordMappingToArray(v8, (__CFArray *)CFSTR("2 Fingers"), CFSTR("Two Fingers"), v11);
  MTPListGestureConfig::addChordMappingToArray(v8, (__CFArray *)CFSTR("3 Fingers"), CFSTR("Three Fingers"), v12);
  CFDictionaryAddValue(v7, CFSTR("Chords"), v8);
  CFDictionaryAddValue(Mutable, CFSTR("Right"), v7);
  obj = 0;
  (*(void (**)(MTMouseHIDManager *, uint64_t))(*(_QWORD *)this + 592))(this, 1);
  MTParser::clear(*((_QWORD **)this + 42), 0, 0, v13);
  MTGestureConfig::clearAllChords(*(MTGestureConfig **)(*((_QWORD *)this + 42) + 72));
  MTPListGestureConfig::setMotionSensitivitiesDictionary(*(MTPListGestureConfig **)(*((_QWORD *)this + 42) + 72), v21);
  MTPListGestureConfig::setGestureSetsDictionary(*(MTPListGestureConfig **)(*((_QWORD *)this + 42) + 72), v2);
  MTPListGestureConfig::setActionEventsDictionary(*(MTPListGestureConfig **)(*((_QWORD *)this + 42) + 72), v20);
  MTPListGestureConfig::setChordMappingsDictionary(*(MTPListGestureConfig **)(*((_QWORD *)this + 42) + 72), Mutable);
  MTPListGestureConfig::parseCreateGestureConfig(*(MTPListGestureConfig **)(*((_QWORD *)this + 42) + 72), (const __CFString **)&obj);
  *(_WORD *)(*(_QWORD *)(*((_QWORD *)this + 42) + 56) + 138) = 1;
  if (obj)
  {
    CFShow(obj);
    CFRelease(obj);
    obj = 0;
  }
  v14 = (_QWORD *)MEMORY[0x24BDBD270];
  if (!v9[2])
    v14 = (_QWORD *)MEMORY[0x24BDBD268];
  (*(void (**)(MTMouseHIDManager *, const __CFString *, _QWORD))(*(_QWORD *)this + 568))(this, CFSTR("SupportsGestureScrolling"), *v14);
  (*(void (**)(MTMouseHIDManager *, const __CFString *, const __CFString *))(*(_QWORD *)this + 568))(this, CFSTR("DeviceTypeHint"), CFSTR("Mouse"));
  v15 = CFArrayCreateMutable(v3, 0, MEMORY[0x24BDBD690]);
  v16 = v15;
  if (v9[2])
    CFArrayAppendValue(v15, CFSTR("Scroll"));
  (*(void (**)(MTMouseHIDManager *, const __CFString *, __CFArray *))(*(_QWORD *)this + 568))(this, CFSTR("SupportedGestures"), v16);
  CFRelease(v16);
  CFRelease(v21);
  CFRelease(v2);
  CFRelease(v20);
  CFRelease(v8);
  CFRelease(v7);
  CFRelease(Mutable);
}

uint64_t MTMouseHIDManager::updateEventDispatcherSettings(MTMouseHIDManager *this)
{
  uint64_t result;
  uint64_t v3;
  char v4;

  result = (*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 120))(this);
  if (result)
  {
    *(_BYTE *)((*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 120))(this) + 432) = 0;
    *(_DWORD *)((*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 120))(this) + 436) = 0;
    v3 = (*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 120))(this);
    result = (*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 880))(this);
    v4 = *(_BYTE *)(result + 8);
    if (v4)
    {
      result = (*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 880))(this);
      v4 = *(_BYTE *)(result + 9) != 0;
    }
    *(_BYTE *)(v3 + 532) = v4;
  }
  return result;
}

void MTMouseHIDManager::getTrackpadSettings(MTMouseHIDManager *this)
{
  NSObject *v2;
  _QWORD *exception;
  int v4;
  const char *v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  MTMouseHIDManager *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v4 = 136315906;
    v5 = "[Error] ";
    v6 = 2080;
    v7 = "MTMouseHIDManager::";
    v8 = 2080;
    v9 = "getTrackpadSettings";
    v10 = 2048;
    v11 = this;
    _os_log_impl(&dword_231071000, v2, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s (%p): Error: invalid use of getTrackpadSettings()", (uint8_t *)&v4, 0x2Au);
  }
  exception = __cxa_allocate_exception(8uLL);
  *exception = this;
}

uint64_t MTMouseHIDManager::getMouseSettings(MTMouseHIDManager *this)
{
  return (uint64_t)this + 352;
}

double MTMouseHIDManager::initDefaultMouseSettings(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  if (a3)
  {
    *(_WORD *)(a3 + 8) = 0;
    *(_QWORD *)a3 = 0;
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 688))(a1);
    *(_QWORD *)&result = 65793;
    *(_DWORD *)a3 = 65793;
    *(_DWORD *)(a3 + 4) = 16843009;
    *(_WORD *)(a3 + 8) = 257;
  }
  return result;
}

__CFDictionary *MTMouseHIDManager::createDefaultMotionSensitivitiesDictionary(MTMouseHIDManager *this)
{
  const __CFAllocator *v1;
  const CFDictionaryKeyCallBacks *v2;
  const CFDictionaryValueCallBacks *v3;
  __CFDictionary *Mutable;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  __CFDictionary *v10;
  __CFDictionary *v11;
  BOOL v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFNumberRef v16;
  CFNumberRef v17;
  CFNumberRef v18;
  __CFDictionary *v19;
  __CFDictionary *v20;
  CFNumberRef v21;
  CFNumberRef v22;
  CFNumberRef v23;
  CFNumberRef v24;
  CFNumberRef v25;
  CFNumberRef v26;
  __CFDictionary *v27;
  __CFDictionary *v28;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int valuePtr;

  v1 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v2 = (const CFDictionaryKeyCallBacks *)MEMORY[0x24BDBD6A0];
  v3 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v37 = 1035489772;
  valuePtr = 1140457472;
  v36 = 971419597;
  v34 = 0;
  v35 = 1097859072;
  v5 = CFNumberCreate(v1, kCFNumberFloat32Type, &valuePtr);
  v6 = CFNumberCreate(v1, kCFNumberFloat32Type, &v35);
  v7 = CFNumberCreate(v1, kCFNumberFloat32Type, &v34);
  v8 = CFNumberCreate(v1, kCFNumberFloat32Type, &v36);
  v9 = CFNumberCreate(v1, kCFNumberFloat32Type, &v37);
  v10 = CFDictionaryCreateMutable(v1, 0, v2, v3);
  v11 = v10;
  if (v5)
    v12 = v10 == 0;
  else
    v12 = 1;
  if (v12)
  {
    if (!v5)
    {
      if (!v6)
        goto LABEL_9;
      goto LABEL_8;
    }
  }
  else
  {
    CFDictionaryRemoveAllValues(v10);
    CFDictionaryAddValue(v11, CFSTR("Resolution_dpi"), v5);
    CFDictionaryAddValue(v11, CFSTR("AccelThresh"), v6);
    CFDictionaryAddValue(v11, CFSTR("AccelPower"), v7);
    CFDictionaryAddValue(v11, CFSTR("FrameDecay_mm"), v8);
    CFDictionaryAddValue(v11, CFSTR("CommitMultiplier"), v9);
    CFDictionaryAddValue(Mutable, CFSTR("Mouse Scrolling"), v11);
  }
  CFRelease(v5);
  if (v6)
LABEL_8:
    CFRelease(v6);
LABEL_9:
  if (v7)
    CFRelease(v7);
  if (v8)
    CFRelease(v8);
  if (v9)
    CFRelease(v9);
  if (v11)
    CFRelease(v11);
  v35 = 1097859072;
  v33 = 1087373312;
  v34 = 1039516303;
  v32 = 1079194419;
  v30 = 1056964608;
  v31 = 1106247680;
  v13 = CFNumberCreate(v1, kCFNumberFloat32Type, &v33);
  v14 = CFNumberCreate(v1, kCFNumberFloat32Type, &v35);
  v15 = CFNumberCreate(v1, kCFNumberFloat32Type, &v34);
  v16 = CFNumberCreate(v1, kCFNumberFloat32Type, &v32);
  v17 = CFNumberCreate(v1, kCFNumberFloat32Type, &v31);
  v18 = CFNumberCreate(v1, kCFNumberFloat32Type, &v30);
  v19 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v20 = v19;
  if (v13 && v14 && v15)
  {
    CFDictionaryRemoveAllValues(v19);
    CFDictionaryAddValue(v20, CFSTR("Resolution_mm"), v13);
    CFDictionaryAddValue(v20, CFSTR("AccelThresh"), v14);
    CFDictionaryAddValue(v20, CFSTR("AccelPower"), v15);
    CFDictionaryAddValue(v20, CFSTR("FluidAnimationStartThreshold_mm"), v16);
    CFDictionaryAddValue(v20, CFSTR("FluidSwipeCompleteThreshold_mm"), v17);
    CFDictionaryAddValue(v20, CFSTR("FluidSwipeInertiaTime_s"), v18);
    CFDictionaryAddValue(Mutable, CFSTR("Mouse Vertical Swipe"), v20);
  }
  else if (!v13)
  {
    goto LABEL_25;
  }
  CFRelease(v13);
LABEL_25:
  if (v14)
    CFRelease(v14);
  if (v15)
    CFRelease(v15);
  if (v16)
    CFRelease(v16);
  if (v17)
    CFRelease(v17);
  if (v18)
    CFRelease(v18);
  if (v20)
    CFRelease(v20);
  v35 = 1097859072;
  v33 = 1083179008;
  v34 = 1041865114;
  v21 = CFNumberCreate(v1, kCFNumberFloat32Type, &v33);
  v22 = CFNumberCreate(v1, kCFNumberFloat32Type, &v35);
  v23 = CFNumberCreate(v1, kCFNumberFloat32Type, &v34);
  v24 = CFNumberCreate(v1, kCFNumberFloat32Type, &v32);
  v25 = CFNumberCreate(v1, kCFNumberFloat32Type, &v31);
  v26 = CFNumberCreate(v1, kCFNumberFloat32Type, &v30);
  v27 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v28 = v27;
  if (v21 && v22 && v23 && v24 && v25 && v26)
  {
    CFDictionaryRemoveAllValues(v27);
    CFDictionaryAddValue(v28, CFSTR("Resolution_mm"), v21);
    CFDictionaryAddValue(v28, CFSTR("AccelThresh"), v22);
    CFDictionaryAddValue(v28, CFSTR("AccelPower"), v23);
    CFDictionaryAddValue(v28, CFSTR("FluidAnimationStartThreshold_mm"), v24);
    CFDictionaryAddValue(v28, CFSTR("FluidSwipeCompleteThreshold_mm"), v25);
    CFDictionaryAddValue(v28, CFSTR("FluidSwipeInertiaTime_s"), v26);
    CFDictionaryAddValue(Mutable, CFSTR("Mouse Horizontal Swipe"), v28);
  }
  else if (!v21)
  {
    goto LABEL_46;
  }
  CFRelease(v21);
LABEL_46:
  if (v22)
    CFRelease(v22);
  if (v23)
    CFRelease(v23);
  if (v24)
    CFRelease(v24);
  if (v25)
    CFRelease(v25);
  if (v26)
    CFRelease(v26);
  if (v28)
    CFRelease(v28);
  return Mutable;
}

MTPListGestureConfig *MTMouseHIDManager::createDefaultActionEventsDictionary(MTMouseHIDManager *this)
{
  MTPListGestureConfig *Mutable;
  const __CFString *v2;
  const __CFString *v3;
  const __CFString *v4;
  const __CFString *v5;
  const __CFString *v6;
  const __CFString *v7;
  const __CFString *v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  const __CFString *v12;
  const __CFString *v13;
  const __CFString *v14;
  const __CFString *v15;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Secondary Click"), CFSTR("Mouse Click"), CFSTR("Button2"), 0, v2);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Scroll"), CFSTR("Scroll"), 0, 0, v3);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Scroll To Edge"), CFSTR("Scroll To Edge"), 0, 0, v4);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Orientation"), CFSTR("Orientation"), 0, 0, v5);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Zoom Toggle"), CFSTR("Zoom Toggle"), 0, 0, v6);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Show Definition"), CFSTR("Show Definition"), 0, 0, v7);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Fluid Navigation"), CFSTR("Fluid Navigation"), 0, 0, v8);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Fluid Dock"), CFSTR("Fluid Dock"), 0, 0, v9);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Fluid Notification"), CFSTR("Fluid Notification"), 0, 0, v10);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Fluid Notification Alt"), CFSTR("Fluid Notification Alt"), 0, 0, v11);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Swipe Left"), CFSTR("Swipe"), 0, 0, v12);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Swipe Right"), CFSTR("Swipe"), 0, 0, v13);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Swipe Up"), CFSTR("Swipe"), 0, 0, v14);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)CFSTR("Swipe Down"), CFSTR("Swipe"), 0, 0, v15);
  return Mutable;
}

void MTMouseHIDManager::createMouseScrollSwipeTapCombo(MTMouseHIDManager *this, __CFDictionary *a2, const __CFString *a3, int a4, int a5, int a6, int a7, int a8, BOOL a9, BOOL a10)
{
  const __CFAllocator *v16;
  MTPListGestureConfig *Mutable;
  CFMutableDictionaryRef v18;
  __CFDictionary *v19;
  BOOL v20;
  int v21;
  _BOOL4 v22;
  const __CFString *v23;
  const __CFString *v24;
  const __CFString *v25;
  __CFString *v26;
  const __CFString *v27;
  __CFString *v28;
  __CFString *v29;
  const __CFString *v30;

  v16 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD690]);
  v18 = CFDictionaryCreateMutable(v16, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v19 = v18;
  if (Mutable)
    v20 = v18 == 0;
  else
    v20 = 1;
  if (!v20)
  {
    v30 = a3;
    v21 = a4 | a5;
    v22 = a9 || a10;
    if (v22)
      v23 = CFSTR("WaitForQuick Momentum");
    else
      v23 = CFSTR("Momentum");
    v24 = CFSTR("OncePerDirection");
    if (v21)
      v24 = CFSTR("OncePerDirection OnlyIfAllMoving");
    v28 = (__CFString *)v23;
    v29 = (__CFString *)v24;
    if (a6)
    {
      MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Zoom Toggle"), CFSTR("DoubleTap"), 0, 0, 0, 0, 0, v23);
      if (!a7)
      {
LABEL_16:
        if (!a8)
          goto LABEL_17;
        goto LABEL_35;
      }
    }
    else if (!a7)
    {
      goto LABEL_16;
    }
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Show Definition"), CFSTR("DoubleTap"), 0, 0, 0, 0, 0, v28);
    if (!a8)
    {
LABEL_17:
      if (a5)
      {
LABEL_18:
        if ((a4 & a5) != 0)
          v25 = CFSTR("Translate");
        else
          v25 = CFSTR("Vertical");
        MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Scroll"), v25, CFSTR("Mouse Scrolling"), v28, CFSTR("LockOnFirst"), 0, 0, v28);
      }
LABEL_22:
      if (v22)
      {
        if (a10)
          v26 = CFSTR("Fluid Dock");
        else
          v26 = CFSTR("Fluid Navigation");
        MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)v26, CFSTR("Horizontal"), CFSTR("Mouse Horizontal Swipe"), v29, 0, 0, 0, v28);
      }
      if (v21 | !v22)
        v27 = CFSTR("ToMoreFingers ToFewerFingers FromFewerFingers FromMoreFingers");
      else
        v27 = CFSTR("ToMoreFingers");
      CFDictionaryAddValue(v19, CFSTR("Transitions"), v27);
      CFDictionaryAddValue(v19, CFSTR("Gestures"), Mutable);
      CFDictionaryAddValue(a2, v30, v19);
      goto LABEL_31;
    }
LABEL_35:
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)CFSTR("Fluid Dock"), CFSTR("DoubleTap"), 0, 0, 0, 0, 0, v28);
    if (a5)
      goto LABEL_18;
    goto LABEL_22;
  }
  if (!Mutable)
  {
    if (!v18)
      return;
LABEL_8:
    CFRelease(v19);
    return;
  }
LABEL_31:
  CFRelease(Mutable);
  if (v19)
    goto LABEL_8;
}

CFMutableDictionaryRef MTMouseHIDManager::createDefaultGestureSetsDictionary(MTMouseHIDManager *this)
{
  return CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
}

uint64_t MTMouseHIDManager::updateMouseMotionFilter(MTMouseHIDManager *this, float a2, float a3, int a4)
{
  uint64_t result;
  double v7;
  double v8;
  float32x2_t v9;
  double v10;
  long double v11;
  long double v12;
  long double v13;
  float32x2_t v14;
  uint64_t v20;
  uint64_t v21;
  int32x2_t v23;
  float32x2_t v25;

  result = MTAbsoluteTimeGetCurrent();
  v8 = v7 - *((double *)this + 47);
  if (!a4 || v8 >= 0.0329999998)
  {
    v9 = vabs_f32((float32x2_t)__PAIR64__(LODWORD(a3), LODWORD(a2)));
    v25 = *(float32x2_t *)((char *)this + 364);
    v10 = v8 / 0.00800000038;
    if (vaddv_f32(v25) <= 5.0)
      v11 = 0.870000005;
    else
      v11 = 0.699999988;
    v12 = pow(v11, v10);
    *(float *)&v12 = v12;
    v23 = *(int32x2_t *)&v12;
    v13 = pow(0.200000003, v10);
    *(float *)&v13 = v13;
    v14 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v9, v25), (int8x8_t)vdup_lane_s32(*(int32x2_t *)&v13, 0), (int8x8_t)vdup_lane_s32(v23, 0));
    __asm { FMOV            V1.2S, #1.0 }
    *(float32x2_t *)((char *)this + 364) = vmla_f32(vmul_f32(v9, vsub_f32(_D1, v14)), v25, v14);
    if ((*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 864))(this))
    {
      if (*(_QWORD *)((*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 864))(this) + 56))
      {
        v20 = (*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 864))(this);
        MTHandMotion::storeFeedbackFromMouse(*(_QWORD *)(v20 + 56), *((float *)this + 91), *((float *)this + 92));
      }
    }
    result = MTAbsoluteTimeGetCurrent();
    *((_QWORD *)this + 47) = v21;
  }
  return result;
}

uint64_t MTMouseHIDManager::tickleMouseMotionFilter(MTMouseHIDManager *this)
{
  MTMouseHIDManager::updateMouseMotionFilter(this, 0.0, 0.0, 1);
  return MTMouseHIDManager::updateButtonMotionFilter(this, 0.0, 0);
}

uint64_t MTMouseHIDManager::updateButtonMotionFilter(MTMouseHIDManager *this, float a2, int a3)
{
  double v6;
  float v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;

  MTAbsoluteTimeGetCurrent();
  if (a3)
  {
    *((float *)this + 96) = a2;
  }
  else
  {
    v7 = pow(0.699999988, (v6 - *((double *)this + 49)) / 0.0112500004);
    *((float *)this + 96) = (float)((float)(1.0 - v7) * a2) + (float)(v7 * *((float *)this + 96));
  }
  if ((*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 864))(this)
    && *(_QWORD *)((*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 864))(this) + 56))
  {
    v8 = (*(uint64_t (**)(MTMouseHIDManager *))(*(_QWORD *)this + 864))(this);
    MTHandMotion::storeFeedbackFromButton(*(_QWORD *)(v8 + 56), *((float *)this + 96));
  }
  result = MTAbsoluteTimeGetCurrent();
  *((_QWORD *)this + 49) = v10;
  return result;
}

uint64_t MTMouseHIDManager::handleTrackingDataForMotionFilter(uint64_t a1, uint64_t a2, int a3, int a4, unsigned int a5)
{
  float v5;

  if (a5 && a5 != 400)
  {
    v5 = 400.0 / (double)a5;
    a3 = (int)(float)((float)a3 * v5);
    a4 = (int)(float)((float)a4 * v5);
  }
  (*(void (**)(uint64_t, _QWORD, float, float))(*(_QWORD *)a1 + 912))(a1, 0, (float)a3, (float)a4);
  return 1;
}

uint64_t MTMouseHIDManager::handleButtonState(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (a3 != a4)
    (*(void (**)(uint64_t, uint64_t, float))(*(_QWORD *)a1 + 920))(a1, 1, 1.0);
  return 1;
}

uint64_t MTMouseHIDManager::handleFrameProcessingEntryExit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (a5)
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 928))(a1);
  return 1;
}

void MTMouseHIDManager::~MTMouseHIDManager(MTMouseHIDManager *this)
{
  MTSimpleHIDManager::~MTSimpleHIDManager(this);
  JUMPOUT(0x2348D0034);
}

uint64_t MTParameterFactory::initFingerTipOffsetParams(uint64_t result, int a2, char a3, int a4)
{
  __int128 v4;
  _DWORD *v5;
  int v6;
  __int128 v7;

  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  if ((a2 - 2000) > 0x3E7)
  {
    if ((a2 - 1000) <= 0x3E7)
    {
      *(_DWORD *)result = 1;
      *(_DWORD *)(result + 8) = 1077936128;
      v5 = (_DWORD *)(result + 36);
      if (a3 < 0 || a4)
      {
        *(_OWORD *)(result + 12) = xmmword_2310BDD90;
        *(_QWORD *)(result + 28) = 0x4108000041200000;
        *v5 = 0;
        *(_DWORD *)(result + 39) = 0;
        *(_WORD *)(result + 43) = 257;
        v6 = 1053609165;
      }
      else
      {
        *(_OWORD *)(result + 12) = xmmword_2310BDD80;
        *(_QWORD *)(result + 28) = 0x40E0000041F00000;
        *v5 = 0;
        *(_DWORD *)(result + 39) = 0;
        *(_WORD *)(result + 43) = 257;
        v6 = 1057132380;
      }
      *(_DWORD *)(result + 48) = v6;
      goto LABEL_16;
    }
    if (a2 == 4)
    {
      *(_DWORD *)result = 1;
      v7 = xmmword_2310BDD50;
    }
    else
    {
      if (a2 == 2)
      {
        *(_DWORD *)result = 1;
        *(_OWORD *)(result + 8) = xmmword_2310BDD50;
        *(_OWORD *)(result + 24) = xmmword_2310BDD60;
        *(_DWORD *)(result + 40) = 65793;
        *(_BYTE *)(result + 44) = 0;
        *(_BYTE *)(result + 52) = 1;
        return result;
      }
      *(_DWORD *)result = 1;
      v7 = xmmword_2310BDD70;
    }
    *(_OWORD *)(result + 8) = v7;
    v4 = xmmword_2310BDD60;
  }
  else
  {
    *(_DWORD *)result = 1;
    *(_OWORD *)(result + 8) = xmmword_2310BDDA0;
    v4 = xmmword_2310BDDB0;
  }
  *(_OWORD *)(result + 24) = v4;
  *(_DWORD *)(result + 40) = 65793;
  *(_BYTE *)(result + 44) = 0;
LABEL_16:
  *(_BYTE *)(result + 52) = 0;
  return result;
}

double MTParameterFactory::initForceFilterParams(_OWORD *a1)
{
  double result;

  result = 0.125000028;
  *a1 = xmmword_2310BDDC0;
  return result;
}

double MTParameterFactory::initForceThresholdQualifiers(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0x3F4000003F000000;
  *(_OWORD *)(a1 + 12) = xmmword_2310BDDD0;
  *(_OWORD *)(a1 + 28) = xmmword_2310BDDE0;
  *(_OWORD *)(a1 + 44) = xmmword_2310BDDF0;
  *(_OWORD *)(a1 + 60) = xmmword_2310BDE00;
  *(_OWORD *)(a1 + 76) = xmmword_2310BDE10;
  *(_OWORD *)(a1 + 92) = xmmword_2310BDE20;
  *(_OWORD *)(a1 + 108) = xmmword_2310BDE30;
  result = 2.85924567e20;
  *(_QWORD *)(a1 + 124) = 0x442F00003E19999ALL;
  *(_DWORD *)(a1 + 132) = 1148846080;
  return result;
}

double MTParameterFactory::initForceActuationQualifiers(uint64_t a1)
{
  double result;

  *(_BYTE *)(a1 + 28) = 1;
  *(_OWORD *)a1 = xmmword_2310BDE40;
  result = 5.23869072e-11;
  *(_QWORD *)(a1 + 16) = 0x3DCCCCCD3F333333;
  *(_DWORD *)(a1 + 24) = 1065353216;
  return result;
}

double MTParameterFactory::initBasicForceActuationQualifiers(uint64_t a1)
{
  double result;

  *(_BYTE *)(a1 + 28) = 0;
  *(_OWORD *)a1 = xmmword_2310BDE50;
  *(_QWORD *)&result = 1065353216;
  *(_QWORD *)(a1 + 16) = 1065353216;
  *(_DWORD *)(a1 + 24) = 1065353216;
  return result;
}

void MTParameterFactory::initPathFilterParams(uint64_t a1, unsigned int a2, __int16 a3, int a4, uint64_t a5, unsigned int a6)
{
  unsigned int v6;
  char v8;
  float v10;
  BOOL v11;
  unsigned int v12;
  char v13;
  float v14;
  float v15;
  NSObject *v16;
  int v17;
  const char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  unsigned int v24;
  uint64_t v25;

  v6 = a6;
  v8 = a3;
  v25 = *MEMORY[0x24BDAC8D0];
  *(_BYTE *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 80) = 1;
  *(_BYTE *)(a1 + 102) = 0;
  *(_OWORD *)(a1 + 112) = xmmword_2310BDE60;
  *(_OWORD *)(a1 + 64) = xmmword_2310BDE70;
  if (a2 <= 0x3E7)
  {
    v10 = 0.8;
    if ((a3 & 0x100) != 0)
      v10 = 0.5;
    *(float *)(a1 + 4) = v10;
    *(_QWORD *)(a1 + 56) = 0x3EA28F5C40000000;
    *(_BYTE *)(a1 + 96) = 1;
    *(_WORD *)(a1 + 80) = 256;
    *(_BYTE *)(a1 + 102) = 1;
    *(_OWORD *)(a1 + 112) = xmmword_2310BDEB0;
    if (a2 == 4)
    {
      *(_OWORD *)(a1 + 56) = xmmword_2310BDEC0;
      *(_DWORD *)(a1 + 4) = 0;
    }
    goto LABEL_8;
  }
  *(_BYTE *)(a1 + 81) = 1;
  *(_DWORD *)(a1 + 4) = 1061997773;
  if (a2 - 3000 <= 0x3E7)
  {
    *(_QWORD *)(a1 + 56) = 0x3EA28F5C40000000;
    *(_BYTE *)(a1 + 96) = 1;
    *(_BYTE *)(a1 + 80) = 0;
    *(_BYTE *)(a1 + 102) = 1;
LABEL_8:
    v11 = a2 - 3000 < 0xFFFFFC18;
    v12 = a2 - 2000;
    goto LABEL_9;
  }
  v14 = 2.66;
  if (!a4)
    v14 = 2.0;
  v15 = 0.127;
  if (a4)
    v15 = 0.16891;
  *(float *)(a1 + 56) = v14;
  *(float *)(a1 + 60) = v15;
  v12 = a2 - 2000;
  if (a2 - 2000 < 0x3E8)
  {
    v13 = 0;
    *(_DWORD *)(a1 + 60) = 1045435305;
    *(_DWORD *)(a1 + 72) = 0x40000000;
    *(_OWORD *)(a1 + 4) = xmmword_2310BDE80;
    *(_OWORD *)(a1 + 20) = xmmword_2310BDE90;
    *(_OWORD *)(a1 + 36) = xmmword_2310BDEA0;
    *(_QWORD *)(a1 + 52) = 0x4080000040266666;
    *(_DWORD *)(a1 + 92) = 1032000111;
    *(_WORD *)(a1 + 97) = 257;
    *(_QWORD *)(a1 + 84) = 0x3D75C2903CA3D70BLL;
    goto LABEL_20;
  }
  v11 = 1;
LABEL_9:
  *(_OWORD *)(a1 + 8) = xmmword_2310BDED0;
  *(_OWORD *)(a1 + 24) = xmmword_2310BDEE0;
  *(_OWORD *)(a1 + 40) = xmmword_2310BDEF0;
  *(_QWORD *)(a1 + 84) = 0x3E9FBE773D449BA6;
  *(_DWORD *)(a1 + 92) = 1032000111;
  *(_BYTE *)(a1 + 98) = 0;
  if (v12 > 0xFFFFFC17)
  {
    *(_DWORD *)(a1 + 76) = 1036831949;
    *(_BYTE *)(a1 + 97) = v11 & a4 ^ 1;
    v13 = 1;
  }
  else if (v11)
  {
    v13 = 0;
    *(_BYTE *)(a1 + 97) = 0;
  }
  else
  {
    v13 = 0;
    *(_BYTE *)(a1 + 97) = 1;
  }
LABEL_20:
  *(_BYTE *)(a1 + 99) = v13;
  *(_BYTE *)(a1 + 100) = v13;
  *(_BYTE *)(a1 + 101) = v13;
  if (a6 >= 5)
  {
    v16 = MTLoggingPlugin();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v17 = 136315906;
      v18 = "[Error] ";
      v19 = 2080;
      v20 = "MTParameterFactory::";
      v21 = 2080;
      v22 = "_InitRadiusCorrectionParams";
      v23 = 1024;
      v24 = v6;
      _os_log_impl(&dword_231071000, v16, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s invalid size ID (%u)", (uint8_t *)&v17, 0x26u);
    }
    v6 = 0;
  }
  *(_QWORD *)(a1 + 104) = qword_2310BDFAC[v6];
  MTParameterFactory::updatePathFilterParamsWithNewSurfaceDimensions(a1, a5);
  *(_BYTE *)(a1 + 128) = (v8 & 0x40) != 0;
}

float MTParameterFactory::updatePathFilterParamsWithNewSurfaceDimensions(uint64_t a1, uint64_t a2)
{
  float v3;
  float result;

  v3 = fabsf(MTSurfaceDimensions::convertMillimetersToPixels(a2, 1.0));
  *(float *)a1 = v3;
  if (*(_BYTE *)(a1 + 81))
  {
    result = v3 * *(float *)(a1 + 60);
    *(float *)(a1 + 56) = result;
  }
  else
  {
    result = *(float *)(a1 + 56) / v3;
    *(float *)(a1 + 60) = result;
  }
  return result;
}

double MTParameterFactory::initRestZoneBalanceParameters(uint64_t a1)
{
  double result;

  *(_OWORD *)a1 = xmmword_2310BDF00;
  *(_OWORD *)(a1 + 16) = xmmword_2310BDF10;
  result = 5.23869071e-11;
  *(_OWORD *)(a1 + 32) = xmmword_2310BDF20;
  *(_DWORD *)(a1 + 48) = -1082130432;
  return result;
}

double MTParameterFactory::initMotionExtractionParams(uint64_t a1)
{
  double result;

  result = 512.000116;
  *(_QWORD *)a1 = 0x408000003CF5C290;
  *(_WORD *)(a1 + 8) = 257;
  return result;
}

uint64_t MTParameterFactory::initChordCyclingParams(uint64_t result, int a2)
{
  BOOL v2;
  float v3;

  *(_QWORD *)result = 0x3CCCCCCD3F19999ALL;
  v2 = (a2 - 2000) < 0x3E8;
  v3 = 10.0;
  *(_BYTE *)(result + 8) = v2;
  if ((a2 - 2000) < 0x3E8)
    v3 = 4.0;
  *(_BYTE *)(result + 16) = v2;
  *(float *)(result + 12) = v3;
  return result;
}

double MTParameterFactory::initTouchZoneParams(uint64_t a1, int a2, uint64_t a3, int a4)
{
  double result;
  float v5;
  float v6;

  result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if ((a2 - 1000) <= 0x3E7)
  {
    *(_BYTE *)a1 = 1;
    v5 = 3.0;
    if (a4)
      v5 = 0.5;
    v6 = 18.0;
    if (a4)
      v6 = 6.0;
    *(float *)(a1 + 20) = v5;
    *(float *)(a1 + 28) = v6;
    result = 375809602.0;
    *(_OWORD *)(a1 + 4) = xmmword_2310BDF30;
    *(_DWORD *)(a1 + 24) = 1094713344;
  }
  return result;
}

_QWORD *MTTrackpadEmbeddedEventDispatcher::createDispatcher(MTSimpleHIDManager *a1, const void *a2)
{
  _QWORD *v4;

  v4 = (_QWORD *)operator new();
  bzero(v4, 0x240uLL);
  MTSimpleEventDispatcher::MTSimpleEventDispatcher((MTSimpleEventDispatcher *)v4);
  v4[58] = v4 + 59;
  v4[59] = 0;
  v4[60] = 0;
  v4[61] = v4 + 61;
  v4[62] = v4 + 61;
  v4[63] = 0;
  *((_DWORD *)v4 + 134) = 1114636288;
  *v4 = &off_24FFF2888;
  v4[69] = MTABCLogger::createLogger((uint64_t)a2);
  MTTrackpadEventDispatcher::initialize((uint64_t)v4, a1, a2);
  return v4;
}

void sub_2310A7130(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10A1C40A9B27C98);
  _Unwind_Resume(a1);
}

void MTTrackpadEmbeddedEventDispatcher::initialize(uint64_t a1, MTSimpleHIDManager *a2, const void *a3)
{
  *(_QWORD *)(a1 + 552) = MTABCLogger::createLogger((uint64_t)a3);
  MTTrackpadEventDispatcher::initialize(a1, a2, a3);
}

MTABCLogger *MTTrackpadEmbeddedEventDispatcher::finalize(MTTrackpadEmbeddedEventDispatcher *this)
{
  id *v2;
  MTABCLogger *result;

  MTTrackpadEventDispatcher::finalize(this);
  v2 = (id *)*((_QWORD *)this + 70);
  if (v2)
  {
    MTABCLogger::endSession(*((_QWORD *)this + 69), v2, 0);
    *((_QWORD *)this + 70) = 0;
  }
  result = (MTABCLogger *)*((_QWORD *)this + 69);
  if (result)
  {
    MTABCLogger::~MTABCLogger(result);
    result = (MTABCLogger *)MEMORY[0x2348D0034]();
  }
  *((_QWORD *)this + 69) = 0;
  return result;
}

void MTTrackpadEmbeddedEventDispatcher::dispatchScrollEvent(MTTrackpadEmbeddedEventDispatcher *this, float a2)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315650;
    v4 = "[Error] ";
    v5 = 2080;
    v6 = "MTTrackpadEmbeddedEventDispatcher::";
    v7 = 2080;
    v8 = "dispatchScrollEvent";
    _os_log_impl(&dword_231071000, v2, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected request to dispatch a Scroll event. Ignoring.", (uint8_t *)&v3, 0x20u);
  }
}

void MTTrackpadEmbeddedEventDispatcher::dispatchPointingEvent(MTTrackpadEmbeddedEventDispatcher *this, int a2, int a3, int a4, unint64_t a5, char a6)
{
  int v7;
  NSObject *v8;
  int v9;
  const char *v10;
  NSObject *v11;
  uint32_t v12;
  NSObject *v13;
  int v14;
  BOOL v15;
  uint64_t RelativePointerEvent;
  const void *v17;
  NSObject *v18;
  int v19;
  int v20;
  NSObject *v21;
  const char *v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  _BYTE v30[10];
  char *v31;
  char __str[16];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  if ((a6 & 1) == 0)
  {
    v13 = MTLoggingPlugin();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136315650;
    v24 = "[Error] ";
    v25 = 2080;
    v26 = "MTTrackpadEmbeddedEventDispatcher::";
    v27 = 2080;
    v28 = "dispatchPointingEvent";
    v10 = "[HID] [MT] %s%s%s Unexpected request to dispatch a Pointer event. Ignoring.";
    v11 = v13;
    v12 = 32;
    goto LABEL_8;
  }
  v7 = a3 | a2;
  if (!(a3 | a2) && *((_DWORD *)this + 131) == a4)
  {
    v8 = MTLoggingPlugin();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      return;
    v9 = *((_DWORD *)this + 131);
    *(_DWORD *)buf = 136315906;
    v24 = "[Error] ";
    v25 = 2080;
    v26 = "MTTrackpadEmbeddedEventDispatcher::";
    v27 = 2080;
    v28 = "dispatchPointingEvent";
    v29 = 1024;
    *(_DWORD *)v30 = v9;
    v10 = "[HID] [MT] %s%s%s No change in device button state(%u). Ignoring.";
    v11 = v8;
    v12 = 38;
LABEL_8:
    _os_log_impl(&dword_231071000, v11, OS_LOG_TYPE_ERROR, v10, buf, v12);
    return;
  }
  *((_DWORD *)this + 131) = a4;
  v14 = *((_DWORD *)this + 130) | a4;
  *((_DWORD *)this + 136) = v14;
  if (*((_BYTE *)this + 512))
    v15 = (v14 & 1) == 0;
  else
    v15 = 1;
  if (!v15)
    *((_DWORD *)this + 136) = v14 & 0xFFFFFFFC | 2;
  RelativePointerEvent = IOHIDEventCreateRelativePointerEvent();
  if (RelativePointerEvent)
  {
    v17 = (const void *)RelativePointerEvent;
    memset(__str, 170, 11);
    if (*((_DWORD *)this + 136) == *((_DWORD *)this + 129))
      strcpy(__str, "no");
    else
      snprintf(__str, 0xBuLL, "0x%08x", *((_DWORD *)this + 136));
    v21 = MTLoggingPlugin();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      v24 = "";
      v22 = "yes";
      *(_DWORD *)buf = 136316162;
      v26 = "MTTrackpadEmbeddedEventDispatcher::";
      v25 = 2080;
      v27 = 2080;
      v28 = "dispatchPointingEvent";
      if (!v7)
        v22 = "no";
      v29 = 2082;
      *(_QWORD *)v30 = v22;
      *(_WORD *)&v30[8] = 2082;
      v31 = __str;
      _os_log_impl(&dword_231071000, v21, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Dispatching Pointer event (displacement? %{public}s) from FW (button? %{public}s)", buf, 0x34u);
    }
    (*(void (**)(MTTrackpadEmbeddedEventDispatcher *, const void *, _QWORD))(*(_QWORD *)this + 40))(this, v17, 0);
    CFRelease(v17);
  }
  else
  {
    v18 = MTLoggingPlugin();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v19 = *((_DWORD *)this + 136);
      v20 = *((_DWORD *)this + 129);
      *(_DWORD *)buf = 136316162;
      v24 = "[Error] ";
      v25 = 2080;
      v26 = "MTTrackpadEmbeddedEventDispatcher::";
      v27 = 2080;
      v28 = "dispatchPointingEvent";
      v29 = 1024;
      *(_DWORD *)v30 = v19;
      *(_WORD *)&v30[4] = 1024;
      *(_DWORD *)&v30[6] = v20;
      _os_log_impl(&dword_231071000, v18, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Failed to create relative pointer event with combined button state(%u) and previous button state(%u)", buf, 0x2Cu);
    }
  }
  *((_DWORD *)this + 129) = *((_DWORD *)this + 136);
}

uint64_t MTTrackpadEmbeddedEventDispatcher::shouldDispatchPointerEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v14;
  float v15;
  double v16;
  int v17;
  const __CFArray *Children;
  CFIndex Count;
  char v20;
  int IntegerValue;
  NSObject *v22;
  const char *v23;
  unsigned int v24;
  _BOOL4 v25;
  _BOOL4 v26;
  const char *v27;
  const char *v28;
  const char *v29;
  const char *v30;
  unsigned int v31;
  const char *v33;
  int v34;
  uint64_t v35;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;
  __int16 v45;
  CFIndex v46;
  __int16 v47;
  unsigned int v48;
  __int16 v49;
  _BOOL4 v50;
  __int16 v51;
  _BOOL4 v52;
  __int16 v53;
  char *v54;
  __int16 v55;
  const char *v56;
  __int16 v57;
  const char *v58;
  __int16 v59;
  const char *v60;
  __int16 v61;
  const char *v62;
  char __str[16];
  uint64_t v64;

  v64 = *MEMORY[0x24BDAC8D0];
  IOHIDEventGetFloatValue();
  v15 = v14;
  IOHIDEventGetFloatValue();
  *(float *)&v16 = v16;
  v17 = *(float *)&v16 != 0.0 || v15 != 0.0;
  Children = (const __CFArray *)IOHIDEventGetChildren();
  if (Children)
    Count = CFArrayGetCount(Children);
  else
    Count = 0;
  if ((IOHIDEventGetIntegerValue() & 2) != 0
    || (v20 = IOHIDEventGetIntegerValue(), a4)
    || v20 < 0
    || a5 && (IOHIDEventGetPhase() & 0xD) != 0
    || a6 && (IOHIDEventGetPhase() & 0xD) != 0
    || a7 && (IOHIDEventGetPhase() & 0xD) != 0
    || a8 && (IOHIDEventGetPhase() & 0xD) != 0)
  {
    memset(__str, 170, 11);
    if (a4)
    {
      IntegerValue = IOHIDEventGetIntegerValue();
      snprintf(__str, 0xBuLL, "0x%08x", IntegerValue);
    }
    else
    {
      strcpy(__str, "no");
    }
    v22 = MTLoggingPlugin();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      if (v17)
        v23 = "yes";
      else
        v23 = "no";
      v33 = v23;
      v35 = a1;
      v24 = (IOHIDEventGetIntegerValue() >> 7) & 1;
      v34 = v17;
      v25 = IOHIDEventGetIntegerValue() == 1;
      *(_DWORD *)buf = 136318210;
      v38 = "";
      v26 = IOHIDEventGetIntegerValue() == 1;
      v39 = 2080;
      v40 = "MTTrackpadEmbeddedEventDispatcher::";
      if (a5)
        v27 = "yes";
      else
        v27 = "no";
      v41 = 2080;
      v42 = "shouldDispatchPointerEvent";
      v43 = 2082;
      if (a6)
        v28 = "yes";
      else
        v28 = "no";
      v44 = v33;
      if (a7)
        v29 = "yes";
      else
        v29 = "no";
      v45 = 2048;
      if (a8)
        v30 = "yes";
      else
        v30 = "no";
      v46 = Count;
      v47 = 1024;
      v48 = v24;
      a1 = v35;
      v49 = 1024;
      v50 = v25;
      v17 = v34;
      v51 = 1024;
      v52 = v26;
      v53 = 2082;
      v54 = __str;
      v55 = 2082;
      v56 = v27;
      v57 = 2082;
      v58 = v28;
      v59 = 2082;
      v60 = v29;
      v61 = 2082;
      v62 = v30;
      _os_log_impl(&dword_231071000, v22, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Dispatching Pointer event (displacement? %{public}s) with digitizer (%lu contacts, cancel=%d, touching=%d, inrange=%d), button? %{public}s, scroll? %{public}s, scale? %{public}s, rotate? %{public}s, translate? %{public}s", buf, 0x78u);
    }
  }
  if (IOHIDEventGetIntegerValue() || (IOHIDEventGetIntegerValue() & 2) != 0 || (IOHIDEventGetIntegerValue() & 1) != 0)
  {
    v31 = 1;
  }
  else if (a4 | a5 | a6 | a7 | a8)
  {
    v31 = 1;
  }
  else
  {
    v31 = v17;
  }
  if (*(_QWORD *)(a1 + 552))
    MTTrackpadEmbeddedEventDispatcher::sanityCheck(a1, a3, a5, a6, a7, a8, v17);
  if (*(_BYTE *)(a1 + 424))
    return 1;
  else
    return v31;
}

void MTTrackpadEmbeddedEventDispatcher::sanityCheck(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  int v12;
  BOOL v13;
  char Phase;
  BOOL v16;
  int v17;
  BOOL v18;
  char v19;
  BOOL v21;
  int v22;
  BOOL v23;
  char v24;
  BOOL v26;
  int v27;
  _BOOL4 v28;
  char v29;
  _BOOL4 v31;
  int v32;
  const __CFArray *Children;
  const __CFArray *v34;
  CFIndex v35;
  unsigned int v36;
  char v37;
  NSObject *v38;
  const char *v39;
  const char *v40;
  int v41;
  int v42;
  const char *v43;
  NSObject *v44;
  const char *v45;
  const char *v46;
  int v47;
  int v48;
  const char *v49;
  id *v50;
  NSObject *v51;
  const char *v52;
  const char *v53;
  int v54;
  int v55;
  const char *v56;
  _BOOL4 v57;
  int v58;
  const char *v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  const char *v63;
  __int16 v64;
  const char *v65;
  __int16 v66;
  const char *v67;
  __int16 v68;
  const char *v69;
  uint64_t v70;

  v70 = *MEMORY[0x24BDAC8D0];
  v12 = *(unsigned __int8 *)(a1 + 569);
  v13 = *(_BYTE *)(a1 + 569) != 0;
  if (a3)
  {
    Phase = IOHIDEventGetPhase();
    v16 = (Phase & 0xC) == 0 && v12 != 0;
    v13 = (Phase & 1) != 0 || v16;
  }
  *(_BYTE *)(a1 + 569) = v13;
  v17 = *(unsigned __int8 *)(a1 + 570);
  v18 = *(_BYTE *)(a1 + 570) != 0;
  if (a4)
  {
    v19 = IOHIDEventGetPhase();
    v21 = (v19 & 0xC) == 0 && v17 != 0;
    v18 = (v19 & 1) != 0 || v21;
  }
  *(_BYTE *)(a1 + 570) = v18;
  v22 = *(unsigned __int8 *)(a1 + 571);
  v23 = *(_BYTE *)(a1 + 571) != 0;
  if (a5)
  {
    v24 = IOHIDEventGetPhase();
    v26 = (v24 & 0xC) == 0 && v22 != 0;
    v23 = (v24 & 1) != 0 || v26;
  }
  *(_BYTE *)(a1 + 571) = v23;
  v27 = *(unsigned __int8 *)(a1 + 572);
  v28 = *(_BYTE *)(a1 + 572) != 0;
  if (a6)
  {
    v29 = IOHIDEventGetPhase();
    v31 = (v29 & 0xC) == 0 && v27 != 0;
    v28 = (v29 & 1) != 0 || v31;
  }
  *(_BYTE *)(a1 + 572) = v28;
  if (*(_BYTE *)(a1 + 570))
  {
    v32 = 1;
  }
  else if (*(_BYTE *)(a1 + 571))
  {
    v32 = 1;
  }
  else
  {
    v32 = v28;
  }
  Children = (const __CFArray *)IOHIDEventGetChildren();
  if (Children && (v34 = Children, CFArrayGetCount(Children) >= 1))
  {
    v35 = 0;
    v36 = 0;
    do
    {
      CFArrayGetValueAtIndex(v34, v35);
      if (IOHIDEventGetIntegerValue() == 1)
        ++v36;
      ++v35;
    }
    while (v35 < CFArrayGetCount(v34));
    if (v36 >= 2)
    {
      if (!*(_QWORD *)(a1 + 560))
      {
        *(_QWORD *)(a1 + 560) = MTABCLogger::startSession(*(MTABCLogger **)(a1 + 552), "ipados_trackpad_orientation_gesture", 60.0);
        *(_BYTE *)(a1 + 568) = 0;
      }
      v36 = 1;
    }
  }
  else
  {
    v36 = 0;
  }
  v37 = v32 ^ 1;
  if (!*(_BYTE *)(a1 + 569))
    v37 = 1;
  if ((v37 & 1) == 0)
  {
    v38 = MTLoggingPlugin();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      v39 = "yes";
      if (*(_BYTE *)(a1 + 570))
        v40 = "yes";
      else
        v40 = "no";
      v41 = *(unsigned __int8 *)(a1 + 571);
      v59 = "[Error] ";
      v61 = "MTTrackpadEmbeddedEventDispatcher::";
      v42 = *(unsigned __int8 *)(a1 + 572);
      if (v41)
        v43 = "yes";
      else
        v43 = "no";
      v58 = 136316418;
      v60 = 2080;
      if (!v42)
        v39 = "no";
      v62 = 2080;
      v63 = "sanityCheck";
      v64 = 2082;
      v65 = v40;
      v66 = 2082;
      v67 = v43;
      v68 = 2082;
      v69 = v39;
      _os_log_impl(&dword_231071000, v38, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Attempting to scroll at the same time we scale %{public}s / rotate %{public}s / translate %{public}s", (uint8_t *)&v58, 0x3Eu);
    }
    *(_BYTE *)(a1 + 568) = 1;
  }
  if ((v32 & a7) == 1)
  {
    v44 = MTLoggingPlugin();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      v45 = "yes";
      if (*(_BYTE *)(a1 + 570))
        v46 = "yes";
      else
        v46 = "no";
      v47 = *(unsigned __int8 *)(a1 + 571);
      v59 = "[Error] ";
      v61 = "MTTrackpadEmbeddedEventDispatcher::";
      v48 = *(unsigned __int8 *)(a1 + 572);
      if (v47)
        v49 = "yes";
      else
        v49 = "no";
      v58 = 136316418;
      v60 = 2080;
      if (!v48)
        v45 = "no";
      v62 = 2080;
      v63 = "sanityCheck";
      v64 = 2082;
      v65 = v46;
      v66 = 2082;
      v67 = v49;
      v68 = 2082;
      v69 = v45;
      _os_log_impl(&dword_231071000, v44, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Active pointer at the same time we scale %{public}s / rotate %{public}s / translate %{public}s (stuck orientation gesture?)", (uint8_t *)&v58, 0x3Eu);
    }
    *(_BYTE *)(a1 + 568) = 1;
  }
  if (!v36)
  {
    v50 = *(id **)(a1 + 560);
    if (v50)
    {
      if ((v32 & 1) != 0)
      {
        v51 = MTLoggingPlugin();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
        {
          v52 = "yes";
          if (*(_BYTE *)(a1 + 570))
            v53 = "yes";
          else
            v53 = "no";
          v54 = *(unsigned __int8 *)(a1 + 571);
          v59 = "[Error] ";
          v61 = "MTTrackpadEmbeddedEventDispatcher::";
          v55 = *(unsigned __int8 *)(a1 + 572);
          if (v54)
            v56 = "yes";
          else
            v56 = "no";
          v58 = 136316418;
          v60 = 2080;
          if (!v55)
            v52 = "no";
          v62 = 2080;
          v63 = "sanityCheck";
          v64 = 2082;
          v65 = v53;
          v66 = 2082;
          v67 = v56;
          v68 = 2082;
          v69 = v52;
          _os_log_impl(&dword_231071000, v51, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s No contacts but we are still trying to scale %{public}s / rotate %{public}s / translate %{public}s (stuck orientation gesture?)", (uint8_t *)&v58, 0x3Eu);
        }
        v57 = 1;
        *(_BYTE *)(a1 + 568) = 1;
        v50 = *(id **)(a1 + 560);
      }
      else
      {
        v57 = *(_BYTE *)(a1 + 568) != 0;
      }
      MTABCLogger::endSession(*(_QWORD *)(a1 + 552), v50, v57);
      *(_QWORD *)(a1 + 560) = 0;
      *(_BYTE *)(a1 + 568) = 0;
    }
  }
}

void MTTrackpadEmbeddedEventDispatcher::dispatchEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFArray *Children;
  NSObject *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int Type;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (IOHIDEventGetType() == 17)
  {
    Children = (const __CFArray *)IOHIDEventGetChildren();
    if (!Children || !CFArrayGetCount(Children))
    {
      v7 = MTLoggingPlugin();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v9 = 136315650;
        v10 = "";
        v11 = 2080;
        v12 = "MTTrackpadEmbeddedEventDispatcher::";
        v13 = 2080;
        v14 = "dispatchEvent";
        _os_log_impl(&dword_231071000, v7, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Dispatching standalone Pointer event", (uint8_t *)&v9, 0x20u);
      }
    }
    MTSimpleEventDispatcher::dispatchEvent(a1, a2, a3);
  }
  else
  {
    v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v9 = 136315906;
      v10 = "[Error] ";
      v11 = 2080;
      v12 = "MTTrackpadEmbeddedEventDispatcher::";
      v13 = 2080;
      v14 = "dispatchEvent";
      v15 = 1024;
      Type = IOHIDEventGetType();
      _os_log_impl(&dword_231071000, v8, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected standalone event type: %u. Eating it", (uint8_t *)&v9, 0x26u);
    }
  }
}

void MTTrackpadEmbeddedEventDispatcher::handleEvent(unsigned int *a1, uint64_t a2, unsigned int a3)
{
  uint64_t Children;
  const __CFAllocator *v7;
  const __CFArray *v8;
  const __CFArray *Copy;
  CFIndex Count;
  __CFArray *Mutable;
  uint64_t RelativePointerEvent;
  const void *v13;
  BOOL v14;
  CFIndex v15;
  const void *v16;
  unsigned int IntegerValue;
  int v18;
  const void *v19;
  const void *v20;
  const void *v21;
  double v22;
  float v23;
  double v24;
  float v25;
  double v26;
  float v27;
  _BOOL4 v28;
  int v29;
  unsigned int NextScrollPhase;
  NSObject *v31;
  uint64_t v32;
  const void *v33;
  uint64_t ScaleEvent;
  uint64_t v35;
  const void *v36;
  uint64_t ButtonEvent;
  int8x8_t v38;
  uint8x8_t v39;
  const void *v40;
  uint64_t RotationEvent;
  uint64_t v42;
  uint64_t TranslationEvent;
  uint64_t v44;
  uint64_t ScrollEvent;
  const __CFArray *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  NSObject *v50;
  NSObject *v51;
  NSObject *v52;
  os_log_type_t v53;
  const char *v54;
  uint32_t v55;
  int Type;
  NSObject *v57;
  _BOOL4 v58;
  int v59;
  NSObject *v60;
  int v61;
  NSObject *v62;
  NSObject *v63;
  NSObject *v64;
  NSObject *v65;
  NSObject *v66;
  NSObject *v67;
  NSObject *v68;
  os_log_type_t v69;
  const char *v70;
  uint32_t v71;
  NSObject *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  const void *v76;
  const void *v77;
  const void *v78;
  const void *v79;
  const void *v80;
  CFIndex v81;
  CFIndex v82;
  CFIndex i;
  const void *ValueAtIndex;
  NSObject *v85;
  const char *v86;
  NSObject *v87;
  uint32_t v88;
  NSObject *v89;
  const void *v90;
  unsigned int v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  const void *v96;
  char v97;
  uint8_t buf[4];
  const char *v99;
  __int16 v100;
  const char *v101;
  __int16 v102;
  const char *v103;
  __int16 v104;
  uint64_t v105;
  __int16 v106;
  uint64_t v107;
  uint64_t v108;

  v108 = *MEMORY[0x24BDAC8D0];
  if (IOHIDEventGetType() == 11)
  {
    if (IOHIDEventGetIntegerValue() == 1)
      goto LABEL_3;
    v89 = MTLoggingPlugin();
    if (!os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
      goto LABEL_3;
    *(_DWORD *)buf = 136315650;
    v99 = "[Error] ";
    v100 = 2080;
    v101 = "MTTrackpadEmbeddedEventDispatcher::";
    v102 = 2080;
    v103 = "handleEvent";
    v86 = "[HID] [MT] %s%s%s Unexpected digitizer event. Eating it.";
    v87 = v89;
    v88 = 32;
  }
  else
  {
    v85 = MTLoggingPlugin();
    if (!os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
      goto LABEL_3;
    *(_DWORD *)buf = 136315906;
    v99 = "[Error] ";
    v100 = 2080;
    v101 = "MTTrackpadEmbeddedEventDispatcher::";
    v102 = 2080;
    v103 = "handleEvent";
    v104 = 1024;
    LODWORD(v105) = IOHIDEventGetType();
    v86 = "[HID] [MT] %s%s%s Unexpected event type: %u Eating it.";
    v87 = v85;
    v88 = 38;
  }
  _os_log_impl(&dword_231071000, v87, OS_LOG_TYPE_ERROR, v86, buf, v88);
LABEL_3:
  (*(void (**)(unsigned int *))(*(_QWORD *)a1 + 112))(a1);
  Children = IOHIDEventGetChildren();
  v7 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  if (Children)
  {
    v8 = (const __CFArray *)IOHIDEventGetChildren();
    Copy = CFArrayCreateCopy(v7, v8);
    Count = CFArrayGetCount(Copy);
  }
  else
  {
    Copy = 0;
    Count = 0;
  }
  Mutable = CFArrayCreateMutable(v7, 0, MEMORY[0x24BDBD690]);
  mach_absolute_time();
  RelativePointerEvent = IOHIDEventCreateRelativePointerEvent();
  v13 = (const void *)RelativePointerEvent;
  if (Mutable)
    v14 = RelativePointerEvent == 0;
  else
    v14 = 1;
  if (v14)
  {
    v16 = 0;
    v76 = 0;
    v77 = 0;
    v79 = 0;
    v78 = 0;
  }
  else
  {
    v91 = a3;
    v96 = (const void *)RelativePointerEvent;
    if (Count >= 1)
    {
      v15 = 0;
      v92 = 0;
      v93 = 0;
      v94 = 0;
      v95 = 0;
      v16 = 0;
      v97 = 0;
      while (1)
      {
        CFArrayGetValueAtIndex(Copy, v15);
        if (IOHIDEventGetType() != 11)
          break;
LABEL_62:
        if (Count == ++v15)
          goto LABEL_106;
      }
      if (IOHIDEventGetType() == 17)
      {
        if (*((_BYTE *)a1 + 541))
          goto LABEL_59;
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        if ((v97 & 1) == 0)
        {
          IOHIDEventSetFloatValue();
          IOHIDEventSetFloatValue();
          v97 = 1;
          goto LABEL_59;
        }
        v33 = v16;
        v62 = MTLoggingPlugin();
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v99 = "[Error] ";
          v100 = 2080;
          v101 = "MTTrackpadEmbeddedEventDispatcher::";
          v102 = 2080;
          v103 = "handleEvent";
          _os_log_impl(&dword_231071000, v62, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected multiple pointer events. Eating it.", buf, 0x20u);
        }
        v97 = 1;
        goto LABEL_75;
      }
      if (IOHIDEventGetType() == 2)
      {
        IntegerValue = IOHIDEventGetIntegerValue();
        a1[130] = IntegerValue;
        v18 = a1[131] | IntegerValue;
        a1[136] = v18;
        if (*((_BYTE *)a1 + 512) && (v18 & 1) != 0)
          a1[136] = v18 & 0xFFFFFFFC | 2;
        if (v16)
        {
          v19 = v16;
          mach_absolute_time();
          v20 = (const void *)IOHIDEventCreateRelativePointerEvent();
          if (v20)
          {
            v21 = v20;
            CFArrayAppendValue(Mutable, v20);
            CFRelease(v21);
          }
          v16 = v19;
          v13 = v96;
        }
        else
        {
          IOHIDEventSetFloatValue();
          mach_absolute_time();
          IOHIDEventGetEventFlags();
          ButtonEvent = IOHIDEventCreateButtonEvent();
          v16 = (const void *)ButtonEvent;
          if (!ButtonEvent
            || (v38 = (int8x8_t)a1[136], v38.i32[0])
            && (v39 = (uint8x8_t)vcnt_s8(v38), v39.i16[0] = vaddlv_u8(v39), v39.i32[0] > 1u))
          {
            v78 = (const void *)v92;
            v79 = (const void *)v93;
            v77 = (const void *)v94;
            v76 = (const void *)v95;
            goto LABEL_114;
          }
          v40 = (const void *)ButtonEvent;
          IOHIDEventSetIntegerValue();
          v16 = v40;
          IOHIDEventSetIntegerValue();
          IOHIDEventAppendEvent();
        }
        a1[129] = a1[136];
        goto LABEL_59;
      }
      if (IOHIDEventGetType() == 6)
      {
        if (!*((_BYTE *)a1 + 540))
          goto LABEL_59;
        IOHIDEventGetFloatValue();
        v23 = v22;
        IOHIDEventGetFloatValue();
        v25 = v24;
        IOHIDEventGetFloatValue();
        v28 = v23 != 0.0;
        if (v25 != 0.0)
          v28 = 1;
        v27 = v26;
        v29 = v27 != 0.0 || v28;
        NextScrollPhase = MTTrackpadEventDispatcher::getNextScrollPhase((MTTrackpadEventDispatcher *)a1, a1[132], v29);
        a1[132] = NextScrollPhase;
        if (!(unsigned __int16)MTTrackpadEventDispatcher::getHIDPhaseFromScrollPhase((MTTrackpadEventDispatcher *)a1, NextScrollPhase))goto LABEL_59;
        v90 = v16;
        if (v95)
        {
          v31 = MTLoggingPlugin();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315650;
            v99 = "[Debug] ";
            v100 = 2080;
            v101 = "MTTrackpadEmbeddedEventDispatcher::";
            v102 = 2080;
            v103 = "handleEvent";
            _os_log_impl(&dword_231071000, v31, OS_LOG_TYPE_DEBUG, "[HID] [MT] %s%s%s Multiple scroll events. Merging.", buf, 0x20u);
          }
          v32 = v95;
          IOHIDEventGetFloatValue();
          IOHIDEventSetFloatValue();
          IOHIDEventGetFloatValue();
          IOHIDEventSetFloatValue();
          IOHIDEventGetFloatValue();
          IOHIDEventSetFloatValue();
        }
        else
        {
          mach_absolute_time();
          IOHIDEventGetEventFlags();
          ScrollEvent = IOHIDEventCreateScrollEvent();
          if (!ScrollEvent)
          {
            v76 = 0;
            v78 = (const void *)v92;
            v79 = (const void *)v93;
            v77 = (const void *)v94;
            goto LABEL_114;
          }
          v32 = ScrollEvent;
          IOHIDEventAppendEvent();
        }
        v95 = v32;
        IOHIDEventSetPhase();
        goto LABEL_58;
      }
      if (IOHIDEventGetType() == 7)
      {
        v33 = v16;
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        IOHIDEventGetPhase();
        if (!v94)
        {
          mach_absolute_time();
          IOHIDEventGetEventFlags();
          ScaleEvent = IOHIDEventCreateScaleEvent();
          if (!ScaleEvent)
          {
            v77 = 0;
            v78 = (const void *)v92;
            v79 = (const void *)v93;
            goto LABEL_112;
          }
          v35 = ScaleEvent;
          IOHIDEventSetPhase();
          v36 = v96;
          v94 = v35;
LABEL_54:
          IOHIDEventAppendEvent();
          v16 = v33;
          v13 = v36;
          goto LABEL_59;
        }
        v63 = MTLoggingPlugin();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v99 = "[Error] ";
          v100 = 2080;
          v101 = "MTTrackpadEmbeddedEventDispatcher::";
          v102 = 2080;
          v103 = "handleEvent";
          v52 = v63;
          v53 = OS_LOG_TYPE_ERROR;
          v54 = "[HID] [MT] %s%s%s Unexpected multiple scale events. Eating the latest.";
          goto LABEL_73;
        }
        goto LABEL_75;
      }
      if (IOHIDEventGetType() == 5)
      {
        v33 = v16;
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        IOHIDEventGetPhase();
        if (!v93)
        {
          mach_absolute_time();
          IOHIDEventGetEventFlags();
          RotationEvent = IOHIDEventCreateRotationEvent();
          if (!RotationEvent)
          {
            v79 = 0;
            v78 = (const void *)v92;
            goto LABEL_142;
          }
          v42 = RotationEvent;
          IOHIDEventSetPhase();
          v36 = v96;
          v93 = v42;
          goto LABEL_54;
        }
        v64 = MTLoggingPlugin();
        if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v99 = "[Error] ";
          v100 = 2080;
          v101 = "MTTrackpadEmbeddedEventDispatcher::";
          v102 = 2080;
          v103 = "handleEvent";
          v52 = v64;
          v53 = OS_LOG_TYPE_ERROR;
          v54 = "[HID] [MT] %s%s%s Unexpected multiple rotate events. Eating the latest.";
          goto LABEL_73;
        }
        goto LABEL_75;
      }
      if (IOHIDEventGetType() == 4)
      {
        v33 = v16;
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        IOHIDEventGetPhase();
        if (!v92)
        {
          mach_absolute_time();
          IOHIDEventGetEventFlags();
          TranslationEvent = IOHIDEventCreateTranslationEvent();
          if (!TranslationEvent)
          {
            v78 = 0;
            v79 = (const void *)v93;
LABEL_142:
            v77 = (const void *)v94;
LABEL_112:
            v76 = (const void *)v95;
            goto LABEL_113;
          }
          v44 = TranslationEvent;
          IOHIDEventSetPhase();
          v36 = v96;
          v92 = v44;
          goto LABEL_54;
        }
        v65 = MTLoggingPlugin();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v99 = "[Error] ";
          v100 = 2080;
          v101 = "MTTrackpadEmbeddedEventDispatcher::";
          v102 = 2080;
          v103 = "handleEvent";
          v52 = v65;
          v53 = OS_LOG_TYPE_ERROR;
          v54 = "[HID] [MT] %s%s%s Unexpected multiple translate events. Eating the latest.";
          goto LABEL_73;
        }
        goto LABEL_75;
      }
      if (IOHIDEventGetType() != 1)
      {
        v33 = v16;
        if (IOHIDEventGetType() != 32)
        {
          if (IOHIDEventGetType() == 3)
          {
            v72 = MTLoggingPlugin();
            if (!os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
              goto LABEL_75;
            v73 = IOHIDEventGetIntegerValue();
            *(_DWORD *)buf = 136315906;
            v99 = "[Error] ";
            v100 = 2080;
            v101 = "MTTrackpadEmbeddedEventDispatcher::";
            v102 = 2080;
            v103 = "handleEvent";
            v104 = 2048;
            v105 = v73;
            v52 = v72;
            v53 = OS_LOG_TYPE_ERROR;
            v54 = "[HID] [MT] %s%s%s Unexpected keyboard child event with usage %lu. Eating it";
          }
          else
          {
            Type = IOHIDEventGetType();
            v57 = MTLoggingPlugin();
            v58 = os_log_type_enabled(v57, OS_LOG_TYPE_ERROR);
            if (Type != 24)
            {
              v16 = v33;
              if (v58)
              {
                v59 = IOHIDEventGetType();
                *(_DWORD *)buf = 136315906;
                v99 = "[Error] ";
                v100 = 2080;
                v101 = "MTTrackpadEmbeddedEventDispatcher::";
                v102 = 2080;
                v103 = "handleEvent";
                v104 = 1024;
                LODWORD(v105) = v59;
                _os_log_impl(&dword_231071000, v57, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected child event type: %u. Eating it", buf, 0x26u);
              }
              goto LABEL_80;
            }
            if (!v58)
              goto LABEL_75;
            v74 = IOHIDEventGetIntegerValue();
            *(_DWORD *)buf = 136315906;
            v99 = "[Error] ";
            v100 = 2080;
            v101 = "MTTrackpadEmbeddedEventDispatcher::";
            v102 = 2080;
            v103 = "handleEvent";
            v104 = 2048;
            v105 = v74;
            v52 = v57;
            v53 = OS_LOG_TYPE_ERROR;
            v54 = "[HID] [MT] %s%s%s Unexpected hotkey child event with value %lu. Eating it";
          }
          v55 = 42;
          goto LABEL_74;
        }
        v51 = MTLoggingPlugin();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315650;
          v99 = "[Debug] ";
          v100 = 2080;
          v101 = "MTTrackpadEmbeddedEventDispatcher::";
          v102 = 2080;
          v103 = "handleEvent";
          v52 = v51;
          v53 = OS_LOG_TYPE_DEBUG;
          v54 = "[HID] [MT] %s%s%s Force event. Ignoring.";
LABEL_73:
          v55 = 32;
LABEL_74:
          _os_log_impl(&dword_231071000, v52, v53, v54, buf, v55);
        }
LABEL_75:
        v16 = v33;
LABEL_80:
        v13 = v96;
LABEL_59:
        if (IOHIDEventGetChildren())
        {
          v46 = (const __CFArray *)IOHIDEventGetChildren();
          if (CFArrayGetCount(v46) >= 1)
          {
            v60 = MTLoggingPlugin();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
            {
              v61 = IOHIDEventGetType();
              *(_DWORD *)buf = 136315906;
              v99 = "[Error] ";
              v100 = 2080;
              v101 = "MTTrackpadEmbeddedEventDispatcher::";
              v102 = 2080;
              v103 = "handleEvent";
              v104 = 1024;
              LODWORD(v105) = v61;
              _os_log_impl(&dword_231071000, v60, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected grandchild events inside event type: %u. Eating them", buf, 0x26u);
            }
          }
        }
        IOHIDEventRemoveEvent();
        goto LABEL_62;
      }
      v90 = v16;
      v47 = IOHIDEventGetIntegerValue();
      v48 = IOHIDEventGetIntegerValue();
      v49 = v48;
      if (v47 == 65280 && v48 == 17)
      {
        v50 = MTLoggingPlugin();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315650;
          v99 = "[Debug] ";
          v100 = 2080;
          v101 = "MTTrackpadEmbeddedEventDispatcher::";
          v102 = 2080;
          v103 = "handleEvent";
          _os_log_impl(&dword_231071000, v50, OS_LOG_TYPE_DEBUG, "[HID] [MT] %s%s%s Vendor-defined Force event. Appending!", buf, 0x20u);
        }
        IOHIDEventAppendEvent();
LABEL_58:
        v16 = v90;
        goto LABEL_59;
      }
      v66 = MTLoggingPlugin();
      v67 = v66;
      if (v47 == 65280 && v49 == 1)
      {
        if (!os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
        {
LABEL_97:
          v16 = v90;
          goto LABEL_80;
        }
        *(_DWORD *)buf = 136315650;
        v99 = "[Debug] ";
        v100 = 2080;
        v101 = "MTTrackpadEmbeddedEventDispatcher::";
        v102 = 2080;
        v103 = "handleEvent";
        v68 = v67;
        v69 = OS_LOG_TYPE_DEBUG;
        v70 = "[HID] [MT] %s%s%s Vendor-defined Momentum event. Ignoring.";
        v71 = 32;
      }
      else
      {
        if (!os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
          goto LABEL_97;
        *(_DWORD *)buf = 136316162;
        v99 = "[Error] ";
        v100 = 2080;
        v101 = "MTTrackpadEmbeddedEventDispatcher::";
        v102 = 2080;
        v103 = "handleEvent";
        v104 = 2048;
        v105 = v47;
        v106 = 2048;
        v107 = v49;
        v68 = v67;
        v69 = OS_LOG_TYPE_ERROR;
        v70 = "[HID] [MT] %s%s%s Unexpected vendor-defined child event with usage page %lu and usage %lu. Eating it";
        v71 = 52;
      }
      _os_log_impl(&dword_231071000, v68, v69, v70, buf, v71);
      goto LABEL_97;
    }
    v16 = 0;
    v94 = 0;
    v95 = 0;
    v92 = 0;
    v93 = 0;
LABEL_106:
    IOHIDEventAppendEvent();
    v75 = a2;
    v77 = (const void *)v94;
    v76 = (const void *)v95;
    v78 = (const void *)v92;
    v79 = (const void *)v93;
    if (MTTrackpadEmbeddedEventDispatcher::shouldDispatchPointerEvent((uint64_t)a1, (uint64_t)v13, v75, (uint64_t)v16, v95, v94, v93, v92))
    {
      v80 = v13;
      v33 = v16;
      (*(void (**)(unsigned int *, const void *, _QWORD))(*(_QWORD *)a1 + 40))(a1, v80, v91);
      v81 = CFArrayGetCount(Mutable);
      if (v81 >= 1)
      {
        v82 = v81;
        for (i = 0; i != v82; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(Mutable, i);
          if (ValueAtIndex)
            (*(void (**)(unsigned int *, const void *, _QWORD))(*(_QWORD *)a1 + 40))(a1, ValueAtIndex, v91);
        }
        goto LABEL_112;
      }
LABEL_113:
      v16 = v33;
      v13 = v96;
    }
  }
LABEL_114:
  if (Mutable)
    CFRelease(Mutable);
  if (v13)
    CFRelease(v13);
  if (Copy)
    CFRelease(Copy);
  if (v16)
    CFRelease(v16);
  if (v76)
    CFRelease(v76);
  if (v77)
    CFRelease(v77);
  if (v79)
    CFRelease(v79);
  if (v78)
    CFRelease(v78);
}

void MTTrackpadEmbeddedEventDispatcher::~MTTrackpadEmbeddedEventDispatcher(MTTrackpadEmbeddedEventDispatcher *this)
{
  *(_QWORD *)this = &off_24FFF1700;
  std::__list_imp<double>::clear((_QWORD *)this + 61);
  std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy((uint64_t)this + 464, *((_QWORD **)this + 59));
  MTSimpleEventDispatcher::~MTSimpleEventDispatcher(this);
}

{
  *(_QWORD *)this = &off_24FFF1700;
  std::__list_imp<double>::clear((_QWORD *)this + 61);
  std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy((uint64_t)this + 464, *((_QWORD **)this + 59));
  MTSimpleEventDispatcher::~MTSimpleEventDispatcher(this);
  JUMPOUT(0x2348D0034);
}

uint64_t MTModeSwitcher::createModeSwitcher(MTModeSwitcher *this, MTSimpleHIDManager *a2)
{
  uint64_t v3;
  uint64_t MultipleFirmwaresConfig;
  const __CFDictionary *v5;
  _OWORD *v6;

  v3 = (*(uint64_t (**)(MTModeSwitcher *, MTSimpleHIDManager *))(*(_QWORD *)this + 80))(this, a2);
  if (v3)
  {
    MultipleFirmwaresConfig = MTDeviceGetMultipleFirmwaresConfig();
    if (MultipleFirmwaresConfig)
    {
      v5 = (const __CFDictionary *)MultipleFirmwaresConfig;
      if (MTDeviceGetParserType() == 4)
      {
        v3 = operator new();
        *(_QWORD *)(v3 + 16) = 255;
        *(_BYTE *)(v3 + 24) = 0;
        *(_QWORD *)(v3 + 28) = 255;
        *(_QWORD *)v3 = &off_24FFF29B0;
        *(_QWORD *)(v3 + 8) = this;
        return v3;
      }
      v3 = operator new();
      *(_QWORD *)(v3 + 16) = 255;
      *(_BYTE *)(v3 + 24) = 0;
      *(_QWORD *)(v3 + 28) = 255;
      *(_QWORD *)v3 = &off_24FFF29F0;
      *(_QWORD *)(v3 + 8) = this;
      v6 = (_OWORD *)operator new();
      *(_QWORD *)(v3 + 40) = v6;
      *v6 = 0u;
      v6[1] = 0u;
      *(_BYTE *)(v3 + 48) = 1;
      if (!MTMultipleFirmwaresModeSwitcher::init((MTMultipleFirmwaresModeSwitcher *)v3, v5))
        return v3;
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    }
    return 0;
  }
  return v3;
}

void sub_2310A9340(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10A1C4054FFC65BLL);
  _Unwind_Resume(a1);
}

void MTNoOpModeSwitcher::MTNoOpModeSwitcher(MTNoOpModeSwitcher *this, MTSimpleHIDManager *a2)
{
  *((_QWORD *)this + 2) = 255;
  *((_BYTE *)this + 24) = 0;
  *(_QWORD *)((char *)this + 28) = 255;
  *(_QWORD *)this = &off_24FFF29B0;
  *((_QWORD *)this + 1) = a2;
}

{
  *((_QWORD *)this + 2) = 255;
  *((_BYTE *)this + 24) = 0;
  *(_QWORD *)((char *)this + 28) = 255;
  *(_QWORD *)this = &off_24FFF29B0;
  *((_QWORD *)this + 1) = a2;
}

void MTMultipleFirmwaresModeSwitcher::MTMultipleFirmwaresModeSwitcher(MTMultipleFirmwaresModeSwitcher *this, MTSimpleHIDManager *a2)
{
  _OWORD *v3;

  *((_QWORD *)this + 2) = 255;
  *((_BYTE *)this + 24) = 0;
  *(_QWORD *)((char *)this + 28) = 255;
  *(_QWORD *)this = &off_24FFF29F0;
  *((_QWORD *)this + 1) = a2;
  v3 = (_OWORD *)operator new();
  *((_QWORD *)this + 5) = v3;
  *v3 = 0u;
  v3[1] = 0u;
  *((_BYTE *)this + 48) = 1;
}

{
  _OWORD *v3;

  *((_QWORD *)this + 2) = 255;
  *((_BYTE *)this + 24) = 0;
  *(_QWORD *)((char *)this + 28) = 255;
  *(_QWORD *)this = &off_24FFF29F0;
  *((_QWORD *)this + 1) = a2;
  v3 = (_OWORD *)operator new();
  *((_QWORD *)this + 5) = v3;
  *v3 = 0u;
  v3[1] = 0u;
  *((_BYTE *)this + 48) = 1;
}

uint64_t MTMultipleFirmwaresModeSwitcher::init(MTMultipleFirmwaresModeSwitcher *this, const __CFDictionary *a2)
{
  uint64_t v4;
  _QWORD *v5;
  NSObject *v7;
  char v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  id v13;
  id v14;
  id v15;
  id v16;
  NSObject *v17;
  _QWORD *v18;
  const __CFDictionary *v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  const char *v23;
  NSObject *v24;
  const char *v25;
  uint64_t v26;
  uint8_t buf[4];
  const __CFDictionary *v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  (*(void (**)(_QWORD))(**((_QWORD **)this + 1) + 80))(*((_QWORD *)this + 1));
  *(_QWORD *)(*((_QWORD *)this + 5) + 8) = -[__CFDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", CFSTR("BootloaderProperty"));
  *(_QWORD *)(*((_QWORD *)this + 5) + 16) = -[__CFDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", CFSTR("ActivePayload"));
  v4 = -[__CFDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", CFSTR("TTWPayload"));
  v5 = (_QWORD *)*((_QWORD *)this + 5);
  v5[3] = v4;
  if (v5[1])
  {
    if (v5[2] && v4 != 0)
    {
      v9 = MTDevicePowerControlSupported();
      if ((v9 & 1) != 0)
      {
        *(_DWORD *)((char *)&v26 + 3) = -1431655766;
        LODWORD(v26) = -1431655766;
        if (MTDeviceGetSensorRegionOfType())
        {
          v10 = (void *)objc_msgSend(MEMORY[0x24BE69408], "getDeviceInServiceTree:", MTDeviceGetService(), v26);
          if (v10)
          {
            v11 = objc_msgSend(v10, "getBootLoader");
            v12 = *((_QWORD *)this + 5);
            *(_QWORD *)v12 = v11;
            if (v11)
            {
              v13 = *(id *)(v12 + 8);
              v14 = *(id *)(*((_QWORD *)this + 5) + 16);
              v15 = *(id *)(*((_QWORD *)this + 5) + 24);
              v16 = **((id **)this + 5);
              MTDeviceGetDeviceID();
              v17 = MTLoggingPlugin();
              if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
              {
                v18 = (_QWORD *)*((_QWORD *)this + 5);
                v19 = (const __CFDictionary *)v18[1];
                v20 = v18[2];
                v21 = v18[3];
                *(_DWORD *)buf = 138544130;
                v28 = v19;
                v29 = 2114;
                v30 = v20;
                v31 = 2114;
                v32 = v21;
                v33 = 2048;
                v34 = 0;
                _os_log_impl(&dword_231071000, v17, OS_LOG_TYPE_DEFAULT, "Device using a FW binary switcher %{public}@ (active: %{public}@, ttw: %{public}@) (deviceID 0x%llX)", buf, 0x2Au);
              }
              return 0;
            }
            MTDeviceGetDeviceID();
            v24 = MTLoggingPlugin();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134217984;
              v28 = 0;
              v25 = "Device doesn't have an AHTBootloader (deviceID 0x%llX)";
              goto LABEL_27;
            }
          }
          else
          {
            MTDeviceGetDeviceID();
            v24 = MTLoggingPlugin();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134217984;
              v28 = 0;
              v25 = "Device doesn't have AHTDevice (deviceID 0x%llX)";
LABEL_27:
              _os_log_impl(&dword_231071000, v24, OS_LOG_TYPE_ERROR, v25, buf, 0xCu);
            }
          }
          return 3758097136;
        }
        MTDeviceGetDeviceID();
        v22 = MTLoggingPlugin();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134217984;
          v28 = 0;
          v23 = "We don't support multiple firmwares in prox integrated devices (deviceID 0x%llX)";
          goto LABEL_21;
        }
      }
      else
      {
        MTDeviceGetDeviceID();
        v22 = MTLoggingPlugin();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134217984;
          v28 = 0;
          v23 = "We don't support multiple firmwares in non-power-controlled devices (deviceID 0x%llX)";
LABEL_21:
          _os_log_impl(&dword_231071000, v22, OS_LOG_TYPE_ERROR, v23, buf, 0xCu);
        }
      }
      return 3758097095;
    }
  }
  MTDeviceGetDeviceID();
  v7 = MTLoggingPlugin();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138543618;
    v28 = a2;
    v29 = 2048;
    v30 = 0;
    _os_log_impl(&dword_231071000, v7, OS_LOG_TYPE_ERROR, "Missing parts of the config: %{public}@ (deviceID 0x%llX)", buf, 0x16u);
  }
  return 3758097090;
}

void MTModeSwitcher::MTModeSwitcher(MTModeSwitcher *this, MTSimpleHIDManager *a2)
{
  *(_QWORD *)this = off_24FFF2970;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = 255;
  *((_BYTE *)this + 24) = 0;
  *(_QWORD *)((char *)this + 28) = 255;
}

void MTModeSwitcher::transitionGraphicsOrientationTo(uint64_t a1, unsigned int a2)
{
  NSObject *v4;
  const char *v5;
  const char *v6;
  NSObject *v7;
  uint64_t v8;
  const char *v9;
  const char *v10;
  NSObject *v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 24) || *(_DWORD *)(a1 + 16) == 255)
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
    MTDeviceGetDeviceID();
    v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (a2 > 4)
        v5 = "Unknown";
      else
        v5 = off_24FFF2A60[a2];
      v6 = "booting";
      if (!*(_BYTE *)(a1 + 24))
        v6 = "off";
      *(_DWORD *)buf = 136446722;
      v13 = v5;
      v14 = 2082;
      v15 = v6;
      v16 = 2048;
      v17 = 0;
      _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_DEFAULT, "Setting orientation to %{public}s deferred (device %{public}s) (deviceID 0x%llX)", buf, 0x20u);
    }
    goto LABEL_10;
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
  MTDeviceGetDeviceID();
  v7 = MTLoggingPlugin();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *(int *)(a1 + 20);
    if (v8 > 4)
      v9 = "Unknown";
    else
      v9 = off_24FFF2A60[v8];
    if (a2 > 4)
      v10 = "Unknown";
    else
      v10 = off_24FFF2A60[a2];
    *(_DWORD *)buf = 136446722;
    v13 = v9;
    v14 = 2082;
    v15 = v10;
    v16 = 2048;
    v17 = 0;
    _os_log_impl(&dword_231071000, v7, OS_LOG_TYPE_DEFAULT, "Graphics orientation transitioning from %{public}s to %{public}s (deviceID 0x%llX)", buf, 0x20u);
  }
  if (*(_DWORD *)(a1 + 20) != a2)
  {
    MTModeSwitcher::setGraphicsOrientation(a1, a2);
    MTModeSwitcher::setTouchDetectionMode(a1, *(_DWORD *)(a1 + 16), a2);
LABEL_10:
    *(_DWORD *)(a1 + 20) = a2;
    return;
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
  MTDeviceGetDeviceID();
  v11 = MTLoggingPlugin();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 134217984;
    v13 = 0;
    _os_log_impl(&dword_231071000, v11, OS_LOG_TYPE_ERROR, "Unexpected: new orientation == old orientation (rebooting firmware?) (deviceID 0x%llX)", buf, 0xCu);
  }
}

uint64_t MTModeSwitcher::getMTDevice(MTModeSwitcher *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 80))(*((_QWORD *)this + 1));
}

const char *MTModeSwitcher::orientationToText(uint64_t a1, unsigned int a2)
{
  if (a2 > 4)
    return "Unknown";
  else
    return off_24FFF2A60[a2];
}

void MTModeSwitcher::setGraphicsOrientation(uint64_t a1, unsigned int a2)
{
  NSObject *v4;
  const char *v5;
  mach_error_t v6;
  mach_error_t v7;
  NSObject *v8;
  const char *v9;
  char *v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  char *v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
  MTDeviceGetDeviceID();
  v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 4)
      v5 = "Unknown";
    else
      v5 = off_24FFF2A60[a2];
    *(_DWORD *)buf = 136446466;
    v12 = v5;
    v13 = 2048;
    v14 = 0;
    _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_DEFAULT, "Setting graphics orientation %{public}s (deviceID 0x%llX)", buf, 0x16u);
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
  v6 = MTDeviceSetReport();
  if (v6)
  {
    v7 = v6;
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
    MTDeviceGetDeviceID();
    v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      if (a2 > 4)
        v9 = "Unknown";
      else
        v9 = off_24FFF2A60[a2];
      v10 = mach_error_string(v7);
      *(_DWORD *)buf = 136446722;
      v12 = v9;
      v13 = 2082;
      v14 = v10;
      v15 = 2048;
      v16 = 0;
      _os_log_impl(&dword_231071000, v8, OS_LOG_TYPE_ERROR, "Error trying to set graphics orientation %{public}s: %{public}s (deviceID 0x%llX)", buf, 0x20u);
    }
  }
}

void MTModeSwitcher::setTouchDetectionMode(uint64_t a1, int a2, unsigned int a3)
{
  NSObject *v6;
  _BOOL8 v7;
  const char *v8;
  const char *v9;
  mach_error_t v10;
  mach_error_t v11;
  NSObject *v12;
  _BOOL8 v13;
  const char *v14;
  const char *v15;
  char *v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
  MTDeviceGetDeviceID();
  v6 = MTLoggingPlugin();
  v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    v8 = MTModeSwitcher::modeToText(v7, a2);
    if (a3 > 4)
      v9 = "Unknown";
    else
      v9 = off_24FFF2A60[a3];
    *(_DWORD *)buf = 136446978;
    v18 = v8;
    v19 = 1024;
    v20 = a2;
    v21 = 2082;
    v22 = v9;
    v23 = 2048;
    v24 = 0;
    _os_log_impl(&dword_231071000, v6, OS_LOG_TYPE_DEFAULT, "Setting touch detection mode to %{public}s (0x%x) and orientation to %{public}s (deviceID 0x%llX)", buf, 0x26u);
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
  v10 = MTDeviceSetTouchMode();
  if (v10)
  {
    v11 = v10;
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
    MTDeviceGetDeviceID();
    v12 = MTLoggingPlugin();
    v13 = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    if (v13)
    {
      v14 = MTModeSwitcher::modeToText(v13, a2);
      if (a3 > 4)
        v15 = "Unknown";
      else
        v15 = off_24FFF2A60[a3];
      v16 = mach_error_string(v11);
      *(_DWORD *)buf = 136447234;
      v18 = v14;
      v19 = 1024;
      v20 = a2;
      v21 = 2082;
      v22 = v15;
      v23 = 2082;
      v24 = v16;
      v25 = 2048;
      v26 = 0;
      _os_log_impl(&dword_231071000, v12, OS_LOG_TYPE_ERROR, "Error trying to set mode to %{public}s (0x%x) and orientation to %{public}s: %{public}s (deviceID 0x%llX)", buf, 0x30u);
    }
  }
}

void MTModeSwitcher::deviceDidBootload(MTModeSwitcher *this)
{
  NSObject *v2;
  const char *v3;
  NSObject *v4;
  int v5;
  unsigned int v6;
  NSObject *v7;
  _BOOL8 v8;
  int v9;
  const char *v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  _WORD v14[17];

  *(_QWORD *)&v14[13] = *MEMORY[0x24BDAC8D0];
  (*(void (**)(_QWORD))(**((_QWORD **)this + 1) + 80))(*((_QWORD *)this + 1));
  MTDeviceGetDeviceID();
  v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*((_BYTE *)this + 24))
      v3 = "expected";
    else
      v3 = "unexpected";
    *(_DWORD *)buf = 136446466;
    v12 = v3;
    v13 = 2048;
    *(_QWORD *)v14 = 0;
    _os_log_impl(&dword_231071000, v2, OS_LOG_TYPE_DEFAULT, "Device booted (%{public}s): setting touch detection mode, orientation and power (deviceID 0x%llX)", buf, 0x16u);
  }
  if (*((_DWORD *)this + 8) == 1)
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 1) + 80))(*((_QWORD *)this + 1));
    MTDeviceGetDeviceID();
    v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      v12 = 0;
      _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_DEFAULT, "Debug mode forced to Always ON (deviceID 0x%llX)", buf, 0xCu);
    }
    *((_DWORD *)this + 7) = 0;
  }
  v5 = *((_DWORD *)this + 4);
  if (!*((_BYTE *)this + 24))
    *((_DWORD *)this + 7) = v5;
  *((_BYTE *)this + 24) = 0;
  if (v5 == 254)
    v6 = 1;
  else
    v6 = 2 * (v5 != 255);
  MTModeSwitcher::setGraphicsOrientation((uint64_t)this, *((_DWORD *)this + 5));
  MTModeSwitcher::setTouchDetectionMode((uint64_t)this, *((_DWORD *)this + 4), *((_DWORD *)this + 5));
  MTModeSwitcher::setDevicePowerState((uint64_t)this, v6);
  if (*((_DWORD *)this + 7) != *((_DWORD *)this + 4))
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 1) + 80))(*((_QWORD *)this + 1));
    MTDeviceGetDeviceID();
    v7 = MTLoggingPlugin();
    v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v8)
    {
      v9 = *((_DWORD *)this + 7);
      v10 = MTModeSwitcher::modeToText(v8, v9);
      *(_DWORD *)buf = 136446722;
      v12 = v10;
      v13 = 1024;
      *(_DWORD *)v14 = v9;
      v14[2] = 2048;
      *(_QWORD *)&v14[3] = 0;
      _os_log_impl(&dword_231071000, v7, OS_LOG_TYPE_DEFAULT, "Pending transition after boot. Going to %{public}s (0x%x) (deviceID 0x%llX)", buf, 0x1Cu);
    }
    (*(void (**)(MTModeSwitcher *, _QWORD, _QWORD))(*(_QWORD *)this + 16))(this, *((unsigned int *)this + 7), 0);
  }
}

void MTModeSwitcher::setDevicePowerState(uint64_t a1, unsigned int a2)
{
  NSObject *v4;
  const char *v5;
  mach_error_t v6;
  mach_error_t v7;
  NSObject *v8;
  const char *v9;
  char *v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  char *v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
  MTDeviceGetDeviceID();
  v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 2)
      v5 = "Unknown";
    else
      v5 = off_24FFF2A88[a2];
    *(_DWORD *)buf = 136446466;
    v12 = v5;
    v13 = 2048;
    v14 = 0;
    _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_DEFAULT, "Setting power state to %{public}s (deviceID 0x%llX)", buf, 0x16u);
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
  v6 = MTDevicePowerSetState();
  if (v6)
  {
    v7 = v6;
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
    MTDeviceGetDeviceID();
    v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      if (a2 > 2)
        v9 = "Unknown";
      else
        v9 = off_24FFF2A88[a2];
      v10 = mach_error_string(v7);
      *(_DWORD *)buf = 136446722;
      v12 = v9;
      v13 = 2082;
      v14 = v10;
      v15 = 2048;
      v16 = 0;
      _os_log_impl(&dword_231071000, v8, OS_LOG_TYPE_ERROR, "Error trying to set power state to %{public}s: %{public}s (deviceID 0x%llX)", buf, 0x20u);
    }
  }
}

const char *MTModeSwitcher::modeToText(uint64_t a1, int a2)
{
  const char *result;

  if (a2 <= 251)
  {
    if (a2)
    {
      if (a2 == 1)
      {
        return "PocketTouchesExpected";
      }
      else if (a2 == 2)
      {
        return "FaceExpected";
      }
      else
      {
        return "Unknown";
      }
    }
    else
    {
      return "On";
    }
  }
  else
  {
    switch(a2)
    {
      case 252:
        result = "LowPersistence";
        break;
      case 253:
        result = "WakeOnTouch";
        break;
      case 254:
        result = "WakeOnTouchAndCoverGesture";
        break;
      case 255:
        result = "Off";
        break;
      default:
        return "Unknown";
    }
  }
  return result;
}

uint64_t MTModeSwitcher::bootloadTimerExpired(MTModeSwitcher *this)
{
  NSObject *v2;
  _BOOL8 v3;
  int v4;
  uint8_t buf[4];
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  *((_BYTE *)this + 24) = 0;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 1) + 80))(*((_QWORD *)this + 1));
  MTDeviceGetDeviceID();
  v2 = MTLoggingPlugin();
  v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    v4 = *((_DWORD *)this + 7);
    *(_DWORD *)buf = 136446722;
    v7 = MTModeSwitcher::modeToText(v3, v4);
    v8 = 1024;
    v9 = v4;
    v10 = 2048;
    v11 = 0;
    _os_log_impl(&dword_231071000, v2, OS_LOG_TYPE_DEFAULT, "Device never bootloaded. Try to recover by going to %{public}s (0x%x) (deviceID 0x%llX)", buf, 0x1Cu);
  }
  return (*(uint64_t (**)(MTModeSwitcher *, _QWORD, _QWORD))(*(_QWORD *)this + 16))(this, *((unsigned int *)this + 7), 0);
}

void MTModeSwitcher::resetFirmware(uint64_t a1, int a2)
{
  mach_error_t v4;
  mach_error_t v5;
  NSObject *v6;
  uint8_t buf[4];
  char *v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 8) + 480))(*(_QWORD *)(a1 + 8), 30);
  v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 424))(*(_QWORD *)(a1 + 8));
  if (v4)
  {
    v5 = v4;
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
    MTDeviceGetDeviceID();
    v6 = MTLoggingPlugin();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v8 = mach_error_string(v5);
      v9 = 2048;
      v10 = 0;
      _os_log_impl(&dword_231071000, v6, OS_LOG_TYPE_ERROR, "Error trying to reset device: %{public}s (deviceID 0x%llX)", buf, 0x16u);
    }
  }
  *(_BYTE *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = a2;
}

uint64_t MTModeSwitcher::setupBootloadPowerAssertion(MTModeSwitcher *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 480))(*((_QWORD *)this + 1));
}

uint64_t MTModeSwitcher::resetDevice(MTModeSwitcher *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 424))(*((_QWORD *)this + 1));
}

void MTModeSwitcher::bootFirmware(uint64_t a1, int a2)
{
  NSObject *v4;
  uint8_t buf[4];
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
  if (MTDevicePowerGetState() | 0xAAAAAAAA)
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
    MTDeviceGetDeviceID();
    v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      v6 = 0;
      _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_ERROR, "Trying to boot a device in an unknown/unexpected state (deviceID 0x%llX)", buf, 0xCu);
    }
    MTModeSwitcher::resetFirmware(a1, a2);
  }
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 8) + 480))(*(_QWORD *)(a1 + 8), 30);
  MTModeSwitcher::setDevicePowerState(a1, 2u);
  *(_BYTE *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = a2;
}

const char *MTModeSwitcher::powerStateToText(uint64_t a1, unsigned int a2)
{
  if (a2 > 2)
    return "Unknown";
  else
    return off_24FFF2A88[a2];
}

uint64_t MTNoOpModeSwitcher::transitionTouchDetectionModeTo(uint64_t result, int a2)
{
  *(_DWORD *)(result + 16) = a2;
  return result;
}

uint64_t MTNoOpModeSwitcher::transitionGraphicsOrientationTo(uint64_t result, int a2)
{
  *(_DWORD *)(result + 20) = a2;
  return result;
}

uint64_t MTNoOpModeSwitcher::deviceDidBootload(uint64_t this)
{
  *(_BYTE *)(this + 24) = 0;
  return this;
}

uint64_t MTNoOpModeSwitcher::bootloadTimerExpired(uint64_t this)
{
  *(_BYTE *)(this + 24) = 0;
  return this;
}

void MTMultipleFirmwaresModeSwitcher::~MTMultipleFirmwaresModeSwitcher(MTMultipleFirmwaresModeSwitcher *this)
{
  id *v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24FFF29F0;
  v2 = (id *)*((_QWORD *)this + 5);
  if (v2)
  {

    v3 = *((_QWORD *)this + 5);
    if (v3)
      MEMORY[0x2348D0034](v3, 0x80C4018A671A6);
    *((_QWORD *)this + 5) = 0;
  }
}

{
  MTMultipleFirmwaresModeSwitcher::~MTMultipleFirmwaresModeSwitcher(this);
  JUMPOUT(0x2348D0034);
}

void MTMultipleFirmwaresModeSwitcher::transitionTouchDetectionModeTo(uint64_t a1, int a2)
{
  NSObject *v4;
  NSObject *v5;
  _BOOL8 v6;
  const char *v7;
  NSObject *v8;
  _BOOL8 v9;
  int v10;
  const char *v11;
  const char *v12;
  unsigned int v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t v16;
  int v17;
  int v18;
  NSObject *v19;
  uint64_t v20;
  int v21;
  NSObject *v22;
  _BOOL8 v23;
  const char *v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a1 + 32) == 1)
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
    MTDeviceGetDeviceID();
    v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      v26 = 0;
      _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_DEFAULT, "Debug mode forced to Always ON (deviceID 0x%llX)", buf, 0xCu);
    }
    a2 = 0;
  }
  if (*(_BYTE *)(a1 + 24))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
    MTDeviceGetDeviceID();
    v5 = MTLoggingPlugin();
    v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      v7 = MTModeSwitcher::modeToText(v6, a2);
      *(_DWORD *)buf = 136446722;
      v26 = v7;
      v27 = 1024;
      v28 = a2;
      v29 = 2048;
      v30 = 0;
      _os_log_impl(&dword_231071000, v5, OS_LOG_TYPE_DEFAULT, "Touch detection mode to %{public}s (0x%x) deferred (device booting) (deviceID 0x%llX)", buf, 0x1Cu);
    }
    *(_DWORD *)(a1 + 28) = a2;
    return;
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
  MTDeviceGetDeviceID();
  v8 = MTLoggingPlugin();
  v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    v10 = *(_DWORD *)(a1 + 16);
    v11 = MTModeSwitcher::modeToText(v9, v10);
    v12 = MTModeSwitcher::modeToText((uint64_t)v11, a2);
    *(_DWORD *)buf = 136447234;
    v26 = v11;
    v27 = 1024;
    v28 = v10;
    v29 = 2082;
    v30 = v12;
    v31 = 1024;
    v32 = a2;
    v33 = 2048;
    v34 = 0;
    _os_log_impl(&dword_231071000, v8, OS_LOG_TYPE_DEFAULT, "Touch detection mode transitioning from %{public}s (0x%x) to %{public}s (0x%x) (deviceID 0x%llX)", buf, 0x2Cu);
  }
  v13 = *(_DWORD *)(a1 + 16);
  if (a2 == v13)
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
    MTDeviceGetDeviceID();
    v14 = MTLoggingPlugin();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      v26 = 0;
      _os_log_impl(&dword_231071000, v14, OS_LOG_TYPE_ERROR, "Unexpected: new mode == old mode (rebooting firmware?) (deviceID 0x%llX)", buf, 0xCu);
    }
    return;
  }
  if (!*(_BYTE *)(a1 + 48))
  {
    if (a2 > 253)
    {
      if (a2 != 254)
      {
        if (a2 == 255)
        {
          if (v13 < 2 || v13 == 254)
            MTModeSwitcher::setDevicePowerState(a1, 0);
          a2 = 255;
          goto LABEL_50;
        }
        goto LABEL_40;
      }
      if (v13 < 2)
      {
        a2 = 254;
        v16 = a1;
        v17 = 1;
        v18 = 254;
LABEL_39:
        MTMultipleFirmwaresModeSwitcher::switchFirmware(v16, v17, v18);
LABEL_50:
        *(_DWORD *)(a1 + 16) = a2;
        return;
      }
      if (v13 != 255)
      {
        a2 = 254;
        goto LABEL_50;
      }
      v20 = a1;
      v21 = 254;
    }
    else
    {
      if (a2)
      {
        if (a2 == 1)
        {
          if (v13 - 254 >= 2)
          {
            a2 = 1;
            if (!v13)
              MTModeSwitcher::setTouchDetectionMode(a1, 1, *(_DWORD *)(a1 + 20));
            goto LABEL_50;
          }
          a2 = 1;
          v16 = a1;
          v17 = 0;
          v18 = 1;
          goto LABEL_39;
        }
LABEL_40:
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
        MTDeviceGetDeviceID();
        v22 = MTLoggingPlugin();
        v23 = os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
        if (v23)
        {
          v24 = MTModeSwitcher::modeToText(v23, a2);
          *(_DWORD *)buf = 136446722;
          v26 = v24;
          v27 = 1024;
          v28 = a2;
          v29 = 2048;
          v30 = 0;
          _os_log_impl(&dword_231071000, v22, OS_LOG_TYPE_ERROR, "Unexpected transition to %{public}s (0x%x) (deviceID 0x%llX)", buf, 0x1Cu);
        }
        goto LABEL_50;
      }
      if (v13 - 254 >= 2)
      {
        if (v13 == 1)
          MTModeSwitcher::setTouchDetectionMode(a1, 0, *(_DWORD *)(a1 + 20));
        goto LABEL_49;
      }
      v20 = a1;
      v21 = 0;
    }
    MTMultipleFirmwaresModeSwitcher::switchFirmware(v20, 0, v21);
LABEL_49:
    a2 = 0;
    goto LABEL_50;
  }
  if (a2 || v13 != 255)
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
    MTDeviceGetDeviceID();
    v19 = MTLoggingPlugin();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      v26 = 0;
      _os_log_impl(&dword_231071000, v19, OS_LOG_TYPE_ERROR, "Unexpected first boot (deviceID 0x%llX)", buf, 0xCu);
    }
  }
  else
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
    MTDeviceGetDeviceID();
    v15 = MTLoggingPlugin();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      v26 = 0;
      _os_log_impl(&dword_231071000, v15, OS_LOG_TYPE_DEFAULT, "First boot: setting power to On (deviceID 0x%llX)", buf, 0xCu);
    }
    MTModeSwitcher::setDevicePowerState(a1, 2u);
    *(_DWORD *)(a1 + 16) = 0;
  }
  *(_BYTE *)(a1 + 48) = 0;
}

void MTMultipleFirmwaresModeSwitcher::switchFirmware(uint64_t a1, int a2, int a3)
{
  uint64_t v6;
  const char *v7;
  NSObject *v8;
  _BOOL8 v9;
  const char *v10;
  const char *v11;
  const char *v12;
  NSObject *v13;
  const char *v14;
  uint64_t v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  _QWORD v21[3];

  v21[2] = *MEMORY[0x24BDAC8D0];
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 8) + 480))(*(_QWORD *)(a1 + 8), 30);
  if (a2)
  {
    if (a2 == 1)
    {
      v6 = *(_QWORD *)(a1 + 40);
      v7 = *(const char **)(v6 + 24);
    }
    else
    {
      v7 = 0;
      v6 = *(_QWORD *)(a1 + 40);
    }
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 40);
    v7 = *(const char **)(v6 + 16);
  }
  v15 = 0;
  if ((objc_msgSend(*(id *)v6, "updateProperty:property:options:error:", *(_QWORD *)(v6 + 8), v7, 0, &v15) & 1) != 0)
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
    MTDeviceGetDeviceID();
    v8 = MTLoggingPlugin();
    v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    if (v9)
    {
      v10 = "Unknown";
      if (a2 == 1)
        v10 = "WakeOnTouch";
      if (a2)
        v11 = v10;
      else
        v11 = "Active";
      v12 = MTModeSwitcher::modeToText(v9, a3);
      *(_DWORD *)buf = 136446978;
      v17 = v11;
      v18 = 2082;
      v19 = v12;
      v20 = 1024;
      LODWORD(v21[0]) = a3;
      WORD2(v21[0]) = 2048;
      *(_QWORD *)((char *)v21 + 6) = 0;
      _os_log_impl(&dword_231071000, v8, OS_LOG_TYPE_DEFAULT, "FW switched to %{public}s with mode %{public}s (0x%x) (deviceID 0x%llX)", buf, 0x26u);
    }
    *(_BYTE *)(a1 + 24) = 1;
    *(_DWORD *)(a1 + 28) = a3;
  }
  else
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 80))(*(_QWORD *)(a1 + 8));
    MTDeviceGetDeviceID();
    v13 = MTLoggingPlugin();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = *(const char **)(*(_QWORD *)(a1 + 40) + 8);
      *(_DWORD *)buf = 138543874;
      v17 = v14;
      v18 = 2114;
      v19 = v7;
      v20 = 2048;
      v21[0] = 0;
      _os_log_impl(&dword_231071000, v13, OS_LOG_TYPE_ERROR, "Error updating %{public}@ to %{public}@ (deviceID 0x%llX)", buf, 0x20u);
    }
  }
}

const char *MTMultipleFirmwaresModeSwitcher::firmwareBinaryToText(uint64_t a1, int a2)
{
  const char *v2;

  v2 = "Unknown";
  if (a2 == 1)
    v2 = "WakeOnTouch";
  if (a2)
    return v2;
  else
    return "Active";
}

void MTNoOpModeSwitcher::~MTNoOpModeSwitcher(MTNoOpModeSwitcher *this)
{
  JUMPOUT(0x2348D0034);
}

_QWORD *MTChordCyclingTrackpad::MTChordCyclingTrackpad(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5, int a6)
{
  _QWORD *result;

  result = (_QWORD *)MTChordCycling::MTChordCycling(a1, a2, a3, a4, a5, a6);
  *result = &off_24FFF2AB0;
  return result;
}

{
  _QWORD *result;

  result = (_QWORD *)MTChordCycling::MTChordCycling(a1, a2, a3, a4, a5, a6);
  *result = &off_24FFF2AB0;
  return result;
}

uint64_t MTChordCyclingTrackpad::chk4newTapChord(MTChordCyclingTrackpad *this, MTHandStatistics *a2, const MTHandMotion *a3, MTChordGestureSet *a4)
{
  int v8;
  unsigned int v9;

  if (a4
    && *((double *)a2 + 10) > *((double *)a2 + 16)
    && (*(unsigned int (**)(MTChordCyclingTrackpad *, MTHandStatistics *))(*(_QWORD *)this + 48))(this, a2))
  {
    v8 = *((_DWORD *)this + 260);
    v9 = *((_DWORD *)a4 + 54);
    if ((!v8 || (v9 >= *((_DWORD *)this + 258) || v9 < *((unsigned __int8 *)a2 + 186)) && *((_DWORD *)a4 + 56) != v8)
      && (v9 != 2 || *((_DWORD *)a4 + 55) != 2 || *((_BYTE *)a2 + 195) != 1))
    {
      (*(void (**)(MTChordCyclingTrackpad *, MTHandStatistics *, const MTHandMotion *, MTChordGestureSet *))(*(_QWORD *)this + 72))(this, a2, a3, a4);
    }
  }
  return (*(uint64_t (**)(MTChordCyclingTrackpad *, MTHandStatistics *, const MTHandMotion *))(*(_QWORD *)this + 80))(this, a2, a3);
}

void MTChordCyclingTrackpad::handleChordTaps(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  int v12;
  int v13;
  _WORD *v14;
  _WORD *v15;
  _WORD *v16;
  _WORD *v17;
  uint64_t v18;
  uint64_t v19;
  _WORD *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;

  if (a1[260]
    && (*(unsigned int (**)(_DWORD *))(*(_QWORD *)a1 + 48))(a1)
    && ((a6 & 1) != 0
     || a1[258] < 2u
     || (*(unsigned int (**)(_DWORD *, uint64_t))(*(_QWORD *)a1 + 56))(a1, a2)))
  {
    if ((*(unsigned int (**)(_DWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 96))(a1, a2, a3, a6))
    {
      v12 = a1[262];
      if (!v12 || (a1[6] & v12) != 0)
      {
        v13 = a1[259];
        if ((a6 & 1) == 0 && v13 >= 2)
        {
          v14 = (_WORD *)*((_QWORD *)a1 + 110);
          v15 = (_WORD *)*((_QWORD *)a1 + 111);
          if (v14 != v15 && *v14)
            goto LABEL_13;
          v17 = (_WORD *)*((_QWORD *)a1 + 102);
          if (v17 != *((_WORD **)a1 + 103) && *v17)
          {
            if (v14 != v15 && *v14)
            {
LABEL_13:
              (*(void (**)(_DWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 112))(a1, a2, a3 + 168, a4);
LABEL_49:
              MTChordIntegrating::nullify((void **)a1 + 102);
              return;
            }
            v18 = *((_QWORD *)a1 + 49);
            if (*(_BYTE *)(v18 + 28) && *(int *)(v18 + 24) >= 3)
            {
              MTTapDragManager::handleTapsForMultiFingerDrag(*((_QWORD *)a1 + 49), a2, a3, a4);
              goto LABEL_49;
            }
            goto LABEL_46;
          }
          goto LABEL_31;
        }
        if (v13 == 1)
        {
          v16 = (_WORD *)*((_QWORD *)a1 + 110);
          if (v16 != *((_WORD **)a1 + 111)
            && *v16
            && vabdd_f64(*(double *)(a2 + 96), *(double *)(a2 + 104)) < *(double *)&qword_255EB3C50
            && *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) <= 1
            && (a6 & 1) == 0)
          {
            (*(void (**)(_DWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 104))(a1, a2, a3 + 168, a4);
            goto LABEL_47;
          }
        }
        if (!(_DWORD)a6 || *(double *)(a2 + 80) - *(double *)(a2 + 88) > 0.09)
        {
LABEL_31:
          v19 = *((_QWORD *)a1 + 102);
          if (v19 == *((_QWORD *)a1 + 103)
            || !*(_WORD *)v19
            || (_DWORD)a6 && (a5 & 1) == 0 && (*(_BYTE *)(v19 + 5) & 1) == 0)
          {
            if (!(_DWORD)a6)
              goto LABEL_49;
            v20 = (_WORD *)*((_QWORD *)a1 + 106);
            if (v20 == *((_WORD **)a1 + 107) || !*v20 || v12 && (a1[6] & v12) == 0)
              goto LABEL_49;
            MTGesture::dispatchEvents((uint64_t *)a1 + 106, *((_QWORD *)a1 + 49), a4, 0, 0, a3 + 168, 24576, a1[260], *(double *)(a2 + 8));
            v21 = *((_QWORD *)a1 + 49);
            *(_QWORD *)(v21 + 72) = *(_QWORD *)(a2 + 8);
            LOBYTE(v22) = 1;
            goto LABEL_48;
          }
          v23 = *((_QWORD *)a1 + 49);
          if (a1[258] != 1 || *(_WORD *)v19 != 65)
          {
            MTTapDragManager::clearCycle(v23);
            v18 = *((_QWORD *)a1 + 49);
LABEL_46:
            MTGesture::dispatchEvents((uint64_t *)a1 + 102, v18, a4, 0, 0, a3 + 168, 12288, a1[260], *(double *)(a2 + 8));
            goto LABEL_47;
          }
          MTTapDragManager::handleTapsForDrag(v23, a2, a3, a4);
LABEL_47:
          v21 = *((_QWORD *)a1 + 49);
          v22 = a1[258];
          *(_QWORD *)(v21 + 72) = *(_QWORD *)(a2 + 8);
LABEL_48:
          *(_BYTE *)(v21 + 49) = v22;
          goto LABEL_49;
        }
      }
    }
  }
}

uint64_t MTChordCyclingTrackpad::possiblyStopChordMomentum(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  MTChordCycling::possiblyStopChordMomentum(a1, a2, a3, a4);
  return MTTapDragManager::chk4dragCycling(*(_QWORD *)(a1 + 392), a2, a3, a4, *(double *)(a2 + 8) - *(double *)(a1 + 1240));
}

void MTChordCyclingTrackpad::chk4chordCycling(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4)
{
  int v8;
  _QWORD *v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  _WORD *v20;
  char v21;
  uint64_t MatchingChord;
  float v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  unsigned int v27;
  MTSlideGesture *v28;
  uint64_t v29;
  unsigned __int16 **v30;
  int v32;
  BOOL v33;
  int hasEnabledFluidNavigation;
  _QWORD *v35;
  unsigned int v36;
  _QWORD *v37;
  double v38;
  double v39;
  char v40;
  float v41;
  double v42;
  char v43;
  _QWORD *v44;
  __int16 v45;
  unsigned int v46;
  _QWORD *v47;

  if (*(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) > *(unsigned __int8 *)(a2 + 190)
                                                                                     + *(unsigned __int8 *)(a2 + 187)
    && *(_DWORD *)(a1 + 632))
  {
    MTChordIntegrating::clearMickeysSinceLastTouchdown(a1 + 408);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 136))(a1, a2, a4);
  if (*(_BYTE *)(a2 + 210))
  {
    v8 = *(_DWORD *)(a1 + 632);
    if (v8 && *(_DWORD *)(a1 + 624) == 1 || *(_DWORD *)(a1 + 1040) && *(_DWORD *)(a1 + 1032) == 1)
      *(_QWORD *)(*(_QWORD *)(a1 + 392) + 80) = *(_QWORD *)(a2 + 8);
    if (v8)
    {
      v9 = *(_QWORD **)(a1 + 680);
      if (v9)
      {
        if (*v9 != v9[1] && *(_WORD *)*v9 == 37 && *(_BYTE *)(a1 + 672))
        {
          v10 = *(unsigned __int8 *)(a2 + 186);
          if ((*(_BYTE *)(a2 + 168) & 0x20) != 0)
            v10 += *(unsigned __int8 *)(a2 + 188);
          if (v10 >= *(unsigned __int8 *)(a2 + 187) && v10 > 2)
            return;
        }
      }
    }
  }
  if (!*(_BYTE *)(a2 + 298) && (*(_BYTE *)(a2 + 186) != 1 || !*(_BYTE *)(a2 + 195)))
    goto LABEL_62;
  v11 = *(_QWORD *)(a1 + 392);
  if (*(_BYTE *)(v11 + 28))
  {
    v12 = *(unsigned __int8 *)(a2 + 186);
    v13 = *(unsigned __int8 *)(a2 + 187);
    if (*(int *)(v11 + 24) >= 3)
    {
      v14 = *(unsigned __int8 *)(a2 + 211);
      v15 = *(unsigned __int8 *)(a2 + 190);
      v16 = v15 + v13;
      goto LABEL_28;
    }
  }
  else
  {
    v12 = *(unsigned __int8 *)(a2 + 186);
    v13 = *(unsigned __int8 *)(a2 + 187);
  }
  v14 = *(unsigned __int8 *)(a2 + 211);
  v15 = *(unsigned __int8 *)(a2 + 190);
  v16 = v15 + v13;
  if (v14 + v12 < v16 && v14 + v12 <= *(unsigned __int8 *)(v11 + 48))
  {
    (*(void (**)(uint64_t, uint64_t, float32x4_t *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, a3, a4);
    goto LABEL_39;
  }
LABEL_28:
  v17 = v14 + v12;
  if (v17 >= v16 || !*(_DWORD *)(a1 + 1040))
    goto LABEL_39;
  if (v17 != 1 || (v18 = 0, v19 = 1, !v15) && *(_BYTE *)(a2 + 195))
  {
    if ((*(_WORD *)(a1 + 1044) & 0x100) == 0)
    {
      v20 = *(_WORD **)(a1 + 848);
      if (v20 == *(_WORD **)(a1 + 856) || !*v20)
        goto LABEL_39;
    }
    v19 = 0;
    v18 = 1;
  }
  (*(void (**)(uint64_t, uint64_t, float32x4_t *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 120))(a1, a2, a3, a4, v19, v18);
LABEL_39:
  (*(void (**)(uint64_t, uint64_t, float32x4_t *, uint64_t))(*(_QWORD *)a1 + 144))(a1, a2, a3, a4);
  v21 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 24))(a1, a2);
  MatchingChord = MTChordTable::findMatchingChord((MTChordTable *)a1, v21, 0);
  (*(void (**)(uint64_t, uint64_t, float32x4_t *, uint64_t))(*(_QWORD *)a1 + 128))(a1, a2, a3, MatchingChord);
  v23 = a3[17].f32[1];
  if (MatchingChord && (*(_WORD *)(MatchingChord + 228) & 0x100) != 0)
  {
    if ((*(_WORD *)(a2 + 296) & 1) != 0 && v23 <= 0.765)
      return;
    if (*(_DWORD *)(MatchingChord + 220) < *(unsigned __int8 *)(a2 + 198)
      && *(unsigned __int8 *)(a2 + 186) == *(unsigned __int8 *)(a2 + 298))
    {
      if (*(_DWORD *)(a1 + 632)
        && !*(_BYTE *)(a1 + 672)
        && *(double *)(a2 + 8) - *(double *)(a2 + 56) > *(double *)&qword_255EB3BD0)
      {
        v29 = a1 + 408;
LABEL_83:
        MTChordIntegrating::endChordIntegration(v29, a2, (uint64_t)a3, a4, a1);
        return;
      }
      return;
    }
  }
  if ((*(_WORD *)(a1 + 636) & 0x100) != 0 && !*(_BYTE *)(a1 + 672) && (*(_WORD *)(a2 + 296) & 1) != 0 && v23 <= 0.765)
  {
    v29 = a1 + 408;
    goto LABEL_83;
  }
  if (!*(_DWORD *)(a1 + 632))
  {
    if (MatchingChord
      && MTChordGestureSet::isChordReadyToIntegrate((MTChordGestureSet *)MatchingChord, (const MTHandStatistics *)a2, a3))
    {
      goto LABEL_147;
    }
    return;
  }
  MTChordIntegrating::markMomentumPause((MTChordIntegrating *)(a1 + 408), (const MTHandStatistics *)a2);
  if (*(double *)(a2 + 8) - *(double *)(a2 + 288) <= *(double *)(a2 + 8) - *(double *)(a2 + 16)
    && MatchingChord
    && *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) >= 4)
  {
    v30 = *(unsigned __int16 ***)(a1 + 680);
    if (!v30 || *v30 == v30[1] || **v30 - 35 >= 5)
      goto LABEL_147;
  }
  else if (!MatchingChord)
  {
    return;
  }
  if (*(_DWORD *)(MatchingChord + 224) != *(_DWORD *)(a1 + 632)
    || (MTChordGestureSet::chordGestureSetEquals((MTChordGestureSet *)MatchingChord, (const MTChordGestureSet *)(a1 + 408)) & 1) == 0)
  {
    v24 = *(_QWORD *)(a1 + 392);
    if (*(int *)(v24 + 24) < 2
      || !(**(unsigned int (***)(uint64_t))v24)(v24)
      || (v25 = *(_QWORD *)(a1 + 392), *(_BYTE *)(v25 + 28)) && *(int *)(v25 + 24) >= 3)
    {
      v26 = *(_DWORD *)(MatchingChord + 216);
      v27 = *(_DWORD *)(a1 + 624);
      if (v26 < v27)
      {
        v28 = *(MTSlideGesture **)(a1 + 680);
        if (!v28)
          goto LABEL_92;
        if (*(_QWORD *)v28 != *((_QWORD *)v28 + 1) && (**(_WORD **)v28 & 0xFFFE) == 0x26)
        {
          if (!MTSlideGesture::isFluidFullyTriggered(v28))
          {
LABEL_60:
            if (!*(_BYTE *)(a2 + 298)
              || *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) < *(unsigned __int8 *)(a2 + 190)
                                                                                               + *(unsigned __int8 *)(a2 + 187))
            {
LABEL_62:
              (*(void (**)(uint64_t, uint64_t, float32x4_t *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, a3, a4);
              (*(void (**)(uint64_t, uint64_t, float32x4_t *, uint64_t))(*(_QWORD *)a1 + 144))(a1, a2, a3, a4);
              return;
            }
LABEL_92:
            if (!*(_BYTE *)(a1 + 672)
              || (*(_WORD *)(a1 + 636) & 0x80) != 0
              && (MTChordIntegrating::hasPartiallyTriggeredFluidNotificationOrNotificationAlt((MTChordIntegrating *)(a1 + 408)) & 1) == 0
              && ((*(_WORD *)(MatchingChord + 228) & 8) != 0 && !*(_BYTE *)(a2 + 211)
               || *(_DWORD *)(MatchingChord + 216) < (int)*(unsigned __int8 *)(a2 + 186)))
            {
              goto LABEL_147;
            }
            if ((*(_WORD *)(a1 + 636) & 0x10) != 0 && (*(_WORD *)(MatchingChord + 228) & 1) != 0)
            {
              v35 = *(_QWORD **)(a1 + 680);
              if (!v35
                || *v35 == v35[1]
                || *(_WORD *)*v35 != 37
                || (v36 = *(unsigned __int8 *)(a2 + 186), v36 > *(unsigned __int8 *)(a2 + 195))
                && *(unsigned __int8 *)(a2 + 211) + v36 == 1)
              {
                if ((MTChordIntegrating::hasPartiallyTriggeredFluidNotificationOrNotificationAlt((MTChordIntegrating *)(a1 + 408)) & 1) == 0)
                {
                  if ((*(_WORD *)(a1 + 636) & 0x80) != 0)
                  {
LABEL_147:
                    (*(void (**)(uint64_t, uint64_t, float32x4_t *, uint64_t, uint64_t))(*(_QWORD *)a1 + 64))(a1, a2, a3, a4, MatchingChord);
                    return;
                  }
                  if ((*(_WORD *)(a1 + 636) & 0x100) != 0)
                  {
                    if (*(_DWORD *)(MatchingChord + 216) == 1
                      && *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) == 1
                      && (!*(_BYTE *)(a1 + 1264) || *(_DWORD *)(a1 + 1268) != 4))
                    {
                      goto LABEL_147;
                    }
                  }
                  else if (*(double *)(a2 + 8) - *(double *)(a2 + 128) > *(double *)&gTimingPrefs * 0.5)
                  {
                    goto LABEL_147;
                  }
                }
              }
            }
            return;
          }
          v28 = *(MTSlideGesture **)(a1 + 680);
          if (!v28)
            goto LABEL_92;
        }
        if (*(_QWORD *)v28 == *((_QWORD *)v28 + 1) || (**(_WORD **)v28 & 0xFFFE) != 0x26)
          goto LABEL_92;
        goto LABEL_60;
      }
      v32 = *(_DWORD *)(a1 + 704) <= v27 + 1 || v26 < *(unsigned __int8 *)(a2 + 186);
      v33 = MTChordIntegrating::recentMomentumPause((MTChordIntegrating *)(a1 + 408), (const MTHandStatistics *)a2, HIBYTE(*(unsigned __int16 *)(MatchingChord + 228)) & 1);
      if (*(_DWORD *)(MatchingChord + 216) < 3u)
        hasEnabledFluidNavigation = 0;
      else
        hasEnabledFluidNavigation = MTChordGestureSet::hasEnabledFluidNavigation((MTChordGestureSet *)MatchingChord, (const MTChordTable *)a1);
      if (v32)
      {
        if ((*(_WORD *)(MatchingChord + 228) & 0x100) != 0
          && (v37 = *(_QWORD **)(a1 + 680)) != 0
          && *v37 != v37[1]
          && (*(_WORD *)*v37 & 0xFFFE) == 0x46
          || (v38 = *(double *)(a2 + 8), v39 = v38 - *(double *)(a2 + 280), v39 >= *(double *)&qword_255EB3BD0))
        {
          v32 = 0;
          goto LABEL_133;
        }
        if ((hasEnabledFluidNavigation & 1) != 0)
        {
          v40 = a3[12].f32[2] != 0.0 || v33;
          if ((v40 & 1) == 0)
          {
            v41 = a3[12].f32[3];
            v32 = v41 != 0.0;
            if (v41 == 0.0 && ((hasEnabledFluidNavigation ^ 1) & 1) == 0)
              v32 = MTChordIntegrating::switchingVerticalToHorizontal((int32x2_t *)(a1 + 408), 20.0, v39 == 0.0);
            goto LABEL_133;
          }
        }
        else
        {
          v42 = v38 - *(double *)(a2 + 80);
          v32 = v42 > 0.0;
          v43 = v42 <= 0.0 || v33;
          if ((v43 & 1) != 0)
            goto LABEL_133;
          if (a3[12].f32[2] == 0.0)
          {
            v32 = a3[12].f32[3] != 0.0;
            goto LABEL_133;
          }
        }
        v32 = 1;
      }
LABEL_133:
      if (!*(_BYTE *)(a1 + 672))
        goto LABEL_147;
      if (*(double *)(a2 + 8) - *(double *)(a2 + 264) < *(double *)&qword_255EB3BD0)
      {
        if ((*(_WORD *)(MatchingChord + 228) & 0x100) == 0
          && !MTChordGestureSet::hasEnabledFluidDock((MTChordGestureSet *)MatchingChord, (const MTChordTable *)a1))
        {
          goto LABEL_147;
        }
        if (*(_DWORD *)(MatchingChord + 216) != 3)
          goto LABEL_147;
        v44 = *(_QWORD **)(a1 + 680);
        if (!v44 || *v44 == v44[1] || (*(_WORD *)*v44 & 0xFFFE) != 0x46)
          goto LABEL_147;
      }
      v45 = *(_WORD *)(a1 + 636);
      if ((v45 & 0x20) != 0
        || (v45 & 0x40) != 0
        && ((v32 & 1) != 0
         || MTChordGestureSet::hasActiveEdgeSlide((MTChordGestureSet *)MatchingChord, (const MTHandStatistics *)a2, (const MTChordCycling *)a1)))
      {
        v46 = *(unsigned __int16 *)(MatchingChord + 228);
        if ((v46 & 2) != 0)
          goto LABEL_147;
        if ((v32 & (v46 >> 2) & 1) != 0)
          goto LABEL_147;
        if ((v32 & (v46 >> 11)) == 1)
        {
          v47 = *(_QWORD **)(a1 + 680);
          if (v47)
          {
            if (*v47 != v47[1] && *(_WORD *)*v47 == 68 && *(_DWORD *)(a1 + 624) == 1)
              goto LABEL_147;
          }
        }
      }
    }
  }
}

MTSlideGesture *MTChordIntegrating::hasPartiallyTriggeredFluidNotificationOrNotificationAlt(MTChordIntegrating *this)
{
  MTSlideGesture *result;

  result = (MTSlideGesture *)*((_QWORD *)this + 34);
  if (result)
  {
    if (*(_QWORD *)result == *((_QWORD *)result + 1) || (**(_WORD **)result & 0xFFFE) != 0x26)
      return 0;
    else
      return (MTSlideGesture *)!MTSlideGesture::isFluidFullyTriggered(result);
  }
  return result;
}

void MTChordCyclingTrackpad::~MTChordCyclingTrackpad(MTChordCyclingTrackpad *this)
{
  MTChordCycling::~MTChordCycling(this);
  JUMPOUT(0x2348D0034);
}

BOOL MTSlideGesture::isFluidFullyTriggered(MTSlideGesture *this)
{
  if (*(_QWORD *)this == *((_QWORD *)this + 1) || **(unsigned __int16 **)this - 35 > 4)
    return 0;
  if (MTSlideGesture::fluidSwipePercentage(this) <= 1.0)
    return MTSlideGesture::fluidSwipePercentage(this) < -1.0;
  return 1;
}

void MTChordCycling::~MTChordCycling(MTChordCycling *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void **v12;

  *(_QWORD *)this = &off_24FFF2B78;
  v12 = (void **)((char *)this + 976);
  std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100](&v12);
  v2 = (void *)*((_QWORD *)this + 118);
  if (v2)
  {
    *((_QWORD *)this + 119) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 114);
  if (v3)
  {
    *((_QWORD *)this + 115) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 110);
  if (v4)
  {
    *((_QWORD *)this + 111) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 106);
  if (v5)
  {
    *((_QWORD *)this + 107) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 102);
  if (v6)
  {
    *((_QWORD *)this + 103) = v6;
    operator delete(v6);
  }
  v12 = (void **)((char *)this + 568);
  std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100](&v12);
  v7 = (void *)*((_QWORD *)this + 67);
  if (v7)
  {
    *((_QWORD *)this + 68) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 63);
  if (v8)
  {
    *((_QWORD *)this + 64) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 59);
  if (v9)
  {
    *((_QWORD *)this + 60) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 55);
  if (v10)
  {
    *((_QWORD *)this + 56) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 51);
  if (v11)
  {
    *((_QWORD *)this + 52) = v11;
    operator delete(v11);
  }
  MTChordTable::~MTChordTable(this);
}

{
  MTChordCycling::~MTChordCycling(this);
  JUMPOUT(0x2348D0034);
}

uint64_t MTChordCycling::MTChordCycling(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5, int a6)
{
  uint64_t v10;

  v10 = MTChordTable::MTChordTable(a1, a2, a3);
  *(_QWORD *)v10 = &off_24FFF2B78;
  *(_QWORD *)(v10 + 392) = a4;
  *(_BYTE *)(v10 + 400) = a5;
  MTChordIntegrating::MTChordIntegrating((MTChordIntegrating *)(v10 + 408));
  MTChordIntegrating::MTChordIntegrating((MTChordIntegrating *)(a1 + 816));
  MTParameterFactory::initChordCyclingParams(a1 + 368, a6);
  MTParameterFactory::initGestureTimingParams(a1 + 388);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  return a1;
}

void sub_2310ABEBC(_Unwind_Exception *a1)
{
  MTChordTable *v1;
  MTChordGestureSet *v2;

  MTChordGestureSet::~MTChordGestureSet(v2);
  MTChordTable::~MTChordTable(v1);
  _Unwind_Resume(a1);
}

uint64_t MTChordCycling::clearChordCyclingState(MTChordCycling *this)
{
  MTChordIntegrating::nullify((void **)this + 51);
  MTChordIntegrating::nullify((void **)this + 102);
  *((_QWORD *)this + 157) = 0;
  *(_OWORD *)((char *)this + 1224) = 0u;
  *(_OWORD *)((char *)this + 1240) = 0u;
  MTTapDragManager::clearState(*((_QWORD *)this + 49));
  return MTChordTable::clearChordCyclingState(this);
}

uint64_t MTChordCycling::getCommittedFingerCount(MTChordCycling *this)
{
  if (*((_BYTE *)this + 672))
    return *((unsigned int *)this + 156);
  else
    return 0;
}

BOOL MTChordCycling::hasTriggeredFluidDock(MTChordCycling *this)
{
  unsigned __int16 **v1;

  return *((_BYTE *)this + 672)
      && (v1 = (unsigned __int16 **)*((_QWORD *)this + 85)) != 0
      && *v1 != v1[1]
      && **v1 == 37;
}

double MTChordCycling::selectSlideChord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  MTChordIntegrating *v8;
  double result;

  v8 = (MTChordIntegrating *)(a1 + 408);
  MTChordIntegrating::endChordIntegration(a1 + 408, a2, a3, a4, a1);
  if (a5)
  {
    MTChordIntegrating::operator=(v8, a5);
    *(_QWORD *)(a1 + 1224) = *(_QWORD *)(a2 + 8);
    MTChordIntegrating::beginChordIntegration((double *)v8, a2);
    result = *(double *)(a2 + 8);
    *(double *)(a1 + 656) = result;
  }
  return result;
}

double MTChordCycling::selectTapChord(MTChordCycling *this, const MTHandStatistics *a2, const MTHandMotion *a3, MTChordGestureSet *a4)
{
  double result;

  if (a4)
  {
    *((_QWORD *)this + 153) = *((_QWORD *)a2 + 1);
    MTChordIntegrating::operator=((MTChordCycling *)((char *)this + 816), (uint64_t)a4);
    result = *((double *)a2 + 1);
    *((double *)this + 133) = result;
  }
  return result;
}

void MTChordCycling::handleChordLiftoff(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  _BOOL8 v9;

  if (*(_DWORD *)(a1 + 1040))
  {
    v8 = *(_QWORD *)(a1 + 392);
    v9 = *(int *)(v8 + 24) >= 2 && *(unsigned __int8 *)(v8 + 48) > 1u
      || *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) == 1;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _BOOL8, _QWORD))(*(_QWORD *)a1 + 120))(a1, a2, a3, a4, v9, 0);
    MTChordIntegrating::endChordIntegration(a1 + 816, a2, a3, a4, a1);
  }
  if (*(_DWORD *)(a1 + 632))
    MTChordIntegrating::endChordIntegration(a1 + 408, a2, a3, a4, a1);
}

BOOL MTChordCycling::touchdownSinceTapOrExcessMotion(MTChordCycling *this, const MTHandStatistics *a2)
{
  double v2;
  double v3;
  double v4;
  uint64_t v5;
  double v6;
  double v7;

  v2 = *((double *)a2 + 10);
  v3 = *((double *)a2 + 1);
  v4 = v3 - v2;
  v5 = *((_QWORD *)this + 49);
  v6 = v3 - *(double *)(v5 + 72);
  v7 = v3 - *(double *)(v5 + 80);
  if (v6 < v7)
    v7 = v6;
  return v4 < v7 && v2 > *((double *)this + 157);
}

BOOL MTChordCycling::subsetSinceTapOrExcessMotion(MTChordCycling *this, const MTHandStatistics *a2)
{
  double v2;
  double v3;
  double v4;
  uint64_t v5;
  double v6;
  double v7;

  v2 = *((double *)a2 + 33);
  v3 = *((double *)a2 + 1);
  v4 = v3 - v2;
  v5 = *((_QWORD *)this + 49);
  v6 = v3 - *(double *)(v5 + 72);
  v7 = v3 - *(double *)(v5 + 80);
  if (v6 < v7)
    v7 = v6;
  return v4 < v7 && v2 > *((double *)this + 157);
}

void MTChordCycling::chk4excessTapMotion(MTChordCycling *this, const MTHandStatistics *a2, const MTHandMotion *a3)
{
  unsigned __int16 **v3;
  unsigned int v4;
  BOOL v5;
  uint64_t v6;
  int v8;
  int v9;
  int v10;

  if (*((_DWORD *)this + 260) && *((_DWORD *)this + 158) && *((_BYTE *)this + 672))
  {
    v3 = (unsigned __int16 **)*((_QWORD *)this + 85);
    if (v3 && *v3 != v3[1])
    {
      if ((**v3 & 0x80) != 0)
        goto LABEL_20;
      v4 = **v3 - 35;
      v5 = v4 > 0x2B;
      v6 = (1 << v4) & 0x8010000001FLL;
      if (!v5 && v6 != 0)
        goto LABEL_20;
    }
    v8 = dword_255EB3C30 >= 0 ? dword_255EB3C30 : dword_255EB3C30 + 1;
    v9 = v8 >> 1;
    v10 = *((unsigned __int8 *)a2 + 186) >= 2u ? v9 : dword_255EB3C30;
    if (*((_DWORD *)this + 174) >= v10)
    {
LABEL_20:
      *((_QWORD *)this + 157) = *((_QWORD *)a2 + 1);
      MTChordIntegrating::nullify((void **)this + 102);
    }
  }
}

uint64_t MTChordCycling::chk4newTapChord(MTChordCycling *this, MTHandStatistics *a2, const MTHandMotion *a3, MTChordGestureSet *a4)
{
  int v8;
  unsigned int v9;

  if (a4
    && *((double *)a2 + 10) > *((double *)a2 + 16)
    && (*(unsigned int (**)(MTChordCycling *, MTHandStatistics *))(*(_QWORD *)this + 48))(this, a2))
  {
    v8 = *((_DWORD *)this + 260);
    if (!v8
      || ((v9 = *((_DWORD *)a4 + 54), v9 >= *((_DWORD *)this + 258)) || v9 < *((unsigned __int8 *)a2 + 186))
      && *((_DWORD *)a4 + 56) != v8)
    {
      (*(void (**)(MTChordCycling *, MTHandStatistics *, const MTHandMotion *, MTChordGestureSet *))(*(_QWORD *)this + 72))(this, a2, a3, a4);
    }
  }
  return (*(uint64_t (**)(MTChordCycling *, MTHandStatistics *, const MTHandMotion *))(*(_QWORD *)this + 80))(this, a2, a3);
}

BOOL MTChordCycling::tapHasValidTimingAndStrength(MTChordCycling *this, const MTHandStatistics *a2, const MTHandMotion *a3, char a4)
{
  double v5;
  double v6;
  double v9;
  double v10;
  _QWORD *v11;

  if (*((float *)a2 + 51) <= *((float *)this + 92))
    return 0;
  v5 = *((double *)a2 + 10);
  v6 = *((double *)a2 + 1);
  if (v6 - v5 >= *(double *)&qword_255EB3BF8
    || v5 - *((double *)a2 + 9) >= *(double *)&qword_255EB3BF8 * 0.5
    || (a4 & 1) == 0 && v6 - *((double *)a2 + 33) >= *(double *)&qword_255EB3BF8)
  {
    return 0;
  }
  if (*((_BYTE *)a2 + 186) && *((_BYTE *)a2 + 185))
    return 0;
  if (v6 - v5 <= *(double *)&qword_255EB3C00 && *((_BYTE *)this + 400))
    return 0;
  MTAbsoluteTimeGetCurrent();
  if (v9 - *((double *)a2 + 5) < *(double *)&qword_255EB3BF8)
    return 0;
  MTAbsoluteTimeGetCurrent();
  if (v10 - *((double *)a2 + 6) < *(double *)&qword_255EB3BF8)
    return 0;
  if (*((_DWORD *)this + 158))
  {
    if (*((_DWORD *)this + 173))
      return 0;
    v11 = (_QWORD *)*((_QWORD *)this + 85);
    if (v11)
    {
      if (*v11 != v11[1] && *(_WORD *)*v11 == 70)
        return 0;
    }
  }
  return (*((_DWORD *)a2 + 44) == *((_DWORD *)a2 + 45) || *((unsigned __int16 *)a2 + 108) >= 2u)
      && (!(*((unsigned __int8 *)a2 + 211) + *((unsigned __int8 *)a2 + 186)) || !*((_BYTE *)a2 + 184))
      && *((float *)a3 + 61) <= *(float *)&dword_255EB3C78;
}

void MTChordCycling::processDoubleTap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  double v5;
  double v6;
  double v7;
  int v9;
  BOOL v13;
  uint64_t v14;

  v4 = *(_QWORD *)(a1 + 392);
  v5 = *(double *)(a2 + 8);
  v6 = *(double *)(v4 + 72);
  v7 = v5 - v6;
  if (v5 - v6 < *(double *)&qword_255EB3C28 && v6 > *(double *)(v4 + 88))
  {
    v9 = *(unsigned __int8 *)(v4 + 49);
    if (*(_DWORD *)(a1 + 1032) == v9
      && (hypotf(*(float *)(a2 + 248) - *(float *)(a2 + 240), *(float *)(a2 + 252) - *(float *)(a2 + 244)) < *(float *)(a1 + 380)
       || vabdd_f64(*(double *)(a2 + 96), *(double *)(a2 + 104)) < *(double *)&qword_255EB3C50)
      && (!*(_BYTE *)(a1 + 376) || v7 >= v5 - *(double *)(a2 + 136)))
    {
      if (!*(_BYTE *)(a1 + 384)
        || (v9 == *(unsigned __int8 *)(a2 + 199) ? (v13 = v9 == *(unsigned __int8 *)(a2 + 200)) : (v13 = 0), v13))
      {
        MTGesture::dispatchEvents((uint64_t *)(a1 + 880), v4, a4, 0, 0, a3, 28672, *(unsigned int *)(a1 + 1040), v5);
        v14 = *(_QWORD *)(a1 + 392);
        *(_QWORD *)(v14 + 88) = *(_QWORD *)(a2 + 8);
        MTTapDragManager::clearCycle(v14);
      }
    }
  }
}

void MTChordCycling::processMultiFingerDoubleTap(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4)
{
  uint64_t v6;
  double v7;
  double v8;
  int v9;
  BOOL v10;
  uint64_t v11;
  _WORD *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;

  v6 = *(_QWORD *)(a1 + 392);
  v7 = *(double *)(a2 + 8);
  v8 = *(double *)(v6 + 72);
  if (v7 - v8 < *(double *)&qword_255EB3C28
    && v8 > *(double *)(v6 + 88)
    && (v9 = *(unsigned __int8 *)(v6 + 49), *(_DWORD *)(a1 + 1032) == v9)
    && (!*(_BYTE *)(a1 + 376) || v7 - v8 >= v7 - *(double *)(a2 + 136))
    && (!*(_BYTE *)(a1 + 384)
     || (v9 == *(unsigned __int8 *)(a2 + 199) ? (v10 = v9 == *(unsigned __int8 *)(a2 + 200)) : (v10 = 0), v10)))
  {
    MTGesture::dispatchEvents((uint64_t *)(a1 + 880), v6, a4, 0, 0, (uint64_t)a3, 28672, *(unsigned int *)(a1 + 1040), v7);
    v14 = *(_QWORD *)(a1 + 392);
    *(_QWORD *)(v14 + 88) = *(_QWORD *)(a2 + 8);
    MTTapDragManager::clearCycle(v14);
  }
  else if (*(int *)(a1 + 1036) >= 2)
  {
    v11 = *(_QWORD *)(a1 + 816);
    if (v11 != *(_QWORD *)(a1 + 824))
    {
      if (*(_WORD *)v11)
      {
        v12 = *(_WORD **)(a1 + 880);
        if (v12 != *(_WORD **)(a1 + 888))
        {
          if (*v12)
          {
            if (*(_WORD *)v11 == 67)
            {
              v13 = *(_DWORD *)(v11 + 4);
              if (v13 == 1024 || v13 == 512)
                MTTapDragManager::queueMultiFingerTapWaitingForDouble(*(_QWORD *)(a1 + 392), a2, a3, a4, v13);
            }
          }
        }
      }
    }
  }
  v15 = *(_QWORD *)(a1 + 392);
  v16 = *(_DWORD *)(a1 + 1032);
  *(_QWORD *)(v15 + 72) = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(v15 + 49) = v16;
  MTChordIntegrating::nullify((void **)(a1 + 816));
}

void MTChordCycling::handleChordTaps(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v11;
  _WORD *v12;
  int v13;
  _WORD *v14;
  _WORD *v15;
  double v16;
  double v17;
  double v18;
  uint64_t v19;
  int v20;

  if (!*(_DWORD *)(a1 + 1040))
    return;
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1))
    return;
  if (!(*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 96))(a1, a2, a3, a6))
    return;
  v11 = *(_DWORD *)(a1 + 1048);
  if (v11)
  {
    if ((*(_DWORD *)(a1 + 24) & v11) == 0)
      return;
  }
  v12 = *(_WORD **)(a1 + 816);
  if (v12 == *(_WORD **)(a1 + 824))
    goto LABEL_11;
  v13 = 0;
  if (!*v12 || (a6 & 1) != 0)
    goto LABEL_12;
  if (*(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186))
  {
LABEL_11:
    v13 = 0;
  }
  else
  {
    MTGesture::dispatchEvents((uint64_t *)(a1 + 816), *(_QWORD *)(a1 + 392), a4, 0, 0, a3 + 168, 12288, *(unsigned int *)(a1 + 1040), *(double *)(a2 + 8));
    v13 = 1;
  }
LABEL_12:
  if (*(_DWORD *)(a1 + 1036) == 1)
  {
    v14 = *(_WORD **)(a1 + 880);
    if (v14 != *(_WORD **)(a1 + 888)
      && *v14
      && (a6 & 1) == 0
      && *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) <= 1)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 104))(a1, a2, a3 + 168, a4);
      v13 = 1;
    }
  }
  if ((_DWORD)a6 && *(double *)(a2 + 80) - *(double *)(a2 + 88) <= 0.09
    || *(int *)(a1 + 1036) < 2
    || (v15 = *(_WORD **)(a1 + 880), v15 == *(_WORD **)(a1 + 888))
    || !*v15
    || *(float *)(a3 + 356) >= 21.0
    || (v16 = *(double *)(a2 + 8),
        v17 = v16 - *(double *)(a2 + 64),
        v17 >= *(double *)&qword_255EB3BF8 + *(double *)&qword_255EB3C58)
    || (v18 = v16 - *(double *)(a2 + 56), v17 - v18 >= *(double *)&qword_255EB3C58)
    || v18 - (v16 - *(double *)(a2 + 80)) >= *(double *)&qword_255EB3C58)
  {
    if (!v13)
      return;
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 112))(a1, a2, a3 + 168, a4);
  }
  if (*(_DWORD *)(a1 + 1040))
  {
    v19 = *(_QWORD *)(a1 + 392);
    v20 = *(_DWORD *)(a1 + 1032);
    *(_QWORD *)(v19 + 72) = *(_QWORD *)(a2 + 8);
    *(_BYTE *)(v19 + 49) = v20;
    MTChordIntegrating::nullify((void **)(a1 + 816));
  }
}

uint64_t MTChordCycling::possiblyStartChordMomentum(uint64_t result, unsigned __int8 *a2, uint64_t a3)
{
  if (a2[211] + a2[186] < a2[190] + a2[187])
  {
    if (*(_DWORD *)(result + 632))
      return MTChordIntegrating::possiblyStartMomentum(result + 408, (uint64_t)a2, a3, result);
  }
  return result;
}

uint64_t MTChordCycling::possiblyStopChordMomentum(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;

  if (*(_BYTE *)(result + 1264)
    && *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) > *(unsigned __int8 *)(a2 + 190)
                                                                                     + *(unsigned __int8 *)(a2 + 187))
  {
    v4 = *(_DWORD *)(result + 1268);
    if (*(_DWORD *)(result + 1276) == v4)
    {
      if (*(_BYTE *)(result + 1272))
        *(_QWORD *)(*(_QWORD *)(result + 392) + 80) = *(_QWORD *)(a2 + 8);
    }
    return MTDragManagerEventQueue::stopMomentum(result, a4, v4);
  }
  return result;
}

uint64_t MTChordCycling::chk4chordCycling(_DWORD *a1, uint64_t a2, float32x4_t *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t result;
  char v10;
  uint64_t MatchingChord;
  int v12;
  __int16 v13;
  unsigned __int16 **v14;

  if (*(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) > *(unsigned __int8 *)(a2 + 190)
                                                                                     + *(unsigned __int8 *)(a2 + 187)
    && a1[158])
  {
    MTChordIntegrating::clearMickeysSinceLastTouchdown((uint64_t)(a1 + 102));
  }
  (*(void (**)(_DWORD *, uint64_t, float32x4_t *, uint64_t))(*(_QWORD *)a1 + 144))(a1, a2, a3, a4);
  (*(void (**)(_DWORD *, uint64_t, uint64_t))(*(_QWORD *)a1 + 136))(a1, a2, a4);
  v8 = *(_QWORD *)a1;
  if (!(*(unsigned __int8 *)(a2 + 298) | *(unsigned __int8 *)(a2 + 186)))
    return (*(uint64_t (**)(_DWORD *, uint64_t, float32x4_t *, uint64_t))(v8 + 88))(a1, a2, a3, a4);
  v10 = (*(uint64_t (**)(_DWORD *, uint64_t))(v8 + 24))(a1, a2);
  MatchingChord = MTChordTable::findMatchingChord((MTChordTable *)a1, v10, 0);
  result = (*(uint64_t (**)(_DWORD *, uint64_t, float32x4_t *, uint64_t))(*(_QWORD *)a1 + 128))(a1, a2, a3, MatchingChord);
  v12 = a1[158];
  if (v12)
  {
    if (MatchingChord)
    {
      if (*(_DWORD *)(MatchingChord + 224) != v12
        || (result = MTChordGestureSet::chordGestureSetEquals((MTChordGestureSet *)MatchingChord, (const MTChordGestureSet *)(a1 + 102)), (result & 1) == 0))
      {
        if (*(_DWORD *)(MatchingChord + 216) >= a1[156])
        {
          if (!*((_BYTE *)a1 + 672)
            || (a1[159] & 0x20) != 0
            && ((*(_WORD *)(MatchingChord + 228) & 2) != 0
             && ((*(_DWORD *)(a2 + 164) - 3000) < 0xFFFFFC18
              || a1[7] == 2
              || *(unsigned __int8 *)(a2 + 298) == *(unsigned __int8 *)(a2 + 302))
             || *(double *)(a2 + 8) - *(double *)(a2 + 56) < 0.09))
          {
            return (*(uint64_t (**)(_DWORD *, uint64_t, float32x4_t *, uint64_t, uint64_t))(*(_QWORD *)a1 + 64))(a1, a2, a3, a4, MatchingChord);
          }
        }
        else
        {
          if (!*((_BYTE *)a1 + 672) && ((*(_DWORD *)(a2 + 164) - 3000) < 0xFFFFFC18 || a1[7] == 2))
            return (*(uint64_t (**)(_DWORD *, uint64_t, float32x4_t *, uint64_t, uint64_t))(*(_QWORD *)a1 + 64))(a1, a2, a3, a4, MatchingChord);
          v13 = *((_WORD *)a1 + 318);
          if ((v13 & 0x10) != 0
            && (*(_WORD *)(MatchingChord + 228) & 1) != 0
            && ((v13 & 0x80) != 0 || *(double *)(a2 + 8) - *(double *)(a2 + 128) > *(double *)&gTimingPrefs * 0.5))
          {
            v14 = (unsigned __int16 **)*((_QWORD *)a1 + 85);
            if (!v14 || *v14 == v14[1] || **v14 - 35 >= 5)
              return (*(uint64_t (**)(_DWORD *, uint64_t, float32x4_t *, uint64_t, uint64_t))(*(_QWORD *)a1 + 64))(a1, a2, a3, a4, MatchingChord);
          }
        }
      }
    }
  }
  else if (MatchingChord)
  {
    result = MTChordGestureSet::isChordReadyToIntegrate((MTChordGestureSet *)MatchingChord, (const MTHandStatistics *)a2, a3);
    if ((_DWORD)result)
      return (*(uint64_t (**)(_DWORD *, uint64_t, float32x4_t *, uint64_t, uint64_t))(*(_QWORD *)a1 + 64))(a1, a2, a3, a4, MatchingChord);
  }
  return result;
}

double MTChordCycling::parseHandGesturesCreateHIDEvents(_DWORD *a1, MTHandStatistics *a2, const MTHandMotion *a3, uint64_t a4)
{
  double result;
  double v9;
  float v10;

  (*(void (**)(_DWORD *))(*(_QWORD *)a1 + 152))(a1);
  if (a1[158])
  {
    MTChordIntegrating::continueChordIntegration((MTChordGestureSet *)(a1 + 102), a2, a3, a4, (uint64_t)a1, result, v9, v10);
    return MTChordIntegrating::decayMomentumFilters((MTChordIntegrating *)(a1 + 102), a2);
  }
  return result;
}

uint64_t MTChordCycling::shouldBlockClicks(MTChordCycling *this, const MTHandStatistics *a2, const MTHandMotion *a3)
{
  float v3;
  double v4;
  double v5;
  int v6;
  unsigned __int16 **v7;
  unsigned int v8;

  v3 = *((float *)a3 + 62);
  v4 = 0.0;
  if (v3 > 1.0)
  {
    v4 = 0.5;
    if (v3 < 100.0)
      v4 = (float)((float)(v3 + -1.0) / 99.0) * 0.5;
  }
  v5 = *((double *)a2 + 1);
  v6 = *((_DWORD *)this + 158);
  if (!v6)
    goto LABEL_12;
  v7 = (unsigned __int16 **)*((_QWORD *)this + 85);
  if (!v7)
  {
    v6 = 0;
    goto LABEL_13;
  }
  v6 = *v7 != v7[1] && **v7 == 69;
  if (*v7 == v7[1])
LABEL_12:
    LODWORD(v7) = 0;
  else
    LODWORD(v7) = **v7 == 71;
LABEL_13:
  v8 = v6 | v7;
  if (v5 - *((double *)this + 155) <= v4)
    v8 = 1;
  if (v5 - *((double *)this + 156) <= v4)
    return 1;
  else
    return v8;
}

void MTTapDragManager::MTTapDragManager(MTTapDragManager *this)
{
  *(_QWORD *)this = &unk_24FFF2C40;
  *((_BYTE *)this + 8) = 0;
  *(_WORD *)((char *)this + 9) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_WORD *)this + 24) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 9) = 0;
  *(_QWORD *)((char *)this + 20) = 0;
  *(_QWORD *)((char *)this + 12) = 0;
  *((_BYTE *)this + 28) = 0;
}

uint64_t MTTapDragManager::clearState(uint64_t this)
{
  *(_BYTE *)(this + 28) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_WORD *)(this + 9) = 0;
  *(_QWORD *)(this + 32) = 0;
  *(_QWORD *)(this + 40) = 0;
  *(_WORD *)(this + 48) = 0;
  *(_QWORD *)(this + 80) = 0;
  *(_QWORD *)(this + 88) = 0;
  *(_QWORD *)(this + 72) = 0;
  return this;
}

uint64_t MTTapDragManager::setCycleState(uint64_t result, int a2)
{
  *(_DWORD *)(result + 24) = a2;
  return result;
}

uint64_t MTTapDragManager::clearCycle(uint64_t this)
{
  *(_BYTE *)(this + 28) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_QWORD *)(this + 32) = 0;
  *(_BYTE *)(this + 48) = 0;
  *(_WORD *)(this + 9) = 0;
  return this;
}

uint64_t MTTapDragManager::dragHandModifiers(MTTapDragManager *this)
{
  int v2;
  uint64_t result;

  v2 = *((_DWORD *)this + 6);
  if (v2 >= 2 && (v2 == 2 || *((_BYTE *)this + 28) == 0))
    return 256;
  result = *((_QWORD *)this + 2);
  if (!result)
    return result;
  if (MTForceManagement::whichForceButtonActivated((MTForceManagement *)result) == 1)
    return 256;
  result = *((_QWORD *)this + 2);
  if (result)
  {
    if (MTForceManagement::whichForceButtonActivated((MTForceManagement *)result) == 2)
    {
      return 512;
    }
    else
    {
      result = *((_QWORD *)this + 2);
      if (result)
        return (MTForceManagement::whichForceButtonActivated((MTForceManagement *)result) == 4) << 10;
    }
  }
  return result;
}

BOOL MTTapDragManager::shouldReleaseTapDragDueToPause(MTTapDragManager *this, double a2)
{
  int v2;

  v2 = *((_DWORD *)this + 6);
  if (v2 < 2)
    return 0;
  if (v2 <= 3)
    return a2 - *((double *)this + 4) < *(double *)&gTimingPrefs;
  return 1;
}

BOOL MTTapDragManager::halfTapDragTimedOut(MTTapDragManager *this, double a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  double v8;
  double v9;

  v4 = *((unsigned __int8 *)this + 28);
  v5 = qword_255EB3C10;
  v6 = qword_255EB3C20;
  if (((*(uint64_t (**)(MTTapDragManager *))(*(_QWORD *)this + 16))(this) & 0x100) == 0)
    return 1;
  if (v4)
    v8 = *(double *)&v6;
  else
    v8 = *(double *)&v5;
  v9 = a2 - *((double *)this + 9);
  if (v9 >= a2 - *((double *)this + 10))
    v9 = a2 - *((double *)this + 10);
  return v9 > v8;
}

BOOL MTTapDragManager::shouldSustainDrag(MTTapDragManager *this, double a2, int a3)
{
  int v6;

  if (*((_BYTE *)this + 9))
    return 0;
  if (a3 - *((unsigned __int8 *)this + 48) > 0)
    return 1;
  v6 = *((_DWORD *)this + 6);
  if (v6 < 2)
    return !MTTapDragManager::halfTapDragTimedOut(this, a2);
  if (v6 > 3 || a2 - *((double *)this + 4) < *(double *)&gTimingPrefs)
    return 0;
  return v6 >= 3
      && *((_BYTE *)this + 8)
      && ((**(uint64_t (***)(MTTapDragManager *))this)(this) & 1) != 0
      || !MTTapDragManager::halfTapDragTimedOut(this, a2);
}

uint64_t MTTapDragManager::sendWaitingClickAtHalfTimeout(uint64_t a1, uint64_t a2, int a3, double a4)
{
  uint64_t v5;
  double v8;
  unint64_t v10;

  if (!*(_BYTE *)(a1 + 9))
  {
    v8 = a4 - *(double *)(a1 + 72);
    if (*(_BYTE *)(a1 + 10))
    {
      if (v8 >= *(double *)&qword_255EB3C28 + *(double *)&qword_255EB3C00 * -2.0 && *(unsigned __int8 *)(a1 + 48) == a3)
      {
        v10 = 0xAAAAAAAAAAAAAAAALL;
        MTActionEvent::MTActionEvent((MTActionEvent *)&v10, 67, *(_DWORD *)(a1 + 12), 0);
        v5 = 1;
        (*(void (**)(uint64_t, unint64_t *, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t, double))(*(_QWORD *)a1 + 24))(a1, &v10, a2, 0, 0, a1 + 52, 12288, 1, a4);
        *(double *)(a1 + 88) = a4;
        *(_BYTE *)(a1 + 28) = 0;
        *(_DWORD *)(a1 + 12) = 0;
        *(_DWORD *)(a1 + 24) = 0;
        *(_QWORD *)(a1 + 32) = 0;
        *(_BYTE *)(a1 + 48) = 0;
        goto LABEL_3;
      }
    }
    else if (v8 >= *(double *)&qword_255EB3C08)
    {
      if (*(unsigned __int8 *)(a1 + 48) == a3)
      {
        v10 = 0xAAAAAAAAAAAAAAAALL;
        MTActionEvent::MTActionEvent((MTActionEvent *)&v10, 67, 256, 0);
        (*(void (**)(uint64_t, unint64_t *, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t, double))(*(_QWORD *)a1 + 24))(a1, &v10, a2, 0, 0, a1 + 52, 12288, 1, a4);
      }
      goto LABEL_2;
    }
    return 0;
  }
LABEL_2:
  *(_BYTE *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  v5 = 1;
LABEL_3:
  *(_WORD *)(a1 + 9) = 0;
  return v5;
}

uint64_t MTTapDragManager::sendPendingMultiFingerTap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, double a6)
{
  double v8;
  double v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v13;

  v8 = *(double *)(a3 + 8);
  if (*(int *)(a1 + 24) <= 1)
  {
    v11 = *(double *)&qword_255EB3C88 > a6 || *(unsigned __int8 *)(a3 + 195) > 1u;
    if (v11 || *(float *)(a4 + 248) > *(float *)&dword_255EB3C78)
    {
      v10 = 0;
LABEL_15:
      *(_BYTE *)(a1 + 28) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 24) = 0;
      *(_QWORD *)(a1 + 32) = 0;
      *(_BYTE *)(a1 + 48) = 0;
      goto LABEL_16;
    }
  }
  if (*(_BYTE *)(a1 + 10))
  {
    v9 = v8 - *(double *)(a1 + 72);
    if (v9 > *(double *)&qword_255EB3C28 + *(double *)&qword_255EB3C00 * 2.0)
    {
      *(_BYTE *)(a1 + 28) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 24) = 0;
      *(_QWORD *)(a1 + 32) = 0;
      *(_BYTE *)(a1 + 48) = 0;
      v10 = 1;
LABEL_16:
      *(_WORD *)(a1 + 9) = 0;
      return v10;
    }
    if (!a5 || v9 > *(double *)&qword_255EB3C28)
    {
      v13 = 0xAAAAAAAAAAAAAAAALL;
      MTActionEvent::MTActionEvent((MTActionEvent *)&v13, 67, *(_DWORD *)(a1 + 12), 0);
      v10 = 1;
      (*(void (**)(uint64_t, unint64_t *, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t, double))(*(_QWORD *)a1 + 24))(a1, &v13, a2, 0, 0, a1 + 52, 12288, 1, v8);
      *(double *)(a1 + 88) = v8;
      goto LABEL_15;
    }
  }
  return 0;
}

double MTTapDragManager::queueTapWaitingForHalf(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  double result;

  *(_DWORD *)(a1 + 24) = 1;
  *(_OWORD *)(a1 + 52) = *a3;
  result = *(double *)(a2 + 8);
  *(double *)(a1 + 40) = result;
  *(_BYTE *)(a1 + 48) = *(_BYTE *)(a2 + 211) + *(_BYTE *)(a2 + 186);
  return result;
}

double MTTapDragManager::queueMultiFingerTapWaitingForDouble(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, int a5)
{
  double result;

  *(_DWORD *)(a1 + 24) = 1;
  *(_OWORD *)(a1 + 52) = *a3;
  result = *(double *)(a2 + 8);
  *(double *)(a1 + 40) = result;
  *(_BYTE *)(a1 + 48) = *(_BYTE *)(a2 + 211) + *(_BYTE *)(a2 + 186);
  *(_BYTE *)(a1 + 10) = 1;
  *(_DWORD *)(a1 + 12) = a5;
  return result;
}

uint64_t MTTapDragManager::queueButtonClickEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v9;

  *(_BYTE *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 9) = 0;
  v9 = 0xAAAAAAAAAAAAAAAALL;
  MTActionEvent::MTActionEvent((MTActionEvent *)&v9, 67, 256, 0);
  return (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t, double))(*(_QWORD *)a1 + 24))(a1, &v9, a4, 0, 0, a3, 12288, 1, *(double *)(a2 + 8));
}

double MTTapDragManager::queueButtonPressEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double result;
  unint64_t v9;

  *(_DWORD *)(a1 + 24) = 2;
  v9 = 0xAAAAAAAAAAAAAAAALL;
  MTActionEvent::MTActionEvent((MTActionEvent *)&v9, 65, 256, 0);
  (*(void (**)(uint64_t, unint64_t *, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t, double))(*(_QWORD *)a1 + 24))(a1, &v9, a4, 0, 0, a3, 12288, 1, *(double *)(a2 + 8));
  result = *(double *)(a2 + 8);
  *(double *)(a1 + 40) = result;
  return result;
}

uint64_t MTTapDragManager::queueButtonReleaseEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v9;

  v9 = 0xAAAAAAAAAAAAAAAALL;
  MTActionEvent::MTActionEvent((MTActionEvent *)&v9, 66, 256, 0);
  *(_BYTE *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 9) = 0;
  return (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t, double))(*(_QWORD *)a1 + 24))(a1, &v9, a4, 0, 0, a3, 12288, 1, *(double *)(a2 + 8));
}

double MTTapDragManager::handleTapsForDrag(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7;
  double result;
  __int128 v9;

  v9 = *(_OWORD *)(a3 + 168);
  v7 = *(_DWORD *)(a1 + 24);
  if (v7 < 2)
  {
    if (*(double *)(a2 + 8) - *(double *)(a1 + 72) >= *(double *)&qword_255EB3BF8)
    {
      *(_DWORD *)(a1 + 24) = 1;
      *(_OWORD *)(a1 + 52) = v9;
      *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 8);
      *(_BYTE *)(a1 + 48) = *(_BYTE *)(a2 + 211) + *(_BYTE *)(a2 + 186);
      goto LABEL_7;
    }
  }
  else
  {
    MTTapDragManager::queueButtonReleaseEvent(a1, a2, (uint64_t)&v9, a4);
    if (v7 != 2)
      goto LABEL_7;
  }
  MTTapDragManager::queueButtonClickEvent(a1, a2, (uint64_t)&v9, a4);
LABEL_7:
  result = *(double *)(a2 + 8);
  *(double *)(a1 + 72) = result;
  *(_BYTE *)(a1 + 49) = 1;
  return result;
}

uint64_t MTTapDragManager::handleImmediateTapDragRelease(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  v4 = result;
  if (*(int *)(result + 24) >= 2)
  {
    result = (**(uint64_t (***)(uint64_t))result)(result);
    if ((_DWORD)result)
    {
      if (*(_BYTE *)(v4 + 9))
        result = MTTapDragManager::queueButtonReleaseEvent(v4, a2, a3 + 168, a4);
    }
  }
  *(_BYTE *)(v4 + 9) = 0;
  return result;
}

uint64_t MTTapDragManager::chk4dragCycling(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5)
{
  int v9;
  unsigned int v10;
  double v11;
  double v12;
  double v13;
  int v14;

  MTTapDragManager::sendPendingMultiFingerTap(a1, a4, a2, a3, 1, a5);
  v9 = *(_DWORD *)(a1 + 24);
  if (v9 == 1)
  {
    v10 = *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186);
    if (v10 <= *(unsigned __int8 *)(a2 + 190) + *(unsigned __int8 *)(a2 + 187)
      || v10 <= *(unsigned __int8 *)(a1 + 48)
      || *(_BYTE *)(a1 + 10))
    {
      MTTapDragManager::sendWaitingClickAtHalfTimeout(a1, a4, v10, *(double *)(a2 + 8));
    }
    else
    {
      MTTapDragManager::queueButtonPressEvent(a1, a2, a3 + 168, a4);
    }
  }
  else if (v9 >= 2 && (**(unsigned int (***)(uint64_t))a1)(a1))
  {
    if (!*(_BYTE *)(a1 + 48) && *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) == 2)
      *(_BYTE *)(a1 + 48) = 1;
    v11 = *(double *)(a2 + 8);
    v12 = v11 - *(double *)(a2 + 80);
    v13 = v11 - *(double *)(a2 + 128);
    if (v12 < v13 || v13 == 0.0)
    {
      if (v12 <= *(double *)&qword_255EB3C18 || v11 - *(double *)(a3 + 160) <= *(double *)&qword_255EB3C18)
      {
        if (*(int *)(a1 + 24) < 4)
          return MTTapDragManager::handleImmediateTapDragRelease(a1, a2, a3, a4);
        v14 = 3;
      }
      else
      {
        *(double *)(a1 + 32) = v11;
        v14 = 4;
      }
      *(_DWORD *)(a1 + 24) = v14;
    }
  }
  return MTTapDragManager::handleImmediateTapDragRelease(a1, a2, a3, a4);
}

double MTTapDragManager::sustainMultiFingerDrag(uint64_t a1, uint64_t a2)
{
  double result;

  *(_BYTE *)(a1 + 28) = 1;
  *(_BYTE *)(a1 + 48) = *(_BYTE *)(a2 + 211) + *(_BYTE *)(a2 + 186);
  *(_DWORD *)(a1 + 24) = 3;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 8))(a1);
  result = *(double *)(a2 + 8);
  *(double *)(a1 + 40) = result;
  *(double *)(a1 + 80) = result;
  return result;
}

uint64_t MTTapDragManager::handleTapsForMultiFingerDrag(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(int *)(result + 24) >= 3)
    return MTTapDragManager::queueButtonReleaseEvent(result, a2, a3 + 168, a4);
  return result;
}

uint64_t MTSimpleEmbeddedHIDManager::createManager(uint64_t a1, const void *a2, int a3, int a4)
{
  uint64_t v8;

  v8 = operator new();
  *(_OWORD *)v8 = 0u;
  *(_OWORD *)(v8 + 16) = 0u;
  *(_OWORD *)(v8 + 32) = 0u;
  *(_OWORD *)(v8 + 48) = 0u;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 112) = 0u;
  *(_OWORD *)(v8 + 128) = 0u;
  *(_OWORD *)(v8 + 144) = 0u;
  *(_OWORD *)(v8 + 160) = 0u;
  *(_OWORD *)(v8 + 176) = 0u;
  *(_OWORD *)(v8 + 192) = 0u;
  *(_OWORD *)(v8 + 208) = 0u;
  *(_QWORD *)(v8 + 224) = 0;
  MTSimpleHIDManager::MTSimpleHIDManager((MTSimpleHIDManager *)v8);
  *(_QWORD *)v8 = &off_24FFF2C78;
  MTSimpleEmbeddedHIDManager::initialize((MTModeSwitcher *)v8, a1, a2, a3, a4);
  return v8;
}

void sub_2310AD908(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10A1C40E945ADD8);
  _Unwind_Resume(a1);
}

void MTSimpleEmbeddedHIDManager::initialize(MTModeSwitcher *a1, uint64_t a2, const void *a3, int a4, int a5)
{
  uint64_t IsReady;
  MTTelemetryAnalyticsReporter *v7;
  int v8;
  int v9;
  NSObject *v10;
  const char *v11;
  NSObject *v12;
  NSObject *v13;
  os_log_type_t v14;
  uint32_t v15;
  NSObject *v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  *((_QWORD *)a1 + 26) = 0;
  *((_QWORD *)a1 + 27) = 0;
  MTSimpleHIDManager::initialize(a1, a2, a3, a4, a5);
  IsReady = MTDeviceDriverIsReady();
  (*(void (**)(MTModeSwitcher *, uint64_t))(*(_QWORD *)a1 + 336))(a1, IsReady);
  (*(void (**)(MTModeSwitcher *))(*(_QWORD *)a1 + 80))(a1);
  if ((MTDeviceSupportsWirelessChargingNotification() & 1) != 0
    || ((*(void (**)(MTModeSwitcher *))(*(_QWORD *)a1 + 80))(a1),
        MTDeviceSupportsUSBChargingNotification()))
  {
    if ((MTDeviceHasExpectedVersion() & 1) == 0)
    {
      MTDeviceGetVersion();
      v12 = MTLoggingPlugin();
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 136315906;
      v18 = "";
      v19 = 2080;
      v20 = "";
      v21 = 2080;
      v22 = "initialize";
      v23 = 2048;
      v24 = 0;
      v11 = "[HID] [MT] %s%s%s Firmware version 0x%04jX is unexpected. Disabling interference monitor.";
      v13 = v12;
      v14 = OS_LOG_TYPE_DEFAULT;
      v15 = 42;
      goto LABEL_18;
    }
    *((_QWORD *)a1 + 27) = (*(uint64_t (**)(MTModeSwitcher *))(*(_QWORD *)a1 + 616))(a1);
  }
  *((_QWORD *)a1 + 28) = 0;
  if (MTDeviceGetSATelemetryReportID())
  {
    v7 = (MTTelemetryAnalyticsReporter *)operator new();
    MTTelemetryAnalyticsReporter::MTTelemetryAnalyticsReporter(v7);
    *((_QWORD *)a1 + 28) = v7;
  }
  v8 = MTDeviceEnableWorkIntervalNotification();
  if (v8 == -536870201)
  {
    v10 = MTLoggingPlugin();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      return;
    *(_DWORD *)buf = 136315650;
    v18 = "";
    v19 = 2080;
    v20 = "";
    v21 = 2080;
    v22 = "initialize";
    v11 = "[HID] [MT] %s%s%s Work interval notification not supported by device. Skipping.";
    goto LABEL_15;
  }
  v9 = v8;
  if (!v8)
  {
    v10 = MTLoggingPlugin();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      return;
    *(_DWORD *)buf = 136315650;
    v18 = "";
    v19 = 2080;
    v20 = "";
    v21 = 2080;
    v22 = "initialize";
    v11 = "[HID] [MT] %s%s%s Work interval notification enabled";
LABEL_15:
    v13 = v10;
    v14 = OS_LOG_TYPE_DEFAULT;
    v15 = 32;
    goto LABEL_18;
  }
  v16 = MTLoggingPlugin();
  if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    return;
  *(_DWORD *)buf = 136315906;
  v18 = "[Error] ";
  v19 = 2080;
  v20 = "";
  v21 = 2080;
  v22 = "initialize";
  v23 = 1024;
  LODWORD(v24) = v9;
  v11 = "[HID] [MT] %s%s%s MTDeviceEnableWorkIntervalNotification returned 0x%08X";
  v13 = v16;
  v14 = OS_LOG_TYPE_ERROR;
  v15 = 38;
LABEL_18:
  _os_log_impl(&dword_231071000, v13, v14, v11, buf, v15);
}

void sub_2310ADC24(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x1020C405F07FB98);
  _Unwind_Resume(a1);
}

uint64_t MTSimpleEmbeddedHIDManager::start(MTSimpleEmbeddedHIDManager *this)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  const void *v5;
  uint64_t v6;
  const void *v7;

  v2 = MTSimpleHIDManager::start(this);
  if ((_DWORD)v2)
  {
    v3 = *((_QWORD *)this + 27);
    if (v3)
    {
      v4 = *((_QWORD *)this + 22);
      v5 = (const void *)(*(uint64_t (**)(MTSimpleEmbeddedHIDManager *))(*(_QWORD *)this + 80))(this);
      MTInterferenceMonitor::start(v3, v4, v5);
    }
    v6 = *((_QWORD *)this + 28);
    if (v6)
    {
      v7 = (const void *)(*(uint64_t (**)(MTSimpleEmbeddedHIDManager *))(*(_QWORD *)this + 80))(this);
      MTTelemetryAnalyticsReporter::start(v6, v7);
    }
  }
  return v2;
}

uint64_t MTSimpleEmbeddedHIDManager::stop(MTSimpleEmbeddedHIDManager *this)
{
  MTInterferenceMonitor *v2;
  MTTelemetryAnalyticsReporter *v3;

  v2 = (MTInterferenceMonitor *)*((_QWORD *)this + 27);
  if (v2)
    MTInterferenceMonitor::stop(v2);
  v3 = (MTTelemetryAnalyticsReporter *)*((_QWORD *)this + 28);
  if (v3)
    MTTelemetryAnalyticsReporter::stop(v3);
  return MTSimpleHIDManager::stop(this);
}

void MTSimpleEmbeddedHIDManager::finalize(MTSimpleEmbeddedHIDManager *this)
{
  uint64_t v2;
  MTTelemetryAnalyticsReporter *v3;

  v2 = *((_QWORD *)this + 27);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (MTTelemetryAnalyticsReporter *)*((_QWORD *)this + 28);
  if (v3)
  {
    MTTelemetryAnalyticsReporter::~MTTelemetryAnalyticsReporter(v3);
    MEMORY[0x2348D0034]();
  }
  MTSimpleHIDManager::finalize(this);
}

unsigned int *MTSimpleEmbeddedHIDManager::createEventDispatcher(MTSimpleEmbeddedHIDManager *this)
{
  const void *v2;
  unsigned int *Dispatcher;

  v2 = (const void *)(*(uint64_t (**)(MTSimpleEmbeddedHIDManager *))(*(_QWORD *)this + 80))(this);
  Dispatcher = (unsigned int *)MTSimpleEmbeddedEventDispatcher::createDispatcher(this, v2);
  (*(void (**)(MTSimpleEmbeddedHIDManager *, unsigned int *))(*(_QWORD *)this + 128))(this, Dispatcher);
  return MTSimpleEventDispatcher::release(Dispatcher);
}

uint64_t MTSimpleEmbeddedHIDManager::createGestureParser(MTSimpleEmbeddedHIDManager *this)
{
  uint64_t v2;
  uint64_t result;

  v2 = (*(uint64_t (**)(MTSimpleEmbeddedHIDManager *))(*(_QWORD *)this + 80))(this);
  result = MTParser::createParserForMTDevice(v2, *((_DWORD *)this + 39), *((_DWORD *)this + 40));
  *((_QWORD *)this + 26) = result;
  return result;
}

uint64_t MTSimpleEmbeddedHIDManager::initializeGestureParser(MTSimpleEmbeddedHIDManager *this)
{
  return (*(uint64_t (**)(MTSimpleEmbeddedHIDManager *, _QWORD))(*(_QWORD *)this + 592))(this, 0);
}

unsigned int *MTSimpleEmbeddedHIDManager::destroyGestureParser(MTSimpleEmbeddedHIDManager *this)
{
  unsigned int *result;

  result = (unsigned int *)*((_QWORD *)this + 26);
  if (result)
  {
    result = MTParser::release(result);
    *((_QWORD *)this + 26) = 0;
  }
  return result;
}

uint64_t MTSimpleEmbeddedHIDManager::devicePropertiesBecameAvailable(MTParser **this)
{
  (*((void (**)(MTParser **))*this + 39))(this);
  MTParser::updateSurfaceDimensions(this[26]);
  return MTSimpleHIDManager::devicePropertiesBecameAvailable((MTSimpleHIDManager *)this);
}

void MTSimpleEmbeddedHIDManager::setPluginDefaultProperties(MTSimpleEmbeddedHIDManager *this)
{
  const __CFAllocator *v2;
  CFNumberRef v3;
  CFNumberRef v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  int ExtendedMaxDigitizerPressureValue;
  int AccurateMaxDigitizerPressureValue;
  int valuePtr;

  MTSimpleHIDManager::setPluginDefaultProperties(this);
  (*(void (**)(MTSimpleEmbeddedHIDManager *))(*(_QWORD *)this + 80))(this);
  if (MTDeviceSupportsForce())
  {
    (*(void (**)(MTSimpleEmbeddedHIDManager *))(*(_QWORD *)this + 80))(this);
    valuePtr = MTDeviceGetMinDigitizerPressureValue();
    (*(void (**)(MTSimpleEmbeddedHIDManager *))(*(_QWORD *)this + 80))(this);
    AccurateMaxDigitizerPressureValue = MTDeviceGetAccurateMaxDigitizerPressureValue();
    (*(void (**)(MTSimpleEmbeddedHIDManager *))(*(_QWORD *)this + 80))(this);
    ExtendedMaxDigitizerPressureValue = MTDeviceGetExtendedMaxDigitizerPressureValue();
    v2 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberSInt32Type, &valuePtr);
    if (v3)
    {
      v4 = v3;
      (*(void (**)(MTSimpleEmbeddedHIDManager *, const __CFString *, CFNumberRef))(*(_QWORD *)this + 568))(this, CFSTR("MinDigitizerPressureValue"), v3);
      CFRelease(v4);
    }
    v5 = CFNumberCreate(v2, kCFNumberSInt32Type, &AccurateMaxDigitizerPressureValue);
    if (v5)
    {
      v6 = v5;
      (*(void (**)(MTSimpleEmbeddedHIDManager *, const __CFString *, CFNumberRef))(*(_QWORD *)this + 568))(this, CFSTR("MaxDigitizerPressureValue"), v5);
      (*(void (**)(MTSimpleEmbeddedHIDManager *, const __CFString *, CFNumberRef))(*(_QWORD *)this + 568))(this, CFSTR("AccurateMaxDigitizerPressureValue"), v6);
      CFRelease(v6);
    }
    v7 = CFNumberCreate(v2, kCFNumberSInt32Type, &ExtendedMaxDigitizerPressureValue);
    if (v7)
    {
      v8 = v7;
      (*(void (**)(MTSimpleEmbeddedHIDManager *, const __CFString *, CFNumberRef))(*(_QWORD *)this + 568))(this, CFSTR("DigitizerPressureDynamicRange"), v7);
      (*(void (**)(MTSimpleEmbeddedHIDManager *, const __CFString *, CFNumberRef))(*(_QWORD *)this + 568))(this, CFSTR("ExtendedMaxDigitizerPressureValue"), v8);
      CFRelease(v8);
    }
  }
}

uint64_t MTSimpleEmbeddedHIDManager::getGestureParser(MTSimpleEmbeddedHIDManager *this)
{
  return *((_QWORD *)this + 26);
}

MTInterferenceMonitor *MTSimpleEmbeddedHIDManager::createInterferenceMonitor(MTSimpleEmbeddedHIDManager *this)
{
  MTInterferenceMonitor *v1;

  v1 = (MTInterferenceMonitor *)operator new();
  MTInterferenceMonitor::MTInterferenceMonitor(v1);
  return v1;
}

void sub_2310AE024(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10B1C405A1A1483);
  _Unwind_Resume(a1);
}

__n128 MTSimpleEmbeddedHIDManager::setTipOffsetParameters(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  __n128 result;
  __int128 v4;
  __int128 v5;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 208) + 64);
  result = *(__n128 *)a2;
  v4 = *(_OWORD *)(a2 + 16);
  v5 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v2 + 228) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v2 + 212) = v5;
  *(_OWORD *)(v2 + 196) = v4;
  *(__n128 *)(v2 + 180) = result;
  return result;
}

uint64_t createVendorDefinedTouchFrameEvent(unsigned __int8 *a1)
{
  mach_absolute_time();
  return IOHIDEventCreateVendorDefinedEvent();
}

const char *MTSimpleEmbeddedHIDManager::getName(MTSimpleEmbeddedHIDManager *this)
{
  return "MTSimpleEmbeddedHIDManager";
}

uint64_t MTSimpleEmbeddedHIDManager::handleContactFrame(MTSimpleHIDManager *this, double a2, uint64_t a3, unsigned __int8 *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11;
  NSObject *v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  NSObject *v16;
  int v17;
  int v18;
  int v19;
  NSObject *v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t VendorDefinedTouchFrameEvent;
  const void *v25;
  CFTypeRef cf;
  _BYTE buf[14];
  double v28;
  _WORD v29[13];

  *(_QWORD *)&v29[9] = *MEMORY[0x24BDAC8D0];
  v11 = *((_QWORD *)this + 25);
  if (v11)
    MTSLGLogger::logPaths(v11, (uint64_t)a4, a5);
  if (!MTSimpleHIDManager::touchFramesAllowed(this))
  {
    cf = 0;
    MTDeviceGetDeviceID();
    v16 = MTLoggingPlugin();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v17 = *((_DWORD *)this + 32);
      v18 = *((_DWORD *)this + 48);
      v19 = *((unsigned __int8 *)this + 122);
      *(_DWORD *)buf = 67109888;
      *(_DWORD *)&buf[4] = v17;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v18;
      LOWORD(v28) = 1024;
      *(_DWORD *)((char *)&v28 + 2) = v19;
      HIWORD(v28) = 2048;
      *(_QWORD *)v29 = cf;
      v13 = "received a touch frame but preventing dispatch. _currentDetectionMode=%d, _currentTouchMode=%d, _proxIntegra"
            "ted=%d (deviceID 0x%llX)";
      v14 = v16;
      v15 = 30;
      goto LABEL_13;
    }
    return 0;
  }
  if (*((double *)this + 18) == a2 && *((unsigned __int8 *)this + 152) == a6)
  {
    cf = 0;
    MTDeviceGetDeviceID();
    v12 = MTLoggingPlugin();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218496;
      *(_QWORD *)&buf[4] = a6;
      *(_WORD *)&buf[12] = 2048;
      v28 = a2;
      v29[0] = 2048;
      *(_QWORD *)&v29[1] = cf;
      v13 = "ignoring duplicate frame #%qu @ %f\n (deviceID 0x%llX)";
      v14 = v12;
      v15 = 32;
LABEL_13:
      _os_log_impl(&dword_231071000, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
      return 0;
    }
    return 0;
  }
  if (*((_BYTE *)this + 121))
  {
    cf = 0;
    MTDeviceGetDeviceID();
    v20 = MTLoggingPlugin();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = cf;
      v13 = "received a touch frame but parser is disabled, preventing dispatch (deviceID 0x%llX)";
      v14 = v20;
      v15 = 12;
      goto LABEL_13;
    }
    return 0;
  }
  kdebug_trace();
  *((double *)this + 18) = a2;
  *((_BYTE *)this + 152) = a6;
  cf = 0;
  *(_QWORD *)buf = 0;
  v22 = *((_QWORD *)this + 26);
  if (v22)
  {
    MTParser::handleContactFrame(v22, (uint64_t)a4, a5, a2, a6, (uint64_t)buf, (uint64_t *)&cf, 0);
    if (*(_QWORD *)buf)
    {
      (*(void (**)(MTSimpleHIDManager *, _QWORD, _QWORD))(*(_QWORD *)this + 136))(this, *(_QWORD *)buf, 0);
      CFRelease(*(CFTypeRef *)buf);
    }
    if (cf)
    {
      v23 = (*(uint64_t (**)(MTSimpleHIDManager *))(*(_QWORD *)this + 120))(this);
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v23 + 80))(v23))
      {
        VendorDefinedTouchFrameEvent = createVendorDefinedTouchFrameEvent(a4);
        if (VendorDefinedTouchFrameEvent)
        {
          v25 = (const void *)VendorDefinedTouchFrameEvent;
          IOHIDEventAppendEvent();
          CFRelease(v25);
        }
      }
      (*(void (**)(MTSimpleHIDManager *, CFTypeRef, _QWORD))(*(_QWORD *)this + 136))(this, cf, 0);
      CFRelease(cf);
    }
  }
  kdebug_trace();
  return 1;
}

void MTSimpleEmbeddedHIDManager::handleImageEntry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 200);
  if (v4)
    MTSLGLogger::logImages(v4, a3, a4);
}

uint64_t MTSimpleEmbeddedHIDManager::handleFrameHeader(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 208);
  if (v3)
    MTParser::handleFrameHeader(v3, a3);
  return 1;
}

void MTSimpleEmbeddedHIDManager::~MTSimpleEmbeddedHIDManager(MTSimpleEmbeddedHIDManager *this)
{
  MTSimpleHIDManager::~MTSimpleHIDManager(this);
  JUMPOUT(0x2348D0034);
}

void MTRestZoneIntegrator::clear(float32x2_t *this)
{
  MTRestZoneIntegrator::clearMotion(this, 1);
}

void MTRestZoneIntegrator::clearMotion(float32x2_t *this, int a2)
{
  char v2;
  NSObject *v4;

  v2 = a2;
  if (a2)
  {
    MTRestZoneIntegrator::clearThumbFingerEnvelope(this);
    this[29].i32[1] = 0;
  }
  this[33] = 0;
  this[34] = 0;
  this[37].i32[1] = 0;
  this[27] = 0;
  *(_OWORD *)this[20].f32 = 0u;
  *(_OWORD *)this[22].f32 = 0u;
  MTFingerToPathMap::clearFingerPathMappings((MTFingerToPathMap *)this);
  v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    MTHandMotion::clearHandMotion(v2, v4);
}

MTFingerToPathMap *MTRestZoneIntegrator::MTRestZoneIntegrator(MTFingerToPathMap *a1, uint64_t a2, __int32 a3, __int32 a4)
{
  float32x2_t *v8;

  MTFingerToPathMap::MTFingerToPathMap(a1, 0);
  *v8 = (float32x2_t)&off_24FFF2F18;
  v8[31] = (float32x2_t)a2;
  v8[32].i32[0] = a3;
  v8[32].i32[1] = a4;
  MTRestZoneIntegrator::clearMotion(v8, 1);
  MTParameterFactory::initRestZoneBalanceParameters((uint64_t)a1 + 108);
  return a1;
}

void sub_2310AE544(_Unwind_Exception *a1)
{
  MTFingerToPathMap *v1;

  MTFingerToPathMap::~MTFingerToPathMap(v1);
  _Unwind_Resume(a1);
}

void MTRestZoneIntegrator::~MTRestZoneIntegrator(MTRestZoneIntegrator *this)
{
  MTFingerToPathMap::~MTFingerToPathMap(this);
  JUMPOUT(0x2348D0034);
}

uint64_t MTRestZoneIntegrator::printExtractedMotion(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t i;
  int v7;

  printf("%dM/%d fingers, %d<-->%d\n", a3, a2, *(_DWORD *)(a1 + 80), *(_DWORD *)(a1 + 88));
  for (i = 3; i != 8; ++i)
  {
    v7 = *(_DWORD *)(a1 + 4 * i);
    if (v7)
      printf("\tF%d %5.2fx %5.2fy %5.2fvx %5.2fvy\n", i - 2, *(float *)(a4 + 96 * v7 + 32), *(float *)(a4 + 96 * v7 + 36), *(float *)(a4 + 96 * v7 + 40), *(float *)(a4 + 96 * v7 + 44));
  }
  return printf("\t%4.2fdx %4.2fdy %4.2fds %4.2fdr\n", *(float *)(a1 + 264), *(float *)(a1 + 268), *(float *)(a1 + 272), *(float *)(a1 + 276));
}

uint64_t MTRestZoneIntegrator::clearThumbFingerEnvelope(float32x2_t *this)
{
  if (this[12].u8[6] <= 3u)
    this[29].f32[1] = MTRestZoneIntegrator::calcResidualBalance(this);
  this[29].i32[0] = 0;
  this[28] = 0;
  this[30].i32[0] = 0;
  this[25] = 0;
  this[26] = 0;
  this[24] = 0;
  return MTFingerToPathMap::clearMaxFingersTouching((uint64_t)this);
}

float MTRestZoneIntegrator::calcResidualBalance(float32x2_t *this)
{
  float32x2_t v1;
  float result;

  v1 = vsqrt_f32(vadd_f32(this[28], this[28]));
  result = (float)((float)(vsub_f32((float32x2_t)vdup_lane_s32((int32x2_t)v1, 1), v1).f32[0]
                         - (float)(this[15].f32[0] * sqrtf(this[27].f32[0])))
                 - (float)(this[15].f32[1] * sqrtf(this[27].f32[1])))
         - (float)(this[16].f32[0] * sqrtf(this[30].f32[0]));
  if (result <= 0.0)
  {
    if (result <= this[19].f32[1])
      return this[19].f32[1];
  }
  else if (result >= this[17].f32[0])
  {
    return this[17].f32[0];
  }
  return result;
}

void MTRestZoneIntegrator::translationSimilarityDotProduct(float a1, float a2, float a3, float a4)
{
  hypotf(a1, a2);
  hypotf(a3, a4);
}

float MTRestZoneIntegrator::scalingFromDotProduct(float a1, float a2, float a3, float a4, float a5, float a6)
{
  return (float)((float)(a2 * a6) + (float)(a5 * a1)) - (float)((float)(a2 * a4) + (float)(a3 * a1));
}

float MTRestZoneIntegrator::rotationFromVectorProduct(float a1, float a2, float a3, float a4, float a5, float a6)
{
  return (float)((float)(a5 * a2) - (float)(a6 * a1)) - (float)((float)(a3 * a2) - (float)(a4 * a1));
}

float MTRestZoneIntegrator::computeSeparationVector(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v3;

  v3 = *(float *)(a3 + 32) - *(float *)(a2 + 32);
  atan2f(-(float)(*(float *)(a3 + 36) - *(float *)(a2 + 36)), v3);
  return v3;
}

uint64_t MTRestZoneIntegrator::extractMotionDeltas(MTRestZoneIntegrator *this, const MTPathStates *a2, const MTParserPath *a3, const MTParserPath *a4, unsigned __int8 a5)
{
  _BOOL4 v10;
  uint64_t result;
  int v12;
  char v13;
  float v14;
  float v15;
  float v16;
  int v17;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  double v34;
  float v35[2];

  v10 = MTParserPath::stableAndMoved(a3);
  result = MTParserPath::stableAndMoved(a4);
  *((_DWORD *)this + 76) = 1065353216;
  *((_QWORD *)this + 33) = 0;
  *((_QWORD *)this + 34) = 0;
  v12 = *((_DWORD *)a3 + 10);
  v13 = a5 ^ 1;
  v14 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  if (v12 && ((a5 ^ 1) & 1) == 0 && *((_DWORD *)a3 + 34) && v10)
  {
    v16 = *((float *)a3 + 112) + 0.0;
    *((float *)this + 66) = v16;
    v15 = *((float *)a3 + 113) + 0.0;
    *((float *)this + 67) = v15;
  }
  v17 = *((_DWORD *)a4 + 10);
  if (v12 != v17 && v17 != 0)
  {
    v19 = *((float *)a4 + 14) - *((float *)a3 + 14);
    v20 = *((float *)a4 + 15) - *((float *)a3 + 15);
    v21 = sqrtf((float)(v20 * v20) + (float)(v19 * v19));
    v22 = 0.0;
    if (v21 > 0.0)
    {
      v23 = v19 / v21;
      v24 = v20 / v21;
      v35[0] = v19 / v21;
      v35[1] = v20 / v21;
      if (!*((_DWORD *)a4 + 34))
        v13 = 1;
      if ((v13 & 1) == 0 && *((_DWORD *)a3 + 34))
      {
        v25 = *((float *)a4 + 112);
        v26 = *((float *)a4 + 113);
        v27 = *((float *)a3 + 112);
        v28 = *((float *)a3 + 113);
        if ((v10 | result) == 1)
        {
          *((float *)this + 66) = (float)(v25 + v16) * 0.5;
          *((float *)this + 67) = (float)(v26 + v15) * 0.5;
          *((float *)this + 68) = (float)((float)((float)(v26 * v24) + (float)(v25 * v23))
                                        - (float)((float)(v28 * v24) + (float)(v27 * v23)))
                                * 0.5;
          *((float *)this + 69) = (float)((float)((float)(v25 * v24) - (float)(v26 * v23))
                                        - (float)((float)(v27 * v24) - (float)(v28 * v23)))
                                * 0.5;
        }
        MTRestZoneIntegrator::translationSimilarityDotProduct(v27, v28, v25, v26);
        v22 = v29;
        if ((*((_DWORD *)a3 + 11) - 3) <= 1
          && (*((_DWORD *)a3 + 35) - 3) <= 1
          && MTParserPath::isFingerOrRestingContact(a3))
        {
          MTRestZoneIntegrator::combineCentralFingerScaleRotate(this, (uint64_t)a2, (uint64_t)a3, v35);
        }
      }
    }
    MTContact_getEllipseEccentricity();
    v31 = v30;
    result = MTContact_getEllipseEccentricity();
    v33 = v31 / v32;
    *((float *)this + 76) = v33;
    if (v22 > 0.0)
    {
      v34 = v33;
      if (v34 < 1.2)
        v14 = ((1.2 - v34) * 2.0 + 0.5) * v22;
    }
  }
  *((float *)this + 75) = v14;
  return result;
}

MTParserPath *MTRestZoneIntegrator::combineCentralFingerScaleRotate(MTParserPath *result, uint64_t a2, uint64_t a3, float *a4)
{
  int v4;
  MTParserPath *v8;
  int v9;
  float v10;
  unsigned int v11;
  uint64_t v12;
  float v13;
  float v14;

  v4 = *((_DWORD *)result + 20) + 1;
  if (v4 < *((_DWORD *)result + 22))
  {
    v8 = result;
    v9 = 0;
    v10 = 0.0;
    do
    {
      if (v4 <= 0xF)
      {
        v11 = *((_DWORD *)v8 + v4 + 2);
        if ((int)v11 >= 1)
        {
          v12 = *(_QWORD *)(a2 + 280);
          result = (MTParserPath *)(v12 + 600 * v11);
          if ((*((_DWORD *)result + 11) - 3) <= 1
            && (*(_DWORD *)(v12 + 600 * v11 + 140) - 3) <= 1)
          {
            result = (MTParserPath *)MTParserPath::isFingerContact(result);
            if ((_DWORD)result)
            {
              v10 = v10
                  + (float)((float)((float)(*(float *)(v12 + 600 * v11 + 452) * a4[1])
                                  + (float)(*(float *)(v12 + 600 * v11 + 448) * *a4))
                          - (float)((float)(*(float *)(a3 + 452) * a4[1]) + (float)(*(float *)(a3 + 448) * *a4)));
              ++v9;
            }
          }
        }
      }
      ++v4;
    }
    while (v4 < *((_DWORD *)v8 + 22));
    if (v9 > 0)
    {
      v13 = v10 / (float)v9;
      v14 = *((float *)v8 + 68);
      if (fabsf(v13) > fabsf(v14))
        *((float *)v8 + 68) = (float)(v13 + v14) * 0.5;
    }
  }
  return result;
}

void MTRestZoneIntegrator::computeSpeedSimilarity(MTRestZoneIntegrator *this, const MTPathStates *a2)
{
  float v4;
  float v5;
  uint64_t i;
  int v7;
  MTParserPath *v8;
  float AverageVelocity_mm_s;
  float v10;
  float v11;

  v4 = 0.0;
  v5 = 3.4028e38;
  for (i = 12; i != 32; i += 4)
  {
    v7 = *(_DWORD *)((char *)this + i);
    if (v7 >= 1)
    {
      v8 = (MTParserPath *)(*((_QWORD *)a2 + 35) + 600 * v7);
      if ((*((_DWORD *)v8 + 11) - 3) <= 1 && MTParserPath::isFingerOrRestingContact(v8))
      {
        AverageVelocity_mm_s = MTParserPath::getAverageVelocity_mm_s(v8);
        v11 = hypotf(AverageVelocity_mm_s, v10);
        if (v11 < v5)
          v5 = v11;
        if (v11 > v4)
          v4 = v11;
      }
    }
  }
}

float32x2_t MTRestZoneIntegrator::decayMotionEnvelope(uint64_t a1, float32x2_t *a2, float32x2_t *a3, float *a4, float *a5, float *a6, float a7)
{
  float v12;
  uint64_t v13;
  double v14;
  float v15;
  float v16;
  float v17;
  float64x2_t v18;
  float32x2_t result;

  v12 = 1.0 - expf((float)-a7 / *(float *)(a1 + 132));
  *(double *)&v13 = (float)(v12 * 0.0);
  v14 = 1.0 - v12;
  v15 = *(double *)&v13 + v14 * *a4;
  *a4 = v15;
  v16 = *(double *)&v13 + v14 * *a6;
  *a6 = v16;
  v17 = *(double *)&v13 + v14 * *a5;
  *a5 = v17;
  v18 = (float64x2_t)vdupq_lane_s64(v13, 0);
  *(float32x4_t *)a2->f32 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_n_f64(v18, vcvtq_f64_f32(*a2), v14)), vmlaq_n_f64(v18, vcvt_hight_f64_f32(*(float32x4_t *)a2->f32), v14));
  result = vcvt_f32_f64(vmlaq_n_f64(v18, vcvtq_f64_f32(*a3), v14));
  *a3 = result;
  return result;
}

void MTRestZoneIntegrator::accumulateMotionEnvelope(uint64_t a1, float32x2_t *a2, float32x2_t *a3, float *a4, float *a5, float *a6, float a7)
{
  float v13;
  float32_t v14;
  float32_t v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;

  v13 = 0.25;
  if (!*(_BYTE *)(a1 + 244))
    v13 = 0.4;
  a2[1] = vmla_n_f32(a2[1], vmul_f32(vmul_n_f32(*(float32x2_t *)(a1 + 108), powf(*(float *)(a1 + 296), v13)), *(float32x2_t *)(a1 + 288)), a7);
  v14 = a2->f32[0] + (float)(*(float *)(a1 + 280) * a7);
  v15 = a2->f32[1] + (float)(*(float *)(a1 + 284) * a7);
  a2->f32[0] = v14;
  a2->f32[1] = v15;
  *a3 = vmla_n_f32(*a3, vmul_n_f32(vadd_f32(*(float32x2_t *)(a1 + 280), *(float32x2_t *)(a1 + 280)), a7), *(float *)(a1 + 300));
  v16 = sqrtf((float)(v15 * v15) + (float)(v14 * v14));
  if (*a4 > v16)
    v16 = *a4;
  *a4 = v16;
  v17 = *a5;
  v18 = sqrtf((float)(a3->f32[1] * a3->f32[1]) + (float)(a3->f32[0] * a3->f32[0]));
  if (*a5 <= v18)
    v17 = v18;
  *a5 = v17;
  v19 = *a6;
  v20 = fabsf(a2[1].f32[1]);
  v21 = fabsf(a2[1].f32[0]);
  if (v20 <= v21)
  {
    if (v19 <= v21)
      v19 = v21;
  }
  else if (v19 <= v20)
  {
    v19 = v20;
  }
  *a6 = v19;
}

float MTRestZoneIntegrator::polarTranslationBalance(MTRestZoneIntegrator *this)
{
  float32x2_t v1;

  v1 = vsqrt_f32(vadd_f32(*(float32x2_t *)((char *)this + 228), *(float32x2_t *)((char *)this + 228)));
  if (v1.f32[0] <= v1.f32[1])
    v1.f32[0] = v1.f32[1];
  return v1.f32[0] - sqrtf(*((float *)this + 56) + *((float *)this + 56));
}

float MTRestZoneIntegrator::adaptivePolarBalance(MTRestZoneIntegrator *this)
{
  float v1;
  float32x2_t v2;
  float v3;
  float32x2_t v5;

  v1 = -(float)(*((float *)this + 32) * sqrtf(*((float *)this + 60)));
  if (*((_BYTE *)this + 244) || *((unsigned __int8 *)this + 101) >= 4u)
  {
    v2 = vsqrt_f32(vadd_f32(*(float32x2_t *)((char *)this + 228), *(float32x2_t *)((char *)this + 228)));
    if (v2.f32[0] <= v2.f32[1])
      v2.f32[0] = v2.f32[1];
    v3 = v2.f32[0] - sqrtf(*((float *)this + 56) + *((float *)this + 56));
    if (v3 <= 0.0)
      v3 = -0.0;
    return (float)(v1 + v3) + (float)(*((float *)this + 35) * 2.0);
  }
  else
  {
    v5 = vsqrt_f32(vadd_f32(*(float32x2_t *)((char *)this + 228), *(float32x2_t *)((char *)this + 228)));
    if (v5.f32[0] <= v5.f32[1])
      v5.f32[0] = v5.f32[1];
    return (float)((float)((float)(v1 + (float)(v5.f32[0] - sqrtf(*((float *)this + 56) + *((float *)this + 56))))
                         + (float)(*((float *)this + 29) * *((float *)this + 59)))
                 - (float)(*((float *)this + 30) * sqrtf(*((float *)this + 54))))
         - (float)(*((float *)this + 31) * sqrtf(*((float *)this + 55)));
  }
}

BOOL MTRestZoneIntegrator::isLockedOnTranslate(MTRestZoneIntegrator *this)
{
  float32x2_t v2;
  float v3;

  v2 = vsqrt_f32(vadd_f32(*(float32x2_t *)((char *)this + 228), *(float32x2_t *)((char *)this + 228)));
  if (v2.f32[0] <= v2.f32[1])
    v2.f32[0] = v2.f32[1];
  v3 = *((float *)this + 39);
  return (float)(v2.f32[0] - sqrtf(*((float *)this + 56) + *((float *)this + 56))) < v3
      && MTRestZoneIntegrator::adaptivePolarBalance(this) < v3
      || MTRestZoneIntegrator::adaptivePolarBalance(this) < (float)(v3 + v3);
}

BOOL MTRestZoneIntegrator::isLockedOnPolarSymmetric(MTRestZoneIntegrator *this)
{
  float32x2_t v2;
  float v3;

  v2 = vsqrt_f32(vadd_f32(*(float32x2_t *)((char *)this + 228), *(float32x2_t *)((char *)this + 228)));
  if (v2.f32[0] <= v2.f32[1])
    v2.f32[0] = v2.f32[1];
  v3 = *((float *)this + 34);
  return (float)(v2.f32[0] - sqrtf(*((float *)this + 56) + *((float *)this + 56))) > v3
      && MTRestZoneIntegrator::adaptivePolarBalance(this) > v3
      || MTRestZoneIntegrator::adaptivePolarBalance(this) > (float)(v3 + v3);
}

BOOL MTRestZoneIntegrator::shouldDoBiPolarIntegration(MTRestZoneIntegrator *this, char a2)
{
  float v2;

  v2 = 0.0;
  if ((a2 & 1) == 0)
    v2 = *((float *)this + 35);
  return MTRestZoneIntegrator::adaptivePolarBalance(this) > v2;
}

float MTRestZoneIntegrator::translationDominance(MTRestZoneIntegrator *this, char a2)
{
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;

  v3 = 0.0;
  v4 = 0.0;
  if ((a2 & 1) == 0)
    v4 = *((float *)this + 35);
  v5 = MTRestZoneIntegrator::adaptivePolarBalance(this);
  if (v5 <= v4)
  {
    v6 = *((float *)this + 38);
    v3 = 1.0;
    if (v5 >= v6)
    {
      v3 = *((float *)this + 36);
      v7 = *((float *)this + 37);
      if (v5 <= v7)
        return (1.0 - v3) * (float)(v7 - v5) / (float)(v7 - v6) + v3;
    }
  }
  return v3;
}

void MTRestZoneIntegrator::weighDominantMotions(float32x2_t *this, double a2, double a3)
{
  __int32 v5;
  float v6;
  float32x2_t *v7;
  float *v8;
  float v9;
  int v10;
  float32x2_t v11;
  int v12;

  MTRestZoneIntegrator::convertPixelDeltasTo_mm_s((MTRestZoneIntegrator *)this, a2, a3);
  if (!MTRestZoneIntegrator::isLockedOnPolarSymmetric((MTRestZoneIntegrator *)this)
    && !MTRestZoneIntegrator::isLockedOnTranslate((MTRestZoneIntegrator *)this))
  {
    v12 = -1;
    v11 = (float32x2_t)-1;
    v10 = -1;
    v5 = this[10].i32[0];
    if (v5 == this[11].i32[0])
    {
      if (v5 == 1)
      {
        v7 = this + 22;
        v8 = (float *)&this[27] + 1;
      }
      else
      {
        v7 = this + 20;
        v8 = (float *)&this[27];
      }
      v6 = a2;
      MTRestZoneIntegrator::accumulateMotionEnvelope((uint64_t)this, v7, &v11, v8, (float *)&v10, (float *)&v12, v6);
    }
    else
    {
      v9 = a2;
      MTRestZoneIntegrator::decayMotionEnvelope((uint64_t)this, this + 24, this + 26, (float *)&this[28], (float *)&this[29], (float *)&this[28] + 1, v9);
      MTRestZoneIntegrator::accumulateMotionEnvelope((uint64_t)this, this + 24, this + 26, (float *)&this[28], (float *)&this[29], (float *)&this[28] + 1, v9);
      MTRestZoneIntegrator::decayMotionEnvelope((uint64_t)this, this + 20, &v11, (float *)&this[27], (float *)&v10, (float *)&v12, v9);
      MTRestZoneIntegrator::decayMotionEnvelope((uint64_t)this, this + 22, &v11, (float *)&this[27] + 1, (float *)&v10, (float *)&v12, v9);
    }
  }
}

void MTRestZoneIntegrator::convertPixelDeltasTo_mm_s(MTRestZoneIntegrator *this, double a2, double a3)
{
  double v3;
  int v5;
  int v6;

  v3 = a2;
  LODWORD(a2) = *((_DWORD *)this + 66);
  LODWORD(a3) = *((_DWORD *)this + 67);
  MTSurfaceDimensions::convertPixelDeltasToMillimetersPerSecond(a2, a3, v3);
  *((_DWORD *)this + 70) = v5;
  *((_DWORD *)this + 71) = v6;
  *((float *)this + 72) = MTSurfaceDimensions::convertPixelDeltaToMillimetersPerSecond(*((MTSurfaceDimensions **)this + 31), *((float *)this + 68), v3);
  *((float *)this + 73) = MTSurfaceDimensions::convertPixelDeltaToMillimetersPerSecond(*((MTSurfaceDimensions **)this + 31), *((float *)this + 69), v3);
}

void MTRestZoneIntegrator::integrateRestingZoneMotion(float32x2_t *this, const MTPathStates *a2, int a3)
{
  __int32 v6;
  uint64_t InnermostTouchingPath;
  const MTParserPath *OutermostTouchingPath;
  MTRestZoneIntegrator *v9;
  const MTPathStates *v10;
  const MTParserPath *v11;
  unsigned __int8 v12;
  uint64_t InnermostInRangePath;

  if (a3 <= 1 && this[12].u8[5] >= 2u)
    MTRestZoneIntegrator::clearThumbFingerEnvelope(this);
  MTFingerToPathMap::updateFingerPathMappings((uint64_t)this, a2);
  if (this[11].i32[1])
  {
    MTRestZoneIntegrator::computeSpeedSimilarity((MTRestZoneIntegrator *)this, a2);
    this[37].i32[0] = v6;
    if (a3)
    {
      InnermostTouchingPath = MTFingerToPathMap::getInnermostTouchingPath((MTFingerToPathMap *)this, a2);
      OutermostTouchingPath = (const MTParserPath *)MTFingerToPathMap::getOutermostTouchingPath((MTFingerToPathMap *)this, a2);
      v9 = (MTRestZoneIntegrator *)this;
      v10 = a2;
      v11 = (const MTParserPath *)InnermostTouchingPath;
      v12 = 1;
    }
    else
    {
      InnermostInRangePath = MTFingerToPathMap::getInnermostInRangePath((MTFingerToPathMap *)this, a2);
      OutermostTouchingPath = (const MTParserPath *)MTFingerToPathMap::getOutermostInRangePath((MTFingerToPathMap *)this, a2);
      v9 = (MTRestZoneIntegrator *)this;
      v10 = a2;
      v11 = (const MTParserPath *)InnermostInRangePath;
      v12 = 0;
    }
    MTRestZoneIntegrator::extractMotionDeltas(v9, v10, v11, OutermostTouchingPath, v12);
    MTRestZoneIntegrator::weighDominantMotions(this, *((double *)a2 + 1) - *((double *)a2 + 2), *((double *)a2 + 2));
  }
  else
  {
    MTRestZoneIntegrator::clearMotion(this, 0);
  }
}

void MTForceFilter::MTForceFilter(MTForceFilter *this)
{
  *(_QWORD *)this = &off_24FFF2F50;
  *((_QWORD *)this + 1) = 0x3F75C28F00000000;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_QWORD *)this + 6) = 0;
}

{
  *(_QWORD *)this = &off_24FFF2F50;
  *((_QWORD *)this + 1) = 0x3F75C28F00000000;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_QWORD *)this + 6) = 0;
}

double MTForceFilter::clear(MTForceFilter *this)
{
  double result;

  *((_QWORD *)this + 1) = 0x3F75C28F00000000;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_QWORD *)this + 6) = 0;
  return result;
}

void MTForceFilter::~MTForceFilter(MTForceFilter *this)
{
  JUMPOUT(0x2348D0034);
}

uint64_t MTForceFilter::resetSliderFilter(uint64_t this)
{
  *(_QWORD *)(this + 48) = 0;
  return this;
}

uint64_t MTForceFilter::updateSliderFilter(uint64_t this, float a2, float a3)
{
  float v3;
  float v4;
  float v5;
  float v6;

  v3 = 0.5;
  if (a2 >= 1.0)
    v3 = 0.0;
  v4 = (float)((float)(1.0 - v3) * a2) + (float)(v3 * *(float *)(this + 48));
  if (v4 >= 0.0)
    v5 = v4;
  else
    v5 = 0.0;
  if (v4 <= 1.0)
    v6 = v5;
  else
    v6 = 1.0;
  *(float *)(this + 48) = v6;
  *(float *)(this + 52) = a3;
  return this;
}

float MTForceFilter::forceVelocityFilterAlpha(MTForceFilter *this, float a2)
{
  float v2;
  float v3;

  v2 = fabsf(a2);
  v3 = fabsf(*((float *)this + 6));
  if (v2 <= v3)
    v2 = v3;
  return (float)(1.0 - (float)(v2 / (float)(v2 + 1500.0))) * 0.9;
}

float MTForceFilter::sigmoidOneSided(MTForceFilter *this, float a2, float a3, float a4)
{
  float v6;

  v6 = powf(fabsf(a2), a4);
  return v6 / (float)(powf(fabsf(a3), a4) + v6);
}

float MTForceFilter::surgeToActuationStrength(uint64_t a1, float *a2)
{
  float v2;
  float v3;

  v2 = *a2;
  v3 = powf(fabsf(*(float *)(a1 + 24)), 1.2);
  return (float)(v3 / (float)(v3 + powf(fabsf(v2), 1.2))) + 0.1;
}

float MTForceFilter::surge_g_s(MTForceFilter *this)
{
  return *((float *)this + 6);
}

void MTForceFilter::updateForceFilter(uint64_t a1, float *a2, float a3, float a4, double a5)
{
  double v6;
  float v7;
  int v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;

  if (a5 <= 0.04)
    v6 = a5;
  else
    v6 = 0.04;
  v7 = *(float *)(a1 + 16);
  *(float *)(a1 + 16) = a3;
  *(float *)(a1 + 20) = v7;
  v8 = *(_DWORD *)(a1 + 28);
  v9 = (float)(a3 - v7) / v6;
  *(float *)(a1 + 28) = v9;
  *(_DWORD *)(a1 + 32) = v8;
  if (a3 == 0.0 || a5 > 0.04)
  {
    v11 = *(float *)(a1 + 24);
    v13 = 0.0;
  }
  else
  {
    v10 = fabsf(v9);
    v11 = *(float *)(a1 + 24);
    v12 = fabsf(v11);
    if (v10 <= v12)
      v10 = v12;
    v13 = (float)(1.0 - (float)(v10 / (float)(v10 + 1500.0))) * 0.9;
  }
  *(float *)(a1 + 24) = (float)((float)(1.0 - v13) * v9) + (float)(v13 * v11);
  v14 = *(float *)(a1 + 36);
  if (v14 >= a4)
    v15 = (float)(a4 * 0.15) + (float)(v14 * 0.85);
  else
    v15 = (float)(a4 * 0.75) + (float)(v14 * 0.25);
  *(float *)(a1 + 36) = v15;
  MTForceFilter::updateHystereticForce(a1, a2, a3);
  v16 = *(float *)(a1 + 40);
  v17 = *(float *)(a1 + 8);
  v18 = v16;
  if (v16 > v17)
    v18 = (float)(v16 * (float)(1.0 - *(float *)(a1 + 12))) + (float)(*(float *)(a1 + 12) * v17);
  *(float *)(a1 + 8) = v18;
}

float MTForceFilter::updateHystereticForce(uint64_t a1, float *a2, float a3)
{
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float result;

  v3 = a2[1];
  v4 = *a2 * a3;
  if (v4 < v3)
    v4 = a2[1];
  v5 = a2[2];
  if (v4 <= v5)
    v5 = v4;
  v6 = *(float *)(a1 + 40);
  if ((float)(v6 + v5) >= a3)
  {
    if (v3 >= a3)
    {
      v7 = a3 + a3;
    }
    else
    {
      v7 = *(float *)(a1 + 40);
      if ((float)(v6 - v5) > a3)
        v7 = v5 + a3;
    }
  }
  else
  {
    v7 = a3 - v5;
  }
  result = (float)(v7 * (float)(1.0 - a2[3])) + (float)(a2[3] * v6);
  *(float *)(a1 + 40) = result;
  *(float *)(a1 + 44) = v6;
  return result;
}

float MTForceFilter::geometricSigmoid(MTForceFilter *this, float a2)
{
  float v2;

  v2 = expf(-a2);
  return exp2((float)((float)(1.0 / (float)(v2 + 1.0)) + (float)(1.0 / (float)(v2 + 1.0)))) * 0.5;
}

float MTForceFilter::sigmoid(MTForceFilter *this, float a2)
{
  return 1.0 / (float)(expf(-a2) + 1.0);
}

float MTForceFilter::sigmoidSquare(MTForceFilter *this, float a2, float a3)
{
  return (float)(a2 * a2) / (float)((float)(a3 * a3) + (float)(a2 * a2));
}

void MTForceThresholding::MTForceThresholding(MTForceThresholding *this)
{
  *(_QWORD *)this = &off_24FFF2F80;
  MTForceBehavior::MTForceBehavior((MTForceThresholding *)((char *)this + 176));
  *((_DWORD *)this + 80) = 0;
  *((_QWORD *)this + 55) = 0;
  *((_QWORD *)this + 56) = 0;
  *((_QWORD *)this + 54) = 0;
  MTForceThresholding::clear(this);
  MTParameterFactory::initForceThresholdQualifiers((uint64_t)this + 8);
  MTParameterFactory::initForceActuationQualifiers((uint64_t)this + 144);
  *((_QWORD *)this + 42) = 0x100000001;
  __asm { FMOV            V0.2S, #1.0 }
  *((_QWORD *)this + 46) = _D0;
}

void sub_2310AF804(_Unwind_Exception *a1)
{
  uint64_t v1;
  MTForceBehavior *v2;
  void **v3;
  void **v4;
  void *v6;

  v4 = v3;
  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 440) = v6;
    operator delete(v6);
  }
  MTForceBehavior::~MTForceBehavior(v2);
  _Unwind_Resume(a1);
}

void MTForceThresholding::clear(MTForceThresholding *this)
{
  unint64_t v1;

  *((_DWORD *)this + 81) = 0;
  *((_QWORD *)this + 41) = 0;
  *((_DWORD *)this + 114) = 0;
  *((_QWORD *)this + 58) = 0;
  *((_QWORD *)this + 44) = 0;
  *((_QWORD *)this + 45) = 0;
  *((_QWORD *)this + 43) = 0;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *((_QWORD *)this + 55) = *((_QWORD *)this + 54);
  v1 = *((unsigned int *)this + 48);
  if ((_DWORD)v1)
    std::vector<float>::resize((uint64_t)this + 432, v1);
}

void MTForceThresholding::~MTForceThresholding(MTForceThresholding *this)
{
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;

  *(_QWORD *)this = &off_24FFF2F80;
  __asm { FMOV            V0.2S, #1.0 }
  *((_QWORD *)this + 46) = _D0;
  v7 = (void *)*((_QWORD *)this + 54);
  if (v7)
  {
    *((_QWORD *)this + 55) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 37);
  if (v8)
  {
    *((_QWORD *)this + 38) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 34);
  if (v9)
  {
    *((_QWORD *)this + 35) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 31);
  if (v10)
  {
    *((_QWORD *)this + 32) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 28);
  if (v11)
  {
    *((_QWORD *)this + 29) = v11;
    operator delete(v11);
  }
  v12 = (void *)*((_QWORD *)this + 25);
  if (v12)
  {
    *((_QWORD *)this + 26) = v12;
    operator delete(v12);
  }
}

{
  MTForceThresholding::~MTForceThresholding(this);
  JUMPOUT(0x2348D0034);
}

uint64_t MTForceThresholding::MTForceThresholding(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;

  *(_QWORD *)a1 = &off_24FFF2F80;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)a2;
  v4 = *(_OWORD *)(a2 + 16);
  v5 = *(_OWORD *)(a2 + 32);
  v6 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 56) = v6;
  *(_OWORD *)(a1 + 40) = v5;
  *(_OWORD *)(a1 + 24) = v4;
  v7 = *(_OWORD *)(a2 + 80);
  v8 = *(_OWORD *)(a2 + 96);
  v9 = *(_OWORD *)(a2 + 112);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 120) = v9;
  *(_OWORD *)(a1 + 104) = v8;
  *(_OWORD *)(a1 + 88) = v7;
  v10 = a3[1];
  *(_OWORD *)(a1 + 144) = *a3;
  *(_OWORD *)(a1 + 160) = v10;
  MTForceBehavior::MTForceBehavior((MTForceBehavior *)(a1 + 176));
  *(_DWORD *)(a1 + 320) = 0;
  *(_QWORD *)(a1 + 440) = 0;
  *(_QWORD *)(a1 + 448) = 0;
  *(_QWORD *)(a1 + 432) = 0;
  MTForceThresholding::clear((MTForceThresholding *)a1);
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(a1 + 368) = _D0;
  return a1;
}

void sub_2310AF9D4(_Unwind_Exception *a1)
{
  uint64_t v1;
  MTForceBehavior *v2;
  void **v3;
  void **v4;
  void *v6;

  v4 = v3;
  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 440) = v6;
    operator delete(v6);
  }
  MTForceBehavior::~MTForceBehavior(v2);
  _Unwind_Resume(a1);
}

uint64_t MTForceThresholding::clearPeakAndStage(uint64_t this)
{
  *(_DWORD *)(this + 332) = 0;
  *(_QWORD *)(this + 376) = 0;
  *(_QWORD *)(this + 384) = 0;
  *(_QWORD *)(this + 408) = 0;
  *(_QWORD *)(this + 416) = 0;
  return this;
}

void std::vector<float>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 4 * a2;
  }
  else
  {
    std::vector<float>::__append((char **)a1, a2 - v2);
  }
}

void MTForceThresholding::setForceBehavior(MTForceThresholding *this, const MTForceBehavior *a2, int a3)
{
  MTForceBehavior::operator=((uint64_t)this + 176, (uint64_t)a2);
  *((_DWORD *)this + 80) = a3;
  MTForceThresholding::clear(this);
}

float MTForceThresholding::updateForceBehavior(MTForceThresholding *this, const MTForceBehavior *a2, int a3)
{
  unint64_t v5;
  float result;

  MTForceBehavior::operator=((uint64_t)this + 176, (uint64_t)a2);
  v5 = *((unsigned int *)this + 48);
  if (v5 > (uint64_t)(*((_QWORD *)this + 55) - *((_QWORD *)this + 54)) >> 2)
  {
    std::vector<float>::resize((uint64_t)this + 432, v5);
    LODWORD(v5) = *((_DWORD *)this + 48);
  }
  if (*((_DWORD *)this + 81) >= v5)
  {
    *((_DWORD *)this + 81) = v5 - 1;
    *((_DWORD *)this + 82) = v5 - 1;
  }
  *((_DWORD *)this + 80) = a3;
  result = *((float *)this + 95);
  *((float *)this + 96) = result;
  return result;
}

uint64_t MTForceThresholding::actuationWaveformID(MTForceThresholding *this)
{
  unsigned int v1;
  int v2;
  char *v3;

  v1 = *((_DWORD *)this + 81);
  v2 = v1 - *((_DWORD *)this + 82);
  if (v2 >= 1)
  {
    v3 = (char *)this + 272;
    return *(unsigned int *)(*(_QWORD *)v3 + 4 * v1);
  }
  if (v2 < 0)
  {
    v3 = (char *)this + 296;
    v1 = *((_DWORD *)this + 82);
    return *(unsigned int *)(*(_QWORD *)v3 + 4 * v1);
  }
  return 0;
}

uint64_t MTForceThresholding::activationLevelAbove(int a1)
{
  int v1;

  if ((a1 & 0x80000001) == 1)
    v1 = 2;
  else
    v1 = 1;
  return (v1 + a1);
}

uint64_t MTForceThresholding::activationLevelForHold(uint64_t result)
{
  if ((result & 0x80000001) == 1)
    return result;
  else
    return (result + 1);
}

uint64_t MTForceThresholding::activationLevelBelowHold(int a1)
{
  return a1 - ((a1 & 0x80000001) != 1);
}

uint64_t MTForceThresholding::activationLevelToStage(int a1)
{
  int v1;

  v1 = a1 + 2;
  if (a1 >= -1)
    v1 = a1 + 1;
  return (v1 >> 1);
}

uint64_t MTForceThresholding::stageToActivationLevel(int a1)
{
  return (2 * a1 - 1);
}

__n128 MTForceThresholding::setForceThresholdQualifiers(uint64_t a1, uint64_t a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __n128 result;
  __int128 v6;
  __int128 v7;

  *(_OWORD *)(a1 + 8) = *(_OWORD *)a2;
  v2 = *(_OWORD *)(a2 + 16);
  v3 = *(_OWORD *)(a2 + 32);
  v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 56) = v4;
  *(_OWORD *)(a1 + 40) = v3;
  *(_OWORD *)(a1 + 24) = v2;
  result = *(__n128 *)(a2 + 80);
  v6 = *(_OWORD *)(a2 + 96);
  v7 = *(_OWORD *)(a2 + 112);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 120) = v7;
  *(_OWORD *)(a1 + 104) = v6;
  *(__n128 *)(a1 + 88) = result;
  return result;
}

__n128 MTForceThresholding::setForceActuationQualifiers(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 144) = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 160) = v3;
  return result;
}

float MTForceThresholding::getClickThresholdMultiplier(uint64_t a1, unsigned int a2)
{
  float result;

  result = 1.0;
  if (a2 <= 2)
    return flt_2310BE148[a2];
  return result;
}

float MTForceThresholding::basicThresholdForLevel(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  float result;
  uint64_t v5;
  float v6;

  if ((a2 & 0x80000000) != 0)
  {
    result = 0.0;
LABEL_7:
    v5 = *(int *)(a1 + 336);
    goto LABEL_8;
  }
  v3 = *(_QWORD *)(a1 + 200);
  v2 = *(_QWORD *)(a1 + 208);
  if ((int)((unint64_t)(v2 - v3) >> 2) <= (int)a2)
    result = *(float *)(v2 - 4) + *(float *)(v2 - 4);
  else
    result = *(float *)(v3 + 4 * a2);
  if (a2 <= 1)
    goto LABEL_7;
  if (a2 > 3)
    return result;
  v5 = *(int *)(a1 + 340);
LABEL_8:
  v6 = 1.0;
  if (v5 <= 2)
    v6 = flt_2310BE148[v5];
  return result * v6;
}

float MTForceThresholding::adaptiveThresholdForLevel(uint64_t a1, unsigned int a2, float *a3, uint64_t a4)
{
  float v8;
  float v9;
  unsigned int v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  float v18;
  unsigned int v19;
  float v20;
  float v21;
  int v22;
  uint64_t v23;
  int v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  BOOL v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;

  if ((a2 & 0x80000000) != 0)
    return 0.0;
  v8 = *(float *)(a1 + 140);
  v9 = MTForceThresholding::basicThresholdForLevel(a1, a2);
  if (!*(_BYTE *)(a1 + 424))
  {
    v10 = a2 + 2;
    v11 = MTForceThresholding::basicThresholdForLevel(a1, a2 + 2);
    v12 = MTForceThresholding::basicThresholdForLevel(a1, a2 - 2);
    v13 = *(float *)(a1 + 136);
    v14 = *(int *)(a1 + 340);
    v15 = 1.0;
    if (v14 <= 2)
      v15 = flt_2310BE148[v14];
    v16 = (float)(v13 * v15) + *(float *)(a1 + 364);
    v17 = v11 - v9;
    v18 = v9 - v12;
    v19 = a2 & 0x80000001;
    if (a2 < 2 || v19 == 1)
    {
      if (v19 == 1)
      {
        v22 = *(_DWORD *)(a1 + 324);
        if (v22 >= (int)((a2 + 1) >> 1))
        {
          v25 = v9;
        }
        else
        {
          v23 = (*(_QWORD *)(a1 + 208) - *(_QWORD *)(a1 + 200)) >> 2;
          if ((int)v23 >= -1)
            v24 = v23 + 1;
          else
            v24 = v23 + 2;
          v25 = v16;
          if (v22 < v24 >> 1)
          {
            v25 = v9;
            if (a2 >= 3)
            {
              v25 = a3[2] + *(float *)(a1 + 456);
              if (v9 > v25)
                v25 = v9;
            }
          }
        }
        v31 = *(float *)(a1 + 392);
        v32 = *(float *)(a1 + 116);
        v33 = 1.0;
        if (v31 > v32)
        {
          v34 = *(float *)(a1 + 120);
          v33 = 0.0;
          if (v31 < v34)
            v33 = (float)(v34 - v31) / (float)(v34 - v32);
        }
        v30 = (float)((float)((float)(v17 * *(float *)(a1 + 8)) + v25) * (float)(1.0 - v33)) + (float)(v33 * v25);
        goto LABEL_32;
      }
    }
    else if ((signed int)(v10 >> 1) <= *(_DWORD *)(a1 + 324))
    {
      v20 = *(float *)(*(_QWORD *)(a1 + 432) + 4 * (v10 >> 1));
      v21 = 1.0;
      if (v20 > 300.0)
      {
        v21 = 0.0;
        if (v20 < v13)
          v21 = (float)(v13 - v20) / (float)(v13 + -300.0);
      }
      v9 = v20 * (float)((float)((float)(1.0 - v21) * 0.625) + (float)(v21 * 0.85));
    }
    v26 = *(float *)(a1 + 396);
    v27 = *(float *)(a1 + 124);
    v28 = 1.0;
    if (v26 > v27)
    {
      v29 = *(float *)(a1 + 128);
      v28 = 0.0;
      if (v26 < v29)
        v28 = (float)(v29 - v26) / (float)(v29 - v27);
    }
    v30 = (float)((float)(v9 - (float)(v18 * *(float *)(a1 + 12))) * (float)(1.0 - v28)) + (float)(v28 * v9);
LABEL_32:
    if ((*(_BYTE *)(a1 + 180) & 0x80) == 0)
    {
      v35 = v17 * *(float *)(a1 + 20);
      v36 = v18 * *(float *)(a1 + 24);
      v37 = *(float *)(a4 + 72);
      v38 = *(float *)(a1 + 108);
      v39 = *(float *)(a1 + 112);
      v40 = v37 < v39;
      v41 = (float)(v39 - v37) / (float)(v39 - v38);
      if (!v40)
        v41 = 0.0;
      if (v37 > v38)
        v42 = v41;
      else
        v42 = 1.0;
      v30 = (float)((float)(v35 + v30) * (float)(1.0 - v42)) + (float)(v42 * (float)(v30 - v36));
    }
    if (v30 >= v16)
      v9 = v16;
    else
      v9 = v30;
    if (v19 == 1 && *(_DWORD *)(a1 + 324) < (signed int)((a2 + 1) >> 1))
    {
      v43 = a3[10];
      v44 = a3[11];
      v45 = v43 * *(float *)(a1 + 132);
      if (v45 >= (float)(*(float *)(a1 + 356) - v44))
        v45 = *(float *)(a1 + 356) - v44;
      v46 = v43 - v44;
      if (v46 < 0.0)
        v46 = 0.0;
      v47 = (float)(v43 + v45) - v46;
      if (v9 <= v47)
        v9 = v47;
    }
    if (*(float *)(a1 + 400) > *(float *)(a1 + 128)
      && v19 == 1
      && *(_DWORD *)(a1 + 176) != 16
      && *(_DWORD *)(a1 + 324) < (signed int)((a2 + 1) >> 1)
      && a2 > 2)
    {
      return v8 + v8;
    }
  }
  return v9;
}

float MTForceThresholding::thresholdForNextRelease(MTForceThresholding *this, const MTForceFilter *a2, const MTParserPath *a3)
{
  int v6;
  char *v7;
  int v8;
  BOOL v9;

  v6 = 2 * *((_DWORD *)this + 81);
  v7 = (char *)this + 176;
  do
  {
    v8 = v6;
    if (v6 < 3)
      break;
    v9 = MTForceBehavior::skipReleaseStage((uint64_t)v7, (v6 - 1) >> 1);
    v6 = v8 - 2;
  }
  while (v9);
  return MTForceThresholding::adaptiveThresholdForLevel((uint64_t)this, v8 - 2, (float *)a2, (uint64_t)a3);
}

BOOL MTForceBehavior::skipReleaseStage(uint64_t a1, int a2)
{
  _DWORD *v3;
  _DWORD *v4;
  _DWORD *v6;
  _DWORD *v7;
  uint64_t v8;

  v6 = 0;
  v7 = 0;
  v8 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&v6, *(const void **)(a1 + 72), *(_QWORD *)(a1 + 80), (uint64_t)(*(_QWORD *)(a1 + 80) - *(_QWORD *)(a1 + 72)) >> 2);
  v3 = v7;
  v4 = v6;
  if (v6 != v7)
  {
    v4 = v6;
    while (*v4 != a2)
    {
      if (++v4 == v7)
      {
        v4 = v7;
        break;
      }
    }
  }
  if (v6)
  {
    v7 = v6;
    operator delete(v6);
  }
  return v4 != v3;
}

float MTForceThresholding::thresholdForNextActivation(MTForceThresholding *this, const MTForceFilter *a2, const MTParserPath *a3)
{
  char *v6;
  int v7;
  int v8;
  BOOL v9;

  v6 = (char *)this + 176;
  v7 = 2 * *((_DWORD *)this + 81) + 2;
  do
  {
    v8 = v7;
    if (v7 >= (int)((*((_QWORD *)this + 26) - *((_QWORD *)this + 25)) >> 2))
      break;
    v9 = MTForceBehavior::skipActivationStage((uint64_t)v6, v7 / 2);
    v7 = v8 + 2;
  }
  while (v9);
  return MTForceThresholding::adaptiveThresholdForLevel((uint64_t)this, v8 - 1, (float *)a2, (uint64_t)a3);
}

BOOL MTForceBehavior::skipActivationStage(uint64_t a1, int a2)
{
  _DWORD *v3;
  _DWORD *v4;
  _DWORD *v6;
  _DWORD *v7;
  uint64_t v8;

  v6 = 0;
  v7 = 0;
  v8 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&v6, *(const void **)(a1 + 48), *(_QWORD *)(a1 + 56), (uint64_t)(*(_QWORD *)(a1 + 56) - *(_QWORD *)(a1 + 48)) >> 2);
  v3 = v7;
  v4 = v6;
  if (v6 != v7)
  {
    v4 = v6;
    while (*v4 != a2)
    {
      if (++v4 == v7)
      {
        v4 = v7;
        break;
      }
    }
  }
  if (v6)
  {
    v7 = v6;
    operator delete(v6);
  }
  return v4 != v3;
}

float MTForceThresholding::preReleaseProgress(MTForceThresholding *this, const MTForceFilter *a2, const MTParserPath *a3)
{
  float v3;
  float v4;
  float result;
  float v6;

  v3 = *((float *)this + 88);
  v4 = v3 * (float)(*((float *)this + 14) + 1.0);
  result = 0.0;
  if (v3 < v4 && *((int *)this + 81) >= 1)
  {
    v6 = *((float *)a2 + 10);
    result = 1.0;
    if (v6 > v3)
    {
      result = 0.0;
      if (v6 < v4)
        return (float)(v4 - v6) / (float)(v4 - v3);
    }
  }
  return result;
}

float MTForceThresholding::preActivationProgress(MTForceThresholding *this, const MTForceFilter *a2, const MTParserPath *a3)
{
  float v3;
  float v4;
  float result;
  uint64_t v6;
  int v7;
  float v8;

  v3 = *((float *)this + 89);
  v4 = v3 * (float)(1.0 - *((float *)this + 15));
  result = 0.0;
  if (v4 < v3)
  {
    v6 = (*((_QWORD *)this + 26) - *((_QWORD *)this + 25)) >> 2;
    if ((int)v6 >= -1)
      v7 = v6 + 1;
    else
      v7 = v6 + 2;
    if (*((_DWORD *)this + 81) < v7 >> 1 && v3 < *((float *)this + 35))
    {
      v8 = *((float *)a2 + 10);
      if (v8 > v4)
      {
        result = 1.0;
        if (v8 < v3)
          return (float)(v8 - v4) / (float)(v3 - v4);
      }
    }
  }
  return result;
}

float MTForceThresholding::postActivationProgress(MTForceThresholding *this, const MTForceFilter *a2, const MTParserPath *a3)
{
  float v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  float v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  double v16;
  float v17;

  v3 = *((float *)this + 16);
  v4 = *((unsigned int *)this + 81);
  if (*((_BYTE *)this + 188))
  {
    v5 = (*((_QWORD *)this + 26) - *((_QWORD *)this + 25)) >> 2;
    v6 = (int)v5 >= -1 ? v5 + 1 : (int)v5 + 2;
    if ((int)v4 >= v6 >> 1)
      v3 = *((float *)this + 17);
  }
  v7 = *(float *)(*((_QWORD *)this + 54) + 4 * v4);
  v8 = *((_DWORD *)this + 44);
  if (v8 == 12)
  {
    v9 = *((int *)this + 84);
    v10 = 1.0;
    if (v9 <= 2)
      v10 = flt_2310BE148[v9];
    v11 = *((float *)this + 34) * v10;
  }
  else
  {
    v12 = 1.0;
    if (v8 == 11)
    {
      v13 = *((int *)this + 84);
      if (v13 <= 2)
        v12 = flt_2310BE148[v13];
      v11 = (float)(*((float *)this + 34) * v12) * 0.5;
      v7 = 0.0;
    }
    else
    {
      v11 = (float)(v3 + 1.0) * v7;
    }
  }
  v14 = (*((_QWORD *)this + 26) - *((_QWORD *)this + 25)) >> 2;
  if ((int)v14 >= -1)
    v15 = v14 + 1;
  else
    v15 = v14 + 2;
  if ((int)v4 < v15 >> 1 && v11 >= *((float *)this + 89))
    v11 = *((float *)this + 89);
  v16 = 0.0;
  if ((int)v4 >= 1 && v7 < v11)
  {
    v17 = *((float *)a2 + 10);
    if (v17 > v7)
    {
      if (v17 >= v11)
        v16 = 3.14159265;
      else
        v16 = (float)((float)(v17 - v7) / (float)(v11 - v7)) * 3.14159265;
    }
  }
  return (1.0 - cos(v16)) * 0.5;
}

float MTForceThresholding::rescaleForceAsLadderProgress(MTForceThresholding *this, const MTPathStates *a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  float v6;
  float v7;
  signed int v8;
  float v9;
  float v10;
  float v11;

  v2 = *((_DWORD *)this + 80);
  v3 = *((_QWORD *)a2 + 35);
  v4 = (*((_QWORD *)this + 26) - *((_QWORD *)this + 25)) >> 2;
  if ((v4 & 0x80000000) != 0)
  {
    v9 = 0.0;
    v10 = 1.0;
    v7 = 0.0;
LABEL_11:
    v11 = (float)(*(float *)(v3 + 600 * v2 + 336) - v9) / (float)(v10 - v9);
    return v7 + v11;
  }
  v6 = *(float *)(v3 + 600 * v2 + 336);
  v7 = 0.0;
  v8 = -1;
  do
  {
    v9 = MTForceThresholding::basicThresholdForLevel((uint64_t)this, v8);
    v8 += 2;
    v10 = MTForceThresholding::basicThresholdForLevel((uint64_t)this, v8);
    if (v6 < v9 || v6 < v10 || v8 >= (int)v4 && v6 > v10)
      break;
    v7 = v7 + 1.0;
  }
  while (v8 < (int)v4);
  v11 = 0.0;
  if (v10 > v9)
    goto LABEL_11;
  return v7 + v11;
}

uint64_t MTForceThresholding::classifyForceLevel(MTForceThresholding *this, const MTForceFilter *a2)
{
  unsigned int v3;
  uint64_t v4;
  float v5;
  int v6;
  uint64_t v7;
  float v8;

  v3 = 0;
  v4 = (*((_QWORD *)this + 26) - *((_QWORD *)this + 25)) >> 2;
  v5 = *((float *)a2 + 10);
  v6 = v4 & ~((int)v4 >> 31);
  v7 = (v6 - 1);
  while (v6 != v3)
  {
    v8 = MTForceThresholding::basicThresholdForLevel((uint64_t)this, v3++);
    if (v5 <= v8)
      return v3 - 2;
  }
  return v7;
}

uint64_t MTForceThresholding::classifyForceLevelAdaptively(MTForceThresholding *this, const MTForceFilter *a2, const MTParserPath *a3)
{
  unsigned int v6;
  uint64_t v7;
  float v8;
  int v9;
  uint64_t v10;
  float v11;

  v6 = 0;
  v7 = (*((_QWORD *)this + 26) - *((_QWORD *)this + 25)) >> 2;
  v8 = *((float *)a2 + 10);
  v9 = v7 & ~((int)v7 >> 31);
  v10 = (v9 - 1);
  while (v9 != v6)
  {
    v11 = MTForceThresholding::adaptiveThresholdForLevel((uint64_t)this, v6++, (float *)a2, (uint64_t)a3);
    if (v8 <= v11)
      return v6 - 2;
  }
  return v10;
}

uint64_t MTForceThresholding::fingersMatchBehavior(MTForceThresholding *this, const MTPathStates *a2, int a3)
{
  char *v5;

  v5 = (char *)this + 176;
  if (MTForceBehavior::forceSourceFingerCount((uint64_t)this + 176) == 2)
  {
    return *((_DWORD *)a2 + 92) == 2;
  }
  else
  {
    if (MTForceBehavior::forceSourceFingerCount((uint64_t)v5) != 3)
      return MTParserPath::isValidClickSource((MTParserPath *)(*((_QWORD *)a2 + 35) + 600 * a3));
    return *((_DWORD *)a2 + 92) == 3;
  }
}

void MTForceThresholding::updateAccidentalClickPreventionOffsets(uint64_t a1, unsigned int a2, uint64_t a3, MTParserPath *this, uint64_t a5, double a6, float a7, float a8)
{
  uint64_t v14;
  float v15;
  double v16;
  float v17;
  _BOOL4 isThumbContact;
  float v19;
  double v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  BOOL v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  double v36;
  float v37;
  float v38;

  v14 = *(int *)(a1 + 340);
  v15 = 1.0;
  if (v14 <= 2)
    v15 = flt_2310BE148[v14];
  if ((_DWORD)v14)
    v16 = dbl_2310BE120[(_DWORD)v14 == 2];
  else
    v16 = 0.9992;
  v17 = *(float *)(a1 + 88) + (v15 + -1.0) * 0.01;
  isThumbContact = MTParserPath::isThumbContact(this);
  v19 = v17 + 0.01;
  if (!isThumbContact)
    v19 = v17;
  v20 = pow(v19, (*(double *)(a5 + 8) - *(double *)(a5 + 16)) / 0.00800000038);
  v21 = *(float *)(a1 + 92);
  if (*(float *)(a1 + 400) > *(float *)(a1 + 128))
  {
    v22 = *(float *)(a3 + 8);
    v23 = *(float *)(a1 + 100);
    v24 = 0.0;
    if (v22 > v23)
    {
      v25 = *(float *)(a1 + 104);
      v26 = v22 < v25;
      v24 = (float)(v22 - v23) / (float)(v25 - v23);
      if (!v26)
        v24 = 1.0;
    }
    v21 = (float)(v21 * (float)(1.0 - v24)) + (float)(v24 * *(float *)(a1 + 96));
  }
  v27 = *(float *)(a1 + 80);
  v28 = *(float *)(a1 + 84);
  v29 = a7 - (float)(*(float *)(a1 + 72) * v15);
  v30 = a8 - (float)(*(float *)(a1 + 76) * v15);
  v31 = fmaxf(v29, 0.0);
  if (v31 >= v27)
    v32 = *(float *)(a1 + 80);
  else
    v32 = v31;
  *(float *)(a1 + 364) = v32;
  if (v29 <= v30)
    v29 = v30;
  v33 = fmaxf(v29, 0.0);
  if (v33 >= v27)
    v34 = v27;
  else
    v34 = v33;
  *(float *)(a1 + 360) = v34;
  v35 = MTForceThresholding::basicThresholdForLevel(a1, 3u);
  if (a2 != 0 && a2 < 0xFFFFFFFE)
  {
    v36 = *(double *)(a1 + 464) * (*(double *)(a1 + 464) * *(double *)(a1 + 464));
    *(double *)(a1 + 464) = v36;
    if (v36 <= 0.01)
    {
      v38 = v20;
      v37 = (float)((float)(1.0 - v38) * (float)((float)(v15 * v21) + v32)) + (float)(v38 * *(float *)(a1 + 456));
      goto LABEL_26;
    }
  }
  else
  {
    *(double *)(a1 + 464) = v16;
  }
  v37 = v35 + (float)(v32 + (float)((float)(v15 * v28) + v34));
LABEL_26:
  *(float *)(a1 + 456) = v37;
}

void MTForceThresholding::updateAdaptiveThresholdingParameters(uint64_t a1, int a2, MTPathStates *this, double a4, uint64_t a5)
{
  float v9;
  float v10;
  int v11;
  float v13;
  float v14;

  MTPathStates::getMaxDisplacement_mm((uint64_t)this);
  *(float *)(a1 + 400) = v9;
  v10 = *(float *)(a5 + 352);
  *(float *)(a1 + 404) = v10;
  v11 = *(_DWORD *)(a1 + 324);
  if (*(_DWORD *)(a1 + 332) > v11 && v11 >= 1)
  {
    v13 = *((double *)this + 1) - a4;
    v14 = 0.0;
    if (v13 > 0.25)
    {
      v14 = 1.0;
      if (v13 < 0.5)
        v14 = (float)(v13 + -0.25) * 4.0;
    }
    v10 = (float)(v9 * (float)(1.0 - v14)) + (float)(v14 * v10);
  }
  *(float *)(a1 + 396) = v10;
  *(float *)(a1 + 392) = MTPathStates::sumOfLowpassPeakFingerSpeeds(this);
}

uint64_t MTForceThresholding::analyzeForceAndStage(MTForceThresholding *this, const MTPathStates *a2, int a3, const MTForceBehavior *a4, double a5, double a6, int a7, float a8, float a9)
{
  double v9;
  int v13;
  int v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  float *v18;
  int v19;
  int v20;
  int v21;
  float v22;
  int v23;
  int v24;
  float v25;
  int v26;
  float v27;
  float v28;
  float v29;
  int v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  int v36;
  int v38;

  v9 = a5;
  v13 = *((_DWORD *)this + 81);
  v14 = 2 * v13;
  v15 = 2 * v13 - 1;
  v16 = *((_DWORD *)this + 80);
  if (v13)
  {
    v17 = *((_QWORD *)a2 + 35);
    LODWORD(a5) = *(_DWORD *)(v17 + 600 * a3 + 336);
    if (*(float *)&a5 <= *(float *)(v17 + 600 * v16 + 336))
    {
      v38 = *((_DWORD *)this + 80);
    }
    else
    {
      v16 = a3;
      v38 = a3;
    }
  }
  else
  {
    v38 = *((_DWORD *)this + 80);
    v17 = *((_QWORD *)a2 + 35);
  }
  v36 = v16;
  v18 = (float *)(v17 + 600 * v16);
  MTForceThresholding::updateAccidentalClickPreventionOffsets((uint64_t)this, v14 - 1, (uint64_t)(v18 + 74), (MTParserPath *)v18, (uint64_t)a2, a5, a8, a9);
  MTForceThresholding::updateAdaptiveThresholdingParameters((uint64_t)this, v19, a2, v9, (uint64_t)v18);
  v20 = MTForceThresholding::classifyForceLevelAdaptively(this, (const MTForceFilter *)(v18 + 74), (const MTParserPath *)v18);
  v21 = v20;
  v22 = v18[84];
  v23 = *((_DWORD *)this + 44);
  *((float *)this + 95) = v22;
  if (*(_DWORD *)a4 == 11 && v23 == 11 && !*((_DWORD *)this + 81) && *((double *)a2 + 1) - v9 < *((float *)this + 12))
  {
    if (v20 <= 1)
      v24 = 1;
    else
      v24 = v20;
    if ((*(_DWORD *)(v17 + 600 * v36 + 44) - 3) >= 2)
      v21 = v20;
    else
      v21 = v24;
  }
  v25 = *((float *)this + 96);
  if (vabds_f32(v22, v25) <= (float)(v25 * *((float *)this + 33)))
  {
    if (v25 != 0.0)
      goto LABEL_40;
  }
  else
  {
    *((_DWORD *)this + 96) = 0;
  }
  if (v21 >= (v14 | 1))
  {
    if (MTForceThresholding::fingersMatchBehavior(this, a2, v38) && a7)
    {
      v31 = v21 - ((v21 & 0x80000001) != 1);
      v32 = v31 + 2;
      if (v31 >= -1)
        v32 = v31 + 1;
      if (!MTForceBehavior::skipActivationStage((uint64_t)this + 176, v32 >> 1))
        v15 = v21 - ((v21 & 0x80000001) != 1);
    }
  }
  else if (v21 <= v14 - 3)
  {
    v26 = (v21 & 0x80000001) == 1 ? v21 : v21 + 1;
    v27 = *((float *)this + 94);
    v28 = *((float *)this + 97);
    if (v28 <= v27
      || (v29 = *((float *)a2 + 90), (float)(v28 - v29) >= (float)((float)(v27 - v22) * *((float *)this + 9)))
      || v29 <= *((float *)this + 10))
    {
      if (v23 != 11 || *((int *)this + 81) < 1 || (*(_DWORD *)(v17 + 600 * v36 + 44) - 3) >= 2)
      {
        v30 = v26 + 2;
        if (v26 >= -1)
          v30 = v26 + 1;
        if (!MTForceBehavior::skipReleaseStage((uint64_t)this + 176, v30 >> 1))
          v15 = v26;
      }
    }
  }
LABEL_40:
  v33 = v15 + 2;
  if ((int)(v15 + 1) >= 0)
    v33 = v15 + 1;
  v34 = (v33 >> 1);
  if ((int)v34 < *((_DWORD *)this + 81))
    v15 = v15 + 1 - ((v15 & 0x80000001) != 1);
  *((float *)this + 86) = MTForceThresholding::basicThresholdForLevel((uint64_t)this, v15);
  *((float *)this + 87) = MTForceThresholding::adaptiveThresholdForLevel((uint64_t)this, v15, v18 + 74, (uint64_t)v18);
  MTForceThresholding::updateStage((uint64_t)this, v34, v18 + 74, (uint64_t)v18, *((float *)a2 + 90), *((double *)a2 + 1));
  *((float *)this + 88) = MTForceThresholding::thresholdForNextRelease(this, (const MTForceFilter *)(v18 + 74), (const MTParserPath *)v18);
  *((float *)this + 89) = MTForceThresholding::thresholdForNextActivation(this, (const MTForceFilter *)(v18 + 74), (const MTParserPath *)v18);
  return v34;
}

BOOL MTForceThresholding::globalForceBlocksRelease(MTForceThresholding *this, const MTPathStates *a2, const MTForceFilter *a3)
{
  float v3;
  float v4;
  float v5;

  v3 = *((float *)this + 94);
  v4 = *((float *)this + 97);
  if (v4 <= v3)
    return 0;
  v5 = *((float *)a2 + 90);
  return (float)(v4 - v5) < (float)(*((float *)this + 9) * (float)(v3 - *((float *)a3 + 10)))
      && v5 > *((float *)this + 10);
}

BOOL MTForceThresholding::blocksReleaseWhileTouching(MTForceThresholding *this)
{
  return *((_DWORD *)this + 44) == 11 && *((int *)this + 81) > 0;
}

void MTForceThresholding::updateStage(uint64_t a1, int a2, float *a3, uint64_t a4, float a5, double a6)
{
  int v8;
  int v9;
  float v10;
  float v11;
  float v12;
  double v13;
  double v14;
  float v15;
  uint64_t v21;
  _DWORD *v22;

  v8 = *(_DWORD *)(a1 + 324);
  *(_DWORD *)(a1 + 328) = v8;
  *(_DWORD *)(a1 + 324) = a2;
  v9 = *(_DWORD *)(a1 + 332);
  if (v9 < a2)
  {
    *(_DWORD *)(a1 + 332) = a2;
    v10 = a3[10];
LABEL_3:
    *(float *)(a1 + 376) = v10;
    *(float *)(a1 + 388) = a5;
    *(double *)(a1 + 416) = a6;
    goto LABEL_6;
  }
  if (v9 == a2)
  {
    v10 = a3[10];
    if (v10 > *(float *)(a1 + 376))
      goto LABEL_3;
  }
LABEL_6:
  if (a2 >= 1 && !v8)
    *(double *)(a1 + 408) = a6;
  if (v8 != a2)
  {
    if (*(_BYTE *)(a1 + 172))
    {
      v11 = *(float *)(a4 + 72) + -1.0;
      v12 = 2.0;
      if (v11 < 2.0)
      {
        v12 = 0.0;
        if (v11 >= 0.0)
          v12 = *(float *)(a4 + 72) + -1.0;
      }
      *(float *)(a1 + 368) = (float)(MTForceFilter::surgeToActuationStrength((uint64_t)a3, (float *)(a1 + 144))
                                   + (float)(*(float *)(a1 + 164) * v12))
                           * *(float *)(a1 + 168);
      *(float *)(a1 + 372) = (float)(*(float *)(a1 + 156) * v12) + 1.0;
      a2 = *(_DWORD *)(a1 + 324);
      v8 = *(_DWORD *)(a1 + 328);
      if (a2 > v8)
      {
        v13 = MTForceFilter::surge_g_s((MTForceFilter *)a3);
        v14 = *(float *)(a1 + 144);
        v15 = MTForceFilter::surgeToActuationStrength((uint64_t)a3, (float *)(a1 + 144));
        printf("Surge=%.2f/%.2f, SurgeAmplitude=%.2f + excess area=%.2f -> stageStrength=%.2f, stageDilation=%.2f\n", v13, v14, v15, v12, *(float *)(a1 + 368), *(float *)(a1 + 372));
        a2 = *(_DWORD *)(a1 + 324);
        v8 = *(_DWORD *)(a1 + 328);
      }
    }
    else
    {
      __asm { FMOV            V0.2S, #1.0 }
      *(_QWORD *)(a1 + 368) = _D0;
    }
    *(_DWORD *)(a1 + 384) = 0;
    if (a2 <= v8)
    {
      if (a2 < v8)
        bzero((void *)(*(_QWORD *)(a1 + 432) + 4 * a2 + 4), 4 * (v8 + ~a2) + 4);
    }
    else
    {
      v21 = a2 - (uint64_t)v8;
      v22 = (_DWORD *)(*(_QWORD *)(a1 + 432) + 4 * v8 + 4);
      do
      {
        *v22++ = *((_DWORD *)a3 + 10);
        --v21;
      }
      while (v21);
    }
  }
}

_QWORD *std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_2310B0EB0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<float>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  int v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 2);
    if (v10 >> 62)
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 2;
    v12 = v5 - v8;
    if (v12 >> 1 > v10)
      v10 = v12 >> 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
      v13 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[4 * v11];
    v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void MTPowerLogger::MTPowerLogger(MTPowerLogger *this, const char *a2)
{
  NSObject *v4;
  void *v5;
  void *v6;
  NSObject *v7;
  const char *v8;
  CFStringRef v9;
  NSObject *v10;
  CFAbsoluteTime Current;
  int v12;
  const char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)this = &off_24FFF2FB0;
  atomic_store(1u, (unsigned int *)this + 2);
  v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v12 = 136446210;
    v13 = a2;
    _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_DEFAULT, "MTPowerLogger %{public}s starting!", (uint8_t *)&v12, 0xCu);
  }
  v5 = dlopen((const char *)objc_msgSend(CFSTR("/System/Library/PrivateFrameworks/PowerLog.framework/PowerLog"), "UTF8String"), 1);
  *((_QWORD *)this + 2) = v5;
  if (v5)
  {
    v6 = dlsym(v5, "PLLogRegisteredEvent");
    *((_QWORD *)this + 3) = v6;
    if (!v6)
    {
      v7 = MTLoggingPlugin();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v12) = 0;
        v8 = "MTPowerLogger could not find PLLogRegisteredEvent function";
LABEL_9:
        _os_log_impl(&dword_231071000, v7, OS_LOG_TYPE_ERROR, v8, (uint8_t *)&v12, 2u);
      }
    }
  }
  else
  {
    v7 = MTLoggingPlugin();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v12) = 0;
      v8 = "MTPowerLogger could not load PowerLog.framework";
      goto LABEL_9;
    }
  }
  v9 = CFStringCreateWithCString(0, a2, 0x8000100u);
  *((_QWORD *)this + 4) = v9;
  if (!v9)
  {
    v10 = MTLoggingPlugin();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v12) = 0;
      _os_log_impl(&dword_231071000, v10, OS_LOG_TYPE_ERROR, "MTPowerLogger could not create a logger name", (uint8_t *)&v12, 2u);
    }
  }
  Current = CFAbsoluteTimeGetCurrent();
  *((CFAbsoluteTime *)this + 6) = Current;
  *((CFAbsoluteTime *)this + 7) = Current;
  *((_DWORD *)this + 10) = 1;
  *((_BYTE *)this + 112) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
}

void MTPowerLogger::~MTPowerLogger(MTPowerLogger *this)
{
  void *v2;
  const void *v3;

  *(_QWORD *)this = &off_24FFF2FB0;
  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)
    dlclose(v2);
  v3 = (const void *)*((_QWORD *)this + 4);
  if (v3)
    CFRelease(v3);
}

{
  MTPowerLogger::~MTPowerLogger(this);
  JUMPOUT(0x2348D0034);
}

uint64_t MTPowerLogger::retain(uint64_t this, uint64_t a2, uint64_t a3)
{
  unsigned int *v3;
  unsigned int v5;

  v3 = (unsigned int *)(this + 8);
  if (!atomic_load((unsigned int *)(this + 8)))
    MTPowerLogger::retain(this, a2, a3);
  do
    v5 = __ldaxr(v3);
  while (__stlxr(v5 + 1, v3));
  return this;
}

unsigned int *MTPowerLogger::release(unsigned int *this)
{
  unsigned int *v1;
  unsigned int v3;
  unsigned int v4;

  v1 = this + 2;
  if (!atomic_load(this + 2))
    MTPowerLogger::release();
  do
  {
    v3 = __ldaxr(v1);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, v1));
  if (!v4)
    return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)this + 8))(this);
  return this;
}

void MTPowerLogger::scheduleOnDispatchQueue(MTPowerLogger *this, NSObject *a2)
{
  NSObject *v4;
  dispatch_source_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v11;
  dispatch_time_t v12;
  NSObject *v13;
  NSObject *v14;
  dispatch_source_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  unsigned int v20;
  NSObject *v21;
  _QWORD v22[5];
  _QWORD v23[5];
  _QWORD handler[5];
  uint8_t buf[16];

  v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_DEFAULT, "MTPowerLogger scheduling on dispatch queue", buf, 2u);
  }
  v5 = dispatch_source_create(MEMORY[0x24BDACA18], 0, 0, a2);
  *((_QWORD *)this + 12) = v5;
  v8 = MEMORY[0x24BDAC760];
  if (v5)
  {
    v9 = (unsigned int *)((char *)this + 8);
    if (!atomic_load((unsigned int *)this + 2))
      MTPowerLogger::retain((uint64_t)v5, v6, v7);
    do
      v11 = __ldaxr(v9);
    while (__stlxr(v11 + 1, v9));
    v12 = dispatch_time(0, 1800000000000);
    dispatch_source_set_timer(*((dispatch_source_t *)this + 12), v12, 0x1A3185C5000uLL, 0x3B9ACA00uLL);
    v13 = *((_QWORD *)this + 12);
    handler[0] = v8;
    handler[1] = 3221225472;
    handler[2] = ___ZN13MTPowerLogger23scheduleOnDispatchQueueEP16dispatch_queue_s_block_invoke;
    handler[3] = &__block_descriptor_40_e5_v8__0l;
    handler[4] = this;
    dispatch_source_set_event_handler(v13, handler);
    v14 = *((_QWORD *)this + 12);
    v23[0] = v8;
    v23[1] = 3221225472;
    v23[2] = ___ZN13MTPowerLogger23scheduleOnDispatchQueueEP16dispatch_queue_s_block_invoke_2;
    v23[3] = &__block_descriptor_40_e5_v8__0l;
    v23[4] = this;
    dispatch_source_set_cancel_handler(v14, v23);
    dispatch_resume(*((dispatch_object_t *)this + 12));
  }
  v15 = dispatch_source_create(MEMORY[0x24BDACA18], 0, 0, a2);
  *((_QWORD *)this + 13) = v15;
  if (v15)
  {
    v18 = (unsigned int *)((char *)this + 8);
    if (!atomic_load((unsigned int *)this + 2))
      MTPowerLogger::retain((uint64_t)v15, v16, v17);
    do
      v20 = __ldaxr(v18);
    while (__stlxr(v20 + 1, v18));
    v21 = *((_QWORD *)this + 13);
    v22[0] = v8;
    v22[1] = 3221225472;
    v22[2] = ___ZN13MTPowerLogger23scheduleOnDispatchQueueEP16dispatch_queue_s_block_invoke_3;
    v22[3] = &__block_descriptor_40_e5_v8__0l;
    v22[4] = this;
    dispatch_source_set_cancel_handler(v21, v22);
  }
}

uint64_t ___ZN13MTPowerLogger23scheduleOnDispatchQueueEP16dispatch_queue_s_block_invoke(uint64_t a1)
{
  return MTPowerLogger::logPower(*(MTPowerLogger **)(a1 + 32));
}

uint64_t MTPowerLogger::logPower(MTPowerLogger *this)
{
  double v2;
  CFAbsoluteTime Current;
  CFAbsoluteTime v4;
  void *v5;
  uint64_t i;
  uint64_t result;
  NSObject *v8;
  int v9;
  void *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v2 = *((double *)this + 6);
  Current = CFAbsoluteTimeGetCurrent();
  *((CFAbsoluteTime *)this + 6) = Current;
  v4 = Current - v2;
  MTPowerLogger::logState(this);
  v5 = (void *)objc_msgSend(MEMORY[0x24BDBCED8], "dictionaryWithCapacity:", 5);
  objc_msgSend(v5, "setObject:forKey:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", v4), CFSTR("SampleTime"));
  for (i = 0; i != 4; ++i)
    result = objc_msgSend(v5, "setObject:forKey:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *(double *)((char *)this + i * 8 + 64)), kPowerLogStateFields[i]);
  if (*((_QWORD *)this + 3) && *((_QWORD *)this + 4))
  {
    v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 138543362;
      v10 = v5;
      _os_log_impl(&dword_231071000, v8, OS_LOG_TYPE_DEFAULT, "MTPowerLogger sending event to PowerLog: %{public}@", (uint8_t *)&v9, 0xCu);
    }
    result = (*((uint64_t (**)(uint64_t, _QWORD, void *, _QWORD))this + 3))(53, *((_QWORD *)this + 4), v5, 0);
  }
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  return result;
}

void MTPowerLogger::unscheduleFromDispatchQueue(dispatch_object_t *this, dispatch_queue_s *a2)
{
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  uint8_t v6[16];

  v3 = MTLoggingPlugin();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_impl(&dword_231071000, v3, OS_LOG_TYPE_DEFAULT, "MTPowerLogger unscheduling from dispatch queue", v6, 2u);
  }
  MTPowerLogger::logPower((MTPowerLogger *)this);
  v4 = this[13];
  if (v4)
  {
    if (!*((_BYTE *)this + 112))
    {
      dispatch_source_set_event_handler(v4, &__block_literal_global_1);
      dispatch_resume(this[13]);
      v4 = this[13];
    }
    dispatch_source_cancel(v4);
    dispatch_release(this[13]);
    this[13] = 0;
    *((_BYTE *)this + 112) = 0;
  }
  v5 = this[12];
  if (v5)
  {
    dispatch_source_cancel(v5);
    dispatch_release(this[12]);
    this[12] = 0;
  }
}

void MTPowerLogger::transitionTo(MTPowerLogger *this, int a2)
{
  NSObject *v4;

  if (*((_BYTE *)this + 112))
  {
    v4 = *((_QWORD *)this + 13);
    if (v4)
      dispatch_suspend(v4);
    *((_BYTE *)this + 112) = 0;
  }
  if (*((_DWORD *)this + 10) != a2)
  {
    MTPowerLogger::logState(this);
    *((_DWORD *)this + 10) = a2;
  }
}

void MTPowerLogger::logState(MTPowerLogger *this)
{
  double v2;
  CFAbsoluteTime Current;
  double v4;
  NSObject *v5;
  __CFString *v6;
  double *v7;
  int v8;
  __CFString *v9;
  __int16 v10;
  double v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = *((double *)this + 7);
  Current = CFAbsoluteTimeGetCurrent();
  *((CFAbsoluteTime *)this + 7) = Current;
  v4 = Current - v2;
  if (v4 > 0.0)
  {
    v5 = MTLoggingPlugin();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      v6 = kPowerLogStateFields[*((unsigned int *)this + 10)];
      v8 = 138543618;
      v9 = v6;
      v10 = 2048;
      v11 = v4;
      _os_log_impl(&dword_231071000, v5, OS_LOG_TYPE_DEBUG, "MTPowerLogger logging state %{public}@ (%gs)", (uint8_t *)&v8, 0x16u);
    }
    v7 = (double *)((char *)this + 8 * *((unsigned int *)this + 10));
    v7[8] = v4 + v7[8];
  }
}

void MTPowerLogger::transitionToDelayed(uint64_t a1, int a2, uint64_t a3)
{
  NSObject *v4;
  dispatch_time_t v7;
  _QWORD v8[5];
  int v9;

  v4 = *(NSObject **)(a1 + 104);
  if (v4)
  {
    if (*(_BYTE *)(a1 + 112))
    {
      dispatch_suspend(v4);
      *(_BYTE *)(a1 + 112) = 0;
      v4 = *(NSObject **)(a1 + 104);
    }
    v8[0] = MEMORY[0x24BDAC760];
    v8[1] = 3221225472;
    v8[2] = ___ZN13MTPowerLogger19transitionToDelayedE18MTPowerLoggerStatex_block_invoke;
    v8[3] = &__block_descriptor_44_e5_v8__0l;
    v8[4] = a1;
    v9 = a2;
    dispatch_source_set_event_handler(v4, v8);
    v7 = dispatch_time(0, a3);
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 104), v7, a3, 0);
    dispatch_resume(*(dispatch_object_t *)(a1 + 104));
    *(_BYTE *)(a1 + 112) = 1;
  }
}

void ___ZN13MTPowerLogger19transitionToDelayedE18MTPowerLoggerStatex_block_invoke(uint64_t a1)
{
  MTPowerLogger::transitionTo(*(MTPowerLogger **)(a1 + 32), *(_DWORD *)(a1 + 40));
}

void OUTLINED_FUNCTION_0_1(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 72, a4);
}

uint64_t MTPathStatesBasic::MTPathStatesBasic(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, char a5, int a6)
{
  int64x2_t *v7;
  unint64_t v8;
  int v9;
  unsigned int v11;
  unsigned int v12[3];

  v11 = a4;
  v12[0] = a3;
  *(_QWORD *)a1 = off_24FFF3060;
  *(_DWORD *)(a1 + 24) = a3;
  *(_DWORD *)(a1 + 28) = a4;
  *(_BYTE *)(a1 + 32) = a5;
  *(_DWORD *)(a1 + 36) = a6;
  *(_QWORD *)(a1 + 40) = a2;
  v7 = (int64x2_t *)(a1 + 280);
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 328) = MTSLGLogger::createLogger((MTSLGLogger *)a1);
  std::vector<MTParserPath>::reserve(v7, 0x20uLL);
  v8 = *(_QWORD *)(a1 + 288);
  v9 = 32;
  do
  {
    if (v8 >= *(_QWORD *)(a1 + 296))
    {
      v8 = std::vector<MTParserPath>::__emplace_back_slow_path<MTParserType const&,MTParserOptions const&,MTSLGLogger *&>(v7, v12, &v11, (_QWORD *)(a1 + 328));
    }
    else
    {
      MTParserPath::MTParserPath(v8, v12[0], v11, *(_QWORD *)(a1 + 328));
      v8 += 600;
      *(_QWORD *)(a1 + 288) = v8;
    }
    *(_QWORD *)(a1 + 288) = v8;
    --v9;
  }
  while (v9);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  return a1;
}

void sub_2310B1980(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<MTParserPath>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<MTParserPath>::reserve(int64x2_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  int64x2_t v29;
  uint64_t v30;
  uint64_t v31;
  int64x2_t v32;
  uint64_t v33;
  uint64_t v34;

  v4 = a1[1].i64[0];
  result = (uint64_t)a1[1].i64;
  if (0x2FC962FC962FC963 * ((v4 - a1->i64[0]) >> 3) < a2)
  {
    if (a2 >= 0x6D3A06D3A06D3BLL)
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    v5 = a1->i64[1] - a1->i64[0];
    v34 = result;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTParserPath>>(result, a2);
    v7 = &v6[v5];
    v9 = &v6[600 * v8];
    v10 = a1->i64[0];
    v11 = a1->u64[1];
    if (v11 == a1->i64[0])
    {
      v29 = vdupq_n_s64(v11);
      v12 = v7;
    }
    else
    {
      v12 = v7;
      do
      {
        v13 = v12;
        v12 -= 600;
        *(_QWORD *)v12 = &off_24FFF08D0;
        memcpy(v13 - 592, (const void *)(v11 - 592), 0x11CuLL);
        *((_QWORD *)v13 - 38) = &off_24FFF2F50;
        v14 = v13 - 296;
        v16 = *(_OWORD *)(v11 - 280);
        v15 = *(_OWORD *)(v11 - 264);
        *(_OWORD *)v14 = *(_OWORD *)(v11 - 296);
        *((_OWORD *)v14 + 1) = v16;
        *((_OWORD *)v14 + 2) = v15;
        v17 = *(_OWORD *)(v11 - 248);
        v18 = *(_OWORD *)(v11 - 200);
        v19 = *(_OWORD *)(v11 - 216);
        *(_OWORD *)(v13 - 232) = *(_OWORD *)(v11 - 232);
        *(_OWORD *)(v13 - 216) = v19;
        *(_OWORD *)(v13 - 200) = v18;
        *(_OWORD *)(v13 - 248) = v17;
        v20 = *(_OWORD *)(v11 - 168);
        v21 = *(_OWORD *)(v11 - 152);
        v22 = *(_OWORD *)(v11 - 136);
        *(_OWORD *)(v13 - 184) = *(_OWORD *)(v11 - 184);
        *(_OWORD *)(v13 - 136) = v22;
        *(_OWORD *)(v13 - 152) = v21;
        *(_OWORD *)(v13 - 168) = v20;
        v23 = *(_OWORD *)(v11 - 104);
        v24 = *(_OWORD *)(v11 - 88);
        v25 = *(_OWORD *)(v11 - 72);
        *(_OWORD *)(v13 - 120) = *(_OWORD *)(v11 - 120);
        *(_OWORD *)(v13 - 72) = v25;
        *(_OWORD *)(v13 - 88) = v24;
        *(_OWORD *)(v13 - 104) = v23;
        v26 = *(_OWORD *)(v11 - 40);
        v27 = *(_OWORD *)(v11 - 24);
        v28 = *(_QWORD *)(v11 - 8);
        *(_OWORD *)(v13 - 56) = *(_OWORD *)(v11 - 56);
        *((_QWORD *)v13 - 1) = v28;
        *(_OWORD *)(v13 - 24) = v27;
        *(_OWORD *)(v13 - 40) = v26;
        v11 -= 600;
      }
      while (v11 != v10);
      v29 = *a1;
    }
    a1->i64[0] = (uint64_t)v12;
    a1->i64[1] = (uint64_t)v7;
    v32 = v29;
    v30 = a1[1].i64[0];
    a1[1].i64[0] = (uint64_t)v9;
    v33 = v30;
    v31 = v29.i64[0];
    return std::__split_buffer<MTParserPath>::~__split_buffer((uint64_t)&v31);
  }
  return result;
}

void MTPathStatesBasic::~MTPathStatesBasic(MTPathStatesBasic *this)
{
  MTSLGLogger *v2;
  void **v3;

  *(_QWORD *)this = off_24FFF3060;
  v2 = (MTSLGLogger *)*((_QWORD *)this + 41);
  if (v2)
  {
    MTSLGLogger::~MTSLGLogger(v2);
    MEMORY[0x2348D0034]();
    *((_QWORD *)this + 41) = 0;
  }
  v3 = (void **)((char *)this + 280);
  std::vector<MTParserPath>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void MTPathStatesBasic::clear(MTPathStatesBasic *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  v3 = 32;
  do
  {
    MTParserPath::clear((MTParserPath *)(*((_QWORD *)this + 35) + v2));
    v2 += 600;
    --v3;
  }
  while (v3);
  *((_QWORD *)this + 38) = 0;
  *((_QWORD *)this + 39) = 0;
}

double MTPathStatesBasic::initializeParams(MTPathStatesBasic *this)
{
  MTParameterFactory::initFingerTipOffsetParams((uint64_t)this + 180, *((_DWORD *)this + 6), *((_DWORD *)this + 7), *((unsigned __int8 *)this + 32));
  MTParameterFactory::initPathFilterParams((uint64_t)this + 48, *((_DWORD *)this + 6), *((_DWORD *)this + 7), *((unsigned __int8 *)this + 32), *((_QWORD *)this + 5), *((_DWORD *)this + 9));
  return MTParameterFactory::initTouchZoneParams((uint64_t)this + 244, *((_DWORD *)this + 6), *((unsigned int *)this + 7), *((unsigned __int8 *)this + 32));
}

float MTPathStatesBasic::updateResolutionDependentParams(MTPathStatesBasic *this)
{
  return MTParameterFactory::updatePathFilterParamsWithNewSurfaceDimensions((uint64_t)this + 48, *((_QWORD *)this + 5));
}

uint64_t MTPathStatesBasic::checkForFingersInZones(uint64_t this)
{
  int v1;
  _DWORD *v2;
  uint64_t v3;

  v1 = *(unsigned __int8 *)(this + 244);
  if (*(_BYTE *)(this + 244))
  {
    v1 = 0;
    v2 = (_DWORD *)(*(_QWORD *)(this + 280) + 644);
    v3 = 31;
    do
    {
      if ((*v2 - 3) <= 1)
        v1 |= v2[59];
      v2 += 150;
      --v3;
    }
    while (v3);
  }
  *(_DWORD *)(this + 324) = v1;
  return this;
}

void MTPathStatesBasic::updateFastestFingerSpeed(MTPathStatesBasic *this)
{
  float *v2;
  float v3;
  uint64_t v4;
  uint64_t v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  uint64_t v11;
  float v12;
  float v13;
  float v14;
  float v15;

  v2 = (float *)((char *)this + 304);
  *((_QWORD *)this + 38) = 0;
  *((_QWORD *)this + 39) = 0;
  v3 = 0.0;
  v4 = 1;
  v5 = 1136;
  v6 = 0.0;
  v7 = 0.0;
  v8 = 0.0;
  v9 = 0.0;
  v10 = 0.0;
  do
  {
    v11 = *((_QWORD *)this + 35);
    if (v4 == *(_DWORD *)(v11 + v5 - 496)
      && *(float *)(v11 + v5 - 464) > 0.0
      && MTParserPath::isFingerContact((MTParserPath *)(v11 + v5 - 536))
      && (*(_DWORD *)(v11 + v5 - 492) - 3) <= 2)
    {
      v13 = *(float *)(v11 + v5 - 4);
      v12 = *(float *)(v11 + v5);
      v14 = *(float *)(v11 + v5 - 8);
      v6 = v6 + v12;
      v3 = v3 + (float)(v12 * v12);
      v9 = v9 + fabsf(v14);
      v8 = v8 + fabsf(v13);
      v7 = v7 + (float)(v14 * v14);
      v10 = v10 + (float)(v13 * v13);
      v15 = hypotf(*(float *)(v11 + v5 - 436), *(float *)(v11 + v5 - 432));
      if (v15 > *((float *)this + 79))
        *((float *)this + 79) = v15;
    }
    ++v4;
    v5 += 600;
  }
  while (v4 != 32);
  if (v6 > 0.0)
    *v2 = v3 / v6;
  if (v9 > 0.0)
    *((float *)this + 77) = v7 / v9;
  if (v8 > 0.0)
    *((float *)this + 78) = v10 / v8;
}

uint64_t MTPathStatesBasic::forceFingerUniquenessAcrossHands(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  uint64_t v9;
  int v10;
  int v11;
  _OWORD v12[4];
  uint64_t v13;

  v1 = 0;
  v13 = *MEMORY[0x24BDAC8D0];
  memset(v12, 0, sizeof(v12));
  v2 = *(_QWORD *)(this + 280);
  do
  {
    if ((*(_DWORD *)(v2 + 600 * v1 + 44) - 1) <= 5)
    {
      v3 = v2 + 600 * v1;
      v6 = *(_DWORD *)(v3 + 48);
      v5 = (unsigned int *)(v3 + 48);
      v4 = v6;
      v7 = v6 - 1;
      if (*((_DWORD *)v12 + (int)v6))
        v8 = v7 > 4;
      else
        v8 = 1;
      if (!v8)
      {
        v9 = (int)v4;
        v10 = 1;
        while (v9 != 5)
        {
          v11 = *((_DWORD *)v12 + v9++);
          --v10;
          if (!v11)
          {
            v4 -= v10;
            *v5 = v4;
            break;
          }
        }
      }
      ++*((_DWORD *)v12 + v4);
    }
    ++v1;
  }
  while (v1 != 32);
  return this;
}

uint64_t MTPathStatesBasic::tasksPrePixelatedPositions(MTPathStatesBasic *this)
{
  return (*(uint64_t (**)(MTPathStatesBasic *))(*(_QWORD *)this + 32))(this);
}

void MTPathStatesBasic::expandAndFilterPackedContacts(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  unsigned int *v12;
  uint64_t v13;
  unint64_t v14;
  unsigned int v15;
  uint64_t v16;
  NSObject *v17;
  uint8_t buf[4];
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  *(_DWORD *)(a1 + 320) = 0;
  if (a2)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, a2, a3);
    if ((int)a3 >= 1)
    {
      v6 = a3;
      v7 = a2;
      do
      {
        v8 = *(unsigned int *)(v7 + 16);
        if ((v8 & 0x80000000) != 0
          || (v9 = *(_QWORD *)(a1 + 280), 0x2FC962FC962FC963 * ((*(_QWORD *)(a1 + 288) - v9) >> 3) <= v8))
        {
          v11 = MTLoggingPlugin();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            v19 = v8;
            _os_log_error_impl(&dword_231071000, v11, OS_LOG_TYPE_ERROR, "Invalid path_id %d, dropping contact", buf, 8u);
          }
        }
        else
        {
          MTParserPath::updateCurPrevContactsWith((MTParserPath *)(v9 + 600 * v8), (__int128 *)v7, *(_QWORD *)(a1 + 40), (float *)(a1 + 244), *(double *)(a1 + 8));
          v10 = *(_QWORD *)(a1 + 280);
          if (*(_DWORD *)(v10 + 600 * v8 + 44) == 1
            || !*(_DWORD *)(v10 + 600 * v8 + 140))
          {
            ++*(_DWORD *)(a1 + 320);
          }
        }
        v7 += 96;
        --v6;
      }
      while (v6);
    }
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 56))(a1, a2, a3);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  MTPathStatesBasic::updateFastestFingerSpeed((MTPathStatesBasic *)a1);
  if ((*(_DWORD *)(a1 + 24) - 1000) <= 0xBB7)
    MTPathStatesBasic::forceFingerUniquenessAcrossHands(a1);
  if ((int)a3 >= 1)
  {
    v12 = (unsigned int *)(a2 + 16);
    v13 = a3;
    do
    {
      v15 = *v12;
      v12 += 24;
      v14 = v15;
      if ((v15 & 0x80000000) != 0
        || (v16 = *(_QWORD *)(a1 + 280), 0x2FC962FC962FC963 * ((*(_QWORD *)(a1 + 288) - v16) >> 3) <= v14))
      {
        v17 = MTLoggingPlugin();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          v19 = v14;
          _os_log_error_impl(&dword_231071000, v17, OS_LOG_TYPE_ERROR, "Invalid path_id %d, dropping contact", buf, 8u);
        }
      }
      else
      {
        MTParserPath::constructPathChangeEventMask((MTParserPath *)(v16 + 600 * v14));
      }
      --v13;
    }
    while (v13);
  }
}

void MTPathStatesBasic::clearExistingPathLiftoffsAndMasks(MTPathStatesBasic *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = 0;
  v3 = *((_QWORD *)this + 35);
  v4 = 32;
  do
  {
    if (*(_DWORD *)(v3 + v2 + 44) == 7)
    {
      MTParserPath::clear((MTParserPath *)(v3 + v2));
      v3 = *((_QWORD *)this + 35);
    }
    *(_DWORD *)(v3 + v2 + 364) = 0;
    v2 += 600;
    --v4;
  }
  while (v4);
}

uint64_t MTPathStatesBasic::calculateCentroidOfPaths(uint64_t a1, float32x2_t *a2, double a3)
{
  int v5;
  int v6;
  float32x2_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  float32x2_t v11;
  uint64_t v12;
  float32x2_t *v13;
  float32x2_t v14;
  uint64_t v15;

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 1;
  v9 = 1032;
  v10 = *(_DWORD *)(a1 + 28) & 0x20;
  v11 = 0;
  do
  {
    v12 = *(_QWORD *)(a1 + 280);
    v13 = (float32x2_t *)(v12 + v9);
    if (v8 == *(_DWORD *)(v12 + v9 - 392) && v13[-45].f32[0] > 0.0)
    {
      v14 = *v13;
      v15 = v12 + v9;
      if (MTParserPath::isFingerContact((MTParserPath *)(v12 + v9 - 432)) || v10)
      {
        ++v5;
        a3 = COERCE_DOUBLE(vadd_f32(v14, *(float32x2_t *)(v15 - 32)));
        v7 = vadd_f32(v7, *(float32x2_t *)&a3);
        if ((*(_DWORD *)(v15 - 388) - 3) <= 1)
        {
          ++v6;
          v11 = vadd_f32(v11, *(float32x2_t *)&a3);
        }
      }
    }
    ++v8;
    v9 += 600;
  }
  while (v8 != 32);
  if (v6 > 0)
  {
    if (!a2)
      return 1;
LABEL_11:
    *(float *)&a3 = (float)v6;
    *a2 = vdiv_f32(v11, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0));
    return 1;
  }
  if (v5 >= 1)
  {
    v6 = v5;
    v11 = v7;
    if (!a2)
      return 1;
    goto LABEL_11;
  }
  return 0;
}

uint64_t MTPathStatesBasic::numFingerSlidWhileEngaged(MTPathStatesBasic *this)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;

  result = 0;
  v3 = *((_QWORD *)this + 35) + 644;
  v4 = 31;
  do
  {
    if (*(_DWORD *)v3 == 7)
      v5 = 100;
    else
      v5 = 4;
    v6 = *(_DWORD *)(v3 + v5) - 1;
    if ((*(_DWORD *)v3 - 3) <= 1 && v6 <= 4)
      result = result + *(unsigned __int8 *)(v3 + 324);
    v3 += 600;
    --v4;
  }
  while (v4);
  return result;
}

void std::vector<MTParserPath>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void (***v2)(_QWORD);
  void (***v4)(_QWORD);
  void *v5;
  void (***v6)(_QWORD);
  BOOL v7;

  v1 = *a1;
  v2 = (void (***)(_QWORD))**a1;
  if (v2)
  {
    v4 = (void (***)(_QWORD))v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 75;
      do
      {
        (**v6)(v6);
        v7 = v6 == v2;
        v6 -= 75;
      }
      while (!v7);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<MTParserPath>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x6D3A06D3A06D3BLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(600 * a2);
}

uint64_t std::__split_buffer<MTParserPath>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 600;
    (**(void (***)(uint64_t))(i - 600))(i - 600);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::vector<MTParserPath>::__emplace_back_slow_path<MTParserType const&,MTParserOptions const&,MTSLGLogger *&>(int64x2_t *a1, unsigned int *a2, unsigned int *a3, _QWORD *a4)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t i64;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  _OWORD *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  int64x2_t v35;
  uint64_t v36;
  char *v37;
  char *v39;
  int64x2_t v40;
  char *v41;
  int64x2_t *v42;

  v5 = a1->i64[0];
  v6 = 0x2FC962FC962FC963 * ((a1->i64[1] - a1->i64[0]) >> 3);
  v7 = v6 + 1;
  if ((unint64_t)(v6 + 1) > 0x6D3A06D3A06D3ALL)
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  i64 = (uint64_t)a1[1].i64;
  v12 = 0x2FC962FC962FC963 * ((a1[1].i64[0] - v5) >> 3);
  if (2 * v12 > v7)
    v7 = 2 * v12;
  if (v12 >= 0x369D0369D0369DLL)
    v13 = 0x6D3A06D3A06D3ALL;
  else
    v13 = v7;
  v42 = a1 + 1;
  if (v13)
    v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTParserPath>>(i64, v13);
  else
    v14 = 0;
  v39 = v14;
  v40.i64[0] = (uint64_t)&v14[600 * v6];
  v40.i64[1] = v40.i64[0];
  v41 = &v14[600 * v13];
  MTParserPath::MTParserPath(v40.i64[0], *a2, *a3, *a4);
  v15 = a1->i64[0];
  v16 = a1->u64[1];
  v18 = (_QWORD *)v40.i64[0];
  v17 = v40.i64[0];
  if (v16 == a1->i64[0])
  {
    v35 = vdupq_n_s64(v16);
  }
  else
  {
    do
    {
      v19 = v18;
      v18 -= 75;
      *v18 = &off_24FFF08D0;
      memcpy(v19 - 74, (const void *)(v16 - 592), 0x11CuLL);
      *(v19 - 38) = &off_24FFF2F50;
      v20 = v19 - 37;
      v22 = *(_OWORD *)(v16 - 280);
      v21 = *(_OWORD *)(v16 - 264);
      *v20 = *(_OWORD *)(v16 - 296);
      v20[1] = v22;
      v20[2] = v21;
      v23 = *(_OWORD *)(v16 - 248);
      v24 = *(_OWORD *)(v16 - 200);
      v25 = *(_OWORD *)(v16 - 216);
      *(_OWORD *)(v19 - 29) = *(_OWORD *)(v16 - 232);
      *(_OWORD *)(v19 - 27) = v25;
      *(_OWORD *)(v19 - 25) = v24;
      *(_OWORD *)(v19 - 31) = v23;
      v26 = *(_OWORD *)(v16 - 168);
      v27 = *(_OWORD *)(v16 - 152);
      v28 = *(_OWORD *)(v16 - 136);
      *(_OWORD *)(v19 - 23) = *(_OWORD *)(v16 - 184);
      *(_OWORD *)(v19 - 17) = v28;
      *(_OWORD *)(v19 - 19) = v27;
      *(_OWORD *)(v19 - 21) = v26;
      v29 = *(_OWORD *)(v16 - 104);
      v30 = *(_OWORD *)(v16 - 88);
      v31 = *(_OWORD *)(v16 - 72);
      *(_OWORD *)(v19 - 15) = *(_OWORD *)(v16 - 120);
      *(_OWORD *)(v19 - 9) = v31;
      *(_OWORD *)(v19 - 11) = v30;
      *(_OWORD *)(v19 - 13) = v29;
      v32 = *(_OWORD *)(v16 - 40);
      v33 = *(_OWORD *)(v16 - 24);
      v34 = *(_QWORD *)(v16 - 8);
      *(_OWORD *)(v19 - 7) = *(_OWORD *)(v16 - 56);
      *(v19 - 1) = v34;
      *(_OWORD *)(v19 - 3) = v33;
      *(_OWORD *)(v19 - 5) = v32;
      v16 -= 600;
    }
    while (v16 != v15);
    v35 = *a1;
  }
  v36 = v17 + 600;
  a1->i64[0] = (uint64_t)v18;
  a1->i64[1] = v36;
  v40 = v35;
  v37 = (char *)a1[1].i64[0];
  a1[1].i64[0] = (uint64_t)v41;
  v41 = v37;
  v39 = (char *)v35.i64[0];
  std::__split_buffer<MTParserPath>::~__split_buffer((uint64_t)&v39);
  return v36;
}

void sub_2310B26D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__split_buffer<MTParserPath>::~__split_buffer((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void MTFingerToPathMap::MTFingerToPathMap(MTFingerToPathMap *this, char a2)
{
  *(_QWORD *)this = &off_24FFF30E0;
  *((_BYTE *)this + 76) = a2;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_WORD *)((char *)this + 103) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *(_QWORD *)((char *)this + 94) = 0;
}

{
  *(_QWORD *)this = &off_24FFF30E0;
  *((_BYTE *)this + 76) = a2;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_WORD *)((char *)this + 103) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *(_QWORD *)((char *)this + 94) = 0;
}

double MTFingerToPathMap::clearFingerPathMappings(MTFingerToPathMap *this)
{
  double result;

  result = 0.0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_WORD *)((char *)this + 103) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *(_QWORD *)((char *)this + 94) = 0;
  return result;
}

void MTFingerToPathMap::~MTFingerToPathMap(MTFingerToPathMap *this)
{
  JUMPOUT(0x2348D0034);
}

uint64_t MTFingerToPathMap::getInnermostTouchingPath(MTFingerToPathMap *this, const MTPathStates *a2)
{
  uint64_t v2;
  int v3;

  v2 = *((unsigned int *)this + 20);
  if (v2 > 0xF)
    v3 = 0;
  else
    v3 = *((_DWORD *)this + v2 + 2);
  return *((_QWORD *)a2 + 35) + 600 * v3;
}

uint64_t MTFingerToPathMap::getNextInnermostTouchingPath(MTFingerToPathMap *this, const MTPathStates *a2)
{
  uint64_t v2;
  int v3;

  v2 = *((unsigned int *)this + 21);
  if (v2 > 0xF)
    v3 = 0;
  else
    v3 = *((_DWORD *)this + v2 + 2);
  return *((_QWORD *)a2 + 35) + 600 * v3;
}

uint64_t MTFingerToPathMap::getOutermostTouchingPath(MTFingerToPathMap *this, const MTPathStates *a2)
{
  uint64_t v2;
  int v3;

  v2 = *((unsigned int *)this + 22);
  if (v2 > 0xF)
    v3 = 0;
  else
    v3 = *((_DWORD *)this + v2 + 2);
  return *((_QWORD *)a2 + 35) + 600 * v3;
}

uint64_t MTFingerToPathMap::getInnermostInRangePath(MTFingerToPathMap *this, const MTPathStates *a2)
{
  uint64_t v2;
  int v3;

  v2 = *((unsigned int *)this + 23);
  if (v2 > 0xF)
    v3 = 0;
  else
    v3 = *((_DWORD *)this + v2 + 2);
  return *((_QWORD *)a2 + 35) + 600 * v3;
}

uint64_t MTFingerToPathMap::getOutermostInRangePath(MTFingerToPathMap *this, const MTPathStates *a2)
{
  uint64_t v2;
  int v3;

  v2 = *((unsigned int *)this + 24);
  if (v2 > 0xF)
    v3 = 0;
  else
    v3 = *((_DWORD *)this + v2 + 2);
  return *((_QWORD *)a2 + 35) + 600 * v3;
}

uint64_t MTFingerToPathMap::getParserPathForFingerID(MTFingerToPathMap *this, unsigned int a2, const MTPathStates *a3)
{
  int v3;

  if (a2 > 0xF)
    v3 = 0;
  else
    v3 = *((_DWORD *)this + a2 + 2);
  return *((_QWORD *)a3 + 35) + 600 * v3;
}

uint64_t MTFingerToPathMap::getMutablePathForFingerID(MTFingerToPathMap *this, unsigned int a2, MTPathStates *a3)
{
  int v3;

  if (a2 > 0xF)
    v3 = 0;
  else
    v3 = *((_DWORD *)this + a2 + 2);
  return *((_QWORD *)a3 + 35) + 600 * v3;
}

uint64_t MTFingerToPathMap::clearMaxFingersTouching(uint64_t this)
{
  *(_BYTE *)(this + 102) = 0;
  return this;
}

uint64_t MTFingerToPathMap::updateMaxFingersTouching(uint64_t this)
{
  unsigned int v1;

  v1 = *(unsigned __int8 *)(this + 101);
  if (v1 > *(unsigned __int8 *)(this + 102) || !*(_BYTE *)(this + 101))
    *(_BYTE *)(this + 102) = v1;
  return this;
}

uint64_t MTFingerToPathMap::updateFingerPathMappings(uint64_t this, const MTPathStates *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float *v7;
  uint64_t v8;
  MTParserPath *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  char v15;

  v3 = this;
  *(_OWORD *)(this + 56) = 0u;
  *(_OWORD *)(this + 40) = 0u;
  *(_OWORD *)(this + 24) = 0u;
  *(_OWORD *)(this + 8) = 0u;
  *(_WORD *)(this + 103) = 0;
  *(_QWORD *)(this + 80) = 0;
  *(_QWORD *)(this + 88) = 0;
  v4 = 1;
  v5 = 672;
  *(_QWORD *)(this + 94) = 0;
  do
  {
    v6 = *((_QWORD *)a2 + 35);
    v7 = (float *)(v6 + v5);
    if (v4 != *(_DWORD *)(v6 + v5 - 32) || *v7 <= 0.0)
      goto LABEL_31;
    v8 = *(unsigned int *)(v6 + v5 - 24);
    if (v8 <= 0xF)
      *(_DWORD *)(v3 + 4 * v8 + 8) = v4;
    v9 = (MTParserPath *)(v7 - 18);
    this = MTParserPath::isPalmContact((MTParserPath *)(v7 - 18));
    if ((_DWORD)this)
    {
      ++*(_BYTE *)(v3 + 104);
      goto LABEL_31;
    }
    this = MTParserPath::isEdgeContact(v9);
    if ((_DWORD)this)
    {
      ++*(_BYTE *)(v3 + 103);
      goto LABEL_31;
    }
    if (*(_BYTE *)(v3 + 76))
    {
      this = MTParserPath::isFingerContact(v9);
      if ((this & 1) != 0)
        goto LABEL_14;
      if (*(_BYTE *)(v3 + 76))
        goto LABEL_31;
    }
    this = MTParserPath::isFingerOrRestingContact(v9);
    if (!(_DWORD)this)
      goto LABEL_31;
LABEL_14:
    ++*(_BYTE *)(v3 + 100);
    v10 = *(_DWORD *)(v3 + 92);
    if (!v10 || (int)v8 < v10)
      *(_DWORD *)(v3 + 92) = v8;
    v11 = *(_DWORD *)(v3 + 96);
    if (!v11 || (int)v8 > v11)
      *(_DWORD *)(v3 + 96) = v8;
    if ((*(_DWORD *)(v6 + v5 - 28) - 3) <= 1)
    {
      ++*(_BYTE *)(v3 + 101);
      v12 = *(_DWORD *)(v3 + 80);
      if (v12 && (int)v8 >= v12)
      {
        v13 = *(_DWORD *)(v3 + 84);
        if (v13 && (int)v8 < v13)
        {
          *(_DWORD *)(v3 + 84) = v8;
          goto LABEL_27;
        }
      }
      else
      {
        *(_DWORD *)(v3 + 80) = v8;
        *(_DWORD *)(v3 + 84) = v12;
LABEL_27:
        *(_DWORD *)(v3 + 72) = *(_DWORD *)(v6 + v5 - 20);
      }
      v14 = *(_DWORD *)(v3 + 88);
      if (!v14 || (int)v8 > v14)
      {
        *(_DWORD *)(v3 + 88) = v8;
        *(_DWORD *)(v3 + 72) = *(_DWORD *)(v6 + v5 - 20);
      }
    }
LABEL_31:
    ++v4;
    v5 += 600;
  }
  while (v4 != 32);
  v15 = *(_BYTE *)(v3 + 101);
  if (*(unsigned __int8 *)(v3 + 102) <= (v15 - 1))
    *(_BYTE *)(v3 + 102) = v15;
  return this;
}

void MTABCLogger::MTABCLogger(MTABCLogger *this)
{
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 1) = 0;
  *(_QWORD *)this = (char *)this + 8;
  *((_QWORD *)this + 3) = operator new();
}

void sub_2310B2B00(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<MTABCSessionHandler *>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

void MTABCLogger::~MTABCLogger(MTABCLogger **this)
{
  MTABCLogger **v2;
  MTABCLogger *v3;
  MTABCLogger *v4;
  MTABCLogger **v5;
  BOOL v6;
  MTABCLogger *v7;
  MTABCLogger *v8;
  MTABCLogger *v9;

  v2 = this + 1;
  v3 = *this;
  if (*this != (MTABCLogger *)(this + 1))
  {
    do
    {
      MTABCLogger::endSession((uint64_t)this, *((id **)v3 + 4), 0);
      v4 = (MTABCLogger *)*((_QWORD *)v3 + 1);
      if (v4)
      {
        do
        {
          v5 = (MTABCLogger **)v4;
          v4 = *(MTABCLogger **)v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          v5 = (MTABCLogger **)*((_QWORD *)v3 + 2);
          v6 = *v5 == v3;
          v3 = (MTABCLogger *)v5;
        }
        while (!v6);
      }
      v3 = (MTABCLogger *)v5;
    }
    while (v5 != v2);
  }
  v7 = this[3];
  if (v7)
  {

    v8 = this[3];
    if (v8)
      MEMORY[0x2348D0034](v8, 0x80C40803F642BLL);
    this[3] = 0;
  }
  v9 = this[5];
  if (v9)
    dlclose(v9);
  std::__tree<MTABCSessionHandler *>::destroy((uint64_t)this, this[1]);
}

void MTABCLogger::endSession(uint64_t a1, id *a2, int a3)
{
  NSObject *v6;
  id v7;
  uint64_t v8;
  void *v9;
  void *v10;
  NSObject *v11;
  id v12;
  id *v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  id v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  if (a2)
  {
    v6 = MTLoggingPlugin();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *a2;
      *(_DWORD *)buf = 136315906;
      v15 = "";
      v16 = 2080;
      v17 = "";
      v18 = 2080;
      v19 = "endSession";
      v20 = 2114;
      v21 = v7;
      _os_log_impl(&dword_231071000, v6, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Ending ABC session %{public}@", buf, 0x2Au);
    }
    v8 = std::__tree<MTABCSessionHandler *>::__erase_unique<MTABCSessionHandler *>(a1, (unint64_t *)&v13);
    if (*(_QWORD *)(a1 + 16))
    {
      if (!a3)
        goto LABEL_11;
    }
    else
    {
      v8 = MTUnregisterFullFrameCallback();
      if (!a3)
      {
LABEL_11:
        MTABCLogger::_freeSession(v8, v13);
        return;
      }
    }
    v9 = (void *)objc_msgSend(v13[3], "objectAtIndexedSubscript:", 0);
    v10 = (void *)MEMORY[0x24BDD16E0];
    objc_msgSend((id)objc_msgSend(MEMORY[0x24BDBCE60], "date"), "timeIntervalSince1970");
    objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(v10, "numberWithDouble:"), CFSTR("CaptureEndTimestamp"));
    v11 = MTLoggingPlugin();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v12 = *v13;
      *(_DWORD *)buf = 136315906;
      v15 = "";
      v16 = 2080;
      v17 = "";
      v18 = 2080;
      v19 = "endSession";
      v20 = 2114;
      v21 = v12;
      _os_log_impl(&dword_231071000, v11, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Snapshotting ABC session %{public}@", buf, 0x2Au);
    }
    v8 = objc_msgSend(*(id *)(*(_QWORD *)(a1 + 24) + 8), "snapshotWithSignature:duration:events:payload:actions:reply:", v13[2], v13[3], 0, 0, &__block_literal_global_2, 0.0);
    goto LABEL_11;
  }
}

MTABCLogger *MTABCLogger::createLogger(uint64_t a1)
{
  MTABCLogger *v2;

  if (!MGGetBoolAnswer())
    return 0;
  v2 = (MTABCLogger *)operator new();
  MTABCLogger::MTABCLogger(v2);
  if ((MTABCLogger::_init((uint64_t)v2, a1) & 1) == 0)
  {
    MTABCLogger::~MTABCLogger((MTABCLogger **)v2);
    MEMORY[0x2348D0034]();
    return 0;
  }
  return v2;
}

void sub_2310B2E7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10A0C40E56C3652);
  _Unwind_Resume(a1);
}

objc_class *MTABCLogger::_init(uint64_t a1, uint64_t a2)
{
  objc_class *result;
  id v4;

  *(_QWORD *)(a1 + 32) = a2;
  if (!a2)
    return 0;
  result = (objc_class *)dlopen((const char *)objc_msgSend(CFSTR("/System/Library/PrivateFrameworks/SymptomDiagnosticReporter.framework/SymptomDiagnosticReporter"), "UTF8String"), 1);
  *(_QWORD *)(a1 + 40) = result;
  if (result)
  {
    result = NSClassFromString(CFSTR("SDRDiagnosticReporter"));
    **(_QWORD **)(a1 + 24) = result;
    if (result)
    {
      v4 = objc_alloc_init(result);
      *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8) = v4;
      return (objc_class *)(v4 != 0);
    }
  }
  return result;
}

void MTABCLogger::_freeSession(uint64_t a1, id *a2)
{
  if (a2)
  {

    JUMPOUT(0x2348D0034);
  }
}

uint64_t MTABCLogger::_prepopulateSessionEvent(uint64_t a1, uint64_t a2)
{
  uint64_t ParserType;
  io_registry_entry_t Service;
  uint64_t v5;
  id v6;
  id v7;
  CFMutableDictionaryRef v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  void *v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  const char *v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  id v25;
  void *v26;
  uint64_t v28;
  CFMutableDictionaryRef properties;
  CFTypeRef cf;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  unsigned __int8 v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  uint64_t v47;
  __int16 v48;
  uint64_t v49;
  _BYTE v50[128];
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  v35 = 0;
  v34 = 0;
  v33 = 0;
  v31 = 0;
  v32 = 0;
  properties = 0;
  cf = 0;
  MTDeviceGetDeviceID();
  MTDeviceGetSubdeviceID();
  MTDeviceGetFamilyID();
  MTDeviceGetSensorDimensions();
  MTDeviceGetSensorSurfaceDimensions();
  ParserType = MTDeviceGetParserType();
  MTDeviceCopyDeviceUsagePairs();
  Service = MTDeviceGetService();
  IORegistryEntryCreateCFProperties(Service, &properties, (CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
  v5 = (uint64_t)objc_alloc_init(MEMORY[0x24BDBCED8]);
  if (!v5)
    goto LABEL_30;
  objc_msgSend((id)v5, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLongLong:", v35), CFSTR("DeviceID"));
  objc_msgSend((id)v5, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedChar:", v34), CFSTR("SubdeviceID"));
  objc_msgSend((id)v5, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", v33), CFSTR("FamilyID"));
  objc_msgSend((id)v5, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", HIDWORD(v32)), CFSTR("Rows"));
  objc_msgSend((id)v5, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", v32), CFSTR("Cols"));
  objc_msgSend((id)v5, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", HIDWORD(v31)), CFSTR("SensorSurfaceWidth"));
  objc_msgSend((id)v5, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", v31), CFSTR("SensorSurfaceHeight"));
  objc_msgSend((id)v5, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", ParserType), CFSTR("ParserType"));
  objc_msgSend((id)v5, "setObject:forKeyedSubscript:", cf, CFSTR("UsagePairs"));
  v6 = objc_alloc_init(MEMORY[0x24BDBCED8]);
  if (!v6)
    goto LABEL_35;
  v7 = v6;
  v28 = v5;
  v8 = properties;
  v36 = 0u;
  v37 = 0u;
  v38 = 0u;
  v39 = 0u;
  v9 = -[__CFDictionary countByEnumeratingWithState:objects:count:](properties, "countByEnumeratingWithState:objects:count:", &v36, v50, 16);
  if (!v9)
    goto LABEL_27;
  v10 = v9;
  v11 = *(_QWORD *)v37;
  do
  {
    v12 = 0;
    do
    {
      if (*(_QWORD *)v37 != v11)
        objc_enumerationMutation(v8);
      v13 = *(_QWORD *)(*((_QWORD *)&v36 + 1) + 8 * v12);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        v17 = MTLoggingPlugin();
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          goto LABEL_22;
        v18 = objc_opt_class();
        *(_DWORD *)buf = 136316162;
        v41 = "[Error] ";
        v42 = 2080;
        v43 = "";
        v44 = 2080;
        v45 = "_JSONify";
        v46 = 2114;
        v47 = v13;
        v48 = 2114;
        v49 = v18;
        v19 = v17;
        v20 = "[HID] [MT] %s%s%s %{public}@ key has an unexpected type (class %{public}@)";
        goto LABEL_13;
      }
      v14 = (void *)-[__CFDictionary objectForKeyedSubscript:](v8, "objectForKeyedSubscript:", v13);
      if (objc_msgSend(MEMORY[0x24BDD1608], "isValidJSONObject:", v14))
      {
        v15 = v7;
        v16 = v14;
LABEL_21:
        objc_msgSend(v15, "setObject:forKey:", v16, v13);
        goto LABEL_22;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v21 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithString:", v14);
LABEL_20:
        v16 = (void *)v21;
        v15 = v7;
        goto LABEL_21;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v21 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithLongLong:", objc_msgSend(v14, "longLongValue"));
        goto LABEL_20;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v21 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@%@"), CFSTR("NSDAT@"), objc_msgSend(v14, "base64EncodedStringWithOptions:", 0));
        goto LABEL_20;
      }
      v22 = MTLoggingPlugin();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        v23 = objc_opt_class();
        *(_DWORD *)buf = 136316162;
        v41 = "[Error] ";
        v42 = 2080;
        v43 = "";
        v44 = 2080;
        v45 = "_JSONify";
        v46 = 2114;
        v47 = v13;
        v48 = 2114;
        v49 = v23;
        v19 = v22;
        v20 = "[HID] [MT] %s%s%s %{public}@ is not serializable (class %{public}@)";
LABEL_13:
        _os_log_impl(&dword_231071000, v19, OS_LOG_TYPE_ERROR, v20, buf, 0x34u);
      }
LABEL_22:
      ++v12;
    }
    while (v10 != v12);
    v24 = -[__CFDictionary countByEnumeratingWithState:objects:count:](v8, "countByEnumeratingWithState:objects:count:", &v36, v50, 16);
    v10 = v24;
  }
  while (v24);
LABEL_27:
  v5 = (uint64_t)objc_alloc_init(MEMORY[0x24BDBCEB8]);
  if (!v5)
    goto LABEL_30;
  v25 = objc_alloc_init(MEMORY[0x24BDBCED8]);
  if (v25)
  {
    v26 = v25;
    objc_msgSend(v25, "setObject:forKeyedSubscript:", v28, CFSTR("DeviceInfo"));
    objc_msgSend(v26, "setObject:forKeyedSubscript:", v7, CFSTR("RegistryProperties"));
    objc_msgSend(v26, "setObject:forKeyedSubscript:", v5, CFSTR("Frames"));
    objc_msgSend(*(id *)(a2 + 24), "addObject:", v26);
    v5 = 1;
    goto LABEL_30;
  }
LABEL_35:
  v5 = 0;
LABEL_30:
  if (cf)
    CFRelease(cf);
  if (properties)
    CFRelease(properties);
  return v5;
}

void MTABCLogger::_dumpSessionToFile(uint64_t a1, uint64_t a2)
{
  id v3;
  NSString *v4;
  void *v5;
  void *v6;
  id v7;
  NSString *v8;
  NSObject *global_queue;
  _QWORD block[6];
  uint64_t v11;

  v3 = objc_alloc_init(MEMORY[0x24BDBCED8]);
  objc_msgSend(v3, "setObject:forKeyedSubscript:", *(_QWORD *)(a2 + 24), CFSTR("events"));
  v4 = -[NSString stringByAppendingPathComponent:](NSTemporaryDirectory(), "stringByAppendingPathComponent:", CFSTR("MTABCLogger.json"));
  v11 = 0;
  v5 = (void *)objc_msgSend(MEMORY[0x24BDD1608], "dataWithJSONObject:options:error:", v3, 1, &v11);
  if (v5)
  {
    v6 = v5;
    v7 = v5;
    v8 = v4;
    global_queue = dispatch_get_global_queue(0, 0);
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 3221225472;
    block[2] = ___ZN11MTABCLogger18_dumpSessionToFileEP19MTABCSessionHandler_block_invoke;
    block[3] = &unk_24FFF3108;
    block[4] = v4;
    block[5] = v6;
    dispatch_async(global_queue, block);
  }
}

void ___ZN11MTABCLogger18_dumpSessionToFileEP19MTABCSessionHandler_block_invoke(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  const char *v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = 136315906;
    v5 = "";
    v6 = 2080;
    v7 = "";
    v8 = 2080;
    v9 = "_dumpSessionToFile_block_invoke";
    v10 = 2114;
    v11 = v3;
    _os_log_impl(&dword_231071000, v2, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Writing ABC session %{public}@", (uint8_t *)&v4, 0x2Au);
  }
  objc_msgSend(*(id *)(a1 + 40), "writeToFile:options:error:", *(_QWORD *)(a1 + 32), 0, 0);

}

void MTABCLogger::_fullFrameCallback(uint64_t a1, uint64_t a2, unsigned int a3, _QWORD *a4)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  _QWORD *v20;
  _QWORD *v21;
  BOOL v22;
  _QWORD v23[2];
  _QWORD v24[3];

  v24[2] = *MEMORY[0x24BDAC8D0];
  v4 = a4 + 1;
  v5 = (_QWORD *)*a4;
  if ((_QWORD *)*a4 != a4 + 1)
  {
    v7 = a3;
    do
    {
      v8 = v5[4];
      v9 = (void *)objc_msgSend(*(id *)(v8 + 24), "objectAtIndexedSubscript:", 0);
      v10 = (void *)objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("Frames"));
      v11 = objc_msgSend((id)objc_msgSend(MEMORY[0x24BDBCE50], "dataWithBytes:length:", a2, v7), "base64EncodedStringWithOptions:", 0);
      v12 = (void *)objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("CaptureBeginTimestamp"));
      if (!v12)
      {
        v13 = (void *)MEMORY[0x24BDD16E0];
        objc_msgSend((id)objc_msgSend(MEMORY[0x24BDBCE60], "date"), "timeIntervalSince1970");
        v12 = (void *)objc_msgSend(v13, "numberWithDouble:");
        objc_msgSend(v9, "setObject:forKeyedSubscript:", v12, CFSTR("CaptureBeginTimestamp"));
      }
      objc_msgSend(v12, "doubleValue");
      v15 = v14;
      objc_msgSend((id)objc_msgSend(MEMORY[0x24BDBCE60], "date"), "timeIntervalSince1970");
      v17 = v16 - v15;
      v18 = *(double *)(v8 + 8);
      if (v18 == 0.0 || v17 <= v18)
      {
        v23[0] = CFSTR("bytes");
        v23[1] = CFSTR("timestamp");
        v24[0] = v11;
        v24[1] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", v17);
        objc_msgSend(v10, "addObject:", objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v24, v23, 2));
      }
      v20 = (_QWORD *)v5[1];
      if (v20)
      {
        do
        {
          v21 = v20;
          v20 = (_QWORD *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          v21 = (_QWORD *)v5[2];
          v22 = *v21 == (_QWORD)v5;
          v5 = v21;
        }
        while (!v22);
      }
      v5 = v21;
    }
    while (v21 != v4);
  }
}

uint64_t MTABCLogger::startSession(MTABCLogger *this, const char *a2, double a3)
{
  NSObject *v6;
  uint64_t v7;
  id v8;
  id v9;
  _BYTE v11[12];
  __int16 v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v6 = MTLoggingPlugin();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v11 = 136315650;
    *(_QWORD *)&v11[4] = "";
    v12 = 2080;
    v13 = "";
    v14 = 2080;
    v15 = "startSession";
    _os_log_impl(&dword_231071000, v6, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Started new ABC session", v11, 0x20u);
  }
  v7 = operator new();
  *(_QWORD *)v11 = v7;
  v8 = (id)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithUTF8String:", a2);
  *(_QWORD *)v7 = v8;
  if (!v8)
    goto LABEL_10;
  *(double *)(v7 + 8) = a3;
  v8 = (id)objc_msgSend(*(id *)(*((_QWORD *)this + 3) + 8), "signatureWithDomain:type:subType:subtypeContext:detectedProcess:triggerThresholdValues:", CFSTR("Multitouch"), CFSTR("Plugin"), v8, 0, objc_msgSend((id)objc_msgSend(MEMORY[0x24BDD1760], "processInfo"), "processName"), 0);
  *(_QWORD *)(v7 + 16) = v8;
  if (!v8)
    goto LABEL_10;
  v9 = v8;
  v8 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
  *(_QWORD *)(v7 + 24) = v8;
  if (v8
    && (v8 = (id)MTABCLogger::_prepopulateSessionEvent((uint64_t)this, v7), (_DWORD)v8)
    && (*((_QWORD *)this + 2) || (v8 = (id)MTRegisterFullFrameCallback(), (_DWORD)v8)))
  {
    std::__tree<MTABCSessionHandler *>::__emplace_unique_key_args<MTABCSessionHandler *,MTABCSessionHandler * const&>((uint64_t **)this, (unint64_t *)v11, (uint64_t *)v11);
    return *(_QWORD *)v11;
  }
  else
  {
LABEL_10:
    MTABCLogger::_freeSession((uint64_t)v8, (id *)v7);
    return 0;
  }
}

void ___ZN11MTABCLogger10endSessionEP19MTABCSessionHandlerb_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  int v4;
  const char *v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v3 = MTLoggingPlugin();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 136315906;
    v5 = "";
    v6 = 2080;
    v7 = "";
    v8 = 2080;
    v9 = "endSession_block_invoke";
    v10 = 2114;
    v11 = a2;
    _os_log_impl(&dword_231071000, v3, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s ABC response: %{public}@", (uint8_t *)&v4, 0x2Au);
  }
}

void std::__tree<MTABCSessionHandler *>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<MTABCSessionHandler *>::destroy(a1, *a2);
    std::__tree<MTABCSessionHandler *>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t *std::__tree<MTABCSessionHandler *>::__emplace_unique_key_args<MTABCSessionHandler *,MTABCSessionHandler * const&>(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unint64_t v7;
  uint64_t **v8;
  unint64_t v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = v5[4];
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

uint64_t std::__tree<MTABCSessionHandler *>::__erase_unique<MTABCSessionHandler *>(uint64_t a1, unint64_t *a2)
{
  _QWORD *v2;
  unint64_t v3;
  uint64_t *v4;
  unint64_t v5;
  BOOL v6;
  _QWORD *v7;

  v2 = *(_QWORD **)(a1 + 8);
  if (!v2)
    return 0;
  v3 = *a2;
  v4 = (uint64_t *)(a1 + 8);
  do
  {
    v5 = v2[4];
    v6 = v5 >= v3;
    if (v5 >= v3)
      v7 = v2;
    else
      v7 = v2 + 1;
    if (v6)
      v4 = v2;
    v2 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t *)(a1 + 8) || v3 < v4[4])
    return 0;
  std::__tree<MTABCSessionHandler *>::__remove_node_pointer((uint64_t **)a1, v4);
  operator delete(v4);
  return 1;
}

uint64_t *std::__tree<MTABCSessionHandler *>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v5 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2)
    *a1 = v3;
  v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 == v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v13 = *(uint64_t **)(v12 + 8);
      v14 = *v13;
      *(_QWORD *)(v12 + 8) = *v13;
      if (v14)
        *(_QWORD *)(v14 + 16) = v12;
      v13[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
      *v13 = v12;
      *(_QWORD *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7)
        result = v7;
      v7 = *(uint64_t **)(*v7 + 8);
    }
    v15 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v15 + 24))
    {
      v16 = (uint64_t *)v7[1];
      if (!v16)
        goto LABEL_56;
LABEL_55:
      if (*((_BYTE *)v16 + 24))
      {
LABEL_56:
        *((_BYTE *)v15 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v22 = v15[1];
        *v7 = v22;
        if (v22)
          *(_QWORD *)(v22 + 16) = v7;
        v15[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        v16 = v7;
      }
      else
      {
        v15 = v7;
      }
      v23 = v15[2];
      *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v16 + 24) = 1;
      v24 = *(uint64_t **)(v23 + 8);
      v25 = *v24;
      *(_QWORD *)(v23 + 8) = *v24;
      if (v25)
        *(_QWORD *)(v25 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      *v24 = v23;
      goto LABEL_72;
    }
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_55;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v18 = v7[1];
    *(_QWORD *)v12 = v18;
    if (v18)
      *(_QWORD *)(v18 + 16) = v12;
    v7[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(_QWORD *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12)
      result = v7;
    v7 = *(uint64_t **)v12;
  }
  v19 = (_QWORD *)*v7;
  if (*v7 && !*((_BYTE *)v19 + 24))
    goto LABEL_68;
  v20 = (uint64_t *)v7[1];
  if (!v20 || *((_BYTE *)v20 + 24))
  {
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
    goto LABEL_49;
  }
  if (v19 && !*((_BYTE *)v19 + 24))
  {
LABEL_68:
    v20 = v7;
  }
  else
  {
    *((_BYTE *)v20 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v26 = *v20;
    v7[1] = *v20;
    if (v26)
      *(_QWORD *)(v26 + 16) = v7;
    v20[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
    *v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    v19 = v7;
  }
  v23 = v20[2];
  *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v19 + 24) = 1;
  v24 = *(uint64_t **)v23;
  v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
  *(_QWORD *)v23 = v27;
  if (v27)
    *(_QWORD *)(v27 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

uint64_t MTForceBehavior::GetNull(MTForceBehavior *this)
{
  if (MTForceBehavior::nullDispatchOnce != -1)
    dispatch_once(&MTForceBehavior::nullDispatchOnce, &__block_literal_global_3);
  return MTForceBehavior::nullForceBehavior;
}

double ___ZN15MTForceBehavior7GetNullEv_block_invoke()
{
  uint64_t v0;
  double result;

  v0 = operator new();
  *(_DWORD *)(v0 + 16) = 0;
  *(_QWORD *)v0 = 0;
  *(_QWORD *)(v0 + 5) = 0;
  result = 0.0;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_OWORD *)(v0 + 40) = 0u;
  *(_OWORD *)(v0 + 56) = 0u;
  *(_OWORD *)(v0 + 72) = 0u;
  *(_OWORD *)(v0 + 88) = 0u;
  *(_OWORD *)(v0 + 104) = 0u;
  *(_OWORD *)(v0 + 120) = 0u;
  *(_QWORD *)(v0 + 136) = 0;
  MTForceBehavior::nullForceBehavior = v0;
  return result;
}

void MTForceBehavior::MTForceBehavior(MTForceBehavior *this)
{
  *((_DWORD *)this + 4) = 0;
  *(_QWORD *)this = 0;
  *(_QWORD *)((char *)this + 5) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_QWORD *)this + 17) = 0;
}

{
  *((_DWORD *)this + 4) = 0;
  *(_QWORD *)this = 0;
  *(_QWORD *)((char *)this + 5) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_QWORD *)this + 17) = 0;
}

uint64_t MTForceBehavior::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
    *(_QWORD *)a1 = *(_QWORD *)a2;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a1 + 24), *(char **)(a2 + 24), *(_QWORD *)(a2 + 32), (uint64_t)(*(_QWORD *)(a2 + 32) - *(_QWORD *)(a2 + 24)) >> 2);
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a1 + 96), *(char **)(a2 + 96), *(_QWORD *)(a2 + 104), (uint64_t)(*(_QWORD *)(a2 + 104) - *(_QWORD *)(a2 + 96)) >> 2);
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a1 + 120), *(char **)(a2 + 120), *(_QWORD *)(a2 + 128), (uint64_t)(*(_QWORD *)(a2 + 128) - *(_QWORD *)(a2 + 120)) >> 2);
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a1 + 48), *(char **)(a2 + 48), *(_QWORD *)(a2 + 56), (uint64_t)(*(_QWORD *)(a2 + 56) - *(_QWORD *)(a2 + 48)) >> 2);
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a1 + 72), *(char **)(a2 + 72), *(_QWORD *)(a2 + 80), (uint64_t)(*(_QWORD *)(a2 + 80) - *(_QWORD *)(a2 + 72)) >> 2);
    *(_BYTE *)(a1 + 12) = *(_BYTE *)(a2 + 12);
  }
  return a1;
}

BOOL MTForceBehavior::behaviorEquals(MTForceBehavior *this, const MTForceBehavior *a2)
{
  float *v4;
  unint64_t v5;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unsigned int v18;

  if (*(_DWORD *)this != *(_DWORD *)a2
    || *((_DWORD *)this + 2) != *((_DWORD *)a2 + 2)
    || *((_DWORD *)this + 1) != *((_DWORD *)a2 + 1)
    || *((_DWORD *)this + 4) != *((_DWORD *)a2 + 4))
  {
    return 0;
  }
  v4 = (float *)*((_QWORD *)this + 3);
  v5 = *((_QWORD *)this + 4) - (_QWORD)v4;
  if ((int)(v5 >> 2) >= 1)
  {
    v6 = (float *)*((_QWORD *)a2 + 3);
    v7 = (v5 >> 2);
    while (*v4 == *v6)
    {
      ++v4;
      ++v6;
      if (!--v7)
        goto LABEL_9;
    }
    return 0;
  }
LABEL_9:
  v8 = *((_QWORD *)this + 12);
  v9 = *((_QWORD *)this + 13) - v8;
  if (v9)
  {
    v10 = 0;
    v11 = v9 >> 2;
    v12 = 1;
    while (*(_DWORD *)(v8 + 4 * v10) == *(_DWORD *)(*((_QWORD *)a2 + 12) + 4 * v10))
    {
      v10 = v12;
      v13 = v11 > v12++;
      if (!v13)
        goto LABEL_13;
    }
    return 0;
  }
LABEL_13:
  v14 = *((_QWORD *)this + 15);
  v15 = *((_QWORD *)this + 16) - v14;
  if (v15)
  {
    v16 = 0;
    v17 = v15 >> 2;
    v18 = 1;
    while (*(_DWORD *)(v14 + 4 * v16) == *(_DWORD *)(*((_QWORD *)a2 + 15) + 4 * v16))
    {
      v16 = v18;
      v13 = v17 > v18++;
      if (!v13)
        goto LABEL_17;
    }
    return 0;
  }
LABEL_17:
  if (std::operator!=[abi:ne180100]<int,std::allocator<int>>((uint64_t)this + 48, (uint64_t)a2 + 48)
    || std::operator!=[abi:ne180100]<int,std::allocator<int>>((uint64_t)this + 72, (uint64_t)a2 + 72))
  {
    return 0;
  }
  return *((unsigned __int8 *)this + 12) == *((unsigned __int8 *)a2 + 12);
}

BOOL std::operator!=[abi:ne180100]<int,std::allocator<int>>(uint64_t a1, uint64_t a2)
{
  const void *v2;
  size_t v4;
  const void *v5;

  v2 = *(const void **)a1;
  v4 = *(_QWORD *)(a1 + 8) - (_QWORD)v2;
  v5 = *(const void **)a2;
  return v4 != *(_QWORD *)(a2 + 8) - (_QWORD)v5 || memcmp(v2, v5, v4) != 0;
}

uint64_t MTForceBehavior::forceSourceFingerCount(uint64_t this)
{
  uint64_t v1;
  int v2;
  unsigned int v3;
  BOOL v4;

  v1 = this;
  LODWORD(this) = 0;
  v2 = *(_DWORD *)(v1 + 4);
  v3 = 16;
  do
  {
    if ((v2 & v3) != 0)
      this = (this + 1);
    else
      this = this;
    v4 = v3 >= 2;
    v3 >>= 1;
  }
  while (v4);
  return this;
}

uint64_t MTForceBehavior::whichButtonBehavior(MTForceBehavior *this)
{
  int v1;

  v1 = *(_DWORD *)this - 1;
  if (v1 > 0x10)
    return 0;
  else
    return dword_2310BE198[v1];
}

void MTForceBehavior::resizeThresholdLadder(MTForceBehavior *this, int a2)
{
  std::vector<float>::resize((uint64_t)this + 24, (2 * a2 - 2));
}

uint64_t MTForceBehavior::resizeToNumStages(MTForceBehavior *this, unsigned int a2)
{
  uint64_t v4;

  v4 = a2 - *((_DWORD *)this + 4);
  std::vector<float>::resize((uint64_t)this + 24, 2 * a2 - 2);
  std::vector<int>::resize((std::vector<int> *)this + 4, a2);
  std::vector<int>::resize((std::vector<int> *)this + 5, a2);
  *((_DWORD *)this + 4) = a2;
  return v4;
}

void std::vector<int>::resize(std::vector<int> *this, std::vector<int>::size_type __sz)
{
  std::vector<int>::size_type v2;

  v2 = this->__end_ - this->__begin_;
  if (__sz <= v2)
  {
    if (__sz < v2)
      this->__end_ = &this->__begin_[__sz];
  }
  else
  {
    std::vector<int>::__append(this, __sz - v2);
  }
}

BOOL MTForceBehavior::addStage(MTForceBehavior *a1, int a2, int a3, int a4, float a5, float a6)
{
  _BOOL8 result;
  uint64_t v13;

  if ((int)MTForceBehavior::resizeToNumStages(a1, a2 + 1) > 1)
    return 0;
  if (a2 >= 1)
  {
    v13 = *((_QWORD *)a1 + 3);
    *(float *)(v13 + 4 * (2 * a2 - 1)) = a5;
    *(float *)(v13 + 4 * (2 * a2 - 2)) = a6;
  }
  result = MTForceBehavior::isThresholdLadderMonotonic((_QWORD *)a1 + 3);
  if (result)
  {
    *(_DWORD *)(*((_QWORD *)a1 + 12) + 4 * a2) = a3;
    *(_DWORD *)(*((_QWORD *)a1 + 15) + 4 * a2) = a4;
    return 1;
  }
  return result;
}

BOOL MTForceBehavior::isThresholdLadderMonotonic(_QWORD *a1)
{
  unint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float *v7;

  v1 = a1[1] - *a1;
  if ((v1 & 4) != 0)
    return 0;
  v2 = 0;
  v3 = (v1 >> 2) - 1;
  v4 = v3;
  v5 = v3 & ~(v3 >> 31);
  do
  {
    v6 = v2;
    if (v5 == v2)
      break;
    v7 = (float *)(*a1 + 4 * v2++);
  }
  while (*v7 <= v7[1]);
  return v6 >= v4;
}

BOOL MTForceBehavior::addStage(MTForceBehavior *a1, int a2, uint64_t a3, float a4, float a5)
{
  return MTForceBehavior::addStage(a1, a2, a3, SHIDWORD(a3), a4, a5);
}

uint64_t MTForceBehavior::print(MTForceBehavior *this)
{
  int v2;
  unsigned int v3;
  BOOL v4;
  uint64_t result;
  uint64_t v6;
  unsigned int v7;
  unint64_t v8;
  unsigned int v9;
  uint64_t v10;

  v2 = 0;
  v3 = 16;
  do
  {
    if ((v3 & *((_DWORD *)this + 1)) != 0)
      ++v2;
    v4 = v3 > 1;
    v3 >>= 1;
  }
  while (v4);
  result = printf("MTForceBehavior type = %d sources = 0x%x fingers = %d\n", *(_DWORD *)this, *((_DWORD *)this + 1), v2);
  v6 = *((_QWORD *)this + 12);
  if ((unint64_t)(*((_QWORD *)this + 13) - v6) >= 5)
  {
    v7 = 0;
    v8 = 1;
    v9 = 1;
    do
    {
      v10 = *((_QWORD *)this + 3);
      if (v8 >= (unint64_t)(((*((_QWORD *)this + 4) - v10) >> 2) + 2) >> 1)
        break;
      result = printf("  Stage %d, Entry[thresh=%f waveform=%d], Exit[ thresh=%f waveform=%d]\n", v9, *(float *)(v10 + 4 * (v7 + 1)), *(_DWORD *)(v6 + 4 * v8), *(float *)(v10 + 4 * v7), *(_DWORD *)(*((_QWORD *)this + 15) + 4 * v8));
      v6 = *((_QWORD *)this + 12);
      v7 += 2;
      v8 = ++v9;
    }
    while (v9 < (unint64_t)((*((_QWORD *)this + 13) - v6) >> 2));
  }
  return result;
}

char *std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 2)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62)
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 1;
    if (v8 >> 1 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL)
      v11 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<float>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 2;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

void std::vector<int>::__append(std::vector<int> *this, std::vector<int>::size_type __n)
{
  std::__compressed_pair<int *> *p_end_cap;
  int *v5;
  int *value;
  int *end;
  std::vector<int>::pointer begin;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  int *v16;
  int *v17;
  int v18;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  v5 = value;
  end = p_end_cap[-1].__value_;
  if (__n <= value - end)
  {
    if (__n)
    {
      bzero(p_end_cap[-1].__value_, 4 * __n);
      end += __n;
    }
    this->__end_ = end;
  }
  else
  {
    begin = this->__begin_;
    v9 = (char *)end - (char *)this->__begin_;
    v10 = __n + (v9 >> 2);
    if (v10 >> 62)
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 2;
    v12 = (char *)v5 - (char *)begin;
    if (v12 >> 1 > v10)
      v10 = v12 >> 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
      v13 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, v13);
      begin = this->__begin_;
      end = this->__end_;
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[4 * v11];
    v16 = (int *)&v14[4 * v13];
    bzero(v15, 4 * __n);
    v17 = (int *)&v15[4 * __n];
    while (end != begin)
    {
      v18 = *--end;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    this->__begin_ = (std::vector<int>::pointer)v15;
    this->__end_ = v17;
    this->__end_cap_.__value_ = v16;
    if (begin)
      operator delete(begin);
  }
}

void MTForceBehaviorConfiguration::MTForceBehaviorConfiguration(MTForceBehaviorConfiguration *this)
{
  std::vector<std::vector<MTForceBehavior>>::vector(this, 6uLL);
}

{
  std::vector<std::vector<MTForceBehavior>>::vector(this, 6uLL);
}

uint64_t MTForceBehaviorConfiguration::addDefaultBehavior(MTForceBehaviorConfiguration *this, const MTForceBehavior *a2)
{
  unsigned int v4;
  uint64_t v5;
  unint64_t v6;
  MTForceBehavior *v7;
  _QWORD *v8;
  uint64_t result;

  v4 = MTForceBehavior::forceSourceFingerCount((uint64_t)a2);
  v5 = *(_QWORD *)this + 24 * v4;
  v7 = *(MTForceBehavior **)(v5 + 8);
  v6 = *(_QWORD *)(v5 + 16);
  v8 = (_QWORD *)(v5 + 8);
  if ((unint64_t)v7 >= v6)
  {
    result = std::vector<MTForceBehavior>::__push_back_slow_path<MTForceBehavior const&>((uint64_t *)(*(_QWORD *)this + 24 * v4), a2);
  }
  else
  {
    MTForceBehavior::MTForceBehavior(v7, a2);
    result = (uint64_t)v7 + 144;
    *v8 = (char *)v7 + 144;
  }
  *v8 = result;
  *(_DWORD *)(result - 136) = 1;
  *((_BYTE *)this + 24) = 1;
  return result;
}

void sub_2310B4958(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;

  *v2 = v1;
  _Unwind_Resume(a1);
}

uint64_t MTForceBehaviorConfiguration::pushBehavior(MTForceBehaviorConfiguration *this, const MTForceBehavior *a2)
{
  unsigned int v4;
  uint64_t v5;
  unint64_t v6;
  MTForceBehavior *v7;
  _QWORD *v8;
  uint64_t result;

  v4 = MTForceBehavior::forceSourceFingerCount((uint64_t)a2);
  v5 = *(_QWORD *)this + 24 * v4;
  v7 = *(MTForceBehavior **)(v5 + 8);
  v6 = *(_QWORD *)(v5 + 16);
  v8 = (_QWORD *)(v5 + 8);
  if ((unint64_t)v7 >= v6)
  {
    result = std::vector<MTForceBehavior>::__push_back_slow_path<MTForceBehavior const&>((uint64_t *)(*(_QWORD *)this + 24 * v4), a2);
  }
  else
  {
    MTForceBehavior::MTForceBehavior(v7, a2);
    result = (uint64_t)v7 + 144;
    *v8 = (char *)v7 + 144;
  }
  *v8 = result;
  *((_BYTE *)this + 24) = 1;
  return result;
}

void sub_2310B49E0(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;

  *v2 = v1;
  _Unwind_Resume(a1);
}

void MTForceBehaviorConfiguration::popBehavior(MTForceBehaviorConfiguration *this, const MTForceBehavior *a2)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;

  v4 = MTForceBehavior::forceSourceFingerCount((uint64_t)a2);
  v5 = *(_QWORD *)this;
  v6 = *(_QWORD *)this + 24 * v4;
  v8 = *(_QWORD *)(v6 + 8);
  v7 = (_QWORD *)(v6 + 8);
  if (MTForceBehavior::behaviorEquals(a2, (const MTForceBehavior *)(v8 - 144)))
  {
    v9 = v5 + 24 * v4 + 16;
    v10 = (_QWORD *)(*v7 - 144);
    std::allocator<MTForceBehavior>::destroy[abi:ne180100](v9, v10);
    *v7 = v10;
  }
  *((_BYTE *)this + 24) = 1;
}

void MTForceBehaviorConfiguration::clearBehaviors(MTForceBehaviorConfiguration *this)
{
  uint64_t i;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *j;

  for (i = 0; i != 6; ++i)
  {
    v3 = (uint64_t *)(*(_QWORD *)this + 24 * i);
    v4 = *v3;
    v7 = v3[1];
    v6 = v3 + 1;
    v5 = v7;
    if (v4 != v7)
    {
      v8 = *(_QWORD *)this + 24 * i + 16;
      do
      {
        std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,MTForceBehavior *,MTForceBehavior *,MTForceBehavior *,0>(v4 + 144, v5, v4);
        v5 = v9;
        for (j = (_QWORD *)*v6; j != (_QWORD *)v5; std::allocator<MTForceBehavior>::destroy[abi:ne180100](v8, j))
          j -= 18;
        *v6 = v5;
      }
      while (v4 != v5);
    }
  }
  *((_BYTE *)this + 24) = 1;
}

void MTForceBehaviorConfiguration::clearNonDefaultBehaviors(MTForceBehaviorConfiguration *this)
{
  uint64_t i;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *j;

  for (i = 0; i != 6; ++i)
  {
    v3 = (uint64_t *)(*(_QWORD *)this + 24 * i);
    v4 = *v3;
    v7 = v3[1];
    v6 = v3 + 1;
    v5 = v7;
    if (v4 != v7)
    {
      v8 = *(_QWORD *)this + 24 * i + 16;
      do
      {
        if (*(_DWORD *)(v4 + 8) == 1)
        {
          v4 += 144;
        }
        else
        {
          std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,MTForceBehavior *,MTForceBehavior *,MTForceBehavior *,0>(v4 + 144, v5, v4);
          v5 = v9;
          for (j = (_QWORD *)*v6; j != (_QWORD *)v5; std::allocator<MTForceBehavior>::destroy[abi:ne180100](v8, j))
            j -= 18;
          *v6 = v5;
        }
      }
      while (v4 != v5);
    }
  }
  *((_BYTE *)this + 24) = 1;
}

MTForceBehavior *MTForceBehaviorConfiguration::matchingBehaviorInStack(MTForceBehavior *result, MTForceBehavior **a2, int a3)
{
  MTForceBehavior *v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  BOOL v7;

  v3 = a2[1];
  if (v3 == *a2)
    return (MTForceBehavior *)MTForceBehavior::GetNull(result);
  v4 = 0;
  result = (MTForceBehavior *)((char *)v3 - 144);
  while (1)
  {
    v5 = *((_DWORD *)result + 2);
    v6 = 1;
    if (v5 != 2 && (v4 & (v5 != 1)) == 0)
    {
      v6 = v4;
      if ((*((_DWORD *)result + 1) & a3) != 0)
        break;
    }
    v4 = v6;
    v7 = result == *a2;
    result = (MTForceBehavior *)((char *)result - 144);
    if (v7)
      return (MTForceBehavior *)MTForceBehavior::GetNull(result);
  }
  return result;
}

MTForceBehavior *MTForceBehaviorConfiguration::firstFingerBehavior(MTForceBehaviorConfiguration *this)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3) < 2)
    return (MTForceBehavior *)MTForceBehavior::GetNull(this);
  else
    return MTForceBehaviorConfiguration::matchingBehaviorInStack(this, (MTForceBehavior **)(*(_QWORD *)this + 24), 32);
}

MTForceBehavior *MTForceBehaviorConfiguration::secondFingerBehavior(MTForceBehaviorConfiguration *this)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3) < 2)
    return (MTForceBehavior *)MTForceBehavior::GetNull(this);
  else
    return MTForceBehaviorConfiguration::matchingBehaviorInStack(this, (MTForceBehavior **)(*(_QWORD *)this + 24), 64);
}

MTForceBehavior *MTForceBehaviorConfiguration::collectiveBehavior(MTForceBehaviorConfiguration *this, int a2)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3) <= a2)
    return (MTForceBehavior *)MTForceBehavior::GetNull(this);
  else
    return MTForceBehaviorConfiguration::matchingBehaviorInStack(this, (MTForceBehavior **)(*(_QWORD *)this + 24 * a2), 128);
}

void MTForceClickHistory::MTForceClickHistory(MTForceClickHistory *this, float a2)
{
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  MTForceClickHistory::initHistory(this, a2);
}

void sub_2310B4D24(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  void *v4;
  void *v5;

  v4 = (void *)v1[4];
  if (v4)
  {
    v1[5] = v4;
    operator delete(v4);
  }
  v5 = *v2;
  if (*v2)
  {
    v1[2] = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void MTForceClickHistory::initHistory(MTForceClickHistory *this, float a2)
{
  int v3;
  void **v4;
  void **v5;
  float v6;
  float v7;
  char *v8;
  char *v9;
  unint64_t v10;
  float *v11;
  float *v12;
  float *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  float *v19;
  int v20;
  unint64_t v21;
  float *v22;
  float *v23;
  float *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  float *v30;
  int v31;

  v3 = 0;
  v4 = (void **)((char *)this + 8);
  *((_QWORD *)this + 2) = *((_QWORD *)this + 1);
  v5 = (void **)((char *)this + 32);
  *((_QWORD *)this + 5) = *((_QWORD *)this + 4);
  *(_QWORD *)this = 0;
  v6 = a2 * 550.0;
  v7 = a2 * 350.0;
  v8 = (char *)this + 24;
  v9 = (char *)this + 48;
  do
  {
    v11 = (float *)*((_QWORD *)this + 2);
    v10 = *((_QWORD *)this + 3);
    if ((unint64_t)v11 >= v10)
    {
      v13 = (float *)*v4;
      v14 = ((char *)v11 - (_BYTE *)*v4) >> 2;
      v15 = v14 + 1;
      if ((unint64_t)(v14 + 1) >> 62)
        std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
      v16 = v10 - (_QWORD)v13;
      if (v16 >> 1 > v15)
        v15 = v16 >> 1;
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL)
        v17 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v17 = v15;
      if (v17)
      {
        v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v8, v17);
        v13 = (float *)*((_QWORD *)this + 1);
        v11 = (float *)*((_QWORD *)this + 2);
      }
      else
      {
        v18 = 0;
      }
      v19 = (float *)&v18[4 * v14];
      *v19 = v6;
      v12 = v19 + 1;
      while (v11 != v13)
      {
        v20 = *((_DWORD *)v11-- - 1);
        *((_DWORD *)v19-- - 1) = v20;
      }
      *((_QWORD *)this + 1) = v19;
      *((_QWORD *)this + 2) = v12;
      *((_QWORD *)this + 3) = &v18[4 * v17];
      if (v13)
        operator delete(v13);
    }
    else
    {
      *v11 = v6;
      v12 = v11 + 1;
    }
    *((_QWORD *)this + 2) = v12;
    v22 = (float *)*((_QWORD *)this + 5);
    v21 = *((_QWORD *)this + 6);
    if ((unint64_t)v22 >= v21)
    {
      v24 = (float *)*v5;
      v25 = ((char *)v22 - (_BYTE *)*v5) >> 2;
      v26 = v25 + 1;
      if ((unint64_t)(v25 + 1) >> 62)
        std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
      v27 = v21 - (_QWORD)v24;
      if (v27 >> 1 > v26)
        v26 = v27 >> 1;
      if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFFCLL)
        v28 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v28 = v26;
      if (v28)
      {
        v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v9, v28);
        v24 = (float *)*((_QWORD *)this + 4);
        v22 = (float *)*((_QWORD *)this + 5);
      }
      else
      {
        v29 = 0;
      }
      v30 = (float *)&v29[4 * v25];
      *v30 = v7;
      v23 = v30 + 1;
      while (v22 != v24)
      {
        v31 = *((_DWORD *)v22-- - 1);
        *((_DWORD *)v30-- - 1) = v31;
      }
      *((_QWORD *)this + 4) = v30;
      *((_QWORD *)this + 5) = v23;
      *((_QWORD *)this + 6) = &v29[4 * v28];
      if (v24)
        operator delete(v24);
    }
    else
    {
      *v22 = v7;
      v23 = v22 + 1;
    }
    *((_QWORD *)this + 5) = v23;
    ++v3;
  }
  while (v3 != 3);
  *(float *)this = v6;
  *((float *)this + 1) = v7;
}

void MTForceClickHistory::~MTForceClickHistory(MTForceClickHistory *this)
{
  void *v2;
  void *v3;

  v2 = (void *)*((_QWORD *)this + 1);
  *((_QWORD *)this + 2) = v2;
  v3 = (void *)*((_QWORD *)this + 4);
  *((_QWORD *)this + 5) = v3;
  *(_QWORD *)this = 0;
  if (v3)
  {
    operator delete(v3);
    v2 = (void *)*((_QWORD *)this + 1);
  }
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
}

_QWORD *MTForceClickHistory::clearHistory(_QWORD *this)
{
  this[2] = this[1];
  this[5] = this[4];
  *this = 0;
  return this;
}

float MTForceClickHistory::updateForceArray(float a1, uint64_t a2, uint64_t a3)
{
  float *v5;
  float *v6;
  unint64_t v7;
  float *v8;
  int64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  float *v17;
  float *v18;
  uint64_t v19;
  char *v20;
  int v21;
  float v22;
  float *v24;
  float *v25;
  uint64_t v26;
  char v27;

  v5 = *(float **)a3;
  v6 = *(float **)(a3 + 8);
  v7 = (unint64_t)v6 - *(_QWORD *)a3;
  if (v7 >= 0x75)
  {
    v8 = *(float **)a3;
    do
    {
      v9 = (char *)v6 - (char *)(v5 + 1);
      if (v6 != v5 + 1)
      {
        memmove(v5, v5 + 1, (char *)v6 - (char *)(v5 + 1));
        v8 = *(float **)a3;
      }
      --v6;
      *(_QWORD *)(a3 + 8) = (char *)v5 + v9;
      v7 = (char *)v5 + v9 - (char *)v8;
      v5 = v8;
    }
    while (v7 > 0x74);
    v5 = v8;
  }
  v10 = *(_QWORD *)(a3 + 16);
  if ((unint64_t)v6 >= v10)
  {
    v12 = v7 >> 2;
    v13 = v10 - (_QWORD)v5;
    if (v13 >> 1 <= (v7 >> 2) + 1)
      v14 = v12 + 1;
    else
      v14 = v13 >> 1;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL)
      v15 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v15 = v14;
    v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a3 + 16, v15);
    v17 = *(float **)a3;
    v18 = *(float **)(a3 + 8);
    v5 = (float *)&v16[4 * v12];
    v20 = &v16[4 * v19];
    *v5 = a1;
    v11 = (uint64_t)(v5 + 1);
    while (v18 != v17)
    {
      v21 = *((_DWORD *)v18-- - 1);
      *((_DWORD *)v5-- - 1) = v21;
    }
    *(_QWORD *)a3 = v5;
    *(_QWORD *)(a3 + 8) = v11;
    *(_QWORD *)(a3 + 16) = v20;
    if (v17)
    {
      operator delete(v17);
      v5 = *(float **)a3;
    }
  }
  else
  {
    *v6 = a1;
    v11 = (uint64_t)(v6 + 1);
  }
  *(_QWORD *)(a3 + 8) = v11;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v24, v5, v11, (v11 - (uint64_t)v5) >> 2);
  v27 = -86;
  std::__sort<std::__less<float,float> &,float *>();
  if ((unint64_t)((char *)v25 - (char *)v24) >= 9)
  {
    v22 = (float)((float)(v24[(int)((unint64_t)((char *)v25 - (char *)v24) >> 2) / 2 - 1]
                        + v24[(int)((unint64_t)((char *)v25 - (char *)v24) >> 2) / 2])
                + v24[(int)((unint64_t)((char *)v25 - (char *)v24) >> 2) / 2 + 1])
        / 3.0;
LABEL_23:
    v25 = v24;
    operator delete(v24);
    return v22;
  }
  v22 = 0.0;
  if (v24)
    goto LABEL_23;
  return v22;
}

void sub_2310B513C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MTForceClickHistory::addDrag(MTForceClickHistory *this, float a2)
{
  *(float *)this = MTForceClickHistory::updateForceArray(a2, (uint64_t)this, (uint64_t)this + 8);
}

void MTForceClickHistory::addClick(MTForceClickHistory *this, float a2)
{
  *((float *)this + 1) = MTForceClickHistory::updateForceArray(a2, (uint64_t)this, (uint64_t)this + 32);
}

uint64_t MTForceManagement::MTForceManagement(uint64_t a1)
{
  MTForceBehavior::MTForceBehavior((MTForceBehavior *)(a1 + 32));
  std::vector<std::vector<MTForceBehavior>>::vector((_QWORD *)(a1 + 264), 6uLL);
  *(_QWORD *)(a1 + 456) = 0;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  std::vector<MTForceThresholding>::vector((_QWORD *)(a1 + 464), 0x20uLL);
  *(_QWORD *)(a1 + 504) = 0x100000001;
  MTForceClickHistory::MTForceClickHistory((MTForceClickHistory *)(a1 + 512), 1.0);
  *(_DWORD *)(a1 + 592) = 65537;
  *(_WORD *)(a1 + 596) = 0;
  MTParameterFactory::initForceThresholdQualifiers(a1 + 296);
  MTParameterFactory::initForceActuationQualifiers(a1 + 432);
  MTForceManagement::clearState(a1, 0);
  return a1;
}

{
  return MTForceManagement::MTForceManagement(a1);
}

void sub_2310B526C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  MTForceBehavior *v2;
  va_list va;

  va_start(va, a2);
  std::vector<MTForceThresholding>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::vector<std::vector<MTForceBehavior>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  MTForceBehavior::~MTForceBehavior(v2);
  _Unwind_Resume(a1);
}

void MTForceManagement::MTForceManagement(MTForceManagement *this)
{
  MTForceBehavior::MTForceBehavior((MTForceManagement *)((char *)this + 32));
  std::vector<std::vector<MTForceBehavior>>::vector((_QWORD *)this + 33, 6uLL);
  *((_QWORD *)this + 57) = 0;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  std::vector<MTForceThresholding>::vector((_QWORD *)this + 58, 0x20uLL);
  *((_QWORD *)this + 63) = 0x100000001;
  MTForceClickHistory::MTForceClickHistory((MTForceManagement *)((char *)this + 512), 1.0);
  *((_DWORD *)this + 148) = 65537;
  *((_WORD *)this + 298) = 0;
  MTParameterFactory::initForceThresholdQualifiers((uint64_t)this + 296);
  MTParameterFactory::initForceActuationQualifiers((uint64_t)this + 432);
  MTForceManagement::clearState((uint64_t)this, 0);
}

void sub_2310B5384(_Unwind_Exception *a1, uint64_t a2, ...)
{
  MTForceBehavior *v2;
  va_list va;

  va_start(va, a2);
  std::vector<MTForceThresholding>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::vector<std::vector<MTForceBehavior>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  MTForceBehavior::~MTForceBehavior(v2);
  _Unwind_Resume(a1);
}

void MTForceManagement::setForceThresholdQualifiers(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;

  *(_OWORD *)(a1 + 296) = *(_OWORD *)a2;
  v4 = *(_OWORD *)(a2 + 16);
  v5 = *(_OWORD *)(a2 + 32);
  v6 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 344) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 360) = v6;
  *(_OWORD *)(a1 + 312) = v4;
  *(_OWORD *)(a1 + 328) = v5;
  v7 = *(_OWORD *)(a2 + 80);
  v8 = *(_OWORD *)(a2 + 96);
  v9 = *(_OWORD *)(a2 + 112);
  *(_QWORD *)(a1 + 424) = *(_QWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 392) = v8;
  *(_OWORD *)(a1 + 408) = v9;
  *(_OWORD *)(a1 + 376) = v7;
  v10 = 472;
  v11 = 31;
  do
  {
    MTForceThresholding::setForceThresholdQualifiers(*(_QWORD *)(a1 + 464) + v10, a2);
    v10 += 472;
    --v11;
  }
  while (v11);
}

void MTForceManagement::setForceActuationQualifiers(uint64_t a1, _OWORD *a2)
{
  __int128 v4;
  NSObject *v5;
  const char *v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  double v25;
  __int16 v26;
  double v27;
  __int16 v28;
  double v29;
  __int16 v30;
  double v31;
  __int16 v32;
  double v33;
  __int16 v34;
  double v35;
  __int16 v36;
  double v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v4 = a2[1];
  *(_OWORD *)(a1 + 432) = *a2;
  *(_OWORD *)(a1 + 448) = v4;
  v5 = MTLoggingPlugin();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    if (*(_BYTE *)(a1 + 460))
      v6 = "ON";
    else
      v6 = "off";
    v7 = *(float *)(a1 + 432);
    v8 = *(float *)(a1 + 436);
    v9 = *(float *)(a1 + 448);
    v10 = *(float *)(a1 + 452);
    v11 = *(float *)(a1 + 440);
    v12 = *(float *)(a1 + 444);
    v13 = *(float *)(a1 + 456);
    v16 = 136317698;
    v17 = "[Debug] ";
    v18 = 2080;
    v19 = "";
    v20 = 2080;
    v21 = "setForceActuationQualifiers";
    v22 = 2082;
    v23 = v6;
    v24 = 2048;
    v25 = v7;
    v26 = 2048;
    v27 = v8;
    v28 = 2048;
    v29 = v9;
    v30 = 2048;
    v31 = v10;
    v32 = 2048;
    v33 = v11;
    v34 = 2048;
    v35 = v12;
    v36 = 2048;
    v37 = v13;
    _os_log_impl(&dword_231071000, v5, OS_LOG_TYPE_DEBUG, "[HID] [MT] %s%s%s ForceActuationQualifiers changed  adapt:%{public}s forcespeed:%f stengthMemory:%f strengthFloor:%f strengthAreaGain:%f timedilationMemory:%f timeAreaGin:%f strengthGain:%f", (uint8_t *)&v16, 0x70u);
  }
  v14 = 472;
  v15 = 31;
  do
  {
    MTForceThresholding::setForceActuationQualifiers(*(_QWORD *)(a1 + 464) + v14, (uint64_t)a2);
    v14 += 472;
    --v15;
  }
  while (v15);
}

void MTForceManagement::setDisableClickWaveformAdaptation(MTForceManagement *this, char a2)
{
  char *v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (char *)this + 432;
  *((_BYTE *)this + 460) = a2 ^ 1;
  v4 = 472;
  v5 = 31;
  do
  {
    MTForceThresholding::setForceActuationQualifiers(*((_QWORD *)this + 58) + v4, (uint64_t)v3);
    v4 += 472;
    --v5;
  }
  while (v5);
}

uint64_t MTForceManagement::setDisableForceThresholdAdaptation(uint64_t this, char a2)
{
  _BYTE *v2;
  uint64_t v3;

  v2 = (_BYTE *)(*(_QWORD *)(this + 464) + 896);
  v3 = 31;
  do
  {
    *v2 = a2;
    v2 += 472;
    --v3;
  }
  while (v3);
  return this;
}

void MTForceManagement::setFirstStageClickPreference(uint64_t a1, unsigned int a2)
{
  float ClickThresholdMultiplier;
  uint64_t v5;
  uint64_t v6;

  if (*(_DWORD *)(a1 + 504) != a2)
  {
    ClickThresholdMultiplier = MTForceThresholding::getClickThresholdMultiplier(*(_QWORD *)(a1 + 464), a2);
    MTForceClickHistory::initHistory((MTForceClickHistory *)(a1 + 512), ClickThresholdMultiplier);
  }
  *(_DWORD *)(a1 + 504) = a2;
  v5 = *(_QWORD *)(a1 + 464) + 336;
  v6 = -15104;
  do
  {
    *(_DWORD *)(v5 + v6 + 15104) = a2;
    v6 += 472;
  }
  while (v6);
}

uint64_t MTForceManagement::setSecondStageClickPreference(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;

  *(_DWORD *)(result + 508) = a2;
  v2 = *(_QWORD *)(result + 464) + 340;
  v3 = -15104;
  do
  {
    *(_DWORD *)(v2 + v3 + 15104) = a2;
    v3 += 472;
  }
  while (v3);
  return result;
}

uint64_t MTForceManagement::whichForceButtonActivated(MTForceManagement *this)
{
  int v1;
  uint64_t v2;

  if (*(_BYTE *)this
    && (v1 = *((_DWORD *)this + 64), v2 = *((_QWORD *)this + 58), *(int *)(v2 + 472 * v1 + 324) >= 1))
  {
    return MTForceBehavior::whichButtonBehavior((MTForceBehavior *)(v2 + 472 * v1 + 176));
  }
  else
  {
    return 0;
  }
}

BOOL MTForceManagement::isForceButtonActivated(MTForceManagement *this)
{
  return (int)MTForceManagement::whichForceButtonActivated(this) > 0;
}

double MTForceManagement::constructForceEvent@<D0>(MTForceManagement *this@<X0>, const MTPathStates *a2@<X3>, int a3@<W1>, int a4@<W2>, uint64_t a5@<X8>)
{
  uint64_t v8;
  _DWORD *v9;
  _DWORD *v10;
  uint64_t v11;
  const MTForceFilter *v12;
  const MTParserPath *v13;
  float v14;
  float v15;
  float v16;
  int v17;
  float v18;
  float v19;
  _DWORD *v20;
  float v21;
  float v22;
  int v23;
  BOOL v24;
  int v25;
  int v26;
  int v27;
  float v28;
  float Release;
  float Activation;
  unint64_t v31;
  uint64_t v32;
  float v33;
  int v34;
  double v35;
  double v36;
  double v37;
  double v38;
  float v39;
  int v40;
  int v41;
  int v42;
  double v43;
  double v44;
  double result;
  MTForceBehavior *v46;

  v8 = *((_QWORD *)this + 58);
  v9 = (_DWORD *)(v8 + 472 * a3);
  v10 = v9 + 81;
  *(_QWORD *)((char *)this + 220) = *(_QWORD *)(v9 + 81);
  v11 = *((_QWORD *)a2 + 35);
  v12 = (const MTForceFilter *)(v11 + 600 * a4 + 296);
  v13 = (const MTParserPath *)(v11 + 600 * a3);
  v14 = MTForceThresholding::preReleaseProgress((MTForceThresholding *)v9, v12, v13);
  v15 = MTForceThresholding::preActivationProgress((MTForceThresholding *)v9, v12, v13);
  v16 = MTForceThresholding::postActivationProgress((MTForceThresholding *)v9, v12, v13);
  v17 = *((_DWORD *)this + 55);
  v18 = 0.0;
  if (v17 == *((_DWORD *)this + 56) && v9[44] != 11)
    v18 = *((float *)this + 85);
  v46 = (MTForceBehavior *)(v9 + 44);
  v19 = (float)(v14 * (float)(1.0 - v18)) + (float)(v18 * *((float *)this + 61));
  v20 = v9 + 82;
  v21 = (float)(v15 * (float)(1.0 - v18)) + (float)(v18 * *((float *)this + 62));
  *((float *)this + 61) = v19;
  *((float *)this + 62) = v21;
  v22 = (float)(v16 * (float)(1.0 - v18)) + (float)(v18 * *((float *)this + 63));
  *((float *)this + 63) = v22;
  v23 = *((_DWORD *)this + 44);
  v24 = v23 == 8 || v23 == 2;
  if (v24)
    v25 = 16;
  else
    v25 = 0;
  if (v24)
    v26 = 8;
  else
    v26 = 2;
  if (v17 <= 0)
    v27 = v25;
  else
    v27 = v26;
  *((_DWORD *)this + 44) = v27;
  v28 = *((float *)this + 107);
  Release = MTForceThresholding::thresholdForNextRelease((MTForceThresholding *)v9, v12, v13);
  Activation = MTForceThresholding::thresholdForNextActivation((MTForceThresholding *)v9, v12, v13);
  v31 = *((unsigned int *)this + 55);
  v32 = *(_QWORD *)(v8 + 472 * a3 + 432);
  v33 = 0.0;
  if (v31 < (*(_QWORD *)(v8 + 472 * a3 + 440) - v32) >> 2)
    v33 = *(float *)(v32 + 4 * v31);
  if (*v10 == *v20)
  {
    v34 = 0;
  }
  else if ((int)v31 > *((_DWORD *)this + 56))
  {
    v34 = 1;
  }
  else
  {
    v34 = 2;
  }
  v35 = (float)(Activation / v28);
  if ((v31 + 1) >= *(_DWORD *)(v8 + 472 * a3 + 192))
    v36 = 1.0;
  else
    v36 = v35;
  if ((int)v31 >= 1)
    v37 = (float)(Release / v28);
  else
    v37 = 0.0;
  v38 = (float)(v33 / v28);
  v39 = v21 - v19;
  v40 = *(_DWORD *)v46;
  v41 = MTForceBehavior::forceSourceFingerCount((uint64_t)v46);
  v42 = *((_DWORD *)this + 55);
  if ((int)v31 <= 0)
    v43 = 0.0;
  else
    v43 = v38;
  v44 = fmax(fmin((float)(*(float *)(v8 + 472 * a3 + 380) / *(float *)(v8 + 472 * a3 + 140)), 1.0), 0.0);
  *(_DWORD *)a5 = v27;
  *(_DWORD *)(a5 + 4) = v40;
  *(_DWORD *)(a5 + 8) = v41;
  *(float *)(a5 + 12) = v39;
  *(_DWORD *)(a5 + 16) = v42;
  *(float *)(a5 + 20) = v22;
  *(float *)&v44 = v44;
  *(_DWORD *)(a5 + 24) = v42;
  *(_DWORD *)(a5 + 28) = v34;
  *(double *)(a5 + 32) = v36;
  *(double *)(a5 + 40) = v43;
  result = *(float *)&v44;
  *(double *)(a5 + 48) = v37;
  *(double *)(a5 + 56) = *(float *)&v44;
  *(_QWORD *)(a5 + 64) = 0;
  return result;
}

void MTForceManagement::updateStatusVariablesFromForceEvent(uint64_t a1, int a2, int *a3, MTPathStates *this)
{
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  int v9;
  uint64_t v10;
  int v11;
  BOOL v12;

  v6 = *(_QWORD *)(a1 + 464);
  v7 = v6 + 472 * a2;
  *(_QWORD *)&v8 = *(_QWORD *)(v7 + 344);
  *((_QWORD *)&v8 + 1) = *(_QWORD *)(v7 + 360);
  *(_OWORD *)(a1 + 228) = v8;
  v9 = *a3;
  if (*a3 == 2)
    *(_DWORD *)(a1 + 212) = *(_DWORD *)(a1 + 180);
  if (a3[4])
  {
    v10 = v6 + 472 * a2;
    *(_DWORD *)(a1 + 180) = *(_DWORD *)(v10 + 332);
    *(_DWORD *)(a1 + 184) = *(_DWORD *)(v10 + 376);
    *(double *)(a1 + 192) = *(double *)(v10 + 416) - *(double *)(v10 + 408);
    *(_DWORD *)(a1 + 208) = *(_DWORD *)(v10 + 400);
  }
  if (*(_DWORD *)(a1 + 220) == 1 && !*(_DWORD *)(a1 + 224))
  {
    *(float *)(a1 + 200) = MTPathStates::getPrePixelatedPositionFromPostPixelatedPosition(this, a2);
    *(_DWORD *)(a1 + 204) = v11;
    v9 = *a3;
  }
  if (v9 == 16)
  {
    if (*(float *)(a1 + 208) <= *(float *)(a1 + 416))
    {
      if (*(_DWORD *)(a1 + 180) == 1 && *(_DWORD *)(a1 + 212) == 1 && a3[2] == 1)
        *(float *)(a1 + 516) = MTForceClickHistory::updateForceArray(*(float *)(a1 + 184), a1, a1 + 544);
    }
    else
    {
      *(float *)(a1 + 512) = MTForceClickHistory::updateForceArray(*(float *)(a1 + 184), a1, a1 + 520);
    }
  }
  v12 = a3[1] == 11 && a3[4] != 0;
  *(_BYTE *)(a1 + 3) = v12;
}

uint64_t MTForceManagement::appendForceEvent(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v4;
  BOOL v5;
  uint64_t v7;
  uint64_t v8;
  char v9;

  v4 = *(_DWORD *)a3;
  v5 = *(_DWORD *)a3 != *(_DWORD *)(result + 568)
    || *(_DWORD *)(a3 + 4) != *(_DWORD *)(result + 572)
    || *(_DWORD *)(a3 + 8) != *(_DWORD *)(result + 576)
    || vabds_f32(*(float *)(a3 + 12), *(float *)(result + 580)) > 0.001
    || *(_DWORD *)(a3 + 16) != *(_DWORD *)(result + 584)
    || vabds_f32(*(float *)(a3 + 20), *(float *)(result + 588)) > 0.001;
  if (v4 == 2 || v4 == 16)
    goto LABEL_13;
  v9 = !v5;
  if (v4 < 1)
    v9 = 1;
  if ((v9 & 1) == 0)
  {
LABEL_13:
    v7 = result + 568;
    result = MTAppendForceGestureEvent();
    v8 = *(_QWORD *)(a3 + 16);
    *(_OWORD *)v7 = *(_OWORD *)a3;
    *(_QWORD *)(v7 + 16) = v8;
  }
  return result;
}

void MTForceManagement::appendForceStageEvent()
{
  uint64_t VendorDefinedEvent;
  const void *v1;

  IOHIDEventGetTimeStamp();
  VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
  if (VendorDefinedEvent)
  {
    v1 = (const void *)VendorDefinedEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
}

double MTForceManagement::constructThresholdInfo@<D0>(MTForceManagement *this@<X0>, const MTPathStates *a2@<X3>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v4;
  int v5;
  double result;

  *(_QWORD *)a4 = *(_QWORD *)((char *)this + 228);
  v4 = *((_QWORD *)a2 + 35) + 600 * a3;
  v5 = *(_DWORD *)(v4 + 304);
  *(_DWORD *)(a4 + 8) = *(_DWORD *)(v4 + 336);
  *(_DWORD *)(a4 + 12) = v5;
  result = *(double *)((char *)this + 236);
  *(double *)(a4 + 16) = result;
  return result;
}

int32x2_t MTForceManagement::constructClickInfo@<D0>(uint64_t a1@<X0>, uint64_t a2@<X4>, uint64_t a3@<X8>)
{
  float v3;
  int32x2_t result;

  *(_QWORD *)a3 = *(_QWORD *)(a2 + 4);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 180);
  v3 = *(double *)(a1 + 192);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a1 + 184);
  *(float *)(a3 + 16) = v3;
  *(_DWORD *)(a3 + 20) = *(_DWORD *)(a1 + 208);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(a1 + 212);
  result = vrev64_s32(*(int32x2_t *)(a1 + 512));
  *(int32x2_t *)(a3 + 28) = result;
  return result;
}

void MTForceManagement::appendThresholdInfo()
{
  uint64_t VendorDefinedEvent;
  const void *v1;

  IOHIDEventGetTimeStamp();
  VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
  if (VendorDefinedEvent)
  {
    v1 = (const void *)VendorDefinedEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
}

void MTForceManagement::appendClickInfo()
{
  uint64_t VendorDefinedEvent;
  const void *v1;

  IOHIDEventGetTimeStamp();
  VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
  if (VendorDefinedEvent)
  {
    v1 = (const void *)VendorDefinedEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
}

BOOL MTForceManagement::actuateForceAndHIDEvents(uint64_t a1, const MTPathStates *a2, CFDictionaryRef *this, uint64_t a4, char a5)
{
  unsigned int v9;
  int v10;
  NSObject *v11;
  _BOOL8 result;
  __int128 v13;
  int v14;
  _OWORD v15[4];
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;

  if (MTActuatorManagement::getActuatorRef((MTActuatorManagement *)this)
    && *(_BYTE *)(a1 + 594)
    && *(_BYTE *)(a1 + 595))
  {
    if ((a5 & 1) == 0)
      MTForceManagement::actuateOnStageChanges((MTForceManagement *)a1, a2, this);
    if (*(_BYTE *)a1)
    {
      v9 = *(_DWORD *)(a1 + 256);
      if (v9)
        goto LABEL_8;
    }
    else
    {
      v9 = MTForceManagement::strongestProgressPathID((MTForceManagement *)a1, a2, 0);
      if (*(_DWORD *)(a1 + 256))
      {
LABEL_8:
        v10 = MTForceManagement::strongestForcePathID((MTForceManagement *)a1, a2, 0);
        if ((v9 & 0x80000000) != 0)
          return *(unsigned __int8 *)(a1 + 1) != *(unsigned __int8 *)(a1 + 2);
        goto LABEL_14;
      }
    }
    v10 = 0;
    if ((v9 & 0x80000000) != 0)
      return *(unsigned __int8 *)(a1 + 1) != *(unsigned __int8 *)(a1 + 2);
LABEL_14:
    *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v29 = v13;
    v30 = v13;
    v27 = v13;
    v28 = v13;
    v25 = v13;
    v26 = v13;
    v23 = v13;
    v24 = v13;
    v22 = v13;
    MTForceBehavior::MTForceBehavior((MTForceBehavior *)&v22, (const MTForceBehavior *)(*(_QWORD *)(a1 + 464) + 472 * v9 + 176));
    v19 = xmmword_2310BE200;
    v20 = unk_2310BE210;
    v21 = -1;
    v17 = xmmword_2310BE1E0;
    v18 = unk_2310BE1F0;
    MTForceManagement::constructForceEvent((MTForceManagement *)a1, a2, v9, v10, (uint64_t)&v17);
    v15[2] = v19;
    v15[3] = v20;
    v16 = v21;
    v15[0] = v17;
    v15[1] = v18;
    MTForceManagement::updateStatusVariablesFromForceEvent(a1, v9, (int *)v15, a2);
    if (!*(_BYTE *)(a1 + 596) || (v14 = *(_DWORD *)(a1 + 568), v14 == 8) || v14 == 2)
      MTForceManagement::appendForceStageEvent();
    if (*(_BYTE *)(a1 + 216))
    {
      if (*(_DWORD *)(a1 + 220) != *(_DWORD *)(a1 + 224))
        MTForceManagement::appendThresholdInfo();
      if ((_DWORD)v17 == 16)
        MTForceManagement::appendClickInfo();
    }
    if (*((_QWORD *)&v29 + 1))
    {
      *(_QWORD *)&v30 = *((_QWORD *)&v29 + 1);
      operator delete(*((void **)&v29 + 1));
    }
    if ((_QWORD)v28)
    {
      *((_QWORD *)&v28 + 1) = v28;
      operator delete((void *)v28);
    }
    if (*((_QWORD *)&v26 + 1))
    {
      *(_QWORD *)&v27 = *((_QWORD *)&v26 + 1);
      operator delete(*((void **)&v26 + 1));
    }
    if ((_QWORD)v25)
    {
      *((_QWORD *)&v25 + 1) = v25;
      operator delete((void *)v25);
    }
    if (*((_QWORD *)&v23 + 1))
    {
      *(_QWORD *)&v24 = *((_QWORD *)&v23 + 1);
      operator delete(*((void **)&v23 + 1));
    }
    return *(unsigned __int8 *)(a1 + 1) != *(unsigned __int8 *)(a1 + 2);
  }
  v11 = MTLoggingPlugin();
  result = os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)result)
  {
    MTForceManagement::actuateForceAndHIDEvents((MTActuatorManagement *)this, a1, v11);
    return 0;
  }
  return result;
}

void sub_2310B60AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MTForceBehavior::~MTForceBehavior((MTForceBehavior *)(v1 - 192));
  _Unwind_Resume(a1);
}

uint64_t MTActuatorManagement::getActuatorRef(MTActuatorManagement *this)
{
  uint64_t result;
  io_registry_entry_t Service;

  result = *((_QWORD *)this + 1);
  if (!result)
  {
    result = MTDeviceGetMTActuator();
    *((_QWORD *)this + 1) = result;
    if (result)
    {
      if ((MTActuatorIsOpen() & 1) == 0)
        MTActuatorOpen();
      Service = MTActuatorGetService();
      IORegistryEntryGetRegistryEntryID(Service, (uint64_t *)this + 4);
      CFRetain(*((CFTypeRef *)this + 1));
      return *((_QWORD *)this + 1);
    }
  }
  return result;
}

uint64_t MTForceManagement::actuateOnStageChanges(MTForceManagement *this, const MTPathStates *a2, CFDictionaryRef *a3)
{
  uint64_t result;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  double v13;
  float v14;
  float v15;
  float v16;

  *((_BYTE *)this + 2) = *((_BYTE *)this + 1);
  result = MTForceManagement::whichForceButtonActivated(this);
  *((_BYTE *)this + 1) = (_DWORD)result != 0;
  if (*(_BYTE *)this)
  {
    v7 = *((_DWORD *)this + 64);
    v8 = *((_QWORD *)this + 58);
    v9 = v8 + 472 * v7;
    v10 = *(_DWORD *)(v9 + 324);
    v11 = *(_DWORD *)(v9 + 328);
    if (v10 != v11)
    {
      v12 = *((unsigned __int8 *)this + 4);
      v13 = *((double *)a2 + 1);
      v14 = *((float *)this + 2);
      *((_BYTE *)this + 4) = v10 < v11;
      if (v10 < v11)
      {
        *((double *)this + 2) = v13;
        result = MTForceBehavior::operator=((uint64_t)this + 32, v8 + 472 * v7 + 176);
        if (!v12 || (v15 = v13 - v14, v15 > 0.2))
        {
          MTForceManagement::actuateThresholderPath(this, a3, *((_DWORD *)this + 64));
          result = MTForceThresholding::actuationWaveformID((MTForceThresholding *)(*((_QWORD *)this + 58)
                                                                                  + 472 * *((int *)this + 64)));
          if ((_DWORD)result)
          {
            v16 = *((double *)a2 + 1);
            *((float *)this + 2) = v16;
          }
        }
      }
      else
      {
        *((double *)this + 3) = v13;
        return MTForceManagement::actuateThresholderPath(this, a3, v7);
      }
    }
  }
  return result;
}

uint64_t MTForceManagement::strongestProgressPathID(MTForceManagement *this, const MTPathStates *a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  float v9;
  uint64_t v10;
  MTForceThresholding *v11;
  MTForceThresholding *v12;
  int v13;
  float v14;
  BOOL v15;
  BOOL v16;

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0.0;
  v10 = 0xFFFFFFFFLL;
  do
  {
    v11 = (MTForceThresholding *)(*((_QWORD *)this + 58) + v6);
    if (*((_DWORD *)v11 + 44)
      && MTForceThresholding::fingersMatchBehavior(v11, a2, v7)
      && (!a3 || v7 && v7 != *((_DWORD *)this + 64)))
    {
      v12 = (MTForceThresholding *)(*((_QWORD *)this + 58) + v6);
      v13 = (*((_DWORD *)v12 + 45) >> 7) & 1;
      v14 = MTForceThresholding::rescaleForceAsLadderProgress(v12, a2);
      v15 = v14 <= 0.0 || v13 <= v8;
      if (!v15 || (v14 > v9 ? (v16 = v13 < v8) : (v16 = 1), !v16))
      {
        v9 = v14;
        v10 = v7;
        v8 = v13;
      }
    }
    ++v7;
    v6 += 472;
  }
  while (v7 != 32);
  return v10;
}

uint64_t MTForceManagement::strongestForcePathID(MTForceManagement *this, const MTPathStates *a2, int a3)
{
  uint64_t v6;
  float v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v6 = 0;
  v7 = 0.0;
  v8 = 1;
  v9 = 472;
  v10 = 936;
  do
  {
    if (MTForceThresholding::fingersMatchBehavior((MTForceThresholding *)(*((_QWORD *)this + 58) + v9), a2, v8)&& (!a3 || v8 != *((_DWORD *)this + 64)))
    {
      v11 = *((_QWORD *)a2 + 35);
      if (*(float *)(v11 + v10) <= v7)
      {
        v6 = v6;
      }
      else
      {
        v7 = *(float *)(v11 + v10);
        v6 = v8;
      }
    }
    ++v8;
    v9 += 472;
    v10 += 600;
  }
  while (v8 != 32);
  return v6;
}

uint64_t MTForceManagement::actuateThresholderPath(MTForceManagement *this, CFDictionaryRef *a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float v8;
  double v9;
  double v10;
  uint64_t v11;
  int v12;

  v5 = *((_QWORD *)this + 58);
  if (a3)
    v6 = 492;
  else
    v6 = 488;
  if (a3)
    v7 = 500;
  else
    v7 = 496;
  if (*((_BYTE *)this + 460) && !*(_DWORD *)(v5 + 472 * a3 + 328) && *(int *)(v5 + 472 * a3 + 324) >= 1)
  {
    v8 = *((float *)this + 112);
    v9 = (float)(*(float *)((char *)this + v6) - v8);
    v10 = v8;
    *(float *)&v9 = v9 / (1.0 - v10);
    v11 = v5 + 472 * a3;
    *(float *)&v9 = (float)(*((float *)this + 109) * *(float *)&v9)
                  + (1.0 - *((float *)this + 109)) * *(float *)(v11 + 368);
    *(float *)&v9 = v10 + (1.0 - v10) * *(float *)&v9;
    *(_DWORD *)((char *)this + v6) = LODWORD(v9);
    *(float *)&v9 = (float)(*((float *)this + 110) * *(float *)((char *)this + v7))
                  + (1.0 - *((float *)this + 110)) * *(float *)(v11 + 372);
    *(_DWORD *)((char *)this + v7) = LODWORD(v9);
  }
  v12 = MTForceThresholding::actuationWaveformID((MTForceThresholding *)(v5 + 472 * a3));
  return MTActuatorManagement::actuateWaveformID(a2, v12, *(float *)((char *)this + v6), *(float *)((char *)this + v7));
}

uint64_t MTActuatorManagement::getActuationOptions(uint64_t a1, unsigned int a2, int a3)
{
  unsigned int v3;

  if (a2 > 2)
    v3 = 0;
  else
    v3 = dword_2310BE228[a2];
  if (a3)
    return v3 | 8;
  else
    return v3;
}

uint64_t MTActuatorManagement::actuateWaveformID(CFDictionaryRef *this, int a2, float a3, float a4)
{
  const void *v5;
  const __CFData *Value;
  const __CFData *v7;

  v5 = (const void *)a2;
  kdebug_trace();
  if (*((_BYTE *)this + 24) && MTActuatorManagement::getActuatorRef((MTActuatorManagement *)this))
  {
    Value = (const __CFData *)CFDictionaryGetValue(this[2], v5);
    if (Value)
    {
      v7 = Value;
      CFDataGetBytePtr(Value);
      CFDataGetLength(v7);
      MTActuatorManagement::getActuatorRef((MTActuatorManagement *)this);
      MTActuatorSetReport();
    }
    else
    {
      MTActuatorManagement::getActuatorRef((MTActuatorManagement *)this);
      MTActuatorActuate();
    }
  }
  return 1;
}

uint64_t MTForceManagement::clearState(uint64_t this, char a2)
{
  uint64_t v2;
  MTForceBehavior *v8;
  uint64_t Null;
  uint64_t v10;
  uint64_t v11;
  BOOL *v12;
  uint64_t v13;

  v2 = this;
  if ((a2 & 1) != 0 || !*(_BYTE *)this || !*(_BYTE *)(this + 597))
  {
    *(_WORD *)(this + 1) = 0;
    MTForceManagement::primeBasicBehaviors((MTForceThresholding **)this, 0);
    __asm { FMOV            V0.4S, #1.0 }
    *(_OWORD *)(v2 + 488) = _Q0;
    *(_BYTE *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
    *(_QWORD *)(v2 + 16) = 0;
    *(_QWORD *)(v2 + 24) = 0;
    Null = MTForceBehavior::GetNull(v8);
    MTForceBehavior::operator=(v2 + 32, Null);
    *(_DWORD *)(v2 + 184) = 0;
    *(_BYTE *)(v2 + 3) = 0;
    *(_QWORD *)(v2 + 176) = 0;
    *(_QWORD *)(v2 + 200) = 0;
    *(_QWORD *)(v2 + 208) = 0;
    *(_QWORD *)(v2 + 192) = 0;
    *(_BYTE *)(v2 + 216) = 0;
    *(_OWORD *)(v2 + 220) = 0u;
    *(_OWORD *)(v2 + 236) = 0u;
    *(_DWORD *)(v2 + 252) = 0;
    *(_BYTE *)(v2 + 460) = CFPreferencesGetAppBooleanValue(CFSTR("DisableClickWaveformAdaptation"), CFSTR("com.apple.MultitouchSupport"), 0) == 0;
    v10 = 31;
    v11 = 472;
    do
    {
      MTForceThresholding::setForceActuationQualifiers(*(_QWORD *)(v2 + 464) + v11, v2 + 432);
      v11 += 472;
      --v10;
    }
    while (v10);
    this = CFPreferencesGetAppBooleanValue(CFSTR("DisableForceThresholdAdaptation"), CFSTR("com.apple.MultitouchSupport"), 0);
    v12 = (BOOL *)(*(_QWORD *)(v2 + 464) + 896);
    v13 = 31;
    do
    {
      *v12 = (_DWORD)this != 0;
      v12 += 472;
      --v13;
    }
    while (v13);
  }
  return this;
}

void MTForceManagement::primeBasicBehaviors(MTForceThresholding **this, int a2)
{
  MTForceBehavior *v4;
  MTForceBehavior *FingerBehavior;
  uint64_t v6;
  uint64_t v7;

  MTForceManagement::disableAllThresholders((MTForceManagement *)this);
  v4 = MTForceBehaviorConfiguration::collectiveBehavior((MTForceBehaviorConfiguration *)(this + 33), a2);
  MTForceThresholding::setForceBehavior(this[58], v4, 0);
  FingerBehavior = MTForceBehaviorConfiguration::firstFingerBehavior((MTForceBehaviorConfiguration *)(this + 33));
  v6 = -31;
  v7 = 472;
  do
  {
    MTForceThresholding::setForceBehavior((MTForceThresholding *)((char *)this[58] + v7), FingerBehavior, v6 + 32);
    v7 += 472;
  }
  while (!__CFADD__(v6++, 1));
  *((_BYTE *)this + 288) = 0;
}

void MTForceManagement::analyzeAndManageStrongestForces(MTForceManagement *this, const MTPathStates *a2)
{
  if (*(_BYTE *)this)
  {
    MTForceManagement::managePostActivation(this, a2);
  }
  else
  {
    MTForceManagement::primeBasicBehaviors((MTForceThresholding **)this, *((_DWORD *)a2 + 92));
    MTForceManagement::managePreActivation(this, a2);
  }
}

void MTForceManagement::managePreActivation(MTForceManagement *this, const MTPathStates *a2)
{
  unsigned int v4;
  uint64_t v5;

  MTForceManagement::analyzeDistributedForces(this, a2);
  v4 = MTForceManagement::strongestProgressPathID(this, a2, 0);
  if ((v4 & 0x80000000) == 0)
  {
    v5 = *((_QWORD *)this + 58);
    if (*(int *)(v5 + 472 * v4 + 324) >= 1
      && !*(_DWORD *)(v5 + 472 * v4 + 328)
      && *((double *)a2 + 1) - *((double *)this + 2) > *((float *)this + 83))
    {
      if (*((_BYTE *)this + 594))
        MTForceManagement::lockBehaviorsOnActivatedFinger(this, v4);
    }
  }
}

void MTForceManagement::managePostActivation(MTForceManagement *this, const MTPathStates *a2)
{
  if (*(_DWORD *)(*((_QWORD *)this + 58) + 472 * *((int *)this + 64) + 324))
  {
    MTForceManagement::analyzeDistributedForces(this, a2);
  }
  else
  {
    MTForceManagement::primeBasicBehaviors((MTForceThresholding **)this, *((_DWORD *)a2 + 92));
    MTForceManagement::managePreActivation(this, a2);
  }
}

MTForceThresholding *MTForceManagement::analyzeDistributedForces(MTForceManagement *this, const MTPathStates *a2)
{
  int v4;
  uint64_t v5;
  float v6;
  float v7;
  uint64_t v8;
  MTForceThresholding *result;

  v4 = MTForceManagement::strongestForcePathID(this, a2, 0);
  v5 = 0;
  v6 = *((float *)this + 128);
  v7 = *((float *)this + 129);
  v8 = 32;
  do
  {
    result = (MTForceThresholding *)(*((_QWORD *)this + 58) + v5);
    if (*((_DWORD *)result + 44))
      result = (MTForceThresholding *)MTForceThresholding::analyzeForceAndStage(result, a2, v4, (MTForceManagement *)((char *)this + 32), *((double *)this + 2), *((double *)this + 3), *((unsigned __int8 *)this + 592), v7, v6);
    v5 += 472;
    --v8;
  }
  while (v8);
  return result;
}

void MTForceManagement::lockBehaviorsOnActivatedFinger(MTForceManagement *this, unsigned int a2)
{
  const MTForceBehavior *Null;
  MTForceBehavior *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;

  *(_BYTE *)this = 1;
  *((_DWORD *)this + 64) = a2;
  if (a2)
  {
    Null = (const MTForceBehavior *)MTForceBehavior::GetNull(this);
    MTForceThresholding::setForceBehavior(*((MTForceThresholding **)this + 58), Null, 0);
    v5 = MTForceBehaviorConfiguration::secondFingerBehavior((MTForceManagement *)((char *)this + 264));
    v6 = 472;
    v7 = 472 * a2;
    v8 = 1;
    v9 = 14632;
    do
    {
      if (v7 != v6)
        MTForceThresholding::setForceBehavior((MTForceThresholding *)(*((_QWORD *)this + 58) + v6), v5, v8);
      ++v8;
      v6 += 472;
      v9 -= 472;
    }
    while (v9);
  }
  else
  {
    MTForceManagement::disableFingerThresholders(this);
  }
}

void MTForceManagement::disableAllThresholders(MTForceManagement *this)
{
  const MTForceBehavior *Null;
  uint64_t v3;
  uint64_t i;

  *(_BYTE *)this = 0;
  *((_DWORD *)this + 64) = 0;
  Null = (const MTForceBehavior *)MTForceBehavior::GetNull(this);
  v3 = 0;
  for (i = 0; i != 32; ++i)
  {
    MTForceThresholding::setForceBehavior((MTForceThresholding *)(*((_QWORD *)this + 58) + v3), Null, i);
    v3 += 472;
  }
}

void MTForceManagement::setBehaviorOnThresholders(MTForceManagement *this, const MTForceBehavior *a2, int a3, int a4)
{
  int v4;
  int v7;
  uint64_t v8;

  if (a3 <= a4)
  {
    v4 = a3;
    v7 = a4 + 1;
    v8 = 472 * a3;
    do
    {
      MTForceThresholding::setForceBehavior((MTForceThresholding *)(*((_QWORD *)this + 58) + v8), a2, v4++);
      v8 += 472;
    }
    while (v7 != v4);
  }
}

void MTForceManagement::disableFingerThresholders(MTForceManagement *this)
{
  uint64_t v2;
  uint64_t v3;
  const MTForceBehavior *Null;

  v2 = -31;
  v3 = 472;
  Null = (const MTForceBehavior *)MTForceBehavior::GetNull(this);
  do
  {
    MTForceThresholding::setForceBehavior((MTForceThresholding *)(*((_QWORD *)this + 58) + v3), Null, v2 + 32);
    v3 += 472;
  }
  while (!__CFADD__(v2++, 1));
}

void MTForceManagement::disableCollectiveThresholder(MTForceThresholding **this)
{
  const MTForceBehavior *Null;

  Null = (const MTForceBehavior *)MTForceBehavior::GetNull((MTForceBehavior *)this);
  MTForceThresholding::setForceBehavior(this[58], Null, 0);
}

void MTForceManagement::setBehaviorOnOtherFingerThresholders(MTForceManagement *this, const MTForceBehavior *a2, unsigned int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v5 = a3;
  v6 = 1;
  v7 = 472;
  do
  {
    if (v5 != v6)
      MTForceThresholding::setForceBehavior((MTForceThresholding *)(*((_QWORD *)this + 58) + v7), a2, v6);
    ++v6;
    v7 += 472;
  }
  while (v6 != 32);
}

float MTForceManagement::setOverrideBehavior(MTForceManagement *this, const MTForceBehavior *a2)
{
  int v4;
  float result;

  v4 = MTForceBehavior::forceSourceFingerCount(*((_QWORD *)this + 58) + 472 * *((int *)this + 64) + 176);
  if (v4 == MTForceBehavior::forceSourceFingerCount((uint64_t)a2) && *(_BYTE *)this)
  {
    if (*(_DWORD *)a2)
      return MTForceThresholding::updateForceBehavior((MTForceThresholding *)(*((_QWORD *)this + 58) + 472 * *((int *)this + 64)), a2, *((_DWORD *)this + 64));
  }
  return result;
}

uint64_t MTActuatorManagement::MTActuatorManagement(uint64_t a1, CFTypeRef cf)
{
  *(_QWORD *)a1 = cf;
  CFRetain(cf);
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 24) = 1;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, 0, MEMORY[0x24BDBD6B0]);
  *(_QWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  return a1;
}

void MTActuatorManagement::~MTActuatorManagement(CFTypeRef *this)
{
  CFTypeRef v2;
  io_object_t v3;

  CFRelease(*this);
  *this = 0;
  if (this[1])
  {
    MTActuatorClose();
    CFRelease(this[1]);
    this[1] = 0;
  }
  v2 = this[2];
  if (v2)
  {
    CFRelease(v2);
    this[2] = 0;
  }
  v3 = *((_DWORD *)this + 14);
  if (v3)
  {
    IOObjectRelease(v3);
    *((_DWORD *)this + 14) = 0;
  }
}

uint64_t MTActuatorManagement::AppleActuatorDeviceMatchedCallback(MTActuatorManagement *this, io_iterator_t iterator)
{
  uint64_t result;
  io_registry_entry_t v5;
  char v6;
  uint64_t entryID;

  result = IOIteratorNext(iterator);
  if (!(_DWORD)result)
  {
    v6 = 0;
    if (!this)
      return result;
    goto LABEL_9;
  }
  v5 = result;
  v6 = 0;
  do
  {
    entryID = 0;
    if (!IORegistryEntryGetRegistryEntryID(v5, &entryID))
      v6 |= entryID == *((_QWORD *)this + 4);
    IOObjectRelease(v5);
    result = IOIteratorNext(iterator);
    v5 = result;
  }
  while ((_DWORD)result);
  if (this)
  {
LABEL_9:
    if ((v6 & 1) == 0 && *(_QWORD *)this)
    {
      if (*((_QWORD *)this + 1))
      {
        MTActuatorClose();
        CFRelease(*((CFTypeRef *)this + 1));
        *(_QWORD *)(*(_QWORD *)this + 32) = 0;
        *((_QWORD *)this + 1) = 0;
      }
      return MTActuatorManagement::getActuatorRef(this);
    }
  }
  return result;
}

uint64_t MTActuatorManagement::setFirmwareClicks(MTActuatorManagement *this, unsigned int a2, int a3)
{
  int v4;
  int v5;

  if (*((_BYTE *)this + 24))
  {
    if (a2 > 2)
      v4 = 0;
    else
      v4 = dword_2310BE228[a2];
    if (a3)
      v5 = v4 | 8;
    else
      v5 = v4;
    if (MTActuatorManagement::getActuatorRef(this) && v5 != *((_DWORD *)this + 10))
    {
      *((_DWORD *)this + 10) = v5;
      MTActuatorSetFirmwareClicks();
    }
  }
  return 1;
}

uint64_t MTActuatorManagement::systemActuationsEnabledChanged(MTActuatorManagement *this)
{
  uint64_t result;

  result = MTActuatorManagement::getActuatorRef(this);
  if (result)
  {
    MTActuatorManagement::getActuatorRef(this);
    result = MTActuatorGetSystemActuationsEnabled();
    *((_BYTE *)this + 24) = result;
  }
  return result;
}

void MTActuatorManagement::scheduleOnDispatchQueue(MTActuatorManagement *this, NSObject *a2)
{
  IONotificationPortRef v4;
  const __CFAllocator *v5;
  CFNumberRef v6;
  const CFDictionaryKeyCallBacks *v7;
  const CFDictionaryValueCallBacks *v8;
  __CFDictionary *Mutable;
  __CFDictionary *v10;
  __CFDictionary *v11;
  BOOL v12;
  uint64_t valuePtr;

  if (!MTDeviceSupportsActuation())
    return;
  v4 = IONotificationPortCreate(0);
  *((_QWORD *)this + 6) = v4;
  if (!v4)
    return;
  valuePtr = 0;
  MTDeviceGetDeviceID();
  v5 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberSInt64Type, &valuePtr);
  v7 = (const CFDictionaryKeyCallBacks *)MEMORY[0x24BDBD6A0];
  v8 = (const CFDictionaryValueCallBacks *)MEMORY[0x24BDBD6B0];
  Mutable = CFDictionaryCreateMutable(v5, 1, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v10 = CFDictionaryCreateMutable(v5, 1, v7, v8);
  v11 = v10;
  if (v6)
    v12 = Mutable == 0;
  else
    v12 = 1;
  if (v12 || v10 == 0)
  {
    IONotificationPortSetDispatchQueue(*((IONotificationPortRef *)this + 6), a2);
    if (!v6)
      goto LABEL_17;
  }
  else
  {
    CFDictionarySetValue(v10, CFSTR("Multitouch Actuator ID"), v6);
    CFDictionarySetValue(Mutable, CFSTR("IOPropertyMatch"), v11);
    CFRetain(Mutable);
    if (!IOServiceAddMatchingNotification(*((IONotificationPortRef *)this + 6), "IOServiceFirstMatch", Mutable, (IOServiceMatchingCallback)MTActuatorManagement::AppleActuatorDeviceMatchedCallback, this, (io_iterator_t *)this + 14))MTActuatorManagement::AppleActuatorDeviceMatchedCallback(this, *((_DWORD *)this + 14));
    IONotificationPortSetDispatchQueue(*((IONotificationPortRef *)this + 6), a2);
  }
  CFRelease(v6);
LABEL_17:
  if (Mutable)
    CFRelease(Mutable);
  if (v11)
    CFRelease(v11);
}

void MTActuatorManagement::unscheduleFromDispatchQueue(MTActuatorManagement *this, dispatch_queue_t queue)
{
  IONotificationPort *v3;

  dispatch_assert_queue_not_V2(queue);
  v3 = (IONotificationPort *)*((_QWORD *)this + 6);
  if (v3)
  {
    IONotificationPortDestroy(v3);
    *((_QWORD *)this + 6) = 0;
  }
}

uint64_t MTActuatorManagement::reloadActuations(MTActuatorManagement *this)
{
  uint64_t result;

  result = MTActuatorManagement::getActuatorRef(this);
  if (result)
  {
    MTActuatorManagement::getActuatorRef(this);
    return MTActuatorLoadActuations();
  }
  return result;
}

uint64_t MTActuatorManagement::reclaimHostClickControl(MTActuatorManagement *this)
{
  uint64_t result;

  result = MTActuatorManagement::getActuatorRef(this);
  if (result)
  {
    MTActuatorManagement::getActuatorRef(this);
    return MTActuatorReclaimHostClickControl();
  }
  return result;
}

void MTForceBehavior::MTForceBehavior(MTForceBehavior *this, const MTForceBehavior *a2)
{
  __int128 v4;

  v4 = *(_OWORD *)a2;
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
  *(_OWORD *)this = v4;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)this + 3, *((const void **)a2 + 3), *((_QWORD *)a2 + 4), (uint64_t)(*((_QWORD *)a2 + 4) - *((_QWORD *)a2 + 3)) >> 2);
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>((_QWORD *)this + 6, *((const void **)a2 + 6), *((_QWORD *)a2 + 7), (uint64_t)(*((_QWORD *)a2 + 7) - *((_QWORD *)a2 + 6)) >> 2);
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>((_QWORD *)this + 9, *((const void **)a2 + 9), *((_QWORD *)a2 + 10), (uint64_t)(*((_QWORD *)a2 + 10) - *((_QWORD *)a2 + 9)) >> 2);
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>((_QWORD *)this + 12, *((const void **)a2 + 12), *((_QWORD *)a2 + 13), (uint64_t)(*((_QWORD *)a2 + 13) - *((_QWORD *)a2 + 12)) >> 2);
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>((_QWORD *)this + 15, *((const void **)a2 + 15), *((_QWORD *)a2 + 16), (uint64_t)(*((_QWORD *)a2 + 16) - *((_QWORD *)a2 + 15)) >> 2);
}

void sub_2310B7238(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  void **v3;
  void **v4;
  void **v5;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  v7 = *v5;
  if (*v5)
  {
    v1[13] = v7;
    operator delete(v7);
  }
  v8 = *v4;
  if (*v4)
  {
    v1[10] = v8;
    operator delete(v8);
  }
  v9 = *v3;
  if (*v3)
  {
    v1[7] = v9;
    operator delete(v9);
  }
  v10 = *v2;
  if (*v2)
  {
    v1[4] = v10;
    operator delete(v10);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<std::vector<MTForceBehavior>>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;
  size_t v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<MTForceBehavior>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_2310B732C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::vector<MTForceBehavior>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<std::vector<MTForceBehavior>>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<MTForceBehavior>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<MTForceBehavior>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a2);
}

uint64_t std::vector<MTForceBehavior>::__push_back_slow_path<MTForceBehavior const&>(uint64_t *a1, const MTForceBehavior *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  void *v13;
  MTForceBehavior *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 4);
  v5 = v4 + 1;
  if (v4 + 1 > 0x1C71C71C71C71C7)
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0x8E38E38E38E38E39 * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0xE38E38E38E38E3)
    v9 = 0x1C71C71C71C71C7;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTForceBehavior>>(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = (MTForceBehavior *)&v10[144 * v4];
  v16 = &v10[144 * v9];
  MTForceBehavior::MTForceBehavior(v14, a2);
  v15 = (char *)v14 + 144;
  std::vector<MTForceBehavior>::__swap_out_circular_buffer(a1, &v13);
  v11 = a1[1];
  std::__split_buffer<MTForceBehavior>::~__split_buffer(&v13);
  return v11;
}

void sub_2310B74E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  std::__split_buffer<MTForceBehavior>::~__split_buffer(&a9);
  _Unwind_Resume(a1);
}

uint64_t std::vector<MTForceBehavior>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MTForceBehavior>,std::reverse_iterator<MTForceBehavior*>,std::reverse_iterator<MTForceBehavior*>,std::reverse_iterator<MTForceBehavior*>>((uint64_t)(a1 + 2), a1[1], (const MTForceBehavior *)a1[1], *a1, (const MTForceBehavior *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<MTForceBehavior>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1C71C71C71C71C8)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(144 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MTForceBehavior>,std::reverse_iterator<MTForceBehavior*>,std::reverse_iterator<MTForceBehavior*>,std::reverse_iterator<MTForceBehavior*>>(uint64_t a1, uint64_t a2, const MTForceBehavior *a3, uint64_t a4, const MTForceBehavior *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  const MTForceBehavior *v9;
  uint64_t v10;
  _QWORD v12[3];
  unint64_t v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0xAAAAAAAAAAAAAA00;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    v9 = a3;
    do
    {
      v9 = (const MTForceBehavior *)((char *)v9 - 144);
      MTForceBehavior::MTForceBehavior((MTForceBehavior *)(v7 - 144), v9);
      v7 = *((_QWORD *)&v15 + 1) - 144;
      *((_QWORD *)&v15 + 1) -= 144;
    }
    while (v9 != a5);
    v10 = v15;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTForceBehavior>,std::reverse_iterator<MTForceBehavior*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

void sub_2310B765C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTForceBehavior>,std::reverse_iterator<MTForceBehavior*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTForceBehavior>,std::reverse_iterator<MTForceBehavior*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<MTForceBehavior>,std::reverse_iterator<MTForceBehavior*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<MTForceBehavior>,std::reverse_iterator<MTForceBehavior*>>::operator()[abi:ne180100](uint64_t *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  v1 = *(_QWORD **)(a1[2] + 8);
  v2 = *(_QWORD **)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<MTForceBehavior>::destroy[abi:ne180100](v3, v1);
      v1 += 18;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<MTForceBehavior>::~__split_buffer(void **a1)
{
  std::__split_buffer<MTForceBehavior>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<MTForceBehavior>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 144;
    std::allocator<MTForceBehavior>::destroy[abi:ne180100](v4, (_QWORD *)(i - 144));
  }
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,MTForceBehavior *,MTForceBehavior *,MTForceBehavior *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a1;
  if (a1 != a2)
  {
    do
    {
      MTForceBehavior::operator=(a3, v4);
      v4 += 144;
      a3 += 144;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

_QWORD *std::vector<MTForceThresholding>::vector(_QWORD *a1, unint64_t a2)
{
  MTForceThresholding *v4;
  uint64_t v5;
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<MTForceThresholding>::__vallocate[abi:ne180100](a1, a2);
    v4 = (MTForceThresholding *)a1[1];
    v5 = 472 * a2;
    v6 = (char *)v4 + 472 * a2;
    do
    {
      MTForceThresholding::MTForceThresholding(v4);
      v4 = (MTForceThresholding *)((char *)v4 + 472);
      v5 -= 472;
    }
    while (v5);
    a1[1] = v6;
  }
  return a1;
}

void sub_2310B7840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<MTForceThresholding>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<MTForceThresholding>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x8AD8F2FBA93869)
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTForceThresholding>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[472 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<MTForceThresholding>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x8AD8F2FBA93869)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(472 * a2);
}

uint64_t MTForceManagerLite::MTForceManagerLite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *v6;
  double v7;
  double v8;
  const char *v9;
  double v10;
  double v11;
  NSObject *v12;
  uint8_t buf[4];
  double v15;
  __int16 v16;
  double v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  *(_BYTE *)a1 = 0;
  *(_QWORD *)(a1 + 40) = a5;
  if (MTDeviceGetForceThresholdForMotion())
  {
    *(_QWORD *)(a1 + 12) = 0x4366000043110000;
    MTDeviceGetDeviceID();
    v6 = MTLoggingPlugin();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      goto LABEL_7;
    v7 = *(float *)(a1 + 12);
    v8 = *(float *)(a1 + 16);
    *(_DWORD *)buf = 134218496;
    v15 = v7;
    v16 = 2048;
    v17 = v8;
    v18 = 2048;
    v19 = 0;
    v9 = "Init from default %f %f (deviceID 0x%llX)";
  }
  else
  {
    *(float *)(a1 + 12) = (float)0;
    *(float *)(a1 + 16) = (float)0;
    MTDeviceGetDeviceID();
    v6 = MTLoggingPlugin();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      goto LABEL_7;
    v10 = *(float *)(a1 + 12);
    v11 = *(float *)(a1 + 16);
    *(_DWORD *)buf = 134218496;
    v15 = v10;
    v16 = 2048;
    v17 = v11;
    v18 = 2048;
    v19 = 0;
    v9 = "Init from MTDeviceRef %f %f (deviceID 0x%llX)";
  }
  _os_log_impl(&dword_231071000, v6, OS_LOG_TYPE_DEBUG, v9, buf, 0x20u);
LABEL_7:
  MTDeviceGetReport();
  MTDeviceGetDeviceID();
  v12 = MTLoggingPlugin();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    v15 = 0.0;
    _os_log_impl(&dword_231071000, v12, OS_LOG_TYPE_DEFAULT, "Can't fetch Orb spec from FW, falling back to default. (deviceID 0x%llX)", buf, 0xCu);
  }
  *(float *)(a1 + 20) = 30.0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 24) = 1050253722;
  return a1;
}

void MTForceManagerLite::updatePaths(MTForceManagerLite *this, const MTPathStates *a2)
{
  float v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  float v21;
  float v22;
  float v23;
  float v24;
  NSObject *v25;
  int v26;
  double v27;
  double v28;
  double v29;
  _OWORD __dst[38];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v3 = 0.0;
  v4 = -18600;
  do
  {
    memcpy(__dst, &unk_2310BE278, 0x258uLL);
    v5 = *((_QWORD *)a2 + 35);
    *(_QWORD *)&__dst[0] = &off_24FFF08D0;
    v6 = v5 + v4;
    memcpy((char *)__dst + 8, (const void *)(v5 + v4 + 19208), 0x11CuLL);
    *((_QWORD *)&__dst[18] + 1) = &off_24FFF2F50;
    v7 = *(_OWORD *)(v6 + 19536);
    v8 = *(_OWORD *)(v6 + 19520);
    __dst[19] = *(_OWORD *)(v6 + 19504);
    __dst[20] = v8;
    __dst[21] = v7;
    v9 = *(_OWORD *)(v6 + 19552);
    v10 = *(_OWORD *)(v6 + 19600);
    v11 = *(_OWORD *)(v6 + 19568);
    __dst[24] = *(_OWORD *)(v6 + 19584);
    __dst[25] = v10;
    __dst[22] = v9;
    __dst[23] = v11;
    v12 = *(_OWORD *)(v6 + 19632);
    v13 = *(_OWORD *)(v6 + 19664);
    v14 = *(_OWORD *)(v6 + 19616);
    __dst[28] = *(_OWORD *)(v6 + 19648);
    __dst[29] = v13;
    __dst[26] = v14;
    __dst[27] = v12;
    v15 = *(_OWORD *)(v6 + 19696);
    v16 = *(_OWORD *)(v6 + 19728);
    v17 = *(_OWORD *)(v6 + 19680);
    __dst[32] = *(_OWORD *)(v6 + 19712);
    __dst[33] = v16;
    __dst[30] = v17;
    __dst[31] = v15;
    v18 = *(_OWORD *)(v6 + 19760);
    v19 = *(_OWORD *)(v6 + 19776);
    v20 = *(_OWORD *)(v6 + 19744);
    *(_QWORD *)&__dst[37] = *(_QWORD *)(v6 + 19792);
    __dst[35] = v18;
    __dst[36] = v19;
    __dst[34] = v20;
    if ((HIDWORD(__dst[2]) - 3) <= 1 && !MTParserPath::isEdgeContact((MTParserPath *)__dst))
      v3 = v3 + *((float *)&__dst[4] + 3);
    MTParserPath::~MTParserPath((MTParserPath *)__dst);
    v4 += 600;
  }
  while (v4);
  v21 = *((float *)this + 1);
  if (v3 > v21 || (v3 = v3 + *((float *)this + 5), v3 < v21))
  {
    *((float *)this + 1) = v3;
    v21 = v3;
  }
  v22 = (float)(v21 - *((float *)this + 3)) / (float)(*((float *)this + 4) - *((float *)this + 3));
  if (v22 > 1.0)
  {
    v23 = *((float *)this + 6);
    v24 = 0.01;
    if (v23 > 0.0)
      v24 = *((float *)this + 6);
    v22 = (float)(v23 * (float)(1.0 - expf((float)(1.0 - v22) / v24))) + 1.0;
  }
  if (*((_BYTE *)this + 1))
  {
    if (v22 >= 0.0)
      v22 = fmaxf(v22, 1.0);
    else
      *((_BYTE *)this + 1) = 0;
  }
  else if (v22 >= 1.0)
  {
    *((_BYTE *)this + 1) = 1;
    MTDeviceGetDeviceID();
    v25 = MTLoggingPlugin();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
    {
      v26 = *((_DWORD *)this + 7);
      v27 = *((float *)this + 3);
      v28 = *((float *)this + 4);
      v29 = *((float *)this + 5);
      LODWORD(__dst[0]) = 67110144;
      DWORD1(__dst[0]) = v26;
      WORD4(__dst[0]) = 2048;
      *(double *)((char *)__dst + 10) = v27;
      WORD1(__dst[1]) = 2048;
      *(double *)((char *)&__dst[1] + 4) = v28;
      WORD6(__dst[1]) = 2048;
      *(double *)((char *)&__dst[1] + 14) = v29;
      WORD3(__dst[2]) = 2048;
      *((_QWORD *)&__dst[2] + 1) = 0;
      _os_log_impl(&dword_231071000, v25, OS_LOG_TYPE_DEBUG, "Force activated : Motion (%d) Thresholds (%f, %f) Hysteresis (%f) (deviceID 0x%llX)", (uint8_t *)__dst, 0x30u);
    }
  }
  *((float *)this + 2) = fmaxf(v22, 0.0);
  MTForceManagerLite::updateMotion((uint64_t)this, *((_DWORD *)this + 8));
}

void sub_2310B7E5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(exception_object);
}

void MTForceManagerLite::updateMotion(uint64_t a1, int a2)
{
  NSObject *v4;
  double v5;
  double v6;
  const char *v7;
  double v8;
  double v9;
  uint8_t buf[4];
  int v11;
  __int16 v12;
  double v13;
  __int16 v14;
  double v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (a2 <= 4)
  {
    *(_DWORD *)(a1 + 32) = a2;
    if (*(float *)(a1 + 4) <= 50.0 && *(_DWORD *)(a1 + 28) != a2)
    {
      if (MTDeviceGetForceThresholdForMotion())
      {
        *(_QWORD *)(a1 + 12) = _defaultThresholds[a2];
        MTDeviceGetDeviceID();
        v4 = MTLoggingPlugin();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          v5 = *(float *)(a1 + 12);
          v6 = *(float *)(a1 + 16);
          *(_DWORD *)buf = 67109888;
          v11 = a2;
          v12 = 2048;
          v13 = v5;
          v14 = 2048;
          v15 = v6;
          v16 = 2048;
          v17 = 0;
          v7 = "Default motion %d %f %f (deviceID 0x%llX)";
LABEL_9:
          _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_DEBUG, v7, buf, 0x26u);
        }
      }
      else
      {
        *(float *)(a1 + 12) = (float)0;
        *(float *)(a1 + 16) = (float)0;
        MTDeviceGetDeviceID();
        v4 = MTLoggingPlugin();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          v8 = *(float *)(a1 + 12);
          v9 = *(float *)(a1 + 16);
          *(_DWORD *)buf = 67109888;
          v11 = a2;
          v12 = 2048;
          v13 = v8;
          v14 = 2048;
          v15 = v9;
          v16 = 2048;
          v17 = 0;
          v7 = "MTDeviceRef motion %d %f %f (deviceID 0x%llX)";
          goto LABEL_9;
        }
      }
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 32);
    }
  }
}

void MTInterferenceMonitor::MTInterferenceMonitor(MTInterferenceMonitor *this)
{
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_24FFF31F8;
  *((_QWORD *)this + 1) = 0;
  *(_DWORD *)((char *)this + 15) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_QWORD *)((char *)this + 87) = 0;
}

{
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_24FFF31F8;
  *((_QWORD *)this + 1) = 0;
  *(_DWORD *)((char *)this + 15) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_QWORD *)((char *)this + 87) = 0;
}

void MTInterferenceMonitor::~MTInterferenceMonitor(MTInterferenceMonitor *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24FFF31F8;
  if (*((_BYTE *)this + 16))
    MTInterferenceMonitor::_stop(this);
  v2 = (void *)*((_QWORD *)this + 8);
  if (v2)
  {
    *((_QWORD *)this + 9) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 5);
  if (v3)
  {
    *((_QWORD *)this + 6) = v3;
    operator delete(v3);
  }
}

{
  MTInterferenceMonitor::~MTInterferenceMonitor(this);
  JUMPOUT(0x2348D0034);
}

uint64_t MTInterferenceMonitor::_stop(MTInterferenceMonitor *this)
{
  NSObject *v2;
  const void *v3;
  uint64_t result;

  if (!*((_BYTE *)this + 16))
    return 3758096385;
  notify_cancel(*((_DWORD *)this + 8));
  v2 = *((_QWORD *)this + 3);
  if (v2)
  {
    dispatch_release(v2);
    *((_QWORD *)this + 3) = 0;
  }
  (*(void (**)(MTInterferenceMonitor *))(*(_QWORD *)this + 72))(this);
  v3 = (const void *)*((_QWORD *)this + 1);
  if (v3)
  {
    CFRelease(v3);
    *((_QWORD *)this + 1) = 0;
  }
  result = 0;
  *((_BYTE *)this + 16) = 0;
  return result;
}

uint64_t MTInterferenceMonitor::start(uint64_t a1, NSObject *a2, CFTypeRef cf)
{
  uint64_t result;
  NSObject *v6;
  int v7;
  int *v8;
  NSObject *v9;
  _QWORD *v10;
  _QWORD v11[5];
  _QWORD handler[5];
  _QWORD v13[5];
  uint64_t v14;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  result = 3758097090;
  if (a2 && cf)
  {
    if (*(_BYTE *)(a1 + 16))
    {
      return 3758097106;
    }
    else
    {
      *(_QWORD *)(a1 + 8) = CFRetain(cf);
      *(_BYTE *)(a1 + 17) = MTDeviceSupportsWirelessChargingNotification();
      *(_BYTE *)(a1 + 18) = MTDeviceSupportsUSBChargingNotification();
      v14 = 0;
      MTDeviceGetDeviceID();
      v6 = MTLoggingPlugin();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        v7 = *(unsigned __int8 *)(a1 + 18);
        *(_DWORD *)buf = 67109376;
        v16 = v7;
        v17 = 2048;
        v18 = v14;
        _os_log_impl(&dword_231071000, v6, OS_LOG_TYPE_INFO, "device support usb charging notification = %d (deviceID 0x%llX)", buf, 0x12u);
      }
      *(_QWORD *)(a1 + 24) = a2;
      dispatch_retain(a2);
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
      if (!(_DWORD)result)
      {
        if (*(_BYTE *)(a1 + 17))
        {
          v8 = (int *)(a1 + 32);
          v9 = *(NSObject **)(a1 + 24);
          if (*(_BYTE *)(a1 + 18))
          {
            v13[0] = MEMORY[0x24BDAC760];
            v13[1] = 0x40000000;
            v13[2] = ___ZN21MTInterferenceMonitor5startEP16dispatch_queue_sP10__MTDevice_block_invoke;
            v13[3] = &__block_descriptor_tmp_4;
            v13[4] = a1;
            v10 = v13;
          }
          else
          {
            handler[0] = MEMORY[0x24BDAC760];
            handler[1] = 0x40000000;
            handler[2] = ___ZN21MTInterferenceMonitor5startEP16dispatch_queue_sP10__MTDevice_block_invoke_2;
            handler[3] = &__block_descriptor_tmp_2;
            handler[4] = a1;
            v10 = handler;
          }
        }
        else
        {
          if (!*(_BYTE *)(a1 + 18))
            return 0;
          v8 = (int *)(a1 + 32);
          v9 = *(NSObject **)(a1 + 24);
          v11[0] = MEMORY[0x24BDAC760];
          v11[1] = 0x40000000;
          v11[2] = ___ZN21MTInterferenceMonitor5startEP16dispatch_queue_sP10__MTDevice_block_invoke_3;
          v11[3] = &__block_descriptor_tmp_3;
          v11[4] = a1;
          v10 = v11;
        }
        notify_register_dispatch("com.apple.system.powersources", v8, v9, v10);
        result = 0;
        *(_BYTE *)(a1 + 16) = 1;
      }
    }
  }
  return result;
}

uint64_t ___ZN21MTInterferenceMonitor5startEP16dispatch_queue_sP10__MTDevice_block_invoke(uint64_t a1)
{
  _BYTE *v1;
  int v2;
  uint64_t result;

  v1 = *(_BYTE **)(a1 + 32);
  v2 = (*(uint64_t (**)(_BYTE *))(*(_QWORD *)v1 + 16))(v1);
  if (v1[92] != v2)
  {
    v1[92] = v2;
    (*(void (**)(_BYTE *))(*(_QWORD *)v1 + 32))(v1);
  }
  result = (*(uint64_t (**)(_BYTE *))(*(_QWORD *)v1 + 24))(v1);
  if (v1[94] != (_DWORD)result)
  {
    v1[94] = result;
    return (*(uint64_t (**)(_BYTE *))(*(_QWORD *)v1 + 48))(v1);
  }
  return result;
}

uint64_t ___ZN21MTInterferenceMonitor5startEP16dispatch_queue_sP10__MTDevice_block_invoke_2(uint64_t a1)
{
  _BYTE *v1;
  uint64_t result;

  v1 = *(_BYTE **)(a1 + 32);
  result = (*(uint64_t (**)(_BYTE *))(*(_QWORD *)v1 + 16))(v1);
  if (v1[92] != (_DWORD)result)
  {
    v1[92] = result;
    return (*(uint64_t (**)(_BYTE *))(*(_QWORD *)v1 + 32))(v1);
  }
  return result;
}

uint64_t ___ZN21MTInterferenceMonitor5startEP16dispatch_queue_sP10__MTDevice_block_invoke_3(uint64_t a1)
{
  _BYTE *v1;
  uint64_t result;

  v1 = *(_BYTE **)(a1 + 32);
  result = (*(uint64_t (**)(_BYTE *))(*(_QWORD *)v1 + 24))(v1);
  if (v1[94] != (_DWORD)result)
  {
    v1[94] = result;
    return (*(uint64_t (**)(_BYTE *))(*(_QWORD *)v1 + 48))(v1);
  }
  return result;
}

uint64_t MTInterferenceMonitor::restoreStateToDevice(MTInterferenceMonitor *this)
{
  uint64_t result;

  result = 3758097112;
  if (*((_BYTE *)this + 16))
  {
    if (!*((_BYTE *)this + 17)
      || (result = (*(uint64_t (**)(MTInterferenceMonitor *))(*(_QWORD *)this + 32))(this), !(_DWORD)result)
      && (result = (*(uint64_t (**)(MTInterferenceMonitor *))(*(_QWORD *)this + 40))(this), !(_DWORD)result))
    {
      if (*((_BYTE *)this + 18))
        return (*(uint64_t (**)(MTInterferenceMonitor *))(*(_QWORD *)this + 48))(this);
    }
  }
  return result;
}

uint64_t MTInterferenceMonitor::powerDriverChangedNotification(uint64_t this, void *a2, int a3, unsigned int a4, void *a5)
{
  if (a3 == -536870896)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)this + 72))(this);
  return this;
}

uint64_t MTInterferenceMonitor::cachePowerSourceDrivers(io_iterator_t *this)
{
  const __CFDictionary *v2;
  const __CFDictionary *v3;
  uint64_t MatchingServices;
  io_object_t v5;
  io_service_t v6;
  char **v7;
  void **v8;
  IONotificationPort *v9;
  unint64_t v10;
  IONotificationPort **v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  IONotificationPort **v18;
  char *v19;
  char *v20;
  IONotificationPort *v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  _DWORD *v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char *v31;
  io_object_t *v32;
  io_object_t v33;
  io_object_t notification;

  (*(void (**)(io_iterator_t *))(*(_QWORD *)this + 72))(this);
  v2 = IOServiceMatching("IOPMPowerSource");
  if (!v2)
    return 3758097084;
  v3 = v2;
  MatchingServices = IOServiceGetMatchingServices(0, v2, this + 22);
  if ((_DWORD)MatchingServices)
  {
    v22 = MatchingServices;
    CFRelease(v3);
  }
  else
  {
    v5 = IOIteratorNext(this[22]);
    if (v5)
    {
      v6 = v5;
      v7 = (char **)(this + 16);
      v8 = (void **)(this + 10);
      while (1)
      {
        notification = -1431655766;
        v9 = IONotificationPortCreate(0);
        IONotificationPortSetDispatchQueue(v9, *((dispatch_queue_t *)this + 3));
        v11 = (IONotificationPort **)*((_QWORD *)this + 9);
        v10 = *((_QWORD *)this + 10);
        if ((unint64_t)v11 >= v10)
        {
          v13 = ((char *)v11 - *v7) >> 3;
          if ((unint64_t)(v13 + 1) >> 61)
            std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
          v14 = v10 - (_QWORD)*v7;
          v15 = v14 >> 2;
          if (v14 >> 2 <= (unint64_t)(v13 + 1))
            v15 = v13 + 1;
          if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
            v16 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v16 = v15;
          if (v16)
            v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTPoint>>((uint64_t)(this + 20), v16);
          else
            v17 = 0;
          v18 = (IONotificationPort **)&v17[8 * v13];
          *v18 = v9;
          v12 = v18 + 1;
          v20 = (char *)*((_QWORD *)this + 8);
          v19 = (char *)*((_QWORD *)this + 9);
          if (v19 != v20)
          {
            do
            {
              v21 = (IONotificationPort *)*((_QWORD *)v19 - 1);
              v19 -= 8;
              *--v18 = v21;
            }
            while (v19 != v20);
            v19 = *v7;
          }
          *((_QWORD *)this + 8) = v18;
          *((_QWORD *)this + 9) = v12;
          *((_QWORD *)this + 10) = &v17[8 * v16];
          if (v19)
            operator delete(v19);
        }
        else
        {
          *v11 = v9;
          v12 = v11 + 1;
        }
        *((_QWORD *)this + 9) = v12;
        v22 = IOServiceAddInterestNotification(v9, v6, "IOGeneralInterest", (IOServiceInterestCallback)MTInterferenceMonitor::powerDriverChangedNotification, this, &notification);
        IOObjectRelease(v6);
        if ((_DWORD)v22)
          break;
        v24 = (char *)*((_QWORD *)this + 6);
        v23 = *((_QWORD *)this + 7);
        if ((unint64_t)v24 >= v23)
        {
          v26 = (char *)*v8;
          v27 = (v24 - (_BYTE *)*v8) >> 2;
          v28 = v27 + 1;
          if ((unint64_t)(v27 + 1) >> 62)
            std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
          v29 = v23 - (_QWORD)v26;
          if (v29 >> 1 > v28)
            v28 = v29 >> 1;
          if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFFCLL)
            v30 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v30 = v28;
          if (v30)
          {
            v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(this + 14), v30);
            v26 = (char *)*((_QWORD *)this + 5);
            v24 = (char *)*((_QWORD *)this + 6);
          }
          else
          {
            v31 = 0;
          }
          v32 = (io_object_t *)&v31[4 * v27];
          *v32 = notification;
          v25 = v32 + 1;
          while (v24 != v26)
          {
            v33 = *((_DWORD *)v24 - 1);
            v24 -= 4;
            *--v32 = v33;
          }
          *((_QWORD *)this + 5) = v32;
          *((_QWORD *)this + 6) = v25;
          *((_QWORD *)this + 7) = &v31[4 * v30];
          if (v26)
            operator delete(v26);
        }
        else
        {
          *(_DWORD *)v24 = notification;
          v25 = v24 + 4;
        }
        *((_QWORD *)this + 6) = v25;
        v6 = IOIteratorNext(this[22]);
        if (!v6)
          goto LABEL_39;
      }
    }
    else
    {
LABEL_39:
      MEMORY[0x2348CF8A8](this[22]);
      return 0;
    }
  }
  return v22;
}

void MTInterferenceMonitor::releaseCachedPowerDrivers(MTInterferenceMonitor *this)
{
  io_object_t v2;
  uint64_t i;
  uint64_t v4;
  uint64_t j;
  uint64_t v6;

  v2 = *((_DWORD *)this + 22);
  if (v2)
  {
    IOObjectRelease(v2);
    *((_DWORD *)this + 22) = 0;
  }
  v4 = *((_QWORD *)this + 5);
  for (i = *((_QWORD *)this + 6); v4 != i; *((_QWORD *)this + 6) = i)
  {
    IOObjectRelease(*(_DWORD *)(i - 4));
    v4 = *((_QWORD *)this + 5);
    i = *((_QWORD *)this + 6) - 4;
  }
  v6 = *((_QWORD *)this + 8);
  for (j = *((_QWORD *)this + 9); v6 != j; *((_QWORD *)this + 9) = j)
  {
    IONotificationPortDestroy(*(IONotificationPortRef *)(j - 8));
    v6 = *((_QWORD *)this + 8);
    j = *((_QWORD *)this + 9) - 8;
  }
}

uint64_t MTInterferenceMonitor::hasEnteredWirelessField(MTInterferenceMonitor *this)
{
  io_iterator_t v2;
  uint64_t result;
  io_registry_entry_t v4;
  const __CFAllocator *v5;
  const __CFArray *CFProperty;
  const __CFArray *v7;
  char context;
  CFRange v9;

  context = 0;
  v2 = *((_DWORD *)this + 22);
  if (!v2 || !IOIteratorIsValid(v2))
    (*(void (**)(MTInterferenceMonitor *))(*(_QWORD *)this + 64))(this);
  result = IOIteratorIsValid(*((_DWORD *)this + 22));
  if ((_DWORD)result)
  {
    MEMORY[0x2348CF8A8](*((unsigned int *)this + 22));
    result = IOIteratorNext(*((_DWORD *)this + 22));
    if ((_DWORD)result)
    {
      v4 = result;
      v5 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
      do
      {
        CFProperty = (const __CFArray *)IORegistryEntryCreateCFProperty(v4, CFSTR("AppleRawAdapterDetails"), v5, 0);
        if (CFProperty)
        {
          v7 = CFProperty;
          v9.length = CFArrayGetCount(CFProperty);
          v9.location = 0;
          CFArrayApplyFunction(v7, v9, (CFArrayApplierFunction)MTInterferenceMonitor::isWirelessChargingAvailable, &context);
          CFRelease(v7);
        }
        IOObjectRelease(v4);
        v4 = IOIteratorNext(*((_DWORD *)this + 22));
      }
      while (v4);
      return context != 0;
    }
  }
  return result;
}

uint64_t MTInterferenceMonitor::isWirelessChargingAvailable(uint64_t this, BOOL *a2, void *a3)
{
  const __CFDictionary *v4;
  CFTypeID v5;
  CFTypeID v6;
  void *value;

  if (this)
  {
    if (a2)
    {
      v4 = (const __CFDictionary *)this;
      v5 = CFGetTypeID((CFTypeRef)this);
      this = CFDictionaryGetTypeID();
      if (v5 == this)
      {
        value = (void *)0xAAAAAAAAAAAAAAAALL;
        this = CFDictionaryGetValueIfPresent(v4, CFSTR("IsWireless"), (const void **)&value);
        if ((_DWORD)this)
        {
          v6 = CFGetTypeID(value);
          this = CFBooleanGetTypeID();
          if (v6 == this)
          {
            this = CFBooleanGetValue((CFBooleanRef)value);
            *a2 = (*a2 | this) != 0;
          }
        }
      }
    }
  }
  return this;
}

uint64_t MTInterferenceMonitor::hasConnectedtoUSB(MTInterferenceMonitor *this)
{
  io_iterator_t v2;
  uint64_t result;
  io_registry_entry_t v4;
  const __CFAllocator *v5;
  const __CFArray *CFProperty;
  const __CFArray *v7;
  char context;
  CFRange v9;

  context = 0;
  v2 = *((_DWORD *)this + 22);
  if (!v2 || !IOIteratorIsValid(v2))
    (*(void (**)(MTInterferenceMonitor *))(*(_QWORD *)this + 64))(this);
  result = IOIteratorIsValid(*((_DWORD *)this + 22));
  if ((_DWORD)result)
  {
    MEMORY[0x2348CF8A8](*((unsigned int *)this + 22));
    result = IOIteratorNext(*((_DWORD *)this + 22));
    if ((_DWORD)result)
    {
      v4 = result;
      v5 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
      do
      {
        CFProperty = (const __CFArray *)IORegistryEntryCreateCFProperty(v4, CFSTR("AppleRawAdapterDetails"), v5, 0);
        if (CFProperty)
        {
          v7 = CFProperty;
          v9.length = CFArrayGetCount(CFProperty);
          v9.location = 0;
          CFArrayApplyFunction(v7, v9, (CFArrayApplierFunction)MTInterferenceMonitor::isUSBChargingAvailable, &context);
          CFRelease(v7);
        }
        IOObjectRelease(v4);
        v4 = IOIteratorNext(*((_DWORD *)this + 22));
      }
      while (v4);
      return context != 0;
    }
  }
  return result;
}

uint64_t MTInterferenceMonitor::isUSBChargingAvailable(uint64_t this, _BYTE *a2, void *a3)
{
  const __CFDictionary *v4;
  CFTypeID v5;
  CFTypeID v6;
  int valuePtr;
  void *value;

  if (this)
  {
    if (a2)
    {
      v4 = (const __CFDictionary *)this;
      v5 = CFGetTypeID((CFTypeRef)this);
      this = CFDictionaryGetTypeID();
      if (v5 == this)
      {
        value = (void *)0xAAAAAAAAAAAAAAAALL;
        valuePtr = -1431655766;
        this = CFDictionaryGetValueIfPresent(v4, CFSTR("FamilyCode"), (const void **)&value);
        if ((_DWORD)this)
        {
          v6 = CFGetTypeID(value);
          this = CFNumberGetTypeID();
          if (v6 == this)
          {
            this = CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &valuePtr);
            if ((_DWORD)this)
            {
              if ((valuePtr + 536854528) <= 0xA && ((1 << valuePtr) & 0x609) != 0)
                *a2 = 1;
            }
          }
        }
      }
    }
  }
  return this;
}

uint64_t MTInterferenceMonitor::sendWirelessFieldNotification(MTInterferenceMonitor *this)
{
  uint64_t v1;

  if (*((_BYTE *)this + 92))
    v1 = 20;
  else
    v1 = 21;
  return (*(uint64_t (**)(MTInterferenceMonitor *, uint64_t))(*(_QWORD *)this + 56))(this, v1);
}

uint64_t MTInterferenceMonitor::sendWirelessFieldAgressorNotification(MTInterferenceMonitor *this)
{
  uint64_t v1;

  if (*((_BYTE *)this + 93))
    v1 = 22;
  else
    v1 = 23;
  return (*(uint64_t (**)(MTInterferenceMonitor *, uint64_t))(*(_QWORD *)this + 56))(this, v1);
}

uint64_t MTInterferenceMonitor::sendUSBConnectionNotification(MTInterferenceMonitor *this)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  uint8_t buf[4];
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 94))
    v2 = 24;
  else
    v2 = 25;
  v3 = (*(uint64_t (**)(MTInterferenceMonitor *, uint64_t))(*(_QWORD *)this + 56))(this, v2);
  if (*((_BYTE *)this + 94))
  {
    MTDeviceGetDeviceID();
    v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134217984;
      v8 = 0;
      v5 = "usb plugged in to charge (deviceID 0x%llX)";
LABEL_9:
      _os_log_impl(&dword_231071000, v4, OS_LOG_TYPE_INFO, v5, buf, 0xCu);
    }
  }
  else
  {
    MTDeviceGetDeviceID();
    v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134217984;
      v8 = 0;
      v5 = "usb unplugged (deviceID 0x%llX)";
      goto LABEL_9;
    }
  }
  return v3;
}

uint64_t MTInterferenceMonitor::sendEvent()
{
  return MTDeviceSetReport();
}

_QWORD *MTEmbeddedStats::create(uint64_t a1)
{
  dispatch_queue_t v2;
  NSObject *v3;
  _QWORD *v4;
  uint64_t v5;

  if (!a1)
    return 0;
  v2 = dispatch_queue_create("com.apple.Multitouch.EmbeddedStatistics.Queue", 0);
  if (!v2)
    return 0;
  v3 = v2;
  v4 = (_QWORD *)operator new();
  *v4 = 0;
  v4[1] = 0;
  v5 = operator new();
  MTEmbeddedStatsImpl::MTEmbeddedStatsImpl(v5, a1, (uint64_t)v3);
  std::shared_ptr<MTEmbeddedStatsImpl>::reset[abi:ne180100]<MTEmbeddedStatsImpl,void>(v4, v5);
  dispatch_release(v3);
  return v4;
}

void sub_2310B8E18(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2348D0034](v1, 0x10E0C40A92C740BLL);
  _Unwind_Resume(a1);
}

void std::shared_ptr<MTEmbeddedStatsImpl>::reset[abi:ne180100]<MTEmbeddedStatsImpl,void>(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  __int128 v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  __int128 v7;

  std::shared_ptr<MTEmbeddedStatsImpl>::shared_ptr[abi:ne180100]<MTEmbeddedStatsImpl,void>(&v7, a2);
  v3 = (std::__shared_weak_count *)a1[1];
  v4 = v7;
  *(_QWORD *)&v7 = *a1;
  *((_QWORD *)&v7 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void MTEmbeddedStats::handlePaths(MTEmbeddedStats *this, const MTPathStates *a2)
{
  std::__shared_weak_count *v3;
  char *shared_owners;
  uint64_t v5;
  unint64_t *p_shared_owners;
  void **v7;
  uint64_t *p_shared_weak_owners;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  char *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  __int128 v19;
  char *v20;
  __int128 v21;
  __int128 v22;
  char *v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  char *v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  NSObject *v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  _QWORD block[5];
  std::__shared_weak_count *v51;
  _QWORD *v52;
  std::__shared_weak_count *v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  _QWORD *v60;
  std::__shared_weak_count *v61;

  v3 = (std::__shared_weak_count *)operator new(0x30uLL);
  shared_owners = 0;
  v5 = 0;
  v3->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  v3->__shared_weak_owners_ = 0;
  v3[1].__vftable = 0;
  v7 = (void **)&v3[1].__vftable;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_24FFF33D0;
  v3[1].__shared_owners_ = 0;
  v3[1].__shared_weak_owners_ = 0;
  p_shared_weak_owners = &v3[1].__shared_weak_owners_;
  v60 = &v3[1].__vftable;
  v61 = v3;
  do
  {
    v9 = *((_QWORD *)a2 + 35);
    if ((*(_DWORD *)(v9 + 600 * v5 + 44) - 3) <= 1)
    {
      v10 = v9 + 600 * v5;
      v11 = *(_OWORD *)(v10 + 72);
      v56 = *(_OWORD *)(v10 + 56);
      v57 = v11;
      v12 = *(_OWORD *)(v10 + 104);
      v58 = *(_OWORD *)(v10 + 88);
      v59 = v12;
      v13 = *(_OWORD *)(v10 + 40);
      v54 = *(_OWORD *)(v10 + 24);
      v55 = v13;
      if ((unint64_t)shared_owners >= *p_shared_weak_owners)
      {
        v14 = (char *)*v7;
        v15 = 0x4EC4EC4EC4EC4EC5 * ((shared_owners - (_BYTE *)*v7) >> 3);
        v16 = v15 + 1;
        if ((unint64_t)(v15 + 1) > 0x276276276276276)
          std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
        if (0x9D89D89D89D89D8ALL * ((*p_shared_weak_owners - (uint64_t)v14) >> 3) > v16)
          v16 = 0x9D89D89D89D89D8ALL * ((*p_shared_weak_owners - (uint64_t)v14) >> 3);
        if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * ((*p_shared_weak_owners - (uint64_t)v14) >> 3)) >= 0x13B13B13B13B13BLL)
          v17 = 0x276276276276276;
        else
          v17 = v16;
        if (v17)
        {
          v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TouchingContact>>((uint64_t)p_shared_weak_owners, v17);
          v14 = (char *)v3[1].__vftable;
          shared_owners = (char *)v3[1].__shared_owners_;
        }
        else
        {
          v18 = 0;
        }
        v19 = v57;
        v20 = &v18[104 * v15];
        *((_OWORD *)v20 + 2) = v56;
        *((_OWORD *)v20 + 3) = v19;
        v21 = v59;
        *((_OWORD *)v20 + 4) = v58;
        *((_OWORD *)v20 + 5) = v21;
        v22 = v55;
        *(_OWORD *)v20 = v54;
        *((_OWORD *)v20 + 1) = v22;
        *((_QWORD *)v20 + 12) = v5;
        if (shared_owners == v14)
        {
          v29 = &v18[104 * v15];
        }
        else
        {
          v23 = &v18[104 * v15];
          do
          {
            v24 = *(_OWORD *)(shared_owners - 104);
            v25 = *(_OWORD *)(shared_owners - 88);
            *(_OWORD *)(v23 - 72) = *(_OWORD *)(shared_owners - 72);
            *(_OWORD *)(v23 - 88) = v25;
            *(_OWORD *)(v23 - 104) = v24;
            v26 = *(_OWORD *)(shared_owners - 56);
            v27 = *(_OWORD *)(shared_owners - 40);
            v28 = *(_OWORD *)(shared_owners - 24);
            v29 = v23 - 104;
            *((_QWORD *)v23 - 1) = *((_QWORD *)shared_owners - 1);
            *(_OWORD *)(v23 - 24) = v28;
            *(_OWORD *)(v23 - 40) = v27;
            *(_OWORD *)(v23 - 56) = v26;
            shared_owners -= 104;
            v23 -= 104;
          }
          while (shared_owners != v14);
        }
        shared_owners = v20 + 104;
        v3[1].__vftable = (std::__shared_weak_count_vtbl *)v29;
        v3[1].__shared_owners_ = (uint64_t)(v20 + 104);
        v3[1].__shared_weak_owners_ = (uint64_t)&v18[104 * v17];
        if (v14)
          operator delete(v14);
      }
      else
      {
        memmove(shared_owners, (const void *)(v10 + 24), 0x60uLL);
        *((_QWORD *)shared_owners + 12) = v5;
        shared_owners += 104;
      }
      v3[1].__shared_owners_ = (uint64_t)shared_owners;
    }
    ++v5;
  }
  while (v5 != 32);
  v30 = *(_QWORD *)this;
  v31 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v31)
  {
    v32 = (unint64_t *)&v31->__shared_owners_;
    do
      v33 = __ldxr(v32);
    while (__stxr(v33 + 1, v32));
  }
  v34 = *(NSObject **)(v30 + 8);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3321888768;
  block[2] = ___ZN15MTEmbeddedStats11handlePathsERK12MTPathStates_block_invoke;
  block[3] = &__block_descriptor_64_e8_32c47_ZTSNSt3__110shared_ptrI19MTEmbeddedStatsImplEE48c75_ZTSNSt3__110shared_ptrINS_6vectorI15TouchingContactNS_9allocatorIS2_EEEEEE_e5_v8__0l;
  block[4] = v30;
  v51 = v31;
  if (v31)
  {
    v35 = (unint64_t *)&v31->__shared_owners_;
    do
      v36 = __ldxr(v35);
    while (__stxr(v36 + 1, v35));
  }
  v52 = &v3[1].__vftable;
  v53 = v3;
  do
    v37 = __ldxr(p_shared_owners);
  while (__stxr(v37 + 1, p_shared_owners));
  dispatch_async(v34, block);
  v38 = v53;
  if (v53)
  {
    v39 = (unint64_t *)&v53->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  v41 = v51;
  if (v51)
  {
    v42 = (unint64_t *)&v51->__shared_owners_;
    do
      v43 = __ldaxr(v42);
    while (__stlxr(v43 - 1, v42));
    if (!v43)
    {
      ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
      std::__shared_weak_count::__release_weak(v41);
    }
  }
  if (v31)
  {
    v44 = (unint64_t *)&v31->__shared_owners_;
    do
      v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v46 = v61;
  if (v61)
  {
    v47 = (unint64_t *)&v61->__shared_owners_;
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
}

void sub_2310B9260(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<MTEmbeddedStats>::~shared_ptr[abi:ne180100](v1 - 104);
  _Unwind_Resume(a1);
}

void ___ZN15MTEmbeddedStats11handlePathsERK12MTPathStates_block_invoke(uint64_t a1)
{
  MTEmbeddedStatsImpl::handleTouchingContacts(*(_QWORD *)(a1 + 32), *(uint64_t **)(a1 + 48));
}

void MTEmbeddedStatsImpl::handleTouchingContacts(uint64_t a1, uint64_t *a2)
{
  double v4;
  double v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  float *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;

  MTAbsoluteTimeGetCurrent();
  v5 = v4;
  v6 = 0;
  v8 = *a2;
  v7 = a2[1];
  v9 = (float *)(a1 + 24);
  v10 = *a2;
  do
  {
    if (v10 == a2[1])
    {
      v11 = 0;
    }
    else
    {
      if (v6 == *(_QWORD *)(v10 + 96))
        v11 = v10;
      else
        v11 = 0;
      v10 += 104 * (v6 == *(_QWORD *)(v10 + 96));
    }
    MTEmbeddedStatsImpl::handleContactForContactTracker(a1, v11, v9);
    ++v6;
    v9 += 16;
  }
  while (v6 != 32);
  v12 = v7 != v8;
  if (*(unsigned __int8 *)(a1 + 16) != v12)
  {
    *(_BYTE *)(a1 + 16) = v12;
    if (v7 == v8)
    {
      *(double *)(a1 + 2072) = v5;
      bzero((void *)(a1 + 24), 0x800uLL);
      *(_WORD *)(a1 + 16) = 0;
    }
    else
    {
      MTEmbeddedStatsImpl::logDurationBetweenTouches(a1, v5);
    }
  }
}

_QWORD *__copy_helper_block_e8_32c47_ZTSNSt3__110shared_ptrI19MTEmbeddedStatsImplEE48c75_ZTSNSt3__110shared_ptrINS_6vectorI15TouchingContactNS_9allocatorIS2_EEEEEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c47_ZTSNSt3__110shared_ptrI19MTEmbeddedStatsImplEE48c75_ZTSNSt3__110shared_ptrINS_6vectorI15TouchingContactNS_9allocatorIS2_EEEEEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 32;
  std::shared_ptr<MTEmbeddedStats>::~shared_ptr[abi:ne180100](a1 + 48);
  return std::shared_ptr<MTEmbeddedStats>::~shared_ptr[abi:ne180100](v1);
}

void MTEmbeddedStats::handleFrameHeader(uint64_t *a1, _OWORD *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  NSObject *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD v14[5];
  std::__shared_weak_count *v15;
  _OWORD v16[2];
  _OWORD v17[2];

  v17[0] = *a2;
  *(_OWORD *)((char *)v17 + 12) = *(_OWORD *)((char *)a2 + 12);
  v2 = *a1;
  v3 = (std::__shared_weak_count *)a1[1];
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v6 = *(NSObject **)(v2 + 8);
  v14[0] = MEMORY[0x24BDAC760];
  v14[1] = 3321888768;
  v14[2] = ___ZN15MTEmbeddedStats17handleFrameHeaderERK19MTBinaryFrameHeader_block_invoke;
  v14[3] = &__block_descriptor_76_e8_32c47_ZTSNSt3__110shared_ptrI19MTEmbeddedStatsImplEE_e5_v8__0l;
  v14[4] = v2;
  v15 = v3;
  if (v3)
  {
    v7 = (unint64_t *)&v3->__shared_owners_;
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v16[0] = v17[0];
  *(_OWORD *)((char *)v16 + 12) = *(_OWORD *)((char *)v17 + 12);
  dispatch_async(v6, v14);
  v9 = v15;
  if (!v15)
    goto LABEL_11;
  v10 = (unint64_t *)&v15->__shared_owners_;
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - 1, v10));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if (!v3)
      return;
  }
  else
  {
LABEL_11:
    if (!v3)
      return;
  }
  v12 = (unint64_t *)&v3->__shared_owners_;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t __copy_helper_block_e8_32c47_ZTSNSt3__110shared_ptrI19MTEmbeddedStatsImplEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c47_ZTSNSt3__110shared_ptrI19MTEmbeddedStatsImplEE(uint64_t a1)
{
  return std::shared_ptr<MTEmbeddedStats>::~shared_ptr[abi:ne180100](a1 + 32);
}

uint64_t MTEmbeddedStats::deviceWillReset(MTEmbeddedStatsImpl **this)
{
  return MTEmbeddedStatsImpl::updateOpenRows(*this);
}

uint64_t MTEmbeddedStatsImpl::MTEmbeddedStatsImpl(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v4;
  _OWORD *v5;
  unsigned int v6;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_WORD *)(a1 + 16) = 0;
  v4 = (void *)(a1 + 24);
  v5 = (_OWORD *)(a1 + 2088);
  bzero((void *)(a1 + 24), 0x809uLL);
  *v5 = 0u;
  v6 = time(0);
  srand(v6);
  CFRetain(*(CFTypeRef *)a1);
  dispatch_retain(*(dispatch_object_t *)(a1 + 8));
  MTEmbeddedStatsImpl::configureAWDLogging((dispatch_queue_t *)a1);
  bzero(v4, 0x800uLL);
  *(_WORD *)(a1 + 16) = 0;
  return a1;
}

void MTEmbeddedStatsImpl::configureAWDLogging(dispatch_queue_t *this)
{
  NSObject *v2;
  NSObject *v3;
  _QWORD v4[5];
  uint64_t v5;
  uint8_t buf[4];
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = dispatch_source_create(MEMORY[0x24BDACA18], 0, 0, this[1]);
  this[261] = v2;
  if (!v2)
  {
    v5 = 0;
    MTDeviceGetDeviceID();
    v3 = MTLoggingPlugin();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      v7 = v5;
      _os_log_impl(&dword_231071000, v3, OS_LOG_TYPE_ERROR, "Couldn't create firmware log timer (deviceID 0x%llX)", buf, 0xCu);
    }
    v2 = this[261];
  }
  dispatch_source_set_timer(v2, 0, 0x13A52453C000uLL, 0x3B9ACA00uLL);
  v4[0] = MEMORY[0x24BDAC760];
  v4[1] = 3221225472;
  v4[2] = ___ZN19MTEmbeddedStatsImpl19configureAWDLoggingEv_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = this;
  ___ZN19MTEmbeddedStatsImpl19configureAWDLoggingEv_block_invoke((uint64_t)v4);
  dispatch_source_set_timer(this[261], 0x13A52453C000uLL, 0x13A52453C000uLL, 0x3B9ACA00uLL);
  dispatch_source_set_event_handler(this[261], v4);
  dispatch_resume(this[261]);
}

void ___ZN19MTEmbeddedStatsImpl19configureAWDLoggingEv_block_invoke(uint64_t a1)
{
  MTEmbeddedStatsImpl *v1;
  int Version;
  int v3;
  NSObject *v4;
  const char *v5;
  NSObject *v6;
  os_log_type_t v7;
  uint32_t v8;
  AWDMultitouchBootEvent *v9;
  NSObject *v10;
  unint64_t v11;
  AWDMultitouchHardwareStatus *v12;
  uint64_t i;
  NSObject *v14;
  uint8_t buf[4];
  _BYTE v16[18];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v1 = *(MTEmbeddedStatsImpl **)(a1 + 32);
  Version = MTDeviceGetVersion();
  if (Version)
  {
    v3 = Version;
    MTDeviceGetDeviceID();
    v4 = MTLoggingPlugin();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)v16 = v3;
    *(_WORD *)&v16[4] = 2048;
    *(_QWORD *)&v16[6] = 0;
    v5 = "Couldn't read firmware version: error 0x%08X (deviceID 0x%llX)";
    v6 = v4;
    v7 = OS_LOG_TYPE_ERROR;
    v8 = 18;
    goto LABEL_13;
  }
  v9 = objc_alloc_init(AWDMultitouchBootEvent);
  -[AWDMultitouchBootEvent setVersion:](v9, "setVersion:", 2863311530);
  AWDPostMetric();

  MTDeviceGetDeviceID();
  v10 = MTLoggingPlugin();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)v16 = -1431655766;
    *(_WORD *)&v16[4] = 2048;
    *(_QWORD *)&v16[6] = 0;
    _os_log_impl(&dword_231071000, v10, OS_LOG_TYPE_DEFAULT, "Logging firmware version 0x%X to AWD (deviceID 0x%llX)", buf, 0x12u);
  }
  if (MTEmbeddedStatsImpl::updateOpenRows(v1))
  {
    v11 = *((_QWORD *)v1 + 262);
    *((_QWORD *)v1 + 262) = 0;
    v12 = objc_alloc_init(AWDMultitouchHardwareStatus);
    for (i = 0; i != 64; ++i)
    {
      if (((v11 >> i) & 1) != 0)
        -[AWDMultitouchHardwareStatus addOpenRows:](v12, "addOpenRows:", i);
    }
    AWDPostMetric();

    MTDeviceGetDeviceID();
    v14 = MTLoggingPlugin();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)v16 = v11;
      *(_WORD *)&v16[8] = 2048;
      *(_QWORD *)&v16[10] = 0;
      v5 = "Logging open rows 0x%016llX to AWD (deviceID 0x%llX)";
      v6 = v14;
      v7 = OS_LOG_TYPE_DEFAULT;
      v8 = 22;
LABEL_13:
      _os_log_impl(&dword_231071000, v6, v7, v5, buf, v8);
    }
  }
}

double MTEmbeddedStatsImpl::handleContactForContactTracker(uint64_t a1, uint64_t a2, float *a3)
{
  int v6;
  float v7;
  float v8;
  NSObject *v9;
  int v10;
  uint64_t v11;
  unsigned __int8 v12;
  uint64_t v13;
  double v14;
  float v15;
  float v16;
  float v17;
  double result;
  NSObject *v19;
  int v20;
  uint64_t v21;
  uint8_t buf[4];
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v6 = a2 != 0;
  if (*(unsigned __int8 *)a3 == v6)
  {
    if (!a2)
      return result;
    v7 = a3[6];
    v8 = a3[7];
    goto LABEL_8;
  }
  *(_BYTE *)a3 = v6;
  if (a2)
  {
    MTDeviceGetDeviceID();
    v9 = MTLoggingPlugin();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      v10 = *(_DWORD *)(a2 + 24);
      v11 = *(_QWORD *)(a2 + 8);
      *(_DWORD *)buf = 67109632;
      v23 = v10;
      v24 = 2048;
      v25 = v11;
      v26 = 2048;
      v27 = 0;
      _os_log_impl(&dword_231071000, v9, OS_LOG_TYPE_DEBUG, "F%d [%f] : Touching (deviceID 0x%llX)", buf, 0x1Cu);
    }
    *((_QWORD *)a3 + 1) = *(_QWORD *)(a2 + 8);
    *((_DWORD *)a3 + 9) = *(unsigned __int16 *)(a2 + 84);
    v12 = *(_BYTE *)(a1 + 17);
    *((_BYTE *)a3 + 1) = v12;
    *(_BYTE *)(a1 + 17) = v12 + 1;
    v13 = *(_QWORD *)(a2 + 68);
    *((_QWORD *)a3 + 3) = v13;
    v8 = *((float *)&v13 + 1);
    v7 = *(float *)&v13;
LABEL_8:
    a3[1] = *(float *)(a2 + 24);
    v14 = *(double *)(a2 + 8);
    *((double *)a3 + 2) = v14;
    v15 = *(float *)(a2 + 68);
    v16 = *(float *)(a2 + 72);
    v17 = a3[8] + sqrtf((float)((float)(v15 - v7) * (float)(v15 - v7)) + (float)((float)(v16 - v8) * (float)(v16 - v8)));
    a3[7] = v16;
    a3[8] = v17;
    a3[6] = v15;
    MTEmbeddedStatsImpl::handleContactRadiiStats(v14, *(float *)(a2 + 60), *(float *)(a2 + 64), a1, (uint64_t)a3);
    return result;
  }
  MTDeviceGetDeviceID();
  v19 = MTLoggingPlugin();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
  {
    v20 = *((_DWORD *)a3 + 1);
    v21 = *((_QWORD *)a3 + 2);
    *(_DWORD *)buf = 67109632;
    v23 = v20;
    v24 = 2048;
    v25 = v21;
    v26 = 2048;
    v27 = 0;
    _os_log_impl(&dword_231071000, v19, OS_LOG_TYPE_DEBUG, "F%d [%f] : Not touching (deviceID 0x%llX)", buf, 0x1Cu);
  }
  MTEmbeddedStatsImpl::logAndFlushRadiiStatsWithContactIdentity(a1, (unsigned int *)a3);
  result = 0.0;
  *((_OWORD *)a3 + 2) = 0u;
  *((_OWORD *)a3 + 3) = 0u;
  *(_OWORD *)a3 = 0u;
  *((_OWORD *)a3 + 1) = 0u;
  return result;
}

uint64_t MTEmbeddedStatsImpl::logDurationBetweenTouches(uint64_t this, double a2)
{
  uint64_t v3;
  unint64_t v4;
  double v5;
  const __CFString *v6;
  _QWORD v7[2];

  v7[1] = *MEMORY[0x24BDAC8D0];
  if (*(double *)(this + 2072) > 0.0)
  {
    v3 = this;
    this = rand();
    HIDWORD(v4) = -1030792151 * this + 85899344;
    LODWORD(v4) = HIDWORD(v4);
    if ((v4 >> 2) <= 0x28F5C28)
    {
      v5 = a2 - *(double *)(v3 + 2072);
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%s.%s"), "com.apple.Multitouch.EmbeddedStatistics", "DurationBetweenTouches");
      v6 = CFSTR("Duration");
      v7[0] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", v5);
      objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v7, &v6, 1);
      return AnalyticsSendEventLazy();
    }
  }
  return this;
}

uint64_t MTEmbeddedStatsImpl::logAndFlushRadiiStatsWithContactIdentity(uint64_t a1, unsigned int *a2)
{
  uint64_t result;
  unint64_t v4;
  double v5;
  double v6;
  double v7;
  double v8;
  _QWORD v9[6];
  _QWORD v10[7];

  v10[6] = *MEMORY[0x24BDAC8D0];
  result = rand();
  HIDWORD(v4) = -1030792151 * result + 85899344;
  LODWORD(v4) = HIDWORD(v4);
  if ((v4 >> 2) <= 0x28F5C28)
  {
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%s.%s"), "com.apple.Multitouch.EmbeddedStatistics", "LiftoffPathStats");
    v9[0] = CFSTR("MinGeometricMean");
    LODWORD(v5) = a2[10];
    v10[0] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v5);
    v9[1] = CFSTR("MaxGeometricMean");
    LODWORD(v6) = a2[12];
    v10[1] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v6);
    v9[2] = CFSTR("EccentricityForMin");
    LODWORD(v7) = a2[11];
    v10[2] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v7);
    v9[3] = CFSTR("EccentricityForMax");
    LODWORD(v8) = a2[13];
    v10[3] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v8);
    v9[4] = CFSTR("InitialTouchIdentity");
    v10[4] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", a2[14]);
    v9[5] = CFSTR("LiftoffTouchIdentity");
    v10[5] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", a2[1]);
    objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v10, v9, 6);
    return AnalyticsSendEventLazy();
  }
  return result;
}

void MTEmbeddedStatsImpl::handleContactRadiiStats(double a1, float a2, float a3, uint64_t a4, uint64_t a5)
{
  float v5;
  float v6;
  float v7;

  if (*(double *)(a5 + 8) == a1)
  {
    *(_OWORD *)(a5 + 40) = xmmword_2310BE500;
    *(_DWORD *)(a5 + 56) = *(_DWORD *)(a5 + 4);
    v5 = 3.4028e38;
  }
  else
  {
    v5 = *(float *)(a5 + 40);
  }
  v6 = sqrtf(a2 * a3);
  v7 = a2 / a3;
  if (v6 < v5)
  {
    *(float *)(a5 + 40) = v6;
    *(float *)(a5 + 44) = v7;
  }
  if (v6 > *(float *)(a5 + 48))
  {
    *(float *)(a5 + 48) = v6;
    *(float *)(a5 + 52) = v7;
  }
}

uint64_t ___ZN19MTEmbeddedStatsImpl18sendAnalyticsEventEP8NSStringP12NSDictionaryIS1_P8NSObjectE_block_invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

_QWORD *std::shared_ptr<MTEmbeddedStatsImpl>::shared_ptr[abi:ne180100]<MTEmbeddedStatsImpl,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_24FFF3358;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_2310B9F24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<MTEmbeddedStatsImpl>::reset[abi:ne180100]((MTEmbeddedStatsImpl **)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<MTEmbeddedStatsImpl *,std::shared_ptr<MTEmbeddedStatsImpl>::__shared_ptr_default_delete<MTEmbeddedStatsImpl,MTEmbeddedStatsImpl>,std::allocator<MTEmbeddedStatsImpl>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2348D0034);
}

MTEmbeddedStatsImpl *std::__shared_ptr_pointer<MTEmbeddedStatsImpl *,std::shared_ptr<MTEmbeddedStatsImpl>::__shared_ptr_default_delete<MTEmbeddedStatsImpl,MTEmbeddedStatsImpl>,std::allocator<MTEmbeddedStatsImpl>>::__on_zero_shared(uint64_t a1)
{
  MTEmbeddedStatsImpl *result;

  result = *(MTEmbeddedStatsImpl **)(a1 + 24);
  if (result)
  {
    MTEmbeddedStatsImpl::~MTEmbeddedStatsImpl(result);
    JUMPOUT(0x2348D0034);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<MTEmbeddedStatsImpl *,std::shared_ptr<MTEmbeddedStatsImpl>::__shared_ptr_default_delete<MTEmbeddedStatsImpl,MTEmbeddedStatsImpl>,std::allocator<MTEmbeddedStatsImpl>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void MTEmbeddedStatsImpl::~MTEmbeddedStatsImpl(MTEmbeddedStatsImpl *this)
{
  NSObject *v2;

  v2 = *((_QWORD *)this + 261);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 261));
  }
  dispatch_release(*((dispatch_object_t *)this + 1));
  CFRelease(*(CFTypeRef *)this);
}

MTEmbeddedStatsImpl *std::unique_ptr<MTEmbeddedStatsImpl>::reset[abi:ne180100](MTEmbeddedStatsImpl **a1, MTEmbeddedStatsImpl *a2)
{
  MTEmbeddedStatsImpl *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    MTEmbeddedStatsImpl::~MTEmbeddedStatsImpl(result);
    JUMPOUT(0x2348D0034);
  }
  return result;
}

void std::__shared_ptr_emplace<std::vector<TouchingContact>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24FFF33D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<TouchingContact>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24FFF33D0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2348D0034);
}

void std::__shared_ptr_emplace<std::vector<TouchingContact>>::__on_zero_shared(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<TouchingContact>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(104 * a2);
}

uint64_t AWDMultitouchBootEventReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  char v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char v28;
  uint64_t result;

  v3 = (int *)MEMORY[0x24BE7AF68];
  v4 = (int *)MEMORY[0x24BE7AF58];
  v5 = (int *)MEMORY[0x24BE7AF40];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x24BE7AF68]) < *(_QWORD *)(a2 + (int)*MEMORY[0x24BE7AF58]))
  {
    v7 = (int *)MEMORY[0x24BE7AF38];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 2)
      {
        v23 = 0;
        v24 = 0;
        v25 = 0;
        *(_BYTE *)(a1 + 20) |= 2u;
        while (1)
        {
          v26 = *v3;
          v27 = *(_QWORD *)(a2 + v26);
          if (v27 == -1 || v27 >= *(_QWORD *)(a2 + *v4))
            break;
          v28 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v27);
          *(_QWORD *)(a2 + v26) = v27 + 1;
          v25 |= (unint64_t)(v28 & 0x7F) << v23;
          if ((v28 & 0x80) == 0)
            goto LABEL_41;
          v23 += 7;
          v14 = v24++ >= 9;
          if (v14)
          {
            LODWORD(v25) = 0;
            goto LABEL_43;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_41:
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v25) = 0;
LABEL_43:
        *(_DWORD *)(a1 + 16) = v25;
      }
      else if ((v10 >> 3) == 1)
      {
        v17 = 0;
        v18 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 20) |= 1u;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            break;
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            goto LABEL_37;
          v17 += 7;
          v14 = v18++ >= 9;
          if (v14)
          {
            v19 = 0;
            goto LABEL_39;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_37:
        if (*(_BYTE *)(a2 + *v5))
          v19 = 0;
LABEL_39:
        *(_QWORD *)(a1 + 8) = v19;
      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t AWDMultitouchHardwareStatusReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  int v16;
  char v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char v23;
  uint64_t result;
  char v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  char v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char v36;

  v3 = (int *)MEMORY[0x24BE7AF68];
  v4 = (int *)MEMORY[0x24BE7AF58];
  v5 = (int *)MEMORY[0x24BE7AF40];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x24BE7AF68]) < *(_QWORD *)(a2 + (int)*MEMORY[0x24BE7AF58]))
  {
    v7 = (int *)MEMORY[0x24BE7AF38];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      v16 = v10 & 7;
      if (v15 || v16 == 4)
        break;
      if ((v10 >> 3) == 2)
      {
        if (v16 == 2)
        {
          result = PBReaderPlaceMark();
          if (!(_DWORD)result)
            return result;
          while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4) && !*(_BYTE *)(a2 + *v5))
          {
            v25 = 0;
            v26 = 0;
            v27 = 0;
            while (1)
            {
              v28 = *v3;
              v29 = *(_QWORD *)(a2 + v28);
              if (v29 == -1 || v29 >= *(_QWORD *)(a2 + *v4))
                break;
              v30 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v29);
              *(_QWORD *)(a2 + v28) = v29 + 1;
              v27 |= (unint64_t)(v30 & 0x7F) << v25;
              if (v30 < 0)
              {
                v25 += 7;
                v14 = v26++ >= 9;
                if (!v14)
                  continue;
              }
              goto LABEL_39;
            }
            *(_BYTE *)(a2 + *v5) = 1;
LABEL_39:
            PBRepeatedUInt32Add();
          }
          PBReaderRecallMark();
        }
        else
        {
          v31 = 0;
          v32 = 0;
          v33 = 0;
          while (1)
          {
            v34 = *v3;
            v35 = *(_QWORD *)(a2 + v34);
            if (v35 == -1 || v35 >= *(_QWORD *)(a2 + *v4))
              break;
            v36 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v35);
            *(_QWORD *)(a2 + v34) = v35 + 1;
            v33 |= (unint64_t)(v36 & 0x7F) << v31;
            if (v36 < 0)
            {
              v31 += 7;
              v14 = v32++ >= 9;
              if (!v14)
                continue;
            }
            goto LABEL_55;
          }
          *(_BYTE *)(a2 + *v5) = 1;
LABEL_55:
          PBRepeatedUInt32Add();
        }
      }
      else if ((v10 >> 3) == 1)
      {
        v18 = 0;
        v19 = 0;
        v20 = 0;
        *(_BYTE *)(a1 + 40) |= 1u;
        while (1)
        {
          v21 = *v3;
          v22 = *(_QWORD *)(a2 + v21);
          if (v22 == -1 || v22 >= *(_QWORD *)(a2 + *v4))
            break;
          v23 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v22);
          *(_QWORD *)(a2 + v21) = v22 + 1;
          v20 |= (unint64_t)(v23 & 0x7F) << v18;
          if ((v23 & 0x80) == 0)
            goto LABEL_43;
          v18 += 7;
          v14 = v19++ >= 9;
          if (v14)
          {
            v20 = 0;
            goto LABEL_45;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_43:
        if (*(_BYTE *)(a2 + *v5))
          v20 = 0;
LABEL_45:
        *(_QWORD *)(a1 + 32) = v20;
      }
      else if ((PBReaderSkipValueWithTag() & 1) == 0)
      {
        return 0;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void MultitouchHIDClass::start(int a1, NSObject *a2)
{
  _DWORD v2[2];
  uint64_t v3;

  v3 = *MEMORY[0x24BDAC8D0];
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl(&dword_231071000, a2, OS_LOG_TYPE_ERROR, "Invalid parserType: %d", (uint8_t *)v2, 8u);
}

void IOHIDPlugInFactory_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  dlerror();
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_231071000, MEMORY[0x24BDACB70], v0, "dlopen failed for %{public}@: %{public}s", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_2();
}

void IOHIDPlugInFactory_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t v5;

  dlerror();
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_231071000, MEMORY[0x24BDACB70], v0, "dlsym returned null for symbol '%{public}@': %{public}s", v1, v2, v3, v4, v5);
  OUTLINED_FUNCTION_2();
}

void MTHandMotion::clearHandMotion(char a1, NSObject *a2)
{
  _DWORD v2[2];
  uint64_t v3;

  v3 = *MEMORY[0x24BDAC8D0];
  v2[0] = 67109120;
  v2[1] = a1 & 1;
  _os_log_debug_impl(&dword_231071000, a2, OS_LOG_TYPE_DEBUG, "\tDHML:  MTHandMotion::resetHandMotion(%d)", (uint8_t *)v2, 8u);
}

void MTParser::retain()
{
  __assert_rtn("retain", "MTParser.cpp", 195, "_retainCount != 0");
}

void MTParser::release()
{
  __assert_rtn("release", "MTParser.cpp", 203, "_retainCount != 0");
}

void MTParserPath::filterContactForScreenUI(uint64_t a1, int *a2, os_log_t log)
{
  int v3;
  int v4;
  int v5;
  _DWORD v6[2];
  __int16 v7;
  int v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)(a1 + 40);
  v4 = *a2;
  v5 = *(_DWORD *)(a1 + 144);
  v6[0] = 67109632;
  v6[1] = v3;
  v7 = 1024;
  v8 = v4;
  v9 = 1024;
  v10 = v5;
  _os_log_debug_impl(&dword_231071000, log, OS_LOG_TYPE_DEBUG, "\tDHML:  P%d Identity=%d <- %d (ignoring motion)", (uint8_t *)v6, 0x14u);
}

void MTParserPath::filterContactForScreenUI(uint64_t a1, uint64_t a2, NSObject *a3)
{
  int v4;
  _DWORD v5[2];
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v4 = *(_DWORD *)(a1 + 40);
  v5[0] = 67109378;
  v5[1] = v4;
  v6 = 2080;
  v7 = MTGetPathStageName();
  _os_log_debug_impl(&dword_231071000, a3, OS_LOG_TYPE_DEBUG, "\tDHML:  P%d Hover (stage %s -- ignoring motion)", (uint8_t *)v5, 0x12u);
}

void MTSLGLogger::registerControlInterface()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_0();
  OUTLINED_FUNCTION_0_0(&dword_231071000, v0, v1, "StudyLog logger: could not create notification port for control interface", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_0();
}

void MTSLGLogger::registerControlInterface(unsigned int *a1, int a2, os_log_t log)
{
  uint64_t v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v3 = *a1;
  v4[0] = 67109376;
  v4[1] = a2;
  v5 = 2048;
  v6 = v3;
  _os_log_error_impl(&dword_231071000, log, OS_LOG_TYPE_ERROR, "StudyLog logger: could not register for control interface 0x%08x (deviceIterator: 0x%08jx)", (uint8_t *)v4, 0x12u);
}

void MTSLGLogger::addControlService()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_0();
  OUTLINED_FUNCTION_0_0(&dword_231071000, v0, v1, "StudyLog logger: could not create MT device for control interface", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_0();
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_0();
  OUTLINED_FUNCTION_0_0(&dword_231071000, v0, v1, "StudyLog logger: could not create dispatch source for control interface", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_0();
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_0();
  OUTLINED_FUNCTION_0_0(&dword_231071000, v0, v1, "StudyLog logger: could not register callbacks for control interface", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_0();
}

void MTSLGLogger::addControlService(int a1, NSObject *a2)
{
  _DWORD v2[2];
  uint64_t v3;

  v3 = *MEMORY[0x24BDAC8D0];
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl(&dword_231071000, a2, OS_LOG_TYPE_ERROR, "StudyLog logger: could not start MT device for control interface 0x%08x", (uint8_t *)v2, 8u);
  OUTLINED_FUNCTION_1_0();
}

void MTSimpleEventDispatcher::retain()
{
  __assert_rtn("retain", "MTSimpleEventDispatcher.cpp", 115, "_retainCount != 0");
}

void MTSimpleEventDispatcher::release()
{
  __assert_rtn("release", "MTSimpleEventDispatcher.cpp", 123, "_retainCount != 0");
}

void MTSimpleHIDManager::retain()
{
  __assert_rtn("retain", "MTSimpleHIDManager.cpp", 227, "_retainCount != 0");
}

void MTSimpleHIDManager::release()
{
  __assert_rtn("release", "MTSimpleHIDManager.cpp", 235, "_retainCount != 0");
}

void MTSimpleHIDManager::setPowerState()
{
  __assert_rtn("setPowerState", "MTSimpleHIDManager.cpp", 2481, "!_modeSwitcher");
}

void MTSimpleHIDManager::setPowerStateWithReset()
{
  __assert_rtn("setPowerStateWithReset", "MTSimpleHIDManager.cpp", 2504, "!_modeSwitcher");
}

void MTPowerLogger::retain(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_1("retain", "MTPowerLogger.mm", a3, "_retainCount != 0");
}

void MTPowerLogger::release()
{
  __assert_rtn("release", "MTPowerLogger.mm", 80, "_retainCount != 0");
}

void MTForceManagement::actuateForceAndHIDEvents(MTActuatorManagement *a1, uint64_t a2, NSObject *a3)
{
  uint64_t ActuatorRef;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  ActuatorRef = MTActuatorManagement::getActuatorRef(a1);
  v6 = *(unsigned __int8 *)(a2 + 594);
  v7 = *(unsigned __int8 *)(a2 + 595);
  v8 = 134218496;
  v9 = ActuatorRef;
  v10 = 1024;
  v11 = v6;
  v12 = 1024;
  v13 = v7;
  _os_log_debug_impl(&dword_231071000, a3, OS_LOG_TYPE_DEBUG, "[HID] Skipping actuation : %p %u %u", (uint8_t *)&v8, 0x18u);
}

uint64_t AWDPostMetric()
{
  return MEMORY[0x24BEC2B08]();
}

uint64_t AnalyticsSendEventLazy()
{
  return MEMORY[0x24BE1A1C0]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x24BDBB780]();
  return result;
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x24BDBB7C8](theArray, value);
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
  MEMORY[0x24BDBB7D8](theArray, range.location, range.length, applier, context);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x24BDBB7F8](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x24BDBB808](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x24BDBB820](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x24BDBB850]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x24BDBB860](theArray, idx);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  MEMORY[0x24BDBB880](theArray, idx);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x24BDBBA18]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x24BDBBA20](BOOLean);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x24BDBBCE0](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x24BDBBCF8](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x24BDBBD08]();
}

CFDateFormatterRef CFDateFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return (CFDateFormatterRef)MEMORY[0x24BDBBD40](allocator, locale, dateStyle, timeStyle);
}

CFStringRef CFDateFormatterCreateStringWithAbsoluteTime(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFAbsoluteTime at)
{
  return (CFStringRef)MEMORY[0x24BDBBD60](allocator, formatter, at);
}

void CFDateFormatterSetProperty(CFDateFormatterRef formatter, CFStringRef key, CFTypeRef value)
{
  MEMORY[0x24BDBBD90](formatter, key, value);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBDB0](theDict, key, value);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x24BDBBDE0](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF0](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF8](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x24BDBBE00](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
  MEMORY[0x24BDBBE10](theDict, keys, values);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x24BDBBE18]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x24BDBBE30](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x24BDBBE38](theDict, key, value);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
  MEMORY[0x24BDBBE40](theDict);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x24BDBBE48](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBE60](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x24BDBBE68](cf1, cf2);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x24BDBBEF8](cf);
}

CFTypeRef CFMakeCollectable(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x24BDBBFE8](cf);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
  MEMORY[0x24BDBC040](center, observer, callBack, name, object, suspensionBehavior);
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x24BDBC050]();
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
  MEMORY[0x24BDBC088](center, observer, name, object);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x24BDBC0A0](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x24BDBC118]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x24BDBC130](number, theType, valuePtr);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return MEMORY[0x24BDBC138](number);
}

void CFPlugInAddInstanceForFactory(CFUUIDRef factoryID)
{
  MEMORY[0x24BDBC140](factoryID);
}

void CFPlugInRemoveInstanceForFactory(CFUUIDRef factoryID)
{
  MEMORY[0x24BDBC148](factoryID);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x24BDBC188](key, applicationID, keyExistsAndHasValidFormat);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x24BDBC298](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x24BDBC2A8](cf);
}

void CFShow(CFTypeRef obj)
{
  MEMORY[0x24BDBC438](obj);
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
  MEMORY[0x24BDBC4A8](theString, appendedString);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x24BDBC4D0](theString1, theString2, compareOptions);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x24BDBC540](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x24BDBC568](alloc, cStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x24BDBC598](alloc, formatOptions, format);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3;
  CFIndex v4;
  CFRange result;

  v3 = MEMORY[0x24BDBC5D0](theString, stringToFind, compareOptions);
  result.length = v4;
  result.location = v3;
  return result;
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x24BDBC610](theString, *(_QWORD *)&encoding);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x24BDBC650](str);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x24BDBC698]();
}

CFTimeZoneRef CFTimeZoneCopySystem(void)
{
  return (CFTimeZoneRef)MEMORY[0x24BDBC760]();
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)MEMORY[0x24BDBC8E0](alloc, *(_QWORD *)&bytes.byte0, *(_QWORD *)&bytes.byte8);
}

CFUUIDRef CFUUIDGetConstantUUIDWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)MEMORY[0x24BDBC8F8](alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6);
}

IOReturn IOAllowPowerChange(io_connect_t kernelPort, intptr_t notificationID)
{
  return MEMORY[0x24BDD7EA8](*(_QWORD *)&kernelPort, notificationID);
}

CFTypeRef IOCFUnserializeBinary(const char *buffer, size_t bufferSize, CFAllocatorRef allocator, CFOptionFlags options, CFStringRef *errorString)
{
  return (CFTypeRef)MEMORY[0x24BDD7EC8](buffer, bufferSize, allocator, options, errorString);
}

IOReturn IODeregisterForSystemPower(io_object_t *notifier)
{
  return MEMORY[0x24BDD7FC8](notifier);
}

uint64_t IOHIDEventAppendEvent()
{
  return MEMORY[0x24BDD8148]();
}

uint64_t IOHIDEventConformsTo()
{
  return MEMORY[0x24BDD8150]();
}

uint64_t IOHIDEventCreateBoundaryScrollEvent()
{
  return MEMORY[0x24BDD8170]();
}

uint64_t IOHIDEventCreateButtonEvent()
{
  return MEMORY[0x24BDD8178]();
}

uint64_t IOHIDEventCreateCopy()
{
  return MEMORY[0x24BDD8188]();
}

uint64_t IOHIDEventCreateDigitizerEvent()
{
  return MEMORY[0x24BDD8190]();
}

uint64_t IOHIDEventCreateDigitizerFingerEventWithQuality()
{
  return MEMORY[0x24BDD81A0]();
}

uint64_t IOHIDEventCreateDigitizerStylusEventWithPolarOrientation()
{
  return MEMORY[0x24BDD81A8]();
}

uint64_t IOHIDEventCreateDockSwipeEvent()
{
  return MEMORY[0x24BDD81B0]();
}

uint64_t IOHIDEventCreateFluidTouchGestureEvent()
{
  return MEMORY[0x24BDD81B8]();
}

uint64_t IOHIDEventCreateForceEvent()
{
  return MEMORY[0x24BDD81C0]();
}

uint64_t IOHIDEventCreateKeyboardEvent()
{
  return MEMORY[0x24BDD81D8]();
}

uint64_t IOHIDEventCreateMouseEvent()
{
  return MEMORY[0x24BDD81E0]();
}

uint64_t IOHIDEventCreateNavigationSwipeEvent()
{
  return MEMORY[0x24BDD81E8]();
}

uint64_t IOHIDEventCreatePolarOrientationEvent()
{
  return MEMORY[0x24BDD81F0]();
}

uint64_t IOHIDEventCreateProximtyEvent()
{
  return MEMORY[0x24BDD81F8]();
}

uint64_t IOHIDEventCreateRelativePointerEvent()
{
  return MEMORY[0x24BDD8200]();
}

uint64_t IOHIDEventCreateRotationEvent()
{
  return MEMORY[0x24BDD8208]();
}

uint64_t IOHIDEventCreateScaleEvent()
{
  return MEMORY[0x24BDD8210]();
}

uint64_t IOHIDEventCreateScrollEvent()
{
  return MEMORY[0x24BDD8218]();
}

uint64_t IOHIDEventCreateSwipeEvent()
{
  return MEMORY[0x24BDD8220]();
}

uint64_t IOHIDEventCreateSymbolicHotKeyEvent()
{
  return MEMORY[0x24BDD8228]();
}

uint64_t IOHIDEventCreateTranslationEvent()
{
  return MEMORY[0x24BDD8238]();
}

uint64_t IOHIDEventCreateVelocityEvent()
{
  return MEMORY[0x24BDD8240]();
}

uint64_t IOHIDEventCreateVendorDefinedEvent()
{
  return MEMORY[0x24BDD8248]();
}

uint64_t IOHIDEventCreateZoomToggleEvent()
{
  return MEMORY[0x24BDD8258]();
}

uint64_t IOHIDEventGetChildren()
{
  return MEMORY[0x24BDD8260]();
}

uint64_t IOHIDEventGetDoubleValue()
{
  return MEMORY[0x24BDD8270]();
}

uint64_t IOHIDEventGetEvent()
{
  return MEMORY[0x24BDD8278]();
}

uint64_t IOHIDEventGetEventFlags()
{
  return MEMORY[0x24BDD8280]();
}

uint64_t IOHIDEventGetFloatValue()
{
  return MEMORY[0x24BDD8290]();
}

uint64_t IOHIDEventGetIntegerValue()
{
  return MEMORY[0x24BDD8298]();
}

uint64_t IOHIDEventGetPhase()
{
  return MEMORY[0x24BDD82A8]();
}

uint64_t IOHIDEventGetScrollMomentum()
{
  return MEMORY[0x24BDD82B0]();
}

uint64_t IOHIDEventGetTimeStamp()
{
  return MEMORY[0x24BDD82C0]();
}

uint64_t IOHIDEventGetType()
{
  return MEMORY[0x24BDD82D0]();
}

uint64_t IOHIDEventGetVendorDefinedData()
{
  return MEMORY[0x24BDD82E8]();
}

uint64_t IOHIDEventIsAbsolute()
{
  return MEMORY[0x24BDD82F0]();
}

uint64_t IOHIDEventRemoveEvent()
{
  return MEMORY[0x24BDD8300]();
}

uint64_t IOHIDEventSetEventFlags()
{
  return MEMORY[0x24BDD8310]();
}

uint64_t IOHIDEventSetFloatValue()
{
  return MEMORY[0x24BDD8318]();
}

uint64_t IOHIDEventSetIntegerValue()
{
  return MEMORY[0x24BDD8320]();
}

uint64_t IOHIDEventSetPhase()
{
  return MEMORY[0x24BDD8328]();
}

uint64_t IOHIDEventSetScrollMomentum()
{
  return MEMORY[0x24BDD8338]();
}

uint64_t IOHIDEventSetTimeStamp()
{
  return MEMORY[0x24BDD8348]();
}

uint64_t IOHIDEventTypeGetName()
{
  return MEMORY[0x24BDD8468]();
}

uint64_t IOHIDPreferencesCopy()
{
  return MEMORY[0x24BDD8500]();
}

uint64_t IOHIDPreferencesCopyDomain()
{
  return MEMORY[0x24BDD8508]();
}

uint64_t IOHIDPreferencesSet()
{
  return MEMORY[0x24BDD8510]();
}

uint64_t IOHIDPreferencesSynchronize()
{
  return MEMORY[0x24BDD8518]();
}

BOOLean_t IOIteratorIsValid(io_iterator_t iterator)
{
  return MEMORY[0x24BDD8660](*(_QWORD *)&iterator);
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return MEMORY[0x24BDD8668](*(_QWORD *)&iterator);
}

void IOIteratorReset(io_iterator_t iterator)
{
  MEMORY[0x24BDD8670](*(_QWORD *)&iterator);
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  return (IONotificationPortRef)MEMORY[0x24BDD8690](*(_QWORD *)&mainPort);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
  MEMORY[0x24BDD8698](notify);
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
  MEMORY[0x24BDD86B0](notify, queue);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x24BDD86F8](*(_QWORD *)&object);
}

kern_return_t IOObjectRetain(io_object_t object)
{
  return MEMORY[0x24BDD8700](*(_QWORD *)&object);
}

IOReturn IOPMAssertionCreateWithName(CFStringRef AssertionType, IOPMAssertionLevel AssertionLevel, CFStringRef AssertionName, IOPMAssertionID *AssertionID)
{
  return MEMORY[0x24BDD8718](AssertionType, *(_QWORD *)&AssertionLevel, AssertionName, AssertionID);
}

IOReturn IOPMAssertionRelease(IOPMAssertionID AssertionID)
{
  return MEMORY[0x24BDD8740](*(_QWORD *)&AssertionID);
}

io_connect_t IORegisterForSystemPower(void *refcon, IONotificationPortRef *thePortRef, IOServiceInterestCallback callback, io_object_t *notifier)
{
  return MEMORY[0x24BDD8888](refcon, thePortRef, callback, notifier);
}

kern_return_t IORegistryEntryCreateCFProperties(io_registry_entry_t entry, CFMutableDictionaryRef *properties, CFAllocatorRef allocator, IOOptionBits options)
{
  return MEMORY[0x24BDD88A8](*(_QWORD *)&entry, properties, allocator, *(_QWORD *)&options);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x24BDD88B0](*(_QWORD *)&entry, key, allocator, *(_QWORD *)&options);
}

kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t *entryID)
{
  return MEMORY[0x24BDD8910](*(_QWORD *)&entry, entryID);
}

kern_return_t IORegistryEntrySetCFProperty(io_registry_entry_t entry, CFStringRef propertyName, CFTypeRef property)
{
  return MEMORY[0x24BDD8938](*(_QWORD *)&entry, propertyName, property);
}

uint64_t IOReportChannelGetCategories()
{
  return MEMORY[0x24BED4AB0]();
}

uint64_t IOReportCopyChannelsForDriver()
{
  return MEMORY[0x24BED4AF8]();
}

uint64_t IOReportCreateSamples()
{
  return MEMORY[0x24BED4B20]();
}

uint64_t IOReportCreateSubscription()
{
  return MEMORY[0x24BED4B30]();
}

uint64_t IOReportGetChannelCount()
{
  return MEMORY[0x24BED4B38]();
}

uint64_t IOReportPrune()
{
  return MEMORY[0x24BED4B78]();
}

kern_return_t IOServiceAddInterestNotification(IONotificationPortRef notifyPort, io_service_t service, const io_name_t interestType, IOServiceInterestCallback callback, void *refCon, io_object_t *notification)
{
  return MEMORY[0x24BDD8958](notifyPort, *(_QWORD *)&service, interestType, callback, refCon, notification);
}

kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
{
  return MEMORY[0x24BDD8960](notifyPort, notificationType, matching, callback, refCon, notification);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return MEMORY[0x24BDD8970](*(_QWORD *)&connect);
}

kern_return_t IOServiceGetMatchingServices(mach_port_t mainPort, CFDictionaryRef matching, io_iterator_t *existing)
{
  return MEMORY[0x24BDD8990](*(_QWORD *)&mainPort, matching, existing);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDD89A8](name);
}

CFMutableDictionaryRef IOServiceNameMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDD89B0](name);
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x24BED8468]();
}

uint64_t MTAbsoluteTimeGetCurrent()
{
  return MEMORY[0x24BE690B0]();
}

uint64_t MTActuatorActuate()
{
  return MEMORY[0x24BE690B8]();
}

uint64_t MTActuatorClose()
{
  return MEMORY[0x24BE690C0]();
}

uint64_t MTActuatorGetReport()
{
  return MEMORY[0x24BE690C8]();
}

uint64_t MTActuatorGetService()
{
  return MEMORY[0x24BE690D0]();
}

uint64_t MTActuatorGetSystemActuationsEnabled()
{
  return MEMORY[0x24BE690D8]();
}

uint64_t MTActuatorIsOpen()
{
  return MEMORY[0x24BE690E0]();
}

uint64_t MTActuatorLoadActuations()
{
  return MEMORY[0x24BE690E8]();
}

uint64_t MTActuatorOpen()
{
  return MEMORY[0x24BE690F0]();
}

uint64_t MTActuatorReclaimHostClickControl()
{
  return MEMORY[0x24BE690F8]();
}

uint64_t MTActuatorSetFirmwareClicks()
{
  return MEMORY[0x24BE69100]();
}

uint64_t MTActuatorSetReport()
{
  return MEMORY[0x24BE69108]();
}

uint64_t MTContact_getEllipseEccentricity()
{
  return MEMORY[0x24BE69110]();
}

uint64_t MTContact_getEllipseOrientationDegrees()
{
  return MEMORY[0x24BE69118]();
}

uint64_t MTContact_isActive()
{
  return MEMORY[0x24BE69120]();
}

uint64_t MTDeviceCopyDeviceUsagePairs()
{
  return MEMORY[0x24BE69128]();
}

uint64_t MTDeviceCreateFromService()
{
  return MEMORY[0x24BE69130]();
}

uint64_t MTDeviceCreateMultitouchDispatchSource()
{
  return MEMORY[0x24BE69138]();
}

uint64_t MTDeviceDispatchKeyboardEvent()
{
  return MEMORY[0x24BE69140]();
}

uint64_t MTDeviceDriverIsReady()
{
  return MEMORY[0x24BE69148]();
}

uint64_t MTDeviceEnableBinaryFilters()
{
  return MEMORY[0x24BE69150]();
}

uint64_t MTDeviceEnableWorkIntervalNotification()
{
  return MEMORY[0x24BE69158]();
}

uint64_t MTDeviceGetAccurateMaxDigitizerPressureValue()
{
  return MEMORY[0x24BE69160]();
}

uint64_t MTDeviceGetCriticalErrors()
{
  return MEMORY[0x24BE69168]();
}

uint64_t MTDeviceGetDeviceID()
{
  return MEMORY[0x24BE69170]();
}

uint64_t MTDeviceGetDeviceTimestampOffset()
{
  return MEMORY[0x24BE69178]();
}

uint64_t MTDeviceGetExtendedMaxDigitizerPressureValue()
{
  return MEMORY[0x24BE69180]();
}

uint64_t MTDeviceGetFamilyID()
{
  return MEMORY[0x24BE69188]();
}

uint64_t MTDeviceGetForceThresholdForMotion()
{
  return MEMORY[0x24BE69190]();
}

uint64_t MTDeviceGetMTActuator()
{
  return MEMORY[0x24BE69198]();
}

uint64_t MTDeviceGetMaxHoverHeightValue()
{
  return MEMORY[0x24BE691A0]();
}

uint64_t MTDeviceGetMinDigitizerPressureValue()
{
  return MEMORY[0x24BE691A8]();
}

uint64_t MTDeviceGetMultipleFirmwaresConfig()
{
  return MEMORY[0x24BE691B0]();
}

uint64_t MTDeviceGetOpenRows()
{
  return MEMORY[0x24BE691B8]();
}

uint64_t MTDeviceGetParserOptions()
{
  return MEMORY[0x24BE691C0]();
}

uint64_t MTDeviceGetParserType()
{
  return MEMORY[0x24BE691C8]();
}

uint64_t MTDeviceGetReport()
{
  return MEMORY[0x24BE691D0]();
}

uint64_t MTDeviceGetResetOnLockMs()
{
  return MEMORY[0x24BE691D8]();
}

uint64_t MTDeviceGetResetOnUnlockMs()
{
  return MEMORY[0x24BE691E0]();
}

uint64_t MTDeviceGetSATelemetryReportID()
{
  return MEMORY[0x24BE691E8]();
}

uint64_t MTDeviceGetSensorDimensions()
{
  return MEMORY[0x24BE691F0]();
}

uint64_t MTDeviceGetSensorRegionOfType()
{
  return MEMORY[0x24BE691F8]();
}

uint64_t MTDeviceGetSensorSurfaceDimensions()
{
  return MEMORY[0x24BE69200]();
}

uint64_t MTDeviceGetService()
{
  return MEMORY[0x24BE69208]();
}

uint64_t MTDeviceGetSubdeviceID()
{
  return MEMORY[0x24BE69210]();
}

uint64_t MTDeviceGetSystemForceResponseEnabled()
{
  return MEMORY[0x24BE69218]();
}

uint64_t MTDeviceGetTouchSizeIdentifier()
{
  return MEMORY[0x24BE69220]();
}

uint64_t MTDeviceGetVersion()
{
  return MEMORY[0x24BE69228]();
}

uint64_t MTDeviceHasExpectedVersion()
{
  return MEMORY[0x24BE69230]();
}

uint64_t MTDeviceInjectFrame()
{
  return MEMORY[0x24BE69238]();
}

uint64_t MTDeviceIsBuiltIn()
{
  return MEMORY[0x24BE69240]();
}

uint64_t MTDeviceIsRunning()
{
  return MEMORY[0x24BE69248]();
}

uint64_t MTDeviceIssueDriverRequest()
{
  return MEMORY[0x24BE69250]();
}

uint64_t MTDeviceNeedsFirstPowerOffSuppressed()
{
  return MEMORY[0x24BE69258]();
}

uint64_t MTDeviceNotifyFirstPowerOffSuppressed()
{
  return MEMORY[0x24BE69260]();
}

uint64_t MTDeviceNotifyWorkInterval()
{
  return MEMORY[0x24BE69268]();
}

uint64_t MTDevicePowerControlSupported()
{
  return MEMORY[0x24BE69270]();
}

uint64_t MTDevicePowerGetState()
{
  return MEMORY[0x24BE69278]();
}

uint64_t MTDevicePowerSetState()
{
  return MEMORY[0x24BE69280]();
}

uint64_t MTDeviceRelease()
{
  return MEMORY[0x24BE69288]();
}

uint64_t MTDeviceSendExternalMessage()
{
  return MEMORY[0x24BE69290]();
}

uint64_t MTDeviceSetBinaryFiltersProperty()
{
  return MEMORY[0x24BE69298]();
}

uint64_t MTDeviceSetInputDetectionCallbackTriggerMask()
{
  return MEMORY[0x24BE692A0]();
}

uint64_t MTDeviceSetInputDetectionModeForOrientation()
{
  return MEMORY[0x24BE692A8]();
}

uint64_t MTDeviceSetPickButtonShouldSendSecondaryClick()
{
  return MEMORY[0x24BE692B0]();
}

uint64_t MTDeviceSetReport()
{
  return MEMORY[0x24BE692B8]();
}

uint64_t MTDeviceSetSurfaceOrientation()
{
  return MEMORY[0x24BE692C0]();
}

uint64_t MTDeviceSetSurfaceOrientationMode()
{
  return MEMORY[0x24BE692C8]();
}

uint64_t MTDeviceSetTouchMode()
{
  return MEMORY[0x24BE692D0]();
}

uint64_t MTDeviceShouldDispatchNormalizedVelocity()
{
  return MEMORY[0x24BE692D8]();
}

uint64_t MTDeviceShouldDispatchRelativeCoordinates()
{
  return MEMORY[0x24BE692E0]();
}

uint64_t MTDeviceShouldResetOnButton()
{
  return MEMORY[0x24BE692E8]();
}

uint64_t MTDeviceStart()
{
  return MEMORY[0x24BE692F0]();
}

uint64_t MTDeviceStop()
{
  return MEMORY[0x24BE692F8]();
}

uint64_t MTDeviceSupportsActuation()
{
  return MEMORY[0x24BE69300]();
}

uint64_t MTDeviceSupportsForce()
{
  return MEMORY[0x24BE69308]();
}

uint64_t MTDeviceSupportsSilentClick()
{
  return MEMORY[0x24BE69310]();
}

uint64_t MTDeviceSupportsTapToWake()
{
  return MEMORY[0x24BE69318]();
}

uint64_t MTDeviceSupportsTouchReadyNotification()
{
  return MEMORY[0x24BE69320]();
}

uint64_t MTDeviceSupportsUSBChargingNotification()
{
  return MEMORY[0x24BE69328]();
}

uint64_t MTDeviceSupportsWirelessChargingNotification()
{
  return MEMORY[0x24BE69330]();
}

uint64_t MTDeviceUpdateDynamicCalibration()
{
  return MEMORY[0x24BE69338]();
}

uint64_t MTDeviceUpdateUILockState()
{
  return MEMORY[0x24BE69340]();
}

uint64_t MTDeviceUseContextualPower()
{
  return MEMORY[0x24BE69348]();
}

uint64_t MTGetPathStageName()
{
  return MEMORY[0x24BE69350]();
}

uint64_t MTRegisterButtonStateCallback()
{
  return MEMORY[0x24BE69358]();
}

uint64_t MTRegisterContactFrameCallbackWithRefcon()
{
  return MEMORY[0x24BE69360]();
}

uint64_t MTRegisterExternalMessageCallback()
{
  return MEMORY[0x24BE69368]();
}

uint64_t MTRegisterFrameHeaderCallback()
{
  return MEMORY[0x24BE69370]();
}

uint64_t MTRegisterFrameProcessingEntryExitCallback()
{
  return MEMORY[0x24BE69378]();
}

uint64_t MTRegisterFullFrameCallback()
{
  return MEMORY[0x24BE69380]();
}

uint64_t MTRegisterImageCallbackWithRefcon()
{
  return MEMORY[0x24BE69388]();
}

uint64_t MTRegisterInputDetectionCallback()
{
  return MEMORY[0x24BE69390]();
}

uint64_t MTRegisterNotificationEventCallback()
{
  return MEMORY[0x24BE69398]();
}

uint64_t MTRegisterProcessedFrameCallback()
{
  return MEMORY[0x24BE693A0]();
}

uint64_t MTRegisterRelativePointerCallback()
{
  return MEMORY[0x24BE693A8]();
}

uint64_t MTRegisterTrackingCallback()
{
  return MEMORY[0x24BE693B0]();
}

uint64_t MTSwapInt32HostToDevice()
{
  return MEMORY[0x24BE693B8]();
}

uint64_t MTUnregisterButtonStateCallback()
{
  return MEMORY[0x24BE693C0]();
}

uint64_t MTUnregisterContactFrameCallback()
{
  return MEMORY[0x24BE693C8]();
}

uint64_t MTUnregisterExternalMessageCallback()
{
  return MEMORY[0x24BE693D0]();
}

uint64_t MTUnregisterFrameProcessingEntryExitCallback()
{
  return MEMORY[0x24BE693D8]();
}

uint64_t MTUnregisterFullFrameCallback()
{
  return MEMORY[0x24BE693E0]();
}

uint64_t MTUnregisterImageCallback()
{
  return MEMORY[0x24BE693E8]();
}

uint64_t MTUnregisterInputDetectionCallback()
{
  return MEMORY[0x24BE693F0]();
}

uint64_t MTUnregisterNotificationEventCallback()
{
  return MEMORY[0x24BE693F8]();
}

uint64_t MTUnregisterTrackingCallback()
{
  return MEMORY[0x24BE69400]();
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x24BDD0B80](aClassName);
}

SEL NSSelectorFromString(NSString *aSelectorName)
{
  return (SEL)MEMORY[0x24BDD1218](aSelectorName);
}

NSString *NSTemporaryDirectory(void)
{
  return (NSString *)MEMORY[0x24BDD1280]();
}

uint64_t PBDataWriterWriteUint32Field()
{
  return MEMORY[0x24BE7AFF8]();
}

uint64_t PBDataWriterWriteUint64Field()
{
  return MEMORY[0x24BE7B000]();
}

uint64_t PBReaderPlaceMark()
{
  return MEMORY[0x24BE7B020]();
}

uint64_t PBReaderRecallMark()
{
  return MEMORY[0x24BE7B040]();
}

uint64_t PBReaderSkipValueWithTag()
{
  return MEMORY[0x24BE7B050]();
}

uint64_t PBRepeatedUInt32Add()
{
  return MEMORY[0x24BE7B140]();
}

uint64_t PBRepeatedUInt32Clear()
{
  return MEMORY[0x24BE7B150]();
}

uint64_t PBRepeatedUInt32Copy()
{
  return MEMORY[0x24BE7B158]();
}

uint64_t PBRepeatedUInt32Hash()
{
  return MEMORY[0x24BE7B168]();
}

uint64_t PBRepeatedUInt32IsEqual()
{
  return MEMORY[0x24BE7B180]();
}

uint64_t PBRepeatedUInt32NSArray()
{
  return MEMORY[0x24BE7B188]();
}

uint64_t PBRepeatedUInt32Set()
{
  return MEMORY[0x24BE7B1A0]();
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x24BDAC730](a1, *(_QWORD *)&a2);
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x24BDBD0A8]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x24BDBD0B0]();
}

uint64_t _IOHIDEventSetAttachment()
{
  return MEMORY[0x24BDD8A90]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x24BDAC780](exception_object);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x24BEDAAA8](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x24BEDABB0](this);
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB180](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB190](this);
}

uint64_t std::__sort<std::__less<float,float> &,float *>()
{
  return MEMORY[0x24BEDB3A8]();
}

uint64_t std::__sort<std::__less<int,int> &,int *>()
{
  return MEMORY[0x24BEDB3B0]();
}

void std::terminate(void)
{
  MEMORY[0x24BEDB6C0]();
}

void operator delete(void *__p)
{
  off_24FFEFE78(__p);
}

uint64_t operator delete()
{
  return off_24FFEFE80();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_24FFEFE88(__sz);
}

uint64_t operator new()
{
  return off_24FFEFE90();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x24BDAC7A0](a1, a2, *(_QWORD *)&a3, a4);
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x24BEDB8F8](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x24BEDB910](a1);
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x24BEDB930](a1);
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x24BEDB960](a1, lptinfo, a3);
}

__float2 __sincosf_stret(float a1)
{
  float v1;
  float v2;
  __float2 result;

  MEMORY[0x24BDAC898](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB68](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB80](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB90](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACC10](dso, log, type, spid, name, format, buf, *(_QWORD *)&size);
}

float atan2f(float a1, float a2)
{
  float result;

  MEMORY[0x24BDAD228](a1, a2);
  return result;
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

float cbrtf(float a1)
{
  float result;

  MEMORY[0x24BDAD338](a1);
  return result;
}

long double cos(long double __x)
{
  long double result;

  MEMORY[0x24BDADBE0](__x);
  return result;
}

float cosf(float a1)
{
  float result;

  MEMORY[0x24BDADBE8](a1);
  return result;
}

void dispatch_assert_queue_not_V2(dispatch_queue_t queue)
{
  MEMORY[0x24BDADCB8](queue);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADCC0](queue, block);
}

void *__cdecl dispatch_get_context(dispatch_object_t object)
{
  return (void *)MEMORY[0x24BDADD98](object);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x24BDADDA8](identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADDB8](group, queue, block);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x24BDADDC8]();
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x24BDADDF0](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x24BDADE98](predicate, block);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x24BDADED0](label, attr);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x24BDADF10](object);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x24BDADF18](object);
}

void dispatch_retain(dispatch_object_t object)
{
  MEMORY[0x24BDADF20](object);
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
  MEMORY[0x24BDADF40](object, context);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  MEMORY[0x24BDADF68](source);
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x24BDADF70](type, handle, mask, queue);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x24BDADFA0](source, handler);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x24BDADFB0](source, handler);
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
  MEMORY[0x24BDADFD0](source, start, interval, leeway);
}

void dispatch_suspend(dispatch_object_t object)
{
  MEMORY[0x24BDADFE0](object);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x24BDADFF8](when, delta);
}

dispatch_time_t dispatch_walltime(const timespec *when, int64_t delta)
{
  return MEMORY[0x24BDAE008](when, delta);
}

int dlclose(void *__handle)
{
  return MEMORY[0x24BDAE060](__handle);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x24BDAE068]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x24BDAE070](__path, *(_QWORD *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x24BDAE088](__handle, __symbol);
}

long double exp(long double __x)
{
  long double result;

  MEMORY[0x24BDAE270](__x);
  return result;
}

long double exp2(long double __x)
{
  long double result;

  MEMORY[0x24BDAE278](__x);
  return result;
}

float expf(float a1)
{
  float result;

  MEMORY[0x24BDAE288](a1);
  return result;
}

int fflush(FILE *a1)
{
  return MEMORY[0x24BDAE350](a1);
}

long double fmod(long double __x, long double __y)
{
  long double result;

  MEMORY[0x24BDAE3F0](__x, __y);
  return result;
}

float fmodf(float a1, float a2)
{
  float result;

  MEMORY[0x24BDAE3F8](a1, a2);
  return result;
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

long double hypot(long double __x, long double __y)
{
  long double result;

  MEMORY[0x24BDAE838](__x, __y);
  return result;
}

float hypotf(float a1, float a2)
{
  float result;

  MEMORY[0x24BDAE840](a1, a2);
  return result;
}

uint64_t kdebug_trace()
{
  return MEMORY[0x24BDAE958]();
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x24BDAEB30]();
}

uint64_t mach_continuous_time(void)
{
  return MEMORY[0x24BDAEB48]();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return (char *)MEMORY[0x24BDAEB58](*(_QWORD *)&error_value);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x24BDAEC68](info);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED78](size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x24BDAEEA8](__b, *(_QWORD *)&__c, __len);
}

float modff(float a1, float *a2)
{
  float result;

  MEMORY[0x24BDAEFB8](a2, a1);
  return result;
}

uint64_t mt_CreateSavedNameForDevice()
{
  return MEMORY[0x24BE69410]();
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x24BDAF138](*(_QWORD *)&token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x24BDAF170](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x24BEDCF68](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x24BEDCF88]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x24BEDCFA8](a1);
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x24BEDCFB0](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x24BEDCFC0]();
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x24BEDD068](obj);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x24BEDD120](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x24BEDD130]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x24BEDD138]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x24BEDD148]();
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x24BEDD2A0](a1);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x24BDAF368](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x24BDAF398](oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x24BDAF400](log);
}

uint64_t os_variant_allows_internal_security_policies()
{
  return MEMORY[0x24BDAF4B0]();
}

long double pow(long double __x, long double __y)
{
  long double result;

  MEMORY[0x24BDAF688](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  float result;

  MEMORY[0x24BDAF690](a1, a2);
  return result;
}

int printf(const char *a1, ...)
{
  return MEMORY[0x24BDAF6A8](a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x24BDAF910](a1, a2);
}

int putchar(int a1)
{
  return MEMORY[0x24BDAF9F0](*(_QWORD *)&a1);
}

int puts(const char *a1)
{
  return MEMORY[0x24BDAF9F8](a1);
}

int rand(void)
{
  return MEMORY[0x24BDAFA38]();
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x24BDAFE40](__str, __size, __format);
}

void srand(unsigned int a1)
{
  MEMORY[0x24BDAFE80](*(_QWORD *)&a1);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x24BDAFEF0](__s1, __s2);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x24BDAFF70](__dst, __src, __n);
}

void syslog(int a1, const char *a2, ...)
{
  MEMORY[0x24BDB0128](*(_QWORD *)&a1, a2);
}

time_t time(time_t *a1)
{
  return MEMORY[0x24BDB0240](a1);
}

int usleep(useconds_t a1)
{
  return MEMORY[0x24BDB02E8](*(_QWORD *)&a1);
}

__int32 *__cdecl wmemchr(__int32 *__s, __int32 __c, size_t __n)
{
  return (__int32 *)MEMORY[0x24BDB0518](__s, *(_QWORD *)&__c, __n);
}

