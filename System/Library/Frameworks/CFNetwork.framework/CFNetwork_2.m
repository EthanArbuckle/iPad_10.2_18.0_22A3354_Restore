void sub_183FE69A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x1081C4076DFA842);
  _Unwind_Resume(a1);
}

uint64_t _FTPStreamOpenCompleted(char *a1, uint64_t a2, char *a3)
{
  uint64_t v6;
  CFTypeID v7;
  uint64_t v8;
  CoreStreamBase *v9;
  unint64_t Status;
  NetConnection *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  CFTypeID v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  const __CFAllocator *v21;
  CFRunLoopSourceRef RunLoopSource;
  __CFRunLoopSource *v23;
  __CFRunLoop *Current;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  CFIndex v36;
  uint64_t v37;
  dispatch_once_t *v38;
  void *v39;
  dispatch_once_t *v40;
  void *v41;

  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  if (!*((_QWORD *)a3 + 3))
    goto LABEL_12;
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  v6 = *(_QWORD *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96);
  v7 = CFGetTypeID(*((CFTypeRef *)a3 + 3));
  v8 = *((_QWORD *)a3 + 3);
  if (v8)
    v9 = (CoreStreamBase *)(v8 + 16);
  else
    v9 = 0;
  if (v7 != v6)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1)
      goto LABEL_11;
    v38 = &CoreWriteStream::Class(void)::sOnce_CoreWriteStream;
    v39 = &__block_literal_global_3166;
    goto LABEL_66;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
  {
    v38 = &CoreReadStream::Class(void)::sOnce_CoreReadStream;
    v39 = &__block_literal_global_16727;
LABEL_66:
    dispatch_once(v38, v39);
  }
LABEL_11:
  Status = CoreStreamBase::_streamInterface_GetStatus(v9);
  if (Status >= 2)
  {
    if (Status != 7)
      return 1;
    v16 = CFGetTypeID(a1);
    if (a1)
      v17 = a1 + 16;
    else
      v17 = 0;
    if (v16 == v6)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream == -1)
        goto LABEL_37;
      v40 = &CoreReadStream::Class(void)::sOnce_CoreReadStream;
      v41 = &__block_literal_global_16727;
    }
    else
    {
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1)
      {
LABEL_37:
        *(_OWORD *)a2 = *(_OWORD *)(v17 + 56);
        return 1;
      }
      v40 = &CoreWriteStream::Class(void)::sOnce_CoreWriteStream;
      v41 = &__block_literal_global_3166;
    }
    dispatch_once(v40, v41);
    goto LABEL_37;
  }
LABEL_12:
  v11 = (NetConnection *)*((_QWORD *)a3 + 16);
  if (!v11)
    goto LABEL_29;
  NetConnection::getState(v11, 1, (uint64_t *)a3);
  v12 = *((_QWORD *)a3 + 16);
  if (!v12)
    goto LABEL_29;
  v13 = *(_QWORD *)(v12 + 96);
  if (v13)
    pthread_mutex_lock((pthread_mutex_t *)(v13 + 8));
  v14 = *(_QWORD *)(v12 + 128);
  if (v14)
    v15 = *(char **)(v14 + 8);
  else
    v15 = 0;
  v18 = *(_QWORD *)(v12 + 96);
  if (v18)
    pthread_mutex_unlock((pthread_mutex_t *)(v18 + 8));
  if (v15 != a3)
    goto LABEL_29;
  v25 = *((_QWORD *)a3 + 16);
  v26 = *(_QWORD *)(v25 + 96);
  if (v26)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v26 + 8));
    v27 = *(_QWORD *)(v25 + 96);
    v28 = *(_QWORD *)(v25 + 152);
    if (v27)
      pthread_mutex_unlock((pthread_mutex_t *)(v27 + 8));
  }
  else
  {
    v28 = *(_QWORD *)(v25 + 152);
  }
  v30 = *((_QWORD *)a3 + 16);
  v31 = *(_QWORD *)(v30 + 96);
  if (v31)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v31 + 8));
    v32 = *(_QWORD *)(v30 + 96);
    v33 = *(_QWORD *)(v30 + 144);
    if (v32)
      pthread_mutex_unlock((pthread_mutex_t *)(v32 + 8));
  }
  else
  {
    v33 = *(_QWORD *)(v30 + 144);
  }
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  if (v28)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v28 + 16)) == 7)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      v34 = *(_OWORD *)(v28 + 72);
LABEL_59:
      *(_OWORD *)a2 = v34;
      v35 = *((_QWORD *)a3 + 16);
      if (v35)
      {
        if (!*(_DWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)v35 + 80))(v35) + 20))
        {
          v36 = *((_QWORD *)a3 + 15);
          if (v36 < CFArrayGetCount(*((CFArrayRef *)a3 + 14)))
          {
            v37 = *((_QWORD *)a3 + 16);
            ++*((_QWORD *)a3 + 15);
            *(_OWORD *)(a3 + 40) = *(_OWORD *)a2;
            (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v37 + 64))(v37, a2);
            return 0;
          }
        }
      }
      _ReportError((uint64_t)a3, (CFStreamError *)a2);
      v19 = 1;
      goto LABEL_30;
    }
  }
  if (v33)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v33 + 16)) == 7)
    {
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      v34 = *(_OWORD *)(v33 + 72);
      goto LABEL_59;
    }
  }
LABEL_29:
  v19 = 0;
LABEL_30:
  v20 = (const void *)*((_QWORD *)a3 + 7);
  if (v20)
  {
    v21 = CFGetAllocator(v20);
    RunLoopSource = CFSocketCreateRunLoopSource(v21, *((CFSocketRef *)a3 + 7), 0);
    if (RunLoopSource)
    {
      v23 = RunLoopSource;
      Current = CFRunLoopGetCurrent();
      CFRunLoopAddSource(Current, v23, CFSTR("_FTPStreamOpenCompleted"));
      CFRunLoopRunInMode(CFSTR("_FTPStreamOpenCompleted"), 0.0, 1u);
      CFRunLoopRemoveSource(Current, v23, CFSTR("_FTPStreamOpenCompleted"));
      CFRelease(v23);
    }
  }
  return v19;
}

uint64_t _FTPStreamWrite(int a1, unsigned __int8 *a2, uint64_t a3, _QWORD *a4, uint64_t *a5)
{
  NetConnection *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  *a4 = 0;
  a4[1] = 0;
  while (1)
  {
    v9 = (NetConnection *)a5[16];
    if (!v9)
    {
LABEL_29:
      v25 = 0;
      goto LABEL_37;
    }
    v10 = a5[3];
    if (v10)
    {
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      if (CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)(v10 + 16)))
        goto LABEL_29;
      v9 = (NetConnection *)a5[16];
    }
    NetConnection::getState(v9, 1, a5);
    v11 = a5[16];
    if (!v11)
      break;
    v12 = *(_QWORD *)(v11 + 96);
    if (v12)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v12 + 8));
      v13 = *(_QWORD *)(v11 + 96);
      v14 = *(_QWORD *)(v11 + 144);
      if (v13)
        pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8));
    }
    else
    {
      v14 = *(_QWORD *)(v11 + 144);
    }
    v15 = a5[16];
    v16 = *(_QWORD *)(v15 + 96);
    if (v16)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v16 + 8));
      v17 = *(_QWORD *)(v15 + 96);
      v18 = *(_QWORD *)(v15 + 152);
      if (v17)
        pthread_mutex_unlock((pthread_mutex_t *)(v17 + 8));
      if (v18)
      {
LABEL_17:
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
        v19 = *(_QWORD *)(v18 + 80);
        *a4 = *(_QWORD *)(v18 + 72);
        a4[1] = v19;
        if ((_DWORD)v19)
          goto LABEL_27;
LABEL_23:
        if (v14)
        {
          if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
            dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
          v20 = *(_QWORD *)(v14 + 80);
          *a4 = *(_QWORD *)(v14 + 72);
          a4[1] = v20;
          LODWORD(v19) = v20;
        }
        goto LABEL_27;
      }
    }
    else
    {
      v18 = *(_QWORD *)(v15 + 152);
      if (v18)
        goto LABEL_17;
    }
    LODWORD(v19) = *((_DWORD *)a4 + 2);
    if (!(_DWORD)v19)
      goto LABEL_23;
LABEL_27:
    if ((_DWORD)v19)
    {
      v25 = -1;
      goto LABEL_37;
    }
  }
  v21 = a5[4];
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  v22 = v21 + 16;
  if (!v21)
    v22 = 0;
  v24 = *(_QWORD *)(v22 + 56);
  v23 = *(_QWORD *)(v22 + 64);
  *a4 = v24;
  a4[1] = v23;
  if ((_DWORD)v23)
    v25 = -1;
  else
    v25 = 0;
LABEL_37:
  v26 = a5[3];
  if (v26)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    v25 = CoreStreamBase::_streamInterface_Write((CoreStreamBase *)(v26 + 16), a2, a3);
    if (v25 <= 0)
    {
      v27 = a5[3];
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      v28 = v27 + 16;
      if (!v27)
        v28 = 0;
      *(_OWORD *)a4 = *(_OWORD *)(v28 + 56);
    }
  }
  return v25;
}

uint64_t _FTPStreamCanWrite(int a1, char *a2)
{
  NetConnection *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFStreamError v10;
  uint64_t v11;
  CoreStreamBase *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFIndex v17;
  int v18;
  CFIndex v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v24;

  v3 = (NetConnection *)*((_QWORD *)a2 + 16);
  if (v3)
  {
    NetConnection::getState(v3, 1, (uint64_t *)a2);
    v4 = *((_QWORD *)a2 + 16);
    if (v4)
    {
      v24 = 0uLL;
      v5 = *(_QWORD *)(v4 + 96);
      if (v5)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v5 + 8));
        v6 = *(_QWORD *)(v4 + 96);
        v7 = *(_QWORD *)(v4 + 144);
        if (v6)
          pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
      }
      else
      {
        v7 = *(_QWORD *)(v4 + 144);
      }
      v13 = *((_QWORD *)a2 + 16);
      v14 = *(_QWORD *)(v13 + 96);
      if (v14)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v14 + 8));
        v15 = *(_QWORD *)(v13 + 96);
        v16 = *(_QWORD *)(v13 + 152);
        if (v15)
          pthread_mutex_unlock((pthread_mutex_t *)(v15 + 8));
        if (v16)
        {
LABEL_19:
          if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
            dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
          v17 = *(_QWORD *)(v16 + 72);
          v16 = *(_QWORD *)(v16 + 80);
          *(_QWORD *)&v24 = v17;
          *((_QWORD *)&v24 + 1) = v16;
          v18 = v16;
          if ((_DWORD)v16)
            goto LABEL_29;
          goto LABEL_25;
        }
      }
      else
      {
        v16 = *(_QWORD *)(v13 + 152);
        if (v16)
          goto LABEL_19;
      }
      v17 = 0;
      v18 = 0;
LABEL_25:
      if (v7)
      {
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
        v17 = *(_QWORD *)(v7 + 72);
        v16 = *(_QWORD *)(v7 + 80);
        *(_QWORD *)&v24 = v17;
        *((_QWORD *)&v24 + 1) = v16;
        v18 = v16;
      }
LABEL_29:
      if (!v18)
        goto LABEL_40;
      if (!*(_DWORD *)((*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 16) + 80))(*((_QWORD *)a2 + 16)) + 20))
      {
        v19 = *((_QWORD *)a2 + 15);
        if (v19 < CFArrayGetCount(*((CFArrayRef *)a2 + 14)))
        {
          v20 = *((_QWORD *)a2 + 16);
          ++*((_QWORD *)a2 + 15);
          *(_OWORD *)(a2 + 40) = v24;
          (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)v20 + 64))(v20, &v24);
          goto LABEL_40;
        }
      }
      v21 = *((_QWORD *)a2 + 4);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      if (v21)
        v12 = (CoreStreamBase *)(v21 + 16);
      else
        v12 = 0;
      v10.domain = v17;
      *(_QWORD *)&v10.error = v16;
      goto LABEL_39;
    }
    v8 = *((_QWORD *)a2 + 4);
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    v9 = v8 + 16;
    if (!v8)
      v9 = 0;
    *(_QWORD *)&v10.error = *(_QWORD *)(v9 + 64);
    if (v10.error)
    {
      v10.domain = *(_QWORD *)(v9 + 56);
      v11 = *((_QWORD *)a2 + 4);
      if (v11)
        v12 = (CoreStreamBase *)(v11 + 16);
      else
        v12 = 0;
LABEL_39:
      CoreStreamBase::_signalEvent(v12, 8, v10, 1);
    }
  }
LABEL_40:
  v22 = *((_QWORD *)a2 + 3);
  if (!v22)
    return 0;
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  return CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)(v22 + 16));
}

void **_FTPStreamClose(uint64_t a1, uint64_t a2)
{
  const void *v3;
  CFTypeID v4;
  uint64_t v5;
  CoreStreamBase *v6;
  const void *v7;
  void **result;
  const __CFArray *v9;
  CFIndex Count;
  CFIndex v11;
  CFIndex i;
  NetConnection *v13;
  __CFRunLoop *v14;
  const __CFString *v15;

  _InvalidateServer(a2);
  invalidatePacExecutionContext(a2);
  v3 = *(const void **)(a2 + 24);
  if (v3)
  {
    v4 = CFGetTypeID(v3);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (v4 == *(_QWORD *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
    {
      _ReleaseDataReadStream(a2);
    }
    else
    {
      _CFTypeInvalidate(*(char **)(a2 + 24));
      _CFTypeUnscheduleFromMultipleRunLoops(*(void **)(a2 + 24), *(const __CFArray **)(a2 + 80));
      v5 = *(_QWORD *)(a2 + 24);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      if (v5)
        v6 = (CoreStreamBase *)(v5 + 16);
      else
        v6 = 0;
      CoreStreamBase::_streamInterface_Close(v6);
      v7 = *(const void **)(a2 + 24);
      if (v7)
        CFRelease(v7);
      *(_QWORD *)(a2 + 24) = 0;
    }
  }
  result = *(void ***)(a2 + 128);
  if (result)
  {
    if (NetConnection::getState((NetConnection *)result, 0, (uint64_t *)a2) == 2)
    {
      v9 = *(const __CFArray **)(a2 + 80);
      Count = CFArrayGetCount(v9);
      if (Count >= 1)
      {
        v11 = Count;
        for (i = 0; i < v11; i += 2)
        {
          v13 = *(NetConnection **)(a2 + 128);
          CFArrayGetValueAtIndex(v9, i);
          CFArrayGetValueAtIndex(v9, i + 1);
          NetConnection::unschedule(v13, (uint64_t *)a2, v14, v15);
        }
      }
      NetConnection::requestIsComplete(*(NetConnection **)(a2 + 128), (void *)a2);
      return (void **)NetConnection::responseIsComplete(*(NetConnection **)(a2 + 128), (void *)a2);
    }
    else
    {
      return NetConnection::dequeue(*(NetConnection **)(a2 + 128), (void *)a2);
    }
  }
  return result;
}

CFArrayRef _FTPStreamCopyProperty(int a1, CFTypeRef cf1, uint64_t a3)
{
  const void **v5;
  const void **v6;
  BOOL v7;
  const void *Value;
  CFArrayRef result;
  const void *v10;
  CFTypeID v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const __CFString *v19;
  CFTypeID v20;
  const __CFAllocator *v21;
  const __CFAllocator *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const __CFAllocator *v27;
  const __CFAllocator *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const __CFAllocator *v33;
  const __CFDictionary *v34;

  if (CFEqual(cf1, CFSTR("kCFStreamPropertyFTPUsePassiveMode")))
  {
    v5 = (const void **)MEMORY[0x1E0C9AE50];
    v6 = (const void **)MEMORY[0x1E0C9AE40];
    v7 = (*(_WORD *)a3 & 1) == 0;
    goto LABEL_7;
  }
  if (CFEqual(cf1, CFSTR("kCFStreamPropertyFTPFetchResourceInfo")))
  {
    v5 = (const void **)MEMORY[0x1E0C9AE50];
    v6 = (const void **)MEMORY[0x1E0C9AE40];
    v7 = (*(_WORD *)a3 & 4) == 0;
    goto LABEL_7;
  }
  if (CFEqual(cf1, CFSTR("kCFStreamPropertyFTPFetchNameList")))
  {
    v5 = (const void **)MEMORY[0x1E0C9AE50];
    v6 = (const void **)MEMORY[0x1E0C9AE40];
    v7 = (*(_WORD *)a3 & 8) == 0;
LABEL_7:
    if (v7)
      v5 = v6;
LABEL_9:
    Value = *v5;
    if (!*v5)
      goto LABEL_11;
    goto LABEL_10;
  }
  if (!CFEqual(cf1, CFSTR("kCFStreamPropertyFTPFileTransferOffset")))
  {
    if (CFEqual(cf1, CFSTR("kCFStreamPropertyFTPResourceSize")))
    {
      v34 = *(const __CFDictionary **)(a3 + 64);
      if (!v34)
        goto LABEL_11;
      Value = CFDictionaryGetValue(v34, CFSTR("kCFFTPResourceSize"));
      if (!Value)
        goto LABEL_11;
    }
    else
    {
      if (!CFEqual(cf1, CFSTR("kCFStreamPropertyFTPAttemptPersistentConnection")))
      {
        if (CFEqual(cf1, CFSTR("_kCFStreamPropertyFTPLogInOnly")))
        {
          v5 = (const void **)MEMORY[0x1E0C9AE50];
          v6 = (const void **)MEMORY[0x1E0C9AE40];
          v7 = (*(_WORD *)a3 & 0x200) == 0;
        }
        else
        {
          if (!CFEqual(cf1, CFSTR("_kCFStreamPropertyFTPRemoveResource")))
            goto LABEL_11;
          v5 = (const void **)MEMORY[0x1E0C9AE50];
          v6 = (const void **)MEMORY[0x1E0C9AE40];
          v7 = (*(_WORD *)a3 & 0x100) == 0;
        }
        goto LABEL_7;
      }
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 88), cf1);
      if (!Value)
      {
        v5 = (const void **)MEMORY[0x1E0C9AE50];
        goto LABEL_9;
      }
    }
LABEL_10:
    result = (CFArrayRef)CFRetain(Value);
    if (result)
      return result;
    goto LABEL_11;
  }
  v27 = CFGetAllocator(*(CFTypeRef *)(a3 + 88));
  result = CFNumberCreate(v27, kCFNumberLongLongType, (const void *)(a3 + 72));
  if (result)
    return result;
LABEL_11:
  v10 = *(const void **)(a3 + 24);
  if (v10)
  {
    v11 = CFGetTypeID(v10);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    v12 = *(_QWORD *)(a3 + 24);
    if (v12)
      v13 = v12 + 16;
    else
      v13 = 0;
    if (v11 != *(_QWORD *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)
      && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    }
    ++*(_QWORD *)(v13 + 80);
    result = (CFArrayRef)(*(uint64_t (**)(_QWORD, CFTypeRef))(**(_QWORD **)(v13 + 24) + 40))(*(_QWORD *)(v13 + 24), cf1);
    --*(_QWORD *)(v13 + 80);
    if (result)
      return result;
  }
  v14 = *(_QWORD *)(a3 + 128);
  if (!v14)
    goto LABEL_30;
  v15 = *(_QWORD *)(v14 + 96);
  if (v15)
    pthread_mutex_lock((pthread_mutex_t *)(v15 + 8));
  v16 = *(_QWORD *)(v14 + 128);
  if (v16)
    v17 = *(_QWORD *)(v16 + 8);
  else
    v17 = 0;
  v18 = *(_QWORD *)(v14 + 96);
  if (v18)
    pthread_mutex_unlock((pthread_mutex_t *)(v18 + 8));
  if (v17 != a3)
    goto LABEL_30;
  v23 = *(_QWORD *)(a3 + 128);
  v24 = *(_QWORD *)(v23 + 96);
  if (!v24)
  {
    v26 = *(_QWORD *)(v23 + 152);
    if (!v26)
      goto LABEL_49;
LABEL_46:
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    ++*(_QWORD *)(v26 + 96);
    result = (CFArrayRef)(*(uint64_t (**)(_QWORD, CFTypeRef))(**(_QWORD **)(v26 + 40) + 40))(*(_QWORD *)(v26 + 40), cf1);
    --*(_QWORD *)(v26 + 96);
    if (result)
      return result;
    goto LABEL_49;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v24 + 8));
  v25 = *(_QWORD *)(v23 + 96);
  v26 = *(_QWORD *)(v23 + 152);
  if (v25)
    pthread_mutex_unlock((pthread_mutex_t *)(v25 + 8));
  if (v26)
    goto LABEL_46;
LABEL_49:
  v29 = *(_QWORD *)(a3 + 128);
  v30 = *(_QWORD *)(v29 + 96);
  if (v30)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v30 + 8));
    v31 = *(_QWORD *)(v29 + 96);
    v32 = *(_QWORD *)(v29 + 144);
    if (v31)
      pthread_mutex_unlock((pthread_mutex_t *)(v31 + 8));
  }
  else
  {
    v32 = *(_QWORD *)(v29 + 144);
  }
  if (!v32)
    goto LABEL_30;
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  ++*(_QWORD *)(v32 + 96);
  result = (CFArrayRef)(*(uint64_t (**)(_QWORD, CFTypeRef))(**(_QWORD **)(v32 + 40) + 40))(*(_QWORD *)(v32 + 40), cf1);
  --*(_QWORD *)(v32 + 96);
  if (!result)
  {
LABEL_30:
    result = (CFArrayRef)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 88), cf1);
    if (result)
    {
      v19 = (const __CFString *)result;
      v20 = CFGetTypeID(result);
      if (v20 == CFStringGetTypeID())
      {
        v21 = CFGetAllocator(*(CFTypeRef *)(a3 + 88));
        return (CFArrayRef)CFStringCreateCopy(v21, v19);
      }
      else if (v20 == CFDataGetTypeID())
      {
        v22 = CFGetAllocator(*(CFTypeRef *)(a3 + 88));
        return CFDataCreateCopy(v22, (CFDataRef)v19);
      }
      else if (v20 == CFDictionaryGetTypeID())
      {
        v28 = CFGetAllocator(*(CFTypeRef *)(a3 + 88));
        return CFDictionaryCreateCopy(v28, (CFDictionaryRef)v19);
      }
      else if (v20 == CFArrayGetTypeID())
      {
        v33 = CFGetAllocator(*(CFTypeRef *)(a3 + 88));
        return CFArrayCreateCopy(v33, (CFArrayRef)v19);
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t _FTPStreamSetProperty(int a1, const __CFString *cf1, const __CFString *a3, uint64_t a4)
{
  CFTypeID v7;
  __CFDictionary *v8;
  const __CFString *v9;
  __CFDictionary *v10;
  const __CFString *v11;
  uint64_t result;
  __int16 v13;
  __int16 v14;
  CFTypeID v15;
  _QWORD *v16;
  CFTypeID v17;
  const void *v18;
  CFTypeID v19;
  uint64_t v20;
  uint64_t v21;

  if (CFEqual(cf1, CFSTR("kCFStreamPropertyFTPProxy")))
  {
    if (*(_QWORD *)(a4 + 128) || *(_QWORD *)(a4 + 24))
      return 0;
    if (a3)
    {
      v7 = CFGetTypeID(a3);
      if (v7 == CFDictionaryGetTypeID())
      {
        v8 = *(__CFDictionary **)(a4 + 88);
        v9 = (const __CFString *)&unk_1EDCFBF30;
LABEL_7:
        CFDictionaryRemoveValue(v8, v9);
LABEL_8:
        v10 = *(__CFDictionary **)(a4 + 88);
LABEL_9:
        v11 = cf1;
LABEL_10:
        CFDictionarySetValue(v10, v11, a3);
        return 1;
      }
      return 0;
    }
    goto LABEL_61;
  }
  if (CFEqual(cf1, &unk_1EDCFBF30))
  {
    if (*(_QWORD *)(a4 + 128) || *(_QWORD *)(a4 + 24))
      return 0;
    if (a3)
    {
      v15 = CFGetTypeID(a3);
      if (v15 == CFDictionaryGetTypeID()
        && !CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 88), CFSTR("kCFStreamPropertyFTPProxy")))
      {
        v8 = *(__CFDictionary **)(a4 + 88);
        v9 = CFSTR("kCFStreamPropertyFTPProxy");
        goto LABEL_7;
      }
      return 0;
    }
    goto LABEL_61;
  }
  if (CFEqual(cf1, CFSTR("kCFStreamPropertyFTPUsePassiveMode")))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x1E0C9AE40]))
      v13 = *(_WORD *)a4 & 0xFFFE;
    else
      v13 = *(_WORD *)a4 | 1;
    v14 = v13 | 2;
    goto LABEL_21;
  }
  if (CFEqual(cf1, CFSTR("kCFStreamPropertyFTPFetchResourceInfo")))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
      v14 = *(_WORD *)a4 | 4;
    else
      v14 = *(_WORD *)a4 & 0xFFFB;
LABEL_21:
    *(_WORD *)a4 = v14;
    return 1;
  }
  if (CFEqual(cf1, CFSTR("kCFStreamPropertyFTPFetchNameList")))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
      v14 = *(_WORD *)a4 | 8;
    else
      v14 = *(_WORD *)a4 & 0xFFF7;
    goto LABEL_21;
  }
  if (CFEqual(cf1, CFSTR("kCFStreamPropertyFTPFileTransferOffset")))
  {
    v16 = (_QWORD *)(a4 + 72);
    if (a3)
      CFNumberGetValue((CFNumberRef)a3, kCFNumberLongLongType, v16);
    else
      *v16 = 0;
    return 1;
  }
  if (CFEqual(cf1, CFSTR("_kCFStreamPropertyFTPLogInOnly")))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
      v14 = *(_WORD *)a4 | 0x200;
    else
      v14 = *(_WORD *)a4 & 0xFDFF;
    goto LABEL_21;
  }
  if (CFEqual(cf1, CFSTR("_kCFStreamPropertyFTPRemoveResource")))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
      v14 = *(_WORD *)a4 | 0x100;
    else
      v14 = *(_WORD *)a4 & 0xFEFF;
    goto LABEL_21;
  }
  if (CFEqual(cf1, CFSTR("kCFStreamPropertyFTPResourceSize")))
    return 0;
  if (CFEqual(cf1, CFSTR("kCFStreamPropertyFTPAttemptPersistentConnection")))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x1E0C9AE40]))
      goto LABEL_8;
LABEL_61:
    v10 = *(__CFDictionary **)(a4 + 88);
LABEL_62:
    v11 = cf1;
    goto LABEL_63;
  }
  if (CFEqual(cf1, CFSTR("kCFStreamPropertyFTPUserName")) || CFEqual(cf1, CFSTR("kCFStreamPropertyFTPPassword")))
  {
    if (a3)
    {
      v17 = CFGetTypeID(a3);
      if (v17 == CFStringGetTypeID())
      {
        result = _ValidFTPString(a3);
        if (!(_DWORD)result)
          return result;
        goto LABEL_8;
      }
      return 0;
    }
    goto LABEL_61;
  }
  if (CFEqual(cf1, CFSTR("kCFStreamPropertyFTPUserName_prevalidated")))
  {
    v10 = *(__CFDictionary **)(a4 + 88);
    v11 = CFSTR("kCFStreamPropertyFTPUserName");
    if (a3)
      goto LABEL_10;
LABEL_63:
    CFDictionaryRemoveValue(v10, v11);
    return 1;
  }
  if (CFEqual(cf1, CFSTR("kCFStreamPropertyFTPPassword_prevalidated")))
  {
    v10 = *(__CFDictionary **)(a4 + 88);
    v11 = CFSTR("kCFStreamPropertyFTPPassword");
    if (a3)
      goto LABEL_10;
    goto LABEL_63;
  }
  v18 = *(const void **)(a4 + 24);
  if (!v18)
    goto LABEL_82;
  v19 = CFGetTypeID(v18);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  v20 = *(_QWORD *)(a4 + 24);
  if (v20)
    v21 = v20 + 16;
  else
    v21 = 0;
  if (v19 != *(_QWORD *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)
    && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
  {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  }
  ++*(_QWORD *)(v21 + 80);
  result = (*(uint64_t (**)(_QWORD, const __CFString *, const __CFString *))(**(_QWORD **)(v21 + 24) + 32))(*(_QWORD *)(v21 + 24), cf1, a3);
  --*(_QWORD *)(v21 + 80);
  if (!(_DWORD)result)
  {
LABEL_82:
    v10 = *(__CFDictionary **)(a4 + 88);
    if (a3)
      goto LABEL_9;
    goto LABEL_62;
  }
  return result;
}

uint64_t _FTPStreamSchedule(uint64_t a1, CoreSchedulingSet *a2, const __CFString *a3, uint64_t a4)
{
  uint64_t result;
  __CFRunLoopSource *v8;
  void *v9;
  void *v10;

  result = _SchedulesAddRunLoopAndMode(*(const __CFArray **)(a4 + 80), a2, a3);
  if ((_DWORD)result)
  {
    v8 = *(__CFRunLoopSource **)(a4 + 96);
    if (v8)
      CFRunLoopAddSource((CFRunLoopRef)a2, v8, a3);
    v9 = *(void **)(a4 + 56);
    if (v9)
      _CFTypeScheduleOnRunLoop(v9, (uint64_t)a2, (uint64_t)a3);
    v10 = *(void **)(a4 + 24);
    if (v10)
      _CFTypeScheduleOnRunLoop(v10, (uint64_t)a2, (uint64_t)a3);
    result = *(_QWORD *)(a4 + 128);
    if (result)
      return NetConnection::schedule(result, (uint64_t *)a4, a2, a3);
  }
  return result;
}

void _FTPStreamUnschedule(uint64_t a1, __CFRunLoop *a2, const __CFString *a3, uint64_t a4)
{
  __CFRunLoop *v7;
  const __CFString *v8;
  __CFRunLoopSource *v9;
  void *v10;
  void *v11;
  NetConnection *v12;

  if (_SchedulesRemoveRunLoopAndMode(*(const __CFArray **)(a4 + 80), a2, a3))
  {
    v9 = *(__CFRunLoopSource **)(a4 + 96);
    if (v9)
      CFRunLoopRemoveSource(a2, v9, a3);
    v10 = *(void **)(a4 + 56);
    if (v10)
      _CFTypeUnscheduleFromRunLoop(v10, (uint64_t)a2, (uint64_t)a3);
    v11 = *(void **)(a4 + 24);
    if (v11)
      _CFTypeUnscheduleFromRunLoop(v11, (uint64_t)a2, (uint64_t)a3);
    v12 = *(NetConnection **)(a4 + 128);
    if (v12)
      NetConnection::unschedule(v12, (uint64_t *)a4, v7, v8);
  }
}

void _InvalidateServer(uint64_t a1)
{
  void *v2;
  const __CFArray *v3;
  const void *v4;

  v2 = *(void **)(a1 + 56);
  if (v2)
  {
    v3 = *(const __CFArray **)(a1 + 80);
    if (v3)
    {
      _CFTypeUnscheduleFromMultipleRunLoops(v2, v3);
      v2 = *(void **)(a1 + 56);
    }
    CFSocketInvalidate((CFSocketRef)v2);
    v4 = *(const void **)(a1 + 56);
    if (v4)
      CFRelease(v4);
    *(_QWORD *)(a1 + 56) = 0;
  }
}

void invalidatePacExecutionContext(uint64_t a1)
{
  char *v2;
  const void *v3;

  v2 = *(char **)(a1 + 96);
  if (v2)
  {
    _CFTypeInvalidate(v2);
    _CFTypeUnscheduleFromMultipleRunLoops(*(void **)(a1 + 96), *(const __CFArray **)(a1 + 80));
    v3 = *(const void **)(a1 + 96);
    if (v3)
      CFRelease(v3);
    *(_QWORD *)(a1 + 96) = 0;
  }
}

void _ReleaseDataReadStream(uint64_t a1)
{
  const __CFArray *v2;
  char *v3;
  CoreStreamBase *v4;

  v2 = *(const __CFArray **)(a1 + 80);
  v3 = *(char **)(a1 + 24);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  if (v3)
    v4 = (CoreStreamBase *)(v3 + 16);
  else
    v4 = 0;
  (*(void (**)(CoreStreamBase *, _QWORD, _QWORD))(*(_QWORD *)v4 + 56))(v4, 0, 0);
  _CFTypeUnscheduleFromMultipleRunLoops(v3, v2);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  CoreStreamBase::_streamInterface_Close(v4);
  if (v3)
    CFRelease(v3);
  *(_QWORD *)(a1 + 24) = 0;
}

void _ReportError(uint64_t a1, CFStreamError *a2)
{
  uint64_t v4;
  CFIndex v5;
  uint64_t v6;
  uint64_t v7;
  const void *v8;
  CFTypeID v9;
  uint64_t v10;
  CoreStreamBase *v11;
  const void *v12;
  CFTypeID v13;
  uint64_t v14;
  CoreStreamBase *v15;
  CFStreamError v16;

  v4 = *(_QWORD *)(a1 + 128);
  if (v4)
  {
    if (!*(_DWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 80))(v4) + 20))
    {
      v5 = *(_QWORD *)(a1 + 120);
      if (v5 < CFArrayGetCount(*(CFArrayRef *)(a1 + 112)))
      {
        v6 = *(_QWORD *)(a1 + 128);
        ++*(_QWORD *)(a1 + 120);
        *(CFStreamError *)(a1 + 40) = *a2;
        (*(void (**)(uint64_t, CFStreamError *))(*(_QWORD *)v6 + 64))(v6, a2);
        return;
      }
    }
    v7 = *(_QWORD *)(a1 + 128);
    *(_WORD *)a1 |= 0x400u;
    if (v7)
      (*(void (**)(uint64_t, CFStreamError *))(*(_QWORD *)v7 + 64))(v7, a2);
  }
  else
  {
    *(_WORD *)a1 |= 0x400u;
  }
  v8 = *(const void **)(a1 + 24);
  if (v8)
  {
    v9 = CFGetTypeID(v8);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (v9 == *(_QWORD *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
    {
      _ReleaseDataReadStream(a1);
    }
    else
    {
      _CFTypeInvalidate(*(char **)(a1 + 24));
      _CFTypeUnscheduleFromMultipleRunLoops(*(void **)(a1 + 24), *(const __CFArray **)(a1 + 80));
      v10 = *(_QWORD *)(a1 + 24);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      if (v10)
        v11 = (CoreStreamBase *)(v10 + 16);
      else
        v11 = 0;
      CoreStreamBase::_streamInterface_Close(v11);
      v12 = *(const void **)(a1 + 24);
      if (v12)
        CFRelease(v12);
      *(_QWORD *)(a1 + 24) = 0;
    }
  }
  v13 = CFGetTypeID(*(CFTypeRef *)(a1 + 32));
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  v14 = *(_QWORD *)(a1 + 32);
  if (v14)
    v15 = (CoreStreamBase *)(v14 + 16);
  else
    v15 = 0;
  if (v13 != *(_QWORD *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1)
    {
      if (a2)
        goto LABEL_31;
    }
    else
    {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      if (a2)
        goto LABEL_31;
    }
LABEL_33:
    *(_QWORD *)&v16.error = 0;
    v16.domain = 0;
    goto LABEL_34;
  }
  if (!a2)
    goto LABEL_33;
LABEL_31:
  v16 = *a2;
LABEL_34:
  CoreStreamBase::_signalEvent(v15, 8, v16, 1);
}

void PACExecutionComplete_FTPStream(uint64_t a1, const void *a2, void *a3)
{
  CFIndex v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CoreStreamBase *v10;
  uint64_t v11;
  CFStreamError v12;
  const __CFArray *v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  CFStreamError v17;

  v17.domain = 0;
  *(_QWORD *)&v17.error = 0;
  *(_WORD *)a1 &= ~0x1000u;
  invalidatePacExecutionContext(a1);
  *(_QWORD *)(a1 + 96) = 0;
  if (a3)
  {
    CFRetain(a3);
    *(_QWORD *)(a1 + 104) = a3;
    v6 = _CFStreamErrorFromCFError((__CFError *)a3);
    v8 = v7;
    v9 = *(_QWORD *)(a1 + 32);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (v9)
      v10 = (CoreStreamBase *)(v9 + 16);
    else
      v10 = 0;
    v11 = 8;
    v12.domain = v6;
    *(_QWORD *)&v12.error = v8;
  }
  else
  {
    if (a2)
      CFRetain(a2);
    *(_QWORD *)(a1 + 112) = a2;
    v13 = *(const __CFArray **)(a1 + 80);
    if (v13 && CFArrayGetCount(v13) >= 1 && (_FTPStreamOpen(*(_QWORD *)(a1 + 32), &v17, &v16, a1), v17.error))
    {
      v14 = *(_QWORD *)(a1 + 32);
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      if (v14)
        v10 = (CoreStreamBase *)(v14 + 16);
      else
        v10 = 0;
      v12 = v17;
      v11 = 8;
    }
    else
    {
      v15 = *(_QWORD *)(a1 + 32);
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      if (v15)
        v10 = (CoreStreamBase *)(v15 + 16);
      else
        v10 = 0;
      v11 = 1;
      v12.domain = 0;
      *(_QWORD *)&v12.error = 0;
    }
  }
  CoreStreamBase::_signalEvent(v10, v11, v12, 1);
}

void PACTimerCallback_FTPStream(uint64_t a1, uint64_t a2)
{
  const __CFAllocator *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFErrorRef CFError;
  __CFRunLoop *Current;

  v3 = CFGetAllocator(*(CFTypeRef *)(a2 + 32));
  CFError = __cfnCreateCFError(v3, CFSTR("kCFErrorDomainCFNetwork"), 308, v4, v5, v6, v7, v8, 0);
  PACExecutionComplete_FTPStream(a2, 0, CFError);
  Current = CFRunLoopGetCurrent();
  CFRunLoopStop(Current);
}

void _SetSOCKS5ProxyInformation(const __CFAllocator *a1, uint64_t a2, const void *a3, const void *a4, const void *a5, const void *a6)
{
  __CFDictionary *Mutable;

  Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0C9B2C8], a3);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0C9B2D0], a4);
  if (a5)
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0C9B2D8], a5);
  if (a6)
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0C9B2B8], a6);
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a2 + 88), &unk_1EDCFBF30, Mutable);
  if (Mutable)
    CFRelease(Mutable);
}

void _StartHTTPRequest(const __CFAllocator *a1, _WORD *a2, _QWORD *a3, const __CFURL *a4)
{
  const __CFString *Value;
  const __CFString *v9;
  __CFHTTPMessage *v10;
  CFStringRef v11;
  CFStringRef v12;
  const __CFURL *v13;
  __CFHTTPMessage *Request;
  const __CFString *v15;
  const __CFString *v16;
  __CFReadStream *v17;
  __CFReadStream *v18;
  _OWORD *v19;
  const __CFString *v20;
  const __CFString *v21;
  const __CFAllocator *v22;
  CFNumberRef v23;
  const void *v24;
  CFStringRef Copy;
  int v26;
  __CFDictionary *Mutable;
  const __CFString *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  CoreStreamBase *v37;
  CFStreamClientContext v38;
  CFTypeRef v39[2];
  CFTypeRef v40[2];
  CFTypeRef v41[2];
  CFTypeRef cf[2];
  CFTypeRef v43[2];
  _QWORD valuePtr[6];

  v38.version = 0;
  v38.info = a2;
  memset(&v38.retain, 0, 24);
  Value = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 11), CFSTR("kCFStreamPropertyFTPUserName"));
  v9 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 11), CFSTR("kCFStreamPropertyFTPPassword"));
  v10 = (__CFHTTPMessage *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 11), CFSTR("_kCFStreamPropertyFTPLastHTTPResponse"));
  *a2 |= 0x10u;
  *a3 = 0;
  a3[1] = 0;
  if (Value)
  {
    CFRetain(Value);
    if (v9)
    {
LABEL_3:
      CFRetain(v9);
      goto LABEL_6;
    }
  }
  else
  {
    Value = CFURLCopyUserName(*((CFURLRef *)a2 + 1));
    if (v9)
      goto LABEL_3;
  }
  v9 = CFURLCopyPassword(*((CFURLRef *)a2 + 1));
LABEL_6:
  *(_OWORD *)cf = 0u;
  *(_OWORD *)v43 = 0u;
  *(_OWORD *)v40 = 0u;
  *(_OWORD *)v41 = 0u;
  *(_OWORD *)v39 = 0u;
  _CFURLCopyComponents();
  if (Value)
    v11 = CFURLCreateStringByAddingPercentEscapes(a1, Value, 0, 0, 0x8000100u);
  else
    v11 = 0;
  v39[1] = v11;
  if (!v40[0])
  {
    if (v9)
      v12 = CFURLCreateStringByAddingPercentEscapes(a1, v9, 0, 0, 0x8000100u);
    else
      v12 = 0;
    v40[0] = v12;
  }
  if (cf[1])
  {
    CFRelease(cf[1]);
    cf[1] = 0;
  }
  if (v43[0])
  {
    CFRelease(v43[0]);
    v43[0] = 0;
  }
  if (cf[0])
  {
    CFRelease(cf[0]);
    cf[0] = 0;
  }
  if (Value)
    CFRelease(Value);
  if (v9)
    CFRelease(v9);
  v13 = (const __CFURL *)_CFURLCreateFromComponents();
  if (v39[0])
    CFRelease(v39[0]);
  if (v39[1])
    CFRelease(v39[1]);
  if (v40[0])
    CFRelease(v40[0]);
  if (v40[1])
    CFRelease(v40[1]);
  if (v41[1])
    CFRelease(v41[1]);
  if (v43[1])
    CFRelease(v43[1]);
  if (v13)
  {
    Request = CFHTTPMessageCreateRequest(a1, CFSTR("GET"), v13, CFSTR("HTTP/1.1"));
    CFRelease(v13);
    if (!v10)
      goto LABEL_39;
    goto LABEL_38;
  }
  Request = CFHTTPMessageCreateRequest(a1, CFSTR("GET"), *((CFURLRef *)a2 + 1), CFSTR("HTTP/1.1"));
  if (v10)
  {
LABEL_38:
    v15 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 11), CFSTR("kCFStreamPropertyFTPProxyUser"));
    v16 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 11), CFSTR("kCFStreamPropertyFTPProxyPassword"));
    CFHTTPMessageAddAuthentication(Request, v10, v15, v16, 0, 1u);
  }
LABEL_39:
  valuePtr[0] = MEMORY[0x1E0C809B0];
  valuePtr[1] = 3221225472;
  valuePtr[2] = __CFReadStreamCreateForHTTPRequest_block_invoke;
  valuePtr[3] = &__block_descriptor_48_e26__v16__0____CFReadStream__8l;
  valuePtr[4] = a1;
  valuePtr[5] = Request;
  v17 = (__CFReadStream *)CFReadStreamCreate();
  if (v17)
  {
    v18 = v17;
    v19 = CoreReadStreamCreateWithCFReadStream(a1, v17);
    CFRelease(v18);
  }
  else
  {
    v19 = 0;
  }
  *((_QWORD *)a2 + 3) = v19;
  CFRelease(Request);
  if (*((_QWORD *)a2 + 3))
  {
    v20 = CFURLCopyScheme(a4);
    v21 = CFURLCopyHostName(a4);
    LODWORD(valuePtr[0]) = CFURLGetPortNumber(a4);
    v22 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v23 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, valuePtr);
    v24 = CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 11), CFSTR("kCFStreamPropertyFTPAttemptPersistentConnection"));
    if (v21)
    {
      Copy = CFStringCreateCopy(v22, v21);
      CFRelease(v21);
    }
    else
    {
      Copy = 0;
    }
    Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (CFStringCompare(v20, CFSTR("http"), 1uLL))
    {
      CFDictionarySetValue(Mutable, &unk_1EDCFEA80, Copy);
      v28 = (const __CFString *)&unk_1EDCFEA48;
    }
    else
    {
      CFDictionarySetValue(Mutable, CFSTR("FTPProxy"), Copy);
      v28 = CFSTR("FTPPort");
    }
    CFDictionarySetValue(Mutable, v28, v23);
    v29 = *((_QWORD *)a2 + 3);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (v29)
      v30 = v29 + 16;
    else
      v30 = 0;
    ++*(_QWORD *)(v30 + 80);
    (*(void (**)(_QWORD, void *, __CFDictionary *))(**(_QWORD **)(v30 + 24) + 32))(*(_QWORD *)(v30 + 24), &unk_1EDCFEC40, Mutable);
    --*(_QWORD *)(v30 + 80);
    if (Mutable)
      CFRelease(Mutable);
    v31 = *MEMORY[0x1E0C9AE50];
    if (!v24 || CFEqual(v24, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
    {
      v32 = *((_QWORD *)a2 + 3);
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      if (v32)
        v33 = v32 + 16;
      else
        v33 = 0;
      ++*(_QWORD *)(v33 + 80);
      (*(void (**)(_QWORD, void *, uint64_t))(**(_QWORD **)(v33 + 24) + 32))(*(_QWORD *)(v33 + 24), &unk_1EDCFEB60, v31);
      --*(_QWORD *)(v33 + 80);
    }
    CFDictionaryApplyFunction(*((CFDictionaryRef *)a2 + 11), (CFDictionaryApplierFunction)_StreamPropertyApplier, *((void **)a2 + 3));
    v34 = *((_QWORD *)a2 + 3);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (v34)
      v35 = v34 + 16;
    else
      v35 = 0;
    CoreReadStream::setClient(v35, -1, (uint64_t)_DataStreamCallBack, &v38);
    _CFTypeScheduleOnMultipleRunLoops(*((void **)a2 + 3), *((const __CFArray **)a2 + 10));
    v36 = *((_QWORD *)a2 + 3);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (v36)
      v37 = (CoreStreamBase *)(v36 + 16);
    else
      v37 = 0;
    CoreStreamBase::_streamInterface_Open(v37);
    if (Copy)
      CFRelease(Copy);
    if (v23)
      CFRelease(v23);
    if (v20)
      CFRelease(v20);
  }
  else
  {
    if (*__error())
    {
      v26 = *__error();
      *a3 = 1;
    }
    else
    {
      *a3 = 1;
      v26 = 12;
    }
    *((_DWORD *)a3 + 2) = v26;
  }
}

CFMutableDictionaryRef _FTPConnectionCacheCreate(void)
{
  const __CFAllocator *v0;
  _QWORD *v1;
  uint64_t v2;
  CFMutableDictionaryRef result;

  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (!_kFTPConnectionCallBacks)
  {
    v1 = CFAllocatorAllocate(v0, 80, 0);
    _kFTPConnectionCallBacks = (uint64_t)v1;
    *v1 = 0;
    v1[1] = _CFFTPNetConnectionContextAllocate;
    v1[2] = _CFFTPNetConnectionContextFinalize;
    v1[3] = _FTPConnectionCreateStreams;
    v1[4] = _FTPConnectionRequestStateChanged;
    v1[5] = _FTPConnectionTransmitRequest;
    v1[6] = _FTPConnectionReceiveResponse;
    v1[7] = _FTPResponseStreamCallBack;
    v1[8] = _FTPRequestStreamCallBack;
    v1[9] = _FTPCopyRunLoopArrayCallBack;
  }
  gFTPConnectionTimeouts = (uint64_t)CFDictionaryCreateMutable(v0, 0, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks, MEMORY[0x1E0C9B3A0]);
  v2 = operator new();
  *(_DWORD *)(v2 + 8) = 0;
  *(_QWORD *)v2 = &off_1E14F00E0;
  result = CFDictionaryCreateMutable(0, 0, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
  *(_QWORD *)(v2 + 16) = result;
  gFTPConnectionCache = v2;
  return result;
}

void sub_183FE8BBC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10A1C406B6A53AFLL);
  _Unwind_Resume(a1);
}

void _FTPConnectionCacheExpiration(const void *a1, uint64_t a2, __CFArray *a3)
{
  double Current;

  Current = CFAbsoluteTimeGetCurrent();
  if (Current >= MEMORY[0x186DB5F80](a2))
    CFArrayAppendValue(a3, a1);
}

uint64_t NetConnection::doNotAllowMoreRequests(NetConnection *this)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;

  v2 = *((_QWORD *)this + 12);
  if (v2)
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  *((_WORD *)this + 44) &= ~1u;
  result = NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease((uint64_t)this);
  v4 = *((_QWORD *)this + 12);
  if (v4)
    return pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
  return result;
}

_OWORD *_CFFTPNetConnectionContextAllocate(const __CFAllocator *a1, __int128 *a2)
{
  _OWORD *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;

  v4 = CFAllocatorAllocate(a1, 64, 0);
  v5 = a2[3];
  v7 = *a2;
  v6 = a2[1];
  v4[2] = a2[2];
  v4[3] = v5;
  *v4 = v7;
  v4[1] = v6;
  *((_QWORD *)v4 + 1) = *((_QWORD *)a2 + 1);
  (*(void (**)(_QWORD))(**((_QWORD **)a2 + 1) + 40))(*((_QWORD *)a2 + 1));
  if (!*((_QWORD *)v4 + 6))
    *((_QWORD *)v4 + 6) = CFDataCreateMutable(a1, 0);
  if (!*((_QWORD *)v4 + 7))
    *((_QWORD *)v4 + 7) = CFDataCreateMutable(a1, 0);
  *(_BYTE *)v4 &= ~4u;
  return v4;
}

void _CFFTPNetConnectionContextFinalize(CFAllocatorRef allocator, _QWORD *ptr)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  const void *v7;

  v4 = ptr[1];
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
  v5 = (const void *)ptr[3];
  if (v5)
    CFRelease(v5);
  v6 = (const void *)ptr[6];
  if (v6)
    CFRelease(v6);
  v7 = (const void *)ptr[7];
  if (v7)
    CFRelease(v7);
  CFAllocatorDeallocate(allocator, ptr);
}

uint64_t _FTPConnectionCreateStreams(__CFAllocator *a1, uint64_t a2, void **a3, void **a4)
{
  uint64_t v7;
  const __CFString *v8;
  uint64_t v9;
  int v10;
  const __CFDictionary *v11;
  const __CFDictionary *Value;
  const __CFNumber *v13;
  __CFHost *v14;
  __CFReadStream *v15;
  _QWORD *v16;
  uint64_t v17;
  unsigned int valuePtr;
  CFTypeRef v20;
  CFTypeRef cf;

  v7 = *(_QWORD *)(a2 + 8);
  v8 = *(const __CFString **)(v7 + 24);
  v9 = *(unsigned int *)(v7 + 32);
  v10 = *(_DWORD *)(v7 + 36);
  valuePtr = *(_DWORD *)(v7 + 32);
  v11 = *(const __CFDictionary **)(v7 + 40);
  *a3 = 0;
  *a4 = 0;
  if ((v10 - 3) <= 1)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(v11, CFSTR("kCFStreamPropertyFTPProxy"));
    v13 = (const __CFNumber *)CFDictionaryGetValue(Value, CFSTR("FTPPort"));
    v8 = (const __CFString *)CFDictionaryGetValue(Value, CFSTR("FTPProxy"));
    if (v13)
    {
      CFNumberGetValue(v13, kCFNumberSInt32Type, &valuePtr);
      v9 = valuePtr;
    }
    else
    {
      if (v10 == 3)
        v9 = 21;
      else
        v9 = 990;
      valuePtr = v9;
    }
  }
  v20 = 0;
  cf = 0;
  v14 = (__CFHost *)_CFHostCreateWithNameAndPortForConnect(a1, v8, (const __CFAllocator *)(unsigned __int16)v9);
  if (v14 || (v14 = CFHostCreateWithName(a1, v8)) != 0)
  {
    __CFStreamCreatePairWithSocketToCFHost(a1, v14, (const __CFAllocator *)v9, (__CFReadStream **)&cf, (__CFWriteStream **)&v20, 0);
    CFRelease(v14);
    v15 = (__CFReadStream *)cf;
  }
  else
  {
    v15 = 0;
    v20 = 0;
    cf = 0;
  }
  *a4 = CoreReadStreamCreateWithCFReadStream(a1, v15);
  *a3 = CoreWriteStreamCreateWithCFWriteStream(a1, (__CFWriteStream *)v20);
  if (cf)
    CFRelease(cf);
  if (v20)
    CFRelease(v20);
  if (*a4 && (v16 = *a3) != 0)
  {
    v17 = *MEMORY[0x1E0C9AE50];
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    ++v16[12];
    (*(void (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)v16[5] + 32))(v16[5], 0x1EDCFB1A0, v17);
    --v16[12];
    CFDictionaryApplyFunction(v11, (CFDictionaryApplierFunction)_StreamPropertyApplier, *a4);
    CFDictionaryApplyFunction(v11, (CFDictionaryApplierFunction)_StreamPropertyApplier, *a3);
    return 0;
  }
  else
  {
    __error();
    return 1;
  }
}

void _FTPConnectionRequestStateChanged(uint64_t a1, int a2, uint64_t a3, NetConnection *a4, uint64_t a5)
{
  const __CFArray *v9;
  CFIndex Count;
  CFIndex v11;
  CFIndex i;
  CoreSchedulingSet *ValueAtIndex;
  const __CFString *v14;
  int v15;
  const void *Value;
  int v17;
  const __CFAllocator *v18;
  CFAbsoluteTime Current;
  CFDateRef v20;
  CFDateRef v21;
  const __CFArray *v22;
  CFIndex v23;
  CFIndex j;
  __CFRunLoop *v25;
  const __CFString *v26;
  uint64_t v27;
  uint64_t v28;
  CFTypeID v29;
  uint64_t v30;
  CoreStreamBase *v31;
  char v32;
  CFStreamError v33;

  switch(a2)
  {
    case 1:
      *(_QWORD *)(a1 + 128) = a4;
      break;
    case 2:
      v9 = *(const __CFArray **)(a1 + 80);
      Count = CFArrayGetCount(v9);
      if (Count >= 1)
      {
        v11 = Count;
        for (i = 0; i < v11; i += 2)
        {
          ValueAtIndex = (CoreSchedulingSet *)CFArrayGetValueAtIndex(v9, i);
          v14 = (const __CFString *)CFArrayGetValueAtIndex(v9, i + 1);
          NetConnection::schedule((uint64_t)a4, (uint64_t *)a1, ValueAtIndex, v14);
        }
      }
      v15 = *(_DWORD *)(a5 + 20);
      if (v15 == 8)
      {
        _StartProcess(a5, a1);
      }
      else if (v15 >= 9)
      {
        *(_BYTE *)a5 |= 2u;
        NetConnection::getState(*(NetConnection **)(a1 + 128), 1, (uint64_t *)a1);
      }
      break;
    case 5:
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), CFSTR("kCFStreamPropertyFTPAttemptPersistentConnection"));
      if (Value)
      {
        v17 = CFEqual(Value, (CFTypeRef)*MEMORY[0x1E0C9AE40]);
        *(_BYTE *)a5 |= 8u;
        if (v17)
          goto LABEL_16;
      }
      else
      {
        *(_BYTE *)a5 |= 8u;
      }
      v18 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Current = CFAbsoluteTimeGetCurrent();
      v20 = CFDateCreate(v18, Current + 180.0);
      if (v20)
      {
        v21 = v20;
        CFDictionarySetValue((CFMutableDictionaryRef)gFTPConnectionTimeouts, *(const void **)(a1 + 128), v20);
        CFRelease(v21);
      }
      goto LABEL_16;
    case 7:
LABEL_16:
      v22 = *(const __CFArray **)(a1 + 80);
      v23 = CFArrayGetCount(v22);
      NetConnection::dequeue(a4, (void *)a1);
      if (v23 >= 1)
      {
        for (j = 0; j < v23; j += 2)
        {
          CFArrayGetValueAtIndex(v22, j);
          CFArrayGetValueAtIndex(v22, j + 1);
          NetConnection::unschedule(a4, (uint64_t *)a1, v25, v26);
        }
      }
      v27 = *(_QWORD *)(a1 + 128);
      if (v27)
        (*(void (**)(uint64_t))(*(_QWORD *)v27 + 48))(v27);
      *(_QWORD *)(a1 + 128) = 0;
      if (a2 == 7 && (*(_WORD *)a1 & 0x400) == 0)
      {
        v32 = 0;
        _FTPStreamOpen(*(_QWORD *)(a1 + 32), &v33, &v32, a1);
        if (v32)
        {
          if (v33.error)
            v28 = 8;
          else
            v28 = 1;
          v29 = CFGetTypeID(*(CFTypeRef *)(a1 + 32));
          if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
            dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
          v30 = *(_QWORD *)(a1 + 32);
          if (v30)
            v31 = (CoreStreamBase *)(v30 + 16);
          else
            v31 = 0;
          if (v29 != *(_QWORD *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)
            && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
          {
            dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
          }
          CoreStreamBase::_signalEvent(v31, v28, v33, 1);
        }
      }
      break;
    default:
      return;
  }
}

void _FTPConnectionTransmitRequest(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CoreStreamBase *v12;
  const void *Value;
  const __CFAllocator *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  _BOOL4 v20;
  BOOL v21;
  CFStringRef v22;
  CFStringRef v23;
  CFStringRef v24;
  SInt32 v25;
  CoreStreamBase *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  CoreStreamBase *v30;
  uint64_t v31;
  __int128 v32;

  v6 = a2[12];
  if (!v6)
  {
    v8 = a2[18];
LABEL_7:
    v11 = a2[19];
    goto LABEL_8;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  v7 = a2[12];
  v8 = a2[18];
  if (!v7)
    goto LABEL_7;
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
  v9 = a2[12];
  if (!v9)
    goto LABEL_7;
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
  v10 = a2[12];
  v11 = a2[19];
  if (v10)
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8));
LABEL_8:
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  if (v8)
    v12 = (CoreStreamBase *)(v8 + 16);
  else
    v12 = 0;
  if (CoreStreamBase::_streamInterface_CanWrite(v12))
  {
    if ((*(_BYTE *)a3 & 0x10) != 0)
    {
      _FTPRequestStreamCallBack(a1, v8, 4, a2, a3);
    }
    else
    {
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), CFSTR("kCFStreamPropertyFTPUserName"));
      v14 = CFGetAllocator(*(CFTypeRef *)(a1 + 80));
      v15 = *(_QWORD *)(a3 + 8);
      v16 = *(_QWORD *)(v15 + 24);
      v17 = *(_DWORD *)(v15 + 36);
      v18 = *(int *)(v15 + 32);
      if (Value)
      {
        CFRetain(Value);
      }
      else
      {
        Value = CFURLCopyUserName(*(CFURLRef *)(a1 + 8));
        if (!Value)
          Value = CFRetain(CFSTR("anonymous"));
      }
      if ((v17 - 3) <= 1)
      {
        v20 = v17 == 4 && (_DWORD)v18 == 990;
        v21 = (_DWORD)v18 == 21 && v17 == 3;
        if (v21 || v20)
          v22 = CFStringCreateWithFormat(v14, 0, CFSTR("%@@%@"), Value, v16);
        else
          v22 = CFStringCreateWithFormat(v14, 0, CFSTR("%@@%@:%ld"), Value, v16, v18);
        v23 = v22;
        CFRelease(Value);
        Value = v23;
      }
      v24 = CFStringCreateWithFormat(v14, 0, CFSTR("USER %@\r\n"), Value);
      CFRelease(Value);
      *(_BYTE *)a3 |= 0x10u;
      if (v24)
      {
        _WriteCommand(a3, a1, v24);
        CFRelease(v24);
      }
      else
      {
        v32 = xmmword_1841E3810;
        v25 = *__error();
        if (!v25)
          v25 = 12;
        DWORD2(v32) = v25;
        _ReportError(a1, (CFStreamError *)&v32);
      }
    }
  }
  if (*(_QWORD *)(a1 + 128))
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (v11)
      v26 = (CoreStreamBase *)(v11 + 16);
    else
      v26 = 0;
    if (CoreStreamBase::_streamInterface_CanRead(v26))
    {
      v27 = a2[12];
      if (v27)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v27 + 8));
        v28 = a2[12];
        v29 = a2[19];
        if (v28)
          pthread_mutex_unlock((pthread_mutex_t *)(v28 + 8));
      }
      else
      {
        v29 = a2[19];
      }
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      if (v29)
        v30 = (CoreStreamBase *)(v29 + 16);
      else
        v30 = 0;
      if (CoreStreamBase::_streamInterface_CanRead(v30))
        _FTPResponseStreamCallBack(a1, v29, 2, v31, a3);
    }
  }
}

void _FTPConnectionReceiveResponse(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CoreStreamBase *v12;
  uint64_t v13;
  CoreStreamBase *v14;

  v6 = a2[12];
  if (!v6)
  {
    v8 = a2[19];
LABEL_7:
    v11 = a2[18];
    goto LABEL_8;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  v7 = a2[12];
  v8 = a2[19];
  if (!v7)
    goto LABEL_7;
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
  v9 = a2[12];
  if (!v9)
    goto LABEL_7;
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
  v10 = a2[12];
  v11 = a2[18];
  if (v10)
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8));
LABEL_8:
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  if (v8)
    v12 = (CoreStreamBase *)(v8 + 16);
  else
    v12 = 0;
  if (CoreStreamBase::_streamInterface_CanRead(v12))
    _FTPResponseStreamCallBack(a1, v8, 2, v13, a3);
  if (*(_QWORD *)(a1 + 128))
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    if (v11)
      v14 = (CoreStreamBase *)(v11 + 16);
    else
      v14 = 0;
    if (CoreStreamBase::_streamInterface_CanWrite(v14))
      _FTPConnectionTransmitRequest(a1, a2, a3);
  }
}

void _FTPResponseStreamCallBack(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFIndex Length;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 *v12;
  uint64_t v13;
  __int128 v14;
  unsigned __int8 *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  UInt8 *MutableBytePtr;
  uint64_t Line;
  uint64_t v21;
  unsigned __int8 *v22;
  int64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  SInt32 v29;
  char v30;
  char v31;
  int v32;
  const __CFAllocator *v33;
  const __CFAllocator *v34;
  const __CFAllocator *v35;
  CFStringRef v36;
  uint64_t v37;
  size_t v38;
  const __CFString *PathForContext;
  const __CFString *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  CFDictionaryRef *parsed;
  unsigned __int8 *v45;
  unsigned __int8 *v46;
  __int128 v47;

  switch(a3)
  {
    case 16:
      goto LABEL_115;
    case 8:
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      v13 = a2 + 16;
      if (!a2)
        v13 = 0;
      v14 = *(_OWORD *)(v13 + 56);
      break;
    case 2:
      Length = CFDataGetLength(*(CFDataRef *)(a5 + 48));
      v9 = *(_QWORD *)(a5 + 32);
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      v10 = a2 ? a2 + 16 : 0;
      if (!CoreStreamBase::_streamInterface_CanRead((CoreStreamBase *)v10))
        return;
      v11 = Length - v9;
      if (v11 <= 2047)
      {
        CFDataSetLength(*(CFMutableDataRef *)(a5 + 48), *(_QWORD *)(a5 + 32) + 2048);
        if (CFDataGetLength(*(CFDataRef *)(a5 + 48)) < *(_QWORD *)(a5 + 32) + 2048)
        {
          v12 = &xmmword_1841E3A80;
LABEL_116:
          v14 = *v12;
          break;
        }
        v11 = 2048;
      }
      v15 = &CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a5 + 48))[*(_QWORD *)(a5 + 32)];
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      v16 = CoreStreamBase::_streamInterface_Read((CoreStreamBase *)v10, v15, v11);
      if ((v16 & 0x8000000000000000) == 0)
      {
        if (v16)
        {
          v17 = *(_QWORD *)(a5 + 32) + v16;
          *(_QWORD *)(a5 + 32) = v17;
          if (!v17)
            return;
          parsed = (CFDictionaryRef *)(a1 + 64);
          v18 = MEMORY[0x1E0C80978];
          while (1)
          {
            v45 = 0;
            v46 = 0;
            MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a5 + 48));
            Line = _FindLine(MutableBytePtr, *(_QWORD *)(a5 + 32), (const unsigned __int8 **)&v46, (const unsigned __int8 **)&v45);
            if (!Line)
              return;
            v21 = Line;
            v22 = v46;
            if (!v46)
              goto LABEL_101;
            v23 = v45 - v46;
            if (v45 - v46 < 4)
              break;
            v24 = *v46;
            if ((*(_DWORD *)(v18 + 4 * v24 + 60) & 0x400) == 0)
              break;
            v25 = v46[1];
            if ((*(_DWORD *)(v18 + 4 * v25 + 60) & 0x400) == 0)
              break;
            v26 = v46[2];
            if ((*(_DWORD *)(v18 + 4 * v26 + 60) & 0x400) == 0)
              break;
            v27 = v46[3];
            if (v27 != 45 && v27 != 32)
              break;
            v28 = 100 * v24 + 10 * v25 + v26;
            if ((v28 - 5428) > 0x1F3)
              break;
            v29 = v28 - 5328;
            if (v27 == 32)
            {
              v30 = *(_BYTE *)a5;
              if ((*(_BYTE *)a5 & 1) != 0 && v29 != *(_DWORD *)(a5 + 16))
              {
                v47 = xmmword_1841E3820;
                DWORD2(v47) = v29;
                goto LABEL_126;
              }
              *(_DWORD *)(a5 + 16) = v29;
              v31 = v30 & 0xFE;
            }
            else
            {
              if (v29 == -1)
                break;
              *(_DWORD *)(a5 + 16) = v29;
              v31 = *(_BYTE *)a5 | 1;
            }
            *(_BYTE *)a5 = v31;
LABEL_42:
            v32 = *(_DWORD *)(a5 + 20);
            if ((v31 & 2) != 0)
            {
              if (v32 > 8)
              {
                if (v32 <= 0xE)
                {
                  if ((v31 & 1) == 0)
                  {
                    *(_DWORD *)(a5 + 20) = 8;
                    _StartProcess(a5, a1);
                  }
                  goto LABEL_101;
                }
              }
              else
              {
                *(_BYTE *)a5 = v31 & 0xFD;
              }
            }
            switch(v32)
            {
              case 0:
                if ((v31 & 1) == 0)
                  _HandleConnect(a5, a1, v22, v23);
                break;
              case 1:
                if ((v31 & 1) == 0)
                  _HandleUsername(a5, a1);
                break;
              case 2:
                if ((v31 & 1) == 0)
                  _HandlePassword(a5, a1);
                break;
              case 3:
                if ((v31 & 1) == 0)
                  _HandleSystem(a5, a1, v22, v23);
                break;
              case 4:
                if ((v31 & 1) == 0)
                  _HandleSiteDirStyle(a5, a1, v22, v23);
                break;
              case 5:
                if ((v31 & 1) == 0)
                {
                  *(_DWORD *)(a5 + 20) = 6;
                  _WriteCommand(a5, a1, CFSTR("PWD\r\n"));
                }
                break;
              case 6:
                if ((v31 & 1) == 0)
                  _HandlePrintWorkingDirectory(a5, a1, (char *)v22, v23);
                break;
              case 7:
                if ((v31 & 1) == 0)
                  _HandleType(a5, a1);
                break;
              case 9:
                if ((v31 & 1) == 0)
                  _HandleChangeDirectory((char *)a5, a1);
                break;
              case 10:
                if ((v31 & 1) == 0)
                  _HandlePassive(a5, (_WORD *)a1, (uint64_t)v22);
                break;
              case 11:
                if ((v31 & 1) == 0)
                  _HandlePort(a5, a1);
                break;
              case 12:
                if (!*parsed)
                {
                  v33 = CFGetAllocator(*(CFTypeRef *)(a1 + 88));
                  CFFTPCreateParsedResourceListing(v33, v22, v23, parsed);
                }
                if ((v31 & 1) != 0 || (*(_DWORD *)(v18 + 4 * *v22 + 60) & 0x400) == 0)
                  break;
                v34 = CFGetAllocator(*(CFTypeRef *)(a1 + 88));
                v35 = v34;
                if (*(_QWORD *)(a1 + 72))
                {
                  v36 = CFStringCreateWithFormat(v34, 0, CFSTR("REST %lld\r\n"), *(_QWORD *)(a1 + 72));
                  *(_DWORD *)(a5 + 20) = 14;
LABEL_77:
                  _WriteCommand(a5, a1, v36);
                  if (v36)
                    CFRelease(v36);
                  break;
                }
                PathForContext = _CreatePathForContext(v34, a5, *(__CFURL **)(a1 + 8));
                if (PathForContext)
                {
                  v40 = PathForContext;
                  v36 = CFStringCreateWithFormat(v35, 0, CFSTR("RETR %@\r\n"), PathForContext);
                  *(_DWORD *)(a5 + 20) = 15;
                  *(_WORD *)a1 &= ~0x800u;
                  CFRelease(v40);
                  v41 = *(_QWORD *)(a1 + 24);
                  if (v41)
                  {
                    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
                      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
                    CoreStreamBase::_streamInterface_Open((CoreStreamBase *)(v41 + 16));
                  }
                  goto LABEL_77;
                }
                v47 = xmmword_1841E3A40;
                _ReportError(a1, (CFStreamError *)&v47);
                break;
              case 13:
                if ((v31 & 1) == 0)
                  _HandleSize(a5, a1, (uint64_t)v22, v23);
                break;
              case 14:
                if ((v31 & 1) == 0)
                  _HandleRestart(a5, a1);
                break;
              case 15:
                if ((v31 & 1) == 0)
                  goto LABEL_90;
                break;
              case 16:
                if ((v31 & 1) == 0)
                  goto LABEL_90;
                break;
              case 17:
                if ((v31 & 1) == 0)
                  goto LABEL_90;
                break;
              case 18:
                if ((v31 & 1) == 0)
LABEL_90:
                  _HandleRetrieve(a5, a1);
                break;
              case 19:
                if ((v31 & 1) == 0)
                  goto LABEL_100;
                break;
              case 20:
                if ((v31 & 1) == 0)
                  goto LABEL_100;
                break;
              case 21:
                if ((v31 & 1) == 0)
                  goto LABEL_100;
                break;
              case 22:
                if ((v31 & 1) == 0)
                  _HandleRenameFrom(a5, a1);
                break;
              case 23:
                if ((v31 & 1) == 0)
LABEL_100:
                  _HandleMakeDirectory(a5, a1);
                break;
              default:
                break;
            }
LABEL_101:
            v37 = *(_QWORD *)(a5 + 32);
            v38 = v37 - v21;
            *(_QWORD *)(a5 + 32) = v37 - v21;
            if (v37 != v21)
            {
              memmove(MutableBytePtr, &MutableBytePtr[v21], v38);
              v38 = *(_QWORD *)(a5 + 32);
            }
            if (!v38)
              return;
          }
          v31 = *(_BYTE *)a5;
          if ((*(_BYTE *)a5 & 1) == 0)
          {
            v47 = xmmword_1841E3830;
            v29 = -1;
LABEL_126:
            *(_DWORD *)(a5 + 16) = v29;
            goto LABEL_118;
          }
          goto LABEL_42;
        }
        if ((*(_BYTE *)a5 & 8) != 0)
        {
          pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 136) + 8));
          v42 = *(_QWORD *)(a1 + 128);
          if (v42)
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v42 + 72))(v42);
            NetConnection::dequeue(*(NetConnection **)(a1 + 128), (void *)a1);
            v43 = *(_QWORD *)(a1 + 128);
            if (v43)
              (*(void (**)(uint64_t))(*(_QWORD *)v43 + 48))(v43);
            *(_QWORD *)(a1 + 128) = 0;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(*(_QWORD *)(a1 + 136) + 8));
          _FTPStreamOpen(*(_QWORD *)(a1 + 32), &v47, &v46, a1);
          return;
        }
LABEL_115:
        v12 = &xmmword_1841E3A50;
        goto LABEL_116;
      }
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      v14 = *(_OWORD *)(v10 + 56);
      break;
    default:
      return;
  }
  v47 = v14;
LABEL_118:
  _ReportError(a1, (CFStreamError *)&v47);
}

void _FTPRequestStreamCallBack(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5)
{
  uint64_t v8;
  __int128 v9;
  UInt8 *MutableBytePtr;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  __int128 v16;

  switch(a3)
  {
    case 16:
      goto LABEL_20;
    case 8:
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      v8 = a2 + 16;
      if (!a2)
        v8 = 0;
      v9 = *(_OWORD *)(v8 + 56);
      goto LABEL_21;
    case 4:
      if ((*(_BYTE *)a5 & 0x10) == 0)
      {
        _FTPConnectionTransmitRequest(a1, a4, a5);
        return;
      }
      if (*(_QWORD *)(a5 + 40))
      {
        MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a5 + 56));
        v11 = *(_QWORD *)(a5 + 40);
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        {
          v15 = *(_QWORD *)(a5 + 40);
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
          v11 = v15;
        }
        if (a2)
          v12 = a2 + 16;
        else
          v12 = 0;
        v13 = CoreStreamBase::_streamInterface_Write((CoreStreamBase *)v12, MutableBytePtr, v11);
        if (v13 < 0)
        {
          if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
            dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
          v9 = *(_OWORD *)(v12 + 56);
          goto LABEL_21;
        }
        if (v13)
        {
          v14 = *(_QWORD *)(a5 + 40) - v13;
          *(_QWORD *)(a5 + 40) = v14;
          memmove(MutableBytePtr, &MutableBytePtr[v13], v14);
          return;
        }
LABEL_20:
        v9 = xmmword_1841E3A50;
LABEL_21:
        v16 = v9;
        _ReportError(a1, (CFStreamError *)&v16);
      }
      break;
  }
}

CFArrayRef _FTPCopyRunLoopArrayCallBack(uint64_t a1)
{
  return CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFArrayRef *)(a1 + 80));
}

uint64_t _FindLine(const unsigned __int8 *a1, uint64_t a2, const unsigned __int8 **a3, const unsigned __int8 **a4)
{
  uint64_t v4;
  const unsigned __int8 *v5;
  const unsigned __int8 *v6;
  int v7;
  const unsigned __int8 *i;
  unsigned __int8 v12;
  const unsigned __int8 *v13;
  int v14;

  v4 = 0;
  *a3 = 0;
  *a4 = 0;
  if (a1 && a2)
  {
    v5 = &a1[a2 - 1];
    if (v5 < a1)
    {
      return a2;
    }
    else
    {
      v6 = a1;
      while (1)
      {
        v7 = *v6;
        if (v7 != 10 && v7 != 13)
          break;
        if (++v6 > v5)
          return a2;
      }
      if (v6 <= v5)
      {
        for (i = v6 + 1; v7 != 10 && v7 != 13; ++i)
        {
          if (i > v5)
            return v6 - a1;
          v12 = *i;
          LOBYTE(v7) = v12;
        }
        v13 = i - 1;
        *a3 = v6;
        *a4 = v13;
        do
        {
          v14 = *v13;
          if (v14 != 13 && v14 != 10)
            break;
          ++v13;
        }
        while (v13 <= v5);
        return v13 - a1;
      }
      else
      {
        return v6 - a1;
      }
    }
  }
  return v4;
}

void _StartProcess(uint64_t a1, uint64_t a2)
{
  const __CFAllocator *v4;
  const __CFString *PathForContext;
  CFTypeID v6;
  uint64_t v7;
  CoreStreamBase *v8;
  const __CFURL *v9;
  __CFURL *PathComponent;
  const void *v11;
  const __CFString *v12;
  __int128 v13;
  CFStreamError v14;

  if ((*(_WORD *)a2 & 0x200) != 0)
  {
    v6 = CFGetTypeID(*(CFTypeRef *)(a2 + 32));
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    v7 = *(_QWORD *)(a2 + 32);
    if (v7)
      v8 = (CoreStreamBase *)(v7 + 16);
    else
      v8 = 0;
    if (v6 != *(_QWORD *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)
      && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    }
    v14.domain = 0;
    *(_QWORD *)&v14.error = 0;
    CoreStreamBase::_signalEvent(v8, 1, v14, 1);
    _ConnectionComplete(a1, a2);
  }
  else
  {
    v4 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
    *(_BYTE *)a1 &= ~2u;
    if ((*(_BYTE *)a2 & 0x80) == 0
      && (CFURLHasDirectoryPath(*(CFURLRef *)(a2 + 8)) || _IsRoot(*(const __CFURL **)(a2 + 8))))
    {
      PathForContext = _CreatePathForContext(v4, a1, *(__CFURL **)(a2 + 8));
      if (!PathForContext)
      {
LABEL_6:
        v13 = xmmword_1841E3A40;
        _ReportError(a2, (CFStreamError *)&v13);
        return;
      }
    }
    else
    {
      v9 = *(const __CFURL **)(a2 + 8);
      PathComponent = CFURLCreateCopyDeletingLastPathComponent(v4, v9);
      *(_QWORD *)(a2 + 8) = PathComponent;
      PathForContext = _CreatePathForContext(v4, a1, PathComponent);
      v11 = *(const void **)(a2 + 8);
      if (v11)
        CFRelease(v11);
      *(_QWORD *)(a2 + 8) = v9;
      if (!PathForContext)
        goto LABEL_6;
    }
    v12 = CFStringCreateWithFormat(v4, 0, CFSTR("CWD %@\r\n"), PathForContext);
    CFRelease(PathForContext);
    *(_DWORD *)(a1 + 20) = 9;
    _WriteCommand(a1, a2, v12);
    if (v12)
      CFRelease(v12);
  }
}

void _HandleConnect(uint64_t a1, uint64_t a2, const UInt8 *a3, CFIndex a4)
{
  unsigned int v4;
  const __CFAllocator *v8;
  const __CFString *v9;
  __int128 v10;
  CFRange v11;

  v4 = *(_DWORD *)(a1 + 16);
  if (v4 >= 0xC8)
  {
    if (v4 < 0x12C)
    {
      v8 = CFGetAllocator(*(CFTypeRef *)(a2 + 80));
      v9 = CFStringCreateWithBytes(v8, a3, a4, 0x8000100u, 0);
      if (v9 || (v9 = CFStringCreateWithBytes(v8, a3, a4, 0x201u, 0)) != 0)
      {
        v11.length = CFStringGetLength(v9);
        v11.location = 0;
        if (CFStringFindWithOptions(v9, CFSTR("Mac OS X Server"), v11, 0, 0))
          *(_BYTE *)a1 |= 4u;
        CFRelease(v9);
      }
      *(_DWORD *)(a1 + 20) = 1;
    }
    else
    {
      v10 = xmmword_1841E3820;
      DWORD2(v10) = v4;
      _ReportError(a2, (CFStreamError *)&v10);
    }
  }
}

void _HandleUsername(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  const void *Value;
  const void *v6;
  const __CFAllocator *v7;
  CFStringRef v8;
  __int128 v9;

  v3 = *(_DWORD *)(a1 + 16);
  if (v3 - 400 <= 0xFFFFFF37)
  {
    v9 = xmmword_1841E3820;
LABEL_3:
    DWORD2(v9) = v3;
    _ReportError(a2, (CFStreamError *)&v9);
    return;
  }
  if (v3 < 0x12C)
  {
    *(_DWORD *)(a1 + 20) = 3;
    _WriteCommand(a1, a2, CFSTR("SYST\r\n"));
  }
  else
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 88), CFSTR("kCFStreamPropertyFTPPassword"));
    if (Value)
    {
      v6 = Value;
      CFRetain(Value);
    }
    else
    {
      v6 = CFURLCopyPassword(*(CFURLRef *)(a2 + 8));
      if (!v6)
        v6 = CFRetain(CFSTR("cfnetwork@apple.com"));
    }
    v7 = CFGetAllocator(*(CFTypeRef *)(a2 + 80));
    v8 = CFStringCreateWithFormat(v7, 0, CFSTR("PASS %@\r\n"), v6);
    if (v6)
      CFRelease(v6);
    if (!v8)
    {
      v9 = xmmword_1841E3810;
      v3 = *__error();
      if (!v3)
        v3 = 12;
      goto LABEL_3;
    }
    *(_DWORD *)(a1 + 20) = 2;
    _WriteCommand(a1, a2, v8);
    CFRelease(v8);
  }
}

void _HandlePassword(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  __int128 v3;

  v2 = *(_DWORD *)(a1 + 16);
  if (v2 - 400 > 0xFFFFFF37 && v2 < 0x12C)
  {
    *(_DWORD *)(a1 + 20) = 3;
    _WriteCommand(a1, a2, CFSTR("SYST\r\n"));
  }
  else
  {
    v3 = xmmword_1841E3820;
    DWORD2(v3) = v2;
    _ReportError(a2, (CFStreamError *)&v3);
  }
}

void _HandleSystem(uint64_t a1, uint64_t a2, const UInt8 *a3, CFIndex a4)
{
  const __CFAllocator *v8;
  const __CFString *v9;
  CFIndex Length;
  char v11;
  const __CFString *v12;
  CFRange v13;

  if ((*(_DWORD *)(a1 + 16) - 200) > 0x63)
  {
    v9 = 0;
    goto LABEL_6;
  }
  v8 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
  v9 = CFStringCreateWithBytes(v8, a3, a4, 0x8000100u, 0);
  Length = CFStringGetLength(v9);
  if (!v9)
  {
LABEL_6:
    v11 = 1;
    goto LABEL_7;
  }
  v13.length = Length;
  v13.location = 0;
  if (CFStringFindWithOptions(v9, CFSTR("Windows_NT"), v13, 0, 0))
  {
    *(_DWORD *)(a1 + 20) = 4;
    _WriteCommand(a1, a2, CFSTR("SITE DIRSTYLE\r\n"));
LABEL_11:
    CFRelease(v9);
    return;
  }
  v11 = 0;
LABEL_7:
  if ((*(_BYTE *)a1 & 4) != 0)
  {
    *(_DWORD *)(a1 + 20) = 5;
    v12 = CFSTR("SITE TRUTH ON\r\n");
  }
  else
  {
    *(_DWORD *)(a1 + 20) = 6;
    v12 = CFSTR("PWD\r\n");
  }
  _WriteCommand(a1, a2, v12);
  if ((v11 & 1) == 0)
    goto LABEL_11;
}

void _HandleSiteDirStyle(uint64_t a1, uint64_t a2, const UInt8 *a3, CFIndex a4)
{
  const __CFAllocator *v8;
  const __CFString *v9;
  const __CFString *v10;
  CFRange v11;

  if ((*(_DWORD *)(a1 + 16) - 200) <= 0x63)
  {
    v8 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
    v9 = CFStringCreateWithBytes(v8, a3, a4, 0x8000100u, 0);
    v11.length = CFStringGetLength(v9);
    v11.location = 0;
    if (CFStringFindWithOptions(v9, CFSTR("MSDOS-like directory output is on"), v11, 0, 0))
    {
      *(_DWORD *)(a1 + 20) = 4;
      _WriteCommand(a1, a2, CFSTR("SITE DIRSTYLE\r\n"));
      if (v9)
        CFRelease(v9);
      return;
    }
    if (v9)
      CFRelease(v9);
  }
  if ((*(_BYTE *)a1 & 4) != 0)
  {
    *(_DWORD *)(a1 + 20) = 5;
    v10 = CFSTR("SITE TRUTH ON\r\n");
  }
  else
  {
    *(_DWORD *)(a1 + 20) = 6;
    v10 = CFSTR("PWD\r\n");
  }
  _WriteCommand(a1, a2, v10);
}

void _WriteCommand(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  CFIndex Length;
  CFIndex v7;
  CFIndex Bytes;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  UInt8 *MutableBytePtr;
  CFIndex v14;
  CoreStreamBase *v15;
  CFRange v16;
  CFRange v17;

  Length = CFDataGetLength(*(CFDataRef *)(a1 + 56));
  v7 = CFStringGetLength(a3);
  v16.location = 0;
  v16.length = v7;
  Bytes = CFStringGetBytes(a3, v16, 0, 0x5Fu, 0, 0, 0, 0);
  v9 = *(_QWORD *)(a2 + 128);
  v10 = *(_QWORD *)(v9 + 96);
  if (v10)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v10 + 8));
    v11 = *(_QWORD *)(v9 + 96);
    v12 = *(_QWORD *)(v9 + 144);
    if (v11)
      pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8));
  }
  else
  {
    v12 = *(_QWORD *)(v9 + 144);
  }
  if (Length - *(_QWORD *)(a1 + 40) < Bytes)
    CFDataSetLength(*(CFMutableDataRef *)(a1 + 56), Bytes + *(_QWORD *)(a1 + 40));
  MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a1 + 56));
  v17.location = 0;
  v17.length = v7;
  CFStringGetBytes(a3, v17, 0, 0x5Fu, 0, &MutableBytePtr[*(_QWORD *)(a1 + 40)], Bytes, 0);
  v14 = *(_QWORD *)(a1 + 40) + Bytes;
  *(_QWORD *)(a1 + 40) = v14;
  if (v14)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    if (v12)
      v15 = (CoreStreamBase *)(v12 + 16);
    else
      v15 = 0;
    if (CoreStreamBase::_streamInterface_CanWrite(v15))
      _FTPRequestStreamCallBack(a2, v12, 4, *(_QWORD **)(a2 + 128), a1);
  }
}

uint64_t _HandlePrintWorkingDirectory(uint64_t a1, uint64_t a2, char *__s, size_t __n)
{
  char *v8;
  const UInt8 *v9;
  const UInt8 *v10;
  const UInt8 *v11;
  char *v12;
  int v13;
  char *v14;
  int v15;
  const UInt8 *v16;
  const __CFAllocator *v17;

  if ((*(_DWORD *)(a1 + 16) - 200) <= 0x63)
  {
    v8 = (char *)memchr(__s, 34, __n);
    if (v8)
    {
      v9 = (const UInt8 *)(v8 + 1);
      v10 = (const UInt8 *)&__s[__n - 1];
      while (v10 != v9)
      {
        v11 = v10;
        v12 = (char *)(v10 + 1);
        v13 = *v10--;
        if (v13 == 34)
        {
          v15 = *(v12 - 2);
          v14 = v12 - 2;
          if (v15 == 47)
            v16 = (const UInt8 *)v14;
          else
            v16 = v11;
          v17 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
          *(_QWORD *)(a1 + 24) = CFStringCreateWithBytes(v17, v9, v16 - v9, 0x8000100u, 0);
          break;
        }
      }
    }
  }
  *(_DWORD *)(a1 + 20) = 7;
  return _WriteCommand(a1, a2, CFSTR("TYPE I\r\n"));
}

void _HandleType(uint64_t a1, uint64_t a2)
{
  SInt32 v2;
  __int128 v3;

  v2 = *(_DWORD *)(a1 + 16);
  if ((v2 - 300) > 0xFFFFFF9B)
  {
    *(_DWORD *)(a1 + 20) = 8;
    _StartProcess();
  }
  else
  {
    v3 = xmmword_1841E3820;
    DWORD2(v3) = v2;
    _ReportError(a2, (CFStreamError *)&v3);
  }
}

void _HandlePassive(uint64_t a1, _WORD *a2, uint64_t a3)
{
  unsigned int v3;
  int v5;
  CFStreamError *v6;
  int ProtocolFamily;
  unsigned int v10;
  const char *v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  char v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  const char *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  const __CFArray *v25;
  const void *ValueAtIndex;
  const __CFAllocator *v28;
  const __CFAllocator *v29;
  const UInt8 *v30;
  CFIndex v31;
  const __CFData *v32;
  __CFReadStream **v33;
  __CFWriteStream **v34;
  const __CFData *v35;
  _QWORD *v36;
  _QWORD *v37;
  _QWORD *v38;
  uint64_t v39;
  __int128 v40;
  CFStreamClientContext v41;
  _BYTE bytes[28];
  _QWORD v43[2];
  _BYTE v44[252];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v5 = *(_DWORD *)(a1 + 16);
  if ((v5 - 300) <= 0xFFFFFF9B)
  {
    *(_OWORD *)v44 = xmmword_1841E3820;
    *(_DWORD *)&v44[8] = v5;
    v6 = (CFStreamError *)v44;
LABEL_38:
    _ReportError((uint64_t)a2, v6);
    return;
  }
  ProtocolFamily = _GetProtocolFamily(*((_QWORD *)a2 + 16), (uint64_t)v44);
  if (ProtocolFamily == 30)
  {
    *(_OWORD *)bytes = *(_OWORD *)v44;
    *(_OWORD *)&bytes[12] = *(_OWORD *)&v44[12];
    v22 = *(unsigned __int8 *)(a3 + 3);
    v21 = (const char *)(a3 + 3);
    v20 = v22;
    if (!v22)
      goto LABEL_37;
    while ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v20 + 60) & 0x400) == 0)
    {
      v23 = *(unsigned __int8 *)++v21;
      v20 = v23;
      if (!v23)
        goto LABEL_37;
    }
    LODWORD(v41.version) = 0;
    if (sscanf(v21, "%u", &v41) != 1)
      goto LABEL_37;
    v24 = 0;
    *(_WORD *)&bytes[2] = bswap32(LOWORD(v41.version)) >> 16;
  }
  else
  {
    if (ProtocolFamily == 2)
    {
      v12 = *(unsigned __int8 *)(a3 + 3);
      v11 = (const char *)(a3 + 3);
      v10 = v12;
      v43[0] = 0;
      v43[1] = 0;
      if (v12)
      {
        v13 = 0;
        v14 = 0;
        v15 = 0;
        v16 = MEMORY[0x1E0C80978];
        while (1)
        {
          if ((*(_DWORD *)(v16 + 4 * v10 + 60) & 0x400) != 0)
          {
            LODWORD(v41.version) = 0;
            if (sscanf(v11, "%u", &v41) != 1)
              goto LABEL_37;
            v17 = 8 * v13;
            if (v13 > 3)
            {
              v14 |= LODWORD(v41.version) << (40 - v17);
              if (v13 != 4)
              {
                v3 = bswap32(v15);
                HIDWORD(v43[0]) = v3;
                LOWORD(v43[0]) = 528;
                WORD1(v43[0]) = bswap32(v14) >> 16;
                v24 = 1;
                goto LABEL_22;
              }
            }
            else
            {
              v15 |= LODWORD(v41.version) << (24 - v17);
            }
            --v11;
            do
              v18 = *(unsigned __int8 *)++v11;
            while ((*(_DWORD *)(v16 + 4 * v18 + 60) & 0x400) != 0);
            ++v13;
          }
          v19 = *(unsigned __int8 *)++v11;
          v10 = v19;
          if (!v19)
            goto LABEL_37;
        }
      }
      goto LABEL_37;
    }
    v24 = 0;
  }
LABEL_22:
  v25 = (const __CFArray *)*((_QWORD *)a2 + 14);
  if (!v25
    || (ValueAtIndex = CFArrayGetValueAtIndex(v25, *((_QWORD *)a2 + 15)),
        CFEqual(ValueAtIndex, (CFTypeRef)*MEMORY[0x1E0C9B0D0]))
    || CFEqual(ValueAtIndex, &unk_1E152A808))
  {
    if (v24)
    {
      if (*(_DWORD *)&v44[4] == v3)
        goto LABEL_33;
LABEL_37:
      *(_OWORD *)&v41.version = xmmword_1841E3A20;
      v6 = (CFStreamError *)&v41;
      goto LABEL_38;
    }
    if (*(_QWORD *)&v44[8] != *(_QWORD *)&bytes[8] || *(_QWORD *)&v44[16] != *(_QWORD *)&bytes[16])
      goto LABEL_37;
  }
LABEL_33:
  v28 = CFGetAllocator(*((CFTypeRef *)a2 + 11));
  v29 = v28;
  v41.version = 0;
  v41.info = a2;
  memset(&v41.retain, 0, 24);
  if (v24)
  {
    v30 = (const UInt8 *)v43;
    v31 = 16;
  }
  else
  {
    v30 = bytes;
    v31 = 28;
  }
  v35 = CFDataCreate(v28, v30, v31);
  if (!v35
    || ((v36 = a2 + 12, (*a2 & 0x80) != 0) ? (v37 = 0, v38 = a2 + 12) : (v37 = a2 + 12, v38 = 0),
        _CoreSocketStreamCreateWithSignature(v29, v35, v37, v38, v32, v33, v34),
        CFRelease(v35),
        !*v36))
  {
    v40 = xmmword_1841E3A80;
    v6 = (CFStreamError *)&v40;
    goto LABEL_38;
  }
  v39 = *v36 + 16;
  if ((*a2 & 0x80) != 0)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    CoreWriteStream::setClient(v39, -1, (uint64_t)_DataStreamCallBack, &v41);
  }
  else
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    CoreReadStream::setClient(v39, -1, (uint64_t)_DataStreamCallBack, &v41);
  }
  _CFTypeScheduleOnMultipleRunLoops(*((void **)a2 + 3), *((const __CFArray **)a2 + 10));
  CFDictionaryApplyFunction(*((CFDictionaryRef *)a2 + 11), (CFDictionaryApplierFunction)_StreamPropertyApplier, *((void **)a2 + 3));
  _StartTransfer(a1, (uint64_t)a2);
}

void _HandlePort(uint64_t a1, uint64_t a2)
{
  SInt32 v2;
  __int128 v3;

  v2 = *(_DWORD *)(a1 + 16);
  if ((v2 - 300) > 0xFFFFFF9B)
  {
    _StartTransfer(a1, a2);
  }
  else
  {
    v3 = xmmword_1841E3820;
    DWORD2(v3) = v2;
    _ReportError(a2, (CFStreamError *)&v3);
  }
}

void _HandleSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const __CFAllocator *v8;
  int v9;
  CFStringRef PathComponent;
  const void *v11;
  CFStringRef v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  const __CFString *PathForContext;
  const __CFString *v17;
  uint64_t v18;
  char *__endptr[2];
  unint64_t valuePtr;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  v8 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
  v9 = *(_DWORD *)(a1 + 16);
  if ((v9 - 500) <= 0x63)
  {
    PathComponent = CFURLCopyLastPathComponent(*(CFURLRef *)(a2 + 8));
    v11 = *(const void **)(a2 + 64);
    if (v11)
    {
      CFRelease(v11);
      *(_QWORD *)(a2 + 64) = 0;
    }
    *(_DWORD *)(a1 + 20) = 12;
    v12 = CFStringCreateWithFormat(v8, 0, CFSTR("STAT %@\r\n"), PathComponent);
    if (PathComponent)
      CFRelease(PathComponent);
    goto LABEL_27;
  }
  if (v9 == 213)
  {
    if (a4 < 1)
    {
      v13 = 0;
    }
    else
    {
      v13 = 0;
      while ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * *(unsigned __int8 *)(a3 + v13) + 60) & 0x400) != 0)
      {
        if (a4 == ++v13)
          goto LABEL_25;
      }
    }
    if (v13 < a4)
    {
      while ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * *(unsigned __int8 *)(a3 + v13) + 60) & 0x400) == 0)
      {
        if (a4 == ++v13)
          goto LABEL_25;
      }
      v14 = (const char *)(a3 + v13);
      __endptr[0] = 0;
      v15 = strtouq(v14, __endptr, 0);
      valuePtr = v15;
      if (v15 == -1)
      {
        if (*__error())
          goto LABEL_25;
      }
      else if (!v15 && __endptr[0] == v14)
      {
        goto LABEL_25;
      }
      keys[0] = CFSTR("kCFFTPResourceSize");
      values = CFNumberCreate(v8, kCFNumberLongLongType, &valuePtr);
      if (values)
      {
        *(_QWORD *)(a2 + 64) = CFDictionaryCreate(v8, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        if (values)
          CFRelease(values);
      }
    }
  }
LABEL_25:
  if (*(_QWORD *)(a2 + 72))
  {
    v12 = CFStringCreateWithFormat(v8, 0, CFSTR("REST %lld\r\n"), *(_QWORD *)(a2 + 72));
    *(_DWORD *)(a1 + 20) = 14;
  }
  else
  {
    PathForContext = _CreatePathForContext(v8, a1, *(__CFURL **)(a2 + 8));
    if (!PathForContext)
    {
      *(_OWORD *)__endptr = xmmword_1841E3A40;
      _ReportError(a2, (CFStreamError *)__endptr);
      return;
    }
    v17 = PathForContext;
    v12 = CFStringCreateWithFormat(v8, 0, CFSTR("RETR %@\r\n"), PathForContext);
    *(_DWORD *)(a1 + 20) = 15;
    *(_WORD *)a2 &= ~0x800u;
    CFRelease(v17);
    v18 = *(_QWORD *)(a2 + 24);
    if (v18)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      CoreStreamBase::_streamInterface_Open((CoreStreamBase *)(v18 + 16));
    }
  }
LABEL_27:
  _WriteCommand(a1, a2, v12);
  if (v12)
    CFRelease(v12);
}

CFIndex CFFTPCreateParsedResourceListing(CFAllocatorRef alloc, const UInt8 *buffer, CFIndex bufferLength, CFDictionaryRef *parsed)
{
  CFIndex v4;
  CFIndex v5;
  const unsigned __int8 *v6;
  uint64_t v7;
  CFIndex i;
  uint64_t Line;
  unsigned __int8 *v10;
  uint64_t v11;
  unsigned __int8 *v13;
  unint64_t v14;
  int64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  const UInt8 *v19;
  unsigned int v20;
  int v21;
  int v22;
  CFIndex v23;
  int v24;
  int v25;
  unint64_t v26;
  char v27;
  int v28;
  int v29;
  int v30;
  unsigned int v31;
  unsigned __int8 *v32;
  int v33;
  unsigned int v34;
  int64_t v35;
  uint64_t v36;
  __int16 *v37;
  uint64_t v39;
  unsigned __int8 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned __int8 v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  unsigned __int8 v48;
  int64_t v49;
  uint64_t v50;
  char v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  const __CFTimeZone *v58;
  double Current;
  CFAbsoluteTime v60;
  CFAbsoluteTime AbsoluteTime;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unsigned int v66;
  CFAbsoluteTime v67;
  CFDateRef v68;
  char *v69;
  signed int v70;
  int v71;
  BOOL v72;
  char v73;
  int v74;
  UInt8 *v75;
  const UInt8 *v76;
  const UInt8 *v77;
  BOOL v78;
  CFStringRef v79;
  const __CFString *v80;
  int v81;
  int Size;
  CFDateRef v83;
  const UInt8 *v85;
  _WORD *v86;
  const UInt8 *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  const __CFString *v91;
  const __CFString *v92;
  CFIndex location;
  CFIndex v94;
  CFStringRef Copy;
  CFStringRef v96;
  CFStringRef v97;
  UInt8 *v98;
  UInt8 *v99;
  uint64_t v100;
  int v101;
  unint64_t v102;
  char *v103;
  BOOL v104;
  uint64_t v105;
  int v106;
  CFStringRef v107;
  const UInt8 *v108;
  uint64_t v109;
  int v110;
  CFStringRef v111;
  CFNumberRef v112;
  CFNumberRef v113;
  int v114;
  const void *v115;
  unsigned int year;
  int v117;
  uint64_t v118;
  unsigned __int8 v119;
  unsigned __int8 v120;
  const UInt8 *v121;
  char cf;
  char cfb;
  CFDateRef cfa;
  int v126;
  unsigned __int8 *v127;
  CFIndex v128;
  const unsigned __int8 *v131;
  void *__s;
  UInt8 *__sa;
  unint64_t v134;
  int valuePtr;
  int v136;
  unsigned __int8 *v137;
  unsigned __int8 *v138;
  void *values[2];
  __int128 v140;
  __int128 v141;
  __int128 v142;
  void *keys[2];
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  uint64_t v155;
  uint64_t v156;
  CFGregorianDate v157;
  CFGregorianDate v158;
  CFRange v159;

  v4 = 0;
  v156 = *MEMORY[0x1E0C80C00];
  *parsed = 0;
  if (!buffer)
    return v4;
  v5 = bufferLength;
  if (!bufferLength)
    return v4;
  v6 = buffer;
  v4 = 0;
  v7 = MEMORY[0x1E0C80978];
  for (i = bufferLength; ; i -= v11)
  {
    v137 = 0;
    v138 = 0;
    Line = _FindLine(v6, i, (const unsigned __int8 **)&v138, (const unsigned __int8 **)&v137);
    v4 += Line;
    v10 = v138;
    if (!v138)
      return v4;
    v11 = Line;
    if (*(_DWORD *)v138 != 1635020660 || *((_WORD *)v138 + 2) != 8300)
      break;
LABEL_172:
    if (v4 >= v5)
      return v4;
    v6 += v11;
  }
  __s = (void *)i;
  v155 = 0;
  v153 = 0u;
  v154 = 0u;
  v151 = 0u;
  v152 = 0u;
  v149 = 0u;
  v150 = 0u;
  v147 = 0u;
  v148 = 0u;
  v13 = v137;
  if (v138 >= v137)
    goto LABEL_171;
  v14 = 0;
  do
  {
    if (v10 >= v13)
    {
      v18 = v14;
      break;
    }
    v15 = v13 - v10;
    while (1)
    {
      v16 = *v10;
      if ((char)*v10 < 0)
        break;
      if ((*(_DWORD *)(v7 + 4 * v16 + 60) & 0x4000) == 0)
        goto LABEL_19;
LABEL_17:
      ++v10;
      if (!--v15)
      {
        v18 = v14;
        v10 = v13;
        goto LABEL_28;
      }
    }
    if (__maskrune(v16, 0x4000uLL))
      goto LABEL_17;
LABEL_19:
    *((_QWORD *)&v147 + v14) = v10;
    while (v10 < v13)
    {
      v17 = *v10;
      if ((char)*v10 < 0)
      {
        if (__maskrune(v17, 0x4000uLL))
          break;
      }
      else if ((*(_DWORD *)(v7 + 4 * v17 + 60) & 0x4000) != 0)
      {
        break;
      }
      ++v10;
    }
    v18 = v14 + 1;
    if (v14 > 0xE)
      break;
    ++v14;
  }
  while (v10 < v13);
LABEL_28:
  v138 = v10;
  if (!v18)
  {
LABEL_171:
    i = (CFIndex)__s;
    goto LABEL_172;
  }
  v131 = v6;
  valuePtr = 0;
  v19 = (const UInt8 *)v147;
  v20 = *(unsigned __int8 *)v147;
  if (v20 <= 0x63)
  {
    switch(v20)
    {
      case '-':
        v21 = 0;
        v22 = 8;
        break;
      case 'b':
        v21 = 0;
        v22 = 6;
        break;
      case 'c':
        v21 = 0;
        v22 = 2;
        break;
      default:
        goto LABEL_145;
    }
    goto LABEL_44;
  }
  if (*(unsigned __int8 *)v147 > 0x6Fu)
  {
    if (v20 == 112)
    {
      v21 = 0;
      v136 = 1;
      goto LABEL_45;
    }
    if (v20 != 115)
      goto LABEL_145;
    v21 = 0;
    v22 = 12;
LABEL_44:
    v136 = v22;
    goto LABEL_45;
  }
  if (v20 == 100)
  {
    v21 = 0;
    v136 = 4;
  }
  else
  {
    if (v20 == 108)
    {
      v136 = 10;
      v21 = 1;
      goto LABEL_45;
    }
LABEL_145:
    v21 = 0;
    v136 = 0;
  }
LABEL_45:
  v23 = (CFIndex)&v13[-v147];
  if ((uint64_t)&v13[-v147] >= 11)
  {
    v25 = 0;
    v26 = 0;
    v27 = 6;
    while (1)
    {
      v28 = *(unsigned __int8 *)(v147 + v26 + 1);
      if (v28 == 45)
      {
        v29 = 1;
      }
      else if (v28 == 114)
      {
        v29 = 1;
        v25 |= 1 << (v27 + 2);
        valuePtr = v25;
      }
      else
      {
        v29 = 0;
      }
      v30 = *(unsigned __int8 *)(v147 + v26 + 2);
      if (v30 != 45)
      {
        if (v30 == 119)
        {
          v25 |= 1 << (v27 + 1);
          valuePtr = v25;
        }
        else
        {
          v29 = 0;
        }
      }
      v24 = 0;
      v31 = *(unsigned __int8 *)(v147 + v26 + 3);
      if (v31 <= 0x72)
        break;
      if (v31 == 115)
      {
        v25 |= 1 << v27;
        valuePtr = v25;
LABEL_67:
        if (v26 > 2)
        {
          if ((v26 - 3) > 2)
            goto LABEL_75;
          v25 |= 0x400u;
        }
        else
        {
          v25 |= 0x800u;
        }
        goto LABEL_74;
      }
      if (v31 == 116)
      {
        v25 |= 1 << v27;
        valuePtr = v25;
LABEL_70:
        if ((v26 - 6) > 2)
          goto LABEL_75;
        v25 |= 0x200u;
        goto LABEL_74;
      }
      if (v31 != 120)
        goto LABEL_79;
      v25 |= 1 << v27;
LABEL_74:
      valuePtr = v25;
LABEL_75:
      if (v26 > 5)
      {
        v24 = v29;
        goto LABEL_79;
      }
      v26 += 3;
      v27 -= 3;
      v24 = v29;
      if (!v29)
        goto LABEL_79;
    }
    if (v31 == 45)
      goto LABEL_75;
    if (v31 != 83)
    {
      if (v31 != 84)
        goto LABEL_79;
      goto LABEL_70;
    }
    goto LABEL_67;
  }
  v24 = 0;
LABEL_79:
  v32 = (unsigned __int8 *)*((_QWORD *)&v148 + 1);
  if (!*((_QWORD *)&v148 + 1) || !(_QWORD)v149)
  {
LABEL_165:
    if (!v24)
    {
      keys[0] = CFSTR("kCFFTPResourceName");
      v79 = CFStringCreateWithBytes(alloc, v19, v23, 0, 0);
      values[0] = (void *)v79;
      if (v79)
      {
        v80 = v79;
        if (!CFStringHasPrefix(v79, CFSTR("<")) || !CFStringHasSuffix(v80, CFSTR(">")))
        {
          *parsed = CFDictionaryCreate(alloc, (const void **)keys, (const void **)values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          v83 = (CFDateRef)values[0];
          if (values[0])
            goto LABEL_182;
          return v4;
        }
        CFRelease(v80);
      }
    }
    v5 = bufferLength;
    v6 = v131;
    goto LABEL_171;
  }
  v127 = &v13[-v147];
  v128 = v4;
  v126 = v21;
  v134 = 0;
  v33 = 3;
  v34 = 2;
  while (2)
  {
    v35 = v13 - v32;
    if (v13 - v32 < 9)
      goto LABEL_140;
    v36 = 0;
    v37 = &_CFFTPGetDateTimeFunc(__CFAllocator const*,unsigned char const*,long,__CFDate const**)::kMonthStrs;
    while (*(unsigned __int16 *)v32 != (unsigned __int16)*v37 || v32[2] != *((unsigned __int8 *)v37 + 2))
    {
      ++v36;
      v37 = (__int16 *)((char *)v37 + 3);
      if (v36 == 12)
        goto LABEL_140;
    }
    v39 = v32[3];
    if ((char)v32[3] < 0)
    {
      if (!__maskrune(v39, 0x4000uLL))
        goto LABEL_140;
    }
    else if ((*(_DWORD *)(v7 + 4 * v39 + 60) & 0x4000) == 0)
    {
      goto LABEL_140;
    }
    v40 = v36 + 1;
    v41 = 4;
    while (1)
    {
      v42 = v32[v41];
      if ((*(_DWORD *)(v7 + 4 * v42 + 60) & 0x400) != 0)
        break;
      if (v35 == ++v41)
        goto LABEL_140;
    }
    if (v41 == v35)
      goto LABEL_140;
    v43 = v41 + 1;
    if (v41 + 1 == v35)
      goto LABEL_140;
    v44 = v42 - 48;
    v45 = v32[v43];
    v46 = *(_DWORD *)(v7 + 4 * v45 + 60);
    v47 = v41 + 2;
    v48 = v45 + 10 * v44 - 48;
    if ((v46 & 0x400) != 0)
    {
      v44 = v48;
      v49 = v47;
    }
    else
    {
      v49 = v43;
    }
    if (v49 == v35)
      goto LABEL_140;
    v50 = v32[v49];
    v120 = v40;
    v119 = v44;
    if ((char)v32[v49] < 0)
    {
      if (!__maskrune(v50, 0x4000uLL))
        goto LABEL_140;
    }
    else if ((*(_DWORD *)(v7 + 4 * v50 + 60) & 0x4000) == 0)
    {
      goto LABEL_140;
    }
    if (v49 < v35)
    {
      while ((*(_DWORD *)(v7 + 4 * v32[v49] + 60) & 0x400) == 0)
      {
        if (v35 == ++v49)
        {
          v51 = 0;
          v118 = 0;
          v117 = 0;
LABEL_117:
          v49 = v13 - v32;
          goto LABEL_132;
        }
      }
    }
    if (v49 >= v35)
    {
      v117 = 0;
LABEL_125:
      v54 = 0;
      v51 = 0;
      goto LABEL_126;
    }
    v52 = 0;
    while (1)
    {
      v53 = v32[v49];
      if ((*(_DWORD *)(v7 + 4 * v53 + 60) & 0x400) == 0)
        break;
      ++v49;
      v52 = v53 + 10 * v52 - 48;
      if (v35 == v49)
      {
        v117 = v52;
        v51 = 0;
        v118 = 0;
        goto LABEL_117;
      }
    }
    v117 = v52;
    if ((_DWORD)v53 != 58)
      goto LABEL_125;
    if (++v49 >= v35)
    {
      v54 = 0;
    }
    else
    {
      v54 = 0;
      while (1)
      {
        v55 = v32[v49];
        if ((*(_DWORD *)(v7 + 4 * v55 + 60) & 0x400) == 0)
          break;
        v54 = (v55 + 10 * v54 - 48);
        if (++v49 >= v35)
        {
          v118 = v54;
          v49 = v13 - v32;
          v51 = 1;
          goto LABEL_132;
        }
      }
    }
    v51 = 1;
LABEL_126:
    cf = v51;
    v118 = v54;
    if (v49 == v35)
    {
      v49 = v13 - v32;
      break;
    }
    v56 = v32[v49];
    if ((char)v32[v49] < 0)
      v57 = __maskrune(v56, 0x4000uLL);
    else
      v57 = *(_DWORD *)(v7 + 4 * v56 + 60) & 0x4000;
    v51 = cf;
    if (!v57)
    {
LABEL_140:
      v32 = (unsigned __int8 *)*((_QWORD *)&v147 + ++v33);
      ++v34;
      if (!v32)
        goto LABEL_164;
      continue;
    }
    break;
  }
LABEL_132:
  cfb = v51;
  v58 = CFTimeZoneCopyDefault();
  Current = CFAbsoluteTimeGetCurrent();
  CFAbsoluteTimeGetGregorianDate(Current, v58);
  if ((cfb & 1) != 0)
  {
    v60 = Current + 86400.0;
    year = CFAbsoluteTimeGetGregorianDate(v60, v58).year;
    *(_QWORD *)&v157.year = year | (unint64_t)(v118 << 56) | ((unint64_t)v119 << 40) & 0xFF00FFFFFFFFFFFFLL | ((unint64_t)v120 << 32) & 0xFF00FFFFFFFFFFFFLL | ((unint64_t)v117 << 48);
    v157.second = 0.0;
    AbsoluteTime = CFGregorianDateGetAbsoluteTime(v157, v58);
    v63 = (unint64_t)v119 << 40;
    v62 = (unint64_t)v120 << 32;
    v64 = (unint64_t)v117 << 48;
    v65 = v118;
    v66 = year - (AbsoluteTime > v60);
  }
  else
  {
    v64 = 0;
    v65 = 0;
    v66 = v117 + 1900;
    if (v117 >= 100)
      v66 = v117;
    v63 = (unint64_t)v119 << 40;
    v62 = (unint64_t)v120 << 32;
  }
  *(_QWORD *)&v158.year = v63 | v62 | v64 | v66 | (v65 << 56);
  v158.second = 0.0;
  v67 = CFGregorianDateGetAbsoluteTime(v158, v58);
  if (v58)
    CFRelease(v58);
  v68 = CFDateCreate(alloc, v67);
  if (!v68)
    goto LABEL_140;
  cfa = v68;
  v69 = (char *)&v32[v49];
  v70 = v34;
  do
  {
    v71 = v70;
    v72 = v24 != 0;
    if (v71)
      v72 = 0;
    v73 = v71 < 0 || v72;
    if ((v73 & 1) != 0)
      goto LABEL_157;
    v74 = _ReadSize(*((char **)&v147 + v71), &v134);
    v70 = v71 - 1;
  }
  while (!v74);
  if (v24 && v71 == 1)
  {
LABEL_157:
    v75 = 0;
    v76 = 0;
    goto LABEL_158;
  }
  v76 = (const UInt8 *)*((_QWORD *)&v147 + v70);
  v81 = v71 - 2;
  if (!v24 || v81)
  {
    if (!v24
      || v81 != 1
      || (v121 = (const UInt8 *)*((_QWORD *)&v147 + v70),
          Size = _ReadSize(*((char **)&v147 + 1), (unint64_t *)keys),
          v76 = v121,
          v75 = (UInt8 *)v121,
          !Size))
    {
      v75 = (UInt8 *)*((_QWORD *)&v147 + v81);
    }
  }
  else
  {
    v75 = (UInt8 *)*((_QWORD *)&v147 + v70);
  }
  do
  {
LABEL_158:
    v77 = (const UInt8 *)*((_QWORD *)&v147 + ++v34);
    if (v77)
      v78 = v69 > (char *)v77;
    else
      v78 = 0;
  }
  while (v78);
  if (!v77)
  {
    CFRelease(cfa);
LABEL_164:
    v23 = (CFIndex)v127;
    v4 = v128;
    goto LABEL_165;
  }
  v145 = 0u;
  v146 = 0u;
  *(_OWORD *)keys = 0u;
  v144 = 0u;
  v141 = 0u;
  v142 = 0u;
  *(_OWORD *)values = 0u;
  v140 = 0u;
  __sa = v75;
  v85 = v76;
  if (v126)
  {
    while (1)
    {
      v86 = (_WORD *)*((_QWORD *)&v147 + v34);
      if (!v86)
        break;
      ++v34;
      if (*v86 == 15917)
      {
        v87 = (const UInt8 *)*((_QWORD *)&v147 + v34);
        goto LABEL_189;
      }
    }
  }
  v87 = 0;
LABEL_189:
  if (v24)
  {
    keys[0] = CFSTR("kCFFTPResourceMode");
    values[0] = CFNumberCreate(alloc, kCFNumberSInt32Type, &valuePtr);
    LODWORD(v88) = values[0] != 0;
  }
  else
  {
    LODWORD(v88) = 0;
  }
  v89 = v88;
  *(_QWORD *)((unint64_t)keys | (8 * v88)) = CFSTR("kCFFTPResourceName");
  if (v87)
    v90 = *((_QWORD *)&v147 + v34 - 1) - 1;
  else
    v90 = (uint64_t)v13;
  v91 = CFStringCreateWithBytes(alloc, v77, v90 - (_QWORD)v77, 0, 0);
  *(_QWORD *)((unint64_t)values | (8 * v88)) = v91;
  if (v91)
  {
    v92 = v91;
    if (CFStringHasPrefix(v91, CFSTR("<"))
      && CFStringHasSuffix(v92, CFSTR(">"))
      && (location = CFStringFind(v92, CFSTR(">"), 0).location,
          v94 = CFStringFind(v92, CFSTR("<"), 4uLL).location,
          location < v94))
    {
      v159.length = v94 + ~location;
      v159.location = location + 1;
      Copy = CFStringCreateWithSubstring(alloc, v92, v159);
    }
    else
    {
      Copy = CFStringCreateCopy(alloc, v92);
    }
    v96 = Copy;
    if (Copy)
    {
      CFRelease(v92);
      *(_QWORD *)((unint64_t)values | (8 * v88)) = v96;
    }
    v89 = (v88 + 1);
    LODWORD(v88) = v88 + 1;
  }
  keys[v89] = CFSTR("kCFFTPResourceLink");
  if (v87)
    v97 = CFStringCreateWithBytes(alloc, v87, v13 - v87, 0, 0);
  else
    v97 = CFStringCreateWithCString(alloc, "", 0x8000100u);
  values[v89] = (void *)v97;
  if (v97)
    LODWORD(v88) = v88 + 1;
  if ((v73 & 1) == 0)
  {
    if (v85 && v85 == __sa)
    {
      v99 = __sa - 1;
      do
      {
        v100 = v99[1];
        if ((char)v99[1] < 0)
          v101 = __maskrune(v100, 0x4000uLL);
        else
          v101 = *(_DWORD *)(v7 + 4 * v100 + 60) & 0x4000;
        ++v99;
      }
      while (!v101);
      v102 = 0;
      do
      {
        v103 = (char *)memchr(__sa, byte_1841E3AD8[v102], v99 - __sa);
        if (v103)
          v104 = 1;
        else
          v104 = v102 >= 3;
        ++v102;
      }
      while (!v104);
      v98 = (UInt8 *)v103;
      if (v103)
        v85 = (const UInt8 *)(v103 + 1);
      else
        v85 = __sa;
    }
    else
    {
      v98 = 0;
    }
    if (__sa)
    {
      if (!v98)
      {
        v98 = __sa - 1;
        do
        {
          v105 = v98[1];
          if ((char)v98[1] < 0)
            v106 = __maskrune(v105, 0x4000uLL);
          else
            v106 = *(_DWORD *)(v7 + 4 * v105 + 60) & 0x4000;
          ++v98;
        }
        while (!v106);
      }
      keys[v88] = CFSTR("kCFFTPResourceOwner");
      v107 = CFStringCreateWithBytes(alloc, __sa, v98 - __sa, 0, 0);
      values[v88] = (void *)v107;
      if (v107)
        LODWORD(v88) = v88 + 1;
    }
    if (v85)
    {
      v108 = v85 - 1;
      do
      {
        v109 = v108[1];
        if ((char)v108[1] < 0)
          v110 = __maskrune(v109, 0x4000uLL);
        else
          v110 = *(_DWORD *)(v7 + 4 * v109 + 60) & 0x4000;
        ++v108;
      }
      while (!v110);
      keys[v88] = CFSTR("kCFFTPResourceGroup");
      v111 = CFStringCreateWithBytes(alloc, v85, v108 - v85, 0, 0);
      values[v88] = (void *)v111;
      if (v111)
        LODWORD(v88) = v88 + 1;
    }
    keys[v88] = CFSTR("kCFFTPResourceSize");
    v112 = CFNumberCreate(alloc, kCFNumberLongLongType, &v134);
    values[v88] = v112;
    if (v112)
      LODWORD(v88) = v88 + 1;
  }
  v4 = v128;
  keys[v88] = CFSTR("kCFFTPResourceType");
  v113 = CFNumberCreate(alloc, kCFNumberIntType, &v136);
  values[v88] = v113;
  if (v113)
    v114 = v88 + 1;
  else
    v114 = v88;
  keys[v114] = CFSTR("kCFFTPResourceModDate");
  if (v113)
    v88 = v88 + 1;
  else
    v88 = v88;
  values[v114] = (void *)CFRetain(cfa);
  *parsed = CFDictionaryCreate(alloc, (const void **)keys, (const void **)values, (v114 + 1), MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  do
  {
    v115 = values[v88];
    if (v115)
      CFRelease(v115);
    v78 = v88-- <= 0;
  }
  while (!v78);
  v83 = cfa;
LABEL_182:
  CFRelease(v83);
  return v4;
}

const __CFString *_CreatePathForContext(const __CFAllocator *a1, uint64_t a2, __CFURL *a3)
{
  const __CFString *v5;
  const __CFString *v6;
  CFStringRef v7;
  CFStringRef v8;
  CFRange v10;

  v5 = _CFURLCopyPathReplacingPercentEscapes(a3);
  if (!v5)
    return 0;
  v6 = v5;
  if (!CFStringGetLength(v5))
  {
    CFRelease(v6);
    v6 = (const __CFString *)CFRetain(CFSTR("/"));
  }
  if (CFStringHasPrefix(v6, CFSTR("//")))
  {
    v10.length = CFStringGetLength(v6) - 1;
    v10.location = 1;
    v7 = CFStringCreateWithSubstring(a1, v6, v10);
    if (!v7)
      return v6;
  }
  else
  {
    if (!*(_QWORD *)(a2 + 24))
      return v6;
    v7 = CFStringCreateWithFormat(a1, 0, CFSTR("%@%@"), *(_QWORD *)(a2 + 24), v6);
    if (!v7)
      return v6;
  }
  v8 = v7;
  if (v6)
    CFRelease(v6);
  return v8;
}

void _HandleRestart(uint64_t a1, uint64_t a2)
{
  SInt32 v3;
  const __CFAllocator *v5;
  const __CFString *PathForContext;
  const __CFString *v7;
  CFStringRef v8;
  uint64_t v9;
  __int128 v10;

  v3 = *(_DWORD *)(a1 + 16);
  if ((v3 - 400) <= 0xFFFFFF9B)
  {
    v10 = xmmword_1841E3820;
    DWORD2(v10) = v3;
LABEL_11:
    _ReportError(a2, (CFStreamError *)&v10);
    return;
  }
  v5 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
  PathForContext = _CreatePathForContext(v5, a1, *(__CFURL **)(a2 + 8));
  if (!PathForContext)
  {
    v10 = xmmword_1841E3A40;
    goto LABEL_11;
  }
  v7 = PathForContext;
  v8 = CFStringCreateWithFormat(v5, 0, CFSTR("RETR %@\r\n"), PathForContext);
  CFRelease(v7);
  *(_DWORD *)(a1 + 20) = 15;
  *(_WORD *)a2 &= ~0x800u;
  v9 = *(_QWORD *)(a2 + 24);
  if (v9)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    CoreStreamBase::_streamInterface_Open((CoreStreamBase *)(v9 + 16));
  }
  _WriteCommand(a1, a2, v8);
  if (v8)
    CFRelease(v8);
}

void _HandleRetrieve(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  __int128 v3;

  v2 = *(_DWORD *)(a1 + 16);
  if (v2 >= 0xC8)
  {
    if ((*(_BYTE *)a1 & 2) != 0)
    {
      *(_DWORD *)(a1 + 20) = 8;
      _StartProcess();
    }
    else if (v2 < 0x12C)
    {
      _ConnectionComplete(a1, a2);
    }
    else
    {
      v3 = xmmword_1841E3820;
      DWORD2(v3) = v2;
      _ReportError(a2, (CFStreamError *)&v3);
    }
  }
}

void _HandleChangeDirectory(char *a1, uint64_t a2)
{
  char v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  CFStreamError *p_context;
  const __CFAllocator *v9;
  CFStringRef PathComponent;
  CFStringRef v11;
  CFStringRef v12;
  int v13;
  const __CFString *v14;
  int v15;
  int IsRoot;
  uint64_t v17;
  CoreStreamBase *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int ProtocolFamily;
  const __CFString *v24;
  uint64_t v25;
  const __CFData *v26;
  const __CFData *v27;
  int *BytePtr;
  __CFSocket *v29;
  CFSocketNativeHandle Native;
  CFIndex v31;
  const __CFData *v32;
  CFRunLoopSourceRef RunLoopSource;
  CFRunLoopSourceRef v34;
  const __CFData *v35;
  const UInt8 *v36;
  int v37;
  CFStringRef v38;
  CFStringRef v39;
  CFSocketContext context;
  socklen_t v41;
  int v42;
  sockaddr v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  _BYTE v57[31];
  uint64_t v58;
  CFStreamError v59;

  v58 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = *((_DWORD *)a1 + 4);
  if ((*a1 & 8) == 0 || v5 != 421)
  {
    if ((v5 - 300) <= 0xFFFFFF9B)
    {
      v43 = (sockaddr)xmmword_1841E3820;
      *(_DWORD *)&v43.sa_data[6] = v5;
      *a1 = v4 & 0xF7;
LABEL_10:
      p_context = (CFStreamError *)&v43;
LABEL_11:
      _ReportError(a2, p_context);
      return;
    }
    v9 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
    *a1 &= ~8u;
    if ((*(_BYTE *)a2 & 0x80) == 0)
    {
LABEL_37:
      if (*((_DWORD *)a1 + 5) != 9)
        return;
      if ((*(_WORD *)a2 & 1) != 0)
      {
        ProtocolFamily = _GetProtocolFamily(*(_QWORD *)(a2 + 128), (uint64_t)&v43);
        *((_DWORD *)a1 + 5) = 10;
        if (ProtocolFamily == 30)
        {
          v24 = CFSTR("EPSV\r\n");
        }
        else
        {
          if (ProtocolFamily != 2)
          {
            *(_OWORD *)&context.version = xmmword_1841E3840;
            p_context = (CFStreamError *)&context;
            goto LABEL_11;
          }
          v24 = CFSTR("PASV\r\n");
        }
        _WriteCommand(a1, a2, v24);
        return;
      }
      v41 = 255;
      v42 = 1;
      context.version = 0;
      context.info = (void *)a2;
      memset(&context.retain, 0, 24);
      v19 = *(_QWORD *)(a2 + 128);
      v20 = *(_QWORD *)(v19 + 96);
      if (v20)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v20 + 8));
        v21 = *(_QWORD *)(v19 + 96);
        v22 = *(_QWORD *)(v19 + 144);
        if (v21)
          pthread_mutex_unlock((pthread_mutex_t *)(v21 + 8));
      }
      else
      {
        v22 = *(_QWORD *)(v19 + 144);
      }
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      if (v22)
        v25 = v22 + 16;
      else
        v25 = 0;
      ++*(_QWORD *)(v25 + 80);
      v26 = (const __CFData *)(*(uint64_t (**)(_QWORD, void *))(**(_QWORD **)(v25 + 24) + 40))(*(_QWORD *)(v25 + 24), &unk_1EDCFBDA8);
      --*(_QWORD *)(v25 + 80);
      if (!v26)
        goto LABEL_54;
      v27 = v26;
      v56 = 0u;
      memset(v57, 0, sizeof(v57));
      v54 = 0u;
      v55 = 0u;
      v52 = 0u;
      v53 = 0u;
      v50 = 0u;
      v51 = 0u;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v44 = 0u;
      v45 = 0u;
      v43 = (sockaddr)0;
      BytePtr = (int *)CFDataGetBytePtr(v26);
      if (getsockname(*BytePtr, &v43, &v41))
        goto LABEL_53;
      CFRelease(v27);
      v29 = CFSocketCreate(v9, v43.sa_family, 1, 6, 2uLL, (CFSocketCallBack)_SocketCallBack, &context);
      *(_QWORD *)(a2 + 56) = v29;
      if (v29)
      {
        Native = CFSocketGetNative(v29);
        setsockopt(Native, 0xFFFF, 4, &v42, 4u);
        v31 = v43.sa_family == 2 ? 16 : 28;
        *(_WORD *)v43.sa_data = 0;
        v32 = CFDataCreateWithBytesNoCopy(v9, &v43.sa_len, v31, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
        if (v32)
        {
          v27 = v32;
          if (CFSocketSetAddress(*(CFSocketRef *)(a2 + 56), v32))
          {
LABEL_53:
            CFRelease(v27);
            goto LABEL_54;
          }
          CFRelease(v27);
          if (!*(_QWORD *)(a2 + 80))
          {
LABEL_69:
            v35 = CFSocketCopyAddress(*(CFSocketRef *)(a2 + 56));
            v36 = CFDataGetBytePtr(v35);
            v37 = v36[1];
            if (v37 == 30)
            {
              v38 = CFStringCreateWithFormat(v9, 0, CFSTR("EPRT |2|%x:%x:%x:%x:%x:%x:%x:%x|%u|\r\n"), bswap32(*((unsigned __int16 *)v36 + 4)) >> 16, bswap32(*((unsigned __int16 *)v36 + 5)) >> 16, bswap32(*((unsigned __int16 *)v36 + 6)) >> 16, bswap32(*((unsigned __int16 *)v36 + 7)) >> 16, bswap32(*((unsigned __int16 *)v36 + 8)) >> 16, bswap32(*((unsigned __int16 *)v36 + 9)) >> 16, bswap32(*((unsigned __int16 *)v36 + 10)) >> 16, bswap32(*((unsigned __int16 *)v36 + 11)) >> 16, bswap32(*((unsigned __int16 *)v36 + 1)) >> 16);
            }
            else
            {
              if (v37 != 2)
              {
                v43 = (sockaddr)xmmword_1841E3840;
                _ReportError(a2, (CFStreamError *)&v43);
LABEL_76:
                CFRelease(v35);
                return;
              }
              v38 = CFStringCreateWithFormat(v9, 0, CFSTR("PORT %u,%u,%u,%u,%u,%u\r\n"), v36[4], v36[5], v36[6], v36[7], v36[2], v36[3]);
            }
            v39 = v38;
            if (v38)
            {
              *((_DWORD *)a1 + 5) = 11;
              _WriteCommand(a1, a2, v38);
              CFRelease(v39);
            }
            goto LABEL_76;
          }
          RunLoopSource = CFSocketCreateRunLoopSource(v9, *(CFSocketRef *)(a2 + 56), 0);
          if (RunLoopSource)
          {
            v34 = RunLoopSource;
            _CFTypeScheduleOnMultipleRunLoops(RunLoopSource, *(const __CFArray **)(a2 + 80));
            CFRelease(v34);
            goto LABEL_69;
          }
        }
      }
LABEL_54:
      _InvalidateServer(a2);
      v43 = (sockaddr)xmmword_1841E3810;
      *(_DWORD *)&v43.sa_data[6] = *__error();
      if (!*(_DWORD *)&v43.sa_data[6])
      {
        *(_QWORD *)&v43.sa_len = 1;
        *(_DWORD *)&v43.sa_data[6] = 57;
      }
      goto LABEL_10;
    }
    PathComponent = CFURLCopyLastPathComponent(*(CFURLRef *)(a2 + 8));
    v11 = PathComponent;
    if ((*(_WORD *)a2 & 0x100) != 0)
    {
      v14 = CFSTR("RMD %@\r\n");
      v15 = 20;
      if (!CFURLHasDirectoryPath(*(CFURLRef *)(a2 + 8)))
      {
        IsRoot = _IsRoot(*(const __CFURL **)(a2 + 8));
        v15 = IsRoot ? 20 : 21;
        if (!IsRoot)
          v14 = CFSTR("DELE %@\r\n");
      }
      *((_DWORD *)a1 + 5) = v15;
      v12 = CFStringCreateWithFormat(v9, 0, v14, v11);
    }
    else
    {
      if (*(_QWORD *)(a2 + 16))
      {
        v12 = CFStringCreateWithFormat(v9, 0, CFSTR("RNFR %@\r\n"), PathComponent);
        v13 = 22;
      }
      else
      {
        if (!CFURLHasDirectoryPath(*(CFURLRef *)(a2 + 8)) && !_IsRoot(*(const __CFURL **)(a2 + 8)))
        {
LABEL_35:
          if (v11)
            CFRelease(v11);
          goto LABEL_37;
        }
        v12 = CFStringCreateWithFormat(v9, 0, CFSTR("MKD %@\r\n"), v11);
        v13 = 19;
      }
      *((_DWORD *)a1 + 5) = v13;
    }
    _WriteCommand(a1, a2, v12);
    if (v12)
      CFRelease(v12);
    v17 = *(_QWORD *)(a2 + 32);
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    if (v17)
      v18 = (CoreStreamBase *)(v17 + 16);
    else
      v18 = 0;
    v59.domain = 0;
    *(_QWORD *)&v59.error = 0;
    CoreStreamBase::_signalEvent(v18, 1, v59, 1);
    goto LABEL_35;
  }
  pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a2 + 136) + 8));
  v6 = *(_QWORD *)(a2 + 128);
  if (v6)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 72))(v6);
    NetConnection::dequeue(*(NetConnection **)(a2 + 128), (void *)a2);
    v7 = *(_QWORD *)(a2 + 128);
    if (v7)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 48))(v7);
    *(_QWORD *)(a2 + 128) = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(*(_QWORD *)(a2 + 136) + 8));
  _FTPStreamOpen(*(_QWORD *)(a2 + 32), &v43, &context, a2);
}

void _HandleMakeDirectory(uint64_t a1, uint64_t a2)
{
  SInt32 v2;
  __int128 v3;

  if ((*(_BYTE *)a1 & 2) != 0)
  {
    *(_DWORD *)(a1 + 20) = 8;
    _StartProcess();
  }
  else
  {
    v2 = *(_DWORD *)(a1 + 16);
    if ((v2 - 300) > 0xFFFFFF9B)
    {
      _ConnectionComplete(a1, a2);
    }
    else
    {
      v3 = xmmword_1841E3820;
      DWORD2(v3) = v2;
      _ReportError(a2, (CFStreamError *)&v3);
    }
  }
}

void _HandleRenameFrom(uint64_t a1, uint64_t a2)
{
  SInt32 v3;
  const __CFAllocator *v5;
  __CFURL *v6;
  uint64_t v7;
  const __CFString *PathForContext;
  const __CFString *v9;
  CFStringRef v10;
  __int128 v11;

  v3 = *(_DWORD *)(a1 + 16);
  if ((v3 - 400) <= 0xFFFFFF9B)
  {
    v11 = xmmword_1841E3820;
    DWORD2(v11) = v3;
LABEL_7:
    _ReportError(a2, (CFStreamError *)&v11);
    return;
  }
  v5 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
  v7 = *(_QWORD *)(a2 + 8);
  v6 = *(__CFURL **)(a2 + 16);
  *(_QWORD *)(a2 + 8) = v6;
  PathForContext = _CreatePathForContext(v5, a1, v6);
  if (!PathForContext)
  {
    v11 = xmmword_1841E3A40;
    goto LABEL_7;
  }
  v9 = PathForContext;
  *(_QWORD *)(a2 + 8) = v7;
  *(_DWORD *)(a1 + 20) = 23;
  v10 = CFStringCreateWithFormat(v5, 0, CFSTR("RNTO %@\r\n"), PathForContext);
  CFRelease(v9);
  _WriteCommand(a1, a2, v10);
  if (v10)
    CFRelease(v10);
}

void _ConnectionComplete(uint64_t a1, uint64_t a2)
{
  int v4;
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  NetConnection *v9;
  __CFRunLoop *v10;
  const __CFString *v11;
  __int16 v12;
  CFTypeID v13;
  uint64_t v14;
  CoreStreamBase *v15;
  CFStreamError v16;

  v4 = *(_DWORD *)(a1 + 20);
  v5 = *(const __CFArray **)(a2 + 80);
  Count = CFArrayGetCount(v5);
  if (Count >= 1)
  {
    v7 = Count;
    for (i = 0; i < v7; i += 2)
    {
      v9 = *(NetConnection **)(a2 + 128);
      CFArrayGetValueAtIndex(v5, i);
      CFArrayGetValueAtIndex(v5, i + 1);
      NetConnection::unschedule(v9, (uint64_t *)a2, v10, v11);
    }
  }
  *(_DWORD *)(a1 + 20) = 8;
  NetConnection::requestIsComplete(*(NetConnection **)(a2 + 128), (void *)a2);
  if (v4 != 15 || (*(_WORD *)a2 & 0x800) != 0)
  {
    NetConnection::responseIsComplete(*(NetConnection **)(a2 + 128), (void *)a2);
    v12 = *(_WORD *)a2 & 0xF7FF;
  }
  else
  {
    v12 = *(_WORD *)a2 | 0x800;
  }
  *(_WORD *)a2 = v12;
  if (!*(_QWORD *)(a2 + 56) && !*(_QWORD *)(a2 + 24))
  {
    v13 = CFGetTypeID(*(CFTypeRef *)(a2 + 32));
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    v14 = *(_QWORD *)(a2 + 32);
    if (v14)
      v15 = (CoreStreamBase *)(v14 + 16);
    else
      v15 = 0;
    if (v13 != *(_QWORD *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)
      && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    }
    v16.domain = 0;
    *(_QWORD *)&v16.error = 0;
    CoreStreamBase::_signalEvent(v15, 16, v16, 1);
  }
}

uint64_t _IsRoot(const __CFURL *a1)
{
  CFStringRef v2;
  CFStringRef v3;
  const void *v4;
  Boolean isAbsolute;

  isAbsolute = 0;
  v2 = CFURLCopyStrictPath(a1, &isAbsolute);
  v3 = CFURLCopyResourceSpecifier(a1);
  if (!((unint64_t)v2 | (unint64_t)v3))
    return 1;
  v4 = v3;
  if (v2)
    CFRelease(v2);
  if (v4)
    CFRelease(v4);
  return 0;
}

uint64_t _GetProtocolFamily(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const __CFData *v8;
  const __CFData *v9;
  int *BytePtr;
  uint64_t v11;
  socklen_t v13;

  v13 = 255;
  v4 = *(_QWORD *)(a1 + 96);
  if (v4)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
    v5 = *(_QWORD *)(a1 + 96);
    v6 = *(_QWORD *)(a1 + 144);
    if (v5)
      pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 144);
  }
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  if (v6)
    v7 = v6 + 16;
  else
    v7 = 0;
  ++*(_QWORD *)(v7 + 80);
  v8 = (const __CFData *)(*(uint64_t (**)(_QWORD, void *))(**(_QWORD **)(v7 + 24) + 40))(*(_QWORD *)(v7 + 24), &unk_1EDCFBDA8);
  --*(_QWORD *)(v7 + 80);
  if (!v8)
    return 255;
  v9 = v8;
  *(_OWORD *)(a2 + 239) = 0u;
  *(_OWORD *)(a2 + 208) = 0u;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  BytePtr = (int *)CFDataGetBytePtr(v8);
  if (getpeername(*BytePtr, (sockaddr *)a2, &v13))
    v11 = 255;
  else
    v11 = *(unsigned __int8 *)(a2 + 1);
  CFRelease(v9);
  return v11;
}

void _SocketCallBack(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, _WORD *a5)
{
  const __CFAllocator *v8;
  _QWORD *v9;
  _QWORD *v10;
  CFTypeID v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CoreStreamBase *v15;
  CFTypeID v16;
  dispatch_once_t *v17;
  void *v18;
  uint64_t v19;
  CFStreamError v20;
  CFStreamClientContext v21;

  v21.version = 0;
  v21.info = a5;
  memset(&v21.retain, 0, 24);
  v8 = CFGetAllocator(*((CFTypeRef *)a5 + 11));
  if (!a4 || *a4 == -1)
  {
    v20 = (CFStreamError)xmmword_1841E3A30;
    _ReportError((uint64_t)a5, &v20);
    return;
  }
  if (a2 != 2)
    return;
  v9 = a5 + 12;
  if ((*a5 & 0x80) != 0)
  {
    v10 = 0;
  }
  else
  {
    v10 = a5 + 12;
    v9 = 0;
  }
  _CoreStreamCreatePairWithNativeSocket(v8, *a4, v10, v9);
  CFDictionaryApplyFunction(*((CFDictionaryRef *)a5 + 11), (CFDictionaryApplierFunction)_StreamPropertyApplier, *((void **)a5 + 3));
  v11 = CFGetTypeID(*((CFTypeRef *)a5 + 3));
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
  {
    v16 = v11;
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    v11 = v16;
  }
  v12 = *((_QWORD *)a5 + 3);
  if (v12)
    v13 = v12 + 16;
  else
    v13 = 0;
  if (v11 == *(_QWORD *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
  {
    CoreReadStream::setClient(v13, -1, (uint64_t)_DataStreamCallBack, &v21);
    _CFTypeScheduleOnMultipleRunLoops(*((void **)a5 + 3), *((const __CFArray **)a5 + 10));
    v14 = *((_QWORD *)a5 + 3);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream == -1)
      goto LABEL_20;
    v17 = &CoreReadStream::Class(void)::sOnce_CoreReadStream;
    v18 = &__block_literal_global_16727;
  }
  else
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    {
      v19 = v13;
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      v13 = v19;
    }
    CoreWriteStream::setClient(v13, -1, (uint64_t)_DataStreamCallBack, &v21);
    _CFTypeScheduleOnMultipleRunLoops(*((void **)a5 + 3), *((const __CFArray **)a5 + 10));
    v14 = *((_QWORD *)a5 + 3);
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1)
      goto LABEL_20;
    v17 = &CoreWriteStream::Class(void)::sOnce_CoreWriteStream;
    v18 = &__block_literal_global_3166;
  }
  dispatch_once(v17, v18);
LABEL_20:
  if (v14)
    v15 = (CoreStreamBase *)(v14 + 16);
  else
    v15 = 0;
  CoreStreamBase::_streamInterface_Open(v15);
  _InvalidateServer((uint64_t)a5);
}

void _CoreStreamCreatePairWithNativeSocket(const __CFAllocator *a1, int a2, _QWORD *a3, _QWORD *a4)
{
  __CFReadStream **p_cf;
  __CFWriteStream **v8;
  CFTypeRef v9;
  CFTypeRef cf;

  v9 = 0;
  cf = 0;
  if (a3)
    p_cf = (__CFReadStream **)&cf;
  else
    p_cf = 0;
  if (a4)
    v8 = (__CFWriteStream **)&v9;
  else
    v8 = 0;
  _CFStreamCreatePairWithNativeSocket(a1, a2, p_cf, v8);
  if (a3)
    *a3 = CoreReadStreamCreateWithCFReadStream(a1, (__CFReadStream *)cf);
  if (a4)
    *a4 = CoreWriteStreamCreateWithCFWriteStream(a1, (__CFWriteStream *)v9);
  if (cf)
    CFRelease(cf);
  if (v9)
    CFRelease(v9);
}

uint64_t _StreamPropertyApplier(const void *a1, const void *a2, char *cf)
{
  CFTypeID v6;
  char *v7;
  uint64_t result;

  v6 = CFGetTypeID(cf);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  if (v6 != *(_QWORD *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)
    && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
  {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  }
  if (cf)
    v7 = cf + 16;
  else
    v7 = 0;
  ++*((_QWORD *)v7 + 10);
  result = (*(uint64_t (**)(_QWORD, const void *, const void *))(**((_QWORD **)v7 + 3) + 32))(*((_QWORD *)v7 + 3), a1, a2);
  --*((_QWORD *)v7 + 10);
  return result;
}

void _DataStreamCallBack(char *cf, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  CFTypeID v7;
  char *v8;
  CFIndex v9;
  CFIndex v10;
  CFTypeID v11;
  uint64_t v12;
  CoreStreamBase *v13;
  dispatch_once_t *v14;
  void *v15;
  dispatch_once_t *v16;
  void *v17;
  CFStreamError v18;

  v4 = a2;
  if (a2 != 16 || (*(_WORD *)a3 & 0x10) != 0)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    v6 = *(_QWORD *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96);
    v7 = CFGetTypeID(cf);
    if (cf)
      v8 = cf + 16;
    else
      v8 = 0;
    if (v7 == v6)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream == -1)
      {
LABEL_12:
        v18 = *(CFStreamError *)(v8 + 56);
        if ((*(_WORD *)a3 & 0x30) != 0x10)
          goto LABEL_24;
        if (v4 == 8)
        {
          v9 = *(_QWORD *)(a3 + 120);
          if (v9 >= CFArrayGetCount(*(CFArrayRef *)(a3 + 112)))
            goto LABEL_23;
        }
        else
        {
          if (v4 != 2)
            goto LABEL_24;
          if (_ProcessHTTPResponse(a3, &v18))
          {
            if (!v18.error)
            {
              if ((*(_WORD *)a3 & 0x40) != 0)
                return;
              goto LABEL_33;
            }
LABEL_23:
            v4 = 8;
            goto LABEL_24;
          }
          v10 = *(_QWORD *)(a3 + 120);
          if (v10 >= CFArrayGetCount(*(CFArrayRef *)(a3 + 112)))
          {
LABEL_33:
            v4 = 2;
LABEL_24:
            v11 = CFGetTypeID(*(CFTypeRef *)(a3 + 32));
            v12 = *(_QWORD *)(a3 + 32);
            if (v12)
              v13 = (CoreStreamBase *)(v12 + 16);
            else
              v13 = 0;
            if (v11 == v6)
            {
              if (CoreReadStream::Class(void)::sOnce_CoreReadStream == -1)
                goto LABEL_31;
              v16 = &CoreReadStream::Class(void)::sOnce_CoreReadStream;
              v17 = &__block_literal_global_16727;
            }
            else
            {
              if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1)
              {
LABEL_31:
                CoreStreamBase::_signalEvent(v13, v4, v18, 1);
                return;
              }
              v16 = &CoreWriteStream::Class(void)::sOnce_CoreWriteStream;
              v17 = &__block_literal_global_3166;
            }
            dispatch_once(v16, v17);
            goto LABEL_31;
          }
        }
        _RollOverHTTPRequest(a3, &v18);
        if (!v18.error)
          return;
        goto LABEL_23;
      }
      v14 = &CoreReadStream::Class(void)::sOnce_CoreReadStream;
      v15 = &__block_literal_global_16727;
    }
    else
    {
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1)
        goto LABEL_12;
      v14 = &CoreWriteStream::Class(void)::sOnce_CoreWriteStream;
      v15 = &__block_literal_global_3166;
    }
    dispatch_once(v14, v15);
    goto LABEL_12;
  }
}

uint64_t _ProcessHTTPResponse(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  const void *v7;
  CFIndex ResponseStatusCode;
  int v9;
  char v10;

  v4 = *(_QWORD *)(a1 + 24);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  if (v4)
    v5 = v4 + 16;
  else
    v5 = 0;
  ++*(_QWORD *)(v5 + 80);
  result = (*(uint64_t (**)(_QWORD, void *))(**(_QWORD **)(v5 + 24) + 40))(*(_QWORD *)(v5 + 24), &unk_1EDCFECE8);
  --*(_QWORD *)(v5 + 80);
  *a2 = 0;
  a2[1] = 0;
  if (result)
  {
    v7 = (const void *)result;
    ResponseStatusCode = CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)result);
    if (ResponseStatusCode > 299)
    {
      v9 = ResponseStatusCode;
      if (ResponseStatusCode == 407
        && (*(_WORD *)a1 & 0x40) == 0
        && CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), CFSTR("kCFStreamPropertyFTPProxyUser"))
        && CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), CFSTR("kCFStreamPropertyFTPProxyPassword")))
      {
        *(_WORD *)a1 |= 0x40u;
        _ReleaseDataReadStream(a1);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 88), CFSTR("_kCFStreamPropertyFTPLastHTTPResponse"), v7);
        _FTPStreamOpen(*(_QWORD *)(a1 + 32), a2, &v10, a1);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 88), CFSTR("_kCFStreamPropertyFTPLastHTTPResponse"));
      }
      else
      {
        *a2 = 6;
        *((_DWORD *)a2 + 2) = v9;
      }
    }
    else
    {
      *(_WORD *)a1 |= 0x20u;
    }
    CFRelease(v7);
    return 1;
  }
  return result;
}

uint64_t _RollOverHTTPRequest(uint64_t a1, _OWORD *a2)
{
  char v5;

  _ReleaseDataReadStream(a1);
  ++*(_QWORD *)(a1 + 120);
  *(_OWORD *)(a1 + 40) = *a2;
  *(_WORD *)a1 &= ~0x40u;
  return _FTPStreamOpen(*(_QWORD *)(a1 + 32), a2, &v5, a1);
}

const __CFString *_CFURLCopyPathReplacingPercentEscapes(const __CFURL *a1)
{
  const __CFAllocator *v2;
  const __CFString *result;
  const __CFString *v4;
  CFStringRef v5;

  v2 = CFGetAllocator(a1);
  result = CFURLCopyPath(a1);
  if (result)
  {
    v4 = result;
    v5 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(v2, result, &stru_1E1500C68, 0);
    CFRelease(v4);
    return v5;
  }
  return result;
}

uint64_t _ReadSize(char *__str, unint64_t *a2)
{
  uint64_t result;
  char *v5;
  __darwin_ct_rune_t v6;
  unsigned int v7;
  int v8;

  *a2 = 0;
  if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * *__str + 60) & 0x400) == 0)
    return 0;
  v5 = __str;
  do
  {
    v7 = *v5++;
    v6 = v7;
    v8 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v7 + 60);
  }
  while ((v8 & 0x400) != 0);
  if ((v6 & 0x80) != 0)
  {
    result = __maskrune(v6, 0x4000uLL);
    if (!(_DWORD)result)
      return result;
  }
  else
  {
    result = v8 & 0x4000;
    if ((v8 & 0x4000) == 0)
      return result;
  }
  *a2 = strtouq(__str, 0, 10);
  return 1;
}

void _StartTransfer(uint64_t a1, uint64_t a2)
{
  CFStringRef PathComponent;
  const __CFAllocator *v5;
  const __CFAllocator *v6;
  const void *v7;
  uint64_t v8;
  dispatch_once_t *v9;
  void *v10;

  PathComponent = CFURLCopyLastPathComponent(*(CFURLRef *)(a2 + 8));
  v5 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
  v6 = v5;
  if ((*(_WORD *)a2 & 0x80) != 0)
  {
    *(_DWORD *)(a1 + 20) = 18;
    v7 = CFStringCreateWithFormat(v5, 0, CFSTR("STOR %@\r\n"), PathComponent);
    v8 = *(_QWORD *)(a2 + 24);
    if (!v8)
      goto LABEL_14;
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1)
      goto LABEL_13;
    v9 = &CoreWriteStream::Class(void)::sOnce_CoreWriteStream;
    v10 = &__block_literal_global_3166;
    goto LABEL_28;
  }
  if (CFURLHasDirectoryPath(*(CFURLRef *)(a2 + 8)) || _IsRoot(*(const __CFURL **)(a2 + 8)))
  {
    if ((*(_WORD *)a2 & 8) != 0)
    {
      v7 = CFStringCreateWithFormat(v6, 0, CFSTR("NLST %@\r\n"), PathComponent);
      *(_DWORD *)(a1 + 20) = 16;
      v8 = *(_QWORD *)(a2 + 24);
      if (!v8)
        goto LABEL_14;
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream == -1)
        goto LABEL_13;
    }
    else
    {
      v7 = CFRetain(CFSTR("LIST\r\n"));
      *(_DWORD *)(a1 + 20) = 17;
      v8 = *(_QWORD *)(a2 + 24);
      if (!v8)
        goto LABEL_14;
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream == -1)
        goto LABEL_13;
    }
LABEL_27:
    v9 = &CoreReadStream::Class(void)::sOnce_CoreReadStream;
    v10 = &__block_literal_global_16727;
LABEL_28:
    dispatch_once(v9, v10);
LABEL_13:
    CoreStreamBase::_streamInterface_Open((CoreStreamBase *)(v8 + 16));
    goto LABEL_14;
  }
  if ((*(_WORD *)a2 & 4) != 0)
  {
    *(_DWORD *)(a1 + 20) = 13;
    v7 = CFStringCreateWithFormat(v6, 0, CFSTR("SIZE %@\r\n"), PathComponent);
  }
  else if (*(_QWORD *)(a2 + 72))
  {
    v7 = CFStringCreateWithFormat(v6, 0, CFSTR("REST %lld\r\n"), *(_QWORD *)(a2 + 72));
    *(_DWORD *)(a1 + 20) = 14;
  }
  else
  {
    v7 = CFStringCreateWithFormat(v6, 0, CFSTR("RETR %@\r\n"), PathComponent);
    *(_DWORD *)(a1 + 20) = 15;
    *(_WORD *)a2 &= ~0x800u;
    v8 = *(_QWORD *)(a2 + 24);
    if (v8)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream == -1)
        goto LABEL_13;
      goto LABEL_27;
    }
  }
LABEL_14:
  if (PathComponent)
    CFRelease(PathComponent);
  _WriteCommand(a1, a2, v7);
  if (v7)
    CFRelease(v7);
}

void _CoreSocketStreamCreateWithSignature(const __CFAllocator *a1, const __CFData *a2, _QWORD *a3, _QWORD *a4, const __CFData *a5, __CFReadStream **a6, __CFWriteStream **a7)
{
  CFTypeRef *p_cf;
  CFTypeRef *v11;
  CFTypeRef v12;
  CFTypeRef cf;

  v12 = 0;
  cf = 0;
  if (a3)
    p_cf = &cf;
  else
    p_cf = 0;
  if (a4)
    v11 = &v12;
  else
    v11 = 0;
  _CFStreamCreatePairWithCFSocketSignaturePieces(a1, a2, (uint64_t)p_cf, (uint64_t)v11, a5, a6, a7);
  if (a3)
    *a3 = CoreReadStreamCreateWithCFReadStream(a1, (__CFReadStream *)cf);
  if (a4)
    *a4 = CoreWriteStreamCreateWithCFWriteStream(a1, (__CFWriteStream *)v12);
  if (cf)
    CFRelease(cf);
  if (v12)
    CFRelease(v12);
}

void ___ZL14_FTPStreamOpenPKvP13CFStreamErrorPhP19_CFFTPStreamContext_block_invoke()
{
  NSLog(CFSTR("FTP is deprecated for URLSession and related APIs. Please adopt modern secure networking protocols such as HTTPS."));
}

CFReadStreamRef CFReadStreamCreateWithFTPURL(CFAllocatorRef alloc, CFURLRef ftpURL)
{
  const __CFURL *CFFTPHappyURL;
  const __CFURL *v4;
  const __CFString *v5;
  const __CFString *v6;
  __CFReadStream *v7;
  CFStringRef v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  const __CFString *v12;
  _QWORD *v13;
  _QWORD *v14;
  CFMutableDictionaryRef Mutable;
  const void *v16;
  _OWORD *v17;
  uint64_t v18;
  const __CFString *v19;
  const void *v20;
  const void *v21;
  __int128 v23;
  void (*v24)(const void *, _QWORD *);
  CFStringRef (*v25)(const void *, uint64_t);
  uint64_t (*v26)(const void *, uint64_t, _BYTE *, uint64_t);
  uint64_t (*v27)(char *, uint64_t, char *);
  uint64_t (*v28)(int, unsigned __int8 *, uint64_t, uint64_t, _BYTE *, char *);
  uint64_t v29;
  uint64_t (*v30)(int, char *);
  void **(*v31)(uint64_t, uint64_t);
  CFArrayRef (*v32)(int, CFTypeRef, uint64_t);
  uint64_t (*v33)(int, const __CFString *, const __CFString *, uint64_t);
  uint64_t v34;
  uint64_t (*v35)(uint64_t, CoreSchedulingSet *, const __CFString *, uint64_t);
  void (*v36)(uint64_t, __CFRunLoop *, const __CFString *, uint64_t);

  if (!ftpURL)
    return 0;
  CFFTPHappyURL = _CreateCFFTPHappyURL(ftpURL);
  if (!CFFTPHappyURL)
    return 0;
  v4 = CFFTPHappyURL;
  if (!_ValidFTPPathname(CFFTPHappyURL))
    goto LABEL_31;
  v5 = CFURLCopyScheme(v4);
  if (!v5)
    goto LABEL_31;
  v6 = v5;
  if (CFStringCompare(v5, CFSTR("ftp"), 1uLL) == kCFCompareEqualTo
    || CFStringCompare(v6, CFSTR("ftps"), 1uLL) == kCFCompareEqualTo)
  {
    CFRelease(v6);
    v8 = CFURLCopyHostName(v4);
    if (v8)
    {
      CFRelease(v8);
      v9 = CFURLCopyUserName(v4);
      v10 = v9;
      if (v9 && !_ValidFTPString(v9))
      {
        v19 = v10;
      }
      else
      {
        v11 = CFURLCopyPassword(v4);
        v12 = v11;
        if (!v11 || _ValidFTPString(v11))
        {
          v13 = CFAllocatorAllocate(alloc, 144, 0);
          if (v13)
          {
            v14 = v13;
            *((_OWORD *)v13 + 7) = 0u;
            *((_OWORD *)v13 + 8) = 0u;
            *((_OWORD *)v13 + 5) = 0u;
            *((_OWORD *)v13 + 6) = 0u;
            *((_OWORD *)v13 + 3) = 0u;
            *((_OWORD *)v13 + 4) = 0u;
            *((_OWORD *)v13 + 1) = 0u;
            *((_OWORD *)v13 + 2) = 0u;
            *(_OWORD *)v13 = 0u;
            *(_WORD *)v13 = 1;
            v13[1] = CFURLCopyAbsoluteURL(v4);
            v14[10] = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E0C9B378]);
            Mutable = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v14[11] = Mutable;
            v16 = (const void *)v14[1];
            if (v16)
            {
              if (!v14[10] || !Mutable)
                goto LABEL_34;
              v29 = 0;
              v23 = 1uLL;
              v24 = _FTPStreamFinalize;
              v25 = _FTPStreamCopyDescription;
              v26 = _FTPStreamOpen;
              v27 = _FTPStreamOpenCompleted;
              v28 = _FTPStreamRead;
              v30 = _FTPStreamCanRead;
              v31 = _FTPStreamClose;
              v32 = _FTPStreamCopyProperty;
              v34 = 0;
              v33 = _FTPStreamSetProperty;
              v35 = _FTPStreamSchedule;
              v36 = _FTPStreamUnschedule;
              v17 = CoreReadStreamCreate((uint64_t)alloc, &v23, (uint64_t)v14);
              if (v17)
              {
                v18 = (uint64_t)v17;
                v14[4] = v17;
                if (v10)
                {
                  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
                    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
                  ++*(_QWORD *)(v18 + 96);
                  (*(void (**)(_QWORD, const __CFString *, const __CFString *))(**(_QWORD **)(v18 + 40) + 32))(*(_QWORD *)(v18 + 40), CFSTR("kCFStreamPropertyFTPUserName_prevalidated"), v10);
                  --*(_QWORD *)(v18 + 96);
                }
                if (v12)
                {
                  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
                    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
                  ++*(_QWORD *)(v18 + 96);
                  (*(void (**)(_QWORD, const __CFString *, const __CFString *))(**(_QWORD **)(v18 + 40) + 32))(*(_QWORD *)(v18 + 40), CFSTR("kCFStreamPropertyFTPPassword_prevalidated"), v12);
                  --*(_QWORD *)(v18 + 96);
                }
LABEL_41:
                CFRelease(v4);
                if (v10)
                  CFRelease(v10);
                if (v12)
                  CFRelease(v12);
                if (v18)
                {
                  v7 = (__CFReadStream *)_CFReadStreamCreateWithCoreStream((uint64_t)alloc, v18);
                  v4 = (const __CFURL *)v18;
                  goto LABEL_32;
                }
                return 0;
              }
              v16 = (const void *)v14[1];
              if (v16)
LABEL_34:
                CFRelease(v16);
            }
            v20 = (const void *)v14[10];
            if (v20)
              CFRelease(v20);
            v21 = (const void *)v14[11];
            if (v21)
              CFRelease(v21);
            CFAllocatorDeallocate(alloc, v14);
          }
          v18 = 0;
          goto LABEL_41;
        }
        if (v10)
          CFRelease(v10);
        v19 = v12;
      }
      CFRelease(v19);
    }
LABEL_31:
    v7 = 0;
    goto LABEL_32;
  }
  CFRelease(v4);
  v7 = 0;
  v4 = (const __CFURL *)v6;
LABEL_32:
  CFRelease(v4);
  return v7;
}

uint64_t _FTPStreamRead(int a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, _BYTE *a5, char *a6)
{
  _OWORD *v11;
  NetConnection *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CFIndex v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  CFIndex v33;
  __int16 v34;
  __int16 v35;
  NetConnection *v36;
  uint64_t v37;
  uint64_t v38;

  v11 = a6 + 40;
  while (2)
  {
    while (2)
    {
      *a5 = 0;
      *(_QWORD *)a4 = 0;
      *(_DWORD *)(a4 + 8) = 0;
LABEL_3:
      v12 = (NetConnection *)*((_QWORD *)a6 + 16);
      while (1)
      {
        if (!v12)
          goto LABEL_39;
        v13 = *((_QWORD *)a6 + 3);
        if (v13)
        {
          if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
            dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
          if (CoreStreamBase::_streamInterface_CanRead((CoreStreamBase *)(v13 + 16)))
            goto LABEL_39;
          v12 = (NetConnection *)*((_QWORD *)a6 + 16);
        }
        NetConnection::getState(v12, 1, (uint64_t *)a6);
        v14 = *((_QWORD *)a6 + 16);
        if (!v14)
          break;
        v15 = *(_QWORD *)(v14 + 96);
        if (v15)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v15 + 8));
          v16 = *(_QWORD *)(v14 + 96);
          v17 = *(_QWORD *)(v14 + 144);
          if (v16)
            pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8));
        }
        else
        {
          v17 = *(_QWORD *)(v14 + 144);
        }
        v18 = *((_QWORD *)a6 + 16);
        v19 = *(_QWORD *)(v18 + 96);
        if (v19)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v19 + 8));
          v20 = *(_QWORD *)(v18 + 96);
          v21 = *(_QWORD *)(v18 + 152);
          if (v20)
            pthread_mutex_unlock((pthread_mutex_t *)(v20 + 8));
          if (v21)
          {
LABEL_19:
            if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
              dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
            v22 = *(_QWORD *)(v21 + 80);
            *(_QWORD *)a4 = *(_QWORD *)(v21 + 72);
            *(_QWORD *)(a4 + 8) = v22;
            if ((_DWORD)v22)
              goto LABEL_29;
LABEL_25:
            if (v17)
            {
              if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
                dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
              v23 = *(_QWORD *)(v17 + 80);
              *(_QWORD *)a4 = *(_QWORD *)(v17 + 72);
              *(_QWORD *)(a4 + 8) = v23;
              LODWORD(v22) = v23;
            }
            goto LABEL_29;
          }
        }
        else
        {
          v21 = *(_QWORD *)(v18 + 152);
          if (v21)
            goto LABEL_19;
        }
        LODWORD(v22) = *(_DWORD *)(a4 + 8);
        if (!(_DWORD)v22)
          goto LABEL_25;
LABEL_29:
        v12 = (NetConnection *)*((_QWORD *)a6 + 16);
        if ((_DWORD)v22)
        {
          if (!*(_DWORD *)((*(uint64_t (**)(NetConnection *))(*(_QWORD *)v12 + 80))(v12) + 20))
          {
            v24 = *((_QWORD *)a6 + 15);
            if (v24 < CFArrayGetCount(*((CFArrayRef *)a6 + 14)))
            {
              v25 = *((_QWORD *)a6 + 16);
              ++*((_QWORD *)a6 + 15);
              *v11 = *(_OWORD *)a4;
              (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v25 + 64))(v25, a4);
              goto LABEL_3;
            }
          }
          goto LABEL_38;
        }
      }
      v26 = *((_QWORD *)a6 + 4);
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      v27 = v26 + 16;
      if (!v26)
        v27 = 0;
      v29 = *(_QWORD *)(v27 + 56);
      v28 = *(_QWORD *)(v27 + 64);
      *(_QWORD *)a4 = v29;
      *(_QWORD *)(a4 + 8) = v28;
      if ((_DWORD)v28)
      {
LABEL_38:
        *a5 = 1;
        v30 = -1;
        goto LABEL_40;
      }
LABEL_39:
      v30 = 0;
LABEL_40:
      v31 = *((_QWORD *)a6 + 3);
      if (!v31)
        return v30;
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      v32 = CoreStreamBase::_streamInterface_Read((CoreStreamBase *)(v31 + 16), a2, a3);
      v30 = v32;
      if ((*(_WORD *)a6 & 0x30) != 0x10)
      {
LABEL_52:
        if (v30 <= 0)
        {
          v34 = *(_WORD *)a6;
          if ((*(_WORD *)a6 & 0x800) != 0)
          {
            v36 = (NetConnection *)*((_QWORD *)a6 + 16);
            if (v36)
            {
              NetConnection::responseIsComplete(v36, a6);
              v34 = *(_WORD *)a6;
            }
            v35 = v34 & 0xF7FF;
          }
          else
          {
            v35 = v34 | 0x800;
          }
          *(_WORD *)a6 = v35;
          *a5 = 1;
          v37 = *((_QWORD *)a6 + 3);
          if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
            dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
          v38 = v37 + 16;
          if (!v37)
            v38 = 0;
          *(_OWORD *)a4 = *(_OWORD *)(v38 + 56);
        }
        return v30;
      }
      if (v32 < 0 || !_ProcessHTTPResponse((uint64_t)a6, (_QWORD *)a4))
      {
        v33 = *((_QWORD *)a6 + 15);
        if (v33 < CFArrayGetCount(*((CFArrayRef *)a6 + 14)))
        {
          _RollOverHTTPRequest((uint64_t)a6, (_OWORD *)a4);
          if (*(_DWORD *)(a4 + 8))
            goto LABEL_55;
          continue;
        }
        goto LABEL_52;
      }
      break;
    }
    if (!*(_DWORD *)(a4 + 8))
    {
      if ((*(_WORD *)a6 & 0x40) == 0)
        goto LABEL_52;
      continue;
    }
    break;
  }
LABEL_55:
  *a5 = 1;
  return v30;
}

uint64_t _FTPStreamCanRead(int a1, char *a2)
{
  NetConnection *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFStreamError v10;
  uint64_t v11;
  CoreStreamBase *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFIndex v18;
  int v19;
  CFIndex v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  CoreStreamBase *v25;
  CFIndex v26;
  uint64_t v27;
  CoreStreamBase *v28;
  CFStreamError v30;

  v3 = (NetConnection *)*((_QWORD *)a2 + 16);
  if (!v3)
    goto LABEL_34;
  NetConnection::getState(v3, 1, (uint64_t *)a2);
  v4 = *((_QWORD *)a2 + 16);
  if (!v4)
  {
    v8 = *((_QWORD *)a2 + 4);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    v9 = v8 + 16;
    if (!v8)
      v9 = 0;
    *(_QWORD *)&v10.error = *(_QWORD *)(v9 + 64);
    if (!v10.error)
      goto LABEL_34;
    v10.domain = *(_QWORD *)(v9 + 56);
    v11 = *((_QWORD *)a2 + 4);
    if (v11)
      v12 = (CoreStreamBase *)(v11 + 16);
    else
      v12 = 0;
    v13 = 1;
    goto LABEL_41;
  }
  v30 = (CFStreamError)0;
  v5 = *(_QWORD *)(v4 + 96);
  if (v5)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v5 + 8));
    v6 = *(_QWORD *)(v4 + 96);
    v7 = *(_QWORD *)(v4 + 144);
    if (v6)
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  }
  else
  {
    v7 = *(_QWORD *)(v4 + 144);
  }
  v14 = *((_QWORD *)a2 + 16);
  v15 = *(_QWORD *)(v14 + 96);
  if (v15)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v15 + 8));
    v16 = *(_QWORD *)(v14 + 96);
    v17 = *(_QWORD *)(v14 + 152);
    if (v16)
      pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8));
    if (v17)
    {
LABEL_20:
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      v18 = *(_QWORD *)(v17 + 72);
      v17 = *(_QWORD *)(v17 + 80);
      v30.domain = v18;
      *(_QWORD *)&v30.error = v17;
      v19 = v17;
      if ((_DWORD)v17)
        goto LABEL_30;
      goto LABEL_26;
    }
  }
  else
  {
    v17 = *(_QWORD *)(v14 + 152);
    if (v17)
      goto LABEL_20;
  }
  v18 = 0;
  v19 = 0;
LABEL_26:
  if (v7)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    v18 = *(_QWORD *)(v7 + 72);
    v17 = *(_QWORD *)(v7 + 80);
    v30.domain = v18;
    *(_QWORD *)&v30.error = v17;
    v19 = v17;
  }
LABEL_30:
  if (!v19)
  {
LABEL_34:
    v13 = 0;
    goto LABEL_42;
  }
  if (!*(_DWORD *)((*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 16) + 80))(*((_QWORD *)a2 + 16)) + 20))
  {
    v20 = *((_QWORD *)a2 + 15);
    if (v20 < CFArrayGetCount(*((CFArrayRef *)a2 + 14)))
    {
      v21 = *((_QWORD *)a2 + 16);
      ++*((_QWORD *)a2 + 15);
      *(CFStreamError *)(a2 + 40) = v30;
      (*(void (**)(uint64_t, CFStreamError *))(*(_QWORD *)v21 + 64))(v21, &v30);
      goto LABEL_34;
    }
  }
  v22 = *((_QWORD *)a2 + 4);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  if (v22)
    v12 = (CoreStreamBase *)(v22 + 16);
  else
    v12 = 0;
  v13 = 1;
  v10.domain = v18;
  *(_QWORD *)&v10.error = v17;
LABEL_41:
  CoreStreamBase::_signalEvent(v12, 8, v10, 1);
LABEL_42:
  v23 = *((_QWORD *)a2 + 3);
  if (!v23)
    return v13;
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  v13 = CoreStreamBase::_streamInterface_CanRead((CoreStreamBase *)(v23 + 16));
  if (!(_DWORD)v13)
  {
    v24 = *((_QWORD *)a2 + 3);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (v24)
      v25 = (CoreStreamBase *)(v24 + 16);
    else
      v25 = 0;
    if (CoreStreamBase::_streamInterface_GetStatus(v25) != 5)
      return 0;
    v13 = 1;
  }
  if ((*(_WORD *)a2 & 0x30) != 0x10)
    return v13;
  if (!_ProcessHTTPResponse((uint64_t)a2, &v30))
  {
    v26 = *((_QWORD *)a2 + 15);
    if (v26 >= CFArrayGetCount(*((CFArrayRef *)a2 + 14)))
      return v13;
    _RollOverHTTPRequest((uint64_t)a2, &v30);
  }
  if (!v30.error)
    return 0;
  v27 = *((_QWORD *)a2 + 4);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  if (v27)
    v28 = (CoreStreamBase *)(v27 + 16);
  else
    v28 = 0;
  CoreStreamBase::_signalEvent(v28, 8, v30, 1);
  return v13;
}

void sub_183FEE29C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FEE334(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FEE38C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FEE50C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_183FEE7D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_183FEEA40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_183FEED74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_183FEEE84(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FEEFD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *a16)
{
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

void sub_183FEF1AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_183FEF508(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_183FEF6A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  void *v20;
  void *v21;
  void *v22;

  _Block_object_dispose(&a15, 8);
  _Unwind_Resume(a1);
}

void sub_183FEF8C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

void sub_183FEF9FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

void sub_183FEFAF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_183FEFBB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

id cookieNotificationQueue(void)
{
  if (cookieNotificationQueue(void)::onceToken != -1)
    dispatch_once(&cookieNotificationQueue(void)::onceToken, &__block_literal_global_843);
  return (id)cookieNotificationQueue(void)::notificaionQueue;
}

void sub_183FEFD58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void ___ZL23cookieNotificationQueuev_block_invoke()
{
  NSObject *v0;
  dispatch_queue_t v1;
  void *v2;
  NSObject *v3;

  dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v3 = objc_claimAutoreleasedReturnValue();
  dispatch_queue_attr_make_with_qos_class(v3, QOS_CLASS_UTILITY, 0);
  v0 = objc_claimAutoreleasedReturnValue();
  v1 = dispatch_queue_create("com.apple.NSHTTPCookieManagerNotification", v0);
  v2 = (void *)cookieNotificationQueue(void)::notificaionQueue;
  cookieNotificationQueue(void)::notificaionQueue = (uint64_t)v1;

}

void sub_183FF0068(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183FF0284(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183FF05BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v3;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__860(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__861(uint64_t a1)
{

}

void sub_183FF0794(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FF08E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FF0A2C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FF0EE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_183FF0F98(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FF1058(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183FF111C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

CFReadStreamRef CFReadStreamCreateForHTTPRequest(CFAllocatorRef alloc, CFHTTPMessageRef request)
{
  return (CFReadStreamRef)CFReadStreamCreate();
}

CFReadStreamRef CFReadStreamCreateForStreamedHTTPRequest(CFAllocatorRef alloc, CFHTTPMessageRef requestHeaders, CFReadStreamRef requestBody)
{
  CFDictionaryRef v5;
  __CFReadStream *v6;
  pthread_t v8;
  CFWriteStreamRef writeStream;
  CFReadStreamRef readStream;
  pthread_attr_t v11;
  void *values[2];
  void *keys[2];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (!requestBody || CFReadStreamGetStatus(requestBody) != kCFStreamStatusOpen)
    return (CFReadStreamRef)CFReadStreamCreate();
  CFLog();
  CFReadStreamSetClient(requestBody, 0, 0, 0);
  writeStream = 0;
  readStream = 0;
  CFStreamCreateBoundPair(alloc, &readStream, &writeStream, 0x8000);
  CFWriteStreamOpen(writeStream);
  *(_OWORD *)keys = xmmword_1E14F6BD0;
  values[0] = requestBody;
  values[1] = writeStream;
  v5 = CFDictionaryCreate(alloc, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFRelease(writeStream);
  pthread_attr_init(&v11);
  pthread_attr_setdetachstate(&v11, 2);
  v8 = 0;
  if (pthread_create(&v8, &v11, (void *(__cdecl *)(void *))_boundPairReadingThread, v5))
  {
    CFRelease(v5);
    CFLog();
    v6 = 0;
  }
  else
  {
    v6 = (__CFReadStream *)CFReadStreamCreate();
  }
  pthread_attr_destroy(&v11);
  CFRelease(readStream);
  return v6;
}

uint64_t _boundPairReadingThread(const __CFDictionary *a1)
{
  UInt8 *v2;
  __CFReadStream *Value;
  __CFWriteStream *v4;
  CFIndex v5;
  UInt8 *v6;
  const UInt8 *v7;
  CFIndex v8;

  v2 = (UInt8 *)operator new[]();
  Value = (__CFReadStream *)CFDictionaryGetValue(a1, CFSTR("requestBody"));
  v4 = (__CFWriteStream *)CFDictionaryGetValue(a1, CFSTR("newWriteStream"));
  while (1)
  {
    v5 = CFReadStreamRead(Value, v2, 0x4000);
    if (v5 < 1)
      break;
    v6 = &v2[v5];
    v7 = v2;
    while (v7 < v6)
    {
      v8 = CFWriteStreamWrite(v4, v7, v6 - v7);
      v7 += v8;
      if (v8 <= 0)
        goto LABEL_6;
    }
  }
LABEL_6:
  CFWriteStreamClose(v4);
  if (a1)
    CFRelease(a1);
  MEMORY[0x186DB7474](v2, 0x1000C8077774924);
  return 0;
}

void ___ZL24_handleAlreadyOpenStreamPK13__CFAllocatorP15__CFHTTPMessageP14__CFReadStream_block_invoke(uint64_t a1, const void *a2)
{
  _OWORD *v4;
  uint64_t v5;
  HTTPRequestMessage *v6;

  v4 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 32), 152, 0);
  *v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  v4[4] = 0u;
  v4[5] = 0u;
  v4[6] = 0u;
  v4[7] = 0u;
  v4[8] = 0u;
  *((_QWORD *)v4 + 18) = 0;
  v5 = *(_QWORD *)(a1 + 40);
  if (v5)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*(_BYTE *)(v5 + 40))
      v6 = 0;
    else
      v6 = (HTTPRequestMessage *)(v5 + 16);
  }
  else
  {
    v6 = 0;
  }
  HTTPReadStream::HTTPReadStream((HTTPReadStream *)v4, a2, v6, *(__CFReadStream **)(a1 + 48));
}

void `non-virtual thunk to'GlueTubeManager::~GlueTubeManager(GlueTubeManager *this)
{
  GlueTubeManager::~GlueTubeManager((GlueTubeManager *)((char *)this - 24));
}

void `non-virtual thunk to'GlueTubeManager::~GlueTubeManager(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  GlueTubeManager::~GlueTubeManager((GlueTubeManager *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

void std::__shared_ptr_pointer<NSObject  {objcproto13OS_nw_context}*,Deleter_NWRelease<NSObject  {objcproto13OS_nw_context}*>,std::allocator<NSObject  {objcproto13OS_nw_context}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_emplace<NWIOConnection>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F09F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NWIOConnection>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F09F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

_QWORD *GlueTubeManager::_findOrCreateSManager(GlueTubeManager *this)
{
  _QWORD *v1;
  _OWORD *v3;
  const __CFAllocator *v4;
  uint64_t v5;
  char *v6;
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  v1 = (_QWORD *)*((_QWORD *)this + 5);
  if (!v1)
  {
    v3 = CFAllocatorAllocate(*((CFAllocatorRef *)this + 1), 152, 0);
    *v3 = 0u;
    v3[2] = 0u;
    v3[3] = 0u;
    v3[4] = 0u;
    v3[5] = 0u;
    v3[6] = 0u;
    v3[7] = 0u;
    v3[8] = 0u;
    *((_QWORD *)v3 + 18) = 0;
    v3[1] = 0u;
    v4 = (const __CFAllocator *)*((_QWORD *)this + 1);
    v5 = *((_QWORD *)this + 6);
    v10 = *((_QWORD *)this + 11);
    v8 = *(_OWORD *)((char *)this + 56);
    v9 = *(_OWORD *)((char *)this + 72);
    *(_QWORD *)v3 = off_1E14EF578;
    *((_QWORD *)v3 + 1) = v4;
    *((_DWORD *)v3 + 4) = 1;
    if (((unint64_t)(v3 + 1) & 3) != 0)
      __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
    v1 = v3;
    *(_QWORD *)v3 = off_1E14E61A8;
    *((_QWORD *)v3 + 3) = &unk_1E14E6210;
    *(_OWORD *)((char *)v3 + 40) = xmmword_1841E37E0;
    v6 = (char *)v3 + 40;
    *(_OWORD *)((char *)v3 + 56) = xmmword_1841E37F0;
    *((_QWORD *)v3 + 9) = 0x7800000078;
    *((_QWORD *)v3 + 13) = &off_1E14EA488;
    *((_QWORD *)v3 + 14) = CFDictionaryCreateMutable(v4, 0, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
    v1[15] = &off_1E14EA528;
    v1[16] = CFDictionaryCreateMutable(v4, 0, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks, MEMORY[0x1E0C9B3A0]);
    v1[17] = CFArrayCreateMutable(v4, 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    v1[18] = CFArrayCreateMutable(v4, 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    if (!v5)
      __assert_rtn("STubeManager", "STubeManager.cpp", 24, "schedulingSet");
    v1[4] = v5;
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
    *(_OWORD *)v6 = v8;
    *((_OWORD *)v6 + 1) = v9;
    *((_QWORD *)v6 + 4) = v10;
    v1[11] = 0;
    v1[12] = 0;
    v1[10] = 0;
    *((_QWORD *)this + 5) = v1;
  }
  return v1;
}

void sub_183FF1918(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  CFRelease(*(CFTypeRef *)(v1 + 136));
  *(_QWORD *)(v1 + 120) = v3;
  CFRelease(*(CFTypeRef *)(v1 + 128));
  *(_QWORD *)(v1 + 104) = v2;
  CFRelease(*(CFTypeRef *)(v1 + 112));
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t _CFServerCreate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Instance;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  __int128 v10;
  uint64_t (*v11)(void);

  if (!_ServerTypeId)
  {
    _ServerTypeId = _CFRuntimeRegisterClass();
    if (!_ServerTypeId)
      return 0;
  }
  Instance = _CFRuntimeCreateInstance();
  v6 = Instance;
  if (!Instance)
    return v6;
  *(_QWORD *)(Instance + 16) = 0;
  *(_QWORD *)(Instance + 24) = 0;
  *(_DWORD *)(Instance + 40) = 0;
  *(_QWORD *)(Instance + 32) = 0;
  *(_QWORD *)(Instance + 56) = CoreSchedulingSet::createEmpty((CoreSchedulingSet *)Instance);
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_OWORD *)(v6 + 96) = 0u;
  v7 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v8 = dispatch_queue_create("com.apple.CFNetwork.CFServer", v7);
  *(_QWORD *)(v6 + 48) = tcp_listener_create();
  dispatch_release(v8);
  if (!*(_QWORD *)(v6 + 48))
  {
    _CFServerInvalidate(v6);
    CFRelease((CFTypeRef)v6);
    return 0;
  }
  tcp_listener_set_accept_handler_f();
  tcp_listener_set_error_handler_f();
  *(_QWORD *)(v6 + 64) = a2;
  v9 = *(_QWORD *)(a3 + 32);
  v10 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(v6 + 72) = *(_OWORD *)a3;
  *(_QWORD *)(v6 + 104) = v9;
  *(_OWORD *)(v6 + 88) = v10;
  if (*(_QWORD *)(v6 + 80))
  {
    v11 = *(uint64_t (**)(void))(v6 + 88);
    if (v11)
      *(_QWORD *)(v6 + 80) = v11();
  }
  return v6;
}

uint64_t _tcp_listener_AcceptCallback()
{
  dispatch_get_global_queue(0, 0);
  tcp_connection_accept();
  tcp_connection_allow_client_socket_access();
  tcp_connection_set_event_handler();
  return tcp_connection_start();
}

uint64_t _tcp_listener_ErrorCallback(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v4[6];
  int v5;
  int v6;

  if (*(_QWORD *)(result + 64))
  {
    v2 = result;
    result = *(_QWORD *)(result + 56);
    if (*(_DWORD *)(result + 40))
    {
      if (a2 >> 5 == 134215679)
      {
        if (a2 > -65549)
        {
          if (a2 == -65548)
          {
            a2 = -72001;
            goto LABEL_15;
          }
          if (a2 == -65540)
          {
            a2 = -72004;
            goto LABEL_15;
          }
LABEL_14:
          a2 = -72000;
          goto LABEL_15;
        }
        if (a2 != -65555)
        {
          if (a2 == -65554)
          {
            a2 = -72002;
LABEL_15:
            v3 = 10;
            goto LABEL_16;
          }
          goto LABEL_14;
        }
        v3 = 10;
        a2 = -72008;
      }
      else
      {
        v3 = 1;
      }
LABEL_16:
      v4[0] = MEMORY[0x1E0C809B0];
      v4[1] = 3221225472;
      v4[2] = ___ZL18_ServerHandleErrorP6Serveri_block_invoke;
      v4[3] = &__block_descriptor_56_e5_v8__0l;
      v4[4] = v2;
      v4[5] = v3;
      v5 = a2;
      v6 = 0;
      return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)result + 96))(result, v4);
    }
  }
  return result;
}

uint64_t _CFServerInvalidate(uint64_t a1)
{
  void (*v2)(void);
  uint64_t v3;
  const void *v4;
  const void *v5;
  const void *v6;
  uint64_t result;

  if (*(_QWORD *)(a1 + 80))
  {
    v2 = *(void (**)(void))(a1 + 96);
    if (v2)
      v2();
  }
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  v3 = *(_QWORD *)(a1 + 56);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
    *(_QWORD *)(a1 + 56) = 0;
  }
  v4 = *(const void **)(a1 + 16);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v5 = *(const void **)(a1 + 24);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v6 = *(const void **)(a1 + 32);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 32) = 0;
  }
  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    tcp_listener_cancel();
    result = tcp_listener_release();
    *(_QWORD *)(a1 + 48) = 0;
  }
  return result;
}

uint64_t ___ZL18_ServerHandleErrorP6Serveri_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32), 0xFFFFFFFFLL, a1 + 40, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 80));
}

uint64_t ___ZL19_ServerHandleAcceptP6Serveri_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32), *(unsigned int *)(a1 + 56), a1 + 40, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 80));
}

CFStringRef _ServerCopyDescription(_QWORD *a1)
{
  const __CFAllocator *v2;
  uint64_t (*v3)(_QWORD);
  CFStringRef v4;
  CFStringRef v5;
  CFStringRef v6;

  v2 = CFGetAllocator(a1);
  v3 = (uint64_t (*)(_QWORD))a1[13];
  if (v3)
    v4 = (CFStringRef)v3(a1[10]);
  else
    v4 = CFStringCreateWithFormat(v2, 0, CFSTR("<%p>"), a1[10]);
  v5 = v4;
  v6 = CFStringCreateWithFormat(v2, 0, CFSTR("<Server %p>{tcp_listener=%p, info=%@}"), a1, a1[6], v4);
  CFRelease(v5);
  return v6;
}

uint64_t _CFServerScheduleWithRunLoopAndMode(uint64_t a1)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 56) + 56))(*(_QWORD *)(a1 + 56));
  *(_QWORD *)(a1 + 56) = result;
  return result;
}

uint64_t _CFServerGetPort(uint64_t a1)
{
  unsigned int port;

  if (*(_QWORD *)(a1 + 48))
  {
    port = tcp_listener_get_port();
    if (port)
      return __rev16(port);
    CFLog();
  }
  return *(unsigned __int16 *)(a1 + 40);
}

uint64_t _CFServerStart(uint64_t a1, const __CFString *a2, const void *a3, unsigned int a4)
{
  CFRunLoopRef Current;
  const __CFString *v9;
  CFIndex Length;
  CFIndex v11;
  CFIndex v12;
  CFIndex v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  const __CFAllocator *v17;
  const __CFString *v18;
  CFIndex v19;
  uint64_t v20;
  CFIndex v21;
  int v22;
  _QWORD v24[2];

  v24[1] = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 48))
    return 0;
  if (!*(_DWORD *)(*(_QWORD *)(a1 + 56) + 40))
  {
    Current = CFRunLoopGetCurrent();
    *(_QWORD *)(a1 + 56) = (*(uint64_t (**)(_QWORD, CFRunLoopRef, _QWORD))(**(_QWORD **)(a1 + 56) + 56))(*(_QWORD *)(a1 + 56), Current, *MEMORY[0x1E0C9B270]);
  }
  if (a4 < 0x10000)
  {
    if (a2)
      v9 = a2;
    else
      v9 = &stru_1E1500C68;
    *(_QWORD *)(a1 + 16) = CFRetain(v9);
    if (a3)
    {
      *(_QWORD *)(a1 + 24) = CFRetain(a3);
      *(_QWORD *)(a1 + 32) = &stru_1E1500C68;
      *(_DWORD *)(a1 + 40) = a4;
      Length = CFStringGetLength(*(CFStringRef *)(a1 + 16));
      v11 = CFStringGetLength(*(CFStringRef *)(a1 + 24));
      v12 = CFStringGetLength(*(CFStringRef *)(a1 + 32));
      v13 = v12 + 1;
      v14 = MEMORY[0x1E0C80A78](v12);
      v15 = MEMORY[0x1E0C80A78](v14);
      v16 = (char *)v24 - ((MEMORY[0x1E0C80A78](v15) + 16) & 0xFFFFFFFFFFFFFFF0);
      CFStringGetCString(*(CFStringRef *)(a1 + 16), (char *)v24 - ((Length + 16) & 0xFFFFFFFFFFFFFFF0), Length + 1, 0x8000100u);
      CFStringGetCString(*(CFStringRef *)(a1 + 24), (char *)v24 - ((v11 + 16) & 0xFFFFFFFFFFFFFFF0), v11 + 1, 0x8000100u);
      CFStringGetCString(*(CFStringRef *)(a1 + 32), v16, v13, 0x8000100u);
      tcp_listener_set_service();
      if (!*(_DWORD *)(a1 + 40))
        goto LABEL_16;
    }
    else
    {
      *(_QWORD *)(a1 + 24) = 0;
      *(_QWORD *)(a1 + 32) = &stru_1E1500C68;
      *(_DWORD *)(a1 + 40) = a4;
      if (!a4)
        goto LABEL_16;
    }
    v17 = CFGetAllocator((CFTypeRef)a1);
    v18 = CFStringCreateWithFormat(v17, 0, CFSTR("%u"), *(unsigned int *)(a1 + 40));
    v19 = CFStringGetLength(v18);
    MEMORY[0x1E0C80A78](v19);
    CFStringGetCString(v18, (char *)v24 - v20, v21, 0x8000100u);
    v22 = tcp_listener_set_port();
    CFRelease(v18);
    if (v22)
      return 0;
LABEL_16:
    tcp_listener_start();
    return 1;
  }
  tcp_listener_release();
  return 0;
}

CFStringRef ActualCredentialStorage::copyDebugDesc(ActualCredentialStorage *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<ActualCredentialStorage@%p<%p> { session %p, persistent %p }"), (char *)this - 16, this, *((_QWORD *)this + 13), *((_QWORD *)this + 14));
}

CFStringRef ActualCredentialStorage::copyDebugSummary(ActualCredentialStorage *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("shared credential storage %p, session %p, persistent %p"), (char *)this - 16, *((_QWORD *)this + 13), *((_QWORD *)this + 14));
}

CFTypeRef ActualCredentialStorage::copyCredentialsForProtectionSpace(ActualCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  const void *v4;
  uint64_t v5;
  const void *v6;
  unint64_t Count;
  const void **v8;
  CFTypeRef v9;
  unint64_t v10;
  const void **v11;
  unint64_t v12;
  const void **v13;
  unint64_t v14;
  const void **v15;
  const __CFAllocator *v16;
  __CFDictionary *Mutable;
  uint64_t i;
  uint64_t j;
  const void *v20;
  CFTypeRef v22;
  unint64_t v23;
  const void **v24;
  _BYTE v25[248];
  CFTypeRef v26;
  uint64_t v27;
  const void **v28;
  _BYTE v29[248];
  CFTypeRef v30;
  unint64_t v31;
  const void **v32;
  _BYTE v33[248];
  CFTypeRef v34;
  uint64_t v35;
  const void **v36;
  _BYTE v37[248];

  v4 = (const void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 16))(*((_QWORD *)this + 13));
  v5 = *((_QWORD *)this + 14);
  if (!v5)
    return v4;
  v6 = (const void *)(*(uint64_t (**)(uint64_t, _CFURLProtectionSpace *))(*(_QWORD *)v5 + 24))(v5, a2);
  if (!v4)
  {
    v31 = 0;
    v30 = 0;
    v32 = (const void **)v33;
    v34 = 0;
    v35 = 0;
    v36 = (const void **)v37;
    goto LABEL_17;
  }
  v30 = CFRetain(v4);
  Count = CFDictionaryGetCount((CFDictionaryRef)v4);
  v31 = Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v32 = 0;
    goto LABEL_11;
  }
  if (Count > 0x1E)
  {
    v8 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
    v32 = v8;
    if (!v8)
      goto LABEL_11;
  }
  else
  {
    v8 = (const void **)v33;
    v32 = (const void **)v33;
  }
  CFDictionaryGetKeysAndValues((CFDictionaryRef)v4, v8, 0);
LABEL_11:
  v34 = CFRetain(v4);
  v10 = CFDictionaryGetCount((CFDictionaryRef)v4);
  v35 = v10;
  if (v10 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v36 = 0;
    goto LABEL_17;
  }
  if (v10 > 0x1E)
  {
    v11 = (const void **)malloc_type_malloc(8 * v10, 0x89ED541CuLL);
    v36 = v11;
    if (!v11)
      goto LABEL_17;
  }
  else
  {
    v11 = (const void **)v37;
    v36 = (const void **)v37;
  }
  CFDictionaryGetKeysAndValues((CFDictionaryRef)v4, 0, v11);
LABEL_17:
  if (!v6)
  {
    v22 = 0;
    v23 = 0;
    v24 = (const void **)v25;
    v26 = 0;
    v27 = 0;
    v28 = (const void **)v29;
    if (!v35)
      goto LABEL_44;
    goto LABEL_42;
  }
  v22 = CFRetain(v6);
  v12 = CFDictionaryGetCount((CFDictionaryRef)v6);
  v23 = v12;
  if (v12 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v24 = 0;
    goto LABEL_26;
  }
  if (v12 > 0x1E)
  {
    v13 = (const void **)malloc_type_malloc(8 * v12, 0x89ED541CuLL);
    v24 = v13;
    if (!v13)
      goto LABEL_26;
  }
  else
  {
    v13 = (const void **)v25;
    v24 = (const void **)v25;
  }
  CFDictionaryGetKeysAndValues((CFDictionaryRef)v6, v13, 0);
LABEL_26:
  v26 = CFRetain(v6);
  v14 = CFDictionaryGetCount((CFDictionaryRef)v6);
  v27 = v14;
  if (v14 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v28 = 0;
  }
  else
  {
    if (v14 <= 0x1E)
    {
      v15 = (const void **)v29;
      v28 = (const void **)v29;
LABEL_31:
      CFDictionaryGetKeysAndValues((CFDictionaryRef)v6, 0, v15);
      goto LABEL_32;
    }
    v15 = (const void **)malloc_type_malloc(8 * v14, 0x89ED541CuLL);
    v28 = v15;
    if (v15)
      goto LABEL_31;
  }
LABEL_32:
  if (!v35)
  {
    v20 = v6;
    goto LABEL_46;
  }
  if (v27)
  {
    v16 = CFGetAllocator((char *)this - 16);
    Mutable = CFDictionaryCreateMutable(v16, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (v35 >= 1)
    {
      for (i = 0; i < v35; ++i)
        CFDictionarySetValue(Mutable, v32[i], v36[i]);
    }
    if (v27 >= 1)
    {
      for (j = 0; j < v27; ++j)
        CFDictionarySetValue(Mutable, v24[j], v28[j]);
    }
    if (Mutable)
      v9 = CFRetain(Mutable);
    else
      v9 = 0;
    CFRelease(Mutable);
    goto LABEL_49;
  }
LABEL_42:
  if (v4)
  {
    v20 = v4;
LABEL_46:
    v9 = CFRetain(v20);
    goto LABEL_49;
  }
LABEL_44:
  v9 = 0;
LABEL_49:
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v26);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v22);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v34);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v30);
  if (v6)
    CFRelease(v6);
  if (v4)
    CFRelease(v4);
  return v9;
}

void sub_183FF25E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFContainerEnumeratorBase *v9;
  const void *v10;
  CFContainerEnumeratorBase *v11;

  CFRelease(v10);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v11);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&a9);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v9);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&STACK[0x220]);
  _Unwind_Resume(a1);
}

CFTypeRef ActualCredentialStorage::copyAllCredentials(ActualCredentialStorage *this)
{
  const void *v2;
  uint64_t v3;
  const void *v4;
  CFTypeRef v5;

  v2 = (const void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 24))(*((_QWORD *)this + 13));
  v3 = *((_QWORD *)this + 14);
  if (!v3)
    return v2;
  v4 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 32))(v3);
  v5 = ActualCredentialStorage::mergeProtectionSpaceToNameToCredentialsDict(this, v2, v4);
  if (v4)
    CFRelease(v4);
  if (v2)
    CFRelease(v2);
  return v5;
}

CFTypeRef ActualCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain(ActualCredentialStorage *this, const __CFString *a2, uint64_t a3)
{
  const void *v6;
  uint64_t v7;
  const void *v8;
  CFTypeRef v9;

  v6 = (const void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 24))(*((_QWORD *)this + 13));
  v7 = *((_QWORD *)this + 14);
  if (!v7)
    return v6;
  v8 = (const void *)(*(uint64_t (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)v7 + 40))(v7, a2, a3);
  v9 = ActualCredentialStorage::mergeProtectionSpaceToNameToCredentialsDict(this, v6, v8);
  if (v8)
    CFRelease(v8);
  if (v6)
    CFRelease(v6);
  return v9;
}

void ActualCredentialStorage::setCredentialForProtectionSpace(ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  _QWORD *v6;
  char *v7;
  int v8;
  _QWORD *v9;
  uint64_t v10;
  const void *v11;
  const void *v12;

  v6 = (_QWORD *)(*(uint64_t (**)(ActualCredentialStorage *, _CFURLProtectionSpace *))(*(_QWORD *)this + 112))(this, a3);
  (*(void (**)(ActualCredentialStorage *, const _CFURLCredential *, _CFURLProtectionSpace *))(*(_QWORD *)this + 104))(this, a2, a3);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  if (a2)
    v7 = (char *)a2 + 16;
  else
    v7 = 0;
  v8 = *((_DWORD *)v7 + 9);
  if ((v8 - 3) < 2)
  {
    v9 = (_QWORD *)*((_QWORD *)this + 14);
    if (v9)
    {
      v10 = 6;
LABEL_11:
      (*(void (**)(void))(*v9 + 8 * v10))();
      goto LABEL_12;
    }
LABEL_10:
    v9 = (_QWORD *)*((_QWORD *)this + 13);
    v10 = 5;
    goto LABEL_11;
  }
  if (v8 != 1)
    goto LABEL_10;
LABEL_12:
  if (a2 && !v6)
  {
    (*(void (**)(ActualCredentialStorage *, const _CFURLCredential *, _CFURLProtectionSpace *))(*(_QWORD *)this + 120))(this, a2, a3);
    return;
  }
  if (a2 && v6)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1)
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
    v11 = (const void *)v6[9];
    if (!v11)
    {
      v11 = (const void *)(*(uint64_t (**)(_QWORD *))(v6[2] + 104))(v6 + 2);
      v6[9] = v11;
      if (URLCredential::Class(void)::sOnce_URLCredential != -1)
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
    }
    v12 = (const void *)*((_QWORD *)a2 + 9);
    if (!v12)
    {
      v12 = (const void *)(*(uint64_t (**)(char *))(*((_QWORD *)a2 + 2) + 104))((char *)a2 + 16);
      *((_QWORD *)a2 + 9) = v12;
    }
    if (v12 && v11)
    {
      if (CFEqual(v12, v11))
        (*(void (**)(ActualCredentialStorage *, const _CFURLCredential *, _CFURLProtectionSpace *))(*(_QWORD *)this + 120))(this, a2, a3);
    }
  }
  else if (!v6)
  {
    return;
  }
  CFRelease(v6);
}

uint64_t ActualCredentialStorage::removeCredentialForProtectionSpace(ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  uint64_t result;

  (*(void (**)(_QWORD))(**((_QWORD **)this + 13) + 48))(*((_QWORD *)this + 13));
  result = *((_QWORD *)this + 14);
  if (result)
    return (*(uint64_t (**)(uint64_t, const _CFURLCredential *, _CFURLProtectionSpace *))(*(_QWORD *)result
                                                                                                 + 56))(result, a2, a3);
  return result;
}

uint64_t ActualCredentialStorage::copyDefaultCredentialForProtectionSpace(ActualCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 56))(*((_QWORD *)this + 13));
  if (!result)
  {
    result = *((_QWORD *)this + 14);
    if (result)
      return (*(uint64_t (**)(uint64_t, _CFURLProtectionSpace *))(*(_QWORD *)result + 64))(result, a2);
  }
  return result;
}

uint64_t ActualCredentialStorage::setDefaultCredentialForProtectionSpace(ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  uint64_t result;
  int v6;
  uint64_t v7;
  uint64_t (*v8)(void);

  result = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 13) + 64))(*((_QWORD *)this + 13), 0);
  if (a2)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1)
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
    v6 = *((_DWORD *)a2 + 13);
    if ((v6 - 3) < 2)
    {
      v7 = *((_QWORD *)this + 14);
      if (v7)
      {
        v8 = *(uint64_t (**)(void))(*(_QWORD *)v7 + 72);
        return v8();
      }
LABEL_11:
      v8 = *(uint64_t (**)(void))(**((_QWORD **)this + 13) + 64);
      return v8();
    }
    if (v6 != 1)
      goto LABEL_11;
    result = *((_QWORD *)this + 14);
    if (result)
    {
      v8 = *(uint64_t (**)(void))(*(_QWORD *)result + 72);
      return v8();
    }
  }
  return result;
}

uint64_t ActualCredentialStorage::setUseSystemKeychain(ActualCredentialStorage *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 14);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 80))(result);
  return result;
}

uint64_t ActualCredentialStorage::useSystemKeychain(ActualCredentialStorage *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 14);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 88))(result);
  return result;
}

void `non-virtual thunk to'ActualCredentialStorage::~ActualCredentialStorage(ActualCredentialStorage *this)
{
  ActualCredentialStorage::~ActualCredentialStorage((ActualCredentialStorage *)((char *)this - 8));
}

{
  ActualCredentialStorage::~ActualCredentialStorage((ActualCredentialStorage *)((char *)this - 8));
}

{
  ActualCredentialStorage::~ActualCredentialStorage((ActualCredentialStorage *)((char *)this - 16));
}

{
  ActualCredentialStorage::~ActualCredentialStorage((ActualCredentialStorage *)((char *)this - 16));
}

{
  ActualCredentialStorage::~ActualCredentialStorage((ActualCredentialStorage *)((char *)this - 24));
}

{
  ActualCredentialStorage::~ActualCredentialStorage((ActualCredentialStorage *)((char *)this - 24));
}

CFTypeRef `non-virtual thunk to'ActualCredentialStorage::copyCredentialsForProtectionSpace(ActualCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  return ActualCredentialStorage::copyCredentialsForProtectionSpace((ActualCredentialStorage *)((char *)this - 8), a2);
}

CFTypeRef `non-virtual thunk to'ActualCredentialStorage::copyAllCredentials(ActualCredentialStorage *this)
{
  return ActualCredentialStorage::copyAllCredentials((ActualCredentialStorage *)((char *)this - 8));
}

CFTypeRef `non-virtual thunk to'ActualCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain(ActualCredentialStorage *this, const __CFString *a2, uint64_t a3)
{
  return ActualCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain((ActualCredentialStorage *)((char *)this - 8), a2, a3);
}

void `non-virtual thunk to'ActualCredentialStorage::setCredentialForProtectionSpace(ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  ActualCredentialStorage::setCredentialForProtectionSpace((ActualCredentialStorage *)((char *)this - 8), a2, a3);
}

uint64_t `non-virtual thunk to'ActualCredentialStorage::removeCredentialForProtectionSpace(ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  uint64_t result;

  (*(void (**)(_QWORD))(**((_QWORD **)this + 12) + 48))(*((_QWORD *)this + 12));
  result = *((_QWORD *)this + 13);
  if (result)
    return (*(uint64_t (**)(uint64_t, const _CFURLCredential *, _CFURLProtectionSpace *))(*(_QWORD *)result
                                                                                                 + 56))(result, a2, a3);
  return result;
}

uint64_t `non-virtual thunk to'ActualCredentialStorage::copyDefaultCredentialForProtectionSpace(ActualCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 12) + 56))(*((_QWORD *)this + 12));
  if (!result)
  {
    result = *((_QWORD *)this + 13);
    if (result)
      return (*(uint64_t (**)(uint64_t, _CFURLProtectionSpace *))(*(_QWORD *)result + 64))(result, a2);
  }
  return result;
}

uint64_t `non-virtual thunk to'ActualCredentialStorage::setDefaultCredentialForProtectionSpace(ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  return ActualCredentialStorage::setDefaultCredentialForProtectionSpace((ActualCredentialStorage *)((char *)this - 8), a2, a3);
}

uint64_t `non-virtual thunk to'ActualCredentialStorage::setUseSystemKeychain(ActualCredentialStorage *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 13);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 80))(result);
  return result;
}

uint64_t `non-virtual thunk to'ActualCredentialStorage::useSystemKeychain(ActualCredentialStorage *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 13);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 88))(result);
  return result;
}

CFTypeRef ActualCredentialStorage::mergeProtectionSpaceToNameToCredentialsDict(ActualCredentialStorage *this, CFTypeRef cf, CFTypeRef a3)
{
  unint64_t Count;
  const void **v7;
  unint64_t v8;
  const void **v9;
  unint64_t v10;
  const void **v11;
  unint64_t v12;
  const void **v13;
  const __CFAllocator *v14;
  __CFDictionary *Mutable;
  uint64_t i;
  uint64_t j;
  CFTypeRef v18;
  CFTypeRef v20;
  unint64_t v21;
  const void **v22;
  _BYTE v23[248];
  CFTypeRef v24;
  uint64_t v25;
  const void **v26;
  _BYTE v27[248];
  CFTypeRef v28;
  unint64_t v29;
  const void **v30;
  _BYTE v31[248];
  CFTypeRef v32;
  uint64_t v33;
  const void **v34;
  _BYTE v35[248];

  if (!cf)
  {
    v29 = 0;
    v28 = 0;
    v30 = (const void **)v31;
    v32 = 0;
    v33 = 0;
    v34 = (const void **)v35;
    goto LABEL_15;
  }
  v28 = CFRetain(cf);
  Count = CFDictionaryGetCount((CFDictionaryRef)cf);
  v29 = Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v30 = 0;
    goto LABEL_9;
  }
  if (Count > 0x1E)
  {
    v7 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
    v30 = v7;
    if (!v7)
      goto LABEL_9;
  }
  else
  {
    v7 = (const void **)v31;
    v30 = (const void **)v31;
  }
  CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, v7, 0);
LABEL_9:
  v32 = CFRetain(cf);
  v8 = CFDictionaryGetCount((CFDictionaryRef)cf);
  v33 = v8;
  if (v8 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v34 = 0;
    goto LABEL_15;
  }
  if (v8 > 0x1E)
  {
    v9 = (const void **)malloc_type_malloc(8 * v8, 0x89ED541CuLL);
    v34 = v9;
    if (!v9)
      goto LABEL_15;
  }
  else
  {
    v9 = (const void **)v35;
    v34 = (const void **)v35;
  }
  CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, 0, v9);
LABEL_15:
  if (!a3)
  {
    v20 = 0;
    v21 = 0;
    v22 = (const void **)v23;
    v24 = 0;
    v25 = 0;
    v26 = (const void **)v27;
    if (!v33)
      goto LABEL_43;
    goto LABEL_40;
  }
  v20 = CFRetain(a3);
  v10 = CFDictionaryGetCount((CFDictionaryRef)a3);
  v21 = v10;
  if (v10 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v22 = 0;
    goto LABEL_24;
  }
  if (v10 > 0x1E)
  {
    v11 = (const void **)malloc_type_malloc(8 * v10, 0x89ED541CuLL);
    v22 = v11;
    if (!v11)
      goto LABEL_24;
  }
  else
  {
    v11 = (const void **)v23;
    v22 = (const void **)v23;
  }
  CFDictionaryGetKeysAndValues((CFDictionaryRef)a3, v11, 0);
LABEL_24:
  v24 = CFRetain(a3);
  v12 = CFDictionaryGetCount((CFDictionaryRef)a3);
  v25 = v12;
  if (v12 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v26 = 0;
    goto LABEL_30;
  }
  if (v12 > 0x1E)
  {
    v13 = (const void **)malloc_type_malloc(8 * v12, 0x89ED541CuLL);
    v26 = v13;
    if (!v13)
      goto LABEL_30;
  }
  else
  {
    v13 = (const void **)v27;
    v26 = (const void **)v27;
  }
  CFDictionaryGetKeysAndValues((CFDictionaryRef)a3, 0, v13);
LABEL_30:
  if (!v33)
  {
LABEL_42:
    v18 = CFRetain(a3);
    goto LABEL_46;
  }
  if (!v25)
  {
LABEL_40:
    if (cf)
    {
      a3 = cf;
      goto LABEL_42;
    }
LABEL_43:
    v18 = 0;
    goto LABEL_46;
  }
  v14 = CFGetAllocator((char *)this - 16);
  Mutable = CFDictionaryCreateMutable(v14, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v33 >= 1)
  {
    for (i = 0; i < v33; ++i)
      CFDictionarySetValue(Mutable, v30[i], v34[i]);
  }
  if (v25 >= 1)
  {
    for (j = 0; j < v25; ++j)
      CFDictionarySetValue(Mutable, v22[j], v26[j]);
  }
  if (Mutable)
    v18 = CFRetain(Mutable);
  else
    v18 = 0;
  CFRelease(Mutable);
LABEL_46:
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v24);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v20);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v32);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v28);
  return v18;
}

void sub_183FF2FDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFContainerEnumeratorBase *v9;
  const void *v10;
  CFContainerEnumeratorBase *v11;

  CFRelease(v10);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v11);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&a9);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v9);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&STACK[0x220]);
  _Unwind_Resume(a1);
}

const __CFDictionary *MemoryCredentialStorage::copyCredentialsForProtectionSpace(CFDictionaryRef *this, _CFURLProtectionSpace *a2)
{
  const __CFDictionary *result;

  result = (const __CFDictionary *)CFDictionaryGetValue(this[5], a2);
  if (result)
    return CFDictionaryCreateCopy(this[1], result);
  return result;
}

CFDictionaryRef MemoryCredentialStorage::copyAllCredentials(CFAllocatorRef *this)
{
  return CFDictionaryCreateCopy(this[1], this[5]);
}

uint64_t MemoryCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain(MemoryCredentialStorage *this, const __CFString *a2)
{
  return (*(uint64_t (**)(MemoryCredentialStorage *))(*(_QWORD *)this + 24))(this);
}

void MemoryCredentialStorage::setCredentialForProtectionSpace(CFDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *key)
{
  _QWORD *v6;
  const void *v7;
  void *Value;

  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  if (a2)
    v6 = (_QWORD *)((char *)a2 + 16);
  else
    v6 = 0;
  v7 = (const void *)v6[7];
  if (v7 || (v7 = (const void *)(*(uint64_t (**)(_QWORD *))(*v6 + 104))(v6), (v6[7] = v7) != 0))
  {
    Value = (void *)CFDictionaryGetValue(this[5], key);
    if (!Value)
    {
      Value = CFDictionaryCreateMutable(this[1], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFDictionarySetValue(this[5], key, Value);
      if (Value)
        CFRelease(Value);
    }
    CFDictionarySetValue((CFMutableDictionaryRef)Value, v7, a2);
  }
}

void MemoryCredentialStorage::removeCredentialForProtectionSpace(CFDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *key)
{
  _QWORD *v6;
  const void *v7;
  __CFDictionary *Value;
  const __CFDictionary *v9;
  const void *v10;

  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  if (a2)
    v6 = (_QWORD *)((char *)a2 + 16);
  else
    v6 = 0;
  v7 = (const void *)v6[7];
  if (v7 || (v7 = (const void *)(*(uint64_t (**)(_QWORD *))(*v6 + 104))(v6), (v6[7] = v7) != 0))
  {
    Value = (__CFDictionary *)CFDictionaryGetValue(this[5], key);
    if (Value)
    {
      v9 = Value;
      CFDictionaryRemoveValue(Value, v7);
      if (!CFDictionaryGetCount(v9))
        CFDictionaryRemoveValue(this[5], key);
    }
    v10 = CFDictionaryGetValue(this[7], key);
    if (v10)
    {
      if (CFEqual(v10, v7))
        CFDictionaryRemoveValue(this[7], key);
    }
  }
}

CFTypeRef MemoryCredentialStorage::copyDefaultCredentialForProtectionSpace(CFDictionaryRef *this, _CFURLProtectionSpace *a2)
{
  const void *Value;
  const void *v5;
  const __CFDictionary *v6;
  const void *v7;

  Value = CFDictionaryGetValue(this[7], a2);
  if (Value
    && (v5 = Value,
        v6 = (const __CFDictionary *)CFDictionaryGetValue(this[5], a2),
        (v7 = CFDictionaryGetValue(v6, v5)) != 0))
  {
    return CFRetain(v7);
  }
  else
  {
    return 0;
  }
}

void MemoryCredentialStorage::setDefaultCredentialForProtectionSpace(CFMutableDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *key)
{
  const void *v6;

  if (a2)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1)
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
    v6 = (const void *)*((_QWORD *)a2 + 9);
    if (v6
      || (v6 = (const void *)(*(uint64_t (**)(char *))(*((_QWORD *)a2 + 2) + 104))((char *)a2 + 16),
          (*((_QWORD *)a2 + 9) = v6) != 0))
    {
      CFDictionarySetValue(this[7], key, v6);
    }
    (*((void (**)(CFMutableDictionaryRef *, const _CFURLCredential *, _CFURLProtectionSpace *))*this + 5))(this, a2, key);
  }
  else
  {
    CFDictionaryRemoveValue(this[7], key);
  }
}

void `non-virtual thunk to'MemoryCredentialStorage::~MemoryCredentialStorage(MemoryCredentialStorage *this)
{
  MemoryCredentialStorage::~MemoryCredentialStorage((MemoryCredentialStorage *)((char *)this - 16));
}

{
  MemoryCredentialStorage::~MemoryCredentialStorage((MemoryCredentialStorage *)((char *)this - 24));
}

void `non-virtual thunk to'MemoryCredentialStorage::~MemoryCredentialStorage(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 2;
  MemoryCredentialStorage::~MemoryCredentialStorage((MemoryCredentialStorage *)(this - 2));
  CFAllocatorDeallocate(*(this - 1), v2);
}

{
  CFAllocatorRef *v2;

  v2 = this - 3;
  MemoryCredentialStorage::~MemoryCredentialStorage((MemoryCredentialStorage *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

const __CFDictionary *`non-virtual thunk to'MemoryCredentialStorage::copyCredentialsForProtectionSpace(CFDictionaryRef *this, _CFURLProtectionSpace *a2)
{
  return MemoryCredentialStorage::copyCredentialsForProtectionSpace(this - 2, a2);
}

CFDictionaryRef `non-virtual thunk to'MemoryCredentialStorage::copyAllCredentials(CFAllocatorRef *this)
{
  return CFDictionaryCreateCopy(*(this - 1), this[3]);
}

uint64_t `non-virtual thunk to'MemoryCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain(MemoryCredentialStorage *this, const __CFString *a2)
{
  return (*(uint64_t (**)(char *))(*((_QWORD *)this - 2) + 24))((char *)this - 16);
}

void `non-virtual thunk to'MemoryCredentialStorage::setCredentialForProtectionSpace(CFDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  MemoryCredentialStorage::setCredentialForProtectionSpace(this - 2, a2, a3);
}

void `non-virtual thunk to'MemoryCredentialStorage::removeCredentialForProtectionSpace(CFDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  MemoryCredentialStorage::removeCredentialForProtectionSpace(this - 2, a2, a3);
}

CFTypeRef `non-virtual thunk to'MemoryCredentialStorage::copyDefaultCredentialForProtectionSpace(CFDictionaryRef *this, _CFURLProtectionSpace *a2)
{
  return MemoryCredentialStorage::copyDefaultCredentialForProtectionSpace(this - 2, a2);
}

void `non-virtual thunk to'MemoryCredentialStorage::setDefaultCredentialForProtectionSpace(CFMutableDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  MemoryCredentialStorage::setDefaultCredentialForProtectionSpace(this - 2, a2, a3);
}

uint64_t CredentialStorageBase::useSystemKeychain(CredentialStorageBase *this)
{
  return 0;
}

uint64_t RetainableTypedDict<_CFURLProtectionSpace *,__CFDictionary *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA3E8;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<_CFURLProtectionSpace *,__CFDictionary *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA3E8;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

uint64_t RetainableTypedDict<_CFURLProtectionSpace *,__CFString const*>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA408;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<_CFURLProtectionSpace *,__CFString const*>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA408;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

void sub_183FF36B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void PersistentCredentialStorage::~PersistentCredentialStorage(PersistentCredentialStorage *this)
{
  uint64_t v2;

  PersistentCredentialStorage::~PersistentCredentialStorage(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  const void *v2;

  *(_QWORD *)this = off_1E14EDDE0;
  *((_QWORD *)this + 2) = &unk_1E14EDE50;
  *((_QWORD *)this + 3) = &unk_1E14EDEB8;
  v2 = (const void *)*((_QWORD *)this + 4);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

__CFDictionary *PersistentCredentialStorage::copyCredentialsForProtectionSpace(PersistentCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  _CFURLProtectionSpace *v2;
  int v4;
  _QWORD *v5;
  const __CFAllocator *v7;
  uint64_t v8;
  __CFDictionary *MutableDictionary;
  CFDictionaryRef v10[7];

  v2 = a2;
  if (a2)
  {
    if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
      dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
    v2 = (_CFURLProtectionSpace *)((char *)v2 + 16);
  }
  v4 = *((_DWORD *)v2 + 14);
  if ((v4 - 8) < 5)
    return 0;
  if (v4 != 7)
  {
    StorageQuery::StorageQuery((StorageQuery *)v10, *((const __CFAllocator **)this + 1), (const URLProtectionSpace *)v2, *((_BYTE *)this + 40), *((const __CFString **)this + 4));
    if (StorageQuery::performQuery((StorageQuery *)v10))
      v5 = StorageQuery::copyNameAndCredsDictForProtectionSpace(v10, (const URLProtectionSpace *)v2);
    else
      v5 = 0;
    StorageQuery::~StorageQuery((StorageQuery *)v10);
    return (__CFDictionary *)v5;
  }
  v5 = (_QWORD *)PersistentCredentialStorage::copyIdentityCredentialForProtectionSpace(*((PersistentCredentialStorage **)this + 1), (const URLProtectionSpace *)v2);
  if (!v5)
    return (__CFDictionary *)v5;
  v7 = (const __CFAllocator *)*((_QWORD *)this + 1);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  v8 = v5[9];
  if (!v8)
  {
    v8 = (*(uint64_t (**)(_QWORD *))(v5[2] + 104))(v5 + 2);
    v5[9] = v8;
  }
  MutableDictionary = cfTypeCreateMutableDictionary(v7, v8, v5, 0, 0);
  CFRelease(v5);
  return MutableDictionary;
}

void sub_183FF3A4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  StorageQuery::~StorageQuery((StorageQuery *)va);
  _Unwind_Resume(a1);
}

CFTypeRef PersistentCredentialStorage::copyAllCredentials(PersistentCredentialStorage *this)
{
  CFTypeRef v1;
  _BYTE v3[16];
  CFTypeRef cf;

  StorageQuery::StorageQuery((StorageQuery *)v3, *((const __CFAllocator **)this + 1), 0, *((_BYTE *)this + 40), *((const __CFString **)this + 4));
  if (StorageQuery::performQuery((StorageQuery *)v3) && cf)
    v1 = CFRetain(cf);
  else
    v1 = 0;
  StorageQuery::~StorageQuery((StorageQuery *)v3);
  return v1;
}

void sub_183FF3AC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  StorageQuery::~StorageQuery((StorageQuery *)va);
  _Unwind_Resume(a1);
}

CFMutableDictionaryRef PersistentCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain(PersistentCredentialStorage *this, CFStringRef theString1, int a3)
{
  int v6;
  NSObject *v7;
  const void **v8;
  const void *v9;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  _BOOL4 v13;
  _BOOL4 v14;
  CFMutableDictionaryRef MutableCopy;
  uint8_t v17[8];
  CFMutableDictionaryRef theDict;
  CFTypeRef cf;
  char v20;

  if (theString1 && CFStringCompare(theString1, CFSTR("com.apple.cfnetwork"), 0) == kCFCompareEqualTo)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v7 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v17 = 0;
      _os_log_impl(&dword_183ECA000, v7, OS_LOG_TYPE_DEFAULT, "Enforcing strict auth scheme matching", v17, 2u);
    }
    v6 = 1;
  }
  else
  {
    v6 = 0;
  }
  v8 = (const void **)MEMORY[0x1E0CD70A8];
  if (a3)
  {
    StorageQuery::StorageQuery((StorageQuery *)v17, *((const __CFAllocator **)this + 1), 0, *((_BYTE *)this + 40), *((const __CFString **)this + 4));
    if (v6)
      v20 = 1;
    v9 = (const void *)*MEMORY[0x1E0C9AE40];
    CFDictionarySetValue(theDict, *v8, (const void *)*MEMORY[0x1E0C9AE40]);
    CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E0CD6B80], v9);
    if (StorageQuery::performQuery((StorageQuery *)v17) && cf)
      v10 = (const __CFDictionary *)CFRetain(cf);
    else
      v10 = 0;
    StorageQuery::~StorageQuery((StorageQuery *)v17);
  }
  else
  {
    v10 = 0;
  }
  StorageQuery::StorageQuery((StorageQuery *)v17, *((const __CFAllocator **)this + 1), 0, *((_BYTE *)this + 40), *((const __CFString **)this + 4));
  if (v6)
    v20 = 1;
  if (theString1)
  {
    CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E0CD6898], theString1);
    CFDictionarySetValue(theDict, *v8, (const void *)*MEMORY[0x1E0C9AE50]);
  }
  if (StorageQuery::performQuery((StorageQuery *)v17) && cf)
  {
    v11 = (const __CFDictionary *)CFRetain(cf);
    v12 = v11;
    v13 = v10 != 0;
    v14 = v11 != 0;
    if (v10 && v11)
    {
      MutableCopy = CFDictionaryCreateMutableCopy(*((CFAllocatorRef *)this + 1), 0, v10);
      if (MutableCopy)
        CFDictionaryApplyFunction(v12, (CFDictionaryApplierFunction)_merge_dictionaries, MutableCopy);
      CFRelease(v10);
      CFRelease(v12);
      goto LABEL_37;
    }
  }
  else
  {
    v14 = 0;
    v12 = 0;
    v13 = v10 != 0;
  }
  if (!v10 || (MutableCopy = v10, v14))
  {
    if (!v12)
      v13 = 1;
    if (v13)
      MutableCopy = 0;
    else
      MutableCopy = v12;
  }
LABEL_37:
  StorageQuery::~StorageQuery((StorageQuery *)v17);
  return MutableCopy;
}

void sub_183FF3D44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  StorageQuery::~StorageQuery((StorageQuery *)&a9);
  _Unwind_Resume(a1);
}

void PersistentCredentialStorage::setCredentialForProtectionSpace(PersistentCredentialStorage **this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  const URLCredential *v6;
  uint8_t v7[16];

  if (a2)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1)
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
    if (*((_DWORD *)a2 + 13) != 3
      && *((_DWORD *)a2 + 13) != 4
      && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v7 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "ephemeral credential in persistent store", v7, 2u);
    }
  }
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  if (*((_DWORD *)a3 + 18) == 7)
  {
    if (a2)
    {
      if (URLCredential::Class(void)::sOnce_URLCredential != -1)
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
      if (*((_DWORD *)a2 + 12) == 3)
        PersistentCredentialStorage::setIdentityCredentialForProtectionSpace(this[1], (const URLCredentialClientCertificate *)((char *)a2 + 16), (const URLProtectionSpace *)((char *)a3 + 16));
    }
  }
  else
  {
    if (a2)
    {
      if (URLCredential::Class(void)::sOnce_URLCredential != -1)
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
      v6 = (const URLCredential *)((char *)a2 + 16);
    }
    else
    {
      v6 = 0;
    }
    PersistentCredentialStorage::updateOrAddCredential((PersistentCredentialStorage *)this, v6, (const URLProtectionSpace *)((char *)a3 + 16), 0);
  }
}

void PersistentCredentialStorage::removeCredentialForProtectionSpace(PersistentCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  char *v6;
  const __CFString *v7;
  const __CFDictionary *v8;
  const __CFAllocator *v9;
  __CFDictionary *MutableCopy;
  const __CFString *v11;
  const __CFAllocator *v12;
  __CFDictionary *v13;
  int v14;
  int v15;
  NSObject *v16;
  _DWORD v17[2];
  __int16 v18;
  __CFDictionary *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
      dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
    v6 = (char *)a3 + 16;
  }
  else
  {
    v6 = 0;
  }
  v7 = (const __CFString *)*((_QWORD *)v6 + 4);
  if (v7 && CFStringGetLength(v7) > 0)
  {
    if (*((_DWORD *)v6 + 14) == 7)
    {
      PersistentCredentialStorage::removeIdentityPreferenceForProtectionSpace(*((PersistentCredentialStorage **)this + 1), (const URLProtectionSpace *)v6);
    }
    else if (a2)
    {
      if (URLCredential::Class(void)::sOnce_URLCredential != -1)
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
      if (!*((_DWORD *)a2 + 12))
      {
        v8 = (const __CFDictionary *)*((_QWORD *)a2 + 12);
        if (v8)
        {
          v9 = CFGetAllocator(a2);
          MutableCopy = CFDictionaryCreateMutableCopy(v9, 0, v8);
          updateAttrsWithValuesForModifyingStore(MutableCopy, (const URLProtectionSpace *)v6, (const URLCredential *)1, *((_QWORD *)this + 4), v11);
          v12 = CFGetAllocator(a2);
          v13 = CFDictionaryCreateMutableCopy(v12, 0, MutableCopy);
          CFDictionarySetValue(v13, (const void *)*MEMORY[0x1E0CD6C98], (const void *)*MEMORY[0x1E0CD6CB8]);
          if (*((_BYTE *)this + 40))
            setUseSystemKeychain(v13);
          v14 = off_1EDCF7EC8(v13);
          if (v14)
          {
            v15 = v14;
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v16 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
            {
              v17[0] = 67109378;
              v17[1] = v15;
              v18 = 2112;
              v19 = v13;
              _os_log_debug_impl(&dword_183ECA000, v16, OS_LOG_TYPE_DEBUG, "CredStore - removeCredForProtSpace - Error removing cred.  Error=%d, query=%@", (uint8_t *)v17, 0x12u);
            }
          }
          CFRelease(v13);
          CFRelease(MutableCopy);
        }
      }
    }
  }
  else
  {
    CFLog();
  }
}

CFTypeRef PersistentCredentialStorage::copyDefaultCredentialForProtectionSpace(PersistentCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  _CFURLProtectionSpace *v2;
  const void *Value;
  const __CFDictionary *v6;
  CFTypeRef v7;
  const void *v8;
  CFDictionaryRef v9[7];

  v2 = a2;
  if (a2)
  {
    if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
      dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
    v2 = (_CFURLProtectionSpace *)((char *)v2 + 16);
  }
  if (*((_DWORD *)v2 + 14) == 7)
    return (CFTypeRef)PersistentCredentialStorage::copyIdentityCredentialForProtectionSpace(*((PersistentCredentialStorage **)this + 1), (const URLProtectionSpace *)v2);
  StorageQuery::StorageQuery((StorageQuery *)v9, *((const __CFAllocator **)this + 1), (const URLProtectionSpace *)v2, *((_BYTE *)this + 40), *((const __CFString **)this + 4));
  if (!StorageQuery::performQuery((StorageQuery *)v9))
    goto LABEL_12;
  Value = CFDictionaryGetValue(v9[3], (char *)v2 - 16);
  if (!Value)
    goto LABEL_12;
  v6 = (const __CFDictionary *)StorageQuery::copyNameAndCredsDictForProtectionSpace(v9, (const URLProtectionSpace *)v2);
  v7 = v6;
  if (v6)
  {
    v8 = CFDictionaryGetValue(v6, Value);
    CFRelease(v7);
    if (v8)
    {
      v7 = CFRetain(v8);
      goto LABEL_13;
    }
LABEL_12:
    v7 = 0;
  }
LABEL_13:
  StorageQuery::~StorageQuery((StorageQuery *)v9);
  return v7;
}

void sub_183FF423C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  StorageQuery::~StorageQuery((StorageQuery *)va);
  _Unwind_Resume(a1);
}

void PersistentCredentialStorage::setDefaultCredentialForProtectionSpace(PersistentCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  const URLProtectionSpace *v6;
  uint64_t v7;
  const _CFURLCredential *v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;
  int v12;
  __CFDictionary *QueryFromProtectionSpaceAndCred;
  __CFDictionary *AttrsFromProtectionSpaceAndCred;
  int v15;
  int v16;
  NSObject *v17;
  _DWORD v18[2];
  __int16 v19;
  __CFDictionary *v20;
  __int16 v21;
  __CFDictionary *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1)
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
    if (*((_DWORD *)a2 + 13) != 3
      && *((_DWORD *)a2 + 13) != 4
      && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v18[0]) = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "ephemeral credential in persistent store", (uint8_t *)v18, 2u);
    }
  }
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  v6 = (const URLProtectionSpace *)((char *)a3 + 16);
  if (*((_DWORD *)a3 + 18) == 7)
  {
    if (a2)
    {
      if (URLCredential::Class(void)::sOnce_URLCredential != -1)
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
      if (*((_DWORD *)a2 + 12) == 3)
        PersistentCredentialStorage::setIdentityCredentialForProtectionSpace(*((PersistentCredentialStorage **)this + 1), (const URLCredentialClientCertificate *)((char *)a2 + 16), (const URLProtectionSpace *)((char *)a3 + 16));
    }
    else
    {
      PersistentCredentialStorage::removeIdentityPreferenceForProtectionSpace(*((PersistentCredentialStorage **)this + 1), (const URLProtectionSpace *)((char *)a3 + 16));
    }
    return;
  }
  v7 = (*(uint64_t (**)(PersistentCredentialStorage *, _CFURLProtectionSpace *))(*(_QWORD *)this + 64))(this, a3);
  if (!v7)
  {
    v12 = 1;
    if (!a2)
      return;
    goto LABEL_38;
  }
  v9 = v7;
  v10 = URLCredential_PasswordBased::safelyCast(v7, v8);
  if (v10)
  {
    v11 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 128))(v10);
    if (v11)
      CFRelease(v11);
  }
  if (a2 && CFEqual((CFTypeRef)v9, a2))
  {
    v12 = 0;
    goto LABEL_34;
  }
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  QueryFromProtectionSpaceAndCred = createQueryFromProtectionSpaceAndCred(*((const __CFAllocator **)this + 1), v6, (const URLCredential *)(v9 + 16), *((unsigned __int8 *)this + 40), *((const __CFString **)this + 4));
  AttrsFromProtectionSpaceAndCred = createAttrsFromProtectionSpaceAndCred(*((const __CFAllocator **)this + 1), v6, (const URLCredential *)(v9 + 16), 0);
  v15 = off_1EDCF7EC0(QueryFromProtectionSpaceAndCred, AttrsFromProtectionSpaceAndCred);
  if (v15)
  {
    v16 = v15;
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v17 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      v18[0] = 67109634;
      v18[1] = v16;
      v19 = 2112;
      v20 = QueryFromProtectionSpaceAndCred;
      v21 = 2112;
      v22 = AttrsFromProtectionSpaceAndCred;
      _os_log_debug_impl(&dword_183ECA000, v17, OS_LOG_TYPE_DEBUG, "CredStore - setDefaultCredForProtSpace - Error removing cred.  Error=%d, query=%@, attrs=%@", (uint8_t *)v18, 0x1Cu);
      if (!QueryFromProtectionSpaceAndCred)
        goto LABEL_31;
      goto LABEL_30;
    }
  }
  if (QueryFromProtectionSpaceAndCred)
LABEL_30:
    CFRelease(QueryFromProtectionSpaceAndCred);
LABEL_31:
  if (AttrsFromProtectionSpaceAndCred)
    CFRelease(AttrsFromProtectionSpaceAndCred);
  v12 = 1;
LABEL_34:
  CFRelease((CFTypeRef)v9);
  if (!a2)
    return;
LABEL_38:
  if (v12)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1)
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
    PersistentCredentialStorage::updateOrAddCredential(this, (const URLCredential *)((char *)a2 + 16), v6, 1);
  }
}

uint64_t PersistentCredentialStorage::setUseSystemKeychain(uint64_t this, char a2)
{
  *(_BYTE *)(this + 40) = a2;
  return this;
}

uint64_t PersistentCredentialStorage::useSystemKeychain(PersistentCredentialStorage *this)
{
  return *((unsigned __int8 *)this + 40);
}

void `non-virtual thunk to'PersistentCredentialStorage::~PersistentCredentialStorage(PersistentCredentialStorage *this)
{
  PersistentCredentialStorage::~PersistentCredentialStorage((PersistentCredentialStorage *)((char *)this - 16));
}

{
  PersistentCredentialStorage::~PersistentCredentialStorage((PersistentCredentialStorage *)((char *)this - 24));
}

void `non-virtual thunk to'PersistentCredentialStorage::~PersistentCredentialStorage(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 2;
  PersistentCredentialStorage::~PersistentCredentialStorage((PersistentCredentialStorage *)(this - 2));
  CFAllocatorDeallocate(*(this - 1), v2);
}

{
  CFAllocatorRef *v2;

  v2 = this - 3;
  PersistentCredentialStorage::~PersistentCredentialStorage((PersistentCredentialStorage *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

__CFDictionary *`non-virtual thunk to'PersistentCredentialStorage::copyCredentialsForProtectionSpace(PersistentCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  return PersistentCredentialStorage::copyCredentialsForProtectionSpace((PersistentCredentialStorage *)((char *)this - 16), a2);
}

CFTypeRef `non-virtual thunk to'PersistentCredentialStorage::copyAllCredentials(PersistentCredentialStorage *this)
{
  return PersistentCredentialStorage::copyAllCredentials((PersistentCredentialStorage *)((char *)this - 16));
}

CFMutableDictionaryRef `non-virtual thunk to'PersistentCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain(PersistentCredentialStorage *this, const __CFString *a2, int a3)
{
  return PersistentCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain((PersistentCredentialStorage *)((char *)this - 16), a2, a3);
}

void `non-virtual thunk to'PersistentCredentialStorage::setCredentialForProtectionSpace(PersistentCredentialStorage **this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  PersistentCredentialStorage::setCredentialForProtectionSpace(this - 2, a2, a3);
}

void `non-virtual thunk to'PersistentCredentialStorage::removeCredentialForProtectionSpace(PersistentCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  PersistentCredentialStorage::removeCredentialForProtectionSpace((PersistentCredentialStorage *)((char *)this - 16), a2, a3);
}

CFTypeRef `non-virtual thunk to'PersistentCredentialStorage::copyDefaultCredentialForProtectionSpace(PersistentCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  return PersistentCredentialStorage::copyDefaultCredentialForProtectionSpace((PersistentCredentialStorage *)((char *)this - 16), a2);
}

void `non-virtual thunk to'PersistentCredentialStorage::setDefaultCredentialForProtectionSpace(PersistentCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  PersistentCredentialStorage::setDefaultCredentialForProtectionSpace((PersistentCredentialStorage *)((char *)this - 16), a2, a3);
}

uint64_t `non-virtual thunk to'PersistentCredentialStorage::setUseSystemKeychain(uint64_t this, char a2)
{
  *(_BYTE *)(this + 24) = a2;
  return this;
}

uint64_t `non-virtual thunk to'PersistentCredentialStorage::useSystemKeychain(PersistentCredentialStorage *this)
{
  return *((unsigned __int8 *)this + 24);
}

void sub_183FF46C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void PersistentCredentialStorage::removeIdentityPreferenceForProtectionSpace(PersistentCredentialStorage *this, const URLProtectionSpace *a2)
{
  __CFDictionary *Mutable;
  CFStringRef v4;
  int v5;
  int v6;
  NSObject *v7;
  _DWORD v8[2];
  __int16 v9;
  __CFDictionary *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  Mutable = CFDictionaryCreateMutable(this, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v4 = URLProtectionSpace::copyNameForIdentityPreference(a2);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD6A90], v4);
  CFRelease(v4);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD6C98], (const void *)*MEMORY[0x1E0CD6CB0]);
  v5 = off_1EDCF7EC8(Mutable);
  if (v5)
  {
    v6 = v5;
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v7 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      v8[0] = 67109378;
      v8[1] = v6;
      v9 = 2112;
      v10 = Mutable;
      _os_log_debug_impl(&dword_183ECA000, v7, OS_LOG_TYPE_DEBUG, "CredStore - removeIdentityPref - Error removing Identity prefs.  Error=%d, query=%@", (uint8_t *)v8, 0x12u);
    }
  }
  CFRelease(Mutable);
}

void PersistentCredentialStorage::setIdentityCredentialForProtectionSpace(PersistentCredentialStorage *this, const URLCredentialClientCertificate *a2, const URLProtectionSpace *a3)
{
  __CFDictionary *Mutable;
  CFStringRef v6;
  const void *v7;
  const void *v8;
  int v9;
  int v10;
  NSObject *v11;
  _DWORD v12[2];
  __int16 v13;
  __CFDictionary *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  Mutable = CFDictionaryCreateMutable(this, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v6 = URLProtectionSpace::copyNameForIdentityPreference(a3);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD6A90], v6);
  CFRelease(v6);
  v7 = (const void *)*MEMORY[0x1E0CD70E8];
  v8 = (const void *)(*(uint64_t (**)(const URLCredentialClientCertificate *))(*(_QWORD *)a2 + 120))(a2);
  CFDictionarySetValue(Mutable, v7, v8);
  v9 = off_1EDCF7EB8(Mutable, 0);
  if (v9)
  {
    v10 = v9;
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v11 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      v12[0] = 67109378;
      v12[1] = v10;
      v13 = 2112;
      v14 = Mutable;
      _os_log_debug_impl(&dword_183ECA000, v11, OS_LOG_TYPE_DEBUG, "CredStore - setIdentityCred - Error adding cred.  Error=%d, attrs=%@", (uint8_t *)v12, 0x12u);
    }
  }
  CFRelease(Mutable);
}

__CFDictionary *createQueryFromProtectionSpaceAndCred(const __CFAllocator *a1, const URLProtectionSpace *a2, const URLCredential *a3, int a4, const __CFString *a5)
{
  __CFDictionary *Mutable;
  const void *v11;
  const void *v12;
  CFStringRef v13;
  const void *SecAttrProtocol;
  CFTypeID v15;
  const void *v16;
  CFTypeID v17;
  const void *v18;
  CFTypeID v19;
  CFTypeID TypeID;
  int v21;
  unsigned int v22;
  const void **v23;
  void (**v25)(AutoScalar *__hidden);
  void *value;

  Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v11 = (const void *)*MEMORY[0x1E0CD6AC8];
  AutoScalar::AutoScalar((AutoScalar *)&v25, (const __CFAllocator *)*((unsigned int *)a2 + 10));
  CFDictionarySetValue(Mutable, v11, value);
  v25 = &off_1E14E47E8;
  if (value)
    CFRelease(value);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD6C98], (const void *)*MEMORY[0x1E0CD6CB8]);
  v12 = (const void *)*((_QWORD *)a2 + 4);
  if (a5)
  {
    v13 = CFStringCreateWithFormat(a1, 0, CFSTR("%@ (%@)"), *((_QWORD *)a2 + 4), a5, v25);
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD6B50], v13);
    CFRelease(v13);
  }
  else
  {
    TypeID = CFStringGetTypeID();
    if (v12 && CFGetTypeID(v12) == TypeID)
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD6B50], v12);
  }
  SecAttrProtocol = (const void *)URLProtectionSpace::getSecAttrProtocol((URLProtectionSpace *)*((unsigned int *)a2 + 11));
  v15 = CFStringGetTypeID();
  if (SecAttrProtocol && CFGetTypeID(SecAttrProtocol) == v15)
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD6AD0], SecAttrProtocol);
  if (*((_DWORD *)a3 + 9) == 4)
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD6B80], (const void *)*MEMORY[0x1E0C9AE50]);
  if ((*((_DWORD *)a2 + 11) - 9) <= 0xFFFFFFFB)
  {
    v16 = (const void *)*((_QWORD *)a2 + 6);
    v17 = CFStringGetTypeID();
    if (v16 && CFGetTypeID(v16) == v17)
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD6B40], v16);
    v18 = (const void *)*((_QWORD *)a3 + 7);
    if (v18)
    {
      v19 = CFStringGetTypeID();
    }
    else
    {
      v18 = (const void *)(*(uint64_t (**)(const URLCredential *))(*(_QWORD *)a3 + 104))(a3);
      *((_QWORD *)a3 + 7) = v18;
      v19 = CFStringGetTypeID();
      if (!v18)
        goto LABEL_22;
    }
    if (CFGetTypeID(v18) == v19)
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD68F8], v18);
  }
LABEL_22:
  v21 = *((_DWORD *)a2 + 14);
  if (v21 == 4)
  {
    v23 = (const void **)MEMORY[0x1E0CD6920];
  }
  else if (v21 == 2 && (v22 = *((_DWORD *)a2 + 11) - 1, v22 < 6))
  {
    v23 = (const void **)qword_1E14F6C28[v22];
  }
  else
  {
    v23 = (const void **)MEMORY[0x1E0CD6918];
  }
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD6910], *v23);
  if (a4)
    setUseSystemKeychain(Mutable);
  return Mutable;
}

void sub_183FF4C78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

__CFDictionary *createAttrsFromProtectionSpaceAndCred(const __CFAllocator *a1, const URLProtectionSpace *a2, const URLCredential *a3, int a4)
{
  __CFDictionary *Mutable;
  const __CFString *v9;
  CFTypeID TypeID;
  const void *v11;
  CFTypeID v12;
  const _CFURLCredential *v13;
  uint64_t v14;
  const __CFString *v15;
  const __CFString *v16;
  CFDataRef v17;
  CFTypeID v18;
  const void *v19;
  const __CFString *v20;
  const __CFString *v21;
  CFStringRef v22;
  CFStringRef v23;
  CFTypeID v24;
  const __CFDictionary *v26;
  const void *v27;
  const void *Value;
  CFIndex v29;
  void *ptr;
  UInt8 v31[1024];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (a4)
    v9 = CFSTR("default");
  else
    v9 = &stru_1E1500C68;
  TypeID = CFStringGetTypeID();
  if (CFGetTypeID(v9) == TypeID)
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD6988], v9);
  v11 = (const void *)*((_QWORD *)a3 + 7);
  if (v11)
  {
    v12 = CFStringGetTypeID();
  }
  else
  {
    v11 = (const void *)(*(uint64_t (**)(const URLCredential *))(*(_QWORD *)a3 + 104))(a3);
    *((_QWORD *)a3 + 7) = v11;
    v12 = CFStringGetTypeID();
    if (!v11)
      goto LABEL_11;
  }
  if (CFGetTypeID(v11) == v12)
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD68F8], v11);
LABEL_11:
  v14 = URLCredential_PasswordBased::safelyCast((uint64_t)a3 - 16, v13);
  if (v14)
  {
    v15 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 128))(v14);
    if (v15)
    {
      v16 = v15;
      v29 = 1023;
      ptr = _CFStringGetOrCreateCString(a1, v15, v31, &v29, 0x8000100u);
      v17 = CFDataCreate(a1, (const UInt8 *)ptr, v29);
      if (v17)
      {
        v18 = CFDataGetTypeID();
        if (CFGetTypeID(v17) == v18)
          CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD70D8], v17);
        CFRelease(v17);
      }
      CFRelease(v16);
      if (ptr && v31 != ptr)
        CFAllocatorDeallocate(a1, ptr);
    }
  }
  v19 = (const void *)*((_QWORD *)a2 + 4);
  v20 = (const __CFString *)*((_QWORD *)a3 + 7);
  if ((v20
     || (v20 = (const __CFString *)(*(uint64_t (**)(const URLCredential *))(*(_QWORD *)a3 + 104))(a3),
         (*((_QWORD *)a3 + 7) = v20) != 0))
    && CFStringGetLength(v20))
  {
    if (__CFNGetCFNetworkBundle::onceToken != -1)
      dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_4752);
    v21 = CFBundleCopyLocalizedString((CFBundleRef)__CFNGetCFNetworkBundle::bundle, CFSTR("KEYCHAIN_LABEL_FORMAT%@%@"), CFSTR("%@ (%@)"), 0);
    v22 = CFStringCreateWithFormat(a1, 0, v21, v19, v20);
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD6A90], v22);
    if (v21)
      CFRelease(v21);
    CFRelease(v22);
  }
  else
  {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD6A90], v19);
  }
  if (*((_DWORD *)a2 + 14) == 4)
  {
    if (__CFNGetCFNetworkBundle::onceToken != -1)
      dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_4752);
    v23 = CFBundleCopyLocalizedString((CFBundleRef)__CFNGetCFNetworkBundle::bundle, CFSTR("KEYCHAIN_WEB_FORM_PASSWORD"), CFSTR("Web form password"), 0);
    v24 = CFStringGetTypeID();
    if (v23)
    {
      if (CFGetTypeID(v23) == v24)
        CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD69A0], v23);
      CFRelease(v23);
    }
  }
  if (*((_DWORD *)a3 + 9) == 4)
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD6B80], (const void *)*MEMORY[0x1E0C9AE50]);
  if (!*((_DWORD *)a3 + 8))
  {
    v26 = (const __CFDictionary *)*((_QWORD *)a3 + 10);
    if (v26)
    {
      v27 = (const void *)*MEMORY[0x1E0CD6998];
      if (CFDictionaryGetValue(v26, (const void *)*MEMORY[0x1E0CD6998]))
      {
        Value = CFDictionaryGetValue(*((CFDictionaryRef *)a3 + 10), v27);
        CFDictionarySetValue(Mutable, v27, Value);
      }
    }
  }
  return Mutable;
}

void sub_183FF5080(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFAllocatorRef allocator, uint64_t a12, void *ptr)
{
  void *v13;

  if (ptr)
  {
    if (v13 != ptr)
      CFAllocatorDeallocate(allocator, ptr);
  }
  _Unwind_Resume(exception_object);
}

void PersistentCredentialStorage::updateOrAddCredential(PersistentCredentialStorage *this, const URLCredential *a2, const URLProtectionSpace *a3, int a4)
{
  __CFDictionary *QueryFromProtectionSpaceAndCred;
  __CFDictionary *AttrsFromProtectionSpaceAndCred;
  int v10;
  int v11;
  NSObject *v12;
  const __CFString *v13;
  int v14;
  int v15;
  NSObject *v16;
  int v17;
  int v18;
  __int16 v19;
  __CFDictionary *v20;
  __int16 v21;
  __CFDictionary *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  QueryFromProtectionSpaceAndCred = createQueryFromProtectionSpaceAndCred(*((const __CFAllocator **)this + 1), a3, a2, *((unsigned __int8 *)this + 40), *((const __CFString **)this + 4));
  AttrsFromProtectionSpaceAndCred = createAttrsFromProtectionSpaceAndCred(*((const __CFAllocator **)this + 1), a3, a2, a4);
  v10 = off_1EDCF7EC0(QueryFromProtectionSpaceAndCred, AttrsFromProtectionSpaceAndCred);
  if (!v10)
    goto LABEL_12;
  v11 = v10;
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v12 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    v17 = 67109634;
    v18 = v11;
    v19 = 2112;
    v20 = QueryFromProtectionSpaceAndCred;
    v21 = 2112;
    v22 = AttrsFromProtectionSpaceAndCred;
    _os_log_debug_impl(&dword_183ECA000, v12, OS_LOG_TYPE_DEBUG, "CredStore - updateOrAddCredential - Error update cred.  Error=%d, query=%@, attrs=%@", (uint8_t *)&v17, 0x1Cu);
  }
  updateAttrsWithValuesForModifyingStore(AttrsFromProtectionSpaceAndCred, a3, 0, *((_QWORD *)this + 4), v13);
  if (*((_BYTE *)this + 40))
    setUseSystemKeychain(AttrsFromProtectionSpaceAndCred);
  v14 = off_1EDCF7EB8(AttrsFromProtectionSpaceAndCred, 0);
  if (!v14)
    goto LABEL_12;
  v15 = v14;
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v16 = CFNLog::logger;
  if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
LABEL_12:
    if (!QueryFromProtectionSpaceAndCred)
      goto LABEL_14;
    goto LABEL_13;
  }
  v17 = 67109378;
  v18 = v15;
  v19 = 2112;
  v20 = AttrsFromProtectionSpaceAndCred;
  _os_log_debug_impl(&dword_183ECA000, v16, OS_LOG_TYPE_DEBUG, "CredStore - updateOrAddCredential - Error add cred.  Error=%d, attrs=%@", (uint8_t *)&v17, 0x12u);
  if (QueryFromProtectionSpaceAndCred)
LABEL_13:
    CFRelease(QueryFromProtectionSpaceAndCred);
LABEL_14:
  if (AttrsFromProtectionSpaceAndCred)
    CFRelease(AttrsFromProtectionSpaceAndCred);
}

void updateAttrsWithValuesForModifyingStore(__CFDictionary *a1, const URLProtectionSpace *a2, const URLCredential *a3, uint64_t a4, const __CFString *a5)
{
  char v6;
  const void *v9;
  CFStringRef v10;
  const void *v11;
  int v12;
  const void *v13;
  const void *v14;
  __CFDictionary *v15;
  CFTypeID TypeID;
  unsigned int v17;
  const void **v18;
  const void *v19;
  CFTypeID v20;
  const void *SecAttrProtocol;
  CFTypeID v22;
  CFTypeID v23;
  void (**v24)(AutoScalar *__hidden);
  void *value;

  v6 = (char)a3;
  CFDictionarySetValue(a1, (const void *)*MEMORY[0x1E0CD6C98], (const void *)*MEMORY[0x1E0CD6CB8]);
  v9 = (const void *)*((_QWORD *)a2 + 4);
  if (a4)
  {
    v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@ (%@)"), *((_QWORD *)a2 + 4), a4);
    CFDictionarySetValue(a1, (const void *)*MEMORY[0x1E0CD6B50], v10);
    CFRelease(v10);
  }
  else
  {
    TypeID = CFStringGetTypeID();
    if (v9 && CFGetTypeID(v9) == TypeID)
      CFDictionarySetValue(a1, (const void *)*MEMORY[0x1E0CD6B50], v9);
  }
  v11 = (const void *)*MEMORY[0x1E0CD6AC8];
  AutoScalar::AutoScalar((AutoScalar *)&v24, (const __CFAllocator *)*((unsigned int *)a2 + 10));
  CFDictionarySetValue(a1, v11, value);
  v24 = &off_1E14E47E8;
  if (value)
    CFRelease(value);
  v12 = *((_DWORD *)a2 + 14);
  if (v12 != 2)
  {
    if (v12 == 4)
    {
      v13 = (const void *)*MEMORY[0x1E0CD6910];
      v14 = (const void *)*MEMORY[0x1E0CD6920];
      v15 = a1;
LABEL_17:
      CFDictionarySetValue(v15, v13, v14);
      goto LABEL_18;
    }
    goto LABEL_13;
  }
  v17 = *((_DWORD *)a2 + 11) - 1;
  if (v17 > 5)
  {
LABEL_13:
    v18 = (const void **)MEMORY[0x1E0CD6918];
    goto LABEL_14;
  }
  v18 = (const void **)qword_1E14F6C28[v17];
LABEL_14:
  CFDictionarySetValue(a1, (const void *)*MEMORY[0x1E0CD6910], *v18);
  v19 = (const void *)*((_QWORD *)a2 + 6);
  v20 = CFStringGetTypeID();
  if (v19 && CFGetTypeID(v19) == v20)
  {
    v13 = (const void *)*MEMORY[0x1E0CD6B40];
    v15 = a1;
    v14 = v19;
    goto LABEL_17;
  }
LABEL_18:
  SecAttrProtocol = (const void *)URLProtectionSpace::getSecAttrProtocol((URLProtectionSpace *)*((unsigned int *)a2 + 11));
  v22 = CFStringGetTypeID();
  if (SecAttrProtocol && CFGetTypeID(SecAttrProtocol) == v22)
    CFDictionarySetValue(a1, (const void *)*MEMORY[0x1E0CD6AD0], SecAttrProtocol);
  if ((v6 & 1) == 0)
  {
    v23 = CFStringGetTypeID();
    if (CFGetTypeID(&stru_1E1500C68) == v23)
      CFDictionarySetValue(a1, (const void *)*MEMORY[0x1E0CD6AC0], &stru_1E1500C68);
  }
  CFDictionaryRemoveValue(a1, (const void *)*MEMORY[0x1E0CD6998]);
}

void sub_183FF5530(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void setUseSystemKeychain(CFMutableDictionaryRef theDict)
{
  if (URLCredentialStorageUtilities::isSystemKeychainSupported(void)::onceToken != -1)
    dispatch_once(&URLCredentialStorageUtilities::isSystemKeychainSupported(void)::onceToken, &__block_literal_global_1164);
  if (URLCredentialStorageUtilities::isSystemKeychainSupported(void)::isMultiUser)
    CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E0CD70C0], (const void *)*MEMORY[0x1E0C9AE50]);
}

uint64_t PersistentCredentialStorage::copyIdentityCredentialForProtectionSpace(PersistentCredentialStorage *this, const URLProtectionSpace *a2)
{
  __CFDictionary *Mutable;
  CFStringRef v4;
  int v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  CFTypeID v10;
  CFTypeRef cf;
  uint8_t buf[4];
  int v13;
  __int16 v14;
  __CFDictionary *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  Mutable = CFDictionaryCreateMutable(this, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v4 = URLProtectionSpace::copyNameForIdentityPreference(a2);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD6A90], v4);
  CFRelease(v4);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD7028], (const void *)*MEMORY[0x1E0C9AE50]);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CD6C98], (const void *)*MEMORY[0x1E0CD6CB0]);
  cf = 0;
  v5 = (*((uint64_t (**)(__CFDictionary *, CFTypeRef *))&_gFwStubs + 1))(Mutable, &cf);
  if (v5)
  {
    v6 = v5;
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v7 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67109378;
      v13 = v6;
      v14 = 2112;
      v15 = Mutable;
      _os_log_debug_impl(&dword_183ECA000, v7, OS_LOG_TYPE_DEBUG, "CredStore - copyIdentPrefs - Error copying Identity cred.  Error=%d, query=%@", buf, 0x12u);
    }
    goto LABEL_6;
  }
  if (!cf)
  {
LABEL_6:
    v8 = 0;
    goto LABEL_7;
  }
  v10 = CFGetTypeID(cf);
  if (v10 != SecIdentityGetTypeID())
  {
    if (cf)
      CFRelease(cf);
    goto LABEL_6;
  }
  v8 = CFURLCredentialCreateWithIdentityAndCertificateArray(*MEMORY[0x1E0C9AE00], cf, 0, 3);
  if (cf)
    CFRelease(cf);
LABEL_7:
  CFRelease(Mutable);
  return v8;
}

void StorageQuery::StorageQuery(StorageQuery *this, const __CFAllocator *a2, const URLProtectionSpace *a3, char a4, const __CFString *a5)
{
  CFMutableDictionaryRef Mutable;
  const void *v10;
  CFStringRef v11;
  const void *SecAttrProtocol;
  const void *v13;
  int v14;
  const void **v15;
  const void **v16;
  unsigned int v17;

  *((_BYTE *)this + 49) = a4;
  *(_QWORD *)this = &off_1E14E6598;
  *((_BYTE *)this + 50) = 0;
  *((_QWORD *)this + 1) = cfTypeCreateMutableDictionary(a2, *MEMORY[0x1E0CD6F30], *MEMORY[0x1E0CD6F38], 0, 0);
  *((_QWORD *)this + 2) = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  Mutable = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *((_QWORD *)this + 4) = a2;
  *((_QWORD *)this + 5) = a5;
  *((_QWORD *)this + 3) = Mutable;
  *((_BYTE *)this + 48) = 0;
  if (!a3)
    goto LABEL_17;
  v10 = (const void *)*((_QWORD *)a3 + 4);
  if (a5)
  {
    v11 = CFStringCreateWithFormat(a2, 0, CFSTR("%@ (%@)"), *((_QWORD *)a3 + 4), a5);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x1E0CD6B50], v11);
    CFRelease(v11);
  }
  else if (v10)
  {
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x1E0CD6B50], v10);
  }
  SecAttrProtocol = (const void *)URLProtectionSpace::getSecAttrProtocol((URLProtectionSpace *)*((unsigned int *)a3 + 11));
  if (SecAttrProtocol)
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x1E0CD6AD0], SecAttrProtocol);
  v13 = (const void *)*((_QWORD *)a3 + 6);
  if (v13)
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x1E0CD6B40], v13);
  v14 = *((_DWORD *)a3 + 14);
  if (v14 == 2)
  {
    v17 = *((_DWORD *)a3 + 11);
    if (v17 <= 6 && ((1 << v17) & 0x62) != 0)
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x1E0CD6910], (const void *)*MEMORY[0x1E0CD6928]);
    goto LABEL_17;
  }
  if (v14 != 8)
  {
    if (v14 == 7)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x1E0CD6C98], (const void *)*MEMORY[0x1E0CD6CB0]);
      v15 = (const void **)MEMORY[0x1E0C9AE50];
      v16 = (const void **)MEMORY[0x1E0CD7028];
LABEL_18:
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), *v16, *v15);
      goto LABEL_19;
    }
LABEL_17:
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x1E0CD7010], (const void *)*MEMORY[0x1E0C9AE50]);
    v15 = (const void **)MEMORY[0x1E0CD6CB8];
    v16 = (const void **)MEMORY[0x1E0CD6C98];
    goto LABEL_18;
  }
  *((_BYTE *)this + 48) = 1;
LABEL_19:
  CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x1E0CD6B80], (const void *)*MEMORY[0x1E0CD6B88]);
  if (*((_BYTE *)this + 49))
    setUseSystemKeychain(*((CFMutableDictionaryRef *)this + 1));
}

void sub_183FF5A30(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t StorageQuery::performQuery(StorageQuery *this)
{
  int v1;
  BOOL v2;
  NSObject *v4;
  uint64_t result;
  CFIndex Count;
  CFIndex v7;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *MutableCopy;
  const __CFDictionary *v10;
  const __CFString *Value;
  const __CFString *v12;
  CFTypeID v13;
  CFIndex location;
  CFIndex v15;
  uint64_t v16;
  CFStringRef v17;
  uint64_t Instance;
  char v19;
  uint64_t v20;
  const void **v21;
  const __CFNumber *v22;
  CFTypeRef v23;
  int v24;
  CFStringRef v25;
  CFTypeRef v26;
  int v27;
  CFStringRef v28;
  const __CFString *v29;
  int v30;
  const void *v31;
  const void *v32;
  CFTypeID v33;
  const __CFData *v34;
  const __CFData *v35;
  CFTypeID v36;
  const __CFAllocator *v37;
  const void *v38;
  const __CFDictionary *v39;
  uint64_t (***v40)(URLCredentialInternetPassword *__hidden, const CFObject *);
  uint64_t v41;
  const __CFBoolean *v42;
  uint64_t v43;
  __CFDictionary *v44;
  uint64_t (**v45)(URLCredentialInternetPassword *__hidden, const CFObject *);
  uint64_t (**v46)(URLCredentialInternetPassword *__hidden, const CFObject *);
  CFMutableDictionaryRef Mutable;
  uint64_t (**v48)(URLCredentialInternetPassword *__hidden, const CFObject *);
  uint64_t (**v49)(URLCredentialInternetPassword *__hidden, const CFObject *);
  uint64_t v50;
  CFTypeRef v51;
  CFTypeRef v52;
  CFTypeRef v53;
  CFTypeRef v54;
  CFTypeRef v55;
  CFTypeRef v56;
  CFTypeRef v57;
  CFTypeRef v58;
  CFTypeRef v59;
  void *v60;
  CFTypeRef v61;
  void *v62;
  CFTypeRef v63;
  CFTypeRef v64;
  void *v65;
  CFTypeRef cf2;
  _BOOL4 v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  CFIndex v73;
  void *key;
  CFTypeRef cf;
  CFNumberRef number[2];
  CFTypeRef cf1[2];
  CFStringRef theString[3];
  uint64_t valuePtr;
  uint8_t buf[8];
  _BYTE v82[10];
  uint64_t v83;
  CFTypeID TypeID;
  char v85;
  uint64_t v86;
  CFTypeID v87;
  char v88;
  uint64_t v89;
  CFTypeID v90;
  char v91;
  uint64_t v92;
  CFTypeID v93;
  char v94;
  uint64_t v95;
  CFTypeID v96;
  char v97;
  uint64_t v98;
  CFRange v99;
  CFRange v100;

  v98 = *MEMORY[0x1E0C80C00];
  cf = 0;
  v1 = (*((uint64_t (**)(_QWORD, CFTypeRef *))&_gFwStubs + 1))(*((_QWORD *)this + 1), &cf);
  if (*((_BYTE *)this + 48))
    v2 = 0;
  else
    v2 = v1 == 0;
  if (!v2 || cf == 0)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v4 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      v50 = *((_QWORD *)this + 1);
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v1;
      *(_WORD *)v82 = 2112;
      *(_QWORD *)&v82[2] = v50;
      _os_log_debug_impl(&dword_183ECA000, v4, OS_LOG_TYPE_DEBUG, "CredStore - performQuery - Error copying matching creds.  Error=%d, query=%@", buf, 0x12u);
    }
    result = (uint64_t)cf;
    if (cf)
    {
      CFRelease(cf);
      return 0;
    }
  }
  else
  {
    Count = CFArrayGetCount((CFArrayRef)cf);
    v73 = Count;
    if (Count >= 1)
    {
      v7 = 0;
      key = (void *)*MEMORY[0x1E0CD6B50];
      v72 = *MEMORY[0x1E0CD6AC8];
      v71 = *MEMORY[0x1E0CD6AD0];
      v70 = *MEMORY[0x1E0CD6910];
      v69 = *MEMORY[0x1E0CD6B40];
      v68 = *MEMORY[0x1E0CD6988];
      cf2 = (CFTypeRef)*MEMORY[0x1E0CD6AF0];
      v63 = (CFTypeRef)*MEMORY[0x1E0CD6B00];
      v59 = (CFTypeRef)*MEMORY[0x1E0CD6AD8];
      v57 = (CFTypeRef)*MEMORY[0x1E0CD6AE8];
      v55 = (CFTypeRef)*MEMORY[0x1E0CD6AF8];
      v53 = (CFTypeRef)*MEMORY[0x1E0CD6B08];
      v52 = (CFTypeRef)*MEMORY[0x1E0CD6AE0];
      v51 = (CFTypeRef)*MEMORY[0x1E0CD6B20];
      v64 = (CFTypeRef)*MEMORY[0x1E0CD6918];
      v61 = (CFTypeRef)*MEMORY[0x1E0CD6928];
      v58 = (CFTypeRef)*MEMORY[0x1E0CD6930];
      v56 = (CFTypeRef)*MEMORY[0x1E0CD6920];
      v54 = (CFTypeRef)*MEMORY[0x1E0CD6938];
      v65 = (void *)*MEMORY[0x1E0CD68F8];
      v62 = (void *)*MEMORY[0x1E0CD70D8];
      v60 = (void *)*MEMORY[0x1E0CD6B80];
      while (1)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)cf, v7);
        if (ValueAtIndex)
        {
          MutableCopy = CFDictionaryCreateMutableCopy(0, 0, ValueAtIndex);
          v10 = MutableCopy;
          if (MutableCopy)
          {
            Value = (const __CFString *)CFDictionaryGetValue(MutableCopy, key);
            v12 = Value;
            if (Value && (v13 = CFGetTypeID(Value), v13 == CFStringGetTypeID()))
            {
              location = CFStringFind(v12, CFSTR(" "), 0).location;
              v15 = location;
              if (*((_QWORD *)this + 5))
              {
                if (location == -1)
                  goto LABEL_114;
                v16 = CFStringGetLength(v12) - location;
                if (v16 < 4)
                  goto LABEL_114;
                v99.length = v16 - 3;
                v99.location = v15 + 2;
                v17 = CFStringCreateWithSubstring(*((CFAllocatorRef *)this + 4), v12, v99);
                if (!v17)
                  goto LABEL_114;
                if (CFStringCompare(*((CFStringRef *)this + 5), v17, 0))
                {
                  CFRelease(v17);
LABEL_114:
                  CFRelease(v10);
                  goto LABEL_115;
                }
                v100.location = 0;
                v100.length = v15;
                v25 = CFStringCreateWithSubstring(*((CFAllocatorRef *)this + 4), v12, v100);
                CFDictionarySetValue(v10, key, v25);
                if (v25)
                  CFRelease(v25);
                CFRelease(v17);
              }
              else if (location != -1)
              {
                goto LABEL_114;
              }
            }
            else if (*((_QWORD *)this + 5))
            {
              goto LABEL_114;
            }
          }
        }
        else
        {
          v10 = 0;
        }
        if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
          dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
        Instance = _CFRuntimeCreateInstance();
        *(_OWORD *)(Instance + 16) = 0u;
        *(_OWORD *)(Instance + 80) = 0u;
        *(_OWORD *)(Instance + 96) = 0u;
        *(_QWORD *)(Instance + 112) = 0;
        *(_OWORD *)(Instance + 48) = 0u;
        *(_OWORD *)(Instance + 64) = 0u;
        *(_OWORD *)(Instance + 32) = 0u;
        *(_QWORD *)(Instance + 16) = &off_1E14E9A20;
        *(_QWORD *)(Instance + 24) = &unk_1E14E9A78;
        *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3759];
        *(_BYTE *)(Instance + 96) = 0;
        *(_BYTE *)(Instance + 104) = 0;
        *(_QWORD *)(Instance + 112) = 1;
        v19 = *((_BYTE *)this + 50);
        *(_OWORD *)cf1 = 0u;
        *(_OWORD *)theString = 0u;
        *(_OWORD *)number = 0u;
        *(_QWORD *)buf = key;
        *(_QWORD *)v82 = CFStringGetTypeID();
        v82[8] = 1;
        v83 = v72;
        TypeID = CFNumberGetTypeID();
        v85 = 1;
        v86 = v71;
        v87 = CFStringGetTypeID();
        v88 = 1;
        v89 = v70;
        v90 = CFStringGetTypeID();
        v91 = 0;
        v92 = v69;
        v93 = CFStringGetTypeID();
        v94 = 0;
        v95 = v68;
        v20 = 0;
        v96 = CFStringGetTypeID();
        v97 = 0;
        v21 = (const void **)&v82[8];
        do
        {
          v22 = (const __CFNumber *)CFDictionaryGetValue(v10, *(v21 - 2));
          number[v20] = v22;
          if (v22)
          {
            if ((const void *)CFGetTypeID(v22) != *(v21 - 1))
            {
              if (*(_BYTE *)v21)
                goto LABEL_113;
              number[v20] = 0;
            }
          }
          else if (*(_BYTE *)v21)
          {
            goto LABEL_113;
          }
          v21 += 3;
          ++v20;
        }
        while (v20 != 6);
        v23 = cf1[0];
        if (!cf1[0])
          goto LABEL_113;
        if (CFEqual(cf1[0], cf2))
        {
          v24 = 1;
        }
        else if (CFEqual(v23, v63))
        {
          v24 = 2;
        }
        else if (CFEqual(v23, v59))
        {
          v24 = 3;
        }
        else if (CFEqual(v23, v57))
        {
          v24 = 4;
        }
        else if (CFEqual(v23, v55))
        {
          v24 = 5;
        }
        else if (CFEqual(v23, v53))
        {
          v24 = 6;
        }
        else if (CFEqual(v23, v52))
        {
          v24 = 7;
        }
        else
        {
          if (!CFEqual(v23, v51))
            goto LABEL_113;
          v24 = 8;
        }
        v26 = cf1[1];
        if (!cf1[1] || CFEqual(cf1[1], v64))
          break;
        if (CFEqual(v26, v61))
        {
          v27 = 2;
        }
        else if (CFEqual(v26, v58))
        {
          v27 = 3;
        }
        else if (CFEqual(v26, v56))
        {
          v27 = 4;
        }
        else
        {
          if (!CFEqual(v26, v54))
            break;
          v27 = 5;
        }
LABEL_63:
        v28 = theString[0];
        if (theString[0])
        {
          if (CFStringGetLength(theString[0]))
            v29 = v28;
          else
            v29 = 0;
        }
        else
        {
          v29 = 0;
        }
        valuePtr = 0;
        CFNumberGetValue(number[1], kCFNumberCFIndexType, &valuePtr);
        v30 = valuePtr;
        if (theString[1])
          v67 = CFEqual(theString[1], CFSTR("default")) != 0;
        else
          v67 = 0;
        *(_BYTE *)(Instance + 96) = v19;
        URLProtectionSpace::initialize(Instance + 16, (const __CFString *)number[0], v30, v24, v29, v27);
        v31 = CFDictionaryGetValue(v10, v65);
        v32 = v31;
        if (v31)
        {
          v33 = CFGetTypeID(v31);
          if (v33 == CFStringGetTypeID())
          {
            v34 = (const __CFData *)CFDictionaryGetValue(v10, v62);
            v35 = v34;
            if (!v34
              || (v36 = CFGetTypeID(v34), v36 != CFDataGetTypeID())
              || (v37 = (const __CFAllocator *)*((_QWORD *)this + 4),
                  (v39 = (const __CFDictionary *)CFPropertyListCreateWithData(v37, v35, 0, 0, 0)) == 0)
              || (v40 = URLCredential::createFromPropertyList(v37, v39, v38), CFRelease(v39), !v40))
            {
              if (URLCredential::Class(void)::sOnce_URLCredential != -1)
                dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
              v41 = _CFRuntimeCreateInstance();
              v40 = (uint64_t (***)(URLCredentialInternetPassword *__hidden, const CFObject *))v41;
              if (v41)
              {
                *(_OWORD *)(v41 + 16) = 0u;
                v40 = (uint64_t (***)(URLCredentialInternetPassword *__hidden, const CFObject *))(v41 + 16);
                *(_QWORD *)(v41 + 112) = 0;
                *(_OWORD *)(v41 + 80) = 0u;
                *(_OWORD *)(v41 + 96) = 0u;
                *(_OWORD *)(v41 + 48) = 0u;
                *(_OWORD *)(v41 + 64) = 0u;
                *(_OWORD *)(v41 + 32) = 0u;
              }
              *((_DWORD *)v40 + 8) = 0;
              *((_BYTE *)v40 + 48) = 0;
              v40[7] = 0;
              v40[5] = 0;
              *v40 = &off_1E14EECF8;
              v40[1] = (uint64_t (**)(URLCredentialInternetPassword *__hidden, const CFObject *))&unk_1E14EEDA0;
              v40[2] = (uint64_t (**)(URLCredentialInternetPassword *__hidden, const CFObject *))&gConstantCFStringValueTable[3752];
              v40[3] = (uint64_t (**)(URLCredentialInternetPassword *__hidden, const CFObject *))&unk_1E14EEDD0;
              *((_BYTE *)v40 + 88) = 0;
              if (!v10)
                goto LABEL_88;
              v42 = (const __CFBoolean *)CFDictionaryGetValue(v10, v60);
              if (v42 && CFBooleanGetValue(v42))
                v43 = 4;
              else
LABEL_88:
                v43 = 3;
              if (!((unsigned int (*)(uint64_t (***)(URLCredentialInternetPassword *__hidden, const CFObject *), const void *, _QWORD, uint64_t, const __CFDictionary *))(*v40)[18])(v40, v32, 0, v43, v10))goto LABEL_112;
            }
            if (*((_BYTE *)this + 49))
              (*v40)[10]((URLCredentialInternetPassword *)v40, (const CFObject *)1);
            if (*((_QWORD *)this + 5))
              ((void (*)(uint64_t (***)(URLCredentialInternetPassword *__hidden, const CFObject *)))(*v40)[11])(v40);
            v44 = (__CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 2), (const void *)Instance);
            if (v44)
            {
              v45 = v40[7];
              if (!v45)
              {
                v45 = (uint64_t (**)(URLCredentialInternetPassword *__hidden, const CFObject *))((uint64_t (*)(uint64_t (***)(URLCredentialInternetPassword *__hidden, const CFObject *)))(*v40)[13])(v40);
                v40[7] = v45;
              }
              if (!CFDictionaryContainsKey(v44, v45))
              {
                v46 = v40[7];
                if (!v46)
                {
                  v46 = (uint64_t (**)(URLCredentialInternetPassword *__hidden, const CFObject *))((uint64_t (*)(uint64_t (***)(URLCredentialInternetPassword *__hidden, const CFObject *)))(*v40)[13])(v40);
                  v40[7] = v46;
                }
                CFDictionarySetValue(v44, v46, v40 - 2);
              }
              if (!v67)
                goto LABEL_112;
            }
            else
            {
              Mutable = CFDictionaryCreateMutable(*((CFAllocatorRef *)this + 4), 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 2), (const void *)Instance, Mutable);
              v48 = v40[7];
              if (!v48)
              {
                v48 = (uint64_t (**)(URLCredentialInternetPassword *__hidden, const CFObject *))((uint64_t (*)(uint64_t (***)(URLCredentialInternetPassword *__hidden, const CFObject *)))(*v40)[13])(v40);
                v40[7] = v48;
              }
              CFDictionarySetValue(Mutable, v48, v40 - 2);
              CFRelease(Mutable);
            }
            v49 = v40[7];
            if (v49
              || (v49 = (uint64_t (**)(URLCredentialInternetPassword *__hidden, const CFObject *))((uint64_t (*)(uint64_t (***)(URLCredentialInternetPassword *__hidden, const CFObject *)))(*v40)[13])(v40),
                  (v40[7] = v49) != 0))
            {
              CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 3), (const void *)Instance, v49);
            }
LABEL_112:
            CFRelease(v40 - 2);
          }
        }
LABEL_113:
        CFRelease((CFTypeRef)Instance);
        if (v10)
          goto LABEL_114;
LABEL_115:
        if (++v7 == v73)
          goto LABEL_121;
      }
      v27 = 1;
      goto LABEL_63;
    }
LABEL_121:
    CFRelease(cf);
    return 1;
  }
  return result;
}

void sub_183FF64CC(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;
  const void *v3;

  if (v1)
    CFRelease(v1);
  CFRelease(v2);
  CFRelease(v3);
  _Unwind_Resume(a1);
}

void StorageQuery::~StorageQuery(StorageQuery *this)
{
  const void *v2;
  const void *v3;
  const void *v4;

  *(_QWORD *)this = &off_1E14E6598;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 2);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 3);
  if (v4)
    CFRelease(v4);
  *(_QWORD *)this = &off_1E14E5838;
}

{
  StorageQuery::~StorageQuery(this);
  JUMPOUT(0x186DB748CLL);
}

void sub_183FF6598(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

CFTypeRef StorageQuery::copyNameAndCredsDictForProtectionSpace(CFDictionaryRef *this, const URLProtectionSpace *a2)
{
  const void *Value;
  uint64_t Instance;
  URLProtectionSpace *v6;
  CFTypeRef v7;
  uint64_t v8;
  CFTypeRef v9;
  CFTypeRef v10;

  Value = CFDictionaryGetValue(this[2], (char *)a2 - 16);
  if (Value)
    return CFRetain(Value);
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  v6 = (URLProtectionSpace *)(Instance + 16);
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_QWORD *)(Instance + 112) = 0;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_QWORD *)(Instance + 16) = &off_1E14E9A20;
  *(_QWORD *)(Instance + 24) = &unk_1E14E9A78;
  *(_BYTE *)(Instance + 96) = 0;
  *(_BYTE *)(Instance + 104) = 0;
  *(_QWORD *)(Instance + 112) = 1;
  v8 = *((_QWORD *)a2 + 3);
  v7 = (CFTypeRef)*((_QWORD *)a2 + 4);
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3759];
  *(_QWORD *)(Instance + 40) = v8;
  if (v7)
    v7 = CFRetain(v7);
  *(_QWORD *)(Instance + 48) = v7;
  *(_QWORD *)(Instance + 56) = *((_QWORD *)a2 + 5);
  v9 = (CFTypeRef)*((_QWORD *)a2 + 6);
  if (v9)
    v9 = CFRetain(v9);
  *(_QWORD *)(Instance + 64) = v9;
  *(_DWORD *)(Instance + 72) = *((_DWORD *)a2 + 14);
  v10 = (CFTypeRef)*((_QWORD *)a2 + 8);
  if (v10)
    v10 = CFRetain(v10);
  *(_QWORD *)(Instance + 80) = v10;
  URLProtectionSpace::calcHash(v6);
  *(_DWORD *)(Instance + 56) = 0;
  URLProtectionSpace::calcHash(v6);
  Value = CFDictionaryGetValue(this[2], (const void *)Instance);
  CFRelease((CFTypeRef)Instance);
  if (Value)
    return CFRetain(Value);
  else
    return 0;
}

void _merge_dictionaries(const void *a1, CFTypeRef cf, __CFDictionary *a3)
{
  CFTypeID v6;
  CFTypeID TypeID;

  if (a1)
  {
    if (cf)
    {
      v6 = CFGetTypeID(cf);
      TypeID = CFDictionaryGetTypeID();
      if (a3)
      {
        if (v6 == TypeID)
          CFDictionarySetValue(a3, a1, cf);
      }
    }
  }
}

void sub_183FF68E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183FF6BB0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_183FF7128(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t GetSvcTicketForHostWithPassword(double a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  const char *v10;
  const char *v11;
  const char *v12;
  const char *v13;
  _DWORD *v14;
  _QWORD *v15;
  const char *v16;
  double Helper_x8__GSSCreateCredentialFromUUID;
  uint64_t v18;
  const char *v19;
  _QWORD *v20;
  _DWORD *v21;
  const char *v22;
  const char *v23;
  const char *v24;
  const char *v25;
  double v26;
  uint64_t v27;
  double v28;
  double v29;
  const __CFAllocator *v30;
  CFStringRef v31;
  double v32;
  CFStringRef v33;
  __CFDictionary *Mutable;
  __CFDictionary *v35;
  double v36;
  double v37;
  uint64_t v38;
  size_t v39;
  const void *v40;
  void *v41;
  double v42;
  char *__s;
  size_t v45;
  char *v46;
  int v47;
  uint64_t inited;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  size_t v53;
  const void *v54;

  Helper_x8__GSSCreateCredentialFromUUID = gotLoadHelper_x8__GSSCreateCredentialFromUUID(a1);
  if (!*(_QWORD *)(v18 + 3224))
    return 1;
  v19 = v16;
  v20 = v15;
  v21 = v14;
  v22 = v13;
  v23 = v12;
  v24 = v11;
  v25 = v10;
  v53 = 0;
  v54 = 0;
  v51 = 0;
  v52 = 0;
  v49 = 0;
  v50 = 0;
  inited = 0;
  v47 = 0;
  *v14 = 0;
  if (v10 && !strcmp(v10, "localhost"))
    v25 = 0;
  if (a10)
  {
    inited = GSSCreateCredentialFromUUID_delayInitStub(Helper_x8__GSSCreateCredentialFromUUID);
  }
  else if (v23)
  {
    __s = 0;
    v46 = (char *)v23;
    v45 = strlen(v23);
    v27 = gss_import_name_delayInitStub(v29);
    if ((_DWORD)v27)
      goto LABEL_29;
    if (v19)
    {
      v30 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v31 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v19, 0x8000100u);
      if (v31)
      {
        v33 = v31;
        Mutable = CFDictionaryCreateMutable(v30, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        if (Mutable)
        {
          v35 = Mutable;
          CFDictionarySetValue(Mutable, CFSTR("kGSSICPassword"), v33);
          gss_aapl_initial_cred_delayInitStub(v36);
          CFRelease(v35);
        }
        CFRelease(v33);
      }
      gss_release_name_delayInitStub(v32);
    }
    else
    {
      v27 = gss_acquire_cred_delayInitStub(v28);
      gss_release_name_delayInitStub(v42);
      if ((_DWORD)v27)
        goto LABEL_29;
    }
  }
  if (v22)
  {
    v46 = (char *)v22;
    v45 = strlen(v22);
    v27 = gss_import_name_delayInitStub(v26);
    if ((_DWORD)v27)
      goto LABEL_29;
  }
  else
  {
    __s = 0;
    asprintf(&__s, "%s@%s", v24, v25);
    v46 = __s;
    v45 = strlen(__s);
    v27 = gss_import_name_delayInitStub(v37);
    free(__s);
    if ((_DWORD)v27)
      goto LABEL_29;
  }
  v38 = gss_init_sec_context_delayInitStub(v28);
  v39 = v53;
  if (v38 > 1)
  {
    v27 = v38;
    if (!v53)
      goto LABEL_31;
    goto LABEL_30;
  }
  if (!v53)
    goto LABEL_26;
  v40 = v54;
  v41 = malloc_type_malloc(v53, 0x40FE505BuLL);
  *v20 = v41;
  if (v41)
  {
    *v21 = v39;
    memcpy(v41, v40, v39);
LABEL_26:
    v27 = 0;
    goto LABEL_29;
  }
  v27 = 12;
LABEL_29:
  if (v53)
LABEL_30:
    gss_release_buffer_delayInitStub(v28);
LABEL_31:
  if (v49)
    gss_delete_sec_context_delayInitStub(v28);
  if (v50)
    gss_release_name_delayInitStub(v28);
  if (inited)
    gss_release_cred_delayInitStub(v28);
  return v27;
}

uint64_t CFURLCredentialStorageCopyCredentialsForProtectionSpace(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const __CFAllocator *v9;
  const __CFString *v10;
  CFStringRef v11;
  CFStringRef v12;
  uint64_t v13;
  uint64_t v14;
  const __CFString *v15;
  CFStringRef v16;
  void (**v18)(AutoString *__hidden);
  CFStringRef v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1)
    dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_2_1169);
  v4 = a1 + 16;
  if (a1)
    v5 = a1 + 16;
  else
    v5 = 0;
  v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v5 + 8) + 16))(v5 + 8, a2);
  v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_1135, 1);
  if (v7)
  {
    v8 = v7;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v7 + 16))(v7, "CopyCredentials", 0))
    {
      v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (a1)
      {
        if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1)
          dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_2_1169);
        v18 = &off_1E14E4818;
        v20 = 0;
        v21 = 0;
        v19 = CFStringCreateWithCString(v9, "Store", 0x8000100u);
        v10 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 32))(a1 + 16);
        v11 = v19;
      }
      else
      {
        v18 = &off_1E14E4818;
        v11 = CFStringCreateWithCString(v9, "Store", 0x8000100u);
        v4 = 0;
        v20 = 0;
        v21 = 0;
        v19 = v11;
        v10 = CFSTR("null");
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v8 + 64))(v8, v11, v10);
      if (v4 && v10)
        CFRelease(v10);
      AutoString::~AutoString((AutoString *)&v18);
      if (a2)
      {
        if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
          dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
        v18 = &off_1E14E4818;
        v12 = CFStringCreateWithCString(v9, "Space", 0x8000100u);
        v20 = 0;
        v21 = 0;
        v19 = v12;
        v14 = *(_QWORD *)(a2 + 16);
        v13 = a2 + 16;
        v15 = (const __CFString *)(*(uint64_t (**)(uint64_t))(v14 + 32))(v13);
        v16 = v19;
      }
      else
      {
        v18 = &off_1E14E4818;
        v16 = CFStringCreateWithCString(v9, "Space", 0x8000100u);
        v13 = 0;
        v20 = 0;
        v21 = 0;
        v15 = CFSTR("null");
        v19 = v16;
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v8 + 64))(v8, v16, v15);
      if (v13 && v15)
        CFRelease(v15);
      AutoString::~AutoString((AutoString *)&v18);
      (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)v8 + 96))(v8, "Result", v6);
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
    }
  }
  return v6;
}

void sub_183FF7770(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t CFURLCredentialStorageCopyAllCredentials(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const __CFAllocator *v7;
  const __CFString *v8;
  CFStringRef v9;
  const __CFAllocator *v11;
  void (**v12)(AutoString *__hidden);
  CFStringRef v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1)
    dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_2_1169);
  v2 = a1 + 16;
  if (a1)
    v3 = a1 + 16;
  else
    v3 = 0;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v3 + 8) + 24))(v3 + 8);
  v5 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_8, 1);
  if (v5)
  {
    v6 = v5;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v5 + 16))(v5, "CopyAllCredentials", 0))
    {
      v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (a1)
      {
        if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1)
        {
          v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_2_1169);
          v7 = v11;
        }
        v12 = &off_1E14E4818;
        v14 = 0;
        v15 = 0;
        v13 = CFStringCreateWithCString(v7, "Store", 0x8000100u);
        v8 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 32))(v2);
        v9 = v13;
      }
      else
      {
        v12 = &off_1E14E4818;
        v9 = CFStringCreateWithCString(v7, "Store", 0x8000100u);
        v2 = 0;
        v14 = 0;
        v15 = 0;
        v13 = v9;
        v8 = CFSTR("null");
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v6 + 64))(v6, v9, v8);
      if (v2 && v8)
        CFRelease(v8);
      AutoString::~AutoString((AutoString *)&v12);
      (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)v6 + 96))(v6, "Result", v4);
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  return v4;
}

void sub_183FF79E0(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t CFURLCredentialStorageSetCredentialForProtectionSpace(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  const __CFAllocator *v8;
  uint64_t v9;
  const __CFString *v10;
  CFStringRef v11;
  CFStringRef v12;
  uint64_t v13;
  const __CFString *v14;
  CFStringRef v15;
  CFStringRef v16;
  uint64_t v17;
  const __CFString *v18;
  CFStringRef v19;
  uint64_t v20;
  void (**v22)(AutoString *__hidden);
  CFStringRef v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_12, 1);
  if (v6)
  {
    v7 = v6;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v6 + 16))(v6, "SetCredential", 0))
    {
      v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (a1)
      {
        v9 = a1 + 16;
        if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1)
          dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_2_1169);
        v22 = &off_1E14E4818;
        v24 = 0;
        v25 = 0;
        v23 = CFStringCreateWithCString(v8, "Store", 0x8000100u);
        v10 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 32))(a1 + 16);
        v11 = v23;
      }
      else
      {
        v22 = &off_1E14E4818;
        v11 = CFStringCreateWithCString(v8, "Store", 0x8000100u);
        v9 = 0;
        v24 = 0;
        v25 = 0;
        v23 = v11;
        v10 = CFSTR("null");
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v7 + 64))(v7, v11, v10);
      if (v9 && v10)
        CFRelease(v10);
      AutoString::~AutoString((AutoString *)&v22);
      if (a3)
      {
        if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
          dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
        v22 = &off_1E14E4818;
        v12 = CFStringCreateWithCString(v8, "Space", 0x8000100u);
        v13 = a3 + 16;
        v24 = 0;
        v25 = 0;
        v23 = v12;
        v14 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)(a3 + 16) + 32))(a3 + 16);
        v15 = v23;
      }
      else
      {
        v22 = &off_1E14E4818;
        v15 = CFStringCreateWithCString(v8, "Space", 0x8000100u);
        v13 = 0;
        v24 = 0;
        v25 = 0;
        v14 = CFSTR("null");
        v23 = v15;
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v7 + 64))(v7, v15, v14);
      if (v13 && v14)
        CFRelease(v14);
      AutoString::~AutoString((AutoString *)&v22);
      if (a2)
      {
        if (URLCredential::Class(void)::sOnce_URLCredential != -1)
          dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
        v22 = &off_1E14E4818;
        v16 = CFStringCreateWithCString(v8, "Credential", 0x8000100u);
        v17 = a2 + 16;
        v24 = 0;
        v25 = 0;
        v23 = v16;
        v18 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)(a2 + 16) + 32))(a2 + 16);
        v19 = v23;
      }
      else
      {
        v22 = &off_1E14E4818;
        v19 = CFStringCreateWithCString(v8, "Credential", 0x8000100u);
        v17 = 0;
        v24 = 0;
        v25 = 0;
        v18 = CFSTR("null");
        v23 = v19;
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v7 + 64))(v7, v19, v18);
      if (v17 && v18)
        CFRelease(v18);
      AutoString::~AutoString((AutoString *)&v22);
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
    }
  }
  if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1)
    dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_2_1169);
  if (a1)
    v20 = a1 + 16;
  else
    v20 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v20 + 8) + 40))(v20 + 8, a2, a3);
}

void sub_183FF7E40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  AutoString::~AutoString((AutoString *)&a9);
  _Unwind_Resume(a1);
}

void CFURLCredentialStorageRemoveCredentialForProtectionSpace(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  const __CFAllocator *v8;
  uint64_t v9;
  const __CFString *v10;
  CFStringRef v11;
  CFStringRef v12;
  uint64_t v13;
  const __CFString *v14;
  CFStringRef v15;
  CFStringRef v16;
  uint64_t v17;
  const __CFString *v18;
  CFStringRef v19;
  uint64_t v20;
  uint64_t v21;
  void (**v22)(AutoString *__hidden);
  CFStringRef v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_15, 1);
  if (v6)
  {
    v7 = v6;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v6 + 16))(v6, "RemoveCredential", 0))
    {
      v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (a1)
      {
        v9 = a1 + 16;
        if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1)
          dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_2_1169);
        v22 = &off_1E14E4818;
        v24 = 0;
        v25 = 0;
        v23 = CFStringCreateWithCString(v8, "Store", 0x8000100u);
        v10 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 32))(a1 + 16);
        v11 = v23;
      }
      else
      {
        v22 = &off_1E14E4818;
        v11 = CFStringCreateWithCString(v8, "Store", 0x8000100u);
        v9 = 0;
        v24 = 0;
        v25 = 0;
        v23 = v11;
        v10 = CFSTR("null");
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v7 + 64))(v7, v11, v10);
      if (v9 && v10)
        CFRelease(v10);
      AutoString::~AutoString((AutoString *)&v22);
      if (a3)
      {
        if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
          dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
        v22 = &off_1E14E4818;
        v12 = CFStringCreateWithCString(v8, "Space", 0x8000100u);
        v13 = a3 + 16;
        v24 = 0;
        v25 = 0;
        v23 = v12;
        v14 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)(a3 + 16) + 32))(a3 + 16);
        v15 = v23;
      }
      else
      {
        v22 = &off_1E14E4818;
        v15 = CFStringCreateWithCString(v8, "Space", 0x8000100u);
        v13 = 0;
        v24 = 0;
        v25 = 0;
        v14 = CFSTR("null");
        v23 = v15;
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v7 + 64))(v7, v15, v14);
      if (v13 && v14)
        CFRelease(v14);
      AutoString::~AutoString((AutoString *)&v22);
      if (a2)
      {
        if (URLCredential::Class(void)::sOnce_URLCredential != -1)
          dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
        v22 = &off_1E14E4818;
        v16 = CFStringCreateWithCString(v8, "Credential", 0x8000100u);
        v17 = a2 + 16;
        v24 = 0;
        v25 = 0;
        v23 = v16;
        v18 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)(a2 + 16) + 32))(a2 + 16);
        v19 = v23;
      }
      else
      {
        v22 = &off_1E14E4818;
        v19 = CFStringCreateWithCString(v8, "Credential", 0x8000100u);
        v17 = 0;
        v24 = 0;
        v25 = 0;
        v18 = CFSTR("null");
        v23 = v19;
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v7 + 64))(v7, v19, v18);
      if (v17 && v18)
        CFRelease(v18);
      AutoString::~AutoString((AutoString *)&v22);
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
    }
  }
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  v20 = a2 + 16;
  if (!a2)
    v20 = 0;
  if (*(_DWORD *)(v20 + 36) != 4)
  {
    if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1)
      dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_2_1169);
    if (a1)
      v21 = a1 + 16;
    else
      v21 = 0;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v21 + 8) + 48))(v21 + 8, a2, a3);
  }
}

void sub_183FF8288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  AutoString::~AutoString((AutoString *)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___Z67CFURLCredentialStorageRemoveCredentialForProtectionSpaceWithOptionsP23_CFURLCredentialStoragePK16_CFURLCredentialP21_CFURLProtectionSpacePK14__CFDictionary_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 114;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t CFURLCredentialStorageCopyDefaultCredentialForProtectionSpace(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const __CFAllocator *v9;
  const __CFString *v10;
  CFStringRef v11;
  CFStringRef v12;
  uint64_t v13;
  uint64_t v14;
  const __CFString *v15;
  CFStringRef v16;
  CFStringRef v17;
  uint64_t v18;
  const __CFString *v19;
  CFStringRef v20;
  void (**v22)(AutoString *__hidden);
  CFStringRef v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1)
    dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_2_1169);
  v4 = a1 + 16;
  if (a1)
    v5 = a1 + 16;
  else
    v5 = 0;
  v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v5 + 8) + 56))(v5 + 8, a2);
  v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_19, 1);
  if (v7)
  {
    v8 = v7;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v7 + 16))(v7, "CopyDefaultCredential", 0))
    {
      v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (a1)
      {
        if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1)
          dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_2_1169);
        v22 = &off_1E14E4818;
        v24 = 0;
        v25 = 0;
        v23 = CFStringCreateWithCString(v9, "Store", 0x8000100u);
        v10 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 32))(a1 + 16);
        v11 = v23;
      }
      else
      {
        v22 = &off_1E14E4818;
        v11 = CFStringCreateWithCString(v9, "Store", 0x8000100u);
        v4 = 0;
        v24 = 0;
        v25 = 0;
        v23 = v11;
        v10 = CFSTR("null");
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v8 + 64))(v8, v11, v10);
      if (v4 && v10)
        CFRelease(v10);
      AutoString::~AutoString((AutoString *)&v22);
      if (a2)
      {
        if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
          dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
        v22 = &off_1E14E4818;
        v12 = CFStringCreateWithCString(v9, "Space", 0x8000100u);
        v24 = 0;
        v25 = 0;
        v23 = v12;
        v14 = *(_QWORD *)(a2 + 16);
        v13 = a2 + 16;
        v15 = (const __CFString *)(*(uint64_t (**)(uint64_t))(v14 + 32))(v13);
        v16 = v23;
      }
      else
      {
        v22 = &off_1E14E4818;
        v16 = CFStringCreateWithCString(v9, "Space", 0x8000100u);
        v13 = 0;
        v24 = 0;
        v25 = 0;
        v15 = CFSTR("null");
        v23 = v16;
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v8 + 64))(v8, v16, v15);
      if (v13 && v15)
        CFRelease(v15);
      AutoString::~AutoString((AutoString *)&v22);
      if (v6)
      {
        if (URLCredential::Class(void)::sOnce_URLCredential != -1)
          dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
        v22 = &off_1E14E4818;
        v17 = CFStringCreateWithCString(v9, "Result", 0x8000100u);
        v18 = v6 + 16;
        v24 = 0;
        v25 = 0;
        v23 = v17;
        v19 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)(v6 + 16) + 32))(v6 + 16);
        v20 = v23;
      }
      else
      {
        v22 = &off_1E14E4818;
        v20 = CFStringCreateWithCString(v9, "Result", 0x8000100u);
        v18 = 0;
        v24 = 0;
        v25 = 0;
        v19 = CFSTR("null");
        v23 = v20;
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v8 + 64))(v8, v20, v19);
      if (v18 && v19)
        CFRelease(v19);
      AutoString::~AutoString((AutoString *)&v22);
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
    }
  }
  return v6;
}

void sub_183FF86E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  AutoString::~AutoString((AutoString *)&a9);
  _Unwind_Resume(a1);
}

uint64_t CFURLCredentialStorageSetDefaultCredentialForProtectionSpace(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  const __CFAllocator *v8;
  uint64_t v9;
  const __CFString *v10;
  CFStringRef v11;
  CFStringRef v12;
  uint64_t v13;
  const __CFString *v14;
  CFStringRef v15;
  CFStringRef v16;
  uint64_t v17;
  const __CFString *v18;
  CFStringRef v19;
  uint64_t v20;
  void (**v22)(AutoString *__hidden);
  CFStringRef v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_21_1152, 1);
  if (v6)
  {
    v7 = v6;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v6 + 16))(v6, "SetDefaultCredential", 0))
    {
      v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (a1)
      {
        v9 = a1 + 16;
        if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1)
          dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_2_1169);
        v22 = &off_1E14E4818;
        v24 = 0;
        v25 = 0;
        v23 = CFStringCreateWithCString(v8, "Store", 0x8000100u);
        v10 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 32))(a1 + 16);
        v11 = v23;
      }
      else
      {
        v22 = &off_1E14E4818;
        v11 = CFStringCreateWithCString(v8, "Store", 0x8000100u);
        v9 = 0;
        v24 = 0;
        v25 = 0;
        v23 = v11;
        v10 = CFSTR("null");
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v7 + 64))(v7, v11, v10);
      if (v9 && v10)
        CFRelease(v10);
      AutoString::~AutoString((AutoString *)&v22);
      if (a3)
      {
        if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
          dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
        v22 = &off_1E14E4818;
        v12 = CFStringCreateWithCString(v8, "Space", 0x8000100u);
        v13 = a3 + 16;
        v24 = 0;
        v25 = 0;
        v23 = v12;
        v14 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)(a3 + 16) + 32))(a3 + 16);
        v15 = v23;
      }
      else
      {
        v22 = &off_1E14E4818;
        v15 = CFStringCreateWithCString(v8, "Space", 0x8000100u);
        v13 = 0;
        v24 = 0;
        v25 = 0;
        v14 = CFSTR("null");
        v23 = v15;
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v7 + 64))(v7, v15, v14);
      if (v13 && v14)
        CFRelease(v14);
      AutoString::~AutoString((AutoString *)&v22);
      if (a2)
      {
        if (URLCredential::Class(void)::sOnce_URLCredential != -1)
          dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
        v22 = &off_1E14E4818;
        v16 = CFStringCreateWithCString(v8, "Result", 0x8000100u);
        v17 = a2 + 16;
        v24 = 0;
        v25 = 0;
        v23 = v16;
        v18 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)(a2 + 16) + 32))(a2 + 16);
        v19 = v23;
      }
      else
      {
        v22 = &off_1E14E4818;
        v19 = CFStringCreateWithCString(v8, "Result", 0x8000100u);
        v17 = 0;
        v24 = 0;
        v25 = 0;
        v18 = CFSTR("null");
        v23 = v19;
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v7 + 64))(v7, v19, v18);
      if (v17 && v18)
        CFRelease(v18);
      AutoString::~AutoString((AutoString *)&v22);
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
    }
  }
  if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1)
    dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_2_1169);
  if (a1)
    v20 = a1 + 16;
  else
    v20 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v20 + 8) + 64))(v20 + 8, a2, a3);
}

void sub_183FF8AE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  AutoString::~AutoString((AutoString *)&a9);
  _Unwind_Resume(a1);
}

uint64_t URLCredentialStorage::initialize(URLCredentialStorage *this, CFTypeRef cf)
{
  CFTypeRef v3;

  if (cf)
    v3 = CFRetain(cf);
  else
    v3 = 0;
  *((_QWORD *)this + 12) = v3;
  return 1;
}

uint64_t ___ZN29URLCredentialStorageUtilities25isSystemKeychainSupportedEv_block_invoke()
{
  const __CFDictionary *inited;
  double v1;
  uint64_t v2;
  const __CFString *Value;
  double v4;
  uint64_t v5;
  const __CFString *v6;
  double v7;
  const __CFString *v8;
  BOOL v9;
  uint64_t v10;
  double v11;
  BOOL v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v16;
  _QWORD v17[2];
  void (*v18)(uint64_t);
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint8_t buf[4];
  _BYTE v23[14];
  __int16 v24;
  const __CFString *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v20 = 0;
  v21 = 0;
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 3221225472;
  v18 = ___ZN29URLCredentialStorageUtilities25isSystemKeychainSupportedEv_block_invoke_2;
  v19 = &__block_descriptor_40_e5_v8__0l;
  inited = (const __CFDictionary *)MKBUserTypeDeviceMode_delayInitStub(COERCE_DOUBLE(3221225472));
  if (inited)
  {
    gotLoadHelper_x8__kMKBDeviceModeKey(v1);
    Value = (const __CFString *)CFDictionaryGetValue(inited, **(const void ***)(v2 + 1440));
    gotLoadHelper_x8__kMKBUserTypeKey(v4);
    v6 = (const __CFString *)CFDictionaryGetValue(inited, **(const void ***)(v5 + 1520));
    v8 = v6;
    if (Value)
      v9 = v6 == 0;
    else
      v9 = 1;
    if (v9
      || (gotLoadHelper_x8__kMKBDeviceModeMultiUser(v7), CFStringCompare(Value, **(CFStringRef **)(v10 + 1448), 0)))
    {
      v12 = 0;
    }
    else
    {
      gotLoadHelper_x8__kMKBUserTypeEphemeral(v11);
      v12 = CFStringCompare(v8, **(CFStringRef **)(v16 + 1512), 0) == kCFCompareEqualTo;
    }
    URLCredentialStorageUtilities::isSystemKeychainSupported(void)::isMultiUser = v12;
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v13 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)v23 = URLCredentialStorageUtilities::isSystemKeychainSupported(void)::isMultiUser;
      *(_WORD *)&v23[4] = 2112;
      *(_QWORD *)&v23[6] = Value;
      v24 = 2112;
      v25 = v8;
      _os_log_impl(&dword_183ECA000, v13, OS_LOG_TYPE_DEFAULT, "Device is multi-user=%d for mode %@ userType %@", buf, 0x1Cu);
    }
    CFRelease(inited);
  }
  else
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v14 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)v23 = v21;
      _os_log_error_impl(&dword_183ECA000, v14, OS_LOG_TYPE_ERROR, "MKBUserTypeDeviceMode returned NULL: %@", buf, 0xCu);
    }
  }
  return ((uint64_t (*)(_QWORD *))v18)(v17);
}

void sub_183FF8E0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void (*a11)(uint64_t *))
{
  const void *v11;

  CFRelease(v11);
  a11(&a9);
  _Unwind_Resume(a1);
}

void ___ZN29URLCredentialStorageUtilities25isSystemKeychainSupportedEv_block_invoke_2(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

uint64_t CFURLCredentialStorageIsSystemKeychainSupported()
{
  if (URLCredentialStorageUtilities::isSystemKeychainSupported(void)::onceToken != -1)
    dispatch_once(&URLCredentialStorageUtilities::isSystemKeychainSupported(void)::onceToken, &__block_literal_global_1164);
  return URLCredentialStorageUtilities::isSystemKeychainSupported(void)::isMultiUser;
}

uint64_t CFURLCredentialStorageSetUseSystemKeychain(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1)
    dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_2_1169);
  if (a1)
    v4 = a1 + 16;
  else
    v4 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v4 + 8) + 72))(v4 + 8, a2);
}

id ___ZN2H329reportServerProtocolViolationEP8NSStringNS_23ServerProtocolViolationE_block_invoke(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  void *v3;
  _QWORD v5[2];
  _QWORD v6[3];

  v6[2] = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  v5[1] = CFSTR("violationType");
  v6[0] = v1;
  v5[0] = CFSTR("domain");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedChar:", *(unsigned __int8 *)(a1 + 40));
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v6[1] = v2;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v6, v5, 2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

void sub_183FF8F9C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL _CFHostIsDomainTopLevelForCookiePolicy(const __CFString *a1)
{
  return isTopLevelDomain(a1, 1);
}

uint64_t ___ZL12creatEnqueueP17HTTPNetConnectionP15__CFHTTPMessageP14__CFReadStream_block_invoke(uint64_t a1, __CFReadStream *a2)
{
  _OWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 40), 184, 0);
  *v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  v4[4] = 0u;
  v4[5] = 0u;
  v4[6] = 0u;
  v4[7] = 0u;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  *((_QWORD *)v4 + 22) = 0;
  HTTPNetStreamInfo::HTTPNetStreamInfo((HTTPNetStreamInfo *)v4, a2, *(CFTypeRef *)(a1 + 48), *(HTTPNetConnection **)(a1 + 56));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v5;
  v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v6 + 112))(v6, 0, 0);
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

CFStringRef MetaConnectionCache::copyDebugDesc(MetaConnectionCache *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("MetaConnectionCache<%p>"), this);
}

BOOL MetaConnectionCache::equals(MetaConnectionCache *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

void MetaConnectionCache::initWithSchedulingSet(MetaConnectionCache *this, const CoreSchedulingSet *a2, TubeManager *a3)
{
  abort();
}

void MetaConnectionCache::initWithSchedulingSet()
{
  abort();
}

void MetaConnectionCache::ingestTube(MetaConnectionCache *this, Tube *a2)
{
  abort();
}

void MetaConnectionCache::ingestTube()
{
  abort();
}

void MetaConnectionCache::getPendingTubeForProtocolWithKey()
{
  abort();
}

void MetaNetStreamInfo::getAuthState(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

CFTypeID CFNetServiceBrowserGetTypeID(void)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = _CFNetServiceBrowserRegisterClass;
  if (_kCFNetServiceBrowserRegisterClass != -1)
    dispatch_once(&_kCFNetServiceBrowserRegisterClass, block);
  return _kCFNetServiceBrowserTypeID;
}

_QWORD *_CFNetServiceBrowserRegisterClass(void)
{
  _QWORD *result;

  result = malloc_type_calloc(1uLL, 0x60uLL, 0x10D00408820D60FuLL);
  _kCFNetServiceBrowserClass = (uint64_t)result;
  if (result)
  {
    *result = 0;
    result[1] = "CFNetServiceBrowser";
    result[4] = _NetServiceBrowserDestroy;
    result = (_QWORD *)_CFRuntimeRegisterClass();
    _kCFNetServiceBrowserTypeID = (uint64_t)result;
  }
  return result;
}

uint64_t ___ZL19_dispatch_once_funcPlPFvvE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

void _NetServiceBrowserDestroy(__CFNetServiceBrowser *a1)
{
  os_unfair_lock_s *v2;
  void (*v3)(void);
  char *v4;
  uint64_t v5;
  _DNSServiceRef_t *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;

  v2 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  if (*((_QWORD *)a1 + 14))
  {
    v3 = (void (*)(void))*((_QWORD *)a1 + 16);
    if (v3)
      v3();
  }
  v4 = (char *)*((_QWORD *)a1 + 5);
  if (v4)
  {
    v5 = *((_QWORD *)a1 + 11);
    if (v5)
    {
      _CFTypeUnscheduleFromMultipleRunLoops(v4, v5);
      v4 = (char *)*((_QWORD *)a1 + 5);
    }
    _CFTypeInvalidate(v4);
    CFRelease(*((CFTypeRef *)a1 + 5));
  }
  v6 = (_DNSServiceRef_t *)*((_QWORD *)a1 + 6);
  if (v6)
    DNSServiceRefDeallocate(v6);
  v7 = (const void *)*((_QWORD *)a1 + 8);
  if (v7)
    CFRelease(v7);
  v8 = (const void *)*((_QWORD *)a1 + 9);
  if (v8)
    CFRelease(v8);
  v9 = (const void *)*((_QWORD *)a1 + 10);
  if (v9)
    CFRelease(v9);
  v10 = (const void *)*((_QWORD *)a1 + 11);
  if (v10)
    CFRelease(v10);
  os_unfair_lock_unlock(v2);
}

CFNetServiceBrowserRef CFNetServiceBrowserCreate(CFAllocatorRef alloc, CFNetServiceBrowserClientCallBack clientCB, CFNetServiceClientContext *clientContext)
{
  _QWORD *v3;
  uint64_t Instance;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t (*v15)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  const CFArrayCallBacks *v16;
  CFDictionaryValueCallBacks v18;

  v3 = 0;
  if (clientCB && clientContext)
  {
    if (!CFNetServiceBrowserGetTypeID())
      return 0;
    Instance = _CFRuntimeCreateInstance();
    v3 = (_QWORD *)Instance;
    if (Instance)
    {
      memset(&v18, 0, sizeof(v18));
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 128) = 0u;
      *(_OWORD *)(Instance + 48) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(_QWORD *)(Instance + 96) = clientCB;
      v12 = *(_OWORD *)&clientContext->version;
      v13 = *(_OWORD *)&clientContext->retain;
      *(_QWORD *)(Instance + 136) = clientContext->copyDescription;
      *(_OWORD *)(Instance + 120) = v13;
      *(_OWORD *)(Instance + 104) = v12;
      v14 = *(_QWORD *)(Instance + 112);
      if (v14)
      {
        v15 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v3[15];
        if (v15)
          v3[14] = v15(v14, v8, v9, v10, v11);
      }
      v16 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
      v3[11] = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E0C9B378]);
      v3[8] = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E0C9B390], &v18);
      v3[9] = CFArrayCreateMutable(alloc, 0, v16);
      v3[10] = CFArrayCreateMutable(alloc, 0, v16);
      if (!v3[11])
      {
        CFRelease(v3);
        return 0;
      }
    }
  }
  return (CFNetServiceBrowserRef)v3;
}

void CFNetServiceBrowserInvalidate(CFNetServiceBrowserRef browser)
{
  os_unfair_lock_s *v2;
  void (*v3)(void);
  uint64_t v4;
  _DNSServiceRef_t *v5;

  v2 = (os_unfair_lock_s *)((char *)browser + 16);
  os_unfair_lock_lock((os_unfair_lock_t)browser + 4);
  if (*((_QWORD *)browser + 14))
  {
    v3 = (void (*)(void))*((_QWORD *)browser + 16);
    if (v3)
      v3();
  }
  v4 = *((_QWORD *)browser + 5);
  if (v4)
  {
    _CFTypeUnscheduleFromMultipleRunLoops(v4, *((_QWORD *)browser + 11));
    _CFTypeInvalidate(*((_QWORD *)browser + 5));
    CFRelease(*((CFTypeRef *)browser + 5));
    *((_QWORD *)browser + 5) = 0;
  }
  v5 = (_DNSServiceRef_t *)*((_QWORD *)browser + 6);
  if (v5)
  {
    DNSServiceRefDeallocate(v5);
    *((_QWORD *)browser + 6) = 0;
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)browser + 8));
    CFArrayRemoveAllValues(*((CFMutableArrayRef *)browser + 9));
    CFArrayRemoveAllValues(*((CFMutableArrayRef *)browser + 10));
  }
  *((_OWORD *)browser + 7) = 0u;
  *((_OWORD *)browser + 8) = 0u;
  *((_OWORD *)browser + 6) = 0u;
  os_unfair_lock_unlock(v2);
}

Boolean CFNetServiceBrowserSearchForDomains(CFNetServiceBrowserRef browser, Boolean registrationDomains, CFStreamError *error)
{
  int v3;
  CFStreamError *v5;
  const void *(__cdecl *v6)(const void *);
  int v7;
  const void *v8;
  CFTypeID v9;
  Boolean v10;
  int v11;
  DNSServiceFlags v12;
  DNSServiceErrorType v13;
  const __CFAllocator *v14;
  dnssd_sock_t v15;
  __CFSocket *v16;
  __CFSocket *v17;
  CFOptionFlags SocketFlags;
  int v20;
  CFSocketContext context;
  char v22;

  v3 = registrationDomains;
  if (error)
    v5 = error;
  else
    v5 = (CFStreamError *)&v22;
  v5->domain = 0;
  *(_QWORD *)&v5->error = 0;
  CFRetain(browser);
  v6 = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
  os_unfair_lock_lock((os_unfair_lock_t)browser + 4);
  context.version = 0;
  context.info = browser;
  context.retain = v6;
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
  context.copyDescription = 0;
  if (!*((_QWORD *)browser + 12))
  {
    v10 = 0;
    *((_QWORD *)browser + 3) = 10;
    v11 = -72006;
    goto LABEL_9;
  }
  v7 = -72008;
  v8 = (const void *)*((_QWORD *)browser + 5);
  if (v8)
  {
    v9 = CFGetTypeID(v8);
    if (v9 == CFSocketGetTypeID())
    {
      v10 = 0;
      *((_QWORD *)browser + 3) = 10;
      v11 = -72003;
LABEL_9:
      *((_DWORD *)browser + 8) = v11;
      goto LABEL_28;
    }
    _CFTypeUnscheduleFromMultipleRunLoops(*((void **)browser + 5), *((const __CFArray **)browser + 11));
    CFRunLoopSourceInvalidate(*((CFRunLoopSourceRef *)browser + 5));
    CFRelease(*((CFTypeRef *)browser + 5));
    *((_QWORD *)browser + 5) = 0;
  }
  *((_BYTE *)browser + 20) = 1;
  if (v3)
    v12 = 128;
  else
    v12 = 64;
  v13 = DNSServiceEnumerateDomains((DNSServiceRef *)browser + 6, v12, 0, (DNSServiceDomainEnumReply)_DomainEnumReply, browser);
  *((_DWORD *)browser + 8) = v13;
  if (v13 <= -65549)
  {
    if (v13 == -65555)
      goto LABEL_27;
    if (v13 == -65554)
    {
      v7 = -72002;
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  if (v13 == -65548)
  {
    v7 = -72001;
    goto LABEL_27;
  }
  if (v13)
  {
    if (v13 == -65540)
    {
      v7 = -72004;
LABEL_27:
      v10 = 0;
      *((_QWORD *)browser + 3) = 10;
      *((_DWORD *)browser + 8) = v7;
      goto LABEL_28;
    }
LABEL_26:
    v7 = -72000;
    goto LABEL_27;
  }
  v14 = CFGetAllocator(browser);
  v15 = DNSServiceRefSockFD(*((DNSServiceRef *)browser + 6));
  v16 = CFSocketCreateWithNative(v14, v15, 1uLL, (CFSocketCallBack)_SocketCallBack, &context);
  *((_QWORD *)browser + 5) = v16;
  if (v16)
  {
    v17 = v16;
    SocketFlags = CFSocketGetSocketFlags(v16);
    CFSocketSetSocketFlags(v17, SocketFlags & 0xFFFFFFFFFFFFFF7FLL);
    if (CFArrayGetCount(*((CFArrayRef *)browser + 11)))
    {
      _CFTypeScheduleOnMultipleRunLoops(*((void **)browser + 5), *((const __CFArray **)browser + 11));
      v10 = 1;
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)browser + 4);
      v10 = _BrowserBlockUntilComplete((os_unfair_lock_s *)browser);
      os_unfair_lock_lock((os_unfair_lock_t)browser + 4);
    }
  }
  else
  {
    if (*__error())
      v20 = *__error();
    else
      v20 = 12;
    *((_QWORD *)browser + 3) = 1;
    *((_DWORD *)browser + 8) = v20;
    DNSServiceRefDeallocate(*((DNSServiceRef *)browser + 6));
    v10 = 0;
    *((_QWORD *)browser + 6) = 0;
  }
LABEL_28:
  *v5 = *(CFStreamError *)((char *)browser + 24);
  os_unfair_lock_unlock((os_unfair_lock_t)browser + 4);
  CFRelease(browser);
  return v10;
}

void _DomainEnumReply(_DNSServiceRef_t *a1, char a2, unsigned int a3, int a4, const char *a5, char *cf)
{
  uint64_t v6;
  uint64_t v7;
  int v12;
  void (*v13)(char *, _QWORD, CFStringRef, __int128 *, uint64_t);
  uint64_t v14;
  CFStringRef v15;
  const __CFAllocator *v16;
  int v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;

  if (a4 != -65570)
  {
    v19 = v6;
    v20 = v7;
    CFRetain(cf);
    os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
    if (!*((_QWORD *)cf + 6))
    {
      v13 = 0;
      v14 = 0;
      v15 = 0;
LABEL_19:
      os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
      if (v13 && v15)
      {
        if ((a2 & 2) != 0)
          v17 = 2;
        else
          v17 = 10;
        v13(cf, v17 | a2 & 5u, v15, &v18, v14);
      }
      else if (!v15)
      {
LABEL_27:
        CFRelease(cf);
        return;
      }
      CFRelease(v15);
      goto LABEL_27;
    }
    if (!a4)
    {
      if (a5)
      {
        v16 = CFGetAllocator(cf);
        v15 = CFStringCreateWithCString(v16, a5, 0x8000100u);
      }
      else
      {
        v15 = 0;
      }
      goto LABEL_18;
    }
    v12 = -72008;
    if (a4 > -65549)
    {
      if (a4 == -65548)
      {
        v12 = -72001;
        goto LABEL_17;
      }
      if (a4 == -65540)
      {
        v12 = -72004;
        goto LABEL_17;
      }
    }
    else
    {
      if (a4 == -65555)
      {
LABEL_17:
        *((_QWORD *)cf + 3) = 10;
        *((_DWORD *)cf + 8) = v12;
        _CFTypeUnscheduleFromMultipleRunLoops(*((void **)cf + 5), *((const __CFArray **)cf + 11));
        CFSocketInvalidate(*((CFSocketRef *)cf + 5));
        CFRelease(*((CFTypeRef *)cf + 5));
        *((_QWORD *)cf + 5) = 0;
        DNSServiceRefDeallocate(*((DNSServiceRef *)cf + 6));
        v15 = 0;
        *((_QWORD *)cf + 6) = 0;
LABEL_18:
        v13 = (void (*)(char *, _QWORD, CFStringRef, __int128 *, uint64_t))*((_QWORD *)cf + 12);
        v18 = *(_OWORD *)(cf + 24);
        v14 = *((_QWORD *)cf + 14);
        goto LABEL_19;
      }
      if (a4 == -65554)
      {
        v12 = -72002;
        goto LABEL_17;
      }
    }
    v12 = -72000;
    goto LABEL_17;
  }
}

void _SocketCallBack(__CFSocket *a1, unint64_t a2, const __CFData *a3, const void *a4, DNSServiceRef *cf)
{
  _DNSServiceRef_t *v6;
  unsigned int v7;

  CFRetain(cf);
  v6 = (_DNSServiceRef_t *)DNSServiceProcessResult(cf[6]);
  if ((_DWORD)v6)
  {
    if (*((_BYTE *)cf + 20))
      _DomainEnumReply(v6, 0, v7, (int)v6, 0, (char *)cf);
    else
      _BrowseReply(v6, 0, v7, (int)v6, 0, 0, 0, (char *)cf);
  }
  CFRelease(cf);
}

BOOL _BrowserBlockUntilComplete(os_unfair_lock_s *a1)
{
  __CFRunLoop *Current;
  _BOOL8 v3;

  Current = CFRunLoopGetCurrent();
  CFNetServiceBrowserScheduleWithRunLoop((CFNetServiceBrowserRef)a1, Current, CFSTR("_kCFNetServiceBrowserBlockingMode"));
  os_unfair_lock_lock(a1 + 4);
  while (*(_QWORD *)&a1[10]._os_unfair_lock_opaque)
  {
    os_unfair_lock_unlock(a1 + 4);
    CFRunLoopRunInMode(CFSTR("_kCFNetServiceBrowserBlockingMode"), 1.79769313e308, 1u);
    os_unfair_lock_lock(a1 + 4);
  }
  v3 = a1[8]._os_unfair_lock_opaque == 0;
  os_unfair_lock_unlock(a1 + 4);
  CFNetServiceBrowserUnscheduleFromRunLoop((CFNetServiceBrowserRef)a1, Current, CFSTR("_kCFNetServiceBrowserBlockingMode"));
  return v3;
}

void CFNetServiceBrowserScheduleWithRunLoop(CFNetServiceBrowserRef browser, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  os_unfair_lock_s *v6;
  void *v7;

  v6 = (os_unfair_lock_s *)((char *)browser + 16);
  os_unfair_lock_lock((os_unfair_lock_t)browser + 4);
  if (_SchedulesAddRunLoopAndMode(*((const __CFArray **)browser + 11), runLoop, runLoopMode))
  {
    v7 = (void *)*((_QWORD *)browser + 5);
    if (v7)
      _CFTypeScheduleOnRunLoop(v7, (uint64_t)runLoop, (uint64_t)runLoopMode);
  }
  os_unfair_lock_unlock(v6);
}

void CFNetServiceBrowserUnscheduleFromRunLoop(CFNetServiceBrowserRef browser, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  os_unfair_lock_s *v6;
  void *v7;

  v6 = (os_unfair_lock_s *)((char *)browser + 16);
  os_unfair_lock_lock((os_unfair_lock_t)browser + 4);
  if (_SchedulesRemoveRunLoopAndMode(*((const __CFArray **)browser + 11), runLoop, runLoopMode))
  {
    v7 = (void *)*((_QWORD *)browser + 5);
    if (v7)
      _CFTypeUnscheduleFromRunLoop(v7, (uint64_t)runLoop, (uint64_t)runLoopMode);
  }
  os_unfair_lock_unlock(v6);
}

void _BrowseReply(_DNSServiceRef_t *a1, char a2, unsigned int a3, int a4, const char *a5, const char *a6, const char *a7, char *cf)
{
  uint64_t v8;
  uint64_t v9;
  int v16;
  const __CFAllocator *v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *v20;
  const __CFString *v21;
  CFNetServiceRef v22;
  void (*v23)(char *, uint64_t, const void *, __int128 *, uint64_t);
  uint64_t v24;
  CFIndex Count;
  CFIndex v26;
  CFIndex v27;
  CFIndex v28;
  uint64_t v29;
  CFIndex v30;
  const void *v31;
  __CFNetService *v32;
  uint64_t v33;
  unsigned int v34;
  CFIndex v35;
  const void *ValueAtIndex;
  unsigned int Value;
  const void *v39;
  const __CFArray *v40;
  CFIndex FirstIndexOfValue;
  __CFArray *v42;
  const __CFArray *v43;
  uint64_t v44;
  __int128 v45;
  uint64_t v46;
  uint64_t v47;
  CFRange v48;
  CFRange v49;

  if (a4 != -65570)
  {
    v46 = v8;
    v47 = v9;
    v45 = 0uLL;
    CFRetain(cf);
    os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
    if (!*((_QWORD *)cf + 6))
      goto LABEL_51;
    if (a4)
    {
      v16 = -72008;
      if (a4 > -65549)
      {
        if (a4 == -65548)
        {
          v16 = -72001;
          goto LABEL_20;
        }
        if (a4 == -65540)
        {
          v16 = -72004;
          goto LABEL_20;
        }
      }
      else
      {
        if (a4 == -65555)
        {
LABEL_20:
          *((_QWORD *)cf + 3) = 10;
          *((_DWORD *)cf + 8) = v16;
          _CFTypeUnscheduleFromMultipleRunLoops(*((void **)cf + 5), *((const __CFArray **)cf + 11));
          CFSocketInvalidate(*((CFSocketRef *)cf + 5));
          CFRelease(*((CFTypeRef *)cf + 5));
          *((_QWORD *)cf + 5) = 0;
          DNSServiceRefDeallocate(*((DNSServiceRef *)cf + 6));
          *((_QWORD *)cf + 6) = 0;
          CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)cf + 8));
          CFArrayRemoveAllValues(*((CFMutableArrayRef *)cf + 9));
          CFArrayRemoveAllValues(*((CFMutableArrayRef *)cf + 10));
          goto LABEL_21;
        }
        if (a4 == -65554)
        {
          v16 = -72002;
          goto LABEL_20;
        }
      }
      v16 = -72000;
      goto LABEL_20;
    }
    if (!a5 || !a6 || !a7)
      goto LABEL_21;
    v17 = CFGetAllocator(cf);
    v18 = CFStringCreateWithCString(v17, a7, 0x8000100u);
    v19 = CFStringCreateWithCString(v17, a6, 0x8000100u);
    v20 = CFStringCreateWithCString(v17, a5, 0x8000100u);
    v21 = v20;
    if (v18 && v19 && v20)
    {
      v22 = CFNetServiceCreate(v17, v18, v19, v20, -1);
    }
    else
    {
      v22 = 0;
      v32 = 0;
      if (!v18)
        goto LABEL_34;
    }
    CFRelease(v18);
    v32 = v22;
LABEL_34:
    if (v19)
      CFRelease(v19);
    if (v21)
      CFRelease(v21);
    if (!v32)
      goto LABEL_21;
    v33 = *((_QWORD *)cf + 7);
    if ((v33 & 1) != 0)
    {
      v34 = 7;
    }
    else
    {
      if ((v33 & 2) == 0)
        goto LABEL_56;
      v34 = 9;
    }
    _ServiceSetInfo(v32, v34, (const void *)*MEMORY[0x1E0C9AE50], 0);
LABEL_56:
    Value = CFDictionaryGetValue(*((CFDictionaryRef *)cf + 8), v32);
    if ((a2 & 2) != 0)
    {
      if (!Value)
      {
        v43 = (const __CFArray *)*((_QWORD *)cf + 10);
        v49.length = CFArrayGetCount(v43);
        v49.location = 0;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v43, v49, v32);
        CFDictionaryAddValue(*((CFMutableDictionaryRef *)cf + 8), v32, (const void *)1);
        CFArrayAppendValue(*((CFMutableArrayRef *)cf + 9), v32);
        if (FirstIndexOfValue != -1)
        {
          v42 = (__CFArray *)*((_QWORD *)cf + 10);
          goto LABEL_65;
        }
LABEL_66:
        CFRelease(v32);
LABEL_21:
        v23 = (void (*)(char *, uint64_t, const void *, __int128 *, uint64_t))*((_QWORD *)cf + 12);
        v45 = *(_OWORD *)(cf + 24);
        v24 = *((_QWORD *)cf + 14);
        if (v23 && DWORD2(v45))
        {
          os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
          v23(cf, 0, 0, &v45, v24);
LABEL_52:
          CFRelease(cf);
          return;
        }
        if ((a2 & 1) == 0 && v23)
        {
          Count = CFArrayGetCount(*((CFArrayRef *)cf + 9));
          v26 = CFArrayGetCount(*((CFArrayRef *)cf + 10));
          v44 = v26;
          if (Count < 1)
          {
            v28 = v26 - 1;
            if (v26 >= 1)
            {
              v29 = *((_QWORD *)cf + 5);
LABEL_44:
              v35 = 0;
              do
              {
                ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)cf + 10), v35);
                os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
                v23(cf, (v28 != v35) | 8, ValueAtIndex, &v45, v24);
                os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
              }
              while (v29 == *((_QWORD *)cf + 5) && v44 - 1 != v35++);
            }
          }
          else
          {
            v27 = 0;
            v28 = v26 - 1;
            v29 = *((_QWORD *)cf + 5);
            v30 = v26 - 1 + Count;
            while (1)
            {
              v31 = CFArrayGetValueAtIndex(*((CFArrayRef *)cf + 9), v27);
              os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
              v23(cf, v30 != v27, v31, &v45, v24);
              os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
              if (v29 != *((_QWORD *)cf + 5))
                break;
              if (Count == ++v27)
              {
                if (v44 > 0)
                  goto LABEL_44;
                break;
              }
            }
          }
          CFArrayRemoveAllValues(*((CFMutableArrayRef *)cf + 9));
          CFArrayRemoveAllValues(*((CFMutableArrayRef *)cf + 10));
        }
LABEL_51:
        os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
        goto LABEL_52;
      }
      v39 = (const void *)(Value + 1);
    }
    else
    {
      v39 = (const void *)(Value - 1);
      if (Value == 1)
      {
        v40 = (const __CFArray *)*((_QWORD *)cf + 9);
        v48.length = CFArrayGetCount(v40);
        v48.location = 0;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v40, v48, v32);
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)cf + 8), v32);
        CFArrayAppendValue(*((CFMutableArrayRef *)cf + 10), v32);
        if (FirstIndexOfValue != -1)
        {
          v42 = (__CFArray *)*((_QWORD *)cf + 9);
LABEL_65:
          CFArrayRemoveValueAtIndex(v42, FirstIndexOfValue);
          goto LABEL_66;
        }
        goto LABEL_66;
      }
    }
    CFDictionaryReplaceValue(*((CFMutableDictionaryRef *)cf + 8), v32, v39);
    goto LABEL_66;
  }
}

BOOL _CFNetServiceBrowserSearchForServices(char *cf, uint64_t a2, uint64_t a3, uint64_t a4, CFErrorRef *a5)
{
  const void *(__cdecl *v10)(const void *);
  os_unfair_lock_s *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  const void *v18;
  CFTypeID v19;
  _BOOL8 v20;
  uint64_t v21;
  char v22;
  char v23;
  const __CFString *v24;
  UInt8 *v25;
  DNSServiceFlags v26;
  DNSServiceErrorType v27;
  const __CFAllocator *v28;
  dnssd_sock_t v29;
  __CFSocket *v30;
  __CFSocket *v31;
  CFOptionFlags SocketFlags;
  const __CFAllocator *v33;
  int v35;
  _DNSServiceRef_t *v36;
  os_unfair_lock_s *lock;
  CFIndex usedBufLen;
  CFSocketContext context;
  _QWORD v40[2];
  char regtype[1024];
  char v42[1024];
  uint64_t v43;
  CFRange v44;

  v43 = *MEMORY[0x1E0C80C00];
  if (a5)
    *a5 = 0;
  CFRetain(cf);
  v10 = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
  v11 = (os_unfair_lock_s *)(cf + 16);
  os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
  v40[0] = a3;
  v40[1] = a2;
  context.version = 0;
  context.info = cf;
  context.retain = v10;
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
  context.copyDescription = 0;
  if (!*((_QWORD *)cf + 12))
  {
    if (!a5)
    {
LABEL_35:
      v20 = 0;
      goto LABEL_37;
    }
    v20 = 0;
    *a5 = __cfnCreateCFError(0, CFSTR("kCFErrorDomainCFNetwork"), -72006, v12, v13, v14, v15, v16, 0);
    goto LABEL_32;
  }
  v17 = -72008;
  v18 = (const void *)*((_QWORD *)cf + 5);
  if (v18)
  {
    v19 = CFGetTypeID(v18);
    if (v19 == CFSocketGetTypeID())
    {
      v20 = 0;
      *((_QWORD *)cf + 3) = 10;
      *((_DWORD *)cf + 8) = -72003;
      goto LABEL_32;
    }
    _CFTypeUnscheduleFromMultipleRunLoops(*((void **)cf + 5), *((const __CFArray **)cf + 11));
    CFRunLoopSourceInvalidate(*((CFRunLoopSourceRef *)cf + 5));
    CFRelease(*((CFTypeRef *)cf + 5));
    *((_QWORD *)cf + 5) = 0;
  }
  lock = (os_unfair_lock_s *)(cf + 16);
  v21 = 0;
  v22 = 1;
  do
  {
    v23 = v22;
    v24 = (const __CFString *)v40[v21];
    if (v24)
    {
      usedBufLen = 0;
      v44.length = CFStringGetLength(v24);
      v25 = (UInt8 *)&regtype[1024 * v21];
      v44.location = 0;
      CFStringGetBytes(v24, v44, 0x8000100u, 0, 0, v25, 1023, &usedBufLen);
      v25[usedBufLen] = 0;
    }
    else
    {
      regtype[1024 * v21] = 0;
    }
    v22 = 0;
    v21 = 1;
  }
  while ((v23 & 1) != 0);
  cf[20] = 0;
  *((_QWORD *)cf + 7) = a4;
  if ((a4 & 1) != 0)
    v26 = 0x100000;
  else
    v26 = ((_DWORD)a4 << 19) & 0x100000;
  v27 = DNSServiceBrowse((DNSServiceRef *)cf + 6, v26, 0, regtype, v42, (DNSServiceBrowseReply)_BrowseReply, cf);
  *((_DWORD *)cf + 8) = v27;
  if (v27 <= -65549)
  {
    v11 = (os_unfair_lock_s *)(cf + 16);
    if (v27 == -65555)
      goto LABEL_31;
    if (v27 == -65554)
    {
      v17 = -72002;
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  if (v27 == -65548)
  {
    v17 = -72001;
    v11 = (os_unfair_lock_s *)(cf + 16);
    goto LABEL_31;
  }
  v11 = (os_unfair_lock_s *)(cf + 16);
  if (v27)
  {
    if (v27 == -65540)
    {
      v17 = -72004;
LABEL_31:
      v20 = 0;
      *((_QWORD *)cf + 3) = 10;
      *((_DWORD *)cf + 8) = v17;
      goto LABEL_32;
    }
LABEL_30:
    v17 = -72000;
    goto LABEL_31;
  }
  v28 = CFGetAllocator(cf);
  v29 = DNSServiceRefSockFD(*((DNSServiceRef *)cf + 6));
  v30 = CFSocketCreateWithNative(v28, v29, 1uLL, (CFSocketCallBack)_SocketCallBack, &context);
  v31 = v30;
  *((_QWORD *)cf + 5) = v30;
  if (v30)
  {
    SocketFlags = CFSocketGetSocketFlags(v30);
    CFSocketSetSocketFlags(v31, SocketFlags & 0xFFFFFFFFFFFFFF7FLL);
    if (CFArrayGetCount(*((CFArrayRef *)cf + 11)))
    {
      _CFTypeScheduleOnMultipleRunLoops(*((void **)cf + 5), *((const __CFArray **)cf + 11));
      v20 = 1;
      v11 = (os_unfair_lock_s *)(cf + 16);
      goto LABEL_37;
    }
    os_unfair_lock_unlock(lock);
    v20 = _BrowserBlockUntilComplete((os_unfair_lock_s *)cf);
    v11 = (os_unfair_lock_s *)(cf + 16);
    os_unfair_lock_lock(lock);
  }
  else
  {
    if (*__error())
      v35 = *__error();
    else
      v35 = 12;
    v36 = (_DNSServiceRef_t *)*((_QWORD *)cf + 6);
    *((_QWORD *)cf + 3) = 1;
    *((_DWORD *)cf + 8) = v35;
    DNSServiceRefDeallocate(v36);
    v20 = 0;
    *((_QWORD *)cf + 6) = 0;
    v11 = (os_unfair_lock_s *)(cf + 16);
  }
LABEL_32:
  if (a5 && !v20)
  {
    if (!*a5)
    {
      v33 = CFGetAllocator(cf);
      v20 = 0;
      *a5 = __cfnCreateCFErrorWithStreamError(v33, (int *)cf + 6);
      goto LABEL_37;
    }
    goto LABEL_35;
  }
LABEL_37:
  os_unfair_lock_unlock(v11);
  CFRelease(cf);
  return v20;
}

Boolean CFNetServiceBrowserSearchForServices(CFNetServiceBrowserRef browser, CFStringRef domain, CFStringRef serviceType, CFStreamError *error)
{
  _BOOL4 v5;
  Boolean v6;
  uint64_t v7;
  CFTypeRef cf;

  cf = 0;
  v5 = _CFNetServiceBrowserSearchForServices((char *)browser, (uint64_t)domain, (uint64_t)serviceType, 0, (CFErrorRef *)&cf);
  v6 = v5;
  if (error && !v5)
  {
    error->domain = _CFStreamErrorFromCFError((__CFError *)cf);
    *(_QWORD *)&error->error = v7;
  }
  if (cf)
    CFRelease(cf);
  return v6;
}

void CFNetServiceBrowserStopSearch(CFNetServiceBrowserRef browser, CFStreamError *error)
{
  CFStreamError *v3;
  os_unfair_lock_s *v4;
  void *v5;
  _DNSServiceRef_t *v6;
  const __CFAllocator *v7;
  CFRunLoopSourceRef v8;
  const __CFArray *v9;
  CFIndex Count;
  CFIndex i;
  __CFRunLoop *ValueAtIndex;
  const __CFString *v13;
  const __CFString *v14;
  CFRunLoopSourceContext v15;
  _QWORD v16[2];

  v16[0] = 10;
  if (error)
    v3 = error;
  else
    v3 = (CFStreamError *)v16;
  v4 = (os_unfair_lock_s *)((char *)browser + 16);
  os_unfair_lock_lock((os_unfair_lock_t)browser + 4);
  v5 = (void *)*((_QWORD *)browser + 5);
  if (v5)
  {
    v15.version = 0;
    v15.info = browser;
    v15.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
    v15.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
    memset(&v15.copyDescription, 0, 40);
    v15.perform = (void (__cdecl *)(void *))_BrowserCancel;
    _CFTypeUnscheduleFromMultipleRunLoops(v5, *((const __CFArray **)browser + 11));
    _CFTypeInvalidate(*((char **)browser + 5));
    CFRelease(*((CFTypeRef *)browser + 5));
    v6 = (_DNSServiceRef_t *)*((_QWORD *)browser + 6);
    if (v6)
    {
      DNSServiceRefDeallocate(v6);
      *((_QWORD *)browser + 6) = 0;
      CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)browser + 8));
      CFArrayRemoveAllValues(*((CFMutableArrayRef *)browser + 9));
      CFArrayRemoveAllValues(*((CFMutableArrayRef *)browser + 10));
    }
    v16[1] = 4294895291;
    *(CFStreamError *)((char *)browser + 24) = *v3;
    v7 = CFGetAllocator(browser);
    v8 = CFRunLoopSourceCreate(v7, 0, &v15);
    *((_QWORD *)browser + 5) = v8;
    if (v8)
    {
      v9 = (const __CFArray *)*((_QWORD *)browser + 11);
      Count = CFArrayGetCount(v9);
      _CFTypeScheduleOnMultipleRunLoops(*((void **)browser + 5), v9);
      CFRunLoopSourceSignal(*((CFRunLoopSourceRef *)browser + 5));
      if (Count >= 1)
      {
        for (i = 0; i < Count; i += 2)
        {
          ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v9, i);
          if (CFRunLoopIsWaiting(ValueAtIndex))
          {
            v13 = CFRunLoopCopyCurrentMode(ValueAtIndex);
            if (v13)
            {
              v14 = v13;
              if (CFRunLoopContainsSource(ValueAtIndex, *((CFRunLoopSourceRef *)browser + 5), v13))
                CFRunLoopWakeUp(ValueAtIndex);
              CFRelease(v14);
            }
          }
        }
      }
    }
  }
  os_unfair_lock_unlock(v4);
}

void _BrowserCancel(__CFNetServiceBrowser *a1)
{
  void *v2;
  void (*v3)(__CFNetServiceBrowser *, _QWORD, _QWORD, __int128 *, uint64_t);
  void (*v4)(_QWORD);
  uint64_t v5;
  void (*v6)(uint64_t);
  BOOL v7;
  __int128 v9;

  CFRetain(a1);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  v2 = (void *)*((_QWORD *)a1 + 5);
  if (v2)
  {
    v3 = (void (*)(__CFNetServiceBrowser *, _QWORD, _QWORD, __int128 *, uint64_t))*((_QWORD *)a1 + 12);
    v9 = *(_OWORD *)((char *)a1 + 24);
    v5 = *((_QWORD *)a1 + 14);
    v4 = (void (*)(_QWORD))*((_QWORD *)a1 + 15);
    v6 = (void (*)(uint64_t))*((_QWORD *)a1 + 16);
    if (v3)
      v7 = v5 == 0;
    else
      v7 = 1;
    if (!v7 && v4 != 0)
    {
      v4(*((_QWORD *)a1 + 14));
      v2 = (void *)*((_QWORD *)a1 + 5);
    }
    _CFTypeUnscheduleFromMultipleRunLoops(v2, *((const __CFArray **)a1 + 11));
    CFRunLoopSourceInvalidate(*((CFRunLoopSourceRef *)a1 + 5));
    CFRelease(*((CFTypeRef *)a1 + 5));
    *((_QWORD *)a1 + 5) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
    if (v3)
    {
      v3(a1, 0, 0, &v9, v5);
      if (v5)
      {
        if (v6)
          v6(v5);
      }
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
  }
  CFRelease(a1);
}

void std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        v4 = std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v4 - 16);
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t ___ZN11URLProtocol20sendDidFinishLoadingEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 199;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
  abort();
}

void std::__shared_ptr_emplace<HTTP3Connection>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0A98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTP3Connection>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0A98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void ___ZN25HTTP3ConnectionCacheEntry16connectionClosedENSt3__110shared_ptrI15HTTP3ConnectionEE_block_invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  __int128 v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  std::__shared_weak_count *v17;
  std::__shared_weak_count *v18;
  HTTP3ConnectionCache *v19;
  unint64_t *v20;
  unint64_t v21;

  v1 = a1[4];
  v2 = a1[6];
  v3 = (std::__shared_weak_count *)a1[7];
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v6 = *(_QWORD **)(v1 + 104);
  v7 = *(_QWORD *)(v1 + 112);
  v8 = v6;
  if (v6 != (_QWORD *)v7)
  {
    while (*v8 != v2)
    {
      v8 += 2;
      if (v8 == (_QWORD *)v7)
      {
        v8 = *(_QWORD **)(v1 + 112);
        break;
      }
    }
  }
  if (v8 == (_QWORD *)v7)
  {
    v8 = *(_QWORD **)(v1 + 112);
  }
  else
  {
    v9 = v8 + 2;
    if (v8 + 2 != (_QWORD *)v7)
    {
      do
      {
        v10 = *(_OWORD *)v9;
        *v9 = 0;
        v9[1] = 0;
        v11 = (std::__shared_weak_count *)v8[1];
        *(_OWORD *)v8 = v10;
        if (v11)
        {
          v12 = (unint64_t *)&v11->__shared_owners_;
          do
            v13 = __ldaxr(v12);
          while (__stlxr(v13 - 1, v12));
          if (!v13)
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
        }
        v9 += 2;
        v8 += 2;
      }
      while (v9 != (_QWORD *)v7);
      v7 = *(_QWORD *)(v1 + 112);
    }
    while ((_QWORD *)v7 != v8)
    {
      v7 -= 16;
      std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v7);
    }
    *(_QWORD *)(v1 + 112) = v8;
    v6 = *(_QWORD **)(v1 + 104);
  }
  if (v8 == v6)
  {
    v16 = *(std::__shared_weak_count **)(v1 + 32);
    if (v16)
    {
      v17 = std::__shared_weak_count::lock(v16);
      if (v17)
      {
        v18 = v17;
        v19 = *(HTTP3ConnectionCache **)(v1 + 24);
        if (v19)
          HTTP3ConnectionCache::_entryRemove(v19, *(const HTTPConnectionCacheKey **)(v1 + 80));
        v20 = (unint64_t *)&v18->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
    }
  }
  if (v3)
  {
    v14 = (unint64_t *)&v3->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_183FFA88C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_ea8_32c53_ZTSNSt3__110shared_ptrI25HTTP3ConnectionCacheEntryEE48c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c53_ZTSNSt3__110shared_ptrI25HTTP3ConnectionCacheEntryEE48c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 32;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void _CFTypeScheduleOnRunLoop(void *a1, uint64_t a2, uint64_t a3)
{
  CFTypeID v6;
  void *RunLoopSource;
  const __CFAllocator *v8;
  const __CFAllocator *v9;
  CFTypeRef v10;
  void (*v11)(uint64_t, CFTypeRef, uint64_t);
  void (*v12)(void *, uint64_t, uint64_t);

  v6 = CFGetTypeID(a1);
  if (v6 == CFRunLoopSourceGetTypeID())
  {
    RunLoopSource = (void *)CFRetain(a1);
  }
  else if (v6 == CFMachPortGetTypeID())
  {
    v8 = CFGetAllocator(a1);
    RunLoopSource = CFMachPortCreateRunLoopSource(v8, (CFMachPortRef)a1, 0);
  }
  else
  {
    if (v6 != CFSocketGetTypeID())
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      if (v6 == *(_QWORD *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
      {
        v12 = (void (*)(void *, uint64_t, uint64_t))CoreReadStreamScheduleWithRunLoop;
      }
      else
      {
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
        if (v6 == *(_QWORD *)(CoreWriteStream::Class(void)::sClass_OBJTYPE + 96))
        {
          v12 = (void (*)(void *, uint64_t, uint64_t))CoreWriteStreamScheduleWithRunLoop;
        }
        else if (v6 == CFReadStreamGetTypeID())
        {
          v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1E0C98B90];
        }
        else if (v6 == CFWriteStreamGetTypeID())
        {
          v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1E0C99658];
        }
        else
        {
          if (HostBase::Class(void)::sOnce_HostBase != -1)
            dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
          if (v6 == *(_QWORD *)(HostBase::Class(void)::sClass_OBJTYPE + 96))
          {
            v12 = (void (*)(void *, uint64_t, uint64_t))CFHostScheduleWithRunLoop;
          }
          else if (v6 == SCNetworkReachabilityGetTypeID())
          {
            v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1E0CE88E8];
          }
          else
          {
            if (v6 == CFRunLoopTimerGetTypeID())
            {
              v10 = CFRetain(a1);
              v11 = (void (*)(uint64_t, CFTypeRef, uint64_t))MEMORY[0x1E0C98C00];
              if (v10)
                goto LABEL_8;
              return;
            }
            if (v6 == CFNetServiceGetTypeID())
            {
              v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceScheduleWithRunLoop;
            }
            else if (v6 == CFNetServiceBrowserGetTypeID())
            {
              v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceBrowserScheduleWithRunLoop;
            }
            else if (v6 == CFNetServiceMonitorGetTypeID())
            {
              v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceMonitorScheduleWithRunLoop;
            }
            else
            {
              if (v6 != SCNetworkConnectionGetTypeID())
                return;
              v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1E0CE8828];
            }
          }
        }
      }
      v12(a1, a2, a3);
      return;
    }
    v9 = CFGetAllocator(a1);
    RunLoopSource = CFSocketCreateRunLoopSource(v9, (CFSocketRef)a1, 0);
  }
  v10 = RunLoopSource;
  v11 = (void (*)(uint64_t, CFTypeRef, uint64_t))MEMORY[0x1E0C98BF8];
  if (RunLoopSource)
  {
LABEL_8:
    v11(a2, v10, a3);
    CFRelease(v10);
  }
}

void _CFTypeUnscheduleFromRunLoop(void *a1, uint64_t a2, uint64_t a3)
{
  CFTypeID v6;
  void *RunLoopSource;
  const __CFAllocator *v8;
  const __CFAllocator *v9;
  CFTypeRef v10;
  void (*v11)(uint64_t, CFTypeRef, uint64_t);
  void (*v12)(void *, uint64_t, uint64_t);

  v6 = CFGetTypeID(a1);
  if (v6 == CFRunLoopSourceGetTypeID())
  {
    RunLoopSource = (void *)CFRetain(a1);
  }
  else if (v6 == CFMachPortGetTypeID())
  {
    v8 = CFGetAllocator(a1);
    RunLoopSource = CFMachPortCreateRunLoopSource(v8, (CFMachPortRef)a1, 0);
  }
  else
  {
    if (v6 != CFSocketGetTypeID())
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      if (v6 == *(_QWORD *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
      {
        v12 = (void (*)(void *, uint64_t, uint64_t))CoreReadStreamUnscheduleFromRunLoop;
      }
      else
      {
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
        if (v6 == *(_QWORD *)(CoreWriteStream::Class(void)::sClass_OBJTYPE + 96))
        {
          v12 = (void (*)(void *, uint64_t, uint64_t))CoreWriteStreamUnscheduleFromRunLoop;
        }
        else if (v6 == CFReadStreamGetTypeID())
        {
          v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1E0C98BB8];
        }
        else if (v6 == CFWriteStreamGetTypeID())
        {
          v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1E0C99680];
        }
        else
        {
          if (HostBase::Class(void)::sOnce_HostBase != -1)
            dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
          if (v6 == *(_QWORD *)(HostBase::Class(void)::sClass_OBJTYPE + 96))
          {
            v12 = (void (*)(void *, uint64_t, uint64_t))CFHostUnscheduleFromRunLoop;
          }
          else if (v6 == SCNetworkReachabilityGetTypeID())
          {
            v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1E0CE8900];
          }
          else
          {
            if (v6 == CFRunLoopTimerGetTypeID())
            {
              v10 = CFRetain(a1);
              v11 = (void (*)(uint64_t, CFTypeRef, uint64_t))MEMORY[0x1E0C98CA0];
              if (v10)
                goto LABEL_8;
              return;
            }
            if (v6 == CFNetServiceGetTypeID())
            {
              v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceUnscheduleFromRunLoop;
            }
            else if (v6 == CFNetServiceBrowserGetTypeID())
            {
              v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceBrowserUnscheduleFromRunLoop;
            }
            else if (v6 == CFNetServiceMonitorGetTypeID())
            {
              v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceMonitorUnscheduleFromRunLoop;
            }
            else
            {
              if (v6 != SCNetworkConnectionGetTypeID())
                return;
              v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1E0CE8830];
            }
          }
        }
      }
      v12(a1, a2, a3);
      return;
    }
    v9 = CFGetAllocator(a1);
    RunLoopSource = CFSocketCreateRunLoopSource(v9, (CFSocketRef)a1, 0);
  }
  v10 = RunLoopSource;
  v11 = (void (*)(uint64_t, CFTypeRef, uint64_t))MEMORY[0x1E0C98C90];
  if (RunLoopSource)
  {
LABEL_8:
    v11(a2, v10, a3);
    CFRelease(v10);
  }
}

void _CFTypeUnscheduleFromMultipleRunLoops(void *a1, const __CFArray *a2)
{
  CFTypeID v4;
  void *RunLoopSource;
  const __CFAllocator *v6;
  const __CFAllocator *v7;
  CFTypeRef v8;
  void (*v9)(const void *, CFTypeRef, const void *);
  CFIndex Count;
  CFIndex v11;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v14;
  void (*v15)(void *, const void *, const void *);
  CFIndex v16;
  CFIndex v17;
  CFIndex j;
  const void *v19;
  const void *v20;

  v4 = CFGetTypeID(a1);
  if (v4 == CFRunLoopSourceGetTypeID())
  {
    RunLoopSource = (void *)CFRetain(a1);
    goto LABEL_7;
  }
  if (v4 == CFMachPortGetTypeID())
  {
    v6 = CFGetAllocator(a1);
    RunLoopSource = CFMachPortCreateRunLoopSource(v6, (CFMachPortRef)a1, 0);
    goto LABEL_7;
  }
  if (v4 == CFSocketGetTypeID())
  {
    v7 = CFGetAllocator(a1);
    RunLoopSource = CFSocketCreateRunLoopSource(v7, (CFSocketRef)a1, 0);
LABEL_7:
    v8 = RunLoopSource;
    v9 = (void (*)(const void *, CFTypeRef, const void *))MEMORY[0x1E0C98C90];
    if (!RunLoopSource)
      return;
LABEL_8:
    Count = CFArrayGetCount(a2);
    if (Count >= 1)
    {
      v11 = Count;
      for (i = 0; i < v11; i += 2)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
        v14 = CFArrayGetValueAtIndex(a2, i + 1);
        v9(ValueAtIndex, v8, v14);
      }
    }
    CFRelease(v8);
    return;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  if (v4 == *(_QWORD *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
  {
    v15 = (void (*)(void *, const void *, const void *))CoreReadStreamUnscheduleFromRunLoop;
  }
  else
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    if (v4 == *(_QWORD *)(CoreWriteStream::Class(void)::sClass_OBJTYPE + 96))
    {
      v15 = (void (*)(void *, const void *, const void *))CoreWriteStreamUnscheduleFromRunLoop;
    }
    else if (v4 == CFReadStreamGetTypeID())
    {
      v15 = (void (*)(void *, const void *, const void *))MEMORY[0x1E0C98BB8];
    }
    else if (v4 == CFWriteStreamGetTypeID())
    {
      v15 = (void (*)(void *, const void *, const void *))MEMORY[0x1E0C99680];
    }
    else
    {
      if (HostBase::Class(void)::sOnce_HostBase != -1)
        dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
      if (v4 == *(_QWORD *)(HostBase::Class(void)::sClass_OBJTYPE + 96))
      {
        v15 = (void (*)(void *, const void *, const void *))CFHostUnscheduleFromRunLoop;
      }
      else if (v4 == SCNetworkReachabilityGetTypeID())
      {
        v15 = (void (*)(void *, const void *, const void *))MEMORY[0x1E0CE8900];
      }
      else
      {
        if (v4 == CFRunLoopTimerGetTypeID())
        {
          v8 = CFRetain(a1);
          v9 = (void (*)(const void *, CFTypeRef, const void *))MEMORY[0x1E0C98CA0];
          if (!v8)
            return;
          goto LABEL_8;
        }
        if (v4 == CFNetServiceGetTypeID())
        {
          v15 = (void (*)(void *, const void *, const void *))CFNetServiceUnscheduleFromRunLoop;
        }
        else if (v4 == CFNetServiceBrowserGetTypeID())
        {
          v15 = (void (*)(void *, const void *, const void *))CFNetServiceBrowserUnscheduleFromRunLoop;
        }
        else if (v4 == CFNetServiceMonitorGetTypeID())
        {
          v15 = (void (*)(void *, const void *, const void *))CFNetServiceMonitorUnscheduleFromRunLoop;
        }
        else
        {
          if (v4 != SCNetworkConnectionGetTypeID())
            return;
          v15 = (void (*)(void *, const void *, const void *))MEMORY[0x1E0CE8830];
        }
      }
    }
  }
  v16 = CFArrayGetCount(a2);
  if (v16 >= 1)
  {
    v17 = v16;
    for (j = 0; j < v17; j += 2)
    {
      v19 = CFArrayGetValueAtIndex(a2, j);
      v20 = CFArrayGetValueAtIndex(a2, j + 1);
      v15(a1, v19, v20);
    }
  }
}

void _CFTypeInvalidate(char *a1)
{
  CFTypeID v2;
  char *v3;

  v2 = CFGetTypeID(a1);
  if (v2 == CFRunLoopSourceGetTypeID())
  {
    CFRunLoopSourceInvalidate((CFRunLoopSourceRef)a1);
  }
  else if (v2 == CFMachPortGetTypeID())
  {
    CFMachPortInvalidate((CFMachPortRef)a1);
  }
  else if (v2 == CFSocketGetTypeID())
  {
    CFSocketInvalidate((CFSocketRef)a1);
  }
  else
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (v2 == *(_QWORD *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
      goto LABEL_13;
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    if (v2 == *(_QWORD *)(CoreWriteStream::Class(void)::sClass_OBJTYPE + 96))
    {
LABEL_13:
      if (a1)
        v3 = a1 + 16;
      else
        v3 = 0;
      (*(void (**)(char *, _QWORD, _QWORD))(*(_QWORD *)v3 + 56))(v3, 0, 0);
    }
    else if (v2 == CFReadStreamGetTypeID())
    {
      CFReadStreamSetClient((CFReadStreamRef)a1, 0, 0, 0);
    }
    else if (v2 == CFWriteStreamGetTypeID())
    {
      CFWriteStreamSetClient((CFWriteStreamRef)a1, 0, 0, 0);
    }
    else
    {
      if (HostBase::Class(void)::sOnce_HostBase != -1)
        dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
      if (v2 == *(_QWORD *)(HostBase::Class(void)::sClass_OBJTYPE + 96))
      {
        CFHostSetClient((CFHostRef)a1, 0, 0);
      }
      else if (v2 == SCNetworkReachabilityGetTypeID())
      {
        SCNetworkReachabilitySetCallback((SCNetworkReachabilityRef)a1, 0, 0);
      }
      else if (v2 == CFRunLoopTimerGetTypeID())
      {
        CFRunLoopTimerInvalidate((CFRunLoopTimerRef)a1);
      }
      else if (v2 == CFNetServiceGetTypeID())
      {
        CFNetServiceSetClient((CFNetServiceRef)a1, 0, 0);
      }
      else if (v2 == CFNetServiceBrowserGetTypeID())
      {
        CFNetServiceBrowserInvalidate((CFNetServiceBrowserRef)a1);
      }
      else if (v2 == CFNetServiceMonitorGetTypeID())
      {
        CFNetServiceMonitorInvalidate((CFNetServiceMonitorRef)a1);
      }
    }
  }
}

void sub_183FFB52C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_183FFB78C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_183FFB82C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183FFC254(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  v9 = v8;

  _Unwind_Resume(a1);
}

void ___ZL22supportedDraftVersionsv_block_invoke()
{
  uint64_t v0;
  void *v1;

  objc_msgSend(MEMORY[0x1E0C99E20], "setWithObjects:", CFSTR("3"), CFSTR("5"), 0);
  v0 = objc_claimAutoreleasedReturnValue();
  v1 = (void *)supportedDraftVersions(void)::supportedDraftVersions;
  supportedDraftVersions(void)::supportedDraftVersions = v0;

}

void ___ZL17resumeDataClassesv_block_invoke_1526()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  v0 = (void *)MEMORY[0x1E0C99E20];
  v1 = objc_opt_class();
  v2 = objc_opt_class();
  v3 = objc_opt_class();
  v4 = objc_opt_class();
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  objc_msgSend(v0, "setWithObjects:", v1, v2, v3, v4, v5, v6, objc_opt_class(), 0);
  v7 = objc_claimAutoreleasedReturnValue();
  v8 = (void *)resumeDataClasses(void)::resumeDataClasses;
  resumeDataClasses(void)::resumeDataClasses = v7;

}

void sub_183FFC530(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183FFC62C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_183FFC7C4(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void sub_183FFCB64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  void *v10;

  _Unwind_Resume(a1);
}

void AuthLiaison::~AuthLiaison(AuthLiaison *this)
{
  AuthLiaison::~AuthLiaison(this);
  JUMPOUT(0x186DB748CLL);
}

{
  char *v2;

  *(_QWORD *)this = &off_1E14E4C88;
  v2 = (char *)this + 40;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 5) + 24))(*((_QWORD *)this + 5));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 24);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
  *(_QWORD *)this = &off_1E14E5838;
}

void sub_183FFCC50(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 3));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 1));
  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void AuthLiaison::negotiateAuthentication(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t *a5, HTTPResponseMessage **a6, uint64_t *a7)
{
  _QWORD *v12;
  const void *v13;
  std::__shared_weak_count_vtbl *v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  uint64_t *v17;
  _BOOL4 isValid;
  AuthenticationState *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  uint64_t Auth;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  NSObject *v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  unsigned __int16 v37;
  const __CFString *v38;
  CFURLRef v39;
  uint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *p_shared_owners;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  std::__shared_weak_count *v47;
  uint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  unint64_t *v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t *v55;
  unint64_t v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  std::__shared_weak_count *v69;
  unint64_t *v70;
  unint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  std::__shared_weak_count *v75;
  unint64_t *v76;
  unint64_t v77;
  uint64_t v78;
  std::__shared_weak_count *v79;
  unint64_t *v80;
  unint64_t v81;
  unint64_t *v82;
  unint64_t v83;
  unint64_t *v84;
  std::__shared_weak_count *v85;
  unint64_t *v86;
  unint64_t v87;
  _QWORD v88[7];
  std::__shared_weak_count *v89;
  std::__shared_weak_count_vtbl *v90;
  std::__shared_weak_count *v91;
  uint64_t v92;
  std::__shared_weak_count *v93;
  uint64_t v94;
  std::__shared_weak_count *v95;
  HTTPResponseMessage *v96;
  std::__shared_weak_count *v97;
  uint64_t v98;
  std::__shared_weak_count *v99;
  uint64_t v100;
  std::__shared_weak_count *v101;
  uint64_t v102;
  std::__shared_weak_count *v103;
  uint64_t v104;
  uint64_t *v105;
  uint64_t v106;
  __n128 (*v107)(__n128 *, __n128 *);
  uint64_t (*v108)();
  void *v109;
  uint64_t v110;
  uint64_t v111;
  std::__shared_weak_count_vtbl *v112;
  std::__shared_weak_count *v113;
  uint8_t buf[24];
  uint64_t v115;

  v115 = *MEMORY[0x1E0C80C00];
  v12 = (_QWORD *)(a1 + 40);
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(a1 + 40), a2, a3);
  if ((*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 32))(*(_QWORD *)(a1 + 40)))
  {
    v13 = (const void *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*v12 + 32))(*v12);
    v14 = (std::__shared_weak_count_vtbl *)CFRetain(v13);
  }
  else
  {
    v14 = 0;
  }
  v112 = v14;
  v15 = (std::__shared_weak_count *)operator new();
  v15->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19E8;
  v15->__shared_owners_ = 0;
  v15->__shared_weak_owners_ = 0;
  v15[1].__vftable = v14;
  v113 = v15;
  v104 = 0;
  v105 = &v104;
  v106 = 0x4012000000;
  v107 = __Block_byref_object_copy__1584;
  v108 = __Block_byref_object_dispose__1585;
  v110 = 0;
  v111 = 0;
  v109 = &unk_18422E08D;
  v17 = (uint64_t *)(a1 + 24);
  v16 = *(_QWORD *)(a1 + 24);
  if (!v16)
  {
LABEL_29:
    (*(void (**)(uint8_t *__return_ptr))(*(_QWORD *)*a4 + 72))(buf);
    v36 = *(_QWORD *)buf;
    v37 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a4 + 64))(*a4);
    v38 = CFStringCreateWithFormat(0, 0, CFSTR("%@://%@:%d"), 0x1EDD00AE0, v36, v37);
    v39 = CFURLCreateWithString(0, v38, 0);
    HTTPResponseMessage::setResponseURL(*a6, v39, 1);
    v40 = *v12;
    v41 = (std::__shared_weak_count *)a4[1];
    v98 = *a4;
    v99 = v41;
    if (v41)
    {
      p_shared_owners = (unint64_t *)&v41->__shared_owners_;
      do
        v43 = __ldxr(p_shared_owners);
      while (__stxr(v43 + 1, p_shared_owners));
    }
    v44 = (std::__shared_weak_count *)a6[1];
    v96 = *a6;
    v97 = v44;
    if (v44)
    {
      v45 = (unint64_t *)&v44->__shared_owners_;
      do
        v46 = __ldxr(v45);
      while (__stxr(v46 + 1, v45));
    }
    v88[0] = MEMORY[0x1E0C809B0];
    v88[1] = 3321888768;
    v88[2] = ___ZN11AuthLiaison23negotiateAuthenticationENSt3__110shared_ptrI14MetaAuthClientEENS1_I12NetworkProxyEENS1_I18HTTPRequestMessageEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJS7_13CFStreamErrorEE_block_invoke;
    v88[3] = &unk_1E14F4900;
    v48 = *a5;
    v47 = (std::__shared_weak_count *)a5[1];
    v88[5] = a1;
    v88[6] = v48;
    v89 = v47;
    if (v47)
    {
      v49 = (unint64_t *)&v47->__shared_owners_;
      do
        v50 = __ldxr(v49);
      while (__stxr(v50 + 1, v49));
    }
    v90 = v112;
    v91 = v113;
    if (v113)
    {
      v51 = (unint64_t *)&v113->__shared_owners_;
      do
        v52 = __ldxr(v51);
      while (__stxr(v52 + 1, v51));
    }
    v54 = *a7;
    v53 = a7[1];
    v88[4] = &v104;
    v92 = v54;
    v93 = (std::__shared_weak_count *)v53;
    if (v53)
    {
      v55 = (unint64_t *)(v53 + 8);
      do
        v56 = __ldxr(v55);
      while (__stxr(v56 + 1, v55));
    }
    SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::SmartBlockWithArgs(&v94, v88);
    (*(void (**)(uint64_t, uint64_t *, HTTPResponseMessage **, uint64_t *))(*(_QWORD *)v40 + 16))(v40, &v98, &v96, &v94);
    v57 = v95;
    if (v95)
    {
      v58 = (unint64_t *)&v95->__shared_owners_;
      do
        v59 = __ldaxr(v58);
      while (__stlxr(v59 - 1, v58));
      if (!v59)
      {
        ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
        std::__shared_weak_count::__release_weak(v57);
      }
    }
    v60 = v97;
    if (v97)
    {
      v61 = (unint64_t *)&v97->__shared_owners_;
      do
        v62 = __ldaxr(v61);
      while (__stlxr(v62 - 1, v61));
      if (!v62)
      {
        ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
        std::__shared_weak_count::__release_weak(v60);
      }
    }
    v63 = v99;
    if (v99)
    {
      v64 = (unint64_t *)&v99->__shared_owners_;
      do
        v65 = __ldaxr(v64);
      while (__stlxr(v65 - 1, v64));
      if (!v65)
      {
        ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
        std::__shared_weak_count::__release_weak(v63);
      }
    }
    v66 = v93;
    if (v93)
    {
      v67 = (unint64_t *)&v93->__shared_owners_;
      do
        v68 = __ldaxr(v67);
      while (__stlxr(v68 - 1, v67));
      if (!v68)
      {
        ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
        std::__shared_weak_count::__release_weak(v66);
      }
    }
    v69 = v91;
    if (v91)
    {
      v70 = (unint64_t *)&v91->__shared_owners_;
      do
        v71 = __ldaxr(v70);
      while (__stlxr(v71 - 1, v70));
      if (!v71)
      {
        ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
        std::__shared_weak_count::__release_weak(v69);
      }
    }
    v72 = v89;
    if (v89)
    {
      v73 = (unint64_t *)&v89->__shared_owners_;
      do
        v74 = __ldaxr(v73);
      while (__stlxr(v74 - 1, v73));
      if (!v74)
      {
        ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
        std::__shared_weak_count::__release_weak(v72);
      }
    }
    if (v39)
      CFRelease(v39);
    if (v38)
      CFRelease(v38);
    v75 = *(std::__shared_weak_count **)&buf[8];
    if (!*(_QWORD *)&buf[8])
      goto LABEL_97;
    v76 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v77 = __ldaxr(v76);
    while (__stlxr(v77 - 1, v76));
    goto LABEL_94;
  }
  (*(void (**)(uint64_t, HTTPResponseMessage *, uint64_t))(*(_QWORD *)v16 + 16))(v16, *a6, a1);
  isValid = AuthenticationState::isValid(*v17, 0);
  v19 = (AuthenticationState *)*v17;
  if (!isValid)
  {
    if (v19)
    {
      Auth = AuthenticationState::getAuth(v19, 1);
      if (!Auth)
      {
        v30 = 0;
        v31 = 0;
        goto LABEL_83;
      }
      v28 = (uint64_t *)(Auth + 88);
      v29 = (uint64_t *)(Auth + 96);
    }
    else
    {
      v28 = v105 + 6;
      v29 = v105 + 7;
    }
    v30 = *v29;
    v31 = *v28;
    if (*v28 == 4 && *v29 == 4294966295)
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v32 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        *(_QWORD *)&buf[4] = v14;
        _os_log_impl(&dword_183ECA000, v32, OS_LOG_TYPE_DEFAULT, "Proxy credentials had a bad username/password, trying again %{public}@", buf, 0xCu);
      }
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = 0;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 24, (__int128 *)buf);
      v33 = *(std::__shared_weak_count **)&buf[8];
      if (*(_QWORD *)&buf[8])
      {
        v34 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v35 = __ldaxr(v34);
        while (__stlxr(v35 - 1, v34));
        if (!v35)
        {
          ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
          std::__shared_weak_count::__release_weak(v33);
        }
      }
      goto LABEL_29;
    }
LABEL_83:
    v78 = *a5;
    v79 = (std::__shared_weak_count *)a5[1];
    v100 = v78;
    v101 = v79;
    if (v79)
    {
      v80 = (unint64_t *)&v79->__shared_owners_;
      do
        v81 = __ldxr(v80);
      while (__stxr(v81 + 1, v80));
    }
    SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::operator()(*a7, v78, v79, v31, v30);
    if (v79)
    {
      v82 = (unint64_t *)&v79->__shared_owners_;
      do
        v83 = __ldaxr(v82);
      while (__stlxr(v83 - 1, v82));
      if (!v83)
      {
        ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
        std::__shared_weak_count::__release_weak(v79);
      }
    }
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 24, (__int128 *)buf);
    v75 = *(std::__shared_weak_count **)&buf[8];
    if (!*(_QWORD *)&buf[8])
      goto LABEL_97;
    v84 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v77 = __ldaxr(v84);
    while (__stlxr(v77 - 1, v84));
LABEL_94:
    if (v77)
      goto LABEL_97;
    ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
    v26 = v75;
    goto LABEL_96;
  }
  (*(void (**)(AuthenticationState *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v19 + 24))(v19, *a5, a1, 1);
  v20 = *a5;
  v21 = (std::__shared_weak_count *)a5[1];
  v102 = *a5;
  v103 = v21;
  if (v21)
  {
    v22 = (unint64_t *)&v21->__shared_owners_;
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }
  SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::operator()(*a7, v20, v21, v105[6], v105[7]);
  if (v21)
  {
    v24 = (unint64_t *)&v21->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      v26 = v21;
LABEL_96:
      std::__shared_weak_count::__release_weak(v26);
    }
  }
LABEL_97:
  _Block_object_dispose(&v104, 8);
  v85 = v113;
  if (v113)
  {
    v86 = (unint64_t *)&v113->__shared_owners_;
    do
      v87 = __ldaxr(v86);
    while (__stlxr(v87 - 1, v86));
    if (!v87)
    {
      ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
      std::__shared_weak_count::__release_weak(v85);
    }
  }
}

void sub_183FFD360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  uint64_t v31;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a31);
  _Block_object_dispose((const void *)(v31 - 192), 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v31 - 128);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__1584(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  return result;
}

void SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::operator()(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t a5)
{
  unint64_t *p_shared_owners;
  unint64_t v6;
  void (*v7)(_QWORD *, uint64_t *, uint64_t, uint64_t);
  uint64_t v8;
  _QWORD *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v18;
  std::__shared_weak_count *v19;

  if (a1)
  {
    if (a3)
    {
      p_shared_owners = (unint64_t *)&a3->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }
    v7 = *(void (**)(_QWORD *, uint64_t *, uint64_t, uint64_t))(a1 + 8);
    v8 = *(_QWORD *)(a1 + 16);
    v9 = (_QWORD *)(a1 + (v8 >> 1));
    if ((v8 & 1) != 0)
      v7 = *(void (**)(_QWORD *, uint64_t *, uint64_t, uint64_t))(*v9 + v7);
    v18 = a2;
    v19 = a3;
    if (a3)
    {
      v10 = (unint64_t *)&a3->__shared_owners_;
      do
        v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }
    v7(v9, &v18, a4, a5);
    v12 = v19;
    if (v19)
    {
      v13 = (unint64_t *)&v19->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    if (a3)
    {
      v15 = (unint64_t *)&a3->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
        std::__shared_weak_count::__release_weak(a3);
      }
    }
  }
}

void sub_183FFD52C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN11AuthLiaison23negotiateAuthenticationENSt3__110shared_ptrI14MetaAuthClientEENS1_I12NetworkProxyEENS1_I18HTTPRequestMessageEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJS7_13CFStreamErrorEE_block_invoke(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint8_t buf[4];
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (*a2
    && (v4 = *(_QWORD *)(a1 + 40),
        AuthenticationState::canApplyHeadersToRequest((AuthenticationState *)*a2, *(HTTPRequestMessage **)(a1 + 48))))
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v4 + 24), *a2, a2[1]);
    if ((*(unsigned int (**)(_QWORD, _QWORD, uint64_t, uint64_t))(**(_QWORD **)(v4 + 24) + 24))(*(_QWORD *)(v4 + 24), *(_QWORD *)(a1 + 48), v4, 1))
    {
      if (UnitTestNotificationCenter::shared(void)::onceToken != -1)
        dispatch_once(&UnitTestNotificationCenter::shared(void)::onceToken, &__block_literal_global_1589);
      NotificationStation::notifyPropertyChanged((NotificationStation *)UnitTestNotificationCenter::shared(void)::shared, CFSTR("AuthBrokerQueryCount"), (const void *)*MEMORY[0x1E0C9AE50]);
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v5 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v6 = *(_QWORD *)(a1 + 64);
        *(_DWORD *)buf = 138543362;
        v19 = v6;
        _os_log_impl(&dword_183ECA000, v5, OS_LOG_TYPE_DEFAULT, "Applied proxy auth to %{public}@", buf, 0xCu);
      }
    }
    else
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v15 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        v16 = *(_QWORD *)(a1 + 64);
        *(_DWORD *)buf = 138543362;
        v19 = v16;
        _os_log_error_impl(&dword_183ECA000, v15, OS_LOG_TYPE_ERROR, "Failed to apply proxy auth to %{public}@", buf, 0xCu);
      }
    }
  }
  else
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v7 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v17 = *(_QWORD *)(a1 + 64);
      *(_DWORD *)buf = 138543362;
      v19 = v17;
      _os_log_error_impl(&dword_183ECA000, v7, OS_LOG_TYPE_ERROR, "Failed to get applicable proxy auth %{public}@", buf, 0xCu);
    }
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    *(_QWORD *)(v8 + 48) = 4;
    *(_DWORD *)(v8 + 56) = -2097;
  }
  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(std::__shared_weak_count **)(a1 + 56);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::operator()(*(_QWORD *)(a1 + 80), v9, v10, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 56));
  if (v10)
  {
    v13 = (unint64_t *)&v10->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_183FFD824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t *SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::SmartBlockWithArgs(uint64_t *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  v4 = (_QWORD *)operator new();
  v4[1] = BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_initial;
  v4[2] = 0;
  *v4 = _Block_copy(a2);
  *a1 = (uint64_t)v4;
  v5 = (_QWORD *)operator new();
  *v5 = &off_1E14F1240;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a1[1] = (uint64_t)v5;
  if (!a2)
  {
    v6 = *a1;
    *(_QWORD *)(v6 + 8) = BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_reseted;
    *(_QWORD *)(v6 + 16) = 0;
  }
  return a1;
}

void sub_183FFD8DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_initial(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  a1[1] = (uint64_t)BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_normal;
  a1[2] = 0;
  v2 = *a1;
  v3 = (std::__shared_weak_count *)a2[1];
  v9 = *a2;
  v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v9);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_183FFD994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<AuthenticationState>> *,SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<AuthenticationState>>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<AuthenticationState>> *,SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<AuthenticationState>>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void (*v3)(uint64_t *, uint64_t *);
  BOOL v4;
  int v5;
  uint64_t *v7;
  void (*v8)(uint64_t *, uint64_t *);
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v13;
  std::__shared_weak_count *v14;

  v1 = *(_QWORD *)(a1 + 24);
  v3 = *(void (**)(uint64_t *, uint64_t *))(v1 + 8);
  v2 = *(_QWORD *)(v1 + 16);
  if (v2)
    v4 = (*(_QWORD *)(v1 + 16) & 1 | (unint64_t)v3) == 0;
  else
    v4 = 1;
  v5 = v4;
  if (v3 == BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_initial && v5 != 0)
  {
    v7 = (uint64_t *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0)
      v8 = *(void (**)(uint64_t *, uint64_t *))(*v7
                                                       + BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_initial);
    else
      v8 = BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_initial;
    v13 = 0;
    v14 = 0;
    v8(v7, &v13);
    v9 = v14;
    if (v14)
    {
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
  _Block_release(*(const void **)v1);
  return MEMORY[0x186DB748C](v1, 0x80C40D6874129);
}

void sub_183FFDAAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  unint64_t *p_shared_owners;
  unint64_t v12;

  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

void BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_normal(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v2 = *a1;
  v3 = (std::__shared_weak_count *)a2[1];
  v9 = *a2;
  v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v9);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_183FFDB7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_48c46_ZTSNSt3__110shared_ptrI18HTTPRequestMessageEE64c39_ZTSNSt3__110shared_ptrIK10__CFStringEE80c85_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI18HTTPRequestMessageEE13CFStreamErrorEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[9];
  result[8] = a2[8];
  result[9] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = a2[11];
  result[10] = a2[10];
  result[11] = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_48c46_ZTSNSt3__110shared_ptrI18HTTPRequestMessageEE64c39_ZTSNSt3__110shared_ptrIK10__CFStringEE80c85_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI18HTTPRequestMessageEE13CFStreamErrorEE(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = a1 + 48;
  v2 = a1 + 64;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 80);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

double ___ZN26UnitTestNotificationCenter6sharedEv_block_invoke_1595()
{
  uint64_t v0;
  double result;

  v0 = operator new();
  *(_QWORD *)v0 = 0;
  *(_QWORD *)(v0 + 8) = 850045863;
  result = 0.0;
  *(_OWORD *)(v0 + 16) = 0u;
  *(_OWORD *)(v0 + 32) = 0u;
  *(_OWORD *)(v0 + 48) = 0u;
  *(_OWORD *)(v0 + 64) = 0u;
  *(_QWORD *)(v0 + 80) = CFTypeRefRelease<__CFSet const*>;
  *(_BYTE *)(v0 + 88) = 1;
  UnitTestNotificationCenter::shared(void)::shared = v0;
  return result;
}

void std::__shared_ptr_pointer<__CFString const*,Deleter_CFRelease,std::allocator<__CFString const>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_1613(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

void _ServiceDestroy(os_unfair_lock_s *a1)
{
  os_unfair_lock_s *v2;
  void (*v3)(void);
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;

  v2 = a1 + 4;
  os_unfair_lock_lock(a1 + 4);
  if (*(_QWORD *)&a1[30]._os_unfair_lock_opaque)
  {
    v3 = *(void (**)(void))&a1[34]._os_unfair_lock_opaque;
    if (v3)
      v3();
  }
  _CleanupService_NoLock((__CFNetService *)a1);
  v4 = *(const void **)&a1[22]._os_unfair_lock_opaque;
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)&a1[20]._os_unfair_lock_opaque;
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)&a1[12]._os_unfair_lock_opaque;
  if (v6)
    CFRelease(v6);
  v7 = *(const void **)&a1[16]._os_unfair_lock_opaque;
  if (v7)
    CFRelease(v7);
  v8 = *(const void **)&a1[24]._os_unfair_lock_opaque;
  if (v8)
    CFRelease(v8);
  os_unfair_lock_unlock(v2);
}

BOOL _ServiceEqual(__CFNetService *a1, __CFNetService *a2)
{
  os_unfair_lock_s *v4;
  os_unfair_lock_s *v5;
  const void *Value;
  const void *v7;
  const __CFString *v8;
  const __CFString *v9;
  __CFString *v10;
  const void *v11;
  const __CFString *v12;
  _BOOL8 v13;
  CFStringRef v14;
  CFStringRef v15;
  CFStringRef v16;

  v4 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  v5 = (os_unfair_lock_s *)((char *)a2 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 4);
  Value = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)4);
  v7 = CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 6), (const void *)4);
  if (!CFEqual(Value, v7))
    goto LABEL_19;
  v8 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), 0);
  v9 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 6), 0);
  if (CFEqual(v8, &stru_1E1500C68))
    v8 = &stru_1E1500C68;
  v10 = CFEqual(v9, &stru_1E1500C68) ? &stru_1E1500C68 : (__CFString *)v9;
  if (!CFEqual(v8, v10))
    goto LABEL_19;
  v11 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)2);
  v12 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 6), (const void *)2);
  if (CFEqual(v11, v12))
  {
    v13 = 1;
    goto LABEL_20;
  }
  if (!CFEqual(v11, &stru_1E1500C68) && !CFEqual(v12, &stru_1E1500C68)
    || (v14 = SCDynamicStoreCopyComputerName(0, 0)) == 0)
  {
LABEL_19:
    v13 = 0;
    goto LABEL_20;
  }
  v15 = v14;
  if (CFEqual(v11, &stru_1E1500C68))
    v11 = v15;
  if (CFEqual(v12, &stru_1E1500C68))
    v16 = v15;
  else
    v16 = v12;
  v13 = CFEqual(v11, v16) != 0;
  CFRelease(v15);
LABEL_20:
  os_unfair_lock_unlock(v4);
  os_unfair_lock_unlock(v5);
  return v13;
}

CFHashCode _ServiceHash(__CFNetService *a1)
{
  os_unfair_lock_s *v2;
  const void *Value;
  CFHashCode v4;
  CFStringRef v5;
  CFStringRef v6;

  v2 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  Value = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)2);
  v4 = CFHash(Value);
  if (CFEqual(Value, &stru_1E1500C68))
  {
    v5 = SCDynamicStoreCopyComputerName(0, 0);
    if (v5)
    {
      v6 = v5;
      v4 = CFHash(v5);
      CFRelease(v6);
    }
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

CFStringRef _ServiceCopyDebugDesc(__CFNetService *a1)
{
  os_unfair_lock_s *v2;
  const __CFAllocator *v3;
  const void *Value;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  CFStringRef v9;

  v2 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  v3 = CFGetAllocator(a1);
  Value = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), 0);
  v5 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)4);
  v6 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)2);
  v7 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)1);
  v8 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)3);
  v9 = CFStringCreateWithFormat(v3, 0, CFSTR("<CFNetService %p>{domain=%@, type=%@, name=%@, specific=%@, addresses=%@}"), a1, Value, v5, v6, v7, v8);
  os_unfair_lock_unlock(v2);
  return v9;
}

void _CleanupService_NoLock(__CFNetService *a1)
{
  const __CFArray *v2;
  _DNSServiceRef_t *v3;
  const void *v4;

  if (CFArrayGetCount(*((CFArrayRef *)a1 + 8)))
  {
    v2 = (const __CFArray *)*((_QWORD *)a1 + 12);
    if (v2)
      _UnscheduleSources(*((const __CFArray **)a1 + 8), v2);
    _InvalidateSources(*((__CFArray **)a1 + 8));
  }
  v3 = (_DNSServiceRef_t *)*((_QWORD *)a1 + 9);
  if (v3)
  {
    DNSServiceRefDeallocate(v3);
    *((_QWORD *)a1 + 9) = 0;
  }
  v4 = (const void *)*((_QWORD *)a1 + 5);
  if (v4)
  {
    CFRelease(v4);
    *((_QWORD *)a1 + 5) = 0;
  }
  CFSetRemoveAllValues(*((CFMutableSetRef *)a1 + 11));
}

void _UnscheduleSources(const __CFArray *a1, const __CFArray *a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  void *ValueAtIndex;

  Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    v5 = Count;
    for (i = 0; i != v5; ++i)
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(a1, i);
      _CFTypeUnscheduleFromMultipleRunLoops(ValueAtIndex, a2);
    }
  }
}

void _InvalidateSources(__CFArray *a1)
{
  CFIndex Count;
  CFIndex v3;
  CFIndex i;
  char *ValueAtIndex;

  Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    v3 = Count;
    for (i = 0; i != v3; ++i)
    {
      ValueAtIndex = (char *)CFArrayGetValueAtIndex(a1, i);
      _CFTypeInvalidate(ValueAtIndex);
    }
  }
  CFArrayRemoveAllValues(a1);
}

CFNetServiceRef CFNetServiceCreate(CFAllocatorRef alloc, CFStringRef domain, CFStringRef serviceType, CFStringRef name, SInt32 port)
{
  uint64_t v5;
  uint64_t Instance;
  const CFArrayCallBacks *v12;
  CFMutableArrayRef Mutable;
  __CFDictionary *v14;
  CFDictionaryValueCallBacks v16;
  CFDictionaryKeyCallBacks keyCallBacks;

  v5 = 0;
  if (domain && serviceType && name)
  {
    if (!CFNetServiceGetTypeID())
      return 0;
    Instance = _CFRuntimeCreateInstance();
    v5 = Instance;
    if (Instance)
    {
      memset(&keyCallBacks, 0, sizeof(keyCallBacks));
      memset(&v16, 0, sizeof(v16));
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 128) = 0u;
      *(_QWORD *)(Instance + 144) = 0;
      *(_OWORD *)(Instance + 48) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(_QWORD *)(Instance + 48) = CFDictionaryCreateMutable(alloc, 0, &keyCallBacks, MEMORY[0x1E0C9B3A0]);
      *(_QWORD *)(v5 + 80) = CFDictionaryCreateMutable(alloc, 0, &keyCallBacks, &v16);
      *(_QWORD *)(v5 + 88) = CFSetCreateMutable(alloc, 0, MEMORY[0x1E0C9B3B0]);
      v12 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
      *(_QWORD *)(v5 + 96) = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E0C9B378]);
      Mutable = CFArrayCreateMutable(alloc, 0, v12);
      *(_QWORD *)(v5 + 64) = Mutable;
      v14 = *(__CFDictionary **)(v5 + 48);
      if (v14 && *(_QWORD *)(v5 + 96) && *(_QWORD *)(v5 + 80) && Mutable)
      {
        CFDictionaryAddValue(v14, 0, domain);
        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v5 + 48), (const void *)4, serviceType);
        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v5 + 48), (const void *)2, name);
        *(_DWORD *)(v5 + 56) = port;
        return (CFNetServiceRef)v5;
      }
      CFRelease((CFTypeRef)v5);
      return 0;
    }
  }
  return (CFNetServiceRef)v5;
}

CFNetServiceRef CFNetServiceCreateCopy(CFAllocatorRef alloc, CFNetServiceRef service)
{
  _QWORD *TypeID;
  uint64_t Instance;
  void *v6;
  const CFArrayCallBacks *v7;
  CFMutableArrayRef Mutable;
  const __CFDictionary *v9;
  CFIndex Count;
  CFDictionaryValueCallBacks v12;
  CFDictionaryKeyCallBacks keyCallBacks;

  TypeID = (_QWORD *)CFNetServiceGetTypeID();
  os_unfair_lock_lock((os_unfair_lock_t)service + 4);
  if (TypeID)
  {
    Instance = _CFRuntimeCreateInstance();
    TypeID = (_QWORD *)Instance;
    if (Instance)
    {
      memset(&keyCallBacks, 0, sizeof(keyCallBacks));
      memset(&v12, 0, sizeof(v12));
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 128) = 0u;
      *(_QWORD *)(Instance + 144) = 0;
      *(_OWORD *)(Instance + 48) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(_QWORD *)(Instance + 48) = CFDictionaryCreateMutable(alloc, 0, &keyCallBacks, MEMORY[0x1E0C9B3A0]);
      TypeID[10] = CFDictionaryCreateMutable(alloc, 0, &keyCallBacks, &v12);
      v6 = (void *)TypeID[6];
      if (v6)
        CFDictionaryApplyFunction(*((CFDictionaryRef *)service + 6), (CFDictionaryApplierFunction)_DictionaryApplier, v6);
      TypeID[11] = CFSetCreateMutable(alloc, 0, MEMORY[0x1E0C9B3B0]);
      v7 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
      TypeID[12] = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E0C9B378]);
      Mutable = CFArrayCreateMutable(alloc, 0, v7);
      TypeID[8] = Mutable;
      v9 = (const __CFDictionary *)TypeID[6];
      if (!v9
        || !TypeID[12]
        || !Mutable
        || !TypeID[10]
        || (Count = CFDictionaryGetCount(v9), Count != CFDictionaryGetCount(*((CFDictionaryRef *)service + 6))))
      {
        CFRelease(TypeID);
        TypeID = 0;
      }
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)service + 4);
  return (CFNetServiceRef)TypeID;
}

void _DictionaryApplier(const void *a1, const __CFString *cf, void *a3)
{
  CFTypeID v6;
  const __CFAllocator *v7;
  const void *Copy;
  const void *v9;
  const __CFAllocator *v10;

  v6 = CFGetTypeID(cf);
  if (v6 == CFStringGetTypeID())
  {
    v7 = CFGetAllocator(a3);
    Copy = CFStringCreateCopy(v7, cf);
    if (Copy)
    {
LABEL_3:
      v9 = Copy;
      CFDictionaryAddValue((CFMutableDictionaryRef)a3, a1, Copy);
      CFRelease(v9);
    }
  }
  else if (v6 == CFArrayGetTypeID())
  {
    v10 = CFGetAllocator(a3);
    Copy = CFArrayCreateCopy(v10, (CFArrayRef)cf);
    if (Copy)
      goto LABEL_3;
  }
  else
  {
    CFDictionaryAddValue((CFMutableDictionaryRef)a3, a1, cf);
  }
}

CFStringRef CFNetServiceGetDomain(CFNetServiceRef theService)
{
  return (CFStringRef)CFNetServiceGetInfo((uint64_t)theService, 0);
}

const void *CFNetServiceGetInfo(uint64_t a1, unsigned int a2)
{
  os_unfair_lock_s *v4;
  const void *Value;

  v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), (const void *)a2);
  os_unfair_lock_unlock(v4);
  return Value;
}

CFStringRef CFNetServiceGetType(CFNetServiceRef theService)
{
  return (CFStringRef)CFNetServiceGetInfo((uint64_t)theService, 4u);
}

CFStringRef CFNetServiceGetName(CFNetServiceRef theService)
{
  return (CFStringRef)CFNetServiceGetInfo((uint64_t)theService, 2u);
}

CFArrayRef CFNetServiceGetAddressing(CFNetServiceRef theService)
{
  return (CFArrayRef)CFNetServiceGetInfo((uint64_t)theService, 3u);
}

CFStringRef CFNetServiceGetTargetHost(CFNetServiceRef theService)
{
  return (CFStringRef)CFNetServiceGetInfo((uint64_t)theService, 5u);
}

SInt32 CFNetServiceGetPortNumber(CFNetServiceRef theService)
{
  return *((_DWORD *)theService + 14);
}

CFDataRef CFNetServiceGetTXTData(CFNetServiceRef theService)
{
  CFDataRef result;
  const __CFData *v2;
  CFTypeID v3;

  result = (CFDataRef)CFNetServiceGetInfo((uint64_t)theService, 1u);
  if (result)
  {
    v2 = result;
    v3 = CFGetTypeID(result);
    if (v3 == CFDataGetTypeID())
      return v2;
    else
      return 0;
  }
  return result;
}

Boolean CFNetServiceSetTXTData(CFNetServiceRef theService, CFDataRef txtRecord)
{
  return _ServiceSetInfo(theService, 1u, txtRecord, 1);
}

uint64_t _ServiceSetInfo(__CFNetService *a1, unsigned int a2, const void *a3, int a4)
{
  os_unfair_lock_s *v8;
  __CFDictionary *v9;
  unint64_t v10;
  uint64_t v11;
  _DNSServiceRef_t *v12;
  uint16_t v13;
  const UInt8 *v14;
  _DNSRecordRef_t *v15;
  _DNSRecordRef_t *v16;
  _DNSServiceRef_t *v17;
  uint16_t Length;
  const UInt8 *BytePtr;
  DNSServiceErrorType updated;
  uint64_t v21;
  const UInt8 *v22;
  void *value;
  int valuePtr;

  v8 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  if ((*((_BYTE *)a1 + 20) & 2) != 0)
  {
LABEL_27:
    v11 = 0;
    goto LABEL_29;
  }
  v9 = (__CFDictionary *)*((_QWORD *)a1 + 6);
  v10 = a2;
  if (a3)
    CFDictionarySetValue(v9, (const void *)a2, a3);
  else
    CFDictionaryRemoveValue(v9, (const void *)a2);
  if (a2 == 8)
  {
    valuePtr = 0;
    v11 = CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, &valuePtr);
    *((_DWORD *)a1 + 14) = valuePtr;
    goto LABEL_29;
  }
  if (!a4 || (v12 = (_DNSServiceRef_t *)*((_QWORD *)a1 + 9)) == 0)
  {
LABEL_28:
    v11 = 1;
    goto LABEL_29;
  }
  if (a2 != 1)
  {
    if ((a2 & 0xFFFF0000) == 0x10000)
    {
      v15 = (_DNSRecordRef_t *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 10), (const void *)a2);
      v16 = v15;
      value = v15;
      if (a3)
      {
        v17 = (_DNSServiceRef_t *)*((_QWORD *)a1 + 9);
        if (v15)
        {
          Length = CFDataGetLength((CFDataRef)a3);
          BytePtr = CFDataGetBytePtr((CFDataRef)a3);
          updated = DNSServiceUpdateRecord(v17, v16, 0, Length, BytePtr, 0);
        }
        else
        {
          v21 = (unsigned __int16)CFDataGetLength((CFDataRef)a3);
          v22 = CFDataGetBytePtr((CFDataRef)a3);
          updated = DNSServiceAddRecord(v17, (DNSRecordRef *)&value, 0, a2, v21, v22, 0);
          CFDictionaryAddValue(*((CFMutableDictionaryRef *)a1 + 10), (const void *)a2, value);
        }
      }
      else
      {
        updated = v15 ? DNSServiceRemoveRecord(*((DNSServiceRef *)a1 + 9), v15, 0) : 0;
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)a1 + 10), (const void *)a2);
      }
      if (updated)
      {
        if (value)
          DNSServiceRemoveRecord(*((DNSServiceRef *)a1 + 9), (DNSRecordRef)value, 0);
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)a1 + 10), (const void *)v10);
        goto LABEL_27;
      }
    }
    goto LABEL_28;
  }
  if (a3)
  {
    v13 = CFDataGetLength((CFDataRef)a3);
    v14 = CFDataGetBytePtr((CFDataRef)a3);
  }
  else
  {
    v13 = 0;
    v14 = 0;
  }
  v11 = DNSServiceUpdateRecord(v12, 0, 0, v13, v14, 0) == 0;
LABEL_29:
  os_unfair_lock_unlock(v8);
  return v11;
}

uint64_t CFNetServiceSetInfo(__CFNetService *a1, unsigned int a2, const void *a3)
{
  return _ServiceSetInfo(a1, a2, a3, 1);
}

Boolean CFNetServiceRegisterWithOptions(CFNetServiceRef theService, CFOptionFlags options, CFStreamError *error)
{
  int v3;
  int v5;
  CFStreamError *v6;
  const void *(__cdecl *v7)(const void *);
  const __CFData *Value;
  uint64_t v9;
  int *v10;
  unsigned int v11;
  const __CFString *v12;
  const __CFString *v13;
  DNSServiceFlags v14;
  const __CFBoolean *v15;
  const __CFBoolean *v16;
  uint32_t v17;
  unsigned int v18;
  uint16_t Length;
  const UInt8 *txtRecord;
  DNSServiceErrorType v21;
  os_unfair_lock_s *v22;
  ifaddrs *v23;
  const char *ifa_name;
  ifaddrs *v25;
  int v26;
  __CFSocket *v27;
  CFStreamError *v28;
  const __CFAllocator *v30;
  dnssd_sock_t v31;
  __CFSocket *v32;
  CFOptionFlags SocketFlags;
  int v34;
  CFStreamError *v35;
  os_unfair_lock_s *lock;
  ifaddrs *usedBufLen;
  CFSocketContext context;
  char v39;
  char name[1024];
  char v41[1024];
  char v42[1024];
  uint64_t v43;
  CFRange v44;

  v3 = options;
  v43 = *MEMORY[0x1E0C80C00];
  v5 = -72008;
  v6 = (CFStreamError *)&v39;
  if (error)
    v6 = error;
  v6->domain = 0;
  *(_QWORD *)&v6->error = 0;
  v35 = v6;
  CFRetain(theService);
  v7 = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
  lock = (os_unfair_lock_s *)((char *)theService + 16);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  context.version = 0;
  context.info = theService;
  context.retain = v7;
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
  context.copyDescription = 0;
  Value = (const __CFData *)CFDictionaryGetValue(*((CFDictionaryRef *)theService + 6), (const void *)1);
  if (CFArrayGetCount(*((CFArrayRef *)theService + 8)))
  {
    if ((*((_BYTE *)theService + 20) & 8) != 0)
    {
      _UnscheduleSources(*((const __CFArray **)theService + 8), *((const __CFArray **)theService + 12));
      _InvalidateSources(*((__CFArray **)theService + 8));
    }
    else
    {
      *((_QWORD *)theService + 3) = 10;
      *((_DWORD *)theService + 8) = -72003;
    }
  }
  v9 = 0;
  v10 = dword_18411DBD8;
  do
  {
    v11 = *v10++;
    v12 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)theService + 6), (const void *)v11);
    if (v12)
    {
      v13 = v12;
      usedBufLen = 0;
      v44.length = CFStringGetLength(v12);
      v44.location = 0;
      CFStringGetBytes(v13, v44, 0x8000100u, 0, 0, (UInt8 *)&name[v9], 1023, (CFIndex *)&usedBufLen);
      name[v9 + (_QWORD)usedBufLen] = 0;
    }
    else
    {
      name[v9] = 0;
    }
    v9 += 1024;
  }
  while (v9 != 3072);
  v14 = v3 & 0x120800 | (8 * (v3 & 1));
  v15 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)theService + 6), (const void *)7);
  if (v15 && CFBooleanGetValue(v15))
    v14 |= 0x100000u;
  v16 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)theService + 6), (const void *)9);
  if (v16 && CFBooleanGetValue(v16))
    v14 |= 0x100000u;
  if ((v3 & 0x200000) != 0 && (usedBufLen = 0, !getifaddrs(&usedBufLen)))
  {
    v23 = usedBufLen;
    if (usedBufLen)
    {
      v17 = 0;
      do
      {
        if (v23->ifa_addr->sa_family == 30)
        {
          ifa_name = v23->ifa_name;
          if (!strncasecmp(ifa_name, "awdl0", 5uLL))
            v17 = if_nametoindex(ifa_name);
        }
        v23 = v23->ifa_next;
      }
      while (v23);
      v25 = usedBufLen;
    }
    else
    {
      v25 = 0;
      v17 = 0;
    }
    MEMORY[0x186DB7A08](v25);
  }
  else
  {
    v17 = 0;
  }
  v18 = bswap32(*((unsigned __int16 *)theService + 28)) >> 16;
  if (Value)
  {
    Length = CFDataGetLength(Value);
    txtRecord = CFDataGetBytePtr(Value);
  }
  else
  {
    Length = 0;
    txtRecord = 0;
  }
  v21 = DNSServiceRegister((DNSServiceRef *)theService + 9, v14, v17, name, v41, v42, 0, v18, Length, txtRecord, (DNSServiceRegisterReply)_RegisterReply, theService);
  *((_DWORD *)theService + 8) = v21;
  if (v21 <= -65549)
  {
    v22 = (os_unfair_lock_s *)((char *)theService + 16);
    if (v21 == -65555)
      goto LABEL_46;
    if (v21 == -65554)
    {
      v5 = -72002;
      goto LABEL_46;
    }
    goto LABEL_45;
  }
  v22 = (os_unfair_lock_s *)((char *)theService + 16);
  if (v21 == -65548)
  {
    v5 = -72001;
    goto LABEL_46;
  }
  if (v21)
  {
    if (v21 == -65540)
    {
      v5 = -72004;
LABEL_46:
      LOBYTE(v27) = 0;
      *((_QWORD *)theService + 3) = 10;
      *((_DWORD *)theService + 8) = v5;
LABEL_47:
      v28 = v35;
      goto LABEL_48;
    }
LABEL_45:
    v5 = -72000;
    goto LABEL_46;
  }
  CFDictionaryApplyFunction(*((CFDictionaryRef *)theService + 6), (CFDictionaryApplierFunction)_AddRecords, theService);
  v26 = *((_DWORD *)theService + 8);
  if (v26 <= -65549)
  {
    if (v26 == -65555)
      goto LABEL_59;
    if (v26 == -65554)
    {
      v5 = -72002;
      goto LABEL_59;
    }
    goto LABEL_58;
  }
  if (v26 == -65548)
  {
    v5 = -72001;
    goto LABEL_59;
  }
  if (v26)
  {
    if (v26 == -65540)
    {
      v5 = -72004;
LABEL_59:
      *((_QWORD *)theService + 3) = 10;
      *((_DWORD *)theService + 8) = v5;
      DNSServiceRefDeallocate(*((DNSServiceRef *)theService + 9));
      *((_QWORD *)theService + 9) = 0;
      CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)theService + 10));
      LOBYTE(v27) = 0;
      goto LABEL_47;
    }
LABEL_58:
    v5 = -72000;
    goto LABEL_59;
  }
  v30 = CFGetAllocator(theService);
  v31 = DNSServiceRefSockFD(*((DNSServiceRef *)theService + 9));
  v32 = CFSocketCreateWithNative(v30, v31, 1uLL, (CFSocketCallBack)_SocketCallBack_NetService, &context);
  v27 = v32;
  if (!v32)
  {
    v34 = *__error();
    *((_QWORD *)theService + 3) = 1;
    *((_DWORD *)theService + 8) = v34;
    DNSServiceRefDeallocate(*((DNSServiceRef *)theService + 9));
    *((_QWORD *)theService + 9) = 0;
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)theService + 10));
    goto LABEL_47;
  }
  SocketFlags = CFSocketGetSocketFlags(v32);
  CFSocketSetSocketFlags(v27, SocketFlags & 0xFFFFFFFFFFFFFF7FLL);
  CFArrayAppendValue(*((CFMutableArrayRef *)theService + 8), v27);
  CFRelease(v27);
  *((_DWORD *)theService + 8) = 0;
  *((_QWORD *)theService + 3) = 0;
  *((_BYTE *)theService + 20) |= 4u;
  v28 = v35;
  if (CFArrayGetCount(*((CFArrayRef *)theService + 12)))
  {
    _ScheduleSources(*((const __CFArray **)theService + 8), *((const __CFArray **)theService + 12));
    LOBYTE(v27) = 1;
  }
  else
  {
    os_unfair_lock_unlock(lock);
    LOBYTE(v27) = _ServiceBlockUntilComplete(theService);
    os_unfair_lock_lock(lock);
  }
LABEL_48:
  *v28 = *(CFStreamError *)((char *)theService + 24);
  os_unfair_lock_unlock(v22);
  CFRelease(theService);
  return v27;
}

void _RegisterReply(_DNSServiceRef_t *a1, unsigned int a2, int a3, const char *a4, const char *a5, const char *a6, char *cf)
{
  const __CFAllocator *v12;
  int v13;
  uint64_t i;
  const char *v15;
  CFStringRef v16;
  CFStringRef v17;
  void (*v18)(char *, __int128 *, uint64_t);
  uint64_t v19;
  __int128 v20;
  _QWORD v21[4];

  v21[3] = *MEMORY[0x1E0C80C00];
  if (a3 != -65570)
  {
    CFRetain(cf);
    os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
    if (!*((_QWORD *)cf + 9))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
LABEL_24:
      CFRelease(cf);
      return;
    }
    v12 = CFGetAllocator(cf);
    v21[0] = a4;
    v21[1] = a5;
    v21[2] = a6;
    if (!a3)
    {
LABEL_15:
      for (i = 0; i != 3; ++i)
      {
        v15 = (const char *)v21[i];
        if (v15)
        {
          v16 = CFStringCreateWithCString(v12, v15, 0x8000100u);
          if (v16)
          {
            v17 = v16;
            CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 6), (const void *)dword_18411DBD8[i], v16);
            CFRelease(v17);
          }
        }
      }
      v18 = (void (*)(char *, __int128 *, uint64_t))*((_QWORD *)cf + 13);
      v20 = *(_OWORD *)(cf + 24);
      v19 = *((_QWORD *)cf + 15);
      os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
      if (v18 && (a3 || (cf[20] & 1) == 0))
        v18(cf, &v20, v19);
      goto LABEL_24;
    }
    v13 = -72008;
    if (a3 > -65549)
    {
      if (a3 == -65548)
      {
        v13 = -72001;
        goto LABEL_14;
      }
      if (a3 == -65540)
      {
        v13 = -72004;
        goto LABEL_14;
      }
    }
    else
    {
      if (a3 == -65555)
      {
LABEL_14:
        *((_QWORD *)cf + 3) = 10;
        *((_DWORD *)cf + 8) = v13;
        goto LABEL_15;
      }
      if (a3 == -65554)
      {
        v13 = -72002;
        goto LABEL_14;
      }
    }
    v13 = -72000;
    goto LABEL_14;
  }
}

void _AddRecords(const void *a1, CFDataRef theData, void *a3)
{
  _DNSRecordRef_t *v3;
  _DNSRecordRef_t *v4;
  _DNSServiceRef_t *v8;
  uint16_t Length;
  const UInt8 *BytePtr;
  DNSServiceErrorType v11;
  DNSRecordRef RecordRef[9];

  if ((a1 & 0xFFFF0000) == 0x10000)
  {
    RecordRef[7] = v3;
    RecordRef[8] = v4;
    if (!*((_DWORD *)a3 + 8))
    {
      RecordRef[0] = 0;
      v8 = (_DNSServiceRef_t *)*((_QWORD *)a3 + 9);
      Length = CFDataGetLength(theData);
      BytePtr = CFDataGetBytePtr(theData);
      v11 = DNSServiceAddRecord(v8, RecordRef, 0, (uint16_t)a1, Length, BytePtr, 0);
      *((_DWORD *)a3 + 8) = v11;
      if (!v11)
        CFDictionaryAddValue(*((CFMutableDictionaryRef *)a3 + 10), a1, RecordRef[0]);
    }
  }
}

void _SocketCallBack_NetService(__CFSocket *a1, unint64_t a2, const __CFData *a3, const void *a4, char *cf)
{
  DNSServiceErrorType v6;
  int v7;
  void (*v8)(char *, __int128 *, uint64_t);
  uint64_t v9;
  __int128 v10;

  CFRetain(cf);
  v6 = DNSServiceProcessResult(*((DNSServiceRef *)cf + 9));
  if (!v6)
    goto LABEL_13;
  v7 = -72008;
  v10 = xmmword_1841E3850;
  if (v6 <= -65549)
  {
    if (v6 == -65555)
      goto LABEL_11;
    if (v6 == -65554)
    {
      v7 = -72002;
      goto LABEL_11;
    }
LABEL_9:
    v7 = -72000;
    goto LABEL_11;
  }
  if (v6 != -65548)
  {
    if (v6 == -65540)
    {
      v7 = -72004;
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  v7 = -72001;
LABEL_11:
  DWORD2(v10) = v7;
  os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
  _CleanupService_NoLock((__CFNetService *)cf);
  cf[20] &= 0xF9u;
  v8 = (void (*)(char *, __int128 *, uint64_t))*((_QWORD *)cf + 13);
  v9 = *((_QWORD *)cf + 15);
  *(_OWORD *)(cf + 24) = v10;
  os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
  if (v8)
    v8(cf, &v10, v9);
LABEL_13:
  CFRelease(cf);
}

void _ScheduleSources(const __CFArray *a1, const __CFArray *a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  void *ValueAtIndex;

  Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    v5 = Count;
    for (i = 0; i != v5; ++i)
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(a1, i);
      _CFTypeScheduleOnMultipleRunLoops(ValueAtIndex, a2);
    }
  }
}

BOOL _ServiceBlockUntilComplete(__CFNetService *a1)
{
  __CFRunLoop *Current;
  _BOOL8 v3;

  Current = CFRunLoopGetCurrent();
  CFNetServiceScheduleWithRunLoop(a1, Current, CFSTR("_kCFNetServiceBlockingMode"));
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  while (CFArrayGetCount(*((CFArrayRef *)a1 + 8)))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
    CFRunLoopRunInMode(CFSTR("_kCFNetServiceBlockingMode"), 1.79769313e308, 1u);
    os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  }
  v3 = *((_DWORD *)a1 + 8) == 0;
  os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
  CFNetServiceUnscheduleFromRunLoop(a1, Current, CFSTR("_kCFNetServiceBlockingMode"));
  return v3;
}

void CFNetServiceScheduleWithRunLoop(CFNetServiceRef theService, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  os_unfair_lock_s *v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex i;
  const void *ValueAtIndex;

  v6 = (os_unfair_lock_s *)((char *)theService + 16);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  if (_SchedulesAddRunLoopAndMode(*((const __CFArray **)theService + 12), runLoop, runLoopMode))
  {
    Count = CFArrayGetCount(*((CFArrayRef *)theService + 8));
    if (Count >= 1)
    {
      v8 = Count;
      for (i = 0; i != v8; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)theService + 8), i);
        _CFTypeScheduleOnRunLoop(ValueAtIndex, runLoop, runLoopMode);
      }
    }
  }
  os_unfair_lock_unlock(v6);
}

void CFNetServiceUnscheduleFromRunLoop(CFNetServiceRef theService, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  os_unfair_lock_s *v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex i;
  const void *ValueAtIndex;

  v6 = (os_unfair_lock_s *)((char *)theService + 16);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  if (_SchedulesRemoveRunLoopAndMode(*((const __CFArray **)theService + 12), runLoop, runLoopMode))
  {
    Count = CFArrayGetCount(*((CFArrayRef *)theService + 8));
    if (Count >= 1)
    {
      v8 = Count;
      for (i = 0; i != v8; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)theService + 8), i);
        _CFTypeUnscheduleFromRunLoop(ValueAtIndex, runLoop, runLoopMode);
      }
    }
  }
  os_unfair_lock_unlock(v6);
}

Boolean CFNetServiceResolveWithTimeout(CFNetServiceRef theService, CFTimeInterval timeout, CFStreamError *error)
{
  CFStreamError *v5;
  Boolean v6;
  const void *v7;
  uint64_t v8;
  int *v9;
  unsigned int v10;
  const __CFString *Value;
  const __CFString *v12;
  int v13;
  CFAbsoluteTime v14;
  const __CFAllocator *v15;
  CFRunLoopTimerRef v16;
  CFRunLoopTimerRef v17;
  int v18;
  CFRunLoopTimerContext context;
  char v21;
  char v22[1024];
  char v23[1024];
  char v24[1024];
  uint64_t v25;
  CFRange v26;

  v25 = *MEMORY[0x1E0C80C00];
  if (error)
    v5 = error;
  else
    v5 = (CFStreamError *)&v21;
  v5->domain = 0;
  *(_QWORD *)&v5->error = 0;
  CFRetain(theService);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  *((_QWORD *)theService + 3) = 0;
  *((_DWORD *)theService + 8) = 0;
  if (CFArrayGetCount(*((CFArrayRef *)theService + 8)))
  {
    if ((*((_BYTE *)theService + 20) & 8) == 0)
    {
      v6 = 0;
      *((_QWORD *)theService + 3) = 10;
      *((_DWORD *)theService + 8) = -72003;
      goto LABEL_29;
    }
    _UnscheduleSources(*((const __CFArray **)theService + 8), *((const __CFArray **)theService + 12));
    _InvalidateSources(*((__CFArray **)theService + 8));
    v7 = (const void *)*((_QWORD *)theService + 5);
    if (v7)
    {
      CFRelease(v7);
      *((_QWORD *)theService + 5) = 0;
    }
  }
  if (*((_DWORD *)theService + 8))
  {
    v6 = 0;
    goto LABEL_29;
  }
  v8 = 0;
  v9 = dword_18411DBD8;
  do
  {
    v10 = *v9++;
    Value = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)theService + 6), (const void *)v10);
    if (Value)
    {
      v12 = Value;
      context.version = 0;
      v26.length = CFStringGetLength(Value);
      v26.location = 0;
      CFStringGetBytes(v12, v26, 0x8000100u, 0, 0, (UInt8 *)&v22[v8], 1023, &context.version);
      v22[v8 + context.version] = 0;
    }
    else
    {
      v22[v8] = 0;
    }
    v8 += 1024;
  }
  while (v8 != 3072);
  _ServiceCreateQuery_NoLock((CFDictionaryRef *)theService, 0, 0, v22, v23, v24);
  v13 = *((_DWORD *)theService + 8);
  if (timeout > 0.0 && !v13)
  {
    context.version = 0;
    context.info = theService;
    memset(&context.retain, 0, 24);
    v14 = CFAbsoluteTimeGetCurrent() + timeout;
    v15 = CFGetAllocator(theService);
    v16 = CFRunLoopTimerCreate(v15, v14, 0.0, 0, 0, (CFRunLoopTimerCallBack)_LongTimerCallBack, &context);
    if (!v16)
    {
      if (*__error())
      {
        v18 = *__error();
        *((_QWORD *)theService + 3) = 1;
      }
      else
      {
        *((_QWORD *)theService + 3) = 1;
        v18 = 12;
      }
      *((_DWORD *)theService + 8) = v18;
      if (v18)
        goto LABEL_21;
      goto LABEL_26;
    }
    v17 = v16;
    CFArrayAppendValue(*((CFMutableArrayRef *)theService + 8), v16);
    CFRelease(v17);
    v13 = *((_DWORD *)theService + 8);
  }
  if (v13)
  {
LABEL_21:
    _InvalidateSources(*((__CFArray **)theService + 8));
    DNSServiceRefDeallocate(*((DNSServiceRef *)theService + 9));
    v6 = 0;
    *((_QWORD *)theService + 9) = 0;
    goto LABEL_29;
  }
LABEL_26:
  CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)theService + 6), (const void *)3);
  CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)theService + 6), (const void *)1);
  CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)theService + 6), (const void *)5);
  *((_DWORD *)theService + 14) = -1;
  *((_BYTE *)theService + 20) |= 2u;
  if (CFArrayGetCount(*((CFArrayRef *)theService + 12)))
  {
    _ScheduleSources(*((const __CFArray **)theService + 8), *((const __CFArray **)theService + 12));
    v6 = 1;
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)theService + 4);
    v6 = _ServiceBlockUntilComplete(theService);
    os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  }
LABEL_29:
  *v5 = *(CFStreamError *)((char *)theService + 24);
  *((_DWORD *)theService + 8) = 0;
  *((_QWORD *)theService + 3) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)theService + 4);
  CFRelease(theService);
  return v6;
}

void _ServiceCreateQuery_NoLock(CFDictionaryRef *a1, uint64_t a2, unsigned int a3, const char *a4, const char *a5, const char *a6)
{
  const __CFBoolean *Value;
  int v13;
  const __CFBoolean *v14;
  DNSServiceRef *v15;
  const __CFAllocator *v16;
  CFStringRef v17;
  CFStringRef v18;
  const __CFString *v19;
  const __CFString *v20;
  CFIndex Length;
  __CFString *MutableCopy;
  __CFString *v23;
  DNSServiceErrorType Connection;
  int v25;
  int v26;
  const __CFAllocator *v27;
  dnssd_sock_t v28;
  __CFSocket *v29;
  __CFSocket *v30;
  CFOptionFlags SocketFlags;
  CFSocketContext sdRef;

  Value = (const __CFBoolean *)CFDictionaryGetValue(a1[6], (const void *)7);
  if (Value)
    v13 = (CFBooleanGetValue(Value) != 0) << 20;
  else
    v13 = 0;
  v14 = (const __CFBoolean *)CFDictionaryGetValue(a1[6], (const void *)9);
  if (v14 && CFBooleanGetValue(v14))
    v13 = 0x100000;
  v15 = a1 + 9;
  if (a3)
  {
    if (*v15)
    {
      v16 = CFGetAllocator(a1);
      v17 = CFStringCreateWithCString(v16, a4, 0x8000100u);
      if (!v17)
        goto LABEL_20;
      v18 = v17;
      v19 = CFStringCreateWithFormat(v16, 0, CFSTR("%@%d.%d"), v17, a3, a2);
      if (v19)
      {
        v20 = v19;
        Length = CFStringGetLength(v19);
        MutableCopy = CFStringCreateMutableCopy(v16, Length, v20);
        CFStringLowercase(MutableCopy, 0);
        CFRelease(v20);
        CFRelease(v18);
        if (!MutableCopy)
          goto LABEL_20;
        if (!CFSetContainsValue(a1[11], MutableCopy))
        {
          CFSetSetValue(a1[11], MutableCopy);
          sdRef.version = (CFIndex)a1[9];
          *((_DWORD *)a1 + 8) = DNSServiceQueryRecord((DNSServiceRef *)&sdRef, v13 | 0x4000, a2, a4, a3, 1u, (DNSServiceQueryRecordReply)_QueryRecordReply_NetService, a1);
        }
        v23 = MutableCopy;
      }
      else
      {
        v23 = (__CFString *)v18;
      }
      CFRelease(v23);
    }
    else
    {
      *((_DWORD *)a1 + 8) = -65537;
    }
  }
  else
  {
    Connection = DNSServiceCreateConnection(v15);
    *((_DWORD *)a1 + 8) = Connection;
    if (!Connection)
    {
      sdRef.version = (CFIndex)a1[9];
      *((_DWORD *)a1 + 8) = DNSServiceResolve((DNSServiceRef *)&sdRef, v13 | 0x4000, a2, a4, a5, a6, (DNSServiceResolveReply)_ResolveReply, a1);
    }
  }
LABEL_20:
  v25 = *((_DWORD *)a1 + 8);
  if (v25)
  {
    v26 = -72008;
    if (v25 > -65549)
    {
      if (v25 == -65548)
      {
        v26 = -72001;
        goto LABEL_33;
      }
      if (v25 == -65540)
      {
        v26 = -72004;
        goto LABEL_33;
      }
    }
    else
    {
      if (v25 == -65555)
      {
LABEL_33:
        a1[3] = (CFDictionaryRef)10;
        *((_DWORD *)a1 + 8) = v26;
        return;
      }
      if (v25 == -65554)
      {
        v26 = -72002;
        goto LABEL_33;
      }
    }
    v26 = -72000;
    goto LABEL_33;
  }
  if (!a3)
  {
    sdRef.version = 0;
    sdRef.info = a1;
    sdRef.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
    sdRef.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
    sdRef.copyDescription = 0;
    v27 = CFGetAllocator(a1);
    v28 = DNSServiceRefSockFD(a1[9]);
    v29 = CFSocketCreateWithNative(v27, v28, 1uLL, (CFSocketCallBack)_SocketCallBack_NetService, &sdRef);
    if (v29)
    {
      v30 = v29;
      SocketFlags = CFSocketGetSocketFlags(v29);
      CFSocketSetSocketFlags(v30, SocketFlags & 0xFFFFFFFFFFFFFF7FLL);
      CFArrayAppendValue(a1[8], v30);
      _CFTypeScheduleOnMultipleRunLoops(v30, a1[12]);
      CFRelease(v30);
    }
  }
}

void _LongTimerCallBack(__CFRunLoopTimer *a1, char *cf)
{
  void (*v3)(char *, __int128 *, uint64_t);
  uint64_t v4;
  __int128 v5;

  CFRetain(cf);
  os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
  if (CFArrayGetCount(*((CFArrayRef *)cf + 8)))
  {
    _CleanupService_NoLock((__CFNetService *)cf);
    *((_QWORD *)cf + 3) = 10;
    *((_DWORD *)cf + 8) = -72007;
    v3 = (void (*)(char *, __int128 *, uint64_t))*((_QWORD *)cf + 13);
    v5 = *(_OWORD *)(cf + 24);
    v4 = *((_QWORD *)cf + 15);
    os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
    if (v3)
      v3(cf, &v5, v4);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
  }
  CFRelease(cf);
}

void _ResolveReply(_DNSServiceRef_t *a1, unsigned int a2, unsigned int a3, int a4, const char *a5, const char *a6, unsigned int a7, unsigned int a8, const unsigned __int8 *a9, char *a10)
{
  uint64_t v10;
  uint64_t v11;
  int v17;
  _BOOL4 v18;
  _BOOL4 v19;
  const __CFAllocator *v20;
  const __CFAllocator *v21;
  CFDataRef v22;
  const void *Value;
  CFStringRef v24;
  const __CFArray *v25;
  BOOL v26;
  unsigned __int8 v27;
  unsigned __int8 v28;
  void (*v29)(char *, __int128 *, uint64_t);
  uint64_t v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;

  if (a4 == -65570)
    return;
  v32 = v10;
  v33 = v11;
  CFRetain(a10);
  os_unfair_lock_lock((os_unfair_lock_t)a10 + 4);
  if (!*((_QWORD *)a10 + 9))
  {
    v18 = 0;
LABEL_9:
    v19 = 0;
    goto LABEL_44;
  }
  if (a4)
  {
    v17 = -72000;
    if (a4 > -65549)
    {
      if (a4 == -65548)
      {
        v17 = -72001;
      }
      else if (a4 == -65540)
      {
        v17 = -72004;
      }
    }
    else if (a4 == -65555)
    {
      v17 = -72008;
    }
    else if (a4 == -65554)
    {
      v17 = -72002;
    }
    v18 = 0;
    v19 = 0;
    *((_QWORD *)a10 + 3) = 10;
    *((_DWORD *)a10 + 8) = v17;
    goto LABEL_44;
  }
  v20 = CFGetAllocator(a10);
  v21 = v20;
  if (a9)
    v22 = CFDataCreate(v20, a9, a8);
  else
    v22 = 0;
  Value = CFDictionaryGetValue(*((CFDictionaryRef *)a10 + 6), (const void *)1);
  if (a6)
    v24 = CFStringCreateWithCString(v21, a6, 0x8000100u);
  else
    v24 = 0;
  v25 = (const __CFArray *)CFDictionaryGetValue(*((CFDictionaryRef *)a10 + 6), (const void *)3);
  *((_DWORD *)a10 + 14) = __rev16(a7);
  if (Value && v22)
  {
    v18 = CFEqual(Value, v22) == 0;
LABEL_35:
    CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)a10 + 6), (const void *)1);
    goto LABEL_36;
  }
  if (Value && !v22)
  {
    v18 = 1;
    goto LABEL_35;
  }
  if (Value)
    v26 = 1;
  else
    v26 = v22 == 0;
  v18 = !v26;
  if (Value)
    goto LABEL_35;
LABEL_36:
  if (v22)
  {
    CFDictionaryAddValue(*((CFMutableDictionaryRef *)a10 + 6), (const void *)1, v22);
    CFRelease(v22);
  }
  CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)a10 + 6), (const void *)5);
  if (v24)
  {
    CFDictionaryAddValue(*((CFMutableDictionaryRef *)a10 + 6), (const void *)5, v24);
    CFRelease(v24);
  }
  _ServiceCreateQuery_NoLock((__CFNetService *)a10, a3, 1u, a6, 0, 0, v27);
  _ServiceCreateQuery_NoLock((__CFNetService *)a10, a3, 0x1Cu, a6, 0, 0, v28);
  if (*((_DWORD *)a10 + 8))
  {
    *((_QWORD *)a10 + 3) = 10;
    *((_DWORD *)a10 + 8) = -72000;
  }
  if (!v25)
    goto LABEL_9;
  v19 = CFArrayGetCount(v25) != 0;
LABEL_44:
  if (*((_DWORD *)a10 + 8) || v18 && v19)
  {
    v29 = (void (*)(char *, __int128 *, uint64_t))*((_QWORD *)a10 + 13);
    v31 = *(_OWORD *)(a10 + 24);
    v30 = *((_QWORD *)a10 + 15);
    os_unfair_lock_unlock((os_unfair_lock_t)a10 + 4);
    if (v29)
      v29(a10, &v31, v30);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)a10 + 4);
  }
  CFRelease(a10);
}

void _QueryRecordReply_NetService(_DNSServiceRef_t *a1, char a2, int a3, int a4, const char *a5, int a6, unsigned __int16 a7, int a8, _DWORD *a9, unsigned int a10, char *cf)
{
  const __CFAllocator *v16;
  void *Value;
  unsigned int v18;
  CFIndex v19;
  int v20;
  CFDataRef v21;
  CFDataRef v22;
  CFIndex FirstIndexOfValue;
  void (*v24)(char *, _OWORD *, uint64_t);
  uint64_t v25;
  double v26;
  double v27;
  __CFRunLoopTimer *v28;
  const __CFAllocator *v29;
  CFRunLoopTimerRef v30;
  _OWORD v31[2];
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  _BYTE v44[31];
  uint64_t v45;
  CFRange v46;

  v45 = *MEMORY[0x1E0C80C00];
  if (a4 != -65570)
  {
    CFRetain(cf);
    os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
    v16 = CFGetAllocator(cf);
    Value = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)cf + 6), (const void *)3);
    if (!Value)
    {
      Value = CFArrayCreateMutable(v16, 0, MEMORY[0x1E0C9B378]);
      CFDictionaryAddValue(*((CFMutableDictionaryRef *)cf + 6), (const void *)3, Value);
      CFRelease(Value);
    }
    if (a4 == -65554)
      goto LABEL_32;
    if (a4)
    {
      v20 = -72008;
      if (a4 != -65555)
      {
        if (a4 == -65548)
        {
          v20 = -72001;
        }
        else if (a4 == -65540)
        {
          v20 = -72004;
        }
        else
        {
          v20 = -72000;
        }
      }
      *((_QWORD *)cf + 3) = 10;
      *((_DWORD *)cf + 8) = v20;
      v24 = (void (*)(char *, _OWORD *, uint64_t))*((_QWORD *)cf + 13);
      v31[0] = *(_OWORD *)(cf + 24);
      v25 = *((_QWORD *)cf + 15);
      os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
      if (v24)
        v24(cf, v31, v25);
      goto LABEL_33;
    }
    v18 = *((_DWORD *)cf + 14);
    v43 = 0u;
    memset(v44, 0, sizeof(v44));
    v41 = 0u;
    v42 = 0u;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v32 = 0u;
    memset(v31, 0, sizeof(v31));
    if (a6 == 1)
    {
      if (a8 == 4)
      {
        LOWORD(v31[0]) = 528;
        WORD1(v31[0]) = bswap32(v18) >> 16;
        DWORD1(v31[0]) = *a9;
        v19 = 16;
LABEL_19:
        v21 = CFDataCreate(v16, (const UInt8 *)v31, v19);
        if (v21)
        {
          v22 = v21;
          if ((a2 & 2) != 0)
          {
            CFArrayAppendValue((CFMutableArrayRef)Value, v21);
          }
          else
          {
            v46.length = CFArrayGetCount((CFArrayRef)Value);
            v46.location = 0;
            FirstIndexOfValue = CFArrayGetFirstIndexOfValue((CFArrayRef)Value, v46, v22);
            if (FirstIndexOfValue != -1)
              CFArrayRemoveValueAtIndex((CFMutableArrayRef)Value, FirstIndexOfValue);
          }
          CFRelease(v22);
        }
      }
    }
    else if (a6 == 28 && a8 == 16)
    {
      LOWORD(v31[0]) = 7708;
      WORD1(v31[0]) = bswap32(v18) >> 16;
      *(_OWORD *)((char *)v31 + 8) = *(_OWORD *)a9;
      if (BYTE8(v31[0]) == 254 && (BYTE9(v31[0]) & 0xC0) == 0x80)
        DWORD2(v31[1]) = a3;
      v19 = 28;
      goto LABEL_19;
    }
    v26 = dbl_1841E3860[(a2 & 1) == 0];
    v27 = CFAbsoluteTimeGetCurrent() + v26;
    v28 = (__CFRunLoopTimer *)*((_QWORD *)cf + 5);
    if (v28)
    {
      CFRunLoopTimerSetNextFireDate(v28, v27);
    }
    else
    {
      *(_QWORD *)&v31[0] = 0;
      *((_QWORD *)&v31[0] + 1) = cf;
      *(_QWORD *)&v32 = 0;
      v31[1] = 0uLL;
      v29 = CFGetAllocator(cf);
      v30 = CFRunLoopTimerCreate(v29, v27, 10000000.0, 0, 0, (CFRunLoopTimerCallBack)_ShortTimerCallBack, (CFRunLoopTimerContext *)v31);
      *((_QWORD *)cf + 5) = v30;
      CFArrayAppendValue(*((CFMutableArrayRef *)cf + 8), v30);
      _CFTypeScheduleOnMultipleRunLoops(*((void **)cf + 5), *((const __CFArray **)cf + 12));
    }
LABEL_32:
    os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
LABEL_33:
    CFRelease(cf);
  }
}

void _ShortTimerCallBack(__CFRunLoopTimer *a1, char *cf)
{
  void (*v3)(char *, __int128 *, uint64_t);
  uint64_t v4;
  __int128 v5;

  CFRetain(cf);
  os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
  v3 = (void (*)(char *, __int128 *, uint64_t))*((_QWORD *)cf + 13);
  v5 = *(_OWORD *)(cf + 24);
  v4 = *((_QWORD *)cf + 15);
  os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
  if (v3)
  {
    v3(cf, &v5, v4);
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
    _CleanupService_NoLock((__CFNetService *)cf);
    os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
  }
  CFRelease(cf);
}

void CFNetServiceCancel(CFNetServiceRef theService)
{
  os_unfair_lock_s *v2;
  const __CFAllocator *v3;
  CFRunLoopSourceRef v4;
  CFRunLoopSourceRef v5;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex i;
  __CFRunLoop *ValueAtIndex;
  const __CFString *v10;
  const __CFString *v11;
  CFRunLoopSourceContext v12;

  v2 = (os_unfair_lock_s *)((char *)theService + 16);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  if (CFArrayGetCount(*((CFArrayRef *)theService + 8)))
  {
    v12.version = 0;
    v12.info = theService;
    v12.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
    v12.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
    memset(&v12.copyDescription, 0, 40);
    v12.perform = (void (__cdecl *)(void *))_ServiceCancel;
    _CleanupService_NoLock(theService);
    *((_BYTE *)theService + 20) &= 0xF1u;
    *((_QWORD *)theService + 3) = 10;
    *((_DWORD *)theService + 8) = -72005;
    v3 = CFGetAllocator(theService);
    v4 = CFRunLoopSourceCreate(v3, 0, &v12);
    if (v4)
    {
      v5 = v4;
      v6 = (const __CFArray *)*((_QWORD *)theService + 12);
      Count = CFArrayGetCount(v6);
      *((_BYTE *)theService + 20) |= 8u;
      CFArrayAppendValue(*((CFMutableArrayRef *)theService + 8), v5);
      _ScheduleSources(*((const __CFArray **)theService + 8), *((const __CFArray **)theService + 12));
      CFRunLoopSourceSignal(v5);
      if (Count >= 1)
      {
        for (i = 0; i < Count; i += 2)
        {
          ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v6, i);
          if (CFRunLoopIsWaiting(ValueAtIndex))
          {
            v10 = CFRunLoopCopyCurrentMode(ValueAtIndex);
            if (v10)
            {
              v11 = v10;
              if (CFRunLoopContainsSource(ValueAtIndex, v5, v10))
                CFRunLoopWakeUp(ValueAtIndex);
              CFRelease(v11);
            }
          }
        }
      }
      CFRelease(v5);
    }
  }
  os_unfair_lock_unlock(v2);
}

void _ServiceCancel(__CFNetService *a1)
{
  uint64_t v2;
  void (*v3)(__CFNetService *, __int128 *, uint64_t);
  const void *v4;
  __int128 v5;

  CFRetain(a1);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  if (CFArrayGetCount(*((CFArrayRef *)a1 + 8)))
  {
    v5 = *(_OWORD *)((char *)a1 + 24);
    v2 = *((_QWORD *)a1 + 15);
    v3 = (void (*)(__CFNetService *, __int128 *, uint64_t))*((_QWORD *)a1 + 13);
    _UnscheduleSources(*((const __CFArray **)a1 + 8), *((const __CFArray **)a1 + 12));
    _InvalidateSources(*((__CFArray **)a1 + 8));
    v4 = (const void *)*((_QWORD *)a1 + 5);
    if (v4)
    {
      CFRelease(v4);
      *((_QWORD *)a1 + 5) = 0;
    }
  }
  else
  {
    v3 = 0;
    v2 = 0;
  }
  *((_BYTE *)a1 + 20) &= ~8u;
  os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
  if (v3)
    v3(a1, &v5, v2);
  CFRelease(a1);
}

Boolean CFNetServiceSetClient(CFNetServiceRef theService, CFNetServiceClientCallBack clientCB, CFNetServiceClientContext *clientContext)
{
  os_unfair_lock_s *v6;
  void (*v7)(void);
  __int128 v8;
  __int128 v9;
  uint64_t (*v10)(void);

  v6 = (os_unfair_lock_s *)((char *)theService + 16);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  if (*((_QWORD *)theService + 15))
  {
    v7 = (void (*)(void))*((_QWORD *)theService + 17);
    if (v7)
      v7();
  }
  if (clientCB && clientContext)
  {
    if (!*((_QWORD *)theService + 13) && CFArrayGetCount(*((CFArrayRef *)theService + 8)))
      _ScheduleSources(*((const __CFArray **)theService + 8), *((const __CFArray **)theService + 12));
    *((_QWORD *)theService + 13) = clientCB;
    v8 = *(_OWORD *)&clientContext->version;
    v9 = *(_OWORD *)&clientContext->retain;
    *((_QWORD *)theService + 18) = clientContext->copyDescription;
    *((_OWORD *)theService + 7) = v8;
    *((_OWORD *)theService + 8) = v9;
    if (*((_QWORD *)theService + 15))
    {
      v10 = (uint64_t (*)(void))*((_QWORD *)theService + 16);
      if (v10)
        *((_QWORD *)theService + 15) = v10();
    }
  }
  else
  {
    _CleanupService_NoLock(theService);
    *((_BYTE *)theService + 20) &= 0xF0u;
    *(_OWORD *)((char *)theService + 104) = 0u;
    *(_OWORD *)((char *)theService + 120) = 0u;
    *(_OWORD *)((char *)theService + 136) = 0u;
  }
  os_unfair_lock_unlock(v6);
  return 1;
}

CFDictionaryRef CFNetServiceCreateDictionaryWithTXTData(CFAllocatorRef alloc, CFDataRef txtRecord)
{
  CFIndex Length;
  const UInt8 *BytePtr;
  const UInt8 *v6;
  unsigned int Count;
  const __CFDictionary *Mutable;
  uint16_t v9;
  const __CFData *v10;
  CFStringRef v11;
  CFDataRef v12;
  void *value;
  uint8_t valueLen;
  char key[256];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  Length = CFDataGetLength(txtRecord);
  BytePtr = CFDataGetBytePtr(txtRecord);
  if ((unint64_t)(Length - 1) > 0xFFFE)
    return 0;
  v6 = BytePtr;
  Count = TXTRecordGetCount(Length, BytePtr);
  Mutable = CFDictionaryCreateMutable(alloc, 0, &CFNetServiceCreateDictionaryWithTXTData::kTXTDictionaryKeyCallBacks, MEMORY[0x1E0C9B3A0]);
  if (Mutable && Count)
  {
    v9 = 0;
    v10 = (const __CFData *)*MEMORY[0x1E0C9B0D0];
    while (1)
    {
      valueLen = 0;
      value = 0;
      if (!TXTRecordGetItemAtIndex(Length, v6, v9, 0x100u, key, &valueLen, (const void **)&value))
        break;
LABEL_17:
      if (Count <= ++v9)
        return Mutable;
    }
    v11 = CFStringCreateWithCString(alloc, key, 0x8000100u);
    v12 = v10;
    if (value)
      v12 = CFDataCreate(alloc, (const UInt8 *)value, valueLen);
    if (v12 && v11)
    {
      if (CFStringGetLength(v11) && !CFDictionaryGetValue(Mutable, v11))
        CFDictionaryAddValue(Mutable, v11, v12);
    }
    else if (!v12)
    {
      goto LABEL_15;
    }
    CFRelease(v12);
LABEL_15:
    if (v11)
      CFRelease(v11);
    goto LABEL_17;
  }
  return Mutable;
}

CFTypeRef TXTDictionaryKeyRetain(const __CFAllocator *a1, CFTypeRef cf)
{
  return CFRetain(cf);
}

void TXTDictionaryKeyRelease(const __CFAllocator *a1, CFTypeRef cf)
{
  CFRelease(cf);
}

BOOL TXTDictionaryKeyEqual(const __CFString *a1, const __CFString *a2)
{
  return CFStringCompare(a1, a2, 1uLL) == kCFCompareEqualTo;
}

CFDataRef CFNetServiceCreateTXTDataWithDictionary(CFAllocatorRef alloc, CFDictionaryRef keyValuePairs)
{
  CFIndex Count;
  const void **v5;
  const void **v6;
  const void **v7;
  CFTypeID TypeID;
  CFTypeID v9;
  uint64_t v10;
  CFTypeID v11;
  CFIndex Length;
  CFIndex Bytes;
  CFIndex v14;
  uint8_t v15;
  const void *BytePtr;
  uint8_t v17;
  CFDataRef v18;
  const __CFData *v19;
  const UInt8 *BytesPtr;
  unsigned int v22;
  const void *v23;
  CFIndex usedBufLen;
  UInt8 v25[256];
  UInt8 buffer[256];
  TXTRecordRef txtRecord;
  uint64_t v28;
  CFRange v29;
  CFRange v30;

  v28 = *MEMORY[0x1E0C80C00];
  Count = CFDictionaryGetCount(keyValuePairs);
  v5 = (const void **)CFAllocatorAllocate(alloc, 8 * Count, 0);
  v6 = (const void **)CFAllocatorAllocate(alloc, 8 * Count, 0);
  v7 = v6;
  if (v5 && v6)
  {
    TypeID = CFStringGetTypeID();
    v9 = CFDataGetTypeID();
    CFDictionaryGetKeysAndValues(keyValuePairs, v5, v7);
    TXTRecordCreate(&txtRecord, 0, 0);
    if (Count < 1)
    {
      v10 = 0;
    }
    else
    {
      v10 = 0;
      v23 = (const void *)*MEMORY[0x1E0C9B0D0];
      while (1)
      {
        usedBufLen = 0;
        v11 = CFGetTypeID(v7[v10]);
        if (CFGetTypeID(v5[v10]) != TypeID)
          break;
        Length = CFStringGetLength((CFStringRef)v5[v10]);
        v29.location = 0;
        v29.length = Length;
        Bytes = CFStringGetBytes((CFStringRef)v5[v10], v29, 0x600u, 0, 0, buffer, 256, &usedBufLen);
        if (!Length || Bytes < Length || usedBufLen > 255)
          break;
        buffer[usedBufLen] = 0;
        if (v11 == TypeID)
        {
          v14 = CFStringGetLength((CFStringRef)v7[v10]);
          v30.location = 0;
          v30.length = v14;
          if (CFStringGetBytes((CFStringRef)v7[v10], v30, 0x8000100u, 0, 0, v25, 256, &usedBufLen) < v14
            || usedBufLen > 255)
          {
            break;
          }
          v15 = usedBufLen;
          BytePtr = v25;
        }
        else if (v11 != v9 || CFDataGetLength((CFDataRef)v7[v10]) > 255 || CFDataGetLength((CFDataRef)v7[v10]) < 0)
        {
          if (v7[v10] != v23)
            break;
          v15 = 0;
          BytePtr = 0;
        }
        else
        {
          v17 = CFDataGetLength((CFDataRef)v7[v10]);
          BytePtr = CFDataGetBytePtr((CFDataRef)v7[v10]);
          v15 = v17;
        }
        if (TXTRecordSetValue(&txtRecord, (const char *)buffer, v15, BytePtr))
          break;
        if (Count == ++v10)
          goto LABEL_28;
      }
    }
    if (v10 == Count)
    {
LABEL_28:
      BytesPtr = (const UInt8 *)TXTRecordGetBytesPtr(&txtRecord);
      v22 = TXTRecordGetLength(&txtRecord);
      v18 = CFDataCreate(alloc, BytesPtr, v22);
    }
    else
    {
      v18 = 0;
    }
    TXTRecordDeallocate(&txtRecord);
LABEL_31:
    CFAllocatorDeallocate(alloc, v5);
    v19 = v18;
    if (!v7)
      return v19;
    goto LABEL_24;
  }
  v18 = 0;
  v19 = 0;
  if (v5)
    goto LABEL_31;
  if (v6)
LABEL_24:
    CFAllocatorDeallocate(alloc, v7);
  return v19;
}

CFNetServiceRef _CFNetServiceCreateFromServiceName(const __CFAllocator *a1, CFStringRef theString)
{
  uint64_t v3;
  uint64_t v4;
  char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  int v17;
  char *v18;
  char v19;
  uint64_t v20;
  uint64_t i;
  char *v22;
  int v23;
  int v24;
  int v25;
  int v26;
  char *v27;
  uint64_t v28;
  CFNetServiceRef v29;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  unsigned __int8 *v34;
  unsigned int v35;
  unsigned __int8 v36;
  char *v37;
  char *v38;
  char *v39;
  char v40;
  const __CFString *v41;
  const __CFString *v42;
  const __CFString *v43;
  const __CFString *v44;
  char v45[1009];
  char v46[1009];
  char cStr[64];
  unsigned __int8 v48[256];
  unsigned __int8 v49[256];
  _BYTE v50[64];
  uint64_t v51;
  _BYTE v52[256];
  char buffer[1009];
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  if (!theString || !CFStringGetCString(theString, buffer, 1009, 0x8000100u))
    return 0;
  v3 = 0;
  v52[0] = 0;
  while (1)
  {
    v4 = v52[v3];
    if (v4 > 0x3F)
    {
LABEL_7:
      v5 = buffer;
      v6 = buffer;
      goto LABEL_8;
    }
    if (!v52[v3])
      break;
    v3 += v4 + 1;
    if ((unint64_t)v3 >= 0x101)
      goto LABEL_7;
  }
  v18 = &v52[v3];
  v6 = buffer;
  if ((unint64_t)v3 > 0xFE || (v19 = buffer[0]) == 0)
  {
    v5 = &v52[v3];
    goto LABEL_8;
  }
  v6 = buffer;
  do
  {
    if (v19 == 46)
    {
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "AppendDNSNameString: Illegal empty label in name \"%s\"", buffer);
      return 0;
    }
    if (v3 <= 254)
      v20 = 254;
    else
      v20 = v3;
    for (i = v3; ; ++i)
    {
      if (!v19 || v19 == 46)
      {
        v20 = i;
LABEL_42:
        v3 = i + 1;
        v5 = &v52[i + 1];
        i = v20;
        goto LABEL_43;
      }
      if (v20 == i)
        goto LABEL_42;
      v22 = v6 + 1;
      if (v19 == 92)
        break;
LABEL_40:
      v52[i + 1] = v19;
      v19 = *v22;
      v6 = v22;
    }
    v23 = *v22;
    if (*v22)
    {
      v19 = *v22;
      v22 = v6 + 2;
      if (v23 - 48 <= 9)
      {
        v24 = *v22;
        if ((v24 - 48) <= 9)
        {
          v25 = v6[3];
          if ((v25 - 48) <= 9)
          {
            v26 = 100 * v23 + 10 * v24 + v25;
            v27 = v6 + 4;
            if (v26 < 5584)
            {
              v19 = v26 + 48;
              v22 = v27;
            }
          }
        }
      }
      goto LABEL_40;
    }
    v19 = 0;
    v3 = i + 1;
    v5 = &v52[i + 1];
    ++v6;
LABEL_43:
    v28 = (uint64_t)&v5[~(unint64_t)v18];
    if (v28 > 63)
      return 0;
    if (v19)
      ++v6;
    *v18 = v28;
    v19 = *v6;
    if (!*v6)
      break;
    v18 = v5;
  }
  while (i < 254);
LABEL_8:
  *v5 = 0;
  if (*v6)
    return 0;
  v7 = v52[0];
  if (v52[0] - 64 < 0xFFFFFFC1)
    return 0;
  v8 = 0;
  v9 = v52[0] + 1;
  do
  {
    v10 = v8 + 1;
    v50[v8] = v52[v8];
    v8 = v10;
  }
  while (v9 != v10);
  v11 = v52[v10];
  if ((v11 - 64) < 0xFFFFFFC1)
    return 0;
  if (v52[v10 + 1] != 95)
    return 0;
  v12 = 0;
  v13 = &v52[v7 + 1];
  v14 = v7 + 2 + v11;
  v15 = v11 + 1;
  do
  {
    v49[v12] = v13[v12];
    ++v12;
  }
  while (v15 != v12);
  v16 = &v13[v12];
  if (*v16 != 4 || v16[1] != 95)
    return 0;
  v17 = v16[2] & 0xDF;
  if (v17 != 84)
  {
    if (v17 != 85 || (v16[3] & 0xDF) != 0x44)
      return 0;
LABEL_55:
    if ((v16[4] & 0xDF) != 0x50)
      return 0;
    v31 = 0;
    do
    {
      v49[v31 + v12] = v52[v14 + v31];
      ++v31;
    }
    while ((_DWORD)v31 != 5);
    v32 = v14 + v31;
    v49[v12 + v31] = 0;
    v33 = v52[v14 + v31];
    if (v52[v32])
    {
      v34 = v48;
      while (v33 <= 0x3F && v32 + v33 + 1 <= 254)
      {
        v35 = v33 + 1;
        do
        {
          v36 = v52[v32++];
          *v34++ = v36;
          --v35;
        }
        while (v35);
        v33 = v52[v32];
        if (!v52[v32])
          goto LABEL_67;
      }
      return 0;
    }
    v34 = v48;
LABEL_67:
    *v34 = 0;
    if (v50[0] <= 0x3Fu)
    {
      if (v50[0])
      {
        v37 = &v50[v50[0] + 1];
        v38 = (char *)&v51;
        v39 = cStr;
        do
        {
          v40 = *v38++;
          *v39++ = v40;
        }
        while (v38 < v37);
      }
      else
      {
        v39 = cStr;
      }
      *v39 = 0;
    }
    _DNSServiceConvertDomainNameToCString_withescape(v49, (unsigned __int8 *)v46);
    _DNSServiceConvertDomainNameToCString_withescape(v48, (unsigned __int8 *)v45);
    v41 = CFStringCreateWithCString(a1, cStr, 0x8000100u);
    v42 = CFStringCreateWithCString(a1, v46, 0x8000100u);
    v43 = CFStringCreateWithCString(a1, v45, 0x8000100u);
    v44 = v43;
    if (v41)
    {
      if (v42 && v43)
      {
        v29 = CFNetServiceCreate(a1, v43, v42, v41, -1);
        CFRelease(v41);
        CFRelease(v42);
        CFRelease(v44);
        return v29;
      }
      CFRelease(v41);
    }
    if (v42)
      CFRelease(v42);
    if (v44)
      CFRelease(v44);
    return 0;
  }
  if ((v16[3] & 0xDF) == 0x43)
    goto LABEL_55;
  return 0;
}

CFNetServiceRef _CFNetServiceCreateFromURL(const __CFAllocator *a1, CFURLRef anURL)
{
  const __CFString *v3;
  const __CFString *v4;
  CFNetServiceRef v5;

  if (!anURL)
    return 0;
  v3 = CFURLCopyHostName(anURL);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = _CFNetServiceCreateFromServiceName(a1, v3);
  CFRelease(v4);
  return v5;
}

CFTypeID CFNetServiceMonitorGetTypeID(void)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_1635;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = _CFNetServiceMonitorRegisterClass;
  if (_kCFNetServiceMonitorRegisterClass != -1)
    dispatch_once(&_kCFNetServiceMonitorRegisterClass, block);
  return _kCFNetServiceMonitorTypeID;
}

_QWORD *_CFNetServiceMonitorRegisterClass(void)
{
  _QWORD *result;

  result = malloc_type_calloc(1uLL, 0x60uLL, 0x10D00408820D60FuLL);
  _kCFNetServiceMonitorClass = (uint64_t)result;
  if (result)
  {
    *result = 0;
    result[1] = "CFNetServiceMonitor";
    result[4] = _MonitorDestroy;
    result = (_QWORD *)_CFRuntimeRegisterClass();
    _kCFNetServiceMonitorTypeID = (uint64_t)result;
  }
  return result;
}

uint64_t ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_1635(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

void _MonitorDestroy(__CFNetServiceMonitor *a1)
{
  os_unfair_lock_s *v2;
  void (*v3)(void);
  uint64_t v4;
  uint64_t v5;
  _DNSServiceRef_t *v6;
  const void *v7;
  const void *v8;
  const void *v9;

  v2 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  if (*((_QWORD *)a1 + 13))
  {
    v3 = (void (*)(void))*((_QWORD *)a1 + 15);
    if (v3)
      v3();
  }
  v4 = *((_QWORD *)a1 + 6);
  if (v4)
  {
    v5 = *((_QWORD *)a1 + 10);
    if (v5)
    {
      _CFTypeUnscheduleFromMultipleRunLoops(v4, v5);
      v4 = *((_QWORD *)a1 + 6);
    }
    _CFTypeInvalidate(v4);
    CFRelease(*((CFTypeRef *)a1 + 6));
  }
  v6 = (_DNSServiceRef_t *)*((_QWORD *)a1 + 7);
  if (v6)
    DNSServiceRefDeallocate(v6);
  v7 = (const void *)*((_QWORD *)a1 + 5);
  if (v7)
  {
    CFRelease(v7);
    *((_QWORD *)a1 + 5) = 0;
  }
  v8 = (const void *)*((_QWORD *)a1 + 10);
  if (v8)
    CFRelease(v8);
  v9 = (const void *)*((_QWORD *)a1 + 8);
  if (v9)
    CFRelease(v9);
  os_unfair_lock_unlock(v2);
}

CFNetServiceMonitorRef CFNetServiceMonitorCreate(CFAllocatorRef alloc, CFNetServiceRef theService, CFNetServiceMonitorClientCallBack clientCB, CFNetServiceClientContext *clientContext)
{
  __CFNetServiceMonitor *v4;
  uint64_t Instance;
  __int128 v10;
  __int128 v11;
  uint64_t (*v12)(void);
  CFMutableArrayRef Mutable;

  v4 = 0;
  if (clientCB && clientContext)
  {
    if (!CFNetServiceMonitorGetTypeID())
      return 0;
    Instance = _CFRuntimeCreateInstance();
    v4 = (__CFNetServiceMonitor *)Instance;
    if (Instance)
    {
      *(_QWORD *)(Instance + 128) = 0;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(_OWORD *)(Instance + 48) = 0u;
      *(_OWORD *)(Instance + 16) = 0u;
      *(_QWORD *)(Instance + 88) = clientCB;
      v11 = *(_OWORD *)&clientContext->version;
      v10 = *(_OWORD *)&clientContext->retain;
      *(_QWORD *)(Instance + 128) = clientContext->copyDescription;
      *(_OWORD *)(Instance + 96) = v11;
      *(_OWORD *)(Instance + 112) = v10;
      if (*(_QWORD *)(Instance + 104))
      {
        v12 = *(uint64_t (**)(void))(Instance + 112);
        if (v12)
          *(_QWORD *)(Instance + 104) = v12();
      }
      Mutable = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E0C9B378]);
      *((_QWORD *)v4 + 10) = Mutable;
      if (Mutable)
      {
        *((_QWORD *)v4 + 5) = CFRetain(theService);
        return v4;
      }
      CFRelease(v4);
      return 0;
    }
  }
  return v4;
}

void CFNetServiceMonitorInvalidate(CFNetServiceMonitorRef monitor)
{
  os_unfair_lock_s *v2;
  void (*v3)(void);
  uint64_t v4;
  _DNSServiceRef_t *v5;
  const void *v6;

  v2 = (os_unfair_lock_s *)((char *)monitor + 16);
  os_unfair_lock_lock((os_unfair_lock_t)monitor + 4);
  if (*((_QWORD *)monitor + 13))
  {
    v3 = (void (*)(void))*((_QWORD *)monitor + 15);
    if (v3)
      v3();
  }
  v4 = *((_QWORD *)monitor + 6);
  if (v4)
  {
    _CFTypeUnscheduleFromMultipleRunLoops(v4, *((_QWORD *)monitor + 10));
    _CFTypeInvalidate(*((_QWORD *)monitor + 6));
    CFRelease(*((CFTypeRef *)monitor + 6));
    *((_QWORD *)monitor + 6) = 0;
  }
  v5 = (_DNSServiceRef_t *)*((_QWORD *)monitor + 7);
  if (v5)
  {
    DNSServiceRefDeallocate(v5);
    *((_QWORD *)monitor + 7) = 0;
  }
  v6 = (const void *)*((_QWORD *)monitor + 5);
  if (v6)
  {
    CFRelease(v6);
    *((_QWORD *)monitor + 5) = 0;
  }
  *(_OWORD *)((char *)monitor + 120) = 0u;
  *(_OWORD *)((char *)monitor + 104) = 0u;
  *(_OWORD *)((char *)monitor + 88) = 0u;
  os_unfair_lock_unlock(v2);
}

Boolean CFNetServiceMonitorStart(CFNetServiceMonitorRef monitor, CFNetServiceMonitorType recordType, CFStreamError *error)
{
  char *v3;
  char *v4;
  int v5;
  int v6;
  char *v7;
  char *v8;
  const void *(__cdecl *v9)(const void *);
  const void *v10;
  CFTypeID v11;
  Boolean v12;
  int v13;
  uint64_t v14;
  const __CFString **v15;
  const __CFString *v16;
  uint16_t v17;
  uint16_t v18;
  const __CFBoolean *Info;
  int v20;
  const __CFBoolean *v21;
  int v22;
  DNSServiceErrorType Record;
  const __CFAllocator *v24;
  dnssd_sock_t v25;
  __CFSocket *v26;
  __CFSocket *v27;
  CFOptionFlags SocketFlags;
  int v30;
  __CFRunLoop *Current;
  CFIndex usedBufLen;
  CFSocketContext context;
  char v34;
  _QWORD v35[3];
  char domain[1024];
  char v37[1024];
  char v38[1024];
  char v39[1024];
  uint64_t v40;
  CFRange v41;

  v3 = (char *)MEMORY[0x1E0C80A78](monitor);
  v6 = v5;
  v7 = v3;
  v40 = *MEMORY[0x1E0C80C00];
  if (v4)
    v8 = v4;
  else
    v8 = &v34;
  *(_QWORD *)v8 = 0;
  *((_QWORD *)v8 + 1) = 0;
  CFRetain(v3);
  v9 = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
  os_unfair_lock_lock((os_unfair_lock_t)v7 + 4);
  v35[0] = CFNetServiceGetInfo(*((_QWORD *)v7 + 5), 0);
  v35[1] = CFNetServiceGetInfo(*((_QWORD *)v7 + 5), 4u);
  v35[2] = CFNetServiceGetInfo(*((_QWORD *)v7 + 5), 2u);
  context.version = 0;
  context.info = v7;
  context.retain = v9;
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
  context.copyDescription = 0;
  if (!*((_QWORD *)v7 + 11))
  {
    v12 = 0;
    *((_QWORD *)v7 + 3) = 10;
    v13 = -72006;
    goto LABEL_9;
  }
  v10 = (const void *)*((_QWORD *)v7 + 6);
  if (v10)
  {
    v11 = CFGetTypeID(v10);
    if (v11 == CFSocketGetTypeID())
    {
      v12 = 0;
      *((_QWORD *)v7 + 3) = 10;
      v13 = -72003;
LABEL_9:
      *((_DWORD *)v7 + 8) = v13;
      goto LABEL_39;
    }
    _CFTypeUnscheduleFromMultipleRunLoops(*((void **)v7 + 6), *((const __CFArray **)v7 + 10));
    CFRunLoopSourceInvalidate(*((CFRunLoopSourceRef *)v7 + 6));
    CFRelease(*((CFTypeRef *)v7 + 6));
    *((_QWORD *)v7 + 6) = 0;
  }
  v14 = 0;
  v15 = (const __CFString **)v35;
  do
  {
    usedBufLen = 0;
    v16 = *v15++;
    v41.length = CFStringGetLength(v16);
    v41.location = 0;
    CFStringGetBytes(v16, v41, 0x8000100u, 0, 0, (UInt8 *)&domain[v14], 1023, &usedBufLen);
    domain[v14 + usedBufLen] = 0;
    v14 += 1024;
  }
  while (v14 != 3072);
  if (v6 == 1)
    v17 = 16;
  else
    v17 = v6;
  if (v6 == 1)
    v18 = 1;
  else
    v18 = HIWORD(v6);
  DNSServiceConstructFullName(v39, v38, v37, domain);
  *((_DWORD *)v7 + 18) = v6;
  Info = (const __CFBoolean *)CFNetServiceGetInfo(*((_QWORD *)v7 + 5), 7u);
  if (Info)
    v20 = (CFBooleanGetValue(Info) != 0) << 20;
  else
    v20 = 0;
  v21 = (const __CFBoolean *)CFNetServiceGetInfo(*((_QWORD *)v7 + 5), 9u);
  if (v21 && CFBooleanGetValue(v21))
    v20 = 0x100000;
  v22 = -72008;
  Record = DNSServiceQueryRecord((DNSServiceRef *)v7 + 7, v20 | 0x100, 0, v39, v17, v18, (DNSServiceQueryRecordReply)_QueryRecordReply, v7);
  *((_DWORD *)v7 + 8) = Record;
  if (Record <= -65549)
  {
    if (Record == -65555)
      goto LABEL_38;
    if (Record == -65554)
    {
      v22 = -72002;
      goto LABEL_38;
    }
    goto LABEL_37;
  }
  if (Record == -65548)
  {
    v22 = -72001;
    goto LABEL_38;
  }
  if (Record)
  {
    if (Record == -65540)
    {
      v22 = -72004;
LABEL_38:
      v12 = 0;
      *((_QWORD *)v7 + 3) = 10;
      *((_DWORD *)v7 + 8) = v22;
      goto LABEL_39;
    }
LABEL_37:
    v22 = -72000;
    goto LABEL_38;
  }
  v24 = CFGetAllocator(v7);
  v25 = DNSServiceRefSockFD(*((DNSServiceRef *)v7 + 7));
  v26 = CFSocketCreateWithNative(v24, v25, 1uLL, (CFSocketCallBack)_SocketCallBack_Mon, &context);
  *((_QWORD *)v7 + 6) = v26;
  if (v26)
  {
    v27 = v26;
    SocketFlags = CFSocketGetSocketFlags(v26);
    CFSocketSetSocketFlags(v27, SocketFlags & 0xFFFFFFFFFFFFFF7FLL);
    if (CFArrayGetCount(*((CFArrayRef *)v7 + 10)))
    {
      _CFTypeScheduleOnMultipleRunLoops(*((void **)v7 + 6), *((const __CFArray **)v7 + 10));
      v12 = 1;
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)v7 + 4);
      Current = CFRunLoopGetCurrent();
      CFNetServiceMonitorScheduleWithRunLoop((CFNetServiceMonitorRef)v7, Current, CFSTR("_kCFNetServiceMonitorBlockingMode"));
      os_unfair_lock_lock((os_unfair_lock_t)v7 + 4);
      while (*((_QWORD *)v7 + 6))
      {
        os_unfair_lock_unlock((os_unfair_lock_t)v7 + 4);
        CFRunLoopRunInMode(CFSTR("_kCFNetServiceMonitorBlockingMode"), 1.79769313e308, 1u);
        os_unfair_lock_lock((os_unfair_lock_t)v7 + 4);
      }
      v12 = *((_DWORD *)v7 + 8) == 0;
      os_unfair_lock_unlock((os_unfair_lock_t)v7 + 4);
      CFNetServiceMonitorUnscheduleFromRunLoop((CFNetServiceMonitorRef)v7, Current, CFSTR("_kCFNetServiceMonitorBlockingMode"));
      os_unfair_lock_lock((os_unfair_lock_t)v7 + 4);
    }
  }
  else
  {
    if (*__error())
      v30 = *__error();
    else
      v30 = 12;
    *((_QWORD *)v7 + 3) = 1;
    *((_DWORD *)v7 + 8) = v30;
    DNSServiceRefDeallocate(*((DNSServiceRef *)v7 + 7));
    v12 = 0;
    *((_QWORD *)v7 + 7) = 0;
  }
LABEL_39:
  *(_OWORD *)v8 = *(_OWORD *)(v7 + 24);
  os_unfair_lock_unlock((os_unfair_lock_t)v7 + 4);
  CFRelease(v7);
  return v12;
}

void _QueryRecordReply(_DNSServiceRef_t *a1, char a2, unsigned int a3, int a4, const char *a5, unsigned __int16 a6, unsigned __int16 a7, unsigned int a8, const UInt8 *a9, unsigned int a10, unsigned int *a11)
{
  uint64_t v11;
  uint64_t v12;
  __CFNetService *v16;
  uint64_t v17;
  int v18;
  int v19;
  CFDataRef v20;
  const __CFAllocator *v21;
  const void *v22;
  int v23;
  _BOOL4 v24;
  void (*v25)(unsigned int *, __CFNetService *, uint64_t, CFDataRef, __int128 *, uint64_t);
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;

  if (a4 != -65570)
  {
    v28 = v11;
    v29 = v12;
    CFRetain(a11);
    os_unfair_lock_lock((os_unfair_lock_t)a11 + 4);
    if (!*((_QWORD *)a11 + 7))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)a11 + 4);
LABEL_36:
      CFRelease(a11);
      return;
    }
    v16 = (__CFNetService *)CFRetain(*((CFTypeRef *)a11 + 5));
    v17 = a11[18];
    if (a4)
    {
      v18 = -72008;
      if (a4 > -65549)
      {
        if (a4 == -65548)
        {
          v18 = -72001;
          goto LABEL_20;
        }
        if (a4 == -65540)
        {
          v18 = -72004;
          goto LABEL_20;
        }
      }
      else
      {
        if (a4 == -65555)
        {
LABEL_20:
          *((_QWORD *)a11 + 3) = 10;
          a11[8] = v18;
          _CFTypeUnscheduleFromMultipleRunLoops(*((void **)a11 + 6), *((const __CFArray **)a11 + 10));
          CFSocketInvalidate(*((CFSocketRef *)a11 + 6));
          CFRelease(*((CFTypeRef *)a11 + 6));
          *((_QWORD *)a11 + 6) = 0;
          DNSServiceRefDeallocate(*((DNSServiceRef *)a11 + 7));
          v20 = 0;
          v19 = 0;
          *((_QWORD *)a11 + 7) = 0;
          goto LABEL_30;
        }
        if (a4 == -65554)
        {
          v18 = -72002;
          goto LABEL_20;
        }
      }
      v18 = -72000;
      goto LABEL_20;
    }
    v19 = 0;
    v20 = 0;
    if ((a2 & 2) == 0 || !a9)
      goto LABEL_30;
    v21 = CFGetAllocator(a11);
    v20 = CFDataCreate(v21, a9, a8);
    v22 = (const void *)*((_QWORD *)a11 + 8);
    if (v22 && v20)
    {
      v23 = CFEqual(v22, v20);
      v22 = (const void *)*((_QWORD *)a11 + 8);
      if (!v23)
      {
        v19 = 1;
        if (!v22)
          goto LABEL_29;
        goto LABEL_28;
      }
      v24 = v22 == 0;
    }
    else
    {
      v24 = v22 == 0;
      if (v22 && !v20)
      {
        v19 = 1;
LABEL_28:
        CFRelease(v22);
LABEL_29:
        *((_QWORD *)a11 + 8) = v20;
        _ServiceSetInfo(v16, v17, v20, 0);
LABEL_30:
        v25 = (void (*)(unsigned int *, __CFNetService *, uint64_t, CFDataRef, __int128 *, uint64_t))*((_QWORD *)a11 + 11);
        v27 = *(_OWORD *)(a11 + 6);
        v26 = *((_QWORD *)a11 + 13);
        os_unfair_lock_unlock((os_unfair_lock_t)a11 + 4);
        if (v25 && (a2 & 2) != 0 && v19)
          v25(a11, v16, v17, v20, &v27, v26);
        if (v16)
          CFRelease(v16);
        goto LABEL_36;
      }
    }
    if (v20)
      v19 = v24;
    else
      v19 = 0;
    if (!v22)
      goto LABEL_29;
    goto LABEL_28;
  }
}

void _SocketCallBack_Mon(__CFSocket *a1, unint64_t a2, const __CFData *a3, const void *a4, DNSServiceRef *cf)
{
  _DNSServiceRef_t *v6;
  unsigned int v7;
  const char *v8;
  unsigned int v9;

  CFRetain(cf);
  v6 = (_DNSServiceRef_t *)DNSServiceProcessResult(cf[7]);
  if ((_DWORD)v6)
    _QueryRecordReply(v6, 0, v7, (int)v6, v8, 0, 0, 0, 0, v9, (unsigned int *)cf);
  CFRelease(cf);
}

void CFNetServiceMonitorScheduleWithRunLoop(CFNetServiceMonitorRef monitor, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  os_unfair_lock_s *v6;
  uint64_t v7;

  v6 = (os_unfair_lock_s *)((char *)monitor + 16);
  os_unfair_lock_lock((os_unfair_lock_t)monitor + 4);
  if (_SchedulesAddRunLoopAndMode(*((const __CFArray **)monitor + 10), runLoop, runLoopMode))
  {
    v7 = *((_QWORD *)monitor + 6);
    if (v7)
      _CFTypeScheduleOnRunLoop(v7, runLoop, runLoopMode);
  }
  os_unfair_lock_unlock(v6);
}

void CFNetServiceMonitorUnscheduleFromRunLoop(CFNetServiceMonitorRef monitor, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  os_unfair_lock_s *v6;
  uint64_t v7;

  v6 = (os_unfair_lock_s *)((char *)monitor + 16);
  os_unfair_lock_lock((os_unfair_lock_t)monitor + 4);
  if (_SchedulesRemoveRunLoopAndMode(*((const __CFArray **)monitor + 10), runLoop, runLoopMode))
  {
    v7 = *((_QWORD *)monitor + 6);
    if (v7)
      _CFTypeUnscheduleFromRunLoop(v7, runLoop, runLoopMode);
  }
  os_unfair_lock_unlock(v6);
}

void CFNetServiceMonitorStop(CFNetServiceMonitorRef monitor, CFStreamError *error)
{
  CFStreamError *v3;
  os_unfair_lock_s *v4;
  void *v5;
  _DNSServiceRef_t *v6;
  const __CFAllocator *v7;
  CFRunLoopSourceRef v8;
  const __CFArray *v9;
  CFIndex Count;
  CFIndex i;
  __CFRunLoop *ValueAtIndex;
  const __CFString *v13;
  const __CFString *v14;
  CFRunLoopSourceContext v15;
  _QWORD v16[2];

  v16[0] = 10;
  if (error)
    v3 = error;
  else
    v3 = (CFStreamError *)v16;
  v4 = (os_unfair_lock_s *)((char *)monitor + 16);
  os_unfair_lock_lock((os_unfair_lock_t)monitor + 4);
  v5 = (void *)*((_QWORD *)monitor + 6);
  if (v5)
  {
    v15.version = 0;
    v15.info = monitor;
    v15.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
    v15.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
    memset(&v15.copyDescription, 0, 40);
    v15.perform = (void (__cdecl *)(void *))_MonitorCancel;
    _CFTypeUnscheduleFromMultipleRunLoops(v5, *((const __CFArray **)monitor + 10));
    _CFTypeInvalidate(*((char **)monitor + 6));
    CFRelease(*((CFTypeRef *)monitor + 6));
    v6 = (_DNSServiceRef_t *)*((_QWORD *)monitor + 7);
    if (v6)
    {
      DNSServiceRefDeallocate(v6);
      *((_QWORD *)monitor + 7) = 0;
    }
    v16[1] = 4294895291;
    *(CFStreamError *)((char *)monitor + 24) = *v3;
    v7 = CFGetAllocator(monitor);
    v8 = CFRunLoopSourceCreate(v7, 0, &v15);
    *((_QWORD *)monitor + 6) = v8;
    if (v8)
    {
      v9 = (const __CFArray *)*((_QWORD *)monitor + 10);
      Count = CFArrayGetCount(v9);
      _CFTypeScheduleOnMultipleRunLoops(*((void **)monitor + 6), v9);
      CFRunLoopSourceSignal(*((CFRunLoopSourceRef *)monitor + 6));
      if (Count >= 1)
      {
        for (i = 0; i < Count; i += 2)
        {
          ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v9, i);
          if (CFRunLoopIsWaiting(ValueAtIndex))
          {
            v13 = CFRunLoopCopyCurrentMode(ValueAtIndex);
            if (v13)
            {
              v14 = v13;
              if (CFRunLoopContainsSource(ValueAtIndex, *((CFRunLoopSourceRef *)monitor + 6), v13))
                CFRunLoopWakeUp(ValueAtIndex);
              CFRelease(v14);
            }
          }
        }
      }
    }
  }
  os_unfair_lock_unlock(v4);
}

void _MonitorCancel(__CFNetServiceMonitor *a1)
{
  void *v2;
  uint64_t v3;
  void (*v4)(__CFNetServiceMonitor *, _QWORD, _QWORD, _QWORD, __int128 *, uint64_t);
  __int128 v5;

  CFRetain(a1);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  v2 = (void *)*((_QWORD *)a1 + 6);
  if (v2)
  {
    v5 = *(_OWORD *)((char *)a1 + 24);
    v3 = *((_QWORD *)a1 + 13);
    v4 = (void (*)(__CFNetServiceMonitor *, _QWORD, _QWORD, _QWORD, __int128 *, uint64_t))*((_QWORD *)a1 + 11);
    _CFTypeUnscheduleFromMultipleRunLoops(v2, *((const __CFArray **)a1 + 10));
    CFRunLoopSourceInvalidate(*((CFRunLoopSourceRef *)a1 + 6));
    CFRelease(*((CFTypeRef *)a1 + 6));
    *((_QWORD *)a1 + 6) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
    if (v4)
      v4(a1, 0, 0, 0, &v5, v3);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
  }
  CFRelease(a1);
}

__CFDictionary *CFNetDiagnosticCreateBasic(const __CFAllocator *a1, const void *a2, const void *a3, const void *a4)
{
  __CFDictionary *Mutable;
  __CFBundle *MainBundle;
  __CFBundle *v9;
  CFTypeRef ValueForInfoDictionaryKey;
  CFStringRef Identifier;

  Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    v9 = MainBundle;
    ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(MainBundle, (CFStringRef)*MEMORY[0x1E0C9AE88]);
    if (ValueForInfoDictionaryKey)
      CFDictionaryAddValue(Mutable, CFSTR("NDNameKey"), ValueForInfoDictionaryKey);
    Identifier = CFBundleGetIdentifier(v9);
    if (Identifier)
      CFDictionaryAddValue(Mutable, CFSTR("NDBundleKey"), Identifier);
  }
  if (a2)
    CFDictionaryAddValue(Mutable, CFSTR("NDRemoteHostKey"), a2);
  if (a3)
    CFDictionaryAddValue(Mutable, CFSTR("NDProtocolKey"), a3);
  if (a4)
    CFDictionaryAddValue(Mutable, CFSTR("NDPortKey"), a4);
  CFDictionaryAddValue(Mutable, CFSTR("NDMethodKey"), CFSTR("CFNetDiagnosticCreateBasic"));
  return Mutable;
}

CFNetDiagnosticRef CFNetDiagnosticCreateWithURL(CFAllocatorRef alloc, CFURLRef url)
{
  __CFDictionary *Mutable;
  __CFBundle *MainBundle;
  __CFBundle *v6;
  CFTypeRef ValueForInfoDictionaryKey;
  CFStringRef Identifier;
  CFStringRef v9;
  CFStringRef v10;
  CFStringRef v11;
  CFStringRef v12;
  CFNumberRef v13;
  CFNumberRef v14;
  SInt32 valuePtr;

  if (!CFURLCanBeDecomposed(url))
    return 0;
  valuePtr = CFURLGetPortNumber(url);
  Mutable = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    v6 = MainBundle;
    ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(MainBundle, (CFStringRef)*MEMORY[0x1E0C9AE88]);
    if (ValueForInfoDictionaryKey)
      CFDictionaryAddValue(Mutable, CFSTR("NDNameKey"), ValueForInfoDictionaryKey);
    Identifier = CFBundleGetIdentifier(v6);
    if (Identifier)
      CFDictionaryAddValue(Mutable, CFSTR("NDBundleKey"), Identifier);
  }
  v9 = CFURLCopyHostName(url);
  if (v9)
  {
    v10 = v9;
    CFDictionaryAddValue(Mutable, CFSTR("NDRemoteHostKey"), v9);
    CFRelease(v10);
  }
  v11 = CFURLCopyScheme(url);
  if (v11)
  {
    v12 = v11;
    CFDictionaryAddValue(Mutable, CFSTR("NDProtocolKey"), v11);
    CFRelease(v12);
  }
  v13 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
  if (v13)
  {
    v14 = v13;
    CFDictionaryAddValue(Mutable, CFSTR("NDPortKey"), v13);
    CFRelease(v14);
  }
  CFDictionaryAddValue(Mutable, CFSTR("NDMethodKey"), CFSTR("CFNetDiagnosticCreateWithURL"));
  return Mutable;
}

CFNetDiagnosticRef CFNetDiagnosticCreateWithStreams(CFAllocatorRef alloc, CFReadStreamRef readStream, CFWriteStreamRef writeStream)
{
  __CFDictionary *Mutable;
  __CFBundle *MainBundle;
  __CFBundle *v5;
  CFTypeRef ValueForInfoDictionaryKey;
  CFStringRef Identifier;

  Mutable = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    v5 = MainBundle;
    ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(MainBundle, (CFStringRef)*MEMORY[0x1E0C9AE88]);
    if (ValueForInfoDictionaryKey)
      CFDictionaryAddValue(Mutable, CFSTR("NDNameKey"), ValueForInfoDictionaryKey);
    Identifier = CFBundleGetIdentifier(v5);
    if (Identifier)
      CFDictionaryAddValue(Mutable, CFSTR("NDBundleKey"), Identifier);
  }
  CFDictionaryAddValue(Mutable, CFSTR("NDMethodKey"), CFSTR("CFNetDiagnosticCreateWithStreams"));
  return Mutable;
}

void CFNetDiagnosticSetName(CFNetDiagnosticRef details, CFStringRef name)
{
  if (name)
    CFDictionaryAddValue(details, CFSTR("NDNameKey"), name);
}

void CFNetDiagnosticSetProtocol(__CFDictionary *a1, void *value)
{
  if (value)
    CFDictionaryAddValue(a1, CFSTR("NDProtocolKey"), value);
}

void CFNetDiagnosticSetServiceID(__CFDictionary *a1, void *value)
{
  if (value)
    CFDictionaryAddValue(a1, CFSTR("NDServiceIDKey"), value);
}

CFNetDiagnosticStatus CFNetDiagnosticDiagnoseProblemInteractively(CFNetDiagnosticRef details)
{
  if (CFNetDiagnosticDiagnoseProblemInteractively::sOnce != -1)
    dispatch_once(&CFNetDiagnosticDiagnoseProblemInteractively::sOnce, &__block_literal_global_1677);
  return -66560;
}

uint64_t CFNetDiagnosticCopyNetworkStatusActively(const __CFDictionary *a1, CFStringRef *a2, double a3)
{
  uint64_t v6;
  uint64_t v7;
  uint32_t numer;
  uint32_t denom;
  const __CFAllocator *v10;
  SCDynamicStoreRef v11;
  const __SCDynamicStore *v12;
  uint64_t v13;
  const __CFString *v14;
  const __CFString *NetworkGlobalEntity;
  const __CFDictionary *v16;
  const __CFDictionary *v17;
  const __CFString *Value;
  const __CFString *v19;
  double v20;
  const __CFString *v21;
  const __CFDictionary *v22;
  const __CFDictionary *v23;
  const __CFString *v24;
  const __CFString *v25;
  const __CFString *NetworkServiceEntity;
  const __CFDictionary *v27;
  const __CFDictionary *v28;
  const __CFArray *v29;
  const __CFArray *v30;
  const __SCDynamicStore *v31;
  CFIndex Count;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const __CFString *ValueAtIndex;
  _BOOL4 v38;
  uint64_t v39;
  const __CFString *v40;
  uint64_t v41;
  const __CFString *v42;
  uint64_t v43;
  const __CFDictionary *theDict;
  const __CFString *domain;
  uint64_t v46;
  const __SCDynamicStore *store;
  CFErrorRef err;
  mach_timebase_info info;

  v6 = -66557;
  if (!mach_timebase_info(&info))
  {
    v7 = mach_absolute_time();
    numer = info.numer;
    denom = info.denom;
    v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v11 = SCDynamicStoreCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("CFNetDiagnostics"), 0, 0);
    if (v11)
    {
      v12 = v11;
      v46 = v7;
      v13 = mach_absolute_time();
      v14 = (const __CFString *)*MEMORY[0x1E0CE8B78];
      domain = (const __CFString *)*MEMORY[0x1E0CE8B30];
      NetworkGlobalEntity = SCDynamicStoreKeyCreateNetworkGlobalEntity(v10, (CFStringRef)*MEMORY[0x1E0CE8B30], (CFStringRef)*MEMORY[0x1E0CE8B78]);
      store = v12;
      v16 = (const __CFDictionary *)SCDynamicStoreCopyValue(v12, NetworkGlobalEntity);
      if (v16)
      {
        v17 = v16;
        theDict = a1;
        Value = (const __CFString *)CFDictionaryGetValue(v16, (const void *)*MEMORY[0x1E0CE8D10]);
        if (Value)
        {
          v19 = Value;
          v20 = (double)numer * -0.000000001 / (double)denom;
          CFRetain(Value);
          CFRelease(v17);
          CFRelease(NetworkGlobalEntity);
          if (CFNetDiagnosticPing(v19, 1, (a3 + v20 * (double)(v13 - v46)), 0))
          {
            v21 = SCDynamicStoreKeyCreateNetworkGlobalEntity(v10, domain, v14);
            v22 = (const __CFDictionary *)SCDynamicStoreCopyValue(store, v21);
            if (v22)
            {
              v23 = v22;
              v24 = (const __CFString *)CFDictionaryGetValue(v22, (const void *)*MEMORY[0x1E0CE8B48]);
              if (v24)
              {
                v25 = v24;
                CFRetain(v24);
                CFRelease(v23);
                CFRelease(v21);
                NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(v10, domain, v25, (CFStringRef)*MEMORY[0x1E0CE8B70]);
                v27 = (const __CFDictionary *)SCDynamicStoreCopyValue(store, NetworkServiceEntity);
                if (v27)
                {
                  v28 = v27;
                  v29 = (const __CFArray *)CFDictionaryGetValue(v27, (const void *)*MEMORY[0x1E0CE8C28]);
                  v30 = v29;
                  if (v29)
                    CFRetain(v29);
                  CFRelease(v28);
                }
                else
                {
                  v30 = 0;
                }
                CFRelease(NetworkServiceEntity);
                CFRelease(v25);
                v31 = store;
                if (!v30)
                  goto LABEL_18;
                Count = CFArrayGetCount(v30);
                v34 = mach_absolute_time();
                if (Count >= 1)
                {
                  v35 = ((a3 + v20 * (double)(v34 - v46)) / (double)Count);
                  v36 = 1;
                  do
                  {
                    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v30, v36 - 1);
                    v38 = CFNetDiagnosticPing(ValueAtIndex, 1, v35, 0);
                    if (v36 >= Count)
                      break;
                    ++v36;
                  }
                  while (!v38);
                  if (v38)
                  {
                    err = 0;
                    v39 = mach_absolute_time();
                    if (CFNetDiagnosticPing(CFSTR("www.apple.com"), 1, (a3 + v20 * (double)(v39 - v46)), &err))
                    {
                      v40 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("NDRemoteHostKey"));
                      v41 = -66559;
                      if (!v40)
                        goto LABEL_45;
                      v42 = v40;
                      if (CFEqual(v40, CFSTR("www.apple.com")))
                        goto LABEL_45;
                      v43 = mach_absolute_time();
                      if (CFNetDiagnosticPing(v42, 1, (a3 + v20 * (double)(v43 - v46)), &err))
                      {
                        v41 = -66552;
LABEL_45:
                        CFRelease(v30);
                        v6 = v41;
                        goto LABEL_18;
                      }
                      if (CFErrorGetDomain(err) == (CFErrorDomain)*MEMORY[0x1E0C9AFD0] && CFErrorGetCode(err) == 65)
                        v6 = -66555;
                      else
                        v6 = -66553;
                    }
                    else if (CFErrorGetDomain(err) == (CFErrorDomain)*MEMORY[0x1E0C9AFD0] && CFErrorGetCode(err) == 65)
                    {
                      v6 = -66556;
                    }
                    CFRelease(err);
                    v41 = v6;
                    goto LABEL_45;
                  }
                }
                v41 = -66556;
                goto LABEL_45;
              }
              CFRelease(v23);
            }
            CFRelease(v21);
          }
          else
          {
            v6 = -66554;
          }
          v31 = store;
LABEL_18:
          CFRelease(v19);
          goto LABEL_19;
        }
        CFRelease(v17);
      }
      CFRelease(NetworkGlobalEntity);
      v31 = store;
LABEL_19:
      CFRelease(v31);
    }
  }
  if (a2)
    *a2 = _CFNetDiagnosticCopyLocalizedDescription(v6);
  return v6;
}

CFStringRef _CFNetDiagnosticCopyLocalizedDescription(uint64_t a1)
{
  const __CFString *v2;
  CFStringRef result;

  if (__CFNGetCFNetworkBundle::onceToken != -1)
    dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_4752);
  switch(a1)
  {
    case -66559:
      v2 = CFSTR("CONNECTION_UP");
      goto LABEL_13;
    case -66558:
      v2 = CFSTR("CONNECTION_INDETERMINATE");
      goto LABEL_13;
    case -66557:
      v2 = CFSTR("CONNECTION_DOWN");
      goto LABEL_13;
    case -66556:
      v2 = CFSTR("NAMESERVER_DOWN");
      goto LABEL_13;
    case -66555:
      v2 = CFSTR("NAMELOOKUP_FAILED");
      goto LABEL_13;
    case -66554:
      v2 = CFSTR("ROUTER_DOWN");
      goto LABEL_13;
    case -66553:
      v2 = CFSTR("SERVER_DOWN");
      goto LABEL_13;
    case -66552:
      v2 = CFSTR("SERVER_UP");
LABEL_13:
      result = CFBundleCopyLocalizedString((CFBundleRef)__CFNGetCFNetworkBundle::bundle, v2, v2, 0);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

CFNetDiagnosticStatus CFNetDiagnosticCopyNetworkStatusPassively(CFNetDiagnosticRef details, CFStringRef *description)
{
  CFNetDiagnosticStatus v4;
  const __CFAllocator *v5;
  SCDynamicStoreRef v6;
  const __SCDynamicStore *v7;
  const __CFString *Value;
  uint64_t v9;
  const __CFString *NetworkGlobalEntity;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  const __CFArray *v13;
  const __CFArray *v14;
  CFIndex Count;
  CFIndex v16;
  CFIndex i;
  const __CFString *ValueAtIndex;
  uint64_t v19;

  v4 = -66560;
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v6 = SCDynamicStoreCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("CFNetDiagnostics"), 0, 0);
  if (v6)
  {
    v7 = v6;
    Value = (const __CFString *)CFDictionaryGetValue(details, CFSTR("NDServiceIDKey"));
    if (Value)
    {
      v9 = _CFNetDiagnosticCopyNetworkStatusPassivelyInterfaceSpecific(v7, Value, description);
      goto LABEL_18;
    }
    NetworkGlobalEntity = SCDynamicStoreKeyCreateNetworkGlobalEntity(v5, (CFStringRef)*MEMORY[0x1E0CE8B28], (CFStringRef)*MEMORY[0x1E0CE8B78]);
    v11 = (const __CFDictionary *)SCDynamicStoreCopyValue(v7, NetworkGlobalEntity);
    if (v11)
    {
      v12 = v11;
      v13 = (const __CFArray *)CFDictionaryGetValue(v11, (const void *)*MEMORY[0x1E0CE8F60]);
      if (v13)
      {
        v14 = v13;
        CFRetain(v13);
        CFRelease(v12);
        CFRelease(NetworkGlobalEntity);
        Count = CFArrayGetCount(v14);
        v9 = -66557;
        if (Count >= 1)
        {
          v16 = Count;
          for (i = 0; v16 != i; ++i)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v14, i);
            v19 = _CFNetDiagnosticCopyNetworkStatusPassivelyInterfaceSpecific(v7, ValueAtIndex, 0);
            if (v19 == -66558)
            {
              v9 = -66558;
            }
            else if (v19 == -66559)
            {
              v9 = -66559;
              if (!description)
              {
LABEL_15:
                CFRelease(v14);
                goto LABEL_18;
              }
LABEL_14:
              *description = _CFNetDiagnosticCopyLocalizedDescription(v9);
              goto LABEL_15;
            }
          }
        }
        if (!description)
          goto LABEL_15;
        goto LABEL_14;
      }
      CFRelease(v12);
    }
    CFRelease(NetworkGlobalEntity);
    v9 = -66560;
LABEL_18:
    CFRelease(v7);
    return v9;
  }
  return v4;
}

uint64_t _CFNetDiagnosticCopyNetworkStatusPassivelyInterfaceSpecific(const __SCDynamicStore *a1, CFStringRef serviceID, const __CFString **a3)
{
  uint64_t v6;
  const __CFAllocator *v7;
  const __CFString *NetworkServiceEntity;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  const void *v11;
  const void *Value;
  int v13;
  const void *v14;
  const void *v15;
  _BOOL4 v16;
  BOOL v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *NetworkInterfaceEntity;
  const __CFDictionary *v21;
  const __CFDictionary *v22;
  const __CFBoolean *v23;
  const __CFBoolean *v24;
  const __SCNetworkConnection *v25;
  _BOOL4 v26;
  const __CFBoolean *v27;
  const __CFString *v28;
  const __CFDictionary *v29;
  const __CFDictionary *v30;
  const __CFArray *v31;
  const __CFArray *v32;
  const __CFString *ValueAtIndex;
  int v34;
  in_addr_t v35;
  unsigned __int16 v36;
  _BOOL4 v37;
  uint64_t v38;
  const __CFString **v40;
  SCNetworkConnectionContext context;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v6 = -66557;
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFStringRef)*MEMORY[0x1E0CE8B28], serviceID, (CFStringRef)*MEMORY[0x1E0CE8B88]);
  v9 = (const __CFDictionary *)SCDynamicStoreCopyValue(a1, NetworkServiceEntity);
  if (!v9)
    goto LABEL_37;
  v10 = v9;
  v11 = (const void *)*MEMORY[0x1E0CE9140];
  Value = CFDictionaryGetValue(v9, (const void *)*MEMORY[0x1E0CE8D90]);
  v13 = CFEqual(v11, Value);
  v14 = CFDictionaryGetValue(v10, (const void *)*MEMORY[0x1E0CE8D88]);
  if (v14)
  {
    v15 = v14;
    if (CFEqual(v14, (CFTypeRef)*MEMORY[0x1E0CE9138]))
      goto LABEL_11;
    v16 = CFEqual(v15, (CFTypeRef)*MEMORY[0x1E0CE9130]) == 0;
  }
  else
  {
    v16 = 1;
  }
  if (v13)
    v17 = !v16;
  else
    v17 = 1;
  if (v17)
  {
LABEL_11:
    v40 = a3;
    v18 = (const __CFString *)CFDictionaryGetValue(v10, (const void *)*MEMORY[0x1E0CE8D80]);
    v19 = (const __CFString *)*MEMORY[0x1E0CE8B30];
    NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(v7, (CFStringRef)*MEMORY[0x1E0CE8B30], v18, (CFStringRef)*MEMORY[0x1E0CE8B90]);
    v21 = (const __CFDictionary *)SCDynamicStoreCopyValue(a1, NetworkInterfaceEntity);
    if (v21)
    {
      v22 = v21;
      v23 = (const __CFBoolean *)CFDictionaryGetValue(v21, (const void *)*MEMORY[0x1E0CE8D98]);
      v24 = (const __CFBoolean *)CFDictionaryGetValue(v22, (const void *)*MEMORY[0x1E0CE8DA0]);
      if (v23)
      {
        LODWORD(v23) = CFBooleanGetValue(v23);
      }
      else if (v24)
      {
        LODWORD(v23) = CFBooleanGetValue(v24) == 0;
      }
      else
      {
        LODWORD(v23) = 1;
      }
      CFRelease(v22);
    }
    else
    {
      LODWORD(v23) = 0;
    }
    CFRelease(NetworkInterfaceEntity);
    a3 = v40;
    goto LABEL_23;
  }
  memset(&context, 0, sizeof(context));
  v25 = SCNetworkConnectionCreateWithServiceID(v7, serviceID, 0, &context);
  v23 = v25;
  if (v25)
  {
    v26 = (SCNetworkConnectionGetStatus(v25) - 1) < 2;
    v27 = v23;
    LODWORD(v23) = v26;
    CFRelease(v27);
  }
  v19 = (const __CFString *)*MEMORY[0x1E0CE8B30];
LABEL_23:
  v28 = SCDynamicStoreKeyCreateNetworkServiceEntity(v7, v19, serviceID, (CFStringRef)*MEMORY[0x1E0CE8B78]);
  v29 = (const __CFDictionary *)SCDynamicStoreCopyValue(a1, v28);
  if (!v29)
  {
    v37 = 0;
    goto LABEL_33;
  }
  v30 = v29;
  v31 = (const __CFArray *)CFDictionaryGetValue(v29, (const void *)*MEMORY[0x1E0CE8CC8]);
  if (!v31
    || (v32 = v31, !CFArrayGetCount(v31))
    || (ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v32, 0)) == 0
    || (v34 = (int)v23, !CFStringGetCString(ValueAtIndex, (char *)&context, 16, 0x600u))
    || (v35 = inet_addr((const char *)&context), v35 == -1))
  {
    CFRelease(v30);
    v37 = (_DWORD)v23 != 0;
    goto LABEL_33;
  }
  v36 = v35;
  CFRelease(v30);
  v37 = v34 != 0;
  if (v36 != 65193)
  {
LABEL_33:
    v38 = -66559;
    goto LABEL_34;
  }
  v38 = -66558;
LABEL_34:
  if (v37)
    v6 = v38;
  CFRelease(v28);
  CFRelease(v10);
LABEL_37:
  CFRelease(NetworkServiceEntity);
  if (a3)
    *a3 = _CFNetDiagnosticCopyLocalizedDescription(v6);
  return v6;
}

void TrustExceptionManager::~TrustExceptionManager(TrustExceptionManager *this)
{
  *(_QWORD *)this = &off_1E14EC228;
  *((_QWORD *)this + 2) = &off_1E14EA568;
  CFRelease(*((CFTypeRef *)this + 3));
  *(_QWORD *)this = &off_1E14E5838;
}

{
  *(_QWORD *)this = &off_1E14EC228;
  *((_QWORD *)this + 2) = &off_1E14EA568;
  CFRelease(*((CFTypeRef *)this + 3));
  *(_QWORD *)this = &off_1E14E5838;
  JUMPOUT(0x186DB748CLL);
}

uint64_t RetainableTypedDict<__CFData const*,__CFData const*>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA568;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<__CFData const*,__CFData const*>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA568;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

void TrustExceptionManager::storeTrustExceptions(TrustExceptionManager *this, const __CFData *a2, SecTrustRef trust)
{
  const __CFData *v6;
  const __CFData *v7;
  CFDataRef Copy;

  if (a2 && trust)
  {
    if (TrustExceptionManager::_isSharingdProcess(void)::onceToken != -1)
      dispatch_once(&TrustExceptionManager::_isSharingdProcess(void)::onceToken, &__block_literal_global_2_1700);
    if (!TrustExceptionManager::_isSharingdProcess(void)::isSharingd)
    {
      v6 = SecTrustCopyExceptions(trust);
      if (v6)
      {
        v7 = v6;
        Copy = CFDataCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6);
        if (Copy)
        {
          os_unfair_lock_lock((os_unfair_lock_t)this + 2);
          CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 3), a2, Copy);
          CFRelease(Copy);
          os_unfair_lock_unlock((os_unfair_lock_t)this + 2);
        }
        CFRelease(v7);
      }
    }
  }
}

void sub_184002ACC(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN21TrustExceptionManager18_isSharingdProcessEv_block_invoke()
{
  const char **v0;
  uint64_t result;

  v0 = (const char **)_CFGetProgname();
  result = strcmp(*v0, "sharingd");
  TrustExceptionManager::_isSharingdProcess(void)::isSharingd = (_DWORD)result == 0;
  return result;
}

CFTypeID CFHostGetTypeID(void)
{
  if (HostBase::Class(void)::sOnce_HostBase != -1)
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
  return *(_QWORD *)(HostBase::Class(void)::sClass_OBJTYPE + 96);
}

CFHostRef CFHostCreateWithAddress(CFAllocatorRef allocator, CFDataRef addr)
{
  _OWORD *Instance;
  DispatchHost *v5;
  __CFArray *Array;
  _OWORD *v7;
  __CFArray *v8;

  if (HostBase::Class(void)::sOnce_HostBase != -1)
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v5 = (DispatchHost *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v5 = (DispatchHost *)(Instance + 1);
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  Array = cfTypeCreateArray(allocator, addr, 0, 0, 0);
  DispatchHost::DispatchHost(v5, CFSTR("kCFHostAddresses"), Array, 0);
  if (Array)
    CFRelease(Array);
  if (v5)
    return (DispatchHost *)((char *)v5 - 16);
  if (HostBase::Class(void)::sOnce_HostBase != -1)
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
  v7 = (_OWORD *)_CFRuntimeCreateInstance();
  v5 = (DispatchHost *)v7;
  if (v7)
  {
    v7[1] = 0u;
    v5 = (DispatchHost *)(v7 + 1);
    v7[8] = 0u;
    v7[9] = 0u;
    v7[6] = 0u;
    v7[7] = 0u;
    v7[4] = 0u;
    v7[5] = 0u;
    v7[2] = 0u;
    v7[3] = 0u;
  }
  v8 = cfTypeCreateArray(allocator, addr, 0, 0, 0);
  Host::Host(v5, CFSTR("kCFHostAddresses"), v8, 0);
  if (v8)
    CFRelease(v8);
  if (v5)
    return (DispatchHost *)((char *)v5 - 16);
  else
    return 0;
}

void sub_184002CE4(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

Boolean CFHostSetClient(CFHostRef theHost, CFHostClientCallBack clientCB, CFHostClientContext *clientContext)
{
  HostBase *v6;
  const __CFAllocator *v8;
  StubHostDelegate *v9;
  uint64_t v10;
  _QWORD *v11;
  Boolean v12;

  if (HostBase::Class(void)::sOnce_HostBase != -1)
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
  if (theHost)
    v6 = (CFHostRef)((char *)theHost + 16);
  else
    v6 = 0;
  if (!((unint64_t)clientCB | (unint64_t)clientContext))
    return HostBase::setDelegate(v6, 0);
  v8 = CFGetAllocator((char *)v6 - 16);
  v9 = (StubHostDelegate *)CFAllocatorAllocate(v8, 96, 0);
  *(_OWORD *)v9 = 0u;
  *((_OWORD *)v9 + 2) = 0u;
  *((_OWORD *)v9 + 3) = 0u;
  *((_OWORD *)v9 + 4) = 0u;
  *((_OWORD *)v9 + 5) = 0u;
  *((_OWORD *)v9 + 1) = 0u;
  v10 = (uint64_t)v9 + 16;
  StubHostDelegate::StubHostDelegate(v9, v8, clientContext);
  *v11 = off_1E14E9CB8;
  *(_QWORD *)v10 = &unk_1E14E9CF0;
  v11[11] = clientCB;
  v12 = HostBase::setDelegate(v6, v10);
  (*(void (**)(uint64_t))(*(_QWORD *)v10 + 32))(v10);
  return v12;
}

uint64_t _CFHostSetClientInfoCallback(__CFHost *a1, unint64_t a2, CFHostClientContext *a3)
{
  HostBase *v6;
  const __CFAllocator *v8;
  StubHostDelegate *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;

  if (HostBase::Class(void)::sOnce_HostBase != -1)
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
  if (a1)
    v6 = (__CFHost *)((char *)a1 + 16);
  else
    v6 = 0;
  if (!(a2 | (unint64_t)a3))
    return HostBase::setDelegate(v6, 0);
  v8 = CFGetAllocator((char *)v6 - 16);
  v9 = (StubHostDelegate *)CFAllocatorAllocate(v8, 96, 0);
  *(_OWORD *)v9 = 0u;
  *((_OWORD *)v9 + 2) = 0u;
  *((_OWORD *)v9 + 3) = 0u;
  *((_OWORD *)v9 + 4) = 0u;
  *((_OWORD *)v9 + 5) = 0u;
  *((_OWORD *)v9 + 1) = 0u;
  v10 = (uint64_t)v9 + 16;
  StubHostDelegate::StubHostDelegate(v9, v8, a3);
  *v11 = off_1E14E9038;
  *(_QWORD *)v10 = &unk_1E14E9070;
  v11[11] = a2;
  v12 = HostBase::setDelegate(v6, v10);
  (*(void (**)(uint64_t))(*(_QWORD *)v10 + 32))(v10);
  return v12;
}

CFArrayRef CFHostGetAddressing(CFHostRef theHost, Boolean *hasBeenResolved)
{
  return (CFArrayRef)CFHostGetInfo((uint64_t)theHost, 0, (BOOL *)hasBeenResolved);
}

CFArrayRef CFHostGetNames(CFHostRef theHost, Boolean *hasBeenResolved)
{
  return (CFArrayRef)CFHostGetInfo((uint64_t)theHost, 1, (BOOL *)hasBeenResolved);
}

CFDataRef CFHostGetReachability(CFHostRef theHost, Boolean *hasBeenResolved)
{
  return (CFDataRef)CFHostGetInfo((uint64_t)theHost, 2, (BOOL *)hasBeenResolved);
}

uint64_t _CFHostStartInfoResolutionForInterface(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;

  if (HostBase::Class(void)::sOnce_HostBase != -1)
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
  if (a1)
    v6 = a1 + 16;
  else
    v6 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v6 + 56))(v6, a2, a3, 0);
}

void CFHostCancelInfoResolution(CFHostRef theHost, CFHostInfoType info)
{
  char *v4;
  uint64_t v5;

  if (HostBase::Class(void)::sOnce_HostBase != -1)
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
  if (theHost)
    v4 = (char *)theHost + 16;
  else
    v4 = 0;
  v5 = infoToString(info);
  (*(void (**)(char *, uint64_t))(*(_QWORD *)v4 + 64))(v4, v5);
}

void CFHostScheduleWithRunLoop(CFHostRef theHost, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  char *v6;

  if (HostBase::Class(void)::sOnce_HostBase != -1)
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
  if (theHost)
    v6 = (char *)theHost + 16;
  else
    v6 = 0;
  (*(void (**)(char *, CFRunLoopRef, CFStringRef))(*(_QWORD *)v6 + 72))(v6, runLoop, runLoopMode);
}

void CFHostUnscheduleFromRunLoop(CFHostRef theHost, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  char *v6;

  if (HostBase::Class(void)::sOnce_HostBase != -1)
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
  if (theHost)
    v6 = (char *)theHost + 16;
  else
    v6 = 0;
  (*(void (**)(char *, CFRunLoopRef, CFStringRef))(*(_QWORD *)v6 + 80))(v6, runLoop, runLoopMode);
}

BOOL CFNetDiagnosticPingWithOptions(const __CFString *a1, const __CFDictionary *a2, CFErrorRef *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  _BOOL4 v11;
  int v12;
  CFErrorRef CFError;
  BOOL v14;
  hostent *v16;
  int h_addrtype;
  const __CFNumber *Value;
  const __CFNumber *v19;
  const __CFNumber *v20;
  const __CFNumber *v21;
  const __CFNumber *v22;
  protoent *v23;
  int v24;
  int v25;
  unsigned int v26;
  int v27;
  int v28;
  int v29;
  size_t v30;
  unsigned __int16 *v31;
  unsigned __int16 *v32;
  _BYTE *v33;
  uint64_t v34;
  NSObject *v35;
  NSObject *v36;
  int v37;
  unsigned int v38;
  unsigned __int16 *v39;
  int v40;
  unsigned int v41;
  ssize_t v42;
  __darwin_time_t v43;
  char v44;
  ssize_t v45;
  int v46;
  uint64_t v47;
  __uint8_t *v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  int v52;
  int valuePtr;
  int v55;
  int v56;
  int v57;
  int v58;
  timeval v59;
  socklen_t v60;
  timeval v61;
  _BYTE __dst[12];
  char buffer[1024];
  sockaddr v64;
  sockaddr v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  bzero(buffer, 0x400uLL);
  if (!a1 || !CFStringGetLength(a1) || !CFStringGetCString(a1, buffer, 1024, 0x8000100u))
  {
    v11 = 0;
    v12 = 22;
    goto LABEL_7;
  }
  *(_DWORD *)&__dst[8] = 0;
  *(_QWORD *)__dst = inet_addr(buffer);
  if (*(_DWORD *)__dst == -1)
  {
    v16 = gethostbyname(buffer);
    if (!v16)
    {
      v11 = 0;
      v12 = 65;
      goto LABEL_7;
    }
    h_addrtype = v16->h_addrtype;
    memcpy(__dst, *(const void **)v16->h_addr_list, v16->h_length);
    v10 = h_addrtype << 8;
  }
  else
  {
    v10 = 512;
  }
  v52 = v10;
  v58 = 0;
  valuePtr = 10;
  v55 = 0;
  Value = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("kCFNetDiagnosticPingOptionTimeout"));
  if (Value)
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
  v56 = 0;
  v19 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("kCFNetDiagnosticPingOptionTypeOfService"));
  if (v19)
    CFNumberGetValue(v19, kCFNumberIntType, &v56);
  v57 = 0;
  v20 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("kCFNetDiagnosticPingOptionTrafficClass"));
  if (v20)
    CFNumberGetValue(v20, kCFNumberIntType, &v57);
  v55 = 1;
  v21 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("kCFNetDiagnosticPingOptionPacketCount"));
  if (v21)
    CFNumberGetValue(v21, kCFNumberIntType, &v55);
  v58 = 0;
  v22 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("kCFNetDiagnosticPingOptionDataLength"));
  if (v22)
    CFNumberGetValue(v22, kCFNumberIntType, &v58);
  LODWORD(v61.tv_sec) = 51200;
  v23 = getprotobyname("icmp");
  if (!v23)
  {
    v12 = 46;
LABEL_37:
    v11 = 0;
    goto LABEL_7;
  }
  v24 = socket(2, 2, v23->p_proto);
  v25 = v24;
  if (v24 < 0)
  {
    v12 = 1;
    goto LABEL_37;
  }
  setsockopt(v24, 0xFFFF, 4098, &v61, 4u);
  *(_QWORD *)&v64.sa_len = 1;
  *(_DWORD *)&v64.sa_data[6] = 0;
  if (setsockopt(v25, 0xFFFF, 4102, &v64, 0x10u))
  {
    close(v25);
    v12 = *__error();
  }
  else
  {
    v12 = 0;
  }
  v11 = 0;
  if (v12 || v55 < 1)
    goto LABEL_110;
  v26 = 0;
  v11 = 0;
  v51 = *(_DWORD *)__dst;
  v50 = *(_QWORD *)&__dst[4];
  while (1)
  {
    v27 = v57;
    v28 = v58;
    v29 = v56;
    *(_DWORD *)&v64.sa_len = v52;
    *(_DWORD *)&v64.sa_data[2] = v51;
    *(_QWORD *)&v64.sa_data[6] = v50;
    v30 = v58 + 48;
    v31 = (unsigned __int16 *)malloc_type_calloc(1uLL, v30, 0xC9121D6uLL);
    v32 = v31;
    if (!v31)
    {
      v12 = 12;
      break;
    }
    *v31 = 8;
    v31[3] = bswap32(v26) >> 16;
    v31[2] = bswap32(getpid()) >> 16;
    if (!gettimeofday((timeval *)v32 + 2, 0))
    {
      v49 = v28;
      if (v28 >= 1)
      {
        v33 = v32 + 24;
        v34 = v49;
        do
        {
          *v33++ = random();
          --v34;
        }
        while (v34);
      }
      if (!v27)
        goto LABEL_56;
      LODWORD(v61.tv_sec) = v27;
      if (!setsockopt(v25, 0xFFFF, 4230, &v61, 4u))
        goto LABEL_56;
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v35 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)&v65.sa_len = 0;
        _os_log_error_impl(&dword_183ECA000, v35, OS_LOG_TYPE_ERROR, "setsockopt SO_TRAFFIC_CLASS failed", &v65.sa_len, 2u);
        if (!v29)
          goto LABEL_62;
      }
      else
      {
LABEL_56:
        if (!v29)
          goto LABEL_62;
      }
      LODWORD(v61.tv_sec) = v29;
      if (setsockopt(v25, 0, 3, &v61, 4u))
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v36 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)&v65.sa_len = 0;
          _os_log_error_impl(&dword_183ECA000, v36, OS_LOG_TYPE_ERROR, "setsockopt IP_TOS failed", &v65.sa_len, 2u);
        }
      }
LABEL_62:
      if ((int)v30 < 2)
      {
        v37 = 0;
        v41 = v30;
        v39 = v32;
      }
      else
      {
        v37 = 0;
        v38 = v49 + 50;
        v39 = v32;
        do
        {
          v40 = *v39++;
          v37 += v40;
          v38 -= 2;
        }
        while (v38 > 3);
        v41 = v38 - 2;
      }
      if (v41 == 1)
        v37 += *(unsigned __int8 *)v39;
      v32[1] = ~(HIWORD(v37) + v37 + (((v37 >> 16) + (unsigned __int16)v37) >> 16));
      v42 = sendto(v25, v32, v30, 0, &v64, 0x10u);
      if (v42 < 0 || v42 != v30)
      {
        if (*__error())
          v12 = *__error();
        else
          v12 = 1;
      }
      else
      {
        v12 = 0;
      }
      free(v32);
      if (v12)
        break;
      goto LABEL_76;
    }
    if (!*__error())
    {
      v12 = 1;
      break;
    }
    v12 = *__error();
    if (v12)
      break;
LABEL_76:
    v43 = valuePtr;
    if (valuePtr <= 0)
    {
      v12 = 22;
      break;
    }
    v44 = 1;
    while (1)
    {
      v60 = 16;
      v45 = recvfrom(v25, &v64, 0x800uLL, 0, &v65, &v60);
      v46 = v45;
      if ((v45 & 0x8000000000000000) == 0)
        break;
      v12 = *__error();
      if ((v44 & 1) != 0)
        goto LABEL_82;
LABEL_83:
      if (v12 == 35)
        goto LABEL_87;
      if (v12)
        goto LABEL_101;
      v47 = 4 * (v64.sa_len & 0xF);
      if (((v46 - (_DWORD)v47) & 0xFFFFFFF0) < 0x30uLL || (v48 = &v64.sa_len + v47, *v48))
LABEL_87:
        v11 = 0;
      else
        v11 = *((unsigned __int16 *)v48 + 2) == bswap32(getpid()) >> 16;
      if (gettimeofday(&v59, 0))
      {
        if (*__error())
          v12 = *__error();
        else
          v12 = 1;
      }
      else
      {
        v12 = 0;
      }
      if (v12 || v59.tv_sec - v61.tv_sec - (v59.tv_usec < v61.tv_usec) >= v43)
        goto LABEL_102;
      v44 = 0;
      if (v11)
      {
        v12 = 0;
        v11 = 1;
        goto LABEL_102;
      }
    }
    v12 = 0;
    if ((v44 & 1) == 0)
      goto LABEL_83;
LABEL_82:
    if (!gettimeofday(&v61, 0))
      goto LABEL_83;
    if (*__error())
      v12 = *__error();
    else
      v12 = 1;
LABEL_101:
    v11 = 0;
LABEL_102:
    if (!v12 && v55 > (__int16)++v26)
      continue;
    break;
  }
LABEL_110:
  close(v25);
LABEL_7:
  if (a3)
  {
    if (v12)
    {
      CFError = __cfnCreateCFError(0, (CFErrorDomain)*MEMORY[0x1E0C9AFD0], v12, v5, v6, v7, v8, v9, 0);
      goto LABEL_10;
    }
    if (!v11)
    {
      CFError = __cfnCreateCFError(0, (CFErrorDomain)*MEMORY[0x1E0C9AFD0], 60, v5, v6, v7, v8, v9, 0);
LABEL_10:
      *a3 = CFError;
    }
  }
  if (v12)
    v14 = 1;
  else
    v14 = !v11;
  return !v14;
}

BOOL CFNetDiagnosticPing(const __CFString *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  __CFDictionary *Mutable;
  CFNumberRef v7;
  CFNumberRef v8;
  _BOOL8 v9;
  uint64_t v11;
  uint64_t valuePtr;

  v11 = a3;
  valuePtr = a2;
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v7 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
  v8 = CFNumberCreate(0, kCFNumberCFIndexType, &v11);
  CFDictionarySetValue(Mutable, CFSTR("kCFNetDiagnosticPingOptionPacketCount"), v7);
  CFDictionarySetValue(Mutable, CFSTR("kCFNetDiagnosticPingOptionTimeout"), v8);
  v9 = CFNetDiagnosticPingWithOptions(a1, Mutable, a4);
  CFRelease(v7);
  CFRelease(v8);
  CFRelease(Mutable);
  return v9;
}

const __CFString *copyMIMETypeForExtension(CFStringRef inTag)
{
  const __CFString *result;
  const __CFString *v2;
  CFStringRef v3;

  result = UTTypeCreatePreferredIdentifierForTag((CFStringRef)*MEMORY[0x1E0CA5A88], inTag, (CFStringRef)*MEMORY[0x1E0CA5B20]);
  if (result)
  {
    v2 = result;
    v3 = UTTypeCopyPreferredTagWithClass(result, (CFStringRef)*MEMORY[0x1E0CA5A90]);
    CFRelease(v2);
    return v3;
  }
  return result;
}

const __CFString *copyPreferredExtensionForMIMEType(CFStringRef inTag)
{
  const __CFString *result;
  const __CFString *v2;
  CFStringRef v3;

  result = UTTypeCreatePreferredIdentifierForTag((CFStringRef)*MEMORY[0x1E0CA5A90], inTag, (CFStringRef)*MEMORY[0x1E0CA5B20]);
  if (result)
  {
    v2 = result;
    v3 = UTTypeCopyPreferredTagWithClass(result, (CFStringRef)*MEMORY[0x1E0CA5A88]);
    CFRelease(v2);
    return v3;
  }
  return result;
}

CFStringRef createSanitizedFileNameFromString(const __CFString *cf)
{
  const __CFAllocator *v2;
  CFMutableStringRef Mutable;
  __CFString *v4;
  CFIndex Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v8;
  int v9;
  int64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFIndex v13;
  UniChar v14;
  int64_t v15;
  uint64_t v17;
  uint64_t v18;
  int64_t v19;
  CFIndex v20;
  const __CFAllocator *v21;
  CFStringRef Copy;
  UniChar chars;
  UniChar buffer[64];
  CFStringRef v26;
  const UniChar *v27;
  const char *v28;
  uint64_t v29;
  CFIndex v30;
  int64_t v31;
  int64_t v32;
  CFRange v33;

  if (!createSanitizedFileNameFromString::charsToReplaceWithADash)
    createSanitizedFileNameFromString::charsToReplaceWithADash = (uint64_t)CFCharacterSetCreateWithCharactersInString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR(":/"));
  v2 = CFGetAllocator(cf);
  Mutable = CFStringCreateMutable(v2, 0);
  if (!Mutable)
    return 0;
  v4 = Mutable;
  chars = 0;
  Length = CFStringGetLength(cf);
  v26 = cf;
  v29 = 0;
  v30 = Length;
  CharactersPtr = CFStringGetCharactersPtr(cf);
  CStringPtr = 0;
  v27 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(cf, 0x600u);
  v28 = CStringPtr;
  v31 = 0;
  v32 = 0;
  if (Length >= 1)
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 64;
    do
    {
      if ((unint64_t)v10 >= 4)
        v12 = 4;
      else
        v12 = v10;
      v13 = v30;
      if (v30 <= v10)
      {
        chars = 0;
      }
      else
      {
        if (v27)
        {
          v14 = v27[v10 + v29];
        }
        else if (v28)
        {
          v14 = v28[v29 + v10];
        }
        else
        {
          v15 = v31;
          if (v32 <= v10 || v31 > v10)
          {
            v17 = v12 + v8;
            v18 = v11 - v12;
            v19 = v10 - v12;
            v20 = v19 + 64;
            if (v19 + 64 >= v30)
              v20 = v30;
            v31 = v19;
            v32 = v20;
            if (v30 >= v18)
              v13 = v18;
            v33.length = v13 + v17;
            v33.location = v19 + v29;
            CFStringGetCharacters(v26, v33, buffer);
            v15 = v31;
          }
          v14 = buffer[v10 - v15];
        }
        chars = v14;
        if (v14)
        {
          if (v9 || v14 != 46)
          {
            if (CFCharacterSetIsCharacterMember((CFCharacterSetRef)createSanitizedFileNameFromString::charsToReplaceWithADash, v14))
            {
              CFStringAppend(v4, CFSTR("_"));
              v9 = 1;
            }
            else
            {
              v9 = 1;
              CFStringAppendCharacters(v4, &chars, 1);
            }
          }
          else
          {
            v9 = 0;
          }
        }
      }
      ++v10;
      --v8;
      ++v11;
    }
    while (Length != v10);
  }
  if (CFStringGetLength(v4))
  {
    v21 = CFGetAllocator(cf);
    Copy = CFStringCreateCopy(v21, v4);
  }
  else
  {
    Copy = 0;
  }
  CFRelease(v4);
  return Copy;
}

CFStringRef createFilenameFromContentDispositionHeader(const __CFString *a1)
{
  const __CFString *v1;
  CFIndex Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  const __CFCharacterSet *Predefined;
  uint64_t v6;
  int64_t v7;
  CFIndex v8;
  uint64_t v9;
  uint64_t i;
  uint64_t v11;
  CFIndex v12;
  UniChar v13;
  CFIndex bufferedRangeStart;
  BOOL v15;
  uint64_t v16;
  CFIndex v17;
  CFIndex v18;
  CFIndex v19;
  CFStringRef v20;
  uint64_t v21;
  UniChar *v22;
  CFIndex v23;
  CFIndex v24;
  CFStringInlineBuffer *directUniCharBuffer;
  CFIndex v26;
  UniChar v27;
  UniChar *v28;
  char v29;
  int64_t v30;
  int64_t v31;
  uint64_t v32;
  CFIndex v33;
  UniChar v34;
  int v35;
  CFIndex v36;
  uint64_t v37;
  CFIndex v38;
  CFIndex v39;
  CFIndex v40;
  unint64_t v41;
  int64_t v42;
  int64_t v43;
  CFIndex v44;
  uint64_t v45;
  CFIndex v46;
  UniChar v47;
  CFIndex v48;
  uint64_t v49;
  CFIndex v50;
  int64_t v51;
  CFIndex v52;
  CFIndex v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  CFIndex v57;
  CFIndex location;
  CFIndex v59;
  UniChar v60;
  _BOOL4 v61;
  CFIndex v62;
  CFStringInlineBuffer *p_buffer;
  CFIndex v64;
  UniChar v65;
  CFIndex v66;
  CFIndex v67;
  const __CFString *v68;
  _BOOL4 v69;
  int64_t v70;
  CFIndex v71;
  UniChar v72;
  unint64_t v73;
  uint64_t v74;
  int64_t v75;
  int64_t v76;
  UniChar *v77;
  CFIndex v78;
  uint64_t v79;
  CFIndex v80;
  UniChar v81;
  CFIndex v82;
  uint64_t v83;
  CFIndex v84;
  CFIndex v85;
  uint64_t v86;
  uint64_t v87;
  CFIndex v88;
  unint64_t v89;
  uint64_t v90;
  CFIndex v91;
  uint64_t v92;
  uint64_t v93;
  CFIndex v94;
  UniChar v95;
  CFIndex v96;
  uint64_t v97;
  CFIndex v98;
  CFIndex v99;
  CFIndex v100;
  CFIndex v101;
  uint64_t v102;
  const __CFAllocator *v103;
  CFIndex v104;
  CFIndex v105;
  CFIndex v106;
  CFIndex v107;
  CFIndex v108;
  unint64_t v109;
  CFIndex v110;
  uint64_t v111;
  uint64_t v112;
  CFIndex v113;
  CFIndex v114;
  uint64_t v115;
  CFIndex v116;
  UniChar v117;
  CFIndex v118;
  uint64_t v119;
  CFIndex v120;
  int64_t v121;
  CFIndex v122;
  CFIndex v123;
  int v124;
  uint64_t v125;
  CFIndex v126;
  CFIndex v127;
  unint64_t v128;
  uint64_t v129;
  int IsCharacterMember;
  uint64_t v131;
  unint64_t v132;
  CFIndex v133;
  CFStringInlineBuffer *v134;
  CFIndex v135;
  UniChar v136;
  const __CFString *v137;
  CFIndex v138;
  UniChar *v139;
  CFIndex v140;
  uint64_t v141;
  const __CFString *v142;
  CFIndex j;
  CFIndex v144;
  CFStringInlineBuffer *v145;
  CFIndex v146;
  UniChar v147;
  CFIndex v148;
  CFIndex v149;
  CFIndex v150;
  CFIndex v151;
  CFIndex v152;
  UniChar *v153;
  const __CFCharacterSet *v154;
  CFIndex v155;
  CFStringInlineBuffer *v156;
  CFIndex v157;
  UniChar v158;
  int v159;
  CFIndex v160;
  CFIndex v161;
  unint64_t v162;
  CFIndex v163;
  CFIndex v164;
  uint64_t v165;
  CFIndex v166;
  UniChar v167;
  CFIndex v168;
  CFIndex v169;
  uint64_t v170;
  CFIndex v171;
  int64_t v172;
  CFIndex v173;
  CFIndex v174;
  CFIndex v175;
  CFIndex v176;
  int v177;
  int64_t v178;
  uint64_t v179;
  CFIndex v180;
  CFIndex v181;
  CFIndex v182;
  uint64_t v183;
  int64_t v184;
  CFIndex v185;
  CFIndex v186;
  const __CFAllocator *v187;
  __CFString *v188;
  __CFString *v189;
  CFMutableStringRef v190;
  unsigned __int16 CharacterFromInlineBuffer;
  CFIndex v192;
  unint64_t v193;
  int64_t v194;
  int64_t v195;
  CFIndex v196;
  uint64_t v197;
  CFIndex v198;
  UniChar v199;
  CFIndex v200;
  uint64_t v201;
  CFIndex v202;
  CFIndex v203;
  CFIndex v204;
  CFIndex v205;
  uint64_t v206;
  const __CFAllocator *v207;
  CFStringRef v208;
  const __CFString *v209;
  const __CFAllocator *v210;
  CFStringEncoding v211;
  CFStringRef SanitizedFileNameFromString;
  uint64_t v214;
  CFIndex range;
  CFIndex rangea;
  int range_12;
  CFCharacterSetRef v218;
  const __CFCharacterSet *v219;
  const __CFCharacterSet *v220;
  UniChar *v221;
  UniChar *v222;
  UniChar *v223;
  UniChar *v224;
  CFIndex v225;
  uint64_t v226;
  CFIndex v227;
  const __CFString *v228;
  CFStringRef v229;
  CFCharacterSetRef theSet;
  const __CFCharacterSet *theSeta;
  CFIndex v232;
  CFIndex v233;
  CFRange result;
  CFStringInlineBuffer buffer;
  CFRange v236;
  CFRange v237;
  CFRange v238;
  CFRange v239;
  CFRange v240;
  CFRange v241;
  CFRange v242;
  CFRange v243;
  CFRange v244;
  CFRange v245;
  CFRange v246;
  CFRange v247;
  CFRange v248;
  CFRange v249;
  CFRange v250;
  CFRange v251;
  CFRange v252;
  CFRange v253;
  CFRange v254;
  CFRange v255;
  CFRange v256;
  CFRange v257;
  CFRange v258;

  v1 = a1;
  Length = CFStringGetLength(a1);
  buffer.theString = v1;
  buffer.rangeToBuffer.location = 0;
  buffer.rangeToBuffer.length = Length;
  CharactersPtr = CFStringGetCharactersPtr(v1);
  CStringPtr = 0;
  buffer.directUniCharBuffer = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(v1, 0x600u);
  buffer.bufferedRangeStart = 0;
  buffer.bufferedRangeEnd = 0;
  buffer.directCStringBuffer = CStringPtr;
  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  v6 = 0;
  v7 = 0;
  v8 = Length - 1;
  if (Length <= 1)
    v9 = 1;
  else
    v9 = Length;
  for (i = 64; ; ++i)
  {
    v11 = (unint64_t)v7 >= 4 ? 4 : v7;
    v12 = buffer.rangeToBuffer.length;
    if (buffer.rangeToBuffer.length <= v7)
    {
      v13 = 0;
    }
    else if (buffer.directUniCharBuffer)
    {
      v13 = buffer.directUniCharBuffer[v7 + buffer.rangeToBuffer.location];
    }
    else if (buffer.directCStringBuffer)
    {
      v13 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
    }
    else
    {
      bufferedRangeStart = buffer.bufferedRangeStart;
      v15 = buffer.bufferedRangeEnd > v7 && buffer.bufferedRangeStart <= v7;
      if (!v15)
      {
        v16 = v11 + v6;
        v17 = i - v11;
        v18 = v7 - v11;
        v19 = v18 + 64;
        if (v18 + 64 >= buffer.rangeToBuffer.length)
          v19 = buffer.rangeToBuffer.length;
        buffer.bufferedRangeStart = v18;
        buffer.bufferedRangeEnd = v19;
        if (buffer.rangeToBuffer.length >= v17)
          v12 = v17;
        v237.length = v12 + v16;
        v237.location = v18 + buffer.rangeToBuffer.location;
        CFStringGetCharacters(buffer.theString, v237, buffer.buffer);
        bufferedRangeStart = buffer.bufferedRangeStart;
      }
      v13 = buffer.buffer[v7 - bufferedRangeStart];
    }
    if (!CFCharacterSetIsCharacterMember(Predefined, v13))
      break;
    ++v7;
    --v6;
    if (v9 == v7)
      return 0;
  }
  if (Length - v7 < 9)
    return 0;
  v20 = 0;
  v21 = 0x1EDCFEAB8;
  v22 = &buffer.buffer[1];
  v23 = 1 - Length;
LABEL_31:
  v253.location = v7;
  v253.length = 8;
  if (!CFStringFindWithOptions(v1, CFSTR("filename"), v253, 9uLL, &result))
    goto LABEL_236;
  v7 = result.length + result.location;
  if (result.length + result.location >= Length)
    goto LABEL_413;
  if (v7 < 0)
    goto LABEL_43;
  v24 = buffer.rangeToBuffer.length;
  if (buffer.rangeToBuffer.length <= v7)
    goto LABEL_43;
  directUniCharBuffer = (CFStringInlineBuffer *)buffer.directUniCharBuffer;
  if (buffer.directUniCharBuffer)
  {
    v26 = buffer.rangeToBuffer.location + v7;
LABEL_37:
    v27 = directUniCharBuffer->buffer[v26];
    goto LABEL_40;
  }
  if (!buffer.directCStringBuffer)
  {
    if (buffer.bufferedRangeEnd <= v7 || (v66 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
    {
      v67 = v7 - 4;
      if ((unint64_t)v7 < 4)
        v67 = 0;
      if (v67 + 64 < buffer.rangeToBuffer.length)
        v24 = v67 + 64;
      buffer.bufferedRangeStart = v67;
      buffer.bufferedRangeEnd = v24;
      v240.location = buffer.rangeToBuffer.location + v67;
      v240.length = v24 - v67;
      CFStringGetCharacters(buffer.theString, v240, buffer.buffer);
      v66 = buffer.bufferedRangeStart;
    }
    v26 = v7 - v66;
    directUniCharBuffer = &buffer;
    goto LABEL_37;
  }
  v27 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
LABEL_40:
  if (v27 != 42)
  {
LABEL_43:
    if (v20)
      goto LABEL_236;
    theSet = 0;
    v232 = v23;
    v227 = v8;
    v228 = (const __CFString *)v21;
    v28 = v22;
    v29 = 0;
    goto LABEL_45;
  }
  if (++v7 >= Length)
    goto LABEL_413;
  theSet = (CFCharacterSetRef)v20;
  v232 = v23;
  v227 = v8;
  v228 = (const __CFString *)v21;
  v28 = v22;
  v29 = 1;
LABEL_45:
  v30 = -v7;
  v31 = v7 + 64;
  do
  {
    if ((unint64_t)v7 >= 4)
      v32 = 4;
    else
      v32 = v7;
    if (v7 < 0 || (v33 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length <= v7))
    {
      v34 = 0;
    }
    else if (buffer.directUniCharBuffer)
    {
      v34 = buffer.directUniCharBuffer[v7 + buffer.rangeToBuffer.location];
    }
    else if (buffer.directCStringBuffer)
    {
      v34 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
    }
    else
    {
      if (buffer.bufferedRangeEnd <= v7 || (v36 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
      {
        v37 = v32 + v30;
        v38 = v31 - v32;
        v39 = v7 - v32;
        v40 = v39 + 64;
        if (v39 + 64 >= buffer.rangeToBuffer.length)
          v40 = buffer.rangeToBuffer.length;
        buffer.bufferedRangeStart = v39;
        buffer.bufferedRangeEnd = v40;
        if (buffer.rangeToBuffer.length >= v38)
          v33 = v38;
        v238.length = v33 + v37;
        v238.location = v39 + buffer.rangeToBuffer.location;
        CFStringGetCharacters(buffer.theString, v238, buffer.buffer);
        v36 = buffer.bufferedRangeStart;
      }
      v34 = buffer.buffer[v7 - v36];
    }
    v35 = v34;
    if (!CFCharacterSetIsCharacterMember(Predefined, v34))
      break;
    ++v7;
    --v30;
    ++v31;
  }
  while (v7 < Length);
  if (v35 != 61)
  {
    v22 = v28;
    v8 = v227;
    v21 = (uint64_t)v228;
LABEL_92:
    v20 = (CFStringRef)theSet;
    v23 = v232;
    goto LABEL_236;
  }
  v41 = v7 + 1;
  if (v7 + 1 >= Length)
  {
LABEL_417:
    v20 = (CFStringRef)theSet;
    goto LABEL_413;
  }
  v22 = v28;
  v42 = ~v7;
  v43 = v7 + 65;
  v8 = v227;
  while (1)
  {
    v44 = v7 + 1;
    v45 = v41 >= 4 ? 4 : v41;
    if (v44 < 0 || (v46 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length <= v44))
    {
      v47 = 0;
    }
    else if (buffer.directUniCharBuffer)
    {
      v47 = buffer.directUniCharBuffer[v7 + 1 + buffer.rangeToBuffer.location];
    }
    else if (buffer.directCStringBuffer)
    {
      v47 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + 1 + v7];
    }
    else
    {
      if (buffer.bufferedRangeEnd <= v44 || (v48 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v44))
      {
        v49 = v45 + v42;
        v50 = v43 - v45;
        v51 = v7 - v45;
        v52 = v51 + 1;
        v53 = v51 + 65;
        if (v53 >= buffer.rangeToBuffer.length)
          v53 = buffer.rangeToBuffer.length;
        buffer.bufferedRangeStart = v52;
        buffer.bufferedRangeEnd = v53;
        if (buffer.rangeToBuffer.length >= v50)
          v46 = v50;
        v239.length = v46 + v49;
        v239.location = v52 + buffer.rangeToBuffer.location;
        CFStringGetCharacters(buffer.theString, v239, buffer.buffer);
        v48 = buffer.bufferedRangeStart;
      }
      v47 = v22[v7 - v48];
    }
    if (!CFCharacterSetIsCharacterMember(Predefined, v47))
      break;
    ++v41;
    ++v7;
    --v42;
    ++v43;
    if (v227 == v7)
    {
      v7 = Length;
      goto LABEL_94;
    }
  }
  ++v7;
LABEL_94:
  v54 = 0x1EDCFF068;
  v20 = (CFStringRef)theSet;
  v23 = v232;
  if ((v29 & 1) == 0)
  {
    if (theSet)
    {
      v61 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT);
      v54 = 0x1EDCFF068;
      if (v61)
      {
        LOWORD(v236.location) = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "filename should be NULL", (uint8_t *)&v236, 2u);
        v54 = 0x1EDCFF068;
      }
    }
    if (Length <= v7)
      goto LABEL_413;
    v21 = (uint64_t)v228;
    if ((v7 & 0x8000000000000000) == 0)
    {
      v62 = buffer.rangeToBuffer.length;
      if (buffer.rangeToBuffer.length > v7)
      {
        p_buffer = (CFStringInlineBuffer *)buffer.directUniCharBuffer;
        if (buffer.directUniCharBuffer)
        {
          v64 = buffer.rangeToBuffer.location + v7;
          goto LABEL_114;
        }
        if (buffer.directCStringBuffer)
        {
          v65 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
        }
        else
        {
          if (buffer.bufferedRangeEnd <= v7 || (v104 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
          {
            v105 = v7 - 4;
            if ((unint64_t)v7 < 4)
              v105 = 0;
            if (v105 + 64 < buffer.rangeToBuffer.length)
              v62 = v105 + 64;
            buffer.bufferedRangeStart = v105;
            buffer.bufferedRangeEnd = v62;
            v243.location = buffer.rangeToBuffer.location + v105;
            v243.length = v62 - v105;
            CFStringGetCharacters(buffer.theString, v243, buffer.buffer);
            v54 = 0x1EDCFF068;
            v21 = (uint64_t)v228;
            v104 = buffer.bufferedRangeStart;
          }
          v64 = v7 - v104;
          p_buffer = &buffer;
LABEL_114:
          v65 = p_buffer->buffer[v64];
        }
        if (v65 == 59 || v65 == 44)
          goto LABEL_236;
        if (v65 == 34)
        {
          v222 = v22;
          v70 = v7 + 1;
          if (v7 + 1 >= Length)
            goto LABEL_413;
          v71 = buffer.rangeToBuffer.length;
          if (buffer.rangeToBuffer.length <= v70)
          {
            v72 = 0;
          }
          else
          {
            if (buffer.directUniCharBuffer)
            {
              v72 = buffer.directUniCharBuffer[buffer.rangeToBuffer.location + v70];
            }
            else if (buffer.directCStringBuffer)
            {
              v72 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v70];
            }
            else
            {
              if (buffer.bufferedRangeEnd <= v70 || (v175 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v70))
              {
                v176 = v7 - 3;
                if ((unint64_t)v70 < 4)
                  v176 = 0;
                if (v176 + 64 < buffer.rangeToBuffer.length)
                  v71 = v176 + 64;
                buffer.bufferedRangeStart = v176;
                buffer.bufferedRangeEnd = v71;
                v250.location = buffer.rangeToBuffer.location + v176;
                v250.length = v71 - v176;
                CFStringGetCharacters(buffer.theString, v250, buffer.buffer);
                v70 = v7 + 1;
                v175 = buffer.bufferedRangeStart;
              }
              v72 = buffer.buffer[v70 - v175];
              v54 = 0x1EDCFF068;
              v21 = (uint64_t)v228;
            }
            if (v72 == 34)
            {
              v87 = v7 + 2;
              goto LABEL_366;
            }
          }
          v177 = 0;
          v178 = v70;
          while (1)
          {
            if (v72 == 92)
            {
              v177 = 1;
              v179 = 2;
            }
            else
            {
              if (v72 == 34)
              {
                v185 = v178 - v70;
                v186 = v70;
                v187 = CFGetAllocator(v1);
                v257.location = v186;
                v257.length = v185;
                v188 = (__CFString *)CFStringCreateWithSubstring(v187, v1, v257);
                v189 = v188;
                if (v177 && v188 && (v190 = cdReplaceQuotedPairs(v188)) != 0)
                {
                  v20 = v190;
                  CFRelease(v189);
                }
                else
                {
                  v20 = v189;
                }
                v87 = v178 + 1;
LABEL_366:
                v22 = v222;
LABEL_188:
                v7 = v87;
                if (v87 >= Length)
                  goto LABEL_413;
                goto LABEL_236;
              }
              v179 = 1;
            }
            v178 += v179;
            if (v178 >= Length)
              goto LABEL_413;
            v72 = 0;
            if ((v178 & 0x8000000000000000) == 0)
            {
              v72 = 0;
              v180 = buffer.rangeToBuffer.length;
              if (buffer.rangeToBuffer.length > v178)
              {
                if (buffer.directUniCharBuffer)
                {
                  v72 = buffer.directUniCharBuffer[buffer.rangeToBuffer.location + v178];
                }
                else if (buffer.directCStringBuffer)
                {
                  v72 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v178];
                }
                else
                {
                  if (buffer.bufferedRangeEnd <= v178
                    || (v181 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v178))
                  {
                    v182 = v178 - 4;
                    if ((unint64_t)v178 < 4)
                      v182 = 0;
                    if (v182 + 64 < buffer.rangeToBuffer.length)
                      v180 = v182 + 64;
                    buffer.bufferedRangeStart = v182;
                    buffer.bufferedRangeEnd = v180;
                    v183 = v54;
                    v251.location = buffer.rangeToBuffer.location + v182;
                    v184 = v70;
                    v251.length = v180 - v182;
                    CFStringGetCharacters(buffer.theString, v251, buffer.buffer);
                    v70 = v184;
                    v54 = v183;
                    v21 = (uint64_t)v228;
                    v181 = buffer.bufferedRangeStart;
                  }
                  v72 = buffer.buffer[v178 - v181];
                }
              }
            }
          }
        }
      }
    }
    v223 = v22;
    v73 = v7 + 1;
    if (v7 + 1 >= Length)
      goto LABEL_413;
    v229 = (CFStringRef)v21;
    v74 = 0;
    v75 = ~v7;
    v76 = v7 + 65;
    v77 = &v223[v7];
    while (1)
    {
      v78 = v7 + v74 + 1;
      if (v73 >= 4)
        v79 = 4;
      else
        v79 = v73;
      if ((v78 & 0x8000000000000000) == 0)
      {
        v80 = buffer.rangeToBuffer.length;
        if (buffer.rangeToBuffer.length > v78)
        {
          if (buffer.directUniCharBuffer)
          {
            v81 = buffer.directUniCharBuffer[v7 + 1 + v74 + buffer.rangeToBuffer.location];
          }
          else if (buffer.directCStringBuffer)
          {
            v81 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + 1 + v7 + v74];
          }
          else
          {
            if (buffer.bufferedRangeEnd <= v78 || (v82 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v78))
            {
              v83 = v79 + v75;
              v84 = v76 - v79;
              v224 = v77;
              v85 = v7 + v74 + 1 - v79;
              v86 = v7 + v74 + 65 - v79;
              if (v86 >= buffer.rangeToBuffer.length)
                v86 = buffer.rangeToBuffer.length;
              buffer.bufferedRangeStart = v85;
              buffer.bufferedRangeEnd = v86;
              if (buffer.rangeToBuffer.length >= v84)
                v80 = v84;
              v241.length = v80 + v83;
              v241.location = v85 + buffer.rangeToBuffer.location;
              CFStringGetCharacters(buffer.theString, v241, buffer.buffer);
              v77 = v224;
              v82 = buffer.bufferedRangeStart;
            }
            v81 = v77[v74 - v82];
          }
          if (v81 > 0x3Au)
          {
            if (v81 == 59)
              goto LABEL_160;
            if (v81 == 92)
            {
LABEL_184:
              v7 += v74 + 1;
              v21 = (uint64_t)v229;
              v22 = v223;
              goto LABEL_92;
            }
          }
          else
          {
            if (v81 == 34)
              goto LABEL_184;
            if (v81 == 44)
            {
LABEL_160:
              v87 = v7 + v74 + 1;
LABEL_161:
              v88 = v87 - v7;
              theSeta = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
              if (v87 - v7 >= 2)
              {
                v89 = v87 - 1;
                v90 = 1 - v87;
                v91 = v87;
                v92 = v87 + 63;
                v218 = (CFCharacterSetRef)v91;
                while (1)
                {
                  v93 = v89 >= 4 ? 4 : v89;
                  if (v91 >= 1 && (v94 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length >= v91))
                  {
                    if (buffer.directUniCharBuffer)
                    {
                      v95 = buffer.directUniCharBuffer[v91 - 1 + buffer.rangeToBuffer.location];
                    }
                    else if (buffer.directCStringBuffer)
                    {
                      v95 = buffer.directCStringBuffer[buffer.rangeToBuffer.location - 1 + v91];
                    }
                    else
                    {
                      if (buffer.bufferedRangeEnd < v91
                        || (v96 = buffer.bufferedRangeStart, buffer.bufferedRangeStart >= v91))
                      {
                        v97 = v93 + v90;
                        v98 = v92 - v93;
                        v99 = v91 - v93;
                        v100 = v99 - 1;
                        v101 = v99 + 63;
                        if (v101 >= buffer.rangeToBuffer.length)
                          v101 = buffer.rangeToBuffer.length;
                        buffer.bufferedRangeStart = v100;
                        buffer.bufferedRangeEnd = v101;
                        if (buffer.rangeToBuffer.length >= v98)
                          v94 = v98;
                        v242.length = v94 + v97;
                        v242.location = v100 + buffer.rangeToBuffer.location;
                        CFStringGetCharacters(buffer.theString, v242, buffer.buffer);
                        v96 = buffer.bufferedRangeStart;
                      }
                      v95 = *((_WORD *)&result.length + v91 - v96 + 3);
                    }
                  }
                  else
                  {
                    v95 = 0;
                  }
                  if (!CFCharacterSetIsCharacterMember(theSeta, v95))
                    break;
                  v102 = v91 - v7;
                  --v89;
                  ++v90;
                  --v92;
                  --v91;
                  if (v102 <= 2)
                  {
                    v88 = 1;
                    goto LABEL_186;
                  }
                }
                v88 = v91 - v7;
LABEL_186:
                v87 = (uint64_t)v218;
              }
              v103 = CFGetAllocator(v1);
              v256.location = v7;
              v256.length = v88;
              v20 = CFStringCreateWithSubstring(v103, v1, v256);
              v21 = (uint64_t)v229;
              v22 = v223;
              v23 = v232;
              goto LABEL_188;
            }
          }
        }
      }
      ++v73;
      ++v74;
      --v75;
      ++v76;
      if (!(v232 + v7 + v74))
      {
        v87 = Length;
        goto LABEL_161;
      }
    }
  }
  v55 = Length - v7;
  if (Length <= v7 || v55 < 8)
    goto LABEL_413;
  v236.location = 0;
  v236.length = 0;
  v254.location = v7;
  v254.length = 5;
  v56 = CFStringFindWithOptions(v1, (CFStringRef)&unk_1EDCFF068, v254, 9uLL, &v236);
  if (!v56 && (unint64_t)v55 >= 0xD)
  {
    v255.location = v7;
    v255.length = 10;
    CFStringFindWithOptions(v1, v228, v255, 9uLL, &v236);
  }
  v57 = v236.length;
  if (!v236.length)
  {
    v68 = 0;
    v69 = (unint64_t)v55 > 0xA;
    goto LABEL_234;
  }
  range_12 = v56;
  v221 = v22;
  location = v236.location;
  v7 = v236.location + v236.length;
  if (v236.location + v236.length >= Length)
    goto LABEL_417;
  if (v7 < 0)
    goto LABEL_233;
  v59 = buffer.rangeToBuffer.length;
  if (buffer.rangeToBuffer.length <= v7)
    goto LABEL_233;
  if (buffer.directUniCharBuffer)
  {
    v60 = buffer.directUniCharBuffer[buffer.rangeToBuffer.location + v7];
  }
  else if (buffer.directCStringBuffer)
  {
    v60 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
  }
  else
  {
    if (buffer.bufferedRangeEnd <= v7 || (v106 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
    {
      v107 = v7 - 4;
      if ((unint64_t)v7 < 4)
        v107 = 0;
      if (v107 + 64 < buffer.rangeToBuffer.length)
        v59 = v107 + 64;
      buffer.bufferedRangeStart = v107;
      buffer.bufferedRangeEnd = v59;
      v244.location = buffer.rangeToBuffer.location + v107;
      v244.length = v59 - v107;
      CFStringGetCharacters(buffer.theString, v244, buffer.buffer);
      v106 = buffer.bufferedRangeStart;
    }
    v60 = buffer.buffer[v7 - v106];
  }
  v8 = v227;
  if (v60 != 39)
  {
LABEL_233:
    v68 = 0;
    v69 = 1;
    v22 = v221;
    goto LABEL_234;
  }
  v219 = CFCharacterSetGetPredefined(kCFCharacterSetLetter);
  v108 = v57 + location;
  v109 = v57 + location + 1;
  v110 = ~(v57 + location);
  v111 = v57 + location + 65;
  v112 = -2 - (v57 + location);
  v113 = v108 + 66;
  while (1)
  {
    v114 = v7 + 1;
    if (v109 >= 4)
      v115 = 4;
    else
      v115 = v109;
    if (v114 >= Length)
      goto LABEL_417;
    v225 = v113;
    if (v7 >= -1)
    {
      v116 = buffer.rangeToBuffer.length;
      if (buffer.rangeToBuffer.length > v114)
        break;
    }
    v117 = 0;
LABEL_231:
    v124 = v117;
    v125 = v112;
    v126 = v110;
    v127 = v8;
    v128 = v109;
    v129 = v111;
    IsCharacterMember = CFCharacterSetIsCharacterMember(v219, v117);
    v131 = v129;
    v132 = v128;
    v8 = v127;
    v109 = v132 + 1;
    v110 = v126 - 1;
    v111 = v131 + 1;
    ++v7;
    v112 = v125 - 1;
    v113 = v225 + 1;
    if (v124 != 45 && !IsCharacterMember)
      goto LABEL_233;
  }
  if (buffer.directUniCharBuffer)
  {
    v117 = buffer.directUniCharBuffer[v7 + 1 + buffer.rangeToBuffer.location];
  }
  else if (buffer.directCStringBuffer)
  {
    v117 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + 1 + v7];
  }
  else
  {
    if (buffer.bufferedRangeEnd <= v114 || (v118 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v114))
    {
      v119 = v115 + v110;
      v120 = v111 - v115;
      v121 = v7 - v115;
      v214 = v111;
      range = v110;
      v122 = v121 + 1;
      v123 = v121 + 65;
      if (v123 >= buffer.rangeToBuffer.length)
        v123 = buffer.rangeToBuffer.length;
      buffer.bufferedRangeStart = v122;
      buffer.bufferedRangeEnd = v123;
      if (buffer.rangeToBuffer.length >= v120)
        v116 = v120;
      v245.length = v116 + v119;
      v245.location = v122 + buffer.rangeToBuffer.location;
      CFStringGetCharacters(buffer.theString, v245, buffer.buffer);
      v111 = v214;
      v110 = range;
      v118 = buffer.bufferedRangeStart;
    }
    v117 = v221[v7 - v118];
  }
  if (v117 != 39)
    goto LABEL_231;
  v162 = v7 + 2;
  if (v7 + 2 >= Length)
    goto LABEL_417;
  v163 = v225;
  v220 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  while (1)
  {
    v164 = v7 + 2;
    v165 = v162 >= 4 ? 4 : v162;
    if (v164 < 0 || (v166 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length <= v164))
    {
      v167 = 0;
    }
    else if (buffer.directUniCharBuffer)
    {
      v167 = buffer.directUniCharBuffer[v7 + 2 + buffer.rangeToBuffer.location];
    }
    else if (buffer.directCStringBuffer)
    {
      v167 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + 2 + v7];
    }
    else
    {
      if (buffer.bufferedRangeEnd <= v164 || (v169 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v164))
      {
        v170 = v165 + v112;
        v171 = v163 - v165;
        v172 = v7 - v165;
        v173 = v172 + 2;
        v174 = v172 + 66;
        if (v174 >= buffer.rangeToBuffer.length)
          v174 = buffer.rangeToBuffer.length;
        buffer.bufferedRangeStart = v173;
        buffer.bufferedRangeEnd = v174;
        if (buffer.rangeToBuffer.length >= v171)
          v166 = v171;
        v249.length = v166 + v170;
        v249.location = v173 + buffer.rangeToBuffer.location;
        CFStringGetCharacters(buffer.theString, v249, buffer.buffer);
        v169 = buffer.bufferedRangeStart;
      }
      v167 = buffer.buffer[v7 + 2 - v169];
    }
    if (!CFCharacterSetIsCharacterMember(v220, v167))
      break;
    ++v162;
    v168 = v7 + 3;
    ++v7;
    --v112;
    ++v163;
    if (v168 >= Length)
      goto LABEL_417;
  }
  rangea = v7 + 2;
  v226 = v112;
  v68 = 0;
  v69 = 1;
  if (v167 == 44 || v167 == 59)
  {
    v7 += 2;
    goto LABEL_411;
  }
  v7 += 2;
  CharacterFromInlineBuffer = v167;
  while (2)
  {
    if (CharacterFromInlineBuffer > 0x3Au)
    {
      if (CharacterFromInlineBuffer == 59)
        goto LABEL_379;
      if (CharacterFromInlineBuffer == 92)
      {
LABEL_402:
        v68 = 0;
        v69 = 1;
        goto LABEL_411;
      }
LABEL_377:
      if (++v7 >= Length)
        goto LABEL_379;
      CharacterFromInlineBuffer = CFStringGetCharacterFromInlineBuffer(&buffer, v7);
      continue;
    }
    break;
  }
  if (CharacterFromInlineBuffer == 34)
    goto LABEL_402;
  if (CharacterFromInlineBuffer != 44)
    goto LABEL_377;
LABEL_379:
  v192 = v7 - rangea;
  if (v7 - rangea >= 2)
  {
    v193 = v7 - 1;
    v194 = 1 - v7;
    v195 = v7 + 63;
    v196 = v7;
    while (1)
    {
      v197 = v193 >= 4 ? 4 : v193;
      if (v196 >= 1 && (v198 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length >= v196))
      {
        if (buffer.directUniCharBuffer)
        {
          v199 = buffer.directUniCharBuffer[v196 - 1 + buffer.rangeToBuffer.location];
        }
        else if (buffer.directCStringBuffer)
        {
          v199 = buffer.directCStringBuffer[buffer.rangeToBuffer.location - 1 + v196];
        }
        else
        {
          if (buffer.bufferedRangeEnd < v196 || (v200 = buffer.bufferedRangeStart, buffer.bufferedRangeStart >= v196))
          {
            v201 = v197 + v194;
            v202 = v195 - v197;
            v203 = v196 - v197;
            v204 = v203 - 1;
            v205 = v203 + 63;
            if (v205 >= buffer.rangeToBuffer.length)
              v205 = buffer.rangeToBuffer.length;
            buffer.bufferedRangeStart = v204;
            buffer.bufferedRangeEnd = v205;
            if (buffer.rangeToBuffer.length >= v202)
              v198 = v202;
            v252.length = v198 + v201;
            v252.location = v204 + buffer.rangeToBuffer.location;
            CFStringGetCharacters(buffer.theString, v252, buffer.buffer);
            v200 = buffer.bufferedRangeStart;
          }
          v199 = *((_WORD *)&result.length + v196 - v200 + 3);
        }
      }
      else
      {
        v199 = 0;
      }
      if (!CFCharacterSetIsCharacterMember(v220, v199))
        break;
      v206 = v226 + v196;
      --v193;
      ++v194;
      --v195;
      --v196;
      if (v206 <= 2)
      {
        v192 = 1;
        goto LABEL_404;
      }
    }
    v192 = v226 + v196;
  }
LABEL_404:
  v207 = CFGetAllocator(v1);
  v258.location = rangea;
  v258.length = v192;
  v208 = CFStringCreateWithSubstring(v207, v1, v258);
  if (v208)
  {
    v209 = v208;
    v210 = CFGetAllocator(v1);
    if (range_12)
      v211 = 134217984;
    else
      v211 = 513;
    v68 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(v210, v209, &stru_1E1500C68, v211);
    CFRelease(v209);
  }
  else
  {
    v68 = 0;
  }
  v69 = v7 < Length;
LABEL_411:
  v22 = v221;
  v8 = v227;
LABEL_234:
  v21 = (uint64_t)v228;
  v20 = (CFStringRef)theSet;
  v23 = v232;
  if (!v69 || v68)
  {
    if (!v68)
      goto LABEL_413;
    if (theSet)
      CFRelease(theSet);
    goto LABEL_414;
  }
LABEL_236:
  while (2)
  {
    if (v7 >= Length)
      goto LABEL_413;
LABEL_237:
    if (v7 < 0 || (v133 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length <= v7))
    {
LABEL_279:
      ++v7;
      continue;
    }
    break;
  }
  v134 = (CFStringInlineBuffer *)buffer.directUniCharBuffer;
  if (buffer.directUniCharBuffer)
  {
    v135 = buffer.rangeToBuffer.location + v7;
    goto LABEL_241;
  }
  if (buffer.directCStringBuffer)
  {
    v136 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
  }
  else
  {
    if (buffer.bufferedRangeEnd <= v7 || (v150 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
    {
      v151 = v7 - 4;
      if ((unint64_t)v7 < 4)
        v151 = 0;
      if (v151 + 64 < buffer.rangeToBuffer.length)
        v133 = v151 + 64;
      buffer.bufferedRangeStart = v151;
      buffer.bufferedRangeEnd = v133;
      v247.location = buffer.rangeToBuffer.location + v151;
      v247.length = v133 - v151;
      CFStringGetCharacters(buffer.theString, v247, buffer.buffer);
      v150 = buffer.bufferedRangeStart;
    }
    v135 = v7 - v150;
    v134 = &buffer;
LABEL_241:
    v136 = v134->buffer[v135];
  }
  if (v136 != 34)
  {
    if (v136 != 44 && v136 != 59)
      goto LABEL_279;
    if (++v7 >= Length)
      goto LABEL_413;
    v233 = v23;
    v152 = v8;
    v153 = v22;
    while (1)
    {
      v154 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
      if (v7 < 0 || (v155 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length <= v7))
      {
        v158 = 0;
      }
      else
      {
        v156 = (CFStringInlineBuffer *)buffer.directUniCharBuffer;
        if (buffer.directUniCharBuffer)
        {
          v157 = buffer.rangeToBuffer.location + v7;
        }
        else
        {
          if (buffer.directCStringBuffer)
          {
            v158 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
            goto LABEL_288;
          }
          if (buffer.bufferedRangeEnd <= v7 || (v160 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
          {
            v161 = v7 - 4;
            if ((unint64_t)v7 < 4)
              v161 = 0;
            if (v161 + 64 < buffer.rangeToBuffer.length)
              v155 = v161 + 64;
            buffer.bufferedRangeStart = v161;
            buffer.bufferedRangeEnd = v155;
            v248.location = buffer.rangeToBuffer.location + v161;
            v248.length = v155 - v161;
            CFStringGetCharacters(buffer.theString, v248, buffer.buffer);
            v160 = buffer.bufferedRangeStart;
          }
          v157 = v7 - v160;
          v156 = &buffer;
        }
        v158 = v156->buffer[v157];
      }
LABEL_288:
      v159 = v158;
      if (!CFCharacterSetIsCharacterMember(v154, v158) && v159 != 59 && v159 != 44)
      {
        v22 = v153;
        v8 = v152;
        v23 = v233;
        if (Length - v7 < 9)
          goto LABEL_413;
        goto LABEL_31;
      }
      if (++v7 >= Length)
        goto LABEL_413;
    }
  }
  v137 = v1;
  v138 = v8;
  v139 = v22;
  v140 = v23;
  v141 = v21;
  v142 = v20;
  for (j = v7 + 1; ; ++j)
  {
    if (j >= Length)
    {
LABEL_412:
      v20 = v142;
      goto LABEL_413;
    }
    if (v7 >= -1)
    {
      v144 = buffer.rangeToBuffer.length;
      if (buffer.rangeToBuffer.length > j)
        break;
    }
LABEL_258:
    v7 = j;
  }
  v145 = (CFStringInlineBuffer *)buffer.directUniCharBuffer;
  if (buffer.directUniCharBuffer)
  {
    v146 = buffer.rangeToBuffer.location + j;
LABEL_251:
    v147 = v145->buffer[v146];
    goto LABEL_254;
  }
  if (!buffer.directCStringBuffer)
  {
    if (buffer.bufferedRangeEnd <= j || (v148 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > j))
    {
      v149 = j - 4;
      if ((unint64_t)j < 4)
        v149 = 0;
      if (v149 + 64 < buffer.rangeToBuffer.length)
        v144 = v149 + 64;
      buffer.bufferedRangeStart = v149;
      buffer.bufferedRangeEnd = v144;
      v246.location = buffer.rangeToBuffer.location + v149;
      v246.length = v144 - v149;
      CFStringGetCharacters(buffer.theString, v246, buffer.buffer);
      v148 = buffer.bufferedRangeStart;
    }
    v146 = j - v148;
    v145 = &buffer;
    goto LABEL_251;
  }
  v147 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + j];
LABEL_254:
  if (v147 == 92)
  {
    if (++j >= Length)
      goto LABEL_412;
    goto LABEL_258;
  }
  if (v147 != 34)
    goto LABEL_258;
  v7 = j + 1;
  v15 = j + 1 < Length;
  v20 = v142;
  v21 = v141;
  v23 = v140;
  v22 = v139;
  v8 = v138;
  v1 = v137;
  if (v15)
    goto LABEL_237;
LABEL_413:
  v68 = v20;
  if (!v20)
    return 0;
LABEL_414:
  SanitizedFileNameFromString = createSanitizedFileNameFromString(v68);
  CFRelease(v68);
  return SanitizedFileNameFromString;
}

CFMutableStringRef cdReplaceQuotedPairs(__CFString *a1)
{
  CFMutableStringRef MutableCopy;
  CFIndex Length;
  CFIndex v3;
  CFIndex v4;
  const __CFAllocator *v5;
  CFIndex i;
  CFRange range;
  CFRange v9;
  CFRange v10;

  MutableCopy = a1;
  Length = CFStringGetLength(a1);
  v3 = Length - 1;
  if (Length > 1)
  {
    v4 = Length;
    v5 = CFGetAllocator(MutableCopy);
    MutableCopy = CFStringCreateMutableCopy(v5, 0, MutableCopy);
    for (i = 0; i < v4; ++i)
    {
      v10.location = i;
      v10.length = v3;
      if (!CFStringFindWithOptions(MutableCopy, CFSTR("\\"), v10, 0, &range))
        break;
      v9.location = range.location;
      v9.length = 1;
      CFStringDelete(MutableCopy, v9);
      --v4;
      v3 -= 2;
    }
  }
  else
  {
    CFRetain(MutableCopy);
  }
  return MutableCopy;
}

uint64_t CFStringGetCharacterFromInlineBuffer(CFStringInlineBuffer *buffer, int64_t a2)
{
  CFIndex length;
  const UniChar *directUniCharBuffer;
  const char *directCStringBuffer;
  CFIndex bufferedRangeStart;
  CFIndex v10;
  CFRange v11;

  if (a2 < 0)
  {
    return 0;
  }
  else
  {
    length = buffer->rangeToBuffer.length;
    if (length <= a2)
    {
      return 0;
    }
    else
    {
      directUniCharBuffer = buffer->directUniCharBuffer;
      if (directUniCharBuffer)
      {
        return directUniCharBuffer[buffer->rangeToBuffer.location + a2];
      }
      else
      {
        directCStringBuffer = buffer->directCStringBuffer;
        if (directCStringBuffer)
        {
          return (unsigned __int16)directCStringBuffer[buffer->rangeToBuffer.location + a2];
        }
        else
        {
          if (buffer->bufferedRangeEnd <= a2
            || (bufferedRangeStart = buffer->bufferedRangeStart, bufferedRangeStart > a2))
          {
            v10 = a2 - 4;
            if ((unint64_t)a2 < 4)
              v10 = 0;
            if (v10 + 64 < length)
              length = v10 + 64;
            buffer->bufferedRangeStart = v10;
            buffer->bufferedRangeEnd = length;
            v11.location = buffer->rangeToBuffer.location + v10;
            v11.length = length - v10;
            CFStringGetCharacters(buffer->theString, v11, buffer->buffer);
            bufferedRangeStart = buffer->bufferedRangeStart;
          }
          return buffer->buffer[a2 - bufferedRangeStart];
        }
      }
    }
  }
}

CFStringRef createExtensionFromFilename(const __CFString *a1)
{
  const __CFString *v1;
  CFIndex Length;
  CFIndex v4;
  CFIndex v5;
  CFIndex v6;
  int CharacterAtIndex;
  CFIndex v8;
  const __CFAllocator *v9;
  uint8_t v10[16];
  CFRange v11;

  v1 = a1;
  Length = CFStringGetLength(a1);
  if (Length >= 2)
  {
    v4 = Length;
    v5 = Length - 1;
    while (v5)
    {
      v6 = v5;
      CharacterAtIndex = CFStringGetCharacterAtIndex(v1, v5);
      if (CharacterAtIndex == 47)
        break;
      v5 = v6 - 1;
      if (CharacterAtIndex == 46)
      {
        v8 = v6 + 1;
        if (v8 != 3)
          goto LABEL_14;
        if (CFStringGetLength(v1) <= 1 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)v10 = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "createExtensionFromFilename(): passed a bogus filename", v10, 2u);
        }
        if (CFStringGetCharacterAtIndex(v1, 1) != 58
          || (CFStringGetCharacterAtIndex(v1, 0) & 0xFFDFu) - 91 < 0xFFFFFFE6)
        {
LABEL_14:
          v9 = CFGetAllocator(v1);
          v11.length = v4 - v8;
          v11.location = v8;
          return CFStringCreateWithSubstring(v9, v1, v11);
        }
        break;
      }
    }
  }
  CFRetain(v1);
  return v1;
}

CFStringRef _CFURLCopyPathExtension_WorksWithMoreSchemes(const __CFURL *a1)
{
  CFStringRef v2;
  const __CFString *v3;
  const __CFString *v4;
  CFIndex Length;
  CFIndex v6;
  const __CFCharacterSet *v7;
  const __CFCharacterSet *v8;
  CFRange v9;
  CFRange v11;
  CFRange result;
  CFRange v13;
  CFRange v14;

  v2 = CFURLCopyPathExtension(a1);
  if (!v2)
  {
    v3 = CFURLCopyPath(a1);
    if (v3)
    {
      v4 = v3;
      Length = CFStringGetLength(v3);
      if (Length < 1)
      {
        v2 = 0;
      }
      else
      {
        v6 = Length;
        v7 = CFCharacterSetCreateWithCharactersInString(0, CFSTR("./;="));
        v13.location = 0;
        v13.length = v6;
        if (CFStringFindCharacterFromSet(v4, v7, v13, 4uLL, &result)
          && CFStringGetCharacterAtIndex(v4, result.location) == 46)
        {
          v8 = CFCharacterSetCreateWithCharactersInString(0, CFSTR(";=?"));
          v14.location = 0;
          v14.length = v6;
          v2 = 0;
          if (!CFStringFindCharacterFromSet(v4, v8, v14, 4uLL, &v11))
          {
            v9.length = v6 + ~result.location;
            if (v9.length < 1)
            {
              v2 = 0;
            }
            else
            {
              v9.location = result.location + 1;
              v2 = CFStringCreateWithSubstring(0, v4, v9);
            }
          }
          CFRelease(v8);
        }
        else
        {
          v2 = 0;
        }
        CFRelease(v7);
      }
      CFRelease(v4);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

char *_CFNetworkIsKnownHSTSHostWithSession(char *a1, os_unfair_lock_s *a2)
{
  id *v3;
  id *v4;
  NSString *v5;
  unsigned __int8 v7;

  v3 = _HSTSPolicyForSession(a2);
  if (v3)
  {
    v4 = v3;
    if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy == -1)
    {
      if (a1)
        goto LABEL_4;
    }
    else
    {
      dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_313);
      if (a1)
      {
LABEL_4:
        v5 = (NSString *)objc_msgSend(a1, "host");
        if (v5)
          a1 = (char *)HSTSPolicy::isKnownHSTSHost((HSTSPolicy *)(v4 + 2), v5, &v7);
        else
          a1 = 0;
      }
    }
    CFRelease(v4);
    return a1;
  }
  return 0;
}

id *_HSTSPolicyForSession(os_unfair_lock_s *a1)
{
  id *result;

  if (a1)
  {
    if (StorageSession::Class(void)::sOnce_StorageSession != -1)
      dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_16297);
    return (id *)StorageSession::copyHSTSStorage(a1 + 4);
  }
  else
  {
    result = (id *)+[NSURLSession _sharedSessionForConnection]();
    if (result)
      return (id *)objc_msgSend(result[14], "copyHSTSPolicy");
  }
  return result;
}

id *_CFNetworkCopyHSTSPolicies(os_unfair_lock_s *a1)
{
  id *result;
  id *v2;
  CFDictionaryRef v3;

  result = _HSTSPolicyForSession(a1);
  if (result)
  {
    v2 = result;
    if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1)
      dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_313);
    v3 = HSTSPolicy::copyExternalRepresentationOfHSTSPolicies((HSTSPolicy *)(v2 + 2));
    CFRelease(v2);
    return (id *)v3;
  }
  return result;
}

void _CFNetworkResetHSTS(const __CFURL *a1, os_unfair_lock_s *a2)
{
  id *v3;
  HSTSCache **v4;
  CFStringRef v5;
  CFStringRef v6;

  v3 = _HSTSPolicyForSession(a2);
  if (v3)
  {
    v4 = (HSTSCache **)v3;
    v5 = CFURLCopyHostName(a1);
    if (v5)
    {
      v6 = v5;
      if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1)
        dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_313);
      HSTSCache::modifyHSTSStore(v4[4], v6, 0, 0);
      CFRelease(v6);
    }
    CFRelease(v4);
  }
}

void _CFNetworkResetHSTSHostsSinceDate(os_unfair_lock_s *a1, const void *a2)
{
  id *v3;
  HSTSCache **v4;

  v3 = _HSTSPolicyForSession(a1);
  if (v3)
  {
    v4 = (HSTSCache **)v3;
    if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1)
      dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_313);
    HSTSCache::modifyHSTSStore(v4[4], 0, 0, a2);
    CFRelease(v4);
  }
}

void _CFNetworkResetHSTSHostsWithSession(os_unfair_lock_s *a1)
{
  _CFNetworkResetHSTSHostsSinceDate(a1, 0);
}

void _CFNetworkResetHSTSHosts()
{
  _CFNetworkResetHSTSHostsSinceDate(0, 0);
}

CFRunLoopSourceRef CFNetworkExecuteProxyAutoConfigurationURL(CFURLRef proxyAutoConfigURL, CFURLRef targetURL, CFProxyAutoConfigurationResultCallback cb, CFStreamClientContext *clientContext)
{
  CFStreamClientContext *v4;

  return PAC::CreatePACTicket(proxyAutoConfigURL, targetURL, 0, 0, (std::__shared_weak_count_vtbl *)cb, (void (*)(void *, const __CFArray *, __CFError *))clientContext, v4);
}

CFRunLoopSourceRef CFNetworkExecuteProxyAutoConfigurationScript(CFStringRef proxyAutoConfigurationScript, CFURLRef targetURL, CFProxyAutoConfigurationResultCallback cb, CFStreamClientContext *clientContext)
{
  CFStreamClientContext *v4;

  return PAC::CreatePACTicket((PAC *)proxyAutoConfigurationScript, targetURL, 0, 0, (std::__shared_weak_count_vtbl *)cb, (void (*)(void *, const __CFArray *, __CFError *))clientContext, v4);
}

CFDictionaryRef _newConnPropsForHTTPSProxy(CFAllocatorRef allocator, __CFHTTPMessage *a2, __CFString *a3, const __CFNumber *a4)
{
  CFDictionaryRef v6;
  HTTPMessage *v8;
  CFIndex v9;
  CFDictionaryRef v10;
  CFDictionaryRef v11;
  void *values;
  CFTypeRef cf;
  CFDictionaryRef v15;
  void *keys;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v6 = a2;
  v19 = *MEMORY[0x1E0C80C00];
  keys = 0;
  v17 = 0;
  v18 = 0;
  values = 0;
  cf = 0;
  v15 = 0;
  if (a2)
  {
    keys = &unk_1EDCFD8C8;
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v8 = (CFDictionaryRef)((char *)v6 + 16);
    values = (void *)HTTPMessage::copyHeaderFieldValue(v8, 0x14C15415u);
    if (!values)
    {
      pthread_once(&initControl, initializeUserAgentString);
      values = (void *)sUserAgentString;
      CFRetain((CFTypeRef)sUserAgentString);
    }
    v17 = 0x1EDCFD3F8;
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    cf = HTTPMessage::copyHeaderFieldValue(v8, 0x1362735Fu);
    if (cf)
      v9 = 2;
    else
      v9 = 1;
    v6 = CFDictionaryCreate(allocator, (const void **)&keys, (const void **)&values, v9, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFRelease(values);
    if (cf)
      CFRelease(cf);
  }
  keys = &unk_1EDD00418;
  v17 = 0x1EDD00450;
  values = a3;
  cf = a4;
  if (v6)
  {
    v18 = 0x1EDD003A8;
    v15 = v6;
    v10 = CFDictionaryCreate(allocator, (const void **)&keys, (const void **)&values, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFRelease(v6);
  }
  else
  {
    v10 = CFDictionaryCreate(allocator, (const void **)&keys, (const void **)&values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  keys = &unk_1EDD003E0;
  values = v10;
  v11 = CFDictionaryCreate(allocator, (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFRelease(v10);
  return v11;
}

CFDictionaryRef newConnPropsForSOCKSProxy(CFAllocatorRef allocator, const __CFString *a2, const __CFNumber *a3, const __CFString *a4, const __CFString *a5, const __CFString *a6)
{
  void *v7;
  void *v8;
  const __CFString *v9;
  uint64_t v10;
  CFIndex v11;
  const CFDictionaryKeyCallBacks *v12;
  const CFDictionaryValueCallBacks *v13;
  CFDictionaryRef v14;
  CFDictionaryRef v15;
  void *values[3];
  const __CFString *v18;
  const __CFString *v19;
  void *keys[3];
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v7 = (void *)*MEMORY[0x1E0C9B2D0];
  keys[0] = *(void **)MEMORY[0x1E0C9B2C8];
  keys[1] = v7;
  values[0] = (void *)a2;
  values[1] = a3;
  v8 = (void *)*MEMORY[0x1E0C9B2E0];
  v9 = (const __CFString *)*MEMORY[0x1E0C9B318];
  if (a6)
    v9 = a6;
  v21 = 0;
  v22 = 0;
  keys[2] = v8;
  v18 = 0;
  v19 = 0;
  values[2] = (void *)v9;
  if (a4)
  {
    v10 = *MEMORY[0x1E0C9B2B8];
    v21 = *MEMORY[0x1E0C9B2D8];
    v22 = v10;
    v18 = a4;
    v19 = a5;
    v11 = 5;
  }
  else
  {
    v11 = 3;
  }
  v12 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v13 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  v14 = CFDictionaryCreate(allocator, (const void **)keys, (const void **)values, v11, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  keys[0] = &unk_1EDCFBF30;
  values[0] = v14;
  v15 = CFDictionaryCreate(allocator, (const void **)keys, (const void **)values, 1, v12, v13);
  CFRelease(v14);
  return v15;
}

unint64_t hasTokenInList(const __CFString *a1, const __CFString *a2)
{
  uint64_t Length;
  CFIndex v5;
  CFIndex v6;
  unint64_t result;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;
  uint64_t v12;
  unsigned int CharacterAtIndex;
  uint64_t v14;
  unsigned int v16;
  CFRange v17;
  CFRange v18;

  Length = CFStringGetLength(a1);
  v5 = CFStringGetLength(a2);
  v17.location = 0;
  v17.length = Length;
  if (Length < 1)
    return 0;
  v6 = v5;
  v18.location = 0;
  v18.length = Length;
  result = CFStringFindWithOptions(a1, a2, v18, 1uLL, &v17);
  if (!(_DWORD)result)
    return result;
  if (!v17.location)
  {
    CharacterAtIndex = CFStringGetCharacterAtIndex(a1, v17.length);
    v11 = CharacterAtIndex > 0x2C;
    v12 = 1 << CharacterAtIndex;
LABEL_7:
    v14 = v12 & 0x100100000200;
    return !v11 && v14 != 0;
  }
  v8 = Length - v17.location;
  v9 = CFStringGetCharacterAtIndex(a1, v17.location - 1);
  v10 = v9;
  if (v6 == v8)
  {
    v11 = v9 > 0x2C;
    v12 = 1 << v9;
    goto LABEL_7;
  }
  result = 0;
  if (v10 <= 0x2C && ((1 << v10) & 0x100100000200) != 0)
  {
    v16 = CFStringGetCharacterAtIndex(a1, v17.length + v17.location);
    if (v16 <= 0x2C)
      return (0x100100000200uLL >> v16) & 1;
    return 0;
  }
  return result;
}

uint64_t convertIPAddress(const __CFString *a1, int a2, void *a3)
{
  CFIndex Length;
  uint64_t result;
  char buffer[57];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  LOBYTE(result) = 0;
  if (Length)
  {
    if (Length <= 56)
    {
      LODWORD(result) = CFStringGetCString(a1, buffer, 57, 0x600u);
      if ((_DWORD)result)
        LOBYTE(result) = inet_pton(a2, buffer, a3);
    }
  }
  return result;
}

uint64_t getBestPortValue(NSURL *a1)
{
  NSNumber *v2;
  NSString *v4;

  v2 = -[NSURL port](a1, "port");
  if (v2)
    return -[NSNumber unsignedShortValue](v2, "unsignedShortValue");
  v4 = -[NSString lowercaseString](-[NSURL scheme](a1, "scheme"), "lowercaseString");
  if (v4 && (v2 = (NSNumber *)objc_msgSend(&unk_1E152A7E0, "objectForKeyedSubscript:", v4)) != 0)
    return -[NSNumber unsignedShortValue](v2, "unsignedShortValue");
  else
    return 0;
}

uint64_t ___Z23createIDNAEncodedDomainPK10__CFString_block_invoke()
{
  uint64_t result;
  int v1;

  v1 = 0;
  result = MEMORY[0x186DB9ACC](60, &v1);
  createIDNAEncodedDomain(__CFString const*)::idna = result;
  if (v1 >= 1)
    abort();
  return result;
}

void sub_184006458(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

NSMutableURLRequest *CFURLRequestCreateMutable(double a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  NSMutableURLRequest *v6;
  NSMutableURLRequest *v7;

  v6 = -[NSURLRequest initWithURL:cachePolicy:timeoutInterval:]([NSMutableURLRequest alloc], "initWithURL:cachePolicy:timeoutInterval:", a3, a4, a1);
  v7 = v6;
  if (a5)
    -[NSMutableURLRequest setMainDocumentURL:](v6, "setMainDocumentURL:", a5);
  return v7;
}

uint64_t CFURLRequestCreateCopy(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "copy");
}

uint64_t CFURLRequestCreateMutableCopy(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "mutableCopy");
}

uint64_t CFURLRequestCreateHTTPRequest(int a1, __CFAllocator *a2, __CFHTTPMessage *a3, int a4, NSURLRequestCachePolicy a5, double a6)
{
  return _constructRequestFromParts(a2, a3, (const __CFArray *)a4, a5, a6, 0);
}

uint64_t CFURLRequestCreateMutableHTTPRequest(int a1, __CFAllocator *a2, __CFHTTPMessage *a3, int a4, NSURLRequestCachePolicy a5, double a6)
{
  return _constructRequestFromParts(a2, a3, (const __CFArray *)a4, a5, a6, (const __CFURL *)1);
}

uint64_t CFURLRequestGetURL(void *a1)
{
  return *(_QWORD *)(objc_msgSend(a1, "_inner") + 8);
}

uint64_t CFURLRequestGetCachePolicy(void *a1)
{
  return *(unsigned int *)(objc_msgSend(a1, "_inner") + 16);
}

double CFURLRequestGetTimeoutInterval(void *a1)
{
  return *(double *)(objc_msgSend(a1, "_inner") + 24);
}

uint64_t CFURLRequestGetSSLProperties(void *a1)
{
  return *(_QWORD *)(objc_msgSend(a1, "_inner") + 72);
}

uint64_t CFURLRequestGetMainDocumentURL(void *a1)
{
  return *(_QWORD *)(objc_msgSend(a1, "_inner") + 32);
}

uint64_t CFURLRequestGetProxySettings(void *a1)
{
  return *(_QWORD *)(objc_msgSend(a1, "_inner") + 48);
}

HTTPMessage *CFURLRequestCopyHTTPRequestBody(void *a1)
{
  HTTPMessage *result;

  result = *(HTTPMessage **)(objc_msgSend(a1, "_inner") + 56);
  if (result)
    return HTTPMessage::copyBody(result);
  return result;
}

HTTPMessage *CFURLRequestCopyHTTPHeaderFieldValue(void *a1, const __CFString *a2)
{
  HTTPMessage *result;

  result = *(HTTPMessage **)(objc_msgSend(a1, "_inner") + 56);
  if (result)
    return (HTTPMessage *)HTTPMessage::copyHeaderFieldValue(result, a2);
  return result;
}

HTTPMessage *CFURLRequestCopyAllHTTPHeaderFields(void *a1)
{
  HTTPMessage *result;

  result = *(HTTPMessage **)(objc_msgSend(a1, "_inner") + 56);
  if (result)
    return HTTPMessage::copyAllHeaderFields(result);
  return result;
}

CFArrayRef CFURLRequestCopyHTTPRequestBodyParts(void *a1)
{
  uint64_t v1;
  const __CFArray *v2;

  v1 = *(_QWORD *)(objc_msgSend(a1, "_inner") + 56);
  if (v1 && (v2 = *(const __CFArray **)(v1 + 208)) != 0)
    return CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v2);
  else
    return 0;
}

uint64_t CFURLRequestShouldHandleHTTPCookies(void *a1)
{
  return *(_WORD *)(objc_msgSend(a1, "_inner") + 64) & 1;
}

CFTypeRef CFURLRequestCopyHTTPCookieStorage(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  NSHTTPCookieStorage *v3;
  OpaqueCFHTTPCookieStorage *v4;

  v1 = *(_QWORD *)(objc_msgSend(a1, "_inner") + 56);
  if (v1 && (v2 = *(_QWORD *)(v1 + 192)) != 0)
  {
    CFRetain(*(CFTypeRef *)(v1 + 192));
  }
  else
  {
    v3 = +[NSHTTPCookieStorage sharedHTTPCookieStorage](NSHTTPCookieStorage, "sharedHTTPCookieStorage");
    if (v3)
    {
      v4 = -[NSHTTPCookieStorage _cookieStorage](v3, "_cookieStorage");
      if (v4)
        return CFRetain(v4);
    }
    return 0;
  }
  return (CFTypeRef)v2;
}

uint64_t CFURLRequestSetCachePolicy(void *a1, int a2)
{
  uint64_t result;

  result = objc_msgSend(a1, "_inner");
  *(_WORD *)(result + 64) |= 0x400u;
  *(_QWORD *)(result + 16) = a2;
  return result;
}

uint64_t CFURLRequestSetTimeoutInterval(void *a1, double a2)
{
  uint64_t result;

  result = objc_msgSend(a1, "_inner");
  *(_WORD *)(result + 64) |= 0x800u;
  *(double *)(result + 24) = a2;
  return result;
}

CFDictionaryRef CFURLRequestSetProxySettings(void *a1, const __CFDictionary *a2)
{
  uint64_t v3;
  CFDictionaryRef result;

  v3 = objc_msgSend(a1, "_inner");
  *(_WORD *)(v3 + 64) |= 0x1000u;
  result = *(CFDictionaryRef *)(v3 + 48);
  if (result != a2)
  {
    if (result)
      CFRelease(result);
    if (a2)
      result = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2);
    else
      result = 0;
    *(_QWORD *)(v3 + 48) = result;
  }
  return result;
}

CFDictionaryRef CFURLRequestSetSSLProperties(void *a1, const __CFDictionary *a2)
{
  uint64_t v3;
  CFDictionaryRef result;

  v3 = objc_msgSend(a1, "_inner");
  *(_WORD *)(v3 + 64) |= 0x2000u;
  result = *(CFDictionaryRef *)(v3 + 72);
  if (result != a2)
  {
    if (result)
      CFRelease(result);
    if (a2)
      result = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2);
    else
      result = 0;
    *(_QWORD *)(v3 + 72) = result;
  }
  return result;
}

void CFURLRequestSetHTTPRequestBodyParts(void *a1, const __CFArray *a2)
{
  URLRequest::_setHTTPBodyParts((URLRequest *)objc_msgSend(a1, "_inner"), a2, 0);
}

uint64_t CFURLRequestSetShouldHandleHTTPCookies(void *a1, int a2)
{
  uint64_t result;
  __int16 v4;
  __int16 v5;
  __int16 v6;

  result = objc_msgSend(a1, "_inner");
  v4 = *(_WORD *)(result + 64);
  v5 = v4 | 0x21;
  v6 = v4 & 0xFFDE | 0x20;
  if (a2)
    v6 = v5;
  *(_WORD *)(result + 64) = v6;
  return result;
}

CFTypeRef CFURLRequestSetHTTPCookieStorage(void *a1, CFTypeRef a2)
{
  uint64_t v3;
  HTTPRequest *fHTTPRequest;
  URLRequest *v5;
  CFTypeRef result;
  void (**v7)(StringSerializable *__hidden);
  CFTypeRef cf;

  v3 = objc_msgSend(a1, "_inner");
  fHTTPRequest = *(HTTPRequest **)(v3 + 56);
  if (!fHTTPRequest)
  {
    v5 = (URLRequest *)v3;
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v7);
    URLRequest::createHTTPRequest(v5, (CFTypeRef *)&v7);
    v7 = &off_1E14E9A00;
    if (cf)
      CFRelease(cf);
    fHTTPRequest = v5->fHTTPRequest;
  }
  result = (CFTypeRef)*((_QWORD *)fHTTPRequest + 24);
  if (result != a2)
  {
    if (result)
      CFRelease(result);
    if (a2)
      result = CFRetain(a2);
    else
      result = 0;
    *((_QWORD *)fHTTPRequest + 24) = result;
  }
  return result;
}

void sub_1840069CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void CFURLRequestSetHTTPCookieStorageAcceptPolicy()
{
  if (CFURLRequestSetHTTPCookieStorageAcceptPolicy::sOnce != -1)
    dispatch_once(&CFURLRequestSetHTTPCookieStorageAcceptPolicy::sOnce, &__block_literal_global_1902);
}

const __CFAllocator *_CFURLRequestCreateArchiveList(const __CFAllocator *result, void *a2, uint64_t *a3, const void ***a4, uint64_t *a5, const __CFDictionary **a6)
{
  if (a2)
    return URLRequest::createArchiveList((URLRequest *)objc_msgSend(a2, "_inner"), result, a3, a4, a5, a6);
  if (a5)
    *a5 = 22;
  return result;
}

CFTypeRef _CFURLRequestCopyContentDispositionEncodingFallbackArray(void *a1)
{
  CFTypeRef result;

  result = *(CFTypeRef *)(objc_msgSend(a1, "_inner") + 80);
  if (result)
    return CFRetain(result);
  return result;
}

uint64_t CFURLRequestSetNetworkServiceType(void *a1, int a2)
{
  uint64_t result;

  result = objc_msgSend(a1, "_inner");
  *(_WORD *)(result + 64) |= 0x40u;
  *(_DWORD *)(result + 104) = a2;
  return result;
}

void _CFURLRequestSetShouldPipelineNonIdempotentHTTP(void *a1, char a2)
{
  uint64_t v3;
  HTTPRequest *fHTTPRequest;
  URLRequest *v5;
  void (**v6)(StringSerializable *__hidden);
  CFTypeRef cf;

  v3 = objc_msgSend(a1, "_inner");
  fHTTPRequest = *(HTTPRequest **)(v3 + 56);
  if (!fHTTPRequest)
  {
    v5 = (URLRequest *)v3;
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v6);
    URLRequest::createHTTPRequest(v5, (CFTypeRef *)&v6);
    v6 = &off_1E14E9A00;
    if (cf)
      CFRelease(cf);
    fHTTPRequest = v5->fHTTPRequest;
  }
  *((_BYTE *)fHTTPRequest + 218) = a2;
}

void sub_184006B84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void _CFURLRequestSetShouldSkipPipelineProbe(void *a1, char a2)
{
  uint64_t v3;
  HTTPRequest *fHTTPRequest;
  URLRequest *v5;
  void (**v6)(StringSerializable *__hidden);
  CFTypeRef cf;

  v3 = objc_msgSend(a1, "_inner");
  fHTTPRequest = *(HTTPRequest **)(v3 + 56);
  if (!fHTTPRequest)
  {
    v5 = (URLRequest *)v3;
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v6);
    URLRequest::createHTTPRequest(v5, (CFTypeRef *)&v6);
    v6 = &off_1E14E9A00;
    if (cf)
      CFRelease(cf);
    fHTTPRequest = v5->fHTTPRequest;
  }
  *((_BYTE *)fHTTPRequest + 219) = a2;
}

void sub_184006C10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

char *CFURLRequestSetShouldStartSynchronously(void *a1, int a2)
{
  uint64_t v3;
  char *result;
  __int16 v5;
  __int16 v6;
  __int16 v7;

  v3 = objc_msgSend(a1, "_inner");
  result = *(char **)(v3 + 8);
  if (!result
    || (result = _CFNetworkIsKnownHSTSHostWithSession(result, *(os_unfair_lock_s **)(v3 + 224)), !(_DWORD)result))
  {
    v5 = *(_WORD *)(v3 + 64);
    v6 = v5 | 0x4004;
    v7 = v5 & 0xBFFB | 0x4000;
    if (a2)
      v7 = v6;
    *(_WORD *)(v3 + 64) = v7;
  }
  return result;
}

uint64_t CFURLRequestSetAllowsCellularAccess(void *a1, int a2)
{
  uint64_t result;
  __int16 v4;
  __int16 v5;
  __int16 v6;

  result = objc_msgSend(a1, "_inner");
  v4 = *(_WORD *)(result + 64);
  v5 = v4 | 0x88;
  v6 = v4 & 0xFF77 | 0x80;
  if (a2)
    v6 = v5;
  *(_WORD *)(result + 64) = v6;
  return result;
}

void _CFURLRequestSetStorageSession(void *a1, const void *a2)
{
  uint64_t v3;
  const void *v4;
  CFTypeRef v5;
  uint64_t v6;
  const void *v7;

  v3 = objc_msgSend(a1, "_inner");
  v4 = *(const void **)(v3 + 224);
  if (v4 != a2)
  {
    if (v4)
      CFRelease(v4);
    if (a2)
      v5 = CFRetain(a2);
    else
      v5 = 0;
    *(_QWORD *)(v3 + 224) = v5;
  }
  v6 = *(_QWORD *)(v3 + 56);
  if (v6)
  {
    v7 = *(const void **)(v6 + 192);
    if (v7)
    {
      CFRelease(v7);
      *(_QWORD *)(v6 + 192) = 0;
    }
  }
}

uint64_t _CFURLRequestSetAllowedProtocolTypes(void *a1, uint64_t a2)
{
  uint64_t result;

  result = objc_msgSend(a1, "_inner");
  *(_QWORD *)(result + 96) = a2;
  return result;
}

uint64_t CFURLResponseGetTypeID()
{
  if (CFURLResponseGetTypeID::sOnce != -1)
    dispatch_once(&CFURLResponseGetTypeID::sOnce, &__block_literal_global_1912);
  return CFURLResponseGetTypeID::sID;
}

id CFURLResponseCreate(uint64_t a1, const void *a2, const __CFString *a3, uint64_t a4, const __CFString *a5, int a6)
{
  NSURLResponseInternal *v11;
  id v12;

  v11 = objc_alloc_init(NSURLResponseInternal);
  URLResponse::initialize((uint64_t)-[NSURLResponseInternal _inner](v11, "_inner"), a2, a3, a4, a5, a6);
  v12 = -[NSURLResponse _initWithInternal:]([NSURLResponse alloc], "_initWithInternal:", v11);

  return v12;
}

uint64_t CFURLResponseGetURL(void *a1)
{
  return *(_QWORD *)(objc_msgSend(a1, "_inner") + 8);
}

uint64_t CFURLResponseGetRecommendedCachePolicy(void *a1)
{
  return *(unsigned int *)(objc_msgSend(a1, "_inner") + 72);
}

double CFURLResponseGetCreationTime(void *a1)
{
  return URLResponse::getCreationTime((URLResponse *)objc_msgSend(a1, "_inner"));
}

uint64_t CFURLResponseSetExpectedContentLength(void *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;

  result = objc_msgSend(a1, "_inner");
  *(_QWORD *)(result + 32) = a2;
  v4 = *(_QWORD *)(result + 88);
  if (v4)
  {
    *(_WORD *)(v4 + 297) |= 0x100u;
    *(_WORD *)(*(_QWORD *)(result + 88) + 297) |= 0x2000u;
  }
  return result;
}

uint64_t CFURLResponseSetExpiration(void *a1, double a2)
{
  uint64_t result;
  uint64_t v4;

  result = objc_msgSend(a1, "_inner");
  *(double *)(result + 40) = a2;
  v4 = *(_QWORD *)(result + 88);
  if (v4)
    *(_WORD *)(v4 + 297) |= 0x1000u;
  return result;
}

uint64_t _CFURLResponseSetCreationTime(void *a1, double a2)
{
  uint64_t result;

  result = objc_msgSend(a1, "_inner");
  *(double *)(result + 48) = a2;
  return result;
}

uint64_t CFURLResponseSetRecommendedCachePolicy(void *a1, int a2)
{
  uint64_t result;

  result = objc_msgSend(a1, "_inner");
  *(_DWORD *)(result + 72) = a2;
  return result;
}

double _CFURLResponseGetFreshnessLifetime(void *a1)
{
  URLResponse *v1;
  double result;

  v1 = (URLResponse *)objc_msgSend(a1, "_inner");
  if (!v1->fHTTP)
    return 1.79769313e308;
  URLResponse::freshnessLifetimeForResponse(v1);
  return result;
}

const __CFAllocator *_CFURLResponseCreateArchiveList(const __CFAllocator *result, void *a2, uint64_t *a3, const void ***a4, uint64_t *a5)
{
  if (a2)
    return (const __CFAllocator *)URLResponse::createArchiveList((URLResponse *)objc_msgSend(a2, "_inner"), result, a3, a4, a5);
  if (a5)
    *a5 = 7;
  return result;
}

const __CFString *CFURLResponseCopySuggestedFilename(void *a1)
{
  return URLResponse::copySuggestedFilename((URLResponse *)objc_msgSend(a1, "_inner"));
}

BOOL CFURLResponseDataIsEncoded(void *a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(objc_msgSend(a1, "_inner") + 88);
  return v1 && ((*(unsigned __int16 *)(v1 + 297) | (*(unsigned __int8 *)(v1 + 299) << 16)) & 0x10000) != 0;
}

uint64_t CFURLResponseConnectionDidFallback(void *a1)
{
  return *(unsigned __int8 *)(objc_msgSend(a1, "_inner") + 96);
}

uint64_t _CFURLProtocolSendDidFailCallback(void *a1, uint64_t a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "client"), "URLProtocol:didFailWithError:", a1, a2);
}

uint64_t _CFURLProtocolSendDidReceiveResponseCallback(void *a1, uint64_t a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "client"), "URLProtocol:didReceiveResponse:cacheStoragePolicy:", a1, +[NSURLResponse _responseWithCFURLResponse:](NSURLResponse, "_responseWithCFURLResponse:", a2), 2);
}

uint64_t _CFURLProtocolSendDidLoadDataCallback(void *a1, uint64_t a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "client"), "URLProtocol:didLoadData:", a1, a2);
}

uint64_t _CFURLProtocolSendDidFinishLoadingCallback(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "client"), "URLProtocolDidFinishLoading:", a1);
}

uint64_t CFURLProtocolGetCachedResponse()
{
  return 0;
}

uint64_t CFURLProtocolGetClient(uint64_t result)
{
  if (result)
    result += 40;
  return result;
}

uint64_t CFURLCredentialCreateWithIdentityAndCertificateArray(uint64_t a1, const void *a2, const __CFArray *a3, int a4)
{
  uint64_t Instance;

  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_DWORD *)(Instance + 48) = 3;
  *(_QWORD *)(Instance + 24) = &unk_1E14EF178;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3752];
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_BYTE *)(Instance + 64) = 0;
  *(_QWORD *)(Instance + 72) = 0;
  *(_QWORD *)(Instance + 56) = 0;
  *(_QWORD *)(Instance + 16) = &off_1E14EF0E8;
  *(_QWORD *)(Instance + 40) = &unk_1E14EF1A8;
  if (!URLCredentialClientCertificate::initialize(Instance + 16, a2, a3, a4))
  {
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  return Instance;
}

uint64_t _CFURLCredentialCreateForKerberosTicketWithUUID(const __CFAllocator *a1, const __CFString *a2, const __CFString *a3, const __CFDictionary *a4, const __CFUUID *a5)
{
  uint64_t Instance;

  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_DWORD *)(Instance + 48) = 2;
  *(_QWORD *)(Instance + 24) = &unk_1E14EE640;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3752];
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_BYTE *)(Instance + 64) = 0;
  *(_QWORD *)(Instance + 72) = 0;
  *(_QWORD *)(Instance + 56) = 0;
  *(_QWORD *)(Instance + 16) = &off_1E14EE598;
  *(_QWORD *)(Instance + 40) = &unk_1E14EE670;
  *(_QWORD *)(Instance + 104) = 0;
  if (!URLCredentialKerberosTicket::initialize((URLCredentialKerberosTicket *)(Instance + 16), a2, a3, a4, a5))
  {
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  return Instance;
}

uint64_t _CFURLCredentialCreateForKerberosTicket(const __CFAllocator *a1, const __CFString *a2, const __CFString *a3, const __CFDictionary *a4)
{
  return _CFURLCredentialCreateForKerberosTicketWithUUID(a1, a2, a3, a4, 0);
}

uint64_t _CFURLCredentialCreateXMobileMeAuthToken(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  uint64_t Instance;

  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_DWORD *)(Instance + 48) = 4;
  *(_QWORD *)(Instance + 24) = &unk_1E14EF370;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3752];
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_BYTE *)(Instance + 64) = 0;
  *(_QWORD *)(Instance + 72) = 0;
  *(_QWORD *)(Instance + 56) = 0;
  *(_QWORD *)(Instance + 16) = &off_1E14EF2C8;
  *(_QWORD *)(Instance + 40) = &unk_1E14EF3A0;
  if (!URLCredentialXMobileMeAuthToken::initialize((URLCredentialXMobileMeAuthToken *)(Instance + 16), a2, a3, a4))
  {
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  return Instance;
}

uint64_t _CFURLCredentialCreateOAuth2(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  uint64_t Instance;

  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_DWORD *)(Instance + 48) = 6;
  *(_QWORD *)(Instance + 24) = &unk_1E14EB048;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3752];
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_BYTE *)(Instance + 64) = 0;
  *(_QWORD *)(Instance + 56) = 0;
  *(_QWORD *)(Instance + 16) = &off_1E14EAFB0;
  *(_QWORD *)(Instance + 40) = &unk_1E14EB078;
  *(_QWORD *)(Instance + 72) = 0;
  *(_QWORD *)(Instance + 80) = 0;
  *(_QWORD *)(Instance + 88) = 0;
  if (!URLCredentialOAuth2::initialize((URLCredentialOAuth2 *)(Instance + 16), a2, a3))
  {
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  return Instance;
}

uint64_t _CFURLCredentialCreateOAuth1(uint64_t a1, objc_object *a2, int a3, const __CFString *a4)
{
  uint64_t Instance;

  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_DWORD *)(Instance + 48) = 7;
  *(_QWORD *)(Instance + 24) = &unk_1E14EAF60;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3752];
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_BYTE *)(Instance + 64) = 0;
  *(_QWORD *)(Instance + 72) = 0;
  *(_QWORD *)(Instance + 56) = 0;
  *(_QWORD *)(Instance + 16) = &off_1E14EAEB0;
  *(_QWORD *)(Instance + 40) = &unk_1E14EAF90;
  *(_DWORD *)(Instance + 80) = 0;
  *(_QWORD *)(Instance + 88) = 0;
  *(_QWORD *)(Instance + 96) = 0;
  if (!URLCredentialOAuth1::initialize((URLCredentialOAuth1 *)(Instance + 16), a2, a3, a4))
  {
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  return Instance;
}

uint64_t CFURLCredentialGetPersistence(uint64_t a1)
{
  uint64_t v2;

  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  return *(unsigned int *)(v2 + 36);
}

uint64_t CFURLCredentialGetUsername(uint64_t a1)
{
  if (!a1)
    return 0;
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  if (!*(_DWORD *)(a1 + 48) || *(_DWORD *)(a1 + 48) == 4 || *(_DWORD *)(a1 + 48) == 2 || *(_DWORD *)(a1 + 48) == 6)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 16) + 112))(a1 + 16);
  else
    return 0;
}

uint64_t CFURLCredentialCopyPassword(uint64_t a1, const _CFURLCredential *a2)
{
  uint64_t result;

  result = URLCredential_PasswordBased::safelyCast(a1, a2);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 128))(result);
  return result;
}

uint64_t CFURLCredentialContainsPassword(uint64_t a1, const _CFURLCredential *a2)
{
  uint64_t result;

  result = URLCredential_PasswordBased::safelyCast(a1, a2);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 136))(result);
  return result;
}

CFTypeRef _CFURLCredentialCreateArchive(CFAllocatorRef allocator, uint64_t a2)
{
  uint64_t v2;
  CFTypeRef v4;
  CFTypeRef cf;

  v2 = a2;
  if (a2)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1)
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
    v2 += 16;
  }
  cf = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  if ((*(unsigned int (**)(uint64_t, CFTypeRef *))(*(_QWORD *)v2 + 72))(v2, &cf))
  {
    if (!cf)
      return 0;
    v4 = CFRetain(cf);
  }
  else
  {
    v4 = 0;
  }
  if (cf)
    CFRelease(cf);
  return v4;
}

void sub_184007CB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t _CFURLCredentialCopyOAuthToken(const _CFURLCredential *a1)
{
  if (!a1)
    return 0;
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  if (*((_DWORD *)a1 + 12) == 6)
    return (*(uint64_t (**)(char *))(*((_QWORD *)a1 + 2) + 128))((char *)a1 + 16);
  else
    return 0;
}

uint64_t _CFURLCredentialCopyOAuth1Account(const _CFURLCredential *a1)
{
  if (!a1)
    return 0;
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  if (*((_DWORD *)a1 + 12) == 7)
    return (*(uint64_t (**)(char *))(*((_QWORD *)a1 + 2) + 128))((char *)a1 + 16);
  else
    return 0;
}

uint64_t _CFURLCredentialGetOAuth1PID(const _CFURLCredential *a1)
{
  if (!a1)
    return 0;
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  if (*((_DWORD *)a1 + 12) == 7)
    return (*(uint64_t (**)(char *))(*((_QWORD *)a1 + 2) + 152))((char *)a1 + 16);
  else
    return 0;
}

uint64_t (***_CFURLCredentialCreateFromArchive(URLCredential *a1, const __CFDictionary *a2, const void *a3))(URLCredentialInternetPassword *__hidden this, const CFObject *)
{
  uint64_t (***v3)(URLCredentialInternetPassword *__hidden, const CFObject *);

  v3 = URLCredential::createFromPropertyList(a1, a2, a3);
  if (v3)
    return v3 - 2;
  else
    return 0;
}

uint64_t CFURLProtectionSpaceGetHost(uint64_t a1)
{
  uint64_t v2;

  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  return *(_QWORD *)(v2 + 32);
}

uint64_t CFURLProtectionSpaceGetPort(uint64_t a1)
{
  uint64_t v2;

  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  return *(unsigned int *)(v2 + 40);
}

uint64_t CFURLProtectionSpaceGetServerType(uint64_t a1)
{
  uint64_t v2;

  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  return *(unsigned int *)(v2 + 44);
}

uint64_t CFURLProtectionSpaceGetRealm(uint64_t a1)
{
  uint64_t v2;

  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  return *(_QWORD *)(v2 + 48);
}

uint64_t CFURLProtectionSpaceGetAuthenticationScheme(uint64_t a1)
{
  uint64_t v2;

  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  return *(unsigned int *)(v2 + 56);
}

uint64_t CFURLProtectionSpaceReceivesCredentialSecurely(uint64_t a1)
{
  uint64_t v2;
  int v3;
  unsigned int v6;
  BOOL v7;
  unsigned int v8;

  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  v3 = *(_DWORD *)(v2 + 44);
  if (v3 == 2 || v3 == 4)
    return 1;
  v6 = *(_DWORD *)(v2 + 56);
  v7 = v6 > 4;
  v8 = (9u >> v6) & 1;
  if (v7)
    return 1;
  else
    return v8;
}

uint64_t CFURLProtectionSpaceGetServerTrust(uint64_t a1)
{
  uint64_t v2;

  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  return *(_QWORD *)(v2 + 72);
}

CFTypeRef _CFURLProtectionSpaceCreateArchive(const __CFAllocator *a1, uint64_t a2)
{
  uint64_t v3;
  CFTypeRef v4;
  CFTypeRef cf;

  cf = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  if (a2)
    v3 = a2 + 16;
  else
    v3 = 0;
  if ((*(unsigned int (**)(uint64_t, CFTypeRef *))(*(_QWORD *)v3 + 64))(v3, &cf))
  {
    if (!cf)
      return 0;
    v4 = CFRetain(cf);
  }
  else
  {
    v4 = 0;
  }
  if (cf)
    CFRelease(cf);
  return v4;
}

void sub_184008184(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t Archiver<URLProtectionSpace,_CFURLProtectionSpace *>::~Archiver(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 8);
  if (v2)
    CFRelease(v2);
  return a1;
}

void Archiver<URLProtectionSpace,_CFURLProtectionSpace *>::~Archiver(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 8);
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t Dearchiver<URLProtectionSpace,_CFURLProtectionSpace *>::~Dearchiver(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 8);
  if (v2)
    CFRelease(v2);
  return a1;
}

void Dearchiver<URLProtectionSpace,_CFURLProtectionSpace *>::~Dearchiver(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 8);
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x186DB748CLL);
}

CFTypeRef URLProtectionSpace::setDistinguishedNames(URLProtectionSpace *this, CFTypeRef cf)
{
  CFTypeRef result;

  result = (CFTypeRef)*((_QWORD *)this + 8);
  if (result != cf)
  {
    if (result)
      CFRelease(result);
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *((_QWORD *)this + 8) = result;
  }
  return result;
}

uint64_t authMethodToAuthScheme(NSString *a1)
{
  if (!a1)
    return 1;
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("NSURLAuthenticationMethodDefault")))
    return 1;
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("NSURLAuthenticationMethodHTTPBasic")))
    return 2;
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("NSURLAuthenticationMethodHTTPDigest")))
    return 3;
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("NSURLAuthenticationMethodHTMLForm")))
    return 4;
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("NSURLAuthenticationMethodNTLM")))
    return 5;
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("NSURLAuthenticationMethodNegotiate")))
    return 6;
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("NSURLAuthenticationMethodClientCertificate")))
    return 7;
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("NSURLAuthenticationMethodServerTrust")))
    return 8;
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("NSURLAuthenticationMethodXMobileMeAuthToken")))
    return 9;
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("NSURLAuthenticationMethodOAuth")))
    return 10;
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("NSURLAuthenticationMethodPrivateAccessToken")))
    return 11;
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("NSURLAuthenticationMethodOAuthBearerToken")))
    return 12;
  return 1;
}

CFTypeRef AppSSOProtocol::_createCanonicalRequest(AppSSOProtocol *this, CFTypeRef cf, const _CFURLRequest *a3, NSURLSessionTask *a4, const void *a5)
{
  if (cf)
    return CFRetain(cf);
  else
    return 0;
}

char *AppSSOProtocol::_instantiateProtocol(AppSSOProtocol *this, const __CFAllocator *a2, URLProtocolClient *a3, URLProtocolClient *a4, const void *a5)
{
  const __CFAllocator *v6;
  uint64_t Instance;
  URLProtocol *v8;
  char *v9;

  v6 = a2;
  if (TCFObject<URLProtocol>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLProtocol>::Class(void)::sOnce, &__block_literal_global_30);
  Instance = _CFRuntimeCreateInstance();
  v8 = (URLProtocol *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    v8 = (URLProtocol *)(Instance + 16);
    *(_QWORD *)(Instance + 144) = 0;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
  }
  *(_OWORD *)((char *)v8 + 104) = 0u;
  *(_OWORD *)((char *)v8 + 120) = 0u;
  *(_OWORD *)((char *)v8 + 88) = 0u;
  *(_OWORD *)((char *)v8 + 72) = 0u;
  *(_OWORD *)((char *)v8 + 56) = 0u;
  *(_OWORD *)((char *)v8 + 40) = 0u;
  *(_OWORD *)((char *)v8 + 24) = 0u;
  *(_QWORD *)v8 = &off_1E14E69D0;
  *((_QWORD *)v8 + 1) = &unk_1E14E6AD0;
  *((_QWORD *)v8 + 2) = &unk_1E14E6AF0;
  *((_QWORD *)v8 + 14) = 0;
  *((_QWORD *)v8 + 15) = 0;
  *((_BYTE *)v8 + 128) = 0;
  if (AppSSOProtocol::initialize(v8, (NSURLSessionTask *)v6, a3))
  {
    v9 = (char *)v8 - 16;
  }
  else
  {
    (*(void (**)(URLProtocol *))(*(_QWORD *)v8 + 64))(v8);
    CFRelease((char *)v8 - 16);
    v9 = 0;
  }

  return v9;
}

void sub_184008EC0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id AppSSO::AppSSOProtocolLog(AppSSO *this)
{
  if (AppSSO::AppSSOProtocolLog(void)::onceToken != -1)
    dispatch_once(&AppSSO::AppSSOProtocolLog(void)::onceToken, &__block_literal_global_2188);
  return (id)AppSSO::AppSSOProtocolLog(void)::ssoLog;
}

void ___ZN6AppSSOL17AppSSOProtocolLogEv_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.CFNetwork", "AppSSOProtocol");
  v1 = (void *)AppSSO::AppSSOProtocolLog(void)::ssoLog;
  AppSSO::AppSSOProtocolLog(void)::ssoLog = (uint64_t)v0;

}

BOOL AppSSOProtocol::initialize(URLProtocol *this, NSURLSessionTask *a2, URLProtocolClient *a3)
{
  NSURLSessionTask *v5;
  void *v6;
  uint64_t v7;
  _QWORD *v8;
  AppSSO *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  NSObject *v13;
  uint64_t v15;
  _BYTE v16[22];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  URLProtocol::initialize(this, v5, a3);
  -[NSURLSessionTask session](v5, "session");
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  if (v6)
  {
    -[NSURLSessionTask _loggableDescription](v5, "_loggableDescription");
    v7 = objc_claimAutoreleasedReturnValue();
    *(_QWORD *)v16 = v7;
    v8 = (_QWORD *)operator new();
    *v8 = &off_1E14F19E8;
    v8[1] = 0;
    v8[2] = 0;
    v8[3] = v7;
    *(_QWORD *)&v16[8] = v8;
    v9 = (AppSSO *)std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 112, (__int128 *)v16);
    v10 = *(std::__shared_weak_count **)&v16[8];
    if (*(_QWORD *)&v16[8])
    {
      v11 = (unint64_t *)(*(_QWORD *)&v16[8] + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    AppSSO::AppSSOProtocolLog(v9);
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v15 = *((_QWORD *)this + 14);
      *(_DWORD *)v16 = 134218242;
      *(_QWORD *)&v16[4] = this;
      *(_WORD *)&v16[12] = 2114;
      *(_QWORD *)&v16[14] = v15;
      _os_log_debug_impl(&dword_183ECA000, v13, OS_LOG_TYPE_DEBUG, "AppSSOProtocol %p initialized for %{public}@", v16, 0x16u);
    }

  }
  return v6 != 0;
}

void sub_1840090C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

CFStringRef AppSSOProtocol::copyDebugDesc(AppSSOProtocol *this)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<AppSSOProtocol instance %p>"), this);
}

void AppSSOProtocol::~AppSSOProtocol(AppSSOProtocol *this)
{
  *(_QWORD *)this = &off_1E14E69D0;
  *((_QWORD *)this + 1) = &unk_1E14E6AD0;
  *((_QWORD *)this + 2) = &unk_1E14E6AF0;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 112);
  URLProtocol::~URLProtocol((URLProtocol *)this);
}

{
  *(_QWORD *)this = &off_1E14E69D0;
  *((_QWORD *)this + 1) = &unk_1E14E6AD0;
  *((_QWORD *)this + 2) = &unk_1E14E6AF0;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 112);
  URLProtocol::~URLProtocol((URLProtocol *)this);
}

void AppSSOProtocol::_protocolInterface_startLoad(id *this, const _CFCachedURLResponse *a2)
{
  id v3;
  void *v4;
  AppSSO *v5;
  AppSSO *v6;
  NSObject *v7;
  id v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  NSObject *v18;
  const __CFAllocator *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __CFError *CFError;
  id v26;
  _QWORD v27[5];
  std::__shared_weak_count *v28;
  _BYTE buf[22];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = this[10];
  if (v3)
  {
    v4 = v3;
    objc_msgSend(v3, "session");
    v5 = (AppSSO *)objc_claimAutoreleasedReturnValue();
    v6 = v5;
    if (v5)
    {
      AppSSO::AppSSOProtocolLog(v5);
      v7 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v8 = this[14];
        *(_DWORD *)buf = 134218242;
        *(_QWORD *)&buf[4] = this;
        *(_WORD *)&buf[12] = 2114;
        *(_QWORD *)&buf[14] = v8;
        _os_log_impl(&dword_183ECA000, v7, OS_LOG_TYPE_DEFAULT, "%p starting load for %{public}@", buf, 0x16u);
      }

      CFRetain(this - 2);
      *(_QWORD *)buf = this;
      v9 = (std::__shared_weak_count *)operator new();
      v9->__shared_owners_ = 0;
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      v9->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1160;
      v9->__shared_weak_owners_ = 0;
      v9[1].__vftable = (std::__shared_weak_count_vtbl *)this;
      *(_QWORD *)&buf[8] = v9;
      v27[0] = MEMORY[0x1E0C809B0];
      v27[1] = 3321888768;
      v27[2] = ___ZN14AppSSOProtocol28_protocolInterface_startLoadEPK20_CFCachedURLResponse_block_invoke;
      v27[3] = &__block_descriptor_48_ea8_32c42_ZTSNSt3__110shared_ptrI14AppSSOProtocolEE_e25_v16__0____CFDictionary__8l;
      v27[4] = this;
      v28 = v9;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
      -[__NSURLSessionLocal _getCookieHeadersForTask:completionHandler:]((uint64_t)v6, v4, (uint64_t)v27);
      v12 = v28;
      if (v28)
      {
        v13 = (unint64_t *)&v28->__shared_owners_;
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      v15 = *(std::__shared_weak_count **)&buf[8];
      if (*(_QWORD *)&buf[8])
      {
        v16 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v17 = __ldaxr(v16);
        while (__stlxr(v17 - 1, v16));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
      }

      return;
    }

  }
  AppSSO::AppSSOProtocolLog((AppSSO *)v3);
  v18 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    v26 = this[14];
    *(_DWORD *)buf = 134218242;
    *(_QWORD *)&buf[4] = this;
    *(_WORD *)&buf[12] = 2114;
    *(_QWORD *)&buf[14] = v26;
    _os_log_error_impl(&dword_183ECA000, v18, OS_LOG_TYPE_ERROR, "%p did not start load for %{public}@", buf, 0x16u);
  }

  v19 = CFGetAllocator(this - 2);
  CFError = __cfnCreateCFError(v19, CFSTR("kCFErrorDomainCFNetwork"), -1000, v20, v21, v22, v23, v24, 0);
  URLProtocol::sendDidFail((URLProtocol *)this, CFError);
  if (CFError)
    CFRelease(CFError);
}

void sub_18400942C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  uint64_t v11;
  va_list va;

  va_start(va, a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

void AppSSOProtocol::_protocolInterface_cancelLoad(AppSSOProtocol *this)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  AppSSOProtocol *v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  AppSSO::AppSSOProtocolLog(this);
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v3 = *((_QWORD *)this + 14);
    v4 = 134218242;
    v5 = this;
    v6 = 2114;
    v7 = v3;
    _os_log_debug_impl(&dword_183ECA000, v2, OS_LOG_TYPE_DEBUG, "%p cancel load %{public}@", (uint8_t *)&v4, 0x16u);
  }

  *((_BYTE *)this + 128) = 1;
}

void AppSSOProtocol::_protocolInterface_haltLoad(AppSSOProtocol *this)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  AppSSOProtocol *v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  AppSSO::AppSSOProtocolLog(this);
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v3 = *((_QWORD *)this + 14);
    v4 = 134218242;
    v5 = this;
    v6 = 2114;
    v7 = v3;
    _os_log_debug_impl(&dword_183ECA000, v2, OS_LOG_TYPE_DEBUG, "%p halt load %{public}@", (uint8_t *)&v4, 0x16u);
  }

}

void AppSSOProtocol::_protocolInterface_resumeLoad(AppSSOProtocol *this)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  AppSSOProtocol *v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  AppSSO::AppSSOProtocolLog(this);
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v3 = *((_QWORD *)this + 14);
    v4 = 134218242;
    v5 = this;
    v6 = 2114;
    v7 = v3;
    _os_log_debug_impl(&dword_183ECA000, v2, OS_LOG_TYPE_DEBUG, "%p resume load %{public}@", (uint8_t *)&v4, 0x16u);
  }

}

void AppSSOProtocol::_protocolInterface_useCredential(AppSSOProtocol *this, const _CFURLCredential *a2, _CFURLAuthChallenge *a3)
{
  NSObject *v4;
  uint64_t v5;
  int v6;
  AppSSOProtocol *v7;
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  AppSSO::AppSSOProtocolLog(this);
  v4 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    v5 = *((_QWORD *)this + 14);
    v6 = 134218242;
    v7 = this;
    v8 = 2114;
    v9 = v5;
    _os_log_debug_impl(&dword_183ECA000, v4, OS_LOG_TYPE_DEBUG, "%p use credential %{public}@", (uint8_t *)&v6, 0x16u);
  }

}

void AppSSOProtocol::_protocolInterface_setIsDownload(AppSSOProtocol *this)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  AppSSOProtocol *v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  AppSSO::AppSSOProtocolLog(this);
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v3 = *((_QWORD *)this + 14);
    v4 = 134218242;
    v5 = this;
    v6 = 2114;
    v7 = v3;
    _os_log_debug_impl(&dword_183ECA000, v2, OS_LOG_TYPE_DEBUG, "%p setIsDownload %{public}@", (uint8_t *)&v4, 0x16u);
  }

}

void AppSSOProtocol::subclassUpdateScheduling(AppSSOProtocol *this, const CoreSchedulingSet *a2, const CoreSchedulingSet *a3)
{
  NSObject *v4;
  uint64_t v5;
  int v6;
  AppSSOProtocol *v7;
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  AppSSO::AppSSOProtocolLog(this);
  v4 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    v5 = *((_QWORD *)this + 14);
    v6 = 134218242;
    v7 = this;
    v8 = 2114;
    v9 = v5;
    _os_log_debug_impl(&dword_183ECA000, v4, OS_LOG_TYPE_DEBUG, "%p update scheduling %{public}@", (uint8_t *)&v6, 0x16u);
  }

}

void `non-virtual thunk to'AppSSOProtocol::~AppSSOProtocol(AppSSOProtocol *this)
{
  *(_QWORD *)this = &unk_1E14E6AD0;
  *((_QWORD *)this + 1) = &unk_1E14E6AF0;
  *((_QWORD *)this - 1) = &off_1E14E69D0;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 104);
  URLProtocol::~URLProtocol((URLProtocol *)((char *)this - 8));
}

{
  *(_QWORD *)this = &unk_1E14E6AD0;
  *((_QWORD *)this + 1) = &unk_1E14E6AF0;
  *((_QWORD *)this - 1) = &off_1E14E69D0;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 104);
  URLProtocol::~URLProtocol((URLProtocol *)((char *)this - 8));
}

{
  *((_QWORD *)this - 1) = &unk_1E14E6AD0;
  *(_QWORD *)this = &unk_1E14E6AF0;
  *((_QWORD *)this - 2) = &off_1E14E69D0;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 96);
  URLProtocol::~URLProtocol((URLProtocol *)((char *)this - 16));
}

{
  *((_QWORD *)this - 1) = &unk_1E14E6AD0;
  *(_QWORD *)this = &unk_1E14E6AF0;
  *((_QWORD *)this - 2) = &off_1E14E69D0;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 96);
  URLProtocol::~URLProtocol((URLProtocol *)((char *)this - 16));
}

void ___ZN14AppSSOProtocol28_protocolInterface_startLoadEPK20_CFCachedURLResponse_block_invoke(uint64_t a1, CFTypeRef cf)
{
  std::__shared_weak_count_vtbl *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  _QWORD v21[5];
  std::__shared_weak_count *v22;
  std::__shared_weak_count_vtbl *v23;
  std::__shared_weak_count *v24;
  std::__shared_weak_count_vtbl *v25;
  std::__shared_weak_count *v26;

  if (cf)
    v3 = (std::__shared_weak_count_vtbl *)CFRetain(cf);
  else
    v3 = 0;
  v25 = v3;
  v4 = (std::__shared_weak_count *)operator new();
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1A58;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = v3;
  v26 = v4;
  v7 = *(_QWORD *)(a1 + 32);
  v6 = *(std::__shared_weak_count **)(a1 + 40);
  v8 = *(_QWORD *)(v7 + 24);
  v21[0] = MEMORY[0x1E0C809B0];
  v21[1] = 3321888768;
  v21[2] = ___ZN14AppSSOProtocol28_protocolInterface_startLoadEPK20_CFCachedURLResponse_block_invoke_2;
  v21[3] = &__block_descriptor_64_ea8_32c42_ZTSNSt3__110shared_ptrI14AppSSOProtocolEE48c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE_e5_v8__0l;
  v21[4] = v7;
  v22 = v6;
  if (v6)
  {
    v9 = (unint64_t *)&v6->__shared_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v23 = v3;
  v24 = v4;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v8 + 96))(v8, v21);
  v12 = v24;
  if (v24)
  {
    v13 = (unint64_t *)&v24->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = v22;
  if (v22)
  {
    v16 = (unint64_t *)&v22->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v26;
  if (v26)
  {
    v19 = (unint64_t *)&v26->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
}

void sub_184009B5C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3 - 48);
  _Unwind_Resume(a1);
}

void ___ZN11URLProtocol19invalidateThrottlerEv_block_invoke_2213(uint64_t a1)
{
  CFRelease((CFTypeRef)(*(_QWORD *)(a1 + 32) - 16));
}

uint64_t ___ZN11URLProtocol11sendDidFailEP9__CFError_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 231;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t __copy_helper_block_ea8_32c42_ZTSNSt3__110shared_ptrI14AppSSOProtocolEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c42_ZTSNSt3__110shared_ptrI14AppSSOProtocolEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void ___ZN14AppSSOProtocol28_protocolInterface_startLoadEPK20_CFCachedURLResponse_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  id v3;
  void *v4;
  uint64_t v5;
  HTTPMessage *v6;
  CFMutableDictionaryRef v7;
  NSObject *v8;
  const __CFAllocator *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __CFError *CFError;
  void *v16;
  id v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t i;
  id v21;
  void *v22;
  HTTPMessage *v23;
  const __CFArray *v24;
  CFTypeRef v25;
  const __CFArray *v26;
  const void *ValueAtIndex;
  const void *v28;
  CFTypeID v29;
  NSObject *v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *p_shared_owners;
  uint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  _QWORD *v40;
  std::__shared_weak_count_vtbl *v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  AppSSO *v44;
  NSObject *v45;
  double v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t *v57;
  unint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  std::__shared_weak_count *v64;
  void *v65;
  id v66;
  CFMutableDictionaryRef v67;
  void *v68;
  void *v69;
  CFTypeRef cf;
  void *v71;
  _QWORD v72[5];
  std::__shared_weak_count *v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  uint8_t v78[4];
  uint64_t v79;
  __int16 v80;
  uint64_t v81;
  _BYTE buf[24];
  void *v83;
  _BYTE v84[32];
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v1 + 128))
    return;
  v2 = *(void **)(a1 + 48);
  v3 = *(id *)(v1 + 88);
  if (v3)
  {
    v4 = v3;
    v5 = objc_msgSend(v3, "cfURL");
    if (v5)
    {
      v71 = v4;
      v6 = *(HTTPMessage **)(objc_msgSend(v4, "_inner") + 56);
      if (v6)
        v7 = HTTPMessage::copyAllHeaderFields(v6);
      else
        v7 = 0;
      v67 = v7;
      objc_msgSend(MEMORY[0x1E0C99E08], "dictionaryWithDictionary:");
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      v76 = 0u;
      v77 = 0u;
      v74 = 0u;
      v75 = 0u;
      v17 = v2;
      v18 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v74, v78, 16);
      v69 = (void *)v5;
      if (v18)
      {
        v19 = *(_QWORD *)v75;
        do
        {
          for (i = 0; i != v18; ++i)
          {
            if (*(_QWORD *)v75 != v19)
              objc_enumerationMutation(v17);
            v21 = *(id *)(*((_QWORD *)&v74 + 1) + 8 * i);
            objc_msgSend(v17, "objectForKeyedSubscript:", v21);
            v22 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v16, "setObject:forKeyedSubscript:", v22, v21);

          }
          v18 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v74, v78, 16);
        }
        while (v18);
      }

      v23 = *(HTTPMessage **)(objc_msgSend(v71, "_inner") + 56);
      if (!v23 || (v24 = HTTPMessage::copyBody(v23), (v25 = v24) == 0))
      {
        v24 = CFURLRequestCopyHTTPRequestBodyParts(v71);
        v26 = v24;
        if (v24)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v24, 0);
          v28 = ValueAtIndex;
          if (ValueAtIndex && (v29 = CFGetTypeID(ValueAtIndex), v29 == CFDataGetTypeID()))
            v25 = CFRetain(v28);
          else
            v25 = 0;
          CFRelease(v26);
        }
        else
        {
          v25 = 0;
        }
      }
      cf = v25;
      AppSSO::AppSSOProtocolLog(v24);
      v30 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        v31 = *(_QWORD *)(v1 + 112);
        *(_DWORD *)buf = 134218242;
        *(_QWORD *)&buf[4] = v1;
        *(_WORD *)&buf[12] = 2114;
        *(_QWORD *)&buf[14] = v31;
        _os_log_impl(&dword_183ECA000, v30, OS_LOG_TYPE_DEFAULT, "%p continuing load of %{public}@", buf, 0x16u);

      }
      else
      {

        if (!v1)
        {
LABEL_33:
          v32 = (std::__shared_weak_count *)operator new();
          v32->__shared_owners_ = 0;
          p_shared_owners = (unint64_t *)&v32->__shared_owners_;
          v32->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1160;
          v32->__shared_weak_owners_ = 0;
          v32[1].__vftable = (std::__shared_weak_count_vtbl *)v1;
          v34 = *(_QWORD *)(v1 + 112);
          v35 = *(std::__shared_weak_count **)(v1 + 120);
          if (v35)
          {
            v36 = (unint64_t *)&v35->__shared_owners_;
            do
              v37 = __ldxr(v36);
            while (__stxr(v37 + 1, v36));
          }
          v64 = v32;
          v38 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithDictionary:", v16);
          v66 = *(id *)(v1 + 80);
          objc_msgSend(v66, "_effectiveConfiguration");
          v65 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v65, "_sourceApplicationAuditTokenData");
          v68 = (void *)objc_claimAutoreleasedReturnValue();
          v72[0] = MEMORY[0x1E0C809B0];
          v72[1] = 3321888768;
          v72[2] = ___ZN14AppSSOProtocol24continueLoadAfterCookiesEPK14__CFDictionary_block_invoke;
          v72[3] = &__block_descriptor_48_ea8_32c42_ZTSNSt3__110shared_ptrI14AppSSOProtocolEE_e52_v32__0__NSURLResponse_8____CFData__16____CFError__24l;
          v72[4] = v1;
          v73 = v32;
          do
            v39 = __ldxr(p_shared_owners);
          while (__stxr(v39 + 1, p_shared_owners));
          v40 = v72;
          v41 = (std::__shared_weak_count_vtbl *)operator new();
          v41->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *>::invoke_initial;
          v41->__on_zero_shared = 0;
          v41->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))_Block_copy(v40);
          v42 = (std::__shared_weak_count *)operator new();
          v42->__shared_owners_ = 0;
          v43 = (unint64_t *)&v42->__shared_owners_;
          v42->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1400;
          v42->__shared_weak_owners_ = 0;
          v42[1].__vftable = v41;

          AppSSO::AppSSOLog(v44);
          v45 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138544642;
            *(_QWORD *)&buf[4] = v34;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = 2;
            *(_WORD *)&buf[22] = 2112;
            v83 = v69;
            *(_WORD *)v84 = 2112;
            *(_QWORD *)&v84[2] = v38;
            *(_WORD *)&v84[10] = 2112;
            *(_QWORD *)&v84[12] = cf;
            *(_WORD *)&v84[20] = 2112;
            *(_QWORD *)&v84[22] = v68;
            _os_log_impl(&dword_183ECA000, v45, OS_LOG_TYPE_DEFAULT, "getResponse %{public}@ flag %lu url %@ headers %@ body %@ token %@", buf, 0x3Eu);
          }

          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 3321888768;
          *(_QWORD *)&buf[16] = ___ZN6AppSSO11getResponseENSt3__110shared_ptrIK10__CFStringEEPK7__CFURLPK14__CFDictionaryPK8__CFDataSD_18SmartBlockWithArgsIJU8__strongP13NSURLResponseSD_P9__CFErrorEE_block_invoke_5;
          v83 = &__block_descriptor_64_ea8_32c39_ZTSNSt3__110shared_ptrIK10__CFStringEE48c76_ZTS18SmartBlockWithArgsIJU8__strongP13NSURLResponsePK8__CFDataP9__CFErrorEE_e54_v32__0___CFURLResponse__8____CFData__16____CFError__24l;
          *(_QWORD *)v84 = v34;
          *(_QWORD *)&v84[8] = v35;
          if (v35)
          {
            v47 = (unint64_t *)&v35->__shared_owners_;
            do
              v48 = __ldxr(v47);
            while (__stxr(v48 + 1, v47));
          }
          *(_QWORD *)&v84[16] = v41;
          *(_QWORD *)&v84[24] = v42;
          do
            v49 = __ldxr(v43);
          while (__stxr(v49 + 1, v43));
          appSSO_handleResponse_delayInitStub(v46);
          v50 = *(std::__shared_weak_count **)&v84[24];
          if (*(_QWORD *)&v84[24])
          {
            v51 = (unint64_t *)(*(_QWORD *)&v84[24] + 8);
            do
              v52 = __ldaxr(v51);
            while (__stlxr(v52 - 1, v51));
            if (!v52)
            {
              ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
              std::__shared_weak_count::__release_weak(v50);
            }
          }
          v53 = *(std::__shared_weak_count **)&v84[8];
          if (*(_QWORD *)&v84[8])
          {
            v54 = (unint64_t *)(*(_QWORD *)&v84[8] + 8);
            do
              v55 = __ldaxr(v54);
            while (__stlxr(v55 - 1, v54));
            if (!v55)
            {
              ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
              std::__shared_weak_count::__release_weak(v53);
            }
          }
          do
            v56 = __ldaxr(v43);
          while (__stlxr(v56 - 1, v43));
          if (!v56)
          {
            ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
            std::__shared_weak_count::__release_weak(v42);
          }

          if (v35)
          {
            v57 = (unint64_t *)&v35->__shared_owners_;
            do
              v58 = __ldaxr(v57);
            while (__stlxr(v58 - 1, v57));
            if (!v58)
            {
              ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
              std::__shared_weak_count::__release_weak(v35);
            }
          }
          v59 = v73;
          if (v73)
          {
            v60 = (unint64_t *)&v73->__shared_owners_;
            do
              v61 = __ldaxr(v60);
            while (__stlxr(v61 - 1, v60));
            if (!v61)
            {
              ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
              std::__shared_weak_count::__release_weak(v59);
            }
          }
          do
            v62 = __ldaxr(p_shared_owners);
          while (__stlxr(v62 - 1, p_shared_owners));
          if (!v62)
          {
            ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
            std::__shared_weak_count::__release_weak(v64);
          }
          if (cf)
            CFRelease(cf);

          if (v67)
            CFRelease(v67);

          return;
        }
      }
      CFRetain((CFTypeRef)(v1 - 16));
      goto LABEL_33;
    }

  }
  AppSSO::AppSSOProtocolLog((AppSSO *)v3);
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    v63 = *(_QWORD *)(v1 + 112);
    *(_DWORD *)v78 = 134218242;
    v79 = v1;
    v80 = 2114;
    v81 = v63;
    _os_log_error_impl(&dword_183ECA000, v8, OS_LOG_TYPE_ERROR, "%p did not continue load for %{public}@", v78, 0x16u);
  }

  v9 = CFGetAllocator((CFTypeRef)(v1 - 16));
  CFError = __cfnCreateCFError(v9, CFSTR("kCFErrorDomainCFNetwork"), -1008, v10, v11, v12, v13, v14, 0);
  URLProtocol::sendDidFail((URLProtocol *)v1, CFError);
  if (CFError)
    CFRelease(CFError);
}

void sub_18400A31C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, CFTypeRef cf, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  const void *v24;
  void *v25;

  CFRelease(v24);

  if (cf)
    CFRelease(cf);

  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_ea8_32c42_ZTSNSt3__110shared_ptrI14AppSSOProtocolEE48c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c42_ZTSNSt3__110shared_ptrI14AppSSOProtocolEE48c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 32;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void ___ZN14AppSSOProtocol24continueLoadAfterCookiesEPK14__CFDictionary_block_invoke(uint64_t a1, void *a2, std::__shared_weak_count_vtbl *a3, std::__shared_weak_count_vtbl *a4)
{
  AppSSO *v7;
  NSObject *v8;
  uint64_t v9;
  AppSSO *v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  _QWORD v46[5];
  std::__shared_weak_count *v47;
  AppSSO *v48;
  std::__shared_weak_count *v49;
  std::__shared_weak_count_vtbl *v50;
  std::__shared_weak_count *v51;
  std::__shared_weak_count_vtbl *v52;
  std::__shared_weak_count *v53;
  std::__shared_weak_count_vtbl *v54;
  std::__shared_weak_count *v55;
  std::__shared_weak_count_vtbl *v56;
  std::__shared_weak_count *v57;
  _BYTE buf[22];
  __int16 v59;
  std::__shared_weak_count_vtbl *v60;
  __int16 v61;
  std::__shared_weak_count_vtbl *v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  v7 = a2;
  AppSSO::AppSSOProtocolLog(v7);
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v9 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)buf = 134218754;
    *(_QWORD *)&buf[4] = v9;
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = v7;
    v59 = 2112;
    v60 = a3;
    v61 = 2112;
    v62 = a4;
    _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_DEFAULT, "getResponse for AppSSOProtocol %p returns response %@ data %@ error %@", buf, 0x2Au);
  }

  v10 = v7;
  *(_QWORD *)buf = v10;
  v11 = (std::__shared_weak_count *)operator new();
  v11->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v11->__shared_owners_;
  v11->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1550;
  v11->__shared_weak_owners_ = 0;
  v11[1].__vftable = (std::__shared_weak_count_vtbl *)v10;
  *(_QWORD *)&buf[8] = v11;
  if (a4)
    a4 = (std::__shared_weak_count_vtbl *)CFRetain(a4);
  v56 = a4;
  v13 = (std::__shared_weak_count *)operator new();
  v13->__shared_owners_ = 0;
  v14 = (unint64_t *)&v13->__shared_owners_;
  v13->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19B0;
  v13->__shared_weak_owners_ = 0;
  v13[1].__vftable = a4;
  v57 = v13;
  if (a3)
    a3 = (std::__shared_weak_count_vtbl *)CFRetain(a3);
  v54 = a3;
  v15 = (std::__shared_weak_count *)operator new();
  v15->__shared_owners_ = 0;
  v16 = (unint64_t *)&v15->__shared_owners_;
  v15->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1A90;
  v15->__shared_weak_owners_ = 0;
  v15[1].__vftable = a3;
  v55 = v15;
  v18 = *(_QWORD *)(a1 + 32);
  v17 = *(std::__shared_weak_count **)(a1 + 40);
  v19 = *(_QWORD *)(v18 + 24);
  v46[0] = MEMORY[0x1E0C809B0];
  v46[1] = 3321888768;
  v46[2] = ___ZN14AppSSOProtocol24continueLoadAfterCookiesEPK14__CFDictionary_block_invoke_2;
  v46[3] = &__block_descriptor_96_ea8_32c42_ZTSNSt3__110shared_ptrI14AppSSOProtocolEE48c42_ZTSNSt3__110shared_ptrI14_CFURLResponseEE64c36_ZTSNSt3__110shared_ptrIK8__CFDataEE80c36_ZTSNSt3__110shared_ptrI9__CFErrorEE_e5_v8__0l;
  v46[4] = v18;
  v47 = v17;
  if (v17)
  {
    v20 = (unint64_t *)&v17->__shared_owners_;
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  v48 = v10;
  v49 = v11;
  do
    v22 = __ldxr(p_shared_owners);
  while (__stxr(v22 + 1, p_shared_owners));
  v50 = a3;
  v51 = v15;
  do
    v23 = __ldxr(v16);
  while (__stxr(v23 + 1, v16));
  v52 = a4;
  v53 = v13;
  do
    v24 = __ldxr(v14);
  while (__stxr(v24 + 1, v14));
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v19 + 96))(v19, v46);
  v25 = v53;
  if (v53)
  {
    v26 = (unint64_t *)&v53->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  v28 = v51;
  if (v51)
  {
    v29 = (unint64_t *)&v51->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v31 = v49;
  if (v49)
  {
    v32 = (unint64_t *)&v49->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = v47;
  if (v47)
  {
    v35 = (unint64_t *)&v47->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v37 = v55;
  if (v55)
  {
    v38 = (unint64_t *)&v55->__shared_owners_;
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
  v40 = v57;
  if (v57)
  {
    v41 = (unint64_t *)&v57->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
  v43 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v44 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }

}

void sub_18400A9CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  va_list va;
  uint64_t v22;
  uint64_t v23;
  va_list va1;
  uint64_t v25;
  va_list va2;

  va_start(va2, a13);
  va_start(va1, a13);
  va_start(va, a13);
  v20 = va_arg(va1, _QWORD);
  v22 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v23 = va_arg(va2, _QWORD);
  v25 = va_arg(va2, _QWORD);
  v18 = v15;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v18);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v16);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v17);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v14);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va2);

  _Unwind_Resume(a1);
}

uint64_t BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *>::invoke_initial(_QWORD *a1)
{
  a1[1] = BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

void std::__shared_ptr_pointer<BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *> *,SmartBlockWithArgs<NSURLResponse * {__strong},__CFData const*,__CFError *>::Deleter,std::allocator<BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *> *,SmartBlockWithArgs<NSURLResponse * {__strong},__CFData const*,__CFError *>::Deleter,std::allocator<BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  BOOL v4;
  int v5;
  _QWORD *v7;

  v1 = *(_QWORD *)(a1 + 24);
  v3 = *(_QWORD *)(v1 + 8);
  v2 = *(_QWORD *)(v1 + 16);
  if (v2)
    v4 = (*(_QWORD *)(v1 + 16) & 1 | v3) == 0;
  else
    v4 = 1;
  v5 = v4;
  if ((uint64_t (*)(_QWORD *))v3 == BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *>::invoke_initial
    && v5 != 0)
  {
    v7 = (_QWORD *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0)
      (*(void (**)(_QWORD *, _QWORD, _QWORD, _QWORD))(*v7
                                                               + BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *>::invoke_initial))(v7, 0, 0, 0);
    else
      ((void (*)(_QWORD *, _QWORD, _QWORD, _QWORD))BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *>::invoke_initial)(v7, 0, 0, 0);
  }

  JUMPOUT(0x186DB748CLL);
}

uint64_t BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a1 + 16))();
}

void ___ZN14AppSSOProtocol24continueLoadAfterCookiesEPK14__CFDictionary_block_invoke_2(AppSSO *a1)
{
  uint64_t v1;
  _CFURLResponse *v2;
  const __CFData *v3;
  AppSSO *v4;
  NSObject *v5;
  __CFError *v6;
  uint64_t v7;
  uint64_t v8;
  CFArrayRef v9;
  void *v10;
  uint64_t v11;
  void *v12;
  _QWORD *v13;
  AppSSO *isPerformDefaultHandlingError;
  NSObject *v15;
  uint64_t v16;
  id v17;
  NSURLRequest *v18;
  NSObject *v19;
  const __CFAllocator *v20;
  __CFError *Mutable;
  NSObject *v22;
  const __CFAllocator *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __CFError *v29;
  uint64_t v30;
  id v31;
  void *v32;
  uint64_t v33;
  unsigned int v34;
  BOOL v35;
  int v36;
  const __CFString *HeaderFieldValue;
  _QWORD *v39;
  AppSSO *v40;
  const __CFAllocator *v41;
  CFStringRef v42;
  std::__shared_weak_count *v43;
  unint64_t *p_shared_owners;
  NSURLRequest *v45;
  const __CFAllocator *v46;
  const __CFString *v47;
  id v48;
  const __CFURL *v49;
  uint64_t v50;
  CFStringRef *v51;
  uint64_t v52;
  uint64_t v53;
  void *v54;
  AppSSO *v55;
  NSObject *v56;
  uint64_t v57;
  CFIndex Length;
  Throttler *v59;
  CFIndex v60;
  _BYTE *v61;
  uint64_t v62;
  uint64_t v63;
  void *v64;
  AppSSO *v65;
  NSObject *v66;
  uint64_t v67;
  NSObject *v68;
  const __CFAllocator *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  const __CFURL *v75;
  std::__shared_weak_count *v76;
  unint64_t *v77;
  unint64_t v78;
  CFIndex v79;
  char *v80;
  CFStringEncoding v81;
  uint64_t v82;
  id v83;
  const __CFURL *v84;
  const __CFAllocator *v85;
  std::__shared_weak_count *v86;
  unint64_t *v87;
  unint64_t v88;
  unint64_t v89;
  const void *v90;
  const __CFString *v91;
  const __CFString *v92;
  id v93;
  NSURLRequest *v94;
  const __CFAllocator *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  __CFError *CFError;
  CFTypeRef cf;
  CFStringRef theString;
  uint64_t v104;
  uint64_t (*v105)(uint64_t, uint64_t);
  void *v106;
  _CFURLResponse *v107;
  _BYTE v108[12];
  __int16 v109;
  uint64_t v110;
  _BYTE buf[24];
  const __CFData *v112;
  __int128 v113;
  uint64_t v114;

  v114 = *MEMORY[0x1E0C80C00];
  v1 = *((_QWORD *)a1 + 4);
  if (*(_BYTE *)(v1 + 128))
    return;
  v2 = (_CFURLResponse *)*((_QWORD *)a1 + 6);
  v3 = (const __CFData *)*((_QWORD *)a1 + 8);
  v4 = (AppSSO *)*((_QWORD *)a1 + 10);
  AppSSO::AppSSOProtocolLog(a1);
  v5 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134218754;
    *(_QWORD *)&buf[4] = v1;
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = v2;
    *(_WORD *)&buf[22] = 2112;
    v112 = v3;
    LOWORD(v113) = 2112;
    *(_QWORD *)((char *)&v113 + 2) = v4;
    _os_log_impl(&dword_183ECA000, v5, OS_LOG_TYPE_DEFAULT, "%p Handling auth response %@ data %@ error %@", buf, 0x2Au);
  }

  if (v2 && !v4)
  {
    v7 = *(_QWORD *)(-[_CFURLResponse _inner](v2, "_inner") + 88);
    if (v7)
      v8 = v7 - 16;
    else
      v8 = 0;
    if (v7)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (!*(_BYTE *)(v8 + 40))
      {
LABEL_55:
        v50 = MEMORY[0x1E0C809B0];
        theString = (CFStringRef)MEMORY[0x1E0C809B0];
        v104 = 3221225472;
        v105 = ___ZN11URLProtocol22sendDidReceiveResponseEP14_CFURLResponse_block_invoke;
        v106 = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
        v107 = v2;
        v51 = &theString;
        v52 = *(_QWORD *)(v1 + 96);
        if (v52)
        {
          v53 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v52 + 16))(*(_QWORD *)(v1 + 96));
          v54 = (void *)MEMORY[0x186DB8C8C](v53);
          v105((uint64_t)v51, *(_QWORD *)(v1 + 96));
          objc_autoreleasePoolPop(v54);
          (*(void (**)(uint64_t))(*(_QWORD *)v52 + 24))(v52);
        }

        AppSSO::AppSSOProtocolLog(v55);
        v56 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          v57 = *(_QWORD *)(v1 + 112);
          *(_DWORD *)buf = 134218242;
          *(_QWORD *)&buf[4] = v1;
          *(_WORD *)&buf[12] = 2114;
          *(_QWORD *)&buf[14] = v57;
          _os_log_impl(&dword_183ECA000, v56, OS_LOG_TYPE_DEFAULT, "%p sent response %{public}@", buf, 0x16u);
        }

        if (v3)
        {
          Length = CFDataGetLength(v3);
          v59 = *(Throttler **)(v1 + 64);
          if (v59)
          {
            v60 = CFDataGetLength(v3);
            Throttler::noteOutstandingBytes(v59, v60);
          }
          *(_QWORD *)buf = v50;
          *(_QWORD *)&buf[8] = 3221225472;
          *(_QWORD *)&buf[16] = ___ZN11URLProtocol15sendDidLoadDataEPK8__CFDatax_block_invoke;
          v112 = (const __CFData *)&__block_descriptor_48_e31_v16__0__URLProtocolClient_____8l;
          *(_QWORD *)&v113 = v3;
          *((_QWORD *)&v113 + 1) = Length;
          v61 = buf;
          v62 = *(_QWORD *)(v1 + 96);
          if (v62)
          {
            v63 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v62 + 16))(*(_QWORD *)(v1 + 96));
            v64 = (void *)MEMORY[0x186DB8C8C](v63);
            (*(void (**)(_BYTE *, _QWORD))&buf[16])(v61, *(_QWORD *)(v1 + 96));
            objc_autoreleasePoolPop(v64);
            (*(void (**)(uint64_t))(*(_QWORD *)v62 + 24))(v62);
          }

          AppSSO::AppSSOProtocolLog(v65);
          v66 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
          {
            v67 = *(_QWORD *)(v1 + 112);
            *(_DWORD *)v108 = 134218242;
            *(_QWORD *)&v108[4] = v1;
            v109 = 2114;
            v110 = v67;
            _os_log_impl(&dword_183ECA000, v66, OS_LOG_TYPE_DEFAULT, "%p sent data %{public}@", v108, 0x16u);
          }

        }
        URLProtocol::sendDidFinishLoading((URLProtocol *)v1);
        return;
      }
      v9 = HTTPResponseMessage::copyCookiesStrings((os_unfair_lock_s *)(v8 + 16));
      if (!v9)
      {
LABEL_46:
        v34 = *(_DWORD *)(v8 + 144) - 301;
        v35 = v34 > 7;
        v36 = (1 << v34) & 0xC3;
        if (!v35 && v36 != 0)
        {
          *(_QWORD *)v108 = 0;
          HeaderFieldValue = HTTPMessage::copyLastHeaderFieldValue((HTTPMessage *)(v8 + 16), 0x12E1132Au);
          theString = HeaderFieldValue;
          v39 = (_QWORD *)operator new();
          *v39 = &off_1E14F19E8;
          v39[1] = 0;
          v39[2] = 0;
          v39[3] = HeaderFieldValue;
          v104 = (uint64_t)v39;
          v40 = (AppSSO *)theString;
          if (!theString || (v40 = (AppSSO *)CFStringGetLength(theString)) == 0)
          {
            AppSSO::AppSSOProtocolLog(v40);
            v68 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
            {
              v82 = *(_QWORD *)(v1 + 112);
              *(_DWORD *)buf = 134218242;
              *(_QWORD *)&buf[4] = v1;
              *(_WORD *)&buf[12] = 2114;
              *(_QWORD *)&buf[14] = v82;
              _os_log_error_impl(&dword_183ECA000, v68, OS_LOG_TYPE_ERROR, "%p failed to get valid location header %{public}@", buf, 0x16u);
            }

            goto LABEL_71;
          }
          cf = (CFTypeRef)(v1 - 16);
          v41 = CFGetAllocator((CFTypeRef)(v1 - 16));
          v42 = CFURLCreateStringByAddingPercentEscapes(v41, theString, CFSTR("%#?:;/@=&[]"), 0, 0x201u);
          v43 = (std::__shared_weak_count *)operator new();
          v43->__shared_owners_ = 0;
          p_shared_owners = (unint64_t *)&v43->__shared_owners_;
          v43->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19E8;
          v43->__shared_weak_owners_ = 0;
          v43[1].__vftable = (std::__shared_weak_count_vtbl *)v42;
          std::shared_ptr<__CFString const>::operator=[abi:nn180100](&theString, (uint64_t)v42, (uint64_t)v43);
          if (!theString)
          {
            do
LABEL_91:
              v89 = __ldaxr(p_shared_owners);
            while (__stlxr(v89 - 1, p_shared_owners));
            if (!v89)
            {
              ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
              std::__shared_weak_count::__release_weak(v43);
            }
            v90 = *(const void **)v108;
            if (*(_QWORD *)v108)
            {
              v75 = CFURLCopyAbsoluteURL(*(CFURLRef *)v108);
              CFRelease(v90);
              v91 = CFURLCopyScheme(v75);
              v92 = v91;
              if (v91 && CFStringCompare(v91, CFSTR("file"), 1uLL) == kCFCompareEqualTo)
              {
                v95 = CFGetAllocator(cf);
                CFError = __cfnCreateCFError(v95, CFSTR("kCFErrorDomainCFNetwork"), -1102, v96, v97, v98, v99, v100, 0);
                URLProtocol::sendDidFail((URLProtocol *)v1, CFError);
                if (CFError)
                  CFRelease(CFError);
              }
              else
              {
                v93 = *(id *)(v1 + 88);
                v94 = (NSURLRequest *)objc_msgSend(v93, "_copyReplacingURLWithURL:", v75);

                URLProtocol::sendWasRedirected((URLProtocol *)v1, v94, v2);
                URLProtocol::sendDidFinishLoading((URLProtocol *)v1);

                if (!v92)
                  goto LABEL_72;
              }
              CFRelease(v92);
LABEL_72:
              if (v75)
                CFRelease(v75);
              v76 = (std::__shared_weak_count *)v104;
              if (v104)
              {
                v77 = (unint64_t *)(v104 + 8);
                do
                  v78 = __ldaxr(v77);
                while (__stlxr(v78 - 1, v77));
                if (!v78)
                {
                  ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
                  std::__shared_weak_count::__release_weak(v76);
                }
              }
              return;
            }
LABEL_71:
            v69 = CFGetAllocator((CFTypeRef)(v1 - 16));
            v75 = __cfnCreateCFError(v69, CFSTR("kCFErrorDomainCFNetwork"), -1010, v70, v71, v72, v73, v74, 0);
            URLProtocol::sendDidFail((URLProtocol *)v1, v75);
            goto LABEL_72;
          }
          objc_msgSend(*(id *)(v1 + 80), "originalRequest");
          v45 = (NSURLRequest *)objc_claimAutoreleasedReturnValue();
          v46 = CFGetAllocator(cf);
          v47 = theString;
          v48 = *(id *)(v1 + 88);
          v49 = CFURLCreateWithString(v46, v47, (CFURLRef)objc_msgSend(v48, "cfURL"));

          if (v49)
          {
            *(_QWORD *)v108 = CFURLCopyAbsoluteURL(v49);
            _ApplyOriginalComponents(v45, (CFTypeRef *)v108);
            CFRelease(v49);
            goto LABEL_85;
          }
          v79 = CFStringGetLength(theString);
          v80 = (char *)malloc_type_malloc(v79 + 1, 0x2572FBAFuLL);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 3221225472;
          *(_QWORD *)&buf[16] = ___ZN14AppSSOProtocol27handleAuthorizationResponseEP14_CFURLResponsePK8__CFDataP9__CFError_block_invoke;
          v112 = (const __CFData *)&__block_descriptor_40_e5_v8__0l;
          *(_QWORD *)&v113 = v80;
          if (CFStringGetCString(theString, v80, v79 + 1, 0x201u))
          {
            v81 = 513;
          }
          else
          {
            if (!CFStringGetCString(theString, v80, v79 + 1, 0x8000100u))
            {
LABEL_84:
              (*(void (**)(_BYTE *))&buf[16])(buf);
LABEL_85:
              v86 = (std::__shared_weak_count *)v104;
              theString = 0;
              v104 = 0;
              if (v86)
              {
                v87 = (unint64_t *)&v86->__shared_owners_;
                do
                  v88 = __ldaxr(v87);
                while (__stlxr(v88 - 1, v87));
                if (!v88)
                {
                  ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
                  std::__shared_weak_count::__release_weak(v86);
                }
              }

              goto LABEL_91;
            }
            v81 = 134217984;
          }
          v83 = *(id *)(v1 + 88);
          v84 = (const __CFURL *)objc_msgSend(v83, "cfURL");

          v85 = CFGetAllocator(cf);
          *(_QWORD *)v108 = CFURLCreateAbsoluteURLWithBytes(v85, (const UInt8 *)v80, v79, v81, v84, 0);
          _ApplyOriginalComponents(v45, (CFTypeRef *)v108);
          goto LABEL_84;
        }
        goto LABEL_55;
      }
      v10 = *(void **)(v1 + 88);
      if (!v10
        || !objc_msgSend(*(id *)(v1 + 80), "shouldHandleCookiesAndSchemeIsAppropriate")
        || !*(_QWORD *)(objc_msgSend(v10, "_inner") + 8))
      {
LABEL_45:
        CFRelease(v9);
        goto LABEL_46;
      }
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 3221225472;
      *(_QWORD *)&buf[16] = ___ZN14AppSSOProtocol24handleCookiesForResponseEP19HTTPResponseMessage_block_invoke;
      v112 = (const __CFData *)&__block_descriptor_40_e5_v8__0l;
      *(_QWORD *)&v113 = 0;
      v11 = *(_QWORD *)(objc_msgSend(v10, "_inner") + 56);
      if (v11 && (v12 = *(void **)(v11 + 192)) != 0)
      {
        v13 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 40, 0);
        v13[4] = 0;
        *(_OWORD *)v13 = 0u;
        *((_OWORD *)v13 + 1) = 0u;
        CFXCookieStorage::CFXCookieStorage((CFXCookieStorage *)v13, v12);
      }
      else
      {
        v31 = *(id *)(v1 + 80);
        if (!v31)
          goto LABEL_44;
        v32 = v31;
        v13 = (_QWORD *)objc_msgSend(*(id *)(v1 + 80), "_createXCookieStorage");

        if (!v13)
          goto LABEL_44;
      }
      (*(void (**)(_QWORD *, CFArrayRef, _QWORD))(*v13 + 64))(v13, v9, *(_QWORD *)(v1 + 80));
LABEL_44:
      (*(void (**)(_BYTE *))&buf[16])(buf);
      goto LABEL_45;
    }
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v22 = (id)CFNLog::logger;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      v33 = *(_QWORD *)(v1 + 112);
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = v33;
      _os_log_error_impl(&dword_183ECA000, v22, OS_LOG_TYPE_ERROR, "%{public}@ AppSSOProtocol did not receive HTTP response", buf, 0xCu);
    }

    v23 = CFGetAllocator((CFTypeRef)(v1 - 16));
    Mutable = __cfnCreateCFError(v23, CFSTR("kCFErrorDomainCFNetwork"), -1011, v24, v25, v26, v27, v28, 0);
    URLProtocol::sendDidFail((URLProtocol *)v1, Mutable);
    goto LABEL_39;
  }
  isPerformDefaultHandlingError = (AppSSO *)AppSSO::isPerformDefaultHandlingError(v4, v6);
  if (!(_DWORD)isPerformDefaultHandlingError)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v19 = (id)CFNLog::logger;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v30 = *(_QWORD *)(v1 + 112);
      *(_DWORD *)buf = 138543874;
      *(_QWORD *)&buf[4] = v30;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = v2;
      *(_WORD *)&buf[22] = 2112;
      v112 = v4;
      _os_log_error_impl(&dword_183ECA000, v19, OS_LOG_TYPE_ERROR, "%{public}@ AppSSOProtocol received response %@ error %@ canceling", buf, 0x20u);
    }

    v20 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (v4)
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CB3388], v4);
    }
    else
    {
      Mutable = 0;
    }
    v29 = CFErrorCreate(v20, CFSTR("kCFErrorDomainCFNetwork"), -1012, Mutable);
    URLProtocol::sendDidFail((URLProtocol *)v1, v29);
    if (v29)
      CFRelease(v29);
LABEL_39:
    if (Mutable)
      CFRelease(Mutable);
    return;
  }
  AppSSO::AppSSOProtocolLog(isPerformDefaultHandlingError);
  v15 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    v16 = *(_QWORD *)(v1 + 112);
    *(_DWORD *)buf = 138543362;
    *(_QWORD *)&buf[4] = v16;
    _os_log_impl(&dword_183ECA000, v15, OS_LOG_TYPE_DEFAULT, "Performing default handling for %{public}@", buf, 0xCu);
  }

  v17 = *(id *)(v1 + 80);
  objc_msgSend(v17, "set_preventsAppSSO:", 1);
  objc_msgSend(v17, "set_appSSOFallback:", 1);
  objc_msgSend(v17, "currentRequest");
  v18 = (NSURLRequest *)objc_claimAutoreleasedReturnValue();
  URLProtocol::sendWasRedirected((URLProtocol *)v1, v18, 0);

}

void sub_18400B658(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23)
{
  const void *v23;
  const void *v24;
  const void *v25;
  unint64_t *p_shared_owners;
  unint64_t v28;

  if (v23)
    CFRelease(v23);
  CFRelease(v25);
  if (v24)
    CFRelease(v24);
  if (a12)
  {
    p_shared_owners = (unint64_t *)&a12->__shared_owners_;
    do
      v28 = __ldaxr(p_shared_owners);
    while (__stlxr(v28 - 1, p_shared_owners));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
    }
  }
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_ea8_32c42_ZTSNSt3__110shared_ptrI14AppSSOProtocolEE48c42_ZTSNSt3__110shared_ptrI14_CFURLResponseEE64c36_ZTSNSt3__110shared_ptrIK8__CFDataEE80c36_ZTSNSt3__110shared_ptrI9__CFErrorEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = a2[9];
  result[8] = a2[8];
  result[9] = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v11 = a2[11];
  result[10] = a2[10];
  result[11] = v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c42_ZTSNSt3__110shared_ptrI14AppSSOProtocolEE48c42_ZTSNSt3__110shared_ptrI14_CFURLResponseEE64c36_ZTSNSt3__110shared_ptrIK8__CFDataEE80c36_ZTSNSt3__110shared_ptrI9__CFErrorEE(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = a1 + 32;
  v2 = a1 + 48;
  v3 = a1 + 64;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 80);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void _ApplyOriginalComponents(NSURLRequest *a1, CFTypeRef *a2)
{
  NSURLRequest *v3;
  NSURLRequest *v4;
  CFTypeRef v5;
  uint64_t v6;
  BOOL v7;
  int v8;
  const void *v9;
  int32x4_t v10;
  int64x2_t v11;
  const __CFString *v12;
  CFStringRef theString2[4];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  CFStringRef theString1[4];
  __int128 v18;
  __int128 v19;
  CFTypeRef cf[2];

  v3 = a1;
  v4 = v3;
  if (!v3)
    goto LABEL_28;
  v5 = *a2;
  v6 = -[NSURLRequest cfURL](v3, "cfURL");
  if (!v5 || !v6)
    goto LABEL_28;
  v19 = 0u;
  *(_OWORD *)cf = 0u;
  v18 = 0u;
  v16 = 0u;
  memset(theString1, 0, sizeof(theString1));
  v14 = 0u;
  v15 = 0u;
  memset(theString2, 0, sizeof(theString2));
  if (_CFURLCopyComponents() && _CFURLCopyComponents())
  {
    if (cf[0])
      v7 = (_QWORD)v16 == 0;
    else
      v7 = 0;
    v8 = v7;
    if (v7)
      *(_QWORD *)&v16 = CFRetain(cf[0]);
    if (theString1[0])
    {
      if (theString2[0])
      {
        if (theString1[3])
        {
          if (theString2[3])
          {
            if (CFStringCompare(theString1[0], theString2[0], 1uLL) == kCFCompareEqualTo
              && CFStringCompare(theString1[3], theString2[3], 1uLL) == kCFCompareEqualTo)
            {
              v10 = (int32x4_t)vtstq_s64(*(int64x2_t *)&theString1[1], *(int64x2_t *)&theString1[1]);
              *(int32x2_t *)v10.i8 = vmovn_s64((int64x2_t)v10);
              v10.i32[0] = vmovn_s32(v10).u32[0];
              v11 = vceqzq_s64(*(int64x2_t *)&theString2[1]);
              v10.i32[1] = vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v11, v11)).i32[1];
              if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(*(int16x4_t *)v10.i8, 0xFuLL))) & 1) != 0
                && (_QWORD)v18 == (_QWORD)v14)
              {
                theString2[1] = (CFStringRef)CFRetain(theString1[1]);
                v12 = theString1[2];
                if (theString1[2])
                  v12 = (const __CFString *)CFRetain(theString1[2]);
                theString2[2] = v12;
                goto LABEL_22;
              }
            }
          }
        }
      }
    }
    if (v8)
    {
LABEL_22:
      v9 = (const void *)_CFURLCreateFromComponents();
      goto LABEL_24;
    }
  }
  v9 = 0;
LABEL_24:
  _CreateURLWithAddedComponentsIfNeeded(__CFURL const*,__CFURL const*)::ComponentsWrapper::~ComponentsWrapper((uint64_t)theString2);
  _CreateURLWithAddedComponentsIfNeeded(__CFURL const*,__CFURL const*)::ComponentsWrapper::~ComponentsWrapper((uint64_t)theString1);
  if (v9)
  {
    CFRetain(v9);
    if (*a2)
      CFRelease(*a2);
    *a2 = v9;
    CFRelease(v9);
  }
LABEL_28:

}

void sub_18400BAAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  void *v19;
  const void *v20;

  CFRelease(v20);

  _Unwind_Resume(a1);
}

void ___ZN14AppSSOProtocol27handleAuthorizationResponseEP14_CFURLResponsePK8__CFDataP9__CFError_block_invoke(uint64_t a1)
{
  free(*(void **)(a1 + 32));
}

void URLProtocol::sendWasRedirected(URLProtocol *this, NSURLRequest *a2, _CFURLResponse *a3)
{
  NSURLRequest *v5;
  NSURLRequest *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  _QWORD v11[2];
  uint64_t (*v12)(uint64_t, uint64_t);
  void *v13;
  NSURLRequest *v14;
  _CFURLResponse *v15;

  v5 = a2;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v12 = ___ZN11URLProtocol17sendWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke;
  v13 = &unk_1E14FB070;
  v6 = v5;
  v14 = v6;
  v15 = a3;
  v7 = v11;
  v8 = *((_QWORD *)this + 12);
  if (v8)
  {
    v9 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v8 + 16))(*((_QWORD *)this + 12));
    v10 = (void *)MEMORY[0x186DB8C8C](v9);
    v12((uint64_t)v7, *((_QWORD *)this + 12));
    objc_autoreleasePoolPop(v10);
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
  }

}

void sub_18400BBC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

uint64_t ___ZN11URLProtocol22sendDidReceiveResponseEP14_CFURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 64))(a2, *(_QWORD *)(a1 + 32));
}

uint64_t ___ZN11URLProtocol15sendDidLoadDataEPK8__CFDatax_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

uint64_t ___ZN11URLProtocol17sendWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 40))(a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

uint64_t _CreateURLWithAddedComponentsIfNeeded(__CFURL const*,__CFURL const*)::ComponentsWrapper::~ComponentsWrapper(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;

  v2 = *(const void **)a1;
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 8);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 16);
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(a1 + 24);
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)(a1 + 40);
  if (v6)
    CFRelease(v6);
  v7 = *(const void **)(a1 + 48);
  if (v7)
    CFRelease(v7);
  v8 = *(const void **)(a1 + 56);
  if (v8)
    CFRelease(v8);
  v9 = *(const void **)(a1 + 64);
  if (v9)
    CFRelease(v9);
  v10 = *(const void **)(a1 + 72);
  if (v10)
    CFRelease(v10);
  return a1;
}

uint64_t ___ZN14AppSSOProtocol24handleCookiesForResponseEP19HTTPResponseMessage_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

void std::__shared_ptr_pointer<__CFData const*,Deleter_CFRelease,std::allocator<__CFData const>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<__CFError *,Deleter_CFRelease,std::allocator<__CFError>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<_CFURLResponse *,Deleter_CFRelease,std::allocator<_CFURLResponse>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<_CFURLResponse *,Deleter_CFRelease,std::allocator<_CFURLResponse>>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 24);
  if (v1)
    CFRelease(v1);
}

void std::__shared_ptr_pointer<AppSSOProtocol *,Deleter_release<AppSSOProtocol>,std::allocator<AppSSOProtocol>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<AppSSOProtocol *,Deleter_release<AppSSOProtocol>,std::allocator<AppSSOProtocol>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
    CFRelease((CFTypeRef)(v1 - 16));
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_2239()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  *(_DWORD *)((char *)_PNAME<URLProtocol>::GET(void)::p + 7) = 1819239279;
  _PNAME<URLProtocol>::GET(void)::p[0] = *(_QWORD *)"URLProtocol>::GET() [OBJTYPE = URLProtocol]";
  CFClass::CFClass(v0, (const char *)_PNAME<URLProtocol>::GET(void)::p);
  TCFObject<URLProtocol>::Class(void)::clazz = (uint64_t)v0;
}

void sub_18400BDFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t CFURLAuthChallengeGetProtectionSpace(uint64_t a1)
{
  uint64_t v2;

  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  return *(_QWORD *)(v2 + 24);
}

uint64_t CFURLAuthChallengeGetProposedCredential(uint64_t a1)
{
  uint64_t v2;

  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  return *(_QWORD *)(v2 + 32);
}

uint64_t CFURLAuthChallengeGetPreviousFailureCount(uint64_t a1)
{
  uint64_t v2;

  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  return *(_QWORD *)(v2 + 40);
}

uint64_t CFURLAuthChallengeGetError(uint64_t a1)
{
  uint64_t v2;

  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  return *(_QWORD *)(v2 + 56);
}

uint64_t CFURLAuthChallengeGetFailureResponse(uint64_t a1)
{
  uint64_t v2;

  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  return *(_QWORD *)(v2 + 48);
}

uint64_t Archiver<URLAuthChallenge,_CFURLAuthChallenge *>::~Archiver(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 8);
  if (v2)
    CFRelease(v2);
  return a1;
}

void Archiver<URLAuthChallenge,_CFURLAuthChallenge *>::~Archiver(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 8);
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t _CFURLAuthChallengeCreateFromArchive(const __CFAllocator *a1, CFTypeRef cf)
{
  CFTypeRef v3;
  uint64_t Instance;
  CFTypeRef cfa[3];

  cfa[1] = a1;
  if (cf)
    v3 = CFRetain(cf);
  else
    v3 = 0;
  cfa[0] = v3;
  cfa[2] = a1;
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3745];
  *(_QWORD *)(Instance + 16) = &off_1E14E8348;
  *(_QWORD *)(Instance + 24) = &unk_1E14E83A0;
  if (!URLAuthChallenge::initializeFromPropertyList((URLAuthChallenge *)(Instance + 16), (CFDictionaryRef *)cfa))
  {
    CFRelease((CFTypeRef)Instance);
    Instance = 0;
  }
  if (cfa[0])
    CFRelease(cfa[0]);
  return Instance;
}

void sub_18400C120(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t Dearchiver<URLAuthChallenge,_CFURLAuthChallenge *>::~Dearchiver(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 8);
  if (v2)
    CFRelease(v2);
  return a1;
}

void Dearchiver<URLAuthChallenge,_CFURLAuthChallenge *>::~Dearchiver(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 8);
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t CFHTTPCookieGetTypeID()
{
  if (CFHTTPCookieGetTypeID::sOnce != -1)
    dispatch_once(&CFHTTPCookieGetTypeID::sOnce, &__block_literal_global_2262);
  return CFHTTPCookieGetTypeID::sResult;
}

CFArrayRef _CFHTTPParsedCookiesWithResponseHeaderFields(const __CFAllocator *a1, CFDictionaryRef theDict, const __CFURL *a3)
{
  const void *Value;
  __CFArray *Array;
  __CFArray *CookiesWithCookieStrings;

  Value = CFDictionaryGetValue(theDict, &unk_1EDCFD660);
  if (!Value)
    return CFArrayCreate(a1, 0, 0, MEMORY[0x1E0C9B378]);
  Array = cfTypeCreateArray(a1, Value, 0, 0, 0);
  CookiesWithCookieStrings = _createCookiesWithCookieStrings(a1, Array, a3, 0, 1);
  if (Array)
    CFRelease(Array);
  if (CookiesWithCookieStrings)
    return CookiesWithCookieStrings;
  else
    return CFArrayCreate(a1, 0, 0, MEMORY[0x1E0C9B378]);
}

void sub_18400C37C(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

CFArrayRef _CFHTTPCookieCreateCookiesWithResponseMessage(CFAllocatorRef allocator, uint64_t a2, const __CFURL *a3, const void *a4)
{
  os_unfair_lock_s *v8;
  const __CFArray *v9;
  const __CFArray *v10;
  __CFArray *CookiesWithCookieStrings;

  if (a2)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v8 = *(_BYTE *)(a2 + 40) ? (os_unfair_lock_s *)(a2 + 16) : 0;
    v9 = HTTPResponseMessage::copyCookiesStrings(v8);
    if (v9)
    {
      v10 = v9;
      if (CFArrayGetCount(v9) <= 0)
      {
        CFRelease(v10);
      }
      else
      {
        CookiesWithCookieStrings = _createCookiesWithCookieStrings(allocator, v10, a3, a4, 1);
        CFRelease(v10);
        if (CookiesWithCookieStrings)
          return CookiesWithCookieStrings;
      }
    }
  }
  return CFArrayCreate(allocator, 0, 0, MEMORY[0x1E0C9B378]);
}

id CFHTTPCookieCreateWithProperties(uint64_t a1, uint64_t a2)
{
  return -[NSHTTPCookie _initWithProperties:fromString:]([NSHTTPCookie alloc], "_initWithProperties:fromString:", a2, 0);
}

uint64_t CFHTTPCookieCopyProperties(void *a1)
{
  uint64_t v1;

  v1 = objc_msgSend(a1, "_inner");
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 40))(v1);
}

uint64_t CFHTTPCookieIsHTTPOnly(void *a1)
{
  uint64_t v1;
  _DWORD *v2;

  v1 = objc_msgSend(a1, "_inner");
  v2 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 16))(v1);
  if (*v2 >= 0xCu)
    return (v2[2] >> 2) & 1;
  else
    return 0;
}

uint64_t CFHTTPCookieGetFlags(void *a1)
{
  uint64_t v1;
  _DWORD *v2;

  v1 = objc_msgSend(a1, "_inner");
  v2 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 16))(v1);
  if (*v2 >= 0xCu)
    return v2[2] & 0x7F;
  else
    return 0;
}

uint64_t CFHTTPCookieIsSecure(void *a1)
{
  uint64_t v1;
  _DWORD *v2;

  v1 = objc_msgSend(a1, "_inner");
  v2 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 16))(v1);
  if (*v2 >= 0xCu)
    return v2[2] & 1;
  else
    return 0;
}

double CFHTTPCookieGetExpirationTime(void *a1)
{
  uint64_t v2;
  uint64_t v3;

  if (CFHTTPCookieGetExpirationTime::sOnce != -1)
    dispatch_once(&CFHTTPCookieGetExpirationTime::sOnce, &__block_literal_global_16);
  v2 = objc_msgSend(a1, "_inner");
  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  if (*(_DWORD *)v3 >= 0xCu && (*(_DWORD *)(v3 + 8) & 2) != 0 || *(_DWORD *)v3 < 0x30u)
    return 0.0;
  else
    return floor(*(double *)(v3 + 40));
}

void CookieHostName::~CookieHostName(CookieHostName *this)
{
  char *v2;

  *(_QWORD *)this = &off_1E14E6B50;
  v2 = (char *)*((_QWORD *)this + 35);
  if (v2 != (char *)this + 24)
    free(v2);
}

{
  char *v2;

  *(_QWORD *)this = &off_1E14E6B50;
  v2 = (char *)*((_QWORD *)this + 35);
  if (v2 != (char *)this + 24)
    free(v2);
  JUMPOUT(0x186DB748CLL);
}

uint64_t formSetProperty(__CFReadStream *a1, CFTypeRef cf1, const __CFNumber *a3, _QWORD *a4)
{
  uint64_t result;
  uint64_t valuePtr;

  result = CFEqual(cf1, (CFTypeRef)*MEMORY[0x1E0C9B2B0]);
  if ((_DWORD)result)
  {
    valuePtr = 0;
    CFNumberGetValue(a3, kCFNumberSInt64Type, &valuePtr);
    a4[6] = valuePtr;
    return 1;
  }
  return result;
}

uint64_t formUnschedule(__CFReadStream *a1, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode, _QWORD *a4)
{
  __CFReadStream *v7;
  uint64_t result;

  v7 = (__CFReadStream *)a4[2];
  if (v7)
    CFReadStreamUnscheduleFromRunLoop(v7, runLoop, runLoopMode);
  result = (*(uint64_t (**)(_QWORD, CFRunLoopRef, CFRunLoopMode))(*(_QWORD *)*a4 + 64))(*a4, runLoop, runLoopMode);
  *a4 = result;
  return result;
}

void ___ZN12__CFURLCacheD2Ev_block_invoke(uint64_t a1)
{

}

uint64_t std::deque<__CFURLCacheNode *>::~deque[abi:nn180100](uint64_t a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(void ***)(a1 + 8);
  v3 = *(void ***)(a1 + 16);
  *(_QWORD *)(a1 + 40) = 0;
  v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = *(void ***)(a1 + 16);
      v2 = (void **)(*(_QWORD *)(a1 + 8) + 8);
      *(_QWORD *)(a1 + 8) = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v5 = v4 >> 3;
  if (v5 == 1)
  {
    v6 = 256;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    v6 = 512;
LABEL_7:
    *(_QWORD *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    v9 = *(_QWORD *)(a1 + 8);
    v8 = *(_QWORD *)(a1 + 16);
    if (v8 != v9)
      *(_QWORD *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_2382(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

BOOL _CFURLCacheEqual(_QWORD *a1, _QWORD *a2)
{
  return a1[2] == a2[2];
}

uint64_t _CFURLCacheHash(_QWORD *a1)
{
  return *(_QWORD *)(a1[2] + 208);
}

CFStringRef _CFURLCacheCopyDescription(const void *a1)
{
  const __CFAllocator *v2;
  CFAllocatorRef v3;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFURLCache %p [%p]>"), a1, v3);
}

BOOL _CFCachedURLResponseEqual(_QWORD *a1, _QWORD *a2)
{
  return a1[2] == a2[2];
}

uint64_t _CFCachedURLResponseHash(_QWORD *a1)
{
  return *(_QWORD *)(a1[2] + 64);
}

CFStringRef _CFCachedURLResponseCopyDescription(const void *a1)
{
  const __CFAllocator *v2;
  CFAllocatorRef v3;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFCachedURLResponse %p [%p]>"), a1, v3);
}

void ___ZN12__CFURLCache13AddCacheTask0ERNSt3__110unique_ptrI16__CFURLCacheNodeNS0_14default_deleteIS2_EEEE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  id v3;
  const char *v4;
  __CFString *v5;
  char *v6;
  _BYTE *v7;
  _QWORD *v8;
  sqlite3_int64 v9;
  const __CFAllocator *v10;
  const char *v11;
  CFStringRef v12;
  const __CFString *Property;
  CFURLCacheFS *FS2;
  CFURLCacheFS *v15;
  const __CFString *v16;
  const __CFString *v17;
  char *v18;
  int v19;
  void *v20;
  NSObject *v21;
  const char *v22;
  void *v23;
  double v24;
  int v25;
  int v26;
  int v27;
  int v28;
  NSObject *log;
  char *v30;
  const __CFString *cf;
  BOOL v32;
  BOOL v33;
  uint8_t buf[4];
  char *v35;
  __int16 v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  __retainStorageAssertion(*(void **)(a1 + 32));
  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(id *)(a1 + 48);
  if (!v2)
    goto LABEL_46;
  v32 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 28));
  if ((-[NSURLStorageURLCacheDB openAndPrepareWriteCacheDB_NoLock]((id)v2, v4) & 1) == 0)
  {
LABEL_45:
    os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 28));
    goto LABEL_46;
  }
  if (!v3)
  {
    -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
    -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
    -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
    goto LABEL_45;
  }
  v5 = (__CFString *)v3;
  v6 = _ExtractCStringfromCFStringRef(v5, &v32);
  if (!v6)
  {

LABEL_22:
    -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
    -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
    -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
    goto LABEL_45;
  }
  v7 = -[NSURLStorageURLCacheDB getEntryIDandReceiverDataForRequestKey:]((sqlite3_stmt **)v2, v6);
  v8 = v7;
  if (v7)
  {
    v9 = *(_QWORD *)v7;
    if (*(_QWORD *)v7)
    {
      if (v7[20])
      {
        v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v12 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *((const UInt8 **)v7 + 1), *((int *)v7 + 4), 0x8000100u, 0);
        if (v12)
        {
          Property = (const __CFString *)objc_getProperty((id)v2, v11, 160, 1);
          FS2 = _CFURLCacheCreateFS2(Property);
          v15 = FS2;
          if (FS2)
          {
            v16 = CFStringCreateWithFormat(v10, 0, CFSTR("%@/%@"), *((_QWORD *)FS2 + 10), v12);
            v17 = v16;
            if (v16)
            {
              v33 = 0;
              v18 = _ExtractCStringfromCFStringRef(v16, &v33);
              cf = v17;
              if (v18)
              {
                v30 = v18;
                if (unlink(v18) == -1)
                {
                  if (CFNLog::onceToken != -1)
                    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
                  log = CFNLog::logger;
                  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
                  {
                    v28 = *__error();
                    *(_DWORD *)buf = 136315394;
                    v35 = v30;
                    v36 = 1024;
                    v37 = v28;
                    _os_log_error_impl(&dword_183ECA000, log, OS_LOG_TYPE_ERROR, "unlink of file %s failed.  Errno=%{errno}d", buf, 0x12u);
                  }
                  v19 = 0;
                }
                else
                {
                  v19 = 1;
                }
                if (v33)
                  MEMORY[0x186DB7474](v30, 0x1000C8077774924);
              }
              else
              {
                if (CFNLog::onceToken != -1)
                  dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
                v21 = CFNLog::logger;
                if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)buf = 0;
                  _os_log_error_impl(&dword_183ECA000, v21, OS_LOG_TYPE_ERROR, "purgeItemFromFileSystemStoreForKey - unable to determine path to file for unlink.", buf, 2u);
                }
                v19 = 0;
              }
              CFRelease(cf);
              if (v19)
                -[NSURLStorageURLCacheDB updateFSBackedCacheUsageOnDisk]((_QWORD *)v2, v22);
            }
            (*(void (**)(CFURLCacheFS *))(*(_QWORD *)v15 + 8))(v15);
          }
          CFRelease(v12);
        }
      }
      v23 = (void *)v8[1];
      if (v23)
        free(v23);
      free(v8);
      sqlite3_reset(*(sqlite3_stmt **)(v2 + 96));
      if (sqlite3_bind_int64(*(sqlite3_stmt **)(v2 + 112), 1, v9))
      {
        if (v32)
          MEMORY[0x186DB7474](v6, 0x1000C8077774924);
LABEL_44:
        sqlite3_reset(*(sqlite3_stmt **)(v2 + 112));

        -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
        goto LABEL_45;
      }
      v25 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]((void *)v2, *(sqlite3_stmt **)(v2 + 112));
      if (v25 && v25 != 101)
      {
        if (v32)
          MEMORY[0x186DB7474](v6, 0x1000C8077774924);
        goto LABEL_44;
      }
      sqlite3_reset(*(sqlite3_stmt **)(v2 + 112));
      if (sqlite3_bind_int64(*(sqlite3_stmt **)(v2 + 120), 1, v9))
      {
        if (v32)
          MEMORY[0x186DB7474](v6, 0x1000C8077774924);
LABEL_52:
        sqlite3_reset(*(sqlite3_stmt **)(v2 + 120));

        -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
        goto LABEL_45;
      }
      v26 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]((void *)v2, *(sqlite3_stmt **)(v2 + 120));
      if (v26 && v26 != 101)
      {
        if (v32)
          MEMORY[0x186DB7474](v6, 0x1000C8077774924);
        goto LABEL_52;
      }
      sqlite3_reset(*(sqlite3_stmt **)(v2 + 120));
      if (sqlite3_bind_int64(*(sqlite3_stmt **)(v2 + 128), 1, v9))
      {
        if (v32)
          MEMORY[0x186DB7474](v6, 0x1000C8077774924);
LABEL_61:
        sqlite3_reset(*(sqlite3_stmt **)(v2 + 128));

        -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
        goto LABEL_45;
      }
      v27 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]((void *)v2, *(sqlite3_stmt **)(v2 + 128));
      if (v27 && v27 != 101)
      {
        if (v32)
          MEMORY[0x186DB7474](v6, 0x1000C8077774924);
        goto LABEL_61;
      }
      sqlite3_reset(*(sqlite3_stmt **)(v2 + 128));

      if (v32)
        MEMORY[0x186DB7474](v6, 0x1000C8077774924);
      goto LABEL_22;
    }
  }
  if (v32)
    MEMORY[0x186DB7474](v6, 0x1000C8077774924);

  -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
  -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
  -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 28));
  if (v8)
  {
    v20 = (void *)v8[1];
    if (v20)
      free(v20);
    free(v8);
  }
LABEL_46:

  __releaseStorageAssertion(v24);
}

void sub_18400D144(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZN12__CFURLCache13logCacheEventE19CFURLCacheEventTypePK13_CFURLRequest_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 32);
  if (v2)
    (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(v2 + 16))(v2, *(unsigned int *)(a1 + 56), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), 0);
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 48);
  if (v4)
    CFRelease(v4);
}

_QWORD *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,__CFURLCacheNode **,__CFURLCacheNode **,std::__deque_iterator<__CFURLCacheNode *,__CFURLCacheNode **,__CFURLCacheNode *&,__CFURLCacheNode ***,long,512l>,0>(_QWORD *result, _BYTE *__src, _BYTE *a3, _QWORD *a4, char *__dst)
{
  _QWORD *v6;
  _QWORD *v8;
  _BYTE *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;

  v6 = a4;
  v8 = result;
  if (__src != a3)
  {
    v9 = __src;
    v10 = (char *)*a4;
    while (1)
    {
      v11 = v10 - __dst + 4096;
      if ((a3 - v9) >> 3 >= v11 >> 3)
        v12 = v11 >> 3;
      else
        v12 = (a3 - v9) >> 3;
      if (v12)
        result = memmove(__dst, v9, 8 * v12);
      v9 += 8 * v12;
      if (v9 == a3)
        break;
      v13 = (char *)v6[1];
      ++v6;
      v10 = v13;
      __dst = v13;
    }
    __dst += 8 * v12;
    if ((char *)(*v6 + 4096) == __dst)
    {
      v14 = (char *)v6[1];
      ++v6;
      __dst = v14;
    }
  }
  *v8 = a3;
  v8[1] = v6;
  v8[2] = __dst;
  return result;
}

_QWORD *std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<__CFURLCacheNode **,std::__deque_iterator<__CFURLCacheNode *,__CFURLCacheNode **,__CFURLCacheNode *&,__CFURLCacheNode ***,long,512l>,0>(_QWORD *result, char *a2, char *a3, _QWORD *a4, char *a5)
{
  _QWORD *v6;
  _QWORD *v8;
  char *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;

  v6 = a4;
  v8 = result;
  if (a2 == a3)
  {
    v9 = a2;
  }
  else
  {
    v9 = a3;
    v10 = *a4;
    v11 = a3;
    while (1)
    {
      v12 = (uint64_t)&a5[-v10];
      if ((v11 - a2) >> 3 >= v12 >> 3)
        v13 = v12 >> 3;
      else
        v13 = (v11 - a2) >> 3;
      v11 -= 8 * v13;
      a5 -= 8 * v13;
      if (v13)
        result = memmove(a5, v11, 8 * v13);
      if (v11 == a2)
        break;
      v14 = *--v6;
      v10 = v14;
      a5 = (char *)(v14 + 4096);
    }
    if ((char *)(*v6 + 4096) == a5)
    {
      v15 = (char *)v6[1];
      ++v6;
      a5 = v15;
    }
  }
  *v8 = v9;
  v8[1] = v6;
  v8[2] = a5;
  return result;
}

void std::__split_buffer<__CFURLCacheNode **>::push_front(uint64_t a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  _BYTE *v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;

  v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    v6 = *(_BYTE **)(a1 + 16);
    v7 = *(_BYTE **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4)
        v11 = 1;
      else
        v11 = (v7 - v4) >> 2;
      v12 = 2 * v11;
      v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v11);
      v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      v15 = *(uint64_t **)(a1 + 8);
      v16 = v5;
      v17 = *(_QWORD *)(a1 + 16) - (_QWORD)v15;
      if (v17)
      {
        v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        v18 = 8 * (v17 >> 3);
        v19 = v5;
        do
        {
          v20 = *v15++;
          *(_QWORD *)v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      v21 = *(char **)a1;
      *(_QWORD *)a1 = v13;
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = v16;
      *(_QWORD *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      v8 = (v7 - v6) >> 3;
      if (v8 >= -1)
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v9 >> 1;
      v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        v4 = *(char **)(a1 + 16);
      }
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    v5 = *(char **)(a1 + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  *(_QWORD *)(a1 + 8) -= 8;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(unint64_t a1)
{
  if (a1 >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(8 * a1);
}

void __CFURLCache::_createVaryStateTable(sqlite3 **this)
{
  uint64_t v2;
  NSObject *v3;
  char *errmsg;
  uint8_t buf[4];
  char *v6;
  uint64_t v7;

  v2 = 0;
  v7 = *MEMORY[0x1E0C80C00];
  errmsg = 0;
  do
  {
    if (sqlite3_exec(this[78], off_1E14F71E8[v2], 0, 0, &errmsg))
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v3 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        v6 = errmsg;
        _os_log_impl(&dword_183ECA000, v3, OS_LOG_TYPE_DEFAULT, "SQL error: %s", buf, 0xCu);
      }
      sqlite3_free(errmsg);
    }
    ++v2;
  }
  while (v2 != 5);
}

void std::__shared_ptr_emplace<__CFURLCache>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F08A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<__CFURLCache>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F08A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t CFURLCacheCreate(const __CFAllocator *a1, uint64_t a2, uint64_t a3, const __CFString *a4)
{
  return __CFURLCacheCreateInternal(a1, a2, a3, a4, 0, 0, 0);
}

uint64_t CFURLCacheCopySharedURLCache()
{
  const void *Internal;
  uint64_t v1;

  pthread_mutex_lock(&gSharedInstanceLock);
  Internal = (const void *)gSharedInstance;
  if (!gSharedInstance)
  {
    Internal = (const void *)__CFURLCacheCreateInternal((const __CFAllocator *)*MEMORY[0x1E0C9AE00], 0x400000, 20971520, 0, 0, 0, 0);
    gSharedInstance = (uint64_t)Internal;
  }
  CFRetain(Internal);
  v1 = gSharedInstance;
  pthread_mutex_unlock(&gSharedInstanceLock);
  return v1;
}

uint64_t __CFURLCacheVaryStateForURL(__CFURLCache **a1, __CFString *a2)
{
  uint64_t TypeID;

  if (!a1)
    return 0;
  TypeID = CFURLCacheGetTypeID();
  if (TypeID == CFGetTypeID(a1))
    return __CFURLCache::_varyStateForURL(a1[2], a2);
  if ((objc_opt_respondsToSelector() & 1) != 0)
    return objc_msgSend(a1, "performSelector:withObject:", sel__varyStateForURL_, a2);
  else
    return 0;
}

uint64_t __CFURLCache::_varyStateForURL(__CFURLCache *this, __CFString *a2)
{
  std::string *v4;
  double v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v9;
  char *errmsg;
  std::string v11;
  uint8_t buf[4];
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (!*((_QWORD *)this + 78))
    return 0;
  std::string::basic_string[abi:nn180100]<0>(&v11, "SELECT * from cfurl_vary_state where request_key=\"");
  std::string::append(&v11, (const std::string::value_type *)-[__CFString UTF8String](a2, "UTF8String"));
  std::string::append(&v11, "\"");
  errmsg = 0;
  __retainStorageAssertion(*((void **)this + 17));
  v9 = 0;
  if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v4 = &v11;
  else
    v4 = (std::string *)v11.__r_.__value_.__r.__words[0];
  if (sqlite3_exec(*((sqlite3 **)this + 78), (const char *)v4, (int (__cdecl *)(void *, int, char **, char **))select_callback, &v9, &errmsg))
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      v13 = errmsg;
      _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, "SQL error: %s", buf, 0xCu);
    }
    sqlite3_free(errmsg);
  }
  __releaseStorageAssertion(v5);
  v7 = v9;
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v11.__r_.__value_.__l.__data_);
  return v7;
}

void sub_18400D880(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t select_callback(_QWORD *a1, int a2, char **a3, char **a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  _BOOL4 v13;
  _WORD *v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t v19;

  if (a2 >= 1)
  {
    v18 = v4;
    v19 = v5;
    v9 = 0;
    v10 = a2;
    do
    {
      std::string::basic_string[abi:nn180100]<0>(&v15, a4[v9]);
      if (v17 < 0)
      {
        if (v16 == 10)
        {
          v13 = *(_QWORD *)v15 != 0x6174735F79726176 || v15[4] != 25972;
          operator delete(v15);
          if (!v13)
          {
LABEL_23:
            *a1 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a3[v9]);
            return 0;
          }
        }
        else
        {
          operator delete(v15);
        }
      }
      else if (v17 == 10 && v15 == (_WORD *)0x6174735F79726176 && (unsigned __int16)v16 == 25972)
      {
        goto LABEL_23;
      }
      ++v9;
    }
    while (v10 != v9);
  }
  return 0;
}

void CFCachedURLResponseSetNSCachedURLResponse(const _CFCachedURLResponse *a1, const void *a2)
{
  __CFCachedURLResponse *var1;

  var1 = a1->var1;
  if (var1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)var1 + 22);
    *((_QWORD *)var1 + 13) = a2;
    os_unfair_lock_unlock((os_unfair_lock_t)var1 + 22);
  }
}

void __CFURLCache::_updateVaryStateForURL(__CFURLCache *this, __CFString *a2, __CFString *a3)
{
  std::string *p_p;
  double v7;
  NSObject *v8;
  std::string __p;
  char *errmsg;
  uint8_t buf[4];
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 78) && *((_QWORD *)this + 22))
  {
    errmsg = 0;
    __retainStorageAssertion(*((void **)this + 17));
    std::string::basic_string[abi:nn180100]<0>(&__p, "INSERT OR REPLACE INTO cfurl_vary_state(request_key, vary_state) VALUES ('");
    std::string::append(&__p, (const std::string::value_type *)-[__CFString UTF8String](a3, "UTF8String"));
    std::string::append(&__p, "', '");
    std::string::append(&__p, (const std::string::value_type *)-[__CFString UTF8String](a2, "UTF8String"));
    std::string::append(&__p, "');");
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if (sqlite3_exec(*((sqlite3 **)this + 78), (const char *)p_p, 0, 0, &errmsg))
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v8 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        v12 = errmsg;
        _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_DEFAULT, "SQL error: %s", buf, 0xCu);
      }
      sqlite3_free(errmsg);
    }
    __releaseStorageAssertion(v7);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_18400DB84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  _Unwind_Resume(exception_object);
}

uint64_t ___ZL50__CFURLCacheAddCachedResponseForRequestWithSessionPK11_CFURLCacheP12NSURLSessionPK20_CFCachedURLResponsePK13_CFURLRequestPKv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 752;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void CFURLCacheRemoveCachedResponseForRequest(__CFURLCache **a1, _CFURLRequest *a2)
{
  uint64_t TypeID;
  const __CFURL *v5;
  unsigned int v6;
  __CFString *v7;
  __CFString *v8;
  __CFString *CacheKeyForRequest;
  uint64_t v10;
  const char *v11;
  uint64_t v12;

  if (a1)
  {
    TypeID = CFURLCacheGetTypeID();
    if (TypeID == CFGetTypeID(a1))
    {
      if (a2)
      {
        v5 = *(const __CFURL **)(-[_CFURLRequest _inner](a2, "_inner") + 8);
        v6 = __CFURLCacheIsVaryHeaderSupportEnabled(a1);
        v7 = 0;
        if (v6 && v5)
        {
          v8 = (__CFString *)CFURLGetString(v5);
          v7 = (__CFString *)__CFURLCacheVaryStateForURL(a1, v8);
        }
        CacheKeyForRequest = _createCacheKeyForRequest(a2, 1, v7);
        v10 = operator new();
        __CFURLCacheNode::__CFURLCacheNode(v10, 0, CacheKeyForRequest, a2, 1);
        v12 = v10;
        __CFURLCache::AddCacheTask((uint64_t)a1[2], &v12);
        if (v12)
          (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
        if (CacheKeyForRequest)
          CFRelease(CacheKeyForRequest);
      }
    }
    else
    {
      v11 = (const char *)CFURLCacheRemoveCachedResponseForRequest::s;
      if (!CFURLCacheRemoveCachedResponseForRequest::s)
      {
        v11 = sel_registerName("_nscfBridgeURLCacheRemoveCachedResponseForRequest:");
        CFURLCacheRemoveCachedResponseForRequest::s = (uint64_t)v11;
      }
      objc_msgSend(a1, v11, a2);
    }
  }
}

void sub_18400DD50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

void ___ZN12__CFURLCache20PurgePersistentCacheEv_block_invoke(uint64_t a1)
{
  double v2;
  os_unfair_lock_s *v3;
  uint64_t v4;
  const char *v5;
  sqlite3 *v6;
  sqlite3 *v7;
  const char *v8;
  id v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  int v13;
  _QWORD v14[2];
  sqlite3 *(*v15)(uint64_t);
  void *v16;
  os_unfair_lock_s *v17;
  sqlite3 *v18;
  _QWORD v19[2];
  void (*v20)(uint64_t);
  void *v21;
  os_unfair_lock_s *v22;

  __retainStorageAssertion(*(void **)(a1 + 32));
  v3 = *(os_unfair_lock_s **)(a1 + 40);
  if (v3)
  {
    os_unfair_lock_lock(v3 + 7);
    v4 = MEMORY[0x1E0C809B0];
    v19[0] = MEMORY[0x1E0C809B0];
    v19[1] = 3221225472;
    v20 = __44__NSURLStorageURLCacheDB_deleteAllResponses__block_invoke;
    v21 = &unk_1E14FE118;
    v22 = v3;
    v6 = -[NSURLStorageURLCacheDB openReadWriteConnection](v3, v5);
    v7 = v6;
    if (v6)
    {
      v14[0] = v4;
      v14[1] = 3221225472;
      v15 = __44__NSURLStorageURLCacheDB_deleteAllResponses__block_invoke_2;
      v16 = &unk_1E14FE140;
      v17 = v3;
      v18 = v6;
      v13 = 141;
      if (sqlite3_file_control(v6, 0, 101, &v13))
      {
        v9 = objc_getProperty(v3, v8, 168, 1);
        v10 = sqlite3_errmsg(v7);
        v11 = sqlite3_errcode(v7);
        NSLog(CFSTR("ERROR: NSURLStorageURLCacheDB deleteAllResponses: dbConnection=%p DB=%@ Truncate Database failed:%s ErrCode: %d."), v7, v9, v10, v11);

        v15((uint64_t)v14);
        v20((uint64_t)v19);
        goto LABEL_7;
      }
      v15((uint64_t)v14);
    }
    v20((uint64_t)v19);
    -[NSURLStorageURLCacheDB updateToCurrentSchema]((uint64_t)v3, v12);
  }
LABEL_7:
  __releaseStorageAssertion(v2);
}

void sub_18400DEDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, void (*a16)(char *), uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,void (*a22)(char *))
{
  a16(&a14);
  a22(&a20);
  _Unwind_Resume(a1);
}

void ___ZN12__CFURLCache30removeCachedResponsesSinceDateEPK8__CFDate_block_invoke(uint64_t a1)
{
  void *v2;
  const char *v3;
  id v4;
  sqlite3 *v5;
  const __CFString *v6;
  __CFString *v7;
  char *v8;
  char *v9;
  const char *v10;
  const char *v11;
  id v12;
  const char *v13;
  uint64_t v14;
  char *v15;
  const char *v16;
  id v17;
  const char *v18;
  uint64_t v19;
  char *v20;
  const char *v21;
  id v22;
  const char *v23;
  uint64_t v24;
  char *v25;
  const char *v26;
  id v27;
  const char *v28;
  uint64_t v29;
  const char *v30;
  id v31;
  const char *v32;
  uint64_t v33;
  const char *v34;
  id v35;
  const char *v36;
  uint64_t v37;
  const char *v38;
  id v39;
  const char *v40;
  uint64_t v41;
  double v42;
  char *errmsg;
  BOOL v44;

  __retainStorageAssertion(*(void **)(a1 + 32));
  v2 = *(void **)(a1 + 40);
  v4 = *(id *)(a1 + 48);
  if (v2)
  {
    v44 = 0;
    v5 = -[NSURLStorageURLCacheDB openReadWriteConnection](v2, v3);
    objc_msgSend(v4, "description");
    v6 = (const __CFString *)objc_claimAutoreleasedReturnValue();
    v7 = (__CFString *)v6;
    if (v6)
      v8 = _ExtractCStringfromCFStringRef(v6, &v44);
    else
      v8 = 0;
    errmsg = 0;
    v9 = sqlite3_mprintf("SELECT receiver_data from cfurl_cache_receiver_data WHERE isDataOnFS > 0 AND entry_ID in (SELECT entry_ID FROM cfurl_cache_response WHERE time_stamp >= \"%s\")", v8);
    if (sqlite3_exec(v5, v9, (int (__cdecl *)(void *, int, char **, char **))SQLdeleteSinceDateCallback, v2, &errmsg)
      && errmsg)
    {
      objc_getProperty(v2, v10, 168, 1);
      CFLog();
      sqlite3_free(errmsg);
    }
    sqlite3_free(v9);
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((uint64_t)v2, "BEGIN IMMEDIATE;",
                         v5,
                         0))
    {
      v12 = objc_getProperty(v2, v11, 168, 1);
      v13 = sqlite3_errmsg(v5);
      v14 = sqlite3_errcode(v5);
      NSLog(CFSTR("ERROR: NSURLStorageURLCacheDB deleteResponsesSinceDate: dbConnection=%p DB=%@ Begin transaction failed:%s ErrCode: %d."), v5, v12, v13, v14);

    }
    v15 = sqlite3_mprintf("DELETE from cfurl_cache_receiver_data WHERE entry_ID in (SELECT entry_ID FROM cfurl_cache_response WHERE time_stamp >= \"%s\")", v8);
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((uint64_t)v2, v15, v5, 0))
    {
      v17 = objc_getProperty(v2, v16, 168, 1);
      v18 = sqlite3_errmsg(v5);
      v19 = sqlite3_errcode(v5);
      NSLog(CFSTR("ERROR: NSURLStorageURLCacheDB deleteResponsesSinceDate: dbConnection=%p DB=%@ Delete failed:%s ErrCode: %d."), v5, v17, v18, v19);

    }
    sqlite3_free(v15);
    v20 = sqlite3_mprintf("DELETE from cfurl_cache_blob_data WHERE entry_ID in (SELECT entry_ID FROM cfurl_cache_response WHERE time_stamp >= \"%s\")", v8);
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((uint64_t)v2, v20, v5, 0))
    {
      v22 = objc_getProperty(v2, v21, 168, 1);
      v23 = sqlite3_errmsg(v5);
      v24 = sqlite3_errcode(v5);
      NSLog(CFSTR("ERROR: NSURLStorageURLCacheDB deleteResponsesSinceDate: dbConnection=%p DB=%@ Delete failed:%s ErrCode: %d."), v5, v22, v23, v24);

    }
    sqlite3_free(v20);
    v25 = sqlite3_mprintf("DELETE from cfurl_cache_response WHERE time_stamp >= \"%s\"", v8);
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((uint64_t)v2, v25, v5, 0))
    {
      v27 = objc_getProperty(v2, v26, 168, 1);
      v28 = sqlite3_errmsg(v5);
      v29 = sqlite3_errcode(v5);
      NSLog(CFSTR("ERROR: NSURLStorageURLCacheDB deleteResponsesSinceDate: dbConnection=%p DB=%@ Delete failed:%s ErrCode: %d."), v5, v27, v28, v29);

    }
    sqlite3_free(v25);
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((uint64_t)v2, "COMMIT;",
                         v5,
                         0))
    {
      v31 = objc_getProperty(v2, v30, 168, 1);
      v32 = sqlite3_errmsg(v5);
      v33 = sqlite3_errcode(v5);
      NSLog(CFSTR("ERROR: NSURLStorageURLCacheDB deleteResponsesSinceDate: dbConnection=%p DB=%@ Commit transaction failed:%s ErrCode: %d."), v5, v31, v32, v33);

    }
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((uint64_t)v2, "PRAGMA incremental_vacuum(500);",
                         v5,
                         0))
    {
      v35 = objc_getProperty(v2, v34, 168, 1);
      v36 = sqlite3_errmsg(v5);
      v37 = sqlite3_errcode(v5);
      NSLog(CFSTR("ERROR: NSURLStorageURLCacheDB deleteResponsesSinceDate: dbConnection=%p DB=%@ Vacuum failed:%s ErrCode: %d."), v5, v35, v36, v37);

    }
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((uint64_t)v2, "PRAGMA wal_checkpoint;",
                         v5,
                         0))
    {
      v39 = objc_getProperty(v2, v38, 168, 1);
      v40 = sqlite3_errmsg(v5);
      v41 = sqlite3_errcode(v5);
      NSLog(CFSTR("ERROR: NSURLStorageURLCacheDB deleteResponsesSinceDate: dbConnection=%p DB=%@ Pragma checkpoint failed:%s ErrCode: %d."), v5, v39, v40, v41);

    }
    if (v8 && v44)
      MEMORY[0x186DB7474](v8, 0x1000C8077774924);
    if (v5)
      sqlite3_close(v5);

  }
  __releaseStorageAssertion(v42);
}

void sub_18400E344(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

_QWORD *_CFURLCacheSetMemoryLimit(_QWORD *result, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;
  uint64_t TypeID;
  uint64_t v7;
  double v8;
  const char *v9;

  if (result)
  {
    v5 = result;
    TypeID = CFURLCacheGetTypeID();
    result = (_QWORD *)CFGetTypeID(v5);
    if ((_QWORD *)TypeID == result)
    {
      v7 = v5[2];
      *(_QWORD *)(v7 + 168) = a2;
      if (a3 < 1 || a3 >= a2)
      {
        v8 = *(double *)(v7 + 200);
        a3 = (uint64_t)(v8 * (double)a2);
        *(_QWORD *)(v7 + 192) = (uint64_t)(v8 * (double)*(uint64_t *)(v7 + 176));
      }
      *(_QWORD *)(v7 + 184) = a3;
    }
    else
    {
      v9 = (const char *)_CFURLCacheSetMemoryLimit::s;
      if (!_CFURLCacheSetMemoryLimit::s)
      {
        v9 = sel_registerName("_nscfBridgeURLCacheSetMemoryCapacity:");
        _CFURLCacheSetMemoryLimit::s = (uint64_t)v9;
      }
      return objc_msgSend(v5, v9, a2);
    }
  }
  return result;
}

void _CFURLCacheSetCacheEventCallBackBlock(uint64_t a1, void *aBlock, dispatch_object_t object)
{
  uint64_t v5;
  const void *v6;
  void *v8;
  NSObject *v9;

  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(const void **)(v5 + 32);
  if (v6 != aBlock)
  {
    if (v6)
    {
      _Block_release(v6);
      v5 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(v5 + 32) = 0;
    }
    if (aBlock)
    {
      v8 = _Block_copy(aBlock);
      v5 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(v5 + 32) = v8;
    }
  }
  v9 = *(NSObject **)(v5 + 24);
  if (v9 != object)
  {
    if (v9)
    {
      dispatch_release(v9);
      v5 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(v5 + 24) = 0;
    }
    if (object)
    {
      *(_QWORD *)(v5 + 24) = object;
      dispatch_retain(object);
    }
  }
}

void _CFCachedURLResponseSetBecameFileBackedCallBackBlock(_QWORD *a1, const void *a2, NSObject *a3)
{
  uint64_t v6;
  const void *v7;
  uint64_t TypeID;
  CFTypeID v9;
  uint64_t v10;
  const void *v11;
  void *v12;
  NSObject *v13;
  os_unfair_lock_s *v14;
  const void *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  __CFDictionary *v20;
  dispatch_time_t v21;
  NSObject *v22;
  _QWORD block[5];
  __int128 buf;
  uint64_t v25;
  CFTypeRef v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v6 = CFURLCacheCopySharedURLCache();
  if (!v6 || (v7 = (const void *)v6, TypeID = CFURLCacheGetTypeID(), v9 = CFGetTypeID(v7), CFRelease(v7), TypeID == v9))
  {
    v10 = a1[2];
    v11 = *(const void **)(v10 + 16);
    if (v11 != a2)
    {
      if (v11)
      {
        _Block_release(v11);
        v10 = a1[2];
        *(_QWORD *)(v10 + 16) = 0;
      }
      if (a2)
      {
        v12 = _Block_copy(a2);
        v10 = a1[2];
        *(_QWORD *)(v10 + 16) = v12;
      }
    }
    v13 = *(NSObject **)(v10 + 8);
    if (v13 == a3)
      goto LABEL_28;
    if (v13)
    {
      dispatch_release(v13);
      v10 = a1[2];
      *(_QWORD *)(v10 + 8) = 0;
    }
    if (!a3 || (*(_QWORD *)(v10 + 8) = a3, dispatch_retain(a3), (v10 = a1[2]) != 0))
    {
LABEL_28:
      if (*(_QWORD *)(v10 + 16) && *(_QWORD *)(v10 + 8))
      {
        v14 = (os_unfair_lock_s *)(v10 + 88);
        os_unfair_lock_lock((os_unfair_lock_t)(v10 + 88));
        v15 = *(const void **)(v10 + 128);
        os_unfair_lock_unlock(v14);
        if (v15)
        {
          v16 = CFURLCacheCopySharedURLCache();
          if (v16)
          {
            v17 = (_QWORD *)v16;
            v18 = *(_QWORD *)(v16 + 16);
            if (v18)
            {
              pthread_mutex_lock((pthread_mutex_t *)(v18 + 456));
              v19 = v17[2];
              v20 = *(__CFDictionary **)(v19 + 520);
              if (v20)
              {
                CFDictionaryAddValue(v20, v15, a1);
                *(_QWORD *)&buf = 0;
                *((_QWORD *)&buf + 1) = &buf;
                v25 = 0x2020000000;
                v26 = 0;
                v26 = CFRetain(v15);
                v21 = dispatch_time(0, 10000000000);
                block[0] = MEMORY[0x1E0C809B0];
                block[1] = 3221225472;
                block[2] = ___CFCachedURLResponseSetBecameFileBackedCallBackBlock_block_invoke;
                block[3] = &unk_1E14FD3D8;
                block[4] = &buf;
                dispatch_after(v21, a3, block);
                _Block_object_dispose(&buf, 8);
                v19 = v17[2];
              }
              pthread_mutex_unlock((pthread_mutex_t *)(v19 + 456));
            }
            CFRelease(v17);
          }
        }
        else
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v22 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 134217984;
            *(_QWORD *)((char *)&buf + 4) = a1;
            _os_log_error_impl(&dword_183ECA000, v22, OS_LOG_TYPE_ERROR, "VM: ADD attempt FAILED for cached response %p. No key found.", (uint8_t *)&buf, 0xCu);
          }
        }
      }
    }
  }
}

const void *_CFCachedURLResponseGetMemMappedData(uint64_t a1)
{
  uint64_t v1;
  const __CFArray *v2;

  v1 = *(_QWORD *)(a1 + 16);
  if (*(_BYTE *)(v1 + 120) && (v2 = *(const __CFArray **)(v1 + 80)) != 0)
    return CFArrayGetValueAtIndex(v2, 0);
  else
    return 0;
}

uint64_t CFCachedURLResponseCreateWithData(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t Instance;
  uint64_t v6;
  CFArrayRef v7;
  const void *v9[6];

  v9[5] = *(const void **)MEMORY[0x1E0C80C00];
  v9[0] = (const void *)MEMORY[0x1E0C809B0];
  v9[1] = (const void *)3221225472;
  v9[2] = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_2382;
  v9[3] = &__block_descriptor_40_e5_v8__0l;
  v9[4] = _CachedURLResponseRegisterClass;
  if (_CFCachedURLResponseClassRegistration != -1)
    dispatch_once(&_CFCachedURLResponseClassRegistration, v9);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v6 = operator new();
    *(_QWORD *)v6 = &off_1E14EC248;
    *(_QWORD *)(v6 + 32) = CFRetain(a2);
    *(_QWORD *)(v6 + 40) = 0;
    *(_DWORD *)(v6 + 88) = 0;
    if (a3)
    {
      v9[0] = a3;
      *(_QWORD *)(v6 + 72) = CFRetain(a3);
      v7 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v9, 1, MEMORY[0x1E0C9B378]);
    }
    else
    {
      v7 = 0;
      *(_QWORD *)(v6 + 72) = 0;
    }
    *(_QWORD *)(v6 + 80) = v7;
    *(_QWORD *)(v6 + 64) = 0;
    *(_DWORD *)(v6 + 56) = 0;
    *(_QWORD *)(v6 + 48) = 0;
    *(_QWORD *)(v6 + 128) = 0;
    *(_QWORD *)(v6 + 8) = 0;
    *(_QWORD *)(v6 + 16) = 0;
    *(_QWORD *)(v6 + 104) = 0;
    *(_QWORD *)(v6 + 112) = 0;
    *(_QWORD *)(v6 + 96) = 0;
    *(_BYTE *)(v6 + 120) = 0;
    __CFCachedURLResponse::Encode((__CFCachedURLResponse *)v6);
    *(_QWORD *)(Instance + 16) = v6;
  }
  return Instance;
}

void sub_18400E998(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10E1C40D8EAFA61);
  _Unwind_Resume(a1);
}

uint64_t CFCachedURLResponseGetWrappedResponse(uint64_t result)
{
  if (result)
    return *(_QWORD *)(*(_QWORD *)(result + 16) + 32);
  return result;
}

__CFData *CFCachedURLResponseGetReceiverData(__CFData *result)
{
  if (result)
    return __CFCachedURLResponse::GetReceiverData(*((__CFCachedURLResponse **)result + 2));
  return result;
}

uint64_t CFCachedURLResponseGetStoragePolicy(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(*(_QWORD *)(a1 + 16) + 56);
  else
    return 2;
}

uint64_t CFCachedURLResponseSetStoragePolicy(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(*(_QWORD *)(result + 16) + 56) = a2;
  return result;
}

void ___ZN12__CFURLCache6ShrinkEP22NSURLStorageURLCacheDB_block_invoke(_QWORD *a1)
{
  __CFURLCache *v2;
  const char *v3;
  double v4;
  id *v5;
  sqlite3 *v6;
  sqlite3 *v7;
  char *v8;
  uint64_t v9;
  const __CFString *v10;
  __CFString *v11;
  char *CStringfromCFStringRef;
  const char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  __CFString *v19;
  char *v20;
  const char *v21;
  char *v22;
  char *v23;
  char *v24;
  const char *v25;
  _QWORD *v26;
  unint64_t v27;
  unint64_t v28;
  NSObject *v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint8_t buf[4];
  unint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v2 = (__CFURLCache *)a1[5];
  __retainStorageAssertion(*(void **)(*(_QWORD *)(a1[6] + 16) + 136));
  v5 = (id *)a1[4];
  if (v5)
  {
    buf[0] = 0;
    v6 = -[NSURLStorageURLCacheDB openReadWriteConnection](v5, v3);
    if (v6)
    {
      v7 = v6;
      if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((uint64_t)v5, "BEGIN IMMEDIATE", v6, 0))
      {
        CFLog();
      }
      else
      {
        v8 = sqlite3_mprintf("SELECT receiver_data, entry_ID from cfurl_cache_receiver_data WHERE isDataOnFS > 0 AND entry_ID in \t\t\t\t\t\t\t\t (SELECT entry_ID from cfurl_cache_response WHERE entry_ID > 0 ORDER BY time_stamp ASC LIMIT %d)", 1500);
        v9 = sqlite3_exec(v7, v8, (int (__cdecl *)(void *, int, char **, char **))SQLHostForDeleteCallback, v5, 0);
        sqlite3_free(v8);
        if ((_DWORD)v9)
        {
          v31 = v9;
          CFLog();
        }
        objc_msgSend(v5[17], "componentsJoinedByString:", CFSTR(","), v31);
        v10 = (const __CFString *)objc_claimAutoreleasedReturnValue();
        v11 = (__CFString *)v10;
        if (v10)
        {
          CStringfromCFStringRef = _ExtractCStringfromCFStringRef(v10, (BOOL *)buf);
          v13 = CStringfromCFStringRef;
          if (CStringfromCFStringRef)
          {
            v14 = sqlite3_mprintf("DELETE from %s WHERE entry_ID in (%s)", "cfurl_cache_blob_data", CStringfromCFStringRef);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((uint64_t)v5, v14, v7, 0);
            sqlite3_free(v14);
            v15 = sqlite3_mprintf("DELETE from %s WHERE entry_ID in (%s)", "cfurl_cache_receiver_data", v13);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((uint64_t)v5, v15, v7, 0);
            sqlite3_free(v15);
            v16 = sqlite3_mprintf("DELETE from %s WHERE entry_ID in (%s)", "cfurl_cache_response", v13);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((uint64_t)v5, v16, v7, 0);
            sqlite3_free(v16);
            if (buf[0])
              MEMORY[0x186DB7474](v13, 0x1000C8077774924);
          }
        }
        objc_msgSend(v5[17], "removeAllObjects");
        v17 = sqlite3_mprintf("SELECT entry_ID from cfurl_cache_receiver_data WHERE isDataOnFS < 1 AND entry_ID in \t\t\t\t\t\t\t\t (SELECT entry_ID from cfurl_cache_response WHERE entry_ID > 0 ORDER BY time_stamp ASC LIMIT %d)", 500);
        v18 = sqlite3_exec(v7, v17, (int (__cdecl *)(void *, int, char **, char **))SQLHostForDeleteCallback, v5, 0);
        sqlite3_free(v17);
        if ((_DWORD)v18)
        {
          v32 = v18;
          CFLog();
        }
        objc_msgSend(v5[17], "componentsJoinedByString:", CFSTR(","), v32);
        v19 = (__CFString *)objc_claimAutoreleasedReturnValue();

        if (v19)
        {
          v20 = _ExtractCStringfromCFStringRef(v19, (BOOL *)buf);
          v21 = v20;
          if (v20)
          {
            v22 = sqlite3_mprintf("DELETE from %s WHERE entry_ID in (%s)", "cfurl_cache_blob_data", v20);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((uint64_t)v5, v22, v7, 0);
            sqlite3_free(v22);
            v23 = sqlite3_mprintf("DELETE from %s WHERE entry_ID in (%s)", "cfurl_cache_receiver_data", v21);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((uint64_t)v5, v23, v7, 0);
            sqlite3_free(v23);
            v24 = sqlite3_mprintf("DELETE from %s WHERE entry_ID in (%s)", "cfurl_cache_response", v21);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((uint64_t)v5, v24, v7, 0);
            sqlite3_free(v24);
            if (buf[0])
              MEMORY[0x186DB7474](v21, 0x1000C8077774924);
          }
        }
        objc_msgSend(v5[17], "removeAllObjects");
        -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((uint64_t)v5, "COMMIT", v7, 0);
        -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((uint64_t)v5, "PRAGMA incremental_vacuum(500);",
          v7,
          0);

      }
      sqlite3_close(v7);
    }
  }
  __releaseStorageAssertion(v4);
  v26 = (_QWORD *)a1[4];
  if (v26)
  {
    -[NSURLStorageURLCacheDB updateFSBackedCacheUsageOnDisk]((_QWORD *)a1[4], v25);
    -[NSURLStorageURLCacheDB updateSQLiteDBCacheUsageOnDisk](v26);
    v27 = v26[25];
    v28 = a1[4];
    if (v28)
      v28 = *(_QWORD *)(v28 + 176);
    if (v27 > v28)
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v29 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134217984;
        v34 = v27;
        _os_log_error_impl(&dword_183ECA000, v29, OS_LOG_TYPE_ERROR, "Cache storage usage (%lu) still exceeds limit after cache shrinking. Purging persistent cache.", buf, 0xCu);
      }
      __CFURLCache::PurgePersistentCache(v2);
    }
  }
  v30 = (_QWORD *)a1[6];
  *(_BYTE *)(v30[2] + 121) = 0;
  CFRelease(v30);
}

void sub_18400EEB4(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void ___ZL39notifyCachedURLResponseBecameFileBackedPK20_CFCachedURLResponse_block_invoke(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = *(_QWORD **)(a1 + 32);
  v3 = *(_QWORD *)(v2[2] + 16);
  if (!v3 || ((*(void (**)(void))(v3 + 16))(), (v2 = *(_QWORD **)(a1 + 32)) != 0))
    CFRelease(v2);
}

uint64_t _CFURLCachePurgeMemoryCache(uint64_t a1)
{
  return __CFURLCache::PurgeMemoryCache(*(__CFURLCache **)(a1 + 16));
}

uint64_t _CFURLCacheGetSharedCache(void)
{
  return gSharedInstance;
}

void _CFURLCacheFlush(uint64_t a1, void (**a2)(_QWORD))
{
  if (IsCFURLCache(a1))
  {
    dispatch_async(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 16) + 136), a2);
  }
  else
  {
    CFURLCacheCurrentDiskUsage((__CFURLCache **)a1);
    a2[2](a2);
  }
}

BOOL HTTP2Connection::equals(HTTP2Connection *this, const CFObject *a2)
{
  CFTypeID v4;
  uint64_t v5;

  v4 = CFGetTypeID((char *)this - 16);
  if (v4 != CFGetTypeID((char *)a2 - 16))
    return 1;
  v5 = (*(uint64_t (**)(const CFObject *))(*(_QWORD *)a2 + 8))(a2);
  return v5 == (*(uint64_t (**)(HTTP2Connection *))(*(_QWORD *)this + 8))(this);
}

CFStringRef HTTP2Connection::copyDebugDesc(HTTP2Connection *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("HTTP2Connection<%p>"), this);
}

void HTTP2Connection::_onqueue_pingWithPongHandler(uint64_t a1, const void *a2)
{
  unint64_t v2;
  void *v5;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD *v9;
  _QWORD *i;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  int8x8_t prime;
  void *v19;
  void *v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  uint8x8_t v24;
  unint64_t v25;
  uint8x8_t v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  unint64_t v33;
  void *v34;

  if (!*(_QWORD *)(a1 + 160))
    return;
  nghttp2_submit_ping();
  v5 = _Block_copy(a2);
  v6 = *(_QWORD *)(a1 + 664);
  v7 = *(_QWORD *)(a1 + 680);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v2 = *(_QWORD *)(a1 + 664);
      if (v6 >= v7)
        v2 = v6 % v7;
    }
    else
    {
      v2 = (v7 - 1) & v6;
    }
    v9 = *(_QWORD **)(*(_QWORD *)(a1 + 672) + 8 * v2);
    if (v9)
    {
      for (i = (_QWORD *)*v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == v6)
        {
          if (i[2] == v6)
            goto LABEL_76;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v2)
            break;
        }
      }
    }
  }
  v12 = operator new(0x28uLL);
  *v12 = 0;
  v12[1] = v6;
  v12[2] = v6;
  v12[3] = 0;
  v12[4] = v5;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 696) + 1);
  v14 = *(float *)(a1 + 704);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      prime = (int8x8_t)v17;
    else
      prime = (int8x8_t)v16;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v7 = *(_QWORD *)(a1 + 680);
    }
    if (*(_QWORD *)&prime > v7)
      goto LABEL_32;
    if (*(_QWORD *)&prime < v7)
    {
      v25 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 696) / *(float *)(a1 + 704));
      if (v7 < 3 || (v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        v25 = std::__next_prime(v25);
      }
      else
      {
        v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2)
          v25 = v27;
      }
      if (*(_QWORD *)&prime <= v25)
        prime = (int8x8_t)v25;
      if (*(_QWORD *)&prime >= v7)
      {
        v7 = *(_QWORD *)(a1 + 680);
      }
      else
      {
        if (prime)
        {
LABEL_32:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v19 = operator new(8 * *(_QWORD *)&prime);
          v20 = *(void **)(a1 + 672);
          *(_QWORD *)(a1 + 672) = v19;
          if (v20)
            operator delete(v20);
          v21 = 0;
          *(int8x8_t *)(a1 + 680) = prime;
          do
            *(_QWORD *)(*(_QWORD *)(a1 + 672) + 8 * v21++) = 0;
          while (*(_QWORD *)&prime != v21);
          v22 = *(_QWORD **)(a1 + 688);
          if (v22)
          {
            v23 = v22[1];
            v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(_QWORD *)&prime)
                v23 %= *(_QWORD *)&prime;
            }
            else
            {
              v23 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)(a1 + 672) + 8 * v23) = a1 + 688;
            v28 = (_QWORD *)*v22;
            if (*v22)
            {
              do
              {
                v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(_QWORD *)&prime)
                    v29 %= *(_QWORD *)&prime;
                }
                else
                {
                  v29 &= *(_QWORD *)&prime - 1;
                }
                if (v29 != v23)
                {
                  v30 = *(_QWORD *)(a1 + 672);
                  if (!*(_QWORD *)(v30 + 8 * v29))
                  {
                    *(_QWORD *)(v30 + 8 * v29) = v22;
                    goto LABEL_57;
                  }
                  *v22 = *v28;
                  *v28 = **(_QWORD **)(*(_QWORD *)(a1 + 672) + 8 * v29);
                  **(_QWORD **)(*(_QWORD *)(a1 + 672) + 8 * v29) = v28;
                  v28 = v22;
                }
                v29 = v23;
LABEL_57:
                v22 = v28;
                v28 = (_QWORD *)*v28;
                v23 = v29;
              }
              while (v28);
            }
          }
          v7 = (unint64_t)prime;
          goto LABEL_61;
        }
        v34 = *(void **)(a1 + 672);
        *(_QWORD *)(a1 + 672) = 0;
        if (v34)
          operator delete(v34);
        v7 = 0;
        *(_QWORD *)(a1 + 680) = 0;
      }
    }
LABEL_61:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7)
        v2 = v6 % v7;
      else
        v2 = v6;
    }
    else
    {
      v2 = (v7 - 1) & v6;
    }
  }
  v31 = *(_QWORD *)(a1 + 672);
  v32 = *(_QWORD **)(v31 + 8 * v2);
  if (v32)
  {
    *v12 = *v32;
  }
  else
  {
    *v12 = *(_QWORD *)(a1 + 688);
    *(_QWORD *)(a1 + 688) = v12;
    *(_QWORD *)(v31 + 8 * v2) = a1 + 688;
    if (!*v12)
      goto LABEL_75;
    v33 = *(_QWORD *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v33 >= v7)
        v33 %= v7;
    }
    else
    {
      v33 &= v7 - 1;
    }
    v32 = (_QWORD *)(*(_QWORD *)(a1 + 672) + 8 * v33);
  }
  *v32 = v12;
LABEL_75:
  ++*(_QWORD *)(a1 + 696);
  v6 = *(_QWORD *)(a1 + 664);
LABEL_76:
  *(_QWORD *)(a1 + 664) = v6 + 1;
  HTTP2Connection::_onqueue_scheduleIO((HTTP2Connection *)a1);
}

void sub_18400F454(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void HTTP2Connection::connEventReadClose(HTTP2Connection *this)
{
  if (!(*((_QWORD *)this + 18) | *((unsigned int *)this + 38)))
  {
    *((_BYTE *)this + 264) = 1;
    HTTP2Connection::stopIfNoOutstandingRequests(this);
  }
}

void HTTP2Connection::connEventDisconnected(HTTP2Connection *this)
{
  if (!(*((_QWORD *)this + 18) | *((unsigned int *)this + 38)))
  {
    *((_QWORD *)this + 18) = 4;
    *((_DWORD *)this + 38) = -4;
    HTTP2Connection::closeConnection(this, 0);
  }
}

void HTTP2Connection::connErrorOccurred(CFStreamError *this, CFStreamError a2)
{
  this[9] = a2;
  HTTP2Connection::closeConnection((HTTP2Connection *)this, 0);
}

uint64_t HTTP2Connection::connEventAlternatePathAvailable(uint64_t a1, uint64_t a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  const void *ValueAtIndex;
  std::__shared_weak_count *v8;
  HTTP2Stream *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  CFStreamError v21;

  *(_BYTE *)(a1 + 264) = 1;
  HTTP2Connection::stopIfNoOutstandingRequests((HTTP2Connection *)a1);
  v21.domain = 4;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 232));
  if (Count >= 1)
  {
    v5 = Count;
    v6 = 0;
    *(_QWORD *)&v21.error = 4294967291;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 232), v6);
      v9 = (HTTP2Stream *)*((_QWORD *)ValueAtIndex + 3);
      v8 = (std::__shared_weak_count *)*((_QWORD *)ValueAtIndex + 4);
      if (v8)
      {
        p_shared_owners = (unint64_t *)&v8->__shared_owners_;
        do
          v11 = __ldxr(p_shared_owners);
        while (__stxr(v11 + 1, p_shared_owners));
      }
      if ((a2 & 0xFFFFFFFD) == 1
        && (v12 = *((_QWORD *)v9 + 2)) != 0
        && (*(unsigned int (**)(uint64_t, CFStreamError *, _QWORD))(*(_QWORD *)v12 + 280))(v12, &v21, 0)
         - 5 <= 5)
      {
        HTTP2Stream::setError(v9, v21);
        HTTP2Stream::closeStreamWithErrorCode(v9);
        if (v8)
        {
          v13 = (unint64_t *)&v8->__shared_owners_;
          do
            v14 = __ldxr(v13);
          while (__stxr(v14 + 1, v13));
        }
        HTTP2Connection::cancelStream(a1, (uint64_t)v9, v8);
        if (v8)
        {
          v15 = (unint64_t *)&v8->__shared_owners_;
          do
            v16 = __ldaxr(v15);
          while (__stlxr(v16 - 1, v15));
          if (!v16)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
      }
      else
      {
        v17 = *((_QWORD *)v9 + 2);
        if (v17)
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v17 + 248))(v17, a2);
      }
      if (v8)
      {
        v18 = (unint64_t *)&v8->__shared_owners_;
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }
      ++v6;
    }
    while (v6 != v5);
  }
  return 1;
}

void sub_18400F670(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'HTTP2Connection::~HTTP2Connection(HTTP2Connection *this)
{
  HTTP2Connection::~HTTP2Connection((HTTP2Connection *)((char *)this - 8));
}

{
  HTTP2Connection::~HTTP2Connection((HTTP2Connection *)((char *)this - 8));
}

{
  HTTP2Connection::~HTTP2Connection((HTTP2Connection *)((char *)this - 16));
}

{
  HTTP2Connection::~HTTP2Connection((HTTP2Connection *)((char *)this - 16));
}

{
  HTTP2Connection::~HTTP2Connection((HTTP2Connection *)((char *)this - 24));
}

{
  HTTP2Connection::~HTTP2Connection((HTTP2Connection *)((char *)this - 24));
}

void `non-virtual thunk to'HTTP2Connection::connEventReadClose(HTTP2Connection *this)
{
  if (!(*((_QWORD *)this + 16) | *((unsigned int *)this + 34)))
  {
    *((_BYTE *)this + 248) = 1;
    HTTP2Connection::stopIfNoOutstandingRequests((HTTP2Connection *)((char *)this - 16));
  }
}

void `non-virtual thunk to'HTTP2Connection::connEventDisconnected(HTTP2Connection *this)
{
  HTTP2Connection::connEventDisconnected((HTTP2Connection *)((char *)this - 16));
}

void `non-virtual thunk to'HTTP2Connection::connErrorOccurred(CFStreamError *this, CFStreamError a2)
{
  this[8] = a2;
  HTTP2Connection::closeConnection((HTTP2Connection *)&this[-1], 0);
}

uint64_t `non-virtual thunk to'HTTP2Connection::connEventAlternatePathAvailable(uint64_t a1, uint64_t a2)
{
  HTTP2Connection::connEventAlternatePathAvailable(a1 - 16, a2);
  return 1;
}

void `non-virtual thunk to'HTTP2Connection::_onqueue_pingWithPongHandler(uint64_t a1, const void *a2)
{
  HTTP2Connection::_onqueue_pingWithPongHandler(a1 - 24, a2);
}

void ___ZN15HTTP2ConnectionD2Ev_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

uint64_t RetainableTypedDict<__CFNumber const*,__CFDictionary *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA428;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<__CFNumber const*,__CFDictionary *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA428;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

void HTTP2Connection::closeConnection(HTTP2Connection *this, char a2)
{
  NSObject *v4;
  _QWORD v5[5];
  char v6;

  CFRetain((char *)this - 16);
  v4 = *((_QWORD *)this + 21);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN15HTTP2Connection15closeConnectionEb_block_invoke;
  v5[3] = &__block_descriptor_41_e5_v8__0l;
  v5[4] = this;
  v6 = a2;
  dispatch_async(v4, v5);
}

void ___ZN15HTTP2Connection15closeConnectionEb_block_invoke(uint64_t a1)
{
  HTTP2Connection *v1;

  v1 = *(HTTP2Connection **)(a1 + 32);
  HTTP2Connection::_onqueue_closeConnection(v1, *(_BYTE *)(a1 + 40), 0);
  CFRelease((char *)v1 - 16);
}

void HTTP2Connection::stopStallRecovery(dispatch_source_t *this)
{
  NSObject *v2;

  dispatch_source_cancel(this[90]);
  v2 = this[90];
  this[90] = 0;
  if (v2)
    dispatch_release(v2);
  this[32] = 0;
}

void std::__shared_ptr_emplace<TCPIOConnectionTest::EnqueedRead>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0F30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TCPIOConnectionTest::EnqueedRead>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0F30;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_emplace<TCPIOConnectionTest::EnqueedRead>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 40);
  if (v1)
    _Block_release(v1);
}

uint64_t HTTP2Server::write(HTTP2Server *this)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(_QWORD *, uint64_t, uint64_t);
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;

  result = nghttp2_session_want_write();
  if ((_DWORD)result)
  {
    v8 = 0;
    result = MEMORY[0x186DB7E64](*((_QWORD *)this + 5), &v8);
    v3 = *((_QWORD *)this + 7);
    if (v3)
    {
      v4 = result;
      v5 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t))(v3 + 8);
      v6 = *(_QWORD *)(v3 + 16);
      v7 = (_QWORD *)(v3 + (v6 >> 1));
      if ((v6 & 1) != 0)
        v5 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t))(*v7 + v5);
      return v5(v7, v8, v4);
    }
  }
  return result;
}

void HTTP2Connection::stopIfNoOutstandingRequests(HTTP2Connection *this)
{
  NSObject *v2;
  _QWORD block[5];

  CFRetain((char *)this - 16);
  v2 = *((_QWORD *)this + 21);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN15HTTP2Connection27stopIfNoOutstandingRequestsEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = this;
  dispatch_async(v2, block);
}

void ___ZN15HTTP2Connection27stopIfNoOutstandingRequestsEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(int *)(v1 + 304);
  if (!(CFArrayGetCount(*(CFArrayRef *)(v1 + 232)) + v2))
    HTTP2Connection::_onqueue_closeConnection((HTTP2Connection *)v1, 0, 0);
  CFRelease((CFTypeRef)(v1 - 16));
}

void HTTP2Connection::cancelStream(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  unint64_t *p_shared_owners;
  unint64_t v7;
  NSObject *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD block[6];
  std::__shared_weak_count *v17;
  int v18;

  if (*(_QWORD *)(a1 + 160))
  {
    if (a3)
    {
      p_shared_owners = (unint64_t *)&a3->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
    if (*(_DWORD *)(a2 + 80) == -1)
      goto LABEL_13;
    CFRetain((CFTypeRef)(a1 - 16));
    v8 = *(NSObject **)(a1 + 168);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3321888768;
    block[2] = ___ZN15HTTP2Connection13sendRSTStreamENSt3__110shared_ptrI11HTTP2StreamEE18nghttp2_error_code_block_invoke;
    block[3] = &__block_descriptor_60_e8_40c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE_e5_v8__0l;
    block[4] = a1;
    block[5] = a2;
    v17 = a3;
    if (a3)
    {
      v9 = (unint64_t *)&a3->__shared_owners_;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v18 = 8;
    dispatch_async(v8, block);
    v11 = v17;
    if (!v17)
      goto LABEL_13;
    v12 = (unint64_t *)&v17->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (v13)
    {
LABEL_13:
      if (!a3)
        return;
    }
    else
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
      if (!a3)
        return;
    }
    v14 = (unint64_t *)&a3->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
      std::__shared_weak_count::__release_weak(a3);
    }
  }
}

void sub_18400FB4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN15HTTP2Connection13sendRSTStreamENSt3__110shared_ptrI11HTTP2StreamEE18nghttp2_error_code_block_invoke(uint64_t a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  void *v5;
  unint64_t *v6;
  unint64_t v7;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  if (*(_QWORD *)(v1 + 160))
  {
    if ((nghttp2_submit_rst_stream() & 0x80000000) != 0)
      HTTP2Connection::closeConnection((HTTP2Connection *)v1, 0);
    v5 = *(void **)(v1 + 128);
    if (v5)
      dispatch_async(*(dispatch_queue_t *)(v1 + 168), v5);
  }
  if (v2)
  {
    v6 = (unint64_t *)&v2->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  CFRelease((CFTypeRef)(v1 - 16));
}

void sub_18400FC18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<IOConnWrapper>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F08D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<IOConnWrapper>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F08D8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void ___ZN15HTTP2Connection10initializeEP4TubeiP25HTTP2ConnectionCacheEntry_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  CFNumberRef v2;
  uint64_t v3;
  dispatch_source_t v4;
  NSObject *v5;
  double Current;
  double v7;
  int64_t v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  dispatch_time_t v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  _QWORD v16[2];
  void (*v17)(uint64_t);
  void *v18;
  CFNumberRef v19;
  _QWORD handler[5];
  _BYTE valuePtr[24];
  void *v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v1 + 642) && *(_QWORD *)(v1 + 56))
  {
    *(_DWORD *)valuePtr = 3;
    v2 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, valuePtr);
    v16[0] = MEMORY[0x1E0C809B0];
    v16[1] = 3221225472;
    v17 = ___ZN15HTTP2Connection11handleStallEv_block_invoke;
    v18 = &__block_descriptor_40_e5_v8__0l;
    v19 = v2;
    if (!v2 || (v3 = *(_QWORD *)(v1 + 56), *(_DWORD *)v3 == 2))
    {
      ___ZN15HTTP2Connection11handleStallEv_block_invoke((uint64_t)v16);
    }
    else
    {
      if (*(_DWORD *)v3 != 1)
        __assert_rtn("setProperty", "TCPIOConnectionTest.hpp", 247, "false");
      (*(void (**)(_QWORD, uint64_t, CFNumberRef))(**(_QWORD **)(v3 + 8) + 200))(*(_QWORD *)(v3 + 8), 0x1EDCF9DF0, v2);
      v17((uint64_t)v16);
    }
  }
  if (*(_DWORD *)(v1 + 176) == 2 && *(_BYTE *)(v1 + 641) && !*(_QWORD *)(v1 + 720))
  {
    v4 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(v1 + 168));
    v5 = *(NSObject **)(v1 + 720);
    *(_QWORD *)(v1 + 720) = v4;
    if (v5)
      dispatch_release(v5);
    Current = CFAbsoluteTimeGetCurrent();
    v7 = Current - *(double *)(v1 + 248);
    if (v7 >= 30.0)
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v9 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v10 = *(_QWORD *)(v1 + 72);
        *(_DWORD *)valuePtr = 134218240;
        *(_QWORD *)&valuePtr[4] = v10;
        *(_WORD *)&valuePtr[12] = 2048;
        *(double *)&valuePtr[14] = v7;
        _os_log_impl(&dword_183ECA000, v9, OS_LOG_TYPE_DEFAULT, "Connection %llu idle %f will initiate stall recovery", valuePtr, 0x16u);
      }
      v8 = 0;
      *(double *)(v1 + 256) = Current + -3.0;
    }
    else
    {
      *(_QWORD *)(v1 + 256) = 0;
      v8 = (uint64_t)((30.0 - v7) * 1000000000.0);
    }
    v11 = *(NSObject **)(v1 + 720);
    v12 = dispatch_time(0x8000000000000000, v8);
    dispatch_source_set_timer(v11, v12, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    CFRetain((CFTypeRef)(v1 - 16));
    v13 = MEMORY[0x1E0C809B0];
    v14 = *(NSObject **)(v1 + 720);
    *(_QWORD *)valuePtr = MEMORY[0x1E0C809B0];
    *(_QWORD *)&valuePtr[8] = 3221225472;
    *(_QWORD *)&valuePtr[16] = ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke;
    v22 = &__block_descriptor_40_e5_v8__0l;
    v23 = v1;
    dispatch_source_set_cancel_handler(v14, valuePtr);
    v15 = *(NSObject **)(v1 + 720);
    handler[0] = v13;
    handler[1] = 3221225472;
    handler[2] = ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke_55;
    handler[3] = &__block_descriptor_40_e5_v8__0l;
    handler[4] = v1;
    dispatch_source_set_event_handler(v15, handler);
    dispatch_resume(*(dispatch_object_t *)(v1 + 720));
  }
}

void sub_18400FF50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void (*a11)(uint64_t *))
{
  a11(&a9);
  _Unwind_Resume(a1);
}

uint64_t BlockHolderVar<>::invoke_initial(_QWORD *a1)
{
  a1[1] = BlockHolderVar<>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

void std::__shared_ptr_pointer<BlockHolderVar<> *,SmartBlockWithArgs<>::Deleter,std::allocator<BlockHolderVar<>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_emplace<HTTPStallTimer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F09B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTPStallTimer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F09B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void ___ZN15HTTP2Connection11handleStallEv_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    v3 = *(_QWORD *)(v1 + 72);
    v4 = 134217984;
    v5 = v3;
    _os_log_debug_impl(&dword_183ECA000, v2, OS_LOG_TYPE_DEBUG, "Connection %llu recovery timer canceled", (uint8_t *)&v4, 0xCu);
  }
  CFRelease((CFTypeRef)(v1 - 16));
}

void ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke_55(uint64_t a1)
{
  uint64_t v1;
  double Current;
  double v3;
  double v4;
  NSObject *v5;
  dispatch_time_t v6;
  NSObject *v7;
  uint64_t v8;
  CFIndex Count;
  CFIndex v10;
  const void *ValueAtIndex;
  std::__shared_weak_count *v12;
  HTTP2Stream *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  _QWORD v23[5];
  uint8_t buf[16];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  Current = CFAbsoluteTimeGetCurrent();
  v3 = *(double *)(v1 + 256);
  if (v3 == 0.0)
  {
    *(double *)(v1 + 256) = Current;
    v3 = Current;
  }
  v4 = Current - v3;
  if (v4 < 9.0)
  {
    v5 = *(NSObject **)(v1 + 720);
    v6 = dispatch_time(0x8000000000000000, (uint64_t)((9.0 - v4) * 1000000000.0));
    dispatch_source_set_timer(v5, v6, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    v23[0] = MEMORY[0x1E0C809B0];
    v23[1] = 3221225472;
    v23[2] = ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke_2;
    v23[3] = &__block_descriptor_40_e23_v24__0____CFError__8d16l;
    v23[4] = v1;
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v1 + 56))(v1, v23);
    return;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v7 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *(_QWORD *)(v1 + 72);
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = v8;
    _os_log_impl(&dword_183ECA000, v7, OS_LOG_TYPE_DEFAULT, "Connection %llu reached max hang time, will retry applicable streams", buf, 0xCu);
  }
  if (*(_QWORD *)(v1 + 720))
    HTTP2Connection::stopStallRecovery((dispatch_source_t *)v1);
  *(_BYTE *)(v1 + 264) = 1;
  HTTP2Connection::stop((HTTP2Connection *)v1, 0);
  *(_OWORD *)buf = xmmword_1841E38A0;
  Count = CFArrayGetCount(*(CFArrayRef *)(v1 + 232));
  if (Count >= 1)
  {
    v10 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 232), v10);
      v13 = (HTTP2Stream *)*((_QWORD *)ValueAtIndex + 3);
      v12 = (std::__shared_weak_count *)*((_QWORD *)ValueAtIndex + 4);
      if (v12)
      {
        p_shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          v15 = __ldxr(p_shared_owners);
        while (__stxr(v15 + 1, p_shared_owners));
      }
      v16 = *((_QWORD *)v13 + 2);
      if (v16)
      {
        if ((*(unsigned int (**)(uint64_t, uint8_t *, _QWORD))(*(_QWORD *)v16 + 280))(v16, buf, 0) - 5 <= 5)
          break;
      }
      if (v12)
        goto LABEL_27;
LABEL_31:
      if (++v10 == Count)
        return;
    }
    HTTP2Stream::setError(v13, *(CFStreamError *)buf);
    HTTP2Stream::closeStreamWithErrorCode(v13);
    if (v12)
    {
      v17 = (unint64_t *)&v12->__shared_owners_;
      do
        v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
    }
    HTTP2Connection::cancelStream(v1, (uint64_t)v13, v12);
    if (!v12)
      goto LABEL_31;
    v19 = (unint64_t *)&v12->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
LABEL_27:
    v21 = (unint64_t *)&v12->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    goto LABEL_31;
  }
}

void sub_1840103A4(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
    v5 = (unint64_t *)&v1->__shared_owners_;
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;
  dispatch_time_t v4;

  v2 = *(_QWORD *)(a1 + 32);
  if (a2)
  {
    if (*(_QWORD *)(v2 + 720))
      HTTP2Connection::stopStallRecovery((dispatch_source_t *)v2);
  }
  else
  {
    *(_QWORD *)(v2 + 256) = 0;
    v3 = *(NSObject **)(v2 + 720);
    if (v3)
    {
      v4 = dispatch_time(0x8000000000000000, 45000000000);
      dispatch_source_set_timer(v3, v4, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    }
  }
}

uint64_t ___ZN15HTTP2Connection20initializeConnectionEv_block_invoke_34(uint64_t a1)
{
  return IOConnWrapper::copyProperty(*(IOConnWrapper **)(*(_QWORD *)(a1 + 32) + 56), CFSTR("__kCFStreamPropertyDoNotReuse"));
}

void std::__shared_ptr_emplace<PropertyObserver>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0B78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PropertyObserver>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0B78;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<HTTP2Connection *,Deleter_release<HTTP2Connection>,std::allocator<HTTP2Connection>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void NotificationStation::~NotificationStation(NotificationStation *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = 0;
  if (v2)
    (*((void (**)(void))this + 10))();
  std::mutex::~mutex((std::mutex *)((char *)this + 8));
  std::unique_ptr<std::map<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>,CFStringRefComp,std::allocator<std::pair<std::unique_ptr<__CFString const,void (*)(__CFString const*)> const,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>>::reset[abi:nn180100]((uint64_t *)this, 0);
}

BOOL HTTP2StreamEqualCallBack(const void *a1, const void *a2)
{
  if (!a1 || !a2)
    __assert_rtn("HTTP2StreamEqualCallBack", "HTTP2Connection.cpp", 1785, "value1 && value2");
  return a1 == a2;
}

void MemPool::~MemPool(MemPool *this)
{
  void **v2;
  void **v3;
  void *v4;

  v2 = (void **)*((_QWORD *)this + 1);
  v3 = (void **)*((_QWORD *)this + 2);
  if (v2 != v3)
  {
    do
    {
      v4 = *v2;
      v2 += 2;
      free(v4);
    }
    while (v2 != v3);
    v2 = (void **)*((_QWORD *)this + 1);
  }
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
}

uint64_t __copy_helper_block_e8_64c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(result + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(result + 72) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_64c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 64);
}

void std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::pair<std::string,std::string>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  int v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  _QWORD *v18;
  char *v19;
  float v20;
  float v21;
  _BOOL8 v22;
  unint64_t v23;
  unint64_t v24;
  size_t v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  _QWORD v29[2];
  char v30;

  v7 = *(char *)(a2 + 23);
  if (v7 >= 0)
    v8 = (uint64_t *)a2;
  else
    v8 = *(uint64_t **)a2;
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(a2 + 23);
  else
    v9 = *(_QWORD *)(a2 + 8);
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v3 = v10;
      if (v10 >= v12)
        v3 = v10 % v12;
    }
    else
    {
      v3 = (v12 - 1) & v10;
    }
    v15 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v15)
    {
      for (i = *v15; i; i = *(unsigned __int8 **)i)
      {
        v17 = *((_QWORD *)i + 1);
        if (v17 == v11)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2))
            return;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v3)
            break;
        }
      }
    }
  }
  v18 = (_QWORD *)(a1 + 16);
  v19 = (char *)operator new(0x40uLL);
  v29[0] = v19;
  v29[1] = a1 + 16;
  *(_QWORD *)v19 = 0;
  *((_QWORD *)v19 + 1) = v11;
  *((_OWORD *)v19 + 1) = *(_OWORD *)a3;
  *((_QWORD *)v19 + 4) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_OWORD *)(v19 + 40) = *(_OWORD *)(a3 + 24);
  *((_QWORD *)v19 + 7) = *(_QWORD *)(a3 + 40);
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 40) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  v30 = 1;
  v20 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v21 = *(float *)(a1 + 32);
  if (!v12 || (float)(v21 * (float)v12) < v20)
  {
    v22 = 1;
    if (v12 >= 3)
      v22 = (v12 & (v12 - 1)) != 0;
    v23 = v22 | (2 * v12);
    v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24)
      v25 = v24;
    else
      v25 = v23;
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__rehash<true>(a1, v25);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v3 = v11 % v12;
      else
        v3 = v11;
    }
    else
    {
      v3 = (v12 - 1) & v11;
    }
  }
  v26 = *(_QWORD *)a1;
  v27 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v27)
  {
    *(_QWORD *)v19 = *v27;
LABEL_44:
    *v27 = v19;
    goto LABEL_45;
  }
  *(_QWORD *)v19 = *v18;
  *v18 = v19;
  *(_QWORD *)(v26 + 8 * v3) = v18;
  if (*(_QWORD *)v19)
  {
    v28 = *(_QWORD *)(*(_QWORD *)v19 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v28 >= v12)
        v28 %= v12;
    }
    else
    {
      v28 &= v12 - 1;
    }
    v27 = (_QWORD *)(*(_QWORD *)a1 + 8 * v28);
    goto LABEL_44;
  }
LABEL_45:
  v29[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)v29);
}

void sub_184010890(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::string,std::string>::~pair(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

uint64_t ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_2(uint64_t a1, int a2)
{
  HTTP2Stream *v3;
  uint64_t v4;
  uint64_t *i;
  unsigned __int8 *v6;
  size_t v7;
  unsigned __int8 *v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  HTTP2Connection *v14;
  HTTP2Stream *v15;
  CFIndex v16;
  uint64_t v17;
  uint64_t v18;
  CFStreamError v19;
  int v20;
  NSObject *v21;
  _QWORD block[5];
  int v24;

  v3 = *(HTTP2Stream **)(a1 + 40);
  if (a2)
  {
    v4 = *(_QWORD *)(a1 + 32);
    HTTP2Stream::beginHeaders(v3);
    for (i = *(uint64_t **)(*(_QWORD *)(a1 + 56) + 96); i; i = (uint64_t *)*i)
    {
      if (*((char *)i + 39) < 0)
      {
        v6 = (unsigned __int8 *)i[2];
        v7 = i[3];
      }
      else
      {
        v6 = (unsigned __int8 *)(i + 2);
        v7 = *((unsigned __int8 *)i + 39);
      }
      if (*((char *)i + 63) < 0)
      {
        v8 = (unsigned __int8 *)i[5];
        v9 = i[6];
      }
      else
      {
        v8 = (unsigned __int8 *)(i + 5);
        v9 = *((unsigned __int8 *)i + 63);
      }
      HTTP2Stream::processHeaderLine(*(HTTP2Stream **)(a1 + 40), v6, v7, v8, v9);
    }
    v10 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_10_2502, 2);
    if (v10)
    {
      v11 = v10;
      if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v10 + 16))(v10, "h2 info push promise", 0))
      {
        (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v11 + 72))(v11, "h2 psps", CFSTR("[%llu] finish push promise processing stream_id=%d"));
        (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
      }
    }
    HTTP2Stream::endHeaders(*(HTTP2Stream **)(a1 + 40));
    v12 = *(_QWORD *)(a1 + 56);
    v13 = *(NSObject **)(v12 + 152);
    if (v13)
    {
      HTTP2Stream::bufferDataFromDataFrame(*(_QWORD *)(a1 + 40), v13, 0);
      v12 = *(_QWORD *)(a1 + 56);
    }
    v14 = (HTTP2Connection *)*(unsigned int *)(v12 + 256);
    if (!(_DWORD)v14)
    {
      v20 = *(_DWORD *)(a1 + 64);
      CFRetain((CFTypeRef)(v4 - 16));
      v21 = *(NSObject **)(v4 + 168);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ___ZN15HTTP2Connection24removeServerPushedStreamEi_block_invoke;
      block[3] = &__block_descriptor_44_e5_v8__0l;
      block[4] = v4;
      v24 = v20;
      dispatch_async(v21, block);
      goto LABEL_20;
    }
    v15 = *(HTTP2Stream **)(a1 + 40);
    v16 = HTTP2Connection::http2ErrorCodeToCFStreamError(v14);
    v18 = v17;
    v3 = v15;
    v19.domain = v16;
    *(_QWORD *)&v19.error = v18;
  }
  else
  {
    v19.domain = 1;
    *(_QWORD *)&v19.error = 53;
  }
  HTTP2Stream::setError(v3, v19);
LABEL_20:
  HTTP2Stream::closeStreamWithErrorCode(*(HTTP2Stream **)(a1 + 40));
  return HTTP2Stream::breakStreamUserDataCycle(*(_QWORD *)(a1 + 40));
}

uint64_t ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_3_28()
{
  return nghttp2_submit_priority();
}

uint64_t ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_2_24@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 485;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_20@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 477;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t HTTP2Connection::http2ErrorCodeToCFStreamError(HTTP2Connection *this)
{
  if (((_DWORD)this - 1) > 0xC)
    return 2;
  else
    return qword_1841E3400[(int)this - 1];
}

void ___ZN15HTTP2Connection24removeServerPushedStreamEi_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  HTTP2ServerPush::_removeStream((HTTP2ServerPush *)(v1 + 288), *(_DWORD *)(a1 + 40), 1);
  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_3@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 451;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](uint64_t *a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v72;
  unint64_t v73;

  if (a2 > 0x20)
  {
    if (a2 <= 0x40)
    {
      v5 = *(uint64_t *)((char *)a1 + a2 - 16);
      v6 = *a1 - 0x3C5A37A36834CED9 * (v5 + a2);
      v8 = a1[2];
      v7 = a1[3];
      v9 = __ROR8__(v6 + v7, 52);
      v10 = v6 + a1[1];
      v11 = __ROR8__(v10, 7);
      v12 = v10 + v8;
      v13 = *(uint64_t *)((char *)a1 + a2 - 32) + v8;
      v14 = *(uint64_t *)((char *)a1 + a2 - 8) + v7;
      v15 = __ROR8__(v14 + v13, 52);
      v16 = v11 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v5 + a2), 37) + v9;
      v17 = __ROR8__(v13, 37);
      v18 = *(uint64_t *)((char *)a1 + a2 - 24) + v13;
      v19 = __ROR8__(v18, 7);
      v20 = v16 + __ROR8__(v12, 31);
      v21 = v18 + v5;
      v22 = v21 + v14;
      v23 = 0x9AE16A3B2F90404FLL;
      v24 = 0xC3A5C85C97CB3127 * (v22 + v20) - 0x651E95C4D06FBFB1 * (v12 + v7 + v17 + v19 + v15 + __ROR8__(v21, 31));
      v25 = v20 - 0x3C5A37A36834CED9 * (v24 ^ (v24 >> 47));
      return (v25 ^ (v25 >> 47)) * v23;
    }
    v4 = 0x9DDFEA08EB382D69;
    v32 = *(uint64_t *)((char *)a1 + a2 - 48);
    v33 = *(uint64_t *)((char *)a1 + a2 - 40);
    v34 = *(uint64_t *)((char *)a1 + a2 - 24);
    v36 = *(uint64_t *)((char *)a1 + a2 - 64);
    v35 = *(uint64_t *)((char *)a1 + a2 - 56);
    v37 = *(uint64_t *)((char *)a1 + a2 - 16);
    v38 = *(uint64_t *)((char *)a1 + a2 - 8);
    v39 = v35 + v37;
    v40 = 0x9DDFEA08EB382D69
        * (v34 ^ ((0x9DDFEA08EB382D69 * (v34 ^ (v32 + a2))) >> 47) ^ (0x9DDFEA08EB382D69 * (v34 ^ (v32 + a2))));
    v41 = 0x9DDFEA08EB382D69 * (v40 ^ (v40 >> 47));
    v42 = v36 + a2 + v35 + v32;
    v43 = v42 + v33;
    v44 = __ROR8__(v42, 44) + v36 + a2 + __ROR8__(v33 + v36 + a2 - 0x622015F714C7D297 * (v40 ^ (v40 >> 47)), 21);
    v45 = v35 + v37 + *(uint64_t *)((char *)a1 + a2 - 32) - 0x4B6D499041670D8DLL;
    v46 = v45 + v34 + v37;
    v47 = __ROR8__(v46, 44);
    v48 = v46 + v38;
    v49 = v47 + v45 + __ROR8__(v45 + v33 + v38, 21);
    v51 = *a1;
    v50 = a1 + 4;
    v52 = v51 - 0x4B6D499041670D8DLL * v33;
    v53 = -(uint64_t)((a2 - 1) & 0xFFFFFFFFFFFFFFC0);
    do
    {
      v54 = *(v50 - 3);
      v55 = v52 + v43 + v39 + v54;
      v56 = v50[2];
      v57 = v50[3];
      v58 = v50[1];
      v39 = v58 + v43 - 0x4B6D499041670D8DLL * __ROR8__(v39 + v44 + v56, 42);
      v59 = v41 + v48;
      v60 = *(v50 - 2);
      v61 = *(v50 - 1);
      v62 = *(v50 - 4) - 0x4B6D499041670D8DLL * v44;
      v63 = v62 + v48 + v61;
      v64 = v62 + v54 + v60;
      v43 = v64 + v61;
      v65 = __ROR8__(v64, 44) + v62;
      v66 = (0xB492B66FBE98F273 * __ROR8__(v55, 37)) ^ v49;
      v52 = 0xB492B66FBE98F273 * __ROR8__(v59, 33);
      v44 = v65 + __ROR8__(v63 + v66, 21);
      v67 = v52 + v49 + *v50;
      v48 = v67 + v58 + v56 + v57;
      v49 = __ROR8__(v67 + v58 + v56, 44) + v67 + __ROR8__(v39 + v60 + v67 + v57, 21);
      v50 += 8;
      v41 = v66;
      v53 += 64;
    }
    while (v53);
    v68 = v52
        - 0x622015F714C7D297
        * ((0x9DDFEA08EB382D69
          * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) ^ ((0x9DDFEA08EB382D69 * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) >> 47));
    v69 = 0x9DDFEA08EB382D69
        * (v68 ^ (v66
                - 0x4B6D499041670D8DLL * (v39 ^ (v39 >> 47))
                - 0x622015F714C7D297
                * ((0x9DDFEA08EB382D69
                  * (v48 ^ ((0x9DDFEA08EB382D69 * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69 * (v48 ^ v43)))) ^ ((0x9DDFEA08EB382D69 * (v48 ^ ((0x9DDFEA08EB382D69 * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69 * (v48 ^ v43)))) >> 47))));
    v70 = 0x9DDFEA08EB382D69 * (v68 ^ (v69 >> 47) ^ v69);
    goto LABEL_13;
  }
  if (a2 > 0x10)
  {
    v26 = a1[1];
    v27 = 0xB492B66FBE98F273 * *a1;
    v28 = __ROR8__(0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8), 30) + __ROR8__(v27 - v26, 43);
    v29 = v27 + a2 + __ROR8__(v26 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8);
    v23 = 0x9DDFEA08EB382D69;
    v30 = 0x9DDFEA08EB382D69 * (v29 ^ (v28 - 0x3C5A37A36834CED9 * *(uint64_t *)((char *)a1 + a2 - 16)));
    v31 = v29 ^ (v30 >> 47) ^ v30;
LABEL_8:
    v25 = 0x9DDFEA08EB382D69 * v31;
    return (v25 ^ (v25 >> 47)) * v23;
  }
  if (a2 < 9)
  {
    if (a2 >= 4)
    {
      v72 = *(unsigned int *)((char *)a1 + a2 - 4);
      v23 = 0x9DDFEA08EB382D69;
      v73 = 0x9DDFEA08EB382D69 * (((8 * *(_DWORD *)a1) + a2) ^ v72);
      v31 = v72 ^ (v73 >> 47) ^ v73;
      goto LABEL_8;
    }
    v4 = 0x9AE16A3B2F90404FLL;
    if (!a2)
      return v4;
    v70 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                   * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
LABEL_13:
    v4 *= v70 ^ (v70 >> 47);
    return v4;
  }
  v2 = *(uint64_t *)((char *)a1 + a2 - 8);
  v3 = __ROR8__(v2 + a2, a2);
  return (0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69
          * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) ^ ((0x9DDFEA08EB382D69 * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) >> 47))) ^ v2;
}

BOOL std::equal_to<std::string>::operator()[abi:nn180100](unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  BOOL v12;
  BOOL v13;
  _BOOL8 v14;

  v2 = a1[23];
  if ((v2 & 0x80u) == 0)
    v3 = a1[23];
  else
    v3 = *((_QWORD *)a1 + 1);
  v4 = a2[23];
  v5 = (char)v4;
  if ((v4 & 0x80u) != 0)
    v4 = *((_QWORD *)a2 + 1);
  if (v3 != v4)
    return 0;
  if (v5 < 0)
    a2 = *(unsigned __int8 **)a2;
  if ((v2 & 0x80) != 0)
    return memcmp(*(const void **)a1, a2, *((_QWORD *)a1 + 1)) == 0;
  if (!a1[23])
    return 1;
  v6 = v2 - 1;
  do
  {
    v8 = *a1++;
    v7 = v8;
    v10 = *a2++;
    v9 = v10;
    v12 = v6-- != 0;
    v13 = v7 == v9;
    v14 = v7 == v9;
  }
  while (v13 && v12);
  return v14;
}

void std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  void *v5;
  void *v6;
  uint64_t v7;
  _QWORD *v8;
  size_t v9;
  uint8x8_t v10;
  unint64_t v11;
  uint8x8_t v12;
  uint64_t v13;
  _QWORD *v14;
  size_t v15;
  void *v16;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(_QWORD *)&v4)
  {
    if (prime >= *(_QWORD *)&v4)
      return;
    v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      v11 = std::__next_prime(v11);
    }
    else
    {
      v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2)
        v11 = v13;
    }
    if (prime <= v11)
      prime = v11;
    if (prime >= *(_QWORD *)&v4)
      return;
    if (!prime)
    {
      v16 = *(void **)a1;
      *(_QWORD *)a1 = 0;
      if (v16)
        operator delete(v16);
      *(_QWORD *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  v5 = operator new(8 * prime);
  v6 = *(void **)a1;
  *(_QWORD *)a1 = v5;
  if (v6)
    operator delete(v6);
  v7 = 0;
  *(_QWORD *)(a1 + 8) = prime;
  do
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  v8 = *(_QWORD **)(a1 + 16);
  if (v8)
  {
    v9 = v8[1];
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime)
        v9 %= prime;
    }
    else
    {
      v9 &= prime - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v9) = a1 + 16;
    v14 = (_QWORD *)*v8;
    if (*v8)
    {
      do
      {
        v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime)
            v15 %= prime;
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v15))
          {
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          *v8 = *v14;
          *v14 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v15);
          **(_QWORD **)(*(_QWORD *)a1 + 8 * v15) = v14;
          v14 = v8;
        }
        v15 = v9;
LABEL_31:
        v8 = v14;
        v14 = (_QWORD *)*v14;
        v9 = v15;
      }
      while (v14);
    }
  }
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>((uint64_t)v1 + 16);
    operator delete(v1);
  }
}

void HTTP2Connection::setErrorOnAllStreams(HTTP2Connection *this, int a2)
{
  NSObject *v4;
  _QWORD v5[5];
  int v6;

  CFRetain((char *)this - 16);
  v4 = *((_QWORD *)this + 21);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN15HTTP2Connection20setErrorOnAllStreamsEj_block_invoke;
  v5[3] = &__block_descriptor_44_e5_v8__0l;
  v5[4] = this;
  v6 = a2;
  dispatch_async(v4, v5);
}

void ___ZN15HTTP2Connection20setErrorOnAllStreamsEj_block_invoke(uint64_t a1)
{
  CFIndex v1;
  uint64_t v2;
  HTTP2Connection *v3;
  const void *ValueAtIndex;
  std::__shared_weak_count *v5;
  HTTP2Stream *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  CFIndex v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  CFStreamError v14;

  v1 = 0;
  v2 = *(_QWORD *)(a1 + 32);
  v3 = (HTTP2Connection *)*(unsigned int *)(a1 + 40);
  while (v1 < CFArrayGetCount(*(CFArrayRef *)(v2 + 232)))
  {
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 232), v1);
    v6 = (HTTP2Stream *)*((_QWORD *)ValueAtIndex + 3);
    v5 = (std::__shared_weak_count *)*((_QWORD *)ValueAtIndex + 4);
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }
    v9 = HTTP2Connection::http2ErrorCodeToCFStreamError(v3);
    v11 = v10;
    v14.domain = v9;
    *(_QWORD *)&v14.error = v11;
    HTTP2Stream::setError(v6, v14);
    if (v5)
    {
      v12 = (unint64_t *)&v5->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    ++v1;
  }
  CFRelease((CFTypeRef)(v2 - 16));
}

void ___ZN15HTTP2Connection20changeStreamPriorityENSt3__110shared_ptrI11HTTP2StreamEEl_block_invoke(_QWORD *a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  uint64_t v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  void *v6;
  unint64_t *v7;
  unint64_t v8;

  v1 = a1[4];
  if (*(_QWORD *)(v1 + 160))
  {
    v3 = a1[5];
    v2 = (std::__shared_weak_count *)a1[6];
    if (v2)
    {
      p_shared_owners = (unint64_t *)&v2->__shared_owners_;
      do
        v5 = __ldxr(p_shared_owners);
      while (__stxr(v5 + 1, p_shared_owners));
    }
    if ((*(_DWORD *)(v3 + 56) & 0xFFFFFFFE) != 2)
    {
      nghttp2_priority_spec_init();
      if (!nghttp2_submit_priority())
      {
        v6 = *(void **)(v1 + 128);
        if (v6)
          dispatch_async(*(dispatch_queue_t *)(v1 + 168), v6);
      }
    }
    if (v2)
    {
      v7 = (unint64_t *)&v2->__shared_owners_;
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }
  }
  CFRelease((CFTypeRef)(v1 - 16));
}

void sub_18401161C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_40c40_ZTSKNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c40_ZTSKNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

std::string *HTTP2Diagnostic::APPEND_RECV_HEADER(std::string *a1, uint64_t a2, uint64_t a3, int a4, unint64_t a5)
{
  std::string *p_p;
  std::string::size_type size;
  std::string *v12;
  std::string::size_type v13;
  int v14;
  const std::string::value_type *v15;
  std::string::size_type v16;
  std::string *v17;
  std::string::size_type v18;
  std::string __p;

  std::string::append(a1, "[");
  std::to_string(&__p, a5);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  std::string::append(a1, (const std::string::value_type *)p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  std::string::append(a1, "] recv (stream_id=");
  std::to_string(&__p, a4);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v12 = &__p;
  else
    v12 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v13 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v13 = __p.__r_.__value_.__l.__size_;
  std::string::append(a1, (const std::string::value_type *)v12, v13);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  std::string::append(a1, ") ");
  v14 = *(char *)(a2 + 23);
  if (v14 >= 0)
    v15 = (const std::string::value_type *)a2;
  else
    v15 = *(const std::string::value_type **)a2;
  if (v14 >= 0)
    v16 = *(unsigned __int8 *)(a2 + 23);
  else
    v16 = *(_QWORD *)(a2 + 8);
  std::string::append(a1, v15, v16);
  std::string::append(a1, ": ");
  if (__CFNCanLogSensitiveContent::onceToken != -1)
    dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_26_4798);
  if (__CFNCanLogSensitiveContent::ok)
  {
    if (*(char *)(a3 + 23) < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
    else
      __p = *(std::string *)a3;
  }
  else
  {
    std::string::basic_string[abi:nn180100]<0>(&__p, "<redacted>");
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = &__p;
  else
    v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v18 = __p.__r_.__value_.__l.__size_;
  std::string::append(a1, (const std::string::value_type *)v17, v18);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return std::string::append(a1, "\n");
}

void sub_184011830(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN15HTTP2Connection22handlePUSHPROMISEframeEPK13nghttp2_frame_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 1272;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN15HTTP2Connection18handleHEADERSFrameEPK13nghttp2_frame_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 1301;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t _CFHTTPAuthenticationUpdateFromResponse(uint64_t a1, __CFHTTPMessage *a2, void *a3)
{
  HTTPAuthentication *v6;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (a1)
    v6 = (HTTPAuthentication *)(a1 + 16);
  else
    v6 = 0;
  return HTTPAuthentication::updateFromResponse(v6, a2, a3);
}

Boolean CFHTTPAuthenticationIsValid(CFHTTPAuthenticationRef auth, CFStreamError *error)
{
  char *v4;
  CFIndex v5;
  uint64_t v7;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (auth)
    v4 = (char *)auth + 16;
  else
    v4 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
  v5 = *((_QWORD *)v4 + 11);
  v7 = *((_QWORD *)v4 + 12);
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 16));
  if (error)
  {
    error->domain = v5;
    *(_QWORD *)&error->error = v7;
  }
  return (_DWORD)v7 == 0;
}

const __CFString *_CFHTTPAuthenticationIsConnectionBasedAuth(_CFHTTPAuthentication *a1)
{
  HTTPAuthentication *v2;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (a1)
    v2 = (_CFHTTPAuthentication *)((char *)a1 + 16);
  else
    v2 = 0;
  return HTTPAuthentication::isConnectionBasedAuth(v2);
}

Boolean CFHTTPAuthenticationRequiresOrderedRequests(CFHTTPAuthenticationRef auth)
{
  char *v2;
  const __CFString *Property_Locked;
  Boolean v4;
  int ExactString;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (auth)
    v2 = (char *)auth + 16;
  else
    v2 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 16));
  Property_Locked = (const __CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)v2, CFSTR("kCFHTTPAuthenticationPropertyMethod"));
  v4 = 1;
  ExactString = _findExactString(Property_Locked, 1u);
  if (ExactString != 6324248 && ExactString != 5316627)
  {
    if (ExactString == 2146311)
    {
      if (!HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)v2, CFSTR("Nextnonce")))
        v4 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)v2, CFSTR("Qop")) != 0;
    }
    else
    {
      v4 = 0;
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v2 + 16));
  return v4;
}

Boolean CFHTTPMessageApplyCredentials(CFHTTPMessageRef request, CFHTTPAuthenticationRef auth, CFStringRef username, CFStringRef password, CFStreamError *error)
{
  const __CFAllocator *v10;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v12;
  HTTPAuthentication *v13;
  const __CFAllocator *v14;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v16;
  const void *ValueAtIndex;
  const void *v18;
  __CFDictionary *v19;
  Boolean v20;

  v10 = CFGetAllocator(request);
  Mutable = CFDictionaryCreateMutable(v10, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v12 = Mutable;
    if (username)
    {
      if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
        dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
      if (auth)
        v13 = (CFHTTPAuthenticationRef)((char *)auth + 16);
      else
        v13 = 0;
      if (HTTPAuthentication::requiresAccountDomain(v13))
      {
        v14 = CFGetAllocator(username);
        ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v14, username, CFSTR("\\"));
        if (ArrayBySeparatingStrings)
        {
          v16 = ArrayBySeparatingStrings;
          if (CFArrayGetCount(ArrayBySeparatingStrings) == 2)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(v16, 0);
            CFDictionaryAddValue(v12, CFSTR("kCFHTTPAuthenticationAccountDomain"), ValueAtIndex);
            v18 = CFArrayGetValueAtIndex(v16, 1);
            v19 = v12;
          }
          else
          {
            v19 = v12;
            v18 = username;
          }
          CFDictionaryAddValue(v19, CFSTR("kCFHTTPAuthenticationUsername"), v18);
          CFRelease(v16);
          if (!password)
            goto LABEL_15;
          goto LABEL_14;
        }
      }
      CFDictionaryAddValue(v12, CFSTR("kCFHTTPAuthenticationUsername"), username);
    }
    if (!password)
    {
LABEL_15:
      v20 = CFHTTPMessageApplyCredentialDictionary(request, auth, v12, error);
      CFRelease(v12);
      LOBYTE(Mutable) = v20;
      return Mutable;
    }
LABEL_14:
    CFDictionaryAddValue(v12, CFSTR("kCFHTTPAuthenticationPassword"), password);
    goto LABEL_15;
  }
  return Mutable;
}

Boolean CFHTTPMessageApplyCredentialDictionary(CFHTTPMessageRef request, CFHTTPAuthenticationRef auth, CFDictionaryRef dict, CFStreamError *error)
{
  char *v8;
  Boolean v9;
  Boolean v10;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (auth)
    v8 = (char *)auth + 16;
  else
    v8 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(v8 + 16));
  HTTPAuthentication::applyCredentials_Locked((CFMutableDictionaryRef *)v8, request, dict, error);
  v10 = v9;
  pthread_mutex_unlock((pthread_mutex_t *)(v8 + 16));
  return v10;
}

Boolean CFHTTPAuthenticationRequiresAccountDomain(CFHTTPAuthenticationRef auth)
{
  HTTPAuthentication *v2;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (auth)
    v2 = (CFHTTPAuthenticationRef)((char *)auth + 16);
  else
    v2 = 0;
  return HTTPAuthentication::requiresAccountDomain(v2);
}

Boolean CFHTTPAuthenticationAppliesToRequest(CFHTTPAuthenticationRef auth, CFHTTPMessageRef request)
{
  HTTPAuthentication *v4;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (auth)
    v4 = (CFHTTPAuthenticationRef)((char *)auth + 16);
  else
    v4 = 0;
  return HTTPAuthentication::appliesToRequest(v4, request);
}

CFTypeID CFHTTPAuthenticationGetTypeID(void)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  return *(_QWORD *)(HTTPAuthentication::Class(void)::sClass_OBJTYPE + 96);
}

_OWORD *_CFHTTPAuthenticationCreateFromResponseInternal(const __CFAllocator *a1, CFHTTPMessageRef response, const __CFString *a3, char a4, const void *a5, const __CFString *a6, const __CFString *a7, const __CFUUID *a8, char a9, unsigned __int8 a10)
{
  CFIndex ResponseStatusCode;
  CFIndex v17;
  uint64_t v18;
  const void *v19;
  _OWORD *v21;
  _OWORD *Instance;
  HTTPAuthentication *v23;
  const __CFUUID *v24;

  if (!response)
    return 0;
  ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(response);
  v17 = ResponseStatusCode;
  if (ResponseStatusCode != 407 && ResponseStatusCode != 401)
    return 0;
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v18 = 88;
  if (v17 == 407)
    v18 = 96;
  v19 = *(const void **)((char *)response + v18);
  if (v19 && CFHTTPAuthenticationIsValid(*(CFHTTPAuthenticationRef *)((char *)response + v18), 0))
    return CFRetain(v19);
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v21 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    Instance[14] = 0u;
    Instance[15] = 0u;
    Instance[12] = 0u;
    Instance[13] = 0u;
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
    HTTPAuthentication::HTTPAuthentication((HTTPAuthentication *)(Instance + 1));
    *((_BYTE *)v21 + 177) = a4;
    HTTPAuthentication::_initialize(v23, response, 0, a5, a6, a7, v24);
    HTTPAuthentication::initializeSchemes((HTTPAuthentication *)(v21 + 1), response, a3);
  }
  else
  {
    HTTPAuthentication::HTTPAuthentication(0);
  }
  return v21;
}

CFHTTPAuthenticationRef CFHTTPAuthenticationCreateFromResponse(CFAllocatorRef alloc, CFHTTPMessageRef response)
{
  unsigned __int8 v3;

  return (CFHTTPAuthenticationRef)_CFHTTPAuthenticationCreateFromResponseInternal(alloc, response, 0, 1, 0, 0, 0, 0, 0, v3);
}

_OWORD *_CFHTTPAuthenticationCreateFromResponseWithFlags(const __CFAllocator *a1, __CFHTTPMessage *a2, __CFUUID *a3, char a4)
{
  unsigned __int8 v5;

  return _CFHTTPAuthenticationCreateFromResponseInternal(a1, a2, 0, 1, 0, 0, 0, a3, a4, v5);
}

CFDictionaryRef _CFHTTPAuthenticationApplyHeaderToRequest(_CFHTTPAuthentication *a1, __CFHTTPMessage *a2, const void *a3)
{
  CFDictionaryRef *v6;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (a1)
    v6 = (CFDictionaryRef *)((char *)a1 + 16);
  else
    v6 = 0;
  return HTTPAuthentication::applyHeaderToRequest(v6, a2, a3);
}

uint64_t _CFHTTPAuthenticationDisassociateConnection(uint64_t a1, const void *a2)
{
  uint64_t v4;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (a1)
    v4 = a1 + 16;
  else
    v4 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v4 + 152), a2);
  return pthread_mutex_unlock((pthread_mutex_t *)(v4 + 16));
}

uint64_t _CFHTTPAuthenticationSetPreferredScheme(uint64_t a1, const void *a2)
{
  uint64_t v4;
  const __CFDictionary *v5;
  const void *Value;
  CFTypeRef v7;
  const void *v8;
  uint64_t v9;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (a1)
    v4 = a1 + 16;
  else
    v4 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
  v5 = *(const __CFDictionary **)(v4 + 144);
  if (v5 && (Value = CFDictionaryGetValue(v5, a2)) != 0)
  {
    v7 = CFRetain(Value);
    v8 = *(const void **)(v4 + 136);
    *(_QWORD *)(v4 + 136) = v7;
    if (v8)
      CFRelease(v8);
    v9 = 1;
  }
  else
  {
    v9 = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 16));
  return v9;
}

BOOL _CFHTTPAuthenticationRequiresPersistentConnection(CFHTTPAuthenticationRef auth)
{
  __CFString *v2;
  _BOOL8 v4;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  v2 = (__CFString *)CFHTTPAuthenticationCopyMethod(auth);
  if (!v2)
    return 0;
  v4 = v2 == CFSTR("Negotiate") || v2 == CFSTR("NTLM");
  CFRelease(v2);
  return v4;
}

CFStringRef CFHTTPAuthenticationCopyRealm(CFHTTPAuthenticationRef auth)
{
  HTTPAuthentication *v2;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (auth)
    v2 = (CFHTTPAuthenticationRef)((char *)auth + 16);
  else
    v2 = 0;
  return (CFStringRef)HTTPAuthentication::copyRealm(v2);
}

CFArrayRef CFHTTPAuthenticationCopyDomains(CFHTTPAuthenticationRef auth)
{
  HTTPAuthentication *v2;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (auth)
    v2 = (CFHTTPAuthenticationRef)((char *)auth + 16);
  else
    v2 = 0;
  return (CFArrayRef)HTTPAuthentication::lockAndCopyProperty(v2, CFSTR("Domain"));
}

CFStringRef CFHTTPAuthenticationCopyMethod(CFHTTPAuthenticationRef auth)
{
  HTTPAuthentication *v2;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (auth)
    v2 = (CFHTTPAuthenticationRef)((char *)auth + 16);
  else
    v2 = 0;
  return HTTPAuthentication::lockAndCopyProperty(v2, CFSTR("kCFHTTPAuthenticationPropertyMethod"));
}

Boolean CFHTTPAuthenticationRequiresUserNameAndPassword(CFHTTPAuthenticationRef auth)
{
  return 1;
}

BOOL _CFHTTPAuthenticationPasswordInClear(uint64_t a1)
{
  uint64_t v2;
  pthread_mutex_t *v3;
  __CFString *Property_Locked;
  BOOL v5;
  _BOOL8 result;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (a1)
    v2 = a1 + 16;
  else
    v2 = 0;
  v3 = (pthread_mutex_t *)(v2 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 16));
  Property_Locked = (__CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)v2, CFSTR("kCFHTTPAuthenticationPropertyMethod"));
  pthread_mutex_unlock(v3);
  result = 1;
  if (Property_Locked)
  {
    v5 = Property_Locked == CFSTR("Digest") || Property_Locked == CFSTR("Negotiate");
    if (v5 || Property_Locked == CFSTR("NTLM"))
      return 0;
  }
  return result;
}

BOOL _CFHTTPAuthenticationConnectionAuthenticated(_CFHTTPAuthentication *a1, const void *a2)
{
  _QWORD *Value;
  _QWORD *v5;
  __CFString *Property_Locked;
  _BOOL8 v7;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  pthread_mutex_lock((pthread_mutex_t *)((char *)a1 + 32));
  Value = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 21), a2);
  if (!Value)
    goto LABEL_6;
  v5 = Value;
  Property_Locked = (__CFString *)HTTPAuthentication::getProperty_Locked((_CFHTTPAuthentication *)((char *)a1 + 16), CFSTR("kCFHTTPAuthenticationPropertyMethod"));
  if (Property_Locked == CFSTR("NTLM"))
  {
    if (v5[2])
      goto LABEL_12;
    goto LABEL_10;
  }
  if (Property_Locked == CFSTR("Negotiate"))
  {
    if (!v5[2])
      goto LABEL_12;
LABEL_10:
    if (v5[1])
    {
      v7 = *v5 == 0;
      goto LABEL_13;
    }
LABEL_12:
    v7 = 0;
    goto LABEL_13;
  }
LABEL_6:
  v7 = 1;
LABEL_13:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)a1 + 32));
  return v7;
}

_CFHTTPAuthentication *_CFHTTPMessageCanRetry(__CFHTTPMessage *a1)
{
  _BOOL4 v2;
  _CFHTTPAuthentication *result;

  v2 = CFHTTPMessageGetResponseStatusCode(a1) == 407;
  result = (_CFHTTPAuthentication *)_CFHTTPMessageGetAuthentication(a1, v2);
  if (result)
    return (_CFHTTPAuthentication *)CFHTTPAuthenticationIsValid(result, 0);
  return result;
}

Boolean CFHTTPMessageAddAuthentication(CFHTTPMessageRef request, CFHTTPMessageRef authenticationFailureResponse, CFStringRef username, CFStringRef password, CFStringRef authenticationScheme, Boolean forProxy)
{
  const __CFString *v6;
  char *v10;
  const __CFAllocator *v12;
  CFStreamError *v13;
  Boolean v14;
  int v15;
  CFStreamError *v16;
  const __CFString *v17;
  const __CFAllocator *v18;
  const __CFDictionary *v19;
  Boolean v20;
  __CFString *Property_Locked;
  const void *Value;
  const void *v23;
  const void *v25;
  const void *v26;
  unsigned __int8 v27;
  void *values[2];
  void *keys[3];

  v6 = (const __CFString *)forProxy;
  v10 = (char *)authenticationFailureResponse;
  keys[2] = *(void **)MEMORY[0x1E0C80C00];
  if (!authenticationFailureResponse
    || (v12 = CFGetAllocator(authenticationFailureResponse),
        (v10 = (char *)_CFHTTPAuthenticationCreateFromResponseInternal(v12, (CFHTTPMessageRef)v10, authenticationScheme, 1, 0, 0, 0, 0, 0, v27)) == 0))
  {
    v15 = 0;
    if (!authenticationScheme)
      goto LABEL_38;
    goto LABEL_9;
  }
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  pthread_mutex_lock((pthread_mutex_t *)(v10 + 32));
  if (!authenticationScheme)
  {
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
    Property_Locked = (__CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)(v10 + 16), CFSTR("kCFHTTPAuthenticationPropertyMethod"));
    if (Property_Locked != CFSTR("NTLM"))
    {
      authenticationScheme = Property_Locked;
      goto LABEL_37;
    }
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
    authenticationScheme = CFSTR("Digest");
    Value = CFDictionaryGetValue(*((CFDictionaryRef *)v10 + 20), CFSTR("Digest"));
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication == -1)
    {
      if (!Value)
      {
LABEL_32:
        authenticationScheme = (CFStringRef)gConstantCFStringValueTable;
        Value = CFDictionaryGetValue(*((CFDictionaryRef *)v10 + 20), gConstantCFStringValueTable);
        if (!Value)
        {
LABEL_40:
          v14 = 0;
          goto LABEL_41;
        }
        if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
        {
          v26 = Value;
          dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
          Value = v26;
        }
      }
    }
    else
    {
      v25 = Value;
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
      Value = v25;
      if (!v25)
        goto LABEL_32;
    }
    v23 = (const void *)*((_QWORD *)v10 + 19);
    *((_QWORD *)v10 + 19) = Value;
    if (v23)
      CFRelease(v23);
LABEL_37:
    v15 = 1;
    if (!authenticationScheme)
    {
LABEL_38:
      v14 = 0;
      if (!v15)
        return v14;
      goto LABEL_41;
    }
LABEL_9:
    if (CFStringCompare(authenticationScheme, (CFStringRef)gConstantCFStringValueTable, 1uLL) == kCFCompareEqualTo)
    {
      v14 = HTTPAuthentication::setBasicAuthenticationOnRequest_NoAuthFromResponse(request, username, password, v6, 0, v16);
      if ((v15 & 1) == 0)
        return v14;
      goto LABEL_41;
    }
    if (!v15)
      return 0;
LABEL_11:
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
    if (!*((_DWORD *)v10 + 28) && CFStringCompare(authenticationScheme, CFSTR("Digest"), 1uLL) == kCFCompareEqualTo)
    {
      if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
        dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
      v17 = (const __CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)(v10 + 16), CFSTR("kCFHTTPAuthenticationPropertyMethod"));
      if (CFStringCompare(authenticationScheme, v17, 1uLL) == kCFCompareEqualTo)
      {
        keys[0] = CFSTR("kCFHTTPAuthenticationUsername");
        keys[1] = CFSTR("kCFHTTPAuthenticationPassword");
        values[0] = (void *)username;
        values[1] = (void *)password;
        v18 = CFGetAllocator(request);
        v19 = CFDictionaryCreate(v18, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
          dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
        HTTPAuthentication::applyCredentials_Locked((CFMutableDictionaryRef *)v10 + 2, request, v19, 0);
        v14 = v20;
        CFRelease(v19);
        goto LABEL_41;
      }
    }
    goto LABEL_40;
  }
  if (CFStringCompare(authenticationScheme, (CFStringRef)gConstantCFStringValueTable, 1uLL))
    goto LABEL_11;
  v14 = HTTPAuthentication::setBasicAuthenticationOnRequest_NoAuthFromResponse(request, username, password, v6, 0, v13);
LABEL_41:
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  pthread_mutex_unlock((pthread_mutex_t *)(v10 + 32));
  CFRelease(v10);
  return v14;
}

unsigned __int8 *_CFHTTPAuthenticationIsFirstNTLMTransaction(_CFHTTPAuthentication *a1, void *key)
{
  unsigned __int8 *result;

  result = 0;
  if (a1 && key)
  {
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
    result = (unsigned __int8 *)*((_QWORD *)a1 + 21);
    if (result)
    {
      result = (unsigned __int8 *)CFDictionaryGetValue((CFDictionaryRef)result, key);
      if (result)
        return (unsigned __int8 *)result[24];
    }
  }
  return result;
}

void _CFHTTPAuthenticationApplyProxyAuthorizationToRequest(__CFHTTPMessage *a1, const void *a2, _QWORD *a3, const void *a4, const void *a5, uint64_t a6)
{
  NSObject *v10;
  __CFString *v11;
  _CFHTTPAuthentication *v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  const __CFURL *v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  const __CFDictionary **v18;
  const void *Value;
  std::__shared_weak_count_vtbl *v20;
  uint64_t v21;
  __CFHTTPMessage *v22;
  _BOOL4 v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  void (__cdecl **p_on_zero_shared)(std::__shared_count *__hidden);
  void (__cdecl *v29)(std::__shared_count *__hidden);
  void (__cdecl *v30)(std::__shared_count *__hidden);
  NSObject *v31;
  _CFHTTPAuthentication *v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  char v36;
  unsigned int v37;
  _CFHTTPAuthentication *v38;
  NSObject *v39;
  unint64_t v40;
  CFTypeRef v41;
  AuthBrokerAgentClient *v42;
  NSObject *v43;
  CFTypeRef v44;
  HTTPProxyAuthentication *v45;
  NetworkProxyCredential *v46;
  NSObject *v47;
  CFIndex domain;
  NSObject *v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  unint64_t v55;
  NetworkProxyAuthorizationElements *v56;
  uint64_t v57;
  NSObject *v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  unsigned __int8 v69;
  unsigned __int8 v70;
  const void *v71;
  CFTypeRef cf;
  HTTPProxyAuthentication *key;
  __CFHTTPMessage *v74;
  std::__shared_weak_count *v75;
  std::__shared_weak_count *v76;
  _QWORD v79[2];
  uint64_t (*v80)(uint64_t);
  void *v81;
  NetworkProxyAuthorizationElements *v82;
  uint64_t v83;
  uint64_t *v84;
  uint64_t v85;
  __n128 (*v86)(__n128 *, __n128 *);
  uint64_t (*v87)(uint64_t);
  void *v88;
  CFTypeRef v89;
  std::__shared_weak_count *v90;
  CFTypeRef v91;
  CFStreamError error;
  _BYTE buf[24];
  void *v94;
  _BYTE v95[24];
  std::__shared_weak_count *v96;
  const __CFURL *v97;
  std::__shared_weak_count *v98;
  const void *v99;
  __CFHTTPMessage *v100;
  const void *v101;
  uint64_t v102;

  v102 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v10 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138413314;
    *(_QWORD *)&buf[4] = a1;
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = a2;
    *(_WORD *)&buf[22] = 2112;
    v94 = a3;
    *(_WORD *)v95 = 2112;
    *(_QWORD *)&v95[2] = a4;
    *(_WORD *)&v95[10] = 2048;
    *(_QWORD *)&v95[12] = a5;
    _os_log_debug_impl(&dword_183ECA000, v10, OS_LOG_TYPE_DEBUG, "Applying proxy auth: response=%@, proxyURL=%@, request=%@, credentials=%@, handle=%p", buf, 0x34u);
  }
  v11 = (__CFString *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%p"), a5);
  v13 = (std::__shared_weak_count *)operator new();
  v13->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v13->__shared_owners_;
  v13->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19E8;
  v13->__shared_weak_owners_ = 0;
  v13[1].__vftable = (std::__shared_weak_count_vtbl *)v11;
  if (a1 && a2 && a3)
  {
    error.domain = 0;
    *(_QWORD *)&error.error = 0;
    _CFHTTPMessageSetResponseProxyURL((uint64_t)a1, a2);
    cf = a4;
    v15 = (const __CFURL *)_CFHTTPAuthenticationCreateFromResponseInternal(0, a1, 0, 1, 0, 0, 0, 0, 0, v69);
    v16 = (std::__shared_weak_count *)operator new();
    key = (HTTPProxyAuthentication *)v11;
    v16->__shared_owners_ = 0;
    v17 = (unint64_t *)&v16->__shared_owners_;
    v16->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1748;
    v16->__shared_weak_owners_ = 0;
    v16[1].__vftable = (std::__shared_weak_count_vtbl *)v15;
    proxyProtectionSpaceFromAuthentication((_CFHTTPAuthentication *)&v91, v15, (const __CFURL *)a2);
    v74 = (__CFHTTPMessage *)a3;
    v71 = a2;
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
    if (v15)
      v18 = (const __CFDictionary **)((char *)v15 + 16);
    else
      v18 = 0;
    if (!HTTPAuthentication::isConnectionBasedAuth((HTTPAuthentication *)v18))
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v21 = a6;
      v22 = (__CFHTTPMessage *)a3;
      v23 = a3[12] != 0;
      goto LABEL_62;
    }
    os_unfair_lock_lock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
    v75 = v16;
    if (HTTPProxyAuthentication::GetProxyAuthCache(void)::onceToken != -1)
      dispatch_once(&HTTPProxyAuthentication::GetProxyAuthCache(void)::onceToken, &__block_literal_global_61);
    if (CFDictionaryGetValue(*(CFDictionaryRef *)(HTTPProxyAuthentication::GetProxyAuthCache(void)::ProxyAuthCache + 8), v11))
    {
      if (HTTPProxyAuthentication::GetProxyAuthCache(void)::onceToken != -1)
        dispatch_once(&HTTPProxyAuthentication::GetProxyAuthCache(void)::onceToken, &__block_literal_global_61);
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(HTTPProxyAuthentication::GetProxyAuthCache(void)::ProxyAuthCache + 8), v11);
      v20 = (std::__shared_weak_count_vtbl *)CFRetain(Value);
    }
    else
    {
      v20 = 0;
    }
    v24 = (std::__shared_weak_count *)operator new();
    v24->__shared_owners_ = 0;
    v25 = (unint64_t *)&v24->__shared_owners_;
    v24->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1748;
    v24->__shared_weak_owners_ = 0;
    v24[1].__vftable = v20;
    os_unfair_lock_unlock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
    if (v20)
    {
      do
        v26 = __ldxr(v25);
      while (__stxr(v26 + 1, v25));
      do
        v27 = __ldaxr(v17);
      while (__stlxr(v27 - 1, v17));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
        std::__shared_weak_count::__release_weak(v75);
      }
      v75 = v24;
    }
    else
    {
      if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
        dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
      v37 = HTTPAuthentication::isKerberosThePreferredAuthScheme(v18[17]);
      v22 = v74;
      if (!v37)
      {
        HTTPProxyAuthentication::SetCachedProxyAuth((HTTPProxyAuthentication *)v11, (const __CFString *)v15, v38);
        v23 = 0;
        v36 = 1;
        goto LABEL_58;
      }
      if (!v15)
      {
        p_on_zero_shared = 0;
        v20 = 0;
LABEL_35:
        HTTPAuthentication::updateFromResponse((HTTPAuthentication *)p_on_zero_shared, a1, a5);
        pthread_mutex_lock((pthread_mutex_t *)(p_on_zero_shared + 2));
        v30 = p_on_zero_shared[11];
        v29 = p_on_zero_shared[12];
        pthread_mutex_unlock((pthread_mutex_t *)(p_on_zero_shared + 2));
        if ((_DWORD)v29)
        {
          if (v30 == (void (__cdecl *)(std::__shared_count *__hidden))4 && (_DWORD)v29 == -1001)
          {
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v31 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 134217984;
              *(_QWORD *)&buf[4] = a5;
              _os_log_impl(&dword_183ECA000, v31, OS_LOG_TYPE_INFO, "Proxy credentials had a bad username/password, trying again handle %p", buf, 0xCu);
            }
          }
          v15 = (const __CFURL *)_CFHTTPAuthenticationCreateFromResponseInternal(0, a1, 0, 1, 0, 0, 0, 0, 0, v70);
          v33 = (std::__shared_weak_count *)operator new();
          v33->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1748;
          v33->__shared_owners_ = 0;
          v34 = (unint64_t *)&v75->__shared_owners_;
          v33->__shared_weak_owners_ = 0;
          v33[1].__vftable = (std::__shared_weak_count_vtbl *)v15;
          do
            v35 = __ldaxr(v34);
          while (__stlxr(v35 - 1, v34));
          if (!v35)
          {
            ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
            std::__shared_weak_count::__release_weak(v75);
          }
          HTTPProxyAuthentication::SetCachedProxyAuth(key, (const __CFString *)v15, v32);
          v23 = 1;
          v75 = v33;
          v36 = 1;
          v22 = v74;
        }
        else
        {
          HTTPAuthentication::applyHeaderToRequest((CFDictionaryRef *)p_on_zero_shared, v74, a5);
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v39 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 134217984;
            *(_QWORD *)&buf[4] = a5;
            _os_log_debug_impl(&dword_183ECA000, v39, OS_LOG_TYPE_DEBUG, "applied header to request for handle %p", buf, 0xCu);
          }
          (*(void (**)(uint64_t, __CFHTTPMessage *, void (__cdecl *)(std::__shared_count *__hidden), void (__cdecl *)(std::__shared_count *__hidden)))(a6 + 16))(a6, v74, v30, v29);
          v23 = 0;
          v36 = 0;
          v15 = (const __CFURL *)v20;
          v22 = v74;
        }
        do
LABEL_58:
          v40 = __ldaxr(v25);
        while (__stlxr(v40 - 1, v25));
        if (!v40)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
        v16 = v75;
        v21 = a6;
        if ((v36 & 1) == 0)
          goto LABEL_94;
LABEL_62:
        v83 = 0;
        v84 = &v83;
        v85 = 0x4012000000;
        v86 = __Block_byref_object_copy__8048;
        v87 = __Block_byref_object_dispose__8049;
        v88 = &unk_18422E08D;
        if (cf)
          v41 = CFRetain(cf);
        else
          v41 = 0;
        v89 = v41;
        v42 = (AuthBrokerAgentClient *)operator new();
        *(_QWORD *)v42 = &off_1E14F1A58;
        *((_QWORD *)v42 + 1) = 0;
        *((_QWORD *)v42 + 2) = 0;
        *((_QWORD *)v42 + 3) = v41;
        v90 = (std::__shared_weak_count *)v42;
        if (v15)
        {
          if (!cf && AuthBrokerAgentClient::AuthBrokerIsAvailable(v42))
          {
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v43 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 138412290;
              *(_QWORD *)&buf[4] = key;
              _os_log_debug_impl(&dword_183ECA000, v43, OS_LOG_TYPE_DEBUG, "Proxy credentials not present, querying AuthBrokerAgent with uuid %@", buf, 0xCu);
            }
            v44 = v91;
            v76 = v16;
            if (v91)
            {
              os_unfair_lock_lock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
              v45 = key;
              if (HTTPProxyAuthentication::GetProxyCredCache(void)::onceToken != -1)
                dispatch_once(&HTTPProxyAuthentication::GetProxyCredCache(void)::onceToken, &__block_literal_global_67);
              v46 = (NetworkProxyCredential *)CFDictionaryGetValue(*(CFDictionaryRef *)(HTTPProxyAuthentication::GetProxyCredCache(void)::ProxyCredCache+ 8), v44);
              os_unfair_lock_unlock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
            }
            else
            {
              v46 = 0;
              v45 = key;
            }
            v56 = (NetworkProxyAuthorizationElements *)CFAllocatorAllocate(0, 80, 0);
            *((_OWORD *)v56 + 3) = 0u;
            *((_OWORD *)v56 + 4) = 0u;
            *((_OWORD *)v56 + 1) = 0u;
            *((_OWORD *)v56 + 2) = 0u;
            *(_OWORD *)v56 = 0u;
            NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements(v56, 0, v46, v44, 0, v45);
            v57 = MEMORY[0x1E0C809B0];
            v79[0] = MEMORY[0x1E0C809B0];
            v79[1] = 3221225472;
            v80 = ___ZN18HTTPAuthentication32applyProxyAuthorizationToRequestEP15__CFHTTPMessagePK7__CFURLS1_PK14__CFDictionaryPKvU13block_pointerFvS1_13CFStreamErrorEU13block_pointerFvP22NetworkProxyCredentialP33NetworkProxyAuthorizationElementsU13block_pointerFvSE_EE_block_invoke;
            v81 = &__block_descriptor_40_e5_v8__0l;
            v82 = v56;
            if (v23)
            {
              if (CFNLog::onceToken != -1)
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
              v58 = CFNLog::logger;
              if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)buf = 134217984;
                *(_QWORD *)&buf[4] = a5;
                _os_log_impl(&dword_183ECA000, v58, OS_LOG_TYPE_INFO, "Setting proxy creds to unviable handle %p", buf, 0xCu);
              }
              HTTPProxyAuthentication::SetCachedProxyCred(v44, 0);
              v45 = key;
              v59 = *((_QWORD *)v56 + 5);
              v46 = 0;
              if (v59)
                *(_DWORD *)(v59 + 40) = 2;
            }
            *(_QWORD *)buf = v57;
            *(_QWORD *)&buf[8] = 3321888768;
            *(_QWORD *)&buf[16] = ___ZN18HTTPAuthentication32applyProxyAuthorizationToRequestEP15__CFHTTPMessagePK7__CFURLS1_PK14__CFDictionaryPKvU13block_pointerFvS1_13CFStreamErrorEU13block_pointerFvP22NetworkProxyCredentialP33NetworkProxyAuthorizationElementsU13block_pointerFvSE_EE_block_invoke_57;
            v94 = &unk_1E14F21E0;
            *(_QWORD *)&v95[16] = v45;
            v96 = v13;
            do
              v60 = __ldxr(p_shared_owners);
            while (__stxr(v60 + 1, p_shared_owners));
            v16 = v76;
            v97 = v15;
            v98 = v76;
            v61 = (unint64_t *)&v76->__shared_owners_;
            do
              v62 = __ldxr(v61);
            while (__stxr(v62 + 1, v61));
            v99 = v71;
            v100 = v74;
            v101 = a5;
            *(_QWORD *)v95 = v21;
            *(_QWORD *)&v95[8] = &v83;
            ___ZN18HTTPAuthentication32applyProxyAuthorizationToRequestEP15__CFHTTPMessagePK7__CFURLS1_PK14__CFDictionaryPKvU13block_pointerFvS1_13CFStreamErrorE_block_invoke((uint64_t)v46, (uint64_t)v56, (void (**)(_QWORD, _QWORD))buf);
            v63 = v98;
            if (v98)
            {
              v64 = (unint64_t *)&v98->__shared_owners_;
              do
                v65 = __ldaxr(v64);
              while (__stlxr(v65 - 1, v64));
              if (!v65)
              {
                ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
                std::__shared_weak_count::__release_weak(v63);
              }
            }
            v66 = v96;
            if (v96)
            {
              v67 = (unint64_t *)&v96->__shared_owners_;
              do
                v68 = __ldaxr(v67);
              while (__stlxr(v68 - 1, v67));
              if (!v68)
              {
                ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
                std::__shared_weak_count::__release_weak(v66);
              }
            }
            v80((uint64_t)v79);
            goto LABEL_89;
          }
          if (CFHTTPMessageApplyCredentialDictionary(v22, v15, (CFDictionaryRef)v84[6], &error))
          {
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v47 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 138412546;
              *(_QWORD *)&buf[4] = v22;
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = a5;
              _os_log_debug_impl(&dword_183ECA000, v47, OS_LOG_TYPE_DEBUG, "Applied proxy credentials dictionary to request %@ handle %p", buf, 0x16u);
            }
            _CFHTTPAuthenticationApplyHeaderToRequest(v15, v22, a5);
          }
          domain = error.domain;
        }
        else
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v49 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 134217984;
            *(_QWORD *)&buf[4] = a5;
            _os_log_error_impl(&dword_183ECA000, v49, OS_LOG_TYPE_ERROR, "Failed to create proxy auth from response handle %p", buf, 0xCu);
          }
          domain = 4;
          error.domain = 4;
          error.error = -1000;
        }
        (*(void (**)(uint64_t, __CFHTTPMessage *, CFIndex, _QWORD))(v21 + 16))(v21, v22, domain, *(_QWORD *)&error.error);
LABEL_89:
        _Block_object_dispose(&v83, 8);
        v50 = v90;
        if (v90)
        {
          v51 = (unint64_t *)&v90->__shared_owners_;
          do
            v52 = __ldaxr(v51);
          while (__stlxr(v52 - 1, v51));
          if (!v52)
          {
            ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
            std::__shared_weak_count::__release_weak(v50);
          }
        }
LABEL_94:
        if (v91)
          CFRelease(v91);
        v53 = (unint64_t *)&v16->__shared_owners_;
        do
          v54 = __ldaxr(v53);
        while (__stlxr(v54 - 1, v53));
        if (!v54)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
        goto LABEL_100;
      }
      v20 = (std::__shared_weak_count_vtbl *)v15;
    }
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
    p_on_zero_shared = &v20->__on_zero_shared;
    goto LABEL_35;
  }
  HTTPProxyAuthentication::SetCachedProxyAuth((HTTPProxyAuthentication *)v11, 0, v12);
  if (a6)
    (*(void (**)(void))(a6 + 16))();
  do
LABEL_100:
    v55 = __ldaxr(p_shared_owners);
  while (__stlxr(v55 - 1, p_shared_owners));
  if (!v55)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
}

void sub_18401368C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, void (*a19)(char *), uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,std::__shared_weak_count *a29,CFTypeRef cf,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42)
{
  unint64_t *v42;
  std::__shared_weak_count *v43;
  std::__shared_weak_count *v45;
  unint64_t *p_shared_owners;
  unint64_t v47;
  unint64_t *v48;
  unint64_t v49;
  unint64_t v50;

  a19(&a17);
  _Block_object_dispose(&a22, 8);
  v45 = a29;
  if (a29)
  {
    p_shared_owners = (unint64_t *)&a29->__shared_owners_;
    do
      v47 = __ldaxr(p_shared_owners);
    while (__stlxr(v47 - 1, p_shared_owners));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  if (cf)
    CFRelease(cf);
  v48 = (unint64_t *)&a14->__shared_owners_;
  do
    v49 = __ldaxr(v48);
  while (__stlxr(v49 - 1, v48));
  if (!v49)
  {
    ((void (*)(std::__shared_weak_count *))a14->__on_zero_shared)(a14);
    std::__shared_weak_count::__release_weak(a14);
  }
  do
    v50 = __ldaxr(v42);
  while (__stlxr(v50 - 1, v42));
  if (!v50)
  {
    ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
    std::__shared_weak_count::__release_weak(v43);
  }
  _Unwind_Resume(a1);
}

CFStringRef _CFHTTPAuthenticationCreateNTLMHeaderForRequest(uint64_t a1, int a2, void *key)
{
  uint64_t v5;
  _BYTE *Value;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (a1)
    v5 = a1 + 16;
  else
    v5 = 0;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 152), key);
  return HTTPAuthentication::createNTLMHeaderForRequest_Mac(v5, Value, key);
}

CFStringRef _CFHTTPAuthenticationCreateNegotiateHeaderForRequest(uint64_t a1, int a2, void *key)
{
  uint64_t v5;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (a1)
    v5 = a1 + 16;
  else
    v5 = 0;
  CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 152), key);
  return HTTPAuthentication::createNegotiateHeaderForRequest_Mac(v5);
}

uint64_t _CFHTTPAuthenticationGetSchemesDict(uint64_t a1)
{
  uint64_t v2;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  return *(_QWORD *)(v2 + 144);
}

const __CFArray *_CFHTTPAuthenticationCopySortedAuthSchemes(uint64_t a1)
{
  HTTPAuthentication *v2;
  const __CFArray *v3;
  const __CFArray *v4;
  const __CFArray *MutableCopy;
  CFRange v7;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (a1)
    v2 = (HTTPAuthentication *)(a1 + 16);
  else
    v2 = 0;
  v3 = (const __CFArray *)HTTPAuthentication::copyServerSupportedSchemes(v2);
  if (!v3)
    return 0;
  v4 = v3;
  MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v3);
  v7.length = CFArrayGetCount(MutableCopy);
  v7.location = 0;
  CFArraySortValues(MutableCopy, v7, (CFComparatorFunction)sortArrayBySecurityStrength, 0);
  CFRelease(v4);
  return MutableCopy;
}

void sub_184013A6C(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t _CFHTTPAuthenticationGetPATSchemes(uint64_t a1)
{
  uint64_t v2;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  return *(_QWORD *)(v2 + 232);
}

void _CFHTTPAuthenticationGetPATAuthHeaders(uint64_t a1, const __CFArray *a2, const __CFData *a3, uint64_t a4, const __CFURL *a5, const __CFURL *a6, void *a7, int a8, char a9, char a10, void *a11, uint64_t a12)
{
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  _QWORD v23[5];
  uint64_t v24;
  std::__shared_weak_count *v25;

  v23[0] = MEMORY[0x1E0C809B0];
  v23[1] = 3221225472;
  v23[2] = ___CFHTTPAuthenticationGetPATAuthHeaders_block_invoke;
  v23[3] = &unk_1E14F7378;
  v23[4] = a12;
  SmartBlockWithArgs<__CFDictionary const*,__CFError *>::SmartBlockWithArgs(&v24, v23);
  PrivateAccessTokens::getPATAuthHeaders(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, &v24);
  v19 = v25;
  if (v25)
  {
    p_shared_owners = (unint64_t *)&v25->__shared_owners_;
    do
      v21 = __ldaxr(p_shared_owners);
    while (__stlxr(v21 - 1, p_shared_owners));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
}

void sub_184013BEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *SmartBlockWithArgs<__CFDictionary const*,__CFError *>::SmartBlockWithArgs(uint64_t *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  v4 = (_QWORD *)operator new();
  v4[1] = BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_initial;
  v4[2] = 0;
  *v4 = _Block_copy(a2);
  *a1 = (uint64_t)v4;
  v5 = (_QWORD *)operator new();
  *v5 = &off_1E14F1358;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a1[1] = (uint64_t)v5;
  if (!a2)
  {
    v6 = *a1;
    *(_QWORD *)(v6 + 8) = BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_reseted;
    *(_QWORD *)(v6 + 16) = 0;
  }
  return a1;
}

void sub_184013CB0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

uint64_t BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_initial(_QWORD *a1)
{
  a1[1] = BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

void std::__shared_ptr_pointer<BlockHolderVar<__CFDictionary const*,__CFError *> *,SmartBlockWithArgs<__CFDictionary const*,__CFError *>::Deleter,std::allocator<BlockHolderVar<__CFDictionary const*,__CFError *>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<BlockHolderVar<__CFDictionary const*,__CFError *> *,SmartBlockWithArgs<__CFDictionary const*,__CFError *>::Deleter,std::allocator<BlockHolderVar<__CFDictionary const*,__CFError *>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  BOOL v4;
  int v5;
  _QWORD *v7;

  v1 = *(_QWORD *)(a1 + 24);
  v3 = *(_QWORD *)(v1 + 8);
  v2 = *(_QWORD *)(v1 + 16);
  if (v2)
    v4 = (*(_QWORD *)(v1 + 16) & 1 | v3) == 0;
  else
    v4 = 1;
  v5 = v4;
  if ((uint64_t (*)(_QWORD *))v3 == BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_initial
    && v5 != 0)
  {
    v7 = (_QWORD *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0)
      (*(void (**)(_QWORD *, _QWORD, _QWORD))(*v7
                                                       + BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_initial))(v7, 0, 0);
    else
      ((void (*)(_QWORD *, _QWORD, _QWORD))BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_initial)(v7, 0, 0);
  }
  _Block_release(*(const void **)v1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a1 + 16))();
}

uint64_t _CFHTTPAuthenticationCheckOriginAllowedAsThirdParty(double a1)
{
  double Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher;
  uint64_t v2;

  Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher(a1);
  return objc_msgSend(*(id *)(v2 + 2736), "checkOriginAllowedAsThirdParty:", Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher);
}

uint64_t _CFHTTPAuthenticationUsingAppSSO(double a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  _BOOL4 v4;
  uint64_t v5;
  NSObject *v6;
  _DWORD v8[2];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  gotLoadHelper_x9__SOErrorDomain(a1);
  v3 = *(unsigned __int8 *)(v2 + 3232);
  v4 = *(_QWORD *)(v1 + 1776) != 0;
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v5 = v4 & ~v3;
  v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    v8[0] = 67109120;
    v8[1] = v5;
    _os_log_debug_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEBUG, "CFHTTPAuthentication using AppSSO %{BOOL}d", (uint8_t *)v8, 8u);
  }
  return v5;
}

uint64_t _CFHTTPAuthenticationAppSSOIsPerformDefaultHandlingError(AppSSO *a1, __CFError *a2)
{
  return AppSSO::isPerformDefaultHandlingError(a1, a2);
}

AppSSO *_CFHTTPAuthenticationAppSSOShouldManageURL(AppSSO *a1, const __CFString *a2, const __CFURL *a3, uint64_t a4, const __CFData *a5, double a6)
{
  return AppSSO::shouldManageURL(a1, a2, a3, a4, a5, a6);
}

void _CFHTTPAuthenticationGetAuthHeadersFromAppSSO(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  std::__shared_weak_count_vtbl *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  _QWORD v21[5];
  uint64_t v22;
  std::__shared_weak_count *v23;
  std::__shared_weak_count_vtbl *v24;
  std::__shared_weak_count *v25;

  if (a1)
    v13 = (std::__shared_weak_count_vtbl *)CFRetain(a1);
  else
    v13 = 0;
  v24 = v13;
  v14 = (std::__shared_weak_count *)operator new();
  v14->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19E8;
  v14->__shared_owners_ = 0;
  v14->__shared_weak_owners_ = 0;
  v14[1].__vftable = v13;
  v25 = v14;
  v21[0] = MEMORY[0x1E0C809B0];
  v21[1] = 3221225472;
  v21[2] = ___CFHTTPAuthenticationGetAuthHeadersFromAppSSO_block_invoke;
  v21[3] = &unk_1E14F7378;
  v21[4] = a7;
  SmartBlockWithArgs<__CFDictionary const*,__CFError *>::SmartBlockWithArgs(&v22, v21);
  AppSSO::getAuthHeaders((AppSSO *)&v24, a2, a3, a4, a5, a6, (uint64_t)&v22);
  v15 = v23;
  if (v23)
  {
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v25;
  if (v25)
  {
    v19 = (unint64_t *)&v25->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
}

void sub_184014048(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void _CFHTTPAuthenticationDisableAppSSO()
{
  AppSSO::AppSSODisabled = 1;
}

uint64_t _CFHTTPAuthenticationFailedToGetKerberosTicket(uint64_t a1)
{
  uint64_t v2;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  return *(unsigned __int8 *)(v2 + 224);
}

BOOL _CFHTTPAuthenticationCanRecoverFromKerberosFailure(KerberosAccountBroker *a1, const __CFData *a2, const __CFString *a3)
{
  return KerberosAccountBroker::getKerberosAccountBrokerForApplication(a1, a2, a3) != 0;
}

void _CFHTTPAuthenticationAskAccountsForCreds(uint64_t a1, const void *a2, KerberosAccountBroker *this, __CFData *a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *KerberosAccountBrokerForApplication;
  _QWORD v17[11];

  KerberosAccountBrokerForApplication = (_QWORD *)KerberosAccountBroker::getKerberosAccountBrokerForApplication(this, a4, (const __CFString *)this);
  if (KerberosAccountBrokerForApplication)
  {
    v17[0] = MEMORY[0x1E0C809B0];
    v17[1] = 3221225472;
    v17[2] = ___CFHTTPAuthenticationAskAccountsForCreds_block_invoke;
    v17[3] = &unk_1E14F73A0;
    v17[6] = a6;
    v17[7] = a7;
    v17[8] = a2;
    v17[9] = this;
    v17[10] = a4;
    v17[4] = a8;
    v17[5] = a1;
    KerberosAccountBroker::getKerberosCredentialForURL(KerberosAccountBrokerForApplication, a5, a2, (uint64_t)v17);
  }
  else
  {
    (*(void (**)(uint64_t, _QWORD, _QWORD))(a8 + 16))(a8, 0, 0);
  }
}

void _CFHTTPAuthenticationClearAccountRefreshState(const __CFURL *a1, KerberosAccountBroker *this, __CFData *a3)
{
  NSObject **KerberosAccountBrokerForApplication;

  KerberosAccountBrokerForApplication = (NSObject **)KerberosAccountBroker::getKerberosAccountBrokerForApplication(this, a3, (const __CFString *)a3);
  if (KerberosAccountBrokerForApplication)
    KerberosAccountBroker::clearAccountRefreshState(KerberosAccountBrokerForApplication, a1);
}

BOOL _CFHTTPAuthenticationIsSecondNTLMTransaction(uint64_t a1)
{
  HTTPAuthentication *v2;

  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (a1)
    v2 = (HTTPAuthentication *)(a1 + 16);
  else
    v2 = 0;
  return HTTPAuthentication::isSecondNTLMTransaction(v2);
}

void _CFHTTPAuthenticationFetchProxyCredentialFromAuthBroker(void *a1, const void *a2, const void *a3, uint64_t a4)
{
  const __CFAllocator *v8;
  _OWORD *v9;
  uint64_t v10;
  NetworkProxyAuthorizationElements *v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  _QWORD v15[5];
  uint64_t v16;
  std::__shared_weak_count *v17;

  if (AuthBrokerAgentClient::AuthBrokerIsAvailable((AuthBrokerAgentClient *)a1))
  {
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (a1)
    {
      v9 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 56, 0);
      *v9 = 0u;
      v9[1] = 0u;
      v9[2] = 0u;
      *((_QWORD *)v9 + 6) = 0;
      NetworkProxyCredential::NetworkProxyCredential((NetworkProxyCredential *)v9, v8, a1);
      *(_DWORD *)(v10 + 40) = 2;
    }
    else
    {
      v9 = 0;
    }
    v11 = (NetworkProxyAuthorizationElements *)CFAllocatorAllocate(v8, 80, 0);
    *(_OWORD *)v11 = 0u;
    *((_OWORD *)v11 + 1) = 0u;
    *((_OWORD *)v11 + 2) = 0u;
    *((_OWORD *)v11 + 3) = 0u;
    *((_OWORD *)v11 + 4) = 0u;
    NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements(v11, v8, (NetworkProxyCredential *)v9, a2, 0, a3);
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v15[2] = ___CFHTTPAuthenticationFetchProxyCredentialFromAuthBroker_block_invoke;
    v15[3] = &unk_1E14F73C8;
    v15[4] = a4;
    SmartBlockWithArgs<NetworkProxyCredential *>::SmartBlockWithArgs(&v16, v15);
    AuthBrokerAgentClient::FetchProxyCredentials((uint64_t)v11, &v16);
    v12 = v17;
    if (v17)
    {
      p_shared_owners = (unint64_t *)&v17->__shared_owners_;
      do
        v14 = __ldaxr(p_shared_owners);
      while (__stlxr(v14 - 1, p_shared_owners));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }
  else
  {
    (*(void (**)(uint64_t, _QWORD))(a4 + 16))(a4, 0);
  }
}

void sub_184014614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *SmartBlockWithArgs<NetworkProxyCredential *>::SmartBlockWithArgs(uint64_t *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  v4 = (_QWORD *)operator new();
  v4[1] = BlockHolderVar<NetworkProxyCredential *>::invoke_initial;
  v4[2] = 0;
  *v4 = _Block_copy(a2);
  *a1 = (uint64_t)v4;
  v5 = (_QWORD *)operator new();
  *v5 = &off_1E14F12E8;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a1[1] = (uint64_t)v5;
  if (!a2)
  {
    v6 = *a1;
    *(_QWORD *)(v6 + 8) = BlockHolderVar<NetworkProxyCredential *>::invoke_reseted;
    *(_QWORD *)(v6 + 16) = 0;
  }
  return a1;
}

void sub_1840146E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

uint64_t BlockHolderVar<NetworkProxyCredential *>::invoke_initial(_QWORD *a1)
{
  a1[1] = BlockHolderVar<NetworkProxyCredential *>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

void std::__shared_ptr_pointer<BlockHolderVar<NetworkProxyCredential *> *,SmartBlockWithArgs<NetworkProxyCredential *>::Deleter,std::allocator<BlockHolderVar<NetworkProxyCredential *>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<BlockHolderVar<NetworkProxyCredential *> *,SmartBlockWithArgs<NetworkProxyCredential *>::Deleter,std::allocator<BlockHolderVar<NetworkProxyCredential *>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  BOOL v4;
  int v5;
  _QWORD *v7;

  v1 = *(_QWORD *)(a1 + 24);
  v3 = *(_QWORD *)(v1 + 8);
  v2 = *(_QWORD *)(v1 + 16);
  if (v2)
    v4 = (*(_QWORD *)(v1 + 16) & 1 | v3) == 0;
  else
    v4 = 1;
  v5 = v4;
  if ((uint64_t (*)(_QWORD *))v3 == BlockHolderVar<NetworkProxyCredential *>::invoke_initial && v5 != 0)
  {
    v7 = (_QWORD *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0)
      (*(void (**)(_QWORD *, _QWORD))(*v7
                                               + BlockHolderVar<NetworkProxyCredential *>::invoke_initial))(v7, 0);
    else
      ((void (*)(_QWORD *, _QWORD))BlockHolderVar<NetworkProxyCredential *>::invoke_initial)(v7, 0);
  }
  _Block_release(*(const void **)v1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t BlockHolderVar<NetworkProxyCredential *>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a1 + 16))();
}

void SyncClient::synchClientDidReceiveResponse(SyncClient *this, _CFURLConnection *a2, _CFURLResponse *a3, const void *a4)
{
  if (*((_QWORD *)a3 + 4))
    SyncClient::cleanup((SyncClient *)a3);
  else
    *((_QWORD *)a3 + 4) = a2;
}

void SyncClient::synchClientDidReceiveData(SyncClient *this, CFDataRef theData, const __CFData *a3, uint64_t a4, const void *a5)
{
  __CFData *v6;
  const UInt8 *BytePtr;
  CFIndex Length;

  v6 = *(__CFData **)(a4 + 48);
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  CFDataAppendBytes(v6, BytePtr, Length);
}

void SyncClient::synchClientDidFinishLoading(SyncClient *this, _CFURLConnection *a2, const void *a3)
{
  SyncClient::cleanup((SyncClient *)a2);
}

void SyncClient::synchClientDidFail(SyncClient *this, CFTypeRef cf, __CFError *a3, const void *a4)
{
  const void *v6;
  CFTypeRef v7;

  if (!*((_QWORD *)a3 + 5))
  {
    v6 = (const void *)*((_QWORD *)a3 + 6);
    if (v6)
      CFRelease(v6);
    *((_QWORD *)a3 + 6) = 0;
    if (cf)
      v7 = CFRetain(cf);
    else
      v7 = 0;
    *((_QWORD *)a3 + 5) = v7;
    SyncClient::cleanup(a3);
  }
}

void SyncClient::cleanup(SyncClient *this)
{
  NSObject *v2;
  void *v3;
  const __CFURL *v4;
  const __CFString *v5;
  const __CFString *v6;
  uint64_t v7;
  __CFHTTPMessage *v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __CFError *CFError;
  const __CFDictionary *v16;
  const __CFDictionary *v17;
  const __CFAllocator *v18;
  __CFDictionary *MutableCopy;
  const __CFString *Domain;
  CFIndex Code;
  CFErrorRef v22;
  const void *v23;
  _QWORD block[5];

  (*(void (**)(SyncClient *))(*(_QWORD *)this + 40))(this);
  CFURLConnectionCancel(*((_QWORD *)this + 3));
  if (!*((_QWORD *)this + 5))
  {
    v3 = (void *)*((_QWORD *)this + 4);
    if (v3)
    {
      v4 = *(const __CFURL **)(objc_msgSend(v3, "_inner") + 8);
      if (v4)
      {
        v5 = CFURLCopyScheme(v4);
        if (v5)
        {
          v6 = v5;
          if (CFStringCompare(v5, CFSTR("http"), 0) == kCFCompareEqualTo
            || CFStringCompare(v6, (CFStringRef)&unk_1EDD00AE0, 0) == kCFCompareEqualTo)
          {
            v7 = *(_QWORD *)(objc_msgSend(*((id *)this + 4), "_inner") + 88);
            v8 = v7 ? (__CFHTTPMessage *)(v7 - 16) : 0;
            if (v7 && (CFHTTPMessageGetResponseStatusCode(v8) == 401 || CFHTTPMessageGetResponseStatusCode(v8) == 407))
            {
              v9 = *((id *)this + 4);
              CFRelease(*((CFTypeRef *)this + 4));
              *((_QWORD *)this + 4) = 0;
              CFError = __cfnCreateCFError(*((CFAllocatorRef *)this + 1), CFSTR("kCFErrorDomainCFNetwork"), -1012, v10, v11, v12, v13, v14, 0);
              *((_QWORD *)this + 5) = CFError;
              if (CFError)
              {
                v16 = CFErrorCopyUserInfo(CFError);
                if (v16)
                {
                  v17 = v16;
                  v18 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
                  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v16);
                  CFRelease(v17);
                  if (MutableCopy)
                  {
                    CFDictionarySetValue(MutableCopy, CFSTR("_kCFURLErrorAuthFailedResponseKey"), v9);
                    Domain = CFErrorGetDomain(*((CFErrorRef *)this + 5));
                    Code = CFErrorGetCode(*((CFErrorRef *)this + 5));
                    v22 = CFErrorCreate(v18, Domain, Code, MutableCopy);
                    CFRelease(MutableCopy);
                    v23 = (const void *)*((_QWORD *)this + 5);
                    if (v23)
                      CFRelease(v23);
                    if (v22)
                    {
                      *((_QWORD *)this + 5) = CFRetain(v22);
                      CFRelease(v22);
                    }
                    else
                    {
                      *((_QWORD *)this + 5) = 0;
                    }
                  }
                }
              }

            }
          }
          CFRelease(v6);
        }
      }
    }
  }
  v2 = *((_QWORD *)this + 7);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN10SyncClient7cleanupEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = this;
  dispatch_async(v2, block);
}

uint64_t ___ZN10SyncClient7cleanupEv_block_invoke(uint64_t a1)
{
  _QWORD *v1;

  v1 = *(_QWORD **)(a1 + 32);
  (*(void (**)(void))(v1[8] + 16))();
  return (*(uint64_t (**)(_QWORD *))(*v1 + 48))(v1);
}

void SyncClient::~SyncClient(SyncClient *this)
{
  uint64_t v2;

  SyncClient::~SyncClient(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  const void *v2;
  const void *v3;
  const void *v4;

  *(_QWORD *)this = off_1E14E4C08;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);

  v3 = (const void *)*((_QWORD *)this + 5);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 6);
  if (v4)
    CFRelease(v4);
  dispatch_release(*((dispatch_object_t *)this + 7));
  _Block_release(*((const void **)this + 8));
}

uint64_t SyncClient::equals(SyncClient *this, const CFAllocatedReferenceCountedObject *a2)
{
  return 0;
}

uint64_t serviceTypeToString(int a1)
{
  uint64_t *v1;
  uint64_t result;

  switch(a1)
  {
    case 1:
      v1 = (uint64_t *)&kCFStreamNetworkServiceTypeVoIP;
      goto LABEL_14;
    case 2:
      v1 = (uint64_t *)&kCFStreamNetworkServiceTypeVideo;
      goto LABEL_14;
    case 3:
      v1 = (uint64_t *)&kCFStreamNetworkServiceTypeBackground;
      goto LABEL_14;
    case 4:
      v1 = (uint64_t *)&kCFStreamNetworkServiceTypeVoice;
      goto LABEL_14;
    case 5:
      v1 = &kCFStreamNetworkServiceTypeBackgroundSystemInitiated;
      goto LABEL_14;
    case 6:
      v1 = (uint64_t *)&kCFStreamNetworkServiceTypeResponsiveData;
      goto LABEL_14;
    case 7:
      v1 = &kCFStreamNetworkServiceTypeOAM;
      goto LABEL_14;
    case 8:
      v1 = (uint64_t *)&kCFStreamNetworkServiceTypeAVStreaming;
      goto LABEL_14;
    case 9:
      v1 = (uint64_t *)&kCFStreamNetworkServiceTypeResponsiveAV;
      goto LABEL_14;
    case 10:
      v1 = &kCFStreamNetworkServiceTypeNetworkControl;
      goto LABEL_14;
    case 11:
      v1 = (uint64_t *)&kCFStreamNetworkServiceTypeCallSignaling;
LABEL_14:
      result = *v1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

void addProhibitedNetworkType(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  xpc_object_t v4;
  _QWORD v5[5];
  unsigned int v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;

  v3 = nw_parameters_copy_prohibited_interface_types();
  if (v3)
  {
    v4 = (xpc_object_t)v3;
    v7 = 0;
    v8 = &v7;
    v9 = 0x2020000000;
    v10 = 0;
  }
  else
  {
    v4 = xpc_array_create(0, 0);
    v7 = 0;
    v8 = &v7;
    v9 = 0x2020000000;
    v10 = 0;
    if (!v4)
      goto LABEL_7;
  }
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___Z24addProhibitedNetworkTypePU27objcproto16OS_nw_parameters8NSObject19nw_interface_type_t_block_invoke;
  v5[3] = &unk_1E14F7418;
  v6 = a2;
  v5[4] = &v7;
  xpc_array_apply(v4, v5);
  if (!*((_BYTE *)v8 + 24))
  {
    xpc_array_set_uint64(v4, 0xFFFFFFFFFFFFFFFFLL, a2);
    nw_parameters_set_prohibited_interface_types();
  }
  xpc_release(v4);
LABEL_7:
  _Block_object_dispose(&v7, 8);
}

void sub_184014DF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24addProhibitedNetworkTypePU27objcproto16OS_nw_parameters8NSObject19nw_interface_type_t_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result;
  uint64_t value;

  if (MEMORY[0x186DB9C40](a3) != MEMORY[0x1E0C81398])
    return 1;
  value = xpc_uint64_get_value(a3);
  result = 1;
  if (value == *(_DWORD *)(a1 + 40))
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    return 0;
  }
  return result;
}

uint64_t ___Z27removeProhibitedNetworkTypePU27objcproto16OS_nw_parameters8NSObject19nw_interface_type_t_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  if (MEMORY[0x186DB9C40](a3) == MEMORY[0x1E0C81398] && xpc_uint64_get_value(a3) != *(_DWORD *)(a1 + 40))
    xpc_array_append_value(*(xpc_object_t *)(a1 + 32), a3);
  return 1;
}

void addProhibitedNetworkSubtype(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  xpc_object_t v4;
  _QWORD v5[5];
  unsigned int v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;

  v3 = nw_parameters_copy_prohibited_interface_subtypes();
  if (v3)
  {
    v4 = (xpc_object_t)v3;
    v7 = 0;
    v8 = &v7;
    v9 = 0x2020000000;
    v10 = 0;
  }
  else
  {
    v4 = xpc_array_create(0, 0);
    v7 = 0;
    v8 = &v7;
    v9 = 0x2020000000;
    v10 = 0;
    if (!v4)
      goto LABEL_7;
  }
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___Z27addProhibitedNetworkSubtypePU27objcproto16OS_nw_parameters8NSObject22nw_interface_subtype_t_block_invoke;
  v5[3] = &unk_1E14F7418;
  v6 = a2;
  v5[4] = &v7;
  xpc_array_apply(v4, v5);
  if (!*((_BYTE *)v8 + 24))
  {
    xpc_array_set_uint64(v4, 0xFFFFFFFFFFFFFFFFLL, a2);
    nw_parameters_set_prohibited_interface_subtypes();
  }
  xpc_release(v4);
LABEL_7:
  _Block_object_dispose(&v7, 8);
}

void sub_184014FD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z27addProhibitedNetworkSubtypePU27objcproto16OS_nw_parameters8NSObject22nw_interface_subtype_t_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result;
  uint64_t value;

  if (MEMORY[0x186DB9C40](a3) != MEMORY[0x1E0C81398])
    return 1;
  value = xpc_uint64_get_value(a3);
  result = 1;
  if (value == *(_DWORD *)(a1 + 40))
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    return 0;
  }
  return result;
}

void removeProhibitedNetworkSubtype(uint64_t a1, int a2)
{
  uint64_t v3;
  void *v4;
  xpc_object_t v5;
  xpc_object_t v6;
  _QWORD v7[5];
  int v8;

  v3 = nw_parameters_copy_prohibited_interface_subtypes();
  if (v3)
  {
    v4 = (void *)v3;
    v5 = xpc_array_create(0, 0);
    if (v5)
    {
      v6 = v5;
      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 3221225472;
      v7[2] = ___Z30removeProhibitedNetworkSubtypePU27objcproto16OS_nw_parameters8NSObject22nw_interface_subtype_t_block_invoke;
      v7[3] = &unk_1E14F7440;
      v8 = a2;
      v7[4] = v5;
      xpc_array_apply(v4, v7);
      xpc_release(v4);
      nw_parameters_set_prohibited_interface_subtypes();
      v4 = v6;
    }
    xpc_release(v4);
  }
}

uint64_t ___Z30removeProhibitedNetworkSubtypePU27objcproto16OS_nw_parameters8NSObject22nw_interface_subtype_t_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  if (MEMORY[0x186DB9C40](a3) == MEMORY[0x1E0C81398] && xpc_uint64_get_value(a3) != *(_DWORD *)(a1 + 40))
    xpc_array_append_value(*(xpc_object_t *)(a1 + 32), a3);
  return 1;
}

uint64_t tlsProtocolVersionForSSLProtocol(SSLProtocol a1, int a2)
{
  int v2;
  uint64_t result;

  v2 = a1 - 1;
  result = 769;
  switch(v2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return result;
    case 6:
      result = 770;
      break;
    case 7:
      result = 771;
      break;
    case 9:
      result = 772;
      break;
    default:
      if (a2)
        result = sec_protocol_options_get_default_min_tls_protocol_version();
      else
        result = sec_protocol_options_get_default_max_tls_protocol_version();
      break;
  }
  return result;
}

CFStringRef CFNNSURLRequest::copyDebugDesc(CFNNSURLRequest *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<CFNNSURLRequest@%p>"), this);
}

void CFNNSURLRequest::~CFNNSURLRequest(CFNNSURLRequest *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E14E73F8;
  *((_QWORD *)this + 1) = &unk_1E14E7440;
  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)

  *((_QWORD *)this + 1) = &off_1E14E5838;
}

{
  void *v2;

  *(_QWORD *)this = &off_1E14E73F8;
  *((_QWORD *)this + 1) = &unk_1E14E7440;
  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)

  *((_QWORD *)this + 1) = &off_1E14E5838;
}

void sub_184015250(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void sub_1840152A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'CFNNSURLRequest::~CFNNSURLRequest(CFNNSURLRequest *this)
{
  void *v2;

  *((_QWORD *)this - 1) = &off_1E14E73F8;
  *(_QWORD *)this = &unk_1E14E7440;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)

  *(_QWORD *)this = &off_1E14E5838;
}

{
  void *v2;

  *((_QWORD *)this - 1) = &off_1E14E73F8;
  *(_QWORD *)this = &unk_1E14E7440;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)

  *(_QWORD *)this = &off_1E14E5838;
}

void sub_1840152FC(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void sub_184015354(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

CFStringRef BrotliDataDecoderHolder::copyDebugDesc(BrotliDataDecoderHolder *this)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<BrotliDecoder@%p>"), this);
}

void sub_1840153E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'BrotliDataDecoderHolder::~BrotliDataDecoderHolder(BrotliDataDecoderHolder *this)
{
  *(_QWORD *)this = &off_1E14E83F0;
  if (*((_BYTE *)this + 48))
    compression_stream_destroy((compression_stream *)((char *)this + 8));
  *(_QWORD *)this = &off_1E14E4DA0;
}

{
  *(_QWORD *)this = &off_1E14E83F0;
  if (*((_BYTE *)this + 48))
    compression_stream_destroy((compression_stream *)((char *)this + 8));
  *(_QWORD *)this = &off_1E14E4DA0;
}

void sub_18401543C(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

void sub_184015490(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

CFStringRef DeflateDataDecoderHolder::copyDebugDesc(DeflateDataDecoderHolder *this)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<GZipDecoder@%p>"), this);
}

void DeflateDataDecoderHolder::~DeflateDataDecoderHolder(DeflateDataDecoderHolder *this)
{
  *((_QWORD *)this + 1) = &off_1E14E9450;
  if (*((_BYTE *)this + 128))
    inflateEnd((z_streamp)((char *)this + 16));
  *((_QWORD *)this + 1) = &off_1E14E4DA0;
}

{
  *((_QWORD *)this + 1) = &off_1E14E9450;
  if (*((_BYTE *)this + 128))
    inflateEnd((z_streamp)((char *)this + 16));
  *((_QWORD *)this + 1) = &off_1E14E4DA0;
}

void sub_184015528(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

void sub_18401557C(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

uint64_t DeflateDataDecoderHolder::decoder(DeflateDataDecoderHolder *this)
{
  return (uint64_t)this + 8;
}

void `non-virtual thunk to'DeflateDataDecoderHolder::~DeflateDataDecoderHolder(DeflateDataDecoderHolder *this)
{
  *(_QWORD *)this = &off_1E14E9450;
  if (*((_BYTE *)this + 120))
    inflateEnd((z_streamp)((char *)this + 8));
  *(_QWORD *)this = &off_1E14E4DA0;
}

{
  *(_QWORD *)this = &off_1E14E9450;
  if (*((_BYTE *)this + 120))
    inflateEnd((z_streamp)((char *)this + 8));
  *(_QWORD *)this = &off_1E14E4DA0;
}

void sub_1840155D8(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

void sub_18401562C(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

uint64_t DeflateDataDecoder::isInitialized(DeflateDataDecoder *this)
{
  return *((unsigned __int8 *)this + 120);
}

CFStringRef GZIPDataDecoderHolder::copyDebugDesc(GZIPDataDecoderHolder *this)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<GZipDecoder@%p>"), this);
}

void sub_1840156C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'GZIPDataDecoderHolder::~GZIPDataDecoderHolder(GZIPDataDecoderHolder *this)
{
  *(_QWORD *)this = &off_1E14E7728;
  if (*((_BYTE *)this + 120))
    inflateEnd((z_streamp)((char *)this + 8));
  *(_QWORD *)this = &off_1E14E4DA0;
}

{
  *(_QWORD *)this = &off_1E14E7728;
  if (*((_BYTE *)this + 120))
    inflateEnd((z_streamp)((char *)this + 8));
  *(_QWORD *)this = &off_1E14E4DA0;
}

void sub_18401571C(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

void sub_184015770(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

_OWORD *CFURLDataDecoderCreateWithResponse(const __CFAllocator *a1, _CFURLResponse *a2)
{
  uint64_t v3;
  const __CFString *v4;
  const __CFString *v5;
  unsigned __int8 v6;
  _OWORD *v7;

  if (!a2)
    return 0;
  v3 = *(_QWORD *)(-[_CFURLResponse _inner](a2, "_inner") + 88);
  if (!v3)
    return 0;
  v4 = CFHTTPMessageCopyHeaderFieldValue((CFHTTPMessageRef)(v3 - 16), (CFStringRef)&unk_1EDCFCE10);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = determineHTTPEncodingFromString(v4);
  v7 = CFURLDataDecoderCreateWithContentEncoding(a1, v6);
  CFRelease(v5);
  return v7;
}

void ___ZN25DownloadDataDecoderHolder5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CFURLDownloadDataDecoder");
  DownloadDataDecoderHolder::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_184015844(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

CFStringRef DownloadDataDecoderHolder::copyDebugDesc(DownloadDataDecoderHolder *this)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<%sDownloadDataDecoder@%p>"), *((_QWORD *)this + 1), this);
}

void MacBinaryDownloadDataDecoderHolder::~MacBinaryDownloadDataDecoderHolder(MacBinaryDownloadDataDecoderHolder *this)
{
  *((_QWORD *)this + 2) = off_1E14E9D70;
}

{
  *((_QWORD *)this + 2) = off_1E14E9D70;
}

uint64_t MacBinaryDownloadDataDecoderHolder::downloadDecoder(MacBinaryDownloadDataDecoderHolder *this)
{
  return (uint64_t)this + 16;
}

void `non-virtual thunk to'MacBinaryDownloadDataDecoderHolder::~MacBinaryDownloadDataDecoderHolder(MacBinaryDownloadDataDecoderHolder *this)
{
  *(_QWORD *)this = off_1E14E9D70;
}

{
  *(_QWORD *)this = off_1E14E9D70;
}

uint64_t MacBinaryDownloadDataDecoder::isInitialized(MacBinaryDownloadDataDecoder *this)
{
  return *((unsigned __int8 *)this + 8);
}

uint64_t MacBinaryDownloadDataDecoder::getMIMEType(MacBinaryDownloadDataDecoder *this)
{
  return 0x1EDCFF8B8;
}

uint64_t MacBinaryDownloadDataDecoder::supportsResume(MacBinaryDownloadDataDecoder *this)
{
  return 1;
}

void BinHexDownloadDataDecoderHolder::~BinHexDownloadDataDecoderHolder(BinHexDownloadDataDecoderHolder *this)
{
  *((_QWORD *)this + 2) = off_1E14E9D70;
}

{
  *((_QWORD *)this + 2) = off_1E14E9D70;
}

uint64_t BinHexDownloadDataDecoderHolder::downloadDecoder(BinHexDownloadDataDecoderHolder *this)
{
  return (uint64_t)this + 16;
}

void `non-virtual thunk to'BinHexDownloadDataDecoderHolder::~BinHexDownloadDataDecoderHolder(BinHexDownloadDataDecoderHolder *this)
{
  *(_QWORD *)this = off_1E14E9D70;
}

{
  *(_QWORD *)this = off_1E14E9D70;
}

uint64_t BinHexDownloadDataDecoder::isInitialized(BinHexDownloadDataDecoder *this)
{
  return *((unsigned __int8 *)this + 8);
}

uint64_t BinHexDownloadDataDecoder::getMIMEType(BinHexDownloadDataDecoder *this)
{
  return 0x1EDCFF880;
}

uint64_t BinHexDownloadDataDecoder::supportsResume(BinHexDownloadDataDecoder *this)
{
  return 1;
}

void GZipDownloadDataDecoderHolder::~GZipDownloadDataDecoderHolder(GZipDownloadDataDecoderHolder *this)
{
  GZipDownloadDataDecoder::~GZipDownloadDataDecoder((GZipDownloadDataDecoderHolder *)((char *)this + 16));
}

{
  GZipDownloadDataDecoder::~GZipDownloadDataDecoder((GZipDownloadDataDecoderHolder *)((char *)this + 16));
}

uint64_t GZipDownloadDataDecoderHolder::downloadDecoder(GZipDownloadDataDecoderHolder *this)
{
  return (uint64_t)this + 16;
}

uint64_t GZipDownloadDataDecoder::isInitialized(GZipDownloadDataDecoder *this)
{
  return *((unsigned __int8 *)this + 136);
}

uint64_t GZipDownloadDataDecoder::getMIMEType(GZipDownloadDataDecoder *this)
{
  return 0x1EDCFFB20;
}

uint64_t DownloadDataDecoder::supportsResume(DownloadDataDecoder *this)
{
  return 0;
}

uint64_t DownloadDataDecoder::createResumeInformation(DownloadDataDecoder *this, const __CFAllocator *a2)
{
  return 0;
}

uint64_t CFURLDownloadDataDecoderDecodeData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  const void *v9;
  uint64_t v10;
  CFAllocatorRef v11;

  if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1)
    dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2564);
  if (a1)
    v8 = a1 + 16;
  else
    v8 = 0;
  v9 = (const void *)(v8 - 16);
  v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 56))(v8);
  v11 = CFGetAllocator(v9);
  return (*(uint64_t (**)(uint64_t, uint64_t, CFAllocatorRef, uint64_t, uint64_t))(*(_QWORD *)v10 + 40))(v10, a2, v11, a3, a4);
}

void BinHexDownloadDataDecoder::~BinHexDownloadDataDecoder(BinHexDownloadDataDecoder *this)
{
  *(_QWORD *)this = off_1E14E9D70;
}

{
  *(_QWORD *)this = off_1E14E9D70;
  JUMPOUT(0x186DB748CLL);
}

BOOL BinHexDownloadDataDecoder::canDecodeHeaderData(BinHexDownloadDataDecoder *this, CFDataRef theData)
{
  const UInt8 *BytePtr;
  _BOOL8 result;

  BytePtr = CFDataGetBytePtr(theData);
  *((_QWORD *)this + 7) = BytePtr;
  *((_QWORD *)this + 8) = &BytePtr[CFDataGetLength(theData)];
  BinHexDownloadDataDecoder::decodeDownloadHeader(this);
  result = *((_BYTE *)this + 153) == 0;
  *((_DWORD *)this + 4) = 0;
  *((_BYTE *)this + 72) = 0;
  *(_QWORD *)((char *)this + 36) = 0;
  *(_QWORD *)((char *)this + 28) = 0;
  *(_QWORD *)((char *)this + 43) = 0;
  *(_QWORD *)((char *)this + 148) = 0;
  return result;
}

BOOL BinHexDownloadDataDecoder::decodeData(BinHexDownloadDataDecoder *this, CFDataRef theData, const __CFAllocator *a3, const __CFData **a4, const __CFData **a5)
{
  const UInt8 *BytePtr;

  *a4 = 0;
  *a5 = 0;
  BytePtr = CFDataGetBytePtr(theData);
  *((_QWORD *)this + 7) = BytePtr;
  *((_QWORD *)this + 8) = &BytePtr[CFDataGetLength(theData)];
  if (!*((_BYTE *)this + 152))
    BinHexDownloadDataDecoder::decodeDownloadHeader(this);
  *a4 = BinHexDownloadDataDecoder::decodeForkWithData(this, a3, (unsigned int *)this + 10, (unsigned __int8 *)this + 48);
  if (*((_BYTE *)this + 48))
    *a5 = BinHexDownloadDataDecoder::decodeForkWithData(this, a3, (unsigned int *)this + 11, (unsigned __int8 *)this + 49);
  return *((_BYTE *)this + 153) == 0;
}

CFStringRef BinHexDownloadDataDecoder::createFilenameWithOriginalFilename(ConstStr255Param pStr, CFAllocatorRef alloc, CFTypeRef cf)
{
  if (pStr[72])
    return CFStringCreateWithPascalString(alloc, pStr + 72, 0);
  else
    return (CFStringRef)CFRetain(cf);
}

uint64_t BinHexDownloadDataDecoder::isFinishedDecoding(BinHexDownloadDataDecoder *this)
{
  return *((unsigned __int8 *)this + 49);
}

__CFDictionary *BinHexDownloadDataDecoder::createFileAttributesDictionary(BinHexDownloadDataDecoder *this, CFAllocatorRef allocator)
{
  __CFDictionary *Mutable;
  CFDataRef v5;
  CFDataRef v6;
  UInt8 bytes[8];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)this + 152))
    return 0;
  Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v9 = 0;
    v10 = 0;
    v11 = 0;
    *(_QWORD *)bytes = *((_QWORD *)this + 17);
    LOWORD(v9) = *((_DWORD *)this + 36);
    v5 = CFDataCreate(allocator, bytes, 32);
    if (v5)
    {
      v6 = v5;
      CFDictionaryAddValue(Mutable, CFSTR("kCFURLDownloadFinderInfoAttr"), v5);
      CFRelease(v6);
    }
  }
  return Mutable;
}

CFDictionaryRef BinHexDownloadDataDecoder::createResumeInformation(BinHexDownloadDataDecoder *this, CFAllocatorRef allocator)
{
  CFDictionaryRef v3;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFDataRef v11;
  CFDataRef v12;
  CFDataRef v13;
  CFIndex v14;
  CFDataRef v15;
  CFNumberRef cf;
  __int16 valuePtr;
  void *keys[8];
  const __CFString *v19;
  uint64_t v20;
  void *values[8];
  CFDataRef v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)this + 152) || *((_BYTE *)this + 153))
    return 0;
  v22 = 0;
  v23 = 0;
  v19 = 0;
  v20 = 0;
  valuePtr = *((_BYTE *)this + 48) != 0;
  v6 = CFNumberCreate(allocator, kCFNumberSInt16Type, &valuePtr);
  v7 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 36);
  v8 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 40);
  v9 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 44);
  v10 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 32);
  v11 = CFDataCreate(allocator, (const UInt8 *)this + 20, *((unsigned int *)this + 7));
  v12 = CFDataCreate(allocator, (const UInt8 *)this + 9, *((unsigned int *)this + 4));
  keys[0] = CFSTR("NSURLDownloadDecoderMIMEType");
  values[0] = (void *)(*(uint64_t (**)(BinHexDownloadDataDecoder *))(*(_QWORD *)this + 24))(this);
  values[1] = v6;
  keys[1] = CFSTR("NSURLDownloadBinHexDataForkCRCChecked");
  keys[2] = CFSTR("NSURLDownloadBinHexCRC");
  values[2] = v7;
  values[3] = v8;
  keys[3] = CFSTR("NSURLDownloadBinHexDataForkBytesRemaining");
  keys[4] = CFSTR("NSURLDownloadBinHexResourceForkBytesRemaining");
  values[4] = v9;
  values[5] = v10;
  cf = v10;
  keys[5] = CFSTR("NSURLDownloadBinHexDecodedDataOffset");
  keys[6] = CFSTR("NSURLDownloadBinHexDecodedData");
  keys[7] = CFSTR("NSURLDownloadBinHexEncodedData");
  values[6] = v11;
  values[7] = v12;
  if (*((_BYTE *)this + 50))
  {
    v13 = CFDataCreate(allocator, (const UInt8 *)this + 157, 1);
    v19 = CFSTR("NSURLDownloadBinHexFirstCRCByte");
    v22 = v13;
    v14 = 9;
  }
  else
  {
    v13 = 0;
    v14 = 8;
  }
  if (*((_BYTE *)this + 155))
  {
    v15 = CFDataCreate(allocator, (const UInt8 *)this + 156, 1);
    keys[v14] = CFSTR("NSURLDownloadBinHexRepeatByte");
    values[v14++] = v15;
  }
  else
  {
    v15 = 0;
  }
  v3 = CFDictionaryCreate(allocator, (const void **)keys, (const void **)values, v14, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v6)
    CFRelease(v6);
  if (v7)
    CFRelease(v7);
  if (v8)
    CFRelease(v8);
  if (v9)
    CFRelease(v9);
  if (cf)
    CFRelease(cf);
  if (v11)
    CFRelease(v11);
  if (v12)
    CFRelease(v12);
  if (v13)
    CFRelease(v13);
  if (v15)
    CFRelease(v15);
  return v3;
}

uint64_t BinHexDownloadDataDecoder::decodeDownloadHeader(BinHexDownloadDataDecoder *this)
{
  void *v2;
  unsigned __int8 *v3;
  char *v4;
  uint64_t result;
  uint64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  int v9;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned __int8 v14[2];
  _OWORD __src[4];
  unsigned __int8 v16[24];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  memset(v16, 0, 19);
  memset(__src, 0, sizeof(__src));
  *(_WORD *)v14 = 0;
  v4 = (char *)this + 56;
  v2 = (void *)*((_QWORD *)this + 7);
  v3 = (unsigned __int8 *)*((_QWORD *)v4 + 1);
  while (1)
  {
    result = (uint64_t)memchr(v2, 40, v3 - (_BYTE *)v2);
    *((_QWORD *)this + 7) = result;
    if (!result)
      break;
    v6 = result;
    if (((_DWORD)v3 - result) <= 0x2C)
      break;
    result = memcmp((const void *)result, "(This file must be converted with BinHex 4.0)", 0x2DuLL);
    if (!(_DWORD)result)
    {
      v7 = (unsigned __int8 *)(v6 + 45);
      *((_QWORD *)this + 7) = v6 + 45;
      if ((unsigned __int8 *)(v6 + 45) != v3)
      {
        while (1)
        {
          v8 = v7 + 1;
          *((_QWORD *)this + 7) = v7 + 1;
          v9 = *v7;
          if (v9 != 10 && v9 != 13)
            break;
          v7 = v8;
          if (v8 == v3)
            goto LABEL_27;
        }
        if (v9 == 58)
        {
          result = BinHexDownloadDataDecoder::decodeIntoBuffer(this, (unsigned __int8 *)__src, 1u, 0);
          if ((_DWORD)result != 1)
            *((_BYTE *)this + 153) = 1;
          v11 = LOBYTE(__src[0]);
          if (LOBYTE(__src[0]) - 64 > 0xFFFFFFC0)
          {
            if (BinHexDownloadDataDecoder::decodeIntoBuffer(this, (unsigned __int8 *)__src + 1, LOBYTE(__src[0]), 0) != v11)*((_BYTE *)this + 153) = 1;
            result = BinHexDownloadDataDecoder::decodeIntoBuffer(this, v16, 0x13u, 0);
            if ((_DWORD)result != 19)
              *((_BYTE *)this + 153) = 1;
            if (!v16[0])
            {
              result = BinHexDownloadDataDecoder::decodeIntoBuffer(this, v14, 2u, 1);
              if ((_DWORD)result != 2)
                *((_BYTE *)this + 153) = 1;
              if (*((unsigned __int16 *)this + 18) == bswap32(*(unsigned __int16 *)v14) >> 16)
              {
                result = (uint64_t)memcpy((char *)this + 72, __src, LOBYTE(__src[0]) + 1);
                v12 = bswap32(*(unsigned int *)&v16[5]);
                *((_DWORD *)this + 34) = bswap32(*(unsigned int *)&v16[1]);
                *((_DWORD *)this + 35) = v12;
                *((_DWORD *)this + 36) = __rev16(*(unsigned __int16 *)&v16[9]);
                v13 = bswap32(*(unsigned int *)&v16[15]);
                *((_DWORD *)this + 10) = bswap32(*(unsigned int *)&v16[11]);
                *((_DWORD *)this + 11) = v13;
                *((_DWORD *)this + 9) = 0;
                *((_BYTE *)this + 152) = 1;
                return result;
              }
            }
          }
        }
      }
      break;
    }
    v2 = (void *)(v6 + 1);
    *((_QWORD *)this + 7) = v6 + 1;
  }
LABEL_27:
  *((_BYTE *)this + 153) = 1;
  return result;
}

__CFData *BinHexDownloadDataDecoder::decodeForkWithData(BinHexDownloadDataDecoder *this, const __CFAllocator *a2, unsigned int *a3, unsigned __int8 *a4)
{
  uint64_t v4;
  const __CFAllocator *v5;
  unsigned int *v6;
  _BYTE *v7;
  _BYTE *v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int *v11;
  const __CFAllocator *v12;
  __CFData *Mutable;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  BOOL v17;
  unsigned __int8 *v18;
  int v19;
  BinHexDownloadDataDecoder *v20;
  unsigned int v21;
  int v22;
  UInt8 bytes[2];
  uint64_t v25;

  v4 = MEMORY[0x1E0C80A78](this);
  v8 = v7;
  v9 = v4;
  v25 = *MEMORY[0x1E0C80C00];
  v10 = *v6;
  if (*v6)
  {
    v11 = v6;
    v12 = v5;
    Mutable = 0;
    while (1)
    {
      v14 = v10 >= 0x2000 ? 0x2000 : v10;
      v15 = BinHexDownloadDataDecoder::decodeIntoBuffer((BinHexDownloadDataDecoder *)v9, bytes, v14, 0);
      if (!v15)
        break;
      v16 = v15;
      if (!Mutable)
        Mutable = CFDataCreateMutable(v12, 0);
      CFDataAppendBytes(Mutable, bytes, v16);
      v10 = *v11 - v16;
      v17 = *v11 == v16;
      *v11 = v10;
      if (v17)
        goto LABEL_13;
    }
  }
  else
  {
    Mutable = 0;
LABEL_13:
    if (!*v8)
    {
      if (*(_BYTE *)(v9 + 50))
      {
        bytes[0] = *(_BYTE *)(v9 + 157);
        v18 = &bytes[1];
        v19 = 1;
        v20 = (BinHexDownloadDataDecoder *)v9;
        v21 = 1;
      }
      else
      {
        v19 = 2;
        v18 = bytes;
        v20 = (BinHexDownloadDataDecoder *)v9;
        v21 = 2;
      }
      v22 = BinHexDownloadDataDecoder::decodeIntoBuffer(v20, v18, v21, 1);
      if (v22 == 1 && !*(_BYTE *)(v9 + 50))
      {
        *(_BYTE *)(v9 + 50) = 1;
        *(_BYTE *)(v9 + 157) = bytes[0];
      }
      else
      {
        if (v22 != v19 || *(unsigned __int16 *)(v9 + 36) != bswap32(*(unsigned __int16 *)bytes) >> 16)
          *(_BYTE *)(v9 + 153) = 1;
        *v8 = 1;
        *(_DWORD *)(v9 + 36) = 0;
        *(_BYTE *)(v9 + 50) = 0;
      }
    }
  }
  return Mutable;
}

uint64_t BinHexDownloadDataDecoder::decodeIntoBuffer(BinHexDownloadDataDecoder *this, unsigned __int8 *a2, unsigned int a3, int a4)
{
  uint64_t result;
  unsigned int v8;
  uint64_t v9;
  unsigned __int8 *v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  BOOL v25;
  unsigned __int8 *v26;
  int v27;
  int v28;
  char *v29;
  unsigned int v30;
  unsigned __int8 v31;
  unsigned int v32;
  int v33;
  unsigned __int8 *v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v38;

  if (*((_BYTE *)this + 153))
    return 0;
  v35 = *((_DWORD *)this + 4);
  v8 = *((_DWORD *)this + 8);
  v38 = *((_DWORD *)this + 7);
  v9 = *((unsigned int *)this + 9);
  v10 = (unsigned __int8 *)*((_QWORD *)this + 7);
  v33 = (int)a2;
  v34 = (unsigned __int8 *)*((_QWORD *)this + 8);
  v11 = *((unsigned __int8 *)this + 155);
  v12 = *((_DWORD *)this + 37);
  if (!v12)
  {
    v14 = *((unsigned __int8 *)this + 156);
    v15 = a2;
LABEL_10:
    v36 = (_DWORD)a2 + a3;
    while (v8 != v38)
    {
      v17 = v8 + 1;
      v18 = *((unsigned __int8 *)this + v8 + 20);
      if ((_DWORD)v18 != 144)
      {
        v21 = 1;
        ++v8;
        goto LABEL_19;
      }
      v19 = v35;
      if (v17 == v38)
      {
        v24 = *((unsigned __int8 *)this + 154);
        if (*((_BYTE *)this + 154))
        {
LABEL_44:
          result = 0;
          *((_BYTE *)this + 153) = 1;
          return result;
        }
LABEL_26:
        if (v24)
          v25 = 1;
        else
          v25 = v10 == v34;
        if (v25)
          goto LABEL_45;
        v26 = v10;
        while (1)
        {
          v27 = *v26++;
          v28 = sixBitTable[v27];
          if (v28 != 64)
          {
            if (v28 == 65)
            {
              *((_BYTE *)this + 154) = 1;
            }
            else
            {
              if (v28 == 66)
                goto LABEL_44;
              v29 = (char *)this + v19++;
              v29[9] = v28;
            }
            if (v19 == 4 || *((_BYTE *)this + 154))
              break;
          }
          v10 = v26;
          if (v26 == v34)
          {
            v10 = v34;
            goto LABEL_45;
          }
        }
        ++v10;
        v30 = v38 - v8;
        if (v38 != v8)
          memmove((char *)this + 20, (char *)this + v8 + 20, v38 - v8);
        v8 = 0;
        v31 = *((_BYTE *)this + 11);
        v32 = *((unsigned __int8 *)this + 10);
        *((_BYTE *)this + v30 + 21) = (v31 >> 2) | (16 * v32);
        *((_BYTE *)this + v30 + 20) = (v32 >> 4) | (4 * *((_BYTE *)this + 9));
        *((_BYTE *)this + v30 + 22) = *((_BYTE *)this + 12) | (v31 << 6);
        v38 = v30 + ((6 * v19) >> 3);
        v35 = 0;
      }
      else
      {
        v8 += 2;
        v20 = *((unsigned __int8 *)this + v17 + 20);
        if (v20)
        {
          if (!v11)
            goto LABEL_44;
          v21 = v20 - 1;
          v18 = v14;
        }
        else
        {
          v21 = 1;
          v18 = 144;
        }
LABEL_19:
        v22 = v36 - (_DWORD)v15;
        if (v21 >= v36 - v15)
          v23 = v22;
        else
          v23 = v21;
        v14 = v18;
        v9 = handleRepeatCount(v23, v18, v9, v15, a4);
        v15 += v23;
        v11 = 1;
        if (v21 > v22)
        {
          *((_DWORD *)this + 37) = v21 - v23;
          goto LABEL_43;
        }
      }
    }
    v24 = *((unsigned __int8 *)this + 154);
    v8 = v38;
    v19 = v35;
    goto LABEL_26;
  }
  if (v12 >= a3)
    v13 = a3;
  else
    v13 = v12;
  v14 = *((unsigned __int8 *)this + 156);
  v9 = handleRepeatCount(v13, *((unsigned __int8 *)this + 156), v9, a2, a4);
  v15 = &a2[v13];
  v16 = *((_DWORD *)this + 37) - v13;
  *((_DWORD *)this + 37) = v16;
  if (!v16)
    goto LABEL_10;
LABEL_43:
  v19 = v35;
LABEL_45:
  *((_DWORD *)this + 4) = v19;
  *((_DWORD *)this + 7) = v38;
  *((_DWORD *)this + 8) = v8;
  *((_DWORD *)this + 9) = v9;
  *((_BYTE *)this + 156) = v14;
  *((_BYTE *)this + 155) = v11;
  result = ((_DWORD)v15 - v33);
  *((_QWORD *)this + 7) = v10;
  return result;
}

uint64_t handleRepeatCount(int a1, unsigned int a2, uint64_t a3, unsigned __int8 *a4, int a5)
{
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;

  if (a1)
  {
    if (a5)
      v5 = 0;
    else
      v5 = a2;
    do
    {
      *a4 = a2;
      v6 = 8;
      v7 = v5;
      do
      {
        v8 = 2 * a3;
        if ((a3 & 0x8000) != 0)
          v8 = (2 * a3) & 0xFFFE ^ 0x1021;
        a3 = v8 ^ (v7 >> 7);
        v7 = 2 * (v7 & 0x7F);
        --v6;
      }
      while (v6);
      ++a4;
      --a1;
    }
    while (a1);
  }
  return a3;
}

uint64_t DownloadDataDecoder::isInitialized(DownloadDataDecoder *this)
{
  return 0;
}

uint64_t DownloadDataDecoder::canDecodeHeaderData(DownloadDataDecoder *this, const __CFData *a2)
{
  return 0;
}

uint64_t DownloadDataDecoder::decodeData(DownloadDataDecoder *this, const __CFData *a2, const __CFAllocator *a3, const __CFData **a4, const __CFData **a5)
{
  return 0;
}

uint64_t DownloadDataDecoder::createFilenameWithOriginalFilename(DownloadDataDecoder *this, const __CFAllocator *a2, const __CFString *a3)
{
  return 0;
}

uint64_t DownloadDataDecoder::isFinishedDecoding(DownloadDataDecoder *this)
{
  return 1;
}

uint64_t DownloadDataDecoder::createFileAttributesDictionary(DownloadDataDecoder *this, const __CFAllocator *a2)
{
  return 0;
}

void sub_1840167DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_184016944(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_184016A44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)_NSHTTPAlternativeServicesStorage;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_184016B68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  void *v22;

  _Block_object_dispose(&a17, 8);

  _Unwind_Resume(a1);
}

void sub_184016E38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21)
{
  void *v21;
  void *v22;
  void *v23;

  _Unwind_Resume(a1);
}

void sub_184016F20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_184016FE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840172B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  a12(&a10);
  _Unwind_Resume(a1);
}

void sub_184017634(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  a12(&a10);
  _Unwind_Resume(a1);
}

void sub_1840176F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_184017A48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  a12(&a10);
  _Unwind_Resume(a1);
}

void sub_184017B44(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_184017CD4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__2748(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2749(uint64_t a1)
{

}

void sub_184017FEC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void DeflateDataDecoder::~DeflateDataDecoder(DeflateDataDecoder *this)
{
  *(_QWORD *)this = &off_1E14E9450;
  if (*((_BYTE *)this + 120))
    inflateEnd((z_streamp)((char *)this + 8));
  *(_QWORD *)this = &off_1E14E4DA0;
}

{
  *(_QWORD *)this = &off_1E14E9450;
  if (*((_BYTE *)this + 120))
    inflateEnd((z_streamp)((char *)this + 8));
  *(_QWORD *)this = &off_1E14E4DA0;
  JUMPOUT(0x186DB748CLL);
}

void sub_184018060(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

void sub_1840180C8(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

__CFData *DeflateDataDecoder::decodeData(DeflateDataDecoder *this, const __CFAllocator *a2, const __CFData *a3, unsigned __int8 *a4)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  const __CFData *v7;
  const __CFData *v8;
  uint64_t v9;
  CFAllocatorRef v10;
  __CFData *Mutable;
  int Length;
  int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  BOOL v17;
  int v18;
  UInt8 v20[16384];
  uint64_t v21;

  v4 = MEMORY[0x1E0C80A78](this);
  v6 = v5;
  v8 = v7;
  v9 = v4;
  v21 = *MEMORY[0x1E0C80C00];
  Mutable = CFDataCreateMutable(v10, 0);
  *v6 = 0;
  if (!Mutable)
    return Mutable;
  *(_QWORD *)(v9 + 8) = CFDataGetBytePtr(v8);
  Length = CFDataGetLength(v8);
  *(_DWORD *)(v9 + 16) = Length;
  if (!Length)
    return Mutable;
  v13 = 1;
  while (1)
  {
    while (1)
    {
      *(_QWORD *)(v9 + 32) = v20;
      *(_DWORD *)(v9 + 40) = 0x4000;
      v14 = inflate((z_streamp)(v9 + 8), 0);
      v15 = v14;
      v16 = *(_DWORD *)(v9 + 40);
      if (*(_DWORD *)(v9 + 16))
        v17 = 0;
      else
        v17 = v14 == -5;
      if (v17)
        goto LABEL_17;
      if (v14 > 1)
        break;
      CFDataAppendBytes(Mutable, v20, 0x4000 - v16);
      if (v15 == 1)
        return Mutable;
      if (!*(_DWORD *)(v9 + 16))
        goto LABEL_17;
    }
    if (v14 != -3 || !v13)
      goto LABEL_20;
    CFDataSetLength(Mutable, 0);
    inflateEnd((z_streamp)(v9 + 8));
    if (inflateInit2_((z_streamp)(v9 + 8), -15, "1.2.12", 112))
      break;
    *(_QWORD *)(v9 + 8) = CFDataGetBytePtr(v8);
    v18 = CFDataGetLength(v8);
    v13 = 0;
    *(_DWORD *)(v9 + 16) = v18;
    if (!v18)
    {
LABEL_17:
      if (v16)
        return Mutable;
    }
  }
  *(_BYTE *)(v9 + 120) = 0;
LABEL_20:
  CFRelease(Mutable);
  return 0;
}

void DataDecoder::~DataDecoder(DataDecoder *this)
{
  *(_QWORD *)this = &off_1E14E4DA0;
}

{
  *(_QWORD *)this = &off_1E14E4DA0;
  JUMPOUT(0x186DB748CLL);
}

uint64_t DataDecoder::isInitialized(DataDecoder *this)
{
  return 0;
}

uint64_t DataDecoder::decodeData(DataDecoder *this, const __CFAllocator *a2, const __CFData *a3, unsigned __int8 *a4)
{
  *a4 = 0;
  return 0;
}

void GZipDataDecoder::~GZipDataDecoder(GZipDataDecoder *this)
{
  *(_QWORD *)this = &off_1E14E7728;
  if (*((_BYTE *)this + 120))
    inflateEnd((z_streamp)((char *)this + 8));
  *(_QWORD *)this = &off_1E14E4DA0;
}

{
  *(_QWORD *)this = &off_1E14E7728;
  if (*((_BYTE *)this + 120))
    inflateEnd((z_streamp)((char *)this + 8));
  *(_QWORD *)this = &off_1E14E4DA0;
  JUMPOUT(0x186DB748CLL);
}

void sub_18401831C(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

void sub_184018384(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

void GZipDownloadDataDecoder::~GZipDownloadDataDecoder(GZipDownloadDataDecoder *this)
{
  GZipDownloadDataDecoder::~GZipDownloadDataDecoder(this);
  JUMPOUT(0x186DB748CLL);
}

{
  const void *v2;

  *(_QWORD *)this = &off_1E14ECA80;
  if (*((_BYTE *)this + 136))
    inflateEnd((z_streamp)((char *)this + 8));
  v2 = (const void *)*((_QWORD *)this + 15);
  if (v2)
    CFRelease(v2);
  *(_QWORD *)this = off_1E14E9D70;
}

uint64_t GZipDownloadDataDecoder::canDecodeHeaderData(GZipDownloadDataDecoder *this, const __CFData *a2)
{
  unsigned __int8 v3;

  return gzipDecodeHeader(a2, 0, 0, 0, 0, &v3);
}

BOOL GZipDownloadDataDecoder::decodeData(GZipDownloadDataDecoder *this, CFDataRef theData, const __CFAllocator *a3, const __CFData **a4, const __CFData **a5)
{
  const __CFData *v8;
  int v9;
  const __CFData *GzipDecodedData;
  unsigned __int8 v12;
  __CFData *v13;

  v8 = 0;
  LODWORD(v13) = 0;
  *a5 = 0;
  if (!*((_BYTE *)this + 137))
  {
    v9 = gzipDecodeHeader(theData, (uInt *)&v13, a3, (const __CFString **)this + 15, (unint64_t *)this + 16, &v12);
    *((_BYTE *)this + 137) = v9;
    if (!v9)
    {
      GzipDecodedData = 0;
      goto LABEL_5;
    }
    v8 = (const __CFData *)v13;
  }
  GzipDecodedData = (const __CFData *)createGzipDecodedData((z_stream_s *)((char *)this + 8), (unsigned __int8 *)this + 138, theData, v8);
LABEL_5:
  *a4 = GzipDecodedData;
  return GzipDecodedData != 0;
}

CFStringRef GZipDownloadDataDecoder::createFilenameWithOriginalFilename(GZipDownloadDataDecoder *this, CFAllocatorRef alloc, const __CFString *a3)
{
  const __CFString *v4;
  const __CFString *ExtensionFromFilename;
  const __CFString *v8;
  const __CFString *v9;
  CFIndex Length;
  CFIndex v11;
  CFStringRef v12;
  const __CFString *v13;
  CFIndex v14;
  CFIndex v15;
  CFStringRef v16;
  CFStringRef v17;
  CFRange v18;
  CFRange v19;

  v4 = (const __CFString *)*((_QWORD *)this + 15);
  if (v4)
    return CFStringCreateCopy(alloc, v4);
  ExtensionFromFilename = createExtensionFromFilename(a3);
  if (!ExtensionFromFilename)
    return (CFStringRef)CFRetain(a3);
  v8 = ExtensionFromFilename;
  if (CFStringCompare(ExtensionFromFilename, CFSTR("gz"), 1uLL) == kCFCompareEqualTo
    || CFStringCompare(v8, CFSTR("gzip"), 1uLL) == kCFCompareEqualTo)
  {
    Length = CFStringGetLength(a3);
    v11 = CFStringGetLength(v8);
    if (Length > v11 + 1)
    {
      v18.length = Length + ~v11;
      v18.location = 0;
      v9 = CFStringCreateWithSubstring(alloc, a3, v18);
      goto LABEL_11;
    }
LABEL_18:
    v12 = 0;
    goto LABEL_19;
  }
  if (CFStringCompare(v8, CFSTR("tgz"), 1uLL) == kCFCompareEqualTo)
  {
    v13 = CFSTR("tar");
LABEL_15:
    v14 = CFStringGetLength(a3);
    v15 = CFStringGetLength(v8);
    if (v14 > v15 + 1)
    {
      v19.length = v14 + ~v15;
      v19.location = 0;
      v16 = CFStringCreateWithSubstring(alloc, a3, v19);
      if (v16)
      {
        v17 = v16;
        v12 = CFStringCreateWithFormat(alloc, 0, CFSTR("%@.%@"), v16, v13);
        CFRelease(v17);
        goto LABEL_19;
      }
    }
    goto LABEL_18;
  }
  if (CFStringCompare(v8, CFSTR("cpgz"), 1uLL) == kCFCompareEqualTo)
  {
    v13 = CFSTR("cpio");
    goto LABEL_15;
  }
  v9 = (const __CFString *)CFRetain(a3);
LABEL_11:
  v12 = v9;
LABEL_19:
  CFRelease(v8);
  return v12;
}

uint64_t GZipDownloadDataDecoder::isFinishedDecoding(GZipDownloadDataDecoder *this)
{
  if (*((_DWORD *)this + 4) | *((unsigned __int8 *)this + 138))
    return *((unsigned __int8 *)this + 138);
  else
    return 1;
}

__CFDictionary *GZipDownloadDataDecoder::createFileAttributesDictionary(GZipDownloadDataDecoder *this, CFAllocatorRef allocator)
{
  __CFDictionary *Mutable;
  CFDateRef v5;
  CFDateRef v6;

  if (!*((_QWORD *)this + 16))
    return 0;
  Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v5 = CFDateCreate(allocator, (double)*((unint64_t *)this + 16) - *MEMORY[0x1E0C9ADF8]);
    if (v5)
    {
      v6 = v5;
      CFDictionaryAddValue(Mutable, CFSTR("kCFURLDownloadFileModDate"), v5);
    }
    else
    {
      v6 = Mutable;
      Mutable = 0;
    }
    CFRelease(v6);
  }
  return Mutable;
}

void sub_184018758(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = off_1E14E9D70;
  _Unwind_Resume(a1);
}

void MacBinaryDownloadDataDecoder::~MacBinaryDownloadDataDecoder(MacBinaryDownloadDataDecoder *this)
{
  *(_QWORD *)this = off_1E14E9D70;
}

{
  *(_QWORD *)this = off_1E14E9D70;
  JUMPOUT(0x186DB748CLL);
}

BOOL MacBinaryDownloadDataDecoder::canDecodeHeaderData(MacBinaryDownloadDataDecoder *this, CFDataRef theData)
{
  const UInt8 *BytePtr;
  uint64_t v4;
  unsigned __int16 v5;
  uint64_t v6;
  uint64_t v8;
  int v9;
  int v10;

  if (CFDataGetLength(theData) < 128)
    return 0;
  BytePtr = CFDataGetBytePtr(theData);
  if (*BytePtr || BytePtr[74] || BytePtr[1] - 64 < 0xFFFFFFC1)
    return 0;
  if (BytePtr[102] != 109 || BytePtr[103] != 66 || BytePtr[104] != 73 || BytePtr[105] != 78)
  {
    v4 = 0;
    v5 = 0;
    do
      v5 = gMagic[((unsigned __int16)(v5 ^ (BytePtr[v4++] << 8)) >> 8)] ^ (v5 << 8);
    while ((_DWORD)v4 != 124);
    if ((BytePtr[125] | (BytePtr[124] << 8)) != v5)
    {
      if (!BytePtr[82] && !BytePtr[126] && !BytePtr[127])
      {
        v8 = 0;
        while (!BytePtr[v8 + 99])
        {
          if (++v8 == 27)
          {
            v6 = 0;
            v9 = bswap32(*(_DWORD *)(BytePtr + 83));
            if (v9 < 0x800000)
            {
              v10 = bswap32(*(_DWORD *)(BytePtr + 87));
              if (v10 < 0x800000)
                return (v9 | v10) != 0;
            }
            return v6;
          }
        }
      }
      return 0;
    }
  }
  return BytePtr[123] < 0x82u;
}

uint64_t MacBinaryDownloadDataDecoder::decodeData(MacBinaryDownloadDataDecoder *this, CFDataRef theData, const __CFAllocator *a3, const __CFData **a4, const __CFData **a5)
{
  const __CFData *Length;
  signed int v11;
  unsigned int v12;
  unsigned int v13;
  const UInt8 *BytePtr;
  __int16 v15;
  UInt8 v16;
  int v17;
  int v18;
  BOOL v19;
  unsigned int v20;
  uint64_t v21;
  signed int v22;
  int v23;
  const UInt8 *v24;
  signed int v25;
  CFIndex v27;
  unsigned int v28;
  size_t v29;
  uint64_t v30;
  UInt8 *v31;
  _QWORD v33[2];
  CFRange v34;

  v33[1] = *MEMORY[0x1E0C80C00];
  *a4 = 0;
  *a5 = 0;
  Length = (const __CFData *)CFDataGetLength(theData);
  v11 = (int)Length;
  if (*((_DWORD *)this + 3))
  {
    v12 = *((_DWORD *)this + 20);
    v13 = *((_DWORD *)this + 21);
  }
  else
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = (const __CFData *)memcpy((char *)this + 16, BytePtr + 1, BytePtr[1] + 1);
    *((_DWORD *)this + 25) = bswap32(*(_DWORD *)(BytePtr + 65));
    *((_DWORD *)this + 26) = bswap32(*(_DWORD *)(BytePtr + 69));
    v12 = bswap32(*(_DWORD *)(BytePtr + 83));
    *((_DWORD *)this + 20) = v12;
    v13 = bswap32(*(_DWORD *)(BytePtr + 87));
    *((_DWORD *)this + 21) = v13;
    *((_DWORD *)this + 23) = bswap32(*(_DWORD *)(BytePtr + 91));
    *((_DWORD *)this + 24) = bswap32(*(_DWORD *)(BytePtr + 95));
    v15 = BytePtr[101] | (BytePtr[73] << 8);
    *((_WORD *)this + 44) = v15;
    v16 = BytePtr[107];
    *((_WORD *)this + 44) = v15 & 0xAC4E;
    *((_WORD *)this + 45) = v16 & 4;
    if (BytePtr[102] == 109 && BytePtr[103] == 66 && BytePtr[104] == 73 && BytePtr[105] == 78)
      *((_WORD *)this + 54) = BytePtr[106];
  }
  v17 = v12 + 128;
  v18 = *((_DWORD *)this + 3);
  if (v12)
    v19 = v17 <= v18;
  else
    v19 = 1;
  if (v19)
  {
    v20 = v13;
  }
  else
  {
    v20 = v13;
    if (v18 + v11 >= 129)
    {
      if (v18 >= 128)
        v21 = 0;
      else
        v21 = (128 - v18);
      v22 = v17 - v18;
      if (v22 >= v11)
        v22 = v11;
      v23 = v22 - v21;
      v24 = CFDataGetBytePtr(theData);
      Length = CFDataCreate(a3, &v24[v21], v23);
      *a4 = Length;
      v18 = *((_DWORD *)this + 3);
      v20 = *((_DWORD *)this + 21);
    }
  }
  if (v20)
  {
    v25 = (v12 + 255) & 0xFFFFFF80;
    if ((int)(v25 + v13) > v18 && v18 + v11 > v25)
    {
      v27 = (v25 - v18) & ~((v25 - v18) >> 31);
      if ((int)(v25 + v13 - v18) >= v11)
        v28 = v11;
      else
        v28 = v25 + v13 - v18;
      v29 = (int)(v28 - v27);
      MEMORY[0x1E0C80A78](Length);
      v31 = (UInt8 *)v33 - v30;
      bzero((char *)v33 - v30, v29);
      v34.location = v27;
      v34.length = v29;
      CFDataGetBytes(theData, v34, v31);
      *a5 = CFDataCreate(a3, v31, v29);
      v18 = *((_DWORD *)this + 3);
    }
  }
  *((_DWORD *)this + 3) = v18 + v11;
  return 1;
}

CFStringRef MacBinaryDownloadDataDecoder::createFilenameWithOriginalFilename(const unsigned __int8 *pStr, CFAllocatorRef alloc, CFTypeRef cf)
{
  if (pStr[16])
    return CFStringCreateWithPascalString(alloc, pStr + 16, *((__int16 *)pStr + 54));
  else
    return (CFStringRef)CFRetain(cf);
}

BOOL MacBinaryDownloadDataDecoder::isFinishedDecoding(MacBinaryDownloadDataDecoder *this)
{
  return *((_DWORD *)this + 3) >= (int)(((*((_DWORD *)this + 20) + 255) & 0xFFFFFF80) + *((_DWORD *)this + 21));
}

__CFDictionary *MacBinaryDownloadDataDecoder::createFileAttributesDictionary(MacBinaryDownloadDataDecoder *this, CFAllocatorRef allocator)
{
  __CFDictionary *Mutable;
  CFDataRef v5;
  CFDataRef v6;
  CFDateRef v7;
  CFDateRef v8;
  CFDateRef v9;
  CFDateRef v10;
  CFAbsoluteTime at;
  UInt8 bytes[8];
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    at = 0.0;
    v15 = 0;
    v16 = 0;
    v14 = 0;
    *(_QWORD *)bytes = *(_QWORD *)((char *)this + 100);
    LOWORD(v14) = *((_WORD *)this + 44);
    LOWORD(v16) = *((_WORD *)this + 45);
    v5 = CFDataCreate(allocator, bytes, 32);
    if (v5)
    {
      v6 = v5;
      CFDictionaryAddValue(Mutable, CFSTR("kCFURLDownloadFinderInfoAttr"), v5);
      CFRelease(v6);
    }
    if (convertLocalMacTimeToCFAbsoluteTime(*((_DWORD *)this + 23), &at))
    {
      v7 = CFDateCreate(allocator, at);
      if (v7)
      {
        v8 = v7;
        CFDictionaryAddValue(Mutable, CFSTR("kCFURLDownloadFileCreateDate"), v7);
        CFRelease(v8);
      }
    }
    if (convertLocalMacTimeToCFAbsoluteTime(*((_DWORD *)this + 24), &at))
    {
      v9 = CFDateCreate(allocator, at);
      if (v9)
      {
        v10 = v9;
        CFDictionaryAddValue(Mutable, CFSTR("kCFURLDownloadFileModDate"), v9);
        CFRelease(v10);
      }
    }
  }
  return Mutable;
}

CFDictionaryRef MacBinaryDownloadDataDecoder::createResumeInformation(MacBinaryDownloadDataDecoder *this, CFAllocatorRef allocator)
{
  CFNumberRef v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFDictionaryRef v8;
  CFDictionaryRef v9;
  __int128 v11;
  __int128 v12;
  void *values[2];
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)values = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v4 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 80);
  v5 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 12);
  v6 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 84);
  v7 = v6;
  if (v4 && v5 && v6)
  {
    *(_QWORD *)&v11 = CFSTR("NSURLDownloadDecoderMIMEType");
    *((_QWORD *)&v11 + 1) = CFSTR("NSURLDownloadMacBinaryDataForkLength");
    *(_QWORD *)&v12 = CFSTR("NSURLDownloadMacBinaryOffset");
    *((_QWORD *)&v12 + 1) = CFSTR("NSURLDownloadMacBinaryResourceForkLength");
    values[0] = (void *)(*(uint64_t (**)(MacBinaryDownloadDataDecoder *))(*(_QWORD *)this + 24))(this);
    values[1] = v4;
    *(_QWORD *)&v14 = v5;
    *((_QWORD *)&v14 + 1) = v7;
    v8 = CFDictionaryCreate(allocator, (const void **)&v11, (const void **)values, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  else
  {
    v8 = 0;
    v9 = 0;
    if (!v4)
      goto LABEL_7;
  }
  CFRelease(v4);
  v9 = v8;
LABEL_7:
  if (v5)
    CFRelease(v5);
  if (v7)
    CFRelease(v7);
  return v9;
}

const __CFTimeZone *convertLocalMacTimeToCFAbsoluteTime(unsigned int a1, double *a2)
{
  const __CFTimeZone *result;
  const __CFTimeZone *v5;
  CFAbsoluteTime v6;
  CFTimeInterval SecondsFromGMT;
  double v8;

  result = CFTimeZoneCopySystem();
  if (result)
  {
    v5 = result;
    v6 = (double)a1 - *MEMORY[0x1E0C9ADE8];
    SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(result, v6);
    v8 = CFTimeZoneGetSecondsFromGMT(v5, v6 - SecondsFromGMT);
    CFRelease(v5);
    *a2 = v6 - v8;
    return (const __CFTimeZone *)1;
  }
  return result;
}

uint64_t _CFNetworkDoesNeedProxy(const __CFString *a1, const __CFArray *a2, const void *a3)
{
  const void *v4;
  const void *v5;
  CFTypeID v6;
  const void *v7;
  CFIndex Length;
  const __CFAllocator *v9;
  CFIndex v10;
  CFIndex v11;
  _BOOL8 v12;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v15;
  CFIndex v16;
  CFIndex v17;
  uint64_t v18;
  CFIndex v19;
  const __CFString *v20;
  const __CFAllocator *v21;
  CFIndex v22;
  __CFString *MutableCopy;
  CFIndex v24;
  const __CFArray *v25;
  const __CFArray *v26;
  const __CFString *v27;
  const __CFString *v28;
  const __CFArray *v29;
  const __CFArray *v30;
  CFIndex v31;
  const __CFAllocator *v32;
  const __CFString *v33;
  CFMutableStringRef v34;
  CFIndex i;
  const __CFString *v36;
  const __CFAllocator *v37;
  UInt8 *v38;
  const __CFArray *v39;
  CFIndex v40;
  CFIndex v42;
  CFIndex v43;
  const __CFString *v44;
  const __CFString *v45;
  const __CFString *v46;
  const __CFString *v47;
  const __CFString *v48;
  BOOL v49;
  const __CFString *v50;
  const __CFString *ValueAtIndex;
  const __CFAllocator *v52;
  UInt8 *v53;
  CFIndex idx;
  SInt32 IntValue;
  __CFString *theString;
  uint64_t v57;
  _BOOL4 v58;
  CFIndex Count;
  unsigned int v61;
  unsigned int v62;
  CFAllocatorRef valuePtr;
  uint64_t v64;
  void *ptr;
  UInt8 v66[1024];
  uint64_t v67;
  CFRange v68;
  CFRange v69;
  CFRange v70;

  v67 = *MEMORY[0x1E0C80C00];
  v4 = (const void *)*MEMORY[0x1E0C9AE40];
  if (a3)
    v5 = a3;
  else
    v5 = (const void *)*MEMORY[0x1E0C9AE40];
  if (!v5)
  {
    v7 = (const void *)*MEMORY[0x1E0C9AE50];
    goto LABEL_10;
  }
  v6 = CFGetTypeID(v5);
  if (v6 == CFNumberGetTypeID())
  {
    LODWORD(valuePtr) = 0;
    CFNumberGetValue((CFNumberRef)v5, kCFNumberSInt32Type, &valuePtr);
    v7 = (const void *)*MEMORY[0x1E0C9AE50];
    if (!(_DWORD)valuePtr)
      goto LABEL_11;
    goto LABEL_10;
  }
  v7 = (const void *)*MEMORY[0x1E0C9AE50];
  if ((const void *)*MEMORY[0x1E0C9AE50] == v5)
LABEL_10:
    v4 = v7;
LABEL_11:
  if (CFStringCompare(a1, CFSTR("localhost"), 1uLL) == kCFCompareEqualTo)
    return 0;
  if (CFStringCompare(a1, CFSTR("127.0.0.1"), 1uLL) == kCFCompareEqualTo)
    return 0;
  if (CFStringCompare(a1, CFSTR("::1"), 1uLL) == kCFCompareEqualTo)
    return 0;
  Length = CFStringGetLength(a1);
  if (v4)
  {
    if (CFEqual(v4, v7) && CFStringFind(a1, CFSTR("."), 0).location == -1)
      return 0;
  }
  if (!a2)
    return 1;
  Count = CFArrayGetCount(a2);
  if (!Count)
    return 1;
  if (CFStringHasSuffix(a1, CFSTR(".")))
  {
    v9 = CFGetAllocator(a1);
    v10 = CFStringGetLength(a1);
    theString = CFStringCreateMutableCopy(v9, v10, a1);
    v11 = CFStringGetLength(a1);
    v68.length = CFStringGetLength(CFSTR("."));
    v68.location = v11 - 1;
    CFStringDelete(theString, v68);
    a1 = theString;
  }
  else
  {
    theString = 0;
  }
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, a1, CFSTR("."));
  v15 = ArrayBySeparatingStrings;
  if (!ArrayBySeparatingStrings)
    goto LABEL_30;
  v16 = CFArrayGetCount(ArrayBySeparatingStrings);
  v17 = v16;
  if (v16 == 5)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v15, 4);
    v58 = 0;
    if (CFStringGetLength(ValueAtIndex) || Length >= 17)
    {
      v18 = 5;
      goto LABEL_32;
    }
LABEL_114:
    v52 = CFGetAllocator(a1);
    valuePtr = v52;
    v64 = 1023;
    if (a1)
    {
      v53 = _CFStringGetOrCreateCString(v52, a1, v66, &v64, 0x600u);
    }
    else
    {
      v66[0] = 0;
      v64 = 0;
      v53 = v66;
    }
    ptr = v53;
    v18 = v17;
    v58 = inet_pton(2, (const char *)v53, &v62) == 1;
    if (ptr && v66 != ptr)
      CFAllocatorDeallocate(valuePtr, ptr);
    goto LABEL_32;
  }
  v18 = v16;
  if (v16 == 4)
  {
    if (Length > 16)
    {
      v58 = 0;
      v18 = 4;
      goto LABEL_32;
    }
    goto LABEL_114;
  }
  if (!v16)
  {
    CFRelease(v15);
    v15 = 0;
LABEL_30:
    v18 = 0;
  }
  v58 = 0;
LABEL_32:
  if (Count >= 1)
  {
    v19 = 0;
    v57 = v18;
    idx = v18 - 1;
    while (1)
    {
      v20 = (const __CFString *)CFArrayGetValueAtIndex(a2, v19);
      if (CFStringHasSuffix(v20, CFSTR(".")))
      {
        v21 = CFGetAllocator(v20);
        v22 = CFStringGetLength(v20);
        MutableCopy = CFStringCreateMutableCopy(v21, v22, v20);
        v24 = CFStringGetLength(v20);
        v69.length = CFStringGetLength(CFSTR("."));
        v69.location = v24 - 1;
        CFStringDelete(MutableCopy, v69);
        v20 = MutableCopy;
      }
      else
      {
        MutableCopy = 0;
      }
      if (CFStringCompare(a1, v20, 1uLL))
      {
        if (!v58
          || (v70.length = CFStringGetLength(v20),
              v70.location = 0,
              !CFStringFindWithOptions(v20, CFSTR("/"), v70, 0, 0)))
        {
          if (v15)
          {
            v39 = CFStringCreateArrayBySeparatingStrings(0, v20, CFSTR("."));
            v26 = v39;
            if (v39)
            {
              v40 = CFArrayGetCount(v39);
              if (v40 >= 2 && v57 >= 1)
              {
                v42 = v40 - 1;
                v43 = idx;
                while (1)
                {
                  v44 = (const __CFString *)CFArrayGetValueAtIndex(v15, v43);
                  v45 = (const __CFString *)CFArrayGetValueAtIndex(v26, v42);
                  v46 = v45;
                  if (!v42 && !CFStringGetLength(v45))
                    v46 = CFSTR("*");
                  if (CFStringCompare(v44, v46, 1uLL))
                  {
                    if (CFStringCompare(v46, CFSTR("*"), 1uLL))
                      break;
                    while (1)
                    {
                      v47 = (const __CFString *)CFArrayGetValueAtIndex(v26, v42);
                      v48 = v47;
                      if (!v42 && !CFStringGetLength(v47))
                        v48 = CFSTR("*");
                      if (CFStringCompare(v48, CFSTR("*"), 1uLL))
                        break;
                      v49 = v42-- <= 0;
                      if (v49)
                        goto LABEL_92;
                    }
                    if (v43 < 0)
                      break;
                    while (1)
                    {
                      v50 = (const __CFString *)CFArrayGetValueAtIndex(v15, v43);
                      if (CFStringCompare(v48, v50, 1uLL) == kCFCompareEqualTo)
                        break;
                      v49 = v43-- <= 0;
                      if (v49)
                        goto LABEL_82;
                    }
                  }
                  else
                  {
                    if (!(v43 | v42))
                    {
LABEL_92:
                      v12 = 0;
                      goto LABEL_83;
                    }
                    --v43;
                    --v42;
                  }
                  v12 = 1;
                  if (v43 < 0 || v42 < 0)
                    goto LABEL_83;
                }
              }
LABEL_82:
              v12 = 1;
              goto LABEL_83;
            }
          }
LABEL_87:
          v12 = 1;
          if (!MutableCopy)
            goto LABEL_89;
LABEL_88:
          CFRelease(MutableCopy);
          goto LABEL_89;
        }
        v25 = CFStringCreateArrayBySeparatingStrings(0, v20, CFSTR("/"));
        v26 = v25;
        if (!v25)
          goto LABEL_87;
        if (CFArrayGetCount(v25) != 2)
          goto LABEL_82;
        v27 = (const __CFString *)CFArrayGetValueAtIndex(v26, 1);
        IntValue = CFStringGetIntValue(v27);
        if ((IntValue - 1) > 0x1F)
          goto LABEL_82;
        v28 = (const __CFString *)CFArrayGetValueAtIndex(v26, 0);
        v29 = CFStringCreateArrayBySeparatingStrings(0, v28, CFSTR("."));
        v30 = v29;
        if (!v29)
          goto LABEL_82;
        v31 = CFArrayGetCount(v29);
        if (v31 > 4)
        {
          v12 = 1;
        }
        else
        {
          v32 = CFGetAllocator(a1);
          v33 = (const __CFString *)CFArrayGetValueAtIndex(v30, 0);
          v34 = CFStringCreateMutableCopy(v32, 0, v33);
          for (i = 1; i != 4; ++i)
          {
            if (i < v31 && (v36 = (const __CFString *)CFArrayGetValueAtIndex(v30, i), CFStringGetLength(v36)))
              CFStringAppendFormat(v34, 0, CFSTR(".%@"), v36);
            else
              CFStringAppend(v34, CFSTR(".0"));
          }
          if (CFStringGetLength(v34) > 16)
          {
            v12 = 1;
          }
          else
          {
            v37 = CFGetAllocator(a1);
            valuePtr = v37;
            v64 = 1023;
            if (v34)
            {
              v38 = _CFStringGetOrCreateCString(v37, v34, v66, &v64, 0x600u);
            }
            else
            {
              v66[0] = 0;
              v64 = 0;
              v38 = v66;
            }
            ptr = v38;
            v12 = inet_pton(2, (const char *)v38, &v61) != 1
               || (bswap32(v62) & (~(-1 << IntValue) << -(char)IntValue)) != bswap32(v61);
            if (ptr && v66 != ptr)
              CFAllocatorDeallocate(valuePtr, ptr);
          }
          if (v34)
            CFRelease(v34);
        }
        CFRelease(v30);
LABEL_83:
        CFRelease(v26);
      }
      else
      {
        v12 = 0;
      }
      if (MutableCopy)
        goto LABEL_88;
LABEL_89:
      if (v12 && ++v19 < Count)
        continue;
      goto LABEL_106;
    }
  }
  v12 = 1;
LABEL_106:
  if (theString)
    CFRelease(theString);
  if (v15)
    CFRelease(v15);
  return v12;
}

void sub_1840196B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, CFAllocatorRef allocator,uint64_t a21,void *ptr)
{
  if (ptr)
  {
    if (a11 != ptr)
      CFAllocatorDeallocate(allocator, ptr);
  }
  _Unwind_Resume(exception_object);
}

CFArrayRef CFNetworkCopyProxiesForURL(CFURLRef url, CFDictionaryRef proxySettings)
{
  return (CFArrayRef)__CFNetworkCopyProxiesForURLWithInterface(url, proxySettings, 0);
}

uint64_t _CFNetworkSetOverrideSystemProxySettings(const void *a1)
{
  CFTypeRef v2;

  pthread_mutex_lock(&__sCFNSystemProxyDictLock);
  if (a1)
    v2 = CFRetain(a1);
  else
    v2 = 0;
  __sProxyOverrideDict = (uint64_t)v2;
  return pthread_mutex_unlock(&__sCFNSystemProxyDictLock);
}

void sub_18401989C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_184019A4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  void *v20;
  void *v21;
  void *v22;
  void *v23;

  _Unwind_Resume(a1);
}

void sub_184019C04(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_184019E2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_184019ED4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_18401A060(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

id getCookieLogHandle(void)
{
  if (getCookieLogHandle(void)::onceToken != -1)
    dispatch_once(&getCookieLogHandle(void)::onceToken, &__block_literal_global_2994);
  return (id)cookieLogHandle;
}

void ___Z18getCookieLogHandlev_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.cfnetwork", "cookies");
  v1 = (void *)cookieLogHandle;
  cookieLogHandle = (uint64_t)v0;

}

uint64_t CFURLDownloadCreate(uint64_t a1, void *a2, _QWORD *a3)
{
  uint64_t Instance;
  uint64_t v6;
  const __CFAllocator *v7;
  const __CFAllocator *v8;
  size_t v9;
  const __CFAllocator *v10;
  __CFDictionary *DownloadConnectionProperties;
  CFAllocatorRef v12;
  CFAllocatorRef allocator;
  _QWORD v15[64];
  void *ptr;
  char *__s;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (URLDownload::Class(void)::sOnce_URLDownload != -1)
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_4678);
  Instance = _CFRuntimeCreateInstance();
  v6 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    v6 = Instance + 16;
    *(_QWORD *)(Instance + 336) = 0;
    *(_OWORD *)(Instance + 304) = 0u;
    *(_OWORD *)(Instance + 320) = 0u;
    *(_OWORD *)(Instance + 272) = 0u;
    *(_OWORD *)(Instance + 288) = 0u;
    *(_OWORD *)(Instance + 240) = 0u;
    *(_OWORD *)(Instance + 256) = 0u;
    *(_OWORD *)(Instance + 208) = 0u;
    *(_OWORD *)(Instance + 224) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
  }
  *(_QWORD *)v6 = &off_1E14E54E0;
  *(_QWORD *)(v6 + 8) = &unk_1E14E5528;
  *(_QWORD *)(v6 + 160) = 0;
  *(_QWORD *)(v6 + 288) = CoreSchedulingSet::createEmpty((CoreSchedulingSet *)Instance);
  *(_DWORD *)(v6 + 304) = 0;
  *(_BYTE *)(v6 + 320) = 1;
  if (!a2 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(allocator) = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "CFURLDownloadCreate(): Asked to create from a NULL request!", (uint8_t *)&allocator, 2u);
  }
  URLDownload::_internal_setClient(v6, a3);
  CFGetAllocator((CFTypeRef)(v6 - 16));
  *(_QWORD *)(v6 + 24) = objc_msgSend(a2, "copy");
  if (*(_QWORD *)(objc_msgSend(a2, "_inner") + 32))
  {
    v7 = CFGetAllocator((CFTypeRef)(v6 - 16));
    URLPortion::URLPortion((URLPortion *)&allocator, v7, *(CFURLRef *)(objc_msgSend(a2, "_inner") + 32), 1);
    v8 = CFGetAllocator((CFTypeRef)(v6 - 16));
    v9 = strlen(__s);
    *(_QWORD *)(v6 + 224) = CFURLCreateWithBytes(v8, (const UInt8 *)__s, v9, 0x201u, 0);
    if (ptr != v15)
      CFAllocatorDeallocate(allocator, ptr);
  }
  else
  {
    *(_QWORD *)(v6 + 224) = 0;
  }
  allocator = (CFAllocatorRef)3;
  v15[0] = v6;
  v15[1] = DownloadConnectionClient::_implRetain;
  v15[2] = DownloadConnectionClient::_implRelease;
  v15[3] = DownloadConnectionClient::_copyDescription;
  v15[4] = DownloadConnectionClient::_willSendRequestCallback;
  v15[5] = DownloadConnectionClient::_didReceiveResponseCallback;
  v15[6] = DownloadConnectionClient::_didReceiveDataCallback;
  v15[7] = DownloadConnectionClient::_didStopBufferingDataCallback;
  v15[8] = DownloadConnectionClient::_connectionDidFinishLoadingCallback;
  v15[9] = DownloadConnectionClient::_didFailCallback;
  v15[10] = DownloadConnectionClient::_willCacheResponseCallback;
  v15[11] = DownloadConnectionClient::_didReceiveAuthenticationChallengeCallback;
  v15[12] = 0;
  v15[13] = DownloadConnectionClient::_shouldUseCredentialStorageCallback;
  v15[14] = 0;
  v10 = CFGetAllocator((CFTypeRef)(v6 - 16));
  DownloadConnectionProperties = createDownloadConnectionProperties(v10);
  v12 = CFGetAllocator((CFTypeRef)(v6 - 16));
  *(_QWORD *)(v6 + 16) = CFURLConnectionCreateWithProperties((uint64_t)v12, a2, &allocator, DownloadConnectionProperties);
  if (DownloadConnectionProperties)
    CFRelease(DownloadConnectionProperties);
  *(_BYTE *)(v6 + 281) = 1;
  *(_QWORD *)(v6 + 264) = 0;
  return v6 - 16;
}

void sub_18401A558(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t CFURLDownloadCreateWithResumeInformation(uint64_t a1, const __CFDictionary *a2, const void *a3, _QWORD *a4)
{
  uint64_t Instance;
  uint64_t v8;
  uint64_t v9;
  const __CFAllocator *v10;
  const __CFString *Value;
  CFTypeID v12;
  CFURLRef v13;
  NSMutableURLRequest *v14;
  const void *v15;
  CFTypeID v16;
  __CFString *v17;
  CFTypeID v18;
  __CFString *v19;
  __CFString *v20;
  CFTypeID v21;
  __CFString *v22;
  CFMutableArrayRef Mutable;
  CFIndex v24;
  const __CFDictionary *ValueAtIndex;
  const __CFString *v26;
  _OWORD *v27;
  _OWORD *v28;
  const __CFNumber *v29;
  const __CFNumber *v30;
  CFTypeID v31;
  const __CFNumber *v32;
  const __CFNumber *v33;
  CFTypeID v34;
  const __CFNumber *v35;
  const __CFNumber *v36;
  CFTypeID v37;
  uint64_t (**v38)(CFObject *__hidden, const CFObject *);
  _OWORD *v39;
  const __CFNumber *v40;
  const __CFNumber *v41;
  CFTypeID v42;
  const __CFNumber *v43;
  const __CFNumber *v44;
  CFTypeID v45;
  const __CFNumber *v46;
  const __CFNumber *v47;
  CFTypeID v48;
  const __CFNumber *v49;
  const __CFNumber *v50;
  CFTypeID v51;
  const __CFNumber *v52;
  const __CFNumber *v53;
  CFTypeID v54;
  const __CFData *v55;
  const __CFData *v56;
  CFTypeID v57;
  uint64_t Length;
  const __CFData *v59;
  const __CFData *v60;
  CFTypeID v61;
  uint64_t v62;
  const __CFData *v63;
  const __CFData *v64;
  CFTypeID v65;
  const __CFData *v66;
  const __CFData *v67;
  CFTypeID v68;
  uint64_t v69;
  CFStringRef v70;
  const __CFString *v71;
  const __CFString *v72;
  const __CFString *v73;
  const void *v74;
  const __CFAllocator *v75;
  __CFDictionary *DownloadConnectionProperties;
  CFAllocatorRef v77;
  CFTypeRef v78;
  void *v80;
  __CFString *v81;
  __CFString *v82;
  const __CFNumber *number;
  const void *v84;
  NSMutableURLRequest *v85;
  uint64_t capacity;
  const __CFArray *theArray;
  const __CFAllocator *allocator;
  _QWORD valuePtr[18];
  CFRange v90;
  CFRange v91;
  CFRange v92;
  CFRange v93;

  if (URLDownload::Class(void)::sOnce_URLDownload != -1)
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_4678);
  Instance = _CFRuntimeCreateInstance();
  v8 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    v8 = Instance + 16;
    *(_QWORD *)(Instance + 336) = 0;
    *(_OWORD *)(Instance + 304) = 0u;
    *(_OWORD *)(Instance + 320) = 0u;
    *(_OWORD *)(Instance + 272) = 0u;
    *(_OWORD *)(Instance + 288) = 0u;
    *(_OWORD *)(Instance + 240) = 0u;
    *(_OWORD *)(Instance + 256) = 0u;
    *(_OWORD *)(Instance + 208) = 0u;
    *(_OWORD *)(Instance + 224) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
  }
  *(_QWORD *)v8 = &off_1E14E54E0;
  *(_QWORD *)(v8 + 8) = &unk_1E14E5528;
  *(_QWORD *)(v8 + 160) = 0;
  *(_QWORD *)(v8 + 288) = CoreSchedulingSet::createEmpty((CoreSchedulingSet *)Instance);
  *(_DWORD *)(v8 + 304) = 0;
  *(_BYTE *)(v8 + 320) = 1;
  if (!a2 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(valuePtr[0]) = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "CFURLDownloadCreateWithResumeInformation(): Asked to create from NULL resumeInformation!", (uint8_t *)valuePtr, 2u);
    if (!a3)
    {
LABEL_8:
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        LOWORD(valuePtr[0]) = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "CFURLDownloadCreateWithResumeData(): Asked to create from a NULL path!", (uint8_t *)valuePtr, 2u);
      }
    }
  }
  else if (!a3)
  {
    goto LABEL_8;
  }
  URLDownload::_internal_setClient(v8, a4);
  v9 = v8 - 16;
  v10 = CFGetAllocator((CFTypeRef)(v8 - 16));
  Value = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("NSURLDownloadURL"));
  if (!Value)
  {
    Value = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("kCFURLDownloadResumeURL"));
    if (!Value)
      goto LABEL_100;
  }
  v12 = CFGetTypeID(Value);
  if (v12 != CFStringGetTypeID())
    goto LABEL_100;
  v13 = CFURLCreateWithString(v10, Value, 0);
  if (!v13)
    goto LABEL_100;
  v14 = (NSMutableURLRequest *)v13;
  v15 = CFDictionaryGetValue(a2, CFSTR("NSURLDownloadBytesReceived"));
  if (!v15)
  {
    v15 = CFDictionaryGetValue(a2, CFSTR("kCFURLDownloadResumeBytesReceived"));
    if (!v15)
      goto LABEL_99;
  }
  v16 = CFGetTypeID(v15);
  if (v16 != CFNumberGetTypeID())
    goto LABEL_99;
  number = (const __CFNumber *)v15;
  v17 = (__CFString *)CFDictionaryGetValue(a2, CFSTR("NSURLDownloadEntityTag"));
  if (v17 || (v17 = (__CFString *)CFDictionaryGetValue(a2, CFSTR("kCFURLDownloadResumeEntityTag"))) != 0)
  {
    v18 = CFGetTypeID(v17);
    if (v18 == CFStringGetTypeID())
      v19 = v17;
    else
      v19 = 0;
    v82 = v19;
  }
  else
  {
    v82 = 0;
  }
  v85 = v14;
  allocator = v10;
  v20 = (__CFString *)CFDictionaryGetValue(a2, CFSTR("NSURLDownloadServerModificationDate"));
  v84 = a3;
  if (v20
    || (v20 = (__CFString *)CFDictionaryGetValue(a2, CFSTR("kCFURLDownloadResumeServerModificationDateString"))) != 0)
  {
    v21 = CFGetTypeID(v20);
    if (v21 == CFStringGetTypeID())
      v22 = v20;
    else
      v22 = 0;
    v81 = v22;
  }
  else
  {
    v81 = 0;
  }
  theArray = (const __CFArray *)CFDictionaryGetValue(a2, CFSTR("NSURLDownloadDecoders"));
  if (!theArray || (capacity = CFArrayGetCount(theArray), capacity < 1))
  {
LABEL_79:
    v14 = -[NSURLRequest initWithURL:cachePolicy:timeoutInterval:]([NSMutableURLRequest alloc], "initWithURL:cachePolicy:timeoutInterval:", v14, 0, 60.0);
    CFRelease(v85);
    if (!v14)
      goto LABEL_100;
    if (!CFNumberGetValue(number, kCFNumberSInt64Type, (void *)(v8 + 272)))
      goto LABEL_99;
    URLDownload::_internal_setServerModificationDateString((URLDownload *)v8, v81);
    URLDownload::_internal_setEntityTag((URLDownload *)v8, v82);
    if (!*(_QWORD *)(v8 + 240) && !*(_QWORD *)(v8 + 232))
      goto LABEL_99;
    v70 = CFStringCreateWithFormat(allocator, 0, CFSTR("bytes=%lld-"), *(_QWORD *)(v8 + 272));
    if (!v70)
      goto LABEL_99;
    v71 = v70;
    v72 = *(const __CFString **)(v8 + 232);
    if (!v72)
      v72 = *(const __CFString **)(v8 + 240);
    CFURLRequestSetHTTPHeaderFieldValue(v14, CFSTR("If-Range"), v72);
    CFURLRequestSetHTTPHeaderFieldValue(v14, (const __CFString *)&unk_1EDCFD4A0, v71);
    CFRelease(v71);
    URLDownload::_internal_setRequest((URLDownload *)v8, (_CFURLRequest *)v14);
    CFRelease(v14);
    v73 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("NSURLDownloadOriginatingURLString"));
    if (v73)
    {
      v74 = CFURLCreateWithString(allocator, v73, 0);
    }
    else
    {
      v80 = *(void **)(v8 + 24);
      if (!v80)
        goto LABEL_100;
      v74 = *(const void **)(objc_msgSend(v80, "_inner") + 32);
      if (v74)
        v74 = CFRetain(v74);
    }
    *(_QWORD *)(v8 + 224) = v74;
    if (!*(_QWORD *)(v8 + 24))
      goto LABEL_100;
    valuePtr[0] = 3;
    valuePtr[1] = v8;
    valuePtr[2] = DownloadConnectionClient::_implRetain;
    valuePtr[3] = DownloadConnectionClient::_implRelease;
    valuePtr[4] = DownloadConnectionClient::_copyDescription;
    valuePtr[5] = DownloadConnectionClient::_willSendRequestCallback;
    valuePtr[6] = DownloadConnectionClient::_didReceiveResponseCallback;
    valuePtr[7] = DownloadConnectionClient::_didReceiveDataCallback;
    valuePtr[8] = DownloadConnectionClient::_didStopBufferingDataCallback;
    valuePtr[9] = DownloadConnectionClient::_connectionDidFinishLoadingCallback;
    valuePtr[10] = DownloadConnectionClient::_didFailCallback;
    valuePtr[11] = DownloadConnectionClient::_willCacheResponseCallback;
    valuePtr[12] = DownloadConnectionClient::_didReceiveAuthenticationChallengeCallback;
    valuePtr[13] = 0;
    valuePtr[14] = DownloadConnectionClient::_shouldUseCredentialStorageCallback;
    valuePtr[15] = 0;
    v75 = CFGetAllocator((CFTypeRef)(v8 - 16));
    DownloadConnectionProperties = createDownloadConnectionProperties(v75);
    v77 = CFGetAllocator((CFTypeRef)(v8 - 16));
    *(_QWORD *)(v8 + 16) = CFURLConnectionCreateWithProperties((uint64_t)v77, *(void **)(v8 + 24), valuePtr, DownloadConnectionProperties);
    if (DownloadConnectionProperties)
      CFRelease(DownloadConnectionProperties);
    *(_BYTE *)(v8 + 281) = 1;
    *(_QWORD *)(v8 + 264) = 0;
    *(_WORD *)(v8 + 284) = 256;
    if (v84)
      v78 = CFRetain(v84);
    else
      v78 = 0;
    *(_QWORD *)(v8 + 200) = v78;
    return v9;
  }
  Mutable = CFArrayCreateMutable(v10, capacity, MEMORY[0x1E0C9B378]);
  *(_QWORD *)(v8 + 256) = Mutable;
  if (!Mutable)
    goto LABEL_99;
  v24 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v24);
    v26 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("NSURLDownloadDecoderMIMEType"));
    if (CFStringCompare(v26, CFSTR("application/mac-binhex40"), 1uLL) == kCFCompareEqualTo)
    {
      if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1)
        dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2564);
      v39 = (_OWORD *)_CFRuntimeCreateInstance();
      v28 = v39;
      if (v39)
      {
        v39[1] = 0u;
        v28 = v39 + 1;
        v39[10] = 0u;
        v39[11] = 0u;
        v39[8] = 0u;
        v39[9] = 0u;
        v39[6] = 0u;
        v39[7] = 0u;
        v39[4] = 0u;
        v39[5] = 0u;
        v39[2] = 0u;
        v39[3] = 0u;
      }
      *(_QWORD *)v28 = &off_1E14ED3B0;
      *((_QWORD *)v28 + 1) = "GZip";
      *((_QWORD *)v28 + 2) = &off_1E14ED308;
      LOWORD(valuePtr[0]) = 0;
      *(_QWORD *)((char *)v28 + 44) = 0;
      *((_DWORD *)v28 + 8) = 0;
      *((_BYTE *)v28 + 88) = 0;
      *(_QWORD *)((char *)v28 + 52) = 0;
      *(_QWORD *)((char *)v28 + 59) = 0;
      *(_QWORD *)((char *)v28 + 164) = 0;
      *((_BYTE *)v28 + 24) = 0;
      v40 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("NSURLDownloadBinHexDataForkCRCChecked"));
      v41 = v40;
      if (!v40)
        goto LABEL_76;
      v42 = CFGetTypeID(v40);
      if (v42 != CFNumberGetTypeID())
        goto LABEL_76;
      CFNumberGetValue(v41, kCFNumberSInt16Type, valuePtr);
      *((_BYTE *)v28 + 64) = LOWORD(valuePtr[0]) != 0;
      v43 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("NSURLDownloadBinHexCRC"));
      v44 = v43;
      if (!v43)
        goto LABEL_76;
      v45 = CFGetTypeID(v43);
      if (v45 != CFNumberGetTypeID())
        goto LABEL_76;
      CFNumberGetValue(v44, kCFNumberSInt32Type, (char *)v28 + 52);
      v46 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("NSURLDownloadBinHexDataForkBytesRemaining"));
      v47 = v46;
      if (!v46)
        goto LABEL_76;
      v48 = CFGetTypeID(v46);
      if (v48 != CFNumberGetTypeID())
        goto LABEL_76;
      CFNumberGetValue(v47, kCFNumberSInt32Type, (char *)v28 + 56);
      v49 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("NSURLDownloadBinHexResourceForkBytesRemaining"));
      v50 = v49;
      if (!v49)
        goto LABEL_76;
      v51 = CFGetTypeID(v49);
      if (v51 != CFNumberGetTypeID())
        goto LABEL_76;
      CFNumberGetValue(v50, kCFNumberSInt32Type, (char *)v28 + 60);
      v52 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("NSURLDownloadBinHexDecodedDataOffset"));
      v53 = v52;
      if (!v52)
        goto LABEL_76;
      v54 = CFGetTypeID(v52);
      if (v54 != CFNumberGetTypeID())
        goto LABEL_76;
      CFNumberGetValue(v53, kCFNumberSInt32Type, v28 + 3);
      v55 = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, CFSTR("NSURLDownloadBinHexDecodedData"));
      v56 = v55;
      if (!v55)
        goto LABEL_76;
      v57 = CFGetTypeID(v55);
      if (v57 != CFDataGetTypeID())
        goto LABEL_76;
      Length = CFDataGetLength(v56);
      if (Length > 8)
        goto LABEL_76;
      v90.location = 0;
      v90.length = Length;
      CFDataGetBytes(v56, v90, (UInt8 *)v28 + 36);
      *((_DWORD *)v28 + 11) = Length;
      v59 = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, CFSTR("NSURLDownloadBinHexEncodedData"));
      v60 = v59;
      if (!v59)
        goto LABEL_76;
      v61 = CFGetTypeID(v59);
      if (v61 != CFDataGetTypeID())
        goto LABEL_76;
      v62 = CFDataGetLength(v60);
      if (v62 > 3)
        goto LABEL_76;
      v91.location = 0;
      v91.length = v62;
      CFDataGetBytes(v60, v91, (UInt8 *)v28 + 25);
      *((_DWORD *)v28 + 8) = v62;
      v63 = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, CFSTR("NSURLDownloadBinHexFirstCRCByte"));
      v64 = v63;
      if (v63)
      {
        v65 = CFGetTypeID(v63);
        if (v65 == CFDataGetTypeID())
        {
          if (CFDataGetLength(v64) != 1)
            goto LABEL_76;
          v92.location = 0;
          v92.length = 1;
          CFDataGetBytes(v64, v92, (UInt8 *)v28 + 173);
          *((_BYTE *)v28 + 66) = 1;
        }
      }
      v66 = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, CFSTR("NSURLDownloadBinHexRepeatByte"));
      v67 = v66;
      if (!v66)
        goto LABEL_75;
      v68 = CFGetTypeID(v66);
      if (v68 != CFDataGetTypeID())
        goto LABEL_75;
      if (CFDataGetLength(v67) == 1)
      {
        v93.location = 0;
        v93.length = 1;
        CFDataGetBytes(v67, v93, (UInt8 *)v28 + 172);
        *((_BYTE *)v28 + 171) = 1;
LABEL_75:
        *((_BYTE *)v28 + 168) = 1;
        *((_BYTE *)v28 + 24) = 1;
      }
LABEL_76:
      v38 = &off_1E14EF1C8;
      goto LABEL_77;
    }
    if (CFStringCompare(v26, CFSTR("application/macbinary"), 1uLL))
      goto LABEL_98;
    if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1)
      dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2564);
    v27 = (_OWORD *)_CFRuntimeCreateInstance();
    v28 = v27;
    if (v27)
    {
      v27[1] = 0u;
      v28 = v27 + 1;
      v27[7] = 0u;
      v27[8] = 0u;
      v27[5] = 0u;
      v27[6] = 0u;
      v27[3] = 0u;
      v27[4] = 0u;
      v27[2] = 0u;
    }
    *(_QWORD *)v28 = &off_1E14ED3B0;
    *((_QWORD *)v28 + 1) = "GZip";
    *((_DWORD *)v28 + 7) = 0;
    *((_QWORD *)v28 + 12) = 0;
    *((_QWORD *)v28 + 2) = &off_1E14EE8C0;
    *((_WORD *)v28 + 62) = 0;
    *((_BYTE *)v28 + 32) = 0;
    *((_QWORD *)v28 + 13) = 0;
    *((_DWORD *)v28 + 28) = 0;
    *((_BYTE *)v28 + 24) = 0;
    v29 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("NSURLDownloadMacBinaryDataForkLength"));
    v30 = v29;
    if (v29)
    {
      v31 = CFGetTypeID(v29);
      if (v31 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v30, kCFNumberSInt32Type, v28 + 6);
        v32 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("NSURLDownloadMacBinaryOffset"));
        v33 = v32;
        if (v32)
        {
          v34 = CFGetTypeID(v32);
          if (v34 == CFNumberGetTypeID())
          {
            CFNumberGetValue(v33, kCFNumberSInt32Type, (char *)v28 + 28);
            v35 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("NSURLDownloadMacBinaryResourceForkLength"));
            v36 = v35;
            if (v35)
            {
              v37 = CFGetTypeID(v35);
              if (v37 == CFNumberGetTypeID())
              {
                CFNumberGetValue(v36, kCFNumberSInt32Type, (char *)v28 + 100);
                *((_BYTE *)v28 + 24) = 1;
              }
            }
          }
        }
      }
    }
    v38 = &off_1E14EF628;
LABEL_77:
    *(_QWORD *)v28 = v38;
    *((_QWORD *)v28 + 2) = v38 + 10;
    v69 = ((uint64_t (*)(MacBinaryDownloadDataDecoderHolder *))v38[7])((MacBinaryDownloadDataDecoderHolder *)v28);
    if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v69 + 16))(v69))
      break;
    CFArrayAppendValue(*(CFMutableArrayRef *)(v8 + 256), v28 - 1);
    CFRelease(v28 - 1);
    if (capacity == ++v24)
      goto LABEL_79;
  }
  CFRelease(v28 - 1);
LABEL_98:
  CFRelease(*(CFTypeRef *)(v8 + 256));
  *(_QWORD *)(v8 + 256) = 0;
LABEL_99:
  CFRelease(v14);
LABEL_100:
  CFRelease((CFTypeRef)(v8 - 16));
  return 0;
}

void sub_18401B0FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 16) = off_1E14E9D70;
  _Unwind_Resume(a1);
}

void sub_18401B110(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t CFURLDownloadCreateAndStartWithLoadingConnection(uint64_t a1, char *a2, _CFURLRequest *a3, _CFURLResponse *a4, _QWORD *a5)
{
  uint64_t Instance;
  uint64_t v10;
  char *v11;
  const __CFAllocator *v12;
  const __CFAllocator *v13;
  size_t v14;
  CFTypeRef v15;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, _QWORD, _CFURLResponse *, _QWORD);
  _CFURLRequest *v19;
  _CFURLRequest *v20;
  const void *v21;
  const __CFAllocator *v22;
  __CFDictionary *DownloadConnectionProperties;
  CFAllocatorRef v24;
  uint64_t v25;
  void (*v26)(uint64_t, _QWORD);
  uint64_t v27;
  void (*v28)(uint64_t, _CFURLResponse *, _QWORD);
  _QWORD v29[16];
  CFAllocatorRef allocator;
  _QWORD v31[64];
  void *ptr;
  char *__s;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (URLDownload::Class(void)::sOnce_URLDownload != -1)
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_4678);
  Instance = _CFRuntimeCreateInstance();
  v10 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    v10 = Instance + 16;
    *(_QWORD *)(Instance + 336) = 0;
    *(_OWORD *)(Instance + 304) = 0u;
    *(_OWORD *)(Instance + 320) = 0u;
    *(_OWORD *)(Instance + 272) = 0u;
    *(_OWORD *)(Instance + 288) = 0u;
    *(_OWORD *)(Instance + 240) = 0u;
    *(_OWORD *)(Instance + 256) = 0u;
    *(_OWORD *)(Instance + 208) = 0u;
    *(_OWORD *)(Instance + 224) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
  }
  *(_QWORD *)v10 = &off_1E14E54E0;
  *(_QWORD *)(v10 + 8) = &unk_1E14E5528;
  *(_QWORD *)(v10 + 160) = 0;
  *(_QWORD *)(v10 + 288) = CoreSchedulingSet::createEmpty((CoreSchedulingSet *)Instance);
  *(_DWORD *)(v10 + 304) = 0;
  *(_BYTE *)(v10 + 320) = 1;
  if (!a2 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(allocator) = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "CFURLDownloadCreateWithConnection(): Asked to create from a NULL connection!", (uint8_t *)&allocator, 2u);
    if (a3)
      goto LABEL_10;
  }
  else if (a3)
  {
    goto LABEL_10;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(allocator) = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "CFURLDownloadCreateWithConnection(): Asked to create with a NULL request!", (uint8_t *)&allocator, 2u);
  }
LABEL_10:
  if (!a4 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(allocator) = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "CFURLDownloadCreateWithConnection(): Asked to create with a NULL response!", (uint8_t *)&allocator, 2u);
  }
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_47);
  if (a2)
    v11 = a2 + 16;
  else
    v11 = 0;
  if (!(*(unsigned int (**)(char *))(*(_QWORD *)v11 + 152))(v11))
  {
    CFRelease((CFTypeRef)(v10 - 16));
    return 0;
  }
  URLDownload::_internal_setClient(v10, a5);
  URLDownload::_internal_setRequest((URLDownload *)v10, a3);
  URLDownload::_internal_setResponse((URLDownload *)v10, a4);
  if (*(_QWORD *)(-[_CFURLRequest _inner](a3, "_inner") + 32))
  {
    v12 = CFGetAllocator((CFTypeRef)(v10 - 16));
    URLPortion::URLPortion((URLPortion *)&allocator, v12, *(CFURLRef *)(-[_CFURLRequest _inner](a3, "_inner") + 32), 1);
    v13 = CFGetAllocator((CFTypeRef)(v10 - 16));
    v14 = strlen(__s);
    *(_QWORD *)(v10 + 224) = CFURLCreateWithBytes(v13, (const UInt8 *)__s, v14, 0x201u, 0);
    if (ptr != v31)
      CFAllocatorDeallocate(allocator, ptr);
    if (a2)
      goto LABEL_23;
  }
  else
  {
    *(_QWORD *)(v10 + 224) = 0;
    if (a2)
    {
LABEL_23:
      v15 = CFRetain(a2);
      goto LABEL_27;
    }
  }
  v15 = 0;
LABEL_27:
  *(_QWORD *)(v10 + 16) = v15;
  *(_BYTE *)(v10 + 281) = 1;
  *(_QWORD *)(v10 + 264) = 0;
  *(_BYTE *)(v10 + 284) = 0;
  allocator = (CFAllocatorRef)3;
  v31[0] = v10;
  v31[1] = DownloadConnectionClient::_implRetain;
  v31[2] = DownloadConnectionClient::_implRelease;
  v31[3] = DownloadConnectionClient::_copyDescription;
  v31[4] = DownloadConnectionClient::_willSendRequestCallback;
  v31[5] = DownloadConnectionClient::_didReceiveResponseCallback;
  v31[6] = DownloadConnectionClient::_didReceiveDataCallback;
  v31[7] = DownloadConnectionClient::_didStopBufferingDataCallback;
  v31[8] = DownloadConnectionClient::_connectionDidFinishLoadingCallback;
  v31[9] = DownloadConnectionClient::_didFailCallback;
  v31[10] = DownloadConnectionClient::_willCacheResponseCallback;
  v31[11] = DownloadConnectionClient::_didReceiveAuthenticationChallengeCallback;
  v31[12] = 0;
  v31[13] = DownloadConnectionClient::_shouldUseCredentialStorageCallback;
  v31[14] = 0;
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_47);
  (*(void (**)(char *, CFAllocatorRef *))(*(_QWORD *)v11 + 144))(v11, &allocator);
  if (!*(_BYTE *)(v10 + 282))
  {
    *(_BYTE *)(v10 + 282) = 1;
    CFRetain((CFTypeRef)(v10 - 16));
  }
  if (!*(_BYTE *)(v10 + 286))
  {
    *(_BYTE *)(v10 + 286) = 1;
    v25 = *(_QWORD *)(v10 + 168);
    if (v25)
    {
      v26 = *(void (**)(uint64_t, _QWORD))(v25 + 40);
      if (v26)
        v26(v10 - 16, *(_QWORD *)(v25 + 8));
    }
  }
  v17 = *(_QWORD *)(v10 + 168);
  if (!v17)
    return v10 - 16;
  v18 = *(uint64_t (**)(uint64_t, _QWORD, _CFURLResponse *, _QWORD))(v17 + 48);
  if (!v18)
    goto LABEL_48;
  v19 = (_CFURLRequest *)v18(v10 - 16, *(_QWORD *)(v10 + 24), a4, *(_QWORD *)(v17 + 8));
  v20 = v19;
  if (v19 == *(_CFURLRequest **)(v10 + 24))
  {
    if (v19)
      CFRelease(v19);
LABEL_48:
    v27 = *(_QWORD *)(v10 + 168);
    if (v27)
    {
      v28 = *(void (**)(uint64_t, _CFURLResponse *, _QWORD))(v27 + 64);
      if (v28)
        v28(v10 - 16, a4, *(_QWORD *)(v27 + 8));
    }
    return v10 - 16;
  }
  if (v19)
  {
    URLDownload::_internal_setRequest((URLDownload *)v10, v19);
    URLDownload::_internal_setResponse((URLDownload *)v10, 0);
    v21 = *(const void **)(v10 + 16);
    if (v21)
      CFRelease(v21);
    v29[0] = 3;
    v29[1] = v10;
    v29[2] = DownloadConnectionClient::_implRetain;
    v29[3] = DownloadConnectionClient::_implRelease;
    v29[4] = DownloadConnectionClient::_copyDescription;
    v29[5] = DownloadConnectionClient::_willSendRequestCallback;
    v29[6] = DownloadConnectionClient::_didReceiveResponseCallback;
    v29[7] = DownloadConnectionClient::_didReceiveDataCallback;
    v29[8] = DownloadConnectionClient::_didStopBufferingDataCallback;
    v29[9] = DownloadConnectionClient::_connectionDidFinishLoadingCallback;
    v29[10] = DownloadConnectionClient::_didFailCallback;
    v29[11] = DownloadConnectionClient::_willCacheResponseCallback;
    v29[12] = DownloadConnectionClient::_didReceiveAuthenticationChallengeCallback;
    v29[13] = 0;
    v29[14] = DownloadConnectionClient::_shouldUseCredentialStorageCallback;
    v29[15] = 0;
    v22 = CFGetAllocator((CFTypeRef)(v10 - 16));
    DownloadConnectionProperties = createDownloadConnectionProperties(v22);
    v24 = CFGetAllocator((CFTypeRef)(v10 - 16));
    *(_QWORD *)(v10 + 16) = CFURLConnectionCreateWithProperties((uint64_t)v24, *(void **)(v10 + 24), v29, DownloadConnectionProperties);
    if (DownloadConnectionProperties)
      CFRelease(DownloadConnectionProperties);
    if (!*(_BYTE *)(v10 + 282))
    {
      *(_BYTE *)(v10 + 282) = 1;
      CFRetain((CFTypeRef)(v10 - 16));
    }
    CFRelease(v20);
  }
  return v10 - 16;
}

void sub_18401B6B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,const __CFAllocator *allocator,uint64_t a26)
{
  if ((uint64_t *)STACK[0x288] != &a26)
    CFAllocatorDeallocate(allocator, (void *)STACK[0x288]);
  _Unwind_Resume(a1);
}

uint64_t CFURLDownloadCreateWithResumeData(CFAllocatorRef allocator, CFDataRef data, const void *a3, _QWORD *a4)
{
  const __CFDictionary *v8;
  uint64_t v9;
  uint8_t v11[16];
  uint8_t buf[8];
  CFErrorRef error;

  if (!data && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "CFURLDownloadCreateWithResumeData(): Asked to create from NULL resumeData!", buf, 2u);
    if (a3)
      goto LABEL_6;
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v11 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "CFURLDownloadCreateWithResumeData(): Asked to create from a NULL path!", v11, 2u);
  }
LABEL_6:
  error = 0;
  v8 = (const __CFDictionary *)CFPropertyListCreateWithData(allocator, data, 0, 0, &error);
  if (!v8 && error)
  {
    CFRelease(error);
    return 0;
  }
  if (!v8)
    return 0;
  v9 = CFURLDownloadCreateWithResumeInformation((uint64_t)allocator, v8, a3, a4);
  CFRelease(v8);
  return v9;
}

void CFURLDownloadSetDestination(uint64_t a1, CFURLRef url, int a3)
{
  uint64_t v6;
  const __CFURL *v7;
  const __CFAllocator *v8;
  CFStringRef v9;
  CFStringRef v10;
  const __CFURL *v11;
  CFStringRef v12;
  CFStringRef v13;
  const __CFURL *v14;
  const void *v15;
  CFStringRef PathComponent;
  const __CFURL *v17;
  uint64_t v18;
  const __CFString *v19;
  const __CFString *v20;
  BOOL v21;
  uint64_t v22;

  if (URLDownload::Class(void)::sOnce_URLDownload != -1)
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_4678);
  if (a1)
    v6 = a1 + 16;
  else
    v6 = 0;
  if (!*(_QWORD *)(v6 + 200))
  {
    if (a3 || !objectExistsAtURL(url))
    {
      if (url)
        v7 = (const __CFURL *)CFRetain(url);
      else
        v7 = 0;
LABEL_30:
      *(_QWORD *)(v6 + 200) = v7;
      *(_BYTE *)(v6 + 283) = a3;
      return;
    }
    v8 = CFGetAllocator(url);
    v9 = CFURLCopyPathExtension(url);
    if (!v9)
    {
      v14 = (const __CFURL *)CFRetain(url);
      v15 = 0;
LABEL_18:
      PathComponent = CFURLCopyLastPathComponent(v14);
      if (v14)
        CFRelease(v14);
      v17 = CFURLCreateCopyDeletingLastPathComponent(v8, url);
      v18 = 1;
      while (1)
      {
        v19 = v15
            ? CFStringCreateWithFormat(v8, 0, CFSTR("%@-%d.%@"), PathComponent, v18, v15)
            : CFStringCreateWithFormat(v8, 0, CFSTR("%@-%d"), PathComponent, v18, v22);
        v20 = v19;
        v7 = CFURLCreateCopyAppendingPathComponent(v8, v17, v19, 0);
        CFRelease(v20);
        if (!objectExistsAtURL(v7))
          break;
        CFRelease(v7);
        v21 = __CFADD__((_DWORD)v18, 1);
        v18 = (v18 + 1);
        if (v21)
        {
          v7 = 0;
          break;
        }
      }
      CFRelease(PathComponent);
      CFRelease(v17);
      if (v15)
        CFRelease(v15);
      goto LABEL_30;
    }
    v10 = v9;
    v11 = CFURLCreateCopyDeletingPathExtension(v8, url);
    v12 = CFURLCopyPathExtension(v11);
    if (v12)
    {
      v13 = v12;
      v14 = CFURLCreateCopyDeletingPathExtension(v8, v11);
      v15 = CFStringCreateWithFormat(v8, 0, CFSTR("%@.%@"), v13, v10);
      CFRelease(v13);
      if (!v11)
      {
LABEL_15:
        CFRelease(v10);
        goto LABEL_18;
      }
    }
    else
    {
      v15 = CFRetain(v10);
      v14 = (const __CFURL *)CFRetain(v11);
      if (!v11)
        goto LABEL_15;
    }
    CFRelease(v11);
    goto LABEL_15;
  }
}

void CFURLDownloadSetDeletesUponFailure(uint64_t a1, char a2)
{
  uint64_t v4;

  if (URLDownload::Class(void)::sOnce_URLDownload != -1)
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_4678);
  v4 = a1 + 16;
  if (!a1)
    v4 = 0;
  *(_BYTE *)(v4 + 281) = a2;
}

uint64_t CFURLDownloadDeletesUponFailure(uint64_t a1)
{
  uint64_t v2;

  if (URLDownload::Class(void)::sOnce_URLDownload != -1)
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_4678);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  return *(unsigned __int8 *)(v2 + 281);
}

CFDictionaryRef CFURLDownloadCopyResumeData(char *a1)
{
  const __CFAllocator *v2;
  URLDownload *v3;
  CFDictionaryRef result;
  CFDictionaryRef v5;
  CFDataRef Data;

  v2 = CFGetAllocator(a1);
  if (URLDownload::Class(void)::sOnce_URLDownload != -1)
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_4678);
  if (a1)
    v3 = (URLDownload *)(a1 + 16);
  else
    v3 = 0;
  result = URLDownload::createResumeInformation(v3, v2);
  if (result)
  {
    v5 = result;
    Data = CFPropertyListCreateData(v2, result, kCFPropertyListXMLFormat_v1_0, 0, 0);
    CFRelease(v5);
    return Data;
  }
  return result;
}

uint64_t CFURLDownloadScheduleWithRunLoop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t result;

  if (URLDownload::Class(void)::sOnce_URLDownload != -1)
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_4678);
  if (a1)
    v6 = a1 + 16;
  else
    v6 = 0;
  CFURLConnectionScheduleWithRunLoop(*(_QWORD *)(v6 + 16), a2, a3);
  result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v6 + 288) + 56))(*(_QWORD *)(v6 + 288), a2, a3);
  *(_QWORD *)(v6 + 288) = result;
  return result;
}

void CFURLDownloadStart(uint64_t a1)
{
  uint64_t v2;

  if (URLDownload::Class(void)::sOnce_URLDownload != -1)
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_4678);
  if (a1)
    v2 = a1 + 16;
  else
    v2 = 0;
  if (!*(_BYTE *)(v2 + 282))
  {
    *(_BYTE *)(v2 + 282) = 1;
    CFRetain((CFTypeRef)(v2 - 16));
  }
  CFURLConnectionStart(*(_QWORD *)(v2 + 16));
}

void CFURLDownloadCancel(uint64_t a1)
{
  URLDownload *v2;

  if (URLDownload::Class(void)::sOnce_URLDownload != -1)
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_4678);
  if (a1)
    v2 = (URLDownload *)(a1 + 16);
  else
    v2 = 0;
  URLDownload::_internal_downloadCancel(v2, 0);
}

void sub_18401C358(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void AutoScalar::~AutoScalar(AutoScalar *this)
{
  const void *v1;

  *(_QWORD *)this = &off_1E14E47E8;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
}

{
  const void *v1;

  *(_QWORD *)this = &off_1E14E47E8;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t AutoScalar::getRef(AutoScalar *this)
{
  return *((_QWORD *)this + 1);
}

uint64_t AutoScalar::isEmpty(AutoScalar *this)
{
  return 0;
}

void HTTPServerService_NW::ensureServerExists(uint64_t a1, NSObject *a2)
{
  void *v4;
  const __CFAllocator *v5;
  char *v6;
  __int16 v7;
  _QWORD *v8;
  nw_listener_t *v9;
  const void *v10;
  _QWORD *v11;
  CFTypeRef v12;
  HTTPServer *v13;
  const __CFArray *v14;
  const __CFArray *v15;
  CFIndex Count;
  AutoArray *ValueAtIndex;
  __SecIdentity *v18;
  const __CFArray *EmptyArray;
  sec_identity_t v20;
  __CFArray *MutableCopy;
  uint64_t v22;
  _QWORD *v23;
  NSObject *secure_tcp;
  void *v25;
  void *v26;
  NSObject *v27;
  NSObject *v28;
  void *v29;
  __CFString *Copy;
  NSObject *v31;
  NSObject *v32;
  _QWORD v33[5];
  _QWORD handler[5];
  _QWORD v35[2];
  void (*v36)(uint64_t, void *, void *, void *);
  void *v37;
  _QWORD *v38;
  _QWORD v39[6];
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  void (*v43)(uint64_t, uint64_t);
  void (*v44)(uint64_t);
  sec_identity_t v45;
  char __str[32];
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 88));
  if (*(_QWORD *)(a1 + 328))
  {
    if (a2)
      dispatch_semaphore_signal(a2);
    return;
  }
  if (a2)
  {
    v4 = *(void **)(a1 + 336);
    if (!v4)
    {
      v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", 0);
      *(_QWORD *)(a1 + 336) = v4;
    }
    objc_msgSend(v4, "addObject:", a2);
  }
  if (!*(_BYTE *)(a1 + 345))
  {
    *(_BYTE *)(a1 + 345) = 1;
    v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v6 = (char *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 72, 0);
    *((_OWORD *)v6 + 2) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *((_QWORD *)v6 + 8) = 0;
    *(_OWORD *)v6 = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    v7 = *(_WORD *)(a1 + 296);
    *(_QWORD *)v6 = off_1E14EF578;
    *((_QWORD *)v6 + 1) = v5;
    *((_DWORD *)v6 + 4) = 1;
    if (((unint64_t)(v6 + 16) & 3) != 0)
      __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
    v8 = v6;
    *(_QWORD *)v6 = off_1E14EFD88;
    *((_QWORD *)v6 + 4) = 0;
    v9 = (nw_listener_t *)(v6 + 32);
    *((_QWORD *)v6 + 3) = &unk_1E14EFDE0;
    *((_QWORD *)v6 + 5) = 0;
    *((_WORD *)v6 + 24) = 0;
    *((_QWORD *)v6 + 7) = 0;
    *((_QWORD *)v6 + 8) = a1;
    CFRetain((CFTypeRef)(a1 - 16));
    *((_WORD *)v8 + 24) = v7;
    v8[7] = 0;
    v10 = (const void *)(*(uint64_t (**)(_QWORD *, uint64_t))(*v8 + 64))(v8, 0x1EDCFF500);
    if (v10)
    {
      v11 = (_QWORD *)operator new();
      *v11 = &off_1E14E80B0;
      v12 = CFRetain(v10);
      *v11 = &off_1E14EBE00;
      v11[1] = v12;
      v8[7] = v11;
    }
    snprintf(__str, 0x20uLL, "%u", *((unsigned __int16 *)v8 + 24));
    v40 = 0;
    v41 = &v40;
    v42 = 0x3052000000;
    v43 = __Block_byref_object_copy__3151;
    v44 = __Block_byref_object_dispose__3152;
    v45 = 0;
    v13 = (HTTPServer *)v8[8];
    if (v13 && (v14 = (const __CFArray *)HTTPServer::copyServerTrustChain(v13), (v15 = v14) != 0))
    {
      Count = CFArrayGetCount(v14);
      if (Count)
      {
        ValueAtIndex = (AutoArray *)CFArrayGetValueAtIndex(v15, 0);
        v18 = ValueAtIndex;
        if (Count == 1)
        {
          EmptyArray = (const __CFArray *)AutoArray::getEmptyArray(ValueAtIndex);
          v20 = sec_identity_create_with_certificates(v18, EmptyArray);
        }
        else
        {
          MutableCopy = CFArrayCreateMutableCopy(v5, Count, v15);
          CFArrayRemoveValueAtIndex(MutableCopy, 0);
          v20 = sec_identity_create_with_certificates(v18, MutableCopy);
          if (MutableCopy)
            CFRelease(MutableCopy);
        }
      }
      else
      {
        v20 = 0;
      }
      CFRelease(v15);
    }
    else
    {
      v20 = 0;
    }
    v45 = v20;
    v22 = MEMORY[0x1E0C809B0];
    if (v41[5])
    {
      v39[0] = MEMORY[0x1E0C809B0];
      v39[1] = 3221225472;
      v39[2] = ___ZN8Listener5startEv_block_invoke;
      v39[3] = &unk_1E14F76D8;
      v39[4] = &v40;
      v39[5] = v8;
      v23 = v39;
    }
    else
    {
      v23 = (_QWORD *)*MEMORY[0x1E0CCED20];
    }
    secure_tcp = nw_parameters_create_secure_tcp(v23, (nw_parameters_configure_protocol_block_t)*MEMORY[0x1E0CCED18]);
    v25 = (void *)(*(uint64_t (**)(_QWORD *, uint64_t))(*v8 + 64))(v8, 0x1EDCFF0A0);
    v26 = v25;
    if (v25)
    {
      if (CFEqual(v25, CFSTR("all")))
      {
        nw_parameters_set_use_awdl();
      }
      else
      {
        objc_msgSend(v26, "UTF8String");
        v27 = nw_interface_create_with_name();
        if (v27)
        {
          nw_parameters_require_interface(secure_tcp, v27);
          CFRelease(v27);
        }
      }
    }
    if ((*(uint64_t (**)(_QWORD *, uint64_t))(*v8 + 64))(v8, 0x1EDCFF458) == *MEMORY[0x1E0C9AE50])
      nw_parameters_set_reuse_local_address(secure_tcp, 1);
    v28 = nw_listener_create_with_port(__str, secure_tcp);
    v8[4] = v28;
    nw_listener_set_queue(v28, *(dispatch_queue_t *)(v8[8] + 88));
    if (secure_tcp)
      CFRelease(secure_tcp);
    v35[0] = v22;
    v35[1] = 3221225472;
    v36 = ___ZN8Listener5startEv_block_invoke_2;
    v37 = &__block_descriptor_40_e44_v32__0__NSString_8__NSString_16__NSString_24l;
    v38 = v8;
    v29 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)v8[8] + 64))(v8[8], 0x1EDCFF4C8);
    if (!v29)
      goto LABEL_41;
    Copy = (__CFString *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)v8[8] + 64))(v8[8], 0x1EDCFF228);
    if (Copy)
    {
      ___ZN8Listener5startEv_block_invoke_2((uint64_t)v35, v29, Copy, &stru_1E1500C68);
    }
    else
    {
      Copy = (__CFString *)CFStringCreateCopy(v5, &stru_1E1500C68);
      v36((uint64_t)v35, v29, Copy, &stru_1E1500C68);
      if (!Copy)
      {
LABEL_40:
        CFRelease(v29);
LABEL_41:
        (*(void (**)(_QWORD *))(*v8 + 40))(v8);
        v31 = v8[4];
        handler[0] = v22;
        handler[1] = 3221225472;
        handler[2] = ___ZN8Listener5startEv_block_invoke_3;
        handler[3] = &__block_descriptor_40_e34_v20__0i8__NSObject_OS_nw_error__12l;
        handler[4] = v8;
        nw_listener_set_state_changed_handler(v31, handler);
        v32 = v8[4];
        v33[0] = v22;
        v33[1] = 3221225472;
        v33[2] = ___ZN8Listener5startEv_block_invoke_4;
        v33[3] = &__block_descriptor_40_e36_v16__0__NSObject_OS_nw_connection__8l;
        v33[4] = v8;
        nw_listener_set_new_connection_handler(v32, v33);
        nw_listener_start(*v9);
        _Block_object_dispose(&v40, 8);
        (*(void (**)(_QWORD *))(*v8 + 48))(v8);
        return;
      }
    }
    CFRelease(Copy);
    goto LABEL_40;
  }
}

void sub_18401D334(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x186DB748C](v2, 0xE1C40D30581F4);
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void HTTPServerService_NW::scheduled_onQueue(HTTPServerService_NW *this)
{
  if (!*((_BYTE *)this + 344) && !*((_QWORD *)this + 41))
    (*(void (**)(HTTPServerService_NW *, _QWORD))(*(_QWORD *)this + 80))(this, 0);
  HTTPServerService::scheduled_onQueue(this);
}

void HTTPServerService_NW::canceled_onQueue(HTTPServerService_NW *this)
{
  Listener *v2;

  if (!*((_BYTE *)this + 344))
  {
    *((_BYTE *)this + 344) = 1;
    v2 = (Listener *)*((_QWORD *)this + 41);
    if (v2)
      Listener::_onqueue_invalidate(v2);
  }
  *((_BYTE *)this + 313) = 0;
}

uint64_t HTTPServerService_NW::setupTLSOnStreams(HTTPServerService_NW *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  return 1;
}

uint64_t HTTPServerService_NW::getPort(HTTPServerService_NW *this)
{
  uint64_t v1;
  unsigned __int16 *v2;

  v1 = *((_QWORD *)this + 41);
  if (v1)
    v2 = (unsigned __int16 *)(v1 + 48);
  else
    v2 = (unsigned __int16 *)((char *)this + 296);
  return *v2;
}

uint64_t HTTPServerService_NW::createServerInstance(HTTPServerService_NW *this)
{
  return 0;
}

void HTTPServerService_NW::errorHandler_onQueue(HTTPServerService_NW *this, __CFError *a2)
{
  HTTPServerBase::becomeErrored_onQueue((HTTPServerService_NW *)((char *)this + 8), a2);
}

void `non-virtual thunk to'HTTPServerService_NW::~HTTPServerService_NW(HTTPServerService_NW *this)
{
  HTTPServerService_NW::~HTTPServerService_NW((HTTPServerService_NW *)((char *)this - 8));
}

{
  HTTPServerService_NW::~HTTPServerService_NW((HTTPServerService_NW *)((char *)this - 8));
}

{
  HTTPServerService_NW::~HTTPServerService_NW((HTTPServerService_NW *)((char *)this - 56));
}

{
  HTTPServerService_NW::~HTTPServerService_NW((HTTPServerService_NW *)((char *)this - 56));
}

void `non-virtual thunk to'HTTPServerService_NW::scheduled_onQueue(HTTPServerService_NW *this)
{
  HTTPServerService_NW::scheduled_onQueue((HTTPServerService_NW *)((char *)this - 8));
}

void `non-virtual thunk to'HTTPServerService_NW::canceled_onQueue(HTTPServerService_NW *this)
{
  Listener *v2;

  if (!*((_BYTE *)this + 336))
  {
    *((_BYTE *)this + 336) = 1;
    v2 = (Listener *)*((_QWORD *)this + 40);
    if (v2)
      Listener::_onqueue_invalidate(v2);
  }
  *((_BYTE *)this + 305) = 0;
}

void HTTPServerService_NW::~HTTPServerService_NW(HTTPServerService_NW *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E14EB668;
  *((_QWORD *)this + 1) = &unk_1E14EB728;
  *((_QWORD *)this + 7) = &unk_1E14EB790;
  v2 = *((_QWORD *)this + 41);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    *((_QWORD *)this + 41) = 0;
  }
  HTTPServerService::~HTTPServerService(this);
}

void sub_18401D4F4(_Unwind_Exception *a1)
{
  HTTPServerService *v1;

  HTTPServerService::~HTTPServerService(v1);
  _Unwind_Resume(a1);
}

void Listener::_onqueue_invalidate(Listener *this)
{
  NSObject *v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 4) = 0;
    nw_listener_cancel(v2);
    CFRelease(v2);
  }
  else
  {
    v3 = *((_QWORD *)this + 8);
    if (v3)
    {
      CFRelease((CFTypeRef)(v3 - 16));
      *((_QWORD *)this + 8) = 0;
    }
  }
}

void __Block_byref_object_copy__3151(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__3152(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void ___ZN8Listener5startEv_block_invoke(uint64_t a1, NSObject *a2)
{
  uint64_t v4;
  NSObject *v5;
  _BOOL4 v6;
  const void **v7;
  int v8;
  _BOOL4 v9;
  _BOOL4 v10;
  const void *v11;
  _DWORD v12[2];
  __int16 v13;
  _BOOL4 v14;
  __int16 v15;
  _BOOL4 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 40);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v5 = CFNLog::logger;
  v6 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT);
  v7 = (const void **)MEMORY[0x1E0C9AE50];
  if (v6)
  {
    v8 = *(unsigned __int16 *)(v4 + 48);
    v9 = CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(v4 + 56) + 8), CFSTR("kCFHTTPServerRequireClientCertificate")) != 0;
    v10 = CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(v4 + 56) + 8), CFSTR("kCFHTTPServerRequireClientCertificate")) == *v7;
    v12[0] = 67109632;
    v12[1] = v8;
    v13 = 1024;
    v14 = v9;
    v15 = 1024;
    v16 = v10;
    _os_log_impl(&dword_183ECA000, v5, OS_LOG_TYPE_DEFAULT, "CFHTTPServer configuring TLS {port=%u, wants_client_cert=%{BOOL}d, requires_client_cert=%{BOOL}d}", (uint8_t *)v12, 0x14u);
  }
  sec_protocol_options_set_local_identity(a2, *(sec_identity_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40));
  v11 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  if (v11)
    CFRelease(v11);
  sec_protocol_options_set_verify_block(a2, &__block_literal_global_3162, *(dispatch_queue_t *)(*(_QWORD *)(v4 + 64) + 88));
  if (CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(v4 + 56) + 8), CFSTR("kCFHTTPServerRequireClientCertificate")))
  {
    if (CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(v4 + 56) + 8), CFSTR("kCFHTTPServerRequireClientCertificate")) == *v7)sec_protocol_options_set_peer_authentication_required(a2, 1);
    else
      sec_protocol_options_set_peer_authentication_optional(a2, 1);
  }
}

void ___ZN8Listener5startEv_block_invoke_2(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v4;
  NSObject *bonjour_service;
  NSObject *v6;

  v4 = *(_QWORD *)(a1 + 32);
  bonjour_service = nw_advertise_descriptor_create_bonjour_service((const char *)objc_msgSend(a3, "UTF8String"), (const char *)objc_msgSend(a2, "UTF8String"), (const char *)objc_msgSend(a4, "UTF8String"));
  if (bonjour_service)
  {
    v6 = bonjour_service;
    nw_listener_set_advertise_descriptor(*(nw_listener_t *)(v4 + 32), bonjour_service);
    CFRelease(v6);
  }
}

uint64_t ___ZN8Listener5startEv_block_invoke_3(uint64_t result, int a2, nw_error_t error)
{
  uint64_t v5;
  uint64_t v6;
  void *v7;
  CFErrorRef v8;
  CFErrorRef v9;
  uint64_t v10;
  const void *v11;
  NSObject *v12;

  if (a2 != 1)
  {
    v5 = *(_QWORD *)(result + 32);
    v6 = *(_QWORD *)(v5 + 64);
    if (v6 && !*(_QWORD *)(v6 + 328))
    {
      *(_QWORD *)(v6 + 328) = v5;
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
      v7 = *(void **)(v6 + 336);
      if (v7)
      {
        *(_QWORD *)(v6 + 336) = 0;
        objc_msgSend(v7, "enumerateObjectsUsingBlock:", &__block_literal_global_10_3157);
        CFRelease(v7);
      }
      if (*(_BYTE *)(v6 + 344))
        Listener::_onqueue_invalidate(*(Listener **)(v6 + 328));
    }
    if (a2 == 2)
    {
      result = *(_QWORD *)(v5 + 32);
      if (result)
      {
        result = nw_listener_get_port((nw_listener_t)result);
        *(_WORD *)(v5 + 48) = result;
      }
    }
    else
    {
      if (error)
        v8 = nw_error_copy_cf_error(error);
      else
        v8 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFErrorDomain)*MEMORY[0x1E0C9AFD0], 22, 0);
      v9 = v8;
      v10 = *(_QWORD *)(v5 + 64);
      if (v10)
      {
        *(_QWORD *)(v5 + 64) = 0;
        v11 = (const void *)(v10 - 16);
        (*(void (**)(uint64_t, CFErrorRef))(*(_QWORD *)v10 + 168))(v10, v9);
        CFRelease(v11);
      }
      CFRelease(v9);
      v12 = *(NSObject **)(v5 + 32);
      if (v12)
      {
        nw_listener_set_state_changed_handler(v12, 0);
        nw_listener_set_new_connection_handler(*(nw_listener_t *)(v5 + 32), 0);
      }
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
    }
  }
  return result;
}

void ___ZN8Listener5startEv_block_invoke_4(uint64_t a1, nw_connection_t connection)
{
  _QWORD *v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD handler[9];
  _QWORD v8[3];
  char v9;

  v3 = *(_QWORD **)(a1 + 32);
  if (v3[4])
  {
    v4 = dispatch_queue_create("com.apple.cfnetwork.httpserver-connection-queue", 0);
    nw_connection_set_queue(connection, v4);
    v5 = v3[8];
    v6 = *(_QWORD *)(v5 + 88);
    if (v6)
      CFRetain(*(CFTypeRef *)(v5 + 88));
    v8[0] = 0;
    v8[1] = v8;
    v8[2] = 0x2020000000;
    v9 = 0;
    (*(void (**)(_QWORD *))(*v3 + 40))(v3);
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 3221225472;
    handler[2] = ___ZN8Listener13newConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke;
    handler[3] = &unk_1E14F7670;
    handler[7] = v8;
    handler[8] = v3;
    handler[4] = connection;
    handler[5] = v4;
    handler[6] = v6;
    nw_connection_set_state_changed_handler(connection, handler);
    dispatch_release(v4);
    nw_connection_start(connection);
    _Block_object_dispose(v8, 8);
  }
  else
  {
    nw_connection_cancel(connection);
  }
}

void sub_18401DA38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN8Listener13newConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  const void *v7;
  const void *v8;
  uint64_t v9;
  NSObject *v10;
  _QWORD block[13];

  if ((a2 - 3) <= 2)
  {
    block[11] = v2;
    block[12] = v3;
    v4 = result;
    if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 56) + 8) + 24))
    {
      v5 = *(_QWORD *)(result + 64);
      v6 = 6u >> ((a2 - 3) & 7);
      nw_connection_set_state_changed_handler(*(nw_connection_t *)(result + 32), 0);
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 56) + 8) + 24) = 1;
      if ((v6 & 1) != 0)
      {
        nw_connection_cancel(*(nw_connection_t *)(v4 + 32));
      }
      else
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
        v7 = *(const void **)(v4 + 32);
        if (v7)
          CFRetain(v7);
        v8 = *(const void **)(v4 + 40);
        if (v8)
        {
          CFRetain(v8);
          v9 = *(_QWORD *)(v4 + 40);
        }
        else
        {
          v9 = 0;
        }
        v10 = *(NSObject **)(v4 + 48);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3221225472;
        block[2] = ___ZN8Listener13newConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_2;
        block[3] = &unk_1E14FD950;
        block[5] = v9;
        block[6] = v5;
        block[4] = *(_QWORD *)(v4 + 32);
        dispatch_async(v10, block);
      }
      dispatch_release(*(dispatch_object_t *)(v4 + 48));
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
    }
  }
  return result;
}

uint64_t ___ZN8Listener13newConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  const void *v5;
  NWStreamPair *v6;
  _QWORD *v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  CFAllocatorRef *v11;
  NSObject *v12;
  const sockaddr *address;
  uint64_t v14;
  uint64_t v15;
  CFMutableArrayRef Mutable;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  const void *v21;
  __CFReadStream *v22;
  uint64_t v23;
  const void *v24;
  __CFWriteStream *v25;
  objc_super v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint8_t buf[8];
  uint64_t v33;
  void *v34;
  CFStringRef (*v35)(uint64_t, uint64_t);
  _QWORD *v36;
  BOOL (*v37)(uint64_t, uint64_t *, uint64_t);
  void *v38;
  uint64_t (*v39)(uint64_t, uint64_t, uint64_t);
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void (*v44)(uint64_t, uint64_t, uint64_t);
  uint64_t (*v45)();
  uint64_t (*v46)();

  v2 = *(_QWORD *)(a1 + 48);
  v3 = *(NSObject **)(a1 + 32);
  if (!*(_QWORD *)(v2 + 32))
    goto LABEL_25;
  v4 = *(_QWORD *)(v2 + 64);
  if (!v4)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "if we have an _nwListener, we should have a _server", buf, 2u);
    }
    goto LABEL_25;
  }
  v5 = *(const void **)(a1 + 40);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v4 + 88));
  v6 = [NWStreamPair alloc];
  if (!v6)
    goto LABEL_25;
  v27.receiver = v6;
  v27.super_class = (Class)NWStreamPair;
  v7 = objc_msgSendSuper2(&v27, sel_initWithLoggableName_, "nwstream");
  if (!v7)
    goto LABEL_25;
  v8 = (uint64_t)v7;
  v7[2] = v3;
  if (v3)
  {
    CFRetain(v3);
    v9 = *(NSObject **)(v8 + 16);
  }
  else
  {
    v9 = 0;
  }
  v10 = nw_connection_copy_endpoint(v9);
  v11 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (v10)
  {
    v12 = v10;
    address = nw_endpoint_get_address(v10);
    *(_QWORD *)(v8 + 88) = CFDataCreate(*v11, &address->sa_len, address->sa_len);
    CFRelease(v12);
  }
  v28 = 0;
  v29 = &v28;
  v30 = 0x2020000000;
  v14 = MEMORY[0x1E0C809B0];
  v31 = 0;
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  v33 = 3221225472;
  v34 = __39__NWStreamPair_copyConnectionPeerTrust__block_invoke;
  v35 = (CFStringRef (*)(uint64_t, uint64_t))&unk_1E14FBBE8;
  v36 = &v28;
  -[NWStreamPair withTLSMetadata:](v8, (uint64_t)buf);
  v15 = v29[3];
  _Block_object_dispose(&v28, 8);
  *(_QWORD *)(v8 + 96) = v15;
  Mutable = CFArrayCreateMutable(*v11, 0, MEMORY[0x1E0C9B378]);
  *(_QWORD *)buf = v14;
  v33 = 3221225472;
  v34 = __39__NWStreamPair_copyConnectionPeerCerts__block_invoke;
  v35 = (CFStringRef (*)(uint64_t, uint64_t))&__block_descriptor_40_e44_v16__0__NSObject_OS_sec_protocol_metadata__8l;
  v36 = Mutable;
  -[NWStreamPair withTLSMetadata:](v8, (uint64_t)buf);
  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    Mutable = 0;
  }
  *(_QWORD *)(v8 + 104) = Mutable;
  *(_QWORD *)(v8 + 24) = 0;
  *(_QWORD *)(v8 + 32) = 0;
  *(_QWORD *)(v8 + 56) = 0;
  v17 = operator new();
  *(_QWORD *)v17 = &off_1E14E4BC8;
  *(_QWORD *)(v17 + 8) = 0xFFFFLL;
  *(_QWORD *)(v17 + 16) = 0;
  *(_QWORD *)(v17 + 24) = 0;
  *(_BYTE *)(v17 + 32) = 0;
  *(_QWORD *)(v8 + 72) = v17;
  *(_BYTE *)(v8 + 80) = 0;
  *(_QWORD *)(v8 + 40) = v5;
  if (v5)
    CFRetain(v5);
  v18 = (_QWORD *)operator new();
  *v18 = off_1E14E52C8;
  v18[1] = (id)v8;
  v18[2] = "read";
  v18[4] = 0;
  v18[5] = 0;
  *v18 = &off_1E14EB9D0;
  *(_QWORD *)(v8 + 24) = v18;
  v19 = (_QWORD *)operator new();
  *v19 = off_1E14E52C8;
  v19[1] = (id)v8;
  v19[2] = "write";
  *v19 = &off_1E14EC1C8;
  v19[5] = 0;
  v19[6] = 0;
  v19[4] = 0;
  *(_QWORD *)(v8 + 32) = v19;
  v20 = *(_QWORD *)(v8 + 24);
  *(_QWORD *)buf = 2;
  v33 = (uint64_t)PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,void *)#1}::__invoke;
  v34 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,void *)#2}::__invoke;
  v35 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,void *)#3}::__invoke;
  v36 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFError **,unsigned char *,void *)#1}::__invoke;
  v37 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFError **,void *)#1}::__invoke;
  v42 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFString const*,void *)#1}::__invoke;
  v43 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFString const*,void const*,void *)#1}::__invoke;
  v44 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,unsigned long,void *)#1}::__invoke;
  v45 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFRunLoop *,__CFString const*,void *)#1}::__invoke;
  v46 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFRunLoop *,__CFString const*,void *)#2}::__invoke;
  v38 = PerSide_CFReadStream::fillinCB(CFReadStreamCallBacks *)::{lambda(__CFReadStream *,unsigned char *,long,__CFError **,unsigned char *,void *)#1}::__invoke;
  v39 = 0;
  v40 = PerSide_CFReadStream::fillinCB(CFReadStreamCallBacks *)::{lambda(__CFReadStream *,__CFError **,void *)#1}::__invoke;
  v41 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,void *)#4}::__invoke;
  v21 = (const void *)CFReadStreamCreate();
  *(_QWORD *)(v20 + 24) = v21;
  v22 = v21 ? (__CFReadStream *)CFRetain(v21) : 0;
  v23 = *(_QWORD *)(v8 + 32);
  *(_QWORD *)buf = 2;
  v33 = (uint64_t)PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,void *)#1}::__invoke;
  v34 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,void *)#2}::__invoke;
  v35 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,void *)#3}::__invoke;
  v36 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFError **,unsigned char *,void *)#1}::__invoke;
  v37 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFError **,void *)#1}::__invoke;
  v40 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,void *)#4}::__invoke;
  v41 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFString const*,void *)#1}::__invoke;
  v42 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFString const*,void const*,void *)#1}::__invoke;
  v43 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,unsigned long,void *)#1}::__invoke;
  v44 = (void (*)(uint64_t, uint64_t, uint64_t))PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFRunLoop *,__CFString const*,void *)#1}::__invoke;
  v45 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFRunLoop *,__CFString const*,void *)#2}::__invoke;
  v38 = PerSide_CFWriteStream::fillinCB(CFWriteStreamCallBacks *)::{lambda(__CFWriteStream *,unsigned char const*,long,__CFError **,void *)#1}::__invoke;
  v39 = PerSide_CFWriteStream::fillinCB(CFWriteStreamCallBacks *)::{lambda(__CFWriteStream *,__CFError **,void *)#1}::__invoke;
  v24 = (const void *)CFWriteStreamCreate();
  *(_QWORD *)(v23 + 24) = v24;
  v25 = v24 ? (__CFWriteStream *)CFRetain(v24) : 0;

  if (!v22 || !v25)
  {
LABEL_25:
    nw_connection_cancel(v3);
    goto LABEL_26;
  }
  HTTPServer::newConnectionWithStreams(*(NSObject ***)(v2 + 64), v22, v25);
  CFRelease(v25);
  CFRelease(v22);
LABEL_26:
  nw_release(*(void **)(a1 + 32));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

void sub_18401E07C(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  MEMORY[0x186DB748C](v1, 0x10F1C40C157D38ELL);
  _Unwind_Resume(a1);
}

intptr_t ___ZN20HTTPServerService_NW15listenerStartedEP8Listener_block_invoke(int a1, dispatch_semaphore_t dsema)
{
  return dispatch_semaphore_signal(dsema);
}

uint64_t ___ZN8Listener5startEv_block_invoke_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))(a4, 1);
}

void HTTPServerSSLSettings::~HTTPServerSSLSettings(HTTPServerSSLSettings *this)
{
  const void *v1;

  *(_QWORD *)this = &off_1E14E80B0;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
}

{
  const void *v1;

  *(_QWORD *)this = &off_1E14E80B0;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x186DB748CLL);
}

void Listener::~Listener(Listener *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E14EFD88;
  *((_QWORD *)this + 3) = &unk_1E14EFDE0;
  v2 = *((_QWORD *)this + 7);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E14EFD88;
  *((_QWORD *)this + 3) = &unk_1E14EFDE0;
  v2 = *((_QWORD *)this + 7);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *((_QWORD *)this + 3) = &off_1E14E5838;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

uint64_t Listener::operator CoreLoggable *(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 64);
  if (v1)
    return v1 + 56;
  else
    return 0;
}

const void *Listener::_getProperty(Listener *this, const __CFString *a2)
{
  uint64_t v2;
  const void *v3;
  const void *v4;

  v2 = *((_QWORD *)this + 8);
  if (!v2)
    return 0;
  v3 = (const void *)(*(uint64_t (**)(uint64_t, const __CFString *))(*(_QWORD *)v2 + 64))(v2, a2);
  v4 = v3;
  if (v3)
    CFAutorelease(v3);
  return v4;
}

void `non-virtual thunk to'Listener::~Listener(Listener *this)
{
  uint64_t v2;

  *((_QWORD *)this - 3) = off_1E14EFD88;
  *(_QWORD *)this = &unk_1E14EFDE0;
  v2 = *((_QWORD *)this + 4);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *(_QWORD *)this = &off_1E14E5838;
}

{
  char *v2;
  uint64_t v3;

  *((_QWORD *)this - 3) = off_1E14EFD88;
  v2 = (char *)this - 24;
  *(_QWORD *)this = &unk_1E14EFDE0;
  v3 = *((_QWORD *)this + 4);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  *(_QWORD *)this = &off_1E14E5838;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this - 2), v2);
}

void CoreWriteStreamClient::coreStreamEventsAvailable(CoreWriteStreamClient *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = a2;
  if (*((_QWORD *)this + 1) && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
  {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    if (!v2)
      return;
  }
  else if (!a2)
  {
    return;
  }
  v4 = 1;
  do
  {
    if ((v4 & ~v2) == 0)
    {
      (*(void (**)(CoreWriteStreamClient *, _QWORD, uint64_t))(*(_QWORD *)this + 56))(this, *((_QWORD *)this + 1), v4);
      v2 &= ~v4;
    }
    v4 *= 2;
  }
  while (v2);
}

uint64_t CoreStreamClient::coreStreamClientCopyCFStreamRef(CoreStreamClient *this)
{
  return 0;
}

void ___ZN15CoreWriteStream5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CoreWriteStream");
  CoreWriteStream::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_18401E410(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

CFWriteStreamRef CoreWriteStreamFromCFWriteStream::streamSetClient(CFWriteStreamRef *this, CFOptionFlags a2, CoreStreamClient *a3)
{
  CFWriteStreamRef result;
  CFStreamClientContext clientContext;

  if (a3)
  {
    clientContext.version = 0;
    clientContext.info = this;
    clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
    clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
    clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
    CFWriteStreamSetClient(this[16], a2, (CFWriteStreamClientCallBack)CoreWriteStreamFromCFWriteStream::_writeStreamClientCallBack, &clientContext);
    return (CFWriteStreamRef)CoreStreamBase::streamSetClient((uint64_t)this, a2, a3);
  }
  else
  {
    CFWriteStreamSetClient(this[16], 0, 0, 0);
    result = this[2];
    this[2] = 0;
    if (result)
      return (CFWriteStreamRef)(*(uint64_t (**)(CFWriteStreamRef))(*(_QWORD *)result + 24))(result);
  }
  return result;
}

CFIndex CoreWriteStreamFromCFWriteStream::_streamImpl_Write(CFWriteStreamRef *this, const unsigned __int8 *a2, CFIndex a3, CFStreamError *a4)
{
  CFIndex v6;
  __CFWriteStream *v7;
  __CFError *v8;
  __CFError *v9;
  CFIndex v10;
  uint64_t v11;
  uint64_t v12;

  if (!a4)
    return CFWriteStreamWrite(this[16], a2, a3);
  a4->domain = 0;
  a4->error = 0;
  v6 = CFWriteStreamWrite(this[16], a2, a3);
  if (CFWriteStreamGetStatus(this[16]) == kCFStreamStatusError)
  {
    v7 = this[16];
    if (v7 && (v8 = CFWriteStreamCopyError(v7)) != 0)
    {
      v9 = v8;
      v10 = _CFStreamErrorFromCFError(v8);
      v12 = v11;
      CFRelease(v9);
    }
    else
    {
      v12 = 0;
      v10 = 0;
    }
    a4->domain = v10;
    *(_QWORD *)&a4->error = v12;
  }
  else
  {
    a4->error = 0;
    a4->domain = 0;
  }
  return v6;
}

uint64_t CoreWriteStreamFromCFWriteStream::_streamImpl_CanWrite(CFWriteStreamRef *this)
{
  return CFWriteStreamCanAcceptBytes(this[16]);
}

uint64_t CoreWriteStreamFromCFWriteStream::_streamImpl_SetProperty(CFWriteStreamRef *this, const __CFString *a2, const void *a3)
{
  return CFWriteStreamSetProperty(this[16], a2, a3);
}

CFTypeRef CoreWriteStreamFromCFWriteStream::_streamImpl_CopyProperty(CFWriteStreamRef *this, const __CFString *a2)
{
  return CFWriteStreamCopyProperty(this[16], a2);
}

uint64_t CoreWriteStreamFromCFWriteStream::_streamImpl_Open(CoreWriteStreamFromCFWriteStream *this, unint64_t a2, BOOL *a3)
{
  CFStreamStatus Status;
  __CFWriteStream *v7;
  __CFError *v8;
  __CFError *v9;
  CFIndex v10;
  uint64_t v11;
  uint64_t v12;

  if (a2)
  {
    *(_QWORD *)a2 = 0;
    *(_DWORD *)(a2 + 8) = 0;
  }
  if (a3)
    *a3 = 0;
  *((_BYTE *)this + 136) = CFWriteStreamOpen(*((CFWriteStreamRef *)this + 16));
  if (a2 | (unint64_t)a3)
  {
    Status = CFWriteStreamGetStatus(*((CFWriteStreamRef *)this + 16));
    if (a3)
      *a3 = Status > kCFStreamStatusOpening;
    if (a2 && Status == kCFStreamStatusError)
    {
      v7 = (__CFWriteStream *)*((_QWORD *)this + 16);
      if (v7 && (v8 = CFWriteStreamCopyError(v7)) != 0)
      {
        v9 = v8;
        v10 = _CFStreamErrorFromCFError(v8);
        v12 = v11;
        CFRelease(v9);
      }
      else
      {
        v12 = 0;
        v10 = 0;
      }
      *(_QWORD *)a2 = v10;
      *(_QWORD *)(a2 + 8) = v12;
    }
  }
  return *((unsigned __int8 *)this + 136);
}

BOOL CoreWriteStreamFromCFWriteStream::_streamImpl_OpenCompleted(CFWriteStreamRef *this, CFStreamError *a2)
{
  CFStreamStatus Status;
  uint64_t v5;
  __CFWriteStream *v6;
  __CFError *v7;
  __CFError *v8;
  CFIndex v9;
  uint64_t v10;
  uint64_t v11;

  Status = CFWriteStreamGetStatus(this[16]);
  v5 = Status;
  if (a2)
  {
    if (Status == kCFStreamStatusError)
    {
      v6 = this[16];
      if (v6 && (v7 = CFWriteStreamCopyError(v6)) != 0)
      {
        v8 = v7;
        v9 = _CFStreamErrorFromCFError(v7);
        v11 = v10;
        CFRelease(v8);
      }
      else
      {
        v11 = 0;
        v9 = 0;
      }
      a2->domain = v9;
      *(_QWORD *)&a2->error = v11;
    }
    else
    {
      a2->domain = 0;
      a2->error = 0;
    }
  }
  return v5 > 1;
}

void CoreWriteStreamFromCFWriteStream::_streamImpl_Close(CoreWriteStreamFromCFWriteStream *this)
{
  if (*((_BYTE *)this + 136))
  {
    if (!*((_BYTE *)this + 137))
    {
      *((_BYTE *)this + 137) = 1;
      CFWriteStreamClose(*((CFWriteStreamRef *)this + 16));
    }
  }
}

void CoreWriteStreamFromCFWriteStream::_streamImpl_UpdateScheduling(__CFWriteStream **this, CoreSchedulingSet *a2, CoreSchedulingSet *a3)
{
  CoreSchedulingSet::unscheduleStream(a2, this[16]);
  CoreSchedulingSet::scheduleStream(a3, this[16]);
}

void `non-virtual thunk to'CoreWriteStreamFromCFWriteStream::~CoreWriteStreamFromCFWriteStream(CoreWriteStreamFromCFWriteStream *this)
{
  CoreWriteStreamFromCFWriteStream::~CoreWriteStreamFromCFWriteStream((CoreWriteStreamFromCFWriteStream *)((char *)this - 8));
}

{
  CoreWriteStreamFromCFWriteStream::~CoreWriteStreamFromCFWriteStream((CoreWriteStreamFromCFWriteStream *)((char *)this - 8));
}

{
  CoreWriteStreamFromCFWriteStream::~CoreWriteStreamFromCFWriteStream((CoreWriteStreamFromCFWriteStream *)((char *)this - 120));
}

{
  CoreWriteStreamFromCFWriteStream::~CoreWriteStreamFromCFWriteStream((CoreWriteStreamFromCFWriteStream *)((char *)this - 120));
}

uint64_t `non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_SetProperty(CFWriteStreamRef *this, const __CFString *a2, const void *a3)
{
  return CFWriteStreamSetProperty(this[1], a2, a3);
}

CFTypeRef `non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_CopyProperty(CFWriteStreamRef *this, const __CFString *a2)
{
  return CFWriteStreamCopyProperty(this[1], a2);
}

uint64_t `non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_Open(CoreWriteStreamFromCFWriteStream *this, CFStreamError *a2, BOOL *a3)
{
  return CoreWriteStreamFromCFWriteStream::_streamImpl_Open((CoreWriteStreamFromCFWriteStream *)((char *)this - 120), (unint64_t)a2, a3);
}

BOOL `non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_OpenCompleted(CFWriteStreamRef *this, CFStreamError *a2)
{
  return CoreWriteStreamFromCFWriteStream::_streamImpl_OpenCompleted(this - 15, a2);
}

void `non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_Close(CoreWriteStreamFromCFWriteStream *this)
{
  if (*((_BYTE *)this + 16))
  {
    if (!*((_BYTE *)this + 17))
    {
      *((_BYTE *)this + 17) = 1;
      CFWriteStreamClose(*((CFWriteStreamRef *)this + 1));
    }
  }
}

CFIndex `non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_Write(CFWriteStreamRef *this, const unsigned __int8 *a2, CFIndex a3, CFStreamError *a4)
{
  return CoreWriteStreamFromCFWriteStream::_streamImpl_Write(this - 15, a2, a3, a4);
}

uint64_t `non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_CanWrite(CFWriteStreamRef *this)
{
  return CFWriteStreamCanAcceptBytes(this[1]);
}

void `non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_UpdateScheduling(__CFWriteStream **this, CoreSchedulingSet *a2, CoreSchedulingSet *a3)
{
  CoreSchedulingSet::unscheduleStream(a2, this[1]);
  CoreSchedulingSet::scheduleStream(a3, this[1]);
}

void CoreWriteStreamFromCFWriteStream::~CoreWriteStreamFromCFWriteStream(CoreWriteStreamFromCFWriteStream *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1E14EF3C0;
  *((_QWORD *)this + 1) = &unk_1E14EF458;
  v2 = (const void *)*((_QWORD *)this + 16);
  *((_QWORD *)this + 15) = &unk_1E14EF478;
  *((_QWORD *)this + 16) = 0;
  if (v2)
    CFRelease(v2);
  CoreStreamBase::~CoreStreamBase(this);
}

void sub_18401E888(_Unwind_Exception *a1)
{
  CoreStreamBase *v1;

  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

void CoreWriteStreamFromCFWriteStream::_writeStreamClientCallBack(CoreWriteStreamFromCFWriteStream *this, uint64_t a2, CoreStreamBase *a3, void *a4)
{
  __CFError *v5;
  __CFError *v6;
  CFIndex v7;
  uint64_t v8;
  uint64_t v9;
  CoreStreamBase *v10;
  CFStreamError v11;

  if (a2 == 8)
  {
    if (this && (v5 = CFWriteStreamCopyError(this)) != 0)
    {
      v6 = v5;
      v7 = _CFStreamErrorFromCFError(v5);
      v9 = v8;
      CFRelease(v6);
    }
    else
    {
      v9 = 0;
      v7 = 0;
    }
    v10 = a3;
    a2 = 8;
    v11.domain = v7;
    *(_QWORD *)&v11.error = v9;
  }
  else
  {
    v10 = a3;
    v11.domain = 0;
    *(_QWORD *)&v11.error = 0;
  }
  CoreStreamBase::_signalEvent(v10, a2, v11, 1);
}

uint64_t CoreWriteStream::setClient(uint64_t a1, uint64_t a2, uint64_t a3, const CFStreamClientContext *a4)
{
  uint64_t v8;
  const __CFAllocator *v9;
  char *v10;
  char *v11;
  const __CFAllocator *v12;
  uint64_t result;

  if (a3)
  {
    v8 = a1 - 16;
    v9 = CFGetAllocator((CFTypeRef)(a1 - 16));
    v10 = (char *)CFAllocatorAllocate(v9, 96, 0);
    *(_OWORD *)v10 = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    *((_OWORD *)v10 + 2) = 0u;
    *((_OWORD *)v10 + 3) = 0u;
    *((_OWORD *)v10 + 5) = 0u;
    *((_OWORD *)v10 + 4) = 0u;
    v11 = v10 + 64;
    v12 = CFGetAllocator((CFTypeRef)(a1 - 16));
    ClassicStreamClient::ClassicStreamClient((ClassicStreamClient *)v10, v12, a4);
    *(_QWORD *)v10 = off_1E14E91E8;
    *((_QWORD *)v10 + 8) = &unk_1E14E9258;
    *((_QWORD *)v10 + 9) = v8;
    *((_QWORD *)v10 + 10) = v8;
    *((_QWORD *)v10 + 11) = a3;
  }
  else
  {
    v11 = 0;
  }
  result = (*(uint64_t (**)(uint64_t, uint64_t, char *))(*(_QWORD *)a1 + 56))(a1, a2, v11);
  if (v11)
    return (*(uint64_t (**)(char *))(*(_QWORD *)v11 + 24))(v11);
  return result;
}

void ClassicWriteClient::~ClassicWriteClient(ClassicWriteClient *this)
{
  void (*v1)(void);

  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 8) = off_1E14EBD28;
  *((_QWORD *)this + 9) = 0;
  *(_QWORD *)this = off_1E14E9D28;
  if (*((_QWORD *)this + 4))
  {
    v1 = (void (*)(void))*((_QWORD *)this + 6);
    if (v1)
      v1();
  }
}

{
  void (*v2)(void);

  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 8) = off_1E14EBD28;
  *((_QWORD *)this + 9) = 0;
  *(_QWORD *)this = off_1E14E9D28;
  if (*((_QWORD *)this + 4))
  {
    v2 = (void (*)(void))*((_QWORD *)this + 6);
    if (v2)
      v2();
  }
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

BOOL ClassicWriteClient::equals(ClassicWriteClient *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

char *ClassicWriteClient::coreStreamClientRetain(ClassicWriteClient *this)
{
  char *v1;

  v1 = (char *)this + 64;
  (*(void (**)(ClassicWriteClient *))(*(_QWORD *)this + 40))(this);
  return v1;
}

uint64_t ClassicWriteClient::coreStreamClientRelease(ClassicWriteClient *this)
{
  return (*(uint64_t (**)(ClassicWriteClient *))(*(_QWORD *)this + 48))(this);
}

uint64_t ClassicWriteClient::coreStreamWriteEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a1 + 88))(a2, a3, *(_QWORD *)(a1 + 32));
}

void ClassicWriteClient::coreStreamEventsAvailable(ClassicWriteClient *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = a2;
  if (*((_QWORD *)this + 10) && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
  {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    if (!v2)
      return;
  }
  else if (!a2)
  {
    return;
  }
  v4 = 1;
  do
  {
    if ((v4 & ~v2) == 0)
    {
      (*(void (**)(ClassicWriteClient *, _QWORD, uint64_t))(*(_QWORD *)this + 80))(this, *((_QWORD *)this + 10), v4);
      v2 &= ~v4;
    }
    v4 *= 2;
  }
  while (v2);
}

void `non-virtual thunk to'ClassicWriteClient::~ClassicWriteClient(ClassicWriteClient *this)
{
  void (*v1)(_QWORD);

  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = off_1E14EBD28;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this - 8) = off_1E14E9D28;
  if (*((_QWORD *)this - 4))
  {
    v1 = (void (*)(_QWORD))*((_QWORD *)this - 2);
    if (v1)
      v1(*((_QWORD *)this - 4));
  }
}

{
  ClassicWriteClient::~ClassicWriteClient((ClassicWriteClient *)((char *)this - 64));
}

ClassicWriteClient *`non-virtual thunk to'ClassicWriteClient::coreStreamClientRetain(ClassicWriteClient *this)
{
  (*(void (**)(char *))(*((_QWORD *)this - 8) + 40))((char *)this - 64);
  return this;
}

uint64_t `non-virtual thunk to'ClassicWriteClient::coreStreamClientRelease(ClassicWriteClient *this)
{
  return (*(uint64_t (**)(char *))(*((_QWORD *)this - 8) + 48))((char *)this - 64);
}

CFStringRef `non-virtual thunk to'ClassicWriteClient::coreStreamClientCopyDescription(ClassicWriteClient *this)
{
  return ClassicStreamClient::clientCopyDescription((ClassicWriteClient *)((char *)this - 64));
}

void `non-virtual thunk to'ClassicWriteClient::coreStreamEventsAvailable(ClassicWriteClient *this, uint64_t a2)
{
  ClassicWriteClient::coreStreamEventsAvailable((ClassicWriteClient *)((char *)this - 64), a2);
}

uint64_t `non-virtual thunk to'ClassicWriteClient::coreStreamWriteEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ClassicWriteClient::coreStreamWriteEvent(a1 - 64, a2, a3);
}

uint64_t CoreWriteStreamCreate(uint64_t a1, __int128 *a2, uint64_t a3)
{
  uint64_t Instance;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t (*v12)(uint64_t, uint64_t);

  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  Instance = _CFRuntimeCreateInstance();
  v6 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    v6 = Instance + 16;
    *(_QWORD *)(Instance + 256) = 0;
    *(_OWORD *)(Instance + 224) = 0u;
    *(_OWORD *)(Instance + 240) = 0u;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 208) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }
  *(_DWORD *)(v6 + 104) = 0;
  *(_QWORD *)(v6 + 120) = &unk_1E14EE750;
  *(_QWORD *)(v6 + 24) = v6 + 120;
  *(_QWORD *)v6 = &off_1E14EE690;
  *(_QWORD *)(v6 + 8) = &unk_1E14EE730;
  v7 = *a2;
  v8 = a2[1];
  *(_OWORD *)(v6 + 168) = a2[2];
  *(_OWORD *)(v6 + 152) = v8;
  *(_OWORD *)(v6 + 136) = v7;
  v9 = a2[3];
  v10 = a2[4];
  v11 = a2[5];
  *(_OWORD *)(v6 + 232) = a2[6];
  *(_OWORD *)(v6 + 216) = v11;
  *(_OWORD *)(v6 + 200) = v10;
  *(_OWORD *)(v6 + 184) = v9;
  v12 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 144);
  if (v12)
    a3 = v12(v6 - 16, a3);
  *(_QWORD *)(v6 + 128) = a3;
  return v6 - 16;
}

void sub_18401EDA4(_Unwind_Exception *a1)
{
  CoreStreamBase *v1;

  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_Write(CoreWriteStreamWithCallbacks *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  uint64_t (*v4)(char *, const unsigned __int8 *);

  if (a4)
  {
    a4->domain = 0;
    a4->error = 0;
  }
  v4 = (uint64_t (*)(char *, const unsigned __int8 *))*((_QWORD *)this + 23);
  if (v4)
    return v4((char *)this - 16, a2);
  else
    return -1;
}

BOOL CoreWriteStreamWithCallbacks::_streamImpl_CanWrite(CoreWriteStreamWithCallbacks *this)
{
  unsigned int (*v1)(char *, _QWORD);

  v1 = (unsigned int (*)(char *, _QWORD))*((_QWORD *)this + 24);
  return v1 && v1((char *)this - 16, *((_QWORD *)this + 16)) != 0;
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_RequestEvents(uint64_t this, uint64_t a2)
{
  uint64_t (*v2)(uint64_t, uint64_t, _QWORD);

  v2 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD))(this + 224);
  if (v2)
    return v2(this - 16, a2, *(_QWORD *)(this + 128));
  return this;
}

BOOL CoreWriteStreamWithCallbacks::_streamImpl_SetProperty(CoreWriteStreamWithCallbacks *this, const __CFString *a2, const void *a3)
{
  unsigned int (*v3)(char *, const __CFString *, const void *, _QWORD);

  v3 = (unsigned int (*)(char *, const __CFString *, const void *, _QWORD))*((_QWORD *)this + 27);
  return v3 && v3((char *)this - 16, a2, a3, *((_QWORD *)this + 16)) != 0;
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_CopyProperty(CoreWriteStreamWithCallbacks *this, const __CFString *a2)
{
  uint64_t (*v2)(char *, const __CFString *, _QWORD);

  v2 = (uint64_t (*)(char *, const __CFString *, _QWORD))*((_QWORD *)this + 26);
  if (v2)
    return v2((char *)this - 16, a2, *((_QWORD *)this + 16));
  else
    return 0;
}

BOOL CoreWriteStreamWithCallbacks::_streamImpl_Open(CoreWriteStreamWithCallbacks *this, CFStreamError *a2, unsigned __int8 *a3)
{
  unsigned int (*v3)(char *);

  if (a2)
  {
    a2->domain = 0;
    a2->error = 0;
  }
  if (a3)
    *a3 = 0;
  v3 = (unsigned int (*)(char *))*((_QWORD *)this + 21);
  return v3 && v3((char *)this - 16) != 0;
}

BOOL CoreWriteStreamWithCallbacks::_streamImpl_OpenCompleted(CoreWriteStreamWithCallbacks *this, CFStreamError *a2)
{
  unsigned int (*v2)(char *);

  if (a2)
  {
    a2->domain = 0;
    a2->error = 0;
  }
  v2 = (unsigned int (*)(char *))*((_QWORD *)this + 22);
  return v2 && v2((char *)this - 16) != 0;
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_Close(uint64_t this)
{
  uint64_t (*v1)(uint64_t, _QWORD);

  v1 = *(uint64_t (**)(uint64_t, _QWORD))(this + 200);
  if (v1)
    return v1(this - 16, *(_QWORD *)(this + 128));
  return this;
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_deprecated_Schedule(uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t (*v3)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD);

  v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD))(this + 232);
  if (v3)
    return v3(this - 16, a2, a3, *(_QWORD *)(this + 128));
  return this;
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_deprecated_Unschedule(uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t (*v3)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD);

  v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD))(this + 240);
  if (v3)
    return v3(this - 16, a2, a3, *(_QWORD *)(this + 128));
  return this;
}

void `non-virtual thunk to'CoreWriteStreamWithCallbacks::~CoreWriteStreamWithCallbacks(CoreWriteStreamWithCallbacks *this)
{
  CoreWriteStreamWithCallbacks::~CoreWriteStreamWithCallbacks((CoreWriteStreamWithCallbacks *)((char *)this - 8));
}

{
  CoreWriteStreamWithCallbacks::~CoreWriteStreamWithCallbacks((CoreWriteStreamWithCallbacks *)((char *)this - 8));
}

{
  CoreWriteStreamWithCallbacks::~CoreWriteStreamWithCallbacks((CoreWriteStreamWithCallbacks *)((char *)this - 120));
}

{
  CoreWriteStreamWithCallbacks::~CoreWriteStreamWithCallbacks((CoreWriteStreamWithCallbacks *)((char *)this - 120));
}

BOOL `non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_SetProperty(CoreWriteStreamWithCallbacks *this, const __CFString *a2, const void *a3)
{
  unsigned int (*v3)(char *, const __CFString *, const void *, _QWORD);

  v3 = (unsigned int (*)(char *, const __CFString *, const void *, _QWORD))*((_QWORD *)this + 12);
  return v3 && v3((char *)this - 136, a2, a3, *((_QWORD *)this + 1)) != 0;
}

uint64_t `non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_CopyProperty(CoreWriteStreamWithCallbacks *this, const __CFString *a2)
{
  uint64_t (*v2)(char *, const __CFString *, _QWORD);

  v2 = (uint64_t (*)(char *, const __CFString *, _QWORD))*((_QWORD *)this + 11);
  if (v2)
    return v2((char *)this - 136, a2, *((_QWORD *)this + 1));
  else
    return 0;
}

uint64_t `non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_RequestEvents(uint64_t this, uint64_t a2)
{
  uint64_t (*v2)(uint64_t, uint64_t, _QWORD);

  v2 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD))(this + 104);
  if (v2)
    return v2(this - 136, a2, *(_QWORD *)(this + 8));
  return this;
}

BOOL `non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_Open(CoreWriteStreamWithCallbacks *this, CFStreamError *a2, unsigned __int8 *a3)
{
  unsigned int (*v3)(char *);

  if (a2)
  {
    a2->domain = 0;
    a2->error = 0;
  }
  if (a3)
    *a3 = 0;
  v3 = (unsigned int (*)(char *))*((_QWORD *)this + 6);
  return v3 && v3((char *)this - 136) != 0;
}

BOOL `non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_OpenCompleted(CoreWriteStreamWithCallbacks *this, CFStreamError *a2)
{
  unsigned int (*v2)(char *);

  if (a2)
  {
    a2->domain = 0;
    a2->error = 0;
  }
  v2 = (unsigned int (*)(char *))*((_QWORD *)this + 7);
  return v2 && v2((char *)this - 136) != 0;
}

uint64_t `non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_Close(uint64_t this)
{
  uint64_t (*v1)(uint64_t, _QWORD);

  v1 = *(uint64_t (**)(uint64_t, _QWORD))(this + 80);
  if (v1)
    return v1(this - 136, *(_QWORD *)(this + 8));
  return this;
}

uint64_t `non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_Write(CoreWriteStreamWithCallbacks *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  uint64_t (*v4)(char *, const unsigned __int8 *);

  if (a4)
  {
    a4->domain = 0;
    a4->error = 0;
  }
  v4 = (uint64_t (*)(char *, const unsigned __int8 *))*((_QWORD *)this + 8);
  if (v4)
    return v4((char *)this - 136, a2);
  else
    return -1;
}

BOOL `non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_CanWrite(CoreWriteStreamWithCallbacks *this)
{
  unsigned int (*v1)(char *, _QWORD);

  v1 = (unsigned int (*)(char *, _QWORD))*((_QWORD *)this + 9);
  return v1 && v1((char *)this - 136, *((_QWORD *)this + 1)) != 0;
}

uint64_t `non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_deprecated_Schedule(uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t (*v3)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD);

  v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD))(this + 112);
  if (v3)
    return v3(this - 136, a2, a3, *(_QWORD *)(this + 8));
  return this;
}

uint64_t `non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_deprecated_Unschedule(uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t (*v3)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD);

  v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD))(this + 120);
  if (v3)
    return v3(this - 136, a2, a3, *(_QWORD *)(this + 8));
  return this;
}

void CoreWriteStreamWithCallbacks::~CoreWriteStreamWithCallbacks(CoreWriteStreamWithCallbacks *this)
{
  void (*v2)(char *, _QWORD);

  *(_QWORD *)this = &off_1E14EE690;
  *((_QWORD *)this + 1) = &unk_1E14EE730;
  *((_QWORD *)this + 15) = &unk_1E14EE750;
  v2 = (void (*)(char *, _QWORD))*((_QWORD *)this + 19);
  if (v2)
    v2((char *)this - 16, *((_QWORD *)this + 16));
  CoreStreamBase::~CoreStreamBase(this);
}

void sub_18401F1A4(_Unwind_Exception *a1)
{
  CoreStreamBase *v1;

  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

_OWORD *CoreWriteStreamCreateWithCFWriteStream(const __CFAllocator *a1, __CFWriteStream *a2)
{
  _OWORD *Instance;
  _OWORD *v4;

  if (!a2)
    return 0;
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v4 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v4 = Instance + 1;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  *((_DWORD *)v4 + 26) = 0;
  *((_QWORD *)v4 + 15) = &unk_1E14EF478;
  *((_QWORD *)v4 + 3) = (char *)v4 + 120;
  *(_QWORD *)v4 = &off_1E14EF3C0;
  *((_QWORD *)v4 + 1) = &unk_1E14EF458;
  *((_QWORD *)v4 + 16) = CFRetain(a2);
  *((_WORD *)v4 + 68) = 0;
  return v4 - 1;
}

void sub_18401F280(_Unwind_Exception *a1)
{
  CoreStreamBase *v1;

  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

uint64_t _CFWriteStreamCreateWithCoreStream()
{
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  return CFWriteStreamCreate();
}

__CFWriteStream *CoreWriteStreamCFStreamSupport::_stream_create_and_bump_refcount(CoreWriteStreamCFStreamSupport *this, __CFWriteStream *a2, void *a3)
{
  char *v5;
  const __CFAllocator *v6;
  _OWORD *v7;
  CFAllocatorRef v8;

  v5 = (char *)a2 - 16;
  CFRetain((char *)a2 - 16);
  v6 = CFGetAllocator(this);
  v7 = CFAllocatorAllocate(v6, 56, 0);
  *v7 = 0u;
  v7[2] = 0u;
  *((_QWORD *)v7 + 6) = 0;
  v7[1] = 0u;
  v8 = CFGetAllocator(this);
  *(_QWORD *)v7 = off_1E14EF578;
  *((_QWORD *)v7 + 1) = v8;
  *((_DWORD *)v7 + 4) = 1;
  if (((unint64_t)(v7 + 1) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *((_QWORD *)v7 + 3) = &unk_1E14EF058;
  *(_QWORD *)v7 = off_1E14EEFE8;
  *((_QWORD *)v7 + 4) = v5;
  *((_QWORD *)v7 + 5) = this;
  *((_QWORD *)v7 + 6) = CFRetain(v5);
  (*(void (**)(__CFWriteStream *, uint64_t, uint64_t))(*(_QWORD *)a2 + 56))(a2, -1, (uint64_t)v7 + 24);
  (*(void (**)(_OWORD *))(*(_QWORD *)v7 + 48))(v7);
  return a2;
}

void sub_18401F3F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = off_1E14EBD28;
  *(_QWORD *)(v1 + 32) = 0;
  _Unwind_Resume(a1);
}

void CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_finalize(uint64_t a1, uint64_t a2)
{
  CFRelease((CFTypeRef)(a2 - 16));
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_copyDescription(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_open(int a1, uint64_t a2, _BYTE *a3, CoreStreamBase *this)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a2)
  {
    *(_DWORD *)(a2 + 8) = 0;
    *(_QWORD *)a2 = 0;
  }
  if (a3)
  {
    *a3 = 0;
    v7 = CoreStreamBase::_streamInterface_Open(this);
    if ((_DWORD)v7)
    {
      v8 = v7;
      *a3 = (*(uint64_t (**)(char *, uint64_t))(*((_QWORD *)this + 15) + 64))((char *)this + 120, a2);
      return v8;
    }
    if (!a2)
      return 0;
LABEL_10:
    v8 = 0;
    *(_OWORD *)a2 = *(_OWORD *)((char *)this + 56);
    return v8;
  }
  v9 = CoreStreamBase::_streamInterface_Open(this);
  v8 = v9;
  if (a2 && !(_DWORD)v9)
    goto LABEL_10;
  return v8;
}

BOOL CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_openCompleted(int a1, uint64_t a2, CoreStreamBase *this)
{
  uint64_t Status;

  Status = CoreStreamBase::_streamInterface_GetStatus(this);
  if (a2)
  {
    *(_DWORD *)(a2 + 8) = 0;
    *(_QWORD *)a2 = 0;
    if (Status == 7)
      *(_OWORD *)a2 = *(_OWORD *)((char *)this + 56);
  }
  return Status > 1;
}

uint64_t CoreWriteStreamCFStreamSupport::_stream_write(CoreWriteStreamCFStreamSupport *this, __CFWriteStream *a2, const unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, void *a6)
{
  uint64_t v8;
  uint64_t Status;

  if (a4)
  {
    *(_QWORD *)a4 = 0;
    *(_DWORD *)(a4 + 8) = 0;
  }
  v8 = CoreStreamBase::_streamInterface_Write((CoreStreamBase *)a5, (const unsigned __int8 *)a2, (uint64_t)a3);
  Status = CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)a5);
  if (a4 && Status == 7)
    *(CFStreamError *)a4 = *(CFStreamError *)((char *)a5 + 56);
  return v8;
}

uint64_t CoreWriteStreamCFStreamSupport::_stream_canWrite(CoreWriteStreamCFStreamSupport *this, __CFWriteStream *a2, void *a3)
{
  uint64_t v4;
  uint64_t Status;

  v4 = CoreStreamBase::_streamInterface_CanWrite(a2);
  if (!(_DWORD)v4)
  {
    Status = CoreStreamBase::_streamInterface_GetStatus(a2);
    if (Status == 5 || Status == 7)
      CFWriteStreamSignalEvent();
  }
  return v4;
}

void CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_close(uint64_t a1, CoreStreamBase *a2)
{
  (*(void (**)(CoreStreamBase *, _QWORD, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0, 0);
  CoreStreamBase::_streamInterface_Close(a2);
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_copyProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  ++*(_QWORD *)(a3 + 80);
  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a3 + 24) + 40))(*(_QWORD *)(a3 + 24));
  --*(_QWORD *)(a3 + 80);
  return result;
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_setProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  ++*(_QWORD *)(a4 + 80);
  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a4 + 24) + 32))(*(_QWORD *)(a4 + 24));
  --*(_QWORD *)(a4 + 80);
  return result;
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_requestEvents(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 80))(a3);
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_schedule(int a1, __CFRunLoop *a2, const __CFString *a3, os_unfair_lock_s *this)
{
  return CoreStreamBase::_streamInterface_Deprecated_Schedule(this, a2, a3);
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_unschedule(int a1, __CFRunLoop *a2, const __CFString *a3, os_unfair_lock_s *this)
{
  return CoreStreamBase::_streamInterface_Deprecated_Unschedule(this, a2, a3);
}

void CoreWriteStreamCFStreamSupport::~CoreWriteStreamCFStreamSupport(CoreWriteStreamCFStreamSupport *this)
{
  uint64_t v2;

  CoreWriteStreamCFStreamSupport::~CoreWriteStreamCFStreamSupport(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  const void *v2;

  *(_QWORD *)this = off_1E14EEFE8;
  *((_QWORD *)this + 3) = &unk_1E14EF058;
  v2 = (const void *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 3) = off_1E14EBD28;
  *((_QWORD *)this + 4) = 0;
}

BOOL CoreWriteStreamCFStreamSupport::equals(CoreWriteStreamCFStreamSupport *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

CFTypeRef CoreWriteStreamCFStreamSupport::coreStreamClientCopyCFStreamRef(CoreWriteStreamCFStreamSupport *this)
{
  CFTypeRef result;

  result = (CFTypeRef)*((_QWORD *)this + 5);
  if (result)
    return CFRetain(result);
  return result;
}

uint64_t CoreWriteStreamCFStreamSupport::coreStreamClientRetain(CoreWriteStreamCFStreamSupport *this)
{
  const void *v2;

  (*(void (**)(CoreWriteStreamCFStreamSupport *))(*(_QWORD *)this + 40))(this);
  v2 = (const void *)*((_QWORD *)this + 6);
  if (v2)
    CFRetain(v2);
  return (uint64_t)this + 24;
}

uint64_t CoreWriteStreamCFStreamSupport::coreStreamClientRelease(CoreWriteStreamCFStreamSupport *this)
{
  const void *v2;

  v2 = (const void *)*((_QWORD *)this + 6);
  if (v2)
    CFRelease(v2);
  return (*(uint64_t (**)(CoreWriteStreamCFStreamSupport *))(*(_QWORD *)this + 48))(this);
}

CFStringRef CoreWriteStreamCFStreamSupport::coreStreamClientCopyDescription(CoreWriteStreamCFStreamSupport *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<write side %p to stream %p>"), *((_QWORD *)this + 6), *((_QWORD *)this + 5));
}

uint64_t CoreWriteStreamCFStreamSupport::coreStreamWriteEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_QWORD *)(a1 + 48) && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  if (a3 == 8 && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  return CFWriteStreamSignalEvent();
}

void `non-virtual thunk to'CoreWriteStreamCFStreamSupport::~CoreWriteStreamCFStreamSupport(CoreWriteStreamCFStreamSupport *this)
{
  CoreWriteStreamCFStreamSupport::~CoreWriteStreamCFStreamSupport((CoreWriteStreamCFStreamSupport *)((char *)this - 24));
}

void `non-virtual thunk to'CoreWriteStreamCFStreamSupport::~CoreWriteStreamCFStreamSupport(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  CoreWriteStreamCFStreamSupport::~CoreWriteStreamCFStreamSupport((CoreWriteStreamCFStreamSupport *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

CoreWriteStreamCFStreamSupport *`non-virtual thunk to'CoreWriteStreamCFStreamSupport::coreStreamClientRetain(CoreWriteStreamCFStreamSupport *this)
{
  char *v2;
  const void *v3;

  v2 = (char *)this - 24;
  (*(void (**)(char *))(*((_QWORD *)this - 3) + 40))((char *)this - 24);
  v3 = (const void *)*((_QWORD *)v2 + 6);
  if (v3)
    CFRetain(v3);
  return this;
}

uint64_t `non-virtual thunk to'CoreWriteStreamCFStreamSupport::coreStreamClientRelease(CoreWriteStreamCFStreamSupport *this)
{
  const void *v2;

  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  return (*(uint64_t (**)(char *))(*((_QWORD *)this - 3) + 48))((char *)this - 24);
}

CFStringRef `non-virtual thunk to'CoreWriteStreamCFStreamSupport::coreStreamClientCopyDescription(CoreWriteStreamCFStreamSupport *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<write side %p to stream %p>"), *((_QWORD *)this + 3), *((_QWORD *)this + 2));
}

CFTypeRef `non-virtual thunk to'CoreWriteStreamCFStreamSupport::coreStreamClientCopyCFStreamRef(CoreWriteStreamCFStreamSupport *this)
{
  CFTypeRef result;

  result = (CFTypeRef)*((_QWORD *)this + 2);
  if (result)
    return CFRetain(result);
  return result;
}

uint64_t `non-virtual thunk to'CoreWriteStreamCFStreamSupport::coreStreamWriteEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CoreWriteStreamCFStreamSupport::coreStreamWriteEvent(a1 - 24, a2, a3);
}

void sub_18401F9CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = off_1E14EBD28;
  *(_QWORD *)(v1 + 32) = 0;
  _Unwind_Resume(a1);
}

uint64_t ___ZL17resumeDataClassesv_block_invoke_3220()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  double v7;
  uint64_t v8;
  uint64_t result;
  double v10;
  void *v11;

  v0 = (void *)MEMORY[0x1E0C99E20];
  v1 = objc_opt_class();
  v2 = objc_opt_class();
  v3 = objc_opt_class();
  v4 = objc_opt_class();
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  resumeDataClasses(void)::resumeDataClasses = (uint64_t)(id)objc_msgSend(v0, "setWithObjects:", v1, v2, v3, v4, v5, v6, objc_opt_class(), 0);
  gotLoadHelper_x20__OBJC_CLASS___SZExtractor(v7);
  if (objc_opt_class())
  {
    v8 = objc_msgSend(*(id *)(v1 + 3688), "knownSZExtractorImplementations");
    objc_msgSend((id)resumeDataClasses(void)::resumeDataClasses, "unionSet:", v8);
  }
  result = objc_opt_class();
  if (result)
  {
    v11 = (void *)resumeDataClasses(void)::resumeDataClasses;
    gotLoadHelper_x8__OBJC_CLASS___STRemoteExtractor(v10);
    return objc_msgSend(v11, "addObject:", objc_opt_class());
  }
  return result;
}

void sub_18402051C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&_localProtocolClassesForDefaultSessionLock);
  _Unwind_Resume(a1);
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_3300()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  *(_DWORD *)((char *)_PNAME<URLProtocol>::GET(void)::p + 7) = 1819239279;
  _PNAME<URLProtocol>::GET(void)::p[0] = *(_QWORD *)"URLProtocol>::GET() [OBJTYPE = URLProtocol]";
  CFClass::CFClass(v0, (const char *)_PNAME<URLProtocol>::GET(void)::p);
  TCFObject<URLProtocol>::Class(void)::clazz = (uint64_t)v0;
}

void sub_1840208AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void NSCFURLProtocolClient::~NSCFURLProtocolClient(NSCFURLProtocolClient *this)
{
  this->var2 = 0;
  this->var3 = 0;
  this->var0 = (void **)&off_1E14EBFE8;
  this->var1 = (void **)&off_1E14E5838;
}

{
  this->var2 = 0;
  this->var3 = 0;
  this->var0 = (void **)&off_1E14EBFE8;
  this->var1 = (void **)&off_1E14E5838;
  JUMPOUT(0x186DB748CLL);
}

id NSCFURLProtocolClient::protocolRetainClient(NSCFURLProtocolClient *this)
{
  return this->var2;
}

void NSCFURLProtocolClient::protocolReleaseClient(NSCFURLProtocolClient *this)
{

}

CFStringRef NSCFURLProtocolClient::protocolCopyDescription(NSCFURLProtocolClient *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("NSCFURLProtocolClient@%p:%p { %@ }"), this, this->var2, this->var2);
}

uint64_t NSCFURLProtocolClient::protocolWasRedirected(NSCFURLProtocolClient *this, NSURLRequest *a2, _CFURLResponse *a3)
{
  return objc_msgSend(this->var2, "URLProtocol:wasRedirectedToRequest:redirectResponse:", this->var3, a2, +[NSURLResponse _responseWithCFURLResponse:](NSURLResponse, "_responseWithCFURLResponse:", a3));
}

void NSCFURLProtocolClient::protocolCacheResponseIsValid(NSCFURLProtocolClient *this, const _CFCachedURLResponse *a2)
{
  id v3;

  v3 = -[NSCachedURLResponse _initWithCFCachedURLResponse:]([NSCachedURLResponse alloc], "_initWithCFCachedURLResponse:", a2);
  objc_msgSend(this->var2, "URLProtocol:cachedResponseIsValid:", this->var3, v3);

}

uint64_t NSCFURLProtocolClient::protocolDidReceiveResponse(NSCFURLProtocolClient *this, _CFURLResponse *a2)
{
  return objc_msgSend(this->var2, "URLProtocol:didReceiveResponse:cacheStoragePolicy:", this->var3, +[NSURLResponse _responseWithCFURLResponse:](NSURLResponse, "_responseWithCFURLResponse:", a2), *(int *)(-[_CFURLResponse _inner](a2, "_inner") + 72));
}

uint64_t NSCFURLProtocolClient::protocolDidLoadData(NSCFURLProtocolClient *this, const __CFData *a2)
{
  return objc_msgSend(this->var2, "URLProtocol:didLoadData:", this->var3, a2);
}

uint64_t NSCFURLProtocolClient::protocolDidFinishLoading(NSCFURLProtocolClient *this)
{
  return objc_msgSend(this->var2, "URLProtocolDidFinishLoading:", this->var3);
}

uint64_t NSCFURLProtocolClient::protocolDidFail(NSCFURLProtocolClient *this, __CFError *a2)
{
  return objc_msgSend(this->var2, "URLProtocol:didFailWithError:", this->var3, a2);
}

void NSCFURLProtocolClient::protocolDidReceiveAuthenticationChallenge(NSCFURLProtocolClient *this, _CFURLAuthChallenge *a2)
{
  id v3;

  v3 = +[NSURLAuthenticationChallenge _createAuthenticationChallengeForCFAuthChallenge:sender:](NSURLAuthenticationChallenge, "_createAuthenticationChallengeForCFAuthChallenge:sender:", a2, this->var3);
  objc_msgSend(this->var2, "URLProtocol:didReceiveAuthenticationChallenge:", this->var3, v3);

}

void NSCFURLProtocolClient::protocolReceivedSocketStreamsForUpgradeHeaderAvailable(NSCFURLProtocolClient *this, CFReadStreamRef stream, CFWriteStreamRef a3)
{
  if (stream)
    CFReadStreamClose(stream);
  if (a3)
    CFWriteStreamClose(a3);
}

uint64_t NSCFURLProtocolClient::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 152))(result, 0);
  return result;
}

void `non-virtual thunk to'NSCFURLProtocolClient::~NSCFURLProtocolClient(NSCFURLProtocolClient *this)
{
  this->var1 = 0;
  this->var2 = 0;
  this[-1].var3 = &off_1E14EBFE8;
  this->var0 = (void **)&off_1E14E5838;
}

{
  this->var1 = 0;
  this->var2 = 0;
  this->var0 = (void **)&off_1E14E5838;
  this[-1].var3 = &off_1E14EBFE8;
  JUMPOUT(0x186DB748CLL);
}

CFStringRef ClassicURLConnection::copyDebugDesc(ClassicURLConnection *this)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFURLConnection %p> { request = %@ }"), this, *((_QWORD *)this + 7));
}

void ClassicURLConnection::performDefaultHandlingForChallenge(ClassicURLConnection *this, CFTypeRef cf)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  _QWORD v8[5];
  _QWORD v9[6];
  _QWORD v10[6];
  _QWORD block[6];

  if (cf)
    CFRetain(cf);
  v4 = MEMORY[0x1E0C809B0];
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN20ClassicURLConnection34performDefaultHandlingForChallengeEP19_CFURLAuthChallenge_block_invoke;
  v8[3] = &__block_descriptor_40_e29_v16__0__LoaderInterface_____8l;
  v8[4] = cf;
  CFRetain((char *)this - 16);
  v5 = *((_QWORD *)this + 4);
  v9[0] = v4;
  v9[1] = 3221225472;
  v9[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  v9[3] = &unk_1E14FABB8;
  v9[4] = v8;
  v9[5] = this;
  v10[0] = v4;
  v10[1] = 3221225472;
  v10[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  v10[3] = &unk_1E14FDA90;
  v10[4] = v9;
  v10[5] = v5;
  v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v5 + 32) + 64))(*(_QWORD *)(v5 + 32));
  v7 = *(NSObject **)(v5 + 40);
  block[0] = v4;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v10;
  block[5] = v6;
  dispatch_async(v7, block);
}

void ClassicURLConnection::rejectChallenge(ClassicURLConnection *this, CFTypeRef cf)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  _QWORD v8[5];
  _QWORD v9[6];
  _QWORD v10[6];
  _QWORD block[6];

  if (cf)
    CFRetain(cf);
  v4 = MEMORY[0x1E0C809B0];
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN20ClassicURLConnection15rejectChallengeEP19_CFURLAuthChallenge_block_invoke;
  v8[3] = &__block_descriptor_40_e29_v16__0__LoaderInterface_____8l;
  v8[4] = cf;
  CFRetain((char *)this - 16);
  v5 = *((_QWORD *)this + 4);
  v9[0] = v4;
  v9[1] = 3221225472;
  v9[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  v9[3] = &unk_1E14FABB8;
  v9[4] = v8;
  v9[5] = this;
  v10[0] = v4;
  v10[1] = 3221225472;
  v10[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  v10[3] = &unk_1E14FDA90;
  v10[4] = v9;
  v10[5] = v5;
  v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v5 + 32) + 64))(*(_QWORD *)(v5 + 32));
  v7 = *(NSObject **)(v5 + 40);
  block[0] = v4;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v10;
  block[5] = v6;
  dispatch_async(v7, block);
}

void ClassicURLConnection::halt(id *this)
{
  os_unfair_lock_s *v2;

  if (!(*(unsigned int (**)(id))(*(_QWORD *)this[3] + 64))(this[3]))
  {
    objc_msgSend(this[7], "_metrics");
    v2 = (os_unfair_lock_s *)this[3];
    os_unfair_lock_lock(v2 + 34);
    LOBYTE(v2[35]._os_unfair_lock_opaque) = 1;
    os_unfair_lock_unlock(v2 + 34);
  }
}

void ClassicURLConnection::resume(ClassicURLConnection *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  _QWORD v7[5];
  _QWORD v8[6];
  _QWORD v9[6];
  _QWORD block[6];

  v2 = *((_QWORD *)this + 3);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 136));
  *(_BYTE *)(v2 + 140) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 136));
  v3 = MEMORY[0x1E0C809B0];
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN20ClassicURLConnection6resumeEv_block_invoke;
  v7[3] = &__block_descriptor_40_e39_v16__0__ConnectionClientInterface_____8l;
  v7[4] = this;
  CFRetain((char *)this - 16);
  v4 = *((_QWORD *)this + 3);
  v8[0] = v3;
  v8[1] = 3221225472;
  v8[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v8[3] = &unk_1E14F78D0;
  v8[4] = v7;
  v8[5] = this;
  v9[0] = v3;
  v9[1] = 3221225472;
  v9[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v9[3] = &unk_1E14FDA90;
  v9[4] = v8;
  v9[5] = v4;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 32) + 64))(*(_QWORD *)(v4 + 32));
  v6 = *(NSObject **)(v4 + 40);
  block[0] = v3;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v9;
  block[5] = v5;
  dispatch_async(v6, block);
}

void ClassicURLConnection::unscheduleFromRunLoop(ClassicURLConnection *this, __CFRunLoop *a2, const __CFString *a3)
{
  const __CFString *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD v9[6];
  _QWORD v10[6];
  _QWORD v11[6];
  _QWORD block[6];

  v4 = (const __CFString *)*MEMORY[0x1E0C9B280];
  if (a3)
    v4 = a3;
  v5 = MEMORY[0x1E0C809B0];
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___ZN20ClassicURLConnection21unscheduleFromRunLoopEP11__CFRunLoopPK10__CFString_block_invoke;
  v9[3] = &__block_descriptor_48_e39_v16__0__ConnectionClientInterface_____8l;
  v9[4] = a2;
  v9[5] = v4;
  CFRetain((char *)this - 16);
  v6 = *((_QWORD *)this + 3);
  v10[0] = v5;
  v10[1] = 3221225472;
  v10[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v10[3] = &unk_1E14F78D0;
  v10[4] = v9;
  v10[5] = this;
  v11[0] = v5;
  v11[1] = 3221225472;
  v11[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v11[3] = &unk_1E14FDA90;
  v11[4] = v10;
  v11[5] = v6;
  v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v6 + 32) + 64))(*(_QWORD *)(v6 + 32));
  v8 = *(NSObject **)(v6 + 40);
  block[0] = v5;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v11;
  block[5] = v7;
  dispatch_async(v8, block);
}

void ClassicURLConnection::scheduleLoaderWithRunLoop(ClassicURLConnection *this, __CFRunLoop *a2, const __CFString *a3)
{
  NSObject *v3;
  uint8_t v4[16];

  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v3 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v4 = 0;
    _os_log_error_impl(&dword_183ECA000, v3, OS_LOG_TYPE_ERROR, "Rescheduling the CFNetwork loader is no longer supported", v4, 2u);
  }
}

void ClassicURLConnection::unscheduleLoaderFromRunLoop(ClassicURLConnection *this, __CFRunLoop *a2, const __CFString *a3)
{
  NSObject *v3;
  uint8_t v4[16];

  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v3 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v4 = 0;
    _os_log_error_impl(&dword_183ECA000, v3, OS_LOG_TYPE_ERROR, "Rescheduling the CFNetwork loader is no longer supported", v4, 2u);
  }
}

void ClassicURLConnection::updateClientForCFURLDownload_sync(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD v9[6];
  _QWORD v10[6];
  _QWORD v11[6];
  _QWORD block[6];

  v4 = dispatch_semaphore_create(0);
  v5 = MEMORY[0x1E0C809B0];
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___ZN20ClassicURLConnection33updateClientForCFURLDownload_syncEP24CFURLConnectionClient_V1_block_invoke;
  v9[3] = &unk_1E14F7860;
  v9[4] = v4;
  v9[5] = a2;
  CFRetain((CFTypeRef)(a1 - 16));
  v6 = *(_QWORD *)(a1 + 24);
  v10[0] = v5;
  v10[1] = 3221225472;
  v10[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v10[3] = &unk_1E14F78D0;
  v10[4] = v9;
  v10[5] = a1;
  v11[0] = v5;
  v11[1] = 3221225472;
  v11[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v11[3] = &unk_1E14FDA90;
  v11[4] = v10;
  v11[5] = v6;
  v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v6 + 32) + 64))(*(_QWORD *)(v6 + 32));
  v8 = *(NSObject **)(v6 + 40);
  block[0] = v5;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v11;
  block[5] = v7;
  dispatch_async(v8, block);
  dispatch_semaphore_wait(v4, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v4);
}

uint64_t ClassicURLConnection::canUpdateForCFURLDownload(ClassicURLConnection *this)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  _QWORD v9[6];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  char v13;
  _QWORD v14[6];
  _QWORD v15[6];
  _QWORD block[6];

  v10 = 0;
  v11 = &v10;
  v12 = 0x2020000000;
  v13 = 0;
  v2 = dispatch_semaphore_create(0);
  v3 = MEMORY[0x1E0C809B0];
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___ZN20ClassicURLConnection25canUpdateForCFURLDownloadEv_block_invoke;
  v9[3] = &unk_1E14F7888;
  v9[4] = v2;
  v9[5] = &v10;
  CFRetain((char *)this - 16);
  v4 = *((_QWORD *)this + 3);
  v14[0] = v3;
  v14[1] = 3221225472;
  v14[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v14[3] = &unk_1E14F78D0;
  v14[4] = v9;
  v14[5] = this;
  v15[0] = v3;
  v15[1] = 3221225472;
  v15[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v15[3] = &unk_1E14FDA90;
  v15[4] = v14;
  v15[5] = v4;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 32) + 64))(*(_QWORD *)(v4 + 32));
  v6 = *(NSObject **)(v4 + 40);
  block[0] = v3;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v15;
  block[5] = v5;
  dispatch_async(v6, block);
  dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v2);
  v7 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  return v7;
}

void sub_1840213F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFTypeRef ClassicURLConnection::copyPeerAddress(ClassicURLConnection *this)
{
  uint64_t v1;
  os_unfair_lock_s *v2;
  const void *v3;
  CFTypeRef v4;

  v1 = *((_QWORD *)this + 3);
  v2 = (os_unfair_lock_s *)(v1 + 208);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 208));
  v3 = *(const void **)(v1 + 200);
  if (v3)
    v4 = CFRetain(v3);
  else
    v4 = 0;
  os_unfair_lock_unlock(v2);
  return v4;
}

id ClassicURLConnection::copyOriginalImmutableRequest(id *this)
{
  return (id)objc_msgSend(this[7], "originalRequest");
}

uint64_t ClassicURLConnection::loaderClientSupportsDispatchData(ClassicURLConnection *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 24))(*((_QWORD *)this + 3));
}

void `non-virtual thunk to'ClassicURLConnection::~ClassicURLConnection(ClassicURLConnection *this)
{
  ClassicURLConnection::~ClassicURLConnection((ClassicURLConnection *)((char *)this - 8));
}

{
  ClassicURLConnection::~ClassicURLConnection((ClassicURLConnection *)((char *)this - 8));
}

{
  ClassicURLConnection::~ClassicURLConnection((ClassicURLConnection *)((char *)this - 16));
}

{
  ClassicURLConnection::~ClassicURLConnection((ClassicURLConnection *)((char *)this - 16));
}

id `non-virtual thunk to'ClassicURLConnection::copyOriginalImmutableRequest(id *this)
{
  return (id)objc_msgSend(this[6], "originalRequest");
}

CFStringRef `non-virtual thunk to'ClassicURLConnection::copyDebugDesc(ClassicURLConnection *this)
{
  char *v2;
  const __CFAllocator *v3;

  v2 = (char *)this - 8;
  v3 = CFGetAllocator((char *)this - 24);
  return CFStringCreateWithFormat(v3, 0, CFSTR("<CFURLConnection %p> { request = %@ }"), v2, *((_QWORD *)this + 6));
}

NSObject *std::allocate_shared[abi:nn180100]<CoreSchedulingSetOneOff,std::allocator<CoreSchedulingSetOneOff>,NSObject  {objcproto17OS_dispatch_queue}*&,void({block_pointer}&)(void),void>(NSObject ***a1, NSObject *a2, const void *a3)
{
  NSObject **v6;
  NSObject **v7;
  NSObject *result;

  v6 = (NSObject **)operator new(0x28uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1E14F0D38;
  v7 = v6 + 3;
  if (a2)
    dispatch_retain(a2);
  *v7 = a2;
  if (a3)
    result = _Block_copy(a3);
  else
    result = 0;
  v6[4] = result;
  *a1 = v7;
  a1[1] = v6;
  return result;
}

void sub_184021584(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v3;

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<CoreSchedulingSetOneOff>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0D38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<CoreSchedulingSetOneOff>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0D38;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

intptr_t ___ZN20ClassicURLConnection25canUpdateForCFURLDownloadEv_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

intptr_t ___ZN20ClassicURLConnection33updateClientForCFURLDownload_syncEP24CFURLConnectionClient_V1_block_invoke(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(a1 + 40));
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t ___ZN20ClassicURLConnection21unscheduleFromRunLoopEP11__CFRunLoopPK10__CFString_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
  if (!(_DWORD)result)
  {
    if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
      dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16941);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 64))(a2, CoreSchedulingSet::getEmptySet(void)::sEmptySet);
  }
  return result;
}

uint64_t ___ZN20ClassicURLConnection6resumeEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  __n128 v4;

  v3 = objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 56), "_metrics");
  if (v3)
    v4.n128_u64[0] = *(_QWORD *)(v3 + 56);
  return (*(uint64_t (**)(uint64_t, __n128))(*(_QWORD *)a2 + 56))(a2, v4);
}

void ___ZN20ClassicURLConnection15rejectChallengeEP19_CFURLAuthChallenge_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 88))(a2, *(_QWORD *)(a1 + 32));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
}

void ___ZN20ClassicURLConnection34performDefaultHandlingForChallengeEP19_CFURLAuthChallenge_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, *(_QWORD *)(a1 + 32));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
}

void sub_184021B80(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void sub_184021C5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

id SessionConnectionLoadable::copyOriginalImmutableRequest(SessionConnectionLoadable *this, const char *a2)
{
  id var3;

  var3 = this->var3;
  if (var3)
    var3 = objc_getProperty(var3, a2, 8, 1);
  return (id)objc_msgSend(var3, "originalRequest");
}

const void *SessionConnectionLoadable::copyDebugDesc(SessionConnectionLoadable *this)
{
  const void *v1;
  const void *v2;

  v1 = (const void *)objc_msgSend(this->var3, "description");
  v2 = v1;
  if (v1)
    CFRetain(v1);
  return v2;
}

uint64_t SessionConnectionLoadable::cancel(SessionConnectionLoadable *this)
{
  return objc_msgSend(this->var3, "cancel");
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_DidReceiveChallenge(SessionConnectionLoadable *this, _CFURLAuthChallenge *a2)
{
  return objc_msgSend(this->var3, "_didReceiveChallenge:", +[NSURLAuthenticationChallenge _authenticationChallengeForCFAuthChallenge:sender:](NSURLAuthenticationChallenge, "_authenticationChallengeForCFAuthChallenge:sender:", a2, this->var3));
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_NeedNewBodyStream(SessionConnectionLoadable *this)
{
  return objc_msgSend(this->var3, "_needNewBodyStream");
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_NeedNewBodyStreamFromOffset(SessionConnectionLoadable *this, uint64_t a2)
{
  return objc_msgSend(this->var3, "_needNewBodyStreamFromOffset:", a2);
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_DidReceiveInformationalResponse(SessionConnectionLoadable *this, _CFURLResponse *a2)
{
  return objc_msgSend(this->var3, "_didReceiveInformationalResponse:", a2);
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_DidSendBodyData(SessionConnectionLoadable *this, UploadProgressInfo *a2)
{
  id var3;
  UploadProgressInfo v4;

  var3 = this->var3;
  v4 = *a2;
  return objc_msgSend(var3, "_didSendBodyData:", &v4);
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_DidFailWithError(SessionConnectionLoadable *this, __CFError *a2)
{
  return objc_msgSend(this->var3, "_didFinishWithError:", a2);
}

void SessionConnectionLoadable::_loaderClientEvent_DidTimeout(SessionConnectionLoadable *this)
{
  const __CFAllocator *v2;
  const char *v3;
  const __CFDictionary *v4;
  uint64_t v5;
  char v6;
  char v7;
  const void *v8;
  id var3;
  id Property;
  void *v11;
  CFIndex v12;
  CFErrorRef v13;
  int valuePtr;
  void *values[2];
  void *keys[3];

  keys[2] = *(void **)MEMORY[0x1E0C80C00];
  valuePtr = -2102;
  keys[0] = CFSTR("_kCFStreamErrorDomainKey");
  keys[1] = CFSTR("_kCFStreamErrorCodeKey");
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &kCFStreamErrorDomainHTTP);
  values[1] = CFNumberCreate(v2, kCFNumberIntType, &valuePtr);
  v4 = CFDictionaryCreate(v2, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v5 = 0;
  v6 = 1;
  do
  {
    v7 = v6;
    v8 = values[v5];
    if (v8)
      CFRelease(v8);
    v6 = 0;
    v5 = 1;
  }
  while ((v7 & 1) != 0);
  var3 = this->var3;
  if (var3
    && (Property = objc_getProperty(var3, v3, 8, 1), (v11 = Property) != 0)
    && objc_msgSend(Property, "_proxySettings")
    && objc_msgSend(v11, "_proxyHandshakePending")
    && !objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "currentRequest_URL"), "scheme"), "caseInsensitiveCompare:", CFSTR("https")))
  {
    v12 = 310;
  }
  else
  {
    v12 = -1001;
  }
  v13 = CFErrorCreate(v2, CFSTR("kCFErrorDomainCFNetwork"), v12, v4);
  if (v4)
    CFRelease(v4);
  (*((void (**)(SessionConnectionLoadable *, CFErrorRef))this->var0 + 21))(this, v13);
  if (v13)
    CFRelease(v13);
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_WillSendRequestForEstablishedConnection(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v3;
  _QWORD v5[5];

  v3 = *(void **)(a1 + 24);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN25SessionConnectionLoadable58_loaderClientEvent_WillSendRequestForEstablishedConnectionEPK14__CFDictionaryU13block_pointerFvP12NSURLRequestE_block_invoke;
  v5[3] = &unk_1E14F9A58;
  v5[4] = a3;
  return objc_msgSend(v3, "_willSendRequestForEstablishedConnection:completion:", a2, v5);
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_ConnectionWaiting(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 24), "_connectionIsWaitingWithReason:", a2);
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_ConditionalRequirementsChanged(SessionConnectionLoadable *this, int a2)
{
  return objc_msgSend(this->var3, "_conditionalRequirementsChanged:", a2 != 0);
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_AlternatePathAvailable(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 24), "_alternatePathAvailable:", a2);
}

void SessionConnectionLoadable::_loaderClientEvent_asyncError(SessionConnectionLoadable *this, const __CFString *a2, CFIndex a3)
{
  CFErrorRef v4;

  v4 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, a3, 0);
  (*((void (**)(SessionConnectionLoadable *, CFErrorRef))this->var0 + 21))(this, v4);
  if (v4)
    CFRelease(v4);
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_capturedSocketStreams(SessionConnectionLoadable *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  return objc_msgSend(this->var3, "_capturedSocketInputStream:outputStream:", a2, a3);
}

void SessionConnectionLoadable::_loaderClientEvent_captureTransportConnection(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  void *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;

  v3 = *(void **)(a1 + 24);
  v4 = (std::__shared_weak_count *)a2[1];
  v10 = *a2;
  v11 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  objc_msgSend(v3, "_captureTransportConnection:extraBytes:", &v10, a3);
  v7 = v11;
  if (v11)
  {
    v8 = (unint64_t *)&v11->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_18402285C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'SessionConnectionLoadable::~SessionConnectionLoadable(SessionConnectionLoadable *this)
{
  this[-1].var3 = &off_1E14ED570;
  this->var0 = (void **)&unk_1E14ED670;
  this->var1 = (void **)&off_1E14E5838;
}

{
  this->var0 = (void **)&unk_1E14ED670;
  this->var1 = (void **)&off_1E14E5838;
  this[-1].var3 = &off_1E14ED570;
  JUMPOUT(0x186DB748CLL);
}

{
  this[-1].var2 = (void **)&off_1E14ED570;
  this[-1].var3 = &unk_1E14ED670;
  this->var0 = (void **)&off_1E14E5838;
}

{
  this[-1].var3 = &unk_1E14ED670;
  this->var0 = (void **)&off_1E14E5838;
  this[-1].var2 = (void **)&off_1E14ED570;
  JUMPOUT(0x186DB748CLL);
}

uint64_t `non-virtual thunk to'SessionConnectionLoadable::_loaderClient_SupportsDispatchData(SessionConnectionLoadable *this)
{
  return 1;
}

uint64_t `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_NeedNewBodyStream(SessionConnectionLoadable *this)
{
  return objc_msgSend(this->var2, "_needNewBodyStream");
}

uint64_t `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_NeedNewBodyStreamFromOffset(SessionConnectionLoadable *this, uint64_t a2)
{
  return objc_msgSend(this->var2, "_needNewBodyStreamFromOffset:", a2);
}

uint64_t `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_DidReceiveInformationalResponse(SessionConnectionLoadable *this, _CFURLResponse *a2)
{
  return objc_msgSend(this->var2, "_didReceiveInformationalResponse:", a2);
}

void `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_DidTimeout(SessionConnectionLoadable *this)
{
  SessionConnectionLoadable::_loaderClientEvent_DidTimeout((SessionConnectionLoadable *)((char *)this - 8));
}

uint64_t `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_ConnectionWaiting(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 16), "_connectionIsWaitingWithReason:", a2);
}

uint64_t `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_ConditionalRequirementsChanged(SessionConnectionLoadable *this, int a2)
{
  return objc_msgSend(this->var2, "_conditionalRequirementsChanged:", a2 != 0);
}

uint64_t `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_AlternatePathAvailable(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 16), "_alternatePathAvailable:", a2);
}

void `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_asyncError(SessionConnectionLoadable *this, const __CFString *a2, CFIndex a3)
{
  SessionConnectionLoadable::_loaderClientEvent_asyncError((SessionConnectionLoadable *)((char *)this - 8), a2, a3);
}

uint64_t `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_capturedSocketStreams(SessionConnectionLoadable *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  return objc_msgSend(this->var2, "_capturedSocketInputStream:outputStream:", a2, a3);
}

void `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_captureTransportConnection(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  SessionConnectionLoadable::_loaderClientEvent_captureTransportConnection(a1 - 8, a2, a3);
}

void AutoStringWithFormat::~AutoStringWithFormat(AutoStringWithFormat *this)
{
  AutoString::~AutoString(this);
  JUMPOUT(0x186DB748CLL);
}

void AutoStringWithFormatAndArgs::~AutoStringWithFormatAndArgs(AutoStringWithFormatAndArgs *this)
{
  AutoString::~AutoString(this);
  JUMPOUT(0x186DB748CLL);
}

void AutoStringArray::addFormat(CFTypeRef *this, const __CFString *a2, ...)
{
  const __CFAllocator *v4;
  void (**v5)(AutoStringWithFormatAndArgs *__hidden);
  CFStringRef v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va;

  va_start(va, a2);
  v9 = *MEMORY[0x1E0C80C00];
  v4 = CFGetAllocator(*this);
  v5 = &off_1E14EDB18;
  v7 = 0;
  v8 = 0;
  v6 = CFStringCreateWithFormatAndArguments(v4, 0, a2, va);
  CFArrayAppendValue((CFMutableArrayRef)*this, v6);
  AutoString::~AutoString((AutoString *)&v5);
}

void sub_184022A9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::weak_ptr<TransportConnection>>,void *>>>::operator()[abi:nn180100](char a1, _QWORD *__p)
{
  std::__shared_weak_count *v3;

  if (a1)
  {
    v3 = (std::__shared_weak_count *)__p[4];
    if (v3)
      std::__shared_weak_count::__release_weak(v3);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t NWIOConnection::registerContext()
{
  return nw_connection_register_context();
}

uint64_t NWIOConnection::unregisterContext()
{
  return nw_connection_unregister_context();
}

void NWIOConnection::setQUICMaxStreamsUnidirectional(nw_connection_t *this, uint64_t a2)
{
  NSObject *v4;
  nw_protocol_metadata_t v5;
  nw_protocol_metadata_t v6;

  v4 = nw_protocol_copy_quic_connection_definition();
  v5 = nw_connection_copy_protocol_metadata(this[34], v4);
  v6 = v5;
  if (v5)
  {
    MEMORY[0x186DB8A94](v5, a2);
    nw_release(v6);
  }
  if (v4)
    nw_release(v4);
}

void sub_184022BA0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  nw_release(v2);
  if (v1)
    nw_release(v1);
  _Unwind_Resume(a1);
}

void NWIOConnection::setReusedAfterAPSleepWake(NWIOConnection *this)
{
  uint64_t v2;
  uint8_t v3[16];

  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "setReusedAfterAPSleepWake", v3, 2u);
  }
  v2 = *((_QWORD *)this + 25);
  if (v2)
    *(_BYTE *)(v2 + 21) = 1;
}

void NWIOConnection::coalesce(NWIOConnection *this)
{
  int v1;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_weak_owners;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  uint64_t v45[2];
  void *v46;
  std::__shared_weak_count *v47;
  __int128 buf;
  void (*v49)(_QWORD *, int, uint64_t, uint64_t, CFIndex, uint64_t);
  void *v50;
  NWIOConnection *v51;
  uint64_t v52;
  std::__shared_weak_count *v53;
  uint64_t v54;
  std::__shared_weak_count *v55;
  uint64_t v56;
  std::__shared_weak_count *v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v1 = *((unsigned __int16 *)this + 124) | (*((unsigned __int8 *)this + 250) << 16);
  if ((v1 & 0x20000) == 0)
  {
    *((_WORD *)this + 124) = *((_WORD *)this + 124);
    *((_BYTE *)this + 250) = (v1 | 0x20000u) >> 16;
    v3 = *((_QWORD *)this + 25);
    if (v3)
      *(_BYTE *)(v3 + 24) = 1;
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v4 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *((_QWORD *)this + 36);
      LODWORD(buf) = 134217984;
      *(_QWORD *)((char *)&buf + 4) = v5;
      _os_log_impl(&dword_183ECA000, v4, OS_LOG_TYPE_DEFAULT, "Connection %llu: will be coalesced", (uint8_t *)&buf, 0xCu);
    }
    v6 = *((_QWORD *)this + 56);
    v7 = (std::__shared_weak_count *)*((_QWORD *)this + 57);
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }
    v10 = *((_QWORD *)this + 60);
    v11 = (std::__shared_weak_count *)*((_QWORD *)this + 61);
    if (v11)
    {
      v12 = (unint64_t *)&v11->__shared_owners_;
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
    }
    v14 = *((_QWORD *)this + 32);
    v15 = (std::__shared_weak_count *)*((_QWORD *)this + 33);
    if (v15)
    {
      p_shared_weak_owners = (unint64_t *)&v15->__shared_weak_owners_;
      do
        v17 = __ldxr(p_shared_weak_owners);
      while (__stxr(v17 + 1, p_shared_weak_owners));
    }
    v46 = 0;
    v47 = 0;
    if (v7)
    {
      v18 = (unint64_t *)&v7->__shared_owners_;
      do
        v19 = __ldxr(v18);
      while (__stxr(v19 + 1, v18));
    }
    v45[0] = v10;
    v45[1] = (uint64_t)v11;
    if (v11)
    {
      v20 = (unint64_t *)&v11->__shared_owners_;
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
    *((_QWORD *)&buf + 1) = 3321888768;
    v49 = ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke;
    v50 = &__block_descriptor_88_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE56c38_ZTSNSt3__110shared_ptrI10__SecTrustEE72c37_ZTSNSt3__110shared_ptrIK9__CFArrayEE_e144_v60__0B8_shared_ptr___SecTrust______SecTrust_____shared_weak_count__12_shared_ptr_const___CFArray______CFArray_____shared_weak_count__28___qi_44l;
    v51 = this;
    v52 = v14;
    v53 = v15;
    if (v15)
    {
      v22 = (unint64_t *)&v15->__shared_weak_owners_;
      do
        v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }
    v54 = v6;
    v55 = v7;
    if (v7)
    {
      v24 = (unint64_t *)&v7->__shared_owners_;
      do
        v25 = __ldxr(v24);
      while (__stxr(v25 + 1, v24));
    }
    v56 = v10;
    v57 = v11;
    if (v11)
    {
      v26 = (unint64_t *)&v11->__shared_owners_;
      do
        v27 = __ldxr(v26);
      while (__stxr(v27 + 1, v26));
    }
    NWIOConnection::_tlsProcessValidateServerTrust_Invoke((uint64_t)this, &v46, v6, (uint64_t)v7, v45, (uint64_t)&buf);
    if (v11)
    {
      v28 = (unint64_t *)&v11->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    if (v7)
    {
      v30 = (unint64_t *)&v7->__shared_owners_;
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    v32 = v47;
    if (v47)
    {
      v33 = (unint64_t *)&v47->__shared_owners_;
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
    v35 = v57;
    if (v57)
    {
      v36 = (unint64_t *)&v57->__shared_owners_;
      do
        v37 = __ldaxr(v36);
      while (__stlxr(v37 - 1, v36));
      if (!v37)
      {
        ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
        std::__shared_weak_count::__release_weak(v35);
      }
    }
    v38 = v55;
    if (v55)
    {
      v39 = (unint64_t *)&v55->__shared_owners_;
      do
        v40 = __ldaxr(v39);
      while (__stlxr(v40 - 1, v39));
      if (!v40)
      {
        ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
        std::__shared_weak_count::__release_weak(v38);
      }
    }
    if (v53)
      std::__shared_weak_count::__release_weak(v53);
    if (v15)
      std::__shared_weak_count::__release_weak(v15);
    if (v11)
    {
      v41 = (unint64_t *)&v11->__shared_owners_;
      do
        v42 = __ldaxr(v41);
      while (__stlxr(v42 - 1, v41));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    if (v7)
    {
      v43 = (unint64_t *)&v7->__shared_owners_;
      do
        v44 = __ldaxr(v43);
      while (__stlxr(v44 - 1, v43));
      if (!v44)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
}

void sub_184022FFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,std::__shared_weak_count *a21,uint64_t a22,std::__shared_weak_count *a23)
{
  std::__shared_weak_count *v23;
  std::__shared_weak_count *v24;
  std::__shared_weak_count *v25;
  unint64_t *p_shared_owners;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t *v39;
  unint64_t v40;

  if (a23)
  {
    p_shared_owners = (unint64_t *)&a23->__shared_owners_;
    do
      v28 = __ldaxr(p_shared_owners);
    while (__stlxr(v28 - 1, p_shared_owners));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))a23->__on_zero_shared)(a23);
      std::__shared_weak_count::__release_weak(a23);
    }
  }
  if (a21)
  {
    v29 = (unint64_t *)&a21->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))a21->__on_zero_shared)(a21);
      std::__shared_weak_count::__release_weak(a21);
    }
  }
  if (a19)
    std::__shared_weak_count::__release_weak(a19);
  if (a10)
  {
    v31 = (unint64_t *)&a10->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  if (v23)
  {
    v33 = (unint64_t *)&v23->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  if (a12)
  {
    v35 = (unint64_t *)&a12->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
    }
  }
  if (v25)
    std::__shared_weak_count::__release_weak(v25);
  if (v24)
  {
    v37 = (unint64_t *)&v24->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  if (v23)
  {
    v39 = (unint64_t *)&v23->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  _Unwind_Resume(exception_object);
}

void NWIOConnection::setPeerCerts(NWIOConnection *this, CFTypeRef cf)
{
  CFTypeRef v3;
  _QWORD *v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t *v8;
  __int128 v9;

  if (cf)
  {
    v3 = CFRetain(cf);
    *(_QWORD *)&v9 = v3;
    v4 = (_QWORD *)operator new();
    *v4 = &off_1E14F1AC8;
    v4[1] = 0;
    v4[2] = 0;
    v4[3] = v3;
    *((_QWORD *)&v9 + 1) = v4;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 480, &v9);
    v5 = (std::__shared_weak_count *)*((_QWORD *)&v9 + 1);
    if (!*((_QWORD *)&v9 + 1))
      return;
    v6 = (unint64_t *)(*((_QWORD *)&v9 + 1) + 8);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
  }
  else
  {
    v9 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 480, &v9);
    v5 = (std::__shared_weak_count *)*((_QWORD *)&v9 + 1);
    if (!*((_QWORD *)&v9 + 1))
      return;
    v8 = (unint64_t *)(*((_QWORD *)&v9 + 1) + 8);
    do
      v7 = __ldaxr(v8);
    while (__stlxr(v7 - 1, v8));
  }
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

uint64_t NWIOConnection::createPeerTrustUsingTrustData(uint64_t this, const __CFData *a2)
{
  _QWORD v2[6];

  if (a2)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = ___ZN14NWIOConnection29createPeerTrustUsingTrustDataEPK8__CFData_block_invoke;
    v2[3] = &__block_descriptor_48_e24_v20__0____CFString__8B16l;
    v2[4] = this;
    v2[5] = a2;
    return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)this + 344))(this, v2);
  }
  return this;
}

uint64_t NWIOConnection::copyConnectionEndpoint(NWIOConnection *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 38);
  if (v1)
    nw_retain(*((void **)this + 38));
  return v1;
}

NSObject *NWIOConnection::copyConnectionParameters(NWIOConnection *this)
{
  NSObject *result;

  result = *((_QWORD *)this + 37);
  if (result)
    return nw_parameters_copy(result);
  return result;
}

uint64_t NWIOConnection::logConnectionAtAPSleep(uint64_t this)
{
  uint64_t v1;
  double Current;
  uint64_t v3;
  double v4;
  unsigned int v5;
  uint8_t buf[4];
  unsigned int v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(this + 681))
  {
    v1 = this;
    *(_BYTE *)(this + 681) = 1;
    Current = CFAbsoluteTimeGetCurrent();
    v3 = *(_QWORD *)(v1 + 200);
    if (v3)
      v4 = *(double *)(v3 + 176);
    else
      v4 = 0.0;
    v5 = ((Current - v4) * 1000.0);
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      v7 = v5;
      _os_log_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "logConnectionAtAPSleep: idleDuration=%u", buf, 8u);
    }
    return AnalyticsSendEventLazy_delayInitStub(COERCE_DOUBLE(3221225472));
  }
  return this;
}

void `non-virtual thunk to'NWIOConnection::~NWIOConnection(NWIOConnection *this)
{
  NWIOConnection::~NWIOConnection((NWIOConnection *)((char *)this - 112));
}

{
  NWIOConnection::~NWIOConnection((NWIOConnection *)((char *)this - 112));
  JUMPOUT(0x186DB748CLL);
}

uint64_t ___ZN14NWIOConnection22logConnectionAtAPSleepEv_block_invoke(uint64_t a1)
{
  const __CFString *v2;
  _QWORD v3[2];

  v3[1] = *MEMORY[0x1E0C80C00];
  v2 = CFSTR("idleDuration");
  v3[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", *(unsigned int *)(a1 + 32));
  return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v3, &v2, 1);
}

uint64_t __Block_byref_object_copy__3541(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(result + 48) = v2;
  return result;
}

void __Block_byref_object_dispose__3542(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 48);
  *(_QWORD *)(a1 + 48) = 0;
  if (v2)
    CFRelease(v2);
}

void ___ZN14NWIOConnection29createPeerTrustUsingTrustDataEPK8__CFData_block_invoke(uint64_t a1, const __CFString *a2)
{
  uint64_t v2;
  SecPolicyRef SSL;
  SecPolicyRef v4;
  __SecTrust *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  OSStatus v8;
  NSObject *v9;
  CFIndex v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  const char *v14;
  CFIndex Code;
  unint64_t v16;
  _QWORD v17[2];
  void (*v18)(uint64_t);
  void *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint8_t buf[4];
  uint64_t v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  CFIndex v30;
  __int16 v31;
  OSStatus v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  SSL = SecPolicyCreateSSL(1u, a2);
  if (SSL)
  {
    v4 = SSL;
    v21 = 0;
    v22 = &v21;
    v23 = 0x2020000000;
    v24 = 0;
    v17[0] = MEMORY[0x1E0C809B0];
    v17[1] = 3221225472;
    v18 = ___ZN14NWIOConnection29createPeerTrustUsingTrustDataEPK8__CFData_block_invoke_2;
    v19 = &unk_1E14FD3D8;
    v20 = &v21;
    v5 = (__SecTrust *)SecTrustDeserialize();
    v6 = (std::__shared_weak_count *)operator new();
    v6->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    v6->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1048;
    v6->__shared_weak_owners_ = 0;
    v6[1].__vftable = (std::__shared_weak_count_vtbl *)v5;
    if (v22[3] || !v5)
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v12 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        v13 = *(_QWORD *)(v2 + 288);
        v14 = (const char *)v22[3];
        if (v14)
          Code = CFErrorGetCode((CFErrorRef)v22[3]);
        else
          Code = 0;
        *(_DWORD *)buf = 134218498;
        v26 = v13;
        v27 = 2112;
        v28 = v14;
        v29 = 2048;
        v30 = Code;
        _os_log_error_impl(&dword_183ECA000, v12, OS_LOG_TYPE_ERROR, "Connection %llu: failed to deserialize cloned trust %@ [%ld]", buf, 0x20u);
      }
    }
    else
    {
      v8 = SecTrustSetPolicies(v5, v4);
      if (v8)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v9 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          v10 = (int)*MEMORY[0x1E0C9B298];
          v11 = *(_QWORD *)(v2 + 288);
          *(_DWORD *)buf = 134218754;
          v26 = v11;
          v27 = 2080;
          v28 = "";
          v29 = 2048;
          v30 = v10;
          v31 = 1024;
          v32 = v8;
          _os_log_error_impl(&dword_183ECA000, v9, OS_LOG_TYPE_ERROR, "Connection %llu: failed to set policy on deserialized cloned trust %s [%ld:%d]", buf, 0x26u);
        }
      }
      else
      {
        std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v2 + 448), (uint64_t)v5, (uint64_t)v6);
      }
    }
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
    v18((uint64_t)v17);
    _Block_object_dispose(&v21, 8);
    CFRelease(v4);
  }
}

void sub_1840237F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  void (*v10)(uint64_t *);
  uint64_t v11;
  uint64_t v12;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, void (*)(uint64_t *));
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  v10((uint64_t *)va1);
  _Block_object_dispose(va2, 8);
  CFRelease(v2);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection29createPeerTrustUsingTrustDataEPK8__CFData_block_invoke_2(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v1)
    CFRelease(v1);
}

void std::__shared_ptr_pointer<__SecTrust *,Deleter_CFRelease,std::allocator<__SecTrust>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<__CFArray const*,Deleter_CFRelease,std::allocator<__CFArray const>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, CFIndex a5, uint64_t a6)
{
  std::__shared_weak_count *v7;
  NWIOConnection *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  NSObject *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  uint64_t v18;
  _QWORD v19[7];
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  CFIndex v23;
  __int16 v24;
  int v25;
  uint64_t v26;
  CFStreamError v27;

  v26 = *MEMORY[0x1E0C80C00];
  v7 = (std::__shared_weak_count *)a1[6];
  if (v7)
  {
    v11 = (NWIOConnection *)a1[4];
    v12 = std::__shared_weak_count::lock(v7);
    v19[6] = v12;
    if (v12)
    {
      v13 = v12;
      v14 = a1[5];
      v19[5] = v14;
      if (v14 && (*(_WORD *)(v14 + 248) & 0x60) == 0 && (*(_DWORD *)(v14 + 136) - 5) >= 3)
      {
        if (a5 || (_DWORD)a6)
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v15 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          {
            v18 = *((_QWORD *)v11 + 36);
            *(_DWORD *)buf = 134218496;
            v21 = v18;
            v22 = 2048;
            v23 = a5;
            v24 = 1024;
            v25 = a6;
            _os_log_error_impl(&dword_183ECA000, v15, OS_LOG_TYPE_ERROR, "Connection %llu: coalesced TLS Trust encountered error %ld:%d", buf, 0x1Cu);
          }
          v27.domain = a5;
          *(_QWORD *)&v27.error = a6;
          NWIOConnection::_handleError(v11, v27);
        }
        else if (a2)
        {
          v19[0] = MEMORY[0x1E0C809B0];
          v19[1] = 3221225472;
          v19[2] = ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_211;
          v19[3] = &__block_descriptor_40_e45_v24__0____CFDictionary__8____CFDictionary__16l;
          v19[4] = v11;
          (*(void (**)(NWIOConnection *, _QWORD *))(*(_QWORD *)v11 + 336))(v11, v19);
          std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)v11 + 56, a1[7], a1[8]);
          std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)v11 + 60, a1[9], a1[10]);
          NWIOConnection::_tlsProcessHandshakeComplete(v11);
          NWIOConnection::_completeEndpointSetup(v11);
        }
      }
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        v17 = __ldaxr(p_shared_owners);
      while (__stlxr(v17 - 1, p_shared_owners));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }
}

void sub_184023AA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__160(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  return result;
}

__n128 __Block_byref_object_copy__147(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__148(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

__n128 __Block_byref_object_copy__168(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__169(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

__n128 __Block_byref_object_copy__165(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__166(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

void ___ZN14NWIOConnection29_tlsProcessTrust_PolicyStrictENSt3__110shared_ptrIK8__CFDataEEU13block_pointerFviE_block_invoke_171(_QWORD *a1, int a2)
{
  uint64_t v4;
  NSObject *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  _BYTE v13[18];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v4 = a1[7];
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v5 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v12 = *(_QWORD *)(v4 + 288);
      *(_DWORD *)v13 = 134218240;
      *(_QWORD *)&v13[4] = v12;
      *(_WORD *)&v13[12] = 1024;
      *(_DWORD *)&v13[14] = a2;
      _os_log_error_impl(&dword_183ECA000, v5, OS_LOG_TYPE_ERROR, "Connection %llu: strict TLS Trust evaluation failed(%d)", v13, 0x12u);
    }
  }
  (*(void (**)(void))(a1[4] + 16))();
  *(_QWORD *)v13 = 0;
  *(_QWORD *)&v13[8] = 0;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(_QWORD *)(a1[5] + 8) + 48, (__int128 *)v13);
  v6 = *(std::__shared_weak_count **)&v13[8];
  if (*(_QWORD *)&v13[8])
  {
    v7 = (unint64_t *)(*(_QWORD *)&v13[8] + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  *(_QWORD *)v13 = 0;
  *(_QWORD *)&v13[8] = 0;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(_QWORD *)(a1[6] + 8) + 48, (__int128 *)v13);
  v9 = *(std::__shared_weak_count **)&v13[8];
  if (*(_QWORD *)&v13[8])
  {
    v10 = (unint64_t *)(*(_QWORD *)&v13[8] + 8);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void std::__shared_ptr_pointer<__CFArray *,Deleter_CFRelease,std::allocator<__CFArray>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

_QWORD *__copy_helper_block_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE56c38_ZTSNSt3__110shared_ptrI10__SecTrustEE72c37_ZTSNSt3__110shared_ptrIK9__CFArrayEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[8];
  result[7] = a2[7];
  result[8] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = a2[10];
  result[9] = a2[9];
  result[10] = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  return result;
}

void __destroy_helper_block_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE56c38_ZTSNSt3__110shared_ptrI10__SecTrustEE72c37_ZTSNSt3__110shared_ptrIK9__CFArrayEE(uint64_t a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;

  v2 = a1 + 56;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 72);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

uint64_t ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_211(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD v5[7];

  v3 = *(_QWORD *)(a1 + 32);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_2;
  v5[3] = &__block_descriptor_56_e24_v20__0____CFString__8B16l;
  v5[4] = v3;
  v5[5] = a2;
  v5[6] = a3;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v3 + 344))(v3, v5);
}

void ___ZN14NWIOConnection39_tlsCopyClientCertificatesUsingMetadataEPU35objcproto24OS_sec_protocol_metadata8NSObject_block_invoke(uint64_t a1, sec_certificate_t certificate)
{
  SecCertificateRef v3;

  v3 = sec_certificate_copy_ref(certificate);
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), v3);
  if (v3)
    CFRelease(v3);
}

void sub_184023E28(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void ___ZN14NWIOConnection39_tlsCopyDistinguishedNamesUsingMetadataEPU35objcproto24OS_sec_protocol_metadata8NSObject_block_invoke(uint64_t a1, NSObject *a2)
{
  unint64_t *Mutable;
  CFTypeRef v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD v14[5];
  std::__shared_weak_count *v15;
  unint64_t *v16;
  std::__shared_weak_count *v17;

  Mutable = (unint64_t *)CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v5 = Mutable;
  v16 = Mutable;
  if (Mutable)
  {
    Mutable = (unint64_t *)operator new();
    *Mutable = (unint64_t)&off_1E14F1908;
    Mutable[1] = 0;
    Mutable[2] = 0;
    Mutable[3] = (unint64_t)v5;
  }
  v17 = (std::__shared_weak_count *)Mutable;
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 3321888768;
  v14[2] = ___ZN14NWIOConnection39_tlsCopyDistinguishedNamesUsingMetadataEPU35objcproto24OS_sec_protocol_metadata8NSObject_block_invoke_2;
  v14[3] = &__block_descriptor_48_e8_32c35_ZTSNSt3__110shared_ptrI8__CFDataEE_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
  v14[4] = v5;
  v15 = (std::__shared_weak_count *)Mutable;
  if (Mutable)
  {
    v6 = Mutable + 1;
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  dispatch_data_apply(a2, v14);
  if (v5)
    v5 = CFRetain(v5);
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), v5);
  if (v5)
    CFRelease(v5);
  v8 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v17;
  if (v17)
  {
    v12 = (unint64_t *)&v17->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_184023FC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v6;
  va_list va;
  uint64_t v8;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14NWIOConnection39_tlsCopyDistinguishedNamesUsingMetadataEPU35objcproto24OS_sec_protocol_metadata8NSObject_block_invoke_2(uint64_t a1, int a2, int a3, UInt8 *bytes, CFIndex length)
{
  CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 32), bytes, length);
  return 1;
}

uint64_t __copy_helper_block_e8_32c35_ZTSNSt3__110shared_ptrI8__CFDataEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c35_ZTSNSt3__110shared_ptrI8__CFDataEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void std::__shared_ptr_pointer<__CFData *,Deleter_CFRelease,std::allocator<__CFData>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<__CFData *,Deleter_CFRelease,std::allocator<__CFData>>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 24);
  if (v1)
    CFRelease(v1);
}

void ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_2(_QWORD *a1, void *a2, char a3)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *Value;
  _QWORD v8[5];
  _QWORD v9[5];

  if (a2)
  {
    if ((a3 & 1) == 0)
    {
      v5 = a1[4];
      v4 = (void *)a1[5];
      v6 = a1[6];
      Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 368), &unk_1EDCF93E0);
      v8[0] = MEMORY[0x1E0C809B0];
      v8[1] = 3221225472;
      v8[2] = ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_3;
      v8[3] = &__block_descriptor_40_e66_v40__0____CFString__8____CFArray__16____CFData__24____CFString__32l;
      v8[4] = v5;
      v9[0] = MEMORY[0x1E0C809B0];
      v9[1] = 3221225472;
      v9[2] = ___ZN18H2CoalescingEngine31updateCoalescingConnectionEntryEP14__CFDictionaryPKS0_PK10__CFStringPK9__CFArrayU13block_pointerFvS6_S9_PK8__CFDataS6_E_block_invoke;
      v9[3] = &unk_1E14FD470;
      v9[4] = v8;
      __NSURLSession_CoalescingGetCoalescingCCEntryHostWithDNSRecord(v4, v6, a2, Value, 0, (uint64_t)v9);
    }
  }
}

void ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 32);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v7 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *(_QWORD *)(v6 + 288);
    v9 = 134218242;
    v10 = v8;
    v11 = 2112;
    v12 = a5;
    _os_log_impl(&dword_183ECA000, v7, OS_LOG_TYPE_DEFAULT, "Connection %llu: coalesced with %@", (uint8_t *)&v9, 0x16u);
  }
}

uint64_t ___ZN18H2CoalescingEngine31updateCoalescingConnectionEntryEP14__CFDictionaryPKS0_PK10__CFStringPK9__CFArrayU13block_pointerFvS6_S9_PK8__CFDataS6_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void NWIOConnection::_signalError(NWIOConnection *this)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  char *v6;
  int v7;
  int v8;
  unint64_t *v9;
  unint64_t v10;

  v2 = *((_QWORD *)this + 20);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 21);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  if (v2)
  {
    (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 47), *((_QWORD *)this + 48));
    v7 = *((unsigned __int16 *)this + 124);
    v6 = (char *)this + 248;
    v8 = v6[2];
    *(_WORD *)v6 = v7 & 0xFFFD;
    v6[2] = (v7 & 0xFFFFFFFD | (v8 << 16)) >> 16;
    if (!v3)
      return;
  }
  else
  {
    *((_WORD *)this + 124) |= 2u;
    if (!v3)
      return;
  }
  v9 = (unint64_t *)&v3->__shared_owners_;
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_184024304(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::_copyNetworkSignature(uint64_t this, uint64_t a2)
{
  _QWORD *v3;
  int v4;
  uint64_t v5;
  _BYTE *v6;
  unint64_t v7;
  char *v8;
  _BYTE v9[39];
  unsigned __int8 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = 0;
  if (*(_QWORD *)(a2 + 336))
  {
    v3 = (_QWORD *)this;
    this = *(_QWORD *)(a2 + 344);
    if (this)
    {
      this = nw_endpoint_get_type((nw_endpoint_t)this);
      if ((_DWORD)this == 1)
      {
        this = (uint64_t)nw_endpoint_get_address(*(nw_endpoint_t *)(a2 + 344));
        if (this)
        {
          v10 = 20;
          this = MEMORY[0x1E0C80A78](this);
          v4 = *(unsigned __int8 *)(this + 1);
          if (v4 == 30)
          {
            this = nw_path_get_ipv6_network_signature();
          }
          else
          {
            if (v4 != 2)
              return this;
            this = nw_path_get_ipv4_network_signature();
          }
          if ((_DWORD)this)
          {
            MEMORY[0x1E0C80A78](this);
            v6 = &v9[-v5];
            v7 = 0;
            v8 = &v9[-v5];
            do
            {
              snprintf(v8, 3uLL, "%.2x", v9[v7++]);
              v8 += 2;
            }
            while (v7 < v10);
            this = (uint64_t)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("0x%s"), v6);
            *v3 = this;
          }
        }
      }
    }
  }
  return this;
}

void sub_1840244BC(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c36_ZTSNSt3__110shared_ptrI9__CFArrayEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c36_ZTSNSt3__110shared_ptrI9__CFArrayEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void NWIOConnection::_setPropertyForSSLSettings(CFDictionaryRef *this, const __CFString *a2, const void *a3)
{
  const __CFDictionary *Value;
  const __CFAllocator *v7;
  __CFDictionary *MutableCopy;
  __CFDictionary *v9;

  Value = (const __CFDictionary *)CFDictionaryGetValue(this[46], &unk_1EDCFC080);
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (Value)
    MutableCopy = CFDictionaryCreateMutableCopy(v7, 0, Value);
  else
    MutableCopy = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v9 = MutableCopy;
  if (a3)
    CFDictionarySetValue(MutableCopy, a2, a3);
  else
    CFDictionaryRemoveValue(MutableCopy, a2);
  CFDictionarySetValue(this[46], &unk_1EDCFC080, v9);
  if (v9)
    CFRelease(v9);
}

void sub_1840245D4(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

_QWORD *std::shared_ptr<__CFArray const>::operator=[abi:nn180100]<__CFArray const,Deleter_CFRelease,void>(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  if (*a2)
  {
    v5 = (_QWORD *)operator new();
    v6 = *a2;
    *v5 = &off_1E14F1AC8;
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = v6;
  }
  else
  {
    v5 = 0;
  }
  *a2 = 0;
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v5;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

uint64_t ___ZN14NWIOConnection26_applyPropertyToConnectionEPK10__CFString_block_invoke(xpc_object_t *a1, size_t a2, void *a3)
{
  xpc_object_t value;
  uint64_t v6;
  uint64_t v7;
  const char *string_ptr;
  const char *v9;

  value = xpc_array_get_value(a1[4], a2);
  v6 = MEMORY[0x186DB9C40](a3);
  v7 = MEMORY[0x1E0C81390];
  if (v6 == MEMORY[0x1E0C81390] && MEMORY[0x186DB9C40](value) == v7)
  {
    string_ptr = xpc_string_get_string_ptr(a3);
    if (strncmp(string_ptr, "Persistent", 0x20uLL)
      || (v9 = xpc_string_get_string_ptr(value), strncmp(v9, "Persistent", 0x20uLL)))
    {
      xpc_array_append_value(a1[5], a3);
      xpc_array_append_value(a1[6], value);
    }
  }
  return 1;
}

void ___ZN14NWIOConnection26_applyPropertyToConnectionEPK10__CFString_block_invoke_117(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

uint64_t NWIOConnection::_toDiagnosticLog(NSObject **a1, uint64_t a2)
{
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;

  v4 = a1[43];
  if (v4 && nw_endpoint_get_type(v4) == nw_endpoint_type_address)
    nw_endpoint_get_description();
  v5 = a1[44];
  if (v5 && nw_endpoint_get_type(v5) == nw_endpoint_type_address)
    nw_endpoint_get_description();
  v6 = a1[38];
  if (v6 && nw_endpoint_get_type(v6) == nw_endpoint_type_host)
    nw_endpoint_get_hostname(a1[38]);
  return (*(uint64_t (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)a2 + 72))(a2, "Connection", CFSTR("{ conn (%llu), local %s => peer %s %s }"));
}

void ___ZN14NWIOConnection52_applyPropertyToConnection_EventHandlerAdaptiveWriteEU13block_pointerFvvE_block_invoke_2(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2)
        NWIOConnection::_handleEvent_AdaptiveWriteTimeout((NWIOConnection *)v5);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1840248D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void NWIOConnection::_handleEvent_AdaptiveWriteTimeout(NWIOConnection *this)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  CFStreamError v7;

  v6 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *((_QWORD *)this + 36);
    v4 = 134217984;
    v5 = v3;
    _os_log_impl(&dword_183ECA000, v2, OS_LOG_TYPE_DEFAULT, "Connection %llu: encountered write timeout event", (uint8_t *)&v4, 0xCu);
  }
  v7.domain = 4;
  *(_QWORD *)&v7.error = 4294965196;
  NWIOConnection::_handleTimeout(this, v7);
}

void NWIOConnection::_handleTimeout(NWIOConnection *this, CFStreamError a2)
{
  uint64_t v2;
  _BOOL4 v4;
  _BOOL4 v5;
  CFIndex domain;
  uint64_t error;
  NSObject *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  CFIndex v13;
  __int16 v14;
  int v15;
  uint64_t v16;
  CFStreamError v17;

  v2 = *(_QWORD *)&a2.error;
  v16 = *MEMORY[0x1E0C80C00];
  v4 = a2.domain == 0;
  v5 = a2.error == 0;
  if (v4 && v5)
    domain = 1;
  else
    domain = a2.domain;
  if (v4 && v5)
    error = 60;
  else
    error = a2.error;
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v8 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    v9 = *((_QWORD *)this + 36);
    v10 = 134218496;
    v11 = v9;
    v12 = 2048;
    v13 = domain;
    v14 = 1024;
    v15 = error;
    _os_log_error_impl(&dword_183ECA000, v8, OS_LOG_TYPE_ERROR, "Connection %llu: timed out with error(%ld:%d)", (uint8_t *)&v10, 0x1Cu);
  }
  if (*((_QWORD *)this + 34))
  {
    *(_QWORD *)&v17.error = v2 & 0xFFFFFFFF00000000 | error;
    v17.domain = domain;
    NWIOConnection::_handleError(this, v17);
    NWIOConnection::_cleanupConnection((CFMutableDictionaryRef *)this, 0);
  }
}

uint64_t ___ZN14NWIOConnection52_applyPropertyToConnection_EventHandlerAdaptiveWriteEU13block_pointerFvvE_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 4026;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN14NWIOConnection51_applyPropertyToConnection_EventHandlerAdaptiveReadEU13block_pointerFvvE_block_invoke_2(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2)
        NWIOConnection::_handleEvent_AdaptiveReadTimeout((NWIOConnection *)v5);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_184024C04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void NWIOConnection::_handleEvent_AdaptiveReadTimeout(NWIOConnection *this)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  CFStreamError v7;

  v6 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *((_QWORD *)this + 36);
    v4 = 134217984;
    v5 = v3;
    _os_log_impl(&dword_183ECA000, v2, OS_LOG_TYPE_DEFAULT, "Connection %llu: encountered read timeout event", (uint8_t *)&v4, 0xCu);
  }
  v7.domain = 4;
  *(_QWORD *)&v7.error = 4294965195;
  NWIOConnection::_handleTimeout(this, v7);
}

uint64_t ___ZN14NWIOConnection51_applyPropertyToConnection_EventHandlerAdaptiveReadEU13block_pointerFvvE_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 3984;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN14NWIOConnection57_applyPropertyToConnection_EventHandlerExcessiveKeepaliveEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2)
        NWIOConnection::_handleEvent_ExcessiveKeepalive((NWIOConnection *)v5);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_184024DF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::_handleEvent_ExcessiveKeepalive(NWIOConnection *this)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t result;
  int v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *((_QWORD *)this + 36);
    v5 = 134217984;
    v6 = v3;
    _os_log_impl(&dword_183ECA000, v2, OS_LOG_TYPE_DEFAULT, "Connection %llu: encountered excessive keepalive event", (uint8_t *)&v5, 0xCu);
  }
  result = *((_QWORD *)this + 79);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD))(result + 16))(result, 0);
  return result;
}

void ___ZN14NWIOConnection52_applyPropertyToConnection_EventHandlerLowThroughputEU13block_pointerFvyEb_block_invoke(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      v6 = v5;
      v7 = *(_QWORD *)(a1 + 32);
      if (v7 && (*(_WORD *)(v7 + 248) & 0x60) == 0 && (*(_DWORD *)(v7 + 136) - 5) >= 2)
        NWIOConnection::_handleEvent_LowThroughput((NWIOConnection *)v7, a2);
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void sub_184024F9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::_handleEvent_LowThroughput(NWIOConnection *this, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t result;
  int v7;
  uint64_t v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v4 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *((_QWORD *)this + 36);
    v7 = 134218240;
    v8 = v5;
    v9 = 2048;
    v10 = a2;
    _os_log_impl(&dword_183ECA000, v4, OS_LOG_TYPE_DEFAULT, "Connection %llu: encountered low throughput event %llu", (uint8_t *)&v7, 0x16u);
  }
  result = *((_QWORD *)this + 80);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD))(result + 16))(result, 0);
  return result;
}

void ___ZN14NWIOConnection14_watchdogTouchEb_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  CFStreamError v8;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 3)
      {
        v8.domain = 4;
        *(_QWORD *)&v8.error = 4294965192;
        NWIOConnection::_handleTimeout((NWIOConnection *)v5, v8);
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_184025150(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14NWIOConnection4openEv_block_invoke(uint64_t a1)
{
  return NWIOConnection::_signalEstablished(*(NWIOConnection **)(a1 + 32));
}

void ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_43(uint64_t a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_weak_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;

  v2 = *(_QWORD *)(a1 + 32);
  nw_quic_connection_set_idle_timeout();
  nw_quic_connection_set_initial_max_streams_bidirectional();
  nw_quic_connection_set_initial_max_streams_unidirectional();
  if (CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 368), &unk_1EDCF9728))
    nw_quic_connection_set_enable_l4s();
  v3 = *(std::__shared_weak_count **)(a1 + 48);
  v6 = v3;
  if (v3)
  {
    p_shared_weak_owners = (unint64_t *)&v3->__shared_weak_owners_;
    do
      v5 = __ldxr(p_shared_weak_owners);
    while (__stxr(v5 + 1, p_shared_weak_owners));
  }
  nw_quic_connection_set_max_streams_update_block();
  nw_quic_connection_set_keepalive_count();
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
}

void sub_18402526C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14)
    std::__shared_weak_count::__release_weak(a14);
  _Unwind_Resume(exception_object);
}

void ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_48(uint64_t a1, NSObject *a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  const __CFBoolean *Value;
  int v9;
  int v10;
  _BOOL4 v11;
  __int16 v12;
  const void *v13;
  CFTypeRef *v14;
  const __CFBoolean *v15;
  BOOL v16;
  const void *v17;
  const void *v18;
  CFTypeID v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  int valuePtr;
  uint64_t v23;
  std::__shared_weak_count *v24;

  v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    v5 = std::__shared_weak_count::lock(v3);
    v24 = v5;
    if (v5)
    {
      v6 = v5;
      v7 = *(_QWORD *)(a1 + 40);
      v23 = v7;
      if (v7)
      {
        Value = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(v7 + 368), &unk_1EDCF9F40);
        if (Value)
        {
          v9 = CFBooleanGetValue(Value);
          v10 = *(_WORD *)(v7 + 248) & 0xFEFF | (*(unsigned __int8 *)(v7 + 250) << 16);
          v11 = (v9 != 0) & ((unsigned __int16)(*(_WORD *)(v7 + 248) & 0x200) >> 9);
          if (v11)
            v12 = 256;
          else
            v12 = 0;
          *(_BYTE *)(v7 + 250) = BYTE2(v10);
          *(_WORD *)(v7 + 248) = v10 | v12;
          nw_tcp_options_set_enable_fast_open(a2, v11);
        }
        if (CFDictionaryGetValue(*(CFDictionaryRef *)(v7 + 368), &unk_1EDCFA758))
          nw_tcp_options_set_connection_timeout(a2, 0xAu);
        v13 = CFDictionaryGetValue(*(CFDictionaryRef *)(v7 + 368), &unk_1EDCF9728);
        v14 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
        if (v13)
          nw_tcp_options_set_enable_l4s();
        v15 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(v7 + 368), &unk_1EDCFB1A0);
        if (v15)
        {
          v16 = CFBooleanGetValue(v15) != 0;
          nw_tcp_options_set_no_delay(a2, v16);
        }
        v17 = CFDictionaryGetValue(*(CFDictionaryRef *)(v7 + 368), &unk_1EDCFA988);
        v18 = v17;
        if (v17)
        {
          if (!CFEqual(v17, *v14))
          {
            v19 = CFGetTypeID(v18);
            if (v19 == CFNumberGetTypeID())
            {
              valuePtr = 0;
              CFNumberGetValue((CFNumberRef)v18, kCFNumberSInt32Type, &valuePtr);
            }
          }
          nw_tcp_options_set_enable_background_traffic_management();
        }
      }
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v21 = __ldaxr(p_shared_owners);
      while (__stlxr(v21 - 1, p_shared_owners));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void sub_184025470(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_49(uint64_t a1)
{
  id v2;

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  v2 = (id)nw_quic_connection_copy_sec_protocol_options();
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

uint64_t ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_50(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_2_52(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  NSObject *v4;
  const void *Value;
  const __CFString *v6;
  __CFString *v7;
  unint64_t *p_info;
  const __CFNumber *v9;
  void *v10;
  unint64_t v11;
  unint64_t v12;
  void *v13;
  uint64_t v14;
  const void *v15;
  const void *v16;
  CFTypeID v17;
  uint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  NSObject *v23;
  nw_connection_t v24;
  _QWORD *v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  uint64_t v31;
  unint64_t *p_shared_weak_owners;
  unint64_t v33;
  NSObject *v34;
  std::__shared_weak_count *v35;
  unint64_t *p_shared_owners;
  unint64_t v37;
  uint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  NSObject *v47;
  unint64_t *v48;
  unint64_t v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t *v52;
  unint64_t v53;
  unint64_t *v54;
  unint64_t v55;
  unint64_t *v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  std::__shared_weak_count *v64;
  unint64_t *v65;
  unint64_t v66;
  const __CFString *v67[2];
  _QWORD v68[5];
  std::__shared_weak_count *v69;
  _QWORD v70[5];
  std::__shared_weak_count *v71;
  _QWORD v72[5];
  std::__shared_weak_count *v73;
  _QWORD v74[5];
  std::__shared_weak_count *v75;
  _QWORD v76[5];
  std::__shared_weak_count *v77;
  uint64_t v78;
  uint64_t v79;
  void (*v80)(uint64_t, uint64_t);
  void *v81;
  uint64_t v82;
  std::__shared_weak_count *v83;
  uint64_t v84;
  uint64_t v85;
  void (*v86)(uint64_t);
  void *v87;
  uint64_t v88;
  std::__shared_weak_count *v89;
  _QWORD valuePtr[5];
  std::__shared_weak_count *v91;
  uint64_t handler[6];
  std::__shared_weak_count *v93;
  __int128 v94;
  uint64_t v95;
  __n128 (*v96)(__n128 *, __n128 *);
  uint64_t (*v97)(uint64_t);
  const char *v98;
  NSObject *v99;
  std::__shared_weak_count *v100;
  CFStreamError v101;

  v1 = *(_QWORD *)(a1 + 48);
  if ((*(_WORD *)(v1 + 248) & 0x60) == 0 && (*(_DWORD *)(v1 + 136) - 5) >= 3)
  {
    v3 = *(_QWORD *)(a1 + 40);
    v4 = nw_retain(*(void **)(v3 + 304));
    if (*(_BYTE *)(a1 + 64))
    {
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 368), &unk_1EDCF99C8);
      if (Value)
        v6 = (const __CFString *)CFRetain(Value);
      else
        v6 = 0;
      *(_QWORD *)&v94 = v6;
      v7 = (__CFString *)operator new();
      v7->info = 0;
      p_info = (unint64_t *)&v7->info;
      v7->isa = &off_1E14F19E8;
      v7->data = 0;
      v7->length = (uint64_t)v6;
      *((_QWORD *)&v94 + 1) = v7;
      v9 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 368), &unk_1EDCF9A00);
      LODWORD(valuePtr[0]) = 0;
      v10 = (void *)nw_protocol_copy_quic_connection_definition();
      if (v6 && v9 && CFNumberGetValue(v9, kCFNumberSInt32Type, valuePtr) && SLODWORD(valuePtr[0]) >= 1)
      {
        v67[0] = v6;
        v67[1] = v7;
        do
          v11 = __ldxr(p_info);
        while (__stxr(v11 + 1, p_info));
        NWIOConnection::_createEndpoint(handler, (NWIOConnection *)v3, v67);
        do
          v12 = __ldaxr(p_info);
        while (__stlxr(v12 - 1, p_info));
        if (!v12)
        {
          (*((void (**)(__CFString *))v7->isa + 2))(v7);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v7);
        }
        v13 = (void *)handler[0];
        nw_endpoint_add_alternative();
        v14 = *(_QWORD *)(v3 + 200);
        if (v14)
          *(_QWORD *)(v14 + 128) = 3;
        if (v13)
          nw_release(v13);
      }
      else
      {
        v15 = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 368), &unk_1EDCF92C8);
        v16 = v15;
        if (!v15)
          goto LABEL_26;
        v17 = CFGetTypeID(v15);
        if (v17 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          LOWORD(handler[0]) = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)handler, 2u);
        }
        if ((const void *)*MEMORY[0x1E0C9AE50] == v16)
        {
          v18 = 4;
        }
        else
        {
LABEL_26:
          nw_endpoint_add_alternative();
          v18 = 2;
        }
        v19 = *(_QWORD *)(v3 + 200);
        if (v19)
          *(_QWORD *)(v19 + 128) = v18;
      }
      if (v10)
        nw_release(v10);
      v20 = (std::__shared_weak_count *)*((_QWORD *)&v94 + 1);
      if (*((_QWORD *)&v94 + 1))
      {
        v21 = (unint64_t *)(*((_QWORD *)&v94 + 1) + 8);
        do
          v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
    }
    v23 = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 368), &unk_1EDCF9760);
    if (!v23)
      v23 = v4;
    v24 = nw_connection_create(v23, *(nw_parameters_t *)(v3 + 296));
    *(_QWORD *)&v94 = v24;
    v25 = (_QWORD *)operator new();
    *v25 = &off_1E14F1CC0;
    v25[1] = 0;
    v25[2] = 0;
    v25[3] = v24;
    *((_QWORD *)&v94 + 1) = v25;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v3 + 272, &v94);
    v26 = (std::__shared_weak_count *)*((_QWORD *)&v94 + 1);
    if (*((_QWORD *)&v94 + 1))
    {
      v27 = (unint64_t *)(*((_QWORD *)&v94 + 1) + 8);
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    if (*(_QWORD *)(v3 + 272))
    {
      *(_QWORD *)(v3 + 288) = nw_connection_get_id();
      TransportConnection::_flushPendingTaskAssociations((TransportConnection *)v3);
      v29 = *(_QWORD *)(a1 + 48);
      v31 = *(_QWORD *)(v29 + 256);
      v30 = *(std::__shared_weak_count **)(v29 + 264);
      if (v30)
      {
        p_shared_weak_owners = (unint64_t *)&v30->__shared_weak_owners_;
        do
          v33 = __ldxr(p_shared_weak_owners);
        while (__stxr(v33 + 1, p_shared_weak_owners));
      }
      nw_connection_set_queue(*(nw_connection_t *)(v29 + 272), *(dispatch_queue_t *)(v29 + 120));
      *(_QWORD *)&v94 = 0;
      *((_QWORD *)&v94 + 1) = &v94;
      v95 = 0x4012000000;
      v96 = __Block_byref_object_copy__53;
      v97 = __Block_byref_object_dispose__54;
      v34 = *(NSObject **)(v29 + 272);
      v35 = *(std::__shared_weak_count **)(v29 + 280);
      v99 = v34;
      v100 = v35;
      if (v35)
      {
        p_shared_owners = (unint64_t *)&v35->__shared_owners_;
        do
          v37 = __ldxr(p_shared_owners);
        while (__stxr(v37 + 1, p_shared_owners));
        v34 = *(NSObject **)(v29 + 272);
      }
      v38 = MEMORY[0x1E0C809B0];
      handler[0] = MEMORY[0x1E0C809B0];
      handler[1] = 3321888768;
      handler[2] = (uint64_t)___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke;
      handler[3] = (uint64_t)&unk_1E14F3238;
      handler[5] = v31;
      v93 = v30;
      if (v30)
      {
        v39 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          v40 = __ldxr(v39);
        while (__stxr(v40 + 1, v39));
      }
      handler[4] = (uint64_t)&v94;
      nw_connection_set_state_changed_handler(v34, handler);
      valuePtr[0] = v38;
      valuePtr[1] = 3321888768;
      valuePtr[2] = ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_57;
      valuePtr[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e5_v8__0l;
      valuePtr[4] = v31;
      v91 = v30;
      if (v30)
      {
        v41 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          v42 = __ldxr(v41);
        while (__stxr(v42 + 1, v41));
      }
      nw_connection_set_read_close_handler();
      v84 = v38;
      v85 = 3321888768;
      v86 = ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_59;
      v87 = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e5_v8__0l;
      v88 = v31;
      v89 = v30;
      if (v30)
      {
        v43 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          v44 = __ldxr(v43);
        while (__stxr(v44 + 1, v43));
      }
      nw_connection_set_write_close_handler();
      v78 = v38;
      v79 = 3321888768;
      v80 = ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_2;
      v81 = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e8_v12__0i8l;
      v82 = v31;
      v83 = v30;
      if (v30)
      {
        v45 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          v46 = __ldxr(v45);
        while (__stxr(v46 + 1, v45));
      }
      nw_connection_set_alternate_path_state_handler();
      v47 = *(NSObject **)(v29 + 272);
      v76[0] = v38;
      v76[1] = 3321888768;
      v76[2] = ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_62;
      v76[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e8_v12__0B8l;
      v76[4] = v31;
      v77 = v30;
      if (v30)
      {
        v48 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          v49 = __ldxr(v48);
        while (__stxr(v49 + 1, v48));
      }
      nw_connection_set_viability_changed_handler(v47, v76);
      v74[0] = v38;
      v74[1] = 3321888768;
      v74[2] = ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_65;
      v74[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e8_v16__0Q8l;
      v74[4] = v31;
      v75 = v30;
      if (v30)
      {
        v50 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          v51 = __ldxr(v50);
        while (__stxr(v51 + 1, v50));
      }
      NWIOConnection::_applyPropertyToConnection_EventHandlerLowThroughput(v29, (uint64_t)v74, 0);
      v72[0] = v38;
      v72[1] = 3321888768;
      v72[2] = ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_68;
      v72[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e5_v8__0l;
      v72[4] = v31;
      v73 = v30;
      if (v30)
      {
        v52 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          v53 = __ldxr(v52);
        while (__stxr(v53 + 1, v52));
      }
      NWIOConnection::_applyPropertyToConnection_EventHandlerExcessiveKeepalive(v29, (uint64_t)v72);
      v70[0] = v38;
      v70[1] = 3321888768;
      v70[2] = ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_2_69;
      v70[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e5_v8__0l;
      v70[4] = v31;
      v71 = v30;
      if (v30)
      {
        v54 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          v55 = __ldxr(v54);
        while (__stxr(v55 + 1, v54));
      }
      NWIOConnection::_applyPropertyToConnection_EventHandlerAdaptiveRead(v29, (uint64_t)v70);
      v68[0] = v38;
      v68[1] = 3321888768;
      v68[2] = ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_3;
      v68[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e5_v8__0l;
      v68[4] = v31;
      v69 = v30;
      if (v30)
      {
        v56 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          v57 = __ldxr(v56);
        while (__stxr(v57 + 1, v56));
      }
      NWIOConnection::_applyPropertyToConnection_EventHandlerAdaptiveWrite(v29, (uint64_t)v68);
      if (v69)
        std::__shared_weak_count::__release_weak(v69);
      if (v71)
        std::__shared_weak_count::__release_weak(v71);
      if (v73)
        std::__shared_weak_count::__release_weak(v73);
      if (v75)
        std::__shared_weak_count::__release_weak(v75);
      if (v77)
        std::__shared_weak_count::__release_weak(v77);
      if (v83)
        std::__shared_weak_count::__release_weak(v83);
      if (v89)
        std::__shared_weak_count::__release_weak(v89);
      if (v91)
        std::__shared_weak_count::__release_weak(v91);
      if (v93)
        std::__shared_weak_count::__release_weak(v93);
      _Block_object_dispose(&v94, 8);
      v64 = v100;
      if (v100)
      {
        v65 = (unint64_t *)&v100->__shared_owners_;
        do
          v66 = __ldaxr(v65);
        while (__stlxr(v66 - 1, v65));
        if (!v66)
        {
          ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
          std::__shared_weak_count::__release_weak(v64);
        }
      }
      if (v30)
        std::__shared_weak_count::__release_weak(v30);
      (*(void (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), v58, v59, v60, v61, v62, v63);
    }
    else
    {
      v101.domain = 1;
      *(_QWORD *)&v101.error = 22;
      NWIOConnection::_handleError((NWIOConnection *)v3, v101);
    }
    if (v4)
      nw_release(v4);
  }
}

void sub_184025C38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,std::__shared_weak_count *a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,std::__shared_weak_count *a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,std::__shared_weak_count *a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,std::__shared_weak_count *a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,std::__shared_weak_count *a58)
{
  void *v58;
  void *v59;
  void *v60;
  uint64_t v61;

  if (v60)
    nw_release(v60);
  if (v59)
    nw_release(v59);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v61 - 160);
  if (v58)
    nw_release(v58);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 56) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

__n128 __Block_byref_object_copy__53(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__54(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_57(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  __int128 buf;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v6 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          v7 = *(_QWORD *)(v5 + 288);
          LODWORD(buf) = 134217984;
          *(_QWORD *)((char *)&buf + 4) = v7;
          _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, "Connection %llu: read-side closed", (uint8_t *)&buf, 0xCu);
        }
        v8 = *(_QWORD *)(v5 + 160);
        v9 = *(std::__shared_weak_count **)(v5 + 168);
        *(_QWORD *)&buf = v8;
        *((_QWORD *)&buf + 1) = v9;
        if (v9)
        {
          p_shared_owners = (unint64_t *)&v9->__shared_owners_;
          do
            v11 = __ldxr(p_shared_owners);
          while (__stxr(v11 + 1, p_shared_owners));
        }
        if (v8)
          (*(void (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8);
        else
          NWIOConnection::_handleEvent_Disconnected(v5, 0);
        if (v9)
        {
          v12 = (unint64_t *)&v9->__shared_owners_;
          do
            v13 = __ldaxr(v12);
          while (__stlxr(v13 - 1, v12));
          if (!v13)
          {
            ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
            std::__shared_weak_count::__release_weak(v9);
          }
        }
      }
      v14 = (unint64_t *)&v4->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_184025FAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_59(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  __int128 buf;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v6 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          v7 = *(_QWORD *)(v5 + 288);
          LODWORD(buf) = 134217984;
          *(_QWORD *)((char *)&buf + 4) = v7;
          _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, "Connection %llu: write-side closed", (uint8_t *)&buf, 0xCu);
        }
        v8 = *(_QWORD *)(v5 + 160);
        v9 = *(std::__shared_weak_count **)(v5 + 168);
        *(_QWORD *)&buf = v8;
        *((_QWORD *)&buf + 1) = v9;
        if (v9)
        {
          p_shared_owners = (unint64_t *)&v9->__shared_owners_;
          do
            v11 = __ldxr(p_shared_owners);
          while (__stxr(v11 + 1, p_shared_owners));
        }
        if (v8)
          (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
        else
          NWIOConnection::_handleEvent_Disconnected(v5, 0);
        if (v9)
        {
          v12 = (unint64_t *)&v9->__shared_owners_;
          do
            v13 = __ldaxr(v12);
          while (__stlxr(v13 - 1, v12));
          if (!v13)
          {
            ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
            std::__shared_weak_count::__release_weak(v9);
          }
        }
      }
      v14 = (unint64_t *)&v4->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1840261A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_2(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t v14;
  char v15;
  unint64_t *v16;
  unint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  _BYTE buf[18];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      v6 = v5;
      v7 = *(_QWORD *)(a1 + 32);
      if (!v7 || (*(_WORD *)(v7 + 248) & 0x60) != 0 || (*(_DWORD *)(v7 + 136) - 5) < 2)
        goto LABEL_35;
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v8 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *(_QWORD *)(v7 + 288);
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = v9;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = a2;
        _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_DEFAULT, "Connection %llu: received advisory(%d)", buf, 0x12u);
      }
      if ((nw_connection_uses_multipath() & 1) != 0)
        goto LABEL_35;
      v10 = *(_QWORD *)(v7 + 160);
      v11 = *(std::__shared_weak_count **)(v7 + 168);
      *(_QWORD *)buf = v10;
      *(_QWORD *)&buf[8] = v11;
      if (v11)
      {
        p_shared_owners = (unint64_t *)&v11->__shared_owners_;
        do
          v13 = __ldxr(p_shared_owners);
        while (__stxr(v13 + 1, p_shared_owners));
        if (!v10)
        {
          do
            v14 = __ldaxr(p_shared_owners);
          while (__stlxr(v14 - 1, p_shared_owners));
          if (!v14)
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
          goto LABEL_25;
        }
      }
      else if (!v10)
      {
LABEL_25:
        if ((a2 & 0xFFFFFFFE) == 2)
        {
          v18 = *(unsigned __int16 *)(v7 + 248);
          v19 = v18 | (*(unsigned __int8 *)(v7 + 250) << 16);
          if ((v18 & 0x80) == 0)
          {
            *(_BYTE *)(v7 + 250) = BYTE2(v19);
            *(_WORD *)(v7 + 248) = v19 | 0x80;
            NotificationStation::notifyPropertyChanged((NotificationStation *)(v7 + 16), CFSTR("__kCFStreamPropertyDoNotReuse"), (const void *)*MEMORY[0x1E0C9AE50]);
          }
        }
        else if ((_DWORD)a2 == 1)
        {
          v20 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_102, 2);
          v24 = v20;
          if (v20
            && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v20 + 16))(v20, "Better Route Detected", 0))
          {
            NWIOConnection::_toDiagnosticLog((NSObject **)v7, v24);
            (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
          }
          v25 = *(_QWORD *)(v7 + 656);
          if (v25)
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v25 + 16))(v25, v21, v22, v23);
          NWIOConnection::_terminateConnectionIfAppropriate((CFDictionaryRef *)v7, 1);
        }
LABEL_35:
        v26 = (unint64_t *)&v6->__shared_owners_;
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
        return;
      }
      v15 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v10 + 48))(v10, a2);
      if (v11)
      {
        v16 = (unint64_t *)&v11->__shared_owners_;
        do
          v17 = __ldaxr(v16);
        while (__stlxr(v17 - 1, v16));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }
      if ((v15 & 1) != 0)
        goto LABEL_35;
      goto LABEL_25;
    }
  }
}

void sub_1840264BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_62(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      v6 = v5;
      v7 = *(_QWORD *)(a1 + 32);
      if (v7 && (*(_WORD *)(v7 + 248) & 0x60) == 0 && (*(_DWORD *)(v7 + 136) - 5) >= 2)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v8 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          v9 = *(_QWORD *)(v7 + 288);
          if ((_DWORD)a2)
            v10 = 89;
          else
            v10 = 78;
          *(_DWORD *)buf = 134218240;
          v17 = v9;
          v18 = 1024;
          v19 = v10;
          _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_DEFAULT, "Connection %llu: received viability advisory(%c)", buf, 0x12u);
        }
        v11 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_104, 2);
        v12 = v11;
        if (v11
          && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v11 + 16))(v11, "Connection Viability Changed", 0))
        {
          NWIOConnection::_toDiagnosticLog((NSObject **)v7, v12);
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v12 + 72))(v12, "Viable", CFSTR("%s"));
          (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
        }
        v13 = *(_QWORD *)(v7 + 648);
        if (v13)
          (*(void (**)(uint64_t, _QWORD, uint64_t))(v13 + 16))(v13, 0, a2);
        if ((a2 & 1) == 0)
          NWIOConnection::_terminateConnectionIfAppropriate((CFDictionaryRef *)v7, 0);
      }
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v15 = __ldaxr(p_shared_owners);
      while (__stlxr(v15 - 1, p_shared_owners));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void sub_184026720(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_65(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      v6 = v5;
      v7 = *(_QWORD *)(a1 + 32);
      if (v7 && (*(_WORD *)(v7 + 248) & 0x60) == 0 && (*(_DWORD *)(v7 + 136) - 5) >= 2)
        NWIOConnection::_handleEvent_LowThroughput((NWIOConnection *)v7, a2);
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void sub_1840267EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_68(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2)
        NWIOConnection::_handleEvent_ExcessiveKeepalive((NWIOConnection *)v5);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1840268A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_2_69(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2)
        NWIOConnection::_handleEvent_AdaptiveReadTimeout((NWIOConnection *)v5);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_18402695C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_3(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2)
        NWIOConnection::_handleEvent_AdaptiveWriteTimeout((NWIOConnection *)v5);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_184026A14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void NWIOConnection::_terminateConnectionIfAppropriate(CFDictionaryRef *this, int a2)
{
  const void *Value;
  const void *v5;
  CFTypeID v6;
  BOOL v7;
  CFDictionaryRef v8;
  _WORD *v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  CFDictionaryRef v16;
  const void **v17;
  int v18;
  CFDictionaryRef v19;
  uint64_t v20;
  CFStreamError v21;

  v20 = *MEMORY[0x1E0C80C00];
  Value = CFDictionaryGetValue(this[46], &unk_1EDCFB7F8);
  if (!Value)
    goto LABEL_8;
  v5 = Value;
  v6 = CFGetTypeID(Value);
  if (v6 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(v18) = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&v18, 2u);
  }
  if ((const void *)*MEMORY[0x1E0C9AE50] == v5)
  {
LABEL_8:
    v8 = this[81];
    v7 = v8 == 0;
    if ((a2 & 1) == 0)
    {
      if (v8)
        return;
      v9 = this + 31;
      v10 = *((_WORD *)this + 124);
      v13 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_87, 2);
      if (v13)
      {
        v14 = v13;
        if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v13 + 16))(v13, "_networkReachabilityChanged", 0))
        {
          NWIOConnection::_toDiagnosticLog((NSObject **)this, v14);
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v14 + 72))(v14, "conn", CFSTR("issuing error to ECONNABORTED"));
          (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
        }
      }
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v15 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v16 = this[36];
        v18 = 134217984;
        v19 = v16;
        _os_log_impl(&dword_183ECA000, v15, OS_LOG_TYPE_DEFAULT, "Connection %llu: reachability changed, issuing ECONNABORTED", (uint8_t *)&v18, 0xCu);
      }
      *((_WORD *)this + 124) |= 0x80u;
      v21.domain = 1;
      *(_QWORD *)&v21.error = 53;
      NWIOConnection::_handleError((NWIOConnection *)this, v21);
      goto LABEL_27;
    }
  }
  else
  {
    if (!a2)
      return;
    v7 = 0;
  }
  if (nw_connection_uses_multipath() || !v7)
    return;
  v9 = this + 31;
  v10 = *((_WORD *)this + 124);
  v11 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_82, 2);
  if (v11)
  {
    v12 = v11;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v11 + 16))(v11, "_networkReachabilityChanged", 0))
    {
      NWIOConnection::_toDiagnosticLog((NSObject **)this, v12);
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v12 + 72))(v12, "conn", CFSTR("keeping alive"));
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
    }
  }
  if (!CFDictionaryGetValue(this[46], &unk_1EDCFB830)
    && !CFDictionaryGetValue(this[46], &unk_1EDCFB9F0)
    && !CFDictionaryGetValue(this[46], &unk_1EDCFBA28))
  {
    *v9 |= 0x80u;
  }
LABEL_27:
  if (((((v10 & 0x80) == 0) ^ ((*v9 & 0x80u) >> 7)) & 1) == 0)
  {
    if ((*v9 & 0x80) != 0)
      v17 = (const void **)MEMORY[0x1E0C9AE50];
    else
      v17 = (const void **)MEMORY[0x1E0C9AE40];
    NotificationStation::notifyPropertyChanged((NotificationStation *)(this + 2), CFSTR("__kCFStreamPropertyDoNotReuse"), *v17);
  }
}

uint64_t ___ZN14NWIOConnection33_terminateConnectionIfAppropriateEb_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 2306;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN14NWIOConnection33_terminateConnectionIfAppropriateEb_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 2294;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN14NWIOConnection29_handleEvent_ViabilityChangedEb_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 2913;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN14NWIOConnection23_handleEvent_BetterPathE36nw_connection_alternate_path_state_t_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 2895;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN14NWIOConnection25_handleEvent_DisconnectedEPU22objcproto11OS_nw_error8NSObject_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 2784;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void NWIOConnection::_startTLS(NWIOConnection *this)
{
  int v1;
  NSObject *options;
  NSObject *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v1 = *((unsigned __int16 *)this + 124) | (*((unsigned __int8 *)this + 250) << 16);
  if ((*((_WORD *)this + 124) & 0xA00) == 0x200 && (*((_DWORD *)this + 34) - 3) <= 1)
  {
    *((_BYTE *)this + 250) = BYTE2(v1);
    *((_WORD *)this + 124) = v1 | 0x800;
    options = nw_tls_create_options();
    NWIOConnection::_tlsConfigure((uint64_t)this, options);
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v4 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *((_QWORD *)this + 36);
      v6 = 134217984;
      v7 = v5;
      _os_log_impl(&dword_183ECA000, v4, OS_LOG_TYPE_DEFAULT, "Connection %llu: enabling TLS", (uint8_t *)&v6, 0xCu);
    }
    if (nw_settings_get_signposts_enabled())
      kdebug_trace();
    nw_connection_append_and_start_application_protocol();
    if (options)
      nw_release(options);
  }
}

void sub_1840270C0(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    nw_release(v1);
  _Unwind_Resume(exception_object);
}

void ___ZN14NWIOConnection13_tlsConfigureEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_136(uint64_t a1, std::__shared_weak_count_vtbl *a2, uint64_t a3)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  NSObject *v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  TLSCallbackQueue **v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *p_shared_weak_owners;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *shared_weak_owners;
  unint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  uint64_t shared_owners;
  std::__shared_weak_count *v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  TLSCallbackQueue *v59;
  unint64_t *v60;
  unint64_t v61;
  uint64_t *v62;
  _QWORD *v63;
  unint64_t *v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t *v67;
  unint64_t v68;
  unint64_t *v69;
  unint64_t v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  uint64_t v74;
  std::__shared_weak_count *v75;
  std::__shared_weak_count *v76;
  std::__shared_weak_count *v77;
  std::__shared_weak_count *v78;
  std::__shared_weak_count *v79;
  _QWORD aBlock[6];
  std::__shared_weak_count *v81;
  uint64_t v82;
  std::__shared_weak_count *v83;
  __int128 buf;
  void (*v85)(_QWORD *, uint64_t);
  void *v86;
  uint64_t v87;
  std::__shared_weak_count *v88;
  uint64_t v89;
  std::__shared_weak_count *v90;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v5)
  {
    v7 = 0;
    goto LABEL_8;
  }
  v7 = std::__shared_weak_count::lock(v5);
  v77 = v7;
  if (!v7 || (v8 = *(_QWORD *)(a1 + 32)) == 0)
  {
LABEL_8:
    (*(void (**)(uint64_t, _QWORD))(a3 + 16))(a3, 0);
    if (!v7)
      return;
    goto LABEL_9;
  }
  if ((*(_WORD *)(v8 + 248) & 0x60) != 0 || (*(_DWORD *)(v8 + 136) - 5) <= 2)
  {
    (*(void (**)(uint64_t, _QWORD))(a3 + 16))(a3, 0);
LABEL_9:
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    return;
  }
  sec_retain(a2);
  v11 = (std::__shared_weak_count *)operator new();
  v11->__shared_owners_ = 0;
  v12 = (unint64_t *)&v11->__shared_owners_;
  v11->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1D68;
  v11->__shared_weak_owners_ = 0;
  v11[1].__vftable = a2;
  v76 = v11;
  v74 = (uint64_t)a2;
  v75 = v11;
  do
    v13 = __ldxr(v12);
  while (__stxr(v13 + 1, v12));
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v14 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v15 = *(_QWORD *)(v8 + 288);
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = v15;
    _os_log_impl(&dword_183ECA000, v14, OS_LOG_TYPE_DEFAULT, "Connection %llu: asked for TLS Client Certificates", (uint8_t *)&buf, 0xCu);
  }
  if ((*(_WORD *)(v8 + 248) & 0x60) != 0 || (*(_DWORD *)(v8 + 136) - 5) <= 2)
  {
    (*(void (**)(uint64_t, _QWORD))(a3 + 16))(a3, 0);
    goto LABEL_23;
  }
  NWIOConnection::_watchdogTouch((NWIOConnection *)v8, 0);
  v20 = (TLSCallbackQueue **)(v8 + 400);
  if (!*(_QWORD *)(v8 + 400))
  {
    _ZNSt3__115allocate_sharedB8nn180100I16TLSCallbackQueueNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&buf);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v8 + 400, &buf);
    v21 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
    if (*((_QWORD *)&buf + 1))
    {
      v22 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
    TLSCallbackQueue::initialize(*v20);
  }
  v24 = *(_QWORD *)(v8 + 256);
  v25 = *(std::__shared_weak_count **)(v8 + 264);
  if (v25)
  {
    p_shared_weak_owners = (unint64_t *)&v25->__shared_weak_owners_;
    do
      v27 = __ldxr(p_shared_weak_owners);
    while (__stxr(v27 + 1, p_shared_weak_owners));
    v85 = ___ZN14NWIOConnection41_tlsProcessClientCertificateRequest_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvPU26objcproto15OS_sec_identityS2_E_block_invoke;
    v86 = &__block_descriptor_64_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE_e148_v16__0___v___shared_ptr_const___CFArray______CFArray_____shared_weak_count___shared_ptr_const___CFArray______CFArray_____shared_weak_count_____qi__8l;
    v87 = v24;
    v88 = v25;
    do
      v28 = __ldxr(p_shared_weak_owners);
    while (__stxr(v28 + 1, p_shared_weak_owners));
  }
  else
  {
    v85 = ___ZN14NWIOConnection41_tlsProcessClientCertificateRequest_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvPU26objcproto15OS_sec_identityS2_E_block_invoke;
    v86 = &__block_descriptor_64_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE_e148_v16__0___v___shared_ptr_const___CFArray______CFArray_____shared_weak_count___shared_ptr_const___CFArray______CFArray_____shared_weak_count_____qi__8l;
    v87 = v24;
    v88 = 0;
  }
  v29 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
  *((_QWORD *)&buf + 1) = 3321888768;
  v89 = v74;
  v90 = v75;
  if (v75)
  {
    v30 = (unint64_t *)&v75->__shared_owners_;
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  aBlock[0] = v29;
  aBlock[1] = 3321888768;
  aBlock[2] = ___ZN14NWIOConnection41_tlsProcessClientCertificateRequest_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvPU26objcproto15OS_sec_identityS2_E_block_invoke_178;
  aBlock[3] = &unk_1E14F2F08;
  aBlock[5] = v24;
  v81 = v25;
  if (v25)
  {
    v32 = (unint64_t *)&v25->__shared_weak_owners_;
    do
      v33 = __ldxr(v32);
    while (__stxr(v33 + 1, v32));
  }
  aBlock[4] = a3;
  v34 = (std::__shared_weak_count *)operator new(0x80uLL);
  v35 = v34;
  v34->__shared_owners_ = 0;
  v36 = (unint64_t *)&v34->__shared_owners_;
  v34->__shared_weak_owners_ = 0;
  v34->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0EC0;
  v82 = v74;
  v83 = v75;
  if (v75)
  {
    v37 = (unint64_t *)&v75->__shared_owners_;
    do
      v38 = __ldxr(v37);
    while (__stxr(v38 + 1, v37));
  }
  *(_OWORD *)&v34[4].__shared_weak_owners_ = 0u;
  v34[1].__shared_owners_ = 0;
  v34[1].__shared_weak_owners_ = 0;
  *(_OWORD *)&v34[2].__shared_weak_owners_ = 0u;
  v34[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14EEA80;
  v34[4].std::__shared_count = 0u;
  v34[2].std::__shared_count = 0u;
  *(_OWORD *)&v34[3].__shared_owners_ = 0u;
  std::shared_ptr<__CFString const>::operator=[abi:nn180100](&v34[2].__shared_weak_owners_, v74, (uint64_t)v75);
  v35[3].__shared_owners_ = (uint64_t)_Block_copy(&buf);
  v39 = v35 + 1;
  v35[3].__shared_weak_owners_ = (uint64_t)_Block_copy(aBlock);
  if (v75)
  {
    v40 = (unint64_t *)&v75->__shared_owners_;
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
      std::__shared_weak_count::__release_weak(v75);
    }
  }
  v78 = v35 + 1;
  v79 = v35;
  shared_weak_owners = (std::__shared_weak_count *)v35[1].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    do
      v46 = __ldxr(v36);
    while (__stxr(v46 + 1, v36));
    v47 = (unint64_t *)&v35->__shared_weak_owners_;
    do
      v48 = __ldxr(v47);
    while (__stxr(v48 + 1, v47));
    v35[1].__shared_owners_ = (uint64_t)v39;
    v35[1].__shared_weak_owners_ = (uint64_t)v35;
    do
LABEL_73:
      v49 = __ldaxr(v36);
    while (__stlxr(v49 - 1, v36));
    if (!v49)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
    goto LABEL_76;
  }
  if (shared_weak_owners->__shared_owners_ == -1)
  {
    do
      v43 = __ldxr(v36);
    while (__stxr(v43 + 1, v36));
    v44 = (unint64_t *)&v35->__shared_weak_owners_;
    do
      v45 = __ldxr(v44);
    while (__stxr(v45 + 1, v44));
    v35[1].__shared_owners_ = (uint64_t)v39;
    v35[1].__shared_weak_owners_ = (uint64_t)v35;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
    goto LABEL_73;
  }
LABEL_76:
  v50 = (std::__shared_weak_count *)v35[1].__shared_weak_owners_;
  if (!v50 || (shared_owners = v35[1].__shared_owners_, (v52 = std::__shared_weak_count::lock(v50)) == 0))
  {
    std::__throw_bad_weak_ptr[abi:nn180100]();
    __break(1u);
    return;
  }
  v53 = v52;
  v54 = (unint64_t *)&v52->__shared_weak_owners_;
  do
    v55 = __ldxr(v54);
  while (__stxr(v55 + 1, v54));
  v56 = (std::__shared_weak_count *)v78[1].__shared_owners_;
  v78[1].__vftable = (std::__shared_weak_count_vtbl *)shared_owners;
  v78[1].__shared_owners_ = (uint64_t)v53;
  if (v56)
    std::__shared_weak_count::__release_weak(v56);
  v57 = (unint64_t *)&v53->__shared_owners_;
  do
    v58 = __ldaxr(v57);
  while (__stlxr(v58 - 1, v57));
  if (!v58)
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
  }
  v59 = *v20;
  v82 = (uint64_t)v78;
  v83 = v79;
  if (v79)
  {
    v60 = (unint64_t *)&v79->__shared_owners_;
    do
      v61 = __ldxr(v60);
    while (__stxr(v61 + 1, v60));
  }
  v62 = (uint64_t *)*((_QWORD *)v59 + 6);
  v63 = operator new(0x30uLL);
  v63[2] = 0;
  v63[3] = 0;
  v63[4] = v78;
  v63[5] = v79;
  if (v79)
  {
    v64 = (unint64_t *)&v79->__shared_owners_;
    do
      v65 = __ldxr(v64);
    while (__stxr(v65 + 1, v64));
  }
  v63[1] = v62;
  v66 = *v62;
  *v63 = *v62;
  *(_QWORD *)(v66 + 8) = v63;
  *v62 = (uint64_t)v63;
  ++v62[2];
  TLSCallbackQueue::_invokeNextCallback(v59);
  if (v79)
  {
    v67 = (unint64_t *)&v79->__shared_owners_;
    do
      v68 = __ldaxr(v67);
    while (__stlxr(v68 - 1, v67));
    if (!v68)
    {
      ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
      std::__shared_weak_count::__release_weak(v79);
    }
  }
  if (v79)
  {
    v69 = (unint64_t *)&v79->__shared_owners_;
    do
      v70 = __ldaxr(v69);
    while (__stlxr(v70 - 1, v69));
    if (!v70)
    {
      ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
      std::__shared_weak_count::__release_weak(v79);
    }
  }
  if (v81)
    std::__shared_weak_count::__release_weak(v81);
  v71 = v90;
  if (v90)
  {
    v72 = (unint64_t *)&v90->__shared_owners_;
    do
      v73 = __ldaxr(v72);
    while (__stlxr(v73 - 1, v72));
    if (!v73)
    {
      ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
      std::__shared_weak_count::__release_weak(v71);
    }
  }
  if (v88)
    std::__shared_weak_count::__release_weak(v88);
  if (v25)
    std::__shared_weak_count::__release_weak(v25);
LABEL_23:
  if (v75)
  {
    v16 = (unint64_t *)&v75->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
      std::__shared_weak_count::__release_weak(v75);
    }
  }
  if (v76)
  {
    v18 = (unint64_t *)&v76->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
      std::__shared_weak_count::__release_weak(v76);
    }
  }
  v7 = v77;
  if (v77)
    goto LABEL_9;
}

void sub_1840277C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,char a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32,uint64_t a33)
{
  std::__shared_weak_count *v33;

  if (a24)
    std::__shared_weak_count::__release_weak(a24);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a33);
  if (a32)
    std::__shared_weak_count::__release_weak(a32);
  if (v33)
    std::__shared_weak_count::__release_weak(v33);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a12);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a14);
  _Unwind_Resume(a1);
}

_QWORD **std::default_delete<std::forward_list<SSLCiphersuiteGroup>>::operator()[abi:nn180100](_QWORD **result)
{
  _QWORD *v1;
  _QWORD *v2;
  _QWORD *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (v2)
    {
      do
      {
        v3 = (_QWORD *)*v2;
        operator delete(v2);
        v2 = v3;
      }
      while (v3);
    }
    *v1 = 0;
    JUMPOUT(0x186DB748CLL);
  }
  return result;
}

void NWIOConnection::_tlsCreateIdentityFromClientCertificates(sec_identity_t *a1, CFArrayRef *a2)
{
  __SecIdentity *ValueAtIndex;
  CFIndex Count;
  CFIndex v6;
  __CFArray *Mutable;
  CFRange v8;

  *a1 = 0;
  if (*a2 && CFArrayGetCount(*a2) >= 1)
  {
    ValueAtIndex = (__SecIdentity *)CFArrayGetValueAtIndex(*a2, 0);
    Count = CFArrayGetCount(*a2);
    if (Count < 2)
    {
      Mutable = 0;
    }
    else
    {
      v6 = Count - 1;
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count - 1, MEMORY[0x1E0C9B378]);
      v8.location = 1;
      v8.length = v6;
      CFArrayAppendArray(Mutable, *a2, v8);
    }
    *a1 = sec_identity_create_with_certificates(ValueAtIndex, Mutable);
    if (Mutable)
      CFRelease(Mutable);
  }
}

void sub_1840279CC(_Unwind_Exception *exception_object)
{
  _QWORD *v1;

  *v1 = 0;
  _Unwind_Resume(exception_object);
}

void ___ZN14NWIOConnection16_tlsApplyOptionsEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN14NWIOConnection16_tlsApplyOptionsEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_2(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN14NWIOConnection16_tlsApplyOptionsEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_3(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void _ZNSt3__115allocate_sharedB8nn180100I16TLSCallbackQueueNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  std::__shared_weak_count *shared_weak_owners;
  unint64_t v9;
  unint64_t *p_shared_weak_owners;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;

  v2 = (std::__shared_weak_count *)operator new(0x60uLL);
  *(_OWORD *)&v2->__shared_owners_ = 0u;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  v2->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0BB0;
  v2[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14E8328;
  v4 = v2 + 1;
  v2[3].__vftable = 0;
  *(_OWORD *)&v2[3].__shared_owners_ = 0u;
  *(_OWORD *)&v2[1].__shared_owners_ = 0u;
  v2[2].std::__shared_count = 0u;
  LOWORD(v2[2].__shared_weak_owners_) = 0;
  v5 = (uint64_t *)operator new();
  *v5 = (uint64_t)v5;
  v5[1] = (uint64_t)v5;
  v5[2] = 0;
  std::unique_ptr<std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>>::reset[abi:nn180100]((uint64_t **)&v2[3], v5);
  v6 = (uint64_t *)operator new();
  *v6 = (uint64_t)v6;
  v6[1] = (uint64_t)v6;
  v6[2] = 0;
  std::unique_ptr<std::list<std::shared_ptr<TLSCallbackServerTrust>>>::reset[abi:nn180100]((uint64_t **)&v2[3].__shared_owners_, v6);
  v7 = (uint64_t *)operator new();
  *v7 = (uint64_t)v7;
  v7[1] = (uint64_t)v7;
  v7[2] = 0;
  std::unique_ptr<std::list<std::shared_ptr<TLSCallbackClientCertificate>>>::reset[abi:nn180100]((uint64_t **)&v2[3].__shared_weak_owners_, v7);
  *a1 = v2 + 1;
  a1[1] = v2;
  shared_weak_owners = (std::__shared_weak_count *)v2[1].__shared_weak_owners_;
  if (shared_weak_owners)
  {
    if (shared_weak_owners->__shared_owners_ != -1)
      return;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v2->__shared_weak_owners_;
    do
      v11 = __ldxr(p_shared_weak_owners);
    while (__stxr(v11 + 1, p_shared_weak_owners));
    v2[1].__shared_owners_ = (uint64_t)v4;
    v2[1].__shared_weak_owners_ = (uint64_t)v2;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  else
  {
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    v13 = (unint64_t *)&v2->__shared_weak_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
    v2[1].__shared_owners_ = (uint64_t)v4;
    v2[1].__shared_weak_owners_ = (uint64_t)v2;
  }
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_184027BF4(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  uint64_t **v2;
  uint64_t **v3;
  uint64_t **v4;
  std::__shared_weak_count *shared_owners;
  std::__shared_weak_count *shared_weak_owners;
  void *v8;

  std::unique_ptr<std::list<std::shared_ptr<TLSCallbackClientCertificate>>>::reset[abi:nn180100](v3, 0);
  std::unique_ptr<std::list<std::shared_ptr<TLSCallbackServerTrust>>>::reset[abi:nn180100](v4, 0);
  std::unique_ptr<std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>>::reset[abi:nn180100](v2, 0);
  shared_owners = (std::__shared_weak_count *)v1[2].__shared_owners_;
  if (shared_owners)
    std::__shared_weak_count::__release_weak(shared_owners);
  v1[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14E5838;
  shared_weak_owners = (std::__shared_weak_count *)v1[1].__shared_weak_owners_;
  if (shared_weak_owners)
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v8);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection41_tlsProcessClientCertificateRequest_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvPU26objcproto15OS_sec_identityS2_E_block_invoke(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  NSObject *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  CFMutableArrayRef Mutable;
  std::__shared_weak_count *v23;
  _BOOL4 v24;
  BOOL v25;
  const void *v26;
  CFTypeRef v27;
  uint64_t *v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  _QWORD *v35;
  unint64_t *v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  std::__shared_weak_count *v41;
  std::__shared_weak_count *v42;
  uint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t *v52;
  unint64_t v53;
  NSObject *v54;
  uint64_t v55;
  CFIndex Count;
  uint64_t v57;
  uint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  unint64_t *v64;
  unint64_t *v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  uint64_t v69;
  std::__shared_weak_count *v70;
  uint64_t v71;
  std::__shared_weak_count *v72;
  NSObject *v73;
  std::__shared_weak_count *v74;
  uint64_t v75;
  std::__shared_weak_count *v76;
  std::__shared_weak_count *v77;
  std::__shared_weak_count *v78;
  uint64_t v79;
  std::__shared_weak_count *v80;
  __int128 v81;
  uint64_t handler;
  uint64_t v83;
  void (*v84)(uint64_t, const void *);
  void *v85;
  _BYTE *v86;
  uint64_t v87;
  uint64_t *v88;
  uint64_t v89;
  __n128 (*v90)(__n128 *, __n128 *);
  uint64_t (*v91)();
  void *v92;
  uint64_t v93;
  uint64_t v94;
  _BYTE buf[24];
  __n128 (*v96)(__n128 *, __n128 *);
  uint64_t (*v97)(uint64_t);
  uint64_t *v98;
  CFMutableArrayRef v99;
  std::__shared_weak_count *v100;
  std::__shared_weak_count *v101;
  uint64_t v102;

  v102 = *MEMORY[0x1E0C80C00];
  v75 = 0;
  v76 = 0;
  v4 = (std::__shared_weak_count *)a1[5];
  if (v4)
  {
    v76 = std::__shared_weak_count::lock(v4);
    if (v76)
    {
      v5 = a1[4];
      v75 = v5;
      if (v5)
      {
        v7 = a1[6];
        v6 = (std::__shared_weak_count *)a1[7];
        v73 = v7;
        v74 = v6;
        if (v6)
        {
          p_shared_owners = (unint64_t *)&v6->__shared_owners_;
          do
            v9 = __ldxr(p_shared_owners);
          while (__stxr(v9 + 1, p_shared_owners));
        }
        v87 = 0;
        v88 = &v87;
        v90 = __Block_byref_object_copy__160;
        v91 = __Block_byref_object_dispose__161;
        v89 = 0x4012000000;
        v93 = 0;
        v94 = 0;
        v92 = &unk_18422E08D;
        if ((*(_WORD *)(v5 + 248) & 0x60) != 0 || (*(_DWORD *)(v5 + 136) - 5) <= 2)
        {
          v93 = 1;
          LODWORD(v94) = 89;
          *(_QWORD *)buf = 0;
          *(_QWORD *)&buf[8] = 0;
          handler = 0;
          v83 = 0;
          (*(void (**)(uint64_t, _BYTE *, uint64_t *, uint64_t, uint64_t))(a2 + 16))(a2, buf, &handler, 1, v94);
          v10 = (std::__shared_weak_count *)v83;
          if (v83)
          {
            v11 = (unint64_t *)(v83 + 8);
            do
              v12 = __ldaxr(v11);
            while (__stlxr(v12 - 1, v11));
            if (!v12)
            {
              ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
              std::__shared_weak_count::__release_weak(v10);
            }
          }
          v13 = *(std::__shared_weak_count **)&buf[8];
          if (!*(_QWORD *)&buf[8])
            goto LABEL_92;
          v14 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v15 = __ldaxr(v14);
          while (__stlxr(v15 - 1, v14));
          if (v15)
            goto LABEL_92;
LABEL_18:
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
LABEL_92:
          _Block_object_dispose(&v87, 8);
          if (!v6)
            goto LABEL_97;
          v65 = (unint64_t *)&v6->__shared_owners_;
          do
            v20 = __ldaxr(v65);
          while (__stlxr(v20 - 1, v65));
          goto LABEL_95;
        }
        if (*(int *)(v5 + 528) <= 0)
          *(_DWORD *)(v5 + 528) = 1;
        v21 = MEMORY[0x1E0C809B0];
        if (!v7)
        {
LABEL_55:
          if (!*(_QWORD *)(v5 + 144))
          {
            v43 = *(_QWORD *)(v5 + 520);
            *(_QWORD *)buf = *(_QWORD *)(v5 + 512);
            *(_QWORD *)&buf[8] = v43;
            if (v43)
            {
              v44 = (unint64_t *)(v43 + 8);
              do
                v45 = __ldxr(v44);
              while (__stxr(v45 + 1, v44));
            }
            v46 = *(std::__shared_weak_count **)(v5 + 504);
            v77 = *(std::__shared_weak_count **)(v5 + 496);
            v78 = v46;
            if (v46)
            {
              v47 = (unint64_t *)&v46->__shared_owners_;
              do
                v48 = __ldxr(v47);
              while (__stxr(v48 + 1, v47));
            }
            (*(void (**)(uint64_t, _BYTE *, std::__shared_weak_count **, uint64_t, uint64_t))(a2 + 16))(a2, buf, &v77, v88[6], v88[7]);
            v49 = v78;
            if (v78)
            {
              v50 = (unint64_t *)&v78->__shared_owners_;
              do
                v51 = __ldaxr(v50);
              while (__stlxr(v51 - 1, v50));
              if (!v51)
              {
                ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
                std::__shared_weak_count::__release_weak(v49);
              }
            }
            v13 = *(std::__shared_weak_count **)&buf[8];
            if (!*(_QWORD *)&buf[8])
              goto LABEL_92;
            v52 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
            do
              v53 = __ldaxr(v52);
            while (__stlxr(v53 - 1, v52));
            goto LABEL_91;
          }
          v77 = 0;
          v78 = 0;
          v40 = *(std::__shared_weak_count **)(v5 + 264);
          if (v40)
          {
            v41 = std::__shared_weak_count::lock(v40);
            v78 = v41;
            if (v41)
            {
              v42 = *(std::__shared_weak_count **)(v5 + 256);
              v77 = v42;
LABEL_76:
              if (CFNLog::onceToken != -1)
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
              v54 = CFNLog::logger;
              if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
              {
                v55 = *(_QWORD *)(v5 + 288);
                Count = CFArrayGetCount(*(CFArrayRef *)(v5 + 496));
                *(_DWORD *)buf = 134218240;
                *(_QWORD *)&buf[4] = v55;
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = Count;
                _os_log_impl(&dword_183ECA000, v54, OS_LOG_TYPE_DEFAULT, "Connection %llu: issuing challenge for client certificates, DNs(%ld)", buf, 0x16u);
              }
              v57 = *(_QWORD *)(v5 + 144);
              v58 = *(_QWORD *)(v5 + 496);
              *(_QWORD *)buf = v21;
              *(_QWORD *)&buf[8] = 3321888768;
              *(_QWORD *)&buf[16] = ___ZN14NWIOConnection42_tlsProcessClientCertificateRequest_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvNS1_IK9__CFArrayEES7_13CFStreamErrorE_block_invoke_182;
              v96 = (__n128 (*)(__n128 *, __n128 *))&unk_1E14F4260;
              v97 = (uint64_t (*)(uint64_t))a2;
              v98 = &v87;
              v99 = (CFMutableArrayRef)v5;
              v100 = v42;
              v101 = v41;
              if (v41)
              {
                v59 = (unint64_t *)&v41->__shared_owners_;
                do
                  v60 = __ldxr(v59);
                while (__stxr(v60 + 1, v59));
              }
              (*(void (**)(uint64_t, uint64_t, _BYTE *))(*(_QWORD *)v57 + 40))(v57, v58, buf);
              v61 = v101;
              if (v101)
              {
                v62 = (unint64_t *)&v101->__shared_owners_;
                do
                  v63 = __ldaxr(v62);
                while (__stlxr(v63 - 1, v62));
                if (!v63)
                {
                  ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
                  std::__shared_weak_count::__release_weak(v61);
                }
              }
              v13 = v78;
              if (!v78)
                goto LABEL_92;
              v64 = (unint64_t *)&v78->__shared_owners_;
              do
                v53 = __ldaxr(v64);
              while (__stlxr(v53 - 1, v64));
LABEL_91:
              if (v53)
                goto LABEL_92;
              goto LABEL_18;
            }
          }
          else
          {
            v41 = 0;
          }
          v42 = 0;
          goto LABEL_76;
        }
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x4012000000;
        v96 = __Block_byref_object_copy__147;
        v97 = __Block_byref_object_dispose__148;
        v98 = (uint64_t *)&unk_18422E08D;
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
        v99 = Mutable;
        v23 = (std::__shared_weak_count *)operator new();
        v23->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1978;
        v23->__shared_owners_ = 0;
        v23->__shared_weak_owners_ = 0;
        v23[1].__vftable = (std::__shared_weak_count_vtbl *)Mutable;
        v100 = v23;
        handler = v21;
        v83 = 3221225472;
        v84 = ___ZN14NWIOConnection42_tlsProcessClientCertificateRequest_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvNS1_IK9__CFArrayEES7_13CFStreamErrorE_block_invoke;
        v85 = &unk_1E14F7F30;
        v86 = buf;
        v24 = sec_protocol_metadata_access_distinguished_names(v7, &handler);
        v25 = v24;
        if (v24)
        {
          v26 = *(const void **)(*(_QWORD *)&buf[8] + 48);
          if (v26)
            v27 = CFRetain(v26);
          else
            v27 = 0;
          *(_QWORD *)&v81 = v27;
          v35 = (_QWORD *)operator new();
          *v35 = &off_1E14F1AC8;
          v35[1] = 0;
          v35[2] = 0;
          v35[3] = v27;
          *((_QWORD *)&v81 + 1) = v35;
          std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v5 + 496, &v81);
          v32 = (std::__shared_weak_count *)*((_QWORD *)&v81 + 1);
          if (!*((_QWORD *)&v81 + 1))
            goto LABEL_49;
          v36 = (unint64_t *)(*((_QWORD *)&v81 + 1) + 8);
          do
            v34 = __ldaxr(v36);
          while (__stlxr(v34 - 1, v36));
        }
        else
        {
          v28 = v88;
          v88[6] = (int)*MEMORY[0x1E0C9B298];
          *((_DWORD *)v28 + 14) = -9800;
          v81 = 0uLL;
          v79 = 0;
          v80 = 0;
          (*(void (**)(uint64_t, __int128 *, uint64_t *))(a2 + 16))(a2, &v81, &v79);
          v29 = v80;
          if (v80)
          {
            v30 = (unint64_t *)&v80->__shared_owners_;
            do
              v31 = __ldaxr(v30);
            while (__stlxr(v31 - 1, v30));
            if (!v31)
            {
              ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
              std::__shared_weak_count::__release_weak(v29);
            }
          }
          v32 = (std::__shared_weak_count *)*((_QWORD *)&v81 + 1);
          if (!*((_QWORD *)&v81 + 1))
          {
LABEL_49:
            _Block_object_dispose(buf, 8);
            v37 = v100;
            if (v100)
            {
              v38 = (unint64_t *)&v100->__shared_owners_;
              do
                v39 = __ldaxr(v38);
              while (__stlxr(v39 - 1, v38));
              if (!v39)
              {
                ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
                std::__shared_weak_count::__release_weak(v37);
              }
            }
            if (!v25)
              goto LABEL_92;
            goto LABEL_55;
          }
          v33 = (unint64_t *)(*((_QWORD *)&v81 + 1) + 8);
          do
            v34 = __ldaxr(v33);
          while (__stlxr(v34 - 1, v33));
        }
        if (!v34)
        {
          ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
          std::__shared_weak_count::__release_weak(v32);
        }
        goto LABEL_49;
      }
    }
  }
  v71 = 0;
  v72 = 0;
  v69 = 0;
  v70 = 0;
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t, uint64_t))(a2 + 16))(a2, &v71, &v69, 1, 89);
  v16 = v70;
  if (v70)
  {
    v17 = (unint64_t *)&v70->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v6 = v72;
  if (v72)
  {
    v19 = (unint64_t *)&v72->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
LABEL_95:
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
LABEL_97:
  v66 = v76;
  if (v76)
  {
    v67 = (unint64_t *)&v76->__shared_owners_;
    do
      v68 = __ldaxr(v67);
    while (__stlxr(v68 - 1, v67));
    if (!v68)
    {
      ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
      std::__shared_weak_count::__release_weak(v66);
    }
  }
}

void sub_184028390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a18);
  _Block_object_dispose(&a29, 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a14);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection41_tlsProcessClientCertificateRequest_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvPU26objcproto15OS_sec_identityS2_E_block_invoke_178(_QWORD *a1, const __CFArray **a2, CFIndex a3, uint64_t a4)
{
  std::__shared_weak_count *v5;
  uint64_t v9;
  const __CFArray *v10;
  const __CFArray *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  sec_identity_t v19;
  NSObject *v20;
  uint64_t v21;
  CFIndex Count;
  unint64_t *p_shared_owners;
  unint64_t v24;
  NSObject *v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  const __CFArray *theArray;
  std::__shared_weak_count *v30;
  CFArrayRef v31[2];
  sec_identity_t v32;
  uint8_t buf[4];
  uint64_t v34;
  __int16 v35;
  CFIndex v36;
  __int16 v37;
  int v38;
  uint64_t v39;
  CFStreamError v40;

  v39 = *MEMORY[0x1E0C80C00];
  v30 = 0;
  v5 = (std::__shared_weak_count *)a1[6];
  if (!v5 || (v30 = std::__shared_weak_count::lock(v5)) == 0 || (v9 = a1[5]) == 0)
  {
    (*(void (**)(void))(a1[4] + 16))();
    goto LABEL_28;
  }
  v10 = *a2;
  v11 = a2[1];
  theArray = v10;
  if (v11)
  {
    v12 = (unint64_t *)((char *)v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v14 = a1[4];
  if ((*(_WORD *)(v9 + 248) & 0x60) == 0 && (*(_DWORD *)(v9 + 136) - 5) >= 3)
  {
    if (!a3 && !(_DWORD)a4)
    {
      v31[0] = v10;
      v31[1] = v11;
      if (v11)
      {
        v15 = (unint64_t *)((char *)v11 + 8);
        do
          v16 = __ldxr(v15);
        while (__stxr(v16 + 1, v15));
      }
      NWIOConnection::_tlsCreateIdentityFromClientCertificates(&v32, v31);
      if (v11)
      {
        v17 = (unint64_t *)((char *)v11 + 8);
        do
          v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          (*(void (**)(const __CFArray *))(*(_QWORD *)v11 + 16))(v11);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v11);
        }
      }
      v19 = v32;
      if (v32 && *(int *)(v9 + 528) <= 1)
        *(_DWORD *)(v9 + 528) = 2;
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v20 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v21 = *(_QWORD *)(v9 + 288);
        if (theArray)
          Count = CFArrayGetCount(theArray);
        else
          Count = -1;
        *(_DWORD *)buf = 134218240;
        v34 = v21;
        v35 = 2048;
        v36 = Count;
        _os_log_impl(&dword_183ECA000, v20, OS_LOG_TYPE_DEFAULT, "Connection %llu: providing TLS Client Identity (%ld elements)", buf, 0x16u);
      }
      (*(void (**)(uint64_t, sec_identity_t))(v14 + 16))(v14, v19);
      if (v19)
        sec_release(v19);
      goto LABEL_40;
    }
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v25 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v28 = *(_QWORD *)(v9 + 288);
      *(_DWORD *)buf = 134218496;
      v34 = v28;
      v35 = 2048;
      v36 = a3;
      v37 = 1024;
      v38 = a4;
      _os_log_error_impl(&dword_183ECA000, v25, OS_LOG_TYPE_ERROR, "Connection %llu: TLS Client Certificates encountered error %ld:%d", buf, 0x1Cu);
    }
    v40.domain = a3;
    *(_QWORD *)&v40.error = a4;
    NWIOConnection::_handleError((NWIOConnection *)v9, v40);
  }
  (*(void (**)(uint64_t, _QWORD))(v14 + 16))(v14, 0);
LABEL_40:
  if (v11)
  {
    v26 = (unint64_t *)((char *)v11 + 8);
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      (*(void (**)(const __CFArray *))(*(_QWORD *)v11 + 16))(v11);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v11);
    }
  }
LABEL_28:
  if (v30)
  {
    p_shared_owners = (unint64_t *)&v30->__shared_owners_;
    do
      v24 = __ldaxr(p_shared_owners);
    while (__stlxr(v24 - 1, p_shared_owners));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
}

void sub_1840287B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14)
{
  void *v14;

  if (v14)
    sec_release(v14);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a12);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TLSCallbackClientCertificate>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0EC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TLSCallbackClientCertificate>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0EC0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_emplace<TLSCallbackClientCertificate>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *__copy_helper_block_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

void __destroy_helper_block_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE(uint64_t a1)
{
  std::__shared_weak_count *v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

void ___ZN14NWIOConnection42_tlsProcessClientCertificateRequest_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvNS1_IK9__CFArrayEES7_13CFStreamErrorE_block_invoke(uint64_t a1, const void *a2)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), a2);
}

void ___ZN14NWIOConnection42_tlsProcessClientCertificateRequest_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvNS1_IK9__CFArrayEES7_13CFStreamErrorE_block_invoke_182(_QWORD *a1, const __CFArray *a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v8;
  uint64_t v9;
  CFIndex Count;
  _QWORD *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *p_shared_owners;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  __int128 v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  _BYTE buf[22];
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    v4 = *(_QWORD *)(a1[5] + 8);
    *(_QWORD *)(v4 + 48) = 1;
    *(_DWORD *)(v4 + 56) = 89;
    v55 = 0;
    v56 = 0;
    v53 = 0;
    v54 = 0;
    (*(void (**)(void))(a1[4] + 16))();
  }
  else
  {
    v5 = a1[6];
    if ((*(_WORD *)(v5 + 248) & 0x60) != 0 || (*(_DWORD *)(v5 + 136) - 5) <= 2)
    {
      v6 = *(_QWORD *)(a1[5] + 8);
      *(_QWORD *)(v6 + 48) = 1;
      *(_DWORD *)(v6 + 56) = 89;
      v51 = 0;
      v52 = 0;
      v49 = 0;
      v50 = 0;
      (*(void (**)(void))(a1[4] + 16))();
    }
    else
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v8 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *(_QWORD *)(v5 + 288);
        if (a2)
          Count = CFArrayGetCount(a2);
        else
          Count = -1;
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = v9;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = Count;
        _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_DEFAULT, "Connection %llu: received response for client certificates (%ld elements)", buf, 0x16u);
      }
      if (a2)
        a2 = (const __CFArray *)CFRetain(a2);
      *(_QWORD *)buf = a2;
      v11 = (_QWORD *)operator new();
      *v11 = &off_1E14F1AC8;
      v11[1] = 0;
      v11[2] = 0;
      v11[3] = a2;
      *(_QWORD *)&buf[8] = v11;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1[7] + 512, (__int128 *)buf);
      v12 = *(std::__shared_weak_count **)&buf[8];
      if (*(_QWORD *)&buf[8])
      {
        v13 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      v15 = *(_QWORD *)(v5 + 520);
      *(_QWORD *)buf = *(_QWORD *)(v5 + 512);
      *(_QWORD *)&buf[8] = v15;
      if (v15)
      {
        v16 = (unint64_t *)(v15 + 8);
        do
          v17 = __ldxr(v16);
        while (__stxr(v17 + 1, v16));
      }
      v48 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v5 + 512, &v48);
      v18 = (std::__shared_weak_count *)*((_QWORD *)&v48 + 1);
      if (*((_QWORD *)&v48 + 1))
      {
        v19 = (unint64_t *)(*((_QWORD *)&v48 + 1) + 8);
        do
          v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
      v21 = *(_QWORD *)(v5 + 504);
      *(_QWORD *)&v48 = *(_QWORD *)(v5 + 496);
      *((_QWORD *)&v48 + 1) = v21;
      if (v21)
      {
        v22 = (unint64_t *)(v21 + 8);
        do
          v23 = __ldxr(v22);
        while (__stxr(v23 + 1, v22));
      }
      v47 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v5 + 496, &v47);
      v24 = (std::__shared_weak_count *)*((_QWORD *)&v47 + 1);
      if (*((_QWORD *)&v47 + 1))
      {
        v25 = (unint64_t *)(*((_QWORD *)&v47 + 1) + 8);
        do
          v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }
      v27 = a1[4];
      v45 = *(_QWORD *)buf;
      v46 = *(std::__shared_weak_count **)&buf[8];
      if (*(_QWORD *)&buf[8])
      {
        v28 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v29 = __ldxr(v28);
        while (__stxr(v29 + 1, v28));
      }
      v44 = v48;
      if (*((_QWORD *)&v48 + 1))
      {
        v30 = (unint64_t *)(*((_QWORD *)&v48 + 1) + 8);
        do
          v31 = __ldxr(v30);
        while (__stxr(v31 + 1, v30));
      }
      (*(void (**)(uint64_t, uint64_t *, __int128 *, _QWORD, _QWORD))(v27 + 16))(v27, &v45, &v44, *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 48), *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 56));
      v32 = (std::__shared_weak_count *)*((_QWORD *)&v44 + 1);
      if (*((_QWORD *)&v44 + 1))
      {
        v33 = (unint64_t *)(*((_QWORD *)&v44 + 1) + 8);
        do
          v34 = __ldaxr(v33);
        while (__stlxr(v34 - 1, v33));
        if (!v34)
        {
          ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
          std::__shared_weak_count::__release_weak(v32);
        }
      }
      v35 = v46;
      if (v46)
      {
        p_shared_owners = (unint64_t *)&v46->__shared_owners_;
        do
          v37 = __ldaxr(p_shared_owners);
        while (__stlxr(v37 - 1, p_shared_owners));
        if (!v37)
        {
          ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
          std::__shared_weak_count::__release_weak(v35);
        }
      }
      v38 = (std::__shared_weak_count *)*((_QWORD *)&v48 + 1);
      if (*((_QWORD *)&v48 + 1))
      {
        v39 = (unint64_t *)(*((_QWORD *)&v48 + 1) + 8);
        do
          v40 = __ldaxr(v39);
        while (__stlxr(v40 - 1, v39));
        if (!v40)
        {
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v38);
        }
      }
      v41 = *(std::__shared_weak_count **)&buf[8];
      if (*(_QWORD *)&buf[8])
      {
        v42 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v43 = __ldaxr(v42);
        while (__stlxr(v43 - 1, v42));
        if (!v43)
        {
          ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
          std::__shared_weak_count::__release_weak(v41);
        }
      }
    }
  }
}

void sub_184028DC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  uint64_t v15;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a15);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v15 - 80);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TLSCallbackQueue>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0BB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TLSCallbackQueue>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0BB0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<NSObject  {objcproto24OS_sec_protocol_metadata}*,Deleter_SecRelease<NSObject  {objcproto24OS_sec_protocol_metadata}*>,std::allocator<NSObject  {objcproto24OS_sec_protocol_metadata}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t __Block_byref_object_copy__131_3670(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(result + 48) = v2;
  return result;
}

void __Block_byref_object_dispose__132_3671(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 48);
  *(_QWORD *)(a1 + 48) = 0;
  if (v2)
    CFRelease(v2);
}

void ___ZN14NWIOConnection13_tlsConfigureEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_133(uint64_t a1, const __CFString *a2)
{
  uint64_t SSLWithATSPinning;
  uint64_t v5;
  const void *v6;
  SecPolicyRef SSL;
  uint64_t v8;
  const void *v9;

  if (a2)
  {
    SSLWithATSPinning = SecPolicyCreateSSLWithATSPinning();
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v6 = *(const void **)(v5 + 48);
    *(_QWORD *)(v5 + 48) = SSLWithATSPinning;
    if (v6)
      CFRelease(v6);
    if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48))
    {
      SSL = SecPolicyCreateSSL(1u, a2);
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v9 = *(const void **)(v8 + 48);
      *(_QWORD *)(v8 + 48) = SSL;
      if (v9)
        CFRelease(v9);
    }
  }
}

void ___ZN14NWIOConnection36_tlsProcessValidateServerTrust_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEEU13block_pointerFvbE_block_invoke_158(_QWORD *a1, uint64_t a2, CFIndex a3, uint64_t a4)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  uint64_t v15;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  CFIndex v19;
  __int16 v20;
  int v21;
  uint64_t v22;
  CFStreamError v23;

  v22 = *MEMORY[0x1E0C80C00];
  v5 = (std::__shared_weak_count *)a1[6];
  if (!v5)
  {
    v9 = 0;
    goto LABEL_16;
  }
  v9 = std::__shared_weak_count::lock(v5);
  if (!v9 || (v10 = a1[5]) == 0)
  {
LABEL_16:
    (*(void (**)(_QWORD, _QWORD))(a1[4] + 16))(a1[4], 0);
    if (!v9)
      return;
    goto LABEL_17;
  }
  v11 = a1[4];
  if ((*(_WORD *)(v10 + 248) & 0x60) == 0 && (*(_DWORD *)(v10 + 136) - 5) >= 3)
  {
    if (!a3 && !(_DWORD)a4)
      goto LABEL_14;
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v12 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v15 = *(_QWORD *)(v10 + 288);
      *(_DWORD *)buf = 134218496;
      v17 = v15;
      v18 = 2048;
      v19 = a3;
      v20 = 1024;
      v21 = a4;
      _os_log_error_impl(&dword_183ECA000, v12, OS_LOG_TYPE_ERROR, "Connection %llu: TLS Trust encountered error %ld:%d", buf, 0x1Cu);
    }
    v23.domain = a3;
    *(_QWORD *)&v23.error = a4;
    NWIOConnection::_handleError((NWIOConnection *)v10, v23);
  }
  a2 = 0;
LABEL_14:
  (*(void (**)(uint64_t, uint64_t))(v11 + 16))(v11, a2);
LABEL_17:
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
}

void sub_18402912C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TLSCallbackServerTrust>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0D00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TLSCallbackServerTrust>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0D00;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t ___ZN14NWIOConnection18_handleEvent_ReadyEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 2552;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void std::__shared_ptr_pointer<NSObject  {objcproto16OS_nw_connection}*,Deleter_NWRelease<NSObject  {objcproto16OS_nw_connection}*>,std::allocator<NSObject  {objcproto16OS_nw_connection}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_2(uint64_t a1, int a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  __int128 buf;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a2 == 1)
  {
    v3 = *(std::__shared_weak_count **)(a1 + 40);
    if (v3)
    {
      v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        v5 = v4;
        v6 = *(_QWORD *)(a1 + 32);
        if (v6 && (*(_WORD *)(v6 + 248) & 0x60) == 0 && (*(_DWORD *)(v6 + 136) - 5) >= 2)
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v7 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            v8 = *(_QWORD *)(v6 + 288);
            LODWORD(buf) = 134217984;
            *(_QWORD *)((char *)&buf + 4) = v8;
            _os_log_impl(&dword_183ECA000, v7, OS_LOG_TYPE_DEFAULT, "Connection %llu: encountered bidirectional stream limit updated event", (uint8_t *)&buf, 0xCu);
          }
          v9 = *(_QWORD *)(v6 + 160);
          v10 = *(std::__shared_weak_count **)(v6 + 168);
          *(_QWORD *)&buf = v9;
          *((_QWORD *)&buf + 1) = v10;
          if (v10)
          {
            p_shared_owners = (unint64_t *)&v10->__shared_owners_;
            do
              v12 = __ldxr(p_shared_owners);
            while (__stxr(v12 + 1, p_shared_owners));
          }
          if (v9)
            (*(void (**)(uint64_t))(*(_QWORD *)v9 + 56))(v9);
          if (v10)
          {
            v13 = (unint64_t *)&v10->__shared_owners_;
            do
              v14 = __ldaxr(v13);
            while (__stlxr(v14 - 1, v13));
            if (!v14)
            {
              ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
              std::__shared_weak_count::__release_weak(v10);
            }
          }
        }
        v15 = (unint64_t *)&v5->__shared_owners_;
        do
          v16 = __ldaxr(v15);
        while (__stlxr(v16 - 1, v15));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
      }
    }
  }
}

void sub_1840293B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14NWIOConnection30_conditionalSchedulingSIMSetupEv_block_invoke(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 40);
  if ((*(_WORD *)(v1 + 248) & 0x60) == 0 && (*(_DWORD *)(v1 + 136) - 5) >= 3)
    return NWIOConnection::_startConnection_Completion(*(NWIOConnection **)(result + 32));
  return result;
}

void ___ZN14NWIOConnection30_conditionalSchedulingSIMSetupEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  CFStreamError v2;

  v1 = *(_QWORD *)(a1 + 40);
  if ((*(_WORD *)(v1 + 248) & 0x60) == 0 && (*(_DWORD *)(v1 + 136) - 5) >= 3)
  {
    v2.domain = 1;
    *(_QWORD *)&v2.error = 60;
    NWIOConnection::_handleError((NWIOConnection *)v1, v2);
  }
}

void std::__shared_ptr_emplace<ConditionalConnectionSIMScheduler>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0EF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<ConditionalConnectionSIMScheduler>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0EF8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_emplace<ConditionalConnectionSIMScheduler>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;

  ConditionalConnectionSIMScheduler::cancel((ConditionalConnectionSIMScheduler *)(a1 + 24));
  v2 = *(_QWORD *)(a1 + 112);
  *(_QWORD *)(a1 + 112) = 0;
  if (v2)
    (*(void (**)(void))(a1 + 120))();
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 96);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 80);
  v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

uint64_t ___ZN14NWIOConnection30_conditionalSchedulingDASSetupEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 40);
  if ((*(_WORD *)(v2 + 248) & 0x60) != 0 || (*(_DWORD *)(v2 + 136) - 5) < 3)
    return 0;
  v6 = *(_QWORD *)(a1 + 32);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v7 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *(_QWORD *)(v6 + 288);
    v9 = 134218240;
    v10 = v8;
    v11 = 2048;
    v12 = a2;
    _os_log_impl(&dword_183ECA000, v7, OS_LOG_TYPE_DEFAULT, "Connection %llu: activity(%p) start handler called", (uint8_t *)&v9, 0x16u);
  }
  v3 = 1;
  *(_BYTE *)(v6 + 592) = 1;
  NWIOConnection::_startConnection_Completion((NWIOConnection *)v6);
  return v3;
}

void ___ZN14NWIOConnection30_conditionalSchedulingDASSetupEv_block_invoke_203(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 40);
  if ((*(_WORD *)(v2 + 248) & 0x60) == 0 && (*(_DWORD *)(v2 + 136) - 5) >= 3)
  {
    v5 = *(_QWORD *)(a1 + 32);
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_QWORD *)(v5 + 288);
      v8 = 134218240;
      v9 = v7;
      v10 = 2048;
      v11 = a2;
      _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, "Connection %llu: activity(%p) suspend handler called", (uint8_t *)&v8, 0x16u);
    }
    if (*(_QWORD *)(*(_QWORD *)(a1 + 40) + 624))
      (*(void (**)(void))(*(_QWORD *)(v5 + 624) + 16))();
    NWIOConnection::_terminateConnectionIfAppropriate((CFDictionaryRef *)v5, 0);
  }
}

void ___ZN14NWIOConnection30_conditionalSchedulingDASSetupEv_block_invoke_206(uint64_t a1, int a2, CFTypeRef cf)
{
  NWIOConnection *v4;
  CFTypeRef v6;
  NSObject *v7;
  uint64_t v8;
  const void *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  __int16 v17;
  CFTypeRef v18;
  uint64_t v19;
  CFStreamError v20;

  v19 = *MEMORY[0x1E0C80C00];
  v4 = *(NWIOConnection **)(a1 + 32);
  if (a2)
  {
    if (cf)
      v6 = CFRetain(cf);
    else
      v6 = 0;
    v8 = *(_QWORD *)(a1 + 40);
    v9 = *(const void **)(v8 + 584);
    *(_QWORD *)(v8 + 584) = v6;
    if (v9)
      CFRelease(v9);
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v10 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v11 = *((_QWORD *)v4 + 36);
      v15 = 134218240;
      v16 = v11;
      v17 = 2048;
      v18 = cf;
      _os_log_impl(&dword_183ECA000, v10, OS_LOG_TYPE_DEFAULT, "Connection %llu: submitted activity(%p)", (uint8_t *)&v15, 0x16u);
    }
    v12 = *((_QWORD *)v4 + 18);
    if (v12)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v12 + 72))(v12, 10000);
    v13 = *((_QWORD *)v4 + 77);
    if (v13)
      (*(void (**)(uint64_t, _QWORD, uint64_t))(v13 + 16))(v13, 0, 10000);
  }
  else
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v7 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v14 = *((_QWORD *)v4 + 36);
      v15 = 134218240;
      v16 = v14;
      v17 = 2048;
      v18 = cf;
      _os_log_error_impl(&dword_183ECA000, v7, OS_LOG_TYPE_ERROR, "Connection %llu: failed to start activity(%p)", (uint8_t *)&v15, 0x16u);
    }
    v20.domain = 1;
    *(_QWORD *)&v20.error = 22;
    NWIOConnection::_handleError(v4, v20);
  }
}

uint64_t ___ZN14NWIOConnection27_startConnection_CompletionEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 2157;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN14NWIOConnection29_connectionAttemptTimerCreateEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  CFStreamError v8;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 3)
      {
        v8.domain = 4;
        *(_QWORD *)&v8.error = 4294965190;
        NWIOConnection::_handleTimeout((NWIOConnection *)v5, v8);
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_184029A08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection16_kickTimerCreateEv_block_invoke(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  NSObject *v7;
  double v8;
  NSObject *v9;
  dispatch_time_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;

  v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    v3 = a1[4];
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      v6 = a1[5];
      if (v6 && (*(_WORD *)(v6 + 248) & 0x60) == 0 && (*(_DWORD *)(v6 + 136) - 5) >= 3)
      {
        v7 = *(NSObject **)(v3 + 272);
        if (v7)
          nw_connection_restart(v7);
        v8 = *(double *)(v3 + 536) + *(double *)(v3 + 536);
        *(double *)(v3 + 536) = v8;
        v9 = *(NSObject **)(v3 + 544);
        v10 = dispatch_time(0x8000000000000000, (uint64_t)(v8 * 1000000000.0));
        dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
      }
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
}

void sub_184029B18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void CFAllocatedReferenceCountedObject::~CFAllocatedReferenceCountedObject(CFAllocatorRef *this)
{
  CFAllocatorDeallocate(this[1], this);
}

CFStringRef CFAllocatedReferenceCountedObject::copyDebugDesc(CFAllocatedReferenceCountedObject *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<CFAllocatedObject@%p>"), this);
}

uint64_t CFAllocatedReferenceCountedObject::_retainable_copyDescription(CFAllocatedReferenceCountedObject *this, const void *a2)
{
  return (*(uint64_t (**)(CFAllocatedReferenceCountedObject *))(*(_QWORD *)this + 16))(this);
}

BOOL CFObject::equals(CFObject *this, const CFObject *a2)
{
  return this == a2;
}

uint64_t CFObject::hash(CFObject *this)
{
  return (uint64_t)this - 16;
}

uint64_t CFObject::copyFormattingDesc(CFObject *this, const __CFDictionary *a2)
{
  return 0;
}

CFStringRef CFObject::copyDebugDescHeader(CFObject *this)
{
  char *v2;
  uint64_t ClassWithTypeID;

  v2 = (char *)this - 16;
  CFGetTypeID((char *)this - 16);
  ClassWithTypeID = _CFRuntimeGetClassWithTypeID();
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<%s %p [%p]>"), *(_QWORD *)(ClassWithTypeID + 8), v2, this);
}

CFStringRef CFObject::_cfobj_copyDescription(CFObject *this, const void *a2)
{
  return CFCopyDescription((char *)this - 16);
}

uint64_t CFObject::_cfobj_equal(CFObject *this, char *a2, const void *a3)
{
  return CFEqual((char *)this - 16, a2 - 16);
}

void CFAllocatedObject::~CFAllocatedObject(CFAllocatorRef *this)
{
  CFAllocatorDeallocate(this[1], this);
}

uint64_t CFAllocatedReferenceCountedObject::_retainable_instance_release(CFAllocatedReferenceCountedObject *this, const void *a2)
{
  return (*(uint64_t (**)(CFAllocatedReferenceCountedObject *))(*(_QWORD *)this + 48))(this);
}

uint64_t CFClass::EqualObj(CFClass *this, char *a2, const void *a3)
{
  char *v3;
  char *v4;

  if (this)
    v3 = (char *)this + 16;
  else
    v3 = 0;
  if (a2)
    v4 = a2 + 16;
  else
    v4 = 0;
  return (**(uint64_t (***)(char *, char *, const void *))v3)(v3, v4, a3);
}

uint64_t CFClass::HashObj(CFClass *this, const void *a2)
{
  if (this)
    return (*(uint64_t (**)(char *))(*((_QWORD *)this + 2) + 8))((char *)this + 16);
  else
    return (*(uint64_t (**)(_QWORD))(MEMORY[0] + 8))(0);
}

uint64_t CFClass::CopyFormattingDescObj(CFClass *this, const void *a2, const __CFDictionary *a3)
{
  char *v3;

  if (this)
    v3 = (char *)this + 16;
  else
    v3 = 0;
  return (*(uint64_t (**)(char *, const void *))(*(_QWORD *)v3 + 16))(v3, a2);
}

uint64_t CFClass::CopyDebugDescObj(CFClass *this, const void *a2)
{
  if (this)
    return (*(uint64_t (**)(char *))(*((_QWORD *)this + 2) + 24))((char *)this + 16);
  else
    return (*(uint64_t (**)(_QWORD))(MEMORY[0] + 24))(0);
}

CFObject *CFObject::_cfobj_instance_retain(CFObject *this, void *a2)
{
  CFRetain((char *)this - 16);
  return this;
}

void CFObject::_cfobj_instance_release(CFObject *this, void *a2)
{
  CFRelease((char *)this - 16);
}

CFStringRef CFObject::_cfobj_instance_copyDescription(CFObject *this, void *a2)
{
  return CFCopyDescription((char *)this - 16);
}

void ___Z26_cfnAutoreleaseDebugBufferl_block_invoke_2(uint64_t a1)
{
  int v2;
  size_t v3;
  void *v4;

  v2 = _cfnAutoreleaseDebugBuffer(long)::pPos;
  v3 = *(_QWORD *)(a1 + 40);
  _cfnAutoreleaseDebugBuffer(long)::pPos += v3;
  if (_cfnAutoreleaseDebugBuffer(long)::pPos >= 0x200)
  {
    v2 = 0;
    _cfnAutoreleaseDebugBuffer(long)::pPos = 0;
  }
  v4 = (void *)(_cfnAutoreleaseDebugBuffer(long)::pBuffer + v2);
  bzero(v4, v3);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v4;
}

dispatch_queue_t ___Z26_cfnAutoreleaseDebugBufferl_block_invoke()
{
  dispatch_queue_t result;

  _cfnAutoreleaseDebugBuffer(long)::pBuffer = (uint64_t)malloc_type_malloc(0x200uLL, 0x5FBE3EDAuLL);
  result = dispatch_queue_create("circLock", 0);
  _cfnAutoreleaseDebugBuffer(long)::sLock = (uint64_t)result;
  return result;
}

char *_cfnAutoreleaseInDebug(const __CFString *a1)
{
  CFIndex Length;
  CFIndex v3;
  char *v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  if (!a1)
    return 0;
  Length = CFStringGetLength(a1);
  v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  if (_cfnAutoreleaseDebugBuffer(long)::sOnce != -1)
    dispatch_once(&_cfnAutoreleaseDebugBuffer(long)::sOnce, &__block_literal_global_3779);
  if (v3 >= 512)
    goto LABEL_7;
  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___Z26_cfnAutoreleaseDebugBufferl_block_invoke_2;
  v6[3] = &unk_1E14FDA68;
  v6[4] = &v7;
  v6[5] = v3;
  dispatch_sync((dispatch_queue_t)_cfnAutoreleaseDebugBuffer(long)::sLock, v6);
  v4 = (char *)v8[3];
  _Block_object_dispose(&v7, 8);
  if (v4)
    CFStringGetCString(a1, v4, v3, 0x8000100u);
  else
LABEL_7:
    v4 = "-";
  CFRelease(a1);
  return v4;
}

_OWORD *CFURLConnectionCreate(uint64_t a1, void *a2, _QWORD *a3)
{
  void *v6;
  _OWORD *v7;

  v6 = (void *)MEMORY[0x186DB8C8C]();
  v7 = CFURLConnectionCreateWithProperties(a1, a2, a3, 0);
  objc_autoreleasePoolPop(v6);
  return v7;
}

void CFURLConnectionUseCredential(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  uint64_t v7;

  v6 = (void *)MEMORY[0x186DB8C8C]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_8_3802);
  if (a1)
    v7 = a1 + 16;
  else
    v7 = 0;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 64))(v7, a2, a3);
  objc_autoreleasePoolPop(v6);
}

void CFURLConnectionPerformDefaultHandlingForChallenge(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;

  v4 = (void *)MEMORY[0x186DB8C8C]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_8_3802);
  if (a1)
    v5 = a1 + 16;
  else
    v5 = 0;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 72))(v5, a2);
  objc_autoreleasePoolPop(v4);
}

void CFURLConnectionRejectChallenge(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;

  v4 = (void *)MEMORY[0x186DB8C8C]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_8_3802);
  if (a1)
    v5 = a1 + 16;
  else
    v5 = 0;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 80))(v5, a2);
  objc_autoreleasePoolPop(v4);
}

void CFURLConnectionHalt(uint64_t a1)
{
  void *v2;
  uint64_t v3;

  v2 = (void *)MEMORY[0x186DB8C8C]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_8_3802);
  if (a1)
    v3 = a1 + 16;
  else
    v3 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)v3 + 88))(v3);
  objc_autoreleasePoolPop(v2);
}

void CFURLConnectionResume(uint64_t a1)
{
  void *v2;
  uint64_t v3;

  v2 = (void *)MEMORY[0x186DB8C8C]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_8_3802);
  if (a1)
    v3 = a1 + 16;
  else
    v3 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)v3 + 96))(v3);
  objc_autoreleasePoolPop(v2);
}

void CFURLConnectionUnscheduleFromRunLoop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  uint64_t v7;

  v6 = (void *)MEMORY[0x186DB8C8C]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_8_3802);
  if (a1)
    v7 = a1 + 16;
  else
    v7 = 0;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 112))(v7, a2, a3);
  objc_autoreleasePoolPop(v6);
}

void CFURLConnectionScheduleDownloadWithRunLoop()
{
  if (CFURLConnectionScheduleDownloadWithRunLoop::onceToken != -1)
    dispatch_once(&CFURLConnectionScheduleDownloadWithRunLoop::onceToken, &__block_literal_global_3809);
}

void CFURLConnectionInvalidateConnectionCache()
{
  void *v0;
  uint64_t v1;
  CFDictionaryRef *v2;

  v0 = (void *)MEMORY[0x186DB8C8C]();
  v1 = +[NSURLSession _sharedSessionForConnection]();
  if (v1)
  {
    v2 = *(CFDictionaryRef **)(v1 + 168);
    if (v2)
      XTubeManager::invalidateAllConnections(v2, 0);
  }
  objc_autoreleasePoolPop(v0);
}

_QWORD *_CFURLConnectionCopyTimingData(_QWORD *a1)
{
  void *v2;
  void *v3;
  id Property;
  const char *v5;
  id v6;

  v2 = (void *)MEMORY[0x186DB8C8C]();
  if (a1)
  {
    if (TCFObject<URLConnection>::Class(void)::sOnce != -1)
      dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_8_3802);
    v3 = (void *)a1[9];
    if (!v3)
      goto LABEL_9;
    Property = (id)objc_msgSend(v3, "_metrics");
    if (Property)
      Property = objc_getProperty(Property, v5, 96, 1);
    v6 = -[__CFN_TransactionMetrics legacyStaticMetrics]((uint64_t)Property);
    if (v6)
      a1 = CFRetain(v6);
    else
LABEL_9:
      a1 = 0;
  }
  objc_autoreleasePoolPop(v2);
  return a1;
}

void `non-virtual thunk to'HTTPRequest::~HTTPRequest(HTTPRequest *this)
{
  HTTPRequest::~HTTPRequest((HTTPRequest *)((char *)this - 8));
}

{
  HTTPRequest::~HTTPRequest((HTTPRequest *)((char *)this - 8));
}

{
  HTTPRequest::~HTTPRequest((HTTPRequest *)((char *)this - 16));
}

{
  HTTPRequest::~HTTPRequest((HTTPRequest *)((char *)this - 16));
}

{
  HTTPRequest::~HTTPRequest((HTTPRequest *)((char *)this - 128));
}

{
  HTTPRequest::~HTTPRequest((HTTPRequest *)((char *)this - 128));
}

BOOL HTTPRequest::isEffectivelyEmpty(HTTPRequest *this)
{
  const __CFArray *v2;
  const __CFArray *v3;
  uint64_t v5;

  v2 = (const __CFArray *)*((_QWORD *)this + 23);
  if (v2 && CFArrayGetCount(v2) > 0)
    return 0;
  v3 = (const __CFArray *)*((_QWORD *)this + 26);
  if (v3)
  {
    if (CFArrayGetCount(v3) > 0)
      return 0;
  }
  if (*((_QWORD *)this + 25))
    return 0;
  v5 = HTTPMessage::headers((os_unfair_lock_s *)this);
  return !v5 || CFDictionaryGetCount(*(CFDictionaryRef *)(v5 + 8)) == 0;
}

void `non-virtual thunk to'HTTPResponse::~HTTPResponse(HTTPResponse *this)
{
  HTTPResponseMessage::~HTTPResponseMessage((HTTPResponseMessage *)((char *)this - 8));
}

{
  HTTPResponseMessage::~HTTPResponseMessage((HTTPResponseMessage *)((char *)this - 8));
}

{
  HTTPResponseMessage::~HTTPResponseMessage((HTTPResponseMessage *)((char *)this - 16));
}

{
  HTTPResponseMessage::~HTTPResponseMessage((HTTPResponseMessage *)((char *)this - 16));
}

uint64_t URLProtocol::getCurrentBodyStream(URLProtocol *this)
{
  return 0;
}

void URLProtocol::setBytesPerSecondLimit(URLProtocol *this, uint64_t a2)
{
  Throttler *v2;

  v2 = (Throttler *)*((_QWORD *)this + 8);
  if (v2)
    Throttler::setMaximumBPSTarget(v2, a2);
}

uint64_t URLProtocol::getCurrentSuspensionThreshold(URLProtocol *this, uint64_t a2)
{
  return a2;
}

uint64_t URLProtocol::_throttle_throttle(URLProtocol *this)
{
  *((_BYTE *)this + 72) = 1;
  return (*(uint64_t (**)(URLProtocol *))(*(_QWORD *)this + 104))(this);
}

uint64_t URLProtocol::_throttle_unthrottle(URLProtocol *this)
{
  *((_BYTE *)this + 72) = 0;
  return (*(uint64_t (**)(URLProtocol *))(*(_QWORD *)this + 112))(this);
}

uint64_t URLProtocol::_throttle_getCurrentSuspensionThreshold(URLProtocol *this)
{
  return (*(uint64_t (**)(URLProtocol *))(*(_QWORD *)this + 168))(this);
}

uint64_t URLProtocol::_throttle_getMaximumWaitTime(URLProtocol *this)
{
  uint64_t result;
  double v3;

  result = objc_msgSend(*((id *)this + 10), "_timeoutInterval");
  if (v3 + -2.0 >= 0.0)
    return objc_msgSend(*((id *)this + 10), "_timeoutInterval", 0.0);
  return result;
}

uint64_t URLProtocol::needsThrottler(URLProtocol *this)
{
  return 0;
}

uint64_t `non-virtual thunk to'URLProtocol::_throttle_throttle(URLProtocol *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this - 2);
  *((_BYTE *)this + 56) = 1;
  return (*(uint64_t (**)(void))(v1 + 104))();
}

uint64_t `non-virtual thunk to'URLProtocol::_throttle_unthrottle(URLProtocol *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this - 2);
  *((_BYTE *)this + 56) = 0;
  return (*(uint64_t (**)(void))(v1 + 112))();
}

uint64_t `non-virtual thunk to'URLProtocol::_throttle_getMaximumWaitTime(URLProtocol *this)
{
  uint64_t result;
  double v3;

  result = objc_msgSend(*((id *)this + 8), "_timeoutInterval");
  if (v3 + -2.0 >= 0.0)
    return objc_msgSend(*((id *)this + 8), "_timeoutInterval", 0.0);
  return result;
}

void ___ZN11URLProtocol19invalidateThrottlerEv_block_invoke_3854(uint64_t a1)
{
  CFRelease((CFTypeRef)(*(_QWORD *)(a1 + 32) - 16));
}

BOOL XCredentialStorage::equals(XCredentialStorage *this, XCredentialStorage *a2)
{
  return this == a2;
}

void NSXCredentialStorage::setDefaultCredentialForProtectionSpace(id *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
  void *v8;

  v8 = (void *)MEMORY[0x186DB8C8C]();
  objc_msgSend(this[3], "setDefaultCredential:forProtectionSpace:task:", -[NSURLCredential _initWithCFURLCredential:]([NSURLCredential alloc], "_initWithCFURLCredential:", a2), -[NSURLProtectionSpace _initWithCFURLProtectionSpace:]([NSURLProtectionSpace alloc], "_initWithCFURLProtectionSpace:", a3), a4);
  objc_autoreleasePoolPop(v8);
}

void NSXCredentialStorage::setCredentialForProtectionSpace(id *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
  void *v8;

  v8 = (void *)MEMORY[0x186DB8C8C]();
  objc_msgSend(this[3], "setCredential:forProtectionSpace:task:", -[NSURLCredential _initWithCFURLCredential:]([NSURLCredential alloc], "_initWithCFURLCredential:", a2), -[NSURLProtectionSpace _initWithCFURLProtectionSpace:]([NSURLProtectionSpace alloc], "_initWithCFURLProtectionSpace:", a3), a4);
  objc_autoreleasePoolPop(v8);
}

void NSXCredentialStorage::removeCredentialForProtectionSpace(id *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
  void *v8;

  v8 = (void *)MEMORY[0x186DB8C8C]();
  objc_msgSend(this[3], "removeCredential:forProtectionSpace:options:task:", -[NSURLCredential _initWithCFURLCredential:]([NSURLCredential alloc], "_initWithCFURLCredential:", a2), -[NSURLProtectionSpace _initWithCFURLProtectionSpace:]([NSURLProtectionSpace alloc], "_initWithCFURLProtectionSpace:", a3), 0, a4);
  objc_autoreleasePoolPop(v8);
}

uint64_t NSXCredentialStorage::copyDefaultCredentialForProtectionSpace(NSXCredentialStorage *this, _CFURLProtectionSpace *a2, NSURLSessionTask *a3)
{
  void *v6;
  id v7;
  NSObject *v8;
  void *v9;
  uint64_t v10;
  _QWORD v12[6];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;

  v13 = 0;
  v14 = &v13;
  v15 = 0x2020000000;
  v16 = 0;
  v6 = (void *)MEMORY[0x186DB8C8C]();
  v7 = -[NSURLProtectionSpace _initWithCFURLProtectionSpace:]([NSURLProtectionSpace alloc], "_initWithCFURLProtectionSpace:", a2);
  v8 = dispatch_group_create();
  dispatch_group_enter(v8);
  v9 = (void *)*((_QWORD *)this + 3);
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 3221225472;
  v12[2] = ___ZNK20NSXCredentialStorage39copyDefaultCredentialForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke;
  v12[3] = &unk_1E14F8070;
  v12[4] = v8;
  v12[5] = &v13;
  objc_msgSend(v9, "getDefaultCredentialForProtectionSpace:task:completionHandler:", v7, a3, v12);
  dispatch_group_wait(v8, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v8);
  objc_autoreleasePoolPop(v6);
  v10 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_18402A8A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t NSXCredentialStorage::copyCredentialsForProtectionSpace(NSXCredentialStorage *this, _CFURLProtectionSpace *a2, NSURLSessionTask *a3)
{
  void *v6;
  id v7;
  NSObject *v8;
  void *v9;
  uint64_t v10;
  _QWORD v12[6];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;

  v13 = 0;
  v14 = &v13;
  v15 = 0x2020000000;
  v16 = 0;
  v6 = (void *)MEMORY[0x186DB8C8C]();
  v7 = -[NSURLProtectionSpace _initWithCFURLProtectionSpace:]([NSURLProtectionSpace alloc], "_initWithCFURLProtectionSpace:", a2);
  v8 = dispatch_group_create();
  dispatch_group_enter(v8);
  v9 = (void *)*((_QWORD *)this + 3);
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 3221225472;
  v12[2] = ___ZNK20NSXCredentialStorage33copyCredentialsForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke;
  v12[3] = &unk_1E14F80C0;
  v12[4] = v8;
  v12[5] = &v13;
  objc_msgSend(v9, "getCredentialsForProtectionSpace:task:completionHandler:", v7, a3, v12);
  dispatch_group_wait(v8, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v8);
  objc_autoreleasePoolPop(v6);
  v10 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_18402A9C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t NSXCredentialStorage::flushOrReset(uint64_t a1, int a2, uint64_t a3)
{
  void *v5;
  void *v6;
  _QWORD v8[5];

  if (a2)
  {
    v5 = (void *)MEMORY[0x186DB8C8C]();
    v6 = (void *)objc_msgSend(*(id *)(a1 + 24), "allCredentials");
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = ___ZNK20NSXCredentialStorage12flushOrResetEhU13block_pointerFvvE_block_invoke;
    v8[3] = &__block_descriptor_40_e15_v32__0_8_16_B24l;
    v8[4] = a1;
    objc_msgSend(v6, "enumerateKeysAndObjectsUsingBlock:", v8);
    objc_autoreleasePoolPop(v5);
  }
  return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
}

uint64_t ___ZNK20NSXCredentialStorage12flushOrResetEhU13block_pointerFvvE_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3;
  _QWORD v5[6];

  v3 = *(_QWORD *)(a1 + 32);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZNK20NSXCredentialStorage12flushOrResetEhU13block_pointerFvvE_block_invoke_2;
  v5[3] = &unk_1E14F80E8;
  v5[4] = a2;
  v5[5] = v3;
  return objc_msgSend(a3, "enumerateKeysAndObjectsUsingBlock:", v5);
}

uint64_t ___ZNK20NSXCredentialStorage12flushOrResetEhU13block_pointerFvvE_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 24), "removeCredential:forProtectionSpace:", a3, *(_QWORD *)(a1 + 32));
}

void ___ZNK20NSXCredentialStorage33copyCredentialsForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke(uint64_t a1, void *a2)
{
  _QWORD v4[5];

  if (a2 && objc_msgSend(a2, "count"))
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 3221225472;
    v4[2] = ___ZNK20NSXCredentialStorage33copyCredentialsForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke_2;
    v4[3] = &unk_1E14F8098;
    v4[4] = *(_QWORD *)(a1 + 40);
    objc_msgSend(a2, "enumerateKeysAndObjectsUsingBlock:", v4);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = cfTypeCreateMutableDictionary((const __CFAllocator *)*MEMORY[0x1E0C9AE00], 0, 0);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void ___ZNK20NSXCredentialStorage33copyCredentialsForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke_2(uint64_t a1, const void *a2, void *a3)
{
  const void *v5;
  CFTypeRef v6;
  const void *v7;

  v5 = (const void *)objc_msgSend(a3, "_cfurlcredential");
  if (v5)
  {
    v6 = CFRetain(v5);
    if (v6)
    {
      v7 = v6;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a2, v6);
      CFRelease(v7);
    }
  }
}

void ___ZNK20NSXCredentialStorage39copyDefaultCredentialForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke(uint64_t a1, void *a2)
{
  CFTypeRef v3;

  v3 = (CFTypeRef)objc_msgSend(a2, "_cfurlcredential");
  if (v3)
    v3 = CFRetain(v3);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v3;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

char *XCredentialStorage::createCFXCredentialStorage(XCredentialStorage *this, _CFURLCredentialStorage *a2)
{
  uint64_t v3;
  char *v4;
  char *v5;
  CFTypeRef v6;

  v3 = *MEMORY[0x1E0C9AE00];
  v4 = (char *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 32, 0);
  *(_QWORD *)(v4 + 20) = 0;
  *((_DWORD *)v4 + 7) = 0;
  *(_QWORD *)v4 = off_1E14EF578;
  *((_QWORD *)v4 + 1) = v3;
  *((_DWORD *)v4 + 4) = 1;
  if (((unint64_t)(v4 + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  v5 = v4;
  *(_QWORD *)v4 = off_1E14EB170;
  if (this)
    v6 = CFRetain(this);
  else
    v6 = 0;
  *((_QWORD *)v5 + 3) = v6;
  return v5;
}

void CFXCredentialStorage::~CFXCredentialStorage(CFXCredentialStorage *this)
{
  const void *v1;

  *(_QWORD *)this = off_1E14EB170;
  v1 = (const void *)*((_QWORD *)this + 3);
  if (v1)
    CFRelease(v1);
}

{
  const void *v2;

  *(_QWORD *)this = off_1E14EB170;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

uint64_t CFXCredentialStorage::setDefaultCredentialForProtectionSpace(CFXCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
  return CFURLCredentialStorageSetDefaultCredentialForProtectionSpace(*((_QWORD *)this + 3), (uint64_t)a2, (uint64_t)a3);
}

uint64_t CFXCredentialStorage::setCredentialForProtectionSpace(CFXCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
  return CFURLCredentialStorageSetCredentialForProtectionSpace(*((_QWORD *)this + 3), (uint64_t)a2, (uint64_t)a3);
}

void CFXCredentialStorage::removeCredentialForProtectionSpace(CFXCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
  CFURLCredentialStorageRemoveCredentialForProtectionSpace(*((_QWORD *)this + 3), (uint64_t)a2, (uint64_t)a3);
}

uint64_t CFXCredentialStorage::copyDefaultCredentialForProtectionSpace(CFXCredentialStorage *this, _CFURLProtectionSpace *a2, NSURLSessionTask *a3)
{
  return CFURLCredentialStorageCopyDefaultCredentialForProtectionSpace(*((_QWORD *)this + 3), (uint64_t)a2);
}

uint64_t CFXCredentialStorage::copyCredentialsForProtectionSpace(CFXCredentialStorage *this, _CFURLProtectionSpace *a2, NSURLSessionTask *a3)
{
  return CFURLCredentialStorageCopyCredentialsForProtectionSpace(*((_QWORD *)this + 3), (uint64_t)a2);
}

uint64_t CFXCredentialStorage::flushOrReset(uint64_t a1, int a2, uint64_t a3)
{
  const __CFDictionary *v5;
  const __CFDictionary *v6;
  unint64_t Count;
  const void **v8;
  unint64_t v9;
  const void **v10;
  uint64_t v11;
  uint64_t v12;
  const __CFDictionary *v13;
  unint64_t v14;
  const void **v15;
  const void **v16;
  uint64_t i;
  CFTypeRef v19;
  uint64_t v20;
  const void **v21;
  _BYTE v22[248];
  _QWORD v23[2];
  const void **v24;
  _BYTE v25[248];
  CFTypeRef v26;
  uint64_t v27;
  const void **v28;
  _BYTE v29[248];

  if (!a2)
    return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
  v5 = (const __CFDictionary *)CFURLCredentialStorageCopyAllCredentials(*(_QWORD *)(a1 + 24));
  if (!v5)
    return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
  v6 = v5;
  v23[0] = CFRetain(v5);
  Count = CFDictionaryGetCount(v6);
  v23[1] = Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v24 = 0;
    goto LABEL_9;
  }
  if (Count > 0x1E)
  {
    v8 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
    v24 = v8;
    if (!v8)
      goto LABEL_9;
  }
  else
  {
    v8 = (const void **)v25;
    v24 = (const void **)v25;
  }
  CFDictionaryGetKeysAndValues(v6, v8, 0);
LABEL_9:
  v26 = CFRetain(v6);
  v9 = CFDictionaryGetCount(v6);
  v27 = v9;
  if (v9 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v28 = 0;
  }
  else
  {
    if (v9 <= 0x1E)
    {
      v10 = (const void **)v29;
      v28 = (const void **)v29;
LABEL_14:
      CFDictionaryGetKeysAndValues(v6, 0, v10);
      goto LABEL_15;
    }
    v10 = (const void **)malloc_type_malloc(8 * v9, 0x89ED541CuLL);
    v28 = v10;
    if (v10)
      goto LABEL_14;
  }
LABEL_15:
  if (v27 >= 1)
  {
    v11 = 0;
    while (1)
    {
      v12 = (uint64_t)v24[v11];
      v13 = (const __CFDictionary *)v28[v11];
      if (!v13)
        break;
      v19 = CFRetain(v28[v11]);
      v14 = CFDictionaryGetCount(v13);
      v20 = v14;
      if (v14 - 1 > 0x1FFFFFFFFFFFFFFDLL)
      {
        v16 = 0;
        goto LABEL_23;
      }
      if (v14 <= 0x1E)
      {
        v21 = (const void **)v22;
        v15 = (const void **)v22;
LABEL_25:
        CFDictionaryGetKeysAndValues(v13, 0, v15);
        goto LABEL_26;
      }
      v15 = (const void **)malloc_type_malloc(8 * v14, 0x89ED541CuLL);
      v21 = v15;
      if (v15)
        goto LABEL_25;
LABEL_26:
      if (v20 >= 1)
      {
        for (i = 0; i < v20; ++i)
          CFURLCredentialStorageRemoveCredentialForProtectionSpace(*(_QWORD *)(a1 + 24), (uint64_t)v21[i], v12);
      }
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v19);
      if (v27 <= ++v11)
        goto LABEL_30;
    }
    v19 = 0;
    v20 = 0;
    v16 = (const void **)v22;
LABEL_23:
    v21 = v16;
    goto LABEL_26;
  }
LABEL_30:
  CFRelease(v6);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v26);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v23);
  return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
}

void sub_18402B008(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
  CFContainerEnumeratorBase *v43;

  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v43);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&a43);
  _Unwind_Resume(a1);
}

CFStringRef URLRequest::copyDebugDesc(URLRequest *this)
{
  __CFURL *fURL;
  CFStringRef v3;
  const char *v4;

  fURL = this->fURL;
  if (fURL)
    v3 = CFURLGetString(fURL);
  else
    v3 = CFSTR("Null URL");
  if ((*(_WORD *)&this->fFlags & 2) != 0)
    v4 = "CFMutableURLRequest";
  else
    v4 = "CFURLRequest";
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<%s %p> { url = %@ }"), v4, this, v3);
}

CFStringRef URLRequest::copyDebugSummary(URLRequest *this)
{
  HTTPRequest *fHTTPRequest;
  uint64_t v3;
  const void *v4;
  CFStringRef v5;
  __CFURL *fURL;
  CFURLRef v7;
  const __CFURL *v8;
  CFStringRef v9;
  const __CFString *v10;

  fHTTPRequest = this->fHTTPRequest;
  if (fHTTPRequest)
  {
    v3 = (*(uint64_t (**)(HTTPRequest *))(*(_QWORD *)fHTTPRequest + 32))(fHTTPRequest);
    if (v3)
    {
      v4 = (const void *)v3;
      v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("request %@"), v3);
      CFRelease(v4);
      if (v5)
        return v5;
    }
  }
  fURL = this->fURL;
  if (fURL)
  {
    v7 = CFURLCopyAbsoluteURL(fURL);
    if (v7)
    {
      v8 = v7;
      if (__CFNCanLogSensitiveContent::onceToken != -1)
        dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_26_4798);
      if (__CFNCanLogSensitiveContent::ok)
      {
        v9 = CFURLGetString(v8);
        if (!v9)
        {
          CFRelease(v8);
          return (CFStringRef)CFRetain(CFSTR("request has no url"));
        }
        v10 = (const __CFString *)CFRetain(v9);
      }
      else
      {
        v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@://%@/<redacted>"), -[__CFURL scheme](v8, "scheme"), -[__CFURL host](v8, "host"));
      }
      v5 = v10;
      CFRelease(v8);
      if (v5)
        return v5;
    }
  }
  return (CFStringRef)CFRetain(CFSTR("request has no url"));
}

CFTypeRef HTTPRequest::setCookieStorage(HTTPRequest *this, CFTypeRef cf)
{
  CFTypeRef result;

  result = (CFTypeRef)*((_QWORD *)this + 24);
  if (result != cf)
  {
    if (result)
      CFRelease(result);
    result = CFRetain(cf);
    *((_QWORD *)this + 24) = result;
  }
  return result;
}

uint64_t ___ZN10URLRequest10initializeEPK14__CFDictionary_block_invoke(uint64_t a1, const __CFString *a2, void *a3)
{
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _BYTE v14[128];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a1 + 32);
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  result = objc_msgSend(a3, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
  if (result)
  {
    v7 = result;
    v8 = *(_QWORD *)v11;
    do
    {
      v9 = 0;
      do
      {
        if (*(_QWORD *)v11 != v8)
          objc_enumerationMutation(a3);
        HTTPMessage::addHeaderFieldStringValue(*(HTTPMessage **)(v5 + 56), a2, *(const __CFString **)(*((_QWORD *)&v10 + 1) + 8 * v9++));
      }
      while (v7 != v9);
      result = objc_msgSend(a3, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
      v7 = result;
    }
    while (result);
  }
  return result;
}

CFStringRef CoreStreamBase::copyDebugDesc(CoreStreamBase *this)
{
  const __CFAllocator *v2;
  SES *v3;
  SES *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  unint64_t v8;
  char *v9;
  unint64_t v10;
  char v12[128];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = CFGetAllocator((char *)this - 16);
  v3 = (SES *)*((_QWORD *)this + 4);
  v4 = (SES *)*((_QWORD *)this + 5);
  v5 = *((_QWORD *)this + 12);
  strcpy(v12, "e:");
  v7 = &v12[SES::pushEvent(v3, (unint64_t)&v12[2], (char *)&v13, v6) + 2];
  v8 = (unint64_t)&v7[snprintf(v7, (char *)&v13 - v7, " p:")];
  v10 = SES::pushEvent(v4, v8, (char *)&v13, v9);
  snprintf((char *)(v8 + v10), (size_t)&v13 - v8 - v10, " s:%c", aNoorwecx[v5]);
  return CFStringCreateWithFormat(v2, 0, CFSTR("CoreStreamBase<%s>(%p %s)"), "", this, v12);
}

void CoreStreamBase::~CoreStreamBase(CoreStreamBase *this)
{
  CoreStreamBase::~CoreStreamBase(this);
  JUMPOUT(0x186DB748CLL);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E14E6CB0;
  *((_QWORD *)this + 1) = &unk_1E14E6D00;
  *((_QWORD *)this + 3) = 0;
  v2 = *((_QWORD *)this + 2);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  os_unfair_lock_lock((os_unfair_lock_t)this + 26);
  v3 = *((_QWORD *)this + 14);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
    *((_QWORD *)this + 14) = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 26);
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

uint64_t CoreStreamBase::streamSetClient(uint64_t this, uint64_t a2, CoreStreamClient *a3)
{
  uint64_t v3;
  uint64_t v5;

  v3 = *(_QWORD *)(this + 16);
  *(_QWORD *)(this + 16) = a3;
  if (a3)
  {
    v5 = this;
    this = (*(uint64_t (**)(CoreStreamClient *))(*(_QWORD *)a3 + 16))(a3);
    if (*(_QWORD *)(v5 + 32) != a2)
    {
      *(_QWORD *)(v5 + 32) = a2;
      ++*(_QWORD *)(v5 + 80);
      this = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v5 + 24) + 48))(*(_QWORD *)(v5 + 24), a2);
      --*(_QWORD *)(v5 + 80);
    }
  }
  if (v3)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  return this;
}

void `non-virtual thunk to'CoreStreamBase::~CoreStreamBase(CoreStreamBase *this)
{
  CoreStreamBase::~CoreStreamBase((CoreStreamBase *)((char *)this - 8));
}

{
  CoreStreamBase::~CoreStreamBase((CoreStreamBase *)((char *)this - 8));
  JUMPOUT(0x186DB748CLL);
}

void sub_18402B638(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

unint64_t SES::pushEvent(SES *this, unint64_t a2, char *a3, char *a4)
{
  unint64_t v5;
  int v7;
  unint64_t v8;
  __darwin_ct_rune_t v9;
  unint64_t v10;
  unint64_t v11;

  v5 = a2;
  if (a2 < (unint64_t)a3)
  {
    v7 = (int)this;
    v8 = 0;
    do
    {
      v9 = aOrwedm[v8];
      if (((1 << v8) & v7) == 0)
        LOBYTE(v9) = __tolower(v9);
      *(_BYTE *)(a2 + v8) = v9;
      v10 = a2 + v8 + 1;
      v11 = v8 + 1;
      if (v8 > 4)
        break;
      ++v8;
    }
    while (v10 < (unint64_t)a3);
    v5 = a2 + v11;
  }
  return v5 - a2;
}

uint64_t CoreStreamBase::copySchedulingSet(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  CoreSchedulingSet *v3;
  uint64_t Empty;

  v2 = this + 26;
  os_unfair_lock_lock(this + 26);
  Empty = *(_QWORD *)&this[28]._os_unfair_lock_opaque;
  if (!Empty)
  {
    Empty = CoreSchedulingSet::createEmpty(v3);
    *(_QWORD *)&this[28]._os_unfair_lock_opaque = Empty;
  }
  (*(void (**)(uint64_t))(*(_QWORD *)Empty + 40))(Empty);
  os_unfair_lock_unlock(v2);
  return Empty;
}

void CoreStreamBase::setSchedulingSet(os_unfair_lock_s *this, const CoreSchedulingSet *a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = this + 26;
  os_unfair_lock_lock(this + 26);
  v5 = *(_QWORD *)&this[28]._os_unfair_lock_opaque;
  if (v5)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
    *(_QWORD *)&this[28]._os_unfair_lock_opaque = 0;
  }
  if (a2)
    *(_QWORD *)&this[28]._os_unfair_lock_opaque = (*(uint64_t (**)(const CoreSchedulingSet *))(*(_QWORD *)a2 + 88))(a2);
  os_unfair_lock_unlock(v4);
}

uint64_t CoreStreamBase::_streamInterface_Open(CoreStreamBase *this)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  __int128 v7;
  char v8;

  v1 = 0;
  v8 = 0;
  if (!*((_QWORD *)this + 12))
  {
    ++*((_QWORD *)this + 10);
    *((_QWORD *)this + 12) = 1;
    v7 = 0uLL;
    v3 = (*(uint64_t (**)(_QWORD, __int128 *, char *))(**((_QWORD **)this + 3) + 56))(*((_QWORD *)this + 3), &v7, &v8);
    v1 = v3;
    if (DWORD2(v7))
    {
      *((_QWORD *)this + 12) = 7;
      *(_OWORD *)((char *)this + 56) = v7;
      *((_QWORD *)this + 5) |= 8uLL;
      v4 = 8;
    }
    else
    {
      if ((_DWORD)v3)
        v5 = v8 == 0;
      else
        v5 = 1;
      if (v5)
        goto LABEL_12;
      if (*((_QWORD *)this + 12) == 1)
        *((_QWORD *)this + 12) = 2;
      v4 = 1;
    }
    CoreStreamBase::_streamSetEventAndScheduleDelivery(this, v4, 0);
LABEL_12:
    --*((_QWORD *)this + 10);
  }
  return v1;
}

void CoreStreamBase::_streamSetEventAndScheduleDelivery(CoreStreamBase *this, uint64_t a2, int a3)
{
  uint64_t v6;
  os_unfair_lock_s *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v15[6];

  v6 = *((_QWORD *)this + 4);
  v7 = (os_unfair_lock_s *)((char *)this + 104);
  os_unfair_lock_lock((os_unfair_lock_t)this + 26);
  v8 = *((_QWORD *)this + 14);
  os_unfair_lock_unlock(v7);
  if (v8)
  {
    v9 = v6 & a2;
    v10 = CoreStreamBase::copySchedulingSet((os_unfair_lock_s *)this);
    v11 = (_DWORD *)v10;
    *((_QWORD *)this + 5) |= v9;
    if (*((_QWORD *)this + 2) && *(_DWORD *)(v10 + 40))
    {
      if (!a3 || *((_QWORD *)this + 10))
        goto LABEL_6;
      if (CoreSchedulingSet::currentlyInContext((CoreSchedulingSet *)v10))
      {
        v13 = *((_QWORD *)this + 2);
        if (v13)
        {
          CFRetain((char *)this - 16);
          (*(void (**)(uint64_t))(*(_QWORD *)v13 + 16))(v13);
          ++*((_QWORD *)this + 10);
          v14 = *((_QWORD *)this + 4) & *((_QWORD *)this + 5);
          *((_QWORD *)this + 5) = 0;
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v13 + 40))(v13, v14);
          --*((_QWORD *)this + 10);
          (*(void (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
          CFRelease((char *)this - 16);
        }
        goto LABEL_8;
      }
      if (v11[10])
      {
LABEL_6:
        v12 = *((_QWORD *)this + 2);
        if (v12)
        {
          CFRetain((char *)this - 16);
          (*(void (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12);
          v15[0] = MEMORY[0x1E0C809B0];
          v15[1] = 3221225472;
          v15[2] = ___ZN14CoreStreamBase34_streamSetEventAndScheduleDeliveryEmh_block_invoke;
          v15[3] = &__block_descriptor_48_e5_v8__0l;
          v15[4] = this;
          v15[5] = v12;
          (*(void (**)(_DWORD *, _QWORD *))(*(_QWORD *)v11 + 96))(v11, v15);
        }
      }
    }
LABEL_8:
    (*(void (**)(_DWORD *))(*(_QWORD *)v11 + 48))(v11);
  }
}

void ___ZN14CoreStreamBase34_streamSetEventAndScheduleDeliveryEmh_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 72))
  {
    v3 = *(_QWORD *)(a1 + 40);
    v4 = *(_QWORD *)(v2 + 80);
    *(_QWORD *)(v2 + 80) = v4 + 1;
    if (v3)
    {
      v5 = *(_QWORD *)(v2 + 32) & *(_QWORD *)(v2 + 40);
      *(_QWORD *)(v2 + 40) = 0;
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 40))(v3, v5);
      v4 = *(_QWORD *)(v2 + 80) - 1;
    }
    *(_QWORD *)(v2 + 80) = v4;
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 24))(*(_QWORD *)(a1 + 40));
  CFRelease((CFTypeRef)(v2 - 16));
}

void CoreStreamBase::_streamInterface_Close(CoreStreamBase *this)
{
  uint64_t v1;
  BOOL v2;

  v1 = *((_QWORD *)this + 12);
  if (v1)
    v2 = v1 == 6;
  else
    v2 = 1;
  if (!v2 && (v1 != 7 || !*((_BYTE *)this + 72)))
  {
    *((_BYTE *)this + 72) = 1;
    ++*((_QWORD *)this + 10);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 3) + 72))(*((_QWORD *)this + 3));
    *((_QWORD *)this + 12) = 6;
    --*((_QWORD *)this + 10);
    CoreStreamBase::setSchedulingSet((os_unfair_lock_s *)this, 0);
  }
}

uint64_t CoreStreamBase::_streamInterface_Deprecated_Schedule(os_unfair_lock_s *this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v6;
  const CoreSchedulingSet *v7;

  v6 = CoreStreamBase::copySchedulingSet(this);
  v7 = (const CoreSchedulingSet *)(*(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *))(*(_QWORD *)v6 + 56))(v6, a2, a3);
  CoreStreamBase::_streamInterface_UpdateScheduling((CoreStreamBase *)this, v7);
  return (*(uint64_t (**)(const CoreSchedulingSet *))(*(_QWORD *)v7 + 48))(v7);
}

void CoreStreamBase::_streamInterface_UpdateScheduling(CoreStreamBase *this, const CoreSchedulingSet *a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v8[6];
  _QWORD v9[8];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  v14 = 0;
  v15 = &v14;
  v16 = 0x2020000000;
  v17 = 0;
  v10 = 0;
  v11 = &v10;
  v12 = 0x2020000000;
  v13 = 0;
  v4 = (char *)this - 16;
  CFRetain((char *)this - 16);
  v5 = MEMORY[0x1E0C809B0];
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke;
  v9[3] = &unk_1E14F8130;
  v9[6] = this;
  v9[7] = a2;
  v9[4] = &v10;
  v9[5] = &v14;
  ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke((uint64_t)v9);
  v6 = v15[3];
  if (v6)
  {
    (*(void (**)(uint64_t, uint64_t, const CoreSchedulingSet *))(*(_QWORD *)v6 + 144))(v6, v11[3], a2);
    v8[0] = v5;
    v8[1] = 3221225472;
    v8[2] = ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke_2;
    v8[3] = &unk_1E14FDA68;
    v8[4] = &v10;
    v8[5] = this;
    ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke_2((uint64_t)v8);
  }
  v7 = v11[3];
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 48))(v7);
  CFRelease(v4);
  _Block_object_dispose(&v10, 8);
  _Block_object_dispose(&v14, 8);
}

void sub_18402BCAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  uint64_t v15;
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 112), 8);
  _Unwind_Resume(a1);
}

void ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 48);
  v3 = CoreStreamBase::copySchedulingSet((os_unfair_lock_s *)v2);
  if ((*(unsigned int (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 24))(v3, *(_QWORD *)(a1 + 56)))
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v3;
    CoreStreamBase::setSchedulingSet((os_unfair_lock_s *)v2, *(const CoreSchedulingSet **)(a1 + 56));
    ++*(_QWORD *)(v2 + 88);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = *(_QWORD *)(v2 + 24);
  }
}

uint64_t ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *(_QWORD *)(a1 + 40);
  --*(_QWORD *)(v2 + 88);
  v3 = CoreStreamBase::copySchedulingSet((os_unfair_lock_s *)v2);
  v4 = v3;
  v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v5)
  {
    if (!*(_DWORD *)(v5 + 40))
    {
      if (*(_DWORD *)(v3 + 40))
      {
        v6 = *(_QWORD *)(v2 + 40);
        if (v6)
          CoreStreamBase::_streamSetEventAndScheduleDelivery((CoreStreamBase *)v2, v6, 0);
      }
    }
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
}

uint64_t CoreStreamBase::_streamInterface_Deprecated_Unschedule(os_unfair_lock_s *this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v6;
  const CoreSchedulingSet *v7;

  v6 = CoreStreamBase::copySchedulingSet(this);
  v7 = (const CoreSchedulingSet *)(*(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *))(*(_QWORD *)v6 + 64))(v6, a2, a3);
  CoreStreamBase::_streamInterface_UpdateScheduling((CoreStreamBase *)this, v7);
  return (*(uint64_t (**)(const CoreSchedulingSet *))(*(_QWORD *)v7 + 48))(v7);
}

uint64_t CoreStreamBase::_streamInterface_GetStatus(CoreStreamBase *this)
{
  uint64_t result;
  int v3;
  uint64_t v4;
  __int128 v5;

  result = *((_QWORD *)this + 12);
  if (result == 1)
  {
    ++*((_QWORD *)this + 10);
    v5 = 0uLL;
    v3 = (*(uint64_t (**)(_QWORD, __int128 *))(**((_QWORD **)this + 3) + 64))(*((_QWORD *)this + 3), &v5);
    --*((_QWORD *)this + 10);
    if (DWORD2(v5))
    {
      *((_QWORD *)this + 12) = 7;
      *(_OWORD *)((char *)this + 56) = v5;
      *((_QWORD *)this + 5) |= 8uLL;
      v4 = 8;
    }
    else
    {
      if (!v3 || *((_QWORD *)this + 12) != 1)
        return *((_QWORD *)this + 12);
      *((_QWORD *)this + 12) = 2;
      v4 = 1;
    }
    CoreStreamBase::_streamSetEventAndScheduleDelivery(this, v4, 0);
    return *((_QWORD *)this + 12);
  }
  return result;
}

void CoreStreamBase::_signalEvent(CoreStreamBase *this, uint64_t a2, CFStreamError a3, int a4)
{
  uint64_t v5;
  CFIndex domain;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  const __CFBoolean *v11;
  const __CFBoolean *v12;

  v5 = *(_QWORD *)&a3.error;
  domain = a3.domain;
  v8 = *((_QWORD *)this + 12);
  v9 = 0;
  switch(v8)
  {
    case 0:
    case 6:
    case 7:
      goto LABEL_21;
    case 1:
      if ((a2 & 1) != 0)
        *((_QWORD *)this + 12) = 2;
      v10 = 1;
      if ((a2 & 0x10) != 0)
        goto LABEL_7;
      goto LABEL_9;
    case 5:
      v9 = a2 & 8;
      if ((a2 & 8) != 0)
        goto LABEL_12;
      goto LABEL_21;
    default:
      a2 &= ~1uLL;
      v10 = v8 < 5;
      if ((a2 & 0x10) != 0)
      {
LABEL_7:
        if (v10)
          *((_QWORD *)this + 12) = 5;
      }
LABEL_9:
      v9 = a2;
      if ((a2 & 8) == 0)
        goto LABEL_21;
LABEL_12:
      if (a3.domain == *MEMORY[0x1E0C9B298]
        && (a3.error + 9850) <= 0x2B
        && ((1 << (LOBYTE(a3.error) + 122)) & 0xC7803E80081) != 0)
      {
        ++*((_QWORD *)this + 10);
        v11 = (const __CFBoolean *)(*(uint64_t (**)(_QWORD, __CFString *))(**((_QWORD **)this + 3) + 40))(*((_QWORD *)this + 3), CFSTR("kCFStreamPropertyConnectionIsCellular"));
        --*((_QWORD *)this + 10);
        if (v11)
        {
          v12 = v11;
          if (!CFBooleanGetValue(v11))
            __CFNReportSSLSymptom(domain, v5);
          CFRelease(v12);
        }
        else
        {
          __CFNReportSSLSymptom(domain, v5);
        }
      }
      *((_QWORD *)this + 7) = domain;
      *((_QWORD *)this + 8) = v5;
      *((_QWORD *)this + 12) = 7;
LABEL_21:
      CoreStreamBase::_streamSetEventAndScheduleDelivery(this, v9, a4);
      return;
  }
}

uint64_t CoreStreamBase::_streamInterface_Read(CoreStreamBase *this, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  char v11;
  __int128 v12;

  v6 = *((_QWORD *)this + 12);
  if (v6 == 1)
  {
    CoreStreamBase::blockingWaitForOpen(this);
    v6 = *((_QWORD *)this + 12);
  }
  if ((unint64_t)(v6 - 2) >= 2)
  {
    if (v6 == 5)
      return 0;
    else
      return -1;
  }
  else
  {
    ++*((_QWORD *)this + 10);
    *((_QWORD *)this + 5) &= ~2uLL;
    *((_QWORD *)this + 12) = 3;
    v12 = 0uLL;
    v11 = 0;
    v7 = (*(uint64_t (**)(_QWORD, unsigned __int8 *, uint64_t, __int128 *, char *))(**((_QWORD **)this + 3)
                                                                                           + 80))(*((_QWORD *)this + 3), a2, a3, &v12, &v11);
    if (DWORD2(v12))
    {
      if (*((uint64_t *)this + 12) <= 5)
      {
        *(_OWORD *)((char *)this + 56) = v12;
        *((_QWORD *)this + 12) = 7;
        *((_QWORD *)this + 5) |= 8uLL;
        CoreStreamBase::_streamSetEventAndScheduleDelivery(this, 8, 0);
      }
      v8 = -1;
    }
    else
    {
      v8 = v7;
      v10 = *((_QWORD *)this + 12);
      if (v11)
      {
        if (v10 <= 4)
        {
          *((_QWORD *)this + 12) = 5;
          *((_QWORD *)this + 5) |= 0x10uLL;
          CoreStreamBase::_streamSetEventAndScheduleDelivery(this, 16, 0);
        }
      }
      else if (v10 == 3)
      {
        *((_QWORD *)this + 12) = 2;
      }
    }
    --*((_QWORD *)this + 10);
  }
  return v8;
}

void CoreStreamBase::blockingWaitForOpen(CoreStreamBase *this)
{
  char *v2;
  uint64_t v3;
  CoreSchedulingSet *Current;
  const __CFString *v5;
  const CoreSchedulingSet *v6;
  const __CFAllocator *v7;
  CFAbsoluteTime v8;
  __CFRunLoopTimer *v9;
  __CFRunLoop *v10;
  __CFRunLoop *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;

  v2 = (char *)this - 16;
  CFRetain((char *)this - 16);
  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  ++*((_QWORD *)this + 11);
  v3 = CoreStreamBase::copySchedulingSet((os_unfair_lock_s *)this);
  v13[3] = v3;
  Current = (CoreSchedulingSet *)CFRunLoopGetCurrent();
  v6 = (const CoreSchedulingSet *)CoreSchedulingSet::create(Current, CFSTR("CoreStreamOpenBlocking"), v5);
  CoreStreamBase::_streamInterface_UpdateScheduling(this, v6);
  (*(void (**)(const CoreSchedulingSet *))(*(_QWORD *)v6 + 48))(v6);
  v7 = CFGetAllocator(v2);
  v8 = CFAbsoluteTimeGetCurrent();
  v9 = CFRunLoopTimerCreateWithHandler(v7, v8 + 1.0e30, 0.0, 0, 0, &__block_literal_global_4024);
  v10 = CFRunLoopGetCurrent();
  CFRunLoopAddTimer(v10, v9, CFSTR("CoreStreamOpenBlocking"));
  while (CoreStreamBase::_streamInterface_GetStatus(this) <= 1)
    CFRunLoopRunInMode(CFSTR("CoreStreamOpenBlocking"), 1.0e30, 1u);
  CoreStreamBase::_streamInterface_UpdateScheduling(this, (const CoreSchedulingSet *)v13[3]);
  (*(void (**)(uint64_t))(*(_QWORD *)v13[3] + 48))(v13[3]);
  CFRunLoopTimerInvalidate(v9);
  CFRunLoopRunInMode(CFSTR("CoreStreamOpenBlocking"), 1.0e30, 0);
  v11 = CFRunLoopGetCurrent();
  CFRunLoopRemoveTimer(v11, v9, CFSTR("CoreStreamOpenBlocking"));
  if (v9)
    CFRelease(v9);
  --*((_QWORD *)this + 11);
  CFRelease(v2);
  _Block_object_dispose(&v12, 8);
}

void sub_18402C360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t CoreStreamBase::_streamInterface_CanRead(CoreStreamBase *this)
{
  uint64_t result;

  if ((unint64_t)(CoreStreamBase::_streamInterface_GetStatus(this) - 4) < 0xFFFFFFFFFFFFFFFELL)
    return 0;
  ++*((_QWORD *)this + 10);
  result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 88))(*((_QWORD *)this + 3));
  --*((_QWORD *)this + 10);
  return result;
}

uint64_t CoreStreamBase::_streamInterface_Write(CoreStreamBase *this, const unsigned __int8 *a2, uint64_t a3)
{
  uint64_t Status;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CoreStreamBase *v10;
  uint64_t v11;
  __int128 v13;

  if (CoreStreamBase::_streamInterface_GetStatus(this) == 1)
    CoreStreamBase::blockingWaitForOpen(this);
  Status = CoreStreamBase::_streamInterface_GetStatus(this);
  if (Status != 4 && Status != 2)
    return -1;
  ++*((_QWORD *)this + 10);
  *((_QWORD *)this + 12) = 4;
  v7 = *((_QWORD *)this + 5);
  if (v7)
    *((_QWORD *)this + 5) = v7 & 0xFFFFFFFFFFFFFFFBLL;
  v13 = 0uLL;
  v8 = (*(uint64_t (**)(_QWORD, const unsigned __int8 *, uint64_t, __int128 *))(**((_QWORD **)this + 3) + 96))(*((_QWORD *)this + 3), a2, a3, &v13);
  v9 = v8;
  if (DWORD2(v13))
  {
    *((_QWORD *)this + 12) = 7;
    *(_OWORD *)((char *)this + 56) = v13;
    *((_QWORD *)this + 5) |= 8uLL;
    v10 = this;
    v11 = 8;
  }
  else
  {
    if (v8)
    {
      if (*((_QWORD *)this + 12) == 4)
        *((_QWORD *)this + 12) = 2;
      goto LABEL_10;
    }
    *((_QWORD *)this + 12) = 5;
    *((_QWORD *)this + 5) |= 0x10uLL;
    v10 = this;
    v11 = 16;
  }
  CoreStreamBase::_streamSetEventAndScheduleDelivery(v10, v11, 0);
LABEL_10:
  --*((_QWORD *)this + 10);
  return v9;
}

uint64_t CoreStreamBase::_streamInterface_CanWrite(CoreStreamBase *this)
{
  uint64_t Status;
  uint64_t result;

  Status = CoreStreamBase::_streamInterface_GetStatus(this);
  if (Status != 4 && Status != 2)
    return 0;
  ++*((_QWORD *)this + 10);
  result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 104))(*((_QWORD *)this + 3));
  --*((_QWORD *)this + 10);
  return result;
}

void setSSLProp(_CFURLRequest *a1, const __CFString *a2, const void *a3)
{
  const __CFDictionary *v6;
  __CFDictionary *MutableCopy;
  const __CFDictionary *v8;

  v6 = *(const __CFDictionary **)(-[_CFURLRequest _inner](a1, "_inner") + 72);
  if (v6)
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v6);
  else
    MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v8 = MutableCopy;
  CFDictionarySetValue(MutableCopy, a2, a3);
  CFURLRequestSetSSLProperties(a1, v8);
  CFRelease(v8);
}

CFStringRef URLResponse::copyDebugDesc(URLResponse *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<URLResponse %p { url = %@ }"), this, this->fURL);
}

CFStringRef URLResponse::copyDebugSummary(URLResponse *this)
{
  uint64_t v2;
  uint64_t v3;
  HTTPResponse *fHTTP;
  const void *v5;
  CFStringRef v6;

  if (__CFNCanLogSensitiveContent::onceToken != -1)
    dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_26_4798);
  if (__CFNCanLogSensitiveContent::ok)
    v2 = -[__CFURL absoluteString](this->fURL, "absoluteString");
  else
    v2 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@://%@/<redacted>"), -[__CFURL scheme](this->fURL, "scheme"), -[__CFURL host](this->fURL, "host"));
  v3 = v2;
  fHTTP = this->fHTTP;
  if (!fHTTP)
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("response from %@"), v3);
  v5 = (const void *)(*(uint64_t (**)(HTTPResponse *))(*(_QWORD *)fHTTP + 32))(fHTTP);
  v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("response from %@, %@"), v3, v5);
  if (v5)
    CFRelease(v5);
  return v6;
}

void *URLResponse::initialize(uint64_t a1, CFTypeRef cf, const __CFString *a3, uint64_t a4, const __CFString *a5, int a6)
{
  const __CFAllocator *v11;
  void *result;

  v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (cf)
    result = (void *)CFRetain(cf);
  else
    result = 0;
  *(_QWORD *)(a1 + 8) = result;
  if (a3)
  {
    result = (void *)CFStringCreateCopy(v11, a3);
    *(_QWORD *)(a1 + 16) = result;
  }
  if (a5)
  {
    result = (void *)CFStringCreateCopy(v11, a5);
    *(_QWORD *)(a1 + 24) = result;
  }
  *(_QWORD *)(a1 + 32) = a4;
  *(_DWORD *)(a1 + 72) = a6;
  return result;
}

const __CFString *URLResponse::copySuggestedFilename(URLResponse *this)
{
  HTTPResponse *fHTTP;
  const __CFString *HeaderFieldValue;
  const __CFString *v4;
  const __CFString *FilenameFromContentDispositionHeader;
  __CFURL *fURL;
  __CFString *fMIMEType;
  const __CFURL *SemiColonEscapedURLIfParamterIsPresent;
  const __CFURL *v9;
  const __CFString *PathComponent;
  const __CFString *v11;
  const __CFString *v12;
  const __CFString *v13;
  const __CFAllocator *v14;
  CFStringRef v15;
  CFStringRef SanitizedFileNameFromString;
  __CFString *v17;
  const __CFString *v18;
  const __CFString *v19;
  CFStringRef v20;
  const __CFAllocator *v21;
  CFStringRef v22;
  int64_t MaximumSizeOfFileSystemRepresentation;
  CFIndex v24;
  char *v25;
  const __CFAllocator *v26;
  CFStringRef v27;
  CFStringRef v28;
  char buffer[256];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  fHTTP = this->fHTTP;
  if (fHTTP)
  {
    HeaderFieldValue = HTTPMessage::copyLastHeaderFieldValue((HTTPMessage *)fHTTP, 0x11A272B3u);
    if (HeaderFieldValue)
    {
      v4 = HeaderFieldValue;
      FilenameFromContentDispositionHeader = createFilenameFromContentDispositionHeader(HeaderFieldValue);
      CFRelease(v4);
      if (FilenameFromContentDispositionHeader)
        goto LABEL_29;
    }
  }
  fURL = this->fURL;
  if (!fURL)
  {
LABEL_28:
    FilenameFromContentDispositionHeader = (const __CFString *)CFRetain(CFSTR("Unknown"));
    goto LABEL_29;
  }
  fMIMEType = this->fMIMEType;
  SemiColonEscapedURLIfParamterIsPresent = cfnCreateSemiColonEscapedURLIfParamterIsPresent(this->fURL);
  if (SemiColonEscapedURLIfParamterIsPresent)
  {
    v9 = SemiColonEscapedURLIfParamterIsPresent;
    PathComponent = CFURLCopyLastPathComponent(SemiColonEscapedURLIfParamterIsPresent);
    CFRelease(v9);
    if (!PathComponent)
      goto LABEL_12;
  }
  else
  {
    PathComponent = CFURLCopyLastPathComponent(fURL);
    if (!PathComponent)
      goto LABEL_12;
  }
  if (CFStringGetLength(PathComponent) && !CFEqual(PathComponent, CFSTR("/")))
    goto LABEL_17;
  CFRelease(PathComponent);
LABEL_12:
  v11 = CFURLCopyHostName(fURL);
  if (!v11)
    goto LABEL_28;
  PathComponent = v11;
  if (CFStringCompare(v11, CFSTR("localhost"), 1uLL) == kCFCompareEqualTo)
  {
    CFRelease(PathComponent);
    goto LABEL_28;
  }
  if (fMIMEType)
  {
    v12 = copyPreferredExtensionForMIMEType(fMIMEType);
    if (v12)
    {
      v13 = v12;
      v14 = CFGetAllocator(fURL);
      v15 = CFStringCreateWithFormat(v14, 0, CFSTR("%@.%@"), PathComponent, v13);
      CFRelease(PathComponent);
      CFRelease(v13);
      PathComponent = v15;
      if (!v15)
        goto LABEL_28;
    }
  }
LABEL_17:
  if (CFStringGetLength(PathComponent)
    && (SanitizedFileNameFromString = createSanitizedFileNameFromString(PathComponent)) != 0)
  {
    FilenameFromContentDispositionHeader = SanitizedFileNameFromString;
    v17 = this->fMIMEType;
    if (v17)
    {
      if (CFStringCompare(v17, (CFStringRef)&unk_1EDCFF8F0, 1uLL))
      {
        v18 = copyPreferredExtensionForMIMEType(this->fMIMEType);
        if (v18)
        {
          v19 = v18;
          v20 = copyExtensionFromName(FilenameFromContentDispositionHeader);
          if (!v20)
          {
            v21 = CFGetAllocator(FilenameFromContentDispositionHeader);
            v22 = CFStringCreateWithFormat(v21, 0, CFSTR("%@.%@"), FilenameFromContentDispositionHeader, v19);
            v20 = FilenameFromContentDispositionHeader;
            FilenameFromContentDispositionHeader = v22;
          }
          CFRelease(v20);
          CFRelease(v19);
        }
      }
    }
  }
  else
  {
    FilenameFromContentDispositionHeader = (const __CFString *)CFRetain(CFSTR("Unknown"));
  }
  CFRelease(PathComponent);
LABEL_29:
  MaximumSizeOfFileSystemRepresentation = CFStringGetMaximumSizeOfFileSystemRepresentation(FilenameFromContentDispositionHeader);
  if (MaximumSizeOfFileSystemRepresentation != -1)
  {
    v24 = MaximumSizeOfFileSystemRepresentation;
    if (MaximumSizeOfFileSystemRepresentation >= 257)
    {
      v25 = (char *)malloc_type_malloc(MaximumSizeOfFileSystemRepresentation, 0x7116E0C4uLL);
      if (!v25)
        return FilenameFromContentDispositionHeader;
    }
    else
    {
      v25 = buffer;
    }
    if (CFStringGetFileSystemRepresentation(FilenameFromContentDispositionHeader, v25, v24)
      && (v26 = CFGetAllocator(FilenameFromContentDispositionHeader),
          (v27 = CFStringCreateWithFileSystemRepresentation(v26, v25)) != 0))
    {
      v28 = v27;
      if (FilenameFromContentDispositionHeader)
        CFRelease(FilenameFromContentDispositionHeader);
    }
    else
    {
      v28 = FilenameFromContentDispositionHeader;
    }
    if (v25 != buffer)
      free(v25);
    return v28;
  }
  return FilenameFromContentDispositionHeader;
}

CFStringRef copyExtensionFromName(const __CFString *a1)
{
  CFIndex location;
  CFIndex Length;
  CFIndex v4;
  CFIndex v5;
  int v6;
  CFStringRef result;
  const __CFAllocator *v8;
  CFRange v9;
  CFRange v10;
  CFRange v11;
  CFRange v12;

  v10.length = CFStringGetLength(a1);
  v10.location = 0;
  if (!CFStringFindWithOptions(a1, CFSTR("."), v10, 4uLL, &v9))
    return 0;
  location = v9.location;
  Length = CFStringGetLength(a1);
  v4 = Length + ~v9.location;
  if (v4 < 1)
    return 0;
  v5 = location + 1;
  v11.location = v5;
  v11.length = Length + ~v9.location;
  v6 = CFStringFindWithOptions(a1, CFSTR(" "), v11, 0, 0);
  result = 0;
  if (!v6)
  {
    v8 = CFGetAllocator(a1);
    v12.location = v5;
    v12.length = v4;
    return CFStringCreateWithSubstring(v8, a1, v12);
  }
  return result;
}

void sub_18402D430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18402D54C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_18402D608(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_18402D6C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_18402D788(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__4402(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__4403(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_184031A50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

void sub_1840323CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id copyDecodedResumeData(NSData *a1)
{
  id v2;
  uint64_t v3;

  if (!a1)
    return 0;
  v2 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3710]), "initForReadingFromData:error:", a1, 0);
  objc_msgSend(v2, "setDecodingFailurePolicy:", 1);
  if (resumeDataClasses(void)::onceToken != -1)
    dispatch_once(&resumeDataClasses(void)::onceToken, &__block_literal_global_392);
  v3 = objc_msgSend((id)objc_msgSend(v2, "decodeObjectOfClasses:forKey:", resumeDataClasses(void)::resumeDataClasses, CFSTR("NSKeyedArchiveRootObjectKey")), "copy");
  objc_msgSend(v2, "finishDecoding");
  if (!v3)
    return (id)objc_msgSend(MEMORY[0x1E0CB38B0], "propertyListWithData:options:format:error:", a1, 0, 0, 0);
  return (id)v3;
}

uint64_t ___ZL17resumeDataClassesv_block_invoke_4541()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  double v7;
  double v8;
  uint64_t v9;
  uint64_t result;

  v0 = (void *)MEMORY[0x1E0C99E20];
  v1 = objc_opt_class();
  v2 = objc_opt_class();
  v3 = objc_opt_class();
  v4 = objc_opt_class();
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  resumeDataClasses(void)::resumeDataClasses = (uint64_t)(id)objc_msgSend(v0, "setWithObjects:", v1, v2, v3, v4, v5, v6, objc_opt_class(), 0);
  gotLoadHelper_x20__OBJC_CLASS___SZExtractor(v7);
  if (objc_opt_class())
  {
    v9 = objc_msgSend(*(id *)(v1 + 3688), "knownSZExtractorImplementations");
    objc_msgSend((id)resumeDataClasses(void)::resumeDataClasses, "unionSet:", v9);
  }
  gotLoadHelper_x20__OBJC_CLASS___STRemoteExtractor(v8);
  result = objc_opt_class();
  if (result)
    return objc_msgSend((id)resumeDataClasses(void)::resumeDataClasses, "addObject:", objc_opt_class());
  return result;
}

uint64_t __Block_byref_object_copy__105(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(result + 48) = v2;
  return result;
}

void __Block_byref_object_dispose__106(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 48);
  *(_QWORD *)(a1 + 48) = 0;
  if (v2)
    CFRelease(v2);
}

CFStringRef URLDownload::copyDebugDesc(URLDownload *this)
{
  char *v2;
  const __CFAllocator *v3;
  uint64_t v4;
  uint64_t (*v5)(_QWORD);
  uint64_t v6;
  const void *v7;
  const __CFString *v8;
  CFStringRef v9;
  uint64_t v11;
  const __CFString *v12;

  v2 = (char *)this - 16;
  v3 = CFGetAllocator((char *)this - 16);
  v4 = *((_QWORD *)this + 21);
  if (!v4)
  {
    v11 = *((_QWORD *)this + 3);
    v12 = (const __CFString *)*((_QWORD *)this + 26);
    if (!v12)
      v12 = CFSTR("path not determined");
    return CFStringCreateWithFormat(v3, 0, CFSTR("<CFURLDownload %p [%p]> {connection = %@, path = %@, client = %p}"), v2, v3, v11, v12, v4);
  }
  v5 = *(uint64_t (**)(_QWORD))(v4 + 32);
  if (!v5)
  {
    v11 = *((_QWORD *)this + 3);
    v12 = (const __CFString *)*((_QWORD *)this + 26);
    if (!v12)
      v12 = CFSTR("path not determined");
LABEL_16:
    v4 = *(_QWORD *)(v4 + 8);
    return CFStringCreateWithFormat(v3, 0, CFSTR("<CFURLDownload %p [%p]> {connection = %@, path = %@, client = %p}"), v2, v3, v11, v12, v4);
  }
  v6 = v5(*(_QWORD *)(v4 + 8));
  if (!v6)
  {
    v4 = *((_QWORD *)this + 21);
    v11 = *((_QWORD *)this + 3);
    v12 = (const __CFString *)*((_QWORD *)this + 26);
    if (!v12)
      v12 = CFSTR("path not determined");
    if (!v4)
      return CFStringCreateWithFormat(v3, 0, CFSTR("<CFURLDownload %p [%p]> {connection = %@, path = %@, client = %p}"), v2, v3, v11, v12, v4);
    goto LABEL_16;
  }
  v7 = (const void *)v6;
  v8 = (const __CFString *)*((_QWORD *)this + 26);
  if (!v8)
    v8 = CFSTR("path not determined");
  v9 = CFStringCreateWithFormat(v3, 0, CFSTR("<CFURLDownload %p [%p]> {connection = %@, path = %@, client = %@}"), v2, v3, *((_QWORD *)this + 3), v8, v6);
  CFRelease(v7);
  return v9;
}

void `non-virtual thunk to'URLDownload::~URLDownload(URLDownload *this)
{
  URLDownload::~URLDownload((URLDownload *)((char *)this - 8));
}

{
  URLDownload::~URLDownload((URLDownload *)((char *)this - 8));
}

void URLDownload::~URLDownload(URLDownload *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;

  *(_QWORD *)this = &off_1E14E54E0;
  *((_QWORD *)this + 1) = &unk_1E14E5528;
  URLDownload::_internal_releaseClient(this);
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 2);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 25);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 26);
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 27);
  if (v6)
    CFRelease(v6);
  v7 = (const void *)*((_QWORD *)this + 29);
  if (v7)
    CFRelease(v7);
  v8 = (const void *)*((_QWORD *)this + 30);
  if (v8)
    CFRelease(v8);

  v9 = (const void *)*((_QWORD *)this + 32);
  if (v9)
    CFRelease(v9);
  v10 = (const void *)*((_QWORD *)this + 31);
  if (v10)
    CFRelease(v10);
  v11 = (const void *)*((_QWORD *)this + 28);
  if (v11)
    CFRelease(v11);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 36) + 48))(*((_QWORD *)this + 36));
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

void sub_1840366D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

double URLDownload::_internal_releaseClient(URLDownload *this)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;
  void (*v5)(void);
  double result;
  int v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 21))
  {
    v2 = (unsigned int *)((char *)this + 176);
    do
    {
      v3 = __ldaxr(v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, v2));
    if (!v4)
    {
      if (!*((_QWORD *)this + 20) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        v7 = 136315138;
        v8 = "T *ClientContextHolder<CFURLDownloadClient>::forget() [T = CFURLDownloadClient]";
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "%s called before remember", (uint8_t *)&v7, 0xCu);
      }
      if (*((_QWORD *)this + 5))
      {
        v5 = (void (*)(void))*((_QWORD *)this + 7);
        if (v5)
          v5();
      }
      result = 0.0;
      *((_OWORD *)this + 9) = 0u;
      *((_OWORD *)this + 10) = 0u;
      *((_OWORD *)this + 7) = 0u;
      *((_OWORD *)this + 8) = 0u;
      *((_OWORD *)this + 5) = 0u;
      *((_OWORD *)this + 6) = 0u;
      *((_OWORD *)this + 3) = 0u;
      *((_OWORD *)this + 4) = 0u;
      *((_OWORD *)this + 2) = 0u;
    }
  }
  return result;
}

void ___ZN11URLDownload5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CFURLDownload");
  URLDownload::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_184036828(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t URLDownload::_internal_setClient(uint64_t result, _QWORD *__src)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(void);
  int v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (__src)
  {
    v3 = result;
    if (*__src && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v6) = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "you shouldn't be using CFURLDownload; use NSURLSession ",
        (uint8_t *)&v6,
        2u);
    }
    v4 = v3 + 32;
    if (*(_QWORD *)(v3 + 160) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      v6 = 136315138;
      v7 = "T *ClientContextHolder<CFURLDownloadClient>::remember(const T *) [T = CFURLDownloadClient]";
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "%s called before forget", (uint8_t *)&v6, 0xCu);
    }
    memmove((void *)(v3 + 32), __src, 0x80uLL);
    result = *(_QWORD *)(v3 + 40);
    if (result)
    {
      v5 = *(uint64_t (**)(void))(v3 + 48);
      if (v5)
      {
        result = v5();
        *(_QWORD *)(v3 + 40) = result;
      }
    }
    *(_QWORD *)(v3 + 160) = v4;
    *(_QWORD *)(v3 + 168) = v4;
    *(_DWORD *)(v3 + 176) = 1;
  }
  return result;
}

DownloadConnectionClient *DownloadConnectionClient::_implRetain(DownloadConnectionClient *this, const void *a2)
{
  CFRetain((char *)this - 16);
  return this;
}

void DownloadConnectionClient::_implRelease(DownloadConnectionClient *this, const void *a2)
{
  CFRelease((char *)this - 16);
}

CFStringRef DownloadConnectionClient::_copyDescription(DownloadConnectionClient *this, const void *a2)
{
  CFStringRef v2;
  CFStringRef v3;

  v2 = CFCopyDescription((char *)this - 16);
  v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("CFURLConnectionClient[%@]"), v2);
  CFRelease(v2);
  return v3;
}

CFTypeRef DownloadConnectionClient::_willSendRequestCallback(DownloadConnectionClient *this, CFTypeRef cf, const _CFURLRequest *a3, _CFURLResponse *a4, const void *a5)
{
  uint64_t v8;
  uint64_t (*v9)(char *, CFTypeRef, const _CFURLRequest *, _QWORD, const void *);
  uint64_t v10;
  void (*v11)(char *, _QWORD);

  if (!*((_BYTE *)a4 + 286))
  {
    *((_BYTE *)a4 + 286) = 1;
    v10 = *((_QWORD *)a4 + 21);
    if (v10)
    {
      v11 = *(void (**)(char *, _QWORD))(v10 + 40);
      if (v11)
        v11((char *)a4 - 16, *(_QWORD *)(v10 + 8));
    }
  }
  v8 = *((_QWORD *)a4 + 21);
  if (v8
    && (v9 = *(uint64_t (**)(char *, CFTypeRef, const _CFURLRequest *, _QWORD, const void *))(v8 + 48)) != 0)
  {
    cf = (CFTypeRef)v9((char *)a4 - 16, cf, a3, *(_QWORD *)(v8 + 8), a5);
    if (cf)
      return cf;
  }
  else if (cf)
  {
    CFRetain(cf);
    return cf;
  }
  if (a3)
    URLDownload::_internal_downloadFinished((URLDownload *)a4);
  else
    URLDownload::_internal_downloadFailed((URLDownload *)a4, 0);
  return 0;
}

void DownloadConnectionClient::_didReceiveResponseCallback(DownloadConnectionClient *this, _CFURLResponse *a2, _CFURLResponse *a3, const void *a4)
{
  int v6;
  uint64_t v7;
  CFIndex ResponseStatusCode;
  CFIndex v9;
  char v11;
  uint64_t v12;
  void (*v13)(char *, _QWORD);
  const void *v14;
  const __CFAllocator *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  CFIndex v21;
  __CFError *CFError;
  uint64_t v23;
  void (*v24)(char *, _CFURLResponse *, _QWORD, _QWORD);
  uint64_t v25;

  if (!*((_BYTE *)a3 + 286))
  {
    *((_BYTE *)a3 + 286) = 1;
    v12 = *((_QWORD *)a3 + 21);
    if (v12)
    {
      v13 = *(void (**)(char *, _QWORD))(v12 + 40);
      if (v13)
        v13((char *)a3 - 16, *(_QWORD *)(v12 + 8));
    }
  }
  URLDownload::_internal_setResponse((URLDownload *)a3, a2);
  v6 = *((unsigned __int8 *)a3 + 285);
  v7 = *(_QWORD *)(-[_CFURLResponse _inner](a2, "_inner") + 88);
  if (!v7)
  {
    if (v6)
    {
LABEL_14:
      *((_QWORD *)a3 + 34) = 0;
      v14 = (const void *)*((_QWORD *)a3 + 25);
      if (v14)
      {
        CFRelease(v14);
        v11 = 0;
        *((_QWORD *)a3 + 25) = 0;
      }
      else
      {
        v11 = 0;
      }
LABEL_22:
      if (*((_BYTE *)a3 + 285))
      {
        *((_BYTE *)a3 + 285) = v11;
        v23 = *((_QWORD *)a3 + 21);
        if (v23)
        {
          v24 = *(void (**)(char *, _CFURLResponse *, _QWORD, _QWORD))(v23 + 72);
          if (v24)
            v24((char *)a3 - 16, a2, *((_QWORD *)a3 + 34), *(_QWORD *)(v23 + 8));
        }
      }
      else
      {
        v25 = *((_QWORD *)a3 + 21);
        if (v25 && *(_QWORD *)(v25 + 72))
          (*(void (**)(char *, _CFURLResponse *, _QWORD))(v25 + 64))((char *)a3 - 16, a2, *(_QWORD *)(v25 + 8));
      }
      return;
    }
LABEL_9:
    v11 = 1;
    goto LABEL_22;
  }
  ResponseStatusCode = CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)(v7 - 16));
  v9 = ResponseStatusCode;
  if ((unint64_t)(ResponseStatusCode - 100) < 0x12C)
  {
    if (ResponseStatusCode != 206 && v6 != 0)
      goto LABEL_14;
    goto LABEL_9;
  }
  v15 = CFGetAllocator((char *)a3 - 16);
  if (v9 == 403)
    v21 = -1102;
  else
    v21 = -1100;
  CFError = __cfnCreateCFError(v15, CFSTR("kCFErrorDomainCFNetwork"), v21, v16, v17, v18, v19, v20, 0);
  URLDownload::_internal_downloadCancel((URLDownload *)a3, CFError);
  if (CFError)
    CFRelease(CFError);
}

void DownloadConnectionClient::_didReceiveDataCallback(DownloadConnectionClient *this, CFDataRef theData, const __CFData *a3, URLDownload *a4, const void *a5)
{
  __CFError *v7;
  __CFError *v8;
  uint8_t v9[16];

  if ((const __CFData *)CFDataGetLength(theData) != a3 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v9 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "originalLength is not really necessary here.", v9, 2u);
  }
  v7 = URLDownload::_internal_downloadProcessData(a4, theData);
  if (v7)
  {
    v8 = v7;
    URLDownload::_internal_downloadCancel(a4, v7);
    CFRelease(v8);
  }
}

void DownloadConnectionClient::_connectionDidFinishLoadingCallback(DownloadConnectionClient *this, _CFURLConnection *a2, const void *a3)
{
  char *v4;
  uint64_t v5;
  const __CFData *v6;
  __CFError *v7;
  void *v8;
  _QWORD v9[6];

  v4 = (char *)a2 - 16;
  CFRetain((char *)a2 - 16);
  *((_BYTE *)a2 + 284) = 1;
  if (!*((_BYTE *)a2 + 280))
  {
    v6 = (const __CFData *)*((_QWORD *)a2 + 31);
    if (v6)
    {
      *((_BYTE *)a2 + 280) = 1;
      v7 = URLDownload::_internal_downloadProcessData((URLDownload *)a2, v6);
      CFRelease(*((CFTypeRef *)a2 + 31));
      *((_QWORD *)a2 + 31) = 0;
      if (v7)
      {
        URLDownload::_internal_downloadCancel((URLDownload *)a2, v7);
        CFRelease(v7);
      }
    }
    else if (!*((_QWORD *)a2 + 33))
    {
      v8 = URLDownload::_internal_downloadOpenTarget((URLDownload *)a2);
      *((_QWORD *)a2 + 33) = v8;
      if (!v8)
        URLDownload::_internal_downloadFailedWithCFNetworkError((URLDownload *)a2, -3000);
    }
  }
  v5 = *((_QWORD *)a2 + 33);
  if (v5)
  {
    *((_QWORD *)a2 + 33) = 0;
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke;
    v9[3] = &__block_descriptor_48_e61_v16__0__CFURLDownloadClient_q_v_____________________________8l;
    v9[4] = a2;
    v9[5] = v5;
    URLDownload::_internal_withClientScheduling((uint64_t)a2, (uint64_t)v9);
  }
  CFRelease(v4);
}

void sub_184036E24(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void DownloadConnectionClient::_didFailCallback(DownloadConnectionClient *this, _CFURLConnection *a2, __CFError *a3, const void *a4)
{
  uint64_t v6;
  void (*v7)(char *, _QWORD);

  if (!*((_BYTE *)a3 + 286))
  {
    *((_BYTE *)a3 + 286) = 1;
    v6 = *((_QWORD *)a3 + 21);
    if (v6)
    {
      v7 = *(void (**)(char *, _QWORD))(v6 + 40);
      if (v7)
        v7((char *)a3 - 16, *(_QWORD *)(v6 + 8));
    }
  }
  URLDownload::_internal_downloadCancel(a3, (__CFError *)a2);
}

uint64_t DownloadConnectionClient::_willCacheResponseCallback(DownloadConnectionClient *this, _CFURLConnection *a2, const _CFCachedURLResponse *a3, const void *a4)
{
  return 0;
}

void DownloadConnectionClient::_didReceiveAuthenticationChallengeCallback(DownloadConnectionClient *this, const _CFURLCredential *cf, _CFURLAuthChallenge *a3, const void *a4)
{
  uint64_t v6;
  void (*v7)(char *, const _CFURLCredential *, _QWORD);
  CFTypeRef v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void (*v15)(char *, _QWORD);

  if (!*((_BYTE *)a3 + 286))
  {
    *((_BYTE *)a3 + 286) = 1;
    v14 = *((_QWORD *)a3 + 21);
    if (v14)
    {
      v15 = *(void (**)(char *, _QWORD))(v14 + 40);
      if (v15)
        v15((char *)a3 - 16, *(_QWORD *)(v14 + 8));
    }
  }
  v6 = *((_QWORD *)a3 + 21);
  if (v6 && (v7 = *(void (**)(char *, const _CFURLCredential *, _QWORD))(v6 + 56)) != 0)
  {
    if (cf)
    {
      v8 = CFRetain(cf);
      v6 = *((_QWORD *)a3 + 21);
      v7 = *(void (**)(char *, const _CFURLCredential *, _QWORD))(v6 + 56);
    }
    else
    {
      v8 = 0;
    }
    *((_QWORD *)a3 + 24) = v8;
    v7((char *)a3 - 16, cf, *(_QWORD *)(v6 + 8));
  }
  else
  {
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
    v9 = (char *)cf + 16;
    if (!cf)
      v9 = 0;
    v10 = *((_QWORD *)v9 + 4);
    if (v10
      && (v11 = URLCredential_PasswordBased::safelyCast(*((_QWORD *)v9 + 4), cf)) != 0
      && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v11 + 136))(v11))
    {
      v12 = *((_QWORD *)a3 + 2);
      v13 = v10;
    }
    else
    {
      v12 = *((_QWORD *)a3 + 2);
      v13 = 0;
    }
    CFURLConnectionUseCredential(v12, v13, (uint64_t)cf);
  }
}

uint64_t DownloadConnectionClient::_shouldUseCredentialStorageCallback(DownloadConnectionClient *this, _CFURLConnection *a2, const void *a3)
{
  return *((unsigned __int8 *)a2 + 320);
}

__CFDictionary *createDownloadConnectionProperties(const __CFAllocator *a1)
{
  __CFDictionary *MutableDictionary;
  __CFDictionary *v3;

  MutableDictionary = cfTypeCreateMutableDictionary(a1, 0x1EDCFA5D0, *MEMORY[0x1E0C9AE50], 0, 0);
  v3 = cfTypeCreateMutableDictionary(a1, CFSTR("kCFURLConnectionSocketStreamProperties"), MutableDictionary, 0, 0);
  if (MutableDictionary)
    CFRelease(MutableDictionary);
  return v3;
}

void URLDownload::_internal_downloadCancel(URLDownload *this, __CFError *a2)
{
  uint64_t v4;
  AsyncTargetFile *v5;
  char v6;
  char v7[1035];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)this + 287))
  {
    *((_BYTE *)this + 287) = 1;
    v4 = *((_QWORD *)this + 2);
    if (v4)
      CFURLConnectionCancel(v4);
    v5 = (AsyncTargetFile *)*((_QWORD *)this + 33);
    if (v5)
    {
      AsyncTargetFile::close(v5, (uint64_t *)this + 34);
      (*(void (**)(_QWORD))(**((_QWORD **)this + 33) + 48))(*((_QWORD *)this + 33));
      *((_QWORD *)this + 33) = 0;
      if (*((_BYTE *)this + 281))
      {
        FilePathStorage<unsigned char>::FilePathStorage((uint64_t)&v6, *((CFURLRef *)this + 26), 0, 0, 1u);
        if (v6)
        {
          if (unlink(v7))
            __error();
        }
      }
    }
    URLDownload::_internal_downloadFailed(this, a2);
  }
}

uint64_t AsyncTargetFile::close(AsyncTargetFile *this, uint64_t *a2)
{
  NSObject *v2;
  uint64_t v3;
  _QWORD block[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2020000000;
  v9 = -1;
  *a2 = 0;
  v2 = *((_QWORD *)this + 3);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN15AsyncTargetFile5closeEPx_block_invoke;
  block[3] = &unk_1E14FD7A8;
  block[4] = &v6;
  block[5] = this;
  block[6] = a2;
  dispatch_sync(v2, block);
  v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void URLDownload::_internal_downloadFailed(URLDownload *this, __CFError *a2)
{
  int v4;
  uint64_t v5;
  void (*v6)(char *, __CFError *, _QWORD);

  v4 = URLDownload::_internal_downloadEnded(this);
  v5 = *((_QWORD *)this + 21);
  if (v5)
  {
    if (a2)
    {
      v6 = *(void (**)(char *, __CFError *, _QWORD))(v5 + 120);
      if (v6)
        v6((char *)this - 16, a2, *(_QWORD *)(v5 + 8));
    }
  }
  if (v4)
  {
    URLDownload::_internal_releaseClient(this);
    CFRelease((char *)this - 16);
  }
}

uint64_t URLDownload::_internal_downloadEnded(URLDownload *this)
{
  const void *v2;
  const void *v3;

  if (!*((_BYTE *)this + 282))
    return 0;
  *((_BYTE *)this + 282) = 0;
  v2 = (const void *)*((_QWORD *)this + 2);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 2) = 0;
  v3 = (const void *)*((_QWORD *)this + 24);
  if (v3)
    CFRelease(v3);
  *((_QWORD *)this + 24) = 0;
  return 1;
}

CFErrorRef URLDownload::_internal_downloadProcessData(URLDownload *this, CFDataRef theData)
{
  CFIndex Length;
  const __CFData *v5;
  __CFData *v6;
  CFIndex v7;
  const UInt8 *BytePtr;
  const __CFData *MutableCopy;
  const __CFAllocator *v10;
  const __CFArray *v11;
  CFIndex v12;
  CFIndex v13;
  CFTypeRef v14;
  CFIndex v15;
  const void *v16;
  int v17;
  CFErrorRef v18;
  void *v19;
  const __CFAllocator *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  void (*v28)(char *, _QWORD, _QWORD);
  const __CFAllocator *v29;
  CFMutableArrayRef Mutable;
  CFArrayRef v31;
  char v33;
  const __CFAllocator *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  CFErrorRef CFError;
  const __CFAllocator *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const __CFAllocator *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  CFTypeRef v53;
  uint64_t v54;
  CFIndex Count;
  CFIndex v56;
  const __CFData *v57;
  const __CFString *ValueAtIndex;
  uint64_t Instance;
  _OWORD *v60;
  uint64_t (**v61)(CFObject *__hidden, const CFObject *);
  _OWORD *v62;
  uint64_t (**v63)(CFObject *__hidden, const CFObject *);
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  const void *v67;
  void *v68;
  const void *v69;
  CFTypeRef v70;
  CFIndex v71;
  CFIndex v72;
  CFIndex v73;
  _QWORD *v74;
  void *v75;
  CFIndex v76;
  CFIndex v77;
  NSObject *v78;
  int v79;
  const __CFAllocator *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _BOOL4 v86;
  _QWORD v87[6];
  const void *v88;
  const void *v89;
  void *values;
  uint64_t v91;
  uint64_t (*v92)(_QWORD *);
  void *v93;
  _QWORD *v94;
  _QWORD *v95;
  CFTypeRef v96;
  CFIndex v97;
  const void *v98;
  CFIndex v99;
  uint64_t v100;

  v100 = *MEMORY[0x1E0C80C00];
  Length = CFDataGetLength(theData);
  if (!*((_BYTE *)this + 280))
  {
    v6 = (__CFData *)*((_QWORD *)this + 31);
    if (v6)
    {
      v7 = Length;
      BytePtr = CFDataGetBytePtr(theData);
      CFDataAppendBytes(v6, BytePtr, v7);
      MutableCopy = (const __CFData *)*((_QWORD *)this + 31);
    }
    else
    {
      v10 = CFGetAllocator((char *)this - 16);
      MutableCopy = CFDataCreateMutableCopy(v10, 0, theData);
      *((_QWORD *)this + 31) = MutableCopy;
      if (!MutableCopy)
      {
        v41 = CFGetAllocator((char *)this - 16);
        return __cfnCreateCFError(v41, (CFErrorDomain)*MEMORY[0x1E0C9AFD0], 12, v42, v43, v44, v45, v46, 0);
      }
    }
    if (CFDataGetLength(MutableCopy) > 0x2000)
    {
      v5 = (const __CFData *)*((_QWORD *)this + 31);
      *((_QWORD *)this + 31) = 0;
      *((_BYTE *)this + 280) = 1;
      goto LABEL_10;
    }
    goto LABEL_8;
  }
  if (!theData)
  {
LABEL_8:
    v5 = 0;
    goto LABEL_10;
  }
  v5 = (const __CFData *)CFRetain(theData);
LABEL_10:
  if (!*((_QWORD *)this + 33))
  {
    if (*((_BYTE *)this + 285))
    {
      v19 = URLDownload::_internal_downloadOpenTarget(this);
      *((_QWORD *)this + 33) = v19;
      if (!v19)
      {
        v20 = CFGetAllocator((char *)this - 16);
        return __cfnCreateCFError(v20, CFSTR("kCFErrorDomainCFNetwork"), -3001, v21, v22, v23, v24, v25, 0);
      }
    }
  }
  if (!v5 || !CFDataGetLength(v5))
  {
    if (!*((_BYTE *)this + 287))
    {
      v27 = *((_QWORD *)this + 21);
      if (v27)
      {
        v28 = *(void (**)(char *, _QWORD, _QWORD))(v27 + 80);
        if (v28)
          v28((char *)this - 16, 0, *(_QWORD *)(v27 + 8));
      }
    }
    v18 = 0;
    if (!v5)
      return v18;
    goto LABEL_111;
  }
  v88 = 0;
  v89 = 0;
  v11 = (const __CFArray *)*((_QWORD *)this + 32);
  if (!v11)
  {
    v29 = CFGetAllocator((char *)this - 16);
    Mutable = CFArrayCreateMutable(v29, 0, MEMORY[0x1E0C9B378]);
    *((_QWORD *)this + 32) = Mutable;
    if (!Mutable)
    {
      v47 = CFGetAllocator((char *)this - 16);
      CFError = __cfnCreateCFError(v47, (CFErrorDomain)*MEMORY[0x1E0C9AFD0], 12, v48, v49, v50, v51, v52, 0);
      goto LABEL_39;
    }
    if (!URLDownload::_internal_decodeHeaderData(__CFData const*,__CFData const**,__CFData const**)::sSupportedDecoderMIMETypeArray)
    {
      values = &unk_1EDCFFB20;
      v91 = 0x1EDCFF880;
      v92 = (uint64_t (*)(_QWORD *))CFSTR("application/macbinary");
      v31 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 3, MEMORY[0x1E0C9B378]);
      while (!__ldaxr((unint64_t *)&URLDownload::_internal_decodeHeaderData(__CFData const*,__CFData const**,__CFData const**)::sSupportedDecoderMIMETypeArray))
      {
        if (!__stlxr((unint64_t)v31, (unint64_t *)&URLDownload::_internal_decodeHeaderData(__CFData const*,__CFData const**,__CFData const**)::sSupportedDecoderMIMETypeArray))
        {
          v33 = 1;
          goto LABEL_42;
        }
      }
      v33 = 0;
      __clrex();
LABEL_42:
      if ((v33 & 1) == 0 && v31)
        CFRelease(v31);
    }
    v54 = *((_QWORD *)this + 21);
    if (v54)
      v86 = *(_QWORD *)(v54 + 88) != 0;
    else
      v86 = 0;
    Count = CFArrayGetCount((CFArrayRef)URLDownload::_internal_decodeHeaderData(__CFData const*,__CFData const**,__CFData const**)::sSupportedDecoderMIMETypeArray);
    if (Count < 1)
    {
LABEL_81:
      if (CFArrayGetCount(*((CFArrayRef *)this + 32)))
      {
        v67 = v88;
        v53 = v89;
LABEL_85:
        if (!*((_QWORD *)this + 33))
        {
          v68 = URLDownload::_internal_downloadOpenTarget(this);
          *((_QWORD *)this + 33) = v68;
          if (!v68)
          {
            v80 = CFGetAllocator((char *)this - 16);
            v18 = __cfnCreateCFError(v80, CFSTR("kCFErrorDomainCFNetwork"), -3001, v81, v82, v83, v84, v85, 0);
            if (v18)
            {
LABEL_107:
              if (v53)
                CFRelease(v53);
              if (v67)
                CFRelease(v67);
              goto LABEL_111;
            }
          }
        }
        CFRetain((char *)this - 16);
        v69 = (const void *)*((_QWORD *)this + 2);
        if (v69)
        {
          v70 = CFRetain(v69);
          if (v53)
            goto LABEL_89;
        }
        else
        {
          v70 = 0;
          if (v53)
          {
LABEL_89:
            v71 = CFDataGetLength((CFDataRef)v53);
            if (v67)
            {
LABEL_90:
              v72 = CFDataGetLength((CFDataRef)v67);
              goto LABEL_94;
            }
LABEL_93:
            v72 = 0;
LABEL_94:
            v73 = v72 + v71;
            os_unfair_lock_lock((os_unfair_lock_t)this + 76);
            *((_QWORD *)this + 37) += v73;
            os_unfair_lock_unlock((os_unfair_lock_t)this + 76);
            v74 = (_QWORD *)*((_QWORD *)this + 33);
            v75 = (void *)MEMORY[0x1E0C809B0];
            v87[0] = MEMORY[0x1E0C809B0];
            v87[1] = 3221225472;
            v87[2] = ___ZN11URLDownload29_internal_downloadProcessDataEPK8__CFData_block_invoke;
            v87[3] = &__block_descriptor_48_e11_v20__0Q8i16l;
            v87[4] = this;
            v87[5] = v70;
            if (v53)
            {
              v76 = CFDataGetLength((CFDataRef)v53);
              if (v67)
                goto LABEL_96;
            }
            else
            {
              v76 = 0;
              if (v67)
              {
LABEL_96:
                v77 = CFDataGetLength((CFDataRef)v67);
                if (!v53)
                  goto LABEL_101;
                goto LABEL_100;
              }
            }
            v77 = 0;
            if (!v53)
            {
LABEL_101:
              if (v67)
                CFRetain(v67);
              (*(void (**)(_QWORD *))(*v74 + 40))(v74);
              v78 = v74[3];
              values = v75;
              v91 = 3221225472;
              v92 = ___ZN15AsyncTargetFile5writeEPK8__CFDataS2_U13block_pointerFvmiE_block_invoke;
              v93 = &unk_1E14F8AE8;
              v96 = v53;
              v97 = v76;
              v98 = v67;
              v99 = v77;
              v94 = v87;
              v95 = v74;
              dispatch_async(v78, &values);
              if (*((_QWORD *)this + 37) > 0x200000uLL)
              {
                v79 = *((_DWORD *)this + 77);
                *((_DWORD *)this + 77) = v79 + 1;
                if (!v79)
                  CFURLConnectionHalt((uint64_t)v70);
              }
              v18 = 0;
              goto LABEL_107;
            }
LABEL_100:
            CFRetain(v53);
            goto LABEL_101;
          }
        }
        v71 = 0;
        if (v67)
          goto LABEL_90;
        goto LABEL_93;
      }
      v53 = CFRetain(v5);
LABEL_84:
      v67 = 0;
      goto LABEL_85;
    }
    v56 = 0;
    v57 = v5;
    while (1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)URLDownload::_internal_decodeHeaderData(__CFData const*,__CFData const**,__CFData const**)::sSupportedDecoderMIMETypeArray, v56);
      CFGetAllocator((char *)this - 16);
      if (CFStringCompare(ValueAtIndex, (CFStringRef)&unk_1EDCFFB20, 1uLL))
      {
        if (CFStringCompare(ValueAtIndex, CFSTR("application/mac-binhex40"), 1uLL))
        {
          if (CFStringCompare(ValueAtIndex, CFSTR("application/macbinary"), 1uLL))
            goto LABEL_76;
          if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1)
            dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2564);
          Instance = _CFRuntimeCreateInstance();
          *(_OWORD *)(Instance + 16) = 0u;
          v60 = (_OWORD *)(Instance + 16);
          *(_OWORD *)(Instance + 112) = 0u;
          *(_OWORD *)(Instance + 128) = 0u;
          *(_OWORD *)(Instance + 32) = 0u;
          *(_OWORD *)(Instance + 48) = 0u;
          *(_OWORD *)(Instance + 80) = 0u;
          *(_OWORD *)(Instance + 96) = 0u;
          *(_OWORD *)(Instance + 64) = 0u;
          *(_DWORD *)(Instance + 44) = 0;
          *(_WORD *)(Instance + 140) = 0;
          *(_BYTE *)(Instance + 48) = 0;
          *(_QWORD *)(Instance + 112) = 0;
          *(_QWORD *)(Instance + 120) = 0;
          *(_DWORD *)(Instance + 128) = 0;
          *(_BYTE *)(Instance + 40) = 1;
          v61 = &off_1E14EF628;
        }
        else
        {
          if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1)
            dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2564);
          v64 = _CFRuntimeCreateInstance();
          *(_OWORD *)(v64 + 16) = 0u;
          v60 = (_OWORD *)(v64 + 16);
          *(_OWORD *)(v64 + 64) = 0u;
          *(_OWORD *)(v64 + 80) = 0u;
          *(_OWORD *)(v64 + 160) = 0u;
          *(_OWORD *)(v64 + 176) = 0u;
          *(_OWORD *)(v64 + 128) = 0u;
          *(_OWORD *)(v64 + 144) = 0u;
          *(_OWORD *)(v64 + 96) = 0u;
          *(_OWORD *)(v64 + 112) = 0u;
          *(_OWORD *)(v64 + 32) = 0u;
          *(_OWORD *)(v64 + 48) = 0u;
          *(_DWORD *)(v64 + 48) = 0;
          *(_BYTE *)(v64 + 104) = 0;
          *(_QWORD *)(v64 + 60) = 0;
          *(_QWORD *)(v64 + 68) = 0;
          *(_QWORD *)(v64 + 75) = 0;
          *(_QWORD *)(v64 + 180) = 0;
          *(_BYTE *)(v64 + 40) = 1;
          v61 = &off_1E14EF1C8;
        }
        v63 = v61;
        *((_QWORD *)v60 + 1) = "GZip";
        *((_QWORD *)v60 + 2) = v61 + 10;
        *(_QWORD *)v60 = v61;
      }
      else
      {
        if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1)
          dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2564);
        v62 = (_OWORD *)_CFRuntimeCreateInstance();
        v60 = v62;
        if (v62)
        {
          v62[1] = 0uLL;
          v60 = v62 + 1;
          v62[9] = 0uLL;
          v62[10] = 0uLL;
          v62[7] = 0uLL;
          v62[8] = 0uLL;
          v62[5] = 0uLL;
          v62[6] = 0uLL;
          v62[3] = 0uLL;
          v62[4] = 0uLL;
          v62[2] = 0uLL;
        }
        *(_QWORD *)v60 = &off_1E14ED3B0;
        *((_QWORD *)v60 + 1) = "GZip";
        *((_QWORD *)v60 + 2) = &off_1E14ECA80;
        *(_OWORD *)((char *)v60 + 40) = 0uLL;
        *(_OWORD *)((char *)v60 + 56) = 0uLL;
        *(_OWORD *)((char *)v60 + 72) = 0uLL;
        *(_OWORD *)((char *)v60 + 88) = 0uLL;
        *(_OWORD *)((char *)v60 + 104) = 0uLL;
        *(_OWORD *)((char *)v60 + 120) = 0uLL;
        *(_OWORD *)((char *)v60 + 24) = 0uLL;
        *((_BYTE *)v60 + 152) = inflateInit2_((z_streamp)((char *)v60 + 24), -15, "1.2.12", 112) == 0;
        *((_QWORD *)v60 + 17) = 0;
        *(_WORD *)((char *)v60 + 153) = 0;
        *(_QWORD *)v60 = &off_1E14EEBD8;
        *((_QWORD *)v60 + 2) = &unk_1E14EEC28;
        v63 = &off_1E14EEBD8;
      }
      v65 = ((uint64_t (*)(MacBinaryDownloadDataDecoderHolder *))v63[7])((MacBinaryDownloadDataDecoderHolder *)v60);
      if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v65 + 16))(v65))
        goto LABEL_75;
      if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1)
        dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2564);
      v66 = (*(uint64_t (**)(_OWORD *))(*(_QWORD *)v60 + 56))(v60);
      if (!(*(unsigned int (**)(uint64_t, const __CFData *))(*(_QWORD *)v66 + 32))(v66, v57)
        || !CFURLDownloadDataDecoderDecodeData((uint64_t)(v60 - 1), (uint64_t)v57, (uint64_t)&v89, (uint64_t)&v88))
      {
LABEL_75:
        CFRelease(v60 - 1);
LABEL_76:
        ++v56;
        goto LABEL_77;
      }
      if (v86
        && !(*(unsigned int (**)(char *, const __CFString *, _QWORD))(*((_QWORD *)this + 21) + 88))((char *)this - 16, ValueAtIndex, *(_QWORD *)(*((_QWORD *)this + 21) + 8)))
      {
        CFRelease(v60 - 1);
        goto LABEL_81;
      }
      CFArrayAppendValue(*((CFMutableArrayRef *)this + 32), v60 - 1);
      CFRelease(v60 - 1);
      if (v57 != v5)
        CFRelease(v57);
      v56 = 0;
      v57 = (const __CFData *)v89;
LABEL_77:
      if (v56 >= Count || !v57)
        goto LABEL_81;
    }
  }
  v12 = CFArrayGetCount(v11);
  if (v12 < 1)
    goto LABEL_81;
  v13 = v12;
  v14 = CFRetain(v5);
  v15 = 0;
  while (1)
  {
    v16 = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 32), v15);
    v17 = CFURLDownloadDataDecoderDecodeData((uint64_t)v16, (uint64_t)v14, (uint64_t)&v89, (uint64_t)&v88);
    if (v14)
      CFRelease(v14);
    if (!v17)
      break;
    v14 = v89;
    if (v13 == ++v15)
      goto LABEL_81;
  }
  v34 = CFGetAllocator((char *)this - 16);
  CFError = __cfnCreateCFError(v34, CFSTR("kCFErrorDomainCFNetwork"), -3006, v35, v36, v37, v38, v39, 0);
LABEL_39:
  v18 = CFError;
  if (!CFError)
  {
    v53 = 0;
    goto LABEL_84;
  }
LABEL_111:
  CFRelease(v5);
  return v18;
}

void sub_184037C14(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 16) = off_1E14E9D70;
  _Unwind_Resume(a1);
}

void *URLDownload::_internal_downloadOpenTarget(URLDownload *this)
{
  uint64_t v2;
  BOOL v3;
  int v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  void *v8;
  const __CFString *v9;
  const __CFString *v10;
  CFTypeRef v11;
  uint64_t v12;
  const __CFURL *v13;
  const __CFURL *SemiColonEscapedURLIfParamterIsPresent;
  const __CFURL *v15;
  CFStringRef PathComponent;
  const __CFString *v17;
  const __CFAllocator *v18;
  CFURLRef v19;
  const __CFURL *v20;
  char *v21;
  size_t v22;
  uint64_t v23;
  BOOL v24;
  int v25;
  int v26;
  int v27;
  char v28;
  const __CFAllocator *v29;
  size_t v30;
  const void *v31;
  void *v32;
  const void *v33;
  char v34;
  uint64_t v35;
  CFTypeRef v36;
  char *v37;
  const __CFAllocator *v38;
  CFAllocatorRef v39;
  ssize_t v40;
  stat v42;
  char __source[8];
  char v44;
  stat __dst[7];
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 25);
  if (*((_BYTE *)this + 285))
    v3 = v2 == 0;
  else
    v3 = 1;
  v4 = !v3;
  if (v2)
    goto LABEL_8;
  v7 = *((_QWORD *)this + 21);
  if (v7)
  {
    if (*(_QWORD *)(v7 + 96))
    {
      v8 = (void *)*((_QWORD *)this + 23);
      if (v8)
      {
        v9 = URLResponse::copySuggestedFilename((URLResponse *)objc_msgSend(v8, "_inner"));
        if (v9)
        {
          v10 = v9;
          v11 = URLDownload::_internal_copySuggestedFilenameFromOriginalFilename(this, v9);
          (*(void (**)(char *, CFTypeRef, _QWORD))(*((_QWORD *)this + 21) + 96))((char *)this - 16, v11, *(_QWORD *)(*((_QWORD *)this + 21) + 8));
          CFRelease(v10);
          CFRelease(v11);
          if (*((_QWORD *)this + 25))
          {
LABEL_8:
            v5 = operator new();
            FilePathStorage<unsigned char>::FilePathStorage(v5, *((CFURLRef *)this + 25), 0, 0, 1u);
            if (*(_BYTE *)v5)
            {
              v6 = 0;
              goto LABEL_40;
            }
            MEMORY[0x186DB748C](v5, 0x1000C4048165BC6);
          }
        }
      }
    }
  }
  if (!*((_QWORD *)this + 27))
    goto LABEL_31;
  v12 = objc_msgSend(*((id *)this + 3), "_inner");
  v13 = *(const __CFURL **)(v12 + 8);
  if (!v13)
    goto LABEL_31;
  SemiColonEscapedURLIfParamterIsPresent = cfnCreateSemiColonEscapedURLIfParamterIsPresent(*(const __CFURL **)(v12 + 8));
  if (SemiColonEscapedURLIfParamterIsPresent)
  {
    v15 = SemiColonEscapedURLIfParamterIsPresent;
    PathComponent = CFURLCopyLastPathComponent(SemiColonEscapedURLIfParamterIsPresent);
    CFRelease(v15);
    if (!PathComponent)
    {
LABEL_31:
      v5 = operator new();
      *(_BYTE *)v5 = 1;
      *(_DWORD *)(v5 + 1028) = 0;
      v21 = (char *)(v5 + 1);
      v22 = confstr(65537, (char *)(v5 + 1), 0x400uLL);
      if (!v22 || v22 + 8 > 0x400)
        goto LABEL_60;
      v23 = 0;
      v44 = 0;
      *(_QWORD *)__source = 0;
      while (1)
      {
        do
          __source[v23++] = FilePathStorage<unsigned char>::makeTempPath(void)::validChars[arc4random() % 0x24];
        while (v23 != 8);
        strlcpy((char *)__dst, v21, 0x400uLL);
        strlcat((char *)__dst, __source, 0x400uLL);
        if (stat((const char *)__dst, &v42))
          break;
        v23 = 0;
      }
      if (*__error() != 2)
        goto LABEL_60;
      strlcpy(v21, (const char *)__dst, 0x400uLL);
      if (!*(_BYTE *)v5)
        goto LABEL_60;
      goto LABEL_39;
    }
  }
  else
  {
    PathComponent = CFURLCopyLastPathComponent(v13);
    if (!PathComponent)
      goto LABEL_31;
  }
  if (!CFStringGetLength(PathComponent))
  {
    CFRelease(PathComponent);
    PathComponent = CFURLCopyHostName(v13);
    if (!PathComponent)
      goto LABEL_31;
  }
  v17 = (const __CFString *)URLDownload::_internal_copySuggestedFilenameFromOriginalFilename(this, PathComponent);
  v18 = CFGetAllocator((char *)this - 16);
  v19 = CFURLCreateCopyAppendingPathComponent(v18, *((CFURLRef *)this + 27), v17, 0);
  if (v19)
  {
    v20 = v19;
    v5 = operator new();
    FilePathStorage<unsigned char>::FilePathStorage(v5, v20, 0, 0, 1u);
    if (!*(_BYTE *)v5)
    {
      MEMORY[0x186DB748C](v5, 0x1000C4048165BC6);
      v5 = 0;
    }
    CFRelease(v20);
    if (v17)
      goto LABEL_29;
  }
  else
  {
    v5 = 0;
    if (v17)
LABEL_29:
      CFRelease(v17);
  }
  CFRelease(PathComponent);
  if (!v5)
    goto LABEL_31;
LABEL_39:
  v6 = 1;
LABEL_40:
  if (v4)
    v24 = *((_QWORD *)this + 34) != 0;
  else
    v24 = 0;
  if (*((_BYTE *)this + 283))
    v25 = 1537;
  else
    v25 = 2561;
  if (v4)
    v26 = open((const char *)(v5 + 1), 1, 438);
  else
    v26 = open((const char *)(v5 + 1), v25, 438);
  v27 = v26;
  if (v26 < 0)
    __error();
  v28 = !v24;
  if (v27 == -1)
    v28 = 1;
  if ((v28 & 1) != 0)
  {
    if (v27 == -1)
    {
LABEL_60:
      MEMORY[0x186DB748C](v5, 0x1000C4048165BC6);
      return 0;
    }
  }
  else if (lseek(v27, 0, 2) == -1)
  {
    if (close(v27))
      __error();
    goto LABEL_60;
  }
  if ((v6 & 1) != 0)
  {
    v29 = CFGetAllocator((char *)this - 16);
    v30 = strlen((const char *)(v5 + 1));
    v31 = CFURLCreateFromFileSystemRepresentation(v29, (const UInt8 *)(v5 + 1), v30, 0);
    goto LABEL_63;
  }
  v33 = (const void *)*((_QWORD *)this + 25);
  if (v33)
  {
    v31 = CFRetain(v33);
LABEL_63:
    *((_QWORD *)this + 26) = v31;
    if (v31)
      v34 = v4;
    else
      v34 = 1;
    if ((v34 & 1) == 0)
    {
      v35 = *((_QWORD *)this + 21);
      if (v35)
      {
        if (*(_QWORD *)(v35 + 104))
        {
          v36 = CFRetain(v31);
          (*(void (**)(char *, CFTypeRef, _QWORD))(*((_QWORD *)this + 21) + 104))((char *)this - 16, v36, *(_QWORD *)(*((_QWORD *)this + 21) + 8));
          if (v36)
            CFRelease(v36);
        }
      }
    }
    goto LABEL_72;
  }
  *((_QWORD *)this + 26) = 0;
LABEL_72:
  MEMORY[0x186DB748C](v5, 0x1000C4048165BC6);
  v37 = (char *)this - 16;
  v38 = CFGetAllocator((char *)this - 16);
  v32 = CFAllocatorAllocate(v38, 48, 0);
  *(_OWORD *)v32 = 0u;
  *((_OWORD *)v32 + 2) = 0u;
  *((_OWORD *)v32 + 1) = 0u;
  v39 = CFGetAllocator(v37);
  *(_QWORD *)v32 = off_1E14EF578;
  *((_QWORD *)v32 + 1) = v39;
  *((_DWORD *)v32 + 4) = 1;
  if ((((unint64_t)v32 + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)v32 = off_1E14E7338;
  *((_DWORD *)v32 + 5) = v27;
  *((_QWORD *)v32 + 3) = dispatch_queue_create("com.apple.URLDownload", 0);
  *((_QWORD *)v32 + 4) = 0;
  if ((fstat(*((_DWORD *)v32 + 5), __dst) & 0x80000000) == 0)
    *((_QWORD *)v32 + 4) = __dst[0].st_size;
  v40 = fgetxattr(*((_DWORD *)v32 + 5), "com.apple.ResourceFork", 0, 0, 0, 0);
  *((_QWORD *)v32 + 5) = v40 & ~(v40 >> 63);
  return v32;
}

void sub_1840381F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x1000C4048165BC6);
  _Unwind_Resume(a1);
}

void URLDownload::_internal_downloadFailedWithCFNetworkError(URLDownload *this, CFIndex a2)
{
  const __CFAllocator *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFError *CFError;

  v4 = CFGetAllocator((char *)this - 16);
  CFError = __cfnCreateCFError(v4, CFSTR("kCFErrorDomainCFNetwork"), a2, v5, v6, v7, v8, v9, 0);
  URLDownload::_internal_downloadCancel(this, CFError);
  if (CFError)
    CFRelease(CFError);
}

uint64_t ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke(uint64_t a1)
{
  uint64_t v2;
  int v3;
  void (*v4)(uint64_t);
  uint64_t *v5;
  uint64_t v7;
  uint64_t v8;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = AsyncTargetFile::close(*(AsyncTargetFile **)(a1 + 40), (uint64_t *)(v2 + 272));
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 48))(*(_QWORD *)(a1 + 40));
  if (v3)
  {
    v7 = MEMORY[0x1E0C809B0];
    v4 = ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke_3;
    v5 = &v7;
  }
  else
  {
    v8 = MEMORY[0x1E0C809B0];
    v4 = ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke_2;
    v5 = &v8;
  }
  v5[1] = 3221225472;
  v5[2] = (uint64_t)v4;
  v5[3] = (uint64_t)&__block_descriptor_40_e61_v16__0__CFURLDownloadClient_q_v_____________________________8l;
  v5[4] = v2;
  return URLDownload::_internal_withClientScheduling(v2, (uint64_t)v5);
}

uint64_t URLDownload::_internal_withClientScheduling(uint64_t a1, uint64_t a2)
{
  _DWORD *v4;
  _OWORD *v5;
  __CFRunLoop *v6;
  const __CFString *v7;
  _OWORD *v8;
  unsigned int *v9;
  unsigned int v10;
  uint64_t v11;
  _QWORD v13[7];

  v4 = *(_DWORD **)(a1 + 288);
  if (v4[10])
  {
    v5 = (_OWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)v4 + 88))(v4);
  }
  else
  {
    v6 = +[NSURLConnection resourceLoaderRunLoop](NSURLConnection, "resourceLoaderRunLoop");
    v5 = CoreSchedulingSet::create((CoreSchedulingSet *)v6, (const __CFString *)*MEMORY[0x1E0C9B280], v7);
  }
  v8 = v5;
  CFRetain((CFTypeRef)(a1 - 16));
  v9 = (unsigned int *)(a1 + 176);
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 + 1, v9));
  if ((v10 & 0x80000000) != 0)
    v11 = 0;
  else
    v11 = *(_QWORD *)(a1 + 168);
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3221225472;
  v13[2] = ___ZN11URLDownload30_internal_withClientSchedulingEU13block_pointerFvP19CFURLDownloadClientE_block_invoke;
  v13[3] = &unk_1E14FDB30;
  v13[4] = a2;
  v13[5] = a1;
  v13[6] = v11;
  (*(void (**)(_OWORD *, _QWORD *))(*(_QWORD *)v8 + 96))(v8, v13);
  return (*(uint64_t (**)(_OWORD *))(*(_QWORD *)v8 + 48))(v8);
}

void ___ZN11URLDownload30_internal_withClientSchedulingEU13block_pointerFvP19CFURLDownloadClientE_block_invoke(_QWORD *a1)
{
  URLDownload *v1;

  v1 = (URLDownload *)a1[5];
  (*(void (**)(_QWORD, _QWORD))(a1[4] + 16))(a1[4], a1[6]);
  URLDownload::_internal_releaseClient(v1);
  CFRelease((char *)v1 - 16);
}

void ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke_3(uint64_t a1)
{
  URLDownload::_internal_downloadFailedWithCFNetworkError(*(URLDownload **)(a1 + 32), -3002);
}

void ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke_2(uint64_t a1)
{
  URLDownload::_internal_downloadFinished(*(URLDownload **)(a1 + 32));
}

void URLDownload::_internal_downloadFinished(URLDownload *this)
{
  int v2;
  uint64_t v3;
  void (*v4)(char *, _QWORD);

  v2 = URLDownload::_internal_downloadEnded(this);
  v3 = *((_QWORD *)this + 21);
  if (v3)
  {
    v4 = *(void (**)(char *, _QWORD))(v3 + 112);
    if (v4)
      v4((char *)this - 16, *(_QWORD *)(v3 + 8));
  }
  if (v2)
  {
    URLDownload::_internal_releaseClient(this);
    CFRelease((char *)this - 16);
  }
}

CFTypeRef URLDownload::_internal_copySuggestedFilenameFromOriginalFilename(URLDownload *this, CFTypeRef cf)
{
  CFTypeRef v3;
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex i;
  char *ValueAtIndex;
  char *v9;
  char *v10;
  uint64_t v11;
  CFAllocatorRef v12;
  uint64_t v13;

  v3 = CFRetain(cf);
  v4 = (const __CFArray *)*((_QWORD *)this + 32);
  if (!v4)
    return v3;
  Count = CFArrayGetCount(v4);
  if (Count < 1)
    return v3;
  v6 = Count;
  for (i = 0; i != v6; ++i)
  {
    ValueAtIndex = (char *)CFArrayGetValueAtIndex(*((CFArrayRef *)this + 32), i);
    if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1)
      dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2564);
    if (ValueAtIndex)
      v9 = ValueAtIndex + 16;
    else
      v9 = 0;
    v10 = v9 - 16;
    v11 = (*(uint64_t (**)(char *))(*(_QWORD *)v9 + 56))(v9);
    v12 = CFGetAllocator(v10);
    v13 = (*(uint64_t (**)(uint64_t, CFAllocatorRef, CFTypeRef))(*(_QWORD *)v11 + 48))(v11, v12, v3);
    if (v3)
      CFRelease(v3);
    v3 = (CFTypeRef)v13;
  }
  return (CFTypeRef)v13;
}

void AsyncTargetFile::~AsyncTargetFile(AsyncTargetFile *this)
{
  uint64_t v2;

  AsyncTargetFile::~AsyncTargetFile(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint8_t v2[16];

  *(_QWORD *)this = off_1E14E7338;
  if (*((_DWORD *)this + 5) != -1 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v2 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "you should have closed the file by now", v2, 2u);
  }
  dispatch_release(*((dispatch_object_t *)this + 3));
}

uint64_t AsyncTargetFile::equals(AsyncTargetFile *this, const CFAllocatedReferenceCountedObject *a2)
{
  return 0;
}

uint64_t ___ZN11URLDownload29_internal_downloadProcessDataEPK8__CFData_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  _QWORD v5[4];
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN11URLDownload29_internal_downloadProcessDataEPK8__CFData_block_invoke_2;
  v5[3] = &__block_descriptor_60_e61_v16__0__CFURLDownloadClient_q_v_____________________________8l;
  v3 = *(_QWORD *)(a1 + 40);
  v6 = *(_QWORD *)(a1 + 32);
  v7 = a2;
  v8 = v3;
  v9 = a3;
  return URLDownload::_internal_withClientScheduling(v6, (uint64_t)v5);
}

uint64_t ___ZN15AsyncTargetFile5writeEPK8__CFDataS2_U13block_pointerFvmiE_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  const __CFData *v3;
  const UInt8 *BytePtr;
  uint64_t v5;
  const UInt8 *v6;
  const UInt8 *v7;
  ssize_t v8;
  int v9;
  const __CFData *v10;
  int v11;
  const UInt8 *v12;
  const void *v13;
  const void *v14;

  v2 = a1[5];
  if (*(_DWORD *)(v2 + 20) != -1)
  {
    v3 = (const __CFData *)a1[6];
    if (!v3)
      goto LABEL_13;
    BytePtr = CFDataGetBytePtr(v3);
    v5 = a1[7];
    if (v5 < 1)
      goto LABEL_13;
    v6 = BytePtr;
    v7 = &BytePtr[v5];
    do
    {
      while (1)
      {
        v8 = write(*(_DWORD *)(v2 + 20), v6, v7 - v6);
        if (v8 == -1)
          break;
        v6 += v8;
        *(_QWORD *)(v2 + 32) += v8;
        if (v6 >= v7)
          goto LABEL_13;
      }
      v9 = *__error();
      --v6;
      --*(_QWORD *)(v2 + 32);
    }
    while (v6 < v7);
    if (v9)
    {
      if (close(*(_DWORD *)(v2 + 20)))
        __error();
      *(_DWORD *)(v2 + 20) = -1;
    }
    else
    {
LABEL_13:
      v10 = (const __CFData *)a1[8];
      if (v10)
      {
        v11 = *(_DWORD *)(v2 + 20);
        v12 = CFDataGetBytePtr(v10);
        if (fsetxattr(v11, "com.apple.ResourceFork", v12, a1[9], *(_DWORD *)(v2 + 40), 0))
        {
          if (close(*(_DWORD *)(v2 + 20)))
            __error();
          *(_DWORD *)(v2 + 20) = -1;
        }
        *(_QWORD *)(v2 + 40) += a1[9];
      }
    }
  }
  v13 = (const void *)a1[6];
  if (v13)
    CFRelease(v13);
  v14 = (const void *)a1[8];
  if (v14)
    CFRelease(v14);
  (*(void (**)(void))(a1[4] + 16))();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

void ___ZN11URLDownload29_internal_downloadProcessDataEPK8__CFData_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  const __CFAllocator *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __CFError *CFError;
  uint64_t v12;
  void (*v13)(uint64_t, _QWORD, _QWORD);

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 304));
  *(_QWORD *)(v2 + 296) -= v3;
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 304));
  if (*(_DWORD *)(v2 + 308) && !(*(_QWORD *)(v2 + 296) >> 18))
  {
    *(_DWORD *)(v2 + 308) = 0;
    CFURLConnectionResume(*(_QWORD *)(a1 + 48));
  }
  if (!*(_BYTE *)(v2 + 287))
  {
    if (*(_DWORD *)(a1 + 56))
    {
      v5 = CFGetAllocator((CFTypeRef)(v2 - 16));
      CFError = __cfnCreateCFError(v5, CFSTR("kCFErrorDomainCFNetwork"), -3003, v6, v7, v8, v9, v10, 0);
      URLDownload::_internal_downloadCancel((URLDownload *)v2, CFError);
      if (CFError)
        CFRelease(CFError);
    }
    else
    {
      v12 = *(_QWORD *)(v2 + 168);
      if (v12)
      {
        v13 = *(void (**)(uint64_t, _QWORD, _QWORD))(v12 + 80);
        if (v13)
          v13(v2 - 16, *(_QWORD *)(a1 + 40), *(_QWORD *)(v12 + 8));
      }
    }
  }
  v4 = *(const void **)(a1 + 48);
  if (v4)
    CFRelease(v4);
  CFRelease((CFTypeRef)(v2 - 16));
}

void URLDownload::_internal_setResponse(URLDownload *this, _CFURLResponse *a2)
{
  _CFURLResponse *v2;
  _CFURLResponse *v4;
  uint64_t v5;
  uint64_t v6;
  HTTPMessage *v7;
  const __CFString *v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  const void *v12;
  const void *v13;

  v2 = a2;
  v4 = (_CFURLResponse *)*((_QWORD *)this + 23);
  if (v4 != a2)
  {

    v2 = v2;
    *((_QWORD *)this + 23) = v2;
  }
  if (v2 && ((v5 = *(_QWORD *)(-[_CFURLResponse _inner](v2, "_inner") + 88)) != 0 ? (v6 = v5 - 16) : (v6 = 0), v5))
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v7 = (HTTPMessage *)(v6 + 16);
    v8 = HTTPMessage::copyHeaderFieldValue(v7, 0x124092F7u);
    if (v8)
    {
      v9 = v8;
      URLDownload::_internal_setEntityTag(this, v8);
      CFRelease(v9);
    }
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v10 = HTTPMessage::copyHeaderFieldValue(v7, 0x12C1B320u);
    if (v10)
    {
      v11 = v10;
      URLDownload::_internal_setServerModificationDateString(this, v10);
      CFRelease(v11);
    }
  }
  else
  {
    v12 = (const void *)*((_QWORD *)this + 29);
    if (v12)
    {
      CFRelease(v12);
      *((_QWORD *)this + 29) = 0;
    }
    v13 = (const void *)*((_QWORD *)this + 30);
    if (v13)
    {
      CFRelease(v13);
      *((_QWORD *)this + 30) = 0;
    }
  }
}

CFStringRef URLDownload::_internal_setEntityTag(URLDownload *this, const __CFString *a2)
{
  CFStringRef result;
  const __CFAllocator *v5;

  result = (CFStringRef)*((_QWORD *)this + 29);
  if (result != a2)
  {
    if (result)
      CFRelease(result);
    if (a2)
    {
      v5 = CFGetAllocator((char *)this - 16);
      result = CFStringCreateCopy(v5, a2);
    }
    else
    {
      result = 0;
    }
    *((_QWORD *)this + 29) = result;
  }
  return result;
}

CFStringRef URLDownload::_internal_setServerModificationDateString(URLDownload *this, const __CFString *a2)
{
  CFStringRef result;
  const __CFAllocator *v5;

  result = (CFStringRef)*((_QWORD *)this + 30);
  if (result != a2)
  {
    if (result)
      CFRelease(result);
    if (a2)
    {
      v5 = CFGetAllocator((char *)this - 16);
      result = CFStringCreateCopy(v5, a2);
    }
    else
    {
      result = 0;
    }
    *((_QWORD *)this + 30) = result;
  }
  return result;
}

const _CFURLRequest *URLDownload::_internal_setRequest(URLDownload *this, _CFURLRequest *a2)
{
  const _CFURLRequest *result;

  result = (const _CFURLRequest *)*((_QWORD *)this + 3);
  if (result != a2)
  {
    if (result)
      CFRelease(result);
    if (a2)
    {
      CFGetAllocator((char *)this - 16);
      result = (const _CFURLRequest *)-[_CFURLRequest copy](a2, "copy");
    }
    else
    {
      result = 0;
    }
    *((_QWORD *)this + 3) = result;
  }
  return result;
}

void ___ZN9TCFObjectI13URLConnectionE5ClassEv_block_invoke_4725()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  qmemcpy(_PNAME<URLConnection>::GET(void)::p, "URLConnection", 13);
  CFClass::CFClass(v0, (const char *)_PNAME<URLConnection>::GET(void)::p);
  TCFObject<URLConnection>::Class(void)::clazz = (uint64_t)v0;
}

void sub_184038C08(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

BOOL objectExistsAtURL(CFURLRef url)
{
  stat v2;
  char v3;
  char v4[1035];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  FilePathStorage<unsigned char>::FilePathStorage((uint64_t)&v3, url, 0, 0, 1u);
  return v3 && lstat(v4, &v2) == 0;
}

CFDictionaryRef URLDownload::_internal_downloadCreateResumeInfoDictionaryInternal(URLDownload *this, CFAllocatorRef allocator, const __CFURL *a3)
{
  CFNumberRef v6;
  CFNumberRef v7;
  CFStringRef v8;
  CFStringRef v9;
  const __CFArray *v10;
  uint64_t Count;
  __CFArray *Mutable;
  CFIndex i;
  _QWORD *ValueAtIndex;
  _QWORD *v15;
  uint64_t v16;
  CFAllocatorRef v17;
  const void *v18;
  const void *v19;
  CFDictionaryRef Copy;
  const void *v21;
  CFStringRef v22;
  __CFDictionary *v23;
  __CFDictionary *v24;

  v6 = CFNumberCreate(allocator, kCFNumberSInt64Type, (char *)this + 272);
  if (v6)
  {
    v7 = v6;
    v8 = CFURLGetString(a3);
    if (!v8)
      goto LABEL_34;
    v9 = v8;
    v10 = (const __CFArray *)*((_QWORD *)this + 32);
    if (v10)
    {
      Count = CFArrayGetCount(v10);
      if (Count)
      {
        Mutable = CFArrayCreateMutable(allocator, Count, MEMORY[0x1E0C9B378]);
        if (Mutable)
        {
          if (Count >= 1)
          {
            for (i = 0; i != Count; ++i)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 32), i);
              if (ValueAtIndex)
              {
                v15 = ValueAtIndex;
                if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1)
                  dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2564);
                v16 = (*(uint64_t (**)(_QWORD *))(v15[2] + 56))(v15 + 2);
                v17 = CFGetAllocator(v15);
                v18 = (const void *)(*(uint64_t (**)(uint64_t, CFAllocatorRef))(*(_QWORD *)v16 + 80))(v16, v17);
                if (v18)
                {
                  v19 = v18;
                  CFArrayAppendValue(Mutable, v18);
                  CFRelease(v19);
                }
              }
            }
          }
          if (Count == CFArrayGetCount(Mutable))
            goto LABEL_18;
          CFRelease(Mutable);
          Mutable = 0;
        }
        LOBYTE(Count) = 1;
      }
      else
      {
        Mutable = 0;
      }
LABEL_22:
      if (!*((_QWORD *)this + 28)
        || (v21 = *(const void **)(objc_msgSend(*((id *)this + 3), "_inner") + 32)) != 0
        && CFEqual(*((CFTypeRef *)this + 28), v21))
      {
        v22 = 0;
        if ((Count & 1) != 0)
          goto LABEL_34;
      }
      else
      {
        v22 = CFURLGetString(*((CFURLRef *)this + 28));
        if ((Count & 1) != 0)
          goto LABEL_34;
      }
      v23 = CFDictionaryCreateMutable(allocator, 6, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
      if (v23)
      {
        v24 = v23;
        CFDictionarySetValue(v23, CFSTR("NSURLDownloadURL"), v9);
        CFDictionarySetValue(v24, CFSTR("NSURLDownloadBytesReceived"), v7);
        CFDictionarySetValue(v24, CFSTR("NSURLDownloadServerModificationDate"), *((const void **)this + 30));
        CFDictionarySetValue(v24, CFSTR("NSURLDownloadEntityTag"), *((const void **)this + 29));
        if (v22)
          CFDictionarySetValue(v24, CFSTR("NSURLDownloadOriginatingURLString"), v22);
        if (Mutable)
          CFDictionarySetValue(v24, CFSTR("NSURLDownloadDecoders"), Mutable);
        Copy = CFDictionaryCreateCopy(allocator, v24);
        CFRelease(v24);
        goto LABEL_35;
      }
LABEL_34:
      Copy = 0;
LABEL_35:
      CFRelease(v7);
      return Copy;
    }
    Mutable = 0;
LABEL_18:
    LOBYTE(Count) = 0;
    goto LABEL_22;
  }
  return 0;
}

CFDictionaryRef URLDownload::createResumeInformation(URLDownload *this, const __CFAllocator *a2)
{
  uint64_t v4;
  const __CFURL *v5;
  CFStringRef v6;
  const __CFString *v7;
  const __CFArray *v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  _QWORD *ValueAtIndex;
  _QWORD *v13;
  uint64_t v14;
  CFDictionaryRef ResumeInfoDictionaryInternal;
  _BOOL4 v16;
  const __CFString *v18;
  const __CFString *v19;

  v4 = objc_msgSend(*((id *)this + 3), "_inner");
  v5 = *(const __CFURL **)(v4 + 8);
  if (v5)
  {
    v6 = CFURLCopyScheme(*(CFURLRef *)(v4 + 8));
    if (v6)
    {
      v7 = v6;
      v8 = (const __CFArray *)*((_QWORD *)this + 32);
      if (v8 && (Count = CFArrayGetCount(v8)) != 0)
      {
        v10 = Count;
        if (Count < 1)
        {
          v11 = 0;
        }
        else
        {
          v11 = 0;
          while (1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 32), v11);
            if (ValueAtIndex)
            {
              v13 = ValueAtIndex;
              if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1)
                dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2564);
              v14 = (*(uint64_t (**)(_QWORD *))(v13[2] + 56))(v13 + 2);
              if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v14 + 72))(v14))
                break;
            }
            if (v10 == ++v11)
            {
              v11 = v10;
              break;
            }
          }
        }
        v16 = v11 == v10;
      }
      else
      {
        v16 = 1;
      }
      if (!*((_BYTE *)this + 282) && !*((_BYTE *)this + 284) && *((_QWORD *)this + 29))
      {
        ResumeInfoDictionaryInternal = 0;
        if (!v16 || !*((_QWORD *)this + 30))
          goto LABEL_20;
        if (CFStringCompare(v7, CFSTR("http"), 1uLL) == kCFCompareEqualTo
          || CFStringCompare(v7, (CFStringRef)&unk_1EDD00AE0, 1uLL) == kCFCompareEqualTo)
        {
          v18 = (const __CFString *)CFURLRequestCopyHTTPRequestMethod(*((void **)this + 3));
          if (v18)
          {
            v19 = v18;
            if (CFStringCompare(v18, CFSTR("GET"), 1uLL))
              ResumeInfoDictionaryInternal = 0;
            else
              ResumeInfoDictionaryInternal = URLDownload::_internal_downloadCreateResumeInfoDictionaryInternal(this, a2, v5);
            CFRelease(v19);
            goto LABEL_20;
          }
        }
      }
      ResumeInfoDictionaryInternal = 0;
LABEL_20:
      CFRelease(v7);
      return ResumeInfoDictionaryInternal;
    }
  }
  return 0;
}

void URLDownload::useCredential(URLDownload *this, const _CFURLCredential *a2, CFTypeRef cf2)
{
  const void *v4;

  if (cf2)
  {
    v4 = (const void *)*((_QWORD *)this + 24);
    if (v4)
    {
      if (CFEqual(v4, cf2))
      {
        CFRelease(*((CFTypeRef *)this + 24));
        *((_QWORD *)this + 24) = 0;
        CFURLConnectionUseCredential(*((_QWORD *)this + 2), (uint64_t)a2, (uint64_t)cf2);
      }
    }
  }
}

uint64_t _CFURLCreateDataAndPropertiesFromResource(uint64_t a1)
{
  uint64_t v1;
  int *v2;
  int *v3;
  const __CFArray *v4;
  const __CFArray *v5;
  CFMutableDictionaryRef *v6;
  CFMutableDictionaryRef *v7;
  CFMutableDataRef *v8;
  CFMutableDataRef *v9;
  const __CFURL *v10;
  const __CFURL *v11;
  const __CFAllocator *v12;
  const __CFString *v13;
  const __CFString *v14;
  unsigned __int8 v15;
  int v16;
  uint64_t *v17;
  __CFHTTPMessage *Request;
  __CFHTTPMessage *v19;
  __CFHTTPMessage *v20;
  __CFHTTPMessage *v21;
  CFDataRef v22;
  uint64_t Count;
  CFIndex v24;
  const __CFString *v25;
  const __CFString *v26;
  const __CFString *ValueAtIndex;
  const __CFString *v28;
  CFStringRef v29;
  CFStringRef v30;
  CFStringRef v31;
  CFStringRef v32;
  CFNumberRef v33;
  CFNumberRef v34;
  __CFReadStream *v35;
  uint64_t v36;
  CFNumberRef v37;
  const __CFDictionary *v38;
  const __CFDictionary *v39;
  CFIndex v40;
  CFStreamError Error;
  CFStringRef v42;
  CFStringRef v43;
  const __CFString *v45;
  const __CFAllocator *allocator;
  __CFHTTPMessage *v47;
  _QWORD valuePtr[4502];

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v12 = (const __CFAllocator *)v1;
  valuePtr[4500] = *MEMORY[0x1E0C80C00];
  v13 = CFURLCopyScheme(v10);
  if (v13)
  {
    v14 = v13;
    if (CFStringCompare(v13, CFSTR("http"), 1uLL) && CFStringCompare(v14, (CFStringRef)&unk_1EDD00AE0, 1uLL))
    {
      if (CFStringCompare(v14, CFSTR("ftp"), 1uLL))
      {
        if (v9)
          *v9 = 0;
        if (v7)
          *v7 = 0;
        if (v3)
        {
          v15 = 0;
          v16 = -11;
LABEL_69:
          *v3 = v16;
LABEL_81:
          CFRelease(v14);
          return v15;
        }
        goto LABEL_70;
      }
      if (v7)
        *v7 = 0;
      if (!v9)
      {
        if (v3)
        {
          v15 = 0;
          v16 = -15;
          goto LABEL_69;
        }
        goto LABEL_70;
      }
      *v9 = CFDataCreateMutable(v12, 0);
      v35 = CFReadStreamCreateWithFTPURL(v12, v11);
      CFReadStreamSetProperty(v35, CFSTR("kCFStreamPropertyFTPAttemptPersistentConnection"), (CFTypeRef)*MEMORY[0x1E0C9AE40]);
      if (CFReadStreamOpen(v35))
      {
        while (1)
        {
          v36 = CFReadStreamRead(v35, (UInt8 *)valuePtr, 36000);
          if (v36 < 1)
            break;
          CFDataAppendBytes(*v9, (const UInt8 *)valuePtr, v36);
        }
        CFReadStreamClose(v35);
      }
      Error = CFReadStreamGetError(v35);
      if (v3)
      {
        *v3 = Error.error;
        CFRelease(v35);
        if (!*v3)
          goto LABEL_74;
LABEL_72:
        CFRelease(*v9);
        v15 = 0;
        *v9 = 0;
        goto LABEL_81;
      }
      CFRelease(v35);
      if (Error.error)
        goto LABEL_72;
LABEL_74:
      v15 = 1;
      goto LABEL_81;
    }
    if (v3)
      *v3 = 0;
    if (v9)
    {
      v17 = &kCFHTTPMethodGet;
    }
    else
    {
      if (!v7)
        goto LABEL_74;
      if (v5 && !CFArrayGetCount(v5))
      {
        *v7 = 0;
        goto LABEL_74;
      }
      v17 = &kCFHTTPMethodHead;
    }
    Request = CFHTTPMessageCreateRequest(v12, (CFStringRef)*v17, v11, CFSTR("HTTP/1.0"));
    v19 = _CFHTTPMessageSendRequest(Request);
    v20 = Request;
    v21 = v19;
    CFRelease(v20);
    if (!v21)
    {
      if (v9)
        *v9 = 0;
      if (v7)
        *v7 = 0;
      if (v3)
      {
        v15 = 0;
        v16 = -14;
        goto LABEL_69;
      }
LABEL_70:
      v15 = 0;
      goto LABEL_81;
    }
    if (v9)
    {
      v22 = CFHTTPMessageCopyBody(v21);
      if (!v22)
        v22 = CFDataCreate(v12, 0, 0);
      *v9 = v22;
    }
    v45 = v14;
    if (v7)
    {
      if (v5)
      {
        Count = CFArrayGetCount(v5);
        *v7 = CFDictionaryCreateMutable(v12, Count, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        if (Count >= 1)
        {
          allocator = v12;
          v24 = 0;
          v25 = (const __CFString *)*MEMORY[0x1E0C9B4C0];
          v26 = (const __CFString *)*MEMORY[0x1E0C9B4B8];
          v15 = 1;
          v47 = v21;
          while (1)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, v24);
            if (ValueAtIndex == v25)
            {
              v31 = CFHTTPMessageCopyResponseStatusLine(v21);
              if (!v31)
              {
                v15 = 0;
                if (v3)
                  *v3 = -17;
                goto LABEL_45;
              }
              v32 = v31;
              CFDictionarySetValue(*v7, v25, v31);
              v33 = (CFNumberRef)v32;
            }
            else
            {
              v28 = ValueAtIndex;
              if (ValueAtIndex != v26)
              {
                v29 = CFHTTPMessageCopyHeaderFieldValue(v21, ValueAtIndex);
                if (v29)
                {
                  v30 = v29;
                  CFDictionarySetValue(*v7, v28, v29);
                  CFRelease(v30);
                }
                else
                {
                  v15 = 0;
                  if (v3)
                    *v3 = -17;
                }
                v21 = v47;
                goto LABEL_45;
              }
              valuePtr[0] = 0;
              valuePtr[0] = CFHTTPMessageGetResponseStatusCode(v21);
              v34 = CFNumberCreate(allocator, kCFNumberCFIndexType, valuePtr);
              CFDictionarySetValue(*v7, v26, v34);
              v33 = v34;
              v21 = v47;
            }
            CFRelease(v33);
LABEL_45:
            if (Count == ++v24)
              goto LABEL_80;
          }
        }
      }
      else
      {
        valuePtr[0] = CFHTTPMessageGetResponseStatusCode(v21);
        v37 = CFNumberCreate(v12, kCFNumberCFIndexType, valuePtr);
        v38 = CFHTTPMessageCopyAllHeaderFields(v21);
        if (v38)
        {
          v39 = v38;
          v40 = CFDictionaryGetCount(v38);
          *v7 = CFDictionaryCreateMutableCopy(v12, v40 + 2, v39);
          CFRelease(v39);
        }
        else
        {
          *v7 = CFDictionaryCreateMutable(v12, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        }
        v42 = CFHTTPMessageCopyResponseStatusLine(v21);
        if (v42)
        {
          v43 = v42;
          CFDictionarySetValue(*v7, (const void *)*MEMORY[0x1E0C9B4C0], v42);
          CFRelease(v43);
        }
        CFDictionarySetValue(*v7, (const void *)*MEMORY[0x1E0C9B4B8], v37);
        CFRelease(v37);
      }
    }
    v15 = 1;
LABEL_80:
    CFRelease(v21);
    v14 = v45;
    goto LABEL_81;
  }
  if (v3)
    *v3 = -15;
  if (v9)
    *v9 = 0;
  v15 = 0;
  if (v7)
    *v7 = 0;
  return v15;
}

__CFHTTPMessage *_CFHTTPMessageSendRequest(__CFHTTPMessage *a1)
{
  const __CFAllocator *v2;
  __CFReadStream *v3;
  CFWriteStreamRef v4;
  __CFWriteStream *v5;
  CFStreamStatus Status;
  uint64_t v7;
  _BOOL4 v8;
  __CFHTTPMessage *v9;
  CFStreamStatus v10;
  const __CFData *v12;
  __CFHTTPMessage *v13;
  UInt8 buffer[8];
  uint64_t v15;
  void (*v16)(uint64_t, const void *);
  void *v17;
  const __CFAllocator *v18;
  __CFHTTPMessage *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v2 = CFGetAllocator(a1);
  *(_QWORD *)buffer = MEMORY[0x1E0C809B0];
  v15 = 3221225472;
  v16 = __CFReadStreamCreateForHTTPRequest_block_invoke;
  v17 = &__block_descriptor_48_e26__v16__0____CFReadStream__8l;
  v18 = v2;
  v19 = a1;
  v3 = (__CFReadStream *)CFReadStreamCreate();
  v4 = CFWriteStreamCreateWithAllocatedBuffers(v2, v2);
  v5 = v4;
  if (v3 && v4)
  {
    CFReadStreamSetProperty(v3, (CFStreamPropertyKey)&unk_1EDCFED20, (CFTypeRef)*MEMORY[0x1E0C9AE50]);
    if (!CFReadStreamOpen(v3) || !CFWriteStreamOpen(v5))
      goto LABEL_18;
    Status = CFReadStreamGetStatus(v3);
    while ((Status | 2) != 7)
    {
      v7 = CFReadStreamRead(v3, buffer, 512);
      v8 = v7 >= 1 && CFWriteStreamWrite(v5, buffer, v7) != v7;
      Status = CFReadStreamGetStatus(v3);
      if (v8)
      {
        CFReadStreamClose(v3);
        CFWriteStreamClose(v5);
        goto LABEL_18;
      }
    }
    v10 = CFReadStreamGetStatus(v3);
    CFReadStreamClose(v3);
    CFWriteStreamClose(v5);
    if (v10 != kCFStreamStatusError)
    {
      v12 = (const __CFData *)CFWriteStreamCopyProperty(v5, (CFStreamPropertyKey)*MEMORY[0x1E0C9B2A8]);
      v13 = (__CFHTTPMessage *)CFReadStreamCopyProperty(v3, CFSTR("kCFStreamPropertyHTTPResponseHeader"));
      v9 = v13;
      if (v13)
        CFHTTPMessageSetBody(v13, v12);
      if (v12)
        CFRelease(v12);
    }
    else
    {
LABEL_18:
      v9 = 0;
    }
    CFRelease(v3);
    CFRelease(v5);
  }
  else
  {
    if (v3)
      CFRelease(v3);
    if (v5)
      CFRelease(v5);
    return 0;
  }
  return v9;
}

unint64_t _CFURLWriteDataAndPropertiesToResource(const __CFURL *a1, const __CFData *a2, const __CFDictionary *a3, SInt32 *a4)
{
  const __CFString *v8;
  const __CFString *v9;
  unint64_t v10;
  int v11;
  const __CFAllocator *v12;
  const __CFAllocator *v13;
  __CFHTTPMessage *Request;
  CFIndex v15;
  const __CFString *v16;
  CFIndex Count;
  CFIndex v18;
  const void **v19;
  const void **v20;
  CFStringRef *v21;
  CFTypeID v22;
  int ResponseStatusCode;
  const UInt8 *BytePtr;
  CFIndex Length;
  const __CFAllocator *v26;
  CFWriteStreamRef v27;
  CFIndex v28;
  CFStreamError Error;
  SInt32 v30;

  v8 = CFURLCopyScheme(a1);
  if (v8)
  {
    v9 = v8;
    if (CFStringCompare(v8, CFSTR("http"), 1uLL) && CFStringCompare(v9, (CFStringRef)&unk_1EDD00AE0, 1uLL))
    {
      if (CFStringCompare(v9, CFSTR("ftp"), 1uLL))
      {
        if (a4)
        {
          v10 = 0;
          v11 = -11;
          goto LABEL_39;
        }
LABEL_42:
        v10 = 0;
        goto LABEL_40;
      }
      if (a2)
      {
        BytePtr = CFDataGetBytePtr(a2);
        Length = CFDataGetLength(a2);
        v26 = CFGetAllocator(a1);
        v27 = CFWriteStreamCreateWithFTPURL(v26, a1);
        if (a3)
          CFDictionaryApplyFunction(a3, (CFDictionaryApplierFunction)_ApplyWriteStreamProperties, v27);
        CFWriteStreamSetProperty(v27, CFSTR("kCFStreamPropertyFTPAttemptPersistentConnection"), (CFTypeRef)*MEMORY[0x1E0C9AE40]);
        if (CFWriteStreamOpen(v27))
        {
          do
          {
            if (!Length)
              break;
            v28 = CFWriteStreamWrite(v27, BytePtr, Length);
            BytePtr += v28;
            Length -= v28;
          }
          while (v28 > 0);
          CFWriteStreamClose(v27);
        }
        Error = CFWriteStreamGetError(v27);
        v30 = Error.error;
        if (a4)
        {
          *a4 = Error.error;
          CFRelease(v27);
          v30 = *a4;
        }
        else
        {
          CFRelease(v27);
        }
        v10 = v30 == 0;
        goto LABEL_40;
      }
      if (!a4)
        goto LABEL_42;
      v10 = 0;
    }
    else
    {
      v12 = CFGetAllocator(a1);
      if (a2)
      {
        v13 = v12;
        Request = CFHTTPMessageCreateRequest(v12, CFSTR("PUT"), a1, CFSTR("HTTP/1.0"));
        v15 = CFDataGetLength(a2);
        v16 = CFStringCreateWithFormat(v13, 0, CFSTR("%ld"), v15);
        CFHTTPMessageSetHeaderFieldValue(Request, (CFStringRef)&unk_1EDCFCE80, v16);
        CFRelease(v16);
        if (a3)
        {
          Count = CFDictionaryGetCount(a3);
          if (Count >= 1)
          {
            v18 = Count;
            v19 = (const void **)CFAllocatorAllocate(v13, 16 * Count, 0);
            v20 = &v19[v18];
            CFDictionaryGetKeysAndValues(a3, v19, v20);
            v21 = (CFStringRef *)v19;
            do
            {
              v22 = CFGetTypeID(v21[v18]);
              if (v22 == CFStringGetTypeID())
                CFHTTPMessageSetHeaderFieldValue(Request, *v21, v21[v18]);
              ++v21;
            }
            while (v21 < (CFStringRef *)v20);
            CFAllocatorDeallocate(v13, v19);
          }
        }
        v10 = (unint64_t)_CFHTTPMessageSendRequest(Request);
        CFRelease(Request);
        if (v10)
        {
          ResponseStatusCode = CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)v10);
          CFRelease((CFTypeRef)v10);
          v10 = (ResponseStatusCode - 200) < 0x64;
          if ((ResponseStatusCode - 200) >= 0x64)
            v11 = ResponseStatusCode;
          else
            v11 = 0;
          if (!a4)
            goto LABEL_40;
        }
        else
        {
          if (!a4)
          {
LABEL_40:
            CFRelease(v9);
            return v10;
          }
          v11 = -14;
        }
LABEL_39:
        *a4 = v11;
        goto LABEL_40;
      }
      v10 = 0;
      if (!a4)
        goto LABEL_40;
    }
    v11 = -15;
    goto LABEL_39;
  }
  v10 = 0;
  if (a4)
    *a4 = -15;
  return v10;
}

CFTypeID _ApplyWriteStreamProperties(const __CFString *a1, const void *a2, __CFWriteStream *a3)
{
  CFTypeID v6;
  CFTypeID result;

  v6 = CFGetTypeID(a1);
  result = CFStringGetTypeID();
  if (v6 == result)
    return CFWriteStreamSetProperty(a3, a1, a2);
  return result;
}

unint64_t _CFURLDestroyResource(const __CFURL *a1, SInt32 *a2)
{
  const __CFString *v4;
  const __CFString *v5;
  unint64_t v6;
  int v7;
  const __CFAllocator *v8;
  __CFHTTPMessage *Request;
  int ResponseStatusCode;
  const __CFAllocator *v11;
  __CFWriteStream *v12;
  CFStreamError Error;
  SInt32 v14;
  UInt8 buffer;

  v4 = CFURLCopyScheme(a1);
  if (v4)
  {
    v5 = v4;
    if (CFStringCompare(v4, CFSTR("http"), 1uLL) && CFStringCompare(v5, (CFStringRef)&unk_1EDD00AE0, 1uLL))
    {
      if (CFStringCompare(v5, CFSTR("ftp"), 1uLL) == kCFCompareEqualTo)
      {
        v11 = CFGetAllocator(a1);
        v12 = CFWriteStreamCreateWithFTPURL(v11, a1);
        CFWriteStreamSetProperty(v12, CFSTR("kCFStreamPropertyFTPAttemptPersistentConnection"), (CFTypeRef)*MEMORY[0x1E0C9AE40]);
        CFWriteStreamSetProperty(v12, CFSTR("_kCFStreamPropertyFTPRemoveResource"), (CFTypeRef)*MEMORY[0x1E0C9AE50]);
        if (CFWriteStreamOpen(v12))
        {
          buffer = 0;
          CFWriteStreamWrite(v12, &buffer, 1);
          CFWriteStreamClose(v12);
        }
        Error = CFWriteStreamGetError(v12);
        v14 = Error.error;
        if (a2)
        {
          *a2 = Error.error;
          CFRelease(v12);
          v14 = *a2;
        }
        else
        {
          CFRelease(v12);
        }
        v6 = v14 == 0;
        goto LABEL_24;
      }
      v6 = 0;
      if (a2)
      {
        v7 = -11;
LABEL_17:
        *a2 = v7;
      }
    }
    else
    {
      v8 = CFGetAllocator(a1);
      Request = CFHTTPMessageCreateRequest(v8, CFSTR("DELETE"), a1, CFSTR("HTTP/1.0"));
      v6 = (unint64_t)_CFHTTPMessageSendRequest(Request);
      CFRelease(Request);
      if (v6)
      {
        ResponseStatusCode = CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)v6);
        CFRelease((CFTypeRef)v6);
        v6 = (ResponseStatusCode - 200) < 0x64;
        if ((ResponseStatusCode - 200) >= 0x64)
          v7 = ResponseStatusCode;
        else
          v7 = 0;
        if (!a2)
          goto LABEL_24;
        goto LABEL_17;
      }
      if (a2)
      {
        v7 = -14;
        goto LABEL_17;
      }
    }
LABEL_24:
    CFRelease(v5);
    return v6;
  }
  v6 = 0;
  if (a2)
    *a2 = -15;
  return v6;
}

uint64_t __CFNIsMachServiceReachable(char *service_name)
{
  kern_return_t v1;
  uint64_t result;
  BOOL v3;
  mach_port_t sp;

  sp = 0;
  v1 = bootstrap_look_up(*MEMORY[0x1E0C81720], service_name, &sp);
  result = 0;
  if (v1)
    v3 = 1;
  else
    v3 = sp == 0;
  if (!v3)
  {
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], sp);
    return 1;
  }
  return result;
}

CFStringRef _CFNetworkCFStringCreateWithCFDataAddress(const __CFData *a1)
{
  const sockaddr *BytePtr;
  socklen_t Length;
  int v4;
  CFStringRef result;
  char cStr[1025];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  BytePtr = (const sockaddr *)CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  v4 = getnameinfo(BytePtr, Length, cStr, 0x401u, 0, 0, 2);
  result = 0;
  if (!v4)
    return CFStringCreateWithCString(0, cStr, 0x600u);
  return result;
}

CFStringRef _CFStringCreateRFC1123DateStringWithGregorianDate(const __CFAllocator *a1, CFGregorianDate *a2, CFTimeZoneRef tz)
{
  CFTimeInterval SecondsFromGMT;
  uint64_t v6;
  int v7;
  uint64_t v8;

  if (tz)
  {
    SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, 0.0);
    v6 = ((int)SecondsFromGMT / 3600);
    v7 = (int)SecondsFromGMT % 3600;
    if (v7 >= 0)
      v8 = v7;
    else
      v8 = -v7;
  }
  else
  {
    v8 = 0;
    v6 = 0;
  }
  if (CFGregorianDateIsValid(*a2, 0xFFFFFFuLL))
    return CFStringCreateWithFormat(a1, 0, CFSTR("%02d %s %04d %02d:%02d:%02d %+03d%02d"), a2->day, kMonthStrs[a2->month + 11], a2->year, a2->hour, a2->minute, (int)a2->second, v6, v8);
  else
    return 0;
}

CFURLRef cfnCreateSemiColonEscapedURLIfParamterIsPresent(const __CFURL *a1)
{
  const __CFString *v2;
  const __CFAllocator *v3;
  const __CFString *v4;
  const __CFString *v5;
  CFURLRef v6;

  if (CFURLGetByteRangeForComponent(a1, kCFURLComponentParameterString, 0).location == -1)
    return 0;
  v2 = CFURLGetString(a1);
  if (!v2)
    return 0;
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v4 = CFURLCreateStringByAddingPercentEscapes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v2, 0, CFSTR(";"), 0x8000100u);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = CFURLCreateWithString(v3, v4, 0);
  CFRelease(v5);
  return v6;
}

const void *_CFNetworkErrorGetLocalizedDescription(uint64_t a1)
{
  return _CFNetworkErrorGetLocalizedString(a1, 0);
}

uint64_t _CFStreamErrorFromCFNetworkErrorCode(__CFError *a1)
{
  unint64_t Code;
  int v3;
  uint64_t result;
  CFIndex v5;
  int v6;
  int v7;
  int v8;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  const __CFString *v11;
  const __CFString *v12;
  CFTypeID v13;
  SInt32 IntValue;
  int v15;
  int v16;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  const __CFNumber *Value;
  const __CFDictionary *v20;
  const __CFDictionary *v21;
  const __CFNumber *v22;
  uint64_t v23;
  int valuePtr;

  Code = CFErrorGetCode(a1);
  if ((uint64_t)Code <= 99)
  {
    if (Code + 72007 >= 8)
    {
      switch(Code)
      {
        case 0xFFFFFFFFFFFFFFFELL:
          v3 = -2095;
          goto LABEL_66;
        case 0xFFFFFFFFFFFFFFFFLL:
          return -1;
        case 0uLL:
          goto LABEL_21;
        case 1uLL:
          goto LABEL_23;
        case 2uLL:
          v17 = CFErrorCopyUserInfo(a1);
          if (!v17)
          {
            v16 = -2;
            goto LABEL_52;
          }
          v18 = v17;
          Value = (const __CFNumber *)CFDictionaryGetValue(v17, CFSTR("kCFGetAddrInfoFailureKey"));
          if (Value)
            CFNumberGetValue(Value, kCFNumberCFIndexType, &v23);
          else
            LODWORD(v23) = -2;
          CFRelease(v18);
          return 12;
        default:
          if (Code == -73000)
            break;
LABEL_21:
          if ((Code & 0x8000000000000000) != 0)
          {
            if (Code + 73000 <= 0x3E8)
              goto LABEL_7;
          }
          else
          {
            if (Code <= 0x63)
            {
LABEL_23:
              v16 = 1;
LABEL_52:
              LODWORD(v23) = v16;
              return 12;
            }
            if (Code <= 0xC7)
            {
              result = (int)*MEMORY[0x1E0C9B290];
              LODWORD(v23) = 3;
              return result;
            }
            if (Code <= 0x12B)
            {
LABEL_62:
              LODWORD(v23) = -1;
              return 6;
            }
            if (Code <= 0x18F)
            {
LABEL_65:
              v3 = -4;
LABEL_66:
              LODWORD(v23) = v3;
              return 4;
            }
          }
          return -1;
      }
    }
    LODWORD(Code) = CFErrorGetCode(a1);
LABEL_7:
    LODWORD(v23) = Code;
    return 10;
  }
  else if (Code - 100 <= 0x18 && ((1 << (Code - 100)) & 0x1F03C03) != 0)
  {
    valuePtr = 0;
    v5 = CFErrorGetCode(a1);
    v6 = 0;
    v7 = 0x10000;
    v8 = 3;
    switch(v5)
    {
      case 'd':
        break;
      case 'e':
        goto LABEL_42;
      case 'n':
        v6 = 0x20000;
        v8 = 91;
        break;
      case 'o':
        v6 = 0x20000;
        v8 = 92;
        break;
      case 'p':
        v6 = 0x20000;
        v8 = 93;
        break;
      case 'q':
        v7 = 0x20000;
        goto LABEL_42;
      case 'x':
        v6 = 0;
        v8 = 2;
        break;
      case 'y':
        v6 = 0;
        v8 = 121;
        break;
      case 'z':
        v7 = 196608;
        goto LABEL_42;
      case '{':
        v7 = 0x40000;
LABEL_42:
        v20 = CFErrorCopyUserInfo(a1);
        if (v20)
        {
          v21 = v20;
          v22 = (const __CFNumber *)CFDictionaryGetValue(v20, CFSTR("kCFSOCKSStatusCodeKey"));
          if (v22)
            CFNumberGetValue(v22, kCFNumberSInt32Type, &valuePtr);
          else
            valuePtr = -1;
          CFRelease(v21);
          v8 = valuePtr;
        }
        else
        {
          v8 = -1;
        }
        v6 = v7;
        break;
      case '|':
        v6 = 0x40000;
        v8 = 255;
        break;
      default:
        v6 = 0;
        v8 = -1;
        break;
    }
    result = (int)*MEMORY[0x1E0C9B290];
    v23 = v6 | v8;
  }
  else
  {
    switch(Code)
    {
      case 0x12CuLL:
        v3 = -1000;
        goto LABEL_66;
      case 0x12DuLL:
      case 0x133uLL:
        v3 = -1002;
        goto LABEL_66;
      case 0x12EuLL:
        goto LABEL_65;
      case 0x12FuLL:
        v3 = -1;
        goto LABEL_66;
      case 0x130uLL:
        v3 = -2;
        goto LABEL_66;
      case 0x131uLL:
        v3 = -3;
        goto LABEL_66;
      case 0x132uLL:
        v3 = -2094;
        goto LABEL_66;
      case 0x134uLL:
      case 0x135uLL:
        goto LABEL_21;
      case 0x136uLL:
        v3 = -2096;
        goto LABEL_66;
      case 0x137uLL:
        v3 = -2098;
        goto LABEL_66;
      default:
        if (Code != 200)
          goto LABEL_21;
        v9 = CFErrorCopyUserInfo(a1);
        if (!v9)
          goto LABEL_62;
        v10 = v9;
        v11 = (const __CFString *)CFDictionaryGetValue(v9, CFSTR("kCFFTPStatusCodeKey"));
        if (v11 && (v12 = v11, v13 = CFGetTypeID(v11), v13 == CFStringGetTypeID()))
        {
          IntValue = CFStringGetIntValue(v12);
          if (IntValue)
            v15 = IntValue;
          else
            v15 = -1;
        }
        else
        {
          v15 = -1;
        }
        LODWORD(v23) = v15;
        CFRelease(v10);
        break;
    }
    return 6;
  }
  return result;
}

void HTTPMessage::visitAllHeaderFields(HTTPMessage *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t context;

  HTTPMessage::ensureParserFinished(a1);
  v4 = HTTPMessage::headers((os_unfair_lock_s *)a1);
  context = a2;
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(v4 + 8), (CFDictionaryApplierFunction)visit, &context);
}

void HTTPMessage::parserAddHeader(HTTPMessage *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  HTTPHeaderDict *v5;

  v5 = HTTPMessage::mutableHeaders(this);
  HTTPHeaderDict::addValue((uint64_t)v5, (uint64_t)a2, (uint64_t)a3);
}

void `non-virtual thunk to'HTTPMessage::parserAddHeader(HTTPMessage *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  HTTPHeaderDict *v5;

  v5 = HTTPMessage::mutableHeaders((HTTPMessage *)((char *)this - 16));
  HTTPHeaderDict::addValue((uint64_t)v5, (uint64_t)a2, (uint64_t)a3);
}

void HTTPHeaderValueMixedValue::~HTTPHeaderValueMixedValue(HTTPHeaderValueMixedValue *this)
{
  const void *v1;

  *(_QWORD *)this = &off_1E14E9A00;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
}

{
  const void *v1;

  *(_QWORD *)this = &off_1E14E9A00;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x186DB748CLL);
}

void HTTPMessage::addHeaderFieldStringValue(HTTPMessage *this, const __CFString *a2, const __CFString *a3)
{
  HTTPHeaderDict *v5;
  void (**v6)(StringSerializable *__hidden);
  CFTypeRef cf;
  void (**v8)(StringSerializable *__hidden);
  CFTypeRef v9;

  HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v8, a2);
  HTTPHeaderValueMixedValue::HTTPHeaderValueMixedValue((HTTPHeaderValueMixedValue *)&v6, a3);
  v5 = HTTPMessage::mutableHeaders(this);
  HTTPHeaderDict::addValue((uint64_t)v5, (uint64_t)&v8, (uint64_t)&v6);
  v6 = &off_1E14E9A00;
  if (cf)
    CFRelease(cf);
  v8 = &off_1E14E9A00;
  if (v9)
    CFRelease(v9);
}

void sub_18403A7E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef a10, uint64_t a11, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN11HTTPMessage13logMsgHeadersEP17DiagnosticLoggingPKc_block_invoke(uint64_t a1, uint64_t a2, CFArrayRef theArray)
{
  CFIndex Count;
  uint64_t v7;
  const __CFString *ValueAtIndex;
  uint64_t (*v9)(uint64_t, uint64_t, const __CFString *);
  uint64_t v10;
  uint64_t v11;

  if (__CFNCanLogSensitiveContent::onceToken != -1)
    dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_26_4798);
  if (__CFNCanLogSensitiveContent::ok)
  {
    Count = CFArrayGetCount(theArray);
    v7 = *(_QWORD *)(a1 + 32);
    if (Count != 1)
    {
      v9 = *(uint64_t (**)(uint64_t, uint64_t, const __CFString *))(*(_QWORD *)v7 + 88);
      v10 = v7;
      v11 = a2;
      ValueAtIndex = (const __CFString *)theArray;
      return v9(v10, v11, ValueAtIndex);
    }
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, 0);
    v9 = *(uint64_t (**)(uint64_t, uint64_t, const __CFString *))(*(_QWORD *)v7 + 64);
    v10 = v7;
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 32);
    v9 = *(uint64_t (**)(uint64_t, uint64_t, const __CFString *))(*(_QWORD *)v10 + 64);
    ValueAtIndex = CFSTR("<redacted>");
  }
  v11 = a2;
  return v9(v10, v11, ValueAtIndex);
}

void std::__shared_ptr_pointer<__CFDictionary *,Deleter_CFRelease,std::allocator<__CFDictionary>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void DomainAndPartition::~DomainAndPartition(DomainAndPartition *this)
{
  char *v2;
  BOOL v3;

  *(_QWORD *)this = &off_1E14E9488;
  v2 = (char *)*((_QWORD *)this + 35);
  if (v2)
    v3 = v2 == (char *)this + 24;
  else
    v3 = 1;
  if (!v3)
    free(v2);
}

{
  char *v2;
  BOOL v3;

  *(_QWORD *)this = &off_1E14E9488;
  v2 = (char *)*((_QWORD *)this + 35);
  if (v2)
    v3 = v2 == (char *)this + 24;
  else
    v3 = 1;
  if (!v3)
    free(v2);
  JUMPOUT(0x186DB748CLL);
}

uint64_t DomainAndPartition::init(_QWORD *a1, uint64_t a2, uint64_t a3, char *__s, uint64_t a5, uint64_t a6)
{
  size_t v10;
  unint64_t v11;
  char *v12;
  _QWORD v14[9];

  a1[1] = a2;
  a1[2] = a3;
  a1[35] = 0;
  a1[38] = 0;
  a1[39] = 0;
  a1[37] = 0;
  if (!a5 || !a6)
    __assert_rtn("init", "HTTPCookiePartitionHelpers.cpp", 137, "partition != nil && partitionLen > 0");
  v10 = strlen(__s);
  v14[0] = MEMORY[0x1E0C809B0];
  v11 = 2 * (v10 + a6) + 5;
  v14[1] = 3221225472;
  v14[2] = ___ZN18DomainAndPartition4initE25CFAbsoluteTimeAsSpecifiedPKhS2_m_block_invoke;
  v14[3] = &__block_descriptor_72_e11_v24__0_8_16l;
  v14[4] = a1;
  v14[5] = __s;
  v14[6] = v10;
  v14[7] = a5;
  v14[8] = a6;
  if (v11 > 0xFF)
  {
    a1[36] = v11;
    v12 = (char *)malloc_type_malloc(2 * (v10 + a6) + 5, 0xE61DE4C8uLL);
  }
  else
  {
    v12 = (char *)(a1 + 3);
  }
  a1[35] = v12;
  return ___ZN18DomainAndPartition4initE25CFAbsoluteTimeAsSpecifiedPKhS2_m_block_invoke((uint64_t)v14, v12, (uint64_t)&v12[v11]);
}

uint64_t ___ZN18DomainAndPartition4initE25CFAbsoluteTimeAsSpecifiedPKhS2_m_block_invoke(uint64_t a1, char *__dst, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  char *v8;
  char *v9;

  v6 = *(_QWORD **)(a1 + 32);
  v6[37] = __dst;
  strncpy(__dst, *(const char **)(a1 + 40), *(_QWORD *)(a1 + 48));
  v7 = *(_QWORD *)(a1 + 48);
  __dst[v7] = 0;
  v8 = &__dst[v7 + 1];
  v6[38] = v8;
  v9 = &strncpy(v8, *(const char **)(a1 + 56), *(_QWORD *)(a1 + 64))[*(_QWORD *)(a1 + 64)];
  *v9++ = 0;
  v6[39] = v9;
  return snprintf(v9, a3 - (_QWORD)v9, "%.*s{%.*s}", *(_QWORD *)(a1 + 48), *(const char **)(a1 + 40), *(_QWORD *)(a1 + 64), *(const char **)(a1 + 56));
}

uint64_t HTTPCookieStoragePolicy::isTopLevelNavigation(HTTPCookieStoragePolicy *this)
{
  const __CFNumber *Value;
  int valuePtr;

  valuePtr = 0;
  if (this
    && (Value = (const __CFNumber *)CFDictionaryGetValue(this, CFSTR("_kCFHTTPCookiePolicyPropertyIsTopLevelNavigation"))) != 0)
  {
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    return valuePtr;
  }
  else
  {
    return 0;
  }
}

uint64_t HTTPCookieStoragePolicy::isURLInSiteForCookie(HTTPCookieStoragePolicy *this, uint64_t a2, const __CFURL *a3)
{
  uint64_t result;
  HTTPCookieStorage *v5;
  const __CFDictionary *v6;
  const __CFURL *Value;

  if (*((_BYTE *)this + 97))
    return *((unsigned __int8 *)this + 96);
  v5 = (HTTPCookieStorage *)*((_QWORD *)this + 2);
  v6 = (const __CFDictionary *)*((_QWORD *)this + 10);
  if (v6)
    Value = (const __CFURL *)CFDictionaryGetValue(v6, CFSTR("_kCFHTTPCookiePolicyPropertySiteForCookies"));
  else
    Value = 0;
  result = HTTPCookieStorage::isURLInMainDocumentDomain(v5, Value, a3);
  *((_WORD *)this + 48) = result | 0x100;
  return result;
}

void HTTP3Connection::connEventReadClose(HTTP3Connection *this)
{
  *((_BYTE *)this + 920) |= 2u;
  if (*((_QWORD *)this + 142) == *((_QWORD *)this + 143))
    HTTP3Connection::_cleanupConnection(this, 256, 0);
}

void HTTP3Connection::connEventDisconnected(HTTP3Connection *this)
{
  *((_BYTE *)this + 920) |= 2u;
  if (*((_QWORD *)this + 142) == *((_QWORD *)this + 143))
    HTTP3Connection::_cleanupConnection(this, 256, 0);
}

void HTTP3Connection::connErrorOccurred(HTTP3Connection *this, CFStreamError a2)
{
  *(CFStreamError *)((char *)this + 1160) = a2;
  HTTP3Connection::_cleanupConnection(this, -1, 0);
}

uint64_t HTTP3Connection::connEventAlternatePathAvailable(uint64_t a1, uint64_t a2)
{
  char *v3;
  char *v4;
  uint64_t v6;
  uint64_t i;
  std::__shared_weak_count *v8;
  void **v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  __int128 v12;
  unint64_t *v13;
  unint64_t v14;
  void **v16[2];
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;

  *(_BYTE *)(a1 + 920) |= 2u;
  v3 = *(char **)(a1 + 1136);
  v4 = *(char **)(a1 + 1144);
  if (v3 == v4)
  {
    HTTP3Connection::_cleanupConnection((HTTP3Connection *)a1, 256, 0);
    v3 = *(char **)(a1 + 1136);
    v4 = *(char **)(a1 + 1144);
  }
  v20 = xmmword_1841E38A0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  std::vector<std::shared_ptr<HTTP3Stream>>::__init_with_size[abi:nn180100]<std::shared_ptr<HTTP3Stream>*,std::shared_ptr<HTTP3Stream>*>(&v17, v3, v4, (v4 - v3) >> 4);
  v6 = v17;
  for (i = v18; v6 != i; v6 += 16)
  {
    v9 = *(void ***)v6;
    v8 = *(std::__shared_weak_count **)(v6 + 8);
    v16[0] = *(void ***)v6;
    v16[1] = (void **)&v8->__vftable;
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
    if ((a2 & 0xFFFFFFFD) == 1
      && (*(unsigned int (**)(void *, __int128 *, _QWORD))(*(_QWORD *)v9[37] + 280))(v9[37], &v20, 0) - 5 <= 5)
    {
      v12 = v20;
      HTTP3Stream::_cleanupStream((uint64_t)v9, 256, 0);
      *(_OWORD *)(v9 + 33) = v12;
      HTTP3Stream::_protocolCallback((HTTP3Stream *)v9);
    }
    else
    {
      (*(void (**)(void *, uint64_t))(*(_QWORD *)v9[37] + 248))(v9[37], a2);
    }
    if (v8)
    {
      v13 = (unint64_t *)&v8->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
  v16[0] = (void **)&v17;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](v16);
  return 1;
}

void sub_18403AE20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, char a12)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  a10 = (void **)&a12;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&a10);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'HTTP3Connection::~HTTP3Connection(HTTP3Connection *this)
{
  HTTP3Connection::~HTTP3Connection((HTTP3Connection *)((char *)this - 24));
}

{
  HTTP3Connection::~HTTP3Connection((HTTP3Connection *)((char *)this - 24));
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::deque<void({block_pointer} {__strong})(std::shared_ptr<HTTP3Framer>,unsigned long long,BOOL),std::allocator<void({block_pointer} {__strong})(std::shared_ptr<HTTP3Framer>,unsigned long long,BOOL)>>::~deque[abi:nn180100](uint64_t a1)
{
  void **v2;
  void **v3;
  _QWORD *v4;
  unint64_t v5;
  void **v6;
  void **v7;
  uint64_t v8;
  void *v9;
  void **v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;

  v2 = *(void ***)(a1 + 8);
  v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    v4 = (_QWORD *)(a1 + 40);
    v3 = *(void ***)(a1 + 8);
  }
  else
  {
    v4 = (_QWORD *)(a1 + 40);
    v5 = *(_QWORD *)(a1 + 32);
    v6 = &v2[v5 >> 9];
    v7 = (void **)((char *)*v6 + 8 * (v5 & 0x1FF));
    v8 = *(uint64_t *)((char *)v2 + (((*(_QWORD *)(a1 + 40) + v5) >> 6) & 0x3FFFFFFFFFFFFF8))
       + 8 * ((*(_QWORD *)(a1 + 40) + v5) & 0x1FF);
    if (v7 != (void **)v8)
    {
      do
      {
        v9 = *v7++;

        if ((char *)v7 - (_BYTE *)*v6 == 4096)
        {
          v10 = (void **)v6[1];
          ++v6;
          v7 = v10;
        }
      }
      while (v7 != (void **)v8);
      v2 = *(void ***)(a1 + 8);
      v3 = *(void ***)(a1 + 16);
    }
  }
  *v4 = 0;
  v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = *(void ***)(a1 + 16);
      v2 = (void **)(*(_QWORD *)(a1 + 8) + 8);
      *(_QWORD *)(a1 + 8) = v2;
      v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v12 = v11 >> 3;
  if (v12 == 1)
  {
    v13 = 256;
    goto LABEL_14;
  }
  if (v12 == 2)
  {
    v13 = 512;
LABEL_14:
    *(_QWORD *)(a1 + 32) = v13;
  }
  if (v2 != v3)
  {
    do
    {
      v14 = *v2++;
      operator delete(v14);
    }
    while (v2 != v3);
    v16 = *(_QWORD *)(a1 + 8);
    v15 = *(_QWORD *)(a1 + 16);
    if (v15 != v16)
      *(_QWORD *)(a1 + 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__shared_ptr_emplace<HTTP3Framer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F07C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTP3Framer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F07C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

_QWORD *std::vector<std::shared_ptr<HTTP3Stream>>::__init_with_size[abi:nn180100]<std::shared_ptr<HTTP3Stream>*,std::shared_ptr<HTTP3Stream>*>(_QWORD *result, _QWORD *a2, _QWORD *a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  if (a4)
  {
    if (a4 >> 60)
      abort();
    v6 = result;
    result = std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<HTTP3Stream>>>(a4);
    *v6 = result;
    v6[1] = result;
    v6[2] = &result[2 * v7];
    while (a2 != a3)
    {
      v8 = a2[1];
      *result = *a2;
      result[1] = v8;
      if (v8)
      {
        v9 = (unint64_t *)(v8 + 8);
        do
          v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }
      a2 += 2;
      result += 2;
    }
    v6[1] = result;
  }
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<HTTP3Stream>>>(unint64_t a1)
{
  if (a1 >> 60)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(16 * a1);
}

void HTTP3Connection::_stopStallRecovery(HTTP3Connection *this)
{
  NSObject *v2;
  void *v3;

  *((_BYTE *)this + 920) &= ~0x20u;
  v2 = *((_QWORD *)this + 124);
  if (v2)
  {
    dispatch_source_cancel(v2);
    v3 = (void *)*((_QWORD *)this + 124);
    *((_QWORD *)this + 124) = 0;

  }
}

void ___ZN15HTTP3Connection10initializeEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  CFNumberRef v6;
  void (*v7)(uint64_t);
  NSObject *v8;
  uint64_t v9;
  dispatch_source_t v10;
  void *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *p_shared_weak_owners;
  unint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  void *v19;
  NSObject *v20;
  id v21;
  NSObject *v22;
  id v23;
  unint64_t *v24;
  unint64_t v25;
  NSObject *v26;
  dispatch_time_t v27;
  unint64_t *p_shared_owners;
  unint64_t v29;
  _QWORD v30[2];
  void (*v31)(uint64_t);
  void *v32;
  CFNumberRef v33;
  _QWORD v34[4];
  id v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  _QWORD handler[4];
  id v39;
  _BYTE valuePtr[24];
  void *v41;
  uint64_t v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5 && *(_QWORD *)(v5 + 1008))
      {
        if ((*(_BYTE *)(v5 + 920) & 8) != 0)
        {
          *(_DWORD *)valuePtr = 3;
          v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, valuePtr);
          v30[0] = MEMORY[0x1E0C809B0];
          v7 = ___ZN15HTTP3Connection12_handleStallEv_block_invoke;
          v30[1] = 3221225472;
          v31 = ___ZN15HTTP3Connection12_handleStallEv_block_invoke;
          v32 = &__block_descriptor_40_e5_v8__0l;
          v33 = v6;
          if (v6)
          {
            (*(void (**)(_QWORD, uint64_t, CFNumberRef))(**(_QWORD **)(v5 + 1008) + 200))(*(_QWORD *)(v5 + 1008), 0x1EDCF9DF0, v6);
            v7 = v31;
          }
          v7((uint64_t)v30);
        }
        if (!*(_QWORD *)(v5 + 992))
        {
          CFN_LOG_h3connection();
          v8 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
          {
            v9 = *(_QWORD *)(v5 + 1216);
            *(_DWORD *)valuePtr = 134218240;
            *(_QWORD *)&valuePtr[4] = v5;
            *(_WORD *)&valuePtr[12] = 2048;
            *(_QWORD *)&valuePtr[14] = v9;
            _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_INFO, "%p %llu start stall recovery", valuePtr, 0x16u);
          }

          *(_BYTE *)(v5 + 920) |= 0x20u;
          v10 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(v5 + 1000));
          v11 = *(void **)(v5 + 992);
          *(_QWORD *)(v5 + 992) = v10;

          v13 = *(_QWORD *)(v5 + 8);
          v12 = *(std::__shared_weak_count **)(v5 + 16);
          if (v12)
          {
            p_shared_weak_owners = (unint64_t *)&v12->__shared_weak_owners_;
            do
              v15 = __ldxr(p_shared_weak_owners);
            while (__stxr(v15 + 1, p_shared_weak_owners));
          }
          v16 = MEMORY[0x1E0C809B0];
          *(_QWORD *)valuePtr = MEMORY[0x1E0C809B0];
          *(_QWORD *)&valuePtr[8] = 3321888768;
          *(_QWORD *)&valuePtr[16] = ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke;
          v41 = &__block_descriptor_56_ea8_40c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE_e5_v8__0l;
          v42 = v5;
          v43 = v13;
          v44 = v12;
          if (v12)
          {
            v17 = (unint64_t *)&v12->__shared_weak_owners_;
            do
              v18 = __ldxr(v17);
            while (__stxr(v18 + 1, v17));
          }
          v19 = _Block_copy(valuePtr);
          v20 = *(NSObject **)(v5 + 992);
          handler[0] = v16;
          handler[1] = 3221225472;
          handler[2] = ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke_22;
          handler[3] = &unk_1E14FDEB0;
          v21 = v19;
          v39 = v21;
          dispatch_source_set_cancel_handler(v20, handler);
          v22 = *(NSObject **)(v5 + 992);
          v34[0] = v16;
          v34[1] = 3321888768;
          v34[2] = ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke_2;
          v34[3] = &unk_1E14F3918;
          v23 = v21;
          v35 = v23;
          v36 = v13;
          v37 = v12;
          if (v12)
          {
            v24 = (unint64_t *)&v12->__shared_weak_owners_;
            do
              v25 = __ldxr(v24);
            while (__stxr(v25 + 1, v24));
          }
          dispatch_source_set_event_handler(v22, v34);
          v26 = *(NSObject **)(v5 + 992);
          v27 = dispatch_time(0x8000000000000000, 4000000000);
          dispatch_source_set_timer(v26, v27, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
          (*(void (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)(v5 + 1008) + 136))(*(_QWORD *)(v5 + 1008), 0, 1);
          dispatch_resume(*(dispatch_object_t *)(v5 + 992));
          if (v37)
            std::__shared_weak_count::__release_weak(v37);

          if (v44)
            std::__shared_weak_count::__release_weak(v44);
          if (v12)
            std::__shared_weak_count::__release_weak(v12);
        }
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v29 = __ldaxr(p_shared_owners);
      while (__stlxr(v29 - 1, p_shared_owners));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_18403B4CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, void (*a14)(char *), uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,std::__shared_weak_count *a35)
{
  a14(&a12);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

uint64_t ___ZN15HTTP3Connection10initializeEv_block_invoke_6(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v2)
    return 0;
  v3 = std::__shared_weak_count::lock(v2);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = *(_QWORD *)(a1 + 32);
  if (v5 && (v6 = *(_QWORD *)(v5 + 1008)) != 0)
    v7 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 216))(v6, 0x1EDCF96B8);
  else
    v7 = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return v7;
}

void sub_18403B5EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN15HTTP3Connection20_setupIncomingStreamEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_b_block_invoke_2(uint64_t a1, void *a2, int a3, unint64_t a4)
{
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  unint64_t p_shared_owners;
  _QWORD *v11;
  uint64_t v12;
  uint64_t *v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  char v22;
  unint64_t v23;
  unint64_t v24;
  uint8x8_t v25;
  uint64_t **v26;
  uint64_t *v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  float v31;
  float v32;
  _BOOL8 v33;
  unint64_t v34;
  unint64_t v35;
  int8x8_t prime;
  void *v37;
  void *v38;
  uint64_t v39;
  _QWORD *v40;
  unint64_t v41;
  uint8x8_t v42;
  unint64_t v43;
  uint8x8_t v44;
  uint64_t v45;
  _QWORD *v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  unint64_t *v54;
  unint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  void *v61;
  id v62;
  std::__shared_weak_count *v63;
  _QWORD *v64;
  std::__shared_weak_count *v65;
  int v66;
  __int128 v67;
  uint64_t *v68;
  std::__shared_weak_count *v69;
  char v70;

  v62 = a2;
  if (*(int *)(*(_QWORD *)(a1 + 40) + 792) - 1 < a4)
  {
    HTTP3Connection::_cleanupConnection(*(HTTP3Connection **)(a1 + 48), 264, 0);
    HTTP3Connection::reportServerProtocolViolation(*(_QWORD *)(a1 + 48), 55, -1);
    goto LABEL_117;
  }
  v7 = *(_QWORD *)(a1 + 48);
  v8 = (std::__shared_weak_count *)operator new(0xB8uLL);
  v9 = v8;
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t)&v8->__shared_owners_;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F07C0;
  v11 = &v8[1].__vftable;
  v12 = *(_QWORD *)(v7 + 1008);
  if (v12)
    v13 = (uint64_t *)(v12 + 112);
  else
    v13 = 0;
  v14 = *(std::__shared_weak_count **)(v7 + 1016);
  v68 = v13;
  v69 = v14;
  if (v14)
  {
    v15 = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  HTTP3Framer::HTTP3Framer((uint64_t)&v8[1], (uint64_t *)&v68, 0, 1, 1);
  if (v14)
  {
    v17 = (unint64_t *)&v14->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v64 = v11;
  v65 = v9;
  std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&v64, v11, (uint64_t)v11);
  HTTP3Framer::setReadHandleBeforeReading((uint64_t)v11, *(void **)(a1 + 32), v62, a3);
  v19 = *(_QWORD *)(a1 + 48);
  v63 = v9;
  do
    v20 = __ldxr((unint64_t *)p_shared_owners);
  while (__stxr(v20 + 1, (unint64_t *)p_shared_owners));
  if (*(_DWORD *)(v19 + 792) <= (int)a4)
  {
    v22 = 0;
    goto LABEL_105;
  }
  v21 = *(_DWORD *)(v19 + 796);
  if (v21 <= (int)a4)
  {
    if (v21 < (int)a4)
    {
      do
      {
        std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(v19 + 800, v21, v21);
        std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(v19 + 840, v21, v21);
        ++v21;
      }
      while ((_DWORD)a4 != v21);
    }
    std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(v19 + 800, a4, a4);
    *(_DWORD *)(v19 + 796) = a4 + 1;
  }
  else if (!std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__erase_unique<int>((uint64_t *)(v19 + 840), a4))
  {
    v22 = 0;
    goto LABEL_104;
  }
  v66 = a4;
  *(_QWORD *)&v67 = v11;
  *((_QWORD *)&v67 + 1) = v9;
  do
    v23 = __ldxr((unint64_t *)p_shared_owners);
  while (__stxr(v23 + 1, (unint64_t *)p_shared_owners));
  v24 = *(_QWORD *)(v19 + 888);
  if (!v24)
    goto LABEL_43;
  v25 = (uint8x8_t)vcnt_s8((int8x8_t)v24);
  v25.i16[0] = vaddlv_u8(v25);
  if (v25.u32[0] > 1uLL)
  {
    p_shared_owners = (int)a4;
    if (v24 <= (int)a4)
      p_shared_owners = (int)a4 % v24;
  }
  else
  {
    p_shared_owners = (v24 - 1) & (int)a4;
  }
  v26 = *(uint64_t ***)(*(_QWORD *)(v19 + 880) + 8 * p_shared_owners);
  if (!v26 || (v27 = *v26) == 0)
  {
LABEL_43:
    v29 = operator new(0x28uLL);
    v30 = (_QWORD *)(v19 + 896);
    v68 = v29;
    v69 = (std::__shared_weak_count *)(v19 + 896);
    *v29 = 0;
    v29[1] = (int)a4;
    *((_DWORD *)v29 + 4) = a4;
    *(_OWORD *)(v29 + 3) = v67;
    v67 = 0uLL;
    v70 = 1;
    v31 = (float)(unint64_t)(*(_QWORD *)(v19 + 904) + 1);
    v32 = *(float *)(v19 + 912);
    if (v24 && (float)(v32 * (float)v24) >= v31)
    {
LABEL_89:
      v49 = *(uint64_t **)(*(_QWORD *)(v19 + 880) + 8 * p_shared_owners);
      v50 = (uint64_t)v68;
      if (v49)
      {
        *v68 = *v49;
      }
      else
      {
        *v68 = *(_QWORD *)(v19 + 896);
        *(_QWORD *)(v19 + 896) = v50;
        *(_QWORD *)(*(_QWORD *)(v19 + 880) + 8 * p_shared_owners) = v30;
        if (!*(_QWORD *)v50)
        {
LABEL_98:
          v68 = 0;
          ++*(_QWORD *)(v19 + 904);
          std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,void *>>>>::reset[abi:nn180100]((uint64_t)&v68);
          goto LABEL_99;
        }
        v51 = *(_QWORD *)(*(_QWORD *)v50 + 8);
        if ((v24 & (v24 - 1)) != 0)
        {
          if (v51 >= v24)
            v51 %= v24;
        }
        else
        {
          v51 &= v24 - 1;
        }
        v49 = (uint64_t *)(*(_QWORD *)(v19 + 880) + 8 * v51);
      }
      *v49 = v50;
      goto LABEL_98;
    }
    v33 = 1;
    if (v24 >= 3)
      v33 = (v24 & (v24 - 1)) != 0;
    v34 = v33 | (2 * v24);
    v35 = vcvtps_u32_f32(v31 / v32);
    if (v34 <= v35)
      prime = (int8x8_t)v35;
    else
      prime = (int8x8_t)v34;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v24 = *(_QWORD *)(v19 + 888);
    if (*(_QWORD *)&prime > v24)
      goto LABEL_55;
    if (*(_QWORD *)&prime < v24)
    {
      v43 = vcvtps_u32_f32((float)*(unint64_t *)(v19 + 904) / *(float *)(v19 + 912));
      if (v24 < 3 || (v44 = (uint8x8_t)vcnt_s8((int8x8_t)v24), v44.i16[0] = vaddlv_u8(v44), v44.u32[0] > 1uLL))
      {
        v43 = std::__next_prime(v43);
      }
      else
      {
        v45 = 1 << -(char)__clz(v43 - 1);
        if (v43 >= 2)
          v43 = v45;
      }
      if (*(_QWORD *)&prime <= v43)
        prime = (int8x8_t)v43;
      if (*(_QWORD *)&prime >= v24)
      {
        v24 = *(_QWORD *)(v19 + 888);
      }
      else
      {
        if (prime)
        {
LABEL_55:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v37 = operator new(8 * *(_QWORD *)&prime);
          v38 = *(void **)(v19 + 880);
          *(_QWORD *)(v19 + 880) = v37;
          if (v38)
            operator delete(v38);
          v39 = 0;
          *(int8x8_t *)(v19 + 888) = prime;
          do
            *(_QWORD *)(*(_QWORD *)(v19 + 880) + 8 * v39++) = 0;
          while (*(_QWORD *)&prime != v39);
          v40 = (_QWORD *)*v30;
          if (*v30)
          {
            v41 = v40[1];
            v42 = (uint8x8_t)vcnt_s8(prime);
            v42.i16[0] = vaddlv_u8(v42);
            if (v42.u32[0] > 1uLL)
            {
              if (v41 >= *(_QWORD *)&prime)
                v41 %= *(_QWORD *)&prime;
            }
            else
            {
              v41 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)(v19 + 880) + 8 * v41) = v30;
            v46 = (_QWORD *)*v40;
            if (*v40)
            {
              do
              {
                v47 = v46[1];
                if (v42.u32[0] > 1uLL)
                {
                  if (v47 >= *(_QWORD *)&prime)
                    v47 %= *(_QWORD *)&prime;
                }
                else
                {
                  v47 &= *(_QWORD *)&prime - 1;
                }
                if (v47 != v41)
                {
                  v48 = *(_QWORD *)(v19 + 880);
                  if (!*(_QWORD *)(v48 + 8 * v47))
                  {
                    *(_QWORD *)(v48 + 8 * v47) = v40;
                    goto LABEL_80;
                  }
                  *v40 = *v46;
                  *v46 = **(_QWORD **)(*(_QWORD *)(v19 + 880) + 8 * v47);
                  **(_QWORD **)(*(_QWORD *)(v19 + 880) + 8 * v47) = v46;
                  v46 = v40;
                }
                v47 = v41;
LABEL_80:
                v40 = v46;
                v46 = (_QWORD *)*v46;
                v41 = v47;
              }
              while (v46);
            }
          }
          v24 = (unint64_t)prime;
          goto LABEL_84;
        }
        v61 = *(void **)(v19 + 880);
        *(_QWORD *)(v19 + 880) = 0;
        if (v61)
          operator delete(v61);
        v24 = 0;
        *(_QWORD *)(v19 + 888) = 0;
      }
    }
LABEL_84:
    if ((v24 & (v24 - 1)) != 0)
    {
      if (v24 <= (int)a4)
        p_shared_owners = (int)a4 % v24;
      else
        p_shared_owners = (int)a4;
    }
    else
    {
      p_shared_owners = (v24 - 1) & (int)a4;
    }
    goto LABEL_89;
  }
  while (1)
  {
    v28 = v27[1];
    if (v28 == (int)a4)
      break;
    if (v25.u32[0] > 1uLL)
    {
      if (v28 >= v24)
        v28 %= v24;
    }
    else
    {
      v28 &= v24 - 1;
    }
    if (v28 != p_shared_owners)
      goto LABEL_43;
LABEL_42:
    v27 = (uint64_t *)*v27;
    if (!v27)
      goto LABEL_43;
  }
  if (*((_DWORD *)v27 + 4) != (_DWORD)a4)
    goto LABEL_42;
  v59 = (unint64_t *)&v9->__shared_owners_;
  do
    v60 = __ldaxr(v59);
  while (__stlxr(v60 - 1, v59));
  if (!v60)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
LABEL_99:
  v52 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>((_QWORD *)(v19 + 672), a4);
  if (v52 && (v53 = v52[3]) != 0 && HTTP2ServerPushStream::_invokeCompletionHadlers(v53, 0))
  {
    v22 = 1;
    HTTP2ServerPush::_removeStream((HTTP2ServerPush *)(v19 + 624), a4, 1);
  }
  else
  {
    v22 = 1;
  }
LABEL_104:
  v9 = v63;
  if (v63)
  {
LABEL_105:
    v54 = (unint64_t *)&v9->__shared_owners_;
    do
      v55 = __ldaxr(v54);
    while (__stlxr(v55 - 1, v54));
    if (v55)
      goto LABEL_108;
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if ((v22 & 1) == 0)
LABEL_111:
      HTTP3Framer::cancelStream((uint64_t)v64, 268);
  }
  else
  {
LABEL_108:
    if ((v22 & 1) == 0)
      goto LABEL_111;
  }
  v56 = v65;
  if (v65)
  {
    v57 = (unint64_t *)&v65->__shared_owners_;
    do
      v58 = __ldaxr(v57);
    while (__stlxr(v58 - 1, v57));
    if (!v58)
    {
      ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
      std::__shared_weak_count::__release_weak(v56);
    }
  }
LABEL_117:

}

void sub_18403BCE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, char a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  uint64_t v18;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,void *>>>>::reset[abi:nn180100]((uint64_t)&a18);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v18);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a13);

  _Unwind_Resume(a1);
}

void HTTP3Connection::_readPushID(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9;
  NSObject *v10;
  void (**v11)(id, dispatch_data_t, uint64_t, _QWORD);
  uint64_t v12;
  dispatch_data_t subrange;
  uint64_t v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  NSObject *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  _QWORD v24[4];
  id v25;
  NSObject *v26;
  void (**v27)(id, dispatch_data_t, uint64_t, _QWORD);
  uint64_t v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  _QWORD applier[7];
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  char v44;

  v9 = a2;
  v10 = a3;
  v11 = a5;
  v41 = 0;
  v42 = &v41;
  v43 = 0x2020000000;
  v44 = 0;
  v37 = 0;
  v38 = &v37;
  v39 = 0x2810000000;
  v40 = &unk_18422E08D;
  v33 = 0;
  v34 = &v33;
  v35 = 0x2020000000;
  v36 = 0;
  v12 = MEMORY[0x1E0C809B0];
  applier[0] = MEMORY[0x1E0C809B0];
  applier[1] = 3221225472;
  applier[2] = ___ZN15HTTP3Connection11_readPushIDEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_bU13block_pointerFvS4_byE_block_invoke;
  applier[3] = &unk_1E14F8FB0;
  applier[4] = &v33;
  applier[5] = &v37;
  applier[6] = &v41;
  dispatch_data_apply(v10, applier);
  if (*((_BYTE *)v42 + 24))
  {
    subrange = dispatch_data_create_subrange(v10, *((unsigned __int8 *)v34 + 24), 0xFFFFFFFFFFFFFFFFLL);

    v10 = subrange;
    v11[2](v11, subrange, a4, v38[4]);
  }
  else if ((_DWORD)a4)
  {
    (*(void (**)(_QWORD, id))(**(_QWORD **)(a1 + 1008) + 80))(*(_QWORD *)(a1 + 1008), v9);
  }
  else
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v30, *(_QWORD *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
    v14 = *(_QWORD *)(a1 + 1008);
    v24[0] = v12;
    v24[1] = 3321888768;
    v24[2] = ___ZN15HTTP3Connection11_readPushIDEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_bU13block_pointerFvS4_byE_block_invoke_2;
    v24[3] = &unk_1E14F44A8;
    v28 = v30;
    v29 = v31;
    if (v31)
    {
      p_shared_owners = (unint64_t *)&v31->__shared_owners_;
      do
        v16 = __ldxr(p_shared_owners);
      while (__stxr(v16 + 1, p_shared_owners));
    }
    v25 = v9;
    v17 = v10;
    v26 = v17;
    v27 = v11;
    (*(void (**)(uint64_t, id, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v14 + 56))(v14, v25, 1, 132000, v24);

    v18 = v29;
    if (v29)
    {
      v19 = (unint64_t *)&v29->__shared_owners_;
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    v21 = v31;
    if (v31)
    {
      v22 = (unint64_t *)&v31->__shared_owners_;
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
    v10 = v17;
  }
  _Block_object_dispose(&v33, 8);
  _Block_object_dispose(&v37, 8);
  _Block_object_dispose(&v41, 8);

}

void sub_18403C004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v31);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a19);
  _Block_object_dispose(&a28, 8);
  _Block_object_dispose((const void *)(v32 - 136), 8);
  _Block_object_dispose((const void *)(v32 - 96), 8);

  _Unwind_Resume(a1);
}

uint64_t HTTP3Connection::reportServerProtocolViolation(uint64_t a1, int a2, uint64_t a3)
{
  NSObject *v6;
  _BOOL4 v7;
  uint64_t v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  uint64_t result;
  uint64_t v13;
  _QWORD v14[4];
  char v15;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  CFN_LOG_h3connection();
  v6 = objc_claimAutoreleasedReturnValue();
  v7 = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  if (a3 == -1)
  {
    if (!v7)
      goto LABEL_5;
    v13 = *(_QWORD *)(a1 + 1216);
    *(_DWORD *)buf = 134218496;
    v17 = a1;
    v18 = 2048;
    v19 = v13;
    v20 = 1024;
    v21 = a2;
    v9 = "%p %llu Server protocol violation 0x%02hhx";
    v10 = v6;
    v11 = 28;
  }
  else
  {
    if (!v7)
      goto LABEL_5;
    v8 = *(_QWORD *)(a1 + 1216);
    *(_DWORD *)buf = 134218752;
    v17 = a1;
    v18 = 2048;
    v19 = v8;
    v20 = 1024;
    v21 = a2;
    v22 = 2048;
    v23 = a3;
    v9 = "%p %llu Server protocol violation 0x%02hhx on stream ID=%llu";
    v10 = v6;
    v11 = 38;
  }
  _os_log_error_impl(&dword_183ECA000, v10, OS_LOG_TYPE_ERROR, v9, buf, v11);
LABEL_5:

  result = *(_QWORD *)(a1 + 1008);
  if (result)
  {
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3221225472;
    v14[2] = ___ZN15HTTP3Connection29reportServerProtocolViolationEN2H323ServerProtocolViolationEy_block_invoke;
    v14[3] = &__block_descriptor_33_e24_v20__0____CFString__8B16l;
    v15 = a2;
    return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)result + 344))(result, v14);
  }
  return result;
}

void ___ZN15HTTP3Connection29reportServerProtocolViolationEN2H323ServerProtocolViolationEy_block_invoke(uint64_t a1, void *a2, char a3)
{
  id v3;
  double v4;
  id v5;

  if (a2 && (a3 & 1) == 0)
  {
    v3 = a2;
    if ((objc_msgSend(v3, "isEqualToString:", CFSTR("localhost")) & 1) == 0)
    {
      v5 = v3;
      AnalyticsSendEventLazy_delayInitStub(v4);

    }
  }
}

void sub_18403C288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;

  _Unwind_Resume(a1);
}

BOOL ___ZN15HTTP3Connection11_readPushIDEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_bU13block_pointerFvS4_byE_block_invoke(_QWORD *a1, int a2, int a3, void *__src, unint64_t a5)
{
  uint64_t v6;
  size_t v7;
  unint64_t *v8;
  uint64_t v9;
  unsigned __int8 *v10;
  const unsigned __int8 *v12;
  unint64_t *v13;

  v6 = *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
  if (8 - v6 >= a5)
    v7 = a5;
  else
    v7 = 8 - v6;
  memcpy((void *)(*(_QWORD *)(a1[5] + 8) + v6 + 32), __src, v7);
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) += v7;
  v8 = (unint64_t *)(*(_QWORD *)(a1[5] + 8) + 32);
  v9 = *(_QWORD *)(a1[4] + 8);
  v12 = (const unsigned __int8 *)*(unsigned __int8 *)(v9 + 24);
  v13 = v8;
  *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24) = QUICUtilities::quic_vle_decode((QUICUtilities *)&v13, &v12, v8, (unint64_t *)(v9 + 24), v10);
  return *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24) == 0;
}

void ___ZN15HTTP3Connection11_readPushIDEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_bU13block_pointerFvS4_byE_block_invoke_2(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  dispatch_data_t concat;
  id v11;

  v11 = a2;
  v7 = a3;
  v8 = *(_QWORD *)(a1 + 56);
  if (v7)
  {
    if (*(_QWORD *)(v8 + 992))
    {
      HTTP3Connection::_stopStallRecovery(*(HTTP3Connection **)(a1 + 56));
      v8 = *(_QWORD *)(a1 + 56);
    }
    v9 = *(_QWORD *)(a1 + 32);
    concat = dispatch_data_create_concat(*(dispatch_data_t *)(a1 + 40), v7);
    HTTP3Connection::_readPushID(v8, v9, concat, a4, *(_QWORD *)(a1 + 48));

  }
  else
  {
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v8 + 1008) + 80))(*(_QWORD *)(v8 + 1008), *(_QWORD *)(a1 + 32));
  }

}

void sub_18403C40C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_56c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(result + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 64) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_56c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 56);
}

uint64_t __copy_helper_block_ea8_48c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 56) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_48c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

uint64_t HTTP3Connection::_cleanupIfNoStreams(uint64_t this)
{
  *(_BYTE *)(this + 920) |= 2u;
  if (*(_QWORD *)(this + 1136) == *(_QWORD *)(this + 1144))
    return HTTP3Connection::_cleanupConnection((HTTP3Connection *)this);
  return this;
}

void ___ZN15HTTP3Connection12_handleStallEv_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  unsigned int v9;
  char v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  uint8_t buf[4];
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    v3 = a1[4];
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      v6 = a1[5];
      if (v6)
      {
        CFN_LOG_h3connection();
        v7 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
        {
          v8 = *(_QWORD *)(v3 + 1216);
          v9 = *(unsigned __int8 *)(v6 + 920);
          *(_DWORD *)buf = 134218752;
          v15 = v3;
          v16 = 2048;
          v17 = v8;
          v18 = 1024;
          v19 = (v9 >> 4) & 1;
          v20 = 1024;
          v21 = (v9 >> 5) & 1;
          _os_log_impl(&dword_183ECA000, v7, OS_LOG_TYPE_INFO, "%p %llu stall recovery timer done (fb=%d sip=%d)", buf, 0x22u);
        }

        v10 = *(_BYTE *)(v6 + 920);
        if ((v10 & 0x30) == 0x20)
        {
          *(_BYTE *)(v6 + 920) = v10 & 0xDF;
          v11 = *(_QWORD *)(v6 + 1008);
          if (v11)
            (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v11 + 136))(v11, 0, 0);
        }
      }
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
}

void sub_18403C628(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke_22(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke_2(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  HTTP3Connection *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  (*(void (**)(void))(a1[4] + 16))();
  v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = (HTTP3Connection *)a1[5];
      if (v5 && *((_QWORD *)v5 + 124))
        HTTP3Connection::_stopStallRecovery(v5);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

uint64_t __copy_helper_block_ea8_40c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_ea8_40c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void std::__shared_ptr_emplace<HTTP3Stream>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F07F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTP3Stream>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F07F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t HTTP3StreamWrapper::copyProperty(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32));
}

uint64_t HTTP3StreamWrapper::setProperty(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
}

uint64_t HTTP3StreamWrapper::setBodyStreamBeforeOpening(HTTP3StreamWrapper *this, __CFReadStream *a2)
{
  return (*(uint64_t (**)(_QWORD, __CFReadStream *))(**((_QWORD **)this + 4) + 32))(*((_QWORD *)this + 4), a2);
}

uint64_t HTTP3StreamWrapper::canScheduleAndOpenWithHandlerAsync(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 40))(*((_QWORD *)this + 4));
}

uint64_t HTTP3StreamWrapper::scheduleAndOpenWithHandler(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

uint64_t HTTP3StreamWrapper::closeAndClearHandler(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 56))(*((_QWORD *)this + 4));
}

uint64_t HTTP3StreamWrapper::updateScheduling(HTTP3StreamWrapper *this, const CoreSchedulingSet *a2)
{
  return (*(uint64_t (**)(_QWORD, const CoreSchedulingSet *))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4), a2);
}

uint64_t HTTP3StreamWrapper::setPriorityHint(HTTP3StreamWrapper *this, float a2)
{
  return (*(uint64_t (**)(_QWORD, float))(**((_QWORD **)this + 4) + 72))(*((_QWORD *)this + 4), a2);
}

uint64_t HTTP3StreamWrapper::rawBytesSent(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 80))(*((_QWORD *)this + 4));
}

uint64_t HTTP3StreamWrapper::rawBytesReceived(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 88))(*((_QWORD *)this + 4));
}

uint64_t HTTP3StreamWrapper::getConnectionIdentifier(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 96))(*((_QWORD *)this + 4));
}

uint64_t HTTP3StreamWrapper::copyTrust(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 104))(*((_QWORD *)this + 4));
}

uint64_t HTTP3StreamWrapper::_conn_no_more_reqests_after_this_one_connectionLost(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 112))(*((_QWORD *)this + 4));
}

void HTTP3StreamWrapper::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = (std::__shared_weak_count *)a2[1];
  v9 = *a2;
  v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v2 + 120))(v2, &v9);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_18403C8E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t HTTP3StreamWrapper::getProxy(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 128))(*((_QWORD *)this + 4));
}

uint64_t HTTP3StreamWrapper::setTransactionMetrics(HTTP3StreamWrapper *this, __CFN_TransactionMetrics *a2)
{
  return (*(uint64_t (**)(_QWORD, __CFN_TransactionMetrics *))(**((_QWORD **)this + 4) + 136))(*((_QWORD *)this + 4), a2);
}

uint64_t HTTP3StreamWrapper::_meta_retain(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(HTTP3StreamWrapper *))(*(_QWORD *)this + 40))(this);
}

uint64_t HTTP3StreamWrapper::_meta_release(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(HTTP3StreamWrapper *))(*(_QWORD *)this + 48))(this);
}

void `non-virtual thunk to'HTTP3StreamWrapper::~HTTP3StreamWrapper(HTTP3StreamWrapper *this)
{
  *((_QWORD *)this - 3) = off_1E14E94A8;
  *(_QWORD *)this = &unk_1E14E9580;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
}

{
  char *v2;

  *((_QWORD *)this - 3) = off_1E14E94A8;
  v2 = (char *)this - 24;
  *(_QWORD *)this = &unk_1E14E9580;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this - 2), v2);
}

void `non-virtual thunk to'HTTP3StreamWrapper::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = (std::__shared_weak_count *)a2[1];
  v9 = *a2;
  v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v2 + 120))(v2, &v9);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_18403CA14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  unint64_t *p_shared_owners;
  unint64_t v12;

  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN15HTTP3Connection22logConnectionAtAPSleepEv_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1008);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 432))(result);
  return result;
}

uint64_t ___ZN15HTTP3Connection26markReusedAfterAPSleepWakeEv_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1008);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 160))(result);
  return result;
}

__CFString *NetConnection::copyDebugDesc(NetConnection *this)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  const __CFString *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  const void *v12;
  const __CFString *v13;
  uint64_t v14;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v4 = *((_QWORD *)this + 12);
  if (v4)
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  (*(void (**)(NetConnection *))(*(_QWORD *)this + 40))(this);
  v5 = *((_QWORD *)this + 12);
  if (v5)
    pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
  (*(void (**)(NetConnection *))(*(_QWORD *)this + 48))(this);
  v6 = (_QWORD *)*((_QWORD *)this + 14);
  if (v6)
  {
    LODWORD(v7) = 0;
    do
    {
      v6 = (_QWORD *)*v6;
      v7 = (v7 + 1);
    }
    while (v6);
  }
  else
  {
    v7 = 0;
  }
  v8 = CFStringCreateWithFormat(v2, 0, CFSTR("<NetConnection@%p> { State = %s, Count = %d, requests = {"), this, "", v7);
  v9 = *((_QWORD *)this + 12);
  if (v9)
    pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
  CFStringAppend(Mutable, v8);
  if (v8)
    CFRelease(v8);
  v10 = (_QWORD *)*((_QWORD *)this + 14);
  if (v10)
  {
    v11 = 0;
    do
    {
      v12 = (const void *)(*(uint64_t (**)(NetConnection *, _QWORD))(*(_QWORD *)this + 184))(this, v10[1]);
      v13 = CFStringCreateWithFormat(v2, 0, CFSTR("%d: %@, "), v11, v12);
      if (v12)
        CFRelease(v12);
      CFStringAppend(Mutable, v13);
      if (v13)
        CFRelease(v13);
      v11 = (v11 + 1);
      v10 = (_QWORD *)*v10;
    }
    while (v10);
  }
  CFStringAppend(Mutable, CFSTR("}  }"));
  v14 = *((_QWORD *)this + 12);
  if (v14)
    pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8));
  return Mutable;
}

BOOL NetConnection::equals(NetConnection *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

uint64_t NetConnection::copyDescription(NetConnection *this)
{
  return (*(uint64_t (**)(NetConnection *))(*(_QWORD *)this + 16))(this);
}

uint64_t NetConnection::errorOccurred(NetConnection *this, CFStreamError *a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  void (*v7)(NetConnection *, _QWORD);

  (*(void (**)(NetConnection *))(*(_QWORD *)this + 40))(this);
  v4 = *((_QWORD *)this + 12);
  if (v4)
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  *((_WORD *)this + 44) &= ~1u;
  v5 = (uint64_t *)*((_QWORD *)this + 17);
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  NetConnection::sendStateChanged((uint64_t)this, v5, (uint64_t)a2);
  NetConnection::shutdownConnectionStreams((uint64_t)this, 0);
  *((_WORD *)this + 44) |= 0x800u;
  v6 = *((_QWORD *)this + 12);
  if (v6)
    pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  v7 = (void (*)(NetConnection *, _QWORD))*((_QWORD *)this + 23);
  if (v7)
    v7(this, *((_QWORD *)this + 27));
  return (*(uint64_t (**)(NetConnection *))(*(_QWORD *)this + 48))(this);
}

uint64_t NetConnection::connectionLost(NetConnection *this)
{
  uint64_t v2;
  uint64_t **v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(NetConnection *, _QWORD);
  uint64_t v9;
  int v10;

  (*(void (**)(NetConnection *))(*(_QWORD *)this + 40))(this);
  v2 = *((_QWORD *)this + 12);
  if (v2)
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  *((_WORD *)this + 44) = *((_WORD *)this + 44) & 0xFEFE | 0x100;
  v3 = (uint64_t **)*((_QWORD *)this + 17);
  if (v3)
  {
    v4 = *v3;
    if (*v3)
    {
      v9 = 4;
      v10 = -4;
      v5 = *((_QWORD *)this + 16);
      if (v5 && (uint64_t **)v5 != v3)
      {
        *((_QWORD *)this + 16) = 0;
        NetConnection::scheduleNewRequest(this, 0, v5, 0);
      }
      NetConnection::sendStateChanged((uint64_t)this, v4, (uint64_t)&v9);
    }
  }
  NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease((uint64_t)this);
  v6 = *((_QWORD *)this + 12);
  if (v6)
    pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  v7 = (void (*)(NetConnection *, _QWORD))*((_QWORD *)this + 23);
  if (v7)
    v7(this, *((_QWORD *)this + 27));
  return (*(uint64_t (**)(NetConnection *))(*(_QWORD *)this + 48))(this);
}

uint64_t NetConnection::pendingResponseCount(NetConnection *this)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *((_QWORD *)this + 12);
  if (v2)
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  v3 = (_QWORD *)((char *)this + 136);
  LODWORD(v4) = -1;
  do
  {
    v3 = (_QWORD *)*v3;
    v4 = (v4 + 1);
  }
  while (v3);
  v5 = *((_QWORD *)this + 12);
  if (v5)
    pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
  return v4;
}

void NetConnection::closeConnectionStreams(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    CoreStreamBase::_streamInterface_Close((CoreStreamBase *)(a3 + 16));
  }
  if (a4)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    CoreStreamBase::_streamInterface_Close((CoreStreamBase *)(a4 + 16));
  }
}

uint64_t NetConnection::cleanAbortRequestTransmission(uint64_t this)
{
  *(_WORD *)(this + 88) &= ~0x20u;
  if (*(_QWORD *)(this + 128) == *(_QWORD *)(this + 136))
    *(_QWORD *)(this + 136) = 0;
  return this;
}

uint64_t NetConnection::copyTrust(NetConnection *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  v2 = *((_QWORD *)this + 12);
  if (v2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
    v3 = *((_QWORD *)this + 12);
    v4 = *((_QWORD *)this + 18);
    if (v3)
      pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
    if (v4)
      goto LABEL_5;
    return 0;
  }
  v4 = *((_QWORD *)this + 18);
  if (!v4)
    return 0;
LABEL_5:
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  ++*(_QWORD *)(v4 + 96);
  result = (*(uint64_t (**)(_QWORD, __CFString *))(**(_QWORD **)(v4 + 40) + 40))(*(_QWORD *)(v4 + 40), CFSTR("kCFStreamPropertySSLPeerTrust"));
  --*(_QWORD *)(v4 + 96);
  return result;
}

void NetConnection::scheduleNewRequest(NetConnection *this, uint64_t **a2, uint64_t a3, int a4)
{
  char v8;
  char *v9;
  uint64_t **v10;
  const CoreSchedulingSet *v11;
  __int16 v12;

  v8 = *((_BYTE *)this + 88);
  if (!a3 || (*((_BYTE *)this + 88) & 2) != 0)
  {
    v9 = (char *)*((_QWORD *)this + 18);
    if (v9)
    {
      if (a2)
      {
        v10 = a2;
        while (((_BYTE)v10[2] & 2) != 0)
        {
          v10 = (uint64_t **)*v10;
          if (!v10)
          {
            v10 = a2;
            break;
          }
        }
        v11 = (const CoreSchedulingSet *)(*(uint64_t (**)(NetConnection *, uint64_t *))(*(_QWORD *)this + 160))(this, v10[1]);
        NetConnection::rescheduleStream(*((char **)this + 18), v11);
        if (v11)
          (*(void (**)(const CoreSchedulingSet *))(*(_QWORD *)v11 + 48))(v11);
      }
      else
      {
        NetConnection::rescheduleStream(v9, 0);
      }
    }
  }
  v12 = *((_WORD *)this + 44);
  if ((v8 & 0x40) != 0)
  {
    if ((v12 & 0x80) == 0)
      NetConnection::setClient((uint64_t)this);
  }
  else
  {
    *((_WORD *)this + 44) = v12 | 0x40;
    NetConnection::openConnectionStreams((uint64_t)this);
  }
  if (a3)
  {
    (*(void (**)(NetConnection *, _QWORD, uint64_t, _QWORD))(*(_QWORD *)this + 120))(this, *(_QWORD *)(a3 + 8), 3, 0);
    *((_WORD *)this + 44) &= ~0x20u;
    if (a4)
      NetConnection::scheduleNewResponse(this, (uint64_t **)a3, 0);
  }
  if (a2)
  {
    *((_WORD *)this + 44) |= 0x20u;
    (*(void (**)(NetConnection *, uint64_t *, uint64_t, _QWORD))(*(_QWORD *)this + 120))(this, a2[1], 2, 0);
  }
}

uint64_t NetConnection::sendStateChanged(uint64_t result, uint64_t *a2, uint64_t a3)
{
  uint64_t i;
  uint64_t v5;

  for (i = result; a2; a2 = (uint64_t *)*a2)
    *((_BYTE *)a2 + 16) |= 1u;
LABEL_3:
  v5 = i + 112;
  while (1)
  {
    v5 = *(_QWORD *)v5;
    if (!v5)
      return result;
    if ((*(_BYTE *)(v5 + 16) & 1) != 0)
    {
      *(_BYTE *)(v5 + 16) &= ~1u;
      result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)i + 120))(i, *(_QWORD *)(v5 + 8), 7, a3);
      goto LABEL_3;
    }
  }
}

uint64_t NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = this;
  v2 = *(_QWORD *)(this + 96);
  if (v2)
    this = pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  if (*(_DWORD *)(v1 + 104) || *(_DWORD *)(v1 + 108))
    *(_WORD *)(v1 + 88) |= 0x800u;
  else
    this = NetConnection::shutdownConnectionStreams(v1, 0);
  v3 = *(_QWORD *)(v1 + 96);
  if (v3)
    return pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
  return this;
}

uint64_t NetConnection::shutdownConnectionStreams(uint64_t this, void *a2)
{
  __int16 v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CoreStreamBase *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CoreStreamBase *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v2 = *(_WORD *)(this + 88);
  *(_WORD *)(this + 88) = v2 & 0xFF7F;
  if ((v2 & 0x2000) != 0)
  {
    v4 = this;
    v5 = *(_QWORD *)(this + 144);
    if (v5)
    {
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v5 + 16)) <= 1)
      {
        v6 = *(_QWORD *)(v4 + 144);
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
        if (v6)
          v7 = (CoreStreamBase *)(v6 + 16);
        else
          v7 = 0;
        CoreStreamBase::_streamInterface_Open(v7);
      }
      v8 = *(_QWORD *)(v4 + 144);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      if (v8)
        v9 = v8 + 16;
      else
        v9 = 0;
      (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v9 + 56))(v9, 0, 0);
      v10 = *(_QWORD *)(v4 + 144);
    }
    else
    {
      v10 = 0;
    }
    v11 = *(_QWORD *)(v4 + 152);
    if (v11)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v11 + 16)) <= 1)
      {
        v12 = *(_QWORD *)(v4 + 152);
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
        if (v12)
          v13 = (CoreStreamBase *)(v12 + 16);
        else
          v13 = 0;
        CoreStreamBase::_streamInterface_Open(v13);
      }
      v14 = *(_QWORD *)(v4 + 152);
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      if (v14)
        v15 = v14 + 16;
      else
        v15 = 0;
      (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v15 + 56))(v15, 0, 0);
      v16 = *(_QWORD *)(v4 + 152);
    }
    else
    {
      v16 = 0;
    }
    this = (*(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t))(*(_QWORD *)v4 + 176))(v4, a2, v16, v10);
    *(_WORD *)(v4 + 88) &= ~0x2000u;
  }
  return this;
}

void NetConnection::rescheduleStream(char *cf, const CoreSchedulingSet *a2)
{
  const CoreSchedulingSet *v2;
  CoreStreamBase *v4;

  v2 = a2;
  if (!cf)
  {
    v4 = 0;
    if (a2)
      goto LABEL_10;
    goto LABEL_7;
  }
  CFRetain(cf);
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  v4 = (CoreStreamBase *)(cf + 16);
  if (!v2)
  {
LABEL_7:
    if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
      dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16941);
    v2 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
  }
LABEL_10:
  CoreStreamBase::_streamInterface_UpdateScheduling(v4, v2);
  if (cf)
    CFRelease(cf);
}

uint64_t NetConnection::openConnectionStreams(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = this;
  v2 = *(_QWORD *)(this + 144);
  if (v2)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    this = CoreStreamBase::_streamInterface_Open((CoreStreamBase *)(v2 + 16));
  }
  v3 = *(_QWORD *)(v1 + 152);
  if (v3)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    this = CoreStreamBase::_streamInterface_Open((CoreStreamBase *)(v3 + 16));
  }
  *(_WORD *)(v1 + 88) |= 0x2000u;
  return this;
}

uint64_t NetConnection::setClient(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  CFStreamClientContext v4;

  v1 = this;
  *(_WORD *)(this + 88) |= 0x80u;
  v4.version = 0;
  v4.info = (void *)this;
  v4.retain = (void *(__cdecl *)(void *))NetConnection::_retainFilter;
  v4.release = (void (__cdecl *)(void *))NetConnection::_releaseFilter;
  v4.copyDescription = (CFStringRef (__cdecl *)(void *))NetConnection::_copyDescription;
  v2 = *(_QWORD *)(this + 144);
  if (v2)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    this = CoreWriteStream::setClient(v2 + 16, -1, (uint64_t)NetConnection::_connectionRequestCallBack, &v4);
  }
  v3 = *(_QWORD *)(v1 + 152);
  if (v3)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    return CoreReadStream::setClient(v3 + 16, -1, (uint64_t)NetConnection::_connectionResponseCallBack, &v4);
  }
  return this;
}

void NetConnection::scheduleNewResponse(_QWORD *a1, uint64_t **a2, uint64_t a3)
{
  char *v6;
  uint64_t **v7;
  uint64_t v8;
  CoreStreamBase *v9;
  char v10;
  const CoreSchedulingSet *v11;
  CoreStreamBase *v12;

  v6 = (char *)a1[19];
  if (!v6)
    goto LABEL_21;
  if (!a2)
  {
    v8 = 0;
LABEL_10:
    CFRetain(v6);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    v10 = 0;
    v9 = (CoreStreamBase *)(v6 + 16);
    goto LABEL_13;
  }
  v7 = a2;
  while (((_BYTE)v7[2] & 2) != 0)
  {
    v7 = (uint64_t **)*v7;
    if (!v7)
    {
      v7 = a2;
      break;
    }
  }
  v8 = (*(uint64_t (**)(_QWORD *, uint64_t *))(*a1 + 160))(a1, v7[1]);
  v6 = (char *)a1[19];
  if (v6)
    goto LABEL_10;
  v9 = 0;
  v10 = 1;
LABEL_13:
  v11 = (const CoreSchedulingSet *)v8;
  if (!v8)
  {
    if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
    {
      v12 = v9;
      dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16941);
      v9 = v12;
    }
    v11 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
  }
  CoreStreamBase::_streamInterface_UpdateScheduling(v9, v11);
  if ((v10 & 1) == 0)
    CFRelease(v6);
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 48))(v8);
LABEL_21:
  if (a3)
    (*(void (**)(_QWORD *, _QWORD, uint64_t, _QWORD))(*a1 + 120))(a1, *(_QWORD *)(a3 + 8), 5, 0);
  if (a2)
    (*(void (**)(_QWORD *, uint64_t *, uint64_t, _QWORD))(*a1 + 120))(a1, a2[1], 4, 0);
}

NetConnection *NetConnection::_retainFilter(NetConnection *this, void *a2)
{
  (*(void (**)(NetConnection *, void *))(*(_QWORD *)this + 40))(this, a2);
  return this;
}

uint64_t NetConnection::_releaseFilter(NetConnection *this, void *a2)
{
  return (*(uint64_t (**)(NetConnection *))(*(_QWORD *)this + 48))(this);
}

uint64_t NetConnection::_copyDescription(NetConnection *this, void *a2)
{
  return (*(uint64_t (**)(NetConnection *))(*(_QWORD *)this + 16))(this);
}

uint64_t NetConnection::_connectionRequestCallBack(uint64_t result, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;

  v5 = result;
  v6 = a3[12];
  if (v6)
    result = pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  v7 = a3[16];
  if (v7)
  {
    result = (*(uint64_t (**)(_QWORD *, _QWORD, uint64_t, uint64_t))(*a3 + 152))(a3, *(_QWORD *)(v7 + 8), v5, a2);
  }
  else if (!a3[17])
  {
    if (a2 == 8)
    {
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      v9 = v5 + 16;
      if (!v5)
        v9 = 0;
      v10 = *(_OWORD *)(v9 + 56);
      result = (*(uint64_t (**)(_QWORD *, __int128 *))(*a3 + 64))(a3, &v10);
    }
    else if (a2 == 16)
    {
      result = (*(uint64_t (**)(_QWORD *))(*a3 + 72))(a3);
    }
  }
  v8 = a3[12];
  if (v8)
    return pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8));
  return result;
}

uint64_t NetConnection::_connectionResponseCallBack(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v11;

  (*(void (**)(uint64_t))(*(_QWORD *)a3 + 40))(a3);
  v6 = *(_QWORD *)(a3 + 96);
  if (v6)
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  v7 = *(_QWORD *)(a3 + 136);
  if (!v7 || (*(_WORD *)(a3 + 88) & 0x200) != 0)
  {
    if (a2 == 8)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      v8 = a1 + 16;
      if (!a1)
        v8 = 0;
      v11 = *(_OWORD *)(v8 + 56);
      (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)a3 + 64))(a3, &v11);
    }
    else if (a2 == 16)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)a3 + 72))(a3);
    }
  }
  else
  {
    (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a3 + 144))(a3, *(_QWORD *)(v7 + 8), a1, a2);
  }
  v9 = *(_QWORD *)(a3 + 96);
  if (v9)
    pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 48))(a3);
}

uint64_t NetConnection::pendingRequestCount(NetConnection *this)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *((_QWORD *)this + 12);
  if (v2)
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  v3 = (_QWORD *)((char *)this + 128);
  LODWORD(v4) = -1;
  do
  {
    v3 = (_QWORD *)*v3;
    v4 = (v4 + 1);
  }
  while (v3);
  v5 = *((_QWORD *)this + 12);
  if (v5)
    pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
  return v4;
}

void NetConnection::~NetConnection(NetConnection *this)
{
  _QWORD *v2;
  const __CFAllocator *v3;
  _QWORD *v4;
  const void *v5;
  uint64_t v6;
  const void *v7;
  const void *v8;

  *(_QWORD *)this = off_1E14E6668;
  *((_QWORD *)this + 3) = &unk_1E14E6748;
  v2 = (_QWORD *)*((_QWORD *)this + 14);
  if (v2)
  {
    v3 = (const __CFAllocator *)*((_QWORD *)this + 1);
    while (v2)
    {
      v4 = (_QWORD *)*v2;
      CFAllocatorDeallocate(v3, v2);
      v2 = v4;
    }
  }
  v5 = (const void *)*((_QWORD *)this + 30);
  if (v5)
    CFRelease(v5);
  v6 = *((_QWORD *)this + 12);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  NetConnection::shutdownConnectionStreams((uint64_t)this, 0);
  v7 = (const void *)*((_QWORD *)this + 18);
  *((_QWORD *)this + 18) = 0;
  if (v7)
    CFRelease(v7);
  v8 = (const void *)*((_QWORD *)this + 19);
  *((_QWORD *)this + 19) = 0;
  if (v8)
    CFRelease(v8);
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

void sub_18403DB0C(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t NetConnection::initialize(NetConnection *this, int a2)
{
  _CoreLockable *v4;

  v4 = (_CoreLockable *)operator new();
  _CoreLockable::_CoreLockable(v4, 1);
  *(_QWORD *)v4 = &off_1E14E5818;
  *((_QWORD *)this + 12) = v4;
  if (a2)
    *((_WORD *)this + 44) |= 0x400u;
  *((CFAbsoluteTime *)this + 20) = CFAbsoluteTimeGetCurrent();
  *((_DWORD *)this + 26) = 0;
  *((_QWORD *)this + 28) = 0;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_QWORD *)this + 30) = CFSTR("NEW CONNECTION");
  *((_DWORD *)this + 58) = 0;
  (*(void (**)(NetConnection *, char *, char *))(*(_QWORD *)this + 112))(this, (char *)this + 144, (char *)this + 152);
  if (!*((_QWORD *)this + 18) && !*((_QWORD *)this + 19))
    return 0;
  NetConnection::setClient((uint64_t)this);
  *((_WORD *)this + 44) |= 1u;
  return 1;
}

void sub_18403DC08(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x1081C4076DFA842);
  _Unwind_Resume(a1);
}

uint64_t NetConnection::enqueue(NetConnection *this, uint64_t *a2, int a3)
{
  uint64_t v6;
  int v7;
  __int16 v8;
  uint64_t v9;
  uint64_t **v10;
  uint64_t **v11;
  uint64_t ***v12;
  uint64_t *v13;
  char *v14;
  uint64_t ***v15;
  uint64_t v16;
  _BOOL4 v17;
  uint64_t v18;
  uint64_t v19;
  __int16 v20;
  uint64_t **v21;
  uint64_t **v22;
  const CoreSchedulingSet *v23;
  uint64_t v24;
  uint64_t **v25;
  uint64_t v26;
  char *v27;
  CoreStreamBase *v28;
  const CoreSchedulingSet *v29;
  uint64_t v30;

  (*(void (**)(NetConnection *))(*(_QWORD *)this + 40))(this);
  v6 = *((_QWORD *)this + 12);
  if (v6)
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  v7 = *((_DWORD *)this + 27);
  *((_DWORD *)this + 27) = v7 + 1;
  v8 = *((_WORD *)this + 44);
  if ((v8 & 1) == 0)
  {
    v9 = 0;
    *((_DWORD *)this + 27) = v7;
    if (!*((_DWORD *)this + 26) && !v7 && (v8 & 0x800) != 0)
    {
      NetConnection::shutdownConnectionStreams((uint64_t)this, 0);
      v9 = 0;
    }
    goto LABEL_74;
  }
  v10 = (uint64_t **)CFAllocatorAllocate(*((CFAllocatorRef *)this + 1), 24, 0);
  v11 = v10;
  *v10 = 0;
  v10[1] = a2;
  *((_BYTE *)v10 + 16) = 0;
  if (a3)
  {
    v12 = (uint64_t ***)*((_QWORD *)this + 16);
    if (v12)
    {
      v13 = (uint64_t *)*v12;
      *v12 = v10;
      *v10 = v13;
      v14 = (char *)this + 120;
      if (*((uint64_t ****)this + 15) != v12)
        goto LABEL_16;
      goto LABEL_15;
    }
  }
  v15 = (uint64_t ***)((char *)this + 112);
  if (*((_QWORD *)this + 14))
    v15 = (uint64_t ***)*((_QWORD *)this + 15);
  *v15 = v10;
  v14 = (char *)this + 128;
  v16 = *((_QWORD *)this + 16);
  *((_QWORD *)this + 15) = v10;
  *v10 = 0;
  if (!v16)
LABEL_15:
    *(_QWORD *)v14 = v10;
LABEL_16:
  if (!*((_QWORD *)this + 17))
    *((_QWORD *)this + 17) = v10;
  ++*((_DWORD *)this + 26);
  ++_NetConnection_GlobalPendingResponses;
  if ((*((_BYTE *)this + 88) & 2) != 0)
    NetConnection::doublecheckPipelining(this);
  if (_pipelineShouldPackPackets(void)::haveChecked == 1)
  {
    if (!_pipelineShouldPackPackets(void)::shouldPackPackets)
      goto LABEL_31;
LABEL_24:
    if ((*((_WORD *)this + 44) & 2) != 0)
    {
      v18 = *((_QWORD *)this + 18);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      if (v18)
        v19 = v18 + 16;
      else
        v19 = 0;
      ++*(_QWORD *)(v19 + 80);
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v19 + 24) + 32))(*(_QWORD *)(v19 + 24), 0x1EDCFA138);
      --*(_QWORD *)(v19 + 80);
    }
    goto LABEL_31;
  }
  v17 = getenv("CFNETWORK_PIPELINE_PACK") != 0;
  _pipelineShouldPackPackets(void)::shouldPackPackets = v17;
  _pipelineShouldPackPackets(void)::haveChecked = 1;
  if (v17)
    goto LABEL_24;
LABEL_31:
  (*(void (**)(NetConnection *, uint64_t *, uint64_t, _QWORD))(*(_QWORD *)this + 120))(this, a2, 1, 0);
  v20 = *((_WORD *)this + 44);
  if ((v20 & 0x400) == 0)
  {
    v20 &= ~1u;
    *((_WORD *)this + 44) = v20;
  }
  v21 = (uint64_t **)*((_QWORD *)this + 16);
  if (v21 == *((uint64_t ***)this + 17) || (v20 & 2) != 0)
  {
    if (v21 == v11)
    {
      NetConnection::scheduleNewRequest(this, v11, 0, 0);
    }
    else if (*((_QWORD *)this + 18))
    {
      if (v21)
      {
        v22 = (uint64_t **)*((_QWORD *)this + 16);
        while (((_BYTE)v22[2] & 2) != 0)
        {
          v22 = (uint64_t **)*v22;
          if (!v22)
          {
            v22 = (uint64_t **)*((_QWORD *)this + 16);
            break;
          }
        }
      }
      else
      {
        v22 = 0;
      }
      if (v22 == v11)
      {
        v23 = (const CoreSchedulingSet *)(*(uint64_t (**)(NetConnection *, uint64_t *))(*(_QWORD *)this + 160))(this, v11[1]);
        NetConnection::rescheduleStream(*((char **)this + 18), v23);
        if (v23)
          (*(void (**)(const CoreSchedulingSet *))(*(_QWORD *)v23 + 48))(v23);
        if ((*((_WORD *)this + 44) & 0x20) != 0)
          (*(void (**)(NetConnection *, _QWORD))(*(_QWORD *)this + 128))(this, *(_QWORD *)(*((_QWORD *)this + 16) + 8));
      }
    }
  }
  if (*((_QWORD *)this + 19))
  {
    v24 = *((_QWORD *)this + 17);
    if (*((_QWORD *)this + 16) != v24)
    {
      if (v24)
      {
        v25 = (uint64_t **)*((_QWORD *)this + 17);
        while (((_BYTE)v25[2] & 2) != 0)
        {
          v25 = (uint64_t **)*v25;
          if (!v25)
          {
            v25 = (uint64_t **)*((_QWORD *)this + 17);
            break;
          }
        }
      }
      else
      {
        v25 = 0;
      }
      if (v25 == v11)
      {
        v26 = (*(uint64_t (**)(NetConnection *, uint64_t *))(*(_QWORD *)this + 160))(this, v11[1]);
        v27 = (char *)*((_QWORD *)this + 19);
        if (v27)
        {
          CFRetain(*((CFTypeRef *)this + 19));
          if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
            dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
          v28 = (CoreStreamBase *)(v27 + 16);
        }
        else
        {
          v28 = 0;
        }
        v29 = (const CoreSchedulingSet *)v26;
        if (!v26)
        {
          if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
            dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16941);
          v29 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
        }
        CoreStreamBase::_streamInterface_UpdateScheduling(v28, v29);
        if (v27)
          CFRelease(v27);
        if (v26)
          (*(void (**)(uint64_t))(*(_QWORD *)v26 + 48))(v26);
        if ((*((_WORD *)this + 44) & 0x200) == 0)
          (*(void (**)(NetConnection *, _QWORD))(*(_QWORD *)this + 136))(this, *(_QWORD *)(*((_QWORD *)this + 17) + 8));
      }
    }
  }
  --*((_DWORD *)this + 27);
  v9 = 1;
LABEL_74:
  v30 = *((_QWORD *)this + 12);
  if (v30)
    pthread_mutex_unlock((pthread_mutex_t *)(v30 + 8));
  (*(void (**)(NetConnection *))(*(_QWORD *)this + 48))(this);
  return v9;
}

void NetConnection::doublecheckPipelining(NetConnection *this)
{
  __int16 v1;
  uint64_t v3;
  const __CFData *v4;
  const __CFData *v5;
  CFNA *v6;
  const char *v7;
  const __CFString *v8;
  const __CFString *v9;
  CFComparisonResult v10;
  __int16 v11;
  const __CFData *v12;
  UInt8 buffer[4];
  CFRange v14;

  v1 = *((_WORD *)this + 44);
  if ((v1 & 4) == 0)
  {
    if ((v1 & 0x10) != 0)
    {
      if ((v1 & 8) == 0)
        return;
      v11 = v1 & 0xFFFD;
      goto LABEL_17;
    }
    *((_WORD *)this + 44) = v1 | 0x10;
    *(_DWORD *)buffer = -1;
    v3 = *((_QWORD *)this + 18);
    if (v3)
    {
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      ++*(_QWORD *)(v3 + 96);
      v4 = (const __CFData *)(*(uint64_t (**)(_QWORD, void *))(**(_QWORD **)(v3 + 40) + 40))(*(_QWORD *)(v3 + 40), &unk_1EDCFBDA8);
      --*(_QWORD *)(v3 + 96);
      if (v4)
      {
        v5 = v4;
        if (CFDataGetLength(v4) != 4)
        {
          v12 = v5;
LABEL_15:
          CFRelease(v12);
          goto LABEL_16;
        }
        v14.location = 0;
        v14.length = 4;
        CFDataGetBytes(v5, v14, buffer);
        v6 = (CFNA *)SCNetworkSignatureCopyIdentifierForConnectedSocket();
        CFRelease(v5);
        if (v6)
        {
          v8 = CFNA::_CFNetworkAgentCopyOperationSupportStateFromDynamicStore(v6, (const __CFString *)"HTTPPipelining", v7);
          if (v8)
          {
            v9 = v8;
            v10 = CFStringCompare(v8, CFSTR("TRUE"), 0);
            CFRelease(v9);
            CFRelease(v6);
            if (v10 == kCFCompareEqualTo)
              return;
            goto LABEL_16;
          }
          if (CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once != -1)
            dispatch_once(&CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once, &__block_literal_global_9684);
          CFNA::CFNetworkAgentClient::executeLegacyQuery((CFNA::CFNetworkAgentClient *)CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::client, (const __CFString *)v6, 1);
          v12 = v6;
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *((_WORD *)this + 44) & 0xFFF5 | 8;
LABEL_17:
    *((_WORD *)this + 44) = v11;
  }
}

void **NetConnection::dequeue(NetConnection *this, void *a2)
{
  uint64_t v4;
  void **v5;
  _QWORD **v6;
  int v7;
  int v8;
  void **v9;
  void **v10;
  void **v11;
  __int16 v12;
  _QWORD **v13;
  void **v14;
  _QWORD **v15;
  void **v16;
  char v17;
  _QWORD *v18;
  _QWORD *v19;
  int v20;
  int v21;
  _QWORD **v22;
  _QWORD **v23;
  _QWORD *v24;
  int v25;
  _QWORD *v26;
  void **v27;
  CFAbsoluteTime Current;
  uint64_t v29;
  uint64_t v30;
  const void *v31;
  const void *v32;
  CFTypeID v33;
  uint64_t v34;
  uint64_t v36;
  int v37;

  (*(void (**)(NetConnection *))(*(_QWORD *)this + 40))(this);
  v4 = *((_QWORD *)this + 12);
  if (v4)
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  v6 = (_QWORD **)((char *)this + 112);
  v5 = (void **)*((_QWORD *)this + 14);
  if (!v5)
    goto LABEL_28;
  if (v5[1] == a2)
  {
    if (v5 == *((void ***)this + 16))
    {
      v7 = 0;
      v10 = 0;
      v9 = (void **)*((_QWORD *)this + 14);
LABEL_19:
      v12 = *((_WORD *)this + 44);
      if (v12 & 0x100 | v7)
      {
        v5 = v9;
        if (v10)
          goto LABEL_24;
        goto LABEL_30;
      }
      if ((v12 & 0x20) != 0 || v9 != v5)
        goto LABEL_27;
      *((_QWORD *)this + 16) = *v5;
    }
    else
    {
      v10 = 0;
      v11 = (void **)*((_QWORD *)this + 17);
LABEL_16:
      v9 = v11;
      if (v5 == v11)
      {
LABEL_27:
        if (*(void **)(*((_QWORD *)this + 15) + 8) != a2)
        {
LABEL_28:
          v9 = 0;
          goto LABEL_78;
        }
        *((_WORD *)this + 44) &= ~1u;
        if (*((_QWORD *)this + 16))
        {
          v14 = (void **)*((_QWORD *)this + 16);
          while (((_BYTE)v14[2] & 2) != 0)
          {
            v14 = (void **)*v14;
            if (!v14)
            {
              v14 = (void **)*((_QWORD *)this + 16);
              break;
            }
          }
          if (v14 == v9)
          {
            NetConnection::rescheduleStream(*((char **)this + 18), 0);
            *((_WORD *)this + 44) &= ~0x20u;
            *((_QWORD *)this + 16) = 0;
          }
        }
        v15 = (_QWORD **)*((_QWORD *)this + 17);
        if (v15)
        {
          v16 = (void **)*((_QWORD *)this + 17);
          while (((_BYTE)v16[2] & 2) != 0)
          {
            v16 = (void **)*v16;
            if (!v16)
            {
              v16 = (void **)*((_QWORD *)this + 17);
              break;
            }
          }
          if (v16 == v9)
          {
            NetConnection::rescheduleStream(*((char **)this + 19));
            v15 = 0;
            *((_QWORD *)this + 17) = 0;
          }
        }
        if (v10)
        {
          v17 = *((_BYTE *)v10 + 16);
          *v10 = *v9;
          *v9 = 0;
          if (*((void ***)this + 15) == v9)
            *((_QWORD *)this + 15) = v10;
          if ((v17 & 2) != 0)
          {
            v18 = *v6;
            v19 = (_QWORD *)**v6;
            if (!v19)
              goto LABEL_65;
            v20 = 0;
            v21 = 0;
            v22 = 0;
            v23 = (_QWORD **)*v6;
            do
            {
              v24 = v19;
              if (((_BYTE)v23[2] & 2) != 0)
              {
                if (v23 == *((_QWORD ***)this + 16))
                  v21 = 1;
                if (v23 == v15)
                  v20 = 1;
              }
              else
              {
                v21 = 0;
                v20 = 0;
                v22 = v23;
              }
              v19 = (_QWORD *)*v19;
              v23 = (_QWORD **)v24;
            }
            while (*v24);
            if (v22)
            {
              v18 = *v22;
              if (v21)
                *((_QWORD *)this + 16) = 0;
              if (v20)
                *((_QWORD *)this + 17) = 0;
            }
            else
            {
LABEL_65:
              *(_OWORD *)v6 = 0u;
              *((_OWORD *)this + 8) = 0u;
            }
            v25 = 0;
            if (v18)
            {
              do
              {
                v36 = 4;
                v37 = -4;
                (*(void (**)(NetConnection *, _QWORD, uint64_t, uint64_t *))(*(_QWORD *)this + 120))(this, v18[1], 7, &v36);
                v26 = (_QWORD *)*v18;
                CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), v18);
                ++v25;
                v18 = v26;
              }
              while (v26);
            }
            *((_DWORD *)this + 26) -= v25;
            _NetConnection_GlobalPendingResponses -= v25;
          }
          goto LABEL_69;
        }
LABEL_31:
        v13 = (_QWORD **)*v9;
        *((_QWORD *)this + 14) = *v9;
        *v9 = 0;
        if (*((void ***)this + 15) != v9)
        {
LABEL_70:
          if (v13)
          {
            v27 = (void **)*((_QWORD *)this + 16);
          }
          else
          {
            Current = CFAbsoluteTimeGetCurrent();
            v27 = 0;
            *((CFAbsoluteTime *)this + 20) = Current;
            *((_QWORD *)this + 16) = 0;
            *((_QWORD *)this + 17) = 0;
          }
          if (v27 == v9)
            *((_QWORD *)this + 16) = 0;
          if (*((void ***)this + 17) == v9)
            *((_QWORD *)this + 17) = 0;
          CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), v9);
          --*((_DWORD *)this + 26);
          --_NetConnection_GlobalPendingResponses;
          v9 = (void **)1;
          goto LABEL_78;
        }
        *((_QWORD *)this + 15) = 0;
LABEL_69:
        v13 = (_QWORD **)*v6;
        goto LABEL_70;
      }
    }
    if (v10)
    {
LABEL_24:
      *v10 = *v5;
      *v5 = 0;
      if (*((void ***)this + 15) == v5)
        *((_QWORD *)this + 15) = v10;
      v9 = v5;
      goto LABEL_69;
    }
LABEL_30:
    v9 = v5;
    goto LABEL_31;
  }
  v7 = 0;
  v8 = 0;
  v9 = (void **)*((_QWORD *)this + 14);
  while (1)
  {
    v10 = v9;
    v9 = (void **)*v9;
    if (!v9)
      break;
    v5 = (void **)*((_QWORD *)this + 16);
    v11 = (void **)*((_QWORD *)this + 17);
    if (v10 == v5)
      v7 = 1;
    if (v10 == v11)
      v8 = 1;
    if (v9[1] == a2)
    {
      if (v8)
        goto LABEL_19;
      v5 = v9;
      goto LABEL_16;
    }
  }
LABEL_78:
  v29 = *((_QWORD *)this + 19);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  if (v29)
    v30 = v29 + 16;
  else
    v30 = 0;
  ++*(_QWORD *)(v30 + 80);
  v31 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v30 + 24) + 40))(*(_QWORD *)(v30 + 24), 0x1EDCF96B8);
  --*(_QWORD *)(v30 + 80);
  if (v31)
  {
    v32 = v31;
    v33 = CFGetTypeID(v31);
    if (v33 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v36) = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&v36, 2u);
    }
    if ((const void *)*MEMORY[0x1E0C9AE50] == v32)
      *((_WORD *)this + 44) &= ~1u;
    CFRelease(v32);
  }
  if (!*((_DWORD *)this + 26) && (*((_WORD *)this + 44) & 0x801) != 1)
    NetConnection::shutdownConnectionStreams((uint64_t)this, a2);
  v34 = *((_QWORD *)this + 12);
  if (v34)
    pthread_mutex_unlock((pthread_mutex_t *)(v34 + 8));
  (*(void (**)(NetConnection *))(*(_QWORD *)this + 48))(this);
  return v9;
}

void NetConnection::rescheduleStream(char *cf)
{
  CoreStreamBase *v2;

  if (cf)
  {
    CFRetain(cf);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    v2 = (CoreStreamBase *)(cf + 16);
  }
  else
  {
    v2 = 0;
  }
  if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
    dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16941);
  CoreStreamBase::_streamInterface_UpdateScheduling(v2, (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet);
  if (cf)
    CFRelease(cf);
}

uint64_t NetConnection::responseIsComplete(NetConnection *this, void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(NetConnection *, _QWORD);
  uint64_t **v9;
  uint64_t **v10;
  __int16 v11;
  uint64_t **v13;
  char *v14;
  uint64_t **v15;
  const CoreSchedulingSet *v16;
  uint64_t **v17;
  char *v18;
  CoreStreamBase *v19;
  const CoreSchedulingSet *v20;
  __int16 v21;
  __int16 v22;
  CoreStreamBase *v23;

  (*(void (**)(NetConnection *))(*(_QWORD *)this + 40))(this);
  v4 = *((_QWORD *)this + 12);
  if (v4)
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  ++*((_QWORD *)this + 28);
  v5 = *((_QWORD *)this + 17);
  if (!v5 || *(void **)(v5 + 8) != a2)
    goto LABEL_5;
  v9 = (uint64_t **)*((_QWORD *)this + 16);
  if ((uint64_t **)v5 == v9)
  {
    *((_WORD *)this + 44) |= 0x200u;
    goto LABEL_5;
  }
  v10 = *(uint64_t ***)v5;
  *((_QWORD *)this + 17) = *(_QWORD *)v5;
  v11 = *((_WORD *)this + 44);
  if (!v10)
  {
    v13 = 0;
    if ((v11 & 2) == 0)
      goto LABEL_23;
LABEL_31:
    if ((v11 & 4) == 0)
      v10 = 0;
    if (v13)
      v17 = v13;
    else
      v17 = v10;
    NetConnection::scheduleNewResponse(this, v17, v5);
    goto LABEL_5;
  }
  if ((*((_WORD *)this + 44) & 0x100) != 0)
  {
    v10 = 0;
    v13 = 0;
    *((_QWORD *)this + 17) = 0;
    if ((v11 & 2) == 0)
      goto LABEL_23;
    goto LABEL_31;
  }
  if ((v11 & 2) != 0 && v10 == v9)
    v13 = 0;
  else
    v13 = v10;
  if ((v11 & 2) != 0)
    goto LABEL_31;
LABEL_23:
  v14 = (char *)*((_QWORD *)this + 18);
  if (v14)
  {
    if (v13)
    {
      v15 = v13;
      while (((_BYTE)v15[2] & 2) != 0)
      {
        v15 = (uint64_t **)*v15;
        if (!v15)
        {
          v15 = v13;
          break;
        }
      }
      v16 = (const CoreSchedulingSet *)(*(uint64_t (**)(NetConnection *, uint64_t *))(*(_QWORD *)this + 160))(this, v15[1]);
      v14 = (char *)*((_QWORD *)this + 18);
    }
    else
    {
      v16 = 0;
    }
    NetConnection::rescheduleStream(v14, v16);
    v18 = (char *)*((_QWORD *)this + 19);
    if (v18)
    {
      CFRetain(*((CFTypeRef *)this + 19));
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      v19 = (CoreStreamBase *)(v18 + 16);
    }
    else
    {
      v19 = 0;
    }
    v20 = v16;
    if (!v16)
    {
      if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
      {
        v23 = v19;
        dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16941);
        v19 = v23;
      }
      v20 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
    }
    CoreStreamBase::_streamInterface_UpdateScheduling(v19, v20);
    if (v18)
      CFRelease(v18);
    if (v16)
      (*(void (**)(const CoreSchedulingSet *))(*(_QWORD *)v16 + 48))(v16);
  }
  v21 = *((_WORD *)this + 44);
  if ((v11 & 0x40) != 0)
  {
    if ((v21 & 0x80) == 0)
      NetConnection::setClient((uint64_t)this);
  }
  else
  {
    *((_WORD *)this + 44) = v21 | 0x40;
    NetConnection::openConnectionStreams((uint64_t)this);
  }
  (*(void (**)(NetConnection *, _QWORD, uint64_t, _QWORD))(*(_QWORD *)this + 120))(this, *(_QWORD *)(v5 + 8), 5, 0);
  v22 = *((_WORD *)this + 44);
  *((_WORD *)this + 44) = v22 & 0xFFDF;
  if (v13)
  {
    *((_WORD *)this + 44) = v22 | 0x20;
    (*(void (**)(NetConnection *, uint64_t *, uint64_t, _QWORD))(*(_QWORD *)this + 120))(this, v13[1], 2, 0);
  }
LABEL_5:
  v6 = *((_QWORD *)this + 12);
  if (v6)
    pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  v7 = (void (*)(NetConnection *, _QWORD))*((_QWORD *)this + 22);
  if (v7)
    v7(this, *((_QWORD *)this + 27));
  return (*(uint64_t (**)(NetConnection *))(*(_QWORD *)this + 48))(this);
}

uint64_t NetConnection::requestIsComplete(NetConnection *this, void *a2)
{
  void (*v4)(NetConnection *, _QWORD);
  uint64_t v5;
  uint64_t v6;
  __int16 v7;
  _BOOL4 v9;
  uint64_t **v10;
  NetConnection *v11;
  uint64_t v12;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  (*(void (**)(NetConnection *))(*(_QWORD *)this + 40))(this);
  v4 = (void (*)(NetConnection *, _QWORD))*((_QWORD *)this + 21);
  if (v4)
    v4(this, *((_QWORD *)this + 27));
  v5 = *((_QWORD *)this + 12);
  if (v5)
    pthread_mutex_lock((pthread_mutex_t *)(v5 + 8));
  v6 = *((_QWORD *)this + 16);
  if (!v6 || *(void **)(v6 + 8) != a2)
  {
    CFLog();
    goto LABEL_18;
  }
  v7 = *((_WORD *)this + 44);
  v9 = (v7 & 0x200) == 0 && *(_QWORD *)(*((_QWORD *)this + 17) + 8) == (_QWORD)a2;
  if ((*((_WORD *)this + 44) & 0x100) != 0)
  {
    *((_QWORD *)this + 16) = 0;
    v11 = this;
    v10 = 0;
  }
  else
  {
    v10 = *(uint64_t ***)v6;
    *((_QWORD *)this + 16) = *(_QWORD *)v6;
    if ((v7 & 2) == 0 || !v10)
    {
      NetConnection::scheduleNewRequest(this, 0, v6, v9);
      if (_pipelineShouldPackPackets(void)::haveChecked == 1)
      {
        v14 = _pipelineShouldPackPackets(void)::shouldPackPackets;
      }
      else
      {
        v14 = getenv("CFNETWORK_PIPELINE_PACK") != 0;
        _pipelineShouldPackPackets(void)::shouldPackPackets = v14;
        _pipelineShouldPackPackets(void)::haveChecked = 1;
      }
      if (v14 && (*((_WORD *)this + 44) & 2) != 0)
      {
        v15 = *((_QWORD *)this + 18);
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        {
          v17 = *((_QWORD *)this + 18);
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
          v15 = v17;
        }
        if (v15)
          v16 = v15 + 16;
        else
          v16 = 0;
        ++*(_QWORD *)(v16 + 80);
        (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v16 + 24) + 32))(*(_QWORD *)(v16 + 24), 0x1EDCFA138);
        --*(_QWORD *)(v16 + 80);
      }
      goto LABEL_23;
    }
    v11 = this;
  }
  NetConnection::scheduleNewRequest(v11, v10, v6, v9);
LABEL_23:
  if ((v7 & 0x200) != 0)
  {
    NetConnection::responseIsComplete(this, *(void **)(v6 + 8));
    *((_WORD *)this + 44) &= ~0x200u;
  }
LABEL_18:
  v12 = *((_QWORD *)this + 12);
  if (v12)
    pthread_mutex_unlock((pthread_mutex_t *)(v12 + 8));
  return (*(uint64_t (**)(NetConnection *))(*(_QWORD *)this + 48))(this);
}

void NetConnection::setShouldPipeline(NetConnection *this, int a2)
{
  uint64_t v4;
  __int16 v5;
  __int16 v6;
  uint64_t **v7;
  uint64_t v8;

  v4 = *((_QWORD *)this + 12);
  if (v4)
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  v5 = *((_WORD *)this + 44);
  if (a2)
  {
    if ((v5 & 2) == 0)
    {
      NetConnection::doublecheckPipelining(this);
      v6 = *((_WORD *)this + 44);
      if ((v6 & 8) == 0)
      {
        *((_WORD *)this + 44) = v6 | 2;
        if ((v6 & 0x20) == 0)
        {
          v7 = (uint64_t **)*((_QWORD *)this + 16);
          if (v7)
            NetConnection::scheduleNewRequest(this, v7, *((_QWORD *)this + 17), 0);
        }
      }
    }
  }
  else if ((v5 & 2) != 0)
  {
    *((_WORD *)this + 44) = v5 & 0xFFFD;
  }
  v8 = *((_QWORD *)this + 12);
  if (v8)
    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8));
}

double NetConnection::getLastAccessTime(NetConnection *this)
{
  uint64_t v2;
  double Current;
  uint64_t v4;

  v2 = *((_QWORD *)this + 12);
  if (v2)
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  if (*((_QWORD *)this + 14))
    Current = CFAbsoluteTimeGetCurrent();
  else
    Current = *((double *)this + 20);
  v4 = *((_QWORD *)this + 12);
  if (v4)
    pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
  return Current;
}

uint64_t NetConnection::getState(NetConnection *this, int a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t **v13;
  uint64_t **v14;
  uint64_t **v15;

  (*(void (**)(NetConnection *))(*(_QWORD *)this + 40))(this);
  v6 = *((_QWORD *)this + 12);
  if (v6)
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  if (a2)
  {
    v7 = *((_QWORD *)this + 16);
    if (v7 && (*((_WORD *)this + 44) & 0x20) != 0)
      (*(void (**)(NetConnection *, _QWORD))(*(_QWORD *)this + 128))(this, *(_QWORD *)(v7 + 8));
    v8 = *((_QWORD *)this + 17);
    if (v8 && (v8 != *((_QWORD *)this + 16) || (*((_WORD *)this + 44) & 0x20) == 0))
      (*(void (**)(NetConnection *, _QWORD))(*(_QWORD *)this + 136))(this, *(_QWORD *)(v8 + 8));
  }
  if (!*((_QWORD *)this + 18) && !*((_QWORD *)this + 19))
    goto LABEL_14;
  v9 = *((_WORD *)this + 44);
  if ((v9 & 0x2000) == 0)
    goto LABEL_14;
  v13 = (uint64_t **)*((_QWORD *)this + 16);
  if (v13 && v13[1] == a3)
  {
    if ((v9 & 0x20) != 0)
      v10 = 2;
    else
      v10 = 1;
  }
  else
  {
    v14 = (uint64_t **)*((_QWORD *)this + 17);
    if (v14 && v14[1] == a3)
    {
      v10 = 4;
    }
    else if (v13)
    {
      while (v13[1] != a3)
      {
        v13 = (uint64_t **)*v13;
        if (!v13)
          goto LABEL_25;
      }
      if ((*((_WORD *)this + 44) & 0x100) != 0)
        v10 = 7;
      else
        v10 = 1;
    }
    else
    {
LABEL_25:
      if (v14)
      {
        while (v14[1] != a3)
        {
          v14 = (uint64_t **)*v14;
          if (!v14)
            goto LABEL_28;
        }
        if ((*((_WORD *)this + 44) & 0x100) != 0)
          v10 = 7;
        else
          v10 = 3;
      }
      else
      {
LABEL_28:
        v15 = (uint64_t **)*((_QWORD *)this + 14);
        if (!v15)
        {
LABEL_14:
          v10 = 7;
          goto LABEL_15;
        }
        while (v15[1] != a3)
        {
          v15 = (uint64_t **)*v15;
          if (!v15)
            goto LABEL_14;
        }
        v10 = 5;
      }
    }
  }
LABEL_15:
  v11 = *((_QWORD *)this + 12);
  if (v11)
    pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8));
  (*(void (**)(NetConnection *))(*(_QWORD *)this + 48))(this);
  return v10;
}

uint64_t NetConnection::schedule(uint64_t this, uint64_t *a2, CoreSchedulingSet *a3, const __CFString *cf1)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t **v9;
  uint64_t **v10;
  uint64_t v11;

  v7 = (_QWORD *)this;
  v8 = *(_QWORD *)(this + 96);
  if (v8)
    this = pthread_mutex_lock((pthread_mutex_t *)(v8 + 8));
  if (v7[16])
  {
    this = v7[18];
    if (this)
    {
      v9 = (uint64_t **)v7[16];
      while (((_BYTE)v9[2] & 2) != 0)
      {
        v9 = (uint64_t **)*v9;
        if (!v9)
        {
          v9 = (uint64_t **)v7[16];
          break;
        }
      }
      if (v9[1] == a2)
        this = CoreWriteStreamScheduleWithRunLoop((CoreStreamBase *)this, a3, cf1);
    }
  }
  if (v7[17])
  {
    this = v7[19];
    if (this)
    {
      v10 = (uint64_t **)v7[17];
      while (((_BYTE)v10[2] & 2) != 0)
      {
        v10 = (uint64_t **)*v10;
        if (!v10)
        {
          v10 = (uint64_t **)v7[17];
          break;
        }
      }
      if (v10[1] == a2)
        this = CoreReadStreamScheduleWithRunLoop((CoreStreamBase *)this, a3, cf1);
    }
  }
  v11 = v7[12];
  if (v11)
    return pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8));
  return this;
}

void NetConnection::unschedule(NetConnection *this, uint64_t *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t v6;
  CoreStreamBase *v7;
  uint64_t **v8;
  uint64_t **v9;
  CoreStreamBase *v10;
  uint64_t **v11;
  uint64_t v12;

  v6 = *((_QWORD *)this + 12);
  if (v6)
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  v7 = (CoreStreamBase *)*((_QWORD *)this + 18);
  if (v7)
  {
    v8 = (uint64_t **)*((_QWORD *)this + 16);
    if (v8)
    {
      v9 = (uint64_t **)*((_QWORD *)this + 16);
      while (((_BYTE)v9[2] & 2) != 0)
      {
        v9 = (uint64_t **)*v9;
        if (!v9)
          goto LABEL_8;
      }
    }
    else
    {
      if ((*((_WORD *)this + 44) & 2) != 0)
        goto LABEL_17;
      v8 = (uint64_t **)*((_QWORD *)this + 17);
      if (!v8)
        goto LABEL_17;
      v9 = (uint64_t **)*((_QWORD *)this + 17);
      while (((_BYTE)v9[2] & 2) != 0)
      {
        v9 = (uint64_t **)*v9;
        if (!v9)
        {
LABEL_8:
          v9 = v8;
          break;
        }
      }
    }
    if (v9[1] == a2)
      CoreWriteStreamUnscheduleFromRunLoop(v7);
  }
LABEL_17:
  if (*((_QWORD *)this + 17))
  {
    v10 = (CoreStreamBase *)*((_QWORD *)this + 19);
    if (v10)
    {
      v11 = (uint64_t **)*((_QWORD *)this + 17);
      while (((_BYTE)v11[2] & 2) != 0)
      {
        v11 = (uint64_t **)*v11;
        if (!v11)
        {
          v11 = (uint64_t **)*((_QWORD *)this + 17);
          break;
        }
      }
      if (v11[1] == a2)
        CoreReadStreamUnscheduleFromRunLoop(v10);
    }
  }
  v12 = *((_QWORD *)this + 12);
  if (v12)
    pthread_mutex_unlock((pthread_mutex_t *)(v12 + 8));
}

void NetConnectionCache::Key::~Key(NetConnectionCache::Key *this)
{
  uint64_t v2;

  NetConnectionCache::Key::~Key(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  const void *v2;
  const void *v3;

  *(_QWORD *)this = off_1E14EFF80;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 5);
  if (v3)
    CFRelease(v3);
}

BOOL NetConnectionCache::Key::equals(NetConnectionCache::Key *this, const CFAllocatedReferenceCountedObject *a2)
{
  _BOOL8 result;
  uint64_t v5;
  unint64_t v6;

  if (*((_DWORD *)this + 9) != *((_DWORD *)a2 + 9)
    || *((_DWORD *)this + 8) != *((_DWORD *)a2 + 8)
    || CFStringCompare(*((CFStringRef *)this + 3), *((CFStringRef *)a2 + 3), 1uLL))
  {
    return 0;
  }
  v5 = *((_QWORD *)this + 5);
  v6 = *((_QWORD *)a2 + 5);
  result = (v5 | v6) == 0;
  if (v5)
  {
    if (v6)
      return CFEqual(*((CFTypeRef *)this + 5), (CFTypeRef)v6) != 0;
  }
  return result;
}

CFHashCode NetConnectionCache::Key::hash(CFTypeRef *this)
{
  return CFHash(this[3]) | (int)(*((_DWORD *)this + 8) << 17) | (8 * *((_DWORD *)this + 9)) | (this[5] == 0);
}

CFStringRef NetConnectionCache::Key::copyDescription(CFAllocatorRef *this)
{
  return CFStringCreateWithFormat(this[1], 0, CFSTR("Host %@, port %d, type %d, properties = %@"), this[3], *((unsigned int *)this + 8), *((unsigned int *)this + 9), this[5]);
}

void NetConnectionCache::~NetConnectionCache(NetConnectionCache *this)
{
  const void *v1;

  *(_QWORD *)this = &off_1E14E9918;
  v1 = (const void *)*((_QWORD *)this + 2);
  if (v1)
    CFRelease(v1);
}

{
  const void *v1;

  *(_QWORD *)this = &off_1E14E9918;
  v1 = (const void *)*((_QWORD *)this + 2);
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t NetConnection::willEnqueueRequests(NetConnection *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const void *v5;
  const void *v6;
  CFTypeID v7;
  uint64_t v8;
  uint8_t v10[16];

  v2 = *((_QWORD *)this + 12);
  if (v2)
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  if ((*((_WORD *)this + 44) & 1) != 0)
  {
    v4 = *((_QWORD *)this + 19);
    if (!v4)
      goto LABEL_14;
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    ++*(_QWORD *)(v4 + 96);
    v5 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 40) + 40))(*(_QWORD *)(v4 + 40), 0x1EDCF96B8);
    --*(_QWORD *)(v4 + 96);
    if (v5)
    {
      v6 = v5;
      v7 = CFGetTypeID(v5);
      if (v7 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v10 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v10, 2u);
      }
      if ((const void *)*MEMORY[0x1E0C9AE50] == v6)
      {
        *((_WORD *)this + 44) &= ~1u;
        NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease((uint64_t)this);
        v3 = 0;
      }
      else
      {
        v3 = 1;
      }
      CFRelease(v6);
    }
    else
    {
LABEL_14:
      v3 = 1;
    }
  }
  else
  {
    v3 = 0;
  }
  v8 = *((_QWORD *)this + 12);
  if (v8)
    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8));
  return v3;
}

void NetConnection_Classic::~NetConnection_Classic(NetConnection_Classic *this)
{
  uint64_t v2;

  NetConnection_Classic::~NetConnection_Classic(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  void (*v2)(_QWORD);

  *(_QWORD *)this = off_1E14EC0C8;
  *((_QWORD *)this + 3) = &unk_1E14EC1A8;
  v2 = *(void (**)(_QWORD))(*((_QWORD *)this + 31) + 16);
  if (v2 && *((_QWORD *)this + 32))
    v2(*((_QWORD *)this + 1));
  NetConnection::~NetConnection(this);
}

uint64_t NetConnection_Classic::infoPointer(NetConnection_Classic *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 12);
  if (!v2)
    return *((_QWORD *)this + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  v3 = *((_QWORD *)this + 12);
  v4 = *((_QWORD *)this + 32);
  if (v3)
    pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
  return v4;
}

uint64_t NetConnection_Classic::createStreams(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t))(a1[31] + 24))(a1[1], a1[32], a2, a3);
}

uint64_t NetConnection_Classic::requestStateChanged(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 248) + 32))(a2, a3, a4, a1, *(_QWORD *)(a1 + 256));
}

uint64_t NetConnection_Classic::transmitRequest(NetConnection_Classic *this, void *a2)
{
  return (*(uint64_t (**)(void *, NetConnection_Classic *, _QWORD))(*((_QWORD *)this + 31) + 40))(a2, this, *((_QWORD *)this + 32));
}

uint64_t NetConnection_Classic::receiveResponse(NetConnection_Classic *this, void *a2)
{
  return (*(uint64_t (**)(void *, NetConnection_Classic *, _QWORD))(*((_QWORD *)this + 31) + 48))(a2, this, *((_QWORD *)this + 32));
}

uint64_t NetConnection_Classic::responseStreamCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 248) + 56))(a2, a3, a4, a1, *(_QWORD *)(a1 + 256));
}

uint64_t NetConnection_Classic::requestStreamCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 248) + 64))(a2, a3, a4, a1, *(_QWORD *)(a1 + 256));
}

_OWORD *NetConnection_Classic::copySchedulingSetForRequest(NetConnection_Classic *this, void *a2)
{
  CoreSchedulingSet *v2;
  const __CFArray *v3;
  _OWORD *v4;

  v2 = (CoreSchedulingSet *)(*(uint64_t (**)(void *, NetConnection_Classic *, _QWORD))(*((_QWORD *)this + 31)
                                                                                               + 72))(a2, this, *((_QWORD *)this + 32));
  v4 = CoreSchedulingSet::create(v2, v3);
  if (v2)
    CFRelease(v2);
  return v4;
}

uint64_t NetConnection_Classic::callTestFunc(NetConnection_Classic *this, unsigned __int8 (*a2)(void *, NetConnection *, const void *), void *a3)
{
  return ((uint64_t (*)(void *, NetConnection_Classic *, _QWORD))a2)(a3, this, *((_QWORD *)this + 32));
}

CFStringRef NetConnection_Classic::copyReqestDebugDesc(CFAllocatorRef *this, void *a2)
{
  return CFStringCreateWithFormat(this[1], 0, CFSTR("<request@%p>"), a2);
}

void `non-virtual thunk to'NetConnection_Classic::~NetConnection_Classic(NetConnection_Classic *this)
{
  NetConnection_Classic::~NetConnection_Classic((NetConnection_Classic *)((char *)this - 24));
}

void `non-virtual thunk to'NetConnection_Classic::~NetConnection_Classic(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  NetConnection_Classic::~NetConnection_Classic((NetConnection_Classic *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

void sub_18403F628(_Unwind_Exception *a1)
{
  NetConnection *v1;

  NetConnection::~NetConnection(v1);
  _Unwind_Resume(a1);
}

void NetConnection_Classic::Cache::Key::~Key(NetConnection_Classic::Cache::Key *this)
{
  uint64_t v2;

  NetConnection_Classic::Cache::Key::~Key(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  const void *v2;
  const void *v3;

  *(_QWORD *)this = off_1E14F0098;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 5);
  if (v3)
    CFRelease(v3);
}

uint64_t NetConnection_Classic::Cache::Key::equals(NetConnection_Classic::Cache::Key *this, const CFAllocatedReferenceCountedObject *a2)
{
  uint64_t result;
  const void *v5;
  const void *v6;
  const void *v7;

  result = *((_QWORD *)this + 3);
  if (result)
  {
    v5 = (const void *)*((_QWORD *)a2 + 3);
    if (!v5)
      return 0;
    result = CFEqual((CFTypeRef)result, v5);
    if (!(_DWORD)result)
      return result;
    if (*((_DWORD *)this + 8) == *((_DWORD *)a2 + 8) && *((_DWORD *)this + 9) == *((_DWORD *)a2 + 9))
    {
      v6 = (const void *)*((_QWORD *)this + 5);
      v7 = (const void *)*((_QWORD *)a2 + 5);
      if (v6 == v7)
      {
        return 1;
      }
      else
      {
        result = 0;
        if (v6)
        {
          if (v7)
            return CFEqual(*((CFTypeRef *)this + 5), v7) != 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFHashCode NetConnection_Classic::Cache::Key::hash(NetConnection_Classic::Cache::Key *this)
{
  const void *v2;
  CFHashCode v3;
  int v4;
  uint64_t v5;
  CFHashCode v6;

  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    v3 = CFHash(v2);
  else
    v3 = 0;
  v4 = *((_DWORD *)this + 9);
  v5 = *((int *)this + 8);
  v6 = *((_QWORD *)this + 5);
  if (v6)
    v6 = CFHash((CFTypeRef)v6);
  return v3 | v5 | v6 | (v4 << 14);
}

void NetConnection_Classic::Cache::~Cache(NetConnection_Classic::Cache *this)
{
  const void *v1;

  *(_QWORD *)this = &off_1E14F00E0;
  v1 = (const void *)*((_QWORD *)this + 2);
  if (v1)
    CFRelease(v1);
}

{
  const void *v1;

  *(_QWORD *)this = &off_1E14F00E0;
  v1 = (const void *)*((_QWORD *)this + 2);
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x186DB748CLL);
}

NetConnection *createNewConnection(const __CFAllocator *a1, uint64_t a2, uint64_t a3, int a4)
{
  char *v8;
  NetConnection *v9;
  uint64_t (*v10)(const __CFAllocator *, uint64_t);

  v8 = (char *)CFAllocatorAllocate(a1, 264, 0);
  *(_OWORD *)(v8 + 20) = 0u;
  *(_OWORD *)(v8 + 36) = 0u;
  *(_OWORD *)(v8 + 52) = 0u;
  *(_OWORD *)(v8 + 68) = 0u;
  *(_OWORD *)(v8 + 84) = 0u;
  *(_OWORD *)(v8 + 100) = 0u;
  *(_OWORD *)(v8 + 116) = 0u;
  *(_OWORD *)(v8 + 132) = 0u;
  *(_OWORD *)(v8 + 148) = 0u;
  *(_OWORD *)(v8 + 164) = 0u;
  *(_OWORD *)(v8 + 180) = 0u;
  *(_OWORD *)(v8 + 196) = 0u;
  *(_OWORD *)(v8 + 212) = 0u;
  *(_OWORD *)(v8 + 228) = 0u;
  *(_OWORD *)(v8 + 244) = 0u;
  *(_QWORD *)v8 = off_1E14EF578;
  *((_QWORD *)v8 + 1) = a1;
  *((_DWORD *)v8 + 65) = 0;
  *((_DWORD *)v8 + 4) = 1;
  if (((unint64_t)(v8 + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  v9 = (NetConnection *)v8;
  *(_QWORD *)v8 = off_1E14EC0C8;
  *((_QWORD *)v8 + 3) = &unk_1E14EC1A8;
  *((_QWORD *)v8 + 31) = a2;
  if (a2)
  {
    v10 = *(uint64_t (**)(const __CFAllocator *, uint64_t))(a2 + 8);
    if (v10)
      a3 = v10(a1, a3);
  }
  *((_QWORD *)v9 + 32) = a3;
  if (!a3 || !NetConnection::initialize(v9, a4))
  {
    (*(void (**)(NetConnection *))(*(_QWORD *)v9 + 48))(v9);
    return 0;
  }
  return v9;
}

void setConnectionProperties(NetConnection_Classic *a1, CFTypeRef cf)
{
  unint64_t Count;
  const void **v5;
  unint64_t v6;
  const void **v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  const void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[2];
  const void **v22;
  _BYTE v23[248];
  CFTypeRef v24;
  uint64_t v25;
  const void **v26;
  _BYTE v27[256];

  if (!cf)
    return;
  v21[0] = CFRetain(cf);
  Count = CFDictionaryGetCount((CFDictionaryRef)cf);
  v21[1] = Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v22 = 0;
    goto LABEL_8;
  }
  if (Count > 0x1E)
  {
    v5 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
    v22 = v5;
    if (!v5)
      goto LABEL_8;
  }
  else
  {
    v5 = (const void **)v23;
    v22 = (const void **)v23;
  }
  CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, v5, 0);
LABEL_8:
  v24 = CFRetain(cf);
  v6 = CFDictionaryGetCount((CFDictionaryRef)cf);
  v25 = v6;
  if (v6 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v26 = 0;
  }
  else
  {
    if (v6 <= 0x1E)
    {
      v7 = (const void **)v27;
      v26 = (const void **)v27;
LABEL_13:
      CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, 0, v7);
      goto LABEL_14;
    }
    v7 = (const void **)malloc_type_malloc(8 * v6, 0x89ED541CuLL);
    v26 = v7;
    if (v7)
      goto LABEL_13;
  }
LABEL_14:
  v8 = v25;
  if (v25 >= 1)
  {
    v9 = 0;
    do
    {
      v10 = v22[v9];
      v11 = v26[v9];
      v12 = *((_QWORD *)a1 + 12);
      if (v12)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v12 + 8));
        v13 = *((_QWORD *)a1 + 12);
        v14 = *((_QWORD *)a1 + 19);
        if (v13)
          pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8));
      }
      else
      {
        v14 = *((_QWORD *)a1 + 19);
      }
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      if (v14)
        v15 = v14 + 16;
      else
        v15 = 0;
      ++*(_QWORD *)(v15 + 80);
      v16 = (*(uint64_t (**)(_QWORD, const void *, const void *))(**(_QWORD **)(v15 + 24) + 32))(*(_QWORD *)(v15 + 24), v10, v11);
      --*(_QWORD *)(v15 + 80);
      if (!v16)
      {
        v17 = *((_QWORD *)a1 + 12);
        if (v17)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v17 + 8));
          v18 = *((_QWORD *)a1 + 12);
          v19 = *((_QWORD *)a1 + 18);
          if (v18)
            pthread_mutex_unlock((pthread_mutex_t *)(v18 + 8));
        }
        else
        {
          v19 = *((_QWORD *)a1 + 18);
        }
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
        if (v19)
          v20 = v19 + 16;
        else
          v20 = 0;
        ++*(_QWORD *)(v20 + 80);
        (*(void (**)(_QWORD, const void *, const void *))(**(_QWORD **)(v20 + 24) + 32))(*(_QWORD *)(v20 + 24), v10, v11);
        --*(_QWORD *)(v20 + 80);
      }
      ++v9;
    }
    while (v8 != v9);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v24);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v21);
}

void sub_18403FBF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  CFContainerEnumeratorBase *v10;

  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v10);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t HTTPNetConnection::errorOccurred(HTTPNetConnection *this, CFStreamError *a2)
{
  uint64_t v4;
  uint64_t v5;
  HTTPNetStreamInfo *v6;
  uint64_t v7;

  v4 = *((_QWORD *)this + 12);
  if (v4)
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  v5 = *((_QWORD *)this + 16);
  if (v5)
    v6 = *(HTTPNetStreamInfo **)(v5 + 8);
  else
    v6 = 0;
  v7 = *((_QWORD *)this + 12);
  if (v7)
    pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
  if (v6)
    HTTPNetStreamInfo::closeAndReleasePayload(v6);
  return NetConnection::errorOccurred(this, a2);
}

uint64_t HTTPNetConnection::createStreams(HTTPNetConnection *a1, uint64_t *a2, uint64_t *a3)
{
  const __CFAllocator *v6;
  _QWORD *v7;
  _QWORD *v8;
  __CFReadStream *v9;
  __CFWriteStream *v10;
  __CFReadStream *v11;
  _QWORD *v12;
  const __CFString *v13;
  const __CFAllocator *v14;
  __CFHost *v15;
  int v16;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _OWORD *HTTPStreamWithConnInfo;
  _OWORD *v22;
  const __CFDictionary *v23;
  unint64_t Count;
  const void **v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  unint64_t *p_shared_owners;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t v33;
  const void **v34;
  uint64_t v35;
  uint64_t v36;
  const void *v37;
  const void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD v43[2];
  const void **v44;
  _BYTE v45[248];
  CFTypeRef v46;
  uint64_t v47;
  const void **v48;
  _BYTE v49[248];
  uint64_t v50;
  std::__shared_weak_count *v51;
  __CFWriteStream *v52;
  __CFReadStream *v53;

  v6 = (const __CFAllocator *)*((_QWORD *)a1 + 1);
  v52 = 0;
  v53 = 0;
  v7 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(**((_QWORD **)a1 + 34) + 72))(*((_QWORD **)a1 + 34));
  *((_QWORD *)a1 + 30) = v7;
  CFRetain(v7);
  v8 = (_QWORD *)*((_QWORD *)a1 + 38);
  if (v8)
  {
    *((_BYTE *)v8 + 176) = 0;
    v9 = (__CFReadStream *)v8[29];
    v52 = (__CFWriteStream *)v8[30];
    v53 = v9;
    v8[29] = 0;
    v8[30] = 0;
    if (!*((_QWORD *)a1 + 35))
    {
      v27 = v8[25];
      v26 = (std::__shared_weak_count *)v8[26];
      v50 = v27;
      v51 = v26;
      if (v26)
      {
        p_shared_owners = (unint64_t *)&v26->__shared_owners_;
        do
          v29 = __ldxr(p_shared_owners);
        while (__stxr(v29 + 1, p_shared_owners));
      }
      (*(void (**)(HTTPNetConnection *, uint64_t *))(*(_QWORD *)a1 + 232))(a1, &v50);
      v30 = v51;
      if (v51)
      {
        v31 = (unint64_t *)&v51->__shared_owners_;
        do
          v32 = __ldaxr(v31);
        while (__stlxr(v32 - 1, v31));
        if (!v32)
        {
          ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
          std::__shared_weak_count::__release_weak(v30);
        }
      }
    }
    (*(void (**)(_QWORD *))(**((_QWORD **)a1 + 38) + 48))(*((_QWORD **)a1 + 38));
    *((_QWORD *)a1 + 38) = 0;
    v10 = v52;
    v11 = v53;
    if (!v53 || !v52)
      goto LABEL_15;
  }
  else
  {
    v12 = (_QWORD *)*((_QWORD *)a1 + 34);
    v13 = (const __CFString *)v12[4];
    v14 = (const __CFAllocator *)*((unsigned int *)v12 + 14);
    v15 = (__CFHost *)_CFHostCreateWithNameAndPortForConnect(v6, v13, (const __CFAllocator *)(unsigned __int16)*((_DWORD *)v12 + 14));
    if (!v15)
    {
      v15 = CFHostCreateWithName(v6, v13);
      if (!v15)
        return 1;
    }
    __CFStreamCreatePairWithSocketToCFHost(v6, v15, v14, &v53, &v52, 0);
    CFRelease(v15);
    v10 = v52;
    v11 = v53;
    if (!v53 || !v52)
    {
LABEL_15:
      if (v11)
      {
        CFRelease(v11);
        v10 = v52;
      }
      if (v10)
        CFRelease(v10);
      return 1;
    }
    CFWriteStreamSetProperty(v52, (CFStreamPropertyKey)&unk_1EDCFB1A0, (CFTypeRef)*MEMORY[0x1E0C9AE50]);
  }
  if ((*(unsigned int (**)(_QWORD *))(**((_QWORD **)a1 + 34) + 88))(*((_QWORD **)a1 + 34)) == 1)
    CFReadStreamSetProperty(v53, (CFStreamPropertyKey)&unk_1EDCFBEC0, &unk_1EDCFC1D0);
  v16 = (*(unsigned int (**)(_QWORD *))(**((_QWORD **)a1 + 34) + 88))(*((_QWORD **)a1 + 34)) == 2
     || (*(uint64_t (**)(_QWORD *))(**((_QWORD **)a1 + 34) + 88))(*((_QWORD **)a1 + 34)) == 3;
  v18 = __CoreWriteStreamCreateHTTPStreamWithConnInfo(v6, 0, v16, v52, a1);
  *a2 = v18;
  v19 = *MEMORY[0x1E0C9AE50];
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  if (v18)
    v20 = v18 + 16;
  else
    v20 = 0;
  ++*(_QWORD *)(v20 + 80);
  (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v20 + 24) + 32))(*(_QWORD *)(v20 + 24), 0x1EDCFE3B8, v19);
  --*(_QWORD *)(v20 + 80);
  if (v52)
    CFRelease(v52);
  HTTPStreamWithConnInfo = __CoreReadStreamCreateHTTPStreamWithConnInfo(v6, v53, 1, a1);
  *a3 = (uint64_t)HTTPStreamWithConnInfo;
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  if (HTTPStreamWithConnInfo)
    v22 = HTTPStreamWithConnInfo + 1;
  else
    v22 = 0;
  ++*((_QWORD *)v22 + 10);
  (*(void (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)v22 + 3) + 32))(*((_QWORD *)v22 + 3), 0x1EDCFE3B8, v19);
  --*((_QWORD *)v22 + 10);
  if (v53)
    CFRelease(v53);
  result = (*(uint64_t (**)(_QWORD *))(**((_QWORD **)a1 + 34) + 64))(*((_QWORD **)a1 + 34));
  if (result)
  {
    v23 = (const __CFDictionary *)result;
    v43[0] = CFRetain((CFTypeRef)result);
    Count = CFDictionaryGetCount(v23);
    v43[1] = Count;
    if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      v44 = 0;
      goto LABEL_50;
    }
    if (Count > 0x1E)
    {
      v25 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
      v44 = v25;
      if (!v25)
        goto LABEL_50;
    }
    else
    {
      v25 = (const void **)v45;
      v44 = (const void **)v45;
    }
    CFDictionaryGetKeysAndValues(v23, v25, 0);
LABEL_50:
    v46 = CFRetain(v23);
    v33 = CFDictionaryGetCount(v23);
    v47 = v33;
    if (v33 - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      v48 = 0;
    }
    else
    {
      if (v33 <= 0x1E)
      {
        v34 = (const void **)v49;
        v48 = (const void **)v49;
LABEL_55:
        CFDictionaryGetKeysAndValues(v23, 0, v34);
        goto LABEL_56;
      }
      v34 = (const void **)malloc_type_malloc(8 * v33, 0x89ED541CuLL);
      v48 = v34;
      if (v34)
        goto LABEL_55;
    }
LABEL_56:
    v35 = v47;
    if (v47 >= 1)
    {
      v36 = 0;
      do
      {
        v37 = v44[v36];
        v38 = v48[v36];
        v39 = *a3;
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
        if (v39)
          v40 = v39 + 16;
        else
          v40 = 0;
        ++*(_QWORD *)(v40 + 80);
        (*(void (**)(_QWORD, const void *, const void *))(**(_QWORD **)(v40 + 24) + 32))(*(_QWORD *)(v40 + 24), v37, v38);
        --*(_QWORD *)(v40 + 80);
        v41 = *a2;
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
        if (v41)
          v42 = v41 + 16;
        else
          v42 = 0;
        ++*(_QWORD *)(v42 + 80);
        (*(void (**)(_QWORD, const void *, const void *))(**(_QWORD **)(v42 + 24) + 32))(*(_QWORD *)(v42 + 24), v37, v38);
        --*(_QWORD *)(v42 + 80);
        ++v36;
      }
      while (v35 != v36);
    }
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v46);
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v43);
    return 0;
  }
  return result;
}

void sub_184040214(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 - 120);
  _Unwind_Resume(a1);
}

void HTTPNetConnection::requestStateChanged(_QWORD *a1, HTTPNetStreamInfo *this, int a3, uint64_t a4)
{
  __CFRunLoopSource *v8;
  __CFHTTPMessage *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int16 v32;
  __int16 v33;
  __CFWriteStream *v34;
  uint64_t v35;
  uint64_t v36;
  const __CFAllocator *v37;
  const void *v38;
  CFStringRef v39;
  CFStringRef v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const __CFString *v44;
  const __CFString *v45;
  const __CFAllocator *v46;
  CFAbsoluteTime v47;
  CFRunLoopTimerRef v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t *v51;
  int v52;
  int v53;
  uint64_t v54;
  HTTPMessage *v55;
  const __CFString *v56;
  const __CFString *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  HTTPMessage *v64;
  const __CFString *v65;
  const __CFString *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  _QWORD *v72;
  uint64_t v73;
  const __CFAllocator *v74;
  CFAbsoluteTime Current;
  CFRunLoopTimerRef v76;
  void (**v77)(AutoString *__hidden);
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  HTTPMessage *v83;
  CFStringRef v84;
  uint64_t v85;
  uint64_t v86;
  _QWORD *v87;
  uint64_t v88;
  uint64_t v89;
  _QWORD *v90;
  uint64_t v91;
  uint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  const __CFBoolean *v95;
  const __CFBoolean *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  const CoreSchedulingSet *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  const __CFAllocator *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  const void *v112;
  const void *v113;
  CFTypeRef v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  const __CFDictionary *v119;
  const __CFDictionary *v120;
  const __CFDictionary *Value;
  const __CFDictionary *v122;
  const void *v123;
  char v124;
  CFHTTPMessageRef Copy;
  uint64_t v126;
  CFStringRef v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  void *v133;
  const void *v134;
  CFTypeRef v135;
  void *MutableCopy;
  CFIndex Count;
  CFIndex v138;
  __CFDictionary *v139;
  _QWORD *v140;
  uint64_t v141;
  uint64_t v142;
  _QWORD *v143;
  uint64_t v144;
  uint64_t v145;
  void *values;
  CFRunLoopTimerContext context;
  void (**v148)(AutoString *__hidden);
  uint64_t v149;
  void (*v150)(uint64_t, CFRunLoopRef, const __CFString *);
  void *v151;
  CFRunLoopTimerRef v152;
  uint64_t v153;
  CFStreamError v154;
  CFStreamError v155;

  v153 = *MEMORY[0x1E0C80C00];
  *((_DWORD *)this + 8) = *((_DWORD *)this + 8) & 0xFFFE1FFF | ((a3 & 0xF) << 13);
  v8 = (__CFRunLoopSource *)*((_QWORD *)this + 17);
  if (v8)
    CFRunLoopSourceSignal(v8);
  switch(a3)
  {
    case 1:
      if (*((_BYTE *)a1 + 250))
        return;
      *((_BYTE *)a1 + 250) = 1;
      if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)a1[34] + 88))(a1[34]) != 3)
        return;
      v9 = (__CFHTTPMessage *)*((_QWORD *)this + 5);
      v10 = a1[12];
      if (v10)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v10 + 8));
        v11 = a1[12];
        v12 = a1[18];
        if (v11)
          pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8));
      }
      else
      {
        v12 = a1[18];
      }
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      *(_WORD *)(v12 + 240) &= ~0x20u;
      v104 = (*(uint64_t (**)(_QWORD *, __CFHTTPMessage *))(*a1 + 264))(a1, v9);
      if (!v104)
        return;
      v105 = v104;
      v106 = (const __CFAllocator *)a1[1];
      v107 = a1[12];
      if (v107)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v107 + 8));
        v108 = a1[12];
        v109 = a1[19];
        if (v108)
          pthread_mutex_unlock((pthread_mutex_t *)(v108 + 8));
      }
      else
      {
        v109 = a1[19];
      }
      context.version = 0;
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      if (v109)
        v118 = v109 + 16;
      else
        v118 = 0;
      ++*(_QWORD *)(v118 + 80);
      v119 = (const __CFDictionary *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v118 + 24) + 40))(*(_QWORD *)(v118 + 24), 0x1EDD003E0);
      v120 = v119;
      --*(_QWORD *)(v118 + 80);
      if (v119)
      {
        Value = (const __CFDictionary *)CFDictionaryGetValue(v119, &unk_1EDD003A8);
        v122 = Value;
        if (Value)
        {
          v123 = CFDictionaryGetValue(Value, &unk_1EDCFD3F8);
          v124 = 0;
          goto LABEL_222;
        }
      }
      else
      {
        v122 = 0;
      }
      v123 = 0;
      v124 = 1;
LABEL_222:
      Copy = CFHTTPMessageCreateCopy(v106, v9);
      v148 = (void (**)(AutoString *__hidden))(*(uint64_t (**)(_QWORD *, CFHTTPMessageRef, uint64_t))(*a1 + 256))(a1, Copy, v105);
      v149 = v126;
      if ((_DWORD)v126)
      {
        (*(void (**)(_QWORD *, void (***)(AutoString *__hidden)))(*a1 + 64))(a1, &v148);
        context.version = 0;
        CFRelease(Copy);
      }
      else
      {
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        v127 = HTTPMessage::copyHeaderFieldValue((CFHTTPMessageRef)((char *)Copy + 16), 0x1362735Fu);
        context.version = (CFIndex)v127;
        CFRelease(Copy);
        if (v127 && (!v123 || !CFEqual(v123, v127)))
        {
          v128 = a1[12];
          if (v128)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v128 + 8));
            v129 = a1[12];
            v130 = a1[18];
            if (v129)
              pthread_mutex_unlock((pthread_mutex_t *)(v129 + 8));
          }
          else
          {
            v130 = a1[18];
          }
          if ((v124 & 1) != 0)
          {
            MutableCopy = CFDictionaryCreate(v106, (const void **)&kCFHTTPHeaderProxyAuthorization, (const void **)&context, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            values = MutableCopy;
          }
          else
          {
            Count = CFDictionaryGetCount(v122);
            MutableCopy = CFDictionaryCreateMutableCopy(v106, Count + 1, v122);
            values = MutableCopy;
            CFDictionarySetValue((CFMutableDictionaryRef)MutableCopy, &unk_1EDCFD3F8, v127);
          }
          if (v120)
          {
            v138 = CFDictionaryGetCount(v120);
            v139 = CFDictionaryCreateMutableCopy(v106, v138 + 1, v120);
            CFDictionarySetValue(v139, &unk_1EDD003A8, MutableCopy);
          }
          else
          {
            v139 = CFDictionaryCreate(v106, (const void **)&kCFStreamPropertyCONNECTAdditionalHeaders, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            MutableCopy = values;
          }
          if (MutableCopy)
            CFRelease(MutableCopy);
          if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
            dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
          v141 = *(_QWORD *)(v118 + 80);
          v140 = (_QWORD *)(v118 + 80);
          *v140 = v141 + 1;
          (*(void (**)(_QWORD, uint64_t, __CFDictionary *))(*(_QWORD *)*(v140 - 7) + 32))(*(v140 - 7), 0x1EDD003E0, v139);
          --*v140;
          if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
            dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
          if (v130)
            v142 = v130 + 16;
          else
            v142 = 0;
          v144 = *(_QWORD *)(v142 + 80);
          v143 = (_QWORD *)(v142 + 80);
          *v143 = v144 + 1;
          (*(void (**)(_QWORD, uint64_t, __CFDictionary *))(*(_QWORD *)*(v143 - 7) + 32))(*(v143 - 7), 0x1EDD003E0, v139);
          --*v143;
          if (v139)
            CFRelease(v139);
        }
      }
      if (v120)
        CFRelease(v120);
      if (context.version)
        CFRelease((CFTypeRef)context.version);
      return;
    case 2:
      v19 = a1[12];
      if (!v19)
      {
        v21 = a1[18];
LABEL_48:
        v24 = a1[19];
        goto LABEL_49;
      }
      pthread_mutex_lock((pthread_mutex_t *)(v19 + 8));
      v20 = a1[12];
      v21 = a1[18];
      if (!v20)
        goto LABEL_48;
      pthread_mutex_unlock((pthread_mutex_t *)(v20 + 8));
      v22 = a1[12];
      if (!v22)
        goto LABEL_48;
      pthread_mutex_lock((pthread_mutex_t *)(v22 + 8));
      v23 = a1[12];
      v24 = a1[19];
      if (v23)
        pthread_mutex_unlock((pthread_mutex_t *)(v23 + 8));
LABEL_49:
      v35 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_5329, 2);
      if (v35)
      {
        v36 = v35;
        if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v35 + 16))(v35, "HTTPNetConnection::prepareTransmission", 0))
        {
          v37 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v36 + 72))(v36, "streamInfo", CFSTR("%p"));
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v36 + 72))(v36, "requestStream", CFSTR("%p"));
          v38 = (const void *)*((_QWORD *)this + 5);
          v148 = &off_1E14E4818;
          v39 = CFStringCreateWithCString(v37, "request: ", 0x8000100u);
          v150 = 0;
          v151 = 0;
          v149 = (uint64_t)v39;
          if (v38)
          {
            v40 = CFCopyDescription(v38);
            v41 = v149;
          }
          else
          {
            v41 = (uint64_t)v39;
            v40 = CFSTR("null");
          }
          (*(void (**)(uint64_t, uint64_t, CFStringRef))(*(_QWORD *)v36 + 64))(v36, v41, v40);
          if (v38 && v40)
            CFRelease(v40);
          AutoString::~AutoString((AutoString *)&v148);
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
        }
      }
      v145 = v24;
      v50 = NetConnection::willEnqueueRequests((NetConnection *)a1);
      v51 = &HSTSCache::defaultStoreURL(void)::once;
      if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)a1[34] + 88))(a1[34]) == 2)
      {
        *((_BYTE *)a1 + 267) = 0;
LABEL_76:
        v53 = 1;
        goto LABEL_77;
      }
      v52 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[34] + 88))(a1[34]);
      *((_BYTE *)a1 + 267) = 0;
      if (v52 == 3)
        goto LABEL_76;
      v53 = 0;
      if ((*((_BYTE *)this + 33) & 4) != 0 && (_DWORD)v50)
      {
        v63 = *((_QWORD *)this + 5);
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        if (v63)
          v64 = (HTTPMessage *)(v63 + 16);
        else
          v64 = 0;
        v65 = HTTPMessage::copyHeaderFieldValue(v64, 0x119152ADu);
        v66 = v65;
        if (v65)
        {
          if (CFStringCompare(v65, CFSTR("close"), 1uLL) == kCFCompareEqualTo)
          {
            v67 = a1[12];
            if (v67)
              pthread_mutex_lock((pthread_mutex_t *)(v67 + 8));
            *((_WORD *)a1 + 44) &= ~1u;
            NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease((uint64_t)a1);
            v68 = a1[12];
            if (v68)
              pthread_mutex_unlock((pthread_mutex_t *)(v68 + 8));
            v50 = 0;
          }
          CFRelease(v66);
        }
        v53 = 0;
      }
LABEL_77:
      v54 = *((_QWORD *)this + 5);
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (v54)
        v55 = (HTTPMessage *)(v54 + 16);
      else
        v55 = 0;
      v56 = HTTPMessage::copyHeaderFieldValue(v55, 0x1250D2FAu);
      v57 = v56;
      if (v56)
      {
        if (CFStringFind(v56, (CFStringRef)&unk_1EDCFDAC0, 1uLL).location == -1
          || (v58 = (*(uint64_t (**)(_QWORD *, HTTPNetStreamInfo *))(*a1 + 160))(a1, this)) == 0)
        {
          v62 = 0;
        }
        else
        {
          *((_BYTE *)a1 + 264) = 1;
          v59 = a1[12];
          if (v59)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v59 + 8));
            v60 = a1[12];
            v61 = a1[18];
            if (v60)
              pthread_mutex_unlock((pthread_mutex_t *)(v60 + 8));
          }
          else
          {
            v61 = a1[18];
          }
          if (v61)
          {
            v69 = v50;
            v70 = v53;
            context.version = 0;
            context.info = a1;
            memset(&context.retain, 0, 24);
            v71 = *MEMORY[0x1E0C9AE50];
            if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
              dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
            v73 = *(_QWORD *)(v61 + 96);
            v72 = (_QWORD *)(v61 + 96);
            *v72 = v73 + 1;
            (*(void (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)*(v72 - 7) + 32))(*(v72 - 7), 0x1EDCFE498, v71);
            v53 = v70;
            v50 = v69;
            --*v72;
            v74 = (const __CFAllocator *)a1[1];
            Current = CFAbsoluteTimeGetCurrent();
            v76 = CFRunLoopTimerCreate(v74, Current + 5.0, -1.0, 0, 0, (CFRunLoopTimerCallBack)HTTPNetConnection::_OneHundredContinueTimeout, &context);
            v77 = (void (**)(AutoString *__hidden))MEMORY[0x1E0C809B0];
            a1[32] = v76;
            v148 = v77;
            v149 = 3221225472;
            v150 = ___ZNK17CoreSchedulingSet13scheduleTimerEP16__CFRunLoopTimer_block_invoke;
            v151 = &__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
            v152 = v76;
            CoreSchedulingSet::applyBlockWithPossibleEmulation(v58, (void (**)(_QWORD, _QWORD, _QWORD))&v148);
          }
          (*(void (**)(uint64_t))(*(_QWORD *)v58 + 48))(v58);
          v78 = a1[12];
          if (v78)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v78 + 8));
            v79 = a1[12];
            v80 = a1[19];
            if (v79)
              pthread_mutex_unlock((pthread_mutex_t *)(v79 + 8));
          }
          else
          {
            v80 = a1[19];
          }
          if (v80 != v145)
            __assert_rtn("prepareTransmission", "HTTPNetConnection.cpp", 899, "getResponseStream() == responseStream");
          if (v145)
          {
            v81 = *MEMORY[0x1E0C9AE50];
            if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
              dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
            ++*(_QWORD *)(v145 + 96);
            (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v145 + 40) + 32))(*(_QWORD *)(v145 + 40), 0x1EDCFE498, v81);
            v51 = &HSTSCache::defaultStoreURL(void)::once;
            --*(_QWORD *)(v145 + 96);
            v62 = 1;
          }
          else
          {
            v62 = 0;
            v51 = &HSTSCache::defaultStoreURL(void)::once;
          }
        }
        CFRelease(v57);
      }
      else
      {
        v62 = 0;
      }
      v82 = *((_QWORD *)this + 5);
      if (v51[127] != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (v82)
        v83 = (HTTPMessage *)(v82 + 16);
      else
        v83 = 0;
      v84 = HTTPMessage::copyHeaderFieldValue(v83, 0x1470F3EAu);
      if (v84)
      {
        CFRelease(v84);
        *((_BYTE *)a1 + 269) = 1;
        v85 = *MEMORY[0x1E0C9AE50];
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
        if (v21)
          v86 = v21 + 16;
        else
          v86 = 0;
        v88 = *(_QWORD *)(v86 + 80);
        v87 = (_QWORD *)(v86 + 80);
        *v87 = v88 + 1;
        (*(void (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)*(v87 - 7) + 32))(*(v87 - 7), 0x1EDCFE428, v85);
        --*v87;
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
        if (v145)
          v89 = v145 + 16;
        else
          v89 = 0;
        v91 = *(_QWORD *)(v89 + 80);
        v90 = (_QWORD *)(v89 + 80);
        *v90 = v91 + 1;
        (*(void (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)*(v90 - 7) + 32))(*(v90 - 7), 0x1EDCFE428, v85);
        --*v90;
      }
      if (*((_QWORD *)this + 7) && (a1[11] & 2) == 0)
      {
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
        if (v21)
          v92 = v21 + 16;
        else
          v92 = 0;
        v94 = *(_QWORD *)(v92 + 80);
        v93 = (_QWORD *)(v92 + 80);
        *v93 = v94 + 1;
        v95 = (const __CFBoolean *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*(v93 - 7) + 40))(*(v93 - 7), 0x1EDCFE230);
        v96 = v95;
        --*v93;
        if (v95)
        {
          if (CFBooleanGetValue(v95))
          {
            v62 = 1;
            *((_BYTE *)a1 + 265) = 1;
          }
          CFRelease(v96);
        }
      }
      if (!v62)
        goto LABEL_167;
      v97 = (*(uint64_t (**)(_QWORD *, HTTPNetStreamInfo *))(*a1 + 160))(a1, this);
      v98 = a1[12];
      if (v98)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v98 + 8));
        v99 = a1[12];
        v100 = a1[19];
        if (v99)
          pthread_mutex_unlock((pthread_mutex_t *)(v99 + 8));
        if (v100)
          goto LABEL_157;
      }
      else
      {
        v100 = a1[19];
        if (v100)
        {
LABEL_157:
          CFRetain((CFTypeRef)v100);
          if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
            dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
          v101 = (const CoreSchedulingSet *)v97;
          if (!v97)
          {
            if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
              dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16941);
            v101 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
          }
          CoreStreamBase::_streamInterface_UpdateScheduling((CoreStreamBase *)(v100 + 16), v101);
          CFRelease((CFTypeRef)v100);
          HTTPNetConnection::prepareReception((HTTPNetConnection *)a1, (uint64_t)this, v100);
          goto LABEL_166;
        }
      }
      HTTPNetConnection::prepareReception((HTTPNetConnection *)a1, (uint64_t)this, 0);
LABEL_166:
      (*(void (**)(uint64_t))(*(_QWORD *)v97 + 48))(v97);
LABEL_167:
      if (*((_QWORD *)this + 7) && !*((_BYTE *)this + 64))
        cleanUpRequest(*((__CFHTTPMessage **)this + 5), *((_QWORD *)this + 9), v50, v53, 0);
      else
        cleanUpRequest(*((__CFHTTPMessage **)this + 5), 0, v50, v53, 0);
      (*(void (**)(_QWORD *, HTTPNetStreamInfo *, uint64_t))(*a1 + 248))(a1, this, v50);
      v102 = *((_QWORD *)this + 5);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      if (v21)
        v103 = v21 + 16;
      else
        v103 = 0;
      ++*(_QWORD *)(v103 + 80);
      (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v103 + 24) + 32))(*(_QWORD *)(v103 + 24), 0x1EDCFE380, v102);
      --*(_QWORD *)(v103 + 80);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      if (CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)v103))
      {
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
        v155.domain = 0;
        *(_QWORD *)&v155.error = 0;
        CoreStreamBase::_signalEvent((CoreStreamBase *)v103, 4, v155, 0);
      }
      return;
    case 3:
      v13 = a1[12];
      if (v13)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v13 + 8));
        v14 = a1[12];
        v15 = a1[18];
        if (v14)
          pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8));
      }
      else
      {
        v15 = a1[18];
      }
      *((_BYTE *)a1 + 265) = 0;
      HTTPNetStreamInfo::closeRequestResources(this);
      if (v15)
      {
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
        v31 = v15 + 16;
      }
      else
      {
        v31 = 0;
      }
      v32 = *(_WORD *)(v31 + 224);
      if ((v32 & 0x400) != 0)
      {
        v33 = v32 | 1;
        *(_WORD *)(v31 + 224) = v32 | 1;
        if ((v32 & 0x80) != 0)
        {
          if (*(_QWORD *)(v31 + 216))
          {
            v34 = *(__CFWriteStream **)(v31 + 208);
            if (v34)
            {
              CFWriteStreamWrite(v34, (const UInt8 *)"\r\n0\r\n\r\n", 7);
              *(_QWORD *)(v31 + 288) += 7;
              v33 = *(_WORD *)(v31 + 224);
            }
          }
        }
      }
      else
      {
        v33 = *(_WORD *)(v31 + 224);
      }
      *(_WORD *)(v31 + 224) = v33 | 4;
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v31 + 72))(v31))
      {
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
        v154.domain = 0;
        *(_QWORD *)&v154.error = 0;
        CoreStreamBase::_signalEvent((CoreStreamBase *)v31, 4, v154, 0);
      }
      return;
    case 4:
      if (!*((_QWORD *)this + 22))
      {
        v42 = *((_QWORD *)this + 21);
        if (v42)
        {
          if (*(_DWORD *)(v42 + 40))
          {
            v43 = *((_QWORD *)this + 15);
            if (!v43 || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v43 + 256))(v43))
            {
              v44 = CFHTTPMessageCopyRequestMethod(*((CFHTTPMessageRef *)this + 5));
              if (v44)
              {
                v45 = v44;
                if (CFStringCompare(v44, CFSTR("GET"), 1uLL) == kCFCompareEqualTo)
                {
                  context.version = 0;
                  context.info = this;
                  memset(&context.retain, 0, 24);
                  v46 = CFGetAllocator(*((CFTypeRef *)this + 1));
                  v47 = CFAbsoluteTimeGetCurrent();
                  v48 = CFRunLoopTimerCreate(v46, v47 + 3.0, -1.0, 0, 0, (CFRunLoopTimerCallBack)HTTPNetStreamInfo::_stallTimerFired, &context);
                  *((_QWORD *)this + 22) = v48;
                  v49 = *((_QWORD *)this + 21);
                  v148 = (void (**)(AutoString *__hidden))MEMORY[0x1E0C809B0];
                  v149 = 3221225472;
                  v150 = ___ZNK17CoreSchedulingSet13scheduleTimerEP16__CFRunLoopTimer_block_invoke;
                  v151 = &__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
                  v152 = v48;
                  CoreSchedulingSet::applyBlockWithPossibleEmulation(v49, (void (**)(_QWORD, _QWORD, _QWORD))&v148);
                }
                CFRelease(v45);
              }
            }
          }
        }
      }
      v25 = a1[12];
      if (v25)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v25 + 8));
        v26 = a1[12];
        v27 = a1[19];
        if (v26)
          pthread_mutex_unlock((pthread_mutex_t *)(v26 + 8));
      }
      else
      {
        v27 = a1[19];
      }
      HTTPNetConnection::prepareReception((HTTPNetConnection *)a1, (uint64_t)this, v27);
      return;
    case 5:
      v28 = a1[12];
      if (v28)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v28 + 8));
        v29 = a1[12];
        v30 = a1[19];
        if (v29)
          pthread_mutex_unlock((pthread_mutex_t *)(v29 + 8));
      }
      else
      {
        v30 = a1[19];
      }
      if ((*((_BYTE *)this + 32) & 0xC) != 0)
        goto LABEL_63;
      if (!*((_QWORD *)this + 6)
        && (HTTPNetStreamInfo *)HTTPNetConnection::updateForHeaders((HTTPNetConnection *)a1, (uint64_t)this, v30) != this)
      {
        goto LABEL_208;
      }
      goto LABEL_207;
    case 7:
      HTTPNetStreamInfo::closeRequestResources(this);
      if ((*((_BYTE *)this + 32) & 4) != 0)
      {
LABEL_63:
        HTTPNetStreamInfo::dequeueFromConnection((NetConnection **)this);
      }
      else
      {
        if (*(_QWORD *)a4 == 4 && *(_DWORD *)(a4 + 8) == -2096)
        {
          v16 = a1[12];
          if (v16)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v16 + 8));
            v17 = a1[12];
            v18 = a1[18];
            if (v17)
              pthread_mutex_unlock((pthread_mutex_t *)(v17 + 8));
          }
          else
          {
            v18 = a1[18];
          }
          if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
            dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
          if (v18)
            v110 = v18 + 16;
          else
            v110 = 0;
          ++*(_QWORD *)(v110 + 80);
          v111 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v110 + 24) + 40))(*(_QWORD *)(v110 + 24), 0x1EDD00488);
          --*(_QWORD *)(v110 + 80);
          if (v111)
          {
            v112 = (const void *)v111;
            v113 = (const void *)*((_QWORD *)this + 6);
            if (v113 == v112)
              goto LABEL_200;
            if (v113)
              CFRelease(v113);
            v114 = CFRetain(v112);
            *((_QWORD *)this + 6) = v114;
            if (v114)
LABEL_200:
              CFReadStreamSignalEvent();
            CFRelease(v112);
          }
          _CFReadStreamSignalEventDelayed();
          if (*(_QWORD *)a4 == 4 && *(_DWORD *)(a4 + 8) == -2096)
          {
            v115 = a1[12];
            if (v115)
            {
              pthread_mutex_lock((pthread_mutex_t *)(v115 + 8));
              v116 = a1[12];
              v117 = a1[18];
              if (v116)
                pthread_mutex_unlock((pthread_mutex_t *)(v116 + 8));
            }
            else
            {
              v117 = a1[18];
            }
            if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
              dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
            if (v117)
              v131 = v117 + 16;
            else
              v131 = 0;
            ++*(_QWORD *)(v131 + 80);
            v132 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v131 + 24) + 40))(*(_QWORD *)(v131 + 24), 0x1EDD00488);
            --*(_QWORD *)(v131 + 80);
            if (v132)
            {
              v133 = (void *)v132;
              v134 = (const void *)*((_QWORD *)this + 6);
              if (v134 == v133)
                goto LABEL_247;
              if (v134)
                CFRelease(v134);
              v135 = CFRetain(v133);
              *((_QWORD *)this + 6) = v135;
              if (v135)
LABEL_247:
                CFReadStreamSignalEvent();
              HTTPNetConnection::updateAuth((HTTPNetConnection *)a1, (CFHTTPMessageRef *)this, (__CFHTTPMessage *)v133);
              CFRelease(v133);
            }
          }
        }
LABEL_207:
        _CFReadStreamSignalEventDelayed();
      }
LABEL_208:
      if ((*((_BYTE *)this + 32) & 4) != 0)
        (*(void (**)(HTTPNetStreamInfo *))(*(_QWORD *)this + 168))(this);
      return;
    default:
      CFLog();
      return;
  }
}

void sub_18404163C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

uint64_t HTTPNetConnection::transmitRequest(uint64_t this, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  const void *v11;
  CFTypeRef v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  int v18;

  v3 = this;
  v4 = *(_QWORD *)(this + 96);
  if (v4)
  {
    this = pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
    v5 = *(_QWORD *)(v3 + 96);
    v6 = *(_QWORD *)(v3 + 144);
    if (v5)
      this = pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
  }
  else
  {
    v6 = *(_QWORD *)(this + 144);
  }
  if ((a2[4] & 0x40) == 0)
  {
    this = HTTPNetConnection::transmitRequest(v3);
    v7 = v18;
    if (v18)
    {
      *(_BYTE *)(v3 + 265) = 0;
      if (v17 == 4 && v7 == -2096)
      {
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
        if (v6)
          v8 = v6 + 16;
        else
          v8 = 0;
        ++*(_QWORD *)(v8 + 80);
        v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v8 + 24) + 40))(*(_QWORD *)(v8 + 24));
        --*(_QWORD *)(v8 + 80);
        if (v9)
        {
          v10 = (const void *)v9;
          v11 = (const void *)a2[6];
          if (v11 == v10)
            goto LABEL_19;
          if (v11)
            CFRelease(v11);
          v12 = CFRetain(v10);
          a2[6] = v12;
          if (v12)
LABEL_19:
            CFReadStreamSignalEvent();
          CFRelease(v10);
        }
        v13 = *(_QWORD *)(v3 + 128);
        if (v13)
          v14 = *(void **)(v13 + 8);
        else
          v14 = 0;
        NetConnection::requestIsComplete((NetConnection *)v3, v14);
        return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 72))(v3);
      }
      else
      {
        return (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 64))(v3, &v17);
      }
    }
    else if ((_DWORD)this)
    {
      *(_BYTE *)(v3 + 265) = 0;
      v15 = *(_QWORD *)(v3 + 128);
      if (v15)
        v16 = *(void **)(v15 + 8);
      else
        v16 = 0;
      return NetConnection::requestIsComplete((NetConnection *)v3, v16);
    }
  }
  return this;
}

void HTTPNetConnection::receiveResponse(HTTPNetConnection *this, void *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  HTTPNetConnection *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  unsigned __int8 v11[32776];
  uint64_t v12;

  v2 = MEMORY[0x1E0C80A78](this);
  v4 = v3;
  v5 = (HTTPNetConnection *)v2;
  v12 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(v2 + 96);
  if (v6)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
    v7 = *((_QWORD *)v5 + 12);
    v8 = *((_QWORD *)v5 + 19);
    if (v7)
      pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
  }
  else
  {
    v8 = *(_QWORD *)(v2 + 152);
  }
  if ((*(_BYTE *)(v4 + 32) & 0x10) == 0 && (*(_BYTE *)(v4 + 32) & 0x40) == 0 && v8)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if ((CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v8 + 16)) & 0xFFFFFFFFFFFFFFFDLL) == 5)
      goto LABEL_49;
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (CoreStreamBase::_streamInterface_CanRead((CoreStreamBase *)(v8 + 16))
      || _CFHTTPReadStreamIsAtMark(v8))
    {
LABEL_49:
      if (*(_QWORD *)(v4 + 48)
        || (*(_BYTE *)(v4 + 32) & 4) != 0
        || (v4 = HTTPNetConnection::updateForHeaders(v5, v4, v8), (*(_BYTE *)(v4 + 32) & 2) == 0))
      {
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
        if (!CoreStreamBase::_streamInterface_CanRead((CoreStreamBase *)(v8 + 16)))
        {
          if (!_CFHTTPReadStreamIsAtMark(v8) || (*(_BYTE *)(v4 + 32) & 4) != 0)
          {
            if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
              dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
            if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v8 + 16)) != 5)
            {
              if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
                dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
              if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v8 + 16)) == 7)
              {
                if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
                  dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
                *(_OWORD *)v11 = *(_OWORD *)(v8 + 72);
                (*(void (**)(HTTPNetConnection *, unsigned __int8 *))(*(_QWORD *)v5 + 64))(v5, v11);
              }
              return;
            }
            (*(void (**)(HTTPNetConnection *))(*(_QWORD *)v5 + 72))(v5);
          }
          HTTPNetStreamInfo::sendStreamIsComplete((HTTPNetStreamInfo *)v4);
          return;
        }
        if ((*(_BYTE *)(v4 + 32) & 4) != 0)
        {
          do
          {
            if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
              dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
            if (!CoreStreamBase::_streamInterface_CanRead((CoreStreamBase *)(v8 + 16)))
              break;
            if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
              dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
            v9 = CoreStreamBase::_streamInterface_Read((CoreStreamBase *)(v8 + 16), v11, 0x8000);
            if (v9 < 0)
            {
              if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
                dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
              v10 = *(_OWORD *)(v8 + 72);
              (*(void (**)(HTTPNetConnection *, __int128 *))(*(_QWORD *)v5 + 64))(v5, &v10);
              return;
            }
          }
          while (v9);
        }
        else
        {
          _CFReadStreamSignalEventDelayed();
        }
      }
    }
  }
}

void HTTPNetConnection::responseStreamCallback(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __CFRunLoopTimer *v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CoreStreamBase *v17;
  unsigned __int8 v18[32776];
  uint64_t v19;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v8 = v1;
  v19 = *MEMORY[0x1E0C80C00];
  v9 = *(__CFRunLoopTimer **)(v6 + 176);
  if (v9)
  {
    CFRunLoopTimerInvalidate(v9);
    CFRelease(*(CFTypeRef *)(v7 + 176));
    *(_QWORD *)(v7 + 176) = 0;
  }
  if (*(_QWORD *)(v8 + 216))
    (*(void (**)(uint64_t))(v8 + 192))(v8);
  if (HTTPNetConnection::handleReadEventsDuringRequestBodyTransmission((HTTPNetConnection *)v8, (void *)v7, v3))return;
  v10 = *(_DWORD *)(v7 + 32);
  if ((v10 & 0x20) == 0)
    HTTPNetConnection::prepareReception((HTTPNetConnection *)v8, v7, v5);
  if (!*(_QWORD *)(v7 + 48) && v3 != 32 && (*(_DWORD *)(v7 + 32) & 4) == 0)
    v7 = HTTPNetConnection::updateForHeaders((HTTPNetConnection *)v8, v7, v5);
  v11 = *(_DWORD *)(v7 + 32);
  if ((v11 & 0x100) == 0)
  {
    *(_DWORD *)(v7 + 32) = v11 | 0x100;
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (v5)
      v12 = v5 + 16;
    else
      v12 = 0;
    ++*(_QWORD *)(v12 + 80);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v12 + 24) + 32))(*(_QWORD *)(v12 + 24), 0x1EDCFA5D0);
    --*(_QWORD *)(v12 + 80);
    v11 = *(_DWORD *)(v7 + 32);
  }
  if ((v11 & 0x200) == 0)
  {
    *(_DWORD *)(v7 + 32) = v11 | 0x200;
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (v5)
      v13 = v5 + 16;
    else
      v13 = 0;
    ++*(_QWORD *)(v13 + 80);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v13 + 24) + 32))(*(_QWORD *)(v13 + 24), 0x1EDCFA250);
    --*(_QWORD *)(v13 + 80);
  }
  if (v3 <= 15)
  {
    if (v3 != 2)
    {
      if (v3 == 8)
      {
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
        v14 = v5 + 16;
        if (!v5)
          v14 = 0;
        *(_OWORD *)v18 = *(_OWORD *)(v14 + 56);
        HTTPNetStreamInfo::grabReadStreamProperties(v7, v5);
        v15 = *(_QWORD *)(v7 + 128);
        if (v15)
          (*(void (**)(uint64_t, unsigned __int8 *))(*(_QWORD *)v15 + 64))(v15, v18);
      }
      return;
    }
    if ((v10 & 0x20) == 0)
      return;
    if ((*(_BYTE *)(v7 + 32) & 4) != 0)
    {
      if (v5)
        v17 = (CoreStreamBase *)(v5 + 16);
      else
        v17 = 0;
      while (1)
      {
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
        if (!CoreStreamBase::_streamInterface_CanRead(v17))
          break;
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
        CoreStreamBase::_streamInterface_Read(v17, v18, 0x8000);
      }
      return;
    }
    goto LABEL_47;
  }
  if (v3 != 16)
  {
    if (v3 == 32 && (v10 & 0x20) != 0 && *(_QWORD *)(v7 + 128))
      HTTPNetStreamInfo::sendStreamIsComplete((HTTPNetStreamInfo *)v7);
    return;
  }
  v16 = *(_QWORD *)(v7 + 128);
  if (v16)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 72))(v16);
  if ((*(_BYTE *)(v7 + 32) & 4) == 0)
LABEL_47:
    _CFReadStreamSignalEventDelayed();
}

uint64_t HTTPNetConnection::requestStreamCallback(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NetConnection *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  _OWORD *v10;
  const __CFAllocator *v11;
  const void *v12;
  __int128 v13;
  __int128 v14;
  uint64_t (*v15)(uint64_t, uint64_t);
  void *v16;
  uint64_t v17;

  if (a4 == 16)
  {
    v14 = xmmword_1841E3A70;
    result = *(_QWORD *)(a2 + 128);
    if (!result)
      return result;
    return (*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)result + 64))(result, &v14);
  }
  if (a4 != 8)
  {
    if (a4 != 4)
      return result;
    v6 = (NetConnection *)result;
    result = HTTPNetConnection::transmitRequest(result);
    if (!(_DWORD)result)
      return result;
    result = *(_QWORD *)(a2 + 128);
    if (!result)
      return result;
    if (!DWORD2(v14))
    {
      v7 = *((_QWORD *)v6 + 16);
      if (v7)
        v8 = *(void **)(v7 + 8);
      else
        v8 = 0;
      return NetConnection::requestIsComplete(v6, v8);
    }
    return (*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)result + 64))(result, &v14);
  }
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  v9 = a3 + 16;
  if (!a3)
    v9 = 0;
  v13 = *(_OWORD *)(v9 + 56);
  v10 = *(_OWORD **)(a2 + 96);
  if (!v10)
  {
    v11 = CFGetAllocator(*(CFTypeRef *)(a2 + 8));
    v10 = CFAllocatorAllocate(v11, 48, 0);
    *v10 = 0u;
    v10[1] = 0u;
    v10[2] = 0u;
    v12 = CFGetAllocator(*(CFTypeRef *)(a2 + 8));
    *(_QWORD *)v10 = off_1E14E8090;
    *((_QWORD *)v10 + 1) = v12;
    *((_QWORD *)v10 + 2) = &off_1E14EFC70;
    if (v12)
      v12 = CFRetain(v12);
    *((_QWORD *)v10 + 4) = 0;
    *((_QWORD *)v10 + 5) = 0;
    *((_QWORD *)v10 + 3) = v12;
    *(_QWORD *)(a2 + 96) = v10;
  }
  *(_QWORD *)&v14 = MEMORY[0x1E0C809B0];
  *((_QWORD *)&v14 + 1) = 3221225472;
  v15 = ___ZN16CapturedSSLState14grabFromStreamEP17__CoreWriteStream_block_invoke;
  v16 = &__block_descriptor_40_e22__v16__0____CFString__8l;
  v17 = a3;
  CapturedSSLState::grabFromStream(v10, (uint64_t)&v14);
  result = *(_QWORD *)(a2 + 128);
  if (result)
    return (*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)result + 64))(result, &v13);
  return result;
}

uint64_t HTTPNetConnection::copySchedulingSetForRequest(HTTPNetConnection *this, _QWORD *a2)
{
  uint64_t v2;

  if (a2 && (v2 = a2[21]) != 0)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 88))(v2);
  else
    return 0;
}

uint64_t HTTPNetConnection::callTestFunc(HTTPNetConnection *this, uint64_t (*a2)(void *, HTTPNetConnection *, HTTPNetConnection *), void *a3)
{
  return a2(a3, this, this);
}

void HTTPNetConnection::closeConnectionStreams(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  __CFReadStream *v8;
  uint64_t v9;
  __CFWriteStream *v10;
  BOOL v11;
  uint64_t v12;

  if (a2 && *(_BYTE *)(a1 + 269))
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (a3)
      v7 = a3 + 16;
    else
      v7 = 0;
    ++*(_QWORD *)(v7 + 80);
    v8 = (__CFReadStream *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v7 + 24) + 40))(*(_QWORD *)(v7 + 24), 0x1EDCFE460);
    --*(_QWORD *)(v7 + 80);
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    if (a4)
      v9 = a4 + 16;
    else
      v9 = 0;
    ++*(_QWORD *)(v9 + 80);
    a1 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v9 + 24) + 40))(*(_QWORD *)(v9 + 24), 0x1EDCFE460);
    v10 = (__CFWriteStream *)a1;
    --*(_QWORD *)(v9 + 80);
    if (v8)
      v11 = a1 == 0;
    else
      v11 = 1;
    if (!v11)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      ++*(_QWORD *)(v7 + 80);
      (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v7 + 24) + 32))(*(_QWORD *)(v7 + 24), 0x1EDCFE460, 0);
      --*(_QWORD *)(v7 + 80);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      ++*(_QWORD *)(v9 + 80);
      (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v9 + 24) + 32))(*(_QWORD *)(v9 + 24), 0x1EDCFE460, 0);
      --*(_QWORD *)(v9 + 80);
      v12 = *(_QWORD *)(a2 + 120);
      if (v12)
      {
        (*(void (**)(uint64_t, __CFReadStream *, __CFWriteStream *))(*(_QWORD *)v12 + 264))(v12, v8, v10);
      }
      else
      {
        CFReadStreamClose(v8);
        CFWriteStreamClose(v10);
      }
      CFRelease(v8);
LABEL_30:
      CFRelease(v10);
      goto LABEL_31;
    }
    if (v8)
      CFRelease(v8);
    if (v10)
      goto LABEL_30;
  }
LABEL_31:
  NetConnection::closeConnectionStreams(a1, a2, a3, a4);
}

uint64_t HTTPNetConnection::copyReqestDebugDesc(HTTPNetConnection *this, void *a2)
{
  return (*(uint64_t (**)(void *))(*(_QWORD *)a2 + 104))(a2);
}

uint64_t HTTPNetConnection::cleanAbortRequestTransmission(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  CoreSchedulingSet *v4;

  v1 = *(_QWORD *)(this + 128);
  if (v1)
  {
    v2 = *(_QWORD *)(v1 + 8);
    if (v2)
    {
      v3 = this;
      *(_WORD *)(this + 88) &= ~0x20u;
      if (v1 == *(_QWORD *)(this + 136))
        *(_QWORD *)(this + 136) = 0;
      *(_DWORD *)(v2 + 32) |= 8u;
      v4 = *(CoreSchedulingSet **)(v2 + 168);
      if (v4)
        CoreSchedulingSet::unscheduleStream(v4, *(__CFReadStream **)(v2 + 8));
      CFReadStreamSetClient(*(CFReadStreamRef *)(v2 + 8), 0, 0, 0);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v3 + 120))(v3, v2, 5, 0);
    }
  }
  return this;
}

uint64_t HTTPNetConnection::sentBytes(uint64_t this, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*(_BYTE *)(this + 268))
  {
    v3 = this;
    v4 = *(_QWORD *)(this + 96);
    if (v4)
      this = pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
    v5 = *(_QWORD *)(v3 + 128);
    if (v5)
      v6 = *(_QWORD *)(v5 + 8);
    else
      v6 = 0;
    v7 = *(_QWORD *)(v3 + 96);
    if (v7)
      this = pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
    if (v6)
      *(_QWORD *)(v6 + 104) += a2;
  }
  return this;
}

uint64_t HTTPNetConnection::receivedBytes(uint64_t this, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*(_BYTE *)(this + 268))
  {
    v3 = this;
    v4 = *(_QWORD *)(this + 96);
    if (v4)
      this = pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
    v5 = *(_QWORD *)(v3 + 136);
    if (v5)
      v6 = *(_QWORD *)(v5 + 8);
    else
      v6 = 0;
    v7 = *(_QWORD *)(v3 + 96);
    if (v7)
      this = pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
    if (v6)
      *(_QWORD *)(v6 + 112) += a2;
  }
  return this;
}

void HTTPNetConnection::setProxy(_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  std::__shared_weak_count *v18;

  v3 = *a2;
  if (a1[35] == v3)
    return;
  v5 = a1 + 35;
  std::shared_ptr<__CFString const>::operator=[abi:nn180100](a1 + 35, v3, a2[1]);
  if (!*v5)
    return;
  v6 = a1[34];
  v7 = (std::__shared_weak_count *)a1[36];
  v17 = *v5;
  v18 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v6 + 56))(v6, &v17);
  v10 = v18;
  if (v18)
  {
    v11 = (unint64_t *)&v18->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = a1[12];
  if (!v13)
  {
    v15 = a1[18];
    if (!v15)
      return;
    goto LABEL_17;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v13 + 8));
  v14 = a1[12];
  v15 = a1[18];
  if (v14)
    pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8));
  if (v15)
  {
LABEL_17:
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    v16 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v5 + 56))(*v5);
    if (v16 == 3)
    {
      HTTPWriteFilter::prepareHTTPSProxy((HTTPWriteFilter *)(v15 + 16));
    }
    else if (v16 == 2)
    {
      *(_WORD *)(v15 + 240) |= 0x200u;
    }
  }
}

void sub_1840426F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t HTTPNetConnection::getProxy@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(this + 288);
  *a2 = *(_QWORD *)(this + 280);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

uint64_t HTTPNetConnection::transmitRequest(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  const void *v11;
  const void *v12;
  CFTypeID v13;
  const void *v14;
  __CFReadStream *v15;
  uint64_t result;
  int v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  const __CFDictionary **v21;
  unsigned int v22;
  char v23;
  char v24;
  void *v25;
  __CFReadStream *v26;
  CoreSchedulingSet *v27;
  uint64_t Status;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  CFIndex ResponseStatusCode;
  char v34;
  uint64_t v35;
  __CFHTTPMessage *v36;
  __CFHTTPMessage *v37;
  __CFHTTPMessage *v38;
  CFTypeRef v39;
  _BYTE *updated;
  const __CFData *v41;
  CFIndex Length;
  const unsigned __int8 *p_clientContext;
  uint64_t v44;
  uint64_t v45;
  int v46;
  CFIndex v47;
  int v48;
  int v49;
  const void *v50;
  int v51;
  const __CFAllocator *v52;
  CFDataRef v53;
  const __CFAllocator *v54;
  CFDataRef v55;
  char v56;
  __CFReadStream *v57;
  char v58;
  CFStreamClientContext clientContext;
  uint64_t v60;

  v1 = MEMORY[0x1E0C80A78](a1);
  v60 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)(v4 + 8) = 0;
  if ((*(_BYTE *)(v2 + 32) & 1) != 0)
    return 1;
  v5 = v4;
  v6 = v3;
  v7 = v2;
  v8 = v1;
  v9 = &unk_1EDD00000;
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  v10 = v6 ? v6 + 16 : 0;
  ++*(_QWORD *)(v10 + 80);
  v11 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v10 + 24) + 40))(*(_QWORD *)(v10 + 24), 0x1EDCFE3F0);
  --*(_QWORD *)(v10 + 80);
  if (v11)
  {
    v12 = v11;
    v13 = CFGetTypeID(v11);
    if (v13 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      LOWORD(clientContext.version) = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&clientContext, 2u);
    }
    v14 = (const void *)*MEMORY[0x1E0C9AE50];
    CFRelease(v12);
    if (v14 == v12)
      return 1;
  }
  v15 = *(__CFReadStream **)(v7 + 56);
  if (!v15)
    goto LABEL_16;
  if (CFReadStreamGetStatus(v15) == kCFStreamStatusNotOpen)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    if (CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)v10))
    {
      v26 = *(__CFReadStream **)(v7 + 56);
      if (!v26)
        goto LABEL_16;
      if (!*(_BYTE *)(v7 + 64))
      {
        clientContext.version = 0;
        clientContext.info = (void *)v7;
        memset(&clientContext.retain, 0, 24);
        CFReadStreamSetClient(v26, 0x1AuLL, (CFReadStreamClientCallBack)HTTPNetStreamInfo::_httpRequestPayloadCallBack, &clientContext);
        v27 = *(CoreSchedulingSet **)(v7 + 168);
        if (v27)
          CoreSchedulingSet::scheduleStream(v27, *(__CFReadStream **)(v7 + 56));
        CFReadStreamOpen(*(CFReadStreamRef *)(v7 + 56));
      }
    }
  }
  if (*(_QWORD *)(v7 + 56) && !*(_BYTE *)(v7 + 64))
  {
    v18 = 0;
    v17 = 1;
    goto LABEL_18;
  }
LABEL_16:
  result = HTTPNetConnection::isStreamReadyForWrite((HTTPNetConnection *)v8, v6, (CFHTTPMessageRef *)v7, (_QWORD *)v5);
  if (!(_DWORD)result)
    return result;
  v17 = 0;
  v18 = 1;
LABEL_18:
  v19 = *(_QWORD *)(v7 + 40);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v20 = v19 + 16;
  if (!v19)
    v20 = 0;
  v21 = *(const __CFDictionary ***)(v20 + 72);
  if (v21)
  {
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
    v22 = HTTPAuthentication::isKerberosThePreferredAuthScheme(v21[19]);
  }
  else
  {
    v22 = 0;
  }
  if (v22)
    v23 = 1;
  else
    v23 = v18;
  if ((v23 & 1) != 0)
  {
    if (!v17)
    {
      v24 = 0;
      goto LABEL_55;
    }
  }
  else
  {
    v25 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 80))(v8);
    if (_CFHTTPAuthenticationIsFirstNTLMTransaction((_CFHTTPAuthentication *)v21, v25))
    {
      result = HTTPNetConnection::isStreamReadyForWrite((HTTPNetConnection *)v8, v6, (CFHTTPMessageRef *)v7, (_QWORD *)v5);
      if (!(_DWORD)result)
        return result;
      v24 = 1;
      goto LABEL_55;
    }
  }
  if (CFReadStreamGetStatus(*(CFReadStreamRef *)(v7 + 56)) == kCFStreamStatusError)
  {
    v24 = 0;
    *(CFStreamError *)v5 = CFReadStreamGetError((CFReadStreamRef)*(_QWORD *)(v7 + 56));
  }
  else
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    Status = CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)v10);
    if (Status == 5)
    {
      v24 = 0;
      *(_QWORD *)v5 = 4;
      *(_DWORD *)(v5 + 8) = -1;
    }
    else
    {
      if (Status != 7)
      {
        v24 = 0;
        v29 = 0;
        goto LABEL_56;
      }
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      v24 = 0;
      *(_OWORD *)v5 = *(_OWORD *)(v10 + 56);
    }
  }
LABEL_55:
  v29 = 1;
LABEL_56:
  if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(v8 + 272) + 88))(*(_QWORD *)(v8 + 272)) == 3)
  {
    v30 = *(_QWORD *)(v8 + 96);
    if (v30)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v30 + 8));
      v31 = *(_QWORD *)(v8 + 96);
      v32 = *(_QWORD *)(v8 + 144);
      if (v31)
        pthread_mutex_unlock((pthread_mutex_t *)(v31 + 8));
    }
    else
    {
      v32 = *(_QWORD *)(v8 + 144);
    }
    v34 = v24;
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    if (v32)
      v35 = v32 + 16;
    else
      v35 = 0;
    ++*(_QWORD *)(v35 + 80);
    v36 = (__CFHTTPMessage *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v35 + 24) + 40))(*(_QWORD *)(v35 + 24), 0x1EDD00488);
    --*(_QWORD *)(v35 + 80);
    if (v36)
    {
      v37 = v36;
      ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v36);
      v24 = v34;
      v9 = (_QWORD *)&unk_1EDD00000;
      if (ResponseStatusCode == 407)
      {
        v38 = *(__CFHTTPMessage **)(v7 + 48);
        if (v38 == v37)
          goto LABEL_74;
        if (v38)
          CFRelease(v38);
        v39 = CFRetain(v37);
        *(_QWORD *)(v7 + 48) = v39;
        if (v39)
LABEL_74:
          CFReadStreamSignalEvent();
        *(_BYTE *)(v8 + 250) = 0;
        updated = (_BYTE *)HTTPNetConnection::updateAuth((HTTPNetConnection *)v8, (CFHTTPMessageRef *)v7, v37);
        v29 = 1;
        if (updated && updated != (_BYTE *)v7 && (updated[32] & 4) != 0)
          NetConnection::responseIsComplete((NetConnection *)v8, updated);
      }
      CFRelease(v37);
      if (v29)
        goto LABEL_129;
    }
    else
    {
      ResponseStatusCode = 0;
      v24 = v34;
      v9 = &unk_1EDD00000;
      if (v29)
        goto LABEL_129;
    }
  }
  else
  {
    ResponseStatusCode = 0;
    if (v29)
      goto LABEL_129;
  }
  v41 = *(const __CFData **)(v7 + 80);
  if (!v41)
  {
    if (!CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)(v7 + 56)))
      goto LABEL_127;
    if (v9[444] != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    if (!CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)v10))
      goto LABEL_127;
    v41 = *(const __CFData **)(v7 + 80);
    if (!v41)
    {
      v47 = CFReadStreamRead(*(CFReadStreamRef *)(v7 + 56), (UInt8 *)&clientContext, 0x8000);
      Length = v47;
      if (v47 < 0)
      {
        *(CFStreamError *)v5 = CFReadStreamGetError((CFReadStreamRef)*(_QWORD *)(v7 + 56));
        v46 = 1;
        p_clientContext = (const unsigned __int8 *)&clientContext;
        goto LABEL_114;
      }
      if (!v47)
      {
        v50 = *(const void **)(v7 + 80);
        if (!v50)
          goto LABEL_129;
        v46 = 1;
        goto LABEL_119;
      }
      p_clientContext = (const unsigned __int8 *)&clientContext;
      goto LABEL_84;
    }
  }
  Length = CFDataGetLength(v41);
  p_clientContext = CFDataGetBytePtr(*(CFDataRef *)(v7 + 80));
  if (Length >= 1)
  {
LABEL_84:
    if (v9[444] != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    if (CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)v10))
    {
      v58 = v24;
      if (v9[444] != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      v44 = CoreStreamBase::_streamInterface_Write((CoreStreamBase *)v10, p_clientContext, Length);
      if (*(_QWORD *)(v8 + 216))
        (*(void (**)(uint64_t))(v8 + 192))(v8);
      v45 = *(_QWORD *)(v7 + 120);
      if (v45)
        URLProtocol::uploadActivityOccurred((URLProtocol *)(v45 - 176), v44);
      if (v44 < 0)
      {
        if (v9[444] != -1)
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
        v24 = v58;
        *(_OWORD *)v5 = *(_OWORD *)(v10 + 56);
        v46 = 1;
      }
      else
      {
        if (v44)
        {
          v46 = 0;
          Length -= v44;
          p_clientContext += v44;
          *(_QWORD *)(v7 + 88) += v44;
        }
        else
        {
          v48 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v8 + 272) + 88))(*(_QWORD *)(v8 + 272));
          *(_QWORD *)v5 = 4;
          if (v48 == 1)
            v49 = -4;
          else
            v49 = -1;
          *(_DWORD *)(v5 + 8) = v49;
          v46 = 1;
        }
        v24 = v58;
      }
      goto LABEL_114;
    }
  }
  v46 = 0;
LABEL_114:
  v50 = *(const void **)(v7 + 80);
  if (!v50)
  {
    if (Length >= 1)
    {
      v52 = CFGetAllocator(*(CFTypeRef *)(v7 + 40));
      v53 = CFDataCreate(v52, p_clientContext, Length);
      HTTPNetStreamInfo::setRequestFragment((HTTPNetStreamInfo *)v7, v53);
      if (v53)
        CFRelease(v53);
    }
LABEL_123:
    if (v46)
      goto LABEL_129;
    goto LABEL_127;
  }
  if (Length < 1)
    v51 = 1;
  else
    v51 = v46;
  if (v51 == 1)
  {
LABEL_119:
    CFRelease(v50);
    *(_QWORD *)(v7 + 80) = 0;
    goto LABEL_123;
  }
  v54 = CFGetAllocator(*(CFTypeRef *)(v7 + 40));
  v55 = CFDataCreate(v54, p_clientContext, Length);
  HTTPNetStreamInfo::setRequestFragment((HTTPNetStreamInfo *)v7, v55);
  if (v55)
    CFRelease(v55);
LABEL_127:
  if (*(_QWORD *)(v7 + 80) || CFReadStreamGetStatus(*(CFReadStreamRef *)(v7 + 56)) < kCFStreamStatusAtEnd)
  {
    v57 = *(__CFReadStream **)(v7 + 56);
    if (v57 && !*(_BYTE *)(v7 + 64))
      CFReadStreamHasBytesAvailable(v57);
    if (v9[444] != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)v10);
    return 0;
  }
LABEL_129:
  if ((*(_BYTE *)(v7 + 33) & 8) != 0)
    return 1;
  if (v22)
    v56 = 1;
  else
    v56 = v24;
  result = 1;
  if ((v56 & 1) == 0 && ResponseStatusCode != 407)
  {
    HTTPNetStreamInfo::closeRequestResources((HTTPNetStreamInfo *)v7);
    *(_DWORD *)(v7 + 32) |= 1u;
    return 1;
  }
  return result;
}

uint64_t HTTPNetConnection::isStreamReadyForWrite(HTTPNetConnection *a1, uint64_t a2, CFHTTPMessageRef *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  __CFHTTPMessage *v12;
  uint64_t v13;
  void *v14;

  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  if (a2)
    v8 = a2 + 16;
  else
    v8 = 0;
  if (CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)v8))
    return 1;
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)v8) != 7)
    return 0;
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  v11 = *(_QWORD *)(v8 + 56);
  v10 = *(_QWORD *)(v8 + 64);
  *a4 = v11;
  a4[1] = v10;
  result = 1;
  if (v11 == 4 && (v10 + 2097) <= 1)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    ++*(_QWORD *)(v8 + 80);
    v12 = (__CFHTTPMessage *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v8 + 24) + 40))(*(_QWORD *)(v8 + 24), 0x1EDD00488);
    --*(_QWORD *)(v8 + 80);
    HTTPNetConnection::updateAuth(a1, a3, v12);
    if (v12)
      CFRelease(v12);
    v13 = *((_QWORD *)a1 + 16);
    if (v13)
      v14 = *(void **)(v13 + 8);
    else
      v14 = 0;
    NetConnection::requestIsComplete(a1, v14);
    (*(void (**)(HTTPNetConnection *))(*(_QWORD *)a1 + 72))(a1);
    return 1;
  }
  return result;
}

uint64_t HTTPNetConnection::updateAuth(HTTPNetConnection *this, CFHTTPMessageRef *a2, __CFHTTPMessage *a3)
{
  CFURLRef v6;
  uint64_t v7;
  const void *v8;
  uint64_t v9;
  const __CFAllocator *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFString *v16;
  const __CFDictionary *v17;
  const __CFDictionary *Value;
  const __CFDictionary *v19;
  const void *v20;
  const void *v21;
  CFTypeRef cf;

  v6 = CFHTTPMessageCopyRequestURL(a2[5]);
  _CFHTTPMessageSetResponseURL((uint64_t)a3, v6);
  if (CFHTTPMessageGetResponseStatusCode(a3) == 407)
  {
    v7 = *((_QWORD *)this + 35);
    if (v7)
    {
      (*(void (**)(CFTypeRef *__return_ptr))(*(_QWORD *)v7 + 48))(&cf);
      v8 = cf;
      if (!cf)
        goto LABEL_5;
      goto LABEL_4;
    }
    v11 = (const __CFAllocator *)*((_QWORD *)this + 1);
    v12 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 34) + 88))(*((_QWORD *)this + 34));
    v13 = **((_QWORD **)this + 34);
    if (v12 == 2)
    {
      v14 = (*(uint64_t (**)(void))(v13 + 72))();
      v15 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 34) + 80))(*((_QWORD *)this + 34));
      v16 = CFStringCreateWithFormat(v11, 0, CFSTR("http://%@:%d"), v14, v15);
      if (!v16)
        goto LABEL_5;
    }
    else
    {
      if ((*(unsigned int (**)(void))(v13 + 88))() != 3)
        goto LABEL_5;
      if (!(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 34) + 64))(*((_QWORD *)this + 34)))
        goto LABEL_5;
      v17 = (const __CFDictionary *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 34) + 64))(*((_QWORD *)this + 34));
      Value = (const __CFDictionary *)CFDictionaryGetValue(v17, &unk_1EDD003E0);
      v19 = Value;
      if (!Value)
        goto LABEL_5;
      v20 = CFDictionaryGetValue(Value, &unk_1EDD00418);
      v21 = CFDictionaryGetValue(v19, &unk_1EDD00450);
      if (!v20)
        goto LABEL_5;
      if (!v21)
        goto LABEL_5;
      v16 = CFStringCreateWithFormat(v11, 0, CFSTR("https://%@:%@"), v20, v21);
      if (!v16)
        goto LABEL_5;
    }
    v8 = CFURLCreateWithString(v11, v16, 0);
    CFRelease(v16);
    if (v8)
    {
LABEL_4:
      _CFHTTPMessageSetResponseProxyURL((uint64_t)a3, v8);
      CFRelease(v8);
    }
  }
LABEL_5:
  v9 = (*(uint64_t (**)(HTTPNetConnection *, CFHTTPMessageRef *, __CFHTTPMessage *))(*(_QWORD *)this + 272))(this, a2, a3);
  if (v6)
    CFRelease(v6);
  return v9;
}

void sub_18404333C(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;

  CFRelease(v2);
  if (v1)
    CFRelease(v1);
  _Unwind_Resume(a1);
}

CFTypeRef HTTPNetStreamInfo::setRequestFragment(HTTPNetStreamInfo *this, CFTypeRef cf)
{
  CFTypeRef result;

  result = (CFTypeRef)*((_QWORD *)this + 10);
  if (result != cf)
  {
    if (result)
      CFRelease(result);
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *((_QWORD *)this + 10) = result;
  }
  return result;
}

uint64_t HTTPNetConnection::handleReadEventsDuringRequestBodyTransmission(HTTPNetConnection *this, void *a2, uint64_t a3)
{
  unsigned int v6;
  __CFRunLoopTimer *v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  _BYTE *v17;
  _BOOL4 v18;
  _BOOL4 v19;
  __CFRunLoopTimer *v20;
  const void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v29;
  _BYTE *v31;
  CFStreamError v32;

  if (!*((_BYTE *)this + 264))
  {
    v6 = *((unsigned __int8 *)this + 265);
    if (!*((_BYTE *)this + 265))
      goto LABEL_66;
  }
  if (a3 != 2 && a3 != 16)
  {
    if (a3 == 64)
    {
      *((_BYTE *)this + 264) = 0;
      v7 = (__CFRunLoopTimer *)*((_QWORD *)this + 32);
      if (v7)
      {
        CFRunLoopTimerInvalidate(v7);
        v8 = (const void *)*((_QWORD *)this + 32);
        *((_QWORD *)this + 32) = 0;
        if (v8)
          CFRelease(v8);
      }
      v9 = *((_QWORD *)this + 12);
      if (v9)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
        v10 = *((_QWORD *)this + 12);
        v11 = *((_QWORD *)this + 18);
        if (v10)
          pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8));
        if (!v11)
          goto LABEL_52;
        goto LABEL_49;
      }
      v11 = *((_QWORD *)this + 18);
      if (v11)
      {
LABEL_49:
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
        ++*(_QWORD *)(v11 + 96);
        (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v11 + 40) + 32))(*(_QWORD *)(v11 + 40), 0x1EDCFE498, 0);
        --*(_QWORD *)(v11 + 96);
        (*(void (**)(HTTPNetConnection *, void *))(*(_QWORD *)this + 128))(this, a2);
      }
    }
LABEL_52:
    v6 = 0;
    goto LABEL_66;
  }
  v12 = *((_QWORD *)this + 12);
  if (v12)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v12 + 8));
    v13 = *((_QWORD *)this + 12);
    v14 = *((_QWORD *)this + 19);
    if (v13)
      pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8));
  }
  else
  {
    v14 = *((_QWORD *)this + 19);
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  if (v14)
    v15 = v14 + 16;
  else
    v15 = 0;
  ++*(_QWORD *)(v15 + 80);
  v16 = (_BYTE *)(*(uint64_t (**)(_QWORD, __CFString *))(**(_QWORD **)(v15 + 24) + 40))(*(_QWORD *)(v15 + 24), CFSTR("kCFStreamPropertyHTTPResponseHeader"));
  --*(_QWORD *)(v15 + 80);
  if (v16)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    {
      v31 = v16;
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v16 = v31;
    }
    v17 = v16 + 16;
    if (!v16[40])
      v17 = 0;
    if (*((_QWORD *)v17 + 11) || *((int *)v17 + 14) < 2)
    {
      v18 = 0;
    }
    else
    {
      v29 = *((_DWORD *)v17 + 32);
      v18 = v29 != 407 && (v29 - 400) < 0xC8;
    }
    CFRelease(v16);
  }
  else
  {
    v18 = 0;
  }
  if (*((_BYTE *)this + 264))
  {
    v18 = 1;
    v19 = 0;
  }
  else
  {
    v19 = v18;
  }
  *((_BYTE *)this + 264) = 0;
  v20 = (__CFRunLoopTimer *)*((_QWORD *)this + 32);
  if (v20)
  {
    CFRunLoopTimerInvalidate(v20);
    v21 = (const void *)*((_QWORD *)this + 32);
    *((_QWORD *)this + 32) = 0;
    if (v21)
      CFRelease(v21);
  }
  if (v18)
  {
    NetConnection::requestIsComplete(this, a2);
    if (v19)
      (*(void (**)(HTTPNetConnection *))(*(_QWORD *)this + 288))(this);
    v22 = *((_QWORD *)this + 12);
    if (v22)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v22 + 8));
      v23 = *((_QWORD *)this + 12);
      v24 = *((_QWORD *)this + 18);
      if (v23)
      {
        pthread_mutex_unlock((pthread_mutex_t *)(v23 + 8));
        v25 = *((_QWORD *)this + 12);
        if (v25)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v25 + 8));
          v26 = *((_QWORD *)this + 12);
          v27 = *((_QWORD *)this + 19);
          if (v26)
            pthread_mutex_unlock((pthread_mutex_t *)(v26 + 8));
          goto LABEL_55;
        }
      }
    }
    else
    {
      v24 = *((_QWORD *)this + 18);
    }
    v27 = *((_QWORD *)this + 19);
LABEL_55:
    if (v24)
    {
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      ++*(_QWORD *)(v24 + 96);
      (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v24 + 40) + 32))(*(_QWORD *)(v24 + 40), 0x1EDCFE498, 0);
      --*(_QWORD *)(v24 + 96);
    }
    if (v27)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      ++*(_QWORD *)(v27 + 96);
      (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v27 + 40) + 32))(*(_QWORD *)(v27 + 40), 0x1EDCFE498, 0);
      --*(_QWORD *)(v27 + 96);
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      v32.domain = 0;
      *(_QWORD *)&v32.error = 0;
      CoreStreamBase::_signalEvent((CoreStreamBase *)(v27 + 16), 2, v32, 0);
    }
    goto LABEL_65;
  }
  *((_BYTE *)this + 266) = 1;
LABEL_65:
  v6 = !v18;
LABEL_66:
  if (a3 == 64)
    return 1;
  else
    return v6;
}

void HTTPNetConnection::prepareReception(HTTPNetConnection *a1, uint64_t a2, uint64_t a3)
{
  CoreStreamBase *v6;
  int v7;
  uint64_t v8;
  const __CFAllocator *v9;
  Boolean IsRequest;
  CFHTTPMessageRef Empty;
  const void *v12;
  int v13;
  int v14;
  const void *v15;
  int v16;
  const void *v17;
  const void *v18;
  CFStringRef v19;
  CFStringRef v20;
  uint64_t v21;
  CoreStreamBase *v22;
  uint64_t v23;
  CFStreamError v24;
  uint64_t v25;
  CFTypeRef cf;
  uint64_t v27;
  CFStreamError v28;
  CFStreamError v29;
  CFStreamError v30;

  if (*((_BYTE *)a1 + 266))
  {
    *((_BYTE *)a1 + 266) = 0;
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (a3)
      v6 = (CoreStreamBase *)(a3 + 16);
    else
      v6 = 0;
    v28.domain = 0;
    *(_QWORD *)&v28.error = 0;
    CoreStreamBase::_signalEvent(v6, 2, v28, 0);
  }
  v7 = *(_DWORD *)(a2 + 32);
  if ((v7 & 0x20) != 0)
    return;
  *(_DWORD *)(a2 + 32) = v7 | 0x20;
  if (a3)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    v8 = a3 + 16;
  }
  else
  {
    v8 = 0;
  }
  HIDWORD(v27) = 0;
  pthread_mutex_lock((pthread_mutex_t *)(v8 + 136));
  if ((~*(unsigned __int16 *)(v8 + 232) & 0x201) == 0)
  {
    v9 = CFGetAllocator(*(CFTypeRef *)(v8 + 224));
    IsRequest = CFHTTPMessageIsRequest(*(CFHTTPMessageRef *)(v8 + 224));
    Empty = CFHTTPMessageCreateEmpty(v9, IsRequest);
    v12 = *(const void **)(v8 + 224);
    if (v12)
      CFRelease(v12);
    v13 = *(unsigned __int16 *)(v8 + 232);
    *(_QWORD *)(v8 + 224) = Empty;
    *(_OWORD *)(v8 + 240) = xmmword_1841E3800;
    v14 = v13 | (*(unsigned __int8 *)(v8 + 234) << 16);
    *(_WORD *)(v8 + 232) = v14 & 0x12DA;
    *(_BYTE *)(v8 + 234) = (v14 & 0xFFFD12DA) >> 16;
    if ((v14 & 0x40) != 0)
    {
      v15 = *(const void **)(v8 + 208);
      if (v15)
      {
        v16 = v14 & 0xFD129A;
        *(_WORD *)(v8 + 232) = v16;
        *(_BYTE *)(v8 + 234) = BYTE2(v16);
        CFRetain(v15);
        CFReadStreamSetProperty(*(CFReadStreamRef *)(v8 + 208), CFSTR("_kCFStreamPropertyLargeDownload"), (CFTypeRef)*MEMORY[0x1E0C9AE40]);
        v17 = *(const void **)(v8 + 208);
        if (v17)
          CFRelease(v17);
      }
    }
  }
  v18 = *(const void **)(v8 + 208);
  if (v18 && !*(_BYTE *)(v8 + 216))
  {
    cf = CFRetain(v18);
    if (HTTPReadFilter::canReadNoSignal(v8))
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      v24.domain = 0;
      *(_QWORD *)&v24.error = 0;
      v25 = 2;
    }
    else
    {
      if (CFReadStreamGetStatus(*(CFReadStreamRef *)(v8 + 208)) != kCFStreamStatusAtEnd
        || *(_QWORD *)(v8 + 248) == *(_QWORD *)(v8 + 240) && (*(_WORD *)(v8 + 232) & 0x20) == 0)
      {
        goto LABEL_61;
      }
      LODWORD(v27) = -4;
      v24.domain = 4;
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
        v24.domain = 4;
      }
      *(_QWORD *)&v24.error = v27;
      v25 = 8;
    }
    CoreStreamBase::_signalEvent((CoreStreamBase *)v8, v25, v24, 0);
LABEL_61:
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    *(_QWORD *)(v8 + 40) &= ~0x20uLL;
    if (cf)
      CFRelease(cf);
    goto LABEL_26;
  }
  LODWORD(v27) = -4;
  *(_WORD *)(v8 + 232) |= 0x4000u;
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  *(_QWORD *)&v29.error = v27;
  v29.domain = 4;
  CoreStreamBase::_signalEvent((CoreStreamBase *)v8, 8, v29, 0);
LABEL_26:
  pthread_mutex_unlock((pthread_mutex_t *)(v8 + 136));
  v19 = CFHTTPMessageCopyRequestMethod(*(CFHTTPMessageRef *)(a2 + 40));
  if (v19)
  {
    v20 = v19;
    if (CFEqual(v19, &unk_1EDCFE150))
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      if (a3)
        v21 = a3 + 16;
      else
        v21 = 0;
      ++*(_QWORD *)(v21 + 80);
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v21 + 24) + 32))(*(_QWORD *)(v21 + 24), 0x1EDCFE508);
      --*(_QWORD *)(v21 + 80);
    }
    CFRelease(v20);
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  if (a3)
    v22 = (CoreStreamBase *)(a3 + 16);
  else
    v22 = 0;
  if (CoreStreamBase::_streamInterface_CanRead(v22))
  {
    if (!*(_QWORD *)(a2 + 48))
      HTTPNetConnection::updateForHeaders(a1, a2, a3);
    v23 = 2;
  }
  else
  {
    if (!_CFHTTPReadStreamIsAtMark(a3))
      return;
    v23 = 32;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  v30.domain = 0;
  *(_QWORD *)&v30.error = 0;
  CoreStreamBase::_signalEvent(v22, v23, v30, 0);
}

void sub_184043CCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t HTTPNetConnection::updateForHeaders(HTTPNetConnection *a1, uint64_t updated, uint64_t a3)
{
  __CFHTTPMessage *v6;
  __CFHTTPMessage *v7;
  __CFHTTPMessage *v8;
  CFTypeRef v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  CFStringRef v16;
  CFStringRef v17;
  BOOL v18;
  char v19;
  const __CFString *v20;
  uint8_t buf[16];

  if (a3)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    ++*(_QWORD *)(a3 + 96);
    v6 = (__CFHTTPMessage *)(*(uint64_t (**)(_QWORD, __CFString *))(**(_QWORD **)(a3 + 40) + 40))(*(_QWORD *)(a3 + 40), CFSTR("kCFStreamPropertyHTTPResponseHeader"));
    v7 = v6;
    --*(_QWORD *)(a3 + 96);
    if (v6)
    {
      if (!canKeepAlive(v6, *(__CFHTTPMessage **)(updated + 40)))
        (*(void (**)(HTTPNetConnection *))(*(_QWORD *)a1 + 72))(a1);
      updated = HTTPNetConnection::updateAuth(a1, (CFHTTPMessageRef *)updated, v7);
    }
    else
    {
      (*(void (**)(HTTPNetConnection *))(*(_QWORD *)a1 + 72))(a1);
    }
    v8 = *(__CFHTTPMessage **)(updated + 48);
    v9 = v7;
    if (v8 != v7)
    {
      if (v8)
        CFRelease(*(CFTypeRef *)(updated + 48));
      if (v7)
        v9 = CFRetain(v7);
      else
        v9 = 0;
      *(_QWORD *)(updated + 48) = v9;
    }
    if (v9)
      CFReadStreamSignalEvent();
    if (v7)
      CFRelease(v7);
    v10 = *(_QWORD *)(updated + 48);
    if (v10)
    {
      v11 = *(_QWORD *)(updated + 40);
      if (v11)
      {
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        v12 = *(unsigned __int8 *)(v10 + 40);
        if (*(_BYTE *)(v10 + 40))
          v13 = v10 + 16;
        else
          v13 = 0;
        if (*(_BYTE *)(v11 + 40))
          v14 = 0;
        else
          v14 = v11 + 16;
        if (v12 && !*(_BYTE *)(v11 + 40) && !*(_QWORD *)(v13 + 88) && *(int *)(v13 + 56) >= 2)
        {
          v15 = *(_DWORD *)(v13 + 128);
          v16 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)v13, 0x11D1D2CFu);
          v17 = v16;
          if (v16)
            CFRelease(v16);
          if (v17)
            v18 = 0;
          else
            v18 = v15 == 204;
          v19 = v18;
          if (v15 == 304
            || (v15 - 100) < 0x64
            || (v19 & 1) != 0
            || ((v20 = *(const __CFString **)(v14 + 152)) != 0
             || os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
             && (*(_WORD *)buf = 0,
                 _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u), (v20 = *(const __CFString **)(v14 + 152)) != 0))&& CFStringCompare(v20, (CFStringRef)&gConstantCFStringValueTable[2597], 0) == kCFCompareEqualTo)
          {
            *(_DWORD *)(updated + 32) |= 2u;
            HTTPNetStreamInfo::sendStreamIsComplete((HTTPNetStreamInfo *)updated);
          }
        }
      }
    }
  }
  else
  {
    CFLog();
  }
  return updated;
}

uint64_t HTTPNetConnection::_OneHundredContinueTimeout(HTTPNetConnection *this, __CFRunLoopTimer *a2, void *a3)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v4 = *((_QWORD *)a2 + 12);
  if (!v4)
  {
    v7 = *((_QWORD *)a2 + 18);
LABEL_7:
    v10 = *((_QWORD *)a2 + 19);
    goto LABEL_8;
  }
  result = pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  v6 = *((_QWORD *)a2 + 12);
  v7 = *((_QWORD *)a2 + 18);
  if (!v6)
    goto LABEL_7;
  result = pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  v8 = *((_QWORD *)a2 + 12);
  if (!v8)
    goto LABEL_7;
  result = pthread_mutex_lock((pthread_mutex_t *)(v8 + 8));
  v9 = *((_QWORD *)a2 + 12);
  v10 = *((_QWORD *)a2 + 19);
  if (v9)
    result = pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8));
LABEL_8:
  if (v10)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    ++*(_QWORD *)(v10 + 96);
    result = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v10 + 40) + 32))(*(_QWORD *)(v10 + 40), 0x1EDCFE498, 0);
    --*(_QWORD *)(v10 + 96);
  }
  if (v7)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    ++*(_QWORD *)(v7 + 96);
    (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v7 + 40) + 32))(*(_QWORD *)(v7 + 40), 0x1EDCFE498, 0);
    --*(_QWORD *)(v7 + 96);
    v11 = *((_QWORD *)a2 + 12);
    if (v11)
      pthread_mutex_lock((pthread_mutex_t *)(v11 + 8));
    v12 = *((_QWORD *)a2 + 16);
    if (v12)
      v13 = *(_QWORD *)(v12 + 8);
    else
      v13 = 0;
    v14 = *((_QWORD *)a2 + 12);
    if (v14)
      pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8));
    return (*(uint64_t (**)(__CFRunLoopTimer *, uint64_t))(*(_QWORD *)a2 + 128))(a2, v13);
  }
  return result;
}

uint64_t ___ZN17HTTPNetConnection19prepareTransmissionEP17HTTPNetStreamInfoP17__CoreWriteStreamP16__CoreReadStream_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 856;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void HTTPNetConnection::HTTPNetConnection(HTTPNetConnection *this, const __CFAllocator *a2, HTTPConnectionCacheKey *a3)
{
  char *v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  __int128 v8;

  *(_QWORD *)this = off_1E14EF578;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = 1;
  if ((((unint64_t)this + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)this = off_1E14E88F0;
  *((_QWORD *)this + 3) = &unk_1E14E8A28;
  v4 = (char *)this + 280;
  *((_QWORD *)this + 35) = 0;
  *((_QWORD *)this + 36) = 0;
  *((_QWORD *)this + 34) = a3;
  (*(void (**)(HTTPConnectionCacheKey *))(*(_QWORD *)a3 + 40))(a3);
  *((_QWORD *)this + 38) = 0;
  *((_DWORD *)this + 62) = 0;
  *((_WORD *)this + 134) = 1;
  v8 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v4, &v8);
  v5 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
  if (*((_QWORD *)&v8 + 1))
  {
    v6 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_184044278(_Unwind_Exception *a1)
{
  NetConnection *v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  NetConnection::~NetConnection(v1);
  _Unwind_Resume(a1);
}

void HTTPNetConnection::~HTTPNetConnection(HTTPNetConnection *this)
{
  uint64_t v2;
  __CFRunLoopTimer *v3;
  const void *v4;

  *(_QWORD *)this = off_1E14E88F0;
  *((_QWORD *)this + 3) = &unk_1E14E8A28;
  v2 = *((_QWORD *)this + 34);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  v3 = (__CFRunLoopTimer *)*((_QWORD *)this + 32);
  if (v3)
  {
    CFRunLoopTimerInvalidate(v3);
    v4 = (const void *)*((_QWORD *)this + 32);
    if (v4)
      CFRelease(v4);
  }
  if (*((_QWORD *)this + 38))
    __assert_rtn("~HTTPNetConnection", "HTTPNetConnection.cpp", 47, "!fTube");
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 280);
  NetConnection::~NetConnection(this);
}

void sub_184044328(_Unwind_Exception *a1)
{
  NetConnection *v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v1 + 280);
  NetConnection::~NetConnection(v1);
  _Unwind_Resume(a1);
}

void HTTPNetConnection_NoAuth::~HTTPNetConnection_NoAuth(HTTPNetConnection_NoAuth *this)
{
  uint64_t v2;

  HTTPNetConnection_NoAuth::~HTTPNetConnection_NoAuth(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  const void *v2;

  *(_QWORD *)this = off_1E14ECE48;
  *((_QWORD *)this + 3) = &unk_1E14ECF80;
  CFSetApplyFunction(*((CFSetRef *)this + 39), (CFSetApplierFunction)_authDisassociate, this);
  v2 = (const void *)*((_QWORD *)this + 39);
  if (v2)
    CFRelease(v2);
  HTTPNetConnection::~HTTPNetConnection(this);
}

uint64_t HTTPNetConnection_NoAuth::isConnectionWithAuth(HTTPNetConnection_NoAuth *this)
{
  return 0;
}

void HTTPNetConnection_NoAuth::applyAnyCredentials(CFMutableSetRef *this, HTTPNetStreamInfo *a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  char v12;
  const void *v13;
  int v14;
  _QWORD v15[3];

  v15[2] = *MEMORY[0x1E0C80C00];
  v6 = *((_QWORD *)a2 + 5);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v7 = 0;
  v8 = v6 + 16;
  if (!v6)
    v8 = 0;
  v15[0] = *(_QWORD *)(v8 + 72);
  v9 = *((_QWORD *)a2 + 5);
  if (v9)
    v10 = v9 + 16;
  else
    v10 = 0;
  v15[1] = *(_QWORD *)(v10 + 80);
  v11 = 1;
  do
  {
    v12 = v11;
    v13 = (const void *)v15[v7];
    if (v13)
    {
      if (a3)
      {
        _CFHTTPAuthenticationApplyHeaderToRequest((_CFHTTPAuthentication *)v15[v7], *((__CFHTTPMessage **)a2 + 5), this);
        if (!v14)
          CFSetSetValue(this[39], v13);
      }
      else
      {
        _CFHTTPAuthenticationDisassociateConnection(v15[v7], this);
        CFSetRemoveValue(this[39], v13);
      }
    }
    v11 = 0;
    v7 = 1;
  }
  while ((v12 & 1) != 0);
}

CFDictionaryRef HTTPNetConnection_NoAuth::applyCredentialsDictionary(HTTPNetConnection_NoAuth *this, __CFHTTPMessage *a2, _CFHTTPAuthentication *a3)
{
  return _CFHTTPAuthenticationApplyHeaderToRequest(a3, a2, this);
}

uint64_t HTTPNetConnection_NoAuth::getProxyAuth(HTTPNetConnection_NoAuth *this, __CFHTTPMessage *a2)
{
  char *v3;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v3 = (char *)a2 + 16;
  if (!a2)
    v3 = 0;
  return *((_QWORD *)v3 + 10);
}

HTTPNetStreamInfo *HTTPNetConnection_NoAuth::updateAuthForReal(CFMutableSetRef *this, HTTPNetStreamInfo *a2, __CFHTTPMessage *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;

  v6 = NetConnection::willEnqueueRequests((NetConnection *)this);
  v7 = *((_QWORD *)a2 + 5);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v8 = v7 + 16;
  if (!v7)
    v8 = 0;
  v9 = *(const void **)(v8 + 72);
  if (v9)
  {
    if (!v6)
    {
      _CFHTTPAuthenticationDisassociateConnection(*(_QWORD *)(v8 + 72), this);
      CFSetRemoveValue(this[39], v9);
    }
    _CFHTTPAuthenticationUpdateFromResponse((uint64_t)v9, a3, this);
    v10 = *((_QWORD *)a2 + 5);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  }
  else
  {
    v10 = *((_QWORD *)a2 + 5);
  }
  v11 = v10 + 16;
  if (!v10)
    v11 = 0;
  v12 = *(const void **)(v11 + 80);
  if (v12)
  {
    if (!v6)
    {
      _CFHTTPAuthenticationDisassociateConnection(*(_QWORD *)(v11 + 80), this);
      CFSetRemoveValue(this[39], v12);
    }
    _CFHTTPAuthenticationUpdateFromResponse((uint64_t)v12, a3, this);
  }
  return a2;
}

void `non-virtual thunk to'HTTPNetConnection_NoAuth::~HTTPNetConnection_NoAuth(HTTPNetConnection_NoAuth *this)
{
  HTTPNetConnection_NoAuth::~HTTPNetConnection_NoAuth((HTTPNetConnection_NoAuth *)((char *)this - 24));
}

void `non-virtual thunk to'HTTPNetConnection_NoAuth::~HTTPNetConnection_NoAuth(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  HTTPNetConnection_NoAuth::~HTTPNetConnection_NoAuth((HTTPNetConnection_NoAuth *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

void sub_1840446AC(_Unwind_Exception *a1)
{
  HTTPNetConnection *v1;

  HTTPNetConnection::~HTTPNetConnection(v1);
  _Unwind_Resume(a1);
}

void HTTPNetConnection_NoAuth::HTTPNetConnection_NoAuth(HTTPNetConnection_NoAuth *this, const __CFAllocator *a2, HTTPConnectionCacheKey *a3)
{
  uint64_t v4;

  HTTPNetConnection::HTTPNetConnection(this, a2, a3);
  *(_QWORD *)v4 = off_1E14ECE48;
  *(_QWORD *)(v4 + 24) = &unk_1E14ECF80;
  *((_QWORD *)this + 39) = CFSetCreateMutable(*(CFAllocatorRef *)(v4 + 8), 0, MEMORY[0x1E0C9B3B0]);
}

void sub_184044714(_Unwind_Exception *a1)
{
  HTTPNetConnection *v1;

  HTTPNetConnection::~HTTPNetConnection(v1);
  _Unwind_Resume(a1);
}

void HTTPNetConnection_WithAuth::~HTTPNetConnection_WithAuth(HTTPNetConnection_WithAuth *this)
{
  uint64_t v2;

  HTTPNetConnection_WithAuth::~HTTPNetConnection_WithAuth(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint64_t v2;
  const void *v3;
  const void *v4;
  uint64_t v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;

  *(_QWORD *)this = off_1E14ED9A0;
  *((_QWORD *)this + 3) = &unk_1E14EDAD8;
  v2 = *((_QWORD *)this + 39);
  if (v2)
  {
    _CFHTTPAuthenticationDisassociateConnection(v2, this);
    v3 = (const void *)*((_QWORD *)this + 39);
    if (v3)
      CFRelease(v3);
  }
  v4 = (const void *)*((_QWORD *)this + 40);
  if (v4)
    CFRelease(v4);
  v5 = *((_QWORD *)this + 41);
  if (v5)
  {
    _CFHTTPAuthenticationDisassociateConnection(v5, this);
    v6 = (const void *)*((_QWORD *)this + 41);
    if (v6)
      CFRelease(v6);
  }
  v7 = (const void *)*((_QWORD *)this + 42);
  if (v7)
    CFRelease(v7);
  v8 = (const void *)*((_QWORD *)this + 44);
  if (v8)
    CFRelease(v8);
  v9 = (const void *)*((_QWORD *)this + 45);
  if (v9)
    CFRelease(v9);
  HTTPNetConnection::~HTTPNetConnection(this);
}

_QWORD *HTTPNetConnection_WithAuth::setRemoteCredsAndAuth(_QWORD *this, CFTypeRef cf, _CFHTTPAuthentication *a3)
{
  uint64_t v4;

  if (cf)
  {
    if (a3)
    {
      v4 = (uint64_t)this;
      this[45] = CFRetain(cf);
      this = CFRetain(a3);
      *(_QWORD *)(v4 + 352) = this;
    }
  }
  return this;
}

CFDictionaryRef HTTPNetConnection_WithAuth::setConnectionCredsAndAuth(CFDictionaryRef this, const __CFDictionary *a2, CFTypeRef cf)
{
  CFDictionaryRef v3;
  CFTypeRef v5;
  const __CFAllocator *v6;

  if (!*((_QWORD *)this + 39))
  {
    v3 = this;
    if (!*((_QWORD *)this + 40))
    {
      if (cf)
        v5 = CFRetain(cf);
      else
        v5 = 0;
      *((_QWORD *)v3 + 39) = v5;
      if (a2)
      {
        v6 = CFGetAllocator(a2);
        this = CFDictionaryCreateCopy(v6, a2);
      }
      else
      {
        this = 0;
      }
      *((_QWORD *)v3 + 40) = this;
    }
  }
  return this;
}

void HTTPNetConnection_WithAuth::responseStreamCallback(void (**this)(HTTPNetConnection *), void *a2, uint64_t a3, uint64_t a4)
{
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CoreStreamBase *v14;
  unsigned __int8 v15[2056];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (this[27])
    this[24]((HTTPNetConnection *)this);
  if (HTTPNetConnection::handleReadEventsDuringRequestBodyTransmission((HTTPNetConnection *)this, a2, a4))
    return;
  v8 = *((_DWORD *)a2 + 8);
  if ((v8 & 0x20) == 0)
    HTTPNetConnection::prepareReception((HTTPNetConnection *)this, (uint64_t)a2, a3);
  if (!*((_QWORD *)a2 + 6) && (*((_BYTE *)a2 + 32) & 4) == 0)
    a2 = (void *)HTTPNetConnection::updateForHeaders((HTTPNetConnection *)this, (uint64_t)a2, a3);
  v9 = *((_DWORD *)a2 + 8);
  if ((v9 & 0x100) == 0)
  {
    *((_DWORD *)a2 + 8) = v9 | 0x100;
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (a3)
      v10 = a3 + 16;
    else
      v10 = 0;
    ++*(_QWORD *)(v10 + 80);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v10 + 24) + 32))(*(_QWORD *)(v10 + 24), 0x1EDCFA5D0);
    --*(_QWORD *)(v10 + 80);
    v9 = *((_DWORD *)a2 + 8);
  }
  if ((v9 & 0x200) == 0)
  {
    *((_DWORD *)a2 + 8) = v9 | 0x200;
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (a3)
      v11 = a3 + 16;
    else
      v11 = 0;
    ++*(_QWORD *)(v11 + 80);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v11 + 24) + 32))(*(_QWORD *)(v11 + 24), 0x1EDCFA250);
    --*(_QWORD *)(v11 + 80);
  }
  if (a4 <= 15)
  {
    if (a4 != 2)
    {
      if (a4 == 8)
      {
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
        v12 = a3 + 16;
        if (!a3)
          v12 = 0;
        *(_OWORD *)v15 = *(_OWORD *)(v12 + 56);
        HTTPNetStreamInfo::grabReadStreamProperties((uint64_t)a2, a3);
        (*(void (**)(_QWORD, unsigned __int8 *))(**((_QWORD **)a2 + 16) + 64))(*((_QWORD *)a2 + 16), v15);
      }
      return;
    }
    if ((v8 & 0x20) == 0)
      return;
    if ((*((_BYTE *)a2 + 32) & 4) != 0)
    {
      if (a3)
        v14 = (CoreStreamBase *)(a3 + 16);
      else
        v14 = 0;
      while (1)
      {
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
        if (!CoreStreamBase::_streamInterface_CanRead(v14))
          break;
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
        CoreStreamBase::_streamInterface_Read(v14, v15, 2048);
      }
      return;
    }
    goto LABEL_43;
  }
  if (a4 != 16)
  {
    if (a4 == 32 && (v8 & 0x20) != 0 && *((_QWORD *)a2 + 16))
      HTTPNetStreamInfo::sendStreamIsComplete((HTTPNetStreamInfo *)a2);
    return;
  }
  v13 = *((_QWORD *)a2 + 16);
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 72))(v13);
  if ((*((_BYTE *)a2 + 32) & 4) == 0)
LABEL_43:
    _CFReadStreamSignalEventDelayed();
}

uint64_t HTTPNetConnection_WithAuth::isConnectionWithAuth(HTTPNetConnection_WithAuth *this)
{
  return 1;
}

CFDictionaryRef HTTPNetConnection_WithAuth::applyAnyCredentials(CFDictionaryRef this, CFHTTPMessageRef *a2)
{
  uint64_t v3;
  uint64_t v4;
  _CFHTTPAuthentication *v5;
  CFStreamError v6;

  v3 = (uint64_t)this;
  v4 = *((_QWORD *)this + 46);
  if (v4 == 407)
    goto LABEL_10;
  v5 = (_CFHTTPAuthentication *)*((_QWORD *)this + 39);
  if (v5)
  {
    CFHTTPMessageApplyCredentialDictionary(a2[5], v5, *((CFDictionaryRef *)this + 40), &v6);
    this = _CFHTTPAuthenticationApplyHeaderToRequest(*(_CFHTTPAuthentication **)(v3 + 312), a2[5], (const void *)v3);
    v4 = *(_QWORD *)(v3 + 368);
  }
  if (v4 != 401)
  {
LABEL_10:
    if (*(_QWORD *)(v3 + 328))
    {
      this = (CFDictionaryRef)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 + 272) + 88))(*(_QWORD *)(v3 + 272));
      if ((_DWORD)this != 3)
      {
        CFHTTPMessageApplyCredentialDictionary(a2[5], *(CFHTTPAuthenticationRef *)(v3 + 328), *(CFDictionaryRef *)(v3 + 336), &v6);
        return _CFHTTPAuthenticationApplyHeaderToRequest(*(_CFHTTPAuthentication **)(v3 + 328), a2[5], (const void *)v3);
      }
    }
  }
  return this;
}

CFIndex HTTPNetConnection_WithAuth::applyCredentialsDictionary(CFHTTPAuthenticationRef *this, __CFHTTPMessage *a2, _CFHTTPAuthentication *a3)
{
  int v5;
  uint64_t v6;
  CFStreamError v8;

  v5 = CFHTTPAuthenticationRequiresOrderedRequests(this[41]);
  CFHTTPMessageApplyCredentialDictionary(a2, this[41], this[42], &v8);
  if (v5 && !v8.error)
  {
    v8.domain = (CFIndex)_CFHTTPAuthenticationApplyHeaderToRequest(this[41], a2, this);
    *(_QWORD *)&v8.error = v6;
  }
  return v8.domain;
}

uint64_t HTTPNetConnection_WithAuth::getProxyAuth(HTTPNetConnection_WithAuth *this, __CFHTTPMessage *a2)
{
  return *((_QWORD *)this + 41);
}

HTTPNetStreamInfo *HTTPNetConnection_WithAuth::updateAuthForReal(HTTPNetConnection_WithAuth *this, HTTPNetStreamInfo *a2, CFHTTPMessageRef response)
{
  CFIndex ResponseStatusCode;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  _BOOL4 v14;
  HTTPNetStreamInfo *v16;
  uint64_t *v17;
  HTTPNetStreamInfo *v18;
  _BOOL4 v19;
  uint64_t *v20;
  uint64_t *v21;
  const CoreSchedulingSet *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  CoreStreamBase *v27;
  const CoreSchedulingSet *v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  const void *v32;
  NetConnection *v33;
  CoreStreamBase *v34;
  CFStreamError v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t (*v38)(uint64_t, uint64_t);
  void *v39;
  uint64_t *v40;
  HTTPNetStreamInfo *v41;
  uint64_t v42;
  HTTPNetConnection_WithAuth *v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;

  if ((*((_BYTE *)a2 + 33) & 8) != 0)
    return a2;
  ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(response);
  v7 = *((_QWORD *)this + 39);
  if (v7)
  {
    _CFHTTPAuthenticationUpdateFromResponse(v7, response, this);
    if (!CFHTTPAuthenticationIsValid(*((CFHTTPAuthenticationRef *)this + 39), &v35))
      *((_BYTE *)this + 248) = 1;
  }
  v8 = *((_QWORD *)this + 41);
  if (v8)
  {
    _CFHTTPAuthenticationUpdateFromResponse(v8, response, this);
    if (!CFHTTPAuthenticationIsValid(*((CFHTTPAuthenticationRef *)this + 41), 0))
      *((_BYTE *)this + 249) = 1;
  }
  v9 = NetConnection::willEnqueueRequests(this);
  *((_QWORD *)this + 46) = ResponseStatusCode;
  if (!v9
    || (*((_BYTE *)this + 248) || !*((_QWORD *)this + 39) || ResponseStatusCode != 401)
    && (*((_BYTE *)this + 249) || !*((_QWORD *)this + 41) || ResponseStatusCode != 407))
  {
    return a2;
  }
  v10 = *((_QWORD *)this + 1);
  v44 = 0;
  v45 = &v44;
  v46 = 0x2020000000;
  v47 = 0;
  v36 = MEMORY[0x1E0C809B0];
  v37 = 3221225472;
  v38 = ___ZN17HTTPNetStreamInfo18createZombieDoubleEPK13__CFAllocatorP17HTTPNetConnection_block_invoke;
  v39 = &unk_1E14F9038;
  v40 = &v44;
  v41 = a2;
  v42 = v10;
  v43 = this;
  CFReadStreamCreate();
  v11 = v45[3];
  _Block_object_dispose(&v44, 8);
  if (!v11)
    return a2;
  *(_DWORD *)(v11 + 32) |= 0x840u;
  v12 = *((_QWORD *)this + 12);
  if (v12)
    pthread_mutex_lock((pthread_mutex_t *)(v12 + 8));
  if (*((_QWORD *)this + 16) && (*((_WORD *)this + 44) & 0x20) != 0)
  {
    v13 = (uint64_t *)*((_QWORD *)this + 16);
    while ((v13[2] & 2) != 0)
    {
      v13 = (uint64_t *)*v13;
      if (!v13)
      {
        v13 = (uint64_t *)*((_QWORD *)this + 16);
        break;
      }
    }
    v16 = (HTTPNetStreamInfo *)v13[1];
    v14 = v16 == a2;
    if (v16 != a2)
      v13 = 0;
  }
  else
  {
    v13 = 0;
    v14 = 0;
  }
  if (!*((_QWORD *)this + 17) || (*((_WORD *)this + 44) & 0x200) != 0)
  {
    v19 = 0;
  }
  else
  {
    v17 = (uint64_t *)*((_QWORD *)this + 17);
    while ((v17[2] & 2) != 0)
    {
      v17 = (uint64_t *)*v17;
      if (!v17)
      {
        v17 = (uint64_t *)*((_QWORD *)this + 17);
        break;
      }
    }
    v18 = (HTTPNetStreamInfo *)v17[1];
    v19 = v18 == a2;
    if (v18 == a2)
      v13 = v17;
  }
  if ((v19 || v14) && (v20 = (uint64_t *)*v13) != 0)
  {
    v21 = (uint64_t *)*v13;
    while ((v21[2] & 2) != 0)
    {
      v21 = (uint64_t *)*v21;
      if (!v21)
      {
        v21 = v20;
        break;
      }
    }
    v22 = (const CoreSchedulingSet *)(*(uint64_t (**)(HTTPNetConnection_WithAuth *, uint64_t))(*(_QWORD *)this + 160))(this, v21[1]);
  }
  else
  {
    v22 = 0;
  }
  v23 = (char *)this + 112;
  while (1)
  {
    v23 = *(char **)v23;
    if (!v23)
      break;
    if (*((HTTPNetStreamInfo **)v23 + 1) == a2)
    {
      *((_QWORD *)v23 + 1) = v11;
      v23[16] |= 2u;
      break;
    }
  }
  if (v14)
  {
    NetConnection::rescheduleStream(*((char **)this + 18), v22);
    v24 = *((_QWORD *)this + 16);
    if (!v24 || *(_QWORD *)(v24 + 8) != v11 || (*((_WORD *)this + 44) & 0x20) == 0)
      goto LABEL_74;
    v25 = 16;
  }
  else
  {
    if (!v19)
      goto LABEL_74;
    v26 = (char *)*((_QWORD *)this + 19);
    if (v26)
    {
      CFRetain(*((CFTypeRef *)this + 19));
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      v27 = (CoreStreamBase *)(v26 + 16);
    }
    else
    {
      v27 = 0;
    }
    v28 = v22;
    if (!v22)
    {
      if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
      {
        v34 = v27;
        dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16941);
        v27 = v34;
      }
      v28 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
    }
    CoreStreamBase::_streamInterface_UpdateScheduling(v27, v28);
    if (v26)
      CFRelease(v26);
    v29 = *((_QWORD *)this + 17);
    if (!v29 || *(_QWORD *)(v29 + 8) != v11 || (*((_WORD *)this + 44) & 0x200) != 0)
      goto LABEL_74;
    v25 = 17;
  }
  (*(void (**)(HTTPNetConnection_WithAuth *, uint64_t))(*(_QWORD *)this + 8 * v25))(this, v11);
LABEL_74:
  if (v22)
    (*(void (**)(const CoreSchedulingSet *))(*(_QWORD *)v22 + 48))(v22);
  v30 = *((_QWORD *)this + 12);
  if (v30)
    pthread_mutex_unlock((pthread_mutex_t *)(v30 + 8));
  *(_DWORD *)(v11 + 32) &= ~0x40u;
  v31 = *((_DWORD *)a2 + 8) & 0xFFFFFFFE;
  *((_DWORD *)a2 + 8) = v31;
  v32 = (const void *)*((_QWORD *)a2 + 6);
  *((_QWORD *)a2 + 6) = 0;
  if (v32)
  {
    CFRelease(v32);
    v31 = *((_DWORD *)a2 + 8);
  }
  *((_DWORD *)a2 + 8) = v31 & 0xFFFE1FDF | 0x2000;
  *((_QWORD *)a2 + 11) = 0;
  v33 = (NetConnection *)*((_QWORD *)a2 + 16);
  if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 34) + 88))(*((_QWORD *)this + 34)) == 3)
    *((_BYTE *)this + 250) = 0;
  if (v33)
    NetConnection::enqueue(v33, (uint64_t *)a2, 1);
  return (HTTPNetStreamInfo *)v11;
}

void sub_184045118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void HTTPNetConnection_WithAuth::applyRemoteCredentials(HTTPNetConnection_WithAuth *this, _CFURLCredential *a2)
{
  uint64_t v2;
  uint64_t v5;
  const __CFString *v6;
  _CFHTTPAuthentication *v7;
  const __CFString *Username;

  v2 = *((_QWORD *)this + 45);
  if (v2)
  {
    v5 = URLCredential_PasswordBased::safelyCast(*((_QWORD *)this + 45), a2);
    if (v5)
      v6 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 128))(v5);
    else
      v6 = 0;
    v7 = (_CFHTTPAuthentication *)*((_QWORD *)this + 44);
    if (v7)
    {
      Username = (const __CFString *)CFURLCredentialGetUsername(v2);
      CFHTTPMessageApplyCredentials((CFHTTPMessageRef)a2, v7, Username, v6, 0);
    }
    if (v6)
      CFRelease(v6);
  }
}

void `non-virtual thunk to'HTTPNetConnection_WithAuth::~HTTPNetConnection_WithAuth(HTTPNetConnection_WithAuth *this)
{
  HTTPNetConnection_WithAuth::~HTTPNetConnection_WithAuth((HTTPNetConnection_WithAuth *)((char *)this - 24));
}

void `non-virtual thunk to'HTTPNetConnection_WithAuth::~HTTPNetConnection_WithAuth(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  HTTPNetConnection_WithAuth::~HTTPNetConnection_WithAuth((HTTPNetConnection_WithAuth *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

void sub_184045298(_Unwind_Exception *a1)
{
  HTTPNetConnection *v1;

  HTTPNetConnection::~HTTPNetConnection(v1);
  _Unwind_Resume(a1);
}

void HTTPNetStreamInfo::~HTTPNetStreamInfo(HTTPNetStreamInfo *this)
{
  HTTPNetStreamInfo::~HTTPNetStreamInfo(this);
  JUMPOUT(0x186DB748CLL);
}

{
  uint64_t v2;
  const void *v3;
  const void *v4;
  uint64_t v5;
  __CFReadStream *v6;
  CoreSchedulingSet *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  __CFRunLoopTimer *v12;
  uint64_t v13;
  uint8_t v14[16];

  *(_QWORD *)this = &off_1E14E8A48;
  *((_QWORD *)this + 2) = &unk_1E14E8B68;
  v2 = *((_QWORD *)this + 15);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
    *((_QWORD *)this + 15) = 0;
  }
  HTTPNetStreamInfo::dequeueFromConnection((NetConnection **)this);
  v3 = (const void *)*((_QWORD *)this + 6);
  if (v3)
    CFRelease(v3);
  HTTPNetStreamInfo::closeAndReleasePayload(this);
  v4 = (const void *)*((_QWORD *)this + 5);
  if (v4)
    CFRelease(v4);
  v5 = *((_QWORD *)this + 12);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  if ((*((_BYTE *)this + 32) & 4) != 0)
  {
    v6 = (__CFReadStream *)*((_QWORD *)this + 1);
    if (v6)
    {
      v7 = (CoreSchedulingSet *)*((_QWORD *)this + 21);
      if (v7)
        CoreSchedulingSet::unscheduleStream(v7, *((__CFReadStream **)this + 1));
      CFReadStreamSetClient(v6, 0, 0, 0);
    }
  }
  v8 = (const void *)*((_QWORD *)this + 10);
  if (v8)
    CFRelease(v8);
  v9 = (const void *)*((_QWORD *)this + 17);
  if (v9)
    CFRelease(v9);
  v10 = (const void *)*((_QWORD *)this + 18);
  if (v10)
    CFRelease(v10);
  v11 = (const void *)*((_QWORD *)this + 7);
  if (v11)
  {
    if (*((_BYTE *)this + 64)
      || !os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
      || (*(_WORD *)v14 = 0,
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "payload was never closed?", v14, 2u), (v11 = (const void *)*((_QWORD *)this + 7)) != 0))
    {
      CFRelease(v11);
    }
  }
  v12 = (__CFRunLoopTimer *)*((_QWORD *)this + 22);
  if (v12)
  {
    CFRunLoopTimerInvalidate(v12);
    CFRelease(*((CFTypeRef *)this + 22));
    *((_QWORD *)this + 22) = 0;
  }
  v13 = *((_QWORD *)this + 21);
  if (v13)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 48))(v13);
    *((_QWORD *)this + 21) = 0;
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 152);
  *(_QWORD *)this = &off_1E14E5838;
  *((_QWORD *)this + 1) = 0;
}

BOOL HTTPNetStreamInfo::_streamImpl_Open(HTTPNetStreamInfo *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  NetConnection *v7;
  int v8;
  _BOOL8 result;
  uint8_t v10[16];

  if ((*((_BYTE *)this + 32) & 4) != 0)
  {
    result = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT);
    if (!result)
      return result;
    *(_WORD *)v10 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Don't open zombies", v10, 2u);
    return 0;
  }
  *a4 = 0;
  a3->error = 0;
  a3->domain = 0;
  v7 = (NetConnection *)*((_QWORD *)this + 16);
  if (!v7 || !NetConnection::enqueue(v7, (uint64_t *)this, 0))
  {
    result = 0;
    *a4 = 1;
    a3->domain = 4;
    a3->error = -4;
    return result;
  }
  v8 = (*((_DWORD *)this + 8) >> 13) & 0xF;
  result = 1;
  if (v8 == 7)
  {
    *a4 = 1;
    a3->domain = 4;
    a3->error = -4;
    return 0;
  }
  if (v8 == 5)
    goto LABEL_8;
  if (v8 != 4)
    return result;
  if (*((_QWORD *)this + 6))
LABEL_8:
    *a4 = 1;
  else
    *a4 = 0;
  return result;
}

uint64_t HTTPNetStreamInfo::_streamImpl_OpenCompleted(HTTPNetStreamInfo *this, __CFReadStream *a2, CFStreamError *a3)
{
  uint64_t result;
  int State;
  uint8_t v7[16];

  if ((*((_BYTE *)this + 32) & 4) != 0)
  {
    result = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT);
    if (!(_DWORD)result)
      return result;
    *(_WORD *)v7 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Don't open zombies", v7, 2u);
    return 0;
  }
  if ((*((_BYTE *)this + 32) & 8) != 0)
    return 0;
  result = *((_QWORD *)this + 16);
  if (!result)
    return result;
  State = NetConnection::getState((NetConnection *)result, 1, (uint64_t *)this);
  if ((State - 5) >= 2)
  {
    if (State != 7)
    {
      if (State == 4)
        return *((_QWORD *)this + 6) != 0;
      return 0;
    }
    a3->domain = 4;
    a3->error = -4;
  }
  return 1;
}

uint64_t HTTPNetStreamInfo::_streamImpl_Read(HTTPNetStreamInfo *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  unsigned int v6;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFStreamError Error;
  uint64_t v19;
  uint64_t v21;
  uint8_t v22[16];
  uint8_t buf[16];

  v6 = *((_DWORD *)this + 8);
  if ((v6 & 4) != 0)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Don't open zombies", buf, 2u);
    }
    return -1;
  }
  if (!*((_QWORD *)this + 6) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v22 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Then he shouldn't be reading.", v22, 2u);
    v6 = *((_DWORD *)this + 8);
  }
  v12 = (v6 >> 13) & 0xF;
  if (v12 == 7)
    goto LABEL_14;
  if (v12 == 5)
  {
    v13 = 0;
    a5->error = 0;
LABEL_32:
    *a6 = 1;
    return v13;
  }
  v14 = *((_QWORD *)this + 16);
  if (!v14)
  {
LABEL_14:
    Error = CFReadStreamGetError((CFReadStreamRef)*((_QWORD *)this + 1));
    *a5 = Error;
    if (!Error.error)
    {
      a5->domain = 1;
      a5->error = 54;
    }
    return -1;
  }
  v15 = *(_QWORD *)(v14 + 96);
  if (v15)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v15 + 8));
    v16 = *(_QWORD *)(v14 + 96);
    v17 = *(_QWORD *)(v14 + 152);
    if (v16)
      pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8));
  }
  else
  {
    v17 = *(_QWORD *)(v14 + 152);
  }
  a5->error = 0;
  *a6 = 0;
  if (!v17)
  {
    a5->domain = 4;
    a5->error = -4;
LABEL_22:
    v13 = -1;
    goto LABEL_31;
  }
  if (_CFHTTPReadStreamIsAtMark(v17))
  {
    HTTPNetStreamInfo::sendStreamIsComplete(this);
    v13 = 0;
LABEL_30:
    *a6 = 1;
    goto LABEL_31;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  v19 = CoreStreamBase::_streamInterface_Read((CoreStreamBase *)(v17 + 16), a3, a4);
  v13 = v19;
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
  {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if ((v13 & 0x8000000000000000) == 0)
      goto LABEL_27;
    goto LABEL_35;
  }
  if (v19 < 0)
  {
LABEL_35:
    *a5 = *(CFStreamError *)(v17 + 72);
    v21 = *((_QWORD *)this + 16);
    if (v21)
      (*(void (**)(uint64_t, CFStreamError *))(*(_QWORD *)v21 + 64))(v21, a5);
    goto LABEL_22;
  }
LABEL_27:
  if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v17 + 16)) == 5 || _CFHTTPReadStreamIsAtMark(v17))
  {
    HTTPNetStreamInfo::sendStreamIsComplete(this);
    goto LABEL_30;
  }
LABEL_31:
  if ((*((_BYTE *)this + 32) & 2) != 0)
    goto LABEL_32;
  return v13;
}

BOOL HTTPNetStreamInfo::_streamImpl_CanRead(HTTPNetStreamInfo *this, __CFReadStream *a2)
{
  NetConnection *v3;
  uint64_t v4;
  unsigned int State;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CoreStreamBase *v11;
  HTTPNetConnection *v12;
  uint8_t v13[16];

  if ((*((_BYTE *)this + 32) & 4) != 0)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v13 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Don't open zombies", v13, 2u);
    }
    return 0;
  }
  v3 = (NetConnection *)*((_QWORD *)this + 16);
  if (!v3)
    return 0;
  v4 = 1;
  State = NetConnection::getState(v3, 1, (uint64_t *)this);
  if (State > 4)
    return v4;
  if (State != 4)
    return 0;
  v6 = *((_QWORD *)this + 16);
  v7 = *(_QWORD *)(v6 + 96);
  if (v7)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v7 + 8));
    v8 = *(_QWORD *)(v6 + 96);
    v9 = *(_QWORD *)(v6 + 152);
    if (v8)
      pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8));
  }
  else
  {
    v9 = *(_QWORD *)(v6 + 152);
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  v11 = v9 ? (CoreStreamBase *)(v9 + 16) : 0;
  if (!CoreStreamBase::_streamInterface_CanRead(v11))
    return 0;
  if (*((_QWORD *)this + 6))
    return 1;
  v12 = (HTTPNetConnection *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 16) + 80))(*((_QWORD *)this + 16));
  return HTTPNetConnection::updateForHeaders(v12, (uint64_t)this, v9) == (_QWORD)this;
}

CFNumberRef HTTPNetStreamInfo::_streamImpl_CopyProperty(CFTypeRef *this, __CFReadStream *a2, CFStringRef theString)
{
  int ExactString;
  CFNumberRef result;
  const __CFAllocator *v7;
  CFTypeRef v8;
  const __CFDictionary *EmptyDict;
  const void *Value;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  ExactString = _findExactString(theString, 8u);
  if (ExactString == 443922397)
  {
    v7 = CFGetAllocator(this[1]);
    return CFNumberCreate(v7, kCFNumberLongLongType, this + 11);
  }
  if (ExactString == 444889076)
  {
    result = (CFNumberRef)this[6];
    if (result)
      return (CFNumberRef)CFRetain(result);
    return result;
  }
  v8 = this[12];
  if (!v8)
    goto LABEL_12;
  EmptyDict = (const __CFDictionary *)*((_QWORD *)v8 + 5);
  if (!EmptyDict)
  {
    EmptyDict = (const __CFDictionary *)*((_QWORD *)v8 + 4);
    if (!EmptyDict)
      EmptyDict = (const __CFDictionary *)AutoDict::getEmptyDict(0);
  }
  Value = CFDictionaryGetValue(EmptyDict, theString);
  if (!Value || (result = (CFNumberRef)CFRetain(Value)) == 0)
  {
LABEL_12:
    v11 = this[16];
    if (!v11)
      return 0;
    v12 = v11[12];
    if (v12)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v12 + 8));
      v13 = v11[12];
      v14 = v11[19];
      if (v13)
        pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8));
      if (!v14)
      {
LABEL_22:
        v15 = this[16];
        v16 = v15[12];
        if (v16)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v16 + 8));
          v17 = v15[12];
          v18 = v15[18];
          if (v17)
            pthread_mutex_unlock((pthread_mutex_t *)(v17 + 8));
          if (v18)
            goto LABEL_26;
        }
        else
        {
          v18 = v15[18];
          if (v18)
          {
LABEL_26:
            if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
              dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
            ++*(_QWORD *)(v18 + 96);
            result = (CFNumberRef)(*(uint64_t (**)(_QWORD, CFStringRef))(**(_QWORD **)(v18 + 40) + 40))(*(_QWORD *)(v18 + 40), theString);
            --*(_QWORD *)(v18 + 96);
            return result;
          }
        }
        return 0;
      }
    }
    else
    {
      v14 = v11[19];
      if (!v14)
        goto LABEL_22;
    }
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    ++*(_QWORD *)(v14 + 96);
    result = (CFNumberRef)(*(uint64_t (**)(_QWORD, CFStringRef))(**(_QWORD **)(v14 + 40) + 40))(*(_QWORD *)(v14 + 40), theString);
    --*(_QWORD *)(v14 + 96);
    if (!result)
      goto LABEL_22;
  }
  return result;
}

CFStreamStatus HTTPNetStreamInfo::_streamImpl_SetProperty(HTTPNetStreamInfo *this, __CFReadStream *a2, CFStringRef theString, const void *a4)
{
  int ExactString;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  const void *v22;
  CFTypeRef v23;
  uint64_t v24;
  HTTPMessage *v25;
  CFStreamStatus result;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t RequestStream;

  ExactString = _findExactString(theString, 0);
  v8 = ExactString;
  if (ExactString > 119892108)
  {
    if (ExactString > 135580084)
    {
      if (ExactString == 135580085 || ExactString == 398906741)
        goto LABEL_19;
      v9 = 406214149;
    }
    else
    {
      if (ExactString == 119892109 || ExactString == 120965283)
        goto LABEL_19;
      v9 = 129296697;
    }
LABEL_18:
    if (ExactString == v9)
      goto LABEL_19;
    goto LABEL_48;
  }
  if (ExactString <= 87361087)
  {
    if (ExactString == 11870276)
    {
      v24 = *((_QWORD *)this + 5);
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (v24)
        v25 = (HTTPMessage *)(v24 + 16);
      else
        v25 = 0;
      HTTPMessage::setHeaderFieldStringValue(v25, 0x1171B29Fu, a4);
      return 1;
    }
    v9 = 83273191;
    goto LABEL_18;
  }
  switch(ExactString)
  {
    case 87361088:
      v22 = (const void *)*((_QWORD *)this + 18);
      *((_QWORD *)this + 18) = 0;
      if (v22)
        CFRelease(v22);
      if (a4)
        v23 = CFRetain(a4);
      else
        v23 = 0;
      *((_QWORD *)this + 18) = v23;
      v11 = *((_DWORD *)this + 8) & 0xFFFFFDFF;
      goto LABEL_54;
    case 90506882:
LABEL_19:
      v12 = *((_QWORD *)this + 16);
      if (!v12)
        return 0;
      v13 = *(_QWORD *)(v12 + 96);
      if (v13)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v13 + 8));
        v14 = *(_QWORD *)(v12 + 96);
        v15 = *(_QWORD *)(v12 + 152);
        if (v14)
          pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8));
        if (!v15)
          goto LABEL_29;
      }
      else
      {
        v15 = *(_QWORD *)(v12 + 152);
        if (!v15)
        {
LABEL_29:
          v17 = *((_QWORD *)this + 16);
          v18 = *(_QWORD *)(v17 + 96);
          if (v18)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v18 + 8));
            v19 = *(_QWORD *)(v17 + 96);
            v20 = *(_QWORD *)(v17 + 144);
            if (v19)
              pthread_mutex_unlock((pthread_mutex_t *)(v19 + 8));
            if (!v20)
              return 0;
LABEL_35:
            if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1)
              goto LABEL_36;
LABEL_74:
            dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
LABEL_36:
            ++*(_QWORD *)(v20 + 96);
            v21 = (*(uint64_t (**)(_QWORD, CFStringRef, const void *))(**(_QWORD **)(v20 + 40) + 32))(*(_QWORD *)(v20 + 40), theString, a4);
            --*(_QWORD *)(v20 + 96);
            return v21 != 0;
          }
          v20 = *(_QWORD *)(v17 + 144);
          if (v20)
            goto LABEL_35;
          return 0;
        }
      }
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      ++*(_QWORD *)(v15 + 96);
      v16 = (*(uint64_t (**)(_QWORD, CFStringRef, const void *))(**(_QWORD **)(v15 + 40) + 32))(*(_QWORD *)(v15 + 40), theString, a4);
      --*(_QWORD *)(v15 + 96);
      if (!v16)
        goto LABEL_29;
      return 1;
    case 104064896:
      v10 = *((_DWORD *)this + 8);
      if ((const void *)*MEMORY[0x1E0C9AE50] == a4)
      {
        if ((v10 & 0x80) != 0)
          return 1;
        v11 = v10 & 0xFFFFFE7F | 0x80;
      }
      else
      {
        if ((v10 & 0x80) == 0)
          return 1;
        v11 = v10 & 0xFFFFFE7F;
      }
      goto LABEL_54;
  }
LABEL_48:
  result = CFReadStreamGetStatus(*((CFReadStreamRef *)this + 1));
  if (result)
    return 0;
  if (v8 != 216338253 && v8 != 223645657)
  {
    if (v8 != 413529750)
    {
      v28 = *((_QWORD *)this + 16);
      if (!v28)
        return 0;
      v29 = *(_QWORD *)(v28 + 96);
      if (v29)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v29 + 8));
        v30 = *(_QWORD *)(v28 + 96);
        v31 = *(_QWORD *)(v28 + 152);
        if (v30)
          pthread_mutex_unlock((pthread_mutex_t *)(v30 + 8));
      }
      else
      {
        v31 = *(_QWORD *)(v28 + 152);
      }
      if (!v31)
        goto LABEL_72;
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      ++*(_QWORD *)(v31 + 96);
      v32 = (*(uint64_t (**)(_QWORD, CFStringRef, const void *))(**(_QWORD **)(v31 + 40) + 32))(*(_QWORD *)(v31 + 40), theString, a4);
      --*(_QWORD *)(v31 + 96);
      if (!v32)
      {
LABEL_72:
        RequestStream = NetConnection::getRequestStream(*((NetConnection **)this + 16));
        if (RequestStream)
        {
          v20 = RequestStream;
          if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1)
            goto LABEL_36;
          goto LABEL_74;
        }
        return 0;
      }
      return 1;
    }
    v27 = *((_DWORD *)this + 8);
    if ((const void *)*MEMORY[0x1E0C9AE50] == a4)
      v11 = v27 | 0x400;
    else
      v11 = v27 & 0xFFFFFBFF;
LABEL_54:
    *((_DWORD *)this + 8) = v11;
    return 1;
  }
  return result;
}

void HTTPNetStreamInfo::_streamImpl_deprecated_Schedule(HTTPNetStreamInfo *this, __CFReadStream *a2, CoreSchedulingSet *a3, const __CFString *cf1)
{
  uint64_t v7;
  uint64_t v8;
  __CFReadStream *v9;
  __CFRunLoopTimer *v10;

  v7 = *((_QWORD *)this + 21);
  if (v7)
    *((_QWORD *)this + 21) = (*(uint64_t (**)(uint64_t, CoreSchedulingSet *, const __CFString *))(*(_QWORD *)v7 + 56))(v7, a3, cf1);
  if (((*((_DWORD *)this + 8) >> 13) & 0xFu) <= 4)
  {
    v8 = *((_QWORD *)this + 16);
    if (v8)
      NetConnection::schedule(v8, (uint64_t *)this, a3, cf1);
  }
  v9 = (__CFReadStream *)*((_QWORD *)this + 7);
  if (v9 && !*((_BYTE *)this + 64))
    CFReadStreamScheduleWithRunLoop(v9, (CFRunLoopRef)a3, cf1);
  v10 = (__CFRunLoopTimer *)*((_QWORD *)this + 22);
  if (v10)
    CFRunLoopAddTimer((CFRunLoopRef)a3, v10, cf1);
}

void HTTPNetStreamInfo::_streamImpl_deprecated_Unschedule(HTTPNetStreamInfo *this, __CFReadStream *a2, CFRunLoopRef rl, CFRunLoopMode mode)
{
  uint64_t v7;
  NetConnection *v8;
  __CFReadStream *v9;
  __CFRunLoopTimer *v10;

  v7 = *((_QWORD *)this + 21);
  if (v7)
    *((_QWORD *)this + 21) = (*(uint64_t (**)(uint64_t, CFRunLoopRef, CFRunLoopMode))(*(_QWORD *)v7 + 64))(v7, rl, mode);
  if (((*((_DWORD *)this + 8) >> 13) & 0xFu) <= 4)
  {
    v8 = (NetConnection *)*((_QWORD *)this + 16);
    if (v8)
    {
      NetConnection::unschedule(v8, (uint64_t *)this, rl, mode);
      v9 = (__CFReadStream *)*((_QWORD *)this + 7);
      if (v9)
      {
        if (!*((_BYTE *)this + 64))
          CFReadStreamUnscheduleFromRunLoop(v9, rl, mode);
      }
    }
  }
  v10 = (__CFRunLoopTimer *)*((_QWORD *)this + 22);
  if (v10)
    CFRunLoopRemoveTimer(rl, v10, mode);
}

void HTTPNetStreamInfo::_readStreamClientCallBack(HTTPNetStreamInfo *this, __CFReadStream *a2, uint64_t a3)
{
  const void *v5;
  UInt8 *v6;
  UInt8 *v7;
  size_t v8;
  size_t v9;
  UInt8 *v10;
  NSObject *v11;
  const void *v12;

  if (!*((_QWORD *)this + 3))
    return;
  v5 = (const void *)(*(uint64_t (**)(HTTPNetStreamInfo *, uint64_t))(*(_QWORD *)this + 192))(this, 34);
  if (a3 == 16)
  {
    (*(void (**)(_QWORD, const void *))(*((_QWORD *)this + 3) + 16))(*((_QWORD *)this + 3), v5);
    goto LABEL_15;
  }
  if (a3 == 8)
  {
    CFReadStreamGetError(*((CFReadStreamRef *)this + 1));
    (*(void (**)(_QWORD, const void *))(*((_QWORD *)this + 3) + 16))(*((_QWORD *)this + 3), v5);
LABEL_15:
    v12 = (const void *)*((_QWORD *)this + 3);
    if (v12)
    {
      _Block_release(v12);
      *((_QWORD *)this + 3) = 0;
      if (!v5)
        return;
      goto LABEL_20;
    }
LABEL_19:
    if (!v5)
      return;
    goto LABEL_20;
  }
  if (a3 != 2)
    goto LABEL_19;
  v6 = (UInt8 *)malloc_type_malloc(0x203A0uLL, 0x33F32B96uLL);
  if (!v6)
  {
    (*(void (**)(_QWORD, const void *))(*((_QWORD *)this + 3) + 16))(*((_QWORD *)this + 3), v5);
    goto LABEL_19;
  }
  v7 = v6;
  v8 = CFReadStreamRead(*((CFReadStreamRef *)this + 1), v6, 132000);
  if ((v8 & 0x8000000000000000) != 0)
  {
    CFReadStreamGetError(*((CFReadStreamRef *)this + 1));
    (*(void (**)(_QWORD, const void *))(*((_QWORD *)this + 3) + 16))(*((_QWORD *)this + 3), v5);
    goto LABEL_24;
  }
  v9 = v8;
  if (!v8)
  {
    (*(void (**)(_QWORD, const void *))(*((_QWORD *)this + 3) + 16))(*((_QWORD *)this + 3), v5);
LABEL_24:
    free(v7);
    if (!v5)
      return;
    goto LABEL_20;
  }
  if (v8 < 0x203A0)
  {
    v10 = (UInt8 *)malloc_type_realloc(v7, v8, 0x669B83F0uLL);
    if (v10)
      v7 = v10;
  }
  v11 = dispatch_data_create(v7, v9, 0, (dispatch_block_t)*MEMORY[0x1E0C80CE0]);
  (*(void (**)(void))(*((_QWORD *)this + 3) + 16))();
  dispatch_release(v11);
  if (v5)
LABEL_20:
    CFRelease(v5);
}

__CFString *HTTPNetStreamInfo::copyDebugDesc(CFHTTPMessageRef *this)
{
  CFURLRef v2;
  const __CFAllocator *v3;
  __CFString *Mutable;
  const char *v5;
  const __CFString *v6;

  v2 = CFHTTPMessageCopyRequestURL(this[5]);
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (((_DWORD)this[4] & 4) != 0)
    v5 = "Yes";
  else
    v5 = "No";
  v6 = CFStringCreateWithFormat(v3, 0, CFSTR("<HTTP stream context %p>{url = %@, state = %s, conn=%p, isZombie=%s}"), this, v2, "", this[16], v5);
  CFStringAppend(Mutable, v6);
  if (v6)
    CFRelease(v6);
  if (v2)
    CFRelease(v2);
  return Mutable;
}

void HTTPNetStreamInfo::setBodyStreamBeforeOpening(HTTPNetStreamInfo *this, CFTypeRef cf)
{
  uint64_t v3;
  HTTPMessage *v4;
  uint64_t v5;
  const __CFData *v6;
  CFIndex Length;
  const __CFAllocator *v8;
  const UInt8 *BytePtr;

  if (cf)
  {
    *((_QWORD *)this + 7) = CFRetain(cf);
    *((_BYTE *)this + 64) = 0;
    *((_QWORD *)this + 9) = -1;
  }
  else
  {
    v3 = *((_QWORD *)this + 5);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (v3)
      v4 = (HTTPMessage *)(v3 + 16);
    else
      v4 = 0;
    HTTPMessage::ensureParserFinished(v4);
    v5 = *((_QWORD *)v4 + 6);
    if (v5)
    {
      v6 = *(const __CFData **)(v5 + 16);
      if (v6 || (v6 = *(const __CFData **)(v5 + 24)) != 0)
      {
        Length = CFDataGetLength(v6);
        *((_QWORD *)this + 9) = Length;
        if (Length >= 1)
        {
          v8 = CFGetAllocator(v6);
          BytePtr = CFDataGetBytePtr(v6);
          *((_QWORD *)this + 7) = CFReadStreamCreateWithBytesNoCopy(v8, BytePtr, *((_QWORD *)this + 9), (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
          *((_BYTE *)this + 64) = 0;
        }
      }
    }
  }
}

uint64_t HTTPNetStreamInfo::rawBytesSent(HTTPNetStreamInfo *this)
{
  return *((_QWORD *)this + 13);
}

uint64_t HTTPNetStreamInfo::rawBytesReceived(HTTPNetStreamInfo *this)
{
  return *((_QWORD *)this + 14);
}

_QWORD *HTTPNetStreamInfo::setProxy(_QWORD *result, uint64_t *a2)
{
  _QWORD *v2;
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;

  v2 = result + 19;
  if (result[19] != *a2)
  {
    v4 = result[16];
    if (v4)
    {
      v5 = a2[1];
      v11 = *a2;
      v12 = (std::__shared_weak_count *)v5;
      if (v5)
      {
        v6 = (unint64_t *)(v5 + 8);
        do
          v7 = __ldxr(v6);
        while (__stxr(v7 + 1, v6));
      }
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v4 + 232))(v4, &v11);
      v8 = v12;
      if (v12)
      {
        p_shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          v10 = __ldaxr(p_shared_owners);
        while (__stlxr(v10 - 1, p_shared_owners));
        if (!v10)
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }
    }
    return std::shared_ptr<__CFString const>::operator=[abi:nn180100](v2, *a2, a2[1]);
  }
  return result;
}

void sub_184046434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t HTTPNetStreamInfo::getProxy@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  v2 = *(_QWORD *)(this + 152);
  if (!v2)
    return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(this + 128) + 240))(*(_QWORD *)(this + 128));
  v3 = *(_QWORD *)(this + 160);
  *a2 = v2;
  a2[1] = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  return this;
}

CFTypeRef HTTPNetStreamInfo::retain(CFTypeRef *this)
{
  return CFRetain(this[1]);
}

void HTTPNetStreamInfo::release(CFTypeRef *this)
{
  CFRelease(this[1]);
}

uint64_t HTTPNetStreamInfo::_meta_retain(HTTPNetStreamInfo *this)
{
  return (*(uint64_t (**)(HTTPNetStreamInfo *))(*(_QWORD *)this + 160))(this);
}

uint64_t HTTPNetStreamInfo::_meta_release(HTTPNetStreamInfo *this)
{
  return (*(uint64_t (**)(HTTPNetStreamInfo *))(*(_QWORD *)this + 168))(this);
}

CFTypeRef HTTPNetStreamInfo::copyProperty(uint64_t a1, int a2)
{
  __CFReadStream *v2;
  const __CFString *v3;

  v2 = *(__CFReadStream **)(a1 + 8);
  v3 = (const __CFString *)MetaNetStreamInfo::applicableToPropertyName(a2);
  return CFReadStreamCopyProperty(v2, v3);
}

uint64_t HTTPNetStreamInfo::setProperty(uint64_t a1, int a2, const void *a3)
{
  __CFReadStream *v4;
  const __CFString *v5;

  v4 = *(__CFReadStream **)(a1 + 8);
  v5 = (const __CFString *)MetaNetStreamInfo::applicableToPropertyName(a2);
  return CFReadStreamSetProperty(v4, v5, a3);
}

void HTTPNetStreamInfo::updateScheduling(HTTPNetStreamInfo *this, CoreSchedulingSet *a2)
{
  CoreSchedulingSet *v2;
  uint64_t v4;
  void (*v5)(_QWORD, _QWORD, _QWORD);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(_QWORD, _QWORD, _QWORD);
  uint64_t v10;
  void (*v11)(uint64_t, CFRunLoopRef, const __CFString *);
  void *v12;
  uint64_t v13;

  v2 = a2;
  if (!CoreSchedulingSet::isEqualTo(*((CoreSchedulingSet **)this + 21), a2))
  {
    v4 = *((_QWORD *)this + 22);
    v5 = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
    if (v4)
    {
      v6 = *((_QWORD *)this + 21);
      v9 = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
      v10 = 3221225472;
      v11 = ___ZNK17CoreSchedulingSet15unscheduleTimerEP16__CFRunLoopTimer_block_invoke;
      v12 = &__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
      v13 = v4;
      CoreSchedulingSet::applyBlockWithPossibleEmulation(v6, &v9);
    }
    CoreSchedulingSet::unscheduleStream(*((CoreSchedulingSet **)this + 21), *((__CFReadStream **)this + 1));
    v7 = *((_QWORD *)this + 21);
    (*(void (**)(CoreSchedulingSet *))(*(_QWORD *)v2 + 40))(v2);
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 48))(v7);
    *((_QWORD *)this + 21) = v2;
    v8 = *((_QWORD *)this + 22);
    if (v8)
    {
      v9 = v5;
      v10 = 3221225472;
      v11 = ___ZNK17CoreSchedulingSet13scheduleTimerEP16__CFRunLoopTimer_block_invoke;
      v12 = &__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
      v13 = v8;
      CoreSchedulingSet::applyBlockWithPossibleEmulation((uint64_t)v2, &v9);
      v2 = (CoreSchedulingSet *)*((_QWORD *)this + 21);
    }
    CoreSchedulingSet::scheduleStream(v2, *((__CFReadStream **)this + 1));
  }
}

uint64_t HTTPNetStreamInfo::canScheduleAndOpenWithHandlerAsync(HTTPNetStreamInfo *this)
{
  return 0;
}

uint64_t HTTPNetStreamInfo::scheduleAndOpenWithHandler(uint64_t a1, uint64_t a2, void *aBlock)
{
  CFStreamClientContext clientContext;

  if (*(_QWORD *)(a1 + 24))
    __assert_rtn("scheduleAndOpenWithHandler", "HTTPNetStreamInfo.cpp", 925, "_metaClientCallback == NULL");
  *(_QWORD *)(a1 + 24) = _Block_copy(aBlock);
  clientContext.version = 0;
  clientContext.info = (void *)a1;
  clientContext.retain = (void *(__cdecl *)(void *))_CFNetworkReadStream_retain;
  clientContext.release = (void (__cdecl *)(void *))_CFNetworkReadStream_release;
  clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))_CFNetworkReadStream_copyDesc;
  CFReadStreamSetClient(*(CFReadStreamRef *)(a1 + 8), 0x1AuLL, (CFReadStreamClientCallBack)CFNetworkReadStream::_readStreamClientCallBackCallBack, &clientContext);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 208))(a1, a2);
  return CFReadStreamOpen(*(CFReadStreamRef *)(a1 + 8));
}

void HTTPNetStreamInfo::closeAndClearHandler(HTTPNetStreamInfo *this)
{
  __CFReadStream *v2;
  uint64_t v3;
  const void *v4;

  v2 = (__CFReadStream *)*((_QWORD *)this + 1);
  if (v2)
  {
    CFReadStreamSetClient(v2, 0, 0, 0);
    CFReadStreamClose(*((CFReadStreamRef *)this + 1));
  }
  v3 = *((_QWORD *)this + 15);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  *((_QWORD *)this + 15) = 0;
  v4 = (const void *)*((_QWORD *)this + 3);
  if (v4)
  {
    _Block_release(v4);
    *((_QWORD *)this + 3) = 0;
  }
}

uint64_t HTTPNetStreamInfo::getConnectionIdentifier(HTTPNetStreamInfo *this)
{
  return *((_QWORD *)this + 16);
}

uint64_t HTTPNetStreamInfo::copyTrust(HTTPNetStreamInfo *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 16);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 200))(result);
  return result;
}

uint64_t HTTPNetStreamInfo::_conn_no_more_reqests_after_this_one_connectionLost(HTTPNetStreamInfo *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 16);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 288))(result);
  return result;
}

void `non-virtual thunk to'HTTPNetStreamInfo::~HTTPNetStreamInfo(HTTPNetStreamInfo *this)
{
  HTTPNetStreamInfo::~HTTPNetStreamInfo((HTTPNetStreamInfo *)((char *)this - 16));
}

{
  HTTPNetStreamInfo::~HTTPNetStreamInfo((HTTPNetStreamInfo *)((char *)this - 16));
  JUMPOUT(0x186DB748CLL);
}

uint64_t `non-virtual thunk to'HTTPNetStreamInfo::_meta_retain(HTTPNetStreamInfo *this)
{
  return (*(uint64_t (**)(char *))(*((_QWORD *)this - 2) + 160))((char *)this - 16);
}

uint64_t `non-virtual thunk to'HTTPNetStreamInfo::_meta_release(HTTPNetStreamInfo *this)
{
  return (*(uint64_t (**)(char *))(*((_QWORD *)this - 2) + 168))((char *)this - 16);
}

CFTypeRef `non-virtual thunk to'HTTPNetStreamInfo::copyProperty(uint64_t a1, int a2)
{
  __CFReadStream *v2;
  const __CFString *v3;

  v2 = *(__CFReadStream **)(a1 - 8);
  v3 = (const __CFString *)MetaNetStreamInfo::applicableToPropertyName(a2);
  return CFReadStreamCopyProperty(v2, v3);
}

uint64_t `non-virtual thunk to'HTTPNetStreamInfo::setProperty(uint64_t a1, int a2, const void *a3)
{
  __CFReadStream *v4;
  const __CFString *v5;

  v4 = *(__CFReadStream **)(a1 - 8);
  v5 = (const __CFString *)MetaNetStreamInfo::applicableToPropertyName(a2);
  return CFReadStreamSetProperty(v4, v5, a3);
}

uint64_t `non-virtual thunk to'HTTPNetStreamInfo::canScheduleAndOpenWithHandlerAsync(HTTPNetStreamInfo *this)
{
  return 0;
}

uint64_t `non-virtual thunk to'HTTPNetStreamInfo::scheduleAndOpenWithHandler(uint64_t a1, uint64_t a2, void *a3)
{
  return HTTPNetStreamInfo::scheduleAndOpenWithHandler(a1 - 16, a2, a3);
}

void `non-virtual thunk to'HTTPNetStreamInfo::closeAndClearHandler(HTTPNetStreamInfo *this)
{
  HTTPNetStreamInfo::closeAndClearHandler((HTTPNetStreamInfo *)((char *)this - 16));
}

void `non-virtual thunk to'HTTPNetStreamInfo::updateScheduling(HTTPNetStreamInfo *this, CoreSchedulingSet *a2)
{
  HTTPNetStreamInfo::updateScheduling((HTTPNetStreamInfo *)((char *)this - 16), a2);
}

void `non-virtual thunk to'HTTPNetStreamInfo::setBodyStreamBeforeOpening(HTTPNetStreamInfo *this, __CFReadStream *a2)
{
  HTTPNetStreamInfo::setBodyStreamBeforeOpening((HTTPNetStreamInfo *)((char *)this - 16), a2);
}

uint64_t `non-virtual thunk to'HTTPNetStreamInfo::rawBytesSent(HTTPNetStreamInfo *this)
{
  return *((_QWORD *)this + 11);
}

uint64_t `non-virtual thunk to'HTTPNetStreamInfo::rawBytesReceived(HTTPNetStreamInfo *this)
{
  return *((_QWORD *)this + 12);
}

uint64_t `non-virtual thunk to'HTTPNetStreamInfo::getConnectionIdentifier(HTTPNetStreamInfo *this)
{
  return *((_QWORD *)this + 14);
}

uint64_t `non-virtual thunk to'HTTPNetStreamInfo::copyTrust(HTTPNetStreamInfo *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 14);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 200))(result);
  return result;
}

uint64_t `non-virtual thunk to'HTTPNetStreamInfo::_conn_no_more_reqests_after_this_one_connectionLost(HTTPNetStreamInfo *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 14);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 288))(result);
  return result;
}

_QWORD *`non-virtual thunk to'HTTPNetStreamInfo::setProxy(uint64_t a1, uint64_t *a2)
{
  return HTTPNetStreamInfo::setProxy((_QWORD *)(a1 - 16), a2);
}

uint64_t `non-virtual thunk to'HTTPNetStreamInfo::getProxy@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  v2 = *(_QWORD *)(this + 136);
  if (!v2)
    return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(this + 112) + 240))(*(_QWORD *)(this + 112));
  v3 = *(_QWORD *)(this + 144);
  *a2 = v2;
  a2[1] = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  return this;
}

void sub_184046A70(_Unwind_Exception *a1)
{
  _QWORD *v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 19));
  *v1 = &off_1E14E5838;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

NetConnection **HTTPNetStreamInfo::dequeueFromConnection(NetConnection **this)
{
  NetConnection *v1;
  NetConnection **v2;
  __CFRunLoopTimer *v3;
  const void *v4;
  uint64_t v5;
  int v6;

  v1 = this[16];
  if (v1)
  {
    v2 = this;
    this[16] = 0;
    v3 = (__CFRunLoopTimer *)*((_QWORD *)v1 + 32);
    if (v3)
    {
      CFRunLoopTimerInvalidate(v3);
      v4 = (const void *)*((_QWORD *)v1 + 32);
      *((_QWORD *)v1 + 32) = 0;
      if (v4)
        CFRelease(v4);
    }
    if (!NetConnection::dequeue(v1, v2))
    {
      v5 = 4;
      v6 = -4;
      (*(void (**)(NetConnection *, uint64_t *))(*(_QWORD *)v1 + 64))(v1, &v5);
    }
    return (NetConnection **)(*(uint64_t (**)(NetConnection *))(*(_QWORD *)v1 + 48))(v1);
  }
  return this;
}

void HTTPNetStreamInfo::closeAndReleasePayload(HTTPNetStreamInfo *this)
{
  __CFReadStream *v2;

  v2 = (__CFReadStream *)*((_QWORD *)this + 7);
  if (v2)
  {
    CFReadStreamSetClient(v2, 0, 0, 0);
    CFReadStreamClose(*((CFReadStreamRef *)this + 7));
    *((_BYTE *)this + 64) = 1;
  }
  *((_QWORD *)this + 9) = -1;
}

uint64_t NetConnection::getRequestStream(NetConnection *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 12);
  if (!v2)
    return *((_QWORD *)this + 18);
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  v3 = *((_QWORD *)this + 12);
  v4 = *((_QWORD *)this + 18);
  if (v3)
    pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
  return v4;
}

void HTTPNetStreamInfo::sendStreamIsComplete(HTTPNetStreamInfo *this)
{
  const void *v2;
  int v3;
  __CFReadStream *v4;
  int v5;
  NetConnection *v6;

  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2 && (v3 = *((_DWORD *)this + 8), (v3 & 0x100) != 0))
  {
    *((_DWORD *)this + 8) = v3 & 0xFFFFFEFF;
    v4 = (__CFReadStream *)CFRetain(v2);
  }
  else
  {
    v4 = 0;
  }
  v5 = *((_DWORD *)this + 8);
  if ((v5 & 0x200) != 0)
    *((_DWORD *)this + 8) = v5 & 0xFFFFFDFF;
  v6 = (NetConnection *)*((_QWORD *)this + 16);
  if (v6)
    NetConnection::responseIsComplete(v6, this);
  if (v4)
  {
    CFReadStreamSetProperty(v4, CFSTR("_kCFStreamPropertyLargeDownload"), (CFTypeRef)*MEMORY[0x1E0C9AE40]);
    CFRelease(v4);
  }
}

void HTTPNetStreamInfo::HTTPNetStreamInfo(HTTPNetStreamInfo *this, __CFReadStream *a2, CFTypeRef cf, HTTPNetConnection *a4)
{
  char *v6;
  CFTypeRef v7;
  CoreSchedulingSet *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  __int128 v12;

  *(_QWORD *)this = &off_1E14E8A48;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = &unk_1E14E8B68;
  *((_QWORD *)this + 19) = 0;
  v6 = (char *)this + 152;
  *((_QWORD *)this + 20) = 0;
  *((_DWORD *)this + 8) &= 0xFFFE1FFF;
  if (cf)
    v7 = CFRetain(cf);
  else
    v7 = 0;
  *((_QWORD *)this + 5) = v7;
  if (a4)
    (*(void (**)(HTTPNetConnection *))(*(_QWORD *)a4 + 40))(a4);
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 16) = a4;
  *((_QWORD *)this + 17) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  v12 = 0uLL;
  v8 = (CoreSchedulingSet *)std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v6, &v12);
  v9 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1))
  {
    v10 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  *((_QWORD *)this + 21) = CoreSchedulingSet::createEmpty(v8);
}

void sub_184046D44(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  *v1 = &off_1E14E5838;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

void HTTPNetStreamInfo::grabReadStreamProperties(uint64_t a1, uint64_t a2)
{
  _OWORD *v3;
  const __CFAllocator *v5;
  const void *v6;
  _QWORD v7[5];

  v3 = *(_OWORD **)(a1 + 96);
  if (!v3)
  {
    v5 = CFGetAllocator(*(CFTypeRef *)(a1 + 8));
    v3 = CFAllocatorAllocate(v5, 48, 0);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    v6 = CFGetAllocator(*(CFTypeRef *)(a1 + 8));
    *(_QWORD *)v3 = off_1E14E8090;
    *((_QWORD *)v3 + 1) = v6;
    *((_QWORD *)v3 + 2) = &off_1E14EFC70;
    if (v6)
      v6 = CFRetain(v6);
    *((_QWORD *)v3 + 4) = 0;
    *((_QWORD *)v3 + 5) = 0;
    *((_QWORD *)v3 + 3) = v6;
    *(_QWORD *)(a1 + 96) = v3;
  }
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN16CapturedSSLState14grabFromStreamEP16__CoreReadStream_block_invoke;
  v7[3] = &__block_descriptor_40_e22__v16__0____CFString__8l;
  v7[4] = a2;
  CapturedSSLState::grabFromStream(v3, (uint64_t)v7);
}

uint64_t ___ZN16CapturedSSLState14grabFromStreamEP16__CoreReadStream_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  v3 = *(_QWORD *)(a1 + 32);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  if (v3)
    v4 = v3 + 16;
  else
    v4 = 0;
  ++*(_QWORD *)(v4 + 80);
  result = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 24) + 40))(*(_QWORD *)(v4 + 24), a2);
  --*(_QWORD *)(v4 + 80);
  return result;
}

void CapturedSSLState::grabFromStream(_QWORD *a1, uint64_t a2)
{
  uint64_t i;
  const void *v5;
  const __CFDictionary *EmptyDict;
  uint64_t v7;
  const void *v8;
  const void *v9;
  __CFDictionary *MutableDict;

  {
    CapturedSSLState::grabFromStream(void const*({block_pointer})(__CFString const*))::sKeys[0] = (uint64_t)CFSTR("kCFStreamPropertySSLPeerTrust");
    *(_QWORD *)algn_1EDD01338 = 0x1EDCFAB48;
    qword_1EDD01340 = (uint64_t)&unk_1EDCFBFD8;
  }
  for (i = 0; i != 3; ++i)
  {
    v5 = (const void *)CapturedSSLState::grabFromStream(void const*({block_pointer})(__CFString const*))::sKeys[i];
    EmptyDict = (const __CFDictionary *)a1[5];
    if (!EmptyDict)
    {
      EmptyDict = (const __CFDictionary *)a1[4];
      if (!EmptyDict)
        EmptyDict = (const __CFDictionary *)AutoDict::getEmptyDict(0);
    }
    if (!CFDictionaryGetValue(EmptyDict, v5))
    {
      v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, CapturedSSLState::grabFromStream(void const*({block_pointer})(__CFString const*))::sKeys[i]);
      if (v7)
      {
        v8 = (const void *)v7;
        v9 = (const void *)CapturedSSLState::grabFromStream(void const*({block_pointer})(__CFString const*))::sKeys[i];
        MutableDict = AutoDict::getMutableDict((AutoDict *)(a1 + 2));
        CFDictionarySetValue(MutableDict, v9, v8);
        CFRelease(v8);
      }
    }
  }
}

void CapturedSSLState::~CapturedSSLState(CapturedSSLState *this)
{
  *(_QWORD *)this = off_1E14E8090;
  AutoDict::~AutoDict((CapturedSSLState *)((char *)this + 16));
}

void CapturedSSLState::~CapturedSSLState(CFAllocatorRef *this)
{
  *this = (CFAllocatorRef)off_1E14E8090;
  AutoDict::~AutoDict((AutoDict *)(this + 2));
  CFAllocatorDeallocate(this[1], this);
}

uint64_t ___ZN16CapturedSSLState14grabFromStreamEP17__CoreWriteStream_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  v3 = *(_QWORD *)(a1 + 32);
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  if (v3)
    v4 = v3 + 16;
  else
    v4 = 0;
  ++*(_QWORD *)(v4 + 80);
  result = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 24) + 40))(*(_QWORD *)(v4 + 24), a2);
  --*(_QWORD *)(v4 + 80);
  return result;
}

uint64_t ___ZN17HTTPNetStreamInfo18createZombieDoubleEPK13__CFAllocatorP17HTTPNetConnection_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  CFTypeRef v7;
  CFTypeRef v8;
  uint64_t v9;
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFDictionary *v14;
  _BYTE *Value;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  CFStreamClientContext clientContext;

  v4 = *(_QWORD *)(a1 + 40);
  v5 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 48), 184, 0);
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *((_OWORD *)v5 + 4) = 0u;
  *((_OWORD *)v5 + 5) = 0u;
  *((_OWORD *)v5 + 6) = 0u;
  *((_OWORD *)v5 + 7) = 0u;
  *((_OWORD *)v5 + 8) = 0u;
  *((_OWORD *)v5 + 9) = 0u;
  *((_OWORD *)v5 + 10) = 0u;
  v5[22] = 0;
  *(_OWORD *)v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  v6 = *(_QWORD *)(a1 + 56);
  *v5 = &off_1E14E8A48;
  v5[1] = a2;
  v5[2] = &unk_1E14E8B68;
  v5[19] = 0;
  v5[20] = 0;
  *((_DWORD *)v5 + 8) = *(_DWORD *)(v4 + 32) | 4;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
  v5[16] = v6;
  v5[11] = *(_QWORD *)(v4 + 88);
  v7 = *(CFTypeRef *)(v4 + 40);
  if (v7)
    v7 = CFRetain(v7);
  v5[5] = v7;
  v8 = *(CFTypeRef *)(v4 + 80);
  if (v8)
    v8 = CFRetain(v8);
  v5[10] = v8;
  if (*(_QWORD *)(v4 + 56))
  {
    v9 = *(_QWORD *)(v4 + 40);
    if (v9)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      HTTPMessage::setHeaderFieldScalarValue((HTTPMessage *)(v9 + 16), *(_QWORD *)(v9 + 80));
    }
    v10 = (const void *)v5[16];
    v11 = v5[5];
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v12 = v11 + 16;
    if (!v11)
      v12 = 0;
    v13 = *(_QWORD *)(v12 + 72);
    if (v13 && v10)
    {
      if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
        dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
      v14 = *(const __CFDictionary **)(v13 + 168);
      if (v14)
      {
        Value = CFDictionaryGetValue(v14, v10);
        if (Value)
          Value[24] = 0;
      }
    }
    clientContext.version = 0;
    clientContext.info = v5;
    clientContext.retain = (void *(__cdecl *)(void *))_CFNetworkReadStream_retain;
    clientContext.release = (void (__cdecl *)(void *))_CFNetworkReadStream_release;
    clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))_CFNetworkReadStream_copyDesc;
    CFReadStreamSetClient(*(CFReadStreamRef *)(v4 + 56), 0x1AuLL, (CFReadStreamClientCallBack)HTTPNetStreamInfo::_httpRequestPayloadCallBack, &clientContext);
  }
  v16 = *(_QWORD *)(v4 + 168);
  if (!v16)
  {
    v5[21] = 0;
    v18 = v5 + 21;
LABEL_28:
    *v18 = CoreSchedulingSet::createEmpty(0);
    goto LABEL_29;
  }
  v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 88))(v16);
  v5[21] = v17;
  v18 = v5 + 21;
  if (!v17)
    goto LABEL_28;
LABEL_29:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v5;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

void sub_1840472BC(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  *v1 = &off_1E14E5838;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

__CFReadStream *HTTPNetStreamInfo::_httpRequestPayloadCallBack(__CFReadStream *this, __CFReadStream *a2, _QWORD *a3, void *a4)
{
  __CFReadStream *v6;
  NetConnection *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFStreamError Error;

  if (a3)
  {
    v6 = this;
    (*(void (**)(_QWORD *))(*a3 + 160))(a3);
    if (a2 == (__CFReadStream *)16)
      goto LABEL_22;
    if (a2 == (__CFReadStream *)8)
    {
      Error = CFReadStreamGetError(v6);
      v12 = a3[16];
      if (v12)
        (*(void (**)(uint64_t, CFStreamError *))(*(_QWORD *)v12 + 64))(v12, &Error);
      return (__CFReadStream *)(*(uint64_t (**)(_QWORD *))(*a3 + 168))(a3);
    }
    if (a2 == (__CFReadStream *)2)
    {
LABEL_22:
      v7 = (NetConnection *)a3[16];
      if (v7)
      {
        v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v7 + 80))(a3[16]);
        v9 = *((_QWORD *)v7 + 12);
        if (v9)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
          v10 = *((_QWORD *)v7 + 12);
          v11 = *((_QWORD *)v7 + 18);
          if (v10)
            pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8));
          if (!v11)
            return (__CFReadStream *)(*(uint64_t (**)(_QWORD *))(*a3 + 168))(a3);
          goto LABEL_14;
        }
        v11 = *((_QWORD *)v7 + 18);
        if (v11)
        {
LABEL_14:
          if (HTTPNetConnection::transmitRequest(v8, a3, v11, &Error))
          {
            if (Error.error)
              (*(void (**)(NetConnection *, CFStreamError *))(*(_QWORD *)v7 + 64))(v7, &Error);
            else
              NetConnection::requestIsComplete(v7, a3);
          }
        }
      }
    }
    return (__CFReadStream *)(*(uint64_t (**)(_QWORD *))(*a3 + 168))(a3);
  }
  return this;
}

void HTTPNetStreamInfo::closeRequestResources(HTTPNetStreamInfo *this)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __CFReadStream *v9;
  const void *v10;

  v2 = *((_QWORD *)this + 16);
  if (!v2)
    goto LABEL_16;
  v3 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 80))(v2);
  v4 = *((_QWORD *)this + 5);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v5 = v4 + 16;
  if (!v4)
    v5 = 0;
  v6 = *(_QWORD *)(v5 + 72);
  if (v6)
  {
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
    if (HTTPAuthentication::isKerberosThePreferredAuthScheme(*(const __CFDictionary **)(v6 + 152)))
      goto LABEL_16;
    v7 = *((_QWORD *)this + 5);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  }
  else
  {
    v7 = *((_QWORD *)this + 5);
  }
  v8 = v7 + 16;
  if (!v7)
    v8 = 0;
  if (!_CFHTTPAuthenticationIsFirstNTLMTransaction(*(_CFHTTPAuthentication **)(v8 + 72), v3))
  {
LABEL_16:
    v9 = (__CFReadStream *)*((_QWORD *)this + 7);
    if (v9 && !*((_BYTE *)this + 64))
    {
      CFReadStreamSetClient(v9, 0, 0, 0);
      CFReadStreamClose(*((CFReadStreamRef *)this + 7));
      *((_BYTE *)this + 64) = 1;
    }
    *((_QWORD *)this + 9) = -1;
    v10 = (const void *)*((_QWORD *)this + 10);
    if (v10)
    {
      CFRelease(v10);
      *((_QWORD *)this + 10) = 0;
    }
  }
}

void HTTPNetStreamInfo::_stallTimerFired(HTTPNetStreamInfo *this, __CFRunLoopTimer *a2, void *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CFNumberRef v8;
  CFNumberRef v9;
  const void *v10;
  int valuePtr;

  v4 = *((_QWORD *)a2 + 16);
  if (!v4)
    goto LABEL_12;
  v5 = *(_QWORD *)(v4 + 96);
  if (!v5)
  {
    v7 = *(_QWORD *)(v4 + 152);
    if (!v7)
      goto LABEL_12;
    goto LABEL_8;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 8));
  v6 = *(_QWORD *)(v4 + 96);
  v7 = *(_QWORD *)(v4 + 152);
  if (v6)
    pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  if (v7)
  {
LABEL_8:
    valuePtr = 3;
    v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
    if (v8)
    {
      v9 = v8;
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      ++*(_QWORD *)(v7 + 96);
      (*(void (**)(_QWORD))(**(_QWORD **)(v7 + 40) + 32))(*(_QWORD *)(v7 + 40));
      --*(_QWORD *)(v7 + 96);
      CFRelease(v9);
    }
  }
LABEL_12:
  v10 = (const void *)*((_QWORD *)a2 + 22);
  *((_QWORD *)a2 + 22) = 0;
  if (v10)
    CFRelease(v10);
}

uint64_t HTTPFilter::expectedSizeFromHeaders(HTTPFilter *this, __CFHTTPMessage *a2)
{
  char *v3;
  char *v4;
  const __CFString *v5;
  const __CFString *v6;
  int IsRequest;
  int ResponseStatusCode;
  int v9;
  uint64_t v10;
  HTTPMessage *v11;
  const __CFString *v12;
  const __CFString *v13;
  CFIndex Length;
  BOOL v15;
  CFIndex v16;
  int CharacterAtIndex;
  char v18;
  unsigned int v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint8_t v24[16];
  uint8_t buf[16];

  if (CFHTTPMessageIsRequest(this))
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v3 = (char *)this + 16;
    v4 = *((_BYTE *)this + 40) ? 0 : (char *)this + 16;
    v5 = (const __CFString *)*((_QWORD *)v4 + 19);
    if (v5
      || os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
      && (*(_WORD *)v24 = 0,
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", v24, 2u), (v5 = (const __CFString *)*((_QWORD *)v4 + 19)) != 0))
    {
      if (CFStringCompare(v5, (CFStringRef)&gConstantCFStringValueTable[2590], 0) == kCFCompareEqualTo)
        return 0;
    }
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*((_BYTE *)this + 40))
      v3 = 0;
    v6 = (const __CFString *)*((_QWORD *)v3 + 19);
    if (v6
      || os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
      && (*(_WORD *)buf = 0,
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u), (v6 = (const __CFString *)*((_QWORD *)v3 + 19)) != 0))
    {
      if (CFStringCompare(v6, (CFStringRef)&gConstantCFStringValueTable[2597], 0) == kCFCompareEqualTo)
        return 0;
    }
  }
  IsRequest = CFHTTPMessageIsRequest(this);
  ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(this);
  v9 = ResponseStatusCode;
  if (!IsRequest && ResponseStatusCode == 304)
    return 0;
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (this)
    v11 = (HTTPFilter *)((char *)this + 16);
  else
    v11 = 0;
  v12 = HTTPMessage::copyHeaderFieldValue(v11, 0x11D1D2CFu);
  if (!v12)
    goto LABEL_46;
  v13 = v12;
  Length = CFStringGetLength(v12);
  if (Length < 1)
  {
    v16 = 0;
    v15 = 1;
  }
  else
  {
    v15 = 0;
    v16 = 0;
    while (1)
    {
      CharacterAtIndex = CFStringGetCharacterAtIndex(v13, v16);
      if (CharacterAtIndex != 32 && CharacterAtIndex != 9)
        break;
      v15 = ++v16 >= Length;
      if (Length == v16)
      {
        v10 = 0;
        v18 = v16 >= Length;
        goto LABEL_43;
      }
    }
  }
  v18 = v15;
  if (v16 >= Length)
  {
    v10 = 0;
  }
  else
  {
    v10 = 0;
    while (1)
    {
      v19 = CFStringGetCharacterAtIndex(v13, v16);
      if (v19 - 48 > 9)
        break;
      ++v16;
      v20 = 10 * v10 + v19;
      if (v16 < Length && v20 >= 0xCCCCCCCCCCCCCF3)
      {
        CFRelease(v13);
        goto LABEL_46;
      }
      v10 = v20 - 48;
      v18 = 1;
      if (Length == v16)
      {
        CFRelease(v13);
        return v10;
      }
    }
  }
LABEL_43:
  CFRelease(v13);
  if (!v18)
  {
LABEL_46:
    if (IsRequest)
      v21 = 0;
    else
      v21 = v9 == 204;
    v22 = !v21;
    return v22 << 63 >> 63;
  }
  return v10;
}

_QWORD *HTTP3Stream::setProxy(uint64_t a1, uint64_t *a2)
{
  return std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(a1 + 280), *a2, a2[1]);
}

BOOL ___ZN11HTTP3Stream9_receivedEN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamError_block_invoke(uint64_t a1, int a2, int a3, void *__src, size_t a5)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unsigned int v9;
  unint64_t v10;
  size_t v11;
  unsigned __int8 v12;
  unsigned __int8 *v13;
  unint64_t v15;
  unint64_t *v16;

  v6 = *(_QWORD *)(a1 + 40);
  v9 = *(unsigned __int8 *)(v6 + 176);
  v8 = (unint64_t *)(v6 + 176);
  v7 = v9;
  v10 = 8 - v9;
  if (v10 >= a5)
    v11 = a5;
  else
    v11 = v10;
  memcpy((char *)v8 + v7 - 8, __src, v11);
  v12 = *(_BYTE *)v8 + v11;
  *(_BYTE *)v8 = v12;
  v15 = v12;
  v16 = v8 - 1;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = QUICUtilities::quic_vle_decode((QUICUtilities *)&v16, (const unsigned __int8 **)&v15, v8 - 1, v8, v13);
  return *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

void HTTP3Stream::_100ContinueReceived(HTTP3Stream *this)
{
  NSObject *v2;
  void *v3;

  if (*((_DWORD *)this + 28) == 1)
  {
    *((_DWORD *)this + 28) = 2;
    HTTP3Stream::_resumeRequestBody(this);
    (*(void (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 12) + 40))(*((_QWORD *)this + 12), *((_QWORD *)this + 39), 0);
  }
  v2 = *((_QWORD *)this + 17);
  if (v2)
  {
    dispatch_source_cancel(v2);
    v3 = (void *)*((_QWORD *)this + 17);
    *((_QWORD *)this + 17) = 0;

  }
}

uint64_t ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_28(uint64_t a1, CFStreamError a2)
{
  return HTTP3Stream::_handleSendError(*(HTTP3Stream **)(a1 + 32), a2, 1);
}

__n128 __Block_byref_object_copy__5408(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  *((_OWORD *)a1 + 3) = *(_OWORD *)(a2 + 48);
  a1[8] = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = 0;
  result = *(__n128 *)(a2 + 72);
  *(__n128 *)(a1 + 9) = result;
  a1[11] = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  *(_QWORD *)(a2 + 88) = 0;
  return result;
}

void __Block_byref_object_dispose__5409(_QWORD *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[9];
  if (v2)
  {
    a1[10] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[6];
  if (v3)
  {
    a1[7] = v3;
    operator delete(v3);
  }
}

void ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_32(uint64_t a1, NSString *a2, NSString *a3)
{
  HTTP3Fields::appendField((std::vector<char> *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), a2, a3);
}

uint64_t ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_2(uint64_t a1, int a2, CFStreamError a3)
{
  return HTTP3Stream::_handleSendError(*(HTTP3Stream **)(a1 + 32), a3, 1);
}

void HTTP3Fields::~HTTP3Fields(HTTP3Fields *this)
{
  void *v2;
  void *v3;

  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
  {
    *((_QWORD *)this + 4) = v2;
    operator delete(v2);
  }
  v3 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v3;
    operator delete(v3);
  }
}

uint64_t __Block_byref_object_copy__17(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__18(uint64_t a1)
{

}

uint64_t ___ZN11HTTP3Stream12_sendHEADERSERK11HTTP3FieldsbU13block_pointerFvm13CFStreamErrorE_block_invoke_22(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  size_t v7;

  v6 = *(_QWORD *)(a1 + 40);
  v7 = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 32))
     + a2
     + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
  return (*(uint64_t (**)(uint64_t, size_t, uint64_t, uint64_t))(v6 + 16))(v6, v7, a3, a4);
}

uint64_t __copy_helper_block_ea8_96c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(result + 96) = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(result + 104) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_96c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 96);
}

void std::vector<char>::__insert_with_size[abi:nn180100]<char const*,char const*>(uint64_t a1, char *__dst, char *__src, char *a4, int64_t a5)
{
  uint64_t v9;
  _BYTE *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  size_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  int64_t v19;
  _BYTE *v20;
  char *v21;
  char *v22;
  _BYTE *v23;
  char *v24;
  char v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;

  if (a5 < 1)
    return;
  v10 = *(_BYTE **)(a1 + 8);
  v9 = *(_QWORD *)(a1 + 16);
  if (v9 - (uint64_t)v10 < a5)
  {
    v11 = *(char **)a1;
    v12 = (uint64_t)&v10[a5 - *(_QWORD *)a1];
    if (v12 < 0)
      abort();
    v13 = (char *)(__dst - v11);
    v14 = v9 - (_QWORD)v11;
    if (2 * v14 > v12)
      v12 = 2 * v14;
    if (v14 >= 0x3FFFFFFFFFFFFFFFLL)
      v15 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v15 = v12;
    if (v15)
      v16 = (char *)operator new(v15);
    else
      v16 = 0;
    v26 = &v13[(_QWORD)v16];
    memcpy(&v13[(_QWORD)v16], __src, a5);
    if (v11 == __dst)
    {
      v27 = &v13[(_QWORD)v16];
    }
    else
    {
      do
      {
        v13[(_QWORD)v16 - 1] = v13[(_QWORD)(v11 - 1)];
        --v13;
      }
      while (v13);
      v10 = *(_BYTE **)(a1 + 8);
      v27 = v16;
    }
    v28 = &v26[a5];
    v29 = &v16[v15];
    if (v10 != __dst)
      memmove(v28, __dst, v10 - __dst);
    v30 = *(char **)a1;
    *(_QWORD *)a1 = v27;
    *(_QWORD *)(a1 + 8) = &v28[v10 - __dst];
    *(_QWORD *)(a1 + 16) = v29;
    if (v30)
      operator delete(v30);
    return;
  }
  v17 = v10 - __dst;
  if (v10 - __dst >= a5)
  {
    v18 = &__src[a5];
    v20 = *(_BYTE **)(a1 + 8);
LABEL_17:
    v21 = &__dst[a5];
    v22 = &v20[-a5];
    v23 = v20;
    if (&v20[-a5] < v10)
    {
      v24 = (char *)(&v10[a5] - v20);
      v23 = v20;
      do
      {
        v25 = *v22++;
        *v23++ = v25;
        --v24;
      }
      while (v24);
    }
    *(_QWORD *)(a1 + 8) = v23;
    if (v20 != v21)
      memmove(&__dst[a5], __dst, v20 - v21);
    if (v18 != __src)
      memmove(__dst, __src, v18 - __src);
    return;
  }
  v18 = &__src[v17];
  v19 = a4 - &__src[v17];
  if (a4 != &__src[v17])
    memmove(*(void **)(a1 + 8), &__src[v17], a4 - &__src[v17]);
  v20 = &v10[v19];
  *(_QWORD *)(a1 + 8) = &v10[v19];
  if (v17 >= 1)
    goto LABEL_17;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned short,unsigned short>>>(unint64_t a1)
{
  if (a1 >> 62)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(4 * a1);
}

void std::__shared_ptr_pointer<CoreSchedulingSet *,Deleter_release<CoreSchedulingSet>,std::allocator<CoreSchedulingSet>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

_DWORD *std::vector<std::pair<unsigned short,unsigned short>>::__init_with_size[abi:nn180100]<std::pair<unsigned short,unsigned short>*,std::pair<unsigned short,unsigned short>*>(_DWORD *result, int *a2, int *a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  int v8;

  if (a4)
  {
    if (a4 >> 62)
      abort();
    v6 = result;
    result = std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned short,unsigned short>>>(a4);
    *v6 = result;
    v6[1] = result;
    v6[2] = &result[v7];
    while (a2 != a3)
    {
      v8 = *a2++;
      *result++ = v8;
    }
    v6[1] = result;
  }
  return result;
}

char *std::vector<char>::__vallocate[abi:nn180100](_QWORD *a1, size_t __sz)
{
  char *result;

  if ((__sz & 0x8000000000000000) != 0)
    abort();
  result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

void ___ZN11HTTP3Stream22_start100ContinueTimerEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  HTTP3Stream *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(HTTP3Stream **)(a1 + 32);
      if (v5)
        HTTP3Stream::_100ContinueReceived(v5);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_18404813C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c36_ZTSNSt3__18weak_ptrI11HTTP3StreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_ea8_32c36_ZTSNSt3__18weak_ptrI11HTTP3StreamEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void std::__shared_ptr_emplace<RequestBodyData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0B08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<RequestBodyData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0B08;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_emplace<RequestBodyData>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<RequestBodyStream>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0BE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<RequestBodyStream>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0BE8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<__CFReadStream *,Deleter_CFRelease,std::allocator<__CFReadStream>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<MetaConnectionCacheClient *,Deleter_meta_release<MetaConnectionCacheClient>,std::allocator<MetaConnectionCacheClient>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void `non-virtual thunk to'TubeManager::~TubeManager(TubeManager *this)
{
  TubeManager::~TubeManager((TubeManager *)((char *)this - 24));
}

void `non-virtual thunk to'TubeManager::~TubeManager(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  TubeManager::~TubeManager((TubeManager *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,MetaConnectionCache *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA488;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<HTTPConnectionCacheKey const*,MetaConnectionCache *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA488;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,__CFString const*>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA528;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<HTTPConnectionCacheKey const*,__CFString const*>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA528;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

CFMutableArrayRef __Block_byref_object_copy__5474(uint64_t a1, uint64_t a2)
{
  const __CFAllocator *v4;
  CFMutableArrayRef result;

  v4 = CFGetAllocator(*(CFTypeRef *)(a2 + 48));
  result = CFArrayCreateMutableCopy(v4, 0, *(CFArrayRef *)(a2 + 48));
  *(_QWORD *)(a1 + 48) = result;
  return result;
}

void __Block_byref_object_dispose__5475(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 48));
}

void ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_33(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = (*(uint64_t (**)(const void *))(*(_QWORD *)a2 + 64))(a2);
  v5 = 40;
  if (v4 == *(_QWORD *)(a1 + 48))
    v5 = 32;
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + v5) + 8) + 48), a2);
}

void ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_2(uint64_t a1, BaseAwaitingTube *a2)
{
  TubeManager::_onqueue_rdar53306264_addWaiter(*(CFArrayRef **)(a1 + 32), a2, 4);
}

uint64_t ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;

  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 80))(a2);
  if (v4)
    v5 = (_QWORD *)(v4 - 176);
  else
    v5 = 0;
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 136);
  if (v6)
    (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD))(*(_QWORD *)v6 + 280))(v6, v5[10], 3, 0);
  (*(void (**)(_QWORD *, uint64_t, uint64_t, _QWORD))(*v5 + 280))(v5, 4, 4294965096, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
}

__n128 __Block_byref_object_copy__37(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[4].n128_u32[0] = a2[4].n128_u32[0];
  a1[3] = result;
  return result;
}

void TubeManager::_onqueue_rdar53306264_logWaiters(CFArrayRef *this)
{
  CFIndex Count;
  NSObject *v3;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  NSObject *v18;
  _QWORD v19[2];
  uint64_t (*v20)(uint64_t);
  void *v21;
  uint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint8_t buf[4];
  CFIndex v26;
  __int16 v27;
  const void *v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  uint64_t v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  uint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  Count = CFArrayGetCount(this[17]);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v3 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 134217984;
    v26 = Count;
    _os_log_error_impl(&dword_183ECA000, v3, OS_LOG_TYPE_ERROR, "[rdar53306264-LW-S] %ld", buf, 0xCu);
  }
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(this[17], i);
      v6 = ValueAtIndex;
      if (ValueAtIndex)
      {
        v7 = (*(uint64_t (**)(const void *))(*(_QWORD *)ValueAtIndex + 72))(ValueAtIndex);
        v8 = (*(uint64_t (**)(const void *))(*(_QWORD *)v6 + 80))(v6);
        v9 = v8;
        if (v8)
        {
          v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 32))(v8);
          (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)v9 + 72))(&v23, v9);
        }
        else
        {
          v10 = 0;
          v23 = 0;
          v24 = 0;
        }
        v13 = (*(uint64_t (**)(const void *))(*(_QWORD *)v6 + 64))(v6);
        v11 = v13;
        if (v13)
          v12 = Tube::copyWaiter(*(Tube **)(v13 + 112));
        else
          v12 = 0;
      }
      else
      {
        v11 = 0;
        v10 = 0;
        v7 = 0;
        v9 = 0;
        v12 = 0;
        v23 = 0;
        v24 = 0;
      }
      v19[0] = MEMORY[0x1E0C809B0];
      v19[1] = 3221225472;
      v20 = ___ZN11TubeManager32_onqueue_rdar53306264_logWaitersEv_block_invoke;
      v21 = &__block_descriptor_40_e5_v8__0l;
      v22 = v12;
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v14 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134219778;
        v26 = i;
        v27 = 2048;
        v28 = v6;
        v29 = 2048;
        v30 = v7;
        v31 = 2048;
        v32 = v9;
        v33 = 2048;
        v34 = v10;
        v35 = 2114;
        v36 = v23;
        v37 = 2048;
        v38 = v11;
        v39 = 2048;
        v40 = v12;
        _os_log_error_impl(&dword_183ECA000, v14, OS_LOG_TYPE_ERROR, "[rdar53306264-LW] W(%ld/%p) K(%p) C(%p) C.K(%p) C.T(%{public}@) T(%p) T.FW(%p)", buf, 0x52u);
      }
      v20((uint64_t)v19);
      v15 = v24;
      if (v24)
      {
        p_shared_owners = (unint64_t *)&v24->__shared_owners_;
        do
          v17 = __ldaxr(p_shared_owners);
        while (__stlxr(v17 - 1, p_shared_owners));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
      }
    }
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v18 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 134217984;
    v26 = Count;
    _os_log_error_impl(&dword_183ECA000, v18, OS_LOG_TYPE_ERROR, "[rdar53306264-LW-F] %ld", buf, 0xCu);
  }
}

void sub_184048860(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_49(uint64_t a1)
{
  CFArrayRef *v2;
  _OWORD *v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v7;

  v2 = *(CFArrayRef **)(a1 + 32);
  v3 = *(_OWORD **)(a1 + 40);
  v4 = (*(uint64_t (**)(_OWORD *))(*(_QWORD *)v3 + 80))(v3);
  v5 = (*(uint64_t (**)(_OWORD *))(*(_QWORD *)v3 + 88))(v3);
  (*(void (**)(__int128 *__return_ptr, _OWORD *))(*(_QWORD *)v3 + 96))(&v7, v3);
  TubeManager::_onqueue_enqueueRequestForProtocol(v2, v4, v5, &v7, v3);
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 48))(*(_QWORD *)(a1 + 40));
  return (*((uint64_t (**)(CFArrayRef *))*v2 + 6))(v2);
}

void ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_2_51(uint64_t a1, BaseAwaitingTube *a2)
{
  TubeManager::_onqueue_rdar53306264_addWaiter(*(CFArrayRef **)(a1 + 32), a2, 5);
}

void ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_3_52(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;

  if (!a1[7])
    __assert_rtn("_onqueue_newTubeReady_block_invoke_3", "TubeManager.cpp", 919, "connCache != NULL");
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 104))(a2, *(_QWORD *)(a1[4] + 8) + 24, *(_QWORD *)(a1[5] + 8) + 24, *(_QWORD *)(a1[6] + 8) + 48);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0);
  v4 = a1[8];
  v5 = *(_QWORD *)(v4 + 264);
  v6 = *(std::__shared_weak_count **)(v4 + 272);
  v33 = v5;
  v34 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    if (!v5)
      goto LABEL_24;
    v9 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
    v31 = v5;
    v32 = v6;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  else
  {
    if (!v5)
      goto LABEL_24;
    v9 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
    v31 = v5;
    v32 = 0;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v9 + 40))(v9, &v31);
  v11 = v32;
  if (v32)
  {
    v12 = (unint64_t *)&v32->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = a1[9];
  v29 = v33;
  v30 = v34;
  if (v34)
  {
    v15 = (unint64_t *)&v34->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v14 + 56))(v14, &v29);
  v17 = v30;
  if (v30)
  {
    v18 = (unint64_t *)&v30->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
LABEL_24:
  v20 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  v21 = *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
  v22 = a1[7];
  v23 = *(_QWORD *)(a1[6] + 8);
  v27 = *(_OWORD *)(v23 + 48);
  v28 = *(_QWORD *)(v23 + 64);
  (*(void (**)(uint64_t, uint64_t, uint64_t, __int128 *))(*(_QWORD *)v22 + 80))(v22, v20, v21, &v27);
  v24 = v34;
  if (v34)
  {
    v25 = (unint64_t *)&v34->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
}

void sub_184048B50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  va_list va;

  va_start(va, a5);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32);
  _Unwind_Resume(a1);
}

uint64_t ___ZN11TubeManager22_onqueue_createNewTubeEP22HTTPConnectionCacheKey_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const __CFArray *v6;
  _QWORD v8[7];
  _QWORD v9[2];
  uint64_t (*v10)(uint64_t);
  void *v11;
  uint64_t v12;
  CFRange v13;

  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 48);
  v5 = Tube::copyKey(*(Tube **)(v4 + 104));
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v10 = ___ZN11TubeManager31_onqueue_waitingForConnectivityEP4Tube40tcp_connection_unmet_conditions_reason_t_block_invoke;
  v11 = &__block_descriptor_40_e5_v8__0l;
  v12 = v5;
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN11TubeManager31_onqueue_waitingForConnectivityEP4Tube40tcp_connection_unmet_conditions_reason_t_block_invoke_2;
  v8[3] = &__block_descriptor_56_e48_v16__0__BaseAwaitingTube________CFAllocator_iB_8l;
  v8[4] = v4;
  v8[5] = v5;
  v8[6] = a2;
  v6 = *(const __CFArray **)(v3 + 136);
  v13.length = CFArrayGetCount(v6);
  v13.location = 0;
  CFArrayApplyFunction(v6, v13, (CFArrayApplierFunction)RetainableTypedArray<BaseAwaitingTube *>::_invoke, v8);
  return v10((uint64_t)v9);
}

void sub_184048C44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void (*a18)(char *))
{
  a18(&a16);
  _Unwind_Resume(a1);
}

uint64_t ___ZN11TubeManager31_onqueue_waitingForConnectivityEP4Tube40tcp_connection_unmet_conditions_reason_t_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

uint64_t ___ZN11TubeManager31_onqueue_waitingForConnectivityEP4Tube40tcp_connection_unmet_conditions_reason_t_block_invoke_2(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  BOOL v7;
  uint64_t v9;

  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 64))(a2);
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 72))(a2);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 80))(a2);
  if (v4)
    v7 = v5 == 0;
  else
    v7 = 1;
  if (!v7 && result != 0 && v4 == a1[4])
  {
    v9 = result;
    result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 24))(v5, a1[5]);
    if ((_DWORD)result)
    {
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 176))(v9);
      if (!(_DWORD)result)
      {
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 232))(v9);
        if ((_DWORD)result)
          return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 240))(v9, a1[6]);
      }
    }
  }
  return result;
}

void std::__shared_ptr_pointer<TubeManager *,TubeManager::_onqueue_createNewTube(HTTPConnectionCacheKey *)::$_0,std::allocator<TubeManager>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t ___ZN11TubeManager32_onqueue_rdar53306264_logWaitersEv_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

void ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_41()
{
  char *v0;
  char *p_p;
  unsigned __int8 v2;
  char *v3;
  _BYTE *v4;
  void *__p;
  uint64_t v7;
  unsigned __int8 v8;

  v0 = getenv("CFN_USE_HTTP2_CONNECTION_COALESCING");
  if (v0)
  {
    p_p = (char *)&__p;
    std::string::basic_string[abi:nn180100]<0>(&__p, v0);
    v2 = v8;
    if ((v8 & 0x80u) == 0)
      v3 = (char *)&__p + v8;
    else
      v3 = (char *)__p + v7;
    if ((v8 & 0x80u) != 0)
      p_p = (char *)__p;
    if (p_p != v3)
    {
      do
      {
        *p_p = __tolower(*p_p);
        ++p_p;
      }
      while (p_p != v3);
      v2 = v8;
    }
    if ((v2 & 0x80) != 0)
    {
      v4 = __p;
      switch(v7)
      {
        case 1:
          if (*(_BYTE *)__p != 48)
            break;
          goto LABEL_31;
        case 2:
          if (*(_WORD *)__p == 28526)
            goto LABEL_31;
          break;
        case 5:
          goto LABEL_18;
      }
LABEL_33:
      operator delete(v4);
      return;
    }
    if (v2 != 1)
    {
      if (v2 == 2)
      {
        if ((unsigned __int16)__p != 28526)
          return;
        goto LABEL_31;
      }
      if (v2 != 5)
        return;
      v4 = &__p;
LABEL_18:
      if (*(_DWORD *)v4 != 1936482662 || v4[4] != 101)
      {
        if ((v2 & 0x80) == 0)
          return;
LABEL_32:
        v4 = __p;
        goto LABEL_33;
      }
LABEL_31:
      TubeManager::_onqueue_newTubeReady(Tube *,CFStreamError)::disableH2ConnectionCoalescing = 1;
      if ((v2 & 0x80) == 0)
        return;
      goto LABEL_32;
    }
    if (__p == 48)
      goto LABEL_31;
  }
}

void sub_184048EDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<HTTP3ConnectionCache>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0CC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTP3ConnectionCache>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0CC8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void HTTP3ConnectionCacheWrapper::~HTTP3ConnectionCacheWrapper(id *this)
{
  *this = off_1E14EDCE0;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 4));
  *this = off_1E14EA0F0;

}

CFStringRef HTTP3ConnectionCacheWrapper::copyDebugDesc(CFAllocatorRef *this)
{
  return CFStringCreateWithFormat(this[1], 0, CFSTR("HTTP3ConnectionCacheWrapper<@%p> for HTTP3ConnectionCache<@%p>"), this, this[4]);
}

void HTTP3ConnectionCacheWrapper::logConnectionsAtAPSleep(HTTP3ConnectionCacheWrapper *this)
{
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(*((_QWORD *)this + 4) + 88), (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP3ConnectionCacheEntryWrapper *>::_visit, &__block_literal_global_14076);
}

void HTTP3ConnectionCacheWrapper::purgeIdleConnections(CFDictionaryRef **this)
{
  HTTP3ConnectionCache::_connectionsRemoveIdle(this[4]);
}

void HTTP3ConnectionCacheWrapper::markReusedAfterAPSleepWake(HTTP3ConnectionCacheWrapper *this)
{
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(*((_QWORD *)this + 4) + 88), (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP3ConnectionCacheEntryWrapper *>::_visit, &__block_literal_global_5_14081);
}

void HTTP3ConnectionCacheWrapper::enableCellTimer(HTTP3ConnectionCache **this)
{
  HTTP3ConnectionCache::enableCellTimer(this[4]);
}

void ___ZN11TubeManager24invalidateAllConnectionsEb_block_invoke_2(int a1, Tube *this)
{
  *((_BYTE *)this + 216) = 0;
  Tube::_onqueue_cancel(this);
}

const void *TubeManager::_onqueue_getValidAwaitingTubeForKey(CFArrayRef *this, const HTTPConnectionCacheKey *a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  const void *ValueAtIndex;
  uint64_t v8;

  Count = CFArrayGetCount(this[17]);
  if (Count < 1)
    return 0;
  v5 = Count;
  v6 = 0;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(this[17], v6);
    v8 = (*(uint64_t (**)(const void *))(*(_QWORD *)ValueAtIndex + 72))(ValueAtIndex);
    if ((*(unsigned int (**)(uint64_t, const HTTPConnectionCacheKey *))(*(_QWORD *)v8 + 24))(v8, a2))
    {
      if ((*(unsigned int (**)(const void *))(*(_QWORD *)ValueAtIndex + 112))(ValueAtIndex)
        && !(*(unsigned int (**)(const void *))(*(_QWORD *)ValueAtIndex + 128))(ValueAtIndex))
      {
        break;
      }
    }
    if (v5 == ++v6)
      return 0;
  }
  return ValueAtIndex;
}

uint64_t HTTPReadFilter::_streamImpl_Read(HTTPReadFilter *this, char *a2, CFIndex a3, CFStreamError *a4, unsigned __int8 *a5)
{
  pthread_mutex_t *v10;
  __int16 v11;
  const void *v12;
  uint64_t v13;
  SInt32 v14;
  uint64_t v16;
  char v17;
  CFTypeRef cf;
  char v19;
  CFStreamError v20;
  CFStreamError v21;

  v10 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  v11 = *((_WORD *)this + 116);
  if ((v11 & 0x800) != 0)
  {
    a4->domain = 4;
    v14 = -1;
LABEL_12:
    a4->error = v14;
    *a5 = 1;
    pthread_mutex_unlock(v10);
    return -1;
  }
  if ((*((_WORD *)this + 116) & 0x4000) != 0)
  {
    a4->domain = 4;
    v14 = -4;
    goto LABEL_12;
  }
  if ((v11 & 1) != 0)
  {
    a4->domain = 4;
    v14 = -2095;
    goto LABEL_12;
  }
  v12 = (const void *)*((_QWORD *)this + 26);
  if (v12 && !*((_BYTE *)this + 216))
  {
    cf = CFRetain(v12);
    v19 = 0;
    if (*((_QWORD *)this + 30) == -2
      && !HTTPReadFilter::readHeaderBytes((uint64_t)this, (uint64_t)&cf, 1, (UInt8 *)a2, a3, (uint64_t)a4))
    {
      v17 = 1;
      *a5 = 1;
      pthread_mutex_unlock(v10);
      v13 = 0;
    }
    else
    {
      if ((*((_WORD *)this + 116) & 0x20) != 0)
        v16 = HTTPReadFilter::doChunkedRead((uint64_t)this, (uint64_t)&cf, a2, a3, a4, a5);
      else
        v16 = HTTPReadFilter::doPlainRead((uint64_t)this, (uint64_t)&cf, a2, a3, a4, a5);
      v13 = v16;
      if (*a5)
      {
        if (!a4->error && (*((_WORD *)this + 116) & 0x200) != 0)
        {
          *a5 = 0;
          *((_WORD *)this + 116) |= 0x401u;
          if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
            dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
          v21.domain = 0;
          *(_QWORD *)&v21.error = 0;
          CoreStreamBase::_signalEvent(this, 32, v21, 1);
          HTTPReadFilter::clearLargeDownloadFlag((uint64_t)this);
        }
      }
      else if (v16 >= 1 && HTTPReadFilter::canReadNoSignal((uint64_t)this))
      {
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
        v20.domain = 0;
        *(_QWORD *)&v20.error = 0;
        CoreStreamBase::_signalEvent(this, 2, v20, 1);
      }
      v17 = 0;
    }
    if (cf)
      CFRelease(cf);
    if ((v17 & 1) == 0)
      goto LABEL_7;
    return -1;
  }
  a4->domain = 4;
  a4->error = -4;
  *((_WORD *)this + 116) |= 0x4000u;
  *a5 = 1;
  v13 = -1;
LABEL_7:
  pthread_mutex_unlock(v10);
  if (*((_QWORD *)this + 33))
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 25) + 224))(*((_QWORD *)this + 25));
    *((_QWORD *)this + 33) = 0;
  }
  return v13;
}

void sub_1840493C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t HTTPReadFilter::_streamImpl_CanRead(HTTPReadFilter *this)
{
  pthread_mutex_t *v2;
  const void *v3;
  uint64_t NoSignal;
  CFTypeRef cf;
  CFStreamError v7;

  v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  v3 = (const void *)*((_QWORD *)this + 26);
  if (v3 && !*((_BYTE *)this + 216))
  {
    cf = CFRetain(v3);
    NoSignal = HTTPReadFilter::canReadNoSignal((uint64_t)this);
    if (cf)
      CFRelease(cf);
  }
  else
  {
    NoSignal = 0;
    v7.domain = 4;
    v7.error = -4;
    *((_WORD *)this + 116) |= 0x4000u;
  }
  pthread_mutex_unlock(v2);
  if (*((_QWORD *)this + 33))
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 25) + 224))(*((_QWORD *)this + 25));
    *((_QWORD *)this + 33) = 0;
  }
  if (v7.error)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    CoreStreamBase::_signalEvent(this, 8, v7, 1);
  }
  return NoSignal;
}

void sub_1840494F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t HTTPReadFilter::_streamImpl_Open(CFReadStreamRef *this, CFStreamError *a2, unsigned __int8 *a3)
{
  pthread_mutex_t *v6;
  CFReadStreamRef v7;
  uint64_t v8;
  CFReadStreamRef v10;
  CFStreamClientContext clientContext;

  clientContext.version = 0;
  clientContext.info = this;
  clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
  clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
  clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
  v6 = (pthread_mutex_t *)(this + 17);
  pthread_mutex_lock((pthread_mutex_t *)(this + 17));
  v7 = this[26];
  if (v7 && !*((_BYTE *)this + 216))
  {
    CFRetain(v7);
    CFReadStreamSetClient(this[26], 0x1BuLL, (CFReadStreamClientCallBack)HTTPReadFilter::_httpRdFilterStreamCallBack, &clientContext);
    v8 = 1;
    if (CFReadStreamGetStatus(this[26]) || (v8 = CFReadStreamOpen(this[26]), (_DWORD)v8))
    {
      a2->error = 0;
      *a3 = 1;
    }
    else
    {
      *a3 = 1;
      *a2 = CFReadStreamGetError(this[26]);
    }
    v10 = this[26];
    if (v10)
      CFRelease(v10);
  }
  else
  {
    v8 = 0;
    a2->domain = 4;
    a2->error = -4;
    *((_WORD *)this + 116) |= 0x4000u;
  }
  pthread_mutex_unlock(v6);
  return v8;
}

BOOL HTTPReadFilter::_streamImpl_OpenCompleted(HTTPReadFilter *this, CFStreamError *a2)
{
  pthread_mutex_t *v3;
  __CFReadStream *v4;
  _BOOL8 v5;

  v3 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  v4 = (__CFReadStream *)*((_QWORD *)this + 26);
  v5 = v4 && !*((_BYTE *)this + 216) && CFReadStreamGetStatus(v4) > kCFStreamStatusOpening;
  pthread_mutex_unlock(v3);
  return v5;
}

uint64_t HTTPReadFilter::_streamImpl_Close(HTTPReadFilter *this)
{
  pthread_mutex_t *v2;
  __CFReadStream *v3;

  v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  v3 = (__CFReadStream *)*((_QWORD *)this + 26);
  if (v3 && !*((_BYTE *)this + 216))
  {
    CFReadStreamSetClient(v3, 0, 0, 0);
    CFReadStreamClose(*((CFReadStreamRef *)this + 26));
    *((_BYTE *)this + 216) = 1;
  }
  return pthread_mutex_unlock(v2);
}

CFTypeRef HTTPReadFilter::_streamImpl_CopyProperty(HTTPReadFilter *this, const __CFString *a2)
{
  pthread_mutex_t *v4;
  int ExactString;
  const void *v6;
  CFTypeRef *v7;
  CFTypeRef v8;
  const __CFData *v9;
  __CFReadStream *v10;
  CFTypeRef v11;

  v4 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  ExactString = _findExactString(a2, 0);
  if (ExactString <= 403994073)
  {
    if (ExactString == 396711238)
    {
      v9 = (const __CFData *)*((_QWORD *)this + 32);
      if (v9 && CFDataGetLength(v9) >= 1)
      {
        v7 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
      }
      else
      {
        v10 = (__CFReadStream *)*((_QWORD *)this + 26);
        if (v10 && !*((_BYTE *)this + 216))
        {
LABEL_25:
          v8 = CFReadStreamCopyProperty(v10, a2);
          goto LABEL_26;
        }
        v7 = (CFTypeRef *)MEMORY[0x1E0C9AE40];
      }
    }
    else
    {
      if (ExactString != 400823713)
      {
LABEL_18:
        v10 = (__CFReadStream *)*((_QWORD *)this + 26);
        if (!v10 || *((_BYTE *)this + 216))
          goto LABEL_20;
        goto LABEL_25;
      }
      if ((*((_WORD *)this + 116) & 0x200) != 0)
        v7 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
      else
        v7 = (CFTypeRef *)MEMORY[0x1E0C9AE40];
    }
    v11 = *v7;
    goto LABEL_27;
  }
  if (ExactString == 444889076 || ExactString == 442734542)
  {
    if (!CFHTTPMessageIsHeaderComplete(*((CFHTTPMessageRef *)this + 28)))
      goto LABEL_20;
    v6 = (const void *)*((_QWORD *)this + 28);
    if (!v6)
      goto LABEL_20;
    goto LABEL_14;
  }
  if (ExactString != 403994074)
    goto LABEL_18;
  v6 = (const void *)*((_QWORD *)this + 26);
  if (v6)
  {
LABEL_14:
    v8 = CFRetain(v6);
LABEL_26:
    v11 = v8;
    goto LABEL_27;
  }
LABEL_20:
  v11 = 0;
LABEL_27:
  pthread_mutex_unlock(v4);
  return v11;
}

uint64_t HTTPReadFilter::_streamImpl_SetProperty(HTTPReadFilter *this, const __CFString *a2, const void *a3)
{
  pthread_mutex_t *v6;
  uint64_t v7;
  int ExactString;
  const void *v9;
  int v10;
  __int16 v11;
  const void *v12;
  const void *v13;
  int v14;
  char v15;
  const void *v16;
  const void *v18;

  v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  v7 = 0;
  ExactString = _findExactString(a2, 0);
  if (ExactString <= 402953670)
  {
    if (ExactString <= 228814902)
    {
      if (ExactString != 104064896)
      {
        if (ExactString == 224669676)
          goto LABEL_42;
        goto LABEL_31;
      }
      v10 = *((unsigned __int16 *)this + 116) | (*((unsigned __int8 *)this + 234) << 16);
      if ((const void *)*MEMORY[0x1E0C9AE50] != a3)
      {
        *((_BYTE *)this + 234) = BYTE2(v10);
        *((_WORD *)this + 116) = v10 & 0x7FFF;
        v12 = (const void *)*((_QWORD *)this + 26);
        if (v12)
        {
          if (!*((_BYTE *)this + 216))
          {
            CFRetain(v12);
            CFReadStreamSetProperty(*((CFReadStreamRef *)this + 26), a2, a3);
            v13 = (const void *)*((_QWORD *)this + 26);
            if (v13)
              CFRelease(v13);
          }
        }
        goto LABEL_41;
      }
      v11 = *((_WORD *)this + 116) | 0x8000;
      goto LABEL_37;
    }
    if (ExactString == 228814903)
      goto LABEL_42;
    if (ExactString == 400823713)
    {
      v10 = *((unsigned __int16 *)this + 116) | (*((unsigned __int8 *)this + 234) << 16);
      if ((const void *)*MEMORY[0x1E0C9AE50] == a3)
        v11 = *((_WORD *)this + 116) | 0x200;
      else
        v11 = *((_WORD *)this + 116) & 0xFDFF;
LABEL_37:
      *((_BYTE *)this + 234) = BYTE2(v10);
      *((_WORD *)this + 116) = v11;
LABEL_41:
      v7 = 1;
      goto LABEL_42;
    }
LABEL_31:
    v16 = (const void *)*((_QWORD *)this + 26);
    if (v16 && !*((_BYTE *)this + 216))
    {
      CFRetain(v16);
      v7 = CFReadStreamSetProperty(*((CFReadStreamRef *)this + 26), a2, a3);
      v18 = (const void *)*((_QWORD *)this + 26);
      if (v18)
        CFRelease(v18);
    }
    else
    {
      v7 = 0;
    }
    goto LABEL_42;
  }
  if (ExactString > 405149163)
  {
    if (ExactString != 405149164)
    {
      if (ExactString == 407246367)
      {
        if ((const void *)*MEMORY[0x1E0C9AE50] == a3)
          *((_WORD *)this + 116) |= 0x2000u;
        goto LABEL_41;
      }
      goto LABEL_31;
    }
    v14 = *((unsigned __int16 *)this + 116) | (*((unsigned __int8 *)this + 234) << 16);
    if ((const void *)*MEMORY[0x1E0C9AE50] == a3)
      v15 = BYTE2(v14) | 1;
    else
      v15 = BYTE2(v14) & 0xFE;
LABEL_40:
    *((_WORD *)this + 116) = v14;
    *((_BYTE *)this + 234) = v15;
    goto LABEL_41;
  }
  if (ExactString == 402953671)
  {
    v14 = *((unsigned __int16 *)this + 116) | (*((unsigned __int8 *)this + 234) << 16);
    if ((const void *)*MEMORY[0x1E0C9AE50] == a3)
      v15 = BYTE2(v14) | 2;
    else
      v15 = BYTE2(v14) & 0xFD;
    goto LABEL_40;
  }
  if (ExactString != 403994074)
    goto LABEL_31;
  v9 = (const void *)*((_QWORD *)this + 26);
  if (v9 != a3)
  {
    *((_QWORD *)this + 26) = 0;
    if (v9)
      CFRelease(v9);
  }
  v7 = 0;
  if (a3)
    *((_QWORD *)this + 26) = CFRetain(a3);
  else
    *((_BYTE *)this + 216) = 1;
LABEL_42:
  pthread_mutex_unlock(v6);
  return v7;
}

uint64_t HTTPReadFilter::_streamImpl_deprecated_Schedule(HTTPReadFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  pthread_mutex_t *v6;
  __CFReadStream *v7;

  v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  v7 = (__CFReadStream *)*((_QWORD *)this + 26);
  if (v7 && !*((_BYTE *)this + 216))
    CFReadStreamScheduleWithRunLoop(v7, a2, a3);
  return pthread_mutex_unlock(v6);
}

uint64_t HTTPReadFilter::_streamImpl_deprecated_Unschedule(HTTPReadFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  pthread_mutex_t *v6;
  __CFReadStream *v7;

  v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  v7 = (__CFReadStream *)*((_QWORD *)this + 26);
  if (v7 && !*((_BYTE *)this + 216))
    CFReadStreamUnscheduleFromRunLoop(v7, a2, a3);
  return pthread_mutex_unlock(v6);
}

void `non-virtual thunk to'HTTPReadFilter::~HTTPReadFilter(HTTPReadFilter *this)
{
  HTTPReadFilter::~HTTPReadFilter((HTTPReadFilter *)((char *)this - 8));
}

{
  HTTPReadFilter::~HTTPReadFilter((HTTPReadFilter *)((char *)this - 8));
}

{
  HTTPReadFilter::~HTTPReadFilter((HTTPReadFilter *)((char *)this - 120));
}

{
  HTTPReadFilter::~HTTPReadFilter((HTTPReadFilter *)((char *)this - 120));
}

{
  HTTPReadFilter::~HTTPReadFilter((HTTPReadFilter *)((char *)this - 128));
}

{
  HTTPReadFilter::~HTTPReadFilter((HTTPReadFilter *)((char *)this - 128));
}

uint64_t `non-virtual thunk to'HTTPReadFilter::_streamImpl_SetProperty(HTTPReadFilter *this, const __CFString *a2, const void *a3)
{
  return HTTPReadFilter::_streamImpl_SetProperty((HTTPReadFilter *)((char *)this - 120), a2, a3);
}

CFTypeRef `non-virtual thunk to'HTTPReadFilter::_streamImpl_CopyProperty(HTTPReadFilter *this, const __CFString *a2)
{
  return HTTPReadFilter::_streamImpl_CopyProperty((HTTPReadFilter *)((char *)this - 120), a2);
}

uint64_t `non-virtual thunk to'HTTPReadFilter::_streamImpl_Open(CFReadStreamRef *this, CFStreamError *a2, unsigned __int8 *a3)
{
  return HTTPReadFilter::_streamImpl_Open(this - 15, a2, a3);
}

BOOL `non-virtual thunk to'HTTPReadFilter::_streamImpl_OpenCompleted(HTTPReadFilter *this, CFStreamError *a2)
{
  return HTTPReadFilter::_streamImpl_OpenCompleted((HTTPReadFilter *)((char *)this - 120), a2);
}

uint64_t `non-virtual thunk to'HTTPReadFilter::_streamImpl_Close(HTTPReadFilter *this)
{
  return HTTPReadFilter::_streamImpl_Close((HTTPReadFilter *)((char *)this - 120));
}

uint64_t `non-virtual thunk to'HTTPReadFilter::_streamImpl_Read(HTTPReadFilter *this, char *a2, CFIndex a3, CFStreamError *a4, unsigned __int8 *a5)
{
  return HTTPReadFilter::_streamImpl_Read((HTTPReadFilter *)((char *)this - 120), a2, a3, a4, a5);
}

uint64_t `non-virtual thunk to'HTTPReadFilter::_streamImpl_CanRead(HTTPReadFilter *this)
{
  return HTTPReadFilter::_streamImpl_CanRead((HTTPReadFilter *)((char *)this - 120));
}

uint64_t `non-virtual thunk to'HTTPReadFilter::_streamImpl_deprecated_Schedule(HTTPReadFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  return HTTPReadFilter::_streamImpl_deprecated_Schedule((HTTPReadFilter *)((char *)this - 120), a2, a3);
}

uint64_t `non-virtual thunk to'HTTPReadFilter::_streamImpl_deprecated_Unschedule(HTTPReadFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  return HTTPReadFilter::_streamImpl_deprecated_Unschedule((HTTPReadFilter *)((char *)this - 120), a2, a3);
}

void HTTPReadFilter::~HTTPReadFilter(HTTPReadFilter *this)
{
  pthread_mutex_t *v2;
  __CFReadStream *v3;
  const void *v4;
  const void *v5;

  *(_QWORD *)this = &off_1E14E6DC0;
  *((_QWORD *)this + 1) = &unk_1E14E6E60;
  *((_QWORD *)this + 15) = &unk_1E14E6E80;
  *((_QWORD *)this + 16) = &unk_1E14E6F38;
  v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  v3 = (__CFReadStream *)*((_QWORD *)this + 26);
  if (!v3)
  {
    *((_QWORD *)this + 26) = 0;
    goto LABEL_7;
  }
  if (*((_BYTE *)this + 216))
  {
    *((_QWORD *)this + 26) = 0;
  }
  else
  {
    CFReadStreamSetClient(v3, 0, 0, 0);
    CFReadStreamClose(*((CFReadStreamRef *)this + 26));
    v3 = (__CFReadStream *)*((_QWORD *)this + 26);
    *((_QWORD *)this + 26) = 0;
    if (!v3)
      goto LABEL_7;
  }
  CFRelease(v3);
LABEL_7:
  v4 = (const void *)*((_QWORD *)this + 28);
  *((_QWORD *)this + 28) = 0;
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 32);
  *((_QWORD *)this + 32) = 0;
  if (v5)
    CFRelease(v5);
  pthread_mutex_unlock(v2);
  *((_QWORD *)this + 16) = &off_1E14E6990;
  pthread_mutex_destroy(v2);
  *(_QWORD *)this = &off_1E14E9310;
  *((_QWORD *)this + 1) = &unk_1E14E9378;
  *((_QWORD *)this + 15) = &unk_1E14E9398;
  CoreStreamBase::~CoreStreamBase(this);
}

void sub_184049D10(_Unwind_Exception *a1)
{
  CoreStreamBase *v1;
  pthread_mutex_t *v2;

  *((_QWORD *)v1 + 16) = &off_1E14E6990;
  pthread_mutex_destroy(v2);
  *(_QWORD *)v1 = &off_1E14E9310;
  *((_QWORD *)v1 + 1) = &unk_1E14E9378;
  *((_QWORD *)v1 + 15) = &unk_1E14E9398;
  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

void HTTPReadFilter::_httpRdFilterStreamCallBack(HTTPReadFilter *this, __CFReadStream *a2, uint64_t a3, void *a4)
{
  pthread_mutex_t *v7;
  int v8;
  const void *v9;
  char *v10;
  uint64_t v11;
  __CFReadStream *v12;
  CFIndex domain;
  unint64_t v14;
  char *v15;
  CoreStreamBase *v16;
  uint64_t v17;
  CFStreamError v18;
  const void *v19;
  __CFReadStream *v20;
  CFStreamError Error;
  uint64_t v22;
  HTTPMessage *v23;
  const char *v24;
  const __CFData **v25;
  unint64_t v26;
  int v27;
  CFStreamError v28;
  CFStreamError v29;

  v7 = (pthread_mutex_t *)(a3 + 136);
  pthread_mutex_lock((pthread_mutex_t *)(a3 + 136));
  if (*(HTTPReadFilter **)(a3 + 208) != this || !this)
  {
    pthread_mutex_unlock(v7);
    return;
  }
  v8 = *(unsigned __int8 *)(a3 + 216);
  pthread_mutex_unlock(v7);
  if (!v8)
  {
    v9 = (const void *)(a3 - 16);
    CFRetain((CFTypeRef)(a3 - 16));
    if (a2 == (__CFReadStream *)16)
    {
      if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)a3 + 72))(a3))
      {
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
        v29.domain = 0;
        *(_QWORD *)&v29.error = 0;
        CoreStreamBase::_signalEvent((CoreStreamBase *)a3, 16, v29, 1);
      }
      goto LABEL_37;
    }
    if (a2 == (__CFReadStream *)8)
    {
      pthread_mutex_lock(v7);
      v12 = *(__CFReadStream **)(a3 + 208);
      if (v12 && !*(_BYTE *)(a3 + 216))
      {
        Error = CFReadStreamGetError(v12);
        domain = Error.domain;
        v14 = *(_QWORD *)&Error.error;
        if (Error.domain == 1 && (Error.error == 54 || Error.error == 32))
        {
          v22 = *(_QWORD *)(a3 + 224);
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
          if (v22)
            v23 = (HTTPMessage *)(v22 + 16);
          else
            v23 = 0;
          HTTPMessage::ensureParserFinished(v23);
          if (!*((_QWORD *)v23 + 5)
            || (v25 = (const __CFData **)*((_QWORD *)v23 + 6)) == 0
            || !HTTPBodyData::getLength(v25, v24))
          {
            v14 = *(_QWORD *)&Error.error & 0xFFFFFFFF00000000 | 0xFFFFFFFC;
            domain = 4;
          }
        }
      }
      else
      {
        *(_WORD *)(a3 + 232) |= 0x4000u;
        domain = 4;
        v14 = 4294967292;
      }
      v15 = (char *)CFRetain(v9);
      pthread_mutex_unlock(v7);
      if (!v15)
        goto LABEL_37;
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      v16 = (CoreStreamBase *)(v15 + 16);
      v17 = 8;
      v18.domain = domain;
      *(_QWORD *)&v18.error = v14;
    }
    else
    {
      if (a2 == (__CFReadStream *)2)
      {
        pthread_mutex_lock(v7);
        v10 = (char *)CFRetain((CFTypeRef)(a3 - 16));
        pthread_mutex_unlock(v7);
        if (v10 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)a3 + 72))(a3))
        {
          v11 = 2;
          goto LABEL_11;
        }
        pthread_mutex_lock(v7);
        v20 = *(__CFReadStream **)(a3 + 208);
        if (v20 && !*(_BYTE *)(a3 + 216))
        {
          v26 = CFReadStreamGetStatus(v20) - 8;
          pthread_mutex_unlock(v7);
          if (v26 <= 0xFFFFFFFFFFFFFFFCLL)
          {
            pthread_mutex_lock(v7);
            v27 = *(unsigned __int16 *)(a3 + 232) | (*(unsigned __int8 *)(a3 + 234) << 16);
            if ((*(_WORD *)(a3 + 232) & 0x601) == 0x201)
            {
              *(_BYTE *)(a3 + 234) = BYTE2(v27);
              *(_WORD *)(a3 + 232) = v27 | 0x400;
              HTTPReadFilter::clearLargeDownloadFlag(a3);
              v11 = 32;
            }
            else
            {
              v11 = 0;
            }
            pthread_mutex_unlock(v7);
            if (v10)
            {
LABEL_11:
              if (v11)
              {
                if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
                  dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
                v28.domain = 0;
                *(_QWORD *)&v28.error = 0;
                CoreStreamBase::_signalEvent((CoreStreamBase *)(v10 + 16), v11, v28, 1);
                goto LABEL_35;
              }
            }
          }
        }
        else
        {
          pthread_mutex_unlock(v7);
        }
        if (v10)
        {
LABEL_35:
          v19 = v10;
          goto LABEL_36;
        }
LABEL_37:
        CFRelease(v9);
        return;
      }
      pthread_mutex_lock(v7);
      v15 = (char *)CFRetain((CFTypeRef)(a3 - 16));
      pthread_mutex_unlock(v7);
      if (!v15)
        goto LABEL_37;
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      v16 = (CoreStreamBase *)(v15 + 16);
      v17 = (uint64_t)a2;
      v18.domain = 0;
      *(_QWORD *)&v18.error = 0;
    }
    CoreStreamBase::_signalEvent(v16, v17, v18, 1);
    v19 = v15;
LABEL_36:
    CFRelease(v19);
    goto LABEL_37;
  }
}

uint64_t HTTPReadFilter::clearLargeDownloadFlag(uint64_t this)
{
  int v1;
  unsigned int v2;

  v1 = *(unsigned __int16 *)(this + 232);
  if ((v1 & 0x40) != 0)
  {
    v2 = v1 & 0xFFFFFFBF | (*(unsigned __int8 *)(this + 234) << 16);
    *(_WORD *)(this + 232) = v1 & 0xFFBF;
    *(_BYTE *)(this + 234) = BYTE2(v2);
    if (*(_QWORD *)(this + 208))
    {
      if (!*(_BYTE *)(this + 216))
        return CFReadStreamSetProperty(*(CFReadStreamRef *)(this + 208), CFSTR("_kCFStreamPropertyLargeDownload"), (CFTypeRef)*MEMORY[0x1E0C9AE40]);
    }
  }
  return this;
}

uint64_t HTTPReadFilter::canReadNoSignal(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t result;
  int v6;
  unsigned int v7;
  int v8;
  CFStreamError *v9;
  CFReadStreamRef *v10;
  uint64_t v11;
  BOOL v12;
  int v13;
  const __CFData *v14;
  UInt8 __dst[4096];
  uint64_t v16;

  v4 = MEMORY[0x1E0C80A78](a1);
  result = 0;
  v16 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)(v2 + 8) = 0;
  v6 = *(unsigned __int16 *)(v4 + 232);
  v7 = v6 | (*(unsigned __int8 *)(v4 + 234) << 16);
  if ((v6 & 1) == 0)
  {
    v8 = v3;
    v9 = (CFStreamError *)v2;
    v10 = (CFReadStreamRef *)v1;
    v11 = *(_QWORD *)(v4 + 240);
    if (v11 != -2)
    {
LABEL_6:
      if ((v7 & 0x20) != 0 && (v11 != -3 ? (v12 = v11 == *(_QWORD *)(v4 + 248)) : (v12 = 1), v12))
      {
        if ((v7 & 0x100) != 0)
          return 1;
        result = HTTPReadFilter::readChunkedHeader(v4, (uint64_t)v10, 0, __dst, 4096, v9);
        if (!(_DWORD)result)
          return result;
        v11 = *(_QWORD *)(v4 + 240);
        if (v11 == -3)
          return 0;
        v7 = *(unsigned __int16 *)(v4 + 232) | (*(unsigned __int8 *)(v4 + 234) << 16);
        v13 = (v7 >> 8) & 1;
      }
      else
      {
        LOBYTE(v13) = 0;
      }
      if ((v13 & 1) == 0 && v11 == *(_QWORD *)(v4 + 248))
      {
        if ((v7 & 0x200) != 0)
        {
          result = 0;
          *(_BYTE *)(v4 + 234) = BYTE2(v7);
          *(_WORD *)(v4 + 232) = v7 | 1;
          return result;
        }
        return 1;
      }
      v14 = *(const __CFData **)(v4 + 256);
      if (v14 && CFDataGetLength(v14))
        return 1;
      if (v8)
        return CFReadStreamHasBytesAvailable(*v10) != 0;
      return 0;
    }
    result = HTTPReadFilter::readHeaderBytes(v4, v1, 0, __dst, 4096, v2);
    if ((_DWORD)result)
    {
      result = CFHTTPMessageIsHeaderComplete(*(CFHTTPMessageRef *)(v4 + 224));
      if ((_DWORD)result)
      {
        v7 = *(unsigned __int16 *)(v4 + 232) | (*(unsigned __int8 *)(v4 + 234) << 16);
        v11 = *(_QWORD *)(v4 + 240);
        goto LABEL_6;
      }
    }
  }
  return result;
}

uint64_t HTTPReadFilter::readHeaderBytes(uint64_t a1, uint64_t a2, int a3, UInt8 *a4, CFIndex a5, uint64_t a6)
{
  const __CFString *v12;
  uint64_t *v13;
  const __CFData *v14;
  CFIndex Length;
  const UInt8 *BytePtr;
  int appended;
  const void *v18;
  __CFHTTPMessage *v19;
  __CFHTTPMessage *v20;
  CFIndex ResponseStatusCode;
  int v22;
  const void *v23;
  int v24;
  CFIndex v25;
  uint64_t v26;
  const char *v27;
  const __CFData **v28;
  int v29;
  uint64_t v31;
  uint64_t v32;
  const void *v33;
  uint64_t v34;
  HTTPMessage *v35;
  const char *v36;
  HTTPBodyData *v37;
  BOOL v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  CFIndex v44;
  CFIndex v45;
  int v46;
  const __CFAllocator *v47;
  CFHTTPMessageRef Empty;
  const void *v49;
  unsigned int v50;
  int v51;
  uint64_t result;
  _WORD *v53;
  __int16 v54;
  __int16 v55;
  CFStreamError Error;
  uint64_t v57;
  HTTPMessage *v58;
  const char *v59;
  const __CFData **v60;
  __int16 v61;
  BOOL v62;
  int v63;
  uint64_t v64;
  HTTPMessage *v65;
  CFStringRef v66;
  __CFHTTPMessage *v67;
  const __CFString *v68;
  const __CFAllocator *v69;
  const __CFArray *ArrayBySeparatingStrings;
  CFIndex Count;
  CFIndex v72;
  CFIndex v73;
  const __CFString *ValueAtIndex;
  unsigned int v75;
  const void *v76;
  const __CFAllocator *v77;
  __CFArray *MutableCopy;
  const __CFAllocator *v79;
  uint64_t v80;
  HTTPMessage *v81;
  int v82;
  int v83;
  uint64_t v84;
  const __CFData *v85;
  int v86;
  const __CFString *v87;
  CFStreamError v88;
  CFRange v89;

  v12 = (const __CFString *)&unk_1EDD00488;
  v13 = &HSTSCache::defaultStoreURL(void)::once;
  while (2)
  {
    v14 = *(const __CFData **)(a1 + 256);
    if (!v14)
    {
      v19 = (__CFHTTPMessage *)CFReadStreamCopyProperty(*(CFReadStreamRef *)a2, v12);
      if (!v19)
        goto LABEL_18;
      v20 = v19;
      ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v19);
      if (v13[127] != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (*((_QWORD *)v20 + 13))
      {
        CFRelease(v20);
        goto LABEL_18;
      }
      if (ResponseStatusCode == 200)
      {
        CFRelease(v20);
        v22 = *(_WORD *)(a1 + 232) & 0xEFFF | (*(unsigned __int8 *)(a1 + 234) << 16);
        *(_WORD *)(a1 + 232) &= ~0x1000u;
        *(_BYTE *)(a1 + 234) = BYTE2(v22);
        goto LABEL_18;
      }
      v23 = *(const void **)(a1 + 224);
      if (v23)
        CFRelease(v23);
      *(_QWORD *)(a1 + 224) = v20;
      v24 = *(unsigned __int16 *)(a1 + 232) | (*(unsigned __int8 *)(a1 + 234) << 16);
      if (ResponseStatusCode == 407)
      {
        *(_BYTE *)(a1 + 234) = BYTE2(v24);
        *(_WORD *)(a1 + 232) = v24 | 8;
        goto LABEL_18;
      }
      result = 0;
      *(_BYTE *)(a1 + 234) = BYTE2(v24);
      *(_WORD *)(a1 + 232) = v24 | 0x10;
      *(_QWORD *)a6 = 4;
      *(_DWORD *)(a6 + 8) = -2096;
      return result;
    }
    Length = CFDataGetLength(v14);
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 256));
    appended = CFHTTPMessageAppendBytes(*(CFHTTPMessageRef *)(a1 + 224), BytePtr, Length);
    v18 = *(const void **)(a1 + 256);
    if (v18)
      CFRelease(v18);
    *(_QWORD *)(a1 + 256) = 0;
    if (!appended)
    {
LABEL_81:
      result = 0;
      *(_QWORD *)a6 = 4;
      *(_DWORD *)(a6 + 8) = -1;
      v54 = *(_WORD *)(a1 + 232);
      v53 = (_WORD *)(a1 + 232);
      v55 = v54 | 0x800;
LABEL_95:
      *v53 = v55;
      return result;
    }
LABEL_18:
    while (!CFHTTPMessageIsHeaderComplete(*(CFHTTPMessageRef *)(a1 + 224))
         && (a3 || CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)a2)))
    {
      *(_BYTE *)(a2 + 8) = 1;
      v25 = CFReadStreamRead(*(CFReadStreamRef *)a2, a4, a5);
      if (v25)
      {
        if (v25 < 0)
          break;
        *(_QWORD *)(a1 + 264) += v25;
        if (!CFHTTPMessageAppendBytes(*(CFHTTPMessageRef *)(a1 + 224), a4, v25))
          goto LABEL_81;
      }
      else
      {
        v26 = *(_QWORD *)(a1 + 224);
        if (v26)
        {
          if (v13[127] != -1)
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
          if (*(_BYTE *)(v26 + 40))
            v26 += 16;
          else
            v26 = 0;
        }
        HTTPMessage::ensureParserFinished((HTTPMessage *)v26);
        if (*(_QWORD *)(v26 + 40)
          && (v28 = *(const __CFData ***)(v26 + 48)) != 0
          && HTTPBodyData::getLength(v28, v27))
        {
          if (!*(_QWORD *)(v26 + 288))
            goto LABEL_43;
        }
        else
        {
          if (*(_QWORD *)(v26 + 88))
            goto LABEL_94;
          if (!*(_QWORD *)(v26 + 288))
          {
            if (!*(_BYTE *)(v26 + 160))
            {
              v29 = *(_DWORD *)(v26 + 128);
              if (v29 == -1 || v29 == 200)
                goto LABEL_94;
            }
LABEL_43:
            if (!*(_BYTE *)(v26 + 160)
              && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v26 + 80))(v26, "", 0))
            {
              break;
            }
          }
        }
      }
    }
    if (CFReadStreamGetStatus(*(CFReadStreamRef *)a2) == kCFStreamStatusError)
    {
      Error = CFReadStreamGetError((CFReadStreamRef)*(_QWORD *)a2);
      *(CFStreamError *)a6 = Error;
      if (Error.domain != 1 || Error.error != 54 && Error.error != 32)
        return 0;
      v57 = *(_QWORD *)(a1 + 224);
      if (v13[127] != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v58 = v57 ? (HTTPMessage *)(v57 + 16) : 0;
      HTTPMessage::ensureParserFinished(v58);
      if (*((_QWORD *)v58 + 5))
      {
        v60 = (const __CFData **)*((_QWORD *)v58 + 6);
        if (v60)
        {
          if (HTTPBodyData::getLength(v60, v59))
            return 0;
        }
      }
      goto LABEL_94;
    }
    if (!CFHTTPMessageIsHeaderComplete(*(CFHTTPMessageRef *)(a1 + 224)))
      return 1;
    v31 = *(_QWORD *)(a1 + 224);
    if (v31)
    {
      if (v13[127] != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v32 = v31 + 16;
      if (!*(_BYTE *)(v31 + 40))
        v32 = 0;
    }
    else
    {
      v32 = 0;
    }
    if (*(_QWORD *)(v32 + 288) || *(_BYTE *)(v32 + 160) || (v51 = *(_DWORD *)(v32 + 128), v51 != -1) && v51 != 200)
    {
      *(_WORD *)(a1 + 232) |= 0x1000u;
    }
    else if ((*(_WORD *)(a1 + 232) & 0x1000) != 0)
    {
LABEL_94:
      result = 0;
      *(_QWORD *)a6 = 4;
      *(_DWORD *)(a6 + 8) = -4;
      v61 = *(_WORD *)(a1 + 232);
      v53 = (_WORD *)(a1 + 232);
      v55 = v61 | 0x4000;
      goto LABEL_95;
    }
    v33 = *(const void **)(a1 + 256);
    *(_QWORD *)(a1 + 256) = 0;
    if (v33)
      CFRelease(v33);
    v34 = *(_QWORD *)(a1 + 224);
    if (v13[127] != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (v34)
      v35 = (HTTPMessage *)(v34 + 16);
    else
      v35 = 0;
    HTTPMessage::ensureParserFinished(v35);
    v37 = (HTTPBodyData *)*((_QWORD *)v35 + 6);
    *((_QWORD *)v35 + 6) = 0;
    if (v37)
    {
      v38 = HTTPBodyData::captureData(v37, v36);
      v87 = v12;
      v39 = v13;
      v40 = a6;
      v42 = v41;
      (*(void (**)(HTTPBodyData *))(*(_QWORD *)v37 + 8))(v37);
      v43 = *(_WORD *)(a1 + 232) & 0xFFFD | (*(unsigned __int8 *)(a1 + 234) << 16);
      *(_WORD *)(a1 + 232) = *(_WORD *)(a1 + 232) & 0xFFFD | (2 * v38);
      *(_BYTE *)(a1 + 234) = BYTE2(v43);
      *(_QWORD *)(a1 + 256) = v42;
      a6 = v40;
      v13 = v39;
      v12 = v87;
    }
    v44 = CFHTTPMessageGetResponseStatusCode(*(CFHTTPMessageRef *)(a1 + 224));
    v45 = v44;
    if (v44 != 101)
    {
      if ((unint64_t)(v44 - 100) > 0x63)
      {
        v63 = *(unsigned __int16 *)(a1 + 232) | (*(unsigned __int8 *)(a1 + 234) << 16);
        v62 = v44 == 304;
        goto LABEL_97;
      }
LABEL_71:
      v47 = CFGetAllocator(*(CFTypeRef *)(a1 + 224));
      Empty = CFHTTPMessageCreateEmpty(v47, 0);
      v49 = *(const void **)(a1 + 224);
      *(_QWORD *)(a1 + 224) = 0;
      if (v49)
        CFRelease(v49);
      *(_QWORD *)(a1 + 224) = Empty;
      if (v45 == 100)
      {
        v50 = (*(unsigned __int16 *)(a1 + 232) | (*(unsigned __int8 *)(a1 + 234) << 16)) & 0xFFFEFFFF;
        *(_WORD *)(a1 + 232) = *(_WORD *)(a1 + 232);
        *(_BYTE *)(a1 + 234) = BYTE2(v50);
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
        v88.domain = 0;
        *(_QWORD *)&v88.error = 0;
        CoreStreamBase::_signalEvent((CoreStreamBase *)a1, 64, v88, 1);
      }
      continue;
    }
    break;
  }
  v46 = *(unsigned __int16 *)(a1 + 232) | (*(unsigned __int8 *)(a1 + 234) << 16);
  if ((v46 & 0x20000) == 0)
    goto LABEL_71;
  v62 = 0;
  v63 = v46 | 0x2000;
  *(_BYTE *)(a1 + 234) = BYTE2(v46);
  *(_WORD *)(a1 + 232) = v46 | 0x2000;
LABEL_97:
  if (v62 || (v63 & 0x2000) != 0)
  {
    v75 = v63 & 0xFFFFDFFF;
    *(_WORD *)(a1 + 232) = v75;
    *(_BYTE *)(a1 + 234) = BYTE2(v75);
    goto LABEL_137;
  }
  v64 = *(_QWORD *)(a1 + 224);
  if (v13[127] != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (v64)
    v65 = (HTTPMessage *)(v64 + 16);
  else
    v65 = 0;
  v66 = HTTPMessage::copyHeaderFieldValue(v65, 0x146233E1u);
  if (v66)
  {
    v68 = v66;
    v69 = CFGetAllocator(v66);
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v69, v68, CFSTR(","));
    Count = CFArrayGetCount(ArrayBySeparatingStrings);
    if (Count >= 1)
    {
      v72 = Count;
      v73 = 0;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v73);
        v89.length = CFStringGetLength(ValueAtIndex);
        v89.location = 0;
        if (CFStringFindWithOptions(ValueAtIndex, (CFStringRef)&unk_1EDCFDBA0, v89, 1uLL, 0))
          break;
        if (v72 == ++v73)
          goto LABEL_124;
      }
      if (v72 == 1)
      {
        v76 = CFRetain(&unk_1EDCFDCF0);
      }
      else
      {
        v77 = CFGetAllocator(v68);
        MutableCopy = CFArrayCreateMutableCopy(v77, v72, ArrayBySeparatingStrings);
        CFArrayRemoveValueAtIndex(MutableCopy, v73);
        v79 = CFGetAllocator(v68);
        v76 = CFStringCreateByCombiningStrings(v79, ArrayBySeparatingStrings, CFSTR(","));
        if (MutableCopy)
          CFRelease(MutableCopy);
      }
      v80 = *(_QWORD *)(a1 + 224);
      if (v13[127] != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (v80)
        v81 = (HTTPMessage *)(v80 + 16);
      else
        v81 = 0;
      HTTPMessage::setHeaderFieldStringValue(v81, 0x146233E1u, v76);
      if (v76)
        CFRelease(v76);
      *(_WORD *)(a1 + 232) |= 0x20u;
    }
LABEL_124:
    if (ArrayBySeparatingStrings)
      CFRelease(ArrayBySeparatingStrings);
    CFRelease(v68);
  }
  v82 = *(unsigned __int16 *)(a1 + 232);
  v83 = v82 | (*(unsigned __int8 *)(a1 + 234) << 16);
  if ((v82 & 0x20) != 0)
  {
    *(_BYTE *)(a1 + 234) = BYTE2(v83);
    *(_WORD *)(a1 + 232) = v83 | 4;
    goto LABEL_137;
  }
  v84 = HTTPFilter::expectedSizeFromHeaders(*(HTTPFilter **)(a1 + 224), v67);
  *(_QWORD *)(a1 + 240) = v84;
  if (v84 == -1)
  {
    if (CFReadStreamGetStatus(*(CFReadStreamRef *)a2) != kCFStreamStatusAtEnd
      || (v85 = *(const __CFData **)(a1 + 256)) != 0 && CFDataGetLength(v85))
    {
      v84 = *(_QWORD *)(a1 + 240);
      goto LABEL_133;
    }
LABEL_137:
    *(_QWORD *)(a1 + 240) = 0;
  }
  else
  {
LABEL_133:
    if (v84 > 0x4000)
    {
      v86 = *(unsigned __int16 *)(a1 + 232) | (*(unsigned __int8 *)(a1 + 234) << 16);
      if ((*(_WORD *)(a1 + 232) & 0x8040) == 0x8000)
      {
        *(_BYTE *)(a1 + 234) = BYTE2(v86);
        *(_WORD *)(a1 + 232) = v86 | 0x40;
        CFReadStreamSetProperty(*(CFReadStreamRef *)a2, CFSTR("_kCFStreamPropertyLargeDownload"), (CFTypeRef)*MEMORY[0x1E0C9AE50]);
      }
    }
  }
  return 1;
}

uint64_t HTTPReadFilter::readChunkedHeader(uint64_t a1, uint64_t a2, int a3, _BYTE *__dst, CFIndex bufferLength, CFStreamError *a6)
{
  const __CFData *v12;
  CFIndex Length;
  const unsigned __int8 *BytePtr;
  CFRange v15;
  uint64_t v16;
  int v17;
  char v18;
  CFIndex v19;
  CFIndex v20;
  CFIndex v21;
  CFIndex v22;
  CFIndex v23;
  int v24;
  __int16 v25;
  const void *v26;
  const __CFAllocator *v27;
  CFMutableDataRef MutableCopy;
  const void *v29;
  const __CFAllocator *v30;
  __int16 v31;
  CFIndex v33;
  UInt8 *MutableBytePtr;
  CFIndex v35;
  CFIndex v36;
  CFIndex v37;
  unsigned int v38;
  char v39;
  CFIndex range;
  CFRange v41;

  v12 = *(const __CFData **)(a1 + 256);
  if (!v12)
  {
    BytePtr = 0;
    Length = 0;
LABEL_10:
    v17 = 0;
    v18 = 1;
    v39 = 1;
LABEL_11:
    v16 = 1;
    goto LABEL_15;
  }
  Length = CFDataGetLength(v12);
  if (!Length)
  {
    BytePtr = 0;
    goto LABEL_10;
  }
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 256));
  if (!BytePtr)
  {
    v39 = 0;
    v17 = 0;
    v18 = 1;
    goto LABEL_11;
  }
  range = 0;
  if (HTTPReadFilter::setFilterForChunkedHeaderBytes((HTTPReadFilter *)a1, BytePtr, Length, &range, a6))
  {
    v15.location = range;
    v16 = range != -1;
    if ((unint64_t)(range - 1) <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v15.length = Length - range;
      HTTPReadFilter::setDataForRange((HTTPReadFilter *)a1, v15);
    }
    v17 = 1;
  }
  else
  {
    v17 = 0;
    v16 = 1;
  }
  v18 = 0;
  v39 = 0;
LABEL_15:
  if (v17 | a3)
  {
    if (v17)
    {
LABEL_41:
      v24 = 1;
      goto LABEL_44;
    }
  }
  else if (!CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)a2)
         && CFReadStreamGetStatus(*(CFReadStreamRef *)a2) != kCFStreamStatusError)
  {
    *(_QWORD *)(a1 + 240) = -3;
    goto LABEL_31;
  }
  v38 = v16;
  v19 = bufferLength - Length;
  if (bufferLength <= Length)
    goto LABEL_43;
  if ((v18 & 1) != 0)
  {
    v20 = 0;
    v19 = bufferLength;
  }
  else
  {
    memmove(__dst, BytePtr, Length);
    v20 = Length;
  }
  *(_BYTE *)(a2 + 8) = 1;
  v21 = CFReadStreamRead(*(CFReadStreamRef *)a2, &__dst[v20], v19);
  if (v21 < 0)
  {
    v16 = 0;
    *a6 = CFReadStreamGetError((CFReadStreamRef)*(_QWORD *)a2);
    goto LABEL_41;
  }
  v22 = v21;
  if (!v21)
  {
    if (v20 == 2 && *__dst == 13 && __dst[1] == 10)
    {
      v25 = *(_WORD *)(a1 + 232);
      *(_QWORD *)(a1 + 240) = 0;
      *(_QWORD *)(a1 + 248) = 0;
      *(_WORD *)(a1 + 232) = v25 | 0x100;
      goto LABEL_31;
    }
    v16 = 0;
    a6->domain = 4;
    a6->error = -1;
    *(_WORD *)(a1 + 232) |= 0x800u;
    goto LABEL_41;
  }
  *(_QWORD *)(a1 + 264) += v21;
  range = 0;
  v23 = v21 + Length;
  if (HTTPReadFilter::setFilterForChunkedHeaderBytes((HTTPReadFilter *)a1, __dst, v21 + Length, &range, a6))
  {
    if (range != -1)
    {
      HTTPReadFilter::setDataForBytes((HTTPReadFilter *)a1, &__dst[range], v23 - range);
LABEL_31:
      v24 = 1;
      v16 = 1;
      goto LABEL_44;
    }
    v16 = 0;
    goto LABEL_41;
  }
  if ((v39 & 1) == 0 && (*(_WORD *)(a1 + 232) & 2) != 0)
    CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 256), &__dst[Length], v22);
  else
    HTTPReadFilter::setDataForBytes((HTTPReadFilter *)a1, __dst, v22 + Length);
LABEL_43:
  v24 = 0;
  v16 = v38;
LABEL_44:
  v26 = *(const void **)(a1 + 256);
  if (v26)
  {
    if ((*(_WORD *)(a1 + 232) & 2) != 0)
      goto LABEL_50;
    v27 = CFGetAllocator(v26);
    MutableCopy = CFDataCreateMutableCopy(v27, 0, *(CFDataRef *)(a1 + 256));
    v29 = *(const void **)(a1 + 256);
    if (v29)
      CFRelease(v29);
  }
  else
  {
    v30 = CFGetAllocator(*(CFTypeRef *)(a1 + 224));
    MutableCopy = CFDataCreateMutable(v30, 0);
  }
  v31 = *(_WORD *)(a1 + 232);
  *(_QWORD *)(a1 + 256) = MutableCopy;
  *(_WORD *)(a1 + 232) = v31 | 2;
LABEL_50:
  if (!v24)
  {
    if (a3)
      goto LABEL_55;
LABEL_53:
    if (CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)a2)
      || CFReadStreamGetStatus(*(CFReadStreamRef *)a2) == kCFStreamStatusError)
    {
      while (1)
      {
LABEL_55:
        v33 = CFDataGetLength(*(CFDataRef *)(a1 + 256));
        CFDataSetLength(*(CFMutableDataRef *)(a1 + 256), v33 + bufferLength);
        MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a1 + 256));
        *(_BYTE *)(a2 + 8) = 1;
        v35 = CFReadStreamRead(*(CFReadStreamRef *)a2, &MutableBytePtr[v33], bufferLength);
        if (v35 < 0)
        {
          v16 = 0;
          *a6 = CFReadStreamGetError((CFReadStreamRef)*(_QWORD *)a2);
          return v16;
        }
        if (!v35)
        {
          v16 = 0;
          a6->domain = 4;
          a6->error = -1;
          *(_WORD *)(a1 + 232) |= 0x800u;
          return v16;
        }
        range = 0;
        v36 = v35 + v33;
        if (HTTPReadFilter::setFilterForChunkedHeaderBytes((HTTPReadFilter *)a1, MutableBytePtr, v35 + v33, &range, a6))break;
        CFDataSetLength(*(CFMutableDataRef *)(a1 + 256), v36);
        if (!a3)
          goto LABEL_53;
      }
      v37 = range;
      v16 = range != -1;
      if ((unint64_t)(range - 1) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v41.location = 0;
        v41.length = range;
        CFDataDeleteBytes(*(CFMutableDataRef *)(a1 + 256), v41);
        CFDataSetLength(*(CFMutableDataRef *)(a1 + 256), v36 - v37);
      }
    }
    else
    {
      *(_QWORD *)(a1 + 240) = -3;
      return 1;
    }
  }
  return v16;
}

uint64_t HTTPReadFilter::setFilterForChunkedHeaderBytes(HTTPReadFilter *this, const unsigned __int8 *a2, uint64_t a3, uint64_t *a4, CFStreamError *a5)
{
  uint64_t v8;
  int v9;
  __int16 v10;

  if ((*((_WORD *)this + 116) & 4) != 0)
  {
    v8 = parseChunkedHeader(a2, a3, 1, a4);
    if (v8 == -3)
      return 0;
    v9 = *((_WORD *)this + 116) & 0xFFFB | (*((unsigned __int8 *)this + 234) << 16);
    *((_WORD *)this + 116) &= ~4u;
    *((_BYTE *)this + 234) = BYTE2(v9);
  }
  else
  {
    v8 = parseChunkedHeader(a2, a3, 0, a4);
  }
  if (v8 == -3)
    return 0;
  if (v8 == -1)
  {
    *a4 = -1;
    a5->domain = 4;
    a5->error = -1;
    v10 = 2048;
LABEL_11:
    *((_WORD *)this + 116) |= v10;
    return 1;
  }
  a5->error = 0;
  *((_QWORD *)this + 30) = v8;
  *((_QWORD *)this + 31) = 0;
  if (!v8)
  {
    v10 = 256;
    goto LABEL_11;
  }
  return 1;
}

void HTTPReadFilter::setDataForRange(HTTPReadFilter *this, CFRange a2)
{
  CFIndex length;
  CFIndex location;
  const __CFAllocator *v5;
  __CFData *Mutable;
  const UInt8 *BytePtr;
  const void *v8;
  char *v9;
  __int16 v10;
  const void *v11;
  CFRange v12;

  if (a2.length <= 0)
  {
    v11 = (const void *)*((_QWORD *)this + 32);
    if (v11)
      CFRelease(v11);
    *((_QWORD *)this + 32) = 0;
  }
  else
  {
    length = a2.length;
    location = a2.location;
    if ((*((_WORD *)this + 116) & 2) != 0)
    {
      if (a2.location >= 1)
      {
        v12.location = 0;
        v12.length = location;
        CFDataDeleteBytes(*((CFMutableDataRef *)this + 32), v12);
      }
      CFDataSetLength(*((CFMutableDataRef *)this + 32), length);
    }
    else
    {
      v5 = CFGetAllocator(*((CFTypeRef *)this + 32));
      Mutable = CFDataCreateMutable(v5, 0);
      BytePtr = CFDataGetBytePtr(*((CFDataRef *)this + 32));
      CFDataAppendBytes(Mutable, &BytePtr[location], length);
      v8 = (const void *)*((_QWORD *)this + 32);
      if (v8)
        CFRelease(v8);
      v10 = *((_WORD *)this + 116);
      v9 = (char *)this + 232;
      *((_QWORD *)v9 + 3) = Mutable;
      *(_WORD *)v9 = v10 | 2;
    }
  }
}

void HTTPReadFilter::setDataForBytes(HTTPReadFilter *this, const unsigned __int8 *a2, CFIndex a3)
{
  const void *v6;
  const __CFAllocator *v7;
  __CFData *Mutable;

  v6 = (const void *)*((_QWORD *)this + 32);
  if (v6)
    CFRelease(v6);
  if (a3)
  {
    v7 = CFGetAllocator(*((CFTypeRef *)this + 28));
    Mutable = CFDataCreateMutable(v7, 0);
    *((_QWORD *)this + 32) = Mutable;
    CFDataAppendBytes(Mutable, a2, a3);
    *((_WORD *)this + 116) |= 2u;
  }
  else
  {
    *((_QWORD *)this + 32) = 0;
  }
}

uint64_t parseChunkedHeader(const unsigned __int8 *a1, uint64_t a2, int a3, uint64_t *a4)
{
  const unsigned __int8 *v4;
  const unsigned __int8 *i;
  uint64_t v6;
  const unsigned __int8 *v7;
  int v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  BOOL v12;
  uint64_t v13;
  const unsigned __int8 *v15;
  int v16;
  int v18;
  const unsigned __int8 *v19;
  const unsigned __int8 *v20;
  const unsigned __int8 *v21;
  int64_t v22;
  int v23;
  int64_t v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  BOOL v30;
  int64_t v31;
  int v32;
  int64_t v34;
  int v35;
  int v37;
  int64_t v38;
  unsigned int v39;
  unsigned int v40;
  uint64_t v41;
  BOOL v42;
  int64_t v43;
  int v44;

  v4 = &a1[a2];
  i = a1;
  if (!a3)
  {
    i = a1;
    if (a2)
    {
      v10 = a2;
      for (i = a1; ; ++i)
      {
        v11 = *i;
        v12 = v11 > 0x20;
        v13 = (1 << v11) & 0x100002600;
        if (v12 || v13 == 0)
          break;
        if (!--v10)
          return -3;
      }
    }
    if (i == v4)
      return -3;
  }
  if (i >= v4)
  {
    v6 = 0;
  }
  else
  {
    v6 = 0;
    v7 = (const unsigned __int8 *)(&a1[a2] - i);
    do
    {
      v8 = *i;
      if ((v8 - 48) >= 0xA)
      {
        if ((v8 - 65) >= 6)
        {
          v9 = -87;
          if ((v8 - 97) > 5)
            goto LABEL_20;
        }
        else
        {
          v9 = -55;
        }
      }
      else
      {
        v9 = -48;
      }
      v6 = (v9 + v8) + 16 * v6;
      ++i;
      --v7;
    }
    while (v7);
    i = &a1[a2];
  }
LABEL_20:
  if (i < v4)
  {
    v15 = (const unsigned __int8 *)(&a1[a2] - i);
    while (1)
    {
      v16 = *i;
      if (v16 != 32 && v16 != 9)
        break;
      ++i;
      if (!--v15)
      {
        i = &a1[a2];
        break;
      }
    }
  }
  if (i == v4)
    return -3;
  v18 = *i;
  if (v18 == 59)
  {
    v19 = &a1[a2];
    v20 = &a1[a2 - 1];
    while (1)
    {
      v21 = i + 1;
      if (i + 1 < v4)
      {
        v22 = v20 - i;
        while (1)
        {
          v23 = *v21;
          if (v23 != 32 && v23 != 9)
            break;
          ++v21;
          if (!--v22)
          {
            v21 = v19;
            break;
          }
        }
      }
      if (v21 == v4)
        return -3;
      v18 = *v21;
      if (v18 == 10 || v18 == 13)
      {
        i = v21;
        goto LABEL_119;
      }
      if (v21 < v4)
      {
        v26 = v19 - v21;
        while (1)
        {
          v27 = *v21;
          v28 = v27 - 32;
          if (v27 < 0x20 || v27 == 127)
            break;
          v12 = v28 > 0x3D;
          v29 = (1 << v28) & 0x38000001FC009305;
          v30 = v12 || v29 == 0;
          if (!v30 || v27 == 123 || v27 == 125)
            break;
          ++v21;
          if (!--v26)
          {
            v21 = v19;
            break;
          }
        }
      }
      if (v21 < v4)
      {
        v31 = v19 - v21;
        while (1)
        {
          v32 = *v21;
          if (v32 != 32 && v32 != 9)
            break;
          ++v21;
          if (!--v31)
          {
            v21 = v19;
            break;
          }
        }
      }
      if (v21 == v4)
        return -3;
      v18 = *v21;
      if (v18 == 61)
      {
        if (v21 < v4)
        {
          v34 = v19 - v21;
          while (1)
          {
            v35 = *v21;
            if (v35 != 32 && v35 != 9)
              break;
            ++v21;
            if (!--v34)
            {
              v21 = v19;
              break;
            }
          }
        }
        if (v21 == v4)
          return -3;
        if (*v21 == 34)
        {
          for (i = v21 + 1; i < v4; ++i)
          {
            v37 = v21[1];
            if (v37 == 92)
            {
              i = v21 + 2;
            }
            else if (v37 == 34)
            {
              i = v21 + 2;
              break;
            }
            v21 = i;
          }
        }
        else if (v21 >= v4)
        {
          i = v21;
        }
        else
        {
          v38 = v19 - v21;
          i = v21;
          while (1)
          {
            v39 = *i;
            v40 = v39 - 32;
            if (v39 < 0x20 || v39 == 127)
              break;
            v12 = v40 > 0x3D;
            v41 = (1 << v40) & 0x38000001FC009305;
            v42 = v12 || v41 == 0;
            if (!v42 || v39 == 123 || v39 == 125)
              break;
            ++i;
            if (!--v38)
            {
              i = v19;
              break;
            }
          }
        }
        if (i < v4)
        {
          v43 = v19 - i;
          while (1)
          {
            v44 = *i;
            if (v44 != 32 && v44 != 9)
              break;
            ++i;
            if (!--v43)
            {
              i = v19;
              break;
            }
          }
        }
        if (i == v4)
          return -3;
        v18 = *i;
      }
      else
      {
        i = v21;
      }
      if (v18 != 59)
        goto LABEL_119;
    }
  }
  if (v18 != 13)
    return -1;
LABEL_119:
  if (i + 1 == v4)
    return -3;
  if (i[1] != 10)
    return -1;
  *a4 = i - a1 + 2;
  if (v6 < 0)
    return -1;
  else
    return v6;
}

uint64_t HTTPReadFilter::doChunkedRead(uint64_t a1, uint64_t a2, char *__dst, CFIndex bufferLength, CFStreamError *a5, _BYTE *a6)
{
  CFIndex v7;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CFIndex v14;
  const __CFData *v15;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFIndex v18;
  int64_t v19;
  size_t v20;
  CFIndex v21;
  CFIndex v22;
  CFRange v25;

  *a6 = 0;
  a5->error = 0;
  if (bufferLength < 1)
    return 0;
  v7 = bufferLength;
  v11 = 0;
  while ((*(_WORD *)(a1 + 232) & 0x100) == 0)
  {
    v12 = *(_QWORD *)(a1 + 240);
    if (v12 == -3 || (v13 = *(_QWORD *)(a1 + 248), v12 == v13))
    {
      if (!HTTPReadFilter::readChunkedHeader(a1, a2, v11 < 1, __dst, v7, a5))
        return -1;
      v12 = *(_QWORD *)(a1 + 240);
      if (v12 == -3)
        return v11;
      if (!v12)
        break;
      v13 = *(_QWORD *)(a1 + 248);
    }
    v14 = v12 - v13;
    v15 = *(const __CFData **)(a1 + 256);
    if (v15)
    {
      BytePtr = CFDataGetBytePtr(v15);
      Length = CFDataGetLength(*(CFDataRef *)(a1 + 256));
      v18 = Length;
      if (Length >= v14)
        v19 = v14;
      else
        v19 = Length;
      if (v19 >= v7)
        v20 = v7;
      else
        v20 = v19;
      memmove(__dst, BytePtr, v20);
      v7 -= v20;
      v11 += v20;
      *(_QWORD *)(a1 + 248) += v20;
      v25.length = v18 - v20;
      v25.location = v20;
      HTTPReadFilter::setDataForRange((HTTPReadFilter *)a1, v25);
      if (!v7)
        return v11;
      __dst += v20;
      v14 -= v20;
    }
    if (v14)
    {
      if (v11 >= 1
        && !CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)a2)
        && CFReadStreamGetStatus(*(CFReadStreamRef *)a2) != kCFStreamStatusError)
      {
        return v11;
      }
      if (v14 >= v7)
        v21 = v7;
      else
        v21 = v14;
      *(_BYTE *)(a2 + 8) = 1;
      v22 = CFReadStreamRead(*(CFReadStreamRef *)a2, (UInt8 *)__dst, v21);
      if (v22 < 0)
      {
        *a5 = CFReadStreamGetError((CFReadStreamRef)*(_QWORD *)a2);
        return -1;
      }
      if (!v22)
      {
        a5->domain = 4;
        a5->error = -1;
        *(_WORD *)(a1 + 232) |= 0x800u;
        return -1;
      }
      *(_QWORD *)(a1 + 264) += v22;
      __dst += v22;
      v7 -= v22;
      v11 += v22;
      *(_QWORD *)(a1 + 248) += v22;
    }
    if (v7 <= 0)
      return v11;
  }
  *a6 = 1;
  if (HTTPReadFilter::readChunkedTrailers(a1, a2, a5))
    return v11;
  return -1;
}

uint64_t HTTPReadFilter::doPlainRead(uint64_t a1, uint64_t a2, void *a3, int64_t a4, CFStreamError *a5, _BYTE *a6)
{
  int64_t v8;
  uint64_t v12;
  int64_t v13;
  const __CFData *v14;
  const UInt8 *BytePtr;
  int64_t Length;
  CFIndex v17;
  uint64_t v18;
  const void *v19;
  CFIndex v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  CFRange v25;

  v8 = a4;
  *a6 = 0;
  a5->error = 0;
  v12 = *(_QWORD *)(a1 + 240);
  if (v12 != -1)
  {
    v13 = v12 - *(_QWORD *)(a1 + 248);
    if (v13 < a4)
      v8 = v13;
  }
  if (!v8)
  {
    v18 = 0;
    *a6 = 1;
    return v18;
  }
  v14 = *(const __CFData **)(a1 + 256);
  if (!v14)
  {
    v18 = 0;
    goto LABEL_15;
  }
  BytePtr = CFDataGetBytePtr(v14);
  Length = CFDataGetLength(*(CFDataRef *)(a1 + 256));
  v17 = Length - v8;
  if (Length <= v8)
  {
    v18 = Length;
    memcpy(a3, BytePtr, Length);
    v19 = *(const void **)(a1 + 256);
    if (v19)
      CFRelease(v19);
    *(_QWORD *)(a1 + 256) = 0;
    if (v18 && (v18 >= v8 || !CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)a2)))
      goto LABEL_19;
LABEL_15:
    *(_BYTE *)(a2 + 8) = 1;
    v20 = CFReadStreamRead(*(CFReadStreamRef *)a2, (UInt8 *)a3 + v18, v8 - v18);
    if (v20 < 0)
    {
      *a5 = CFReadStreamGetError((CFReadStreamRef)*(_QWORD *)a2);
      *a6 = 1;
      return -1;
    }
    if (!v20
      || (*(_QWORD *)(a1 + 264) += v20, v18 += v20,
                                        CFReadStreamGetStatus(*(CFReadStreamRef *)a2) == kCFStreamStatusAtEnd))
    {
      *a6 = 1;
    }
    goto LABEL_19;
  }
  memcpy(a3, BytePtr, v8);
  v25.location = v8;
  v25.length = v17;
  HTTPReadFilter::setDataForRange((HTTPReadFilter *)a1, v25);
  v18 = v8;
LABEL_19:
  if (v18 >= 1)
  {
    v21 = *(_QWORD *)(a1 + 240);
    v22 = *(_QWORD *)(a1 + 248) + v18;
    *(_QWORD *)(a1 + 248) = v22;
    if (v21 != -1 && v22 >= v21)
    {
      *a6 = 1;
      v21 = *(_QWORD *)(a1 + 240);
    }
    if (v21 > 0x4000)
    {
      v23 = *(unsigned __int16 *)(a1 + 232) | (*(unsigned __int8 *)(a1 + 234) << 16);
      if ((*(_WORD *)(a1 + 232) & 0x8040) == 0x8000)
      {
        *(_BYTE *)(a1 + 234) = BYTE2(v23);
        *(_WORD *)(a1 + 232) = v23 | 0x40;
        CFReadStreamSetProperty(*(CFReadStreamRef *)a2, CFSTR("_kCFStreamPropertyLargeDownload"), (CFTypeRef)*MEMORY[0x1E0C9AE50]);
      }
    }
  }
  return v18;
}

uint64_t HTTPReadFilter::readChunkedTrailers(uint64_t a1, uint64_t a2, CFStreamError *a3)
{
  const __CFAllocator *v6;
  CFHTTPMessageRef Empty;
  const __CFData *v8;
  CFIndex Length;
  const UInt8 *BytePtr;
  int appended;
  const void *v12;
  uint64_t v13;
  int v14;
  const char *v15;
  HTTPBodyData *v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  const __CFDictionary *v21;
  const __CFDictionary *v22;
  UInt8 buffer[2048];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v6 = CFGetAllocator((CFTypeRef)(a1 - 16));
  Empty = CFHTTPMessageCreateEmpty(v6, 0);
  CFHTTPMessageAppendBytes(Empty, (const UInt8 *)"HTTP/1.0 200 OK\r\n", 17);
  v8 = *(const __CFData **)(a1 + 256);
  if (!v8)
  {
    LOBYTE(appended) = 1;
    goto LABEL_7;
  }
  Length = CFDataGetLength(v8);
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 256));
  appended = CFHTTPMessageAppendBytes(Empty, BytePtr, Length);
  v12 = *(const void **)(a1 + 256);
  if (v12)
    CFRelease(v12);
  *(_QWORD *)(a1 + 256) = 0;
  if (appended)
  {
    while (1)
    {
LABEL_7:
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (!*((_QWORD *)Empty + 13))
        break;
      *(_BYTE *)(a2 + 8) = 1;
      v13 = CFReadStreamRead(*(CFReadStreamRef *)a2, buffer, 2048);
      if (v13 <= 0)
      {
        if (v13)
        {
          *a3 = CFReadStreamGetError((CFReadStreamRef)*(_QWORD *)a2);
        }
        else
        {
          a3->domain = 4;
          a3->error = -1;
          *(_WORD *)(a1 + 232) |= 0x800u;
        }
        LOBYTE(appended) = 0;
        goto LABEL_21;
      }
      *(_QWORD *)(a1 + 264) += v13;
      v14 = CFHTTPMessageAppendBytes(Empty, buffer, v13);
      LOBYTE(appended) = v14;
      if (!v14)
        goto LABEL_21;
    }
    HTTPMessage::ensureParserFinished((CFHTTPMessageRef)((char *)Empty + 16));
    v16 = (HTTPBodyData *)*((_QWORD *)Empty + 8);
    *((_QWORD *)Empty + 8) = 0;
    if (v16)
    {
      v17 = HTTPBodyData::captureData(v16, v15);
      v19 = v18;
      (*(void (**)(HTTPBodyData *))(*(_QWORD *)v16 + 8))(v16);
      v20 = *(_WORD *)(a1 + 232) & 0xFFFD | (*(unsigned __int8 *)(a1 + 234) << 16);
      *(_WORD *)(a1 + 232) = *(_WORD *)(a1 + 232) & 0xFFFD | (2 * v17);
      *(_BYTE *)(a1 + 234) = BYTE2(v20);
      *(_QWORD *)(a1 + 256) = v19;
    }
    v21 = CFHTTPMessageCopyAllHeaderFields(Empty);
    if (v21)
    {
      v22 = v21;
      CFDictionaryApplyFunction(v21, (CFDictionaryApplierFunction)_addTrailingHeader, *(void **)(a1 + 224));
      CFRelease(v22);
    }
  }
LABEL_21:
  CFRelease(Empty);
  return appended;
}

void _addTrailingHeader(CFStringRef headerField, CFStringRef a2, CFHTTPMessageRef message)
{
  CFStringRef v6;
  CFStringRef v7;
  const __CFAllocator *v8;

  v6 = CFHTTPMessageCopyHeaderFieldValue(message, headerField);
  if (v6)
  {
    v7 = v6;
    v8 = CFGetAllocator(message);
    a2 = CFStringCreateWithFormat(v8, 0, CFSTR("%@, %@"), v7, a2);
    CFRelease(v7);
  }
  else
  {
    CFRetain(a2);
  }
  CFHTTPMessageSetHeaderFieldValue(message, headerField, a2);
  CFRelease(a2);
}

CFIndex HTTPWriteFilter::_streamImpl_Write(HTTPWriteFilter *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  pthread_mutex_t *v8;
  __int16 v9;
  SInt32 v10;
  CFIndex v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  CFIndex v18;
  CFIndex v19;
  uint64_t v20;

  a4->error = 0;
  v8 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  v9 = *((_WORD *)this + 112);
  if ((v9 & 0x20) != 0)
  {
    pthread_mutex_unlock(v8);
    return 0;
  }
  if ((v9 & 0x40) != 0)
  {
    a4->domain = 4;
    v10 = -2096;
    goto LABEL_8;
  }
  if ((*((_WORD *)this + 112) & 0x400) != 0 && (v9 & 1) != 0)
  {
    a4->domain = 4;
    v10 = -2095;
LABEL_8:
    a4->error = v10;
LABEL_9:
    pthread_mutex_unlock(v8);
    return -1;
  }
  if (!*((_QWORD *)this + 26))
    goto LABEL_9;
  if ((v9 & 0x10) != 0)
  {
    if (a4->error)
      goto LABEL_9;
  }
  else
  {
    a4->domain = HTTPWriteFilter::transmitHeader(this, (__CFHTTPMessage *)1);
    *(_QWORD *)&a4->error = v13;
    if ((_DWORD)v13)
      goto LABEL_9;
  }
  if ((*((_WORD *)this + 112) & 0x80) == 0)
  {
    v15 = *((_QWORD *)this + 30);
    v14 = *((_QWORD *)this + 31);
    v16 = __OFSUB__(v15, v14);
    v17 = v15 - v14;
    if ((v17 < 0) ^ v16 | (v17 == 0))
    {
      pthread_mutex_unlock(v8);
      (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 25) + 216))(*((_QWORD *)this + 25), *((_QWORD *)this + 36));
      v11 = 0;
    }
    else
    {
      if (v17 >= a3)
        v18 = a3;
      else
        v18 = v17;
      v19 = CFWriteStreamWrite(*((CFWriteStreamRef *)this + 26), a2, v18);
      if (v19 < 0)
      {
        *a4 = CFWriteStreamGetError((CFWriteStreamRef)*((_QWORD *)this + 26));
        goto LABEL_9;
      }
      v11 = v19;
      *((_QWORD *)this + 31) += v19;
      *((_QWORD *)this + 36) += v19;
      pthread_mutex_unlock(v8);
      (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 25) + 216))(*((_QWORD *)this + 25), *((_QWORD *)this + 36));
    }
    *((_QWORD *)this + 36) = 0;
    return v11;
  }
  v20 = HTTPWriteFilter::doChunkedWrite(this, a2, a3, a4);
  pthread_mutex_unlock(v8);
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 25) + 216))(*((_QWORD *)this + 25), *((_QWORD *)this + 36));
  *((_QWORD *)this + 36) = 0;
  return v20;
}

uint64_t HTTPWriteFilter::_streamImpl_Open(__CFWriteStream **this, CFStreamError *a2, unsigned __int8 *a3)
{
  pthread_mutex_t *v6;
  __CFWriteStream *v7;
  uint64_t v8;
  CFStreamClientContext clientContext;

  clientContext.version = 0;
  clientContext.info = this;
  clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
  clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
  clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
  v6 = (pthread_mutex_t *)(this + 17);
  pthread_mutex_lock((pthread_mutex_t *)(this + 17));
  v7 = this[26];
  if (v7)
  {
    CFWriteStreamSetClient(v7, 0x1CuLL, (CFWriteStreamClientCallBack)HTTPWriteFilter::_httpWrFilterSocketStreamCallBack, &clientContext);
    v8 = 1;
    if (CFWriteStreamGetStatus(this[26]) || (v8 = CFWriteStreamOpen(this[26]), (_DWORD)v8))
    {
      a2->error = 0;
      *a3 = 1;
    }
    else
    {
      *a3 = 1;
      *a2 = CFWriteStreamGetError(this[26]);
    }
  }
  else
  {
    v8 = 0;
    a2->domain = 4;
    a2->error = -4;
  }
  pthread_mutex_unlock(v6);
  return v8;
}

BOOL HTTPWriteFilter::_streamImpl_OpenCompleted(HTTPWriteFilter *this, CFStreamError *a2)
{
  pthread_mutex_t *v3;
  __CFWriteStream *v4;
  _BOOL8 v5;

  v3 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  v4 = (__CFWriteStream *)*((_QWORD *)this + 26);
  if (v4)
    v5 = CFWriteStreamGetStatus(v4) > kCFStreamStatusOpening;
  else
    v5 = 0;
  pthread_mutex_unlock(v3);
  return v5;
}

uint64_t HTTPWriteFilter::_streamImpl_Close(HTTPWriteFilter *this)
{
  pthread_mutex_t *v2;
  __CFWriteStream *v3;
  const void *v4;

  v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  v3 = (__CFWriteStream *)*((_QWORD *)this + 26);
  if (v3)
  {
    CFWriteStreamClose(v3);
    CFWriteStreamSetClient(*((CFWriteStreamRef *)this + 26), 0, 0, 0);
    v4 = (const void *)*((_QWORD *)this + 26);
    *((_QWORD *)this + 26) = 0;
    if (v4)
      CFRelease(v4);
  }
  return pthread_mutex_unlock(v2);
}

CFTypeRef HTTPWriteFilter::_streamImpl_CopyProperty(HTTPWriteFilter *this, const __CFString *a2)
{
  pthread_mutex_t *v4;
  int ExactString;
  uint64_t v6;
  const void *v7;
  __CFWriteStream *v8;
  CFTypeRef v9;
  const void **v10;
  CFTypeRef v11;

  v4 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  ExactString = _findExactString(a2, 0);
  if (ExactString <= 401937841)
  {
    if (ExactString <= 393737462)
    {
      if (ExactString == 224669676)
      {
        if ((*((_WORD *)this + 112) & 0x108) == 8)
          goto LABEL_29;
        v7 = (const void *)*((_QWORD *)this + 33);
        if (!v7)
          goto LABEL_39;
      }
      else
      {
        if (ExactString != 228814903 || (*((_WORD *)this + 112) & 0x108) == 8)
          goto LABEL_29;
        v7 = (const void *)*((_QWORD *)this + 34);
        if (!v7)
          goto LABEL_39;
      }
LABEL_36:
      v9 = CFRetain(v7);
      goto LABEL_37;
    }
    if (ExactString != 393737463)
    {
      if (ExactString != 400823713)
        goto LABEL_29;
      if ((*((_WORD *)this + 112) & 0x400) == 0)
        goto LABEL_34;
      goto LABEL_32;
    }
    if (*((__int16 *)this + 112) < 0)
      goto LABEL_32;
LABEL_34:
    v10 = (const void **)MEMORY[0x1E0C9AE40];
LABEL_35:
    v7 = *v10;
    if (!*v10)
      goto LABEL_39;
    goto LABEL_36;
  }
  if (ExactString <= 406214148)
  {
    if (ExactString != 401937842)
    {
      if (ExactString != 403994074)
        goto LABEL_29;
      v7 = (const void *)*((_QWORD *)this + 26);
      if (!v7)
        goto LABEL_39;
      goto LABEL_36;
    }
    if ((*((_WORD *)this + 112) & 0x40) != 0)
      goto LABEL_32;
    goto LABEL_34;
  }
  if (ExactString == 406214149)
  {
    if ((*((_WORD *)this + 112) & 0x4000) == 0)
      goto LABEL_34;
LABEL_32:
    v10 = (const void **)MEMORY[0x1E0C9AE50];
    goto LABEL_35;
  }
  if (ExactString == 442734542 || ExactString == 444889076)
  {
    v6 = *((_QWORD *)this + 27);
    if (!v6)
      goto LABEL_39;
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*(_BYTE *)(v6 + 40))
      goto LABEL_39;
    v7 = (const void *)*((_QWORD *)this + 27);
    if (!v7)
      goto LABEL_39;
    goto LABEL_36;
  }
LABEL_29:
  v8 = (__CFWriteStream *)*((_QWORD *)this + 26);
  if (!v8)
  {
LABEL_39:
    v11 = 0;
    goto LABEL_40;
  }
  v9 = CFWriteStreamCopyProperty(v8, a2);
LABEL_37:
  v11 = v9;
LABEL_40:
  pthread_mutex_unlock(v4);
  return v11;
}

unint64_t HTTPWriteFilter::_streamImpl_SetProperty(HTTPWriteFilter *this, const __CFString *a2, unint64_t a3)
{
  pthread_mutex_t *v6;
  int ExactString;
  const void *v8;
  CFTypeRef v9;
  const void *v10;
  void *v11;
  __int16 v12;
  CFTypeID v13;
  const void *v14;
  CFTypeRef v15;
  CFTypeID v16;
  const void *v17;
  CFTypeRef v18;
  __int16 v19;
  CFTypeID v20;
  const void *v21;
  CFTypeRef v22;
  __int16 v23;
  __int16 v24;
  __int16 v25;
  CFTypeID v26;
  const void *v27;
  CFTypeRef v28;
  __CFWriteStream *v29;
  const void *v31;
  __int16 v32;
  const __CFURL *v33;
  const __CFString *v34;
  __int16 v35;
  const void *v36;
  char *v37;
  __CFWriteStream *v38;
  CFStreamPropertyKey *v39;
  const void *v40;
  const void *v41;
  const void *v42;
  __CFWriteStream *v43;

  v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  ExactString = _findExactString(a2, 0);
  if (ExactString <= 399766928)
  {
    if (ExactString > 231968870)
    {
      if (ExactString != 231968871)
      {
        if (ExactString == 393737463)
        {
          v23 = *((_WORD *)this + 112);
          if (*MEMORY[0x1E0C9AE50] == a3)
            v12 = v23 | 0x8000;
          else
            v12 = v23 & 0x7FFF;
          goto LABEL_73;
        }
        if (ExactString == 398906741)
        {
          v10 = (const void *)*((_QWORD *)this + 29);
          if (v10)
            _Block_release(v10);
          if (a3)
            v11 = _Block_copy((const void *)a3);
          else
            v11 = 0;
          *((_QWORD *)this + 29) = v11;
          goto LABEL_74;
        }
        goto LABEL_64;
      }
      v20 = CFGetTypeID((CFTypeRef)a3);
      if (v20 != CFDictionaryGetTypeID())
        goto LABEL_66;
      if ((*((_WORD *)this + 112) & 0x108) == 8)
        goto LABEL_74;
      v21 = (const void *)*((_QWORD *)this + 35);
      if (v21 != (const void *)a3)
      {
        if (v21)
          CFRelease(v21);
        if (a3)
          v22 = CFRetain((CFTypeRef)a3);
        else
          v22 = 0;
        *((_QWORD *)this + 35) = v22;
      }
      v42 = (const void *)*((_QWORD *)this + 33);
      *((_QWORD *)this + 33) = 0;
      if (v42)
        CFRelease(v42);
      v41 = (const void *)*((_QWORD *)this + 34);
      *((_QWORD *)this + 34) = 0;
      if (!v41)
        goto LABEL_74;
LABEL_107:
      CFRelease(v41);
      goto LABEL_74;
    }
    if (ExactString == 224669676)
    {
      v26 = CFGetTypeID((CFTypeRef)a3);
      if (v26 != CFDataGetTypeID())
        goto LABEL_66;
      if ((*((_WORD *)this + 112) & 0x108) != 8)
      {
        v27 = (const void *)*((_QWORD *)this + 33);
        if (v27 != (const void *)a3)
        {
          if (v27)
            CFRelease(v27);
          if (a3)
            v28 = CFRetain((CFTypeRef)a3);
          else
            v28 = 0;
          *((_QWORD *)this + 33) = v28;
        }
        v40 = (const void *)*((_QWORD *)this + 34);
        *((_QWORD *)this + 34) = 0;
        if (v40)
          goto LABEL_99;
        goto LABEL_100;
      }
    }
    else
    {
      if (ExactString != 228814903)
        goto LABEL_64;
      v13 = CFGetTypeID((CFTypeRef)a3);
      if (v13 != SSLContextGetTypeID())
        goto LABEL_66;
      if ((*((_WORD *)this + 112) & 0x108) != 8)
      {
        v14 = (const void *)*((_QWORD *)this + 34);
        if (v14 != (const void *)a3)
        {
          if (v14)
            CFRelease(v14);
          if (a3)
            v15 = CFRetain((CFTypeRef)a3);
          else
            v15 = 0;
          *((_QWORD *)this + 34) = v15;
        }
        v40 = (const void *)*((_QWORD *)this + 33);
        *((_QWORD *)this + 33) = 0;
        if (v40)
LABEL_99:
          CFRelease(v40);
LABEL_100:
        v41 = (const void *)*((_QWORD *)this + 35);
        *((_QWORD *)this + 35) = 0;
        if (!v41)
          goto LABEL_74;
        goto LABEL_107;
      }
    }
LABEL_74:
    a3 = 1;
    goto LABEL_75;
  }
  if (ExactString > 405149163)
  {
    switch(ExactString)
    {
      case 405149164:
        v24 = *((_WORD *)this + 112);
        if (*MEMORY[0x1E0C9AE50] == a3)
          v12 = v24 | 0x1000;
        else
          v12 = v24 & 0xEFFF;
        goto LABEL_73;
      case 406214149:
        v25 = *((_WORD *)this + 112);
        if (*MEMORY[0x1E0C9AE50] == a3)
          v12 = v25 | 0x4000;
        else
          v12 = v25 & 0xBFFF;
        goto LABEL_73;
      case 554941461:
        if (*(_BYTE *)(*((_QWORD *)this + 25) + 251))
        {
          v12 = *((_WORD *)this + 112) & 0xFFCF;
LABEL_73:
          *((_WORD *)this + 112) = v12;
          goto LABEL_74;
        }
        goto LABEL_66;
    }
LABEL_64:
    v29 = (__CFWriteStream *)*((_QWORD *)this + 26);
    if (v29)
    {
      a3 = CFWriteStreamSetProperty(v29, a2, (CFTypeRef)a3);
      goto LABEL_75;
    }
    goto LABEL_66;
  }
  if (ExactString == 399766929)
  {
    v16 = CFGetTypeID((CFTypeRef)a3);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (v16 == *(_QWORD *)(HTTPMessage::Class(void)::sClass_OBJTYPE + 96) && *((_QWORD *)this + 26))
    {
      v17 = (const void *)*((_QWORD *)this + 27);
      if (!v17)
      {
        if (!a3)
          goto LABEL_81;
        goto LABEL_79;
      }
      if ((~*((unsigned __int16 *)this + 112) & 0x401) == 0)
      {
        if (v17 == (const void *)a3)
          goto LABEL_81;
        CFRelease(v17);
        if (!a3)
        {
          v18 = 0;
LABEL_80:
          *((_QWORD *)this + 27) = v18;
LABEL_81:
          *((_QWORD *)this + 30) = 0;
          *((_QWORD *)this + 31) = 0;
          v31 = (const void *)*((_QWORD *)this + 32);
          if (v31)
          {
            CFRelease(v31);
            *((_QWORD *)this + 32) = 0;
          }
          v32 = *((_WORD *)this + 112);
          *((_WORD *)this + 112) = v32 & 0xFF2C;
          if ((v32 & 0xA00) != 0 && CFHTTPMessageIsRequest(*((CFHTTPMessageRef *)this + 27)))
          {
            v33 = CFHTTPMessageCopyRequestURL(*((CFHTTPMessageRef *)this + 27));
            v34 = CFURLCopyScheme(v33);
            if (v33)
              CFRelease(v33);
            if (CFStringCompare(v34, (CFStringRef)&unk_1EDD00AE0, 1uLL) == kCFCompareEqualTo)
              HTTPWriteFilter::prepareHTTPSProxy(this);
            if (v34)
              CFRelease(v34);
          }
          v35 = *((_WORD *)this + 112);
          if ((v35 & 8) != 0)
            goto LABEL_122;
          *((_WORD *)this + 112) = v35 | 8;
          if ((v35 & 0x100) != 0)
            goto LABEL_122;
          v36 = (const void *)*((_QWORD *)this + 34);
          if (v36)
          {
            v37 = (char *)this + 272;
            v38 = (__CFWriteStream *)*((_QWORD *)this + 26);
            if (v38)
            {
              v39 = (CFStreamPropertyKey *)&kCFStreamPropertySSLContext;
              goto LABEL_118;
            }
LABEL_120:
            *(_QWORD *)v37 = 0;
LABEL_121:
            CFRelease(v36);
            goto LABEL_122;
          }
          v36 = (const void *)*((_QWORD *)this + 33);
          if (v36)
          {
            v37 = (char *)this + 264;
            v38 = (__CFWriteStream *)*((_QWORD *)this + 26);
            if (!v38)
              goto LABEL_120;
            v39 = (CFStreamPropertyKey *)&kCFStreamPropertySocketSSLContext;
          }
          else
          {
            v36 = (const void *)*((_QWORD *)this + 35);
            if (!v36)
            {
LABEL_122:
              v43 = (__CFWriteStream *)*((_QWORD *)this + 26);
              if (v43 && CFWriteStreamCanAcceptBytes(v43))
                HTTPWriteFilter::transmitHeader(this, 0);
              goto LABEL_74;
            }
            v37 = (char *)this + 280;
            v38 = (__CFWriteStream *)*((_QWORD *)this + 26);
            if (!v38)
              goto LABEL_120;
            v39 = (CFStreamPropertyKey *)&kCFStreamPropertySSLSettings;
          }
LABEL_118:
          CFWriteStreamSetProperty(v38, *v39, v36);
          v36 = *(const void **)v37;
          *(_QWORD *)v37 = 0;
          if (!v36)
            goto LABEL_122;
          goto LABEL_121;
        }
LABEL_79:
        v18 = CFRetain((CFTypeRef)a3);
        goto LABEL_80;
      }
    }
LABEL_66:
    a3 = 0;
    goto LABEL_75;
  }
  if (ExactString == 400823713)
  {
    v19 = *((_WORD *)this + 112);
    if (*MEMORY[0x1E0C9AE50] == a3)
      v12 = v19 | 0x400;
    else
      v12 = v19 & 0xFBFF;
    goto LABEL_73;
  }
  if (ExactString != 403994074)
    goto LABEL_64;
  v8 = (const void *)*((_QWORD *)this + 26);
  if (v8 != (const void *)a3)
  {
    *((_QWORD *)this + 26) = 0;
    if (v8)
      CFRelease(v8);
  }
  if (a3)
  {
    v9 = CFRetain((CFTypeRef)a3);
    a3 = 0;
    *((_QWORD *)this + 26) = v9;
  }
LABEL_75:
  pthread_mutex_unlock(v6);
  if (*((_QWORD *)this + 36))
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 25) + 216))(*((_QWORD *)this + 25));
    *((_QWORD *)this + 36) = 0;
  }
  return a3;
}

uint64_t HTTPWriteFilter::_streamImpl_deprecated_Schedule(HTTPWriteFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  pthread_mutex_t *v6;
  __CFWriteStream *v7;

  v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  v7 = (__CFWriteStream *)*((_QWORD *)this + 26);
  if (v7)
    CFWriteStreamScheduleWithRunLoop(v7, a2, a3);
  return pthread_mutex_unlock(v6);
}

uint64_t HTTPWriteFilter::_streamImpl_deprecated_Unschedule(HTTPWriteFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  pthread_mutex_t *v6;
  __CFWriteStream *v7;

  v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  v7 = (__CFWriteStream *)*((_QWORD *)this + 26);
  if (v7)
    CFWriteStreamUnscheduleFromRunLoop(v7, a2, a3);
  return pthread_mutex_unlock(v6);
}

void `non-virtual thunk to'HTTPWriteFilter::~HTTPWriteFilter(HTTPWriteFilter *this)
{
  HTTPWriteFilter::~HTTPWriteFilter((HTTPWriteFilter *)((char *)this - 8));
}

{
  HTTPWriteFilter::~HTTPWriteFilter((HTTPWriteFilter *)((char *)this - 8));
}

{
  HTTPWriteFilter::~HTTPWriteFilter((HTTPWriteFilter *)((char *)this - 120));
}

{
  HTTPWriteFilter::~HTTPWriteFilter((HTTPWriteFilter *)((char *)this - 120));
}

{
  HTTPWriteFilter::~HTTPWriteFilter((HTTPWriteFilter *)((char *)this - 128));
}

{
  HTTPWriteFilter::~HTTPWriteFilter((HTTPWriteFilter *)((char *)this - 128));
}

unint64_t `non-virtual thunk to'HTTPWriteFilter::_streamImpl_SetProperty(HTTPWriteFilter *this, const __CFString *a2, unint64_t a3)
{
  return HTTPWriteFilter::_streamImpl_SetProperty((HTTPWriteFilter *)((char *)this - 120), a2, a3);
}

CFTypeRef `non-virtual thunk to'HTTPWriteFilter::_streamImpl_CopyProperty(HTTPWriteFilter *this, const __CFString *a2)
{
  return HTTPWriteFilter::_streamImpl_CopyProperty((HTTPWriteFilter *)((char *)this - 120), a2);
}

uint64_t `non-virtual thunk to'HTTPWriteFilter::_streamImpl_Open(__CFWriteStream **this, CFStreamError *a2, unsigned __int8 *a3)
{
  return HTTPWriteFilter::_streamImpl_Open(this - 15, a2, a3);
}

BOOL `non-virtual thunk to'HTTPWriteFilter::_streamImpl_OpenCompleted(HTTPWriteFilter *this, CFStreamError *a2)
{
  return HTTPWriteFilter::_streamImpl_OpenCompleted((HTTPWriteFilter *)((char *)this - 120), a2);
}

uint64_t `non-virtual thunk to'HTTPWriteFilter::_streamImpl_Close(HTTPWriteFilter *this)
{
  return HTTPWriteFilter::_streamImpl_Close((HTTPWriteFilter *)((char *)this - 120));
}

CFIndex `non-virtual thunk to'HTTPWriteFilter::_streamImpl_Write(HTTPWriteFilter *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  return HTTPWriteFilter::_streamImpl_Write((HTTPWriteFilter *)((char *)this - 120), a2, a3, a4);
}

uint64_t `non-virtual thunk to'HTTPWriteFilter::_streamImpl_CanWrite(HTTPWriteFilter *this)
{
  return HTTPWriteFilter::socketStreamCanWrite((HTTPWriteFilter *)((char *)this - 120));
}

uint64_t `non-virtual thunk to'HTTPWriteFilter::_streamImpl_deprecated_Schedule(HTTPWriteFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  return HTTPWriteFilter::_streamImpl_deprecated_Schedule((HTTPWriteFilter *)((char *)this - 120), a2, a3);
}

uint64_t `non-virtual thunk to'HTTPWriteFilter::_streamImpl_deprecated_Unschedule(HTTPWriteFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  return HTTPWriteFilter::_streamImpl_deprecated_Unschedule((HTTPWriteFilter *)((char *)this - 120), a2, a3);
}

void HTTPWriteFilter::~HTTPWriteFilter(HTTPWriteFilter *this)
{
  pthread_mutex_t *v2;
  const void *v3;
  const void *v4;
  __CFWriteStream *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;

  *(_QWORD *)this = &off_1E14E7A50;
  *((_QWORD *)this + 1) = &unk_1E14E7AF0;
  *((_QWORD *)this + 15) = &unk_1E14E7B10;
  *((_QWORD *)this + 16) = &unk_1E14E7BC8;
  v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  v3 = (const void *)*((_QWORD *)this + 27);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 32);
  if (v4)
    CFRelease(v4);
  v5 = (__CFWriteStream *)*((_QWORD *)this + 26);
  if (v5)
  {
    CFWriteStreamClose(v5);
    CFWriteStreamSetClient(*((CFWriteStreamRef *)this + 26), 0, 0, 0);
    v6 = (const void *)*((_QWORD *)this + 26);
    *((_QWORD *)this + 26) = 0;
    if (v6)
      CFRelease(v6);
  }
  v7 = (const void *)*((_QWORD *)this + 33);
  if (v7)
    CFRelease(v7);
  v8 = (const void *)*((_QWORD *)this + 35);
  if (v8)
    CFRelease(v8);
  v9 = (const void *)*((_QWORD *)this + 29);
  if (v9)
    _Block_release(v9);
  pthread_mutex_unlock(v2);
  *((_QWORD *)this + 16) = &off_1E14E6990;
  pthread_mutex_destroy(v2);
  CoreStreamBase::~CoreStreamBase(this);
}

void sub_18404C900(_Unwind_Exception *a1)
{
  CoreStreamBase *v1;
  pthread_mutex_t *v2;

  *((_QWORD *)v1 + 16) = &off_1E14E6990;
  pthread_mutex_destroy(v2);
  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

uint64_t HTTPWriteFilter::socketStreamCanWrite(HTTPWriteFilter *this)
{
  pthread_mutex_t *v2;
  __CFWriteStream *v3;
  CFStreamStatus Status;
  __CFWriteStream *v5;
  CFStreamError Error;
  CFIndex domain;
  unint64_t v8;
  int *v9;
  int v10;
  CFIndex v11;
  uint64_t v12;
  uint64_t v13;
  CFIndex v14;
  CoreStreamBase *v15;
  CFStreamError v16;
  __int16 v17;

  v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  v3 = (__CFWriteStream *)*((_QWORD *)this + 26);
  if (!v3)
    goto LABEL_27;
  Status = CFWriteStreamGetStatus(v3);
  v5 = (__CFWriteStream *)*((_QWORD *)this + 26);
  if (Status == kCFStreamStatusError)
  {
    Error = CFWriteStreamGetError(v5);
    domain = Error.domain;
    v8 = *(_QWORD *)&Error.error;
    if (Error.domain != *MEMORY[0x1E0C9B298])
    {
      if ((*((_WORD *)this + 112) & 0x100) != 0)
      {
        v9 = &_kCFStreamErrorHTTPSProxyFailure;
        goto LABEL_16;
      }
      if ((*((_WORD *)this + 112) & 0x200) != 0)
      {
        v9 = &_kCFStreamErrorHTTPProxyFailure;
LABEL_16:
        v8 = *(_QWORD *)&Error.error & 0xFFFFFFFF00000000 | *v9;
        domain = 4;
      }
    }
    pthread_mutex_unlock(v2);
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    v15 = this;
    v16.domain = domain;
    *(_QWORD *)&v16.error = v8;
LABEL_20:
    CoreStreamBase::_signalEvent(v15, 8, v16, 1);
    return 0;
  }
  if (!CFWriteStreamCanAcceptBytes(v5))
    goto LABEL_27;
  v10 = *((unsigned __int16 *)this + 112);
  if ((~v10 & 0x401) == 0 || !*((_QWORD *)this + 27))
    goto LABEL_27;
  if ((v10 & 0x10) == 0)
  {
    v11 = HTTPWriteFilter::transmitHeader(this, 0);
    v13 = v12;
    if ((_DWORD)v12)
    {
      v14 = v11;
      pthread_mutex_unlock(v2);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      v15 = this;
      v16.domain = v14;
      *(_QWORD *)&v16.error = v13;
      goto LABEL_20;
    }
    if ((*((_WORD *)this + 112) & 0x10) == 0)
      goto LABEL_27;
  }
  if (!CFWriteStreamCanAcceptBytes(*((CFWriteStreamRef *)this + 26)))
  {
LABEL_27:
    pthread_mutex_unlock(v2);
    return 0;
  }
  v17 = *((_WORD *)this + 112);
  pthread_mutex_unlock(v2);
  if ((v17 & 0x1000) != 0)
    return 0;
  if (*((_QWORD *)this + 36))
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 25) + 216))(*((_QWORD *)this + 25));
    *((_QWORD *)this + 36) = 0;
  }
  return 1;
}

CFIndex HTTPWriteFilter::transmitHeader(HTTPWriteFilter *this, __CFHTTPMessage *a2)
{
  __int16 v2;
  int v4;
  uint64_t v5;
  __CFData *v6;
  int v7;
  const void *v8;
  const void *v9;
  uint64_t v10;
  uint64_t v11;
  CFIndex domain;
  __CFWriteStream *v13;
  __CFHTTPMessage *v14;
  __CFHTTPMessage *v15;
  CFIndex ResponseStatusCode;
  const void *v17;
  __CFWriteStream *v18;
  uint64_t v19;
  uint64_t v20;
  const __CFDictionary **v21;
  unsigned int v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  HTTPMessage *v31;
  const __CFString *v32;
  const __CFString *v33;
  __CFString *MutableCopy;
  uint64_t v35;
  HTTPMessage *v36;
  __CFWriteStream *v37;
  uint64_t v38;
  HTTPMessage *v39;
  uint64_t v40;
  HTTPMessage *v41;
  CFIndex Length;
  const UInt8 *BytePtr;
  CFIndex v44;
  CFIndex *v45;
  const UInt8 *v46;
  __CFWriteStream *v47;
  CFIndex v48;
  const void *v49;
  uint64_t v51;
  HTTPMessage *v52;
  CFStringRef v53;
  CFStringRef v54;
  uint64_t v55;
  HTTPMessage *v56;
  CFStreamError Error;
  SInt32 v58;
  __CFWriteStream *v59;
  const __CFURL *v60;
  CFStringRef v61;
  CFStringRef v62;
  __CFWriteStream *v63;
  __CFWriteStream *v64;
  uint64_t v65;
  CFRange v66;

  v2 = *((_WORD *)this + 112);
  if ((v2 & 0x10) != 0)
    return 0;
  if (!*((_QWORD *)this + 26))
    return 4;
  if ((*((_WORD *)this + 112) & 0x4000) != 0)
  {
    *((_WORD *)this + 112) = v2 & 0xBFFF;
    v8 = (const void *)*((_QWORD *)this + 27);
    *((_QWORD *)this + 27) = 0;
    if (v8)
      CFRelease(v8);
    v9 = (const void *)*((_QWORD *)this + 32);
    *((_QWORD *)this + 32) = 0;
    if (v9)
      CFRelease(v9);
    v10 = *((_QWORD *)this + 25);
    *(CFAbsoluteTime *)(v10 + 296) = CFAbsoluteTimeGetCurrent() + 10.0;
    (*(void (**)(_QWORD))(**((_QWORD **)this + 25) + 192))(*((_QWORD *)this + 25));
    v11 = *((_QWORD *)this + 29);
    if (v11)
    {
      (*(void (**)(uint64_t, _QWORD))(v11 + 16))(v11, 0);
      _Block_release(*((const void **)this + 29));
      domain = 0;
      *((_QWORD *)this + 29) = 0;
      return domain;
    }
    return 0;
  }
  v4 = (int)a2;
  v5 = *((_QWORD *)this + 29);
  if (v5)
  {
    (*(void (**)(uint64_t, _QWORD))(v5 + 16))(v5, 0);
    _Block_release(*((const void **)this + 29));
    *((_QWORD *)this + 29) = 0;
  }
  if (!*((_QWORD *)this + 27))
    return 4;
  if ((*((_WORD *)this + 112) & 0x100) != 0)
  {
    v13 = (__CFWriteStream *)*((_QWORD *)this + 26);
    if (!v13
      || (v14 = (__CFHTTPMessage *)CFWriteStreamCopyProperty(v13, CFSTR("kCFStreamPropertyCONNECTResponse"))) == 0)
    {
      *((_QWORD *)this + 31) = 0;
      *((_QWORD *)this + 32) = 0;
      return 4;
    }
    v15 = v14;
    ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v14);
    CFRelease(v15);
    if (ResponseStatusCode != 200)
    {
      *((_QWORD *)this + 31) = 0;
      *((_QWORD *)this + 32) = 0;
      if (ResponseStatusCode == 407)
      {
        domain = 0;
        v23 = *((_WORD *)this + 112) | 0x30;
LABEL_99:
        *((_WORD *)this + 112) = v23;
        return domain;
      }
      return 4;
    }
    *((_WORD *)this + 112) &= ~0x100u;
    v17 = (const void *)*((_QWORD *)this + 34);
    if (v17)
    {
      v18 = (__CFWriteStream *)*((_QWORD *)this + 26);
      if (v18)
      {
        CFWriteStreamSetProperty(v18, CFSTR("kCFStreamPropertySSLContext"), v17);
        v17 = (const void *)*((_QWORD *)this + 34);
        *((_QWORD *)this + 34) = 0;
        if (!v17)
          goto LABEL_142;
      }
      else
      {
        *((_QWORD *)this + 34) = 0;
      }
      goto LABEL_141;
    }
    v17 = (const void *)*((_QWORD *)this + 33);
    if (v17)
    {
      v37 = (__CFWriteStream *)*((_QWORD *)this + 26);
      if (!v37)
      {
        *((_QWORD *)this + 33) = 0;
        goto LABEL_141;
      }
      CFWriteStreamSetProperty(v37, CFSTR("kCFStreamPropertySocketSSLContext"), v17);
      v17 = (const void *)*((_QWORD *)this + 33);
      *((_QWORD *)this + 33) = 0;
      if (!v17)
      {
LABEL_142:
        if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 25) + 208))(*((_QWORD *)this + 25)))
          (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 25) + 280))(*((_QWORD *)this + 25), *((_QWORD *)this + 27));
        goto LABEL_8;
      }
    }
    else
    {
      v17 = (const void *)*((_QWORD *)this + 35);
      if (!v17)
      {
        v60 = CFHTTPMessageCopyRequestURL(*((CFHTTPMessageRef *)this + 27));
        v61 = CFURLCopyHostName(v60);
        if (v61)
        {
          v62 = v61;
          v63 = (__CFWriteStream *)*((_QWORD *)this + 26);
          if (v63)
            CFWriteStreamSetProperty(v63, (CFStreamPropertyKey)&unk_1EDCFA9C0, v62);
          CFRelease(v62);
        }
        if (v60)
          CFRelease(v60);
        v64 = (__CFWriteStream *)*((_QWORD *)this + 26);
        if (v64)
          CFWriteStreamSetProperty(v64, CFSTR("kCFStreamPropertySocketSecurityLevel"), &unk_1EDCFC1D0);
        goto LABEL_142;
      }
      v59 = (__CFWriteStream *)*((_QWORD *)this + 26);
      if (!v59)
      {
        *((_QWORD *)this + 35) = 0;
        goto LABEL_141;
      }
      CFWriteStreamSetProperty(v59, CFSTR("kCFStreamPropertySSLSettings"), v17);
      v17 = (const void *)*((_QWORD *)this + 35);
      *((_QWORD *)this + 35) = 0;
      if (!v17)
        goto LABEL_142;
    }
LABEL_141:
    CFRelease(v17);
    goto LABEL_142;
  }
LABEL_8:
  v6 = (__CFData *)*((_QWORD *)this + 32);
  if (v6)
  {
    v7 = 0;
    goto LABEL_85;
  }
  v19 = *((_QWORD *)this + 27);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v20 = v19 + 16;
  if (!v19)
    v20 = 0;
  v21 = *(const __CFDictionary ***)(v20 + 72);
  if (v21)
  {
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
    v22 = HTTPAuthentication::isKerberosThePreferredAuthScheme(v21[19]);
  }
  else
  {
    v22 = 0;
  }
  v24 = HTTPFilter::expectedSizeFromHeaders(*((HTTPFilter **)this + 27), a2);
  if (v24 == -1)
  {
    v30 = *((_QWORD *)this + 27);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (v30)
      v31 = (HTTPMessage *)(v30 + 16);
    else
      v31 = 0;
    v32 = HTTPMessage::copyHeaderFieldValue(v31, 0x146233E1u);
    if (v32)
    {
      v33 = v32;
      v66.length = CFStringGetLength(v32);
      v66.location = 0;
      if (!CFStringFindWithOptions(v33, (CFStringRef)&unk_1EDCFDBA0, v66, 1uLL, 0))
      {
        MutableCopy = CFStringCreateMutableCopy(0, 0, v33);
        CFStringAppend(MutableCopy, CFSTR(", Chunked"));
        v35 = *((_QWORD *)this + 27);
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        {
          v65 = *((_QWORD *)this + 27);
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
          v35 = v65;
        }
        if (v35)
          v36 = (HTTPMessage *)(v35 + 16);
        else
          v36 = 0;
        HTTPMessage::setHeaderFieldStringValue(v36, 0x146233E1u, MutableCopy);
        if (MutableCopy)
          CFRelease(MutableCopy);
      }
      CFRelease(v33);
    }
    else
    {
      v38 = *((_QWORD *)this + 27);
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (v38)
        v39 = (HTTPMessage *)(v38 + 16);
      else
        v39 = 0;
      HTTPMessage::setHeaderFieldStringValue(v39, 0x146233E1u, &unk_1EDCFDBD8);
    }
    *((_WORD *)this + 112) |= 0x80u;
    *((_QWORD *)this + 30) = 0;
  }
  else
  {
    v25 = v24;
    if (!v22)
    {
      v26 = *((_QWORD *)this + 27);
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v27 = v26 + 16;
      if (!v26)
        v27 = 0;
      if (_CFHTTPAuthenticationIsFirstNTLMTransaction(*(_CFHTTPAuthentication **)(v27 + 72), *((void **)this + 25)))
      {
        v28 = *((_QWORD *)this + 27);
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        v29 = v28 + 16;
        if (!v28)
          v29 = 0;
        *(_QWORD *)(v29 + 64) = v25;
        v25 = 0;
      }
    }
    *((_QWORD *)this + 30) = v25;
    *((_WORD *)this + 112) &= ~0x80u;
  }
  if (!v22
    && _CFHTTPAuthenticationIsFirstNTLMTransaction((_CFHTTPAuthentication *)v21, *((void **)this + 25)))
  {
    v51 = *((_QWORD *)this + 27);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (v51)
      v52 = (HTTPMessage *)(v51 + 16);
    else
      v52 = 0;
    v53 = HTTPMessage::copyHeaderFieldValue(v52, 0x11D1D2CFu);
    if (v53)
    {
      v54 = v53;
      v55 = *((_QWORD *)this + 27);
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (v55)
        v56 = (HTTPMessage *)(v55 + 16);
      else
        v56 = 0;
      HTTPMessage::setHeaderFieldStringValue(v56, 0x11D1D2CFu, CFSTR("0"));
      CFRelease(v54);
    }
  }
  v40 = *((_QWORD *)this + 27);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (v40)
    v41 = (HTTPMessage *)(v40 + 16);
  else
    v41 = 0;
  v6 = HTTPMessage::copySerializedHeaders(v41, (*((unsigned __int16 *)this + 112) >> 9) & 1);
  *((_QWORD *)this + 31) = 0;
  *((_QWORD *)this + 32) = v6;
  if (!v6)
    return 4;
  v7 = 1;
LABEL_85:
  Length = CFDataGetLength(v6);
  BytePtr = CFDataGetBytePtr(*((CFDataRef *)this + 32));
  v45 = (CFIndex *)((char *)this + 248);
  v44 = *((_QWORD *)this + 31);
  if (v44 < Length)
  {
    v46 = BytePtr;
    do
    {
      v47 = (__CFWriteStream *)*((_QWORD *)this + 26);
      if (!v47)
        break;
      if (!v4)
      {
        if (!CFWriteStreamCanAcceptBytes(v47))
          break;
        v47 = (__CFWriteStream *)*((_QWORD *)this + 26);
        v44 = *((_QWORD *)this + 31);
      }
      v48 = CFWriteStreamWrite(v47, &v46[v44], Length - v44);
      if (v48 < 0)
      {
        Error = CFWriteStreamGetError((CFWriteStreamRef)*((_QWORD *)this + 26));
        domain = Error.domain;
        v58 = Error.error;
        if (v7 && Error.domain == 1)
        {
          if (Error.error == 54 || Error.error == 32)
          {
            v58 = -4;
            domain = 4;
          }
          else
          {
            domain = 1;
          }
        }
        if (v58)
          goto LABEL_96;
        goto LABEL_95;
      }
      if (!v48)
      {
        if (!v7)
          *((_WORD *)this + 112) |= 0x2000u;
        domain = 4;
        goto LABEL_96;
      }
      v7 = 0;
      *((_QWORD *)this + 36) += v48;
      v44 = *((_QWORD *)this + 31) + v48;
      *((_QWORD *)this + 31) = v44;
    }
    while (v44 < Length);
  }
  domain = 0;
LABEL_95:
  if (*v45 >= Length)
  {
LABEL_96:
    v49 = (const void *)*((_QWORD *)this + 32);
    if (v49)
      CFRelease(v49);
    *v45 = 0;
    *((_QWORD *)this + 32) = 0;
    v23 = *((_WORD *)this + 112) | 0x10;
    goto LABEL_99;
  }
  return domain;
}

void HTTPWriteFilter::prepareHTTPSProxy(HTTPWriteFilter *this)
{
  uint64_t v2;
  HTTPMessage *v3;
  CFStringRef v4;
  CFStringRef v5;
  uint64_t v6;
  HTTPMessage *v7;

  v2 = *((_QWORD *)this + 27);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (v2)
    v3 = (HTTPMessage *)(v2 + 16);
  else
    v3 = 0;
  v4 = HTTPMessage::copyHeaderFieldValue(v3, 0x1362735Fu);
  if (v4)
  {
    v5 = v4;
    v6 = *((_QWORD *)this + 27);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (v6)
      v7 = (HTTPMessage *)(v6 + 16);
    else
      v7 = 0;
    HTTPMessage::removeHeaderFieldValue(v7, 0x1362735Fu);
    CFRelease(v5);
  }
  if ((*((_WORD *)this + 112) & 0x800) == 0)
    *((_WORD *)this + 112) = *((_WORD *)this + 112) & 0xF4FF | 0x900;
}

void HTTPWriteFilter::_httpWrFilterSocketStreamCallBack(HTTPWriteFilter *this, __CFWriteStream *a2, uint64_t a3, void *a4)
{
  const void *v7;
  CFStreamError Error;
  CFIndex domain;
  unint64_t v10;
  CoreStreamBase *v11;
  uint64_t v12;
  CFStreamError v13;
  __CFWriteStream *v14;
  __CFHTTPMessage *v15;
  __CFHTTPMessage *v16;
  CFIndex ResponseStatusCode;
  const void *v18;
  uint64_t v19;

  v7 = (const void *)(a3 - 16);
  CFRetain((CFTypeRef)(a3 - 16));
  if (a2 != (__CFWriteStream *)4)
  {
    if (a2 == (__CFWriteStream *)8)
    {
      Error = CFWriteStreamGetError(this);
      domain = Error.domain;
      v10 = *(_QWORD *)&Error.error;
      pthread_mutex_lock((pthread_mutex_t *)(a3 + 136));
      if ((*(_WORD *)(a3 + 224) & 0x10) == 0)
      {
        if ((*(_WORD *)(a3 + 224) & 0x100) == 0)
        {
          if ((*(_WORD *)(a3 + 224) & 0x200) != 0)
          {
            v10 = (*(_QWORD *)&Error.error & 0xFFFFFFFF00000000 | 0xFFFFF7CE) + 4;
            domain = 4;
          }
          goto LABEL_29;
        }
        v14 = *(__CFWriteStream **)(a3 + 208);
        if (v14
          && (v15 = (__CFHTTPMessage *)CFWriteStreamCopyProperty(v14, CFSTR("kCFStreamPropertyCONNECTResponse"))) != 0)
        {
          v16 = v15;
          ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v15);
          CFRelease(v16);
          if (ResponseStatusCode == 200)
            goto LABEL_29;
        }
        else
        {
          ResponseStatusCode = 500;
        }
        if (!*(_QWORD *)(a3 + 248))
        {
          v18 = *(const void **)(a3 + 256);
          if (v18)
            CFRelease(v18);
          *(_QWORD *)(a3 + 256) = 0;
          *(_WORD *)(a3 + 224) |= 0x10u;
        }
        if (ResponseStatusCode == 407)
        {
          *(_WORD *)(a3 + 224) |= 0x20u;
        }
        else
        {
          v19 = 4294965198;
          *(_WORD *)(a3 + 224) |= 0x40u;
          if ((unint64_t)(ResponseStatusCode - 300) > 0x63)
            v19 = 4294965200;
          v10 = *(_QWORD *)&Error.error & 0xFFFFFFFF00000000 | v19;
          domain = 4;
        }
      }
LABEL_29:
      pthread_mutex_unlock((pthread_mutex_t *)(a3 + 136));
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
      v11 = (CoreStreamBase *)a3;
      v12 = 8;
      v13.domain = domain;
      *(_QWORD *)&v13.error = v10;
      goto LABEL_32;
    }
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    v11 = (CoreStreamBase *)a3;
    v12 = (uint64_t)a2;
LABEL_14:
    v13.domain = 0;
    *(_QWORD *)&v13.error = 0;
LABEL_32:
    CoreStreamBase::_signalEvent(v11, v12, v13, 1);
    goto LABEL_33;
  }
  if (HTTPWriteFilter::socketStreamCanWrite((HTTPWriteFilter *)a3))
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    v11 = (CoreStreamBase *)a3;
    v12 = 4;
    goto LABEL_14;
  }
LABEL_33:
  CFRelease(v7);
}

uint64_t HTTPWriteFilter::doChunkedWrite(HTTPWriteFilter *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  uint64_t v5;
  CFIndex v8;
  uint64_t v9;
  __CFWriteStream *v10;
  __int16 v11;
  _BYTE *v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  const UInt8 *v16;
  CFIndex v17;
  uint64_t v18;
  __CFWriteStream *v19;
  uint64_t v20;
  CFIndex v21;
  uint64_t v22;
  _BYTE v24[3];
  uint64_t v25;

  v5 = a3;
  v25 = *MEMORY[0x1E0C80C00];
  v9 = *((_QWORD *)this + 30);
  v8 = *((_QWORD *)this + 31);
  if (v9 <= v8)
  {
    v10 = (__CFWriteStream *)*((_QWORD *)this + 26);
    v11 = *((_WORD *)this + 112);
    a4->error = 0;
    *(_WORD *)&v24[1] = 2573;
    v12 = v24;
    if (a3 >= 1)
    {
      v13 = a3;
      do
      {
        if ((v13 & 0xF) >= 0xA)
          v14 = (v13 & 0xF) + 55;
        else
          v14 = v13 & 0xF | 0x30;
        *v12-- = v14;
        v15 = v13 > 0xF;
        v13 >>= 4;
      }
      while (v15);
    }
    if ((v11 & 4) != 0)
    {
      v16 = v12 + 1;
    }
    else
    {
      *(_WORD *)(v12 - 1) = 2573;
      v16 = v12 - 1;
    }
    while (v16 < (const UInt8 *)&v25)
    {
      v17 = CFWriteStreamWrite(v10, v16, (char *)&v25 - (char *)v16);
      if (v17 < 0)
      {
        *a4 = CFWriteStreamGetError(v10);
        break;
      }
      if (!v17)
      {
        a4->domain = 4;
        a4->error = -1;
        break;
      }
      v16 += v17;
      *((_QWORD *)this + 36) += v17;
    }
    *((_WORD *)this + 112) &= ~4u;
    if (a4->error)
      return -1;
    v8 = 0;
    *((_QWORD *)this + 30) = v5;
    *((_QWORD *)this + 31) = 0;
    v9 = v5;
  }
  if (v9 <= v8)
  {
    v18 = 0;
  }
  else
  {
    v18 = 0;
    while (1)
    {
      v19 = (__CFWriteStream *)*((_QWORD *)this + 26);
      if (!v19)
        break;
      if (v18)
      {
        if (!CFWriteStreamCanAcceptBytes(v19))
          break;
        v9 = *((_QWORD *)this + 30);
        v8 = *((_QWORD *)this + 31);
        v19 = (__CFWriteStream *)*((_QWORD *)this + 26);
      }
      v20 = v9 - v8;
      if (v20 >= v5)
        LODWORD(v20) = v5;
      v21 = CFWriteStreamWrite(v19, a2, (int)v20);
      if (v21 < 0)
      {
        *a4 = CFWriteStreamGetError((CFWriteStreamRef)*((_QWORD *)this + 26));
        return -1;
      }
      if (v21)
      {
        v9 = *((_QWORD *)this + 30);
        v8 = *((_QWORD *)this + 31) + v21;
        *((_QWORD *)this + 36) += v21;
        *((_QWORD *)this + 31) = v8;
        v18 += v21;
        a2 += v21;
        v5 -= v21;
        if (v9 > v8)
          continue;
      }
      break;
    }
  }
  if (v5 && CFWriteStreamCanAcceptBytes(*((CFWriteStreamRef *)this + 26)))
  {
    v22 = HTTPWriteFilter::doChunkedWrite(this, a2, v5, a4);
    if (v22 < 0)
      return -1;
    else
      v18 += v22;
  }
  return v18;
}

void HTTPReadStream::~HTTPReadStream(CFReadStreamRef *this)
{
  HTTPReadStream::~HTTPReadStream(this);
  JUMPOUT(0x186DB748CLL);
}

{
  CFReadStreamRef v2;
  CFReadStreamRef v3;
  __CFReadStream *v4;
  CFReadStreamRef v5;
  CFReadStreamRef v6;
  CFReadStreamRef v7;
  CFReadStreamRef v8;
  CFReadStreamRef v9;
  CFReadStreamRef v10;
  CFReadStreamRef v11;
  CFReadStreamRef v12;
  CFReadStreamRef v13;

  *this = (CFReadStreamRef)&off_1E14E6F58;
  HTTPReadStream::dequeueRequestFromConnection((HTTPReadStream *)this, 0);
  v2 = this[3];
  if (v2)
    CFRelease((char *)v2 - 16);
  v3 = this[4];
  if (v3)
    CFRelease((char *)v3 - 16);
  v4 = this[5];
  if (((_WORD)this[2] & 0x10) != 0)
  {
    if (!v4)
      goto LABEL_11;
    CFReadStreamSetClient(this[5], 0, 0, 0);
    CFReadStreamClose(v4);
    goto LABEL_10;
  }
  if (v4)
LABEL_10:
    CFRelease(v4);
LABEL_11:
  v5 = this[6];
  if (v5)
    CFRelease(v5);
  v6 = this[11];
  if (v6)
    CFRelease(v6);
  if (((_WORD)this[2] & 4) == 0)
  {
    v7 = this[12];
    if (v7)
      CFRelease(v7);
    v8 = this[13];
    if (v8)
      CFRelease(v8);
  }
  v9 = this[7];
  if (v9)
    _Block_release(v9);
  v10 = this[8];
  if (v10)
    _Block_release(v10);
  v11 = this[9];
  if (v11)
    _Block_release(v11);
  v12 = this[15];
  if (v12)
    CFRelease(v12);
  v13 = this[18];
  if (v13)
  {
    (*(void (**)(CFReadStreamRef))(*(_QWORD *)v13 + 48))(v13);
    this[18] = 0;
  }
  *this = (CFReadStreamRef)&off_1E14E5838;
  this[1] = 0;
}

BOOL HTTPReadStream::_streamImpl_Open(HTTPReadStream *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  uint64_t Instance;
  uint64_t v8;
  const void *v9;
  int v10;
  _BOOL8 result;
  __CFReadStream *v12;
  _BOOL4 v13;

  CFGetAllocator(*((CFTypeRef *)this + 1));
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    Instance += 16;
    *(_QWORD *)(Instance + 176) = 0;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
  }
  HTTPRequestMessage::HTTPRequestMessage((HTTPRequestMessage *)Instance, *((const HTTPRequestMessage **)this + 3));
  *((_QWORD *)this + 4) = v8;
  if ((*((_WORD *)this + 8) & 0x100) != 0)
  {
    v9 = (const void *)*((_QWORD *)this + 11);
    if (v9)
      CFRelease(v9);
    *((_QWORD *)this + 11) = CFNetworkCopySystemProxySettings();
  }
  v10 = HTTPReadStream::constructProxyList(this, a3);
  if (a3->error)
  {
    result = 0;
    *a4 = 1;
    return result;
  }
  if (v10)
  {
    *a4 = 0;
    return 1;
  }
  HTTPReadStream::startRequest(this, a3);
  if (!a3->error)
  {
    v12 = (__CFReadStream *)*((_QWORD *)this + 10);
    if (v12)
      v13 = CFReadStreamGetStatus(v12) > kCFStreamStatusOpening;
    else
      v13 = 0;
    *a4 = v13;
    if (v13)
      return a3->error == 0;
    goto LABEL_15;
  }
  if (!*a4)
LABEL_15:
    *a4 = 1;
  return a3->error == 0;
}

BOOL HTTPReadStream::_streamImpl_OpenCompleted(HTTPReadStream *this, __CFReadStream *a2, CFStreamError *a3)
{
  return (*((_WORD *)this + 8) & 4) == 0 && *((_QWORD *)this + 10) != 0;
}

uint64_t HTTPReadStream::_streamImpl_Read(HTTPReadStream *this, __CFReadStream *a2, UInt8 *buffer, CFIndex bufferLength, CFStreamError *a5, BOOL *a6)
{
  __CFReadStream *v12;
  CFIndex v13;
  __int16 v14;
  uint64_t v15;
  int Header;
  uint8_t v18[16];

  a5->domain = 0;
  a5->error = 0;
  v12 = (__CFReadStream *)*((_QWORD *)this + 10);
  if (!v12)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v18 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "httpRequestRead(): no stream to read from!", v18, 2u);
      v12 = (__CFReadStream *)*((_QWORD *)this + 10);
    }
    else
    {
      v12 = 0;
    }
  }
  *((_WORD *)this + 8) |= 0x40u;
  v13 = CFReadStreamRead(v12, buffer, bufferLength);
  v14 = *((_WORD *)this + 8);
  *((_WORD *)this + 8) = v14 & 0xFFBF;
  if (v13 < 0)
  {
    *a5 = CFReadStreamGetError((CFReadStreamRef)*((_QWORD *)this + 10));
    if (HTTPReadStream::reattemptAfterError((CFReadStreamRef *)this, a5))
      goto LABEL_10;
    goto LABEL_11;
  }
  v15 = v13;
  if ((v14 & 8) == 0)
  {
    Header = HTTPReadStream::readHeader(this, a5);
    if (!a5->error)
    {
      if (Header)
        goto LABEL_8;
LABEL_10:
      v15 = (*(uint64_t (**)(HTTPReadStream *, __CFReadStream *, UInt8 *, CFIndex, CFStreamError *, BOOL *))(*(_QWORD *)this + 40))(this, a2, buffer, bufferLength, a5, a6);
      goto LABEL_12;
    }
LABEL_11:
    v15 = -1;
    goto LABEL_12;
  }
LABEL_8:
  *a6 = CFReadStreamGetStatus(*((CFReadStreamRef *)this + 10)) > kCFStreamStatusWriting;
LABEL_12:
  *((_WORD *)this + 8) &= ~0x200u;
  return v15;
}

uint64_t HTTPReadStream::_streamImpl_CanRead(HTTPReadStream *this, __CFReadStream *a2)
{
  __CFReadStream *v3;
  CFStreamStatus Status;
  uint64_t result;
  CFStreamError v6;

  v6.domain = 0;
  *(_QWORD *)&v6.error = 0;
  v3 = (__CFReadStream *)*((_QWORD *)this + 10);
  if (!v3)
  {
    v6.domain = 4;
    v6.error = -4;
    goto LABEL_9;
  }
  Status = CFReadStreamGetStatus(v3);
  if (Status < kCFStreamStatusOpen)
    return 0;
  if ((unint64_t)Status > kCFStreamStatusWriting)
    return 1;
  result = CFReadStreamHasBytesAvailable(*((CFReadStreamRef *)this + 10));
  if (!(_DWORD)result)
    return result;
  if ((*((_WORD *)this + 8) & 8) != 0)
    return 1;
  result = HTTPReadStream::readHeader(this, &v6);
  if (v6.error)
  {
LABEL_9:
    CFReadStreamSignalEvent();
    return 0;
  }
  return result;
}

void HTTPReadStream::_streamImpl_Close(__CFRunLoopSource **this, __CFReadStream *a2)
{
  __int16 v3;
  __CFRunLoopSource *v4;
  __CFRunLoopSource *v5;

  if (this[10])
    HTTPReadStream::dequeueRequestFromConnection((HTTPReadStream *)this, 1);
  v3 = *((_WORD *)this + 8);
  if ((v3 & 4) != 0)
  {
    v4 = this[14];
    if (v4)
    {
      CFRunLoopSourceInvalidate(v4);
      v5 = this[14];
      if (v5)
        CFRelease(v5);
      this[14] = 0;
      v3 = *((_WORD *)this + 8);
    }
    *((_WORD *)this + 8) = v3 & 0xFFFB;
  }
}

CFTypeRef HTTPReadStream::_streamImpl_CopyProperty(HTTPReadStream *this, __CFReadStream *a2, CFStringRef theString)
{
  int ExactString;
  uint64_t v6;
  const void *v7;
  const void **v8;
  CFTypeRef v10;
  __CFReadStream *v11;
  void (**v12)(AutoScalar *__hidden);
  CFTypeRef cf;

  ExactString = _findExactString(theString, 8u);
  if (ExactString > 440678318)
  {
    if (ExactString == 440678319)
    {
      AutoScalar::AutoScalar((AutoScalar *)&v12, (const __CFAllocator *)*((unsigned int *)this + 32));
      if (cf)
      {
        v10 = CFRetain(cf);
        v12 = &off_1E14E47E8;
        if (cf)
          CFRelease(cf);
      }
      else
      {
        v10 = 0;
        v12 = &off_1E14E47E8;
      }
      return v10;
    }
    if (ExactString != 441669568)
    {
      if (ExactString == 445970438)
      {
        v8 = (const void **)MEMORY[0x1E0C9AE50];
        if ((*((_WORD *)this + 8) & 1) == 0)
          v8 = (const void **)MEMORY[0x1E0C9AE40];
        v7 = *v8;
        if (!*v8)
          return 0;
        return CFRetain(v7);
      }
LABEL_22:
      v11 = (__CFReadStream *)*((_QWORD *)this + 10);
      if (v11)
        return CFReadStreamCopyProperty(v11, theString);
      return 0;
    }
    v7 = (const void *)*((_QWORD *)this + 11);
    if (v7)
      return CFRetain(v7);
  }
  else if (ExactString != 436426600)
  {
    if (ExactString == 438581135)
      return CFRetain((CFTypeRef)(*((_QWORD *)this + 4) - 16));
    if (ExactString == 439596960)
    {
      v6 = *((_QWORD *)this + 4);
      if (!v6)
        v6 = *((_QWORD *)this + 3);
      v7 = (const void *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(v6 + 128));
      if (!v7)
        return 0;
      return CFRetain(v7);
    }
    goto LABEL_22;
  }
  return 0;
}

void sub_18404DD10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t HTTPReadStream::_streamImpl_SetProperty(CFReadStreamRef *this, __CFReadStream *a2, const __CFString *a3, const void *a4)
{
  uint64_t result;
  int ExactString;
  CFTypeID v9;
  const __CFAllocator *v10;
  __CFArray *Mutable;
  const void *v12;
  __int16 v13;
  CFReadStreamRef v14;
  __CFReadStream *v15;
  CFTypeID v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const void *Value;
  uint64_t v23;
  CFReadStreamRef v24;
  const __CFAllocator *v25;
  const __CFAllocator *v26;
  const CFDictionaryKeyCallBacks *v27;
  const CFDictionaryValueCallBacks *v28;
  const void **v29;
  const void **v30;
  CFIndex v31;
  int v32;
  CFTypeID v33;
  CFReadStreamRef v34;
  const __CFAllocator *v35;
  CFTypeID v36;
  __CFDictionary *v37;
  CFReadStreamRef v38;
  const __CFAllocator *v39;
  CFIndex v40;
  __CFDictionary *MutableCopy;
  CFTypeID v42;
  __int16 v43;
  CFReadStreamRef v44;
  __CFReadStream *v45;
  CFTypeID v46;
  CFTypeID v47;
  uint64_t v48;
  CFReadStreamRef v49;
  __CFReadStream *v50;
  CFReadStreamRef v51;
  const __CFDictionary *v52;
  const void *v53;
  const __CFAllocator *v54;
  CFIndex v55;
  const void *v56;
  __CFDictionary *v57;
  CFReadStreamRef v58;
  const __CFAllocator *v59;
  CFIndex v60;
  CFIndex Count;
  const void **v62;
  const void **v63;
  const void *v64;
  const void *v65;
  const void *v66;
  CFReadStreamRef v67;
  _OWORD v68[3];
  uint64_t v69;
  _OWORD v70[3];
  uint64_t v71;
  _QWORD valuePtr[8];

  valuePtr[7] = *MEMORY[0x1E0C80C00];
  if (CFReadStreamGetStatus(this[1]) > kCFStreamStatusNotOpen)
    return 0;
  ExactString = _findExactString(a3, 0);
  result = 0;
  if (ExactString <= 223645656)
  {
    if (ExactString > 104064895)
    {
      if (ExactString > 107284407)
      {
        if (ExactString == 107284408)
          return result;
        v32 = 216338253;
      }
      else
      {
        if (ExactString == 104064896)
        {
          if (!a4)
            goto LABEL_81;
          v46 = CFGetTypeID(a4);
          if (v46 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            LOWORD(valuePtr[0]) = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)valuePtr, 2u);
          }
          if ((const void *)*MEMORY[0x1E0C9AE50] == a4)
            v13 = *((_WORD *)this + 8) | 0x20;
          else
LABEL_81:
            v13 = (_WORD)this[2] & 0xFFDF;
          goto LABEL_116;
        }
        v32 = 106203045;
      }
    }
    else
    {
      if (ExactString <= 96814833)
      {
        if (ExactString == 83273191)
        {
          v44 = this[9];
          if (v44)
            _Block_release(v44);
          if (a4)
            v45 = (__CFReadStream *)_Block_copy(a4);
          else
            v45 = 0;
          this[9] = v45;
          return 1;
        }
        if (ExactString == 90506882)
        {
          v14 = this[8];
          if (v14)
            _Block_release(v14);
          if (a4)
            v15 = (__CFReadStream *)_Block_copy(a4);
          else
            v15 = 0;
          this[8] = v15;
          return 1;
        }
        goto LABEL_61;
      }
      if (ExactString == 96814834)
        return result;
      v32 = 97904392;
    }
    if (ExactString == v32)
      return result;
LABEL_61:
    v37 = this[6];
    if (a4)
      CFDictionarySetValue(v37, a3, a4);
    else
      CFDictionaryRemoveValue(v37, a3);
    return 1;
  }
  if (ExactString <= 440678318)
  {
    if (ExactString > 397808987)
    {
      if (ExactString == 397808988)
      {
        v49 = this[7];
        if (v49)
          _Block_release(v49);
        if (a4)
          v50 = (__CFReadStream *)_Block_copy(a4);
        else
          v50 = 0;
        this[7] = v50;
        return 1;
      }
      if (ExactString == 437655414)
      {
        if (!a4)
          goto LABEL_57;
        v36 = CFGetTypeID(a4);
        if (v36 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          LOWORD(valuePtr[0]) = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)valuePtr, 2u);
        }
        if ((const void *)*MEMORY[0x1E0C9AE50] == a4)
          v13 = *((_WORD *)this + 8) | 2;
        else
LABEL_57:
          v13 = (_WORD)this[2] & 0xFFFD;
        goto LABEL_116;
      }
      goto LABEL_61;
    }
    if (ExactString == 223645657)
      return result;
    if (ExactString != 225669117)
      goto LABEL_61;
    if (a4)
    {
      v16 = CFGetTypeID(a4);
      if (v16 != CFDictionaryGetTypeID())
        return 0;
      v17 = 0;
      v18 = 0;
      v71 = 0;
      memset(v70, 0, sizeof(v70));
      v69 = 0;
      v19 = *MEMORY[0x1E0C9B2D0];
      valuePtr[0] = *MEMORY[0x1E0C9B2C8];
      valuePtr[1] = v19;
      v20 = *MEMORY[0x1E0C9B2D8];
      valuePtr[2] = *MEMORY[0x1E0C9B2E0];
      valuePtr[3] = v20;
      valuePtr[4] = *MEMORY[0x1E0C9B2B8];
      valuePtr[5] = 0x1EDCFB408;
      valuePtr[6] = *MEMORY[0x1E0CE8F30];
      memset(v68, 0, sizeof(v68));
      do
      {
        v21 = valuePtr[v17];
        if (v21)
        {
          Value = CFDictionaryGetValue((CFDictionaryRef)a4, (const void *)valuePtr[v17]);
          if (Value)
          {
            *((_QWORD *)v70 + v18) = v21;
            *((_QWORD *)v68 + v18++) = Value;
          }
        }
        ++v17;
      }
      while (v17 != 7);
      v23 = v18;
      v24 = this[11];
      v25 = CFGetAllocator(this[1]);
      v26 = v25;
      if (v24 || !v18)
      {
        Count = CFDictionaryGetCount(this[11]);
        MutableCopy = CFDictionaryCreateMutableCopy(v26, Count + 4, this[11]);
        if (v18 >= 1)
        {
          v62 = (const void **)v68;
          v63 = (const void **)v70;
          do
          {
            v65 = *v63++;
            v64 = v65;
            v66 = *v62++;
            CFDictionarySetValue(MutableCopy, v64, v66);
            --v23;
          }
          while (v23);
        }
        goto LABEL_120;
      }
      v27 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
      v28 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
      v29 = (const void **)v70;
      v30 = (const void **)v68;
      v31 = v18;
      goto LABEL_113;
    }
    v52 = this[11];
    if (!v52)
      return 1;
    v53 = (const void *)*MEMORY[0x1E0C9B2C8];
    if (!CFDictionaryGetValue(v52, (const void *)*MEMORY[0x1E0C9B2C8]))
      return 1;
    v54 = CFGetAllocator(this[1]);
    v55 = CFDictionaryGetCount(this[11]);
    MutableCopy = CFDictionaryCreateMutableCopy(v54, v55, this[11]);
    CFDictionaryRemoveValue(MutableCopy, v53);
    v56 = (const void *)*MEMORY[0x1E0C9B2D0];
    v57 = MutableCopy;
LABEL_103:
    CFDictionaryRemoveValue(v57, v56);
LABEL_120:
    v67 = this[11];
    if (v67)
      CFRelease(v67);
    goto LABEL_122;
  }
  if (ExactString > 445970437)
  {
    if (ExactString != 455284827)
    {
      if (ExactString != 447051802)
      {
        if (ExactString == 445970438)
        {
          if (!a4)
            goto LABEL_89;
          v9 = CFGetTypeID(a4);
          if (v9 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            LOWORD(valuePtr[0]) = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)valuePtr, 2u);
          }
          if ((const void *)*MEMORY[0x1E0C9AE40] == a4)
          {
LABEL_89:
            v51 = this[15];
            if (v51)
              CFRelease(v51);
            this[15] = 0;
            v13 = (_WORD)this[2] & 0xFFFE;
          }
          else
          {
            if (!this[15])
            {
              v10 = CFGetAllocator(this[1]);
              Mutable = CFArrayCreateMutable(v10, 0, MEMORY[0x1E0C9B378]);
              this[15] = Mutable;
              v12 = (const void *)HTTPRequestParserClient::requestURL((CFReadStreamRef)((char *)this[3] + 128));
              CFArrayAppendValue(Mutable, v12);
            }
            v13 = *((_WORD *)this + 8) | 1;
          }
LABEL_116:
          *((_WORD *)this + 8) = v13;
          return 1;
        }
        goto LABEL_61;
      }
      if (a4)
      {
        v42 = CFGetTypeID(a4);
        if (v42 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          LOWORD(valuePtr[0]) = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)valuePtr, 2u);
        }
        v43 = *((_WORD *)this + 8);
        if ((const void *)*MEMORY[0x1E0C9AE50] == a4)
          v13 = v43 | 0x100;
        else
          v13 = v43 & 0xFEFF;
        goto LABEL_116;
      }
      return 0;
    }
    valuePtr[0] = a4;
    v38 = this[11];
    if (a4)
    {
      v25 = CFGetAllocator(this[1]);
      v39 = v25;
      if (v38)
      {
        v40 = CFDictionaryGetCount(this[11]);
        MutableCopy = CFDictionaryCreateMutableCopy(v39, v40 + 1, this[11]);
        CFDictionarySetValue(MutableCopy, &unk_1EDCFEF18, a4);
        goto LABEL_120;
      }
      v29 = (const void **)&_kCFStreamPropertyHTTPProxyProxyAutoConfigURLString;
      v27 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
      v28 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
      v30 = (const void **)valuePtr;
      v31 = 1;
LABEL_113:
      MutableCopy = CFDictionaryCreate(v25, v29, v30, v31, v27, v28);
LABEL_122:
      this[11] = MutableCopy;
      return 1;
    }
    if (!v38 || !CFDictionaryGetValue(this[11], &unk_1EDCFEF18))
      return 1;
    v59 = CFGetAllocator(this[1]);
    v60 = CFDictionaryGetCount(this[11]);
    v57 = CFDictionaryCreateMutableCopy(v59, v60, this[11]);
    MutableCopy = v57;
    v56 = &unk_1EDCFEF18;
    goto LABEL_103;
  }
  if (ExactString != 440678319)
  {
    if (ExactString != 441669568)
      goto LABEL_61;
    if (!a4)
    {
      v58 = this[11];
      if (v58)
        CFRelease(v58);
      this[11] = 0;
      return 1;
    }
    v33 = CFGetTypeID(a4);
    if (v33 == CFDictionaryGetTypeID())
    {
      v34 = this[11];
      if (v34)
        CFRelease(v34);
      v35 = CFGetAllocator(this[1]);
      this[11] = CFDictionaryCreateCopy(v35, (CFDictionaryRef)a4);
      return 1;
    }
    return 0;
  }
  if (a4)
  {
    v47 = CFGetTypeID(a4);
    if (v47 != CFNumberGetTypeID())
      return 0;
    valuePtr[0] = 0;
    CFNumberGetValue((CFNumberRef)a4, kCFNumberCFIndexType, valuePtr);
    v48 = valuePtr[0];
  }
  else
  {
    v48 = 20;
  }
  this[16] = (CFReadStreamRef)v48;
  return 1;
}

void HTTPReadStream::_streamImpl_deprecated_Schedule(HTTPReadStream *this, __CFReadStream *a2, CFRunLoopRef rl, CFRunLoopMode mode)
{
  uint64_t v7;
  __CFReadStream *v8;

  v7 = *((_QWORD *)this + 18);
  if (v7)
    *((_QWORD *)this + 18) = (*(uint64_t (**)(uint64_t, CFRunLoopRef, CFRunLoopMode))(*(_QWORD *)v7 + 56))(v7, rl, mode);
  if ((*((_WORD *)this + 8) & 4) != 0)
  {
    CFRunLoopAddSource(rl, *((CFRunLoopSourceRef *)this + 14), mode);
  }
  else
  {
    v8 = (__CFReadStream *)*((_QWORD *)this + 10);
    if (v8)
      CFReadStreamScheduleWithRunLoop(v8, rl, mode);
  }
}

void HTTPReadStream::_streamImpl_deprecated_Unschedule(HTTPReadStream *this, __CFReadStream *a2, CFRunLoopRef rl, CFRunLoopMode mode)
{
  uint64_t v7;
  __CFReadStream *v8;

  v7 = *((_QWORD *)this + 18);
  if (v7)
    *((_QWORD *)this + 18) = (*(uint64_t (**)(uint64_t, CFRunLoopRef, CFRunLoopMode))(*(_QWORD *)v7 + 64))(v7, rl, mode);
  if ((*((_WORD *)this + 8) & 4) != 0)
  {
    CFRunLoopRemoveSource(rl, *((CFRunLoopSourceRef *)this + 14), mode);
  }
  else
  {
    v8 = (__CFReadStream *)*((_QWORD *)this + 10);
    if (v8)
      CFReadStreamUnscheduleFromRunLoop(v8, rl, mode);
  }
}

CFStringRef HTTPReadStream::copyDebugDesc(HTTPReadStream *this)
{
  const __CFURL *v2;
  const __CFAllocator *v3;
  CFStringRef v4;

  v2 = (const __CFURL *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*((_QWORD *)this + 3) + 128));
  v3 = CFGetAllocator(*((CFTypeRef *)this + 1));
  v4 = CFURLGetString(v2);
  return CFStringCreateWithFormat(v3, 0, CFSTR("<HTTP request stream %p>{url = %@, flags=%p, connection stream = %p}"), this, v4, (char *)this + 16, *((_QWORD *)this + 10));
}

CFStringRef HTTPReadStream::copyDebugSummary(HTTPReadStream *this)
{
  __CFReadStream *v2;
  const char *v3;
  CFStringRef result;
  const __CFAllocator *v5;
  CFStreamError Error;
  const __CFAllocator *v7;

  v2 = (__CFReadStream *)*((_QWORD *)this + 1);
  if (!v2)
    return (CFStringRef)CFRetain(CFSTR("null response stream"));
  v3 = "NotOpen";
  switch(CFReadStreamGetStatus(v2))
  {
    case kCFStreamStatusNotOpen:
      goto LABEL_11;
    case kCFStreamStatusOpening:
      v3 = "Opening";
      goto LABEL_11;
    case kCFStreamStatusOpen:
      v3 = "Open";
      goto LABEL_11;
    case kCFStreamStatusReading:
      v3 = "Reading";
      goto LABEL_11;
    case kCFStreamStatusWriting:
      v3 = "Writing";
      goto LABEL_11;
    case kCFStreamStatusAtEnd:
      v3 = "AtEnd";
      goto LABEL_11;
    case kCFStreamStatusClosed:
      v3 = "Closed";
      goto LABEL_11;
    case kCFStreamStatusError:
      Error = CFReadStreamGetError((CFReadStreamRef)*((_QWORD *)this + 1));
      v7 = CFGetAllocator(*((CFTypeRef *)this + 1));
      return CFStringCreateWithFormat(v7, 0, CFSTR("read stream error { %ld, %d }"), Error.domain, *(_QWORD *)&Error.error);
    default:
      v3 = "?";
LABEL_11:
      v5 = CFGetAllocator(*((CFTypeRef *)this + 1));
      result = CFStringCreateWithFormat(v5, 0, CFSTR("read stream status %s"), v3);
      break;
  }
  return result;
}

void HTTPReadStream::dequeueRequestFromConnection(HTTPReadStream *this, int a2)
{
  __CFReadStream *v2;
  uint64_t InfoPointer;
  uint64_t v6;
  uint64_t v7;
  __CFReadStream *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _CFHTTPAuthentication *v13;
  _CFHTTPAuthentication *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  NetConnectionCache *v19;
  const __CFString *v20;
  const __CFString *v21;
  int v22;
  const __CFDictionary *v23;
  const __CFDictionary *v24;
  char *Key;
  char *v26;
  const void *Value;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;
  int IsValid;
  const void *v32;
  const void *v33;

  v2 = (__CFReadStream *)*((_QWORD *)this + 10);
  if (v2)
  {
    if ((*((_WORD *)this + 8) & 2) == 0)
    {
      CFReadStreamSetClient(*((CFReadStreamRef *)this + 10), 0, 0, 0);
      if (a2)
      {
        CFReadStreamClose(*((CFReadStreamRef *)this + 10));
      }
      else
      {
        CFReadStreamClose(v2);
        CFRelease(v2);
        *((_QWORD *)this + 10) = 0;
      }
      return;
    }
    InfoPointer = CFReadStreamGetInfoPointer();
    v6 = *(_QWORD *)(InfoPointer + 128);
    if (v6)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
      v7 = *(_QWORD *)(InfoPointer + 128);
    }
    else
    {
      v7 = 0;
    }
    v8 = (__CFReadStream *)*((_QWORD *)this + 10);
    if (a2)
    {
      if (v8)
      {
        CFReadStreamClose(*((CFReadStreamRef *)this + 10));
        CFReadStreamSetClient(*((CFReadStreamRef *)this + 10), 0, 0, 0);
      }
      if (v7)
        goto LABEL_13;
    }
    else
    {
      if (v8)
      {
        CFReadStreamSetClient(*((CFReadStreamRef *)this + 10), 0, 0, 0);
        CFReadStreamClose(v8);
        CFRelease(v8);
      }
      *((_QWORD *)this + 10) = 0;
      if (v7)
      {
LABEL_13:
        if (!NetConnection::willEnqueueRequests((NetConnection *)v7))
          goto LABEL_31;
        v9 = *(_QWORD *)(v7 + 96);
        if (v9)
          pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
        v10 = (_QWORD *)(v7 + 136);
        do
          v10 = (_QWORD *)*v10;
        while (v10
             && (*(unsigned int (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v7 + 168))(v7, _checkIsZombie, v10[1]));
        v11 = *(_QWORD *)(v7 + 96);
        if (v11)
          pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8));
        v12 = *((_QWORD *)this + 4);
        v13 = *(_CFHTTPAuthentication **)(v12 + 72);
        if (v13)
        {
          if (!_CFHTTPAuthenticationRequiresPersistentConnection(*(CFHTTPAuthenticationRef *)(v12 + 72)))
            v13 = 0;
          v12 = *((_QWORD *)this + 4);
        }
        v14 = *(_CFHTTPAuthentication **)(v12 + 80);
        if (v14 && !_CFHTTPAuthenticationRequiresPersistentConnection(*(CFHTTPAuthenticationRef *)(v12 + 80)))
          v14 = 0;
        if (!v13 && !v14 && !v10 || v13 && !CFHTTPAuthenticationIsValid(v13, 0))
          goto LABEL_31;
        if (v14)
        {
          IsValid = CFHTTPAuthenticationIsValid(v14, 0);
          if (!IsValid || v10)
          {
            if (!IsValid)
            {
LABEL_31:
              v15 = *(_QWORD *)(v7 + 96);
              if (v15)
                pthread_mutex_lock((pthread_mutex_t *)(v15 + 8));
              *(_WORD *)(v7 + 88) &= ~1u;
              NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease(v7);
              v16 = *(_QWORD *)(v7 + 96);
              if (v16)
                pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8));
              if (getNetConnectionCache(void)::sOnce != -1)
                dispatch_once(&getNetConnectionCache(void)::sOnce, &__block_literal_global_37);
              v17 = getNetConnectionCache(void)::gHTTPConnectionCache;
              v18 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 80))(v7);
              v19 = *(NetConnectionCache **)(v7 + 8);
              v20 = (const __CFString *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v18 + 272) + 72))(*(_QWORD *)(v18 + 272));
              v21 = (const __CFString *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v18 + 272) + 80))(*(_QWORD *)(v18 + 272));
              v22 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v18 + 272) + 88))(*(_QWORD *)(v18 + 272));
              v23 = (const __CFDictionary *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v18 + 272) + 64))(*(_QWORD *)(v18 + 272));
              Key = NetConnectionCache::createKey(v19, v20, v21, v22, v23, v24);
              if (Key)
              {
                v26 = Key;
                os_unfair_lock_lock((os_unfair_lock_t)(v17 + 8));
                Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v17 + 16), v26);
                if (Value)
                  v28 = Value == (const void *)v7;
                else
                  v28 = 0;
                if (v28)
                {
                  v29 = *(_QWORD *)(v7 + 96);
                  if (v29)
                    pthread_mutex_lock((pthread_mutex_t *)(v29 + 8));
                  *(_WORD *)(v7 + 88) &= ~1u;
                  NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease(v7);
                  v30 = *(_QWORD *)(v7 + 96);
                  if (v30)
                    pthread_mutex_unlock((pthread_mutex_t *)(v30 + 8));
                  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v17 + 16), v26);
                }
                os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 8));
                (*(void (**)(char *))(*(_QWORD *)v26 + 48))(v26);
              }
            }
LABEL_49:
            (*(void (**)(uint64_t))(*(_QWORD *)v7 + 48))(v7);
            return;
          }
        }
        else if (v10)
        {
          goto LABEL_49;
        }
        if (!v13
          || (v32 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 80))(v7),
              _CFHTTPAuthenticationConnectionAuthenticated(v13, v32)))
        {
          if (!v14)
            goto LABEL_31;
          v33 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 80))(v7);
          if (_CFHTTPAuthenticationConnectionAuthenticated(v14, v33))
            goto LABEL_31;
        }
        goto LABEL_49;
      }
    }
  }
}

uint64_t _checkIsZombie(unsigned __int8 *a1, NetConnection *a2, const void *a3)
{
  return (a1[32] >> 2) & 1;
}

char *NetConnectionCache::createKey(NetConnectionCache *this, const __CFString *a2, const __CFString *a3, int a4, const __CFDictionary *a5, const __CFDictionary *a6)
{
  int v8;
  char *v11;
  char *v12;
  AutoDict *Copy;
  const void *EmptyDict;

  if (!a2)
    return 0;
  v8 = (int)a3;
  v11 = (char *)CFAllocatorAllocate(this, 48, 0);
  *(_QWORD *)(v11 + 20) = 0;
  *(_QWORD *)(v11 + 36) = 0;
  *(_QWORD *)(v11 + 28) = 0;
  *((_DWORD *)v11 + 11) = 0;
  *(_QWORD *)v11 = off_1E14EF578;
  *((_QWORD *)v11 + 1) = this;
  *((_DWORD *)v11 + 4) = 1;
  if (((unint64_t)(v11 + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  v12 = v11;
  *(_QWORD *)v11 = off_1E14EFF80;
  Copy = (AutoDict *)CFStringCreateCopy(this, a2);
  *((_QWORD *)v12 + 3) = Copy;
  *((_DWORD *)v12 + 8) = v8;
  *((_DWORD *)v12 + 9) = a4;
  if (a5)
  {
    EmptyDict = CFDictionaryCreateCopy(this, a5);
  }
  else
  {
    EmptyDict = (const void *)AutoDict::getEmptyDict(Copy);
    if (EmptyDict)
      EmptyDict = CFRetain(EmptyDict);
  }
  *((_QWORD *)v12 + 5) = EmptyDict;
  return v12;
}

CFMutableDictionaryRef ___ZL21getNetConnectionCachev_block_invoke()
{
  uint64_t v0;
  CFMutableDictionaryRef result;

  v0 = operator new();
  *(_DWORD *)(v0 + 8) = 0;
  *(_QWORD *)v0 = &off_1E14E9918;
  result = CFDictionaryCreateMutable(0, 0, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
  *(_QWORD *)(v0 + 16) = result;
  getNetConnectionCache(void)::gHTTPConnectionCache = v0;
  return result;
}

void sub_18404ED84(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10A1C406B6A53AFLL);
  _Unwind_Resume(a1);
}

uint64_t HTTPReadStream::readHeader(HTTPReadStream *this, CFStreamError *a2)
{
  __int16 v4;
  const __CFURL *v5;
  CFURLRef v6;
  uint64_t v7;
  const __CFString *v8;
  CFStreamError Error;
  uint64_t result;
  CFIndex ResponseStatusCode;
  const __CFString *v12;
  const __CFAllocator *v13;
  const __CFArray *v14;
  const __CFArray *v15;
  CFIndex Count;
  const __CFURL *ValueAtIndex;
  CFIndex location;
  const __CFString *v19;
  CFStringEncoding v20;
  CFIndex Length;
  UInt8 *v22;
  const __CFArray *v23;
  uint64_t Instance;
  HTTPRequestMessage *v25;
  HTTPMessage *v26;
  __CFArray *v27;
  const __CFDictionary *v28;
  const __CFString *v29;
  const __CFString *v30;
  const void *v31;
  int v32;
  uint8_t v33[16];
  uint8_t buf[16];
  CFRange v35;

  if (!*((_QWORD *)this + 10) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v33 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "readHeader(): no stream to read from!", v33, 2u);
  }
  v4 = *((_WORD *)this + 8);
  *((_WORD *)this + 8) = v4 | 8;
  if ((v4 & 1) == 0)
    return 1;
  v5 = (const __CFURL *)CFReadStreamCopyProperty(*((CFReadStreamRef *)this + 10), CFSTR("kCFStreamPropertyHTTPResponseHeader"));
  if (!v5)
  {
    if (CFReadStreamGetStatus(*((CFReadStreamRef *)this + 10)) == kCFStreamStatusError)
    {
      Error = CFReadStreamGetError((CFReadStreamRef)*((_QWORD *)this + 10));
      result = 0;
      *a2 = Error;
      return result;
    }
    return 0;
  }
  v6 = v5;
  v7 = *((_QWORD *)this + 3);
  v8 = *(const __CFString **)(v7 + 152);
  if (v8
    || os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
    && (*(_WORD *)buf = 0,
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u), (v8 = *(const __CFString **)(v7 + 152)) != 0))
  {
    if (CFStringCompare(v8, (CFStringRef)&gConstantCFStringValueTable[2597], 0) == kCFCompareEqualTo)
      goto LABEL_49;
  }
  ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v6);
  if (ResponseStatusCode == 304 || (unint64_t)(ResponseStatusCode - 400) <= 0xFFFFFFFFFFFFFF9BLL)
    goto LABEL_49;
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v12 = HTTPMessage::copyHeaderFieldValue((CFURLRef)((char *)v6 + 16), 0x12E1132Au);
  CFRelease(v6);
  if (!v12)
    return 1;
  v13 = CFGetAllocator(v6);
  v14 = (const __CFArray *)*((_QWORD *)this + 15);
  if (v14 && CFArrayGetCount(v14) >= 1)
  {
    v15 = (const __CFArray *)*((_QWORD *)this + 15);
    Count = CFArrayGetCount(v15);
    ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v15, Count - 1);
  }
  else
  {
    ValueAtIndex = 0;
  }
  location = CFStringFind(v12, CFSTR(", "), 0).location;
  if (location == -1)
  {
    v20 = 134217984;
    Length = CFStringGetLength(v12);
    v22 = (UInt8 *)malloc_type_malloc(Length + 1, 0xD80B8DDDuLL);
    if (CFStringGetCString(v12, (char *)v22, Length + 1, 0x8000100u)
      || (v20 = 513, CFStringGetCString(v12, (char *)v22, Length + 1, 0x201u)))
    {
      v6 = CFURLCreateAbsoluteURLWithBytes(v13, v22, Length, v20, ValueAtIndex, 1u);
    }
    else
    {
      v6 = 0;
    }
    free(v22);
  }
  else
  {
    v35.length = location;
    v35.location = 0;
    v19 = CFStringCreateWithSubstring(v13, v12, v35);
    v6 = CFURLCreateWithString(v13, v19, ValueAtIndex);
    if (v19)
      CFRelease(v19);
  }
  CFRelease(v12);
  if (!v6)
    return 1;
  v23 = (const __CFArray *)*((_QWORD *)this + 15);
  if (v23 && CFArrayGetCount(v23) >= *((_QWORD *)this + 16))
  {
    a2->domain = 4;
    a2->error = -2;
LABEL_49:
    CFRelease(v6);
    return 1;
  }
  CFGetAllocator((CFTypeRef)(*((_QWORD *)this + 4) - 16));
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  Instance = _CFRuntimeCreateInstance();
  v25 = (HTTPRequestMessage *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    v25 = (HTTPRequestMessage *)(Instance + 16);
    *(_QWORD *)(Instance + 192) = 0;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }
  HTTPRequestMessage::HTTPRequestMessage(v25, *((const HTTPRequestMessage **)this + 4), v6);
  HTTPMessage::removeHeaderFieldValue(v26, (const __CFString *)&unk_1EDCFD0B0);
  v27 = (__CFArray *)*((_QWORD *)this + 15);
  if (v27)
    CFArrayAppendValue(v27, v6);
  v28 = (const __CFDictionary *)*((_QWORD *)this + 6);
  if (v28)
  {
    if (CFDictionaryContainsKey(v28, CFSTR("kCFStreamPropertySSLSettings")))
    {
      v29 = CFURLCopyScheme(v6);
      if (v29)
      {
        v30 = v29;
        if (CFStringCompare(v29, (CFStringRef)&unk_1EDD00AE0, 1uLL))
          CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 6), CFSTR("kCFStreamPropertySSLSettings"));
        CFRelease(v30);
      }
    }
  }
  CFRelease(v6);
  HTTPReadStream::dequeueRequestFromConnection(this, 0);
  CFRelease((CFTypeRef)(*((_QWORD *)this + 4) - 16));
  *((_QWORD *)this + 4) = v25;
  v31 = (const void *)*((_QWORD *)this + 12);
  if (v31)
  {
    CFRelease(v31);
    *((_QWORD *)this + 12) = 0;
  }
  v32 = HTTPReadStream::constructProxyList(this, a2);
  if (!a2->error)
  {
    if (v32)
      return 0;
    HTTPReadStream::startRequest(this, a2);
    if (!a2->error)
      return 0;
  }
  return 1;
}

uint64_t HTTPReadStream::constructProxyList(HTTPReadStream *this, CFStreamError *a2)
{
  const void *v4;
  const __CFAllocator *v5;
  uint64_t v6;
  const void *v7;
  const __CFURL *v8;
  const __CFURL *v9;
  CFStringRef v10;
  __CFString *Value;
  const __CFArray *v12;
  CFIndex Count;
  CFMutableArrayRef MutableCopy;
  const __CFDictionary *ValueAtIndex;
  const void *v16;
  const void *v17;
  PAC *v18;
  PAC *v19;
  CFStreamClientContext *v20;
  __int16 v21;
  uint64_t v22;
  CFStringRef (__cdecl *v23)(const void *);
  uint64_t v24;
  CFAbsoluteTime Current;
  __CFRunLoopTimer *v26;
  __CFRunLoop *v27;
  __CFRunLoop *v28;
  __CFError *v29;
  uint64_t v30;
  _QWORD v32[5];
  CFRunLoopTimerContext context;

  v4 = (const void *)*((_QWORD *)this + 5);
  if (!v4)
    v4 = (const void *)*((_QWORD *)this + 1);
  v5 = CFGetAllocator(v4);
  if (*((_QWORD *)this + 12) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(context.version) = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "constructProxyList(): proxy list already constructed!", (uint8_t *)&context, 2u);
  }
  v6 = *((_QWORD *)this + 4);
  if (!v6)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      LOWORD(context.version) = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "constructproxyList(): no request!", (uint8_t *)&context, 2u);
      v6 = *((_QWORD *)this + 4);
    }
    else
    {
      v6 = 0;
    }
  }
  v7 = (const void *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(v6 + 128));
  if (v7 && (v8 = (const __CFURL *)CFRetain(v7)) != 0)
  {
    v9 = v8;
    v10 = CFURLCopyScheme(v8);
    if (v10)
    {
      CFRelease(v10);
      *((_WORD *)this + 8) &= ~4u;
      Value = (__CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 6), &unk_1EDCFB830);
      v12 = (const __CFArray *)__CFNetworkCopyProxiesForURLWithInterface(v9, *((__CFDictionary **)this + 11), Value);
      Count = CFArrayGetCount(v12);
      MutableCopy = CFArrayCreateMutableCopy(v5, Count, v12);
      if (v12)
        CFRelease(v12);
      if (MutableCopy)
      {
        if (!CFArrayGetCount(MutableCopy))
        {
          CFRelease(MutableCopy);
          v24 = 0;
          a2->domain = 4;
          a2->error = -1;
          goto LABEL_33;
        }
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(MutableCopy, 0);
        v16 = CFDictionaryGetValue(ValueAtIndex, CFSTR("kCFProxyTypeKey"));
        if (!CFEqual(CFSTR("kCFProxyTypeAutoConfigurationURL"), v16))
        {
          v17 = CFDictionaryGetValue(ValueAtIndex, CFSTR("kCFProxyTypeKey"));
          if (!CFEqual(CFSTR("kCFProxyTypeAutoConfigurationJavaScript"), v17))
          {
            v24 = 0;
            *((_QWORD *)this + 12) = MutableCopy;
            goto LABEL_33;
          }
        }
        v32[0] = 0;
        v32[1] = this;
        memset(&v32[2], 0, 24);
        v18 = (PAC *)CFDictionaryGetValue(ValueAtIndex, CFSTR("kCFProxyAutoConfigurationURLKey"));
        v19 = (PAC *)CFDictionaryGetValue(ValueAtIndex, CFSTR("kCFProxyAutoConfigurationJavaScriptKey"));
        if (!v19)
          v19 = v18;
        *((_QWORD *)this + 14) = PAC::CreatePACTicket(v19, v9, 0, 0, (std::__shared_weak_count_vtbl *)HTTPReadStream::_PACExecutionComplete, (void (*)(void *, const __CFArray *, __CFError *))v32, v20);
        CFArrayRemoveValueAtIndex(MutableCopy, 0);
        *((_QWORD *)this + 12) = MutableCopy;
        v21 = *((_WORD *)this + 8);
        *((_WORD *)this + 8) = v21 | 4;
        v22 = *((_QWORD *)this + 18);
        if (v22 && *(_DWORD *)(v22 + 40))
        {
          *((_WORD *)this + 8) = v21 | 0x84;
          v23 = (CFStringRef (__cdecl *)(const void *))*((_QWORD *)this + 14);
          context.version = MEMORY[0x1E0C809B0];
          context.info = (void *)3221225472;
          context.retain = (const void *(__cdecl *)(const void *))___ZNK17CoreSchedulingSet14scheduleSourceEP17__CFRunLoopSource_block_invoke;
          context.release = (void (__cdecl *)(const void *))&__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
          context.copyDescription = v23;
          CoreSchedulingSet::applyBlockWithPossibleEmulation(v22, &context);
          v24 = 1;
LABEL_33:
          CFRelease(v9);
          return v24;
        }
        context.version = 0;
        context.info = this;
        memset(&context.retain, 0, 24);
        Current = CFAbsoluteTimeGetCurrent();
        v26 = CFRunLoopTimerCreate(v5, Current + 60.0, -1.0, 0, 0, (CFRunLoopTimerCallBack)HTTPReadStream::_PACExecutionCompleteTimer, &context);
        v27 = CFRunLoopGetCurrent();
        CFRunLoopAddTimer(v27, v26, CFSTR("_kProxySupportSyncPACExecutionRunLoopMode"));
        v28 = CFRunLoopGetCurrent();
        CFRunLoopAddSource(v28, *((CFRunLoopSourceRef *)this + 14), CFSTR("_kProxySupportSyncPACExecutionRunLoopMode"));
        while ((*((_WORD *)this + 8) & 4) != 0)
          CFRunLoopRunInMode(CFSTR("_kProxySupportSyncPACExecutionRunLoopMode"), 1.0e10, 1u);
        CFRunLoopTimerInvalidate(v26);
        if (v26)
          CFRelease(v26);
        v29 = (__CFError *)*((_QWORD *)this + 13);
        if (v29)
        {
          a2->domain = _CFStreamErrorFromCFError(v29);
          *(_QWORD *)&a2->error = v30;
        }
      }
      v24 = 0;
      goto LABEL_33;
    }
    a2->domain = 4;
    a2->error = -3;
    CFRelease(v9);
    return 0;
  }
  else
  {
    v24 = 0;
    a2->domain = 4;
    a2->error = -3;
  }
  return v24;
}

void HTTPReadStream::startRequest(HTTPReadStream *this, CFStreamError *a2)
{
  __int16 v4;
  __int16 v5;
  uint64_t v6;
  _CFHTTPAuthentication *v7;
  _CFHTTPAuthentication *v8;
  const __CFArray *v9;
  const void *ValueAtIndex;
  uint64_t v11;
  const __CFDictionary *v12;
  __CFDictionary *MutableCopy;
  CFIndex Count;
  const __CFAllocator *v15;
  const void **v16;
  CFIndex v17;
  const void **v18;
  CFIndex v19;
  __CFDictionary *v20;
  NetConnectionCache *v21;
  const void *version;
  const __CFDictionary *v23;
  char *Key;
  const __CFAllocator *v25;
  uint64_t v26;
  __int16 v27;
  HTTPNetConnection_NoAuth *v28;
  NetConnection *Value;
  SInt32 v30;
  __CFReadStream *v31;
  CoreSchedulingSet *v32;
  __CFReadStream *v33;
  __CFReadStream *v34;
  __CFReadStream *v35;
  _QWORD v36[5];
  _QWORD v37[5];
  _QWORD propertyValue[5];
  CFStreamClientContext buf;
  uint64_t v40;
  uint64_t v41;
  _OWORD *(*v42)(uint64_t, __CFReadStream *);
  void *v43;
  HTTPReadStream *v44;
  HTTPNetConnection_NoAuth *v45;
  uint64_t v46;
  uint64_t v47;
  _OWORD *(*v48)(uint64_t, __CFReadStream *);
  void *v49;
  HTTPReadStream *v50;
  HTTPNetConnection_NoAuth *v51;
  CFDictionaryRef v52;
  uint64_t v53;

  if (!*((_QWORD *)this + 4) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(buf.version) = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "startRequest(): no current request!", (uint8_t *)&buf, 2u);
  }
  v4 = *((_WORD *)this + 8);
  if ((v4 & 4) != 0 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(buf.version) = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "startRequest(): called while waiting for proxy info!", (uint8_t *)&buf, 2u);
    v4 = *((_WORD *)this + 8);
  }
  LOBYTE(v5) = v4 & 0xF7;
  *((_WORD *)this + 8) = v4 & 0xFFF7;
  if (*((_QWORD *)this + 10))
  {
    HTTPReadStream::dequeueRequestFromConnection(this, 0);
    v5 = *((_WORD *)this + 8);
  }
  if ((v5 & 2) == 0)
  {
    v6 = *((_QWORD *)this + 4);
    v7 = *(_CFHTTPAuthentication **)(v6 + 72);
    if (v7)
    {
      if (_CFHTTPAuthenticationRequiresPersistentConnection(v7))
      {
LABEL_15:
        *((_WORD *)this + 8) |= 2u;
        goto LABEL_16;
      }
      v6 = *((_QWORD *)this + 4);
    }
    v8 = *(_CFHTTPAuthentication **)(v6 + 80);
    if (!v8 || !_CFHTTPAuthenticationRequiresPersistentConnection(v8))
      goto LABEL_16;
    goto LABEL_15;
  }
LABEL_16:
  v9 = (const __CFArray *)*((_QWORD *)this + 12);
  if (!v9)
    goto LABEL_53;
  if (!CFArrayGetCount(v9))
    goto LABEL_53;
  ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 12), 0);
  if (!ValueAtIndex)
    goto LABEL_53;
  v11 = *((_QWORD *)this + 4);
  if (!v11)
    v11 = *((_QWORD *)this + 3);
  buf.version = 0;
  v52 = 0;
  v53 = 0;
  _getConnectionInfoForProxy(ValueAtIndex, (__CFHTTPMessage *)(v11 - 16), &buf, (SInt32 *)&v53 + 1, (_BOOL4 *)&v53, &v52);
  v12 = v52;
  MutableCopy = (__CFDictionary *)*((_QWORD *)this + 6);
  if (v52)
  {
    if (MutableCopy)
    {
      Count = CFDictionaryGetCount(v52);
      v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v16 = (const void **)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 16 * Count, 0);
      CFDictionaryGetKeysAndValues(v12, v16, &v16[Count]);
      v17 = CFDictionaryGetCount(*((CFDictionaryRef *)this + 6));
      MutableCopy = CFDictionaryCreateMutableCopy(v15, v17 + Count, *((CFDictionaryRef *)this + 6));
      if (Count >= 1)
      {
        v18 = v16;
        v19 = Count;
        do
        {
          CFDictionarySetValue(MutableCopy, *v18, v18[Count]);
          ++v18;
          --v19;
        }
        while (v19);
      }
      CFAllocatorDeallocate(v15, v16);
      v20 = MutableCopy;
    }
    else
    {
      v20 = 0;
      MutableCopy = v52;
    }
  }
  else
  {
    v20 = 0;
  }
  v21 = CFGetAllocator(*((CFTypeRef *)this + 1));
  version = (const void *)buf.version;
  Key = NetConnectionCache::createKey(v21, (const __CFString *)buf.version, (const __CFString *)HIDWORD(v53), v53, MutableCopy, v23);
  if (version)
    CFRelease(version);
  if (v12)
    CFRelease(v12);
  if (v20)
    CFRelease(v20);
  if (!Key)
    goto LABEL_53;
  v25 = CFGetAllocator(*((CFTypeRef *)this + 1));
  if (getNetConnectionCache(void)::sOnce != -1)
    dispatch_once(&getNetConnectionCache(void)::sOnce, &__block_literal_global_37);
  v26 = getNetConnectionCache(void)::gHTTPConnectionCache;
  v27 = *((_WORD *)this + 8);
  buf.version = *((_QWORD *)Key + 3);
  buf.info = (void *)*((_QWORD *)Key + 4);
  buf.retain = (void *(__cdecl *)(void *))*((_QWORD *)Key + 5);
  if ((v27 & 2) == 0)
  {
    v28 = _constructNetConnection(v25, &buf, 0);
    goto LABEL_47;
  }
  os_unfair_lock_lock((os_unfair_lock_t)(getNetConnectionCache(void)::gHTTPConnectionCache + 8));
  Value = (NetConnection *)CFDictionaryGetValue(*(CFDictionaryRef *)(v26 + 16), Key);
  if (!Value)
    goto LABEL_44;
  v28 = Value;
  if (!NetConnection::willEnqueueRequests(Value))
  {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v26 + 16), Key);
LABEL_44:
    v28 = _constructNetConnection(v25, &buf, 1);
    if (v28)
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(v26 + 16), Key, v28);
    goto LABEL_46;
  }
  (*(void (**)(HTTPNetConnection_NoAuth *))(*(_QWORD *)v28 + 40))(v28);
LABEL_46:
  os_unfair_lock_unlock((os_unfair_lock_t)(v26 + 8));
LABEL_47:
  (*(void (**)(char *))(*(_QWORD *)Key + 48))(Key);
  if (!v28)
  {
LABEL_53:
    a2->domain = 4;
    v30 = -3;
LABEL_54:
    a2->error = v30;
    return;
  }
  if (a2->error)
    return;
  if ((*((_WORD *)this + 8) & 0x10) != 0)
  {
    v46 = MEMORY[0x1E0C809B0];
    v47 = 3221225472;
    v48 = ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke;
    v49 = &__block_descriptor_48_e26__v16__0____CFReadStream__8l;
    v50 = this;
    v51 = v28;
  }
  else
  {
    if (*((_QWORD *)this + 5))
      (*(void (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
    v40 = MEMORY[0x1E0C809B0];
    v41 = 3221225472;
    v42 = ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_2;
    v43 = &__block_descriptor_48_e26__v16__0____CFReadStream__8l;
    v44 = this;
    v45 = v28;
  }
  *((_QWORD *)this + 10) = CFReadStreamCreate();
  (*(void (**)(HTTPNetConnection_NoAuth *))(*(_QWORD *)v28 + 48))(v28);
  v31 = (__CFReadStream *)*((_QWORD *)this + 10);
  if (!v31)
  {
    a2->domain = 4;
    v30 = -1;
    goto LABEL_54;
  }
  buf.version = 0;
  buf.info = this;
  buf.retain = (void *(__cdecl *)(void *))_httpreadstream_retain;
  buf.release = (void (__cdecl *)(void *))_httpreadstream_release;
  buf.copyDescription = (CFStringRef (__cdecl *)(void *))_httpreadstream_copyDesc;
  CFReadStreamSetClient(v31, 0xFFFFFFFFFFFFFFFFLL, (CFReadStreamClientCallBack)HTTPReadStream::_streamCB, &buf);
  v32 = (CoreSchedulingSet *)*((_QWORD *)this + 18);
  if (v32)
    CoreSchedulingSet::scheduleStream(v32, *((__CFReadStream **)this + 10));
  if ((*((_WORD *)this + 8) & 0x20) != 0)
    CFReadStreamSetProperty(*((CFReadStreamRef *)this + 10), CFSTR("_kCFStreamPropertyLargeDownload"), (CFTypeRef)*MEMORY[0x1E0C9AE50]);
  if (*((_QWORD *)this + 7))
  {
    v33 = (__CFReadStream *)*((_QWORD *)this + 10);
    propertyValue[0] = MEMORY[0x1E0C809B0];
    propertyValue[1] = 3221225472;
    propertyValue[2] = ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_3;
    propertyValue[3] = &__block_descriptor_40_e25_v16__0____CFDictionary__8l;
    propertyValue[4] = this;
    CFReadStreamSetProperty(v33, (CFStreamPropertyKey)&unk_1EDCFE348, propertyValue);
  }
  if (*((_QWORD *)this + 8))
  {
    v34 = (__CFReadStream *)*((_QWORD *)this + 10);
    v37[0] = MEMORY[0x1E0C809B0];
    v37[1] = 3221225472;
    v37[2] = ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_4;
    v37[3] = &__block_descriptor_40_e28_v24__0____CFReadStream__8q16l;
    v37[4] = this;
    CFReadStreamSetProperty(v34, CFSTR("_kCFStreamPropertyConnectionWaitingBlock"), v37);
  }
  if (*((_QWORD *)this + 9))
  {
    v35 = (__CFReadStream *)*((_QWORD *)this + 10);
    v36[0] = MEMORY[0x1E0C809B0];
    v36[1] = 3221225472;
    v36[2] = ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_5;
    v36[3] = &__block_descriptor_40_e28_v20__0____CFReadStream__8C16l;
    v36[4] = this;
    CFReadStreamSetProperty(v35, (CFStreamPropertyKey)&unk_1EDCFA170, v36);
  }
  CFReadStreamOpen(*((CFReadStreamRef *)this + 10));
}

HTTPNetConnection_NoAuth *_constructNetConnection(const __CFAllocator *a1, const void *a2, int a3)
{
  _OWORD *v6;
  HTTPNetConnection_NoAuth *v7;

  v6 = CFAllocatorAllocate(a1, 152, 0);
  *v6 = 0u;
  v6[1] = 0u;
  v6[2] = 0u;
  v6[3] = 0u;
  v6[4] = 0u;
  v6[5] = 0u;
  v6[6] = 0u;
  v6[7] = 0u;
  v6[8] = 0u;
  *((_QWORD *)v6 + 18) = 0;
  HTTPConnectionCacheKey::HTTPConnectionCacheKey((uint64_t)v6, (uint64_t)a1, *(const __CFString **)a2, *((_DWORD *)a2 + 2), *((_DWORD *)a2 + 3), *((const void **)a2 + 2), 0);
  v7 = (HTTPNetConnection_NoAuth *)CFAllocatorAllocate(a1, 320, 0);
  *(_OWORD *)v7 = 0u;
  *((_OWORD *)v7 + 1) = 0u;
  *((_OWORD *)v7 + 2) = 0u;
  *((_OWORD *)v7 + 3) = 0u;
  *((_OWORD *)v7 + 4) = 0u;
  *((_OWORD *)v7 + 5) = 0u;
  *((_OWORD *)v7 + 6) = 0u;
  *((_OWORD *)v7 + 7) = 0u;
  *((_OWORD *)v7 + 8) = 0u;
  *((_OWORD *)v7 + 9) = 0u;
  *((_OWORD *)v7 + 10) = 0u;
  *((_OWORD *)v7 + 11) = 0u;
  *((_OWORD *)v7 + 12) = 0u;
  *((_OWORD *)v7 + 13) = 0u;
  *((_OWORD *)v7 + 14) = 0u;
  *((_OWORD *)v7 + 15) = 0u;
  *((_OWORD *)v7 + 16) = 0u;
  *((_OWORD *)v7 + 17) = 0u;
  *((_OWORD *)v7 + 18) = 0u;
  *((_OWORD *)v7 + 19) = 0u;
  HTTPNetConnection_NoAuth::HTTPNetConnection_NoAuth(v7, a1, (HTTPConnectionCacheKey *)v6);
  (*(void (**)(_OWORD *))(*(_QWORD *)v6 + 48))(v6);
  if (NetConnection::initialize(v7, a3))
  {
    *((_BYTE *)v7 + 268) = 0;
  }
  else
  {
    (*(void (**)(HTTPNetConnection_NoAuth *))(*(_QWORD *)v7 + 48))(v7);
    return 0;
  }
  return v7;
}

CFTypeRef *_httpreadstream_retain(CFTypeRef *a1)
{
  CFRetain(a1[1]);
  return a1;
}

void _httpreadstream_release(CFTypeRef *a1)
{
  CFRelease(a1[1]);
}

uint64_t _httpreadstream_copyDesc(void *a1)
{
  return (*(uint64_t (**)(void *))(*(_QWORD *)a1 + 104))(a1);
}

void HTTPReadStream::_streamCB(HTTPReadStream *this, __CFReadStream *a2, HTTPReadStream *a3, void *a4)
{
  __int16 v4;
  int v6;
  int v7;
  CFStreamError Error;

  v4 = *((_WORD *)a3 + 8);
  if ((v4 & 0x40) != 0)
    return;
  if ((uint64_t)a2 > 7)
  {
    if (a2 == (__CFReadStream *)8)
    {
      Error = CFReadStreamGetError((CFReadStreamRef)*((_QWORD *)a3 + 10));
      if (HTTPReadStream::reattemptAfterError((CFReadStreamRef *)a3, &Error))
        return;
      goto LABEL_18;
    }
    if (a2 != (__CFReadStream *)16)
      return;
    if ((v4 & 8) == 0)
    {
      Error.domain = 0;
      *(_QWORD *)&Error.error = 0;
      v7 = HTTPReadStream::readHeader(a3, &Error);
      if (Error.error || v7)
        goto LABEL_18;
      return;
    }
LABEL_22:
    CFReadStreamSignalEvent();
    return;
  }
  if (a2 == (__CFReadStream *)1)
    goto LABEL_22;
  if (a2 != (__CFReadStream *)2)
    return;
  if ((v4 & 8) != 0)
  {
    if ((*((_WORD *)a3 + 8) & 0x200) != 0)
      return;
    *((_WORD *)a3 + 8) = v4 | 0x200;
    goto LABEL_22;
  }
  Error.domain = 0;
  *(_QWORD *)&Error.error = 0;
  v6 = HTTPReadStream::readHeader(a3, &Error);
  if (Error.error)
  {
LABEL_18:
    CFReadStreamSignalEvent();
    return;
  }
  if (v6 && (*((_WORD *)a3 + 8) & 0x200) == 0)
  {
    *((_WORD *)a3 + 8) |= 0x200u;
    goto LABEL_18;
  }
}

void ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_3(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  (*(void (**)(void))(*(_QWORD *)(v1 + 56) + 16))();
  _Block_release(*(const void **)(v1 + 56));
  *(_QWORD *)(v1 + 56) = 0;
}

uint64_t ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 64) + 16))();
}

uint64_t ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_5(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 72) + 16))();
}

const __CFArray *HTTPReadStream::reattemptAfterError(CFReadStreamRef *this, CFStreamError *a2)
{
  const __CFArray *result;
  CFStreamError v4;

  v4.domain = 0;
  *(_QWORD *)&v4.error = 0;
  if (((_BYTE)this[2] & 2) != 0
    && a2->domain == 4
    && a2->error == -4
    && (((_BYTE)this[2] & 0x10) == 0 || CFReadStreamGetStatus(this[5]) == kCFStreamStatusNotOpen))
  {
    HTTPReadStream::dequeueRequestFromConnection((HTTPReadStream *)this, 0);
  }
  else
  {
    result = this[12];
    if (!result)
      return result;
    if (CFArrayGetCount(result) < 2 || ((_WORD)this[2] & 0x10) != 0 && CFReadStreamGetStatus(this[5]))
      return 0;
    HTTPReadStream::dequeueRequestFromConnection((HTTPReadStream *)this, 0);
    if (CFArrayGetCount(this[12]) >= 1)
      CFArrayRemoveValueAtIndex(this[12], 0);
  }
  HTTPReadStream::startRequest((HTTPReadStream *)this, &v4);
  return (const __CFArray *)(v4.error == 0);
}

void HTTPReadStream::_PACExecutionCompleteTimer(HTTPReadStream *this, __CFRunLoopTimer *a2, void *a3)
{
  const void *v4;
  const __CFAllocator *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFErrorRef CFError;
  uint64_t v12;
  uint64_t v13;
  const __CFAllocator *v14;
  uint64_t v15;
  CFStringRef v16;
  const __CFString *v17;
  CFStringRef v18;
  uint64_t v19;
  CFStringRef v20;
  const __CFString *v21;
  const void *v22;
  CFStringRef v23;
  CFStringRef v24;
  const void *v25;
  CFStringRef v26;
  CFStringRef v27;
  __CFRunLoop *Current;
  void (**v29)(AutoString *__hidden);
  const __CFString *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v4 = (const void *)*((_QWORD *)a2 + 5);
  if (!v4)
    v4 = (const void *)*((_QWORD *)a2 + 1);
  v5 = CFGetAllocator(v4);
  CFError = __cfnCreateCFError(v5, CFSTR("kCFErrorDomainCFNetwork"), 308, v6, v7, v8, v9, v10, 0);
  v12 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_5595, 2);
  if (v12)
  {
    v13 = v12;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v12 + 16))(v12, "Read Stream PAC Timeout", 0))
    {
      v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v15 = *((_QWORD *)a2 + 3);
      v29 = &off_1E14E4818;
      v16 = CFStringCreateWithCString(v14, "Original Request", 0x8000100u);
      v31 = 0;
      v32 = 0;
      v30 = v16;
      if (v15)
      {
        v17 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 32))(v15);
        v18 = v30;
      }
      else
      {
        v18 = v16;
        v17 = CFSTR("null");
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v13 + 64))(v13, v18, v17);
      if (v15 && v17)
        CFRelease(v17);
      AutoString::~AutoString((AutoString *)&v29);
      v19 = *((_QWORD *)a2 + 4);
      v29 = &off_1E14E4818;
      v20 = CFStringCreateWithCString(v14, "Current Request", 0x8000100u);
      v31 = 0;
      v32 = 0;
      v30 = v20;
      if (v19)
      {
        v21 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v19 + 32))(v19);
        v20 = v30;
      }
      else
      {
        v21 = CFSTR("null");
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v13 + 64))(v13, v20, v21);
      if (v19 && v21)
        CFRelease(v21);
      AutoString::~AutoString((AutoString *)&v29);
      v22 = (const void *)*((_QWORD *)a2 + 11);
      v29 = &off_1E14E4818;
      v23 = CFStringCreateWithCString(v14, "Proxy Configuration", 0x8000100u);
      v31 = 0;
      v32 = 0;
      v30 = v23;
      if (v22)
      {
        v24 = CFCopyDescription(v22);
        v23 = v30;
      }
      else
      {
        v24 = CFSTR("null");
      }
      (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(_QWORD *)v13 + 64))(v13, v23, v24);
      if (v22 && v24)
        CFRelease(v24);
      AutoString::~AutoString((AutoString *)&v29);
      v25 = (const void *)*((_QWORD *)a2 + 12);
      v29 = &off_1E14E4818;
      v26 = CFStringCreateWithCString(v14, "Proxy List", 0x8000100u);
      v31 = 0;
      v32 = 0;
      v30 = v26;
      if (v25)
      {
        v27 = CFCopyDescription(v25);
        v26 = v30;
      }
      else
      {
        v27 = CFSTR("null");
      }
      (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(_QWORD *)v13 + 64))(v13, v26, v27);
      if (v25 && v27)
        CFRelease(v27);
      AutoString::~AutoString((AutoString *)&v29);
      (*(void (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v13 + 56))(v13, "Proxy Error", *((_QWORD *)a2 + 13));
      (*(void (**)(uint64_t, const char *, CFErrorRef))(*(_QWORD *)v13 + 56))(v13, "Error", CFError);
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
    }
  }
  HTTPReadStream::pacExecutionComplete((uint64_t)a2, 0, CFError);
  Current = CFRunLoopGetCurrent();
  CFRunLoopStop(Current);
  if (CFError)
    CFRelease(CFError);
}

void sub_1840503F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

uint64_t HTTPReadStream::pacExecutionComplete(uint64_t this, CFTypeRef cf, void *a3)
{
  __int16 v3;
  uint64_t v6;
  __CFRunLoopSource *v7;
  const void *v8;
  const __CFArray *v9;
  uint64_t v10;
  const __CFAllocator *v11;
  CFStreamError v12;

  v12.domain = 0;
  *(_QWORD *)&v12.error = 0;
  v3 = *(_WORD *)(this + 16);
  if ((v3 & 4) != 0)
  {
    v6 = this;
    *(_WORD *)(this + 16) = v3 & 0xFFFB;
    v7 = *(__CFRunLoopSource **)(this + 112);
    if (v7)
    {
      CFRunLoopSourceInvalidate(v7);
      v8 = *(const void **)(v6 + 112);
      if (v8)
        CFRelease(v8);
      *(_QWORD *)(v6 + 112) = 0;
    }
    v9 = *(const __CFArray **)(v6 + 96);
    if (a3)
    {
      if (!v9 || (this = CFArrayGetCount(v9), this <= 0))
      {
        CFRetain(a3);
        *(_QWORD *)(v6 + 104) = a3;
        v12.domain = _CFStreamErrorFromCFError((__CFError *)a3);
        *(_QWORD *)&v12.error = v10;
        return CFReadStreamSignalEvent();
      }
    }
    else
    {
      if (v9)
        CFRelease(v9);
      v11 = CFGetAllocator(cf);
      this = (uint64_t)CFArrayCreateMutableCopy(v11, 0, (CFArrayRef)cf);
      *(_QWORD *)(v6 + 96) = this;
    }
    if ((*(_WORD *)(v6 + 16) & 0x80) == 0)
      return this;
    HTTPReadStream::startRequest((HTTPReadStream *)v6, &v12);
    if (!v12.error)
      return CFReadStreamSignalEvent();
    return CFReadStreamSignalEvent();
  }
  return this;
}

uint64_t ___ZN14HTTPReadStream15pacTimerTimeoutEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 834;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void sub_18405069C(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

void HTTPReadStream::HTTPReadStream(HTTPReadStream *this, CFTypeRef cf, HTTPRequestMessage *a3, __CFReadStream *a4)
{
  uint64_t Instance;
  HTTPRequestMessage *v8;
  const char *v9;
  HTTPBodyData *v10;
  uint64_t v11;
  uint64_t v12;
  const __CFAllocator *v13;
  CoreSchedulingSet *Mutable;

  *(_QWORD *)this = &off_1E14E6F58;
  *((_QWORD *)this + 1) = cf;
  *((_WORD *)this + 8) = 0;
  CFGetAllocator(cf);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  Instance = _CFRuntimeCreateInstance();
  v8 = (HTTPRequestMessage *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    v8 = (HTTPRequestMessage *)(Instance + 16);
    *(_QWORD *)(Instance + 192) = 0;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }
  HTTPRequestMessage::HTTPRequestMessage(v8, a3);
  *((_QWORD *)this + 3) = v8;
  *((_QWORD *)this + 4) = 0;
  if (a4)
  {
    *((_QWORD *)this + 5) = CFRetain(a4);
    *((_WORD *)this + 8) |= 0x10u;
  }
  else
  {
    HTTPMessage::ensureParserFinished(v8);
    v10 = (HTTPBodyData *)*((_QWORD *)v8 + 6);
    *((_QWORD *)v8 + 6) = 0;
    if (v10)
    {
      HTTPBodyData::captureData(v10, v9);
      v12 = v11;
      (*(void (**)(HTTPBodyData *))(*(_QWORD *)v10 + 8))(v10);
      *((_QWORD *)this + 5) = v12;
    }
  }
  v13 = CFGetAllocator(*((CFTypeRef *)this + 1));
  Mutable = (CoreSchedulingSet *)CFDictionaryCreateMutable(v13, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 20;
  *((_QWORD *)this + 6) = Mutable;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 18) = CoreSchedulingSet::createEmpty(Mutable);
}

void sub_184050804(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

CFStringRef SocketStream::copyDebugDesc(SocketStream *this)
{
  __CFSocket *v2;
  CFSocketNativeHandle Native;
  const __CFAllocator *v4;
  char __str[256];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v2 = (__CFSocket *)*((_QWORD *)this + 36);
  if (v2)
    Native = CFSocketGetNative(v2);
  else
    Native = -1;
  snprintf(__str, 0x100uLL, "{ fd %d }", Native);
  v4 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v4, 0, CFSTR("<SocketStream@%p> %s"), this, __str);
}

__CFHost *SocketStream::initialize(CFMutableDictionaryRef *this, const __CFString *a2, const __CFAllocator *a3)
{
  CFMutableDictionaryRef *v6;
  const __CFAllocator *v7;
  __CFHost *v8;
  const __CFAllocator *v9;
  __CFHost *result;

  v6 = this - 2;
  v7 = CFGetAllocator(this - 2);
  v8 = (__CFHost *)_CFHostCreateWithNameAndPortForConnect(v7, a2, (const __CFAllocator *)(unsigned __int16)a3);
  if (v8 || (v9 = CFGetAllocator(v6), result = CFHostCreateWithName(v9, a2), (v8 = result) != 0))
  {
    SocketStream::initialize(this, v8, a3);
    CFRelease(v8);
    return (__CFHost *)1;
  }
  return result;
}

void SocketStream::finalize(SocketStream *this, const void *a2)
{
  char *v4;
  id *v5;
  uint64_t v6;
  const void *v7;
  unint64_t v8;
  const __CFArray *v9;
  CFRunLoopRef Current;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  NSObject *v16;
  NSObject *v17;
  const void *v18;
  CFRunLoopRef context;
  uint64_t v20;
  void (*v21)(uint64_t);
  void *v22;
  SocketStream *v23;
  CFRange v24;
  CFRange v25;
  CFRange v26;

  v4 = (char *)this - 16;
  CFRetain((char *)this - 16);
  (*(void (**)(SocketStream *, const void *))(*(_QWORD *)this + 104))(this, a2);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  v5 = (id *)((char *)this + 272);
  if (*((const void **)this + 34) != a2)
  {
    if (*((const void **)this + 35) != a2)
      goto LABEL_5;
    v5 = (id *)((char *)this + 280);
  }
  objc_storeWeak(v5, 0);
  CFRelease(v4);
LABEL_5:
  v6 = *((unsigned int *)this + 62);
  if ((v6 & 0x80) != 0)
  {
    v8 = v6 & 0xFFFFFFFFFFFFFF7FLL | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) = v6 & 0xFFFFFF7F;
    *((_WORD *)this + 126) = WORD2(v8);
    CFRelease(v4);
    goto LABEL_12;
  }
  if (!*((_QWORD *)this + 34) && !*((_QWORD *)this + 35))
  {
    v7 = (const void *)*((_QWORD *)this + 37);
    if (v7)
    {
      if (*((_DWORD *)this + 66))
      {
        *((_QWORD *)this + 37) = 0;
      }
      else
      {
        do
        {
          if (SSLClose(*((SSLContextRef *)this + 37)) != -9803)
            break;
          v9 = (const __CFArray *)*((_QWORD *)this + 40);
          if (!v9)
            break;
          if (!CFArrayGetCount(v9))
            break;
          Current = CFRunLoopGetCurrent();
          _SchedulesAddRunLoopAndMode(*((const __CFArray **)this + 40), Current, CFSTR("_kCFStreamSocketSecurityClosePrivateMode"));
          v11 = *((_QWORD *)this + 41);
          context = Current;
          v20 = (uint64_t)CFSTR("_kCFStreamSocketSecurityClosePrivateMode");
          v24.length = *(_QWORD *)(v11 + 24);
          v24.location = 0;
          CFArrayApplyFunction(*(CFArrayRef *)(v11 + 16), v24, (CFArrayApplierFunction)Schedulables::_SchedulablesScheduleApplierFunction, &context);
          pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
          CFRunLoopRunInMode(CFSTR("_kCFStreamSocketSecurityClosePrivateMode"), 1.0e20, 1u);
          pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
          v12 = *((_QWORD *)this + 41);
          context = Current;
          v20 = (uint64_t)CFSTR("_kCFStreamSocketSecurityClosePrivateMode");
          v25.length = *(_QWORD *)(v12 + 24);
          v25.location = 0;
          CFArrayApplyFunction(*(CFArrayRef *)(v12 + 16), v25, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleApplierFunction, &context);
          _SchedulesRemoveRunLoopAndMode(*((const __CFArray **)this + 40), Current, CFSTR("_kCFStreamSocketSecurityClosePrivateMode"));
        }
        while (!*((_DWORD *)this + 66));
        v7 = (const void *)*((_QWORD *)this + 37);
        *((_QWORD *)this + 37) = 0;
        if (!v7)
          goto LABEL_19;
      }
      CFRelease(v7);
    }
LABEL_19:
    v13 = *((_QWORD *)this + 41);
    v26.length = *(_QWORD *)(v13 + 24);
    v26.location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v13 + 16), v26, (CFArrayApplierFunction)Schedulables::_SchedulablesInvalidateApplierFunction, 0);
    v14 = *((_QWORD *)this + 41);
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(v14 + 16));
    *(_QWORD *)(v14 + 24) = 0;
    if (*((_QWORD *)this + 70) && *((_QWORD *)this + 71))
    {
      SocketStream::cleanupConnection_NoLock(this);
      CFRetain(v4);
      v16 = *((_QWORD *)this + 71);
      context = (CFRunLoopRef)MEMORY[0x1E0C809B0];
      v20 = 3221225472;
      v21 = ___ZN12SocketStream31finalizeCancelConnection_LockedEv_block_invoke;
      v22 = &__block_descriptor_40_e5_v8__0l;
      v23 = this;
      dispatch_async(v16, &context);
    }
    v17 = *((_QWORD *)this + 71);
    if (v17)
    {
      dispatch_release(v17);
      *((_QWORD *)this + 71) = 0;
    }
    if (*((_QWORD *)this + 36))
    {
      SocketStream::checkOutVoIPSocket(this, v15);
      *((_DWORD *)this + 62) |= 0x800u;
      CFSocketInvalidate(*((CFSocketRef *)this + 36));
    }
    v18 = (const void *)*((_QWORD *)this + 30);
    if (v18)
      CFRelease(v18);
    *((_QWORD *)this + 30) = 0;
  }
LABEL_12:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
  CFRelease(v4);
}

CFStringRef SocketStream::copyDescription(SocketStream *this, const void *a2)
{
  const __CFAllocator *v4;

  v4 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v4, 0, CFSTR("<SocketStream %p>{flags = %p, read = %p, write = %p, socket = %@, properties = %p }"), a2, (char *)this + 248, *((_QWORD *)this + 34), *((_QWORD *)this + 35), *((_QWORD *)this + 36), *((_QWORD *)this + 42));
}

uint64_t SocketStream::openCompleted(SocketStream *this, const void *a2, CFStreamError *a3)
{
  return SocketStream::streamCan((uint64_t)this, a2, 0, CFSTR("_kCFStreamSocketOpenCompletedPrivateMode"), a3);
}

void SocketStream::close(SocketStream *this, const void *a2)
{
  char *v4;
  pthread_mutex_t *v5;
  double v6;
  __CFRunLoop *v7;
  void **v8;
  __CFArray **v9;
  uint64_t v10;
  void *v11;
  __CFArray *v12;
  unint64_t v13;
  uint64_t v14;
  CFIndex Count;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  CFSocketRef *v19;
  int v20;
  _QWORD block[5];
  CFRange v22;
  CFRange v23;

  v4 = (char *)this - 16;
  CFRetain((char *)this - 16);
  v5 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  v7 = (__CFRunLoop *)*((_QWORD *)this + 30);
  if (v7)
    SocketStream::unschedule_NoLock(this, a2, v7, CFSTR("_kCFStreamSocketBogusPrivateMode"));
  if (*((const void **)this + 34) == a2)
  {
    v8 = (void **)((char *)this + 304);
    v9 = (__CFArray **)((char *)this + 312);
    v10 = 0x1000000000;
  }
  else
  {
    if (*((const void **)this + 35) != a2)
      goto LABEL_12;
    v8 = (void **)((char *)this + 312);
    v9 = (__CFArray **)((char *)this + 304);
    v10 = 0x2000000000;
  }
  v11 = *v8;
  v12 = *v9;
  v13 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | v10;
  *((_DWORD *)this + 62) = v13;
  *((_WORD *)this + 126) = WORD2(v13);
  if (v11 && v12)
  {
    v14 = *((_QWORD *)this + 41);
    v22.length = *(_QWORD *)(v14 + 24);
    v22.location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v14 + 16), v22, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleFromAllApplierFunction, v11);
    CFArrayRemoveAllValues((CFMutableArrayRef)v11);
    Count = CFArrayGetCount(*((CFArrayRef *)this + 40));
    if (Count)
    {
      v23.length = Count;
      v23.location = 0;
      CFArrayAppendArray(v12, *((CFArrayRef *)this + 40), v23);
      CFArrayRemoveAllValues(*((CFMutableArrayRef *)this + 40));
    }
    *((_DWORD *)this + 103) = 0;
  }
LABEL_12:
  v16 = *((unsigned int *)this + 62);
  if ((v16 & 0x80) == 0
    || ((v16 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) & 0x3000000000) == 0x3000000000)
  {
    if (*((_QWORD *)this + 70) && *((_QWORD *)this + 71))
    {
      SocketStream::cleanupConnection_NoLock(this);
      CFRetain(v4);
      v17 = *((_QWORD *)this + 71);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ___ZN12SocketStream5closeEPKv_block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      block[4] = this;
      dispatch_async(v17, block);
    }
    v18 = *((_QWORD *)this + 71);
    if (v18)
    {
      dispatch_release(v18);
      *((_QWORD *)this + 71) = 0;
    }
    if (*((_QWORD *)this + 36))
    {
      SocketStream::checkOutVoIPSocket(this, v6);
      v20 = *((_DWORD *)this + 62);
      v19 = (CFSocketRef *)((char *)this + 248);
      *(_DWORD *)v19 = v20 | 0x800;
      CFSocketInvalidate(v19[5]);
    }
  }
  pthread_mutex_unlock(v5);
  CFRelease(v4);
}

CFDictionaryRef SocketStream::copyProperty(SocketStream *this, const void *a2, const __CFString *a3)
{
  pthread_mutex_t *v5;
  const __CFString *v6;
  CFDictionaryRef v7;

  v5 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  v7 = SocketStream::copyProperty_NoLock(this, a3, v6);
  pthread_mutex_unlock(v5);
  return v7;
}

void sub_184050EA8(_Unwind_Exception *a1)
{
  pthread_mutex_t *v1;

  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t SocketStream::schedule(SocketStream *this, const void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  pthread_mutex_t *v8;

  v8 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  SocketStream::schedule_NoLock(this, a2, a3, a4);
  return pthread_mutex_unlock(v8);
}

uint64_t SocketStream::unschedule(SocketStream *this, const void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  pthread_mutex_t *v8;

  v8 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  SocketStream::unschedule_NoLock(this, a2, a3, a4);
  return pthread_mutex_unlock(v8);
}

void SocketStream::setConnectionEstablishment(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = (os_unfair_lock_s *)(a1 + 424);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 424));
  v5 = *(_QWORD *)(a1 + 416);
  if (v5 != a2)
  {
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
    *(_QWORD *)(a1 + 416) = a2;
    if (a2)
      (*(void (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  }
  os_unfair_lock_unlock(v4);
  if (*(_QWORD *)(a1 + 296))
  {
    v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 184))(a1);
    SSLSetSessionOption(*(SSLContextRef *)(a1 + 296), kSSLSessionOptionBreakOnCertRequested, v6 != 0);
    SSLSetSessionOption(*(SSLContextRef *)(a1 + 296), kSSLSessionOptionBreakOnServerAuth, v6 != 0);
    if (v6)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  }
}

uint64_t SocketStream::beginConnection(SocketStream *this)
{
  NSObject *v2;
  _QWORD block[5];

  CFRetain((char *)this - 16);
  v2 = *((_QWORD *)this + 71);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN12SocketStream15beginConnectionEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = this;
  dispatch_async(v2, block);
  return 1;
}

uint64_t SocketStream::setProperty(id *this, const __CFString *a2, const void *a3)
{
  id WeakRetained;
  uint64_t v7;

  WeakRetained = objc_loadWeakRetained(this + 34);
  if (!WeakRetained)
    WeakRetained = objc_loadWeakRetained(this + 35);
  v7 = (*((uint64_t (**)(id *, id, const __CFString *, const void *))*this + 15))(this, WeakRetained, a2, a3);
  if (WeakRetained)
    CFRelease(WeakRetained);
  return v7;
}

void SocketStream::setProperties(SocketStream *this, CFDictionaryRef theDict)
{
  _QWORD context[5];

  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 3221225472;
  context[2] = ___ZN12SocketStream13setPropertiesEPK14__CFDictionary_block_invoke;
  context[3] = &__block_descriptor_40_e25_v24__0____CFString__8_v16l;
  context[4] = this;
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)_apply_block, context);
}

void SocketStream::setNotificationProperty(SocketStream *this, int a2, CFStringRef theString, const void *a4)
{
  int ExactString;
  const void **v8;
  const void **v9;
  const void **v10;

  ExactString = _findExactString(theString, 2u);
  if (ExactString > 90506881)
  {
    switch(ExactString)
    {
      case 106203045:
        v8 = (const void **)((char *)this + 488);
        v9 = (const void **)((char *)this + 480);
        break;
      case 96814834:
        v8 = (const void **)((char *)this + 472);
        v9 = (const void **)((char *)this + 464);
        break;
      case 90506882:
        v8 = (const void **)((char *)this + 440);
        v9 = (const void **)((char *)this + 432);
        break;
      default:
        return;
    }
    goto LABEL_14;
  }
  if (ExactString == 83273191)
  {
    v8 = (const void **)((char *)this + 456);
    v9 = (const void **)((char *)this + 448);
LABEL_14:
    if (a2)
      v10 = v9;
    else
      v10 = v8;
    goto LABEL_17;
  }
  if (ExactString != 84248066)
  {
    if (ExactString != 89532009)
      return;
    v8 = (const void **)((char *)this + 504);
    v9 = (const void **)((char *)this + 496);
    goto LABEL_14;
  }
  v10 = (const void **)((char *)this + 512);
LABEL_17:
  if (*v10)
  {
    _Block_release(*v10);
    *v10 = 0;
  }
  if (a4)
    *v10 = _Block_copy(a4);
}

uint64_t SocketStream::copyProperty(id *this, const __CFString *a2)
{
  id WeakRetained;
  uint64_t v5;

  WeakRetained = objc_loadWeakRetained(this + 34);
  if (!WeakRetained)
    WeakRetained = objc_loadWeakRetained(this + 35);
  v5 = (*((uint64_t (**)(id *, id, const __CFString *))*this + 14))(this, WeakRetained, a2);
  if (WeakRetained)
    CFRelease(WeakRetained);
  return v5;
}

void SocketStream::closeStreams(SocketStream *this)
{
  NSObject *v2;
  _QWORD block[5];

  CFRetain((char *)this - 16);
  v2 = *((_QWORD *)this + 71);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN12SocketStream12closeStreamsEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = this;
  dispatch_async(v2, block);
}

void `non-virtual thunk to'SocketStream::~SocketStream(SocketStream *this)
{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 8));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 8));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 16));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 16));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 24));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 24));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 32));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 32));
}

void `virtual thunk to'SocketStream::finalize(SocketStream *this, const void *a2)
{
  SocketStream::finalize((SocketStream *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 32)), a2);
}

CFStringRef `virtual thunk to'SocketStream::copyDescription(SocketStream *this, const void *a2)
{
  return SocketStream::copyDescription((SocketStream *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 40)), a2);
}

uint64_t `virtual thunk to'SocketStream::openCompleted(SocketStream *this, const void *a2, CFStreamError *a3)
{
  return SocketStream::streamCan((uint64_t)this + *(_QWORD *)(*(_QWORD *)this - 56), a2, 0, CFSTR("_kCFStreamSocketOpenCompletedPrivateMode"), a3);
}

void `virtual thunk to'SocketStream::close(SocketStream *this, const void *a2)
{
  SocketStream::close((SocketStream *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 64)), a2);
}

CFDictionaryRef `virtual thunk to'SocketStream::copyProperty(SocketStream *this, const void *a2, const __CFString *a3)
{
  return SocketStream::copyProperty((SocketStream *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 72)), a2, a3);
}

uint64_t `virtual thunk to'SocketStream::unschedule(SocketStream *this, const void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  char *v7;

  v7 = (char *)this + *(_QWORD *)(*(_QWORD *)this - 96);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 40));
  SocketStream::unschedule_NoLock((SocketStream *)v7, a2, a3, a4);
  return pthread_mutex_unlock((pthread_mutex_t *)(v7 + 40));
}

void SocketStream::~SocketStream(SocketStream *this)
{
  double v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  uint64_t v19;
  const void *v20;
  const void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  const void *v37;
  uint64_t v38;
  CFRange v39;
  CFRange v40;
  CFRange v41;
  CFRange v42;

  *(_QWORD *)this = &off_1E14E6258;
  *((_QWORD *)this + 1) = &unk_1E14E6358;
  *((_QWORD *)this + 2) = &unk_1E14E63F0;
  *((_QWORD *)this + 3) = &unk_1E14E64F0;
  *((_QWORD *)this + 4) = &unk_1E14E6578;
  if (*((_QWORD *)this + 74))
  {
    tcp_connection_cancel();
    tcp_connection_release();
    *((_QWORD *)this + 74) = 0;
  }
  SocketStream::cleanupConnection_NoLock(this);
  if (*((_BYTE *)this + 644))
  {
    *((_BYTE *)this + 644) = 0;
    entr_act_end_delayInitStub(v2);
  }
  v3 = *((_QWORD *)this + 71);
  if (v3)
  {
    dispatch_release(v3);
    *((_QWORD *)this + 71) = 0;
  }
  v4 = *((_QWORD *)this + 48);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*((dispatch_object_t *)this + 48));
    *((_QWORD *)this + 48) = 0;
  }
  v5 = *((_QWORD *)this + 49);
  if (v5)
  {
    dispatch_source_cancel(v5);
    dispatch_release(*((dispatch_object_t *)this + 49));
    *((_QWORD *)this + 49) = 0;
  }
  v6 = *((_QWORD *)this + 41);
  if (v6)
  {
    v39.length = *(_QWORD *)(v6 + 24);
    v39.location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v6 + 16), v39, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleFromAllApplierFunction, *((void **)this + 38));
    v7 = *((_QWORD *)this + 41);
    v40.length = *(_QWORD *)(v7 + 24);
    v40.location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v7 + 16), v40, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleFromAllApplierFunction, *((void **)this + 39));
    v8 = *((_QWORD *)this + 41);
    v41.length = *(_QWORD *)(v8 + 24);
    v41.location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v8 + 16), v41, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleFromAllApplierFunction, *((void **)this + 40));
    v9 = *((_QWORD *)this + 41);
    v42.length = *(_QWORD *)(v9 + 24);
    v42.location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v9 + 16), v42, (CFArrayApplierFunction)Schedulables::_SchedulablesInvalidateApplierFunction, 0);
    v10 = *((_QWORD *)this + 41);
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  }
  if (*((_QWORD *)this + 36))
  {
    SocketStream::checkOutVoIPSocket(this, v2);
    *((_DWORD *)this + 62) |= 0x800u;
    CFSocketInvalidate(*((CFSocketRef *)this + 36));
    CFRelease(*((CFTypeRef *)this + 36));
    *((_QWORD *)this + 36) = 0;
  }
  v11 = (const void *)*((_QWORD *)this + 67);
  if (v11)
    CFRelease(v11);
  v12 = (const void *)*((_QWORD *)this + 38);
  *((_QWORD *)this + 38) = 0;
  if (v12)
    CFRelease(v12);
  v13 = (const void *)*((_QWORD *)this + 39);
  *((_QWORD *)this + 39) = 0;
  if (v13)
    CFRelease(v13);
  v14 = (const void *)*((_QWORD *)this + 40);
  *((_QWORD *)this + 40) = 0;
  if (v14)
    CFRelease(v14);
  v15 = (const void *)*((_QWORD *)this + 37);
  *((_QWORD *)this + 37) = 0;
  if (v15)
    CFRelease(v15);
  v16 = (const void *)*((_QWORD *)this + 42);
  *((_QWORD *)this + 42) = 0;
  if (v16)
    CFRelease(v16);
  v17 = (const void *)*((_QWORD *)this + 29);
  *((_QWORD *)this + 29) = 0;
  if (v17)
    CFRelease(v17);
  v18 = (const void *)*((_QWORD *)this + 30);
  *((_QWORD *)this + 30) = 0;
  if (v18)
    CFRelease(v18);
  v19 = *((_QWORD *)this + 65);
  if (v19)
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
  v20 = (const void *)*((_QWORD *)this + 72);
  *((_QWORD *)this + 72) = 0;
  if (v20)
    CFRelease(v20);
  v21 = (const void *)*((_QWORD *)this + 73);
  *((_QWORD *)this + 73) = 0;
  if (v21)
    CFRelease(v21);
  v22 = *((_QWORD *)this + 66);
  if (v22)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
    *((_QWORD *)this + 66) = 0;
  }
  v23 = *((_QWORD *)this + 75);
  if (v23)
    (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
  v24 = *((_QWORD *)this + 27);
  if (v24)
    (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
  v25 = (const void *)*((_QWORD *)this + 54);
  if (v25)
    _Block_release(v25);
  v26 = (const void *)*((_QWORD *)this + 55);
  if (v26)
    _Block_release(v26);
  v27 = (const void *)*((_QWORD *)this + 56);
  if (v27)
    _Block_release(v27);
  v28 = (const void *)*((_QWORD *)this + 57);
  if (v28)
    _Block_release(v28);
  v29 = (const void *)*((_QWORD *)this + 58);
  if (v29)
    _Block_release(v29);
  v30 = (const void *)*((_QWORD *)this + 59);
  if (v30)
    _Block_release(v30);
  v31 = (const void *)*((_QWORD *)this + 60);
  if (v31)
    _Block_release(v31);
  v32 = (const void *)*((_QWORD *)this + 61);
  if (v32)
    _Block_release(v32);
  v33 = (const void *)*((_QWORD *)this + 62);
  if (v33)
    _Block_release(v33);
  v34 = (const void *)*((_QWORD *)this + 63);
  if (v34)
    _Block_release(v34);
  v35 = (const void *)*((_QWORD *)this + 64);
  if (v35)
    _Block_release(v35);
  (*(void (**)(SocketStream *, _QWORD))(*(_QWORD *)this + 176))(this, 0);
  objc_storeWeak((id *)this + 34, 0);
  objc_storeWeak((id *)this + 35, 0);
  v36 = (const void *)*((_QWORD *)this + 86);
  *((_QWORD *)this + 86) = 0;
  if (v36)
    CFRelease(v36);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 664);
  v37 = (const void *)*((_QWORD *)this + 81);
  *((_QWORD *)this + 81) = 0;
  if (v37)
    CFRelease(v37);
  v38 = *((_QWORD *)this + 22);
  *((_QWORD *)this + 22) = 0;
  if (v38)
    (*((void (**)(void))this + 23))();
  std::mutex::~mutex((std::mutex *)((char *)this + 112));
  std::unique_ptr<std::map<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>,CFStringRefComp,std::allocator<std::pair<std::unique_ptr<__CFString const,void (*)(__CFString const*)> const,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>>::reset[abi:nn180100]((uint64_t *)this + 13, 0);
  *((_QWORD *)this + 4) = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 40));
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

void sub_184051810(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;
  const void *v4;

  v3 = *(const void **)(v1 + 688);
  *(_QWORD *)(v1 + 688) = 0;
  if (v3)
    CFRelease(v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 664);
  v4 = *(const void **)(v1 + 648);
  *(_QWORD *)(v1 + 648) = 0;
  if (v4)
    CFRelease(v4);
  NotificationStation::~NotificationStation((NotificationStation *)(v1 + 104));
  *(_QWORD *)(v1 + 32) = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 40));
  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void SocketStream::cleanupConnection_NoLock(SocketStream *this)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 70))
  {
    *((_DWORD *)this + 62) |= 0x1000u;
    tcp_connection_cancel();
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v2 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v3 = *((_QWORD *)this + 70);
      v4 = 134217984;
      v5 = v3;
      _os_log_impl(&dword_183ECA000, v2, OS_LOG_TYPE_DEFAULT, "TCP Conn %p canceled", (uint8_t *)&v4, 0xCu);
    }
    *((_QWORD *)this + 70) = 0;
  }
}

uint64_t SocketStream::checkOutVoIPSocket(SocketStream *this, double a2)
{
  uint64_t result;
  double v4;

  result = *((_QWORD *)this + 69);
  if (result)
  {
    spd_client_checkout_socket_delayInitStub(a2);
    result = spd_client_destroy_delayInitStub(v4);
    *((_QWORD *)this + 69) = 0;
  }
  return result;
}

void SocketStream::unschedule_NoLock(SocketStream *this, CFTypeRef cf, __CFRunLoop *a3, const __CFString *a4)
{
  CFTypeID v7;
  CFTypeID TypeID;
  uint64_t v9;
  uint64_t v10;
  const __CFArray *v11;
  const __CFArray *v12;
  uint64_t v13;
  _QWORD v14[2];
  CFRange v15;

  v7 = CFGetTypeID(cf);
  TypeID = CFReadStreamGetTypeID();
  v9 = 312;
  if (v7 == TypeID)
    v10 = 304;
  else
    v10 = 312;
  if (v7 != TypeID)
    v9 = 304;
  v11 = *(const __CFArray **)((char *)this + v9);
  v12 = *(const __CFArray **)((char *)this + v10);
  if (_SchedulesRemoveRunLoopAndMode(*((const __CFArray **)this + 40), a3, a4))
  {
    _SchedulesAddRunLoopAndMode(v11, a3, a4);
  }
  else if (_SchedulesRemoveRunLoopAndMode(v12, a3, a4))
  {
    v13 = *((_QWORD *)this + 41);
    v14[0] = a3;
    v14[1] = a4;
    v15.length = *(_QWORD *)(v13 + 24);
    v15.location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v13 + 16), v15, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleApplierFunction, v14);
  }
}

void ___ZN12SocketStream12closeStreamsEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  __CFReadStream *v2;
  __CFWriteStream *v3;
  const void *v4;
  const void *v5;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(__CFReadStream **)(v1 + 200);
  if (v2)
  {
    if (CFReadStreamGetStatus(v2) <= kCFStreamStatusOpening)
      CFReadStreamOpen(*(CFReadStreamRef *)(v1 + 200));
    CFReadStreamClose(*(CFReadStreamRef *)(v1 + 200));
  }
  v3 = *(__CFWriteStream **)(v1 + 208);
  if (v3)
  {
    if (CFWriteStreamGetStatus(v3) <= kCFStreamStatusOpening)
      CFWriteStreamOpen(*(CFWriteStreamRef *)(v1 + 208));
    CFWriteStreamClose(*(CFWriteStreamRef *)(v1 + 208));
  }
  v4 = *(const void **)(v1 + 200);
  *(_QWORD *)(v1 + 200) = 0;
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(v1 + 208);
  *(_QWORD *)(v1 + 208) = 0;
  if (v5)
    CFRelease(v5);
  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN12SocketStream13setPropertiesEPK14__CFDictionary_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 200))(*(_QWORD *)(a1 + 32));
}

void ___ZN12SocketStream15beginConnectionEv_block_invoke(uint64_t a1)
{
  CFWriteStreamRef *v1;
  CFStreamClientContext clientContext;

  v1 = *(CFWriteStreamRef **)(a1 + 32);
  (*((void (**)(CFWriteStreamRef *, _BYTE *, _BYTE *))*v1 + 8))(v1, (_BYTE *)v1 + 200, (_BYTE *)v1 + 208);
  *((_BYTE *)v1 + 193) = 1;
  clientContext.version = 0;
  clientContext.info = v1;
  clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
  clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
  clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
  CFWriteStreamSetClient(v1[26], 0xCuLL, (CFWriteStreamClientCallBack)SocketStream::_beginConnection_streamEvent, &clientContext);
  MEMORY[0x186DB6A90](v1[26], v1[71]);
  CFWriteStreamOpen(v1[26]);
  CFRelease(v1 - 2);
}

void SocketStream::_beginConnection_streamEvent(SocketStream *this, __CFWriteStream *a2, uint64_t a3, void *a4)
{
  const void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  const void *v10;

  v5 = (const void *)(a3 - 16);
  CFRetain((CFTypeRef)(a3 - 16));
  v6 = *(_QWORD *)(a3 + 208);
  if (v6)
  {
    MEMORY[0x186DB6A90](v6, 0);
    CFWriteStreamSetClient(*(CFWriteStreamRef *)(a3 + 208), 0, 0, 0);
  }
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 184))(a3);
  if (v7)
  {
    v8 = v7;
    (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v7 + 64))(v7, *(_QWORD *)(a3 + 200), *(_QWORD *)(a3 + 208));
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
  }
  v9 = *(const void **)(a3 + 200);
  *(_QWORD *)(a3 + 200) = 0;
  if (v9)
    CFRelease(v9);
  v10 = *(const void **)(a3 + 208);
  *(_QWORD *)(a3 + 208) = 0;
  if (v10)
    CFRelease(v10);
  CFRelease(v5);
}

uint64_t ___ZN12SocketStream25touchWatchdogTimer_LockedEb_block_invoke(uint64_t a1)
{
  SocketStream *v1;
  CFStreamError v3;

  v1 = *(SocketStream **)(a1 + 32);
  CFLog();
  v3.domain = 4;
  *(_QWORD *)&v3.error = 4294965192;
  return SocketStream::_onqueue_cancelTCPConnectionAfterTimeout(v1, v3);
}

void ___ZN12SocketStream25touchWatchdogTimer_LockedEb_block_invoke_2(uint64_t a1)
{
  CFRelease((CFTypeRef)(*(_QWORD *)(a1 + 32) - 16));
}

uint64_t SocketStream::_onqueue_cancelTCPConnectionAfterTimeout(SocketStream *this, CFStreamError a2)
{
  uint64_t v2;
  CFIndex domain;
  pthread_mutex_t *v5;
  __int16 v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  id WeakRetained;
  const void *v11;
  id v12;
  const void *v13;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  CFIndex v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v2 = *(_QWORD *)&a2.error;
  domain = a2.domain;
  v22 = *MEMORY[0x1E0C80C00];
  v5 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  v6 = *((_WORD *)this + 126);
  *((_DWORD *)this + 62) = *((_DWORD *)this + 62);
  *((_WORD *)this + 126) = v6 | 2;
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v7 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    v15 = *((_QWORD *)this + 70);
    v16 = 134218496;
    v17 = v15;
    v18 = 2048;
    v19 = domain;
    v20 = 1024;
    v21 = v2;
    _os_log_error_impl(&dword_183ECA000, v7, OS_LOG_TYPE_ERROR, "TCP Conn %p timed out : error %ld %d", (uint8_t *)&v16, 0x1Cu);
  }
  SocketStream::cleanupConnection_NoLock(this);
  if (*((_BYTE *)this + 544))
  {
    *((_BYTE *)this + 544) = 0;
    CFRelease((char *)this - 16);
  }
  v8 = *((_QWORD *)this + 48);
  if (v8)
  {
    dispatch_source_cancel(v8);
    dispatch_release(*((dispatch_object_t *)this + 48));
    *((_QWORD *)this + 48) = 0;
  }
  v9 = *((_QWORD *)this + 49);
  if (v9)
  {
    dispatch_source_cancel(v9);
    dispatch_release(*((dispatch_object_t *)this + 49));
    *((_QWORD *)this + 49) = 0;
  }
  *((_QWORD *)this + 32) = domain;
  *((_QWORD *)this + 33) = v2;
  WeakRetained = objc_loadWeakRetained((id *)this + 34);
  v11 = WeakRetained;
  if (*((_QWORD *)this + 29) && *((uint64_t *)this + 28) >= 1 || !WeakRetained)
  {
    if (!WeakRetained)
      goto LABEL_18;
  }
  else if ((*((_DWORD *)this + 62) & 0x200) != 0)
  {
    _CFReadStreamSignalEventDelayed();
  }
  CFRelease(v11);
LABEL_18:
  v12 = objc_loadWeakRetained((id *)this + 35);
  if (v12)
  {
    v13 = v12;
    if ((*((_DWORD *)this + 62) & 0x400) != 0)
      _CFWriteStreamSignalEventDelayed();
    CFRelease(v13);
  }
  return pthread_mutex_unlock(v5);
}

CFStreamError *SocketStream::flushTransmissionBuffer_NoLock(CFStreamError *this)
{
  CFStreamError *v1;
  CFIndex domain;
  int64_t v3;
  unsigned __int8 *v4;
  CFStreamError *v5;
  CFIndex v6;
  CFStreamError *v7;
  CFStreamError *v8;

  if ((this[15].error & 8) != 0)
  {
    v1 = this;
    domain = this[33].domain;
    if (domain)
    {
      v3 = *(_QWORD *)(domain + 24);
      if (v3 >= 1)
      {
        v4 = *(unsigned __int8 **)(domain + 32);
        this = (CFStreamError *)SocketStream::sendToSocket((SocketStream *)this, v4, v3, this + 16);
        v5 = this;
        v6 = v1[33].domain;
        v7 = *(CFStreamError **)(v6 + 24);
        if (v7 == this)
        {
          v8 = this;
        }
        else
        {
          this = (CFStreamError *)memmove(v4, (char *)this + (_QWORD)v4, (char *)v7 - (char *)this);
          v6 = v1[33].domain;
          v8 = *(CFStreamError **)(v6 + 24);
        }
        *(_QWORD *)(v6 + 24) = (char *)v8 - (char *)v5;
      }
    }
  }
  return this;
}

void CFBufferConstantSize<36000l>::~CFBufferConstantSize(CFAllocatorRef *ptr)
{
  CFAllocatorDeallocate(ptr[1], ptr);
}

uint64_t SocketStream::_copyPeerTrustWithPinning_NoLock(CFDictionaryRef *this, SSLContextRef context, SecTrustRef *trust)
{
  uint64_t result;

  result = SSLCopyPeerTrust(context, trust);
  if (trust && !(_DWORD)result)
  {
    if (*trust)
    {
      result = (uint64_t)CFDictionaryGetValue(this[42], &unk_1EDCFAC60);
      if (result)
        return SecTrustSetPinningPolicyName();
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t logPeerCertAvailable(SSLContext *a1)
{
  uint64_t result;
  uint64_t v3;
  const __CFAllocator *v4;
  const __CFArray *v5;
  const __CFArray *v6;
  __SecCertificate *ValueAtIndex;
  __SecCertificate *v8;
  CFStringRef v9;
  CFStringRef v10;
  CFArrayRef v11;
  OSStatus v12;
  CFStringRef v13;
  CFStringRef v14;
  const __CFArray *v15;
  unint64_t Count;
  CFRange v17;
  const void **v18;
  CFStringRef v19;
  CFStringRef v20;
  CFIndex v21;
  const void *v22;
  CFStringRef v23;
  CFStringRef commonName;
  CFArrayRef emailAddresses;
  SecTrustRef trust;
  void (**v27)(AutoString *__hidden);
  CFIndex range;
  const void **v29;
  _QWORD v30[31];
  CFIndex v31;
  void (**v32)(AutoString *__hidden);
  CFStringRef v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  result = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_211, 1);
  if (!result)
    return result;
  v3 = result;
  result = (*(uint64_t (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)result + 16))(result, "Peer certificate", 0);
  if (!(_DWORD)result)
    return result;
  trust = 0;
  if (SSLCopyPeerTrust(a1, &trust))
  {
    (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v3 + 72))(v3, "Error", CFSTR("can't obtain peer certs (%d)"));
    goto LABEL_37;
  }
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (!trust || !SecTrustGetCertificateCount(trust))
  {
    v27 = &off_1E14E4818;
    v19 = CFStringCreateWithCString(v4, "Error", 0x8000100u);
    v29 = 0;
    v30[0] = 0;
    range = (CFIndex)v19;
    v32 = &off_1E14E4818;
    v20 = CFStringCreateWithCString(v4, "NULL or empty trust returned", 0x8000100u);
    v34 = 0;
    v35 = 0;
    v33 = v20;
    (*(void (**)(uint64_t, CFIndex, CFStringRef))(*(_QWORD *)v3 + 64))(v3, range, v20);
    AutoString::~AutoString((AutoString *)&v32);
    AutoString::~AutoString((AutoString *)&v27);
    goto LABEL_37;
  }
  v5 = SecTrustCopyCertificateChain(trust);
  v6 = v5;
  if (v5)
  {
    if (CFArrayGetCount(v5) < 1
      || (ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(v6, 0), (v8 = ValueAtIndex) == 0))
    {
LABEL_36:
      CFRelease(v6);
      goto LABEL_37;
    }
    v9 = SecCertificateCopySubjectSummary(ValueAtIndex);
    v27 = &off_1E14E4818;
    v10 = CFStringCreateWithCString(v4, "Subject Sum", 0x8000100u);
    v29 = 0;
    v30[0] = 0;
    range = (CFIndex)v10;
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 64))(v3);
    AutoString::~AutoString((AutoString *)&v27);
    if (v9)
      CFRelease(v9);
    commonName = 0;
    emailAddresses = 0;
    if (SecCertificateCopyEmailAddresses(v8, &emailAddresses))
    {
      v11 = emailAddresses;
      emailAddresses = 0;
      if (v11)
        CFRelease(v11);
    }
    v12 = SecCertificateCopyCommonName(v8, &commonName);
    v13 = commonName;
    if (v12)
    {
      commonName = 0;
      if (v13)
        CFRelease(v13);
    }
    v27 = &off_1E14E4818;
    v14 = CFStringCreateWithCString(v4, "Common Name", 0x8000100u);
    v29 = 0;
    v30[0] = 0;
    range = (CFIndex)v14;
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 64))(v3);
    AutoString::~AutoString((AutoString *)&v27);
    v15 = emailAddresses;
    if (!emailAddresses)
    {
LABEL_30:
      if (commonName)
        CFRelease(commonName);
      if (emailAddresses)
        CFRelease(emailAddresses);
      v22 = (const void *)SecCertificateCopyIssuerSummary();
      v27 = &off_1E14E4818;
      v23 = CFStringCreateWithCString(v4, "Summary", 0x8000100u);
      v29 = 0;
      v30[0] = 0;
      range = (CFIndex)v23;
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 64))(v3);
      AutoString::~AutoString((AutoString *)&v27);
      if (v22)
        CFRelease(v22);
      goto LABEL_36;
    }
    v27 = (void (**)(AutoString *__hidden))CFRetain(emailAddresses);
    Count = CFArrayGetCount(v15);
    v17.length = Count;
    range = Count;
    if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      v29 = 0;
    }
    else
    {
      if (Count <= 0x1E)
      {
        v18 = (const void **)v30;
        v29 = (const void **)v30;
LABEL_25:
        v17.location = 0;
        CFArrayGetValues(v15, v17, v18);
        v17.length = range;
        goto LABEL_26;
      }
      v18 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
      v29 = v18;
      v17.length = range;
      if (v18)
        goto LABEL_25;
    }
LABEL_26:
    v31 = 0;
    if (v17.length >= 1)
    {
      v21 = 0;
      do
      {
        v31 = v21 + 1;
        v32 = &off_1E14E4818;
        v33 = CFStringCreateWithCString(v4, "Email", 0x8000100u);
        v34 = 0;
        v35 = 0;
        (*(void (**)(uint64_t))(*(_QWORD *)v3 + 64))(v3);
        AutoString::~AutoString((AutoString *)&v32);
        v21 = v31;
      }
      while (v31 < range);
    }
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v27);
    goto LABEL_30;
  }
LABEL_37:
  if (trust)
    CFRelease(trust);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
}

void sub_184052414(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  const void *v6;
  va_list va;

  va_start(va, a6);
  AutoString::~AutoString((AutoString *)va);
  CFRelease(v6);
  _Unwind_Resume(a1);
}

void ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke(uint64_t a1, int a2)
{
  uint64_t v2;
  NSObject *v4;
  _QWORD v5[5];
  int v6;

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v2 + 568))
  {
    CFRetain((CFTypeRef)(v2 - 16));
    v4 = *(NSObject **)(v2 + 568);
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_2;
    v5[3] = &__block_descriptor_44_e5_v8__0l;
    v5[4] = v2;
    v6 = a2;
    dispatch_async(v4, v5);
  }
  CFRelease((CFTypeRef)(v2 - 16));
}

void SocketStream::unscheduleFromSSL(SocketStream *this)
{
  uint64_t v2;
  __int128 v3;
  uint64_t v4;
  uint64_t v5;

  v2 = 0;
  v5 = *MEMORY[0x1E0C80C00];
  v3 = *((_OWORD *)this + 19);
  v4 = *((_QWORD *)this + 40);
  do
  {
    _CFTypeUnscheduleFromMultipleRunLoops(*((void **)this + 36), *(const __CFArray **)((char *)&v3 + v2));
    v2 += 8;
  }
  while (v2 != 24);
}

void ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_3(uint64_t a1, const void *a2)
{
  uint64_t v2;
  NSObject *v4;
  _QWORD v5[6];

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v2 + 568))
  {
    CFRetain((CFTypeRef)(v2 - 16));
    if (a2)
      CFRetain(a2);
    v4 = *(NSObject **)(v2 + 568);
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_4;
    v5[3] = &__block_descriptor_48_e5_v8__0l;
    v5[4] = v2;
    v5[5] = a2;
    dispatch_async(v4, v5);
  }
  CFRelease((CFTypeRef)(v2 - 16));
}

uint64_t translateSSLContextError(SSLContext *a1, uint64_t a2)
{
  uint64_t v2;
  SSLClientCertificateState clientState;
  SSLClientCertificateState v5;

  v2 = a2;
  if ((_DWORD)a2 == -9809)
  {
    v5 = kSSLClientCertNone;
    if (!SSLGetClientCertificateState(a1, &v5) && v5 == kSSLClientCertSent)
      return 4294957471;
  }
  else if ((_DWORD)a2 == -9824)
  {
    clientState = kSSLClientCertNone;
    if (!SSLGetClientCertificateState(a1, &clientState) && clientState == kSSLClientCertRequested)
      return 4294957467;
  }
  return v2;
}

void ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_4(uint64_t a1)
{
  SocketStream *v2;
  const void *v3;

  v2 = *(SocketStream **)(a1 + 32);
  SocketStream::securitySetPeerCert(v2, *(const __CFArray **)(a1 + 40));
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
  CFRelease((char *)v2 - 16);
}

void SocketStream::securitySetPeerCert(SocketStream *this, const __CFArray *a2)
{
  pthread_mutex_t *v4;
  SocketStreamSignalHolder *v5;
  _OWORD v6[4];
  uint64_t v7;

  v7 = 0;
  memset(v6, 0, sizeof(v6));
  v4 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  SocketStream::securitySetPeerCert_NoLock(this, a2, (SocketStreamSignalHolder *)v6);
  pthread_mutex_unlock(v4);
  SocketStream::dispatchSignalFromSocketCallbackUnlocked((CFRunLoopSourceRef *)v6, v5);
  SocketStreamSignalHolder::~SocketStreamSignalHolder((SocketStreamSignalHolder *)v6);
}

void sub_184052758(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  SocketStreamSignalHolder::~SocketStreamSignalHolder((SocketStreamSignalHolder *)&a9);
  _Unwind_Resume(a1);
}

void SocketStream::securitySetPeerCert_NoLock(SocketStream *this, const __CFArray *a2, SocketStreamSignalHolder *a3)
{
  SSLContext *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v5 = (SSLContext *)*((_QWORD *)this + 37);
    if (v5)
      SSLSetCertificate(v5, a2);
  }
  v6 = *((unsigned int *)this + 62);
  if ((v6 & 0x20000000) != 0)
  {
    v7 = 0;
    v8 = v6 & 0xFFFFFFFFDFFFFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) = v6 & 0xDFFFFFFF;
    *((_WORD *)this + 126) = WORD2(v8);
    v9 = *((_OWORD *)this + 19);
    v10 = *((_QWORD *)this + 40);
    do
    {
      _CFTypeScheduleOnMultipleRunLoops(*((void **)this + 36), *(const __CFArray **)((char *)&v9 + v7));
      v7 += 8;
    }
    while (v7 != 24);
    if (!*((_DWORD *)this + 103))
    {
      SocketStream::socketCallbackReadLocked(this, a3);
      SocketStream::prepareSignalFromSocketCallbackLocked(this, a3);
    }
  }
}

uint64_t SocketStream::doSettingsOverrideTrustEvaluation(CFDictionaryRef *this)
{
  const __CFDictionary *Value;
  uint64_t v3;
  CFTypeRef v4;
  const void *v5;
  const void *v6;
  CFTypeID v7;
  CFDataRef v8;
  const __CFData *v9;
  CFTypeRef v10;
  const void *v11;
  const void *v12;
  const void **v13;
  CFTypeID v14;
  const void *v15;
  const void *v16;
  CFTypeID v17;
  const void *v18;
  const void *v19;
  CFTypeID v20;
  const void *v21;
  int v22;
  void (**v24)(CFNetworkTrust *__hidden);
  CFTypeRef v25;
  uint64_t v26;
  CFTypeRef v27;
  __int16 v28;
  BOOL v30;
  CFTypeRef cf;
  uint8_t buf[4];

  Value = (const __CFDictionary *)CFDictionaryGetValue(this[42], CFSTR("kCFStreamPropertySSLSettings"));
  cf = 0;
  v3 = SocketStream::_copyPeerTrustWithPinning_NoLock(this, this[37], (SecTrustRef *)&cf);
  if ((_DWORD)v3)
  {
    v4 = cf;
    cf = 0;
    if (!v4)
      return 4294957494;
    CFRelease(v4);
  }
  if (!cf)
    return 4294957494;
  if (Value)
  {
    v5 = CFDictionaryGetValue(Value, &unk_1EDCFC588);
    if (v5)
    {
      v6 = v5;
      v7 = CFGetTypeID(v5);
      if (v7 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        LOWORD(v24) = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&v24, 2u);
      }
      if ((const void *)*MEMORY[0x1E0C9AE40] == v6)
        goto LABEL_15;
    }
  }
  v30 = 0;
  v8 = copyPeerID(this[37]);
  if (v8)
  {
    v9 = v8;
    if (TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce != -1)
      dispatch_once(&TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce, &__block_literal_global_1699);
    TrustExceptionManager::applyTrustExceptions((TrustExceptionManager *)TrustExceptionManager::sharedTrustExceptionManager(void)::singleton, v9, (__SecTrust *)cf, &v30);
    CFRelease(v9);
    if (v30)
    {
LABEL_15:
      v3 = 0;
      goto LABEL_45;
    }
  }
  v10 = cf;
  v24 = &off_1E14E6B30;
  v28 = 0;
  if (cf)
    v10 = CFRetain(cf);
  v26 = 0;
  v27 = 0;
  v25 = v10;
  if (Value)
  {
    v11 = CFDictionaryGetValue(Value, CFSTR("kCFStreamSSLAllowsExpiredCertificates"));
    v12 = v11;
    v13 = (const void **)MEMORY[0x1E0C9AE50];
    if (v11)
    {
      v14 = CFGetTypeID(v11);
      if (v14 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
      }
      if (*v13 == v12)
        HIBYTE(v28) |= 1u;
    }
    v15 = CFDictionaryGetValue(Value, CFSTR("kCFStreamSSLAllowsExpiredRoots"));
    v16 = v15;
    if (v15)
    {
      v17 = CFGetTypeID(v15);
      if (v17 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
      }
      if (*v13 == v16)
        HIBYTE(v28) |= 2u;
    }
    v18 = CFDictionaryGetValue(Value, CFSTR("kCFStreamSSLAllowsAnyRoot"));
    v19 = v18;
    if (v18)
    {
      v20 = CFGetTypeID(v18);
      if (v20 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
      }
      if (*v13 == v19)
        HIBYTE(v28) |= 4u;
    }
    v21 = CFDictionaryGetValue(Value, &unk_1EDCFB2F0);
    if (v21)
      v27 = CFRetain(v21);
  }
  *(_DWORD *)buf = 0;
  if (MEMORY[0x186DB7078](v25, buf))
  {
    LOBYTE(v28) = v28 | 0x20;
  }
  else
  {
    v22 = CFNetworkTrust::processEvaluateResult((SecTrustRef *)&v24, *(SecTrustResultType *)buf);
    if ((v22 - 1) >= 2)
    {
      if (!v22)
        v3 = 0;
      goto LABEL_44;
    }
  }
  v3 = CFNetworkTrust::errorForEvaluationFalure((CFNetworkTrust *)&v24);
LABEL_44:
  CFNetworkTrust::~CFNetworkTrust((CFNetworkTrust *)&v24);
LABEL_45:
  if (cf)
    CFRelease(cf);
  return v3;
}

void sub_184052C4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFNetworkTrust::~CFNetworkTrust((CFNetworkTrust *)&a9);
  _Unwind_Resume(a1);
}

void ___ZN12SocketStream19securityRead_NoLockEPhlS0_S0__block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v2;
  NSObject *v4;
  _QWORD v5[6];

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v2 + 568))
  {
    CFRetain((CFTypeRef)(v2 - 16));
    if (a2)
      CFRetain(a2);
    v4 = *(NSObject **)(v2 + 568);
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = ___ZN12SocketStream19securityRead_NoLockEPhlS0_S0__block_invoke_2;
    v5[3] = &__block_descriptor_48_e5_v8__0l;
    v5[4] = v2;
    v5[5] = a2;
    dispatch_async(v4, v5);
  }
  CFRelease((CFTypeRef)(v2 - 16));
}

void ___ZN12SocketStream19securityRead_NoLockEPhlS0_S0__block_invoke_2(uint64_t a1)
{
  SocketStream *v2;
  const void *v3;

  v2 = *(SocketStream **)(a1 + 32);
  SocketStream::securitySetPeerCert(v2, *(const __CFArray **)(a1 + 40));
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
  CFRelease((char *)v2 - 16);
}

CFDataRef copyPeerID(SSLContext *a1)
{
  OSStatus v1;
  CFDataRef result;
  CFIndex length;
  void *peerID;

  length = 0;
  peerID = 0;
  v1 = SSLGetPeerID(a1, (const void **)&peerID, (size_t *)&length);
  result = 0;
  if (!v1)
  {
    if (peerID)
      return CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)peerID, length);
  }
  return result;
}

void SocketStream::_PerformSOCKSv4Handshake_NoLock(CFDictionaryRef *this)
{
  const __CFData *Value;
  __CFData *v3;
  size_t Length;
  const unsigned __int8 *BytePtr;
  uint64_t v6;
  size_t v7;
  __CFDictionary *v8;
  const void *v9;
  CFMutableDataRef v10;
  const __CFAllocator *v11;
  CFMutableDataRef Mutable;
  UInt8 *v13;
  CFIndex v14;
  int v15;
  uint64_t v16;
  UInt8 *MutableBytePtr;
  __CFSocket *v18;
  CFIndex v19;
  uint64_t v20;
  size_t v21;
  __CFSocket *v22;
  int v23;
  int v24;
  char __dst[8];
  CFStreamError v26;

  Value = (const __CFData *)CFDictionaryGetValue(this[42], &unk_1EDCFAAA0);
  v3 = (__CFData *)CFDictionaryGetValue(this[42], &unk_1EDCFAA68);
  if (Value)
  {
    v26.domain = 0;
    *(_QWORD *)&v26.error = 0;
    Length = CFDataGetLength(Value);
    BytePtr = CFDataGetBytePtr(Value);
    v6 = SocketStream::sendToSocket((SocketStream *)this, BytePtr, Length, &v26);
    v7 = Length - v6;
    if (!v7)
    {
      v8 = this[42];
      v9 = &unk_1EDCFAAA0;
LABEL_32:
      CFDictionaryRemoveValue(v8, v9);
      goto LABEL_33;
    }
    v16 = v6;
    if (v6 >= 1)
    {
      MutableBytePtr = CFDataGetMutableBytePtr(Value);
      memmove(MutableBytePtr, &MutableBytePtr[v16], v7);
      CFDataSetLength(Value, v7);
      v18 = this[36];
      if (v18 && CFSocketIsValid(v18))
        CFSocketEnableCallBacks(this[36], 8uLL);
      goto LABEL_33;
    }
    goto LABEL_21;
  }
  v10 = v3;
  if (!v3)
  {
    v11 = CFGetAllocator(this[42]);
    Mutable = CFDataCreateMutable(v11, 8);
    if (!Mutable)
    {
      this[32] = (CFDictionaryRef)1;
      v24 = 12;
      goto LABEL_28;
    }
    v10 = Mutable;
    CFDictionaryAddValue(this[42], &unk_1EDCFAA68, Mutable);
    CFRelease(v10);
  }
  v13 = CFDataGetMutableBytePtr(v10);
  v14 = CFDataGetLength(v10);
  if (v14 == 8)
    goto LABEL_8;
  v19 = v14;
  v26.domain = 0;
  *(_QWORD *)&v26.error = 0;
  v20 = SocketStream::recvBytes((SocketStream *)this, &v13[v14], 8 - v14, &v26);
  if (!v20)
  {
    this[32] = (CFDictionaryRef)1;
    v24 = 57;
LABEL_28:
    *((_DWORD *)this + 66) = v24;
    goto LABEL_33;
  }
  if (v20 < 1)
  {
LABEL_21:
    if (v26.error != 35 || v26.domain != 1)
      *((CFStreamError *)this + 16) = v26;
    goto LABEL_33;
  }
  v21 = v20 + v19;
  memcpy(__dst, v13, v21);
  CFDataSetLength(v10, v21);
  memcpy(v13, __dst, v21);
  v22 = this[36];
  if (v22 && CFSocketIsValid(v22))
    CFSocketEnableCallBacks(this[36], 1uLL);
  if (v21 == 8)
  {
LABEL_8:
    if (*v13)
    {
      v15 = 196607;
    }
    else
    {
      v23 = v13[1];
      if (v23 == 90)
      {
        SocketStream::removeHandshake_NoLock((uint64_t)this, 4);
LABEL_31:
        v8 = this[42];
        v9 = &unk_1EDCFAA68;
        goto LABEL_32;
      }
      v15 = v23 | 0x20000;
    }
    this[32] = (CFDictionaryRef)(int)*MEMORY[0x1E0C9B290];
    *((_DWORD *)this + 66) = v15;
    goto LABEL_31;
  }
LABEL_33:
  if (*((_DWORD *)this + 66))
    SocketStream::removeHandshake_NoLock((uint64_t)this, 4);
}

void ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke(uint64_t a1, int a2)
{
  uint64_t v2;
  NSObject *v4;
  _QWORD v5[5];
  int v6;

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v2 + 568))
  {
    CFRetain((CFTypeRef)(v2 - 16));
    v4 = *(NSObject **)(v2 + 568);
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_2;
    v5[3] = &__block_descriptor_44_e5_v8__0l;
    v5[4] = v2;
    v6 = a2;
    dispatch_async(v4, v5);
  }
  CFRelease((CFTypeRef)(v2 - 16));
}

void ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_3(uint64_t a1, const void *a2)
{
  uint64_t v2;
  NSObject *v4;
  _QWORD v5[6];

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v2 + 568))
  {
    CFRetain((CFTypeRef)(v2 - 16));
    if (a2)
      CFRetain(a2);
    v4 = *(NSObject **)(v2 + 568);
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_4;
    v5[3] = &__block_descriptor_48_e5_v8__0l;
    v5[4] = v2;
    v5[5] = a2;
    dispatch_async(v4, v5);
  }
  CFRelease((CFTypeRef)(v2 - 16));
}

void ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_4(uint64_t a1)
{
  SocketStream *v2;
  const void *v3;

  v2 = *(SocketStream **)(a1 + 32);
  SocketStream::securitySetPeerCert(v2, *(const __CFArray **)(a1 + 40));
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
  CFRelease((char *)v2 - 16);
}

uint64_t ___ZL22logClientCertRequestedPK9__CFArray_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 8247;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  int v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_DWORD *)(a1 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 40));
  SocketStream::securityAcceptPeerTrust_NoLock((SocketStream *)v1, v2);
  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 40));
  CFRelease((CFTypeRef)(v1 - 16));
}

void SocketStream::securityAcceptPeerTrust_NoLock(SocketStream *this, int a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  SSLContext *v7;
  CFDataRef v8;
  const __CFData *v9;
  int v10;
  const void *v11;
  const __CFDictionary *Value;
  const __CFDictionary *v13;
  const __CFDictionary *ATSVersion;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  const void *v18;
  CFTypeRef v19;
  int v20;
  NSObject *v21;
  _BOOL4 v22;
  NSObject *v23;
  NSObject *v24;
  CFTypeRef v25;
  NSObject *v26;
  uint64_t v27;
  CFTypeRef v28;
  CFIndex Code;
  CFTypeRef v30;
  CFTypeRef v31;
  uint8_t buf[4];
  int v33;
  _BYTE cf[24];
  uint64_t v35;
  __int16 v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v4 = *((unsigned int *)this + 62);
  if ((v4 & 0x40000000) != 0)
  {
    v5 = 0;
    v6 = v4 & 0xFFFFFFFFBFFFFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) = v4 & 0xBFFFFFFF;
    *((_WORD *)this + 126) = WORD2(v6);
    *(_OWORD *)cf = *((_OWORD *)this + 19);
    *(_QWORD *)&cf[16] = *((_QWORD *)this + 40);
    do
    {
      _CFTypeScheduleOnMultipleRunLoops(*((void **)this + 36), *(const __CFArray **)&cf[v5]);
      v5 += 8;
    }
    while (v5 != 24);
  }
  if (a2 == 2)
  {
    v30 = 0;
    SocketStream::_copyPeerTrustWithPinning_NoLock((CFDictionaryRef *)this, *((SSLContextRef *)this + 37), (SecTrustRef *)&v30);
    Value = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), CFSTR("kCFStreamPropertySSLSettings"));
    if (v30)
    {
      ATSVersion = StrictSecurity::getATSVersion(Value, v13);
      v15 = (uint64_t)ATSVersion;
      v16 = *((_BYTE *)this + 253) & 1;
      if (!*((_QWORD *)this + 86) || !ATSVersion || !dyld_program_sdk_at_least())
        goto LABEL_43;
      v31 = 0;
      v17 = (const void *)SecTrustDeserialize();
      v18 = v17;
      if (v31 || !v17)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v24 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          v28 = v31;
          if (v31)
            Code = CFErrorGetCode((CFErrorRef)v31);
          else
            Code = 0;
          *(_DWORD *)cf = 138412546;
          *(_QWORD *)&cf[4] = v28;
          *(_WORD *)&cf[12] = 2048;
          *(_QWORD *)&cf[14] = Code;
          _os_log_error_impl(&dword_183ECA000, v24, OS_LOG_TYPE_ERROR, "Failed to deserialize cloned ATS trust %@ [%ld]", cf, 0x16u);
        }
        v22 = 1;
        v20 = -9802;
      }
      else
      {
        *(_QWORD *)cf = &off_1E14E6B30;
        v36 = 0;
        v19 = CFRetain(v17);
        *(_QWORD *)&cf[16] = 0;
        v35 = 0;
        *(_QWORD *)&cf[8] = v19;
        v20 = CFNetworkTrust::strictEvaluate((uint64_t)cf, 1, v16);
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v21 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          v33 = v20;
          _os_log_impl(&dword_183ECA000, v21, OS_LOG_TYPE_DEFAULT, "System Trust Evaluation yielded status(%d)", buf, 8u);
        }
        v22 = v20 == 0;
        if (v20)
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v23 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_183ECA000, v23, OS_LOG_TYPE_ERROR, "ATS failed system trust", buf, 2u);
          }
        }
        CFNetworkTrust::~CFNetworkTrust((CFNetworkTrust *)cf);
      }
      if (v31)
        CFRelease(v31);
      if (v18)
        CFRelease(v18);
      if (v22)
      {
LABEL_43:
        v25 = v30;
        *(_QWORD *)cf = &off_1E14E6B30;
        v36 = 0;
        if (v30)
          v25 = CFRetain(v30);
        *(_QWORD *)&cf[16] = 0;
        v35 = 0;
        *(_QWORD *)&cf[8] = v25;
        v20 = CFNetworkTrust::strictEvaluate((uint64_t)cf, v15, v16);
        CFNetworkTrust::~CFNetworkTrust((CFNetworkTrust *)cf);
      }
      CFRelease(v30);
    }
    else
    {
      v20 = -9802;
    }
  }
  else
  {
    if (a2 == 1)
    {
      v7 = (SSLContext *)*((_QWORD *)this + 37);
      if (v7)
      {
        v8 = copyPeerID(v7);
        if (v8)
        {
          v9 = v8;
          *(_QWORD *)cf = 0;
          v10 = SocketStream::_copyPeerTrustWithPinning_NoLock((CFDictionaryRef *)this, *((SSLContextRef *)this + 37), (SecTrustRef *)cf);
          v11 = *(const void **)cf;
          if (!v10 && *(_QWORD *)cf)
          {
            if (TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce != -1)
              dispatch_once(&TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce, &__block_literal_global_1699);
            TrustExceptionManager::storeTrustExceptions((TrustExceptionManager *)TrustExceptionManager::sharedTrustExceptionManager(void)::singleton, v9, *(SecTrustRef *)cf);
            v11 = *(const void **)cf;
          }
          if (v11)
            CFRelease(v11);
          CFRelease(v9);
        }
      }
LABEL_52:
      if ((*((_DWORD *)this + 62) & 0x8000) == 0)
        return;
      goto LABEL_53;
    }
    v20 = SocketStream::doSettingsOverrideTrustEvaluation((CFDictionaryRef *)this);
  }
  if (!v20)
    goto LABEL_52;
  *((_QWORD *)this + 32) = (int)*MEMORY[0x1E0C9B298];
  *((_DWORD *)this + 66) = v20;
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v26 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    v27 = *((_QWORD *)this + 70);
    *(_DWORD *)cf = 134218240;
    *(_QWORD *)&cf[4] = v27;
    *(_WORD *)&cf[12] = 1024;
    *(_DWORD *)&cf[14] = v20;
    _os_log_error_impl(&dword_183ECA000, v26, OS_LOG_TYPE_ERROR, "TCP Conn %p trust evalulation failed: %d", cf, 0x12u);
  }
LABEL_53:
  SocketStream::removeSSLHandshake(this);
}

void sub_1840536C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  const void *v13;

  if (v13)
    CFRelease(v13);
  _Unwind_Resume(exception_object);
}

uint64_t SocketStream::_CreateNameAndPortForCONNECTProxy(SocketStream *this, const __CFDictionary *a2, const __CFString **a3, const __CFNumber **a4, CFStreamError *a5)
{
  const __CFAllocator *v9;
  const __CFString *Value;
  const void *v11;
  uint64_t v12;
  const __CFArray *ValueAtIndex;
  const __CFArray *v14;
  const __CFArray *v15;
  const __CFArray *Info;
  const __CFArray *v17;
  const __CFArray *v18;
  const __CFArray *v19;
  BOOL v20;
  const UInt8 *BytePtr;
  int v23;
  CFStringRef v24;
  uint64_t result;
  int v26;
  unsigned int valuePtr;

  v9 = CFGetAllocator(this);
  *a4 = 0;
  a4[1] = 0;
  Value = (const __CFString *)CFDictionaryGetValue(this, &unk_1EDCFBE88);
  v11 = CFDictionaryGetValue(this, &unk_1EDCFBE50);
  if (!v11)
  {
    v15 = (const __CFArray *)CFDictionaryGetValue(this, &unk_1EDCFBDE0);
    ValueAtIndex = v15;
    if (v15)
    {
      Info = (const __CFArray *)CFHostGetInfo((uint64_t)v15, 1, 0);
      if (Info && (v17 = Info, CFArrayGetCount(Info)))
      {
        ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(v17, 0);
      }
      else
      {
        v19 = (const __CFArray *)CFHostGetInfo((uint64_t)ValueAtIndex, 0, 0);
        ValueAtIndex = v19;
        if (v19)
        {
          if (CFArrayGetCount(v19))
            v14 = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
          else
            v14 = 0;
          ValueAtIndex = 0;
          goto LABEL_18;
        }
      }
    }
LABEL_15:
    v14 = 0;
    goto LABEL_18;
  }
  v12 = (uint64_t)v11;
  ValueAtIndex = (const __CFArray *)CFNetServiceGetInfo((uint64_t)v11, 5u);
  if (Value)
  {
    CFRetain(Value);
    if (!ValueAtIndex)
    {
      v14 = 0;
      goto LABEL_31;
    }
LABEL_27:
    CFRetain(ValueAtIndex);
    goto LABEL_32;
  }
  v18 = (const __CFArray *)CFNetServiceGetInfo(v12, 3u);
  v14 = v18;
  if (v18)
  {
    if (CFArrayGetCount(v18))
    {
      v14 = (const __CFArray *)CFArrayGetValueAtIndex(v14, 0);
      goto LABEL_18;
    }
    goto LABEL_15;
  }
LABEL_18:
  if (Value)
    v20 = 0;
  else
    v20 = ValueAtIndex == 0;
  if (v20 && v14 == 0)
    goto LABEL_36;
  if (!Value)
  {
    BytePtr = CFDataGetBytePtr(v14);
    v23 = BytePtr[1];
    if (v23 == 30 || v23 == 2)
    {
      valuePtr = bswap32(*((unsigned __int16 *)BytePtr + 1)) >> 16;
      Value = (const __CFString *)CFNumberCreate(v9, kCFNumberSInt32Type, &valuePtr);
      if (ValueAtIndex)
        goto LABEL_27;
      goto LABEL_31;
    }
LABEL_36:
    result = 0;
    *a4 = (const __CFNumber *)1;
    v26 = 22;
LABEL_42:
    *((_DWORD *)a4 + 2) = v26;
    return result;
  }
  CFRetain(Value);
  if (ValueAtIndex)
    goto LABEL_27;
LABEL_31:
  ValueAtIndex = (const __CFArray *)_CFNetworkCFStringCreateWithCFDataAddress(v14);
  if (!ValueAtIndex)
  {
LABEL_37:
    if (ValueAtIndex)
      CFRelease(ValueAtIndex);
    if (Value)
      CFRelease(Value);
    result = 0;
    *a4 = (const __CFNumber *)1;
    v26 = 12;
    goto LABEL_42;
  }
LABEL_32:
  if (!Value)
    goto LABEL_37;
  if (_isIPAddress((const __CFString *)ValueAtIndex, 0))
  {
    v24 = CFStringCreateWithFormat(v9, 0, CFSTR("[%@]"), ValueAtIndex);
    CFRelease(ValueAtIndex);
    ValueAtIndex = (const __CFArray *)v24;
  }
  *(_QWORD *)a2 = ValueAtIndex;
  *a3 = Value;
  return 1;
}

void _CONNECTHeaderApplier(CFStringRef headerField, CFStringRef value, CFHTTPMessageRef message)
{
  CFHTTPMessageSetHeaderFieldValue(message, headerField, value);
}

void ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  int v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_DWORD *)(a1 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 40));
  SocketStream::securityAcceptPeerTrust_NoLock((SocketStream *)v1, v2);
  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 40));
  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZL20logPeerCertAvailableP10SSLContext_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 7822;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t _CFSocketSetNoDelay(__CFSocket *a1)
{
  CFSocketNativeHandle Native;
  int v3;

  v3 = 1;
  Native = CFSocketGetNative(a1);
  return setsockopt(Native, 6, 1, &v3, 4u);
}

uint64_t _CFSocketSetRecvAnyIf(__CFSocket *a1)
{
  CFSocketNativeHandle Native;
  int v3;

  v3 = 1;
  Native = CFSocketGetNative(a1);
  return setsockopt(Native, 0xFFFF, 4356, &v3, 4u);
}

uint64_t SocketStream::_CONNECTSetInfo_NoLock(CFDictionaryRef *this, CFDictionaryRef theDict)
{
  const void *Value;
  const void *v5;
  const void *v6;
  BOOL v7;
  CFDictionaryRef *v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int v11;
  uint64_t v12;
  char v13;
  __CFDictionary *v14;
  const void *v15;
  uint64_t v16;
  const __CFArray *Info;
  uint64_t result;
  const void *v19;

  if (theDict)
  {
    Value = CFDictionaryGetValue(theDict, &unk_1EDD00418);
    v5 = CFDictionaryGetValue(theDict, &unk_1EDD00450);
    v6 = CFDictionaryGetValue(this[42], &unk_1EDD003E0);
    if (Value)
      v7 = v5 == 0;
    else
      v7 = 1;
    if (v7)
      return 0;
    v8 = this + 42;
  }
  else
  {
    v8 = this + 42;
    v6 = CFDictionaryGetValue(this[42], &unk_1EDD003E0);
  }
  v9 = *((unsigned int *)this + 62);
  v10 = v9 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
  if ((v9 & 0x100) != 0)
    return 0;
  if ((v9 & 3) != 0)
  {
    v11 = *((_DWORD *)this + 103);
    if (v11)
    {
      v12 = 0;
      while (((v11 >> v12) & 1) == 0)
      {
        if (++v12 == 8)
          goto LABEL_18;
      }
      if ((_DWORD)v12 == 5)
      {
        v13 = 0;
        if (!v6)
          goto LABEL_21;
        goto LABEL_20;
      }
    }
LABEL_18:
    if ((v10 & 0xC00000000) != 0x400000000)
      return 0;
  }
  v13 = 1;
  if (!v6)
    goto LABEL_21;
LABEL_20:
  if (CFEqual(v6, theDict))
    return 1;
LABEL_21:
  v14 = *v8;
  if (!theDict)
  {
    CFDictionaryRemoveValue(v14, &unk_1EDD003E0);
    SocketStream::removeHandshake_NoLock((uint64_t)this, 6);
    return 1;
  }
  v15 = CFDictionaryGetValue(v14, &unk_1EDCFBDE0);
  if (!v15)
  {
    result = (uint64_t)CFDictionaryGetValue(*v8, &unk_1EDCFBE50);
    if (!result)
      return result;
    result = (uint64_t)CFNetServiceGetInfo(result, 5u);
    if (!result)
      return result;
    goto LABEL_32;
  }
  v16 = (uint64_t)v15;
  Info = (const __CFArray *)CFHostGetInfo((uint64_t)v15, 1, 0);
  if (Info && CFArrayGetCount(Info)
    || (result = (uint64_t)CFHostGetInfo(v16, 0, 0)) != 0 && (result = CFArrayGetCount((CFArrayRef)result)) != 0)
  {
LABEL_32:
    SocketStream::addHandshake_NoLock((uint64_t)this, 6);
    if ((v13 & 1) == 0)
    {
      v19 = CFDictionaryGetValue(*v8, &unk_1EDD00488);
      if (v19)
        CFDictionarySetValue(*v8, &unk_1EDD004F8, v19);
      CFDictionaryRemoveValue(this[42], &unk_1EDD00488);
      SocketStream::removeHandshake_NoLock((uint64_t)this, 5);
    }
    CFDictionarySetValue(*v8, &unk_1EDD003E0, theDict);
    return 1;
  }
  return result;
}

uint64_t SocketStream::_SOCKSSetInfo_NoLock(CFDictionaryRef *this, const __CFDictionary *a2)
{
  const void *Value;
  CFTypeID TypeID;
  uint64_t v6;
  const __CFString *v8;
  const __CFString *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const __CFNumber *v14;
  const void *v15;
  const __CFArray *Info;
  const __CFArray *v17;
  const void *ValueAtIndex;
  const __CFString *v19;
  const __CFArray *v20;
  const __CFArray *v21;
  const __CFData *v22;
  const __CFString *v23;
  const __CFArray *v24;
  const void *v25;
  int v26;
  CFIndex Length;
  int valuePtr;

  Value = CFDictionaryGetValue(this[42], &unk_1EDCFBF30);
  if (a2)
  {
    TypeID = CFDictionaryGetTypeID();
    if (TypeID != CFGetTypeID(a2))
      return 0;
  }
  if (((_DWORD)this[31] & 0x103) != 0)
    return 0;
  if (Value && CFEqual(Value, a2))
    return 1;
  if (!a2)
  {
    CFDictionaryRemoveValue(this[42], &unk_1EDCFBF30);
    SocketStream::removeHandshake_NoLock((uint64_t)this, 4);
    v6 = 1;
    SocketStream::removeHandshake_NoLock((uint64_t)this, 1);
    return v6;
  }
  v8 = (const __CFString *)CFDictionaryGetValue(a2, (const void *)*MEMORY[0x1E0C9B2D8]);
  v9 = (const __CFString *)CFDictionaryGetValue(a2, (const void *)*MEMORY[0x1E0C9B2B8]);
  v10 = CFDictionaryGetValue(a2, (const void *)*MEMORY[0x1E0C9B2E0]);
  v11 = (const void *)*MEMORY[0x1E0C9B318];
  if (v10)
    v12 = v10;
  else
    v12 = (const void *)*MEMORY[0x1E0C9B318];
  v13 = CFDictionaryGetValue(this[42], &unk_1EDCFBDE0);
  v14 = (const __CFNumber *)CFDictionaryGetValue(a2, &unk_1EDCFC5F8);
  valuePtr = 0;
  v15 = (const void *)*MEMORY[0x1E0C9B310];
  if (CFEqual(v12, (CFTypeRef)*MEMORY[0x1E0C9B310]) || CFEqual(v12, v11))
  {
    if (v14 && CFNumberGetValue(v14, kCFNumberSInt32Type, &valuePtr) && !valuePtr)
    {
      CFDictionaryRemoveValue(this[42], &unk_1EDCFBF30);
      return 1;
    }
    if (!v13)
    {
      if (CFDictionaryGetValue(this[42], &unk_1EDCFBE50))
        return 0;
      goto LABEL_33;
    }
    Info = (const __CFArray *)CFHostGetInfo((uint64_t)v13, 1, 0);
    if (Info && (v17 = Info, CFArrayGetCount(Info)))
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v17, 0);
      if (!ValueAtIndex)
        goto LABEL_33;
      v19 = (const __CFString *)CFRetain(ValueAtIndex);
    }
    else
    {
      v20 = (const __CFArray *)CFHostGetInfo((uint64_t)v13, 0, 0);
      if (!v20)
        goto LABEL_33;
      v21 = v20;
      if (!CFArrayGetCount(v20))
        goto LABEL_33;
      CFGetAllocator(v21);
      v22 = (const __CFData *)CFArrayGetValueAtIndex(v21, 0);
      v19 = _CFNetworkCFStringCreateWithCFDataAddress(v22);
    }
    v23 = v19;
    if (v19)
    {
      Length = CFStringGetLength(v19);
      v24 = (const __CFArray *)CFDictionaryGetValue(a2, &unk_1EDCFB408);
      v25 = CFDictionaryGetValue(a2, &unk_1EDCFB440);
      LODWORD(v24) = _CFNetworkDoesNeedProxy(v23, v24, v25);
      CFRelease(v23);
      if (!(_DWORD)v24 || CFEqual(v12, v11) && (unint64_t)(Length - 256) < 0xFFFFFFFFFFFFFF01)
        return 0;
LABEL_34:
      if ((!CFEqual(v12, v11) || !v9 || CFStringGetLength(v9) <= 255)
        && (!v8
         || (!CFEqual(v12, v15) || CFStringGetLength(v8) <= 512) && (!CFEqual(v12, v11) || CFStringGetLength(v8) < 256)))
      {
        if (CFEqual(v12, v15))
          v26 = 4;
        else
          v26 = 1;
        SocketStream::addHandshake_NoLock((uint64_t)this, v26);
        CFDictionarySetValue(this[42], &unk_1EDCFBF30, a2);
        return 1;
      }
      return 0;
    }
LABEL_33:
    if (!CFEqual(v12, v15))
      return 0;
    goto LABEL_34;
  }
  return 0;
}

uint64_t _CFSocketSetTrafficMgtBackground(__CFSocket *a1, int a2)
{
  CFSocketNativeHandle Native;
  _BOOL4 v4;

  v4 = a2 != 0;
  Native = CFSocketGetNative(a1);
  return setsockopt(Native, 0xFFFF, 4357, &v4, 4u);
}

uint64_t SocketStream::updateExcessiveKeepalivesParameters(uint64_t this, CFTypeRef cf)
{
  CFTypeID v3;
  const __CFBoolean *Value;
  const __CFNumber *v5;
  const __CFNumber *v6;
  uint64_t valuePtr;

  if (*(_QWORD *)(this + 560))
  {
    valuePtr = 0;
    if (cf)
    {
      v3 = CFGetTypeID(cf);
      if (v3 == CFDictionaryGetTypeID())
      {
        Value = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("_kExcessiveKeepalivesParametersEnabled"));
        if (Value)
          CFBooleanGetValue(Value);
        v5 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("_kExcessiveKeepalivesParametersInterval"));
        if (v5)
          CFNumberGetValue(v5, kCFNumberSInt32Type, (char *)&valuePtr + 4);
        v6 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("_kExcessiveKeepalivesParametersCount"));
        if (v6)
          CFNumberGetValue(v6, kCFNumberSInt32Type, &valuePtr);
      }
    }
    return tcp_connection_add_event_excessive_keepalives();
  }
  return this;
}

uint64_t SocketStream::updateTCPKeepalivesParameters(uint64_t this, CFTypeRef cf)
{
  CFTypeID v3;
  const __CFBoolean *Value;
  const __CFNumber *v5;
  const __CFNumber *v6;
  uint64_t valuePtr;

  if (*(_QWORD *)(this + 560))
  {
    valuePtr = 0;
    if (cf)
    {
      v3 = CFGetTypeID(cf);
      if (v3 == CFDictionaryGetTypeID())
      {
        Value = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("_kTCPKeepAliveParametersEnabled"));
        if (Value)
          CFBooleanGetValue(Value);
        v5 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("_kTCPKeepAliveParametersIdleTime"));
        if (v5)
          CFNumberGetValue(v5, kCFNumberSInt32Type, (char *)&valuePtr + 4);
        v6 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("_kTCPKeepAliveParametersInterval"));
        if (v6)
          CFNumberGetValue(v6, kCFNumberSInt32Type, &valuePtr);
      }
    }
    return tcp_connection_set_keepalive();
  }
  return this;
}

uint64_t SocketStream::updateTCPAdaptiveParamters(SocketStream *this, CFNumberRef number, CFNumberRef a3)
{
  uint64_t result;
  CFNumberRef *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int valuePtr;

  result = *((_QWORD *)this + 70);
  if (result)
  {
    v5 = (CFNumberRef *)MEMORY[0x1E0C9B0D0];
    if (number)
    {
      if ((CFNumberRef)*MEMORY[0x1E0C9B0D0] == number)
      {
        result = tcp_connection_add_event_adaptive_read_timeout();
      }
      else
      {
        valuePtr = 0;
        CFNumberGetValue(number, kCFNumberSInt32Type, &valuePtr);
        tcp_connection_add_event_adaptive_read_timeout();
        result = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_113, 2);
        if (result)
        {
          v6 = result;
          result = (*(uint64_t (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)result + 16))(result, "updateTCPAdaptiveParamters", 0);
          if ((_DWORD)result)
          {
            (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v6 + 72))(v6, "conn", CFSTR("%p"));
            (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v6 + 72))(v6, "read count", CFSTR("%d"));
            result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
          }
        }
      }
    }
    if (a3)
    {
      if (*v5 == a3)
      {
        return tcp_connection_add_event_adaptive_write_timeout();
      }
      else
      {
        v8 = 0;
        CFNumberGetValue(a3, kCFNumberSInt32Type, &v8);
        tcp_connection_add_event_adaptive_write_timeout();
        result = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_116, 2);
        if (result)
        {
          v7 = result;
          result = (*(uint64_t (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)result + 16))(result, "updateTCPAdaptiveParamters", 0);
          if ((_DWORD)result)
          {
            (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v7 + 72))(v7, "conn", CFSTR("%p"));
            (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v7 + 72))(v7, "write count", CFSTR("%d"));
            return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
          }
        }
      }
    }
  }
  return result;
}

void SocketStream::updateTCPConnectionPoolPriority(SocketStream *this, const __CFString *a2, const __CFNumber *a3)
{
  UInt8 *v5;
  uint64_t valuePtr;
  CFAllocatorRef allocator;
  uint64_t v8;
  void *ptr;
  UInt8 v10[1024];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a2 && *((_QWORD *)this + 70))
  {
    allocator = CFGetAllocator((char *)this - 16);
    v8 = 1023;
    v5 = _CFStringGetOrCreateCString(allocator, a2, v10, &v8, 0x8000100u);
    ptr = v5;
    valuePtr = 300;
    if (a3)
      CFNumberGetValue(a3, kCFNumberSInt64Type, &valuePtr);
    if (v5)
      tcp_connection_set_connection_pool();
    if (ptr)
    {
      if (v10 != ptr)
        CFAllocatorDeallocate(allocator, ptr);
    }
  }
}

void sub_184054570(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFAllocatorRef allocator, uint64_t a12, void *ptr)
{
  _Unwind_Resume(exception_object);
}

CFDictionaryRef ___ZN12SocketStream11setPropertyEPKvPK10__CFStringS1__block_invoke(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  return SocketStream::copyProperty_NoLock(*(SocketStream **)(a1 + 32), *(const __CFString **)(*(_QWORD *)(a1 + 48) + 8), a3);
}

CFDictionaryRef SocketStream::copyProperty_NoLock(SocketStream *this, const __CFString *a2, const __CFString *a3)
{
  char *Value;
  CFTypeID v6;
  const __CFAllocator *v7;
  char *v8;
  int ExactString;
  const __CFAllocator *v10;
  sockaddr *v11;
  CFIndex v12;
  const __CFAllocator *v13;
  SSLContext *v14;
  const __CFAllocator *v15;
  void **v16;
  void **v17;
  BOOL v18;
  const __CFAllocator *v19;
  const __CFAllocator *v20;
  const __CFAllocator *v21;
  __CFSocket *v22;
  int is_expensive;
  SSLContext *v24;
  uint64_t RemoteHostName_NoLock;
  int v26;
  const __CFAllocator *v27;
  CFNumberType v28;
  void **v29;
  int v30;
  uint64_t v31;
  void *v32;
  const __CFAllocator *v33;
  size_t count;
  const __CFArray *Mutable;
  void *v36;
  SSLContext *v37;
  __CFSocket *v38;
  unsigned int primary_subflow_ifindex;
  const __CFAllocator *v40;
  sockaddr *p_clientState;
  __CFSocket *v43;
  CFSocketNativeHandle Native;
  int v45;
  uint64_t v46;
  void *v47;
  _QWORD v48[6];
  socklen_t v49;
  unsigned int v50;
  socklen_t v51;
  CFArrayRef names;
  char v53[16];
  sockaddr clientState;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  names = 0;
  Value = (char *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), a2);
  if (Value)
  {
LABEL_2:
    v6 = CFGetTypeID(Value);
    if (HostBase::Class(void)::sOnce_HostBase != -1)
      dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
    if (*(_QWORD *)(HostBase::Class(void)::sClass_OBJTYPE + 96) == v6)
    {
      v7 = CFGetAllocator((char *)this - 16);
      return CFHostCreateCopy(v7, (CFHostRef)Value);
    }
    if (CFNetServiceGetTypeID() == v6)
    {
      v13 = CFGetAllocator((char *)this - 16);
      return CFNetServiceCreateCopy(v13, (CFNetServiceRef)Value);
    }
    if (CFDictionaryGetTypeID() == v6)
    {
      v15 = CFGetAllocator((char *)this - 16);
      return CFDictionaryCreateCopy(v15, (CFDictionaryRef)Value);
    }
    if (CFArrayGetTypeID() == v6)
    {
      v19 = CFGetAllocator((char *)this - 16);
      return CFArrayCreateCopy(v19, (CFArrayRef)Value);
    }
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*(_QWORD *)(HTTPMessage::Class(void)::sClass_OBJTYPE + 96) == v6)
    {
      v21 = CFGetAllocator((char *)this - 16);
      return CFHTTPMessageCreateCopy(v21, (CFHTTPMessageRef)Value);
    }
    v8 = Value;
    return (CFDictionaryRef)CFRetain(v8);
  }
  ExactString = _findExactString(a2, 0);
  if (ExactString <= 198495749)
  {
    if (ExactString <= 131443042)
    {
      if (ExactString <= 99878706)
      {
        if (ExactString <= 85255704)
        {
          if (ExactString != 31695365)
          {
            if (ExactString != 56869868)
              return names;
            v22 = (__CFSocket *)*((_QWORD *)this + 36);
            if (v22 && CFSocketIsValid(v22))
              return CFSocketCopyPeerAddress(*((CFSocketRef *)this + 36));
            return 0;
          }
          v16 = (void **)MEMORY[0x1E0C9AE50];
          v17 = (void **)MEMORY[0x1E0C9AE40];
          v18 = ((*((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) & 0x200000000) == 0;
          goto LABEL_131;
        }
        if (ExactString == 85255705)
        {
LABEL_100:
          if (!*((_QWORD *)this + 70))
            return names;
          is_expensive = tcp_connection_is_expensive();
          goto LABEL_144;
        }
        v26 = 88393301;
      }
      else
      {
        if (ExactString > 124045534)
        {
          if (ExactString == 124045535)
          {
            v8 = (char *)this - 16;
            return (CFDictionaryRef)CFRetain(v8);
          }
          if (ExactString == 129296697)
          {
            if (*((_QWORD *)this + 37))
              SSLGetCertificate();
            return names;
          }
          if (ExactString != 130378061)
            return names;
          v14 = (SSLContext *)*((_QWORD *)this + 37);
          if (!v14)
            return names;
          *(_DWORD *)&clientState.sa_len = 0;
          if (SSLGetClientCertificateState(v14, (SSLClientCertificateState *)&clientState))
            return 0;
LABEL_137:
          v27 = CFGetAllocator((char *)this - 16);
          v28 = kCFNumberIntType;
          return CFNumberCreate(v27, v28, &clientState);
        }
        if (ExactString == 99878707)
        {
          if (!*((_QWORD *)this + 70))
            return names;
          is_expensive = tcp_connection_has_better_route();
LABEL_144:
          v29 = (void **)MEMORY[0x1E0C9AE50];
          if (!is_expensive)
            v29 = (void **)MEMORY[0x1E0C9AE40];
          goto LABEL_154;
        }
        v26 = 100902724;
      }
      if (ExactString == v26)
        return (CFDictionaryRef)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), a2);
      return names;
    }
    if (ExactString <= 161713009)
    {
      if (ExactString <= 140716566)
      {
        if (ExactString != 131443043)
        {
          if (ExactString != 132442490)
            return names;
          v24 = (SSLContext *)*((_QWORD *)this + 37);
          if (!v24 || !SSLCopyDistinguishedNames(v24, &names))
            return names;
          return 0;
        }
        if (!*((_QWORD *)this + 37))
          return names;
        *(_DWORD *)&clientState.sa_len = 0;
        if (SSLGetClientSideAuthenticate())
          *(_DWORD *)&clientState.sa_len = 0;
        goto LABEL_137;
      }
      if (ExactString == 140716567)
      {
        if (!*((_QWORD *)this + 70))
          return names;
        v46 = tcp_connection_copy_tcp_info();
        if (!v46)
          return names;
        v47 = (void *)v46;
        if (MEMORY[0x186DB9C40]() == MEMORY[0x1E0C812F8] && xpc_dictionary_get_count(v47))
          names = (CFArrayRef)_CFXPCCreateCFObjectFromXPCObject();
        v36 = v47;
        goto LABEL_175;
      }
      if (ExactString != 160648036)
        return names;
      v29 = (void **)MEMORY[0x1E0C9AE50];
      v30 = *((unsigned __int8 *)this + 405);
    }
    else
    {
      if (ExactString > 192228738)
      {
        if (ExactString == 192228739)
        {
          Value = (char *)*((_QWORD *)this + 67);
          if (!Value)
            return names;
          goto LABEL_2;
        }
        if (ExactString != 194301361)
        {
          if (ExactString != 197438963)
            return names;
          v16 = (void **)MEMORY[0x1E0C9AE50];
          v17 = (void **)MEMORY[0x1E0C9AE40];
          v18 = (*((_DWORD *)this + 62) & 0x8000000) == 0;
LABEL_131:
          if (v18)
            v29 = v17;
          else
            v29 = v16;
          goto LABEL_154;
        }
        if (!*((_QWORD *)this + 70))
        {
          v29 = (void **)MEMORY[0x1E0C9AE40];
          goto LABEL_154;
        }
        is_expensive = tcp_connection_did_fallback();
        goto LABEL_144;
      }
      if (ExactString != 161713010)
      {
        if (ExactString != 174287922)
          return names;
        RemoteHostName_NoLock = serviceTypeToString(*((_DWORD *)this + 102));
        goto LABEL_104;
      }
      v29 = (void **)MEMORY[0x1E0C9AE50];
      v30 = *((unsigned __int8 *)this + 406);
    }
    if (!v30)
      v29 = (void **)MEMORY[0x1E0C9AE40];
    goto LABEL_154;
  }
  if (ExactString <= 218394490)
  {
    if (ExactString > 209071817)
    {
      if (ExactString > 211103476)
      {
        if (ExactString != 211103477)
        {
          if (ExactString != 212037386)
          {
            if (ExactString != 214216493)
              return names;
            v16 = (void **)MEMORY[0x1E0C9AE50];
            v17 = (void **)MEMORY[0x1E0C9AE40];
            v18 = ((*((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) & 0x100000000) == 0;
            goto LABEL_131;
          }
          v29 = (void **)MEMORY[0x1E0C9AE50];
          if (*((int *)this + 62) >= 0)
            v29 = (void **)MEMORY[0x1E0C9AE40];
LABEL_154:
          Value = (char *)*v29;
          if (!*v29)
            return names;
          goto LABEL_2;
        }
        if (!*((_QWORD *)this + 70))
          return names;
        v31 = tcp_connection_multipath_copy_subflow_switch_counts();
        if (!v31)
          return names;
        v32 = (void *)v31;
        if (MEMORY[0x186DB9C40]() == MEMORY[0x1E0C812F8] && xpc_dictionary_get_count(v32))
        {
          v33 = CFGetAllocator((char *)this - 16);
          count = xpc_dictionary_get_count(v32);
          Mutable = CFDictionaryCreateMutable(v33, count, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          v48[0] = MEMORY[0x1E0C809B0];
          v48[1] = 3221225472;
          v48[2] = ___ZN12SocketStream19copyProperty_NoLockEPKvPK10__CFString_block_invoke;
          v48[3] = &__block_descriptor_48_e37_B24__0r_8__NSObject_OS_xpc_object__16l;
          v48[4] = this;
          v48[5] = Mutable;
          xpc_dictionary_apply(v32, v48);
          names = Mutable;
        }
        v36 = v32;
LABEL_175:
        xpc_release(v36);
        return names;
      }
      if (ExactString != 209071818)
      {
        if (ExactString != 209997539)
          return names;
        *(_QWORD *)&clientState.sa_len = 0;
        if (!*((_QWORD *)this + 70))
          goto LABEL_95;
LABEL_94:
        *(_QWORD *)&clientState.sa_len = tcp_connection_multipath_get_subflow_count();
LABEL_95:
        v27 = CFGetAllocator((char *)this - 16);
        v28 = kCFNumberCFIndexType;
        return CFNumberCreate(v27, v28, &clientState);
      }
      if (!*((_QWORD *)this + 70))
        return names;
      primary_subflow_ifindex = tcp_connection_multipath_get_primary_subflow_ifindex();
      if (!if_indextoname(primary_subflow_ifindex, (char *)&clientState))
        return names;
      v40 = CFGetAllocator((char *)this - 16);
      p_clientState = &clientState;
      return (CFDictionaryRef)CFStringCreateWithCString(v40, (const char *)p_clientState, 0x8000100u);
    }
    if (ExactString > 206868128)
    {
      if (ExactString != 206868129)
      {
        if (ExactString != 207974068)
          return names;
        *(_QWORD *)&clientState.sa_len = 0;
        if (!*((_QWORD *)this + 70))
          goto LABEL_95;
        goto LABEL_94;
      }
      v43 = (__CFSocket *)*((_QWORD *)this + 36);
      if (!v43)
        return names;
      if (!CFSocketIsValid(v43))
        return names;
      Native = CFSocketGetNative(*((CFSocketRef *)this + 36));
      v51 = 128;
      if (getsockname(Native, &clientState, &v51))
        return names;
      v49 = 4;
      v50 = 0;
      v45 = clientState.sa_family == 30 ? 41 : 0;
      if (getsockopt(Native, v45, 9696, &v50, &v49) || !if_indextoname(v50, v53))
        return names;
      v40 = CFGetAllocator((char *)this - 16);
      p_clientState = (sockaddr *)v53;
      return (CFDictionaryRef)CFStringCreateWithCString(v40, (const char *)p_clientState, 0x8000100u);
    }
    if (ExactString != 198495750)
    {
      if (ExactString != 199544346 || !*((_QWORD *)this + 70))
        return names;
      is_expensive = tcp_connection_is_multipath();
      goto LABEL_144;
    }
    goto LABEL_100;
  }
  if (ExactString > 228814902)
  {
    if (ExactString <= 230928471)
    {
      if (ExactString == 228814903)
      {
        v8 = (char *)*((_QWORD *)this + 37);
        if (!v8)
          return (CFDictionaryRef)v8;
        return (CFDictionaryRef)CFRetain(v8);
      }
      if (ExactString != 229937221 || !*((_QWORD *)this + 37) || !_SSLCopyPeerCertificates())
        return names;
    }
    else
    {
      if (ExactString != 230928472)
      {
        if (ExactString == 233173110)
        {
          if (*((_QWORD *)this + 37))
          {
            *(_QWORD *)&clientState.sa_len = 0;
            *(_QWORD *)v53 = 0;
            if (!_SSLGetDiffieHellmanParams())
            {
              v10 = CFGetAllocator((char *)this - 16);
              v11 = 0;
              v12 = *(_QWORD *)v53;
              return CFDataCreate(v10, &v11->sa_len, v12);
            }
          }
        }
        else if (ExactString == 558111814 && CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDD003E0))
        {
          v20 = CFGetAllocator((char *)this - 16);
          return CFHTTPMessageCreateEmpty(v20, 0);
        }
        return names;
      }
      v37 = (SSLContext *)*((_QWORD *)this + 37);
      if (!v37 || !SocketStream::_copyPeerTrustWithPinning_NoLock((CFDictionaryRef *)this, v37, &names))
        return names;
    }
    if (!names)
      return names;
    CFRelease(names);
    return 0;
  }
  if (ExactString <= 222621636)
  {
    if (ExactString == 218394491)
    {
      v38 = (__CFSocket *)*((_QWORD *)this + 36);
      if (v38 && CFSocketIsValid(v38))
      {
        *(_DWORD *)&clientState.sa_len = CFSocketGetNative(*((CFSocketRef *)this + 36));
        v10 = CFGetAllocator((char *)this - 16);
        v11 = &clientState;
        v12 = 4;
        return CFDataCreate(v10, &v11->sa_len, v12);
      }
      return names;
    }
    if (ExactString != 220508062)
      return names;
    RemoteHostName_NoLock = (uint64_t)SocketStream::getRemoteHostName_NoLock((CFDictionaryRef *)this);
LABEL_104:
    Value = (char *)RemoteHostName_NoLock;
    if (!RemoteHostName_NoLock)
      return names;
    goto LABEL_2;
  }
  switch(ExactString)
  {
    case 222621637:
      RemoteHostName_NoLock = (uint64_t)SocketStream::getRemoteHostPort_NoLock((CFDictionaryRef *)this);
      goto LABEL_104;
    case 223645657:
      RemoteHostName_NoLock = (uint64_t)SocketStream::securityGetProtocol(this);
      goto LABEL_104;
    case 224669676:
      if (*((_QWORD *)this + 37))
      {
        v10 = CFGetAllocator((char *)this - 16);
        v11 = (sockaddr *)((char *)this + 296);
        v12 = 8;
        return CFDataCreate(v10, &v11->sa_len, v12);
      }
      return 0;
  }
  return names;
}

const void *SocketStream::getRemoteHostName_NoLock(CFDictionaryRef *this)
{
  const void *Value;
  const __CFArray *Info;
  const __CFArray *v4;
  const void *v6;

  Value = CFDictionaryGetValue(this[42], &unk_1EDCFBDE0);
  if (Value)
  {
    Info = (const __CFArray *)CFHostGetInfo((uint64_t)Value, 1, 0);
    if (Info)
    {
      v4 = Info;
      if (CFArrayGetCount(Info))
        return CFArrayGetValueAtIndex(v4, 0);
    }
  }
  else
  {
    v6 = CFDictionaryGetValue(this[42], &unk_1EDCFBE50);
    if (v6)
      return CFNetServiceGetInfo((uint64_t)v6, 5u);
  }
  return 0;
}

const __CFArray *SocketStream::getRemoteHostPort_NoLock(CFDictionaryRef *this)
{
  const void *Value;
  const __CFArray *Info;
  const __CFArray *v4;
  const __CFData *ValueAtIndex;
  const UInt8 *BytePtr;
  int v7;
  const __CFAllocator *v8;
  unsigned int *p_valuePtr;
  _DWORD *v10;
  int valuePtr;
  unsigned int v13;

  Value = CFDictionaryGetValue(this[42], &unk_1EDCFBDE0);
  if (!Value)
  {
    v10 = CFDictionaryGetValue(this[42], &unk_1EDCFBE50);
    if (v10)
    {
      valuePtr = v10[14];
      v8 = CFGetAllocator(this - 2);
      p_valuePtr = (unsigned int *)&valuePtr;
      goto LABEL_9;
    }
    return 0;
  }
  Info = (const __CFArray *)CFHostGetInfo((uint64_t)Value, 0, 0);
  v4 = Info;
  if (!Info)
    return v4;
  if (!CFArrayGetCount(Info))
    return 0;
  ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v4, 0);
  BytePtr = CFDataGetBytePtr(ValueAtIndex);
  v7 = BytePtr[1];
  if (v7 != 30)
  {
    v4 = 0;
    if (v7 != 2)
      return v4;
  }
  v13 = bswap32(*((unsigned __int16 *)BytePtr + 1)) >> 16;
  v8 = CFGetAllocator(this - 2);
  p_valuePtr = &v13;
LABEL_9:
  v4 = CFNumberCreate(v8, kCFNumberSInt32Type, p_valuePtr);
  if (v4)
  {
    CFDictionarySetValue(this[42], &unk_1EDCFBE88, v4);
    CFRelease(v4);
  }
  return v4;
}

SSLContext *SocketStream::securityGetProtocol(SocketStream *this)
{
  SSLContext *result;
  SSLProtocol v3;
  CFStringRef *v4;
  SSLProtocol maxVersion;
  SSLProtocol protocol[2];

  result = (SSLContext *)*((_QWORD *)this + 37);
  if (result)
  {
    *(_QWORD *)protocol = 0;
    maxVersion = kSSLProtocolUnknown;
    SSLGetNegotiatedProtocolVersion(result, &protocol[1]);
    SSLGetProtocolVersionMin(*((SSLContextRef *)this + 37), protocol);
    SSLGetProtocolVersionMax(*((SSLContextRef *)this + 37), &maxVersion);
    if (protocol[1] == kSSLProtocol3)
    {
      v3 = maxVersion;
    }
    else
    {
      if (protocol[1] == kSSLProtocol2)
      {
LABEL_6:
        v4 = &kCFStreamSocketSecurityLevelSSLv2;
        return (SSLContext *)*v4;
      }
      if (protocol[1])
      {
LABEL_10:
        if (protocol[0] == kSSLProtocol2)
          v4 = &kCFStreamSocketSecurityLevelNegotiatedSSL;
        else
          v4 = &kCFStreamSocketSecurityLevelTLSv1;
        return (SSLContext *)*v4;
      }
      v3 = maxVersion;
      if (maxVersion == kSSLProtocol2)
        goto LABEL_6;
    }
    if (v3 == kSSLProtocol3)
    {
      v4 = &kCFStreamSocketSecurityLevelSSLv3;
      return (SSLContext *)*v4;
    }
    goto LABEL_10;
  }
  return result;
}

uint64_t ___ZN12SocketStream19copyProperty_NoLockEPKvPK10__CFString_block_invoke(uint64_t a1, const char *a2, void *a3)
{
  const void *v6;
  const __CFAllocator *v7;
  CFStringRef v8;
  const __CFAllocator *v9;
  CFNumberRef v10;
  uint64_t valuePtr;

  v6 = (const void *)(*(_QWORD *)(a1 + 32) - 16);
  v7 = CFGetAllocator(v6);
  v8 = CFStringCreateWithCString(v7, a2, 0x8000100u);
  valuePtr = xpc_uint64_get_value(a3);
  v9 = CFGetAllocator(v6);
  v10 = CFNumberCreate(v9, kCFNumberCFIndexType, &valuePtr);
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 40), v8, v10);
  if (v8)
    CFRelease(v8);
  if (v10)
    CFRelease(v10);
  return 1;
}

uint64_t ___ZN12SocketStream26updateTCPAdaptiveParamtersEPK10__CFNumberS2__block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 5943;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream26updateTCPAdaptiveParamtersEPK10__CFNumberS2__block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 5929;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void SocketStream::_SecurityNPNFunc(SocketStream *this, SSLContext *a2, const UInt8 *a3, unint64_t a4)
{
  char *v7;
  const __CFDictionary *v8;
  const __CFArray *Value;
  const __CFArray *v10;
  CFIndex Count;
  uint64_t v12;
  unint64_t v13;
  CFIndex v14;
  CFStringRef v15;
  CFIndex v16;
  const __CFString *ValueAtIndex;
  CFIndex Length;
  char v19;
  CFStringRef v20;
  CFStringRef v21;
  __CFDictionary *theDict;
  char *v23;
  const __CFAllocator *alloc;
  _QWORD v26[2];
  BOOL (*v27)();
  void *v28;
  SocketStream *v29;
  uint64_t v30;
  char v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v7 = (char *)a2 - 16;
  CFRetain((char *)a2 - 16);
  v8 = (const __CFDictionary *)*((_QWORD *)a2 + 42);
  v26[0] = MEMORY[0x1E0C809B0];
  v26[1] = 3221225472;
  v27 = ___ZN12SocketStream16_SecurityNPNFuncEP10SSLContextPvPKvm_block_invoke;
  v28 = &__block_descriptor_40_e12_B24__0r_8Q16l;
  v29 = this;
  v30 = 0x2E312F7074746808;
  v31 = 49;
  Value = (const __CFArray *)CFDictionaryGetValue(v8, &unk_1EDCFA6E8);
  if (Value)
  {
    v10 = Value;
    Count = CFArrayGetCount(Value);
    alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (a4)
    {
      v12 = Count;
      theDict = v8;
      v23 = v7;
      v13 = 0;
      while (1)
      {
        v14 = a3[v13];
        v15 = CFStringCreateWithBytes(alloc, &a3[v13 + 1], v14, 0x8000100u, 0);
        if (v12 < 1)
        {
LABEL_9:
          CFRelease(v15);
        }
        else
        {
          v16 = 0;
          while (1)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v10, v16);
            Length = CFStringGetLength(v15);
            if (Length == CFStringGetLength(ValueAtIndex)
              && CFStringCompare(v15, ValueAtIndex, 1uLL) == kCFCompareEqualTo)
            {
              break;
            }
            if (v12 == ++v16)
              goto LABEL_9;
          }
          v19 = ((uint64_t (*)(_QWORD *, const UInt8 *, CFIndex))v27)(v26, &a3[v13 + 1], v14);
          CFRelease(v15);
          if ((v19 & 1) != 0)
          {
            CFDictionarySetValue(theDict, &unk_1EDCFA720, ValueAtIndex);
            v7 = v23;
            goto LABEL_19;
          }
        }
        v13 += v14 + 1;
        if (v13 >= a4)
        {
          v8 = theDict;
          v7 = v23;
          ((void (*)(_QWORD *, uint64_t *, uint64_t))v27)(v26, &v30, 9);
          goto LABEL_15;
        }
      }
    }
    ((void (*)(_QWORD *, uint64_t *, uint64_t))___ZN12SocketStream16_SecurityNPNFuncEP10SSLContextPvPKvm_block_invoke)(v26, &v30, 9);
LABEL_15:
    v20 = CFStringCreateWithBytes(alloc, (const UInt8 *)&v30 + 1, 8, 0x8000100u, 0);
    if (v20)
    {
      v21 = v20;
      CFDictionarySetValue(v8, &unk_1EDCFA720, v20);
      CFRelease(v21);
    }
    else
    {
      CFDictionarySetValue(v8, &unk_1EDCFA720, &stru_1E1500C68);
    }
  }
  else
  {
    ___ZN12SocketStream16_SecurityNPNFuncEP10SSLContextPvPKvm_block_invoke();
  }
LABEL_19:
  CFRelease(v7);
}

void SocketStream::_SecurityALPNFunc(SocketStream *this, CFMutableDictionaryRef *a2, const UInt8 *a3, const void *a4)
{
  CFMutableDictionaryRef *v6;
  CFStringRef v7;

  v6 = a2 - 2;
  CFRetain(a2 - 2);
  if (a3)
  {
    v7 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a3 + 1, *(char *)a3, 0x600u, 0);
    CFDictionarySetValue(a2[42], &unk_1EDCFA720, v7);
    CFRelease(v7);
  }
  else
  {
    CFDictionarySetValue(a2[42], &unk_1EDCFA720, &stru_1E1500C68);
  }
  CFRelease(v6);
}

BOOL ___ZN12SocketStream16_SecurityNPNFuncEP10SSLContextPvPKvm_block_invoke()
{
  return SSLSetNPNData() == 0;
}

void CFBufferConstantSize<32768l>::~CFBufferConstantSize(CFAllocatorRef *ptr)
{
  CFAllocatorDeallocate(ptr[1], ptr);
}

uint64_t setTLSMaxVersion_ifNeeded(CFStringRef theString2, SSLContext *a2, const __CFNumber *a3, SSLProtocol a4)
{
  if (a3 || CFStringCompare((CFStringRef)*MEMORY[0x1E0CD6870], theString2, 0))
    return 0;
  else
    return SSLSetProtocolVersionMax(a2, a4);
}

void ___ZN12SocketStream5closeEPKv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  double v2;
  NSObject *v3;
  NSObject *v4;

  v1 = *(_QWORD *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 40));
  if (*(_BYTE *)(v1 + 544))
  {
    *(_BYTE *)(v1 + 544) = 0;
    CFRelease((CFTypeRef)(v1 - 16));
  }
  if (*(_BYTE *)(v1 + 644))
  {
    *(_BYTE *)(v1 + 644) = 0;
    entr_act_end_delayInitStub(v2);
  }
  v3 = *(NSObject **)(v1 + 384);
  if (v3)
  {
    dispatch_source_cancel(v3);
    dispatch_release(*(dispatch_object_t *)(v1 + 384));
    *(_QWORD *)(v1 + 384) = 0;
  }
  v4 = *(NSObject **)(v1 + 392);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*(dispatch_object_t *)(v1 + 392));
    *(_QWORD *)(v1 + 392) = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 40));
  CFRelease((CFTypeRef)(v1 - 16));
}

void SocketStream::setLoggerPrefixWithNativeHandle(SocketStream *this, uint64_t a2)
{
  char *v4;
  const __CFAllocator *v5;
  const __CFAllocator *v6;
  const char *v7;
  uint64_t v8;
  const char *CString;
  const char *v10;
  char v11;
  _QWORD v12[19];
  _QWORD v13[20];

  v13[19] = *MEMORY[0x1E0C80C00];
  v4 = (char *)this - 16;
  v5 = CFGetAllocator((char *)this - 16);
  v13[0] = &off_1E14E4818;
  v13[1] = createStringFromSomeAddr(v5, (int (*)(int, sockaddr *, unsigned int *))MEMORY[0x1E0C83810], "local", a2);
  v13[2] = 0;
  v13[3] = 0;
  v6 = CFGetAllocator(v4);
  v12[0] = &off_1E14E4818;
  v12[1] = createStringFromSomeAddr(v6, (int (*)(int, sockaddr *, unsigned int *))MEMORY[0x1E0C83748], "peer", a2);
  v12[2] = 0;
  v12[3] = 0;
  if (*((_QWORD *)this + 70))
  {
    v7 = &v11;
    tcp_connection_get_hostname();
  }
  else
  {
    v7 = "";
  }
  v8 = *((_QWORD *)this + 27);
  CString = (const char *)AutoString::getCString((AutoString *)v13);
  v10 = (const char *)AutoString::getCString((AutoString *)v12);
  *(_DWORD *)(v8 + 8) = a2;
  snprintf((char *)(v8 + 12), 0x100uLL, "{ fd: %d, local %s => peer %s %s}", a2, CString, v10, v7);
  AutoString::~AutoString((AutoString *)v12);
  AutoString::~AutoString((AutoString *)v13);
}

void sub_184055914(_Unwind_Exception *a1)
{
  uint64_t v1;

  AutoString::~AutoString((AutoString *)(v1 - 208));
  _Unwind_Resume(a1);
}

void ___ZN9TCFObjectI12SocketStreamE5ClassEv_block_invoke_5709()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  dword_1EDD01068 = 1835099506;
  _PNAME<SocketStream>::GET(void)::p = *(_QWORD *)"SocketStream>::GET() [OBJTYPE = SocketStream]";
  CFClass::CFClass(v0, (const char *)&_PNAME<SocketStream>::GET(void)::p);
  TCFObject<SocketStream>::Class(void)::clazz = (uint64_t)v0;
}

void sub_18405599C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke(uint64_t a1)
{
  dispatch_queue_t result;

  result = dispatch_queue_create("shared_tcpConnWorkQueue_UserInteractive", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUserInteractiveTCPConnWorkQueue = (uint64_t)result;
  return result;
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_2(uint64_t a1)
{
  dispatch_queue_t result;

  result = dispatch_queue_create("shared_tcpConnWorkQueue_UserInitiated", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUserInitiatedTCPConnWorkQueue = (uint64_t)result;
  return result;
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_3(uint64_t a1)
{
  dispatch_queue_t result;

  result = dispatch_queue_create("shared_tcpConnWorkQueue_Default", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sDefaultTCPConnWorkQueue = (uint64_t)result;
  return result;
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_4(uint64_t a1)
{
  dispatch_queue_t result;

  result = dispatch_queue_create("shared_tcpConnWorkQueue_Utility", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUtilityTCPConnWorkQueue = (uint64_t)result;
  return result;
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_5(uint64_t a1)
{
  dispatch_queue_t result;

  result = dispatch_queue_create("shared_tcpConnWorkQueue_Background", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sBackgroundTCPConnWorkQueue = (uint64_t)result;
  return result;
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_6(uint64_t a1)
{
  dispatch_queue_t result;

  result = dispatch_queue_create("shared_tcpConnWorkQueue_Unspecified", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUnspecifiedTCPConnWorkQueue = (uint64_t)result;
  return result;
}

void ___ZN12SocketStream25startLookupForOpen_NoLockEv_block_invoke(uint64_t a1)
{
  SocketStream *v1;

  v1 = *(SocketStream **)(a1 + 32);
  SocketStream::_onqueue_completeTCPConnection(v1);
  CFRelease((char *)v1 - 16);
}

uint64_t SocketStream::startTCPConnection_Proxy_Connect(SocketStream *this, const __CFDictionary *a2)
{
  const __CFAllocator *v4;
  const __CFString *Value;
  __CFHost *v6;
  const __CFNumber *v7;
  uint64_t started;

  v4 = CFGetAllocator((char *)this - 16);
  Value = (const __CFString *)CFDictionaryGetValue(a2, &unk_1EDD00418);
  v6 = CFHostCreateWithName(v4, Value);
  v7 = (const __CFNumber *)CFDictionaryGetValue(a2, &unk_1EDD00450);
  if (v6)
  {
    started = SocketStream::startTCPConnection_Host(this, v6, v7);
    CFRelease(v6);
    return started;
  }
  else
  {
    *((_QWORD *)this + 32) = 1;
    *((_DWORD *)this + 66) = 22;
    return 0;
  }
}

uint64_t SocketStream::startTCPConnection_NetService(SocketStream *this, __CFNetService *a2)
{
  const __CFString *Info;
  const __CFString *v5;
  const __CFString *v6;
  const __CFString *v7;
  uint64_t v8;
  uint64_t v9;
  const __CFBoolean *v10;
  const __CFBoolean *v11;
  const __CFArray *v12;
  const __CFArray *v13;
  const __CFData *ValueAtIndex;
  uint64_t v15;
  uint64_t v16;
  const __CFAllocator *allocator;
  uint64_t v19;
  void *ptr;
  UInt8 v21[1024];
  CFAllocatorRef v22;
  uint64_t v23;
  void *v24;
  UInt8 v25[1024];
  CFAllocatorRef v26;
  uint64_t v27;
  void *v28;
  UInt8 v29[1024];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  Info = (const __CFString *)CFNetServiceGetInfo((uint64_t)a2, 2u);
  v5 = (const __CFString *)CFNetServiceGetInfo((uint64_t)a2, 4u);
  v6 = (const __CFString *)CFNetServiceGetInfo((uint64_t)a2, 0);
  if (Info && v5 && (v7 = v6) != 0)
  {
    v26 = CFGetAllocator((char *)this - 16);
    v27 = 1023;
    v28 = _CFStringGetOrCreateCString(v26, Info, v29, &v27, 0x8000100u);
    v22 = CFGetAllocator((char *)this - 16);
    v23 = 1023;
    v24 = _CFStringGetOrCreateCString(v22, v5, v25, &v23, 0x8000100u);
    allocator = CFGetAllocator((char *)this - 16);
    v19 = 1023;
    ptr = _CFStringGetOrCreateCString(allocator, v7, v21, &v19, 0x8000100u);
    *((_QWORD *)this + 70) = tcp_connection_create_with_service();
    v8 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_100, 2);
    v9 = v8;
    if (v8
      && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v8 + 16))(v8, "TCP Connection Created", 0))
    {
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v9 + 72))(v9, "conn", CFSTR("%p for netservice %s %s %s"));
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
    }
    if (*((_QWORD *)this + 70))
    {
      v10 = (const __CFBoolean *)CFNetServiceGetInfo((uint64_t)a2, 7u);
      if (v10 && CFBooleanGetValue(v10))
        tcp_connection_override_obscure();
      v11 = (const __CFBoolean *)CFNetServiceGetInfo((uint64_t)a2, 9u);
      if (v11 && CFBooleanGetValue(v11))
        tcp_connection_override_obscure();
    }
    else
    {
      *((_QWORD *)this + 32) = 10;
      *((_DWORD *)this + 66) = -72004;
    }
    if (ptr && v21 != ptr)
      CFAllocatorDeallocate(allocator, ptr);
    if (v24 && v25 != v24)
      CFAllocatorDeallocate(v22, v24);
    if (v28 && v29 != v28)
      CFAllocatorDeallocate(v26, v28);
  }
  else
  {
    v12 = (const __CFArray *)CFNetServiceGetInfo((uint64_t)a2, 3u);
    if (!v12)
      goto LABEL_21;
    v13 = v12;
    if (CFArrayGetCount(v12) < 1)
      goto LABEL_21;
    ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v13, 0);
    if (!ValueAtIndex)
      goto LABEL_21;
    CFDataGetBytePtr(ValueAtIndex);
    *((_QWORD *)this + 70) = tcp_connection_create_with_sockaddr();
    v15 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_103, 2);
    if (v15)
    {
      v16 = v15;
      if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v15 + 16))(v15, "TCP Connection Created", 0))
      {
        (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v16 + 72))(v16, "conn", CFSTR("%p for sockaddr %@"));
        (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
      }
    }
    if (!*((_QWORD *)this + 70))
    {
LABEL_21:
      *((_QWORD *)this + 32) = 10;
      *((_DWORD *)this + 66) = -72004;
    }
  }
  if (!*((_QWORD *)this + 70))
    return 0;
  SocketStream::startTCPConnection(this);
  return 1;
}

void sub_184055F0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const __CFAllocator *allocator, uint64_t a14, void *ptr)
{
  void *v15;
  void *v16;
  void *v17;
  void *v19;
  void *v20;

  if (ptr && v17 != ptr)
    CFAllocatorDeallocate(allocator, ptr);
  v19 = (void *)STACK[0x448];
  if (STACK[0x448] && v16 != v19)
    CFAllocatorDeallocate((CFAllocatorRef)STACK[0x438], v19);
  v20 = (void *)STACK[0x860];
  if (STACK[0x860])
  {
    if (v15 != v20)
      CFAllocatorDeallocate((CFAllocatorRef)STACK[0x850], v20);
  }
  _Unwind_Resume(a1);
}

uint64_t ___ZN12SocketStream29startTCPConnection_NetServiceEP14__CFNetService_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 4552;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream29startTCPConnection_NetServiceEP14__CFNetService_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 4529;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream23startTCPConnection_HostEP8__CFHostPK10__CFNumber_block_invoke_3@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 4489;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream23startTCPConnection_HostEP8__CFHostPK10__CFNumber_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 4474;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream23startTCPConnection_HostEP8__CFHostPK10__CFNumber_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 4470;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void SocketStream::_SocksHostCallBack(SocketStream *this, __CFHost *a2, const __CFString *a3, char *cf, void *a5)
{
  pthread_mutex_t *v8;
  const __CFDictionary *Value;
  const __CFString *v10;
  uint64_t v11;
  const __CFArray *Info;
  const __CFArray *v13;
  const __CFString *ValueAtIndex;
  CFIndex Bytes;
  CFIndex v16;
  const __CFArray *v17;
  const __CFAllocator *v18;
  __CFData *Mutable;
  __CFData *v20;
  UInt8 *MutableBytePtr;
  size_t Length;
  unsigned int v23;
  uint64_t v24;
  CFIndex Count;
  CFIndex v26;
  const __CFData *v27;
  const UInt8 *BytePtr;
  int v29;
  id WeakRetained;
  id v31;
  const __CFNumber *number;
  unsigned int valuePtr;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  CFRange v37;
  CFRange v38;
  CFRange v39;
  CFRange v40;

  v36 = *MEMORY[0x1E0C80C00];
  if (cf)
  {
    if (TCFObject<SocketStream>::Class(void)::sOnce != -1)
      dispatch_once(&TCFObject<SocketStream>::Class(void)::sOnce, &__block_literal_global_233);
    CFRetain(cf);
    if (a2 != (__CFHost *)&unk_1EDCFF6C0)
      goto LABEL_5;
    v8 = (pthread_mutex_t *)(cf + 56);
    pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
    Value = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)cf + 44), &unk_1EDCFBF30);
    v10 = (const __CFString *)CFDictionaryGetValue(Value, (const void *)*MEMORY[0x1E0C9B2D8]);
    number = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)cf + 44), &unk_1EDCFBE88);
    Schedulables::_remove(*((Schedulables **)cf + 43), this);
    _CFTypeInvalidate((char *)this);
    v11 = 0;
    v34 = *((_OWORD *)cf + 20);
    v35 = *((_QWORD *)cf + 42);
    do
    {
      _CFTypeUnscheduleFromMultipleRunLoops(this, *(const __CFArray **)((char *)&v34 + v11));
      v11 += 8;
    }
    while (v11 != 24);
    Info = (const __CFArray *)CFHostGetInfo((uint64_t)this, 0, 0);
    v13 = Info;
    if (Info && CFArrayGetCount(Info))
    {
      ValueAtIndex = 0;
      if (!v10)
        goto LABEL_12;
    }
    else
    {
      v17 = (const __CFArray *)CFHostGetInfo((uint64_t)this, 1, 0);
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v17, 0);
      if (!v10)
      {
LABEL_12:
        Bytes = 0;
        if (!ValueAtIndex)
        {
LABEL_13:
          v16 = 0;
          goto LABEL_17;
        }
LABEL_16:
        v38.length = CFStringGetLength(ValueAtIndex);
        v38.location = 0;
        v16 = CFStringGetBytes(ValueAtIndex, v38, 0x8000100u, 0, 0, 0, 0, 0) + 1;
LABEL_17:
        v18 = CFGetAllocator(cf);
        Mutable = CFDataCreateMutable(v18, Bytes + v16 + 9);
        if (!Mutable)
        {
          *((_QWORD *)cf + 34) = 1;
          *((_DWORD *)cf + 70) = 12;
          goto LABEL_42;
        }
        v20 = Mutable;
        CFDataSetLength(Mutable, Bytes + v16 + 9);
        CFDictionaryAddValue(*((CFMutableDictionaryRef *)cf + 44), &unk_1EDCFAAA0, v20);
        CFRelease(v20);
        MutableBytePtr = CFDataGetMutableBytePtr(v20);
        Length = CFDataGetLength(v20);
        bzero(MutableBytePtr, Length);
        if (ValueAtIndex)
        {
          v39.length = CFStringGetLength(ValueAtIndex);
          v39.location = 0;
          CFStringGetBytes(ValueAtIndex, v39, 0x8000100u, 0, 0, &MutableBytePtr[Bytes + 9], v16, 0);
          MutableBytePtr[Bytes + 8 + v16] = 0;
          MutableBytePtr[7] = 16;
        }
        else
        {
          Count = CFArrayGetCount(v13);
          if (Count < 1)
          {
            v26 = 0;
          }
          else
          {
            v26 = 0;
            while (1)
            {
              v27 = (const __CFData *)CFArrayGetValueAtIndex(v13, v26);
              BytePtr = CFDataGetBytePtr(v27);
              if (BytePtr[1] == 2)
                break;
              if (Count == ++v26)
                goto LABEL_41;
            }
            *((_DWORD *)MutableBytePtr + 1) = *((_DWORD *)BytePtr + 1);
            if (!number)
              *((_WORD *)MutableBytePtr + 1) = *((_WORD *)BytePtr + 1);
          }
          if (v26 == Count)
            goto LABEL_41;
        }
        *(_WORD *)MutableBytePtr = 260;
        if (!number)
          goto LABEL_23;
        valuePtr = 0;
        CFNumberGetValue(number, kCFNumberSInt32Type, &valuePtr);
        if (!HIWORD(valuePtr))
        {
          *((_WORD *)MutableBytePtr + 1) = bswap32(valuePtr) >> 16;
LABEL_23:
          if (v10)
          {
            v40.length = CFStringGetLength(v10);
            v40.location = 0;
            CFStringGetBytes(v10, v40, 0x8000100u, 0, 0, MutableBytePtr + 8, Bytes, 0);
          }
          v8 = (pthread_mutex_t *)(cf + 56);
          if ((*((_DWORD *)cf + 66) & 2) != 0)
          {
            v23 = *((_DWORD *)cf + 107);
            if (v23)
            {
              v24 = 0;
              while (((v23 >> v24) & 1) == 0)
              {
                if (++v24 == 8)
                  goto LABEL_42;
              }
              if ((_DWORD)v24 == 4)
                SocketStream::_PerformSOCKSv4Handshake_NoLock((CFDictionaryRef *)cf + 2);
            }
          }
LABEL_42:
          CFHostCancelInfoResolution(this, kCFHostAddresses);
          if (!*((_DWORD *)cf + 70))
          {
            pthread_mutex_unlock(v8);
LABEL_5:
            CFRelease(cf);
            return;
          }
          v29 = *((_DWORD *)cf + 66);
          *((_DWORD *)cf + 66) = v29 & 0xFFFFFFEC | 2;
          v34 = *((_OWORD *)cf + 17);
          if ((v29 & 0x200) != 0)
          {
            WeakRetained = objc_loadWeakRetained((id *)cf + 36);
            if ((*((_DWORD *)cf + 66) & 0x400) != 0)
              goto LABEL_45;
          }
          else
          {
            WeakRetained = 0;
            if ((v29 & 0x400) != 0)
            {
LABEL_45:
              v31 = objc_loadWeakRetained((id *)cf + 37);
LABEL_49:
              pthread_mutex_unlock(v8);
              if (WeakRetained)
              {
                CFReadStreamSignalEvent();
                CFRelease(WeakRetained);
              }
              if (v31)
              {
                CFWriteStreamSignalEvent();
                CFRelease(v31);
              }
              goto LABEL_5;
            }
          }
          v31 = 0;
          goto LABEL_49;
        }
LABEL_41:
        *((_QWORD *)cf + 34) = 1;
        *((_DWORD *)cf + 70) = 22;
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)cf + 44), &unk_1EDCFAAA0);
        v8 = (pthread_mutex_t *)(cf + 56);
        goto LABEL_42;
      }
    }
    v37.length = CFStringGetLength(v10);
    v37.location = 0;
    Bytes = CFStringGetBytes(v10, v37, 0x8000100u, 0, 0, 0, 0, 0);
    if (!ValueAtIndex)
      goto LABEL_13;
    goto LABEL_16;
  }
}

void ___ZN12SocketStream30_onqueue_completeTCPConnectionEv_block_invoke(uint64_t a1, NSObject *a2, const void *a3, char a4)
{
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  _QWORD block[8];
  char v12;

  v8 = *(_QWORD *)(a1 + 48);
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 56) + 24))(*(_QWORD *)(a1 + 56));
  if (a2)
    dispatch_retain(a2);
  if (a3)
    CFRetain(a3);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN12SocketStream30_onqueue_completeTCPConnectionEv_block_invoke_2;
  block[3] = &unk_1E14F9380;
  block[6] = v8;
  block[7] = a3;
  v12 = a4;
  v9 = *(NSObject **)(a1 + 32);
  v10 = *(_QWORD *)(a1 + 40);
  block[4] = a2;
  block[5] = v10;
  dispatch_async(v9, block);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void ___ZN12SocketStream30_onqueue_completeTCPConnectionEv_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  IOPMAssertionID v3;
  IOPMAssertionID v4;
  const void *v5;
  const void *Value;
  uint64_t v7;
  unint64_t v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 48);
  v3 = *(_DWORD *)(v2 + 612);
  if (v3)
  {
    IOPMAssertionRelease(v3);
    *(_DWORD *)(v2 + 612) = 0;
  }
  v4 = *(_DWORD *)(v2 + 616);
  if (v4)
  {
    IOPMAssertionRelease(v4);
    *(_DWORD *)(v2 + 616) = 0;
  }
  v5 = *(const void **)(a1 + 56);
  if (v5)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 40));
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 336), &unk_1EDD003E0);
    if (Value)
      v5 = Value;
    CFRetain(v5);
    SocketStream::removeHandshake_NoLock(v2, 7);
    v7 = *(unsigned int *)(v2 + 248);
    v8 = v7 | ((unint64_t)*(unsigned __int16 *)(v2 + 252) << 32) | 0x400000000;
    *(_DWORD *)(v2 + 248) = v7;
    *(_WORD *)(v2 + 252) = WORD2(v8);
    SocketStream::_CONNECTSetInfo_NoLock((CFDictionaryRef *)v2, (CFDictionaryRef)v5);
    CFRelease(v5);
    pthread_mutex_unlock((pthread_mutex_t *)(v2 + 40));
    CFRelease(*(CFTypeRef *)(a1 + 56));
  }
  if (*(_BYTE *)(a1 + 64))
  {
    *(_QWORD *)(v2 + 256) = 1;
    *(_DWORD *)(v2 + 264) = 57;
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v9 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *(_QWORD *)(v2 + 560);
      v12 = 134217984;
      v13 = v10;
      _os_log_impl(&dword_183ECA000, v9, OS_LOG_TYPE_DEFAULT, "TCP Conn %p canceled by ceClient", (uint8_t *)&v12, 0xCu);
    }
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 40));
    SocketStream::cleanupConnection_NoLock((SocketStream *)v2);
    pthread_mutex_unlock((pthread_mutex_t *)(v2 + 40));
  }
  else
  {
    SocketStream::_onqueue_completeTCPConnection0(v2, *(_QWORD *)(a1 + 32));
  }
  v11 = *(NSObject **)(a1 + 32);
  if (v11)
    dispatch_release(v11);
  tcp_connection_release();
  CFRelease((CFTypeRef)(v2 - 16));
}

uint64_t ___ZN12SocketStream31_onqueue_completeTCPConnection0EPU27objcproto16OS_dispatch_data8NSObject_block_invoke_40@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 3515;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream31_onqueue_completeTCPConnection0EPU27objcproto16OS_dispatch_data8NSObject_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 3484;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream18startTCPConnectionEh_block_invoke_2(uint64_t a1)
{
  NSObject *v2;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    v4 = *(_QWORD *)(a1 + 32);
    v5 = 134217984;
    v6 = v4;
    _os_log_debug_impl(&dword_183ECA000, v2, OS_LOG_TYPE_DEBUG, "TCP Conn %p released", (uint8_t *)&v5, 0xCu);
  }
  return tcp_connection_release();
}

void ___ZN12SocketStream18startTCPConnectionEh_block_invoke_87(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  _QWORD v4[5];
  __int16 v5;

  v2 = *(_QWORD *)(a1 + 40);
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 24))(*(_QWORD *)(a1 + 48));
  v3 = *(NSObject **)(a1 + 32);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN12SocketStream18startTCPConnectionEh_block_invoke_2_88;
  v4[3] = &__block_descriptor_42_e5_v8__0l;
  v4[4] = v2;
  v5 = *(_WORD *)(a1 + 56);
  dispatch_async(v3, v4);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void ___ZN12SocketStream18startTCPConnectionEh_block_invoke_2_88(uint64_t a1)
{
  SocketStream *v1;

  v1 = *(SocketStream **)(a1 + 32);
  SocketStream::_onqueue_startTCPConnectionConditional(v1, *(unsigned __int8 *)(a1 + 40), *(unsigned __int8 *)(a1 + 41));
  CFRelease((char *)v1 - 16);
}

void ___ZN12SocketStream37_onqueue_startTCPConnectionCompletionEhh_block_invoke(uint64_t a1)
{
  uint64_t v1;
  double v2;
  NSObject *v3;
  dispatch_time_t v4;

  v1 = *(_QWORD *)(a1 + 32);
  tcp_connection_retry();
  v2 = *(double *)(v1 + 376) + *(double *)(v1 + 376);
  *(double *)(v1 + 376) = v2;
  v3 = *(NSObject **)(v1 + 392);
  v4 = dispatch_time(0, (uint64_t)(v2 * 1000000000.0));
  dispatch_source_set_timer(v3, v4, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
}

uint64_t ___ZN12SocketStream37_onqueue_startTCPConnectionCompletionEhh_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 4161;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream17setupSIMSchedulerEPK14__CFDictionaryhh_block_invoke(uint64_t a1)
{
  return SocketStream::_onqueue_startTCPConnectionCompletion(*(SocketStream **)(a1 + 32), *(unsigned __int8 *)(a1 + 48), *(unsigned __int8 *)(a1 + 49));
}

uint64_t ___ZN12SocketStream17setupSIMSchedulerEPK14__CFDictionaryhh_block_invoke_183(uint64_t a1)
{
  CFStreamError v2;

  v2.domain = 1;
  *(_QWORD *)&v2.error = 60;
  return SocketStream::_onqueue_cancelTCPConnectionAfterTimeout(*(SocketStream **)(a1 + 32), v2);
}

uint64_t __copy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12SocketStreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12SocketStreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void std::__shared_ptr_pointer<SocketStream *,Deleter_release<SocketStream>,std::allocator<SocketStream>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<SocketStream *,Deleter_release<SocketStream>,std::allocator<SocketStream>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
    CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN12SocketStream26setupDuetActivitySchedulerEhh_block_invoke(uint64_t a1)
{
  SocketStream::_onqueue_startTCPConnectionCompletion(*(SocketStream **)(a1 + 32), *(unsigned __int8 *)(a1 + 48), *(unsigned __int8 *)(a1 + 49));
  return 1;
}

void ___ZN12SocketStream26setupDuetActivitySchedulerEhh_block_invoke_177(uint64_t a1)
{
  id *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  BOOL v8;
  CFTypeRef v9;
  CFTypeRef cf;

  v2 = *(id **)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  if (*(_QWORD *)(v3 + 448) || *(_QWORD *)(v3 + 456))
  {
    v9 = 0;
    cf = 0;
    SocketStream::retainOpenClientStreamsSafer(v2, (__CFReadStream **)&cf, (__CFWriteStream **)&v9);
    v4 = *(_QWORD *)(a1 + 40);
    v5 = *(_QWORD *)(v4 + 448);
    if (v5)
      v6 = cf == 0;
    else
      v6 = 1;
    if (!v6)
    {
      (*(void (**)(void))(v5 + 16))();
      v4 = *(_QWORD *)(a1 + 40);
    }
    v7 = *(_QWORD *)(v4 + 456);
    if (v7)
      v8 = v9 == 0;
    else
      v8 = 1;
    if (!v8)
      (*(void (**)(void))(v7 + 16))();
    if (cf)
      CFRelease(cf);
    if (v9)
      CFRelease(v9);
  }
}

void ___ZN12SocketStream26setupDuetActivitySchedulerEhh_block_invoke_180(uint64_t a1, int a2, CFTypeRef cf)
{
  uint64_t v3;
  CFTypeRef v4;
  const void *v5;

  if (a2)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (cf)
      v4 = CFRetain(cf);
    else
      v4 = 0;
    v5 = *(const void **)(v3 + 648);
    *(_QWORD *)(v3 + 648) = v4;
    if (v5)
      CFRelease(v5);
  }
}

uint64_t __copy_helper_block_e8_40c40_ZTSNSt3__110shared_ptrI12SocketStreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c40_ZTSNSt3__110shared_ptrI12SocketStreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

uint64_t SocketStream::retainOpenClientStreamsSafer(id *this, __CFReadStream **a2, __CFWriteStream **a3)
{
  pthread_mutex_t *v6;
  __CFReadStream *WeakRetained;
  __CFWriteStream *v8;

  v6 = (pthread_mutex_t *)(this + 5);
  pthread_mutex_lock((pthread_mutex_t *)(this + 5));
  if (a2)
  {
    if (((*((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) & 0x1000000000) != 0)
      WeakRetained = 0;
    else
      WeakRetained = (__CFReadStream *)objc_loadWeakRetained(this + 34);
    *a2 = WeakRetained;
  }
  if (a3)
  {
    if (((*((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) & 0x2000000000) != 0)
      v8 = 0;
    else
      v8 = (__CFWriteStream *)objc_loadWeakRetained(this + 35);
    *a3 = v8;
  }
  return pthread_mutex_unlock(v6);
}

uint64_t diagnosticLogTCPConnectionInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  char v12[1024];
  char __str[1024];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if ((tcp_connection_get_local() & 1) == 0)
    {
      v8 = 0;
      v9 = 0;
      v11 = 0;
      v10 = 0;
    }
    if ((tcp_connection_get_remote() & 1) == 0)
    {
      v4 = 0;
      v5 = 0;
      v7 = 0;
      v6 = 0;
    }
    tcp_connection_get_hostname();
  }
  else
  {
    v8 = 0;
    v9 = 0;
    v11 = 0;
    v10 = 0;
    v5 = 0;
    v6 = 0;
    v4 = 0;
    v7 = 0;
  }
  IOLogger::addrToName((uint64_t)&v8, __str);
  IOLogger::addrToName((uint64_t)&v4, v12);
  return (*(uint64_t (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)a1 + 72))(a1, "connection", CFSTR("{ conn: %p, local %s => peer %s %s}"));
}

uint64_t SocketStream::terminateConnectionIfAppropriate(SocketStream *this, int a2)
{
  pthread_mutex_t *v4;
  const void *Value;
  const void *v6;
  CFTypeID v7;
  _BOOL4 v8;
  unsigned int *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  __int16 v17;
  _BOOL4 v18;
  id WeakRetained;
  const void *v20;
  id v21;
  const void *v22;
  unint64_t v23;
  const void **v24;
  uint8_t buf[4];
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v4 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFB7F8);
  if (Value)
  {
    v6 = Value;
    v7 = CFGetTypeID(Value);
    if (v7 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
    }
    if ((const void *)*MEMORY[0x1E0C9AE50] != v6)
      goto LABEL_7;
  }
  if (*((_QWORD *)this + 62))
  {
LABEL_7:
    v8 = 0;
    if (a2)
      goto LABEL_8;
LABEL_18:
    if (!v8)
      return pthread_mutex_unlock(v4);
    v9 = (unsigned int *)((char *)this + 248);
    v10 = (*((unsigned __int16 *)this + 126) >> 1) & 1;
    goto LABEL_20;
  }
  v8 = *((_QWORD *)this + 63) == 0;
  if (!a2)
    goto LABEL_18;
LABEL_8:
  if ((v8 & ~tcp_connection_is_multipath() & 1) == 0)
    return pthread_mutex_unlock(v4);
  v9 = (unsigned int *)((char *)this + 248);
  v10 = (*((unsigned __int16 *)this + 126) >> 1) & 1;
  if (!tcp_connection_is_cellular())
  {
LABEL_20:
    v13 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_55_5785, 2);
    if (v13)
    {
      v14 = v13;
      if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v13 + 16))(v13, "_networkReachabilityChanged", 0))
      {
        diagnosticLogTCPConnectionInfo(v14, *((_QWORD *)this + 70));
        (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v14 + 72))(v14, "conn", CFSTR("%p -- setting stream error to ENOTCONN"));
        (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
      }
    }
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v15 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *((_QWORD *)this + 70);
      *(_DWORD *)buf = 134217984;
      v27 = v16;
      _os_log_impl(&dword_183ECA000, v15, OS_LOG_TYPE_DEFAULT, "TCP Conn %p network reachability changed : setting stream error to ENOTCONN", buf, 0xCu);
    }
    v17 = *((_WORD *)this + 126);
    *((_DWORD *)this + 62) = *((_DWORD *)this + 62);
    *((_WORD *)this + 126) = v17 | 2;
    v18 = 1;
    *((_QWORD *)this + 32) = 1;
    *((_DWORD *)this + 66) = 57;
    SocketStream::cleanupConnection_NoLock(this);
    WeakRetained = objc_loadWeakRetained((id *)this + 34);
    v20 = WeakRetained;
    if (*((_QWORD *)this + 29))
      v18 = *((_QWORD *)this + 28) < 1;
    if (v18 && WeakRetained)
    {
      if ((*v9 & 0x200) != 0)
        _CFReadStreamSignalEventDelayed();
    }
    else if (!WeakRetained)
    {
      goto LABEL_35;
    }
    CFRelease(v20);
LABEL_35:
    v21 = objc_loadWeakRetained((id *)this + 35);
    if (v21)
    {
      v22 = v21;
      if ((*v9 & 0x400) != 0)
        _CFWriteStreamSignalEventDelayed();
      CFRelease(v22);
    }
    goto LABEL_39;
  }
  v11 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_51, 2);
  if (v11)
  {
    v12 = v11;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v11 + 16))(v11, "_networkReachabilityChanged", 0))
    {
      diagnosticLogTCPConnectionInfo(v12, *((_QWORD *)this + 70));
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v12 + 72))(v12, "conn", CFSTR("%p -- keeping alive"));
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
    }
  }
  if (!*((_QWORD *)this + 67)
    && !CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFB9F0)
    && !CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFBA28))
  {
    *((_WORD *)this + 126) = (*v9 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | 0x200000000) >> 32;
  }
LABEL_39:
  v23 = *v9 | ((unint64_t)*((unsigned __int16 *)v9 + 2) << 32);
  if (((v10 ^ ((v23 & 0x200000000) == 0)) & 1) == 0)
  {
    if ((v23 & 0x200000000) != 0)
      v24 = (const void **)MEMORY[0x1E0C9AE50];
    else
      v24 = (const void **)MEMORY[0x1E0C9AE40];
    NotificationStation::notifyPropertyChanged((SocketStream *)((char *)this + 104), CFSTR("__kCFStreamPropertyDoNotReuse"), *v24);
  }
  return pthread_mutex_unlock(v4);
}

uint64_t ___ZN12SocketStream33_onqueue_HandleTCPConnectionEventEjPKv_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 4024;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream32terminateConnectionIfAppropriateEh_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 3778;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream32terminateConnectionIfAppropriateEh_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 3764;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream33_onqueue_HandleTCPConnectionEventEjPKv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 4000;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN12SocketStream31finalizeCancelConnection_LockedEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  double v2;
  NSObject *v3;
  NSObject *v4;
  uint64_t v5;
  int v6;
  double Helper_x8__OBJC_CLASS____DASScheduler;
  uint64_t v8;
  void *v9;
  const void *v10;

  v1 = *(_QWORD *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 40));
  if (*(_BYTE *)(v1 + 544))
  {
    *(_BYTE *)(v1 + 544) = 0;
    CFRelease((CFTypeRef)(v1 - 16));
  }
  if (*(_BYTE *)(v1 + 644))
  {
    *(_BYTE *)(v1 + 644) = 0;
    entr_act_end_delayInitStub(v2);
  }
  v3 = *(NSObject **)(v1 + 384);
  if (v3)
  {
    dispatch_source_cancel(v3);
    dispatch_release(*(dispatch_object_t *)(v1 + 384));
    *(_QWORD *)(v1 + 384) = 0;
  }
  v4 = *(NSObject **)(v1 + 392);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*(dispatch_object_t *)(v1 + 392));
    *(_QWORD *)(v1 + 392) = 0;
  }
  v5 = *(_QWORD *)(v1 + 648);
  if (v5)
  {
    v6 = *(unsigned __int8 *)(v1 + 656);
    Helper_x8__OBJC_CLASS____DASScheduler = gotLoadHelper_x8__OBJC_CLASS____DASScheduler(v2);
    v9 = (void *)objc_msgSend(*(id *)(v8 + 2352), "sharedScheduler", Helper_x8__OBJC_CLASS____DASScheduler);
    if (v6)
      objc_msgSend(v9, "activityCompleted:", v5);
    else
      objc_msgSend(v9, "activityCanceled:", v5);
    v10 = *(const void **)(v1 + 648);
    *(_QWORD *)(v1 + 648) = 0;
    if (v10)
      CFRelease(v10);
  }
  SocketStream::cancelSIMScheduler((SocketStream *)v1);
  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 40));
  CFRelease((CFTypeRef)(v1 - 16));
}

void Schedulables::~Schedulables(Schedulables *this)
{
  const void *v1;

  *(_QWORD *)this = off_1E14E6230;
  v1 = (const void *)*((_QWORD *)this + 2);
  if (v1)
    CFRelease(v1);
}

{
  const void *v2;

  *(_QWORD *)this = off_1E14E6230;
  v2 = (const void *)*((_QWORD *)this + 2);
  if (v2)
    CFRelease(v2);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

void SocketStream::initialize(CFMutableDictionaryRef *this, __CFNetService *a2)
{
  const __CFAllocator *v4;
  CFNetServiceRef Copy;

  SocketStream::commonInitialization((SocketStream *)this);
  v4 = CFGetAllocator(this - 2);
  Copy = CFNetServiceCreateCopy(v4, a2);
  CFDictionaryAddValue(this[42], &unk_1EDCFBE50, Copy);
  CFRelease(Copy);
}

uint64_t ReadStreamCallbacks::_finalize(ReadStreamCallbacks *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *))(*(_QWORD *)((char *)a2
                                                                              + *(_QWORD *)(*(_QWORD *)a2 - 136))
                                                                  + 16))((char *)a2 + *(_QWORD *)(*(_QWORD *)a2 - 136), this);
}

uint64_t ReadStreamCallbacks::_copyDescription(ReadStreamCallbacks *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *))(*(_QWORD *)((char *)a2
                                                                              + *(_QWORD *)(*(_QWORD *)a2 - 136))
                                                                  + 24))((char *)a2 + *(_QWORD *)(*(_QWORD *)a2 - 136), this);
}

uint64_t ReadStreamCallbacks::_openCompleted(ReadStreamCallbacks *this, __CFReadStream *a2, CFStreamError *a3, void *a4)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *, __CFReadStream *))(*(CFIndex *)((char *)&a3->domain
                                                                                                 + *(_QWORD *)(a3->domain - 136))
                                                                                    + 40))((char *)a3 + *(_QWORD *)(a3->domain - 136), this, a2);
}

uint64_t ReadStreamCallbacks::_close(ReadStreamCallbacks *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *))(*(_QWORD *)((char *)a2
                                                                              + *(_QWORD *)(*(_QWORD *)a2 - 136))
                                                                  + 48))((char *)a2 + *(_QWORD *)(*(_QWORD *)a2 - 136), this);
}

uint64_t ReadStreamCallbacks::_copyProperty(ReadStreamCallbacks *this, __CFReadStream *a2, const __CFString *a3, void *a4)
{
  return (*(uint64_t (***)(char *, ReadStreamCallbacks *, __CFReadStream *))((char *)&a3->isa
                                                                                     + *((_QWORD *)a3->isa - 17)))[7]((char *)a3 + *((_QWORD *)a3->isa - 17), this, a2);
}

uint64_t ReadStreamCallbacks::_unschedule(ReadStreamCallbacks *this, __CFReadStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*(uint64_t (***)(char *, ReadStreamCallbacks *, __CFReadStream *, __CFRunLoop *))((char *)&a4->isa + *((_QWORD *)a4->isa - 17)))[10]((char *)a4 + *((_QWORD *)a4->isa - 17), this, a2, a3);
}

uint64_t WriteStreamCallbacks::_finalize(WriteStreamCallbacks *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *))(*(_QWORD *)((char *)a2
                                                                               + *(_QWORD *)(*(_QWORD *)a2 - 136))
                                                                   + 16))((char *)a2 + *(_QWORD *)(*(_QWORD *)a2 - 136), this);
}

uint64_t WriteStreamCallbacks::_copyDescription(WriteStreamCallbacks *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *))(*(_QWORD *)((char *)a2
                                                                               + *(_QWORD *)(*(_QWORD *)a2 - 136))
                                                                   + 24))((char *)a2 + *(_QWORD *)(*(_QWORD *)a2 - 136), this);
}

uint64_t WriteStreamCallbacks::_openCompleted(WriteStreamCallbacks *this, __CFWriteStream *a2, CFStreamError *a3, void *a4)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *, __CFWriteStream *))(*(CFIndex *)((char *)&a3->domain + *(_QWORD *)(a3->domain - 136))
                                                                                      + 40))((char *)a3 + *(_QWORD *)(a3->domain - 136), this, a2);
}

uint64_t WriteStreamCallbacks::_close(WriteStreamCallbacks *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *))(*(_QWORD *)((char *)a2
                                                                               + *(_QWORD *)(*(_QWORD *)a2 - 136))
                                                                   + 48))((char *)a2 + *(_QWORD *)(*(_QWORD *)a2 - 136), this);
}

uint64_t WriteStreamCallbacks::_copyProperty(WriteStreamCallbacks *this, __CFWriteStream *a2, const __CFString *a3, void *a4)
{
  return (*(uint64_t (***)(char *, WriteStreamCallbacks *, __CFWriteStream *))((char *)&a3->isa
                                                                                       + *((_QWORD *)a3->isa - 17)))[7]((char *)a3 + *((_QWORD *)a3->isa - 17), this, a2);
}

uint64_t WriteStreamCallbacks::_unschedule(WriteStreamCallbacks *this, __CFWriteStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*(uint64_t (***)(char *, WriteStreamCallbacks *, __CFWriteStream *, __CFRunLoop *))((char *)&a4->isa + *((_QWORD *)a4->isa - 17)))[10]((char *)a4 + *((_QWORD *)a4->isa - 17), this, a2, a3);
}

void sub_184057DD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  id *v19;
  id *v20;

  objc_destroyWeak(v20);
  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1840581B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  id *v19;
  id *v20;

  objc_destroyWeak(v20);
  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1840597C8(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;

  CFRelease(v2);
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void sub_184059D64(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void sub_18405A6BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v2;
  va_list va;

  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  if (v2)
    CFRelease(v2);
  _Unwind_Resume(a1);
}

void sub_18405B004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  uint64_t v30;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v30);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a28);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a30);
  _Unwind_Resume(a1);
}

void std::allocate_shared[abi:nn180100]<TCPIO_Delegate,std::allocator<TCPIO_Delegate>,std::shared_ptr<TransportConnectionObjCPP> &,void>(_QWORD *a1, std::__shared_weak_count_vtbl *a2, std::__shared_weak_count *a3)
{
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD *v13;
  const void *(__cdecl *get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *shared_weak_owners;
  unint64_t v19;
  unint64_t *p_shared_weak_owners;
  unint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t v25;

  v6 = (std::__shared_weak_count *)operator new(0x78uLL);
  v7 = v6;
  v6->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0A28;
  if (a3)
  {
    v9 = (unint64_t *)&a3->__shared_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    v6[1].__shared_owners_ = 0;
    v6[1].__shared_weak_owners_ = 0;
    v6[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14E7318;
    v11 = (unint64_t *)&a3->__shared_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  else
  {
    v6[1].__shared_owners_ = 0;
    v6[1].__shared_weak_owners_ = 0;
    v6[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14E7318;
  }
  v13 = &v6[1].__vftable;
  v6[2].__vftable = a2;
  v6[2].__shared_owners_ = (uint64_t)a3;
  get_deleter = a2->__get_deleter;
  v15 = *((_QWORD *)get_deleter + 15);
  if (v15)
    dispatch_retain(*((dispatch_object_t *)get_deleter + 15));
  v7[2].__shared_weak_owners_ = v15;
  v7[3].__vftable = 0;
  LODWORD(v7[3].__shared_owners_) = 0;
  LOWORD(v7[3].__shared_weak_owners_) = 0;
  BYTE2(v7[3].__shared_weak_owners_) = 0;
  v7[4].__vftable = 0;
  LODWORD(v7[4].__shared_owners_) = 0;
  LOWORD(v7[4].__shared_weak_owners_) = 0;
  if (a3)
  {
    v16 = (unint64_t *)&a3->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
      std::__shared_weak_count::__release_weak(a3);
    }
  }
  *a1 = v13;
  a1[1] = v7;
  shared_weak_owners = (std::__shared_weak_count *)v7[1].__shared_weak_owners_;
  if (shared_weak_owners)
  {
    if (shared_weak_owners->__shared_owners_ != -1)
      return;
    do
      v19 = __ldxr(p_shared_owners);
    while (__stxr(v19 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
    do
      v21 = __ldxr(p_shared_weak_owners);
    while (__stxr(v21 + 1, p_shared_weak_owners));
    v7[1].__shared_owners_ = (uint64_t)v13;
    v7[1].__shared_weak_owners_ = (uint64_t)v7;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  else
  {
    do
      v22 = __ldxr(p_shared_owners);
    while (__stxr(v22 + 1, p_shared_owners));
    v23 = (unint64_t *)&v7->__shared_weak_owners_;
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
    v7[1].__shared_owners_ = (uint64_t)v13;
    v7[1].__shared_weak_owners_ = (uint64_t)v7;
  }
  do
    v25 = __ldaxr(p_shared_owners);
  while (__stlxr(v25 - 1, p_shared_owners));
  if (!v25)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void sub_18405B6C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_18405B7AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t __NSCFTCPIOWriteStream::__NSCFTCPIOWriteStream(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = &off_1E14EB0F8;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 32) = off_1E14EECD0;
  v6 = a1 + 32;
  *(_QWORD *)(a1 + 88) = a4;
  *(_DWORD *)(a1 + 96) = 1;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_QWORD *)a1 = &off_1E14EC7B8;
  *(_QWORD *)(a1 + 32) = &unk_1E14EC838;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(a1 + 104), *a3, a3[1]);
  v7 = *(_QWORD *)(a1 + 88);
  if (v7)
  {
    v8 = 16;
    if (!*(_DWORD *)(a1 + 96))
      v8 = 8;
    *(_QWORD *)(v7 + v8) = v6;
  }
  return a1;
}

void sub_18405B89C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  std::__shared_weak_count *v3;

  *v1 = &off_1E14E5838;
  v1[1] = 0;
  v3 = (std::__shared_weak_count *)v1[3];
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  _Unwind_Resume(exception_object);
}

void __NSCFTCPIOWriteStream::~__NSCFTCPIOWriteStream(__NSCFTCPIOWriteStream *this)
{
  __NSCFTCPIOWriteStream::~__NSCFTCPIOWriteStream(this);
  JUMPOUT(0x186DB748CLL);
}

{
  TCPIO_BlockCallbacks_Listener *v2;
  char *v3;
  uint64_t v4;
  NSObject *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  __int128 v18;
  void (*v19)(uint64_t);
  void *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  std::__shared_weak_count *v24;

  *((_QWORD *)this + 4) = &unk_1E14EC838;
  v2 = (TCPIO_BlockCallbacks_Listener *)((char *)this + 32);
  *(_QWORD *)this = &off_1E14EC7B8;
  v3 = (char *)this + 104;
  v4 = *((_QWORD *)this + 13);
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v23, *(_QWORD *)(v4 + 8), *(std::__shared_weak_count **)(v4 + 16));
  v5 = *(NSObject **)(v4 + 40);
  *(_QWORD *)&v18 = MEMORY[0x1E0C809B0];
  *((_QWORD *)&v18 + 1) = 3321888768;
  v19 = ___ZN14TCPIO_Delegate18writeSideFinalizedEv_block_invoke;
  v20 = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE_e5_v8__0l;
  v21 = v23;
  v22 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  dispatch_async(v5, &v18);
  v8 = v22;
  if (v22)
  {
    v9 = (unint64_t *)&v22->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v24;
  if (v24)
  {
    v12 = (unint64_t *)&v24->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v18 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v3, &v18);
  v14 = (std::__shared_weak_count *)*((_QWORD *)&v18 + 1);
  if (*((_QWORD *)&v18 + 1))
  {
    v15 = (unint64_t *)(*((_QWORD *)&v18 + 1) + 8);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v3);
  *((_QWORD *)this + 4) = off_1E14EECD0;
  TCPIO_BlockCallbacks_Listener::detachPropertyBlocks(v2);

  *(_QWORD *)this = &off_1E14E5838;
  *((_QWORD *)this + 1) = 0;
  v17 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
  if (v17)
    std::__shared_weak_count::__release_weak(v17);
}

CFStringRef __NSCFTCPIOWriteStream::copyDescription(__NSCFTCPIOWriteStream *this, __CFWriteStream *a2)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<TransportConnection@%p>"), *((_QWORD *)this + 13) + 24);
}

BOOL __NSCFTCPIOWriteStream::_streamImpl_Open(__NSCFTCPIOWriteStream *this, __CFWriteStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  uint64_t v6;
  NSObject *v7;
  _QWORD v9[6];

  v6 = *((_QWORD *)this + 13);
  v7 = *(NSObject **)(v6 + 40);
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___ZN14TCPIO_Delegate14getWriteStatusEP13CFStreamError_block_invoke;
  v9[3] = &__block_descriptor_48_e5_v8__0l;
  v9[4] = v6;
  v9[5] = a3;
  dispatch_sync(v7, v9);
  *a4 = 1;
  CFWriteStreamSignalEvent();
  return !a3->domain && a3->error == 0;
}

uint64_t __NSCFTCPIOWriteStream::_streamImpl_OpenCompleted(__NSCFTCPIOWriteStream *this, __CFWriteStream *a2, CFStreamError *a3)
{
  uint64_t v3;
  NSObject *v4;
  _QWORD v6[6];

  v3 = *((_QWORD *)this + 13);
  v4 = *(NSObject **)(v3 + 40);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN14TCPIO_Delegate14getWriteStatusEP13CFStreamError_block_invoke;
  v6[3] = &__block_descriptor_48_e5_v8__0l;
  v6[4] = v3;
  v6[5] = a3;
  dispatch_sync(v4, v6);
  return 1;
}

void __NSCFTCPIOWriteStream::_streamImpl_Close(__NSCFTCPIOWriteStream *this, __CFWriteStream *a2)
{
  TCPIO_Delegate::closeWriteSide(*((TCPIO_Delegate **)this + 13));
  TCPIO_BlockCallbacks_Listener::detachPropertyBlocks((TCPIO_BlockCallbacks_Listener *)((char *)this + 32));
}

uint64_t __NSCFTCPIOWriteStream::_streamImpl_CopyProperty(TCPIO_Delegate **this, __CFWriteStream *a2, const __CFString *a3)
{
  return TCPIO_Delegate::copyProperty(this[13], a3);
}

uint64_t __NSCFTCPIOWriteStream::_streamImpl_SetProperty(__NSCFTCPIOWriteStream *this, __CFWriteStream *a2, const __CFString *a3, const void *a4)
{
  if (!TCPIO_BlockCallbacks_Listener::listenerSetProperty((TCPIO_BlockCallbacks_Listener *)((char *)this + 32), a3, a4))TCPIO_Delegate::setProperty(*((TCPIO_Delegate **)this + 13), a3, a4);
  return 1;
}

uint64_t __NSCFTCPIOWriteStream::streamObject(__NSCFTCPIOWriteStream *this)
{
  return *((_QWORD *)this + 1);
}

void `non-virtual thunk to'__NSCFTCPIOWriteStream::~__NSCFTCPIOWriteStream(__NSCFTCPIOWriteStream *this)
{
  __NSCFTCPIOWriteStream::~__NSCFTCPIOWriteStream((__NSCFTCPIOWriteStream *)((char *)this - 32));
}

{
  __NSCFTCPIOWriteStream::~__NSCFTCPIOWriteStream((__NSCFTCPIOWriteStream *)((char *)this - 32));
  JUMPOUT(0x186DB748CLL);
}

uint64_t `non-virtual thunk to'__NSCFTCPIOWriteStream::streamObject(__NSCFTCPIOWriteStream *this)
{
  return *((_QWORD *)this - 3);
}

void sub_18405BCA4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  TCPIO_BlockCallbacks_Listener *v2;
  uint64_t v3;
  std::__shared_weak_count *v5;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  TCPIO_BlockCallbacks_Listener::~TCPIO_BlockCallbacks_Listener(v2);
  *v1 = &off_1E14E5838;
  v1[1] = 0;
  v5 = (std::__shared_weak_count *)v1[3];
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
  _Unwind_Resume(a1);
}

void TCPIO_BlockCallbacks_Listener::detachPropertyBlocks(TCPIO_BlockCallbacks_Listener *this)
{
  id var0;
  id var1;
  id var2;
  id var3;
  id var4;
  id var5;
  char *v8;
  uint64_t v9;

  var0 = this->var1.var0;
  if (var0)
  {
    _Block_release(var0);
    this->var1.var0 = 0;
  }
  var1 = this->var1.var1;
  if (var1)
  {
    _Block_release(var1);
    this->var1.var1 = 0;
  }
  var2 = this->var1.var2;
  if (var2)
  {
    _Block_release(var2);
    this->var1.var2 = 0;
  }
  var3 = this->var1.var3;
  if (var3)
  {
    _Block_release(var3);
    this->var1.var3 = 0;
  }
  var4 = this->var1.var4;
  if (var4)
  {
    _Block_release(var4);
    this->var1.var4 = 0;
  }
  var5 = this->var1.var5;
  if (var5)
  {
    _Block_release(var5);
    this->var1.var5 = 0;
  }
  v8 = (char *)this->var2;
  if (v8)
  {
    v9 = 16;
    if (!this->var3)
      v9 = 8;
    *(_QWORD *)&v8[v9] = 0;
  }
}

void TCPIO_BlockCallbacks_Listener::~TCPIO_BlockCallbacks_Listener(TCPIO_BlockCallbacks_Listener *this)
{
  this->var0 = (void **)off_1E14EECD0;
  TCPIO_BlockCallbacks_Listener::detachPropertyBlocks(this);

}

void ___ZN14TCPIO_Delegate18writeSideFinalizedEv_block_invoke(uint64_t a1)
{
  TCPIO_Delegate *v1;

  v1 = *(TCPIO_Delegate **)(a1 + 32);
  *((_BYTE *)v1 + 89) = 1;
  if (*((_BYTE *)v1 + 66))
    TCPIO_Delegate::_onqueue_bothSidesFinalized(v1);
}

uint64_t __copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void TCPIO_Delegate::_onqueue_bothSidesFinalized(TCPIO_Delegate *this)
{
  char *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;

  if (!*((_BYTE *)this + 66) || !*((_BYTE *)this + 89))
    __assert_rtn("_onqueue_bothSidesFinalized", "LocalTCPIOStreamTask.mm", 769, "_readFinalized && _writeFinalized");
  if (!*((_BYTE *)this + 65))
  {
    *((_BYTE *)this + 65) = 1;
    if (*((_BYTE *)this + 88))
    {
      v11 = *((_QWORD *)this + 3);
      if (v11)
      {
        v12 = *(_QWORD *)(v11 + 24);
        if (v12)
        {
          if (!*(_BYTE *)(v11 + 40))
          {
            *(_BYTE *)(v11 + 40) = 1;
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 152))(v12, 0);
          }
        }
      }
    }
  }
  if (!*((_BYTE *)this + 88))
  {
    *((_BYTE *)this + 88) = 1;
    if (*((_BYTE *)this + 65))
    {
      v13 = *((_QWORD *)this + 3);
      if (v13)
      {
        v14 = *(_QWORD *)(v13 + 24);
        if (v14)
        {
          if (!*(_BYTE *)(v13 + 40))
          {
            *(_BYTE *)(v13 + 40) = 1;
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v14 + 152))(v14, 0);
          }
        }
      }
    }
  }
  v2 = (char *)this + 24;
  if (*((_QWORD *)this + 3))
  {
    v3 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v5 = __ldxr(p_shared_owners);
      while (__stxr(v5 + 1, p_shared_owners));
    }
    v15 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v2, &v15);
    v6 = (std::__shared_weak_count *)*((_QWORD *)&v15 + 1);
    if (!*((_QWORD *)&v15 + 1))
      goto LABEL_13;
    v7 = (unint64_t *)(*((_QWORD *)&v15 + 1) + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
      if (!v3)
        return;
    }
    else
    {
LABEL_13:
      if (!v3)
        return;
    }
    v9 = (unint64_t *)&v3->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void **TCPIO_BlockCallbacks_Listener::listenerSetProperty(TCPIO_BlockCallbacks_Listener *this, const __CFString *a2, const void *a3)
{
  void **result;
  void **v5;
  void *v6;

  result = TCPIO_BlockCallbacks_Listener::findPropertyBlockPtr(this, a2);
  if (result)
  {
    v5 = result;
    v6 = *result;
    if (v6)
    {
      _Block_release(v6);
      *v5 = 0;
    }
    if (a3)
      *v5 = _Block_copy(a3);
    return (void **)1;
  }
  return result;
}

id *TCPIO_BlockCallbacks_Listener::findPropertyBlockPtr(TCPIO_BlockCallbacks_Listener *this, CFStringRef theString)
{
  int ExactString;
  CBs *p_var1;
  id *p_var0;
  id *p_var4;
  id *p_var2;
  id *p_var3;
  id *p_var5;

  ExactString = _findExactString(theString, 2u);
  p_var1 = &this->var1;
  if (ExactString != 96814834)
    p_var1 = 0;
  if (ExactString == 106203045)
    p_var0 = &this->var1.var1;
  else
    p_var0 = &p_var1->var0;
  if (ExactString == 90506882)
    p_var4 = &this->var1.var4;
  else
    p_var4 = p_var0;
  p_var2 = &this->var1.var2;
  if (ExactString != 89532009)
    p_var2 = 0;
  if (ExactString == 84248066)
    p_var3 = &this->var1.var3;
  else
    p_var3 = p_var2;
  if (ExactString == 83273191)
    p_var5 = &this->var1.var5;
  else
    p_var5 = p_var3;
  if (ExactString <= 90506881)
    return p_var5;
  else
    return p_var4;
}

void TCPIO_Delegate::closeWriteSide(TCPIO_Delegate *this)
{
  NSObject *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD v11[5];
  std::__shared_weak_count *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;

  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v13, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
  v2 = *((_QWORD *)this + 5);
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3321888768;
  v11[2] = ___ZN14TCPIO_Delegate14closeWriteSideEv_block_invoke;
  v11[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE_e5_v8__0l;
  v11[4] = v13;
  v12 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  dispatch_async(v2, v11);
  v5 = v12;
  if (v12)
  {
    v6 = (unint64_t *)&v12->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v8 = v14;
  if (v14)
  {
    v9 = (unint64_t *)&v14->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

uint64_t __NSCFTCPIOReadStream::__NSCFTCPIOReadStream(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  uint64_t v6;
  CoreSchedulingSet *v7;
  uint64_t v8;
  uint64_t v9;

  *(_QWORD *)a1 = &off_1E14E9C40;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = off_1E14EECD0;
  v6 = a1 + 16;
  *(_QWORD *)(a1 + 72) = a4;
  *(_DWORD *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)a1 = &off_1E14EC268;
  *(_QWORD *)(a1 + 16) = &unk_1E14EC2E8;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  v7 = (CoreSchedulingSet *)std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(a1 + 88), *a3, a3[1]);
  *(_QWORD *)(a1 + 112) = 0xFFFF00000000;
  *(_QWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 128) = 1;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 120) = CoreSchedulingSet::createEmpty(v7);
  v8 = *(_QWORD *)(a1 + 72);
  if (v8)
  {
    v9 = 16;
    if (!*(_DWORD *)(a1 + 80))
      v9 = 8;
    *(_QWORD *)(v8 + v9) = v6;
  }
  return a1;
}

void sub_18405C2A8(_Unwind_Exception *a1)
{
  _QWORD *v1;
  TCPIO_BlockCallbacks_Listener *v2;
  uint64_t v3;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  TCPIO_BlockCallbacks_Listener::~TCPIO_BlockCallbacks_Listener(v2);
  *v1 = &off_1E14E5838;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

void __NSCFTCPIOReadStream::~__NSCFTCPIOReadStream(__NSCFTCPIOReadStream *this)
{
  __NSCFTCPIOReadStream::~__NSCFTCPIOReadStream(this);
  JUMPOUT(0x186DB748CLL);
}

{
  TCPIO_BlockCallbacks_Listener *v2;
  char *v3;
  uint64_t v4;
  NSObject *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  NSObject *v17;
  __int128 v18;
  void (*v19)(uint64_t);
  void *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  std::__shared_weak_count *v24;

  *((_QWORD *)this + 2) = &unk_1E14EC2E8;
  v2 = (TCPIO_BlockCallbacks_Listener *)((char *)this + 16);
  *(_QWORD *)this = &off_1E14EC268;
  v3 = (char *)this + 88;
  v4 = *((_QWORD *)this + 11);
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v23, *(_QWORD *)(v4 + 8), *(std::__shared_weak_count **)(v4 + 16));
  v5 = *(NSObject **)(v4 + 40);
  *(_QWORD *)&v18 = MEMORY[0x1E0C809B0];
  *((_QWORD *)&v18 + 1) = 3321888768;
  v19 = ___ZN14TCPIO_Delegate17readSideFinalizedEv_block_invoke;
  v20 = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE_e5_v8__0l;
  v21 = v23;
  v22 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  dispatch_async(v5, &v18);
  v8 = v22;
  if (v22)
  {
    v9 = (unint64_t *)&v22->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v24;
  if (v24)
  {
    v12 = (unint64_t *)&v24->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v18 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v3, &v18);
  v14 = (std::__shared_weak_count *)*((_QWORD *)&v18 + 1);
  if (*((_QWORD *)&v18 + 1))
  {
    v15 = (unint64_t *)(*((_QWORD *)&v18 + 1) + 8);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  (*(void (**)(_QWORD))(**((_QWORD **)this + 15) + 48))(*((_QWORD *)this + 15));
  v17 = *((_QWORD *)this + 13);
  if (v17)
    dispatch_release(v17);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v3);
  *((_QWORD *)this + 2) = off_1E14EECD0;
  TCPIO_BlockCallbacks_Listener::detachPropertyBlocks(v2);

  *(_QWORD *)this = &off_1E14E5838;
  *((_QWORD *)this + 1) = 0;
}

CFStringRef __NSCFTCPIOReadStream::copyDescription(__NSCFTCPIOReadStream *this, __CFReadStream *a2)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<TransportConnection@%p>"), *((_QWORD *)this + 11) + 24);
}

BOOL __NSCFTCPIOReadStream::_streamImpl_Open(__NSCFTCPIOReadStream *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  uint64_t v6;
  NSObject *v7;
  char v9;
  _QWORD block[8];

  v9 = 0;
  v6 = *((_QWORD *)this + 11);
  v7 = *(NSObject **)(v6 + 40);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN14TCPIO_Delegate13getReadStatusEP13CFStreamErrorPh_block_invoke;
  block[3] = &__block_descriptor_56_e5_v8__0l;
  block[4] = v6;
  block[5] = a3;
  block[6] = &v9;
  dispatch_sync(v7, block);
  *a4 = 1;
  if (*((_QWORD *)this + 13) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(block[0]) = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "should only open this stream once", (uint8_t *)block, 2u);
  }
  __NSCFTCPIOReadStream::issueDelegateRead(this);
  return v9 == 0;
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_OpenCompleted(__NSCFTCPIOReadStream *this, __CFReadStream *a2, CFStreamError *a3)
{
  uint64_t v3;
  NSObject *v4;
  char v6;
  _QWORD block[7];

  v6 = 0;
  v3 = *((_QWORD *)this + 11);
  v4 = *(NSObject **)(v3 + 40);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN14TCPIO_Delegate13getReadStatusEP13CFStreamErrorPh_block_invoke;
  block[3] = &__block_descriptor_56_e5_v8__0l;
  block[4] = v3;
  block[5] = a3;
  block[6] = &v6;
  dispatch_sync(v4, block);
  return 1;
}

BOOL __NSCFTCPIOReadStream::_streamImpl_CanRead(os_unfair_lock_s *this, __CFReadStream *a2)
{
  os_unfair_lock_s *v4;
  _BOOL8 v5;

  v4 = this + 28;
  os_unfair_lock_lock(this + 28);
  if (*(_QWORD *)&this[26]._os_unfair_lock_opaque)
    v5 = 1;
  else
    v5 = CFReadStreamGetStatus(a2) == kCFStreamStatusOpen;
  os_unfair_lock_unlock(v4);
  return v5;
}

void __NSCFTCPIOReadStream::_streamImpl_Close(__NSCFTCPIOReadStream *this, __CFReadStream *a2)
{
  TCPIO_Delegate::closeReadSide(*((TCPIO_Delegate **)this + 11));
  TCPIO_BlockCallbacks_Listener::detachPropertyBlocks((TCPIO_BlockCallbacks_Listener *)((char *)this + 16));
  *((_BYTE *)this + 128) = 0;
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_SetProperty(__NSCFTCPIOReadStream *this, __CFReadStream *a2, const __CFString *a3, const void *a4)
{
  if (!TCPIO_BlockCallbacks_Listener::listenerSetProperty((TCPIO_BlockCallbacks_Listener *)((char *)this + 16), a3, a4))TCPIO_Delegate::setProperty(*((TCPIO_Delegate **)this + 11), a3, a4);
  return 1;
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_deprecated_Schedule(__NSCFTCPIOReadStream *this, __CFReadStream *a2, __CFRunLoop *a3, const __CFString *a4)
{
  _DWORD *v5;
  int v6;
  uint64_t result;
  uint64_t v8;
  _QWORD v9[5];

  v5 = (_DWORD *)*((_QWORD *)this + 15);
  v6 = v5[10];
  result = (*(uint64_t (**)(_DWORD *, __CFRunLoop *, const __CFString *))(*(_QWORD *)v5 + 56))(v5, a3, a4);
  *((_QWORD *)this + 15) = result;
  if (!v6)
  {
    if (*(_DWORD *)(result + 40))
    {
      CFRetain(*((CFTypeRef *)this + 1));
      v8 = *((_QWORD *)this + 15);
      v9[0] = MEMORY[0x1E0C809B0];
      v9[1] = 3221225472;
      v9[2] = ___ZN21__NSCFTCPIOReadStream31_streamImpl_deprecated_ScheduleEP14__CFReadStreamP11__CFRunLoopPK10__CFString_block_invoke;
      v9[3] = &__block_descriptor_40_e5_v8__0l;
      v9[4] = this;
      return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v8 + 96))(v8, v9);
    }
  }
  return result;
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_deprecated_Unschedule(__NSCFTCPIOReadStream *this, __CFReadStream *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD, __CFRunLoop *, const __CFString *))(**((_QWORD **)this + 15) + 64))(*((_QWORD *)this + 15), a3, a4);
  *((_QWORD *)this + 15) = result;
  return result;
}

uint64_t __NSCFTCPIOReadStream::streamObject(__NSCFTCPIOReadStream *this)
{
  return *((_QWORD *)this + 1);
}

void `non-virtual thunk to'__NSCFTCPIOReadStream::~__NSCFTCPIOReadStream(__NSCFTCPIOReadStream *this)
{
  __NSCFTCPIOReadStream::~__NSCFTCPIOReadStream((__NSCFTCPIOReadStream *)((char *)this - 16));
}

{
  __NSCFTCPIOReadStream::~__NSCFTCPIOReadStream((__NSCFTCPIOReadStream *)((char *)this - 16));
  JUMPOUT(0x186DB748CLL);
}

uint64_t `non-virtual thunk to'__NSCFTCPIOReadStream::streamObject(__NSCFTCPIOReadStream *this)
{
  return *((_QWORD *)this - 1);
}

void sub_18405C834(_Unwind_Exception *a1)
{
  _QWORD *v1;
  TCPIO_BlockCallbacks_Listener *v2;
  uint64_t v3;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  TCPIO_BlockCallbacks_Listener::~TCPIO_BlockCallbacks_Listener(v2);
  *v1 = &off_1E14E5838;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

void ___ZN14TCPIO_Delegate17readSideFinalizedEv_block_invoke(uint64_t a1)
{
  TCPIO_Delegate *v1;

  v1 = *(TCPIO_Delegate **)(a1 + 32);
  *((_BYTE *)v1 + 66) = 1;
  if (*((_BYTE *)v1 + 89))
    TCPIO_Delegate::_onqueue_bothSidesFinalized(v1);
}

void ___ZN21__NSCFTCPIOReadStream31_streamImpl_deprecated_ScheduleEP14__CFReadStreamP11__CFRunLoopPK10__CFString_block_invoke(uint64_t a1)
{
  CFTypeRef *v1;

  v1 = *(CFTypeRef **)(a1 + 32);
  __NSCFTCPIOReadStream::_onss_excite((__NSCFTCPIOReadStream *)v1);
  CFRelease(v1[1]);
}

void ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke(uint64_t a1, NSObject *a2, uint64_t a3)
{
  uint64_t v5;
  NSObject *v6;
  int is_wake_packet;
  size_t size;
  dispatch_data_t concat;

  if (*(_BYTE *)(*(_QWORD *)(a1 + 40) + 128))
  {
    v5 = *(_QWORD *)(a1 + 32);
    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 112));
    if (a2)
    {
      v6 = *(NSObject **)(v5 + 104);
      if (v6)
      {
        if (a3)
        {
          is_wake_packet = nw_content_context_get_is_wake_packet();
          v6 = *(NSObject **)(v5 + 104);
          if (is_wake_packet)
          {
            size = dispatch_data_get_size(*(dispatch_data_t *)(v5 + 104));
            *(_QWORD *)(v5 + 136) = size;
            *(_QWORD *)(v5 + 144) = dispatch_data_get_size(a2) + size;
          }
        }
        concat = dispatch_data_create_concat(v6, a2);
        dispatch_release(*(dispatch_object_t *)(v5 + 104));
        *(_QWORD *)(v5 + 104) = concat;
      }
      else
      {
        *(_QWORD *)(v5 + 104) = a2;
        dispatch_retain(a2);
        if (a3 && nw_content_context_get_is_wake_packet())
        {
          *(_QWORD *)(v5 + 136) = 0;
          *(_QWORD *)(v5 + 144) = dispatch_data_get_size(a2);
        }
      }
    }
    else
    {
      *(_BYTE *)(v5 + 129) = 1;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 112));
  }
}

void ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_261(uint64_t a1, dispatch_object_t object, uint64_t a3)
{
  uint64_t v4;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD v22[7];
  _QWORD v23[5];

  v4 = *(_QWORD *)(a1 + 32);
  if (object)
  {
    dispatch_retain(object);
    CFRetain(*(CFTypeRef *)(v4 + 8));
    v8 = *(_QWORD *)(a1 + 40);
    v7 = (_QWORD *)(a1 + 40);
    v22[5] = a3;
    v22[6] = v4;
    v22[4] = object;
    (*(void (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, void (*)(uint64_t), void *))(*(_QWORD *)v8 + 96))(v8, v22, v9, v10, v11, v12, v13, v14, MEMORY[0x1E0C809B0], 3221225472, ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_3, &unk_1E14FD950);
  }
  else
  {
    CFRetain(*(CFTypeRef *)(v4 + 8));
    v15 = *(_QWORD *)(a1 + 40);
    v7 = (_QWORD *)(a1 + 40);
    v23[0] = MEMORY[0x1E0C809B0];
    v23[1] = 3221225472;
    v23[2] = ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_2;
    v23[3] = &__block_descriptor_40_e5_v8__0l;
    v23[4] = v4;
    (*(void (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v15 + 96))(v15, v23, v16, v17, v18, v19, v20, v21, v22[0], v22[1], v22[2], v22[3]);
  }
  (*(void (**)(_QWORD))(*(_QWORD *)*v7 + 48))(*v7);
  CFRelease(*(CFTypeRef *)(v4 + 8));
}

void ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_2(uint64_t a1)
{
  CFTypeRef *v1;

  v1 = *(CFTypeRef **)(a1 + 32);
  __NSCFTCPIOReadStream::_onss_excite((__NSCFTCPIOReadStream *)v1);
  CFRelease(v1[1]);
}

uint64_t __copy_helper_block_e8_40c49_ZTSNSt3__110shared_ptrI21__NSCFTCPIOReadStreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c49_ZTSNSt3__110shared_ptrI21__NSCFTCPIOReadStreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

void std::__shared_ptr_pointer<__NSCFTCPIOReadStream *,__NSCFTCPIOReadStream::issueDelegateRead(void)::{lambda(__NSCFTCPIOReadStream *)#1},std::allocator<__NSCFTCPIOReadStream>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<__NSCFTCPIOReadStream *,__NSCFTCPIOReadStream::issueDelegateRead(void)::{lambda(__NSCFTCPIOReadStream *)#1},std::allocator<__NSCFTCPIOReadStream>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
    CFRelease(*(CFTypeRef *)(v1 + 8));
}

void TCPIO_Delegate::closeReadSide(TCPIO_Delegate *this)
{
  NSObject *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD v11[5];
  std::__shared_weak_count *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;

  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v13, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
  v2 = *((_QWORD *)this + 5);
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3321888768;
  v11[2] = ___ZN14TCPIO_Delegate13closeReadSideEv_block_invoke;
  v11[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE_e5_v8__0l;
  v11[4] = v13;
  v12 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  dispatch_async(v2, v11);
  v5 = v12;
  if (v12)
  {
    v6 = (unint64_t *)&v12->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v8 = v14;
  if (v14)
  {
    v9 = (unint64_t *)&v14->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void TCPIO_Delegate::~TCPIO_Delegate(TCPIO_Delegate *this)
{
  TCPIO_Delegate::~TCPIO_Delegate(this);
  JUMPOUT(0x186DB748CLL);
}

{
  uint64_t v2;
  char *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  NSObject *v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  _QWORD block[5];
  __int128 v16;
  _QWORD v17[7];
  std::__shared_weak_count *v18;

  *(_QWORD *)this = &off_1E14E7318;
  v17[0] = 0;
  v17[1] = v17;
  v17[2] = 0x4012000000;
  v17[3] = __Block_byref_object_copy__6017;
  v17[4] = __Block_byref_object_dispose__6018;
  v3 = (char *)this + 24;
  v2 = *((_QWORD *)this + 3);
  v17[5] = &unk_18422E08D;
  v17[6] = v2;
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
  v18 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v16 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 24, &v16);
  v7 = (std::__shared_weak_count *)*((_QWORD *)&v16 + 1);
  if (*((_QWORD *)&v16 + 1))
  {
    v8 = (unint64_t *)(*((_QWORD *)&v16 + 1) + 8);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v10 = *((_QWORD *)this + 5);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN14TCPIO_DelegateD2Ev_block_invoke;
  block[3] = &unk_1E14FD3D8;
  block[4] = v17;
  dispatch_async(v10, block);
  dispatch_release(*((dispatch_object_t *)this + 5));
  _Block_object_dispose(v17, 8);
  v11 = v18;
  if (v18)
  {
    v12 = (unint64_t *)&v18->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v3);
  *(_QWORD *)this = &off_1E14E5838;
  v14 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v14)
    std::__shared_weak_count::__release_weak(v14);
}

__n128 __Block_byref_object_copy__6017(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__6018(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

void ___ZN14TCPIO_DelegateD2Ev_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *v2;
  unint64_t v3;
  __int128 v4;

  v4 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48, &v4);
  v1 = (std::__shared_weak_count *)*((_QWORD *)&v4 + 1);
  if (*((_QWORD *)&v4 + 1))
  {
    v2 = (unint64_t *)(*((_QWORD *)&v4 + 1) + 8);
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 - 1, v2));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void std::__shared_ptr_emplace<TCPIO_Delegate>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0A28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TCPIO_Delegate>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0A28;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_emplace<TCPIO_Delegate>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void __NSCFTCPIOErroredWriteStream::~__NSCFTCPIOErroredWriteStream(__NSCFTCPIOErroredWriteStream *this)
{
  *(_QWORD *)this = &off_1E14E5838;
  *((_QWORD *)this + 1) = 0;
}

{
  *(_QWORD *)this = &off_1E14E5838;
  *((_QWORD *)this + 1) = 0;
  JUMPOUT(0x186DB748CLL);
}

uint64_t __NSCFTCPIOErroredWriteStream::_streamImpl_Open(CFStreamError *this, __CFWriteStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  *a3 = this[1];
  *a4 = 1;
  return 0;
}

uint64_t __NSCFTCPIOErroredWriteStream::_streamImpl_OpenCompleted(CFStreamError *this, __CFWriteStream *a2, CFStreamError *a3)
{
  *a3 = this[1];
  return 0;
}

uint64_t __NSCFTCPIOErroredWriteStream::_streamImpl_Write(CFStreamError *this, __CFWriteStream *a2, const unsigned __int8 *a3, uint64_t a4, CFStreamError *a5)
{
  *a5 = this[1];
  return -1;
}

void __NSCFTCPIOErroredReadStream::~__NSCFTCPIOErroredReadStream(__NSCFTCPIOErroredReadStream *this)
{
  *(_QWORD *)this = &off_1E14E5838;
  *((_QWORD *)this + 1) = 0;
}

{
  *(_QWORD *)this = &off_1E14E5838;
  *((_QWORD *)this + 1) = 0;
  JUMPOUT(0x186DB748CLL);
}

uint64_t __NSCFTCPIOErroredReadStream::_streamImpl_Open(CFStreamError *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  *a3 = this[1];
  *a4 = 1;
  return 0;
}

uint64_t __NSCFTCPIOErroredReadStream::_streamImpl_OpenCompleted(CFStreamError *this, __CFReadStream *a2, CFStreamError *a3)
{
  *a3 = this[1];
  return 0;
}

uint64_t __NSCFTCPIOErroredReadStream::_streamImpl_Read(CFStreamError *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  *a5 = this[1];
  *a6 = 1;
  return -1;
}

void std::__shared_ptr_pointer<HTTPProtocol *,Deleter_release<HTTPProtocol>,std::allocator<HTTPProtocol>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_6031()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  *(_DWORD *)((char *)_PNAME<URLProtocol>::GET(void)::p + 7) = 1819239279;
  _PNAME<URLProtocol>::GET(void)::p[0] = *(_QWORD *)"URLProtocol>::GET() [OBJTYPE = URLProtocol]";
  CFClass::CFClass(v0, (const char *)_PNAME<URLProtocol>::GET(void)::p);
  TCFObject<URLProtocol>::Class(void)::clazz = (uint64_t)v0;
}

void sub_18405D3F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void sub_18405DB2C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 104);
  _Unwind_Resume(a1);
}

void sub_18405DC90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_18405DDC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_18405E2F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_18405E620(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void std::allocate_shared[abi:nn180100]<TCPIO_Establish,std::allocator<TCPIO_Establish>,__NSCFTCPIOStreamTask *&,void>(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *shared_weak_owners;
  unint64_t v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;

  v4 = (std::__shared_weak_count *)operator new(0x60uLL);
  *(_OWORD *)&v4->__shared_owners_ = 0u;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0B40;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14E7C78;
  v6 = v4 + 1;
  *(_OWORD *)&v4[1].__shared_owners_ = 0u;
  v4[2].__vftable = (std::__shared_weak_count_vtbl *)&unk_1E14E7D38;
  v4[2].__shared_weak_owners_ = a2;
  v4[2].__shared_owners_ = (uint64_t)objc_alloc_init(__NSCFTCPIO_BlockCallbacks_Referent);
  v4[3].__vftable = 0;
  v4[3].__shared_owners_ = 0;
  LOWORD(v4[3].__shared_weak_owners_) = 0;
  *a1 = v4 + 1;
  a1[1] = v4;
  shared_weak_owners = (std::__shared_weak_count *)v4[1].__shared_weak_owners_;
  if (shared_weak_owners)
  {
    if (shared_weak_owners->__shared_owners_ != -1)
      return;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v10 = __ldxr(p_shared_weak_owners);
    while (__stxr(v10 + 1, p_shared_weak_owners));
    v4[1].__shared_owners_ = (uint64_t)v6;
    v4[1].__shared_weak_owners_ = (uint64_t)v4;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  else
  {
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    v12 = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    v4[1].__shared_owners_ = (uint64_t)v6;
    v4[1].__shared_weak_owners_ = (uint64_t)v4;
  }
  do
    v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_18405E848(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  std::__shared_weak_count *shared_weak_owners;
  void *v4;

  v1[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14E5838;
  shared_weak_owners = (std::__shared_weak_count *)v1[1].__shared_weak_owners_;
  if (shared_weak_owners)
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v4);
  _Unwind_Resume(a1);
}

void TCPIO_Establish::~TCPIO_Establish(TCPIO_Establish *this)
{
  TCPIO_Establish::~TCPIO_Establish(this);
  JUMPOUT(0x186DB748CLL);
}

{
  std::__shared_weak_count *v2;

  *(_QWORD *)this = &off_1E14E7C78;
  *((_QWORD *)this + 3) = &unk_1E14E7D38;

  *(_QWORD *)this = &off_1E14E5838;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

void TCPIO_Establish::initialize(TCPIO_Establish *this, NSString *a2, uint64_t a3)
{
  const void *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count_vtbl *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  std::__shared_weak_count_vtbl *v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  std::__shared_weak_count *v46;
  std::__shared_weak_count *v47;
  std::__shared_weak_count *v48;
  std::__shared_weak_count_vtbl *v49;
  std::__shared_weak_count *v50;

  v5 = (const void *)-[NSString copy](a2, "copy");
  *((_QWORD *)this + 6) = v5;
  *((_QWORD *)this + 7) = a3;
  v6 = *((_QWORD *)this + 5);
  if (v6)
  {
    v7 = (uint64_t *)(v6 + 784);
    v8 = *v7;
    v9 = (std::__shared_weak_count *)v7[1];
    v47 = v9;
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
      v5 = (const void *)*((_QWORD *)this + 6);
    }
    if (v5)
      goto LABEL_7;
LABEL_9:
    v12 = 0;
    goto LABEL_10;
  }
  v8 = 0;
  v47 = 0;
  if (!v5)
    goto LABEL_9;
LABEL_7:
  v12 = (std::__shared_weak_count_vtbl *)CFRetain(v5);
LABEL_10:
  v13 = (std::__shared_weak_count *)operator new();
  v13->__shared_owners_ = 0;
  v14 = (unint64_t *)&v13->__shared_owners_;
  v13->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19E8;
  v13->__shared_weak_owners_ = 0;
  v13[1].__vftable = v12;
  v46 = v13;
  v15 = *((unsigned int *)this + 14);
  v16 = *(_QWORD *)(v8 + 24);
  v49 = v12;
  v50 = v13;
  do
    v17 = __ldxr(v14);
  while (__stxr(v17 + 1, v14));
  (*(void (**)(uint64_t, std::__shared_weak_count_vtbl **, uint64_t))(*(_QWORD *)v16 + 16))(v16, &v49, v15);
  v18 = v50;
  if (v50)
  {
    v19 = (unint64_t *)&v50->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  if (v46)
  {
    v21 = (unint64_t *)&v46->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
  if (v47)
  {
    v23 = (unint64_t *)&v47->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
  }
  v25 = (_QWORD *)*((_QWORD *)this + 5);
  if (v25)
  {
    v26 = v25[98];
    v27 = (std::__shared_weak_count *)v25[99];
    v48 = v27;
    if (v27)
    {
      v28 = (unint64_t *)&v27->__shared_owners_;
      do
        v29 = __ldxr(v28);
      while (__stxr(v29 + 1, v28));
      v25 = (_QWORD *)*((_QWORD *)this + 5);
    }
  }
  else
  {
    v26 = 0;
    v48 = 0;
  }
  v30 = objc_msgSend(v25, "session");
  if (!v30)
  {
    v31 = 0;
    v45 = 0;
    goto LABEL_41;
  }
  v31 = *(std::__shared_weak_count_vtbl **)(v30 + 16);
  v32 = *(std::__shared_weak_count **)(v30 + 24);
  v45 = v32;
  if (!v32)
  {
LABEL_41:
    v35 = *(_QWORD *)(v26 + 24);
    v49 = v31;
    v50 = 0;
    goto LABEL_42;
  }
  v33 = (unint64_t *)&v32->__shared_owners_;
  do
    v34 = __ldxr(v33);
  while (__stxr(v34 + 1, v33));
  v35 = *(_QWORD *)(v26 + 24);
  v36 = (unint64_t *)&v32->__shared_owners_;
  v49 = v31;
  v50 = v32;
  do
    v37 = __ldxr(v36);
  while (__stxr(v37 + 1, v36));
LABEL_42:
  (*(void (**)(uint64_t, std::__shared_weak_count_vtbl **))(*(_QWORD *)v35 + 240))(v35, &v49);
  v38 = v50;
  if (v50)
  {
    v39 = (unint64_t *)&v50->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  if (v45)
  {
    v41 = (unint64_t *)&v45->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  if (v48)
  {
    v43 = (unint64_t *)&v48->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
  }
}

void sub_18405EBD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a15);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void TCPIO_Establish::beginConnection(TCPIO_Establish *this, int a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  void *v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  const __CFDictionary *v21;
  const __CFAllocator *v22;
  const __CFDictionary *MutableCopy;
  const __CFDictionary *Value;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v26;
  uint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t *p_shared_weak_owners;
  unint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  uint64_t v45;
  NSObject *v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  std::__shared_weak_count *v59;
  _QWORD aBlock[5];
  std::__shared_weak_count *v61;
  char *v62;
  std::__shared_weak_count *v63;
  uint64_t v64;
  std::__shared_weak_count *v65;
  uint64_t v66;
  std::__shared_weak_count *v67;
  _QWORD v68[5];
  _QWORD v69[5];
  _QWORD v70[5];
  _QWORD v71[5];
  _QWORD v72[5];
  _BYTE buf[24];
  void *v74;
  uint64_t v75;
  uint64_t v76;
  std::__shared_weak_count *v77;
  uint64_t v78;
  std::__shared_weak_count *v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)this + 5);
  if (v4)
  {
    v5 = (uint64_t *)(v4 + 784);
    v6 = *v5;
    v66 = *v5;
    v7 = (std::__shared_weak_count *)v5[1];
    v67 = v7;
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }
  }
  else
  {
    v6 = 0;
    v66 = 0;
    v67 = 0;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v10 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v11 = *((_QWORD *)this + 5);
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)&buf[4] = this;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v11;
    _os_log_impl(&dword_183ECA000, v10, OS_LOG_TYPE_DEFAULT, "Establish Object : %p .Task : %p", buf, 0x16u);
  }
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v64, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
  v12 = MEMORY[0x1E0C809B0];
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3321888768;
  aBlock[2] = ___ZN15TCPIO_Establish15beginConnectionEb_block_invoke;
  aBlock[3] = &__block_descriptor_48_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE_e5_v8__0l;
  aBlock[4] = v64;
  v61 = v65;
  if (v65)
  {
    v13 = (unint64_t *)&v65->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  v15 = _Block_copy(aBlock);
  v62 = (char *)this + 24;
  v16 = (std::__shared_weak_count *)operator new();
  v16->__shared_owners_ = 0;
  v17 = (unint64_t *)&v16->__shared_owners_;
  v16->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1B00;
  v16->__shared_weak_owners_ = 0;
  v16[1].__vftable = (std::__shared_weak_count_vtbl *)((char *)this + 24);
  v16[1].__shared_owners_ = (uint64_t)v15;
  v16[1].__shared_weak_owners_ = 0;
  v63 = v16;
  v18 = *(_QWORD *)(v6 + 24);
  do
    v19 = __ldxr(v17);
  while (__stxr(v19 + 1, v17));
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v18 + 144), (uint64_t)this + 24, (uint64_t)v16);
  do
    v20 = __ldaxr(v17);
  while (__stlxr(v20 - 1, v17));
  if (!v20)
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  v21 = (const __CFDictionary *)objc_msgSend(*((id *)this + 5), "_copySocketStreamProperties");
  v22 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (v21)
  {
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v21);
    CFRelease(v21);
  }
  else
  {
    MutableCopy = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(MutableCopy, CFSTR("kCFStreamPropertySSLSettings"));
  if (Value)
    Mutable = CFDictionaryCreateMutableCopy(v22, 0, Value);
  else
    Mutable = CFDictionaryCreateMutable(v22, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v26 = Mutable;
  CFDictionarySetValue(MutableCopy, CFSTR("kCFStreamPropertySSLSettings"), Mutable);
  if (v26)
    CFRelease(v26);
  v27 = v66;
  if (a2)
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v66 + 24) + 24))(*(_QWORD *)(v66 + 24), 1);
  if (MutableCopy)
  {
    (*(void (**)(_QWORD, const __CFDictionary *))(**(_QWORD **)(v27 + 24) + 208))(*(_QWORD *)(v27 + 24), MutableCopy);
    CFRelease(MutableCopy);
  }
  v59 = v67;
  if (v67)
  {
    v28 = (unint64_t *)&v67->__shared_owners_;
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  v30 = *((_QWORD *)this + 4);
  v72[0] = v12;
  v72[1] = 3221225472;
  v72[2] = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke;
  v72[3] = &unk_1E14F95F0;
  v72[4] = v30;
  (*(void (**)(_QWORD, uint64_t, _QWORD *))(**(_QWORD **)(v27 + 24) + 200))(*(_QWORD *)(v27 + 24), 0x1EDCFA448, v72);
  v71[0] = v12;
  v71[1] = 3221225472;
  v71[2] = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_3;
  v71[3] = &unk_1E14F95F0;
  v71[4] = v30;
  (*(void (**)(_QWORD, uint64_t, _QWORD *))(**(_QWORD **)(v27 + 24) + 200))(*(_QWORD *)(v27 + 24), 0x1EDCFA640, v71);
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(buf, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
  v32 = *(_QWORD *)buf;
  v31 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v33 = (unint64_t *)(*(_QWORD *)&buf[8] + 16);
    do
      v34 = __ldxr(v33);
    while (__stxr(v34 + 1, v33));
    v35 = (unint64_t *)&v31->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  if (v59)
  {
    p_shared_weak_owners = (unint64_t *)&v59->__shared_weak_owners_;
    do
      v38 = __ldxr(p_shared_weak_owners);
    while (__stxr(v38 + 1, p_shared_weak_owners));
  }
  *(_QWORD *)buf = v12;
  *(_QWORD *)&buf[8] = 3321888768;
  *(_QWORD *)&buf[16] = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_5;
  v74 = &unk_1E14F4308;
  v75 = v30;
  v76 = v27;
  v77 = v59;
  if (v59)
  {
    v39 = (unint64_t *)&v59->__shared_weak_owners_;
    do
      v40 = __ldxr(v39);
    while (__stxr(v40 + 1, v39));
  }
  v78 = v32;
  v79 = v31;
  if (v31)
  {
    v41 = (unint64_t *)&v31->__shared_weak_owners_;
    do
      v42 = __ldxr(v41);
    while (__stxr(v42 + 1, v41));
  }
  (*(void (**)(_QWORD, uint64_t, _BYTE *))(**(_QWORD **)(v27 + 24) + 200))(*(_QWORD *)(v27 + 24), 0x1EDCFA2C0, buf);
  v70[0] = v12;
  v70[1] = 3221225472;
  v70[2] = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_276;
  v70[3] = &unk_1E14F9618;
  v70[4] = v30;
  (*(void (**)(_QWORD, uint64_t, _QWORD *))(**(_QWORD **)(v27 + 24) + 200))(*(_QWORD *)(v27 + 24), 0x1EDCFA2F8, v70);
  v69[0] = v12;
  v69[1] = 3221225472;
  v69[2] = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_3_280;
  v69[3] = &unk_1E14F9640;
  v69[4] = v30;
  (*(void (**)(_QWORD, uint64_t, _QWORD *))(**(_QWORD **)(v27 + 24) + 200))(*(_QWORD *)(v27 + 24), 0x1EDCFA170, v69);
  v68[0] = v12;
  v68[1] = 3221225472;
  v68[2] = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_5_282;
  v68[3] = &unk_1E14FE118;
  v68[4] = v30;
  (*(void (**)(_QWORD, uint64_t, _QWORD *))(**(_QWORD **)(v27 + 24) + 200))(*(_QWORD *)(v27 + 24), 0x1EDCFA1A8, v68);
  if (v79)
    std::__shared_weak_count::__release_weak(v79);
  if (v77)
    std::__shared_weak_count::__release_weak(v77);
  if (v59)
    std::__shared_weak_count::__release_weak(v59);
  if (v31)
    std::__shared_weak_count::__release_weak(v31);
  if (v59)
  {
    v43 = (unint64_t *)&v59->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
  }
  v45 = v66;
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v66 + 24) + 200))(*(_QWORD *)(v66 + 24), 0x1EDCFAC98, *MEMORY[0x1E0C9AE50]);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v46 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_183ECA000, v46, OS_LOG_TYPE_DEFAULT, "StreamTask opening connection", buf, 2u);
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(v45 + 24) + 32))(*(_QWORD *)(v45 + 24));
  v47 = v63;
  if (v63)
  {
    v48 = (unint64_t *)&v63->__shared_owners_;
    do
      v49 = __ldaxr(v48);
    while (__stlxr(v49 - 1, v48));
    if (!v49)
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
  }
  v50 = v61;
  if (v61)
  {
    v51 = (unint64_t *)&v61->__shared_owners_;
    do
      v52 = __ldaxr(v51);
    while (__stlxr(v52 - 1, v51));
    if (!v52)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }
  v53 = v65;
  if (v65)
  {
    v54 = (unint64_t *)&v65->__shared_owners_;
    do
      v55 = __ldaxr(v54);
    while (__stlxr(v55 - 1, v54));
    if (!v55)
    {
      ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
      std::__shared_weak_count::__release_weak(v53);
    }
  }
  v56 = v67;
  if (v67)
  {
    v57 = (unint64_t *)&v67->__shared_owners_;
    do
      v58 = __ldaxr(v57);
    while (__stlxr(v58 - 1, v57));
    if (!v58)
    {
      ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
      std::__shared_weak_count::__release_weak(v56);
    }
  }
}

void sub_18405F394(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, char a20,uint64_t a21,char a22)
{
  std::__shared_weak_count *v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  std::__shared_weak_count *v26;
  std::__shared_weak_count *v27;

  v26 = *(std::__shared_weak_count **)(v24 - 128);
  if (v26)
    std::__shared_weak_count::__release_weak(v26);
  v27 = *(std::__shared_weak_count **)(v24 - 144);
  if (v27)
  {
    std::__shared_weak_count::__release_weak(v27);
    if (!v23)
    {
LABEL_5:
      if (!v22)
      {
LABEL_10:
        std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
        std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a18);
        std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a16);
        std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a20);
        std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a22);
        _Unwind_Resume(a1);
      }
LABEL_9:
      std::__shared_weak_count::__release_weak(v22);
      goto LABEL_10;
    }
  }
  else if (!v23)
  {
    goto LABEL_5;
  }
  std::__shared_weak_count::__release_weak(v23);
  if (!v22)
    goto LABEL_10;
  goto LABEL_9;
}

void TCPIO_Establish::endConnection(TCPIO_Establish *this)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  int v12;
  TCPIO_Establish *v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *((_QWORD *)this + 5);
    v12 = 134218240;
    v13 = this;
    v14 = 2048;
    v15 = v3;
    _os_log_impl(&dword_183ECA000, v2, OS_LOG_TYPE_DEFAULT, "Establish Object : %p .Task : %p", (uint8_t *)&v12, 0x16u);
  }
  v4 = *((_QWORD *)this + 5);
  if (v4)
  {
    v5 = v4 + 784;
    v6 = *(_QWORD *)(v4 + 784);
    v7 = *(std::__shared_weak_count **)(v5 + 8);
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }
    if (v6)
      TransportConnection::rstConnectionEstablishmentDelegate(*(TransportConnection **)(v6 + 24));
    if (*((_QWORD *)this + 5))
      *((_QWORD *)this + 5) = 0;
    if (v7)
    {
      v10 = (unint64_t *)&v7->__shared_owners_;
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
}

uint64_t TCPIO_Establish::connectionEstablished(id *this, CFStreamError a2)
{
  uint64_t v2;
  CFIndex domain;
  uint64_t result;

  v2 = *(_QWORD *)&a2.error;
  domain = a2.domain;
  result = objc_msgSend(this[5], "_onqueue_cleanUpConnectionEstablishmentState");
  if (!*((_BYTE *)this + 65))
  {
    *((_BYTE *)this + 65) = 1;
    return objc_msgSend(this[5], "_onqueue_connectionEstablishedWithError:callbackReferent:", domain, v2, this[4]);
  }
  return result;
}

void TCPIO_Establish::beginSecureConnection(TCPIO_Establish *this)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  void *v10;
  std::__shared_weak_count_vtbl *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  _QWORD v29[5];
  std::__shared_weak_count *v30;
  char *v31;
  std::__shared_weak_count *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  uint64_t v35;
  std::__shared_weak_count *v36;

  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v35, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = (uint64_t *)(v2 + 784);
    v4 = *v3;
    v33 = *v3;
    v5 = (std::__shared_weak_count *)v3[1];
    v34 = v5;
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
  }
  else
  {
    v4 = 0;
    v33 = 0;
    v34 = 0;
  }
  v29[0] = MEMORY[0x1E0C809B0];
  v29[1] = 3321888768;
  v29[2] = ___ZN15TCPIO_Establish21beginSecureConnectionEv_block_invoke;
  v29[3] = &__block_descriptor_48_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE_e5_v8__0l;
  v29[4] = v35;
  v30 = v36;
  if (v36)
  {
    v8 = (unint64_t *)&v36->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = _Block_copy(v29);
  v11 = (std::__shared_weak_count_vtbl *)((char *)this + 24);
  v31 = (char *)this + 24;
  v12 = (std::__shared_weak_count *)operator new();
  v12->__shared_owners_ = 0;
  v13 = (unint64_t *)&v12->__shared_owners_;
  v12->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1B00;
  v12->__shared_weak_owners_ = 0;
  v12[1].__vftable = v11;
  v12[1].__shared_owners_ = (uint64_t)v10;
  v12[1].__shared_weak_owners_ = 0;
  v32 = v12;
  v14 = *(_QWORD *)(v4 + 24);
  do
    v15 = __ldxr(v13);
  while (__stxr(v15 + 1, v13));
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v14 + 144), (uint64_t)v11, (uint64_t)v12);
  do
    v16 = __ldaxr(v13);
  while (__stlxr(v16 - 1, v13));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v33 + 24) + 24))(*(_QWORD *)(v33 + 24), 1);
  v17 = v32;
  if (v32)
  {
    v18 = (unint64_t *)&v32->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v30;
  if (v30)
  {
    v21 = (unint64_t *)&v30->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  v23 = v34;
  if (v34)
  {
    v24 = (unint64_t *)&v34->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  v26 = v36;
  if (v36)
  {
    v27 = (unint64_t *)&v36->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
}

void sub_18405F848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  va_list va1;
  uint64_t v12;
  va_list va2;

  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v10 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 64);
  _Unwind_Resume(a1);
}

void TCPIO_Establish::endSecureConnection(TCPIO_Establish *this)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  void *v10;
  std::__shared_weak_count_vtbl *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  _QWORD v28[5];
  std::__shared_weak_count *v29;
  char *v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;

  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v34, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = (uint64_t *)(v2 + 784);
    v4 = *v3;
    v32 = *v3;
    v5 = (std::__shared_weak_count *)v3[1];
    v33 = v5;
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
  }
  else
  {
    v4 = 0;
    v32 = 0;
    v33 = 0;
  }
  v28[0] = MEMORY[0x1E0C809B0];
  v28[1] = 3321888768;
  v28[2] = ___ZN15TCPIO_Establish19endSecureConnectionEv_block_invoke;
  v28[3] = &__block_descriptor_48_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE_e5_v8__0l;
  v28[4] = v34;
  v29 = v35;
  if (v35)
  {
    v8 = (unint64_t *)&v35->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = _Block_copy(v28);
  v11 = (std::__shared_weak_count_vtbl *)((char *)this + 24);
  v30 = (char *)this + 24;
  v12 = (std::__shared_weak_count *)operator new();
  v12->__shared_owners_ = 0;
  v13 = (unint64_t *)&v12->__shared_owners_;
  v12->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1B00;
  v12->__shared_weak_owners_ = 0;
  v12[1].__vftable = v11;
  v12[1].__shared_owners_ = (uint64_t)v10;
  v12[1].__shared_weak_owners_ = 0;
  v31 = v12;
  if (!v4)
    goto LABEL_16;
  v14 = *(_QWORD *)(v4 + 24);
  do
    v15 = __ldxr(v13);
  while (__stxr(v15 + 1, v13));
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v14 + 144), (uint64_t)v11, (uint64_t)v12);
  do
    v16 = __ldaxr(v13);
  while (__stlxr(v16 - 1, v13));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v32 + 24) + 24))(*(_QWORD *)(v32 + 24), 0);
  v12 = v31;
  if (v31)
  {
LABEL_16:
    v17 = (unint64_t *)&v12->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v19 = v29;
  if (v29)
  {
    v20 = (unint64_t *)&v29->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v22 = v33;
  if (v33)
  {
    v23 = (unint64_t *)&v33->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = v35;
  if (v35)
  {
    v26 = (unint64_t *)&v35->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
}

void sub_18405FAF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  va_list va1;
  uint64_t v12;
  va_list va2;

  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v10 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 64);
  _Unwind_Resume(a1);
}

uint64_t TCPIO_Establish::getBlockCallbackReferent(TCPIO_Establish *this)
{
  return *((_QWORD *)this + 4);
}

uint64_t TCPIO_Establish::needServerTrust(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  const __CFString *v6;
  const void *Challenge;
  id v8;
  _QWORD v10[5];

  if (!*(_QWORD *)(a1 + 40))
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a3 + 16))(a3, 0, 1);
  v6 = *(const __CFString **)(a1 + 48);
  v5 = *(_QWORD *)(a1 + 56);
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = ___ZN22HTTPProtocolSSLSupport35CreateTrustChallengeWithHostAndPortEPK10__CFStringlP10__SecTrust_block_invoke;
  v10[3] = &__block_descriptor_40_e32_v16__0___CFURLProtectionSpace__8l;
  v10[4] = a2;
  Challenge = (const void *)createChallenge(8, v6, v5, (uint64_t)v10);
  v8 = +[NSURLAuthenticationChallenge _authenticationChallengeForCFAuthChallenge:sender:](NSURLAuthenticationChallenge, "_authenticationChallengeForCFAuthChallenge:sender:", Challenge, 0);
  if (Challenge)
    CFRelease(Challenge);
  return objc_msgSend(*(id *)(a1 + 40), "_onqueue_needServerTrust:completionHandler:", v8, a3);
}

uint64_t TCPIO_Establish::needClientCert(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  const __CFString *v7;
  const void *Challenge;
  id v9;
  void *v10;
  _QWORD v12[5];
  _QWORD v13[5];

  if (!a1[5])
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a3 + 16))(a3, 0, 1);
  v5 = MEMORY[0x1E0C809B0];
  v7 = (const __CFString *)a1[6];
  v6 = a1[7];
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3221225472;
  v13[2] = ___ZN22HTTPProtocolSSLSupport40CreateClientCertChallengeWithHostAndPortEPK10__CFStringlPK9__CFArray_block_invoke;
  v13[3] = &__block_descriptor_40_e32_v16__0___CFURLProtectionSpace__8l;
  v13[4] = a2;
  Challenge = (const void *)createChallenge(7, v7, v6, (uint64_t)v13);
  v9 = +[NSURLAuthenticationChallenge _authenticationChallengeForCFAuthChallenge:sender:](NSURLAuthenticationChallenge, "_authenticationChallengeForCFAuthChallenge:sender:", Challenge, 0);
  if (Challenge)
    CFRelease(Challenge);
  v10 = (void *)a1[5];
  v12[0] = v5;
  v12[1] = 3221225472;
  v12[2] = ___ZN15TCPIO_Establish14needClientCertEPK9__CFArrayU13block_pointerFvS2_bE_block_invoke;
  v12[3] = &unk_1E14FC778;
  v12[4] = a3;
  return objc_msgSend(v10, "_onqueue_needClientCert:completionHandler:", v9, v12);
}

uint64_t TCPIO_Establish::preConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v8;
  uint64_t v9;
  void *v10;
  int v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v8 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v9 = *(_QWORD *)(a1 + 40);
    v12 = 134218240;
    v13 = a1;
    v14 = 2048;
    v15 = v9;
    _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_DEFAULT, "Establish Object : %p .Task : %p", (uint8_t *)&v12, 0x16u);
  }
  v10 = *(void **)(a1 + 40);
  if (v10)
    return objc_msgSend(v10, "_onqueue_preConnectionConfiguration:parameters:completionHandler:", a2, a3, a4);
  else
    return (*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
}

uint64_t TCPIO_Establish::postConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v4;

  v4 = *(void **)(a1 + 40);
  if (v4)
    return objc_msgSend(v4, "_onqueue_postConnectConfiguration:parameters:completionHandler:", a2, a3, a4);
  else
    return (*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
}

void TCPIO_Establish::setTransportConnection(uint64_t a1, uint64_t *a2)
{
  void *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v2 = *(void **)(a1 + 40);
  v3 = (std::__shared_weak_count *)a2[1];
  v9 = *a2;
  v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  objc_msgSend(v2, "_onqueue_setTransportConnection:", &v9);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_18405FED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t TCPIO_Establish::connectionTLSEnabled(id *this)
{
  return objc_msgSend(this[5], "_onqueue_tlsCompletion");
}

uint64_t TCPIO_Establish::connectionTLSDisabled(id *this)
{
  return objc_msgSend(this[5], "_onqueue_tlsDisabled");
}

void TCPIO_Establish::connectionWaitingNotification(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  if (objc_msgSend((id)objc_msgSend(*(id *)(a1 + 40), "_effectiveConfiguration"), "waitsForConnectivity")
    && !*(_BYTE *)(a1 + 64))
  {
    *(_BYTE *)(a1 + 64) = 1;
    v2 = *(_QWORD **)(a1 + 40);
    if (v2)
    {
      v3 = v2[88];
      if (!v3)
        v3 = v2[87];
    }
    else
    {
      v3 = 0;
    }
    -[__NSCFURLSessionDelegateWrapper taskIsWaitingForConnectivity:](v3, v2);
  }
}

void `non-virtual thunk to'TCPIO_Establish::~TCPIO_Establish(TCPIO_Establish *this)
{
  TCPIO_Establish::~TCPIO_Establish((TCPIO_Establish *)((char *)this - 24));
}

{
  TCPIO_Establish::~TCPIO_Establish((TCPIO_Establish *)((char *)this - 24));
  JUMPOUT(0x186DB748CLL);
}

uint64_t `non-virtual thunk to'TCPIO_Establish::preConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return TCPIO_Establish::preConnectConfiguration(a1 - 24, a2, a3, a4);
}

uint64_t `non-virtual thunk to'TCPIO_Establish::postConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v4;

  v4 = *(void **)(a1 + 16);
  if (v4)
    return objc_msgSend(v4, "_onqueue_postConnectConfiguration:parameters:completionHandler:", a2, a3, a4);
  else
    return (*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
}

uint64_t `non-virtual thunk to'TCPIO_Establish::needServerTrust(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return TCPIO_Establish::needServerTrust(a1 - 24, a2, a3);
}

uint64_t `non-virtual thunk to'TCPIO_Establish::needClientCert(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return TCPIO_Establish::needClientCert((_QWORD *)(a1 - 24), a2, a3);
}

uint64_t `non-virtual thunk to'TCPIO_Establish::connectionEstablished(id *this, CFStreamError a2)
{
  uint64_t v2;
  CFIndex domain;
  uint64_t result;

  v2 = *(_QWORD *)&a2.error;
  domain = a2.domain;
  result = objc_msgSend(this[2], "_onqueue_cleanUpConnectionEstablishmentState");
  if (!*((_BYTE *)this + 41))
  {
    *((_BYTE *)this + 41) = 1;
    return objc_msgSend(this[2], "_onqueue_connectionEstablishedWithError:callbackReferent:", domain, v2, this[1]);
  }
  return result;
}

uint64_t `non-virtual thunk to'TCPIO_Establish::connectionTLSEnabled(id *this)
{
  return objc_msgSend(this[2], "_onqueue_tlsCompletion");
}

uint64_t `non-virtual thunk to'TCPIO_Establish::connectionTLSDisabled(id *this)
{
  return objc_msgSend(this[2], "_onqueue_tlsDisabled");
}

void `non-virtual thunk to'TCPIO_Establish::connectionWaitingNotification(uint64_t a1)
{
  TCPIO_Establish::connectionWaitingNotification(a1 - 24);
}

void `non-virtual thunk to'TCPIO_Establish::setTransportConnection(uint64_t a1, uint64_t *a2)
{
  TCPIO_Establish::setTransportConnection(a1 - 24, a2);
}

void sub_1840600B8(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  std::__shared_weak_count *v3;

  *v1 = &off_1E14E5838;
  v3 = (std::__shared_weak_count *)v1[2];
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN15TCPIO_Establish14needClientCertEPK9__CFArrayU13block_pointerFvS2_bE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void std::__shared_ptr_pointer<TransportConnection::ConnectionEstablishmentDelegate *,Deleter_CustomBlock,std::allocator<TransportConnection::ConnectionEstablishmentDelegate>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t __copy_helper_block_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_5(_QWORD *a1, int a2, uint64_t a3)
{
  uint64_t v5;
  TCPIO_BlockCallbacks_Listener *v6;
  char v7;
  TCPIO_BlockCallbacks_Listener *v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  dispatch_object_t *v13;
  NSObject *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  std::__shared_weak_count *v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  _QWORD v28[5];
  std::__shared_weak_count *v29;
  uint64_t v30;
  std::__shared_weak_count *v31;

  v5 = a1[4];
  if (!v5)
  {
    v7 = 0;
    if ((_DWORD)a3)
      return;
    goto LABEL_8;
  }
  v6 = *(TCPIO_BlockCallbacks_Listener **)(v5 + 8);
  if (v6)
    v7 = TCPIO_BlockCallbacks_Listener::receiveEvent(v6, CFSTR("_kCFStreamPropertyConnectionViabilityChangedBlock"), a3);
  else
    v7 = 0;
  v8 = *(TCPIO_BlockCallbacks_Listener **)(v5 + 16);
  if (v8)
    v7 |= TCPIO_BlockCallbacks_Listener::receiveEvent(v8, CFSTR("_kCFStreamPropertyConnectionViabilityChangedBlock"), a3);
  if (!(_DWORD)a3)
  {
LABEL_8:
    if ((v7 & 1) == 0)
    {
      v9 = (std::__shared_weak_count *)a1[6];
      if (v9 && (v10 = std::__shared_weak_count::lock(v9), (v31 = v10) != 0))
      {
        v11 = v10;
        v12 = a1[5];
        v30 = v12;
        if (v12)
        {
          v13 = *(dispatch_object_t **)(v12 + 24);
          v14 = v13[15];
          if (!v14 || (dispatch_retain(v13[15]), (v13 = *(dispatch_object_t **)(v12 + 24)) != 0))
          {
            if (!*(_BYTE *)(v12 + 40))
            {
              *(_BYTE *)(v12 + 40) = 1;
              ((void (*)(dispatch_object_t *, _QWORD))(*v13)[19].isa)(v13, 0);
            }
          }
        }
        else
        {
          v14 = 0;
        }
        p_shared_owners = (unint64_t *)&v11->__shared_owners_;
        do
          v16 = __ldaxr(p_shared_owners);
        while (__stlxr(v16 - 1, p_shared_owners));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }
      else
      {
        v14 = 0;
      }
      v17 = (std::__shared_weak_count *)a1[8];
      if (v17)
      {
        v18 = std::__shared_weak_count::lock(v17);
        if (v18)
        {
          v19 = v18;
          v20 = a1[7];
          if (v20)
          {
            if (v14)
            {
              v28[0] = MEMORY[0x1E0C809B0];
              v28[1] = 3321888768;
              v28[2] = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_7;
              v28[3] = &__block_descriptor_48_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE_e5_v8__0l;
              v28[4] = v20;
              v29 = v18;
              v21 = (unint64_t *)&v18->__shared_owners_;
              do
                v22 = __ldxr(v21);
              while (__stxr(v22 + 1, v21));
              dispatch_async(v14, v28);
              v23 = v29;
              if (v29)
              {
                v24 = (unint64_t *)&v29->__shared_owners_;
                do
                  v25 = __ldaxr(v24);
                while (__stlxr(v25 - 1, v24));
                if (!v25)
                {
                  ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
                  std::__shared_weak_count::__release_weak(v23);
                }
              }
            }
          }
          v26 = (unint64_t *)&v19->__shared_owners_;
          do
            v27 = __ldaxr(v26);
          while (__stlxr(v27 - 1, v26));
          if (!v27)
          {
            ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
            std::__shared_weak_count::__release_weak(v19);
          }
        }
      }
      if (v14)
        dispatch_release(v14);
    }
  }
}

void sub_184060404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t TCPIO_BlockCallbacks_Listener::receiveEvent(TCPIO_BlockCallbacks_Listener *this, const __CFString *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;

  result = (uint64_t)TCPIO_BlockCallbacks_Listener::findPropertyBlockPtr(this, a2);
  if (result)
  {
    v6 = *(_QWORD *)result;
    if (*(_QWORD *)result)
    {
      v7 = (*((uint64_t (**)(TCPIO_BlockCallbacks_Listener *))this->var0 + 2))(this);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 16))(v6, v7, a3);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_QWORD *__copy_helper_block_e8_40c50_ZTSNSt3__18weak_ptrI25TransportConnectionObjCPPEE56c44_ZTSNSt3__18weak_ptrI19TCPIO_EstablishBaseEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[8];
  result[7] = a2[7];
  result[8] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 16);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

void __destroy_helper_block_e8_40c50_ZTSNSt3__18weak_ptrI25TransportConnectionObjCPPEE56c44_ZTSNSt3__18weak_ptrI19TCPIO_EstablishBaseEE(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;

  v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

uint64_t ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_7(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a1 + 32) + 40))(*(_QWORD *)(a1 + 32), 1, 57);
}

id *TCPIO_BlockCallbacks_Listener::receiveEvent(TCPIO_BlockCallbacks_Listener *this, const __CFString *a2)
{
  id *result;
  uint64_t (**v4)(id, uint64_t);
  uint64_t v5;

  result = TCPIO_BlockCallbacks_Listener::findPropertyBlockPtr(this, a2);
  if (result)
  {
    v4 = (uint64_t (**)(id, uint64_t))*result;
    if (*result)
    {
      v5 = (*((uint64_t (**)(TCPIO_BlockCallbacks_Listener *))this->var0 + 2))(this);
      return (id *)v4[2](v4, v5);
    }
  }
  return result;
}

void std::__shared_ptr_emplace<TCPIO_Establish>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0B40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TCPIO_Establish>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0B40;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_emplace<TCPIO_Establish>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<TransportConnectionObjCPP>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0E18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TransportConnectionObjCPP>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0E18;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_emplace<TransportConnectionObjCPP>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_184060824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t subclassMissingImplementation(objc_selector *a1, objc_class *a2)
{
  void *v3;
  uint64_t v4;
  const char *Name;

  v3 = (void *)MEMORY[0x1E0C99DA0];
  v4 = *MEMORY[0x1E0C99778];
  Name = sel_getName((SEL)a1);
  return objc_msgSend(v3, "raise:format:", v4, CFSTR("*** -%s cannot be sent to an abstract object of class %s: Create a concrete instance!"), Name, class_getName(a2));
}

void HandySSLSettings::~HandySSLSettings(HandySSLSettings *this)
{
  const void *v1;

  *(_QWORD *)this = &off_1E14E80B0;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
}

{
  const void *v1;

  *(_QWORD *)this = &off_1E14E80B0;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x186DB748CLL);
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::string>>,0>(uint64_t a1)
{
  void **v2;

  v2 = (void **)(a1 + 24);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v2);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:nn180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::string>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,0>(uint64_t a1)
{
  std::__tree<std::shared_ptr<void>>::destroy(*(_QWORD **)(a1 + 32));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::shared_ptr<__CoalescingConnectionKey>>,0>(uint64_t a1)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 24);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(24 * a1);
}

uint64_t std::set<std::string>::set[abi:nn180100](uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  BOOL v10;
  uint64_t **v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t *v15;
  _QWORD *v16;

  *(_QWORD *)(a1 + 8) = 0;
  v3 = a1 + 8;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  v4 = a2 + 1;
  v5 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      v6 = *(_QWORD *)(a1 + 8);
      v7 = (_QWORD *)v3;
      if (*(_QWORD *)a1 == v3)
        goto LABEL_8;
      v8 = *(_QWORD **)(a1 + 8);
      v9 = (_QWORD *)v3;
      if (v6)
      {
        do
        {
          v7 = v8;
          v8 = (_QWORD *)v8[1];
        }
        while (v8);
      }
      else
      {
        do
        {
          v7 = (_QWORD *)v9[2];
          v10 = *v7 == (_QWORD)v9;
          v9 = v7;
        }
        while (v10);
      }
      if (std::less<std::string>::operator()[abi:nn180100](v7 + 4, v5 + 4))
      {
LABEL_8:
        if (!v6)
        {
          v16 = (_QWORD *)v3;
          v11 = (uint64_t **)v3;
LABEL_14:
          std::__tree<std::string>::__construct_node<std::string const&>((uint64_t)&v15, a1, (uint64_t)(v5 + 4));
          std::__tree<std::string>::__insert_node_at((uint64_t **)a1, (uint64_t)v16, v11, v15);
          goto LABEL_15;
        }
        v16 = v7;
        v11 = (uint64_t **)(v7 + 1);
      }
      else
      {
        v11 = (uint64_t **)std::__tree<std::string>::__find_equal<std::string>(a1, &v16, v5 + 4);
      }
      if (!*v11)
        goto LABEL_14;
LABEL_15:
      v12 = (_QWORD *)v5[1];
      if (v12)
      {
        do
        {
          v13 = v12;
          v12 = (_QWORD *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          v13 = (_QWORD *)v5[2];
          v10 = *v13 == (_QWORD)v5;
          v5 = v13;
        }
        while (!v10);
      }
      v5 = v13;
    }
    while (v13 != v4);
  }
  return a1;
}

void sub_184060ECC(_Unwind_Exception *a1)
{
  char **v1;

  std::__tree<std::string>::destroy(*v1);
  _Unwind_Resume(a1);
}

std::string *std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(__int128 *a1, __int128 *a2, std::string *this)
{
  __int128 *v5;
  __int128 v6;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      if (*((char *)v5 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)v5, *((_QWORD *)v5 + 1));
      }
      else
      {
        v6 = *v5;
        this->__r_.__value_.__r.__words[2] = *((_QWORD *)v5 + 2);
        *(_OWORD *)&this->__r_.__value_.__l.__data_ = v6;
      }
      v5 = (__int128 *)((char *)v5 + 24);
      ++this;
    }
    while (v5 != a2);
  }
  return this;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::vector<std::string>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::vector<std::string>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::string>>,0>((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

void std::unique_ptr<std::__tree_node<std::shared_ptr<__CoalescingConnectionKey>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<__CoalescingConnectionKey>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::shared_ptr<__CoalescingConnectionKey>>,0>((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

_QWORD *std::__tree<std::string>::_DetachedTreeCache::__detach_next(uint64_t a1)
{
  _QWORD *result;
  _QWORD *v3;
  _QWORD *v4;

  result = *(_QWORD **)(a1 + 16);
  if (result)
  {
    v3 = (_QWORD *)*result;
    if (*result == a1)
    {
      *result = 0;
      while (1)
      {
        v4 = (_QWORD *)result[1];
        if (!v4)
          break;
        do
        {
          result = v4;
          v4 = (_QWORD *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; v3 = (_QWORD *)result[1])
      {
        do
        {
          result = v3;
          v3 = (_QWORD *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

uint64_t std::__tree<std::string>::_DetachedTreeCache::~_DetachedTreeCache[abi:nn180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  std::__tree<std::string>::destroy(*(char **)(a1 + 16));
  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    v3 = *(_QWORD *)(v2 + 16);
    if (v3)
    {
      do
      {
        v2 = v3;
        v3 = *(_QWORD *)(v3 + 16);
      }
      while (v3);
      *(_QWORD *)(a1 + 8) = v2;
    }
    std::__tree<std::string>::destroy((char *)v2);
  }
  return a1;
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::string,void *>>>::operator()[abi:nn180100](char a1, void **__p)
{
  if (a1)
  {
    if (*((char *)__p + 55) < 0)
      operator delete(__p[4]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,0>((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

void std::__shared_ptr_emplace<__CoalescingConnectionKey>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0E50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<__CoalescingConnectionKey>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0E50;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t __NSURLSession_CoalescingHelperIsOnDNSNameList(void *a1, void *a2)
{
  void *v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  id v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t j;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _BYTE v27[128];
  _BYTE v28[128];
  uint64_t v29;

  v3 = a1;
  v29 = *MEMORY[0x1E0C80C00];
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  result = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v23, v28, 16);
  if (result)
  {
    v5 = result;
    v6 = *(_QWORD *)v24;
    v17 = *(_QWORD *)v24;
    v18 = v3;
    do
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v24 != v6)
          objc_enumerationMutation(v3);
        v8 = (id)SecCertificateCopyDNSNames();
        v19 = 0u;
        v20 = 0u;
        v21 = 0u;
        v22 = 0u;
        v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v19, v27, 16);
        if (v9)
        {
          v10 = v9;
          v11 = *(_QWORD *)v20;
          while (2)
          {
            for (j = 0; j != v10; ++j)
            {
              if (*(_QWORD *)v20 != v11)
                objc_enumerationMutation(v8);
              v13 = *(void **)(*((_QWORD *)&v19 + 1) + 8 * j);
              if ((objc_msgSend(v13, "isEqualToString:", a2, v17) & 1) == 0)
              {
                if (!objc_msgSend(v13, "hasPrefix:", CFSTR("*")))
                  continue;
                if ((unint64_t)objc_msgSend(v13, "length") < 2)
                  continue;
                v14 = objc_msgSend(v13, "substringFromIndex:", 1);
                v15 = objc_msgSend(a2, "rangeOfString:", CFSTR("."));
                if (!v16
                  || (objc_msgSend((id)objc_msgSend(a2, "substringFromIndex:", v15), "isEqualToString:", v14) & 1) == 0)
                {
                  continue;
                }
              }
              return 1;
            }
            v10 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v19, v27, 16);
            if (v10)
              continue;
            break;
          }
        }
        v6 = v17;
        v3 = v18;
      }
      v5 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v23, v28, 16);
      result = 0;
    }
    while (v5);
  }
  return result;
}

void Schedulables::_SchedulablesScheduleApplierFunction(Schedulables *this, uint64_t *a2, void *a3)
{
  _CFTypeScheduleOnRunLoop(this, *a2, a2[1]);
}

void Schedulables::_SchedulablesUnscheduleApplierFunction(Schedulables *this, uint64_t *a2, void *a3)
{
  _CFTypeUnscheduleFromRunLoop(this, *a2, a2[1]);
}

void Schedulables::_SchedulablesInvalidateApplierFunction(Schedulables *this, const void *a2, void *a3)
{
  CFTypeID v4;

  v4 = CFGetTypeID(this);
  _CFTypeInvalidate((char *)this);
  if (HostBase::Class(void)::sOnce_HostBase != -1)
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
  if (*(_QWORD *)(HostBase::Class(void)::sClass_OBJTYPE + 96) == v4)
  {
    CFHostCancelInfoResolution(this, kCFHostAddresses);
  }
  else if (CFNetServiceGetTypeID() == v4)
  {
    CFNetServiceCancel(this);
  }
}

void Schedulables::_remove(Schedulables *this, const void *value)
{
  CFIndex FirstIndexOfValue;
  CFRange v5;

  v5.length = *((_QWORD *)this + 3);
  v5.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*((CFArrayRef *)this + 2), v5, value);
  if (FirstIndexOfValue != -1)
  {
    CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)this + 2), FirstIndexOfValue);
    --*((_QWORD *)this + 3);
  }
}

CFStringRef createStringFromSomeAddr(const __CFAllocator *a1, int (*a2)(int, sockaddr *, unsigned int *), const char *a3, uint64_t a4)
{
  int v4;
  int *v8;
  int *v9;
  uint64_t v10;
  int v11;
  char __str[1024];
  char v13;
  unsigned __int8 v14;
  unsigned __int16 v15;
  int v16;
  _QWORD v17[32];

  v4 = a4;
  v17[31] = *MEMORY[0x1E0C80C00];
  v11 = 255;
  if (a2(a4, (sockaddr *)&v13, (unsigned int *)&v11))
  {
    __error();
    snprintf(__str, 0x400uLL, "error %d resolving %s address for socket %d");
    return CFStringCreateWithFormat(a1, 0, CFSTR("%s"), __str, v10);
  }
  if (v14 == 2)
  {
    v8 = &v16;
  }
  else
  {
    if (v14 != 30)
    {
      snprintf(__str, 0x400uLL, "[error %d converting %s address for socket %d]");
      return CFStringCreateWithFormat(a1, 0, CFSTR("%s"), __str, v10);
    }
    v8 = (int *)v17;
  }
  if (!inet_ntop(v14, v8, __str, 0x400u))
  {
    v9 = __error();
    snprintf(__str, 0x400uLL, "[error %d converting %s address for socket %d]", *v9, a3, v4);
  }
  return CFStringCreateWithFormat(a1, 0, CFSTR("%s:%d"), __str, bswap32(v15) >> 16);
}

void sub_18406209C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__6280(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__6281(uint64_t a1)
{

}

uint64_t HTTP2ConnectionCacheEntry::equals(HTTP2ConnectionCacheEntry *this, const CFObject *a2)
{
  CFTypeID v4;
  uint64_t result;
  CFIndex Count;

  v4 = CFGetTypeID((char *)this - 16);
  if (v4 != CFGetTypeID((char *)a2 - 16))
    return 0;
  result = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 3) + 24))(*((_QWORD *)this + 3), *((_QWORD *)a2 + 3));
  if (!(_DWORD)result)
    return result;
  if (*((_DWORD *)this + 27) == *((_DWORD *)a2 + 27)
    && (Count = CFArrayGetCount(*((CFArrayRef *)this + 11)), Count == CFArrayGetCount(*((CFArrayRef *)this + 11)))
    && *((unsigned __int8 *)this + 104) == *((unsigned __int8 *)a2 + 104))
  {
    return *((unsigned __int8 *)this + 105) == *((unsigned __int8 *)a2 + 105);
  }
  else
  {
    return 0;
  }
}

uint64_t HTTP2ConnectionCacheEntry::hash(HTTP2ConnectionCacheEntry *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 32))(*((_QWORD *)this + 3));
}

CFStringRef HTTP2ConnectionCacheEntry::copyDebugDesc(HTTP2ConnectionCacheEntry *this)
{
  const __CFAllocator *v2;
  const __CFString *v3;
  char *v4;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v3 = (const __CFString *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 16))(*((_QWORD *)this + 3));
  v4 = _cfnAutoreleaseInDebug(v3);
  return CFStringCreateWithFormat(v2, 0, CFSTR("HTTP2ConnectionCacheEntry(@%p, key=%s)"), this, v4);
}

void `non-virtual thunk to'HTTP2ConnectionCacheEntry::~HTTP2ConnectionCacheEntry(HTTP2ConnectionCacheEntry *this)
{
  HTTP2ConnectionCacheEntry::~HTTP2ConnectionCacheEntry((HTTP2ConnectionCacheEntry *)((char *)this - 8));
}

{
  HTTP2ConnectionCacheEntry::~HTTP2ConnectionCacheEntry((HTTP2ConnectionCacheEntry *)((char *)this - 8));
}

void ___ZN25HTTP2ConnectionCacheEntry21releaseAllConnectionsEv_block_invoke(uint64_t a1, uint64_t a2)
{
  CFRelease((CFTypeRef)(a2 - 16));
}

void ___ZN25HTTP2ConnectionCacheEntry15shouldIdleCloseEdd_block_invoke(uint64_t a1, uint64_t a2)
{
  double v4;
  double v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *(double *)(a1 + 40);
  v5 = *(double *)(a1 + 48);
  v8 = 0;
  v9 = &v8;
  v10 = 0x2020000000;
  v11 = 0;
  v6 = *(int *)(a2 + 304);
  v7 = CFArrayGetCount(*(CFArrayRef *)(a2 + 232)) + v6;
  v9[3] = v7;
  _Block_object_dispose(&v8, 8);
  if (v7 > 0)
    goto LABEL_2;
  if (v4 != v5 && *(_BYTE *)(a2 + 597))
  {
    if (*(double *)(a2 + 248) <= v5)
      goto LABEL_8;
LABEL_2:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    return;
  }
  if (*(double *)(a2 + 248) > v4)
    goto LABEL_2;
LABEL_8:
  HTTP2Connection::stop((HTTP2Connection *)a2, 0);
}

void sub_184062338(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN25HTTP2ConnectionCacheEntry23shouldOpenNewConnectionEv_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  BOOL v3;

  v2 = *(_QWORD *)(*(_QWORD *)(result + 32) + 8);
  if (*(_BYTE *)(v2 + 24))
    v3 = 1;
  else
    v3 = !*(_BYTE *)(a2 + 264)
      && (*(_DWORD *)(a2 + 176) - 3) >= 2
      && (*(_QWORD *)(a2 + 144) | *(unsigned int *)(a2 + 152)) == 0;
  *(_BYTE *)(v2 + 24) = v3;
  return result;
}

void ___ZN25HTTP2ConnectionCacheEntry26markReusedAfterAPSleepWakeEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  v2 = *(_QWORD *)(a2 + 56);
  if (v2 && *(_DWORD *)v2 == 1)
  {
    v3 = *(_QWORD *)(v2 + 8);
    v4 = *(std::__shared_weak_count **)(v2 + 16);
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 160))(v3);
    if (v4)
    {
      v7 = (unint64_t *)&v4->__shared_owners_;
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_184062448(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN25HTTP2ConnectionCacheEntry23logConnectionsAtAPSleepEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  v2 = *(_QWORD *)(a2 + 56);
  if (v2 && *(_DWORD *)v2 == 1)
  {
    v3 = *(_QWORD *)(v2 + 8);
    v4 = *(std::__shared_weak_count **)(v2 + 16);
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 432))(v3);
    if (v4)
    {
      v7 = (unint64_t *)&v4->__shared_owners_;
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_184062500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

CFRunLoopSourceRef PAC::CreatePACTicket(PAC *this, const void *a2, const __CFURL *a3, const __CFData *a4, std::__shared_weak_count_vtbl *a5, void (*a6)(void *, const __CFArray *, __CFError *), CFStreamClientContext *a7)
{
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const __CFString *v20;
  const __CFString *v21;
  const __CFString *v22;
  const __CFString *v23;
  std::__shared_weak_count *v24;
  __int128 v25;
  unint64_t *p_shared_owners;
  void (*shared_owners)(void);
  std::__shared_weak_count *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t *p_shared_weak_owners;
  unint64_t v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  uint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  std::__shared_weak_count_vtbl *v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  CFTypeRef v47;
  CFTypeRef v48;
  const __CFURL *v49;
  const __CFData *v50;
  unint64_t *v51;
  unint64_t v52;
  unint64_t v53;
  CFTypeID v54;
  unint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  __int128 v59;
  std::__shared_weak_count *shared_weak_owners;
  unint64_t *v61;
  unint64_t v62;
  Boolean (__cdecl *equal)(const void *, const void *);
  unint64_t *v64;
  unint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  std::__shared_weak_count *v69;
  CFRunLoopSourceRef v70;
  CFRunLoopSourceRef v71;
  CFTypeRef v72;
  const void *v73;
  std::__shared_weak_count *v74;
  unint64_t *v75;
  unint64_t v76;
  void *context;
  CFURLRef contexta;
  CFRunLoopSourceContext aBlock;
  std::__shared_weak_count *v85;
  std::__shared_weak_count *v86;
  __int128 v87;
  std::__shared_weak_count_vtbl *v88;
  std::__shared_weak_count *v89;
  uint64_t v90;
  std::__shared_weak_count *v91;

  context = (void *)MEMORY[0x186DB8C8C](this, a2, a3, a4, a5, a6, a7);
  v9 = (void *)objc_msgSend(MEMORY[0x1E0CB3998], "componentsWithURL:resolvingAgainstBaseURL:", a2, 1);
  v10 = (void *)objc_msgSend(v9, "string");
  v11 = objc_msgSend(v9, "rangeOfHost");
  v13 = v12;
  v14 = objc_msgSend(v9, "rangeOfPort");
  v16 = v15;
  v17 = objc_msgSend(v9, "rangeOfScheme");
  v19 = (void *)MEMORY[0x1E0CB3940];
  if (v17 == 0x7FFFFFFFFFFFFFFFLL)
    v20 = &stru_1E1500C68;
  else
    v20 = (const __CFString *)objc_msgSend(v10, "substringWithRange:", v17, v18);
  if (v11 == 0x7FFFFFFFFFFFFFFFLL)
    v21 = &stru_1E1500C68;
  else
    v21 = (const __CFString *)objc_msgSend(v10, "substringWithRange:", v11, v13);
  if (v14 == 0x7FFFFFFFFFFFFFFFLL)
    v22 = &stru_1E1500C68;
  else
    v22 = (const __CFString *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR(":%@"), objc_msgSend(v10, "substringWithRange:", v14, v16));
  v23 = (const __CFString *)(id)objc_msgSend(v19, "stringWithFormat:", CFSTR("%@://%@%@/"), v20, v21, v22);
  objc_autoreleasePoolPop(context);
  contexta = CFURLCreateWithString(0, v23, 0);
  v24 = (std::__shared_weak_count *)operator new(0xE0uLL);
  v25 = *((_OWORD *)a6 + 1);
  *(_OWORD *)&v24[1].__shared_weak_owners_ = *(_OWORD *)a6;
  *(_OWORD *)&v24->__shared_owners_ = 0u;
  p_shared_owners = (unint64_t *)&v24->__shared_owners_;
  v24->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0FD8;
  v24[1].std::__shared_count = 0u;
  *(_OWORD *)&v24[2].__shared_owners_ = v25;
  v24[3].__vftable = (std::__shared_weak_count_vtbl *)*((_QWORD *)a6 + 4);
  *(_OWORD *)&v24[3].__shared_owners_ = 0u;
  v24[4].__vftable = a5;
  *(_OWORD *)&v24[4].__shared_owners_ = 0u;
  v24[5].std::__shared_count = 0u;
  *(_OWORD *)&v24[5].__shared_weak_owners_ = 0u;
  v24[6].__shared_weak_owners_ = 850045863;
  LOWORD(v24[6].__shared_owners_) = 0;
  v24[7].std::__shared_count = 0u;
  *(_OWORD *)&v24[7].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v24[8].__shared_owners_ = 0u;
  v24[9].__vftable = 0;
  if (!v24[2].__vftable || (shared_owners = (void (*)(void))v24[2].__shared_owners_) == 0)
  {
    v85 = v24 + 1;
    v86 = v24;
    goto LABEL_19;
  }
  shared_owners();
  v28 = (std::__shared_weak_count *)v24[1].__shared_owners_;
  v85 = v24 + 1;
  v86 = v24;
  if (!v28)
  {
    do
LABEL_19:
      v32 = __ldxr(p_shared_owners);
    while (__stxr(v32 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v24->__shared_weak_owners_;
    do
      v34 = __ldxr(p_shared_weak_owners);
    while (__stxr(v34 + 1, p_shared_weak_owners));
    v24[1].__vftable = (std::__shared_weak_count_vtbl *)&v24[1];
    v24[1].__shared_owners_ = (uint64_t)v24;
    goto LABEL_23;
  }
  if (v28->__shared_owners_ != -1)
    goto LABEL_26;
  do
    v29 = __ldxr(p_shared_owners);
  while (__stxr(v29 + 1, p_shared_owners));
  v30 = (unint64_t *)&v24->__shared_weak_owners_;
  do
    v31 = __ldxr(v30);
  while (__stxr(v31 + 1, v30));
  v24[1].__vftable = (std::__shared_weak_count_vtbl *)&v24[1];
  v24[1].__shared_owners_ = (uint64_t)v24;
  std::__shared_weak_count::__release_weak(v28);
  do
LABEL_23:
    v35 = __ldaxr(p_shared_owners);
  while (__stlxr(v35 - 1, p_shared_owners));
  if (!v35)
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
LABEL_26:
  v36 = v85;
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v87, (uint64_t)v85->__vftable, (std::__shared_weak_count *)v85->__shared_owners_);
  v37 = v87;
  if ((_QWORD)v87)
  {
    aBlock.version = MEMORY[0x1E0C809B0];
    aBlock.info = (void *)3321888768;
    aBlock.retain = (const void *(__cdecl *)(const void *))___ZN3PAC9PACClient10initializeEPKvPK7__CFURLPK8__CFDataPK10__CFString_block_invoke;
    aBlock.release = (void (__cdecl *)(const void *))&__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrIN3PAC9PACClientEEE_e161_v56__0____CFString__8____CFData__16_shared_ptr_const___CFArray______CFArray_____shared_weak_count__24_shared_ptr___CFError______CFError_____shared_weak_count__40l;
    *(_OWORD *)&aBlock.copyDescription = v87;
    if (*((_QWORD *)&v87 + 1))
    {
      v38 = (unint64_t *)(*((_QWORD *)&v87 + 1) + 8);
      do
        v39 = __ldxr(v38);
      while (__stxr(v39 + 1, v38));
    }
    v40 = operator new(0x78uLL);
    v40[1] = 0;
    v40[2] = 0;
    *v40 = &off_1E14F0FA0;
    v41 = *((_QWORD *)&v87 + 1);
    v90 = v37;
    v91 = (std::__shared_weak_count *)*((_QWORD *)&v87 + 1);
    if (*((_QWORD *)&v87 + 1))
    {
      v42 = (unint64_t *)(*((_QWORD *)&v87 + 1) + 8);
      do
        v43 = __ldxr(v42);
      while (__stxr(v43 + 1, v42));
    }
    v44 = (std::__shared_weak_count_vtbl *)operator new();
    v44->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke_initial;
    v44->__on_zero_shared = 0;
    v44->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))_Block_copy(&aBlock);
    v88 = v44;
    v45 = (std::__shared_weak_count *)operator new();
    v45->__shared_owners_ = 0;
    v46 = (unint64_t *)&v45->__shared_owners_;
    v45->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1320;
    v45->__shared_weak_owners_ = 0;
    v45[1].__vftable = v44;
    v89 = v45;
    if (this)
      v47 = CFRetain(this);
    else
      v47 = 0;
    v40[3] = v47;
    v48 = contexta;
    if (contexta)
      v48 = CFRetain(contexta);
    v40[5] = 0;
    v40[4] = v48;
    v40[6] = 0;
    v49 = a3;
    if (a3)
      v49 = (const __CFURL *)CFRetain(a3);
    v40[7] = v49;
    v50 = a4;
    if (a4)
      v50 = (const __CFData *)CFRetain(a4);
    v40[10] = v37;
    v40[8] = v50;
    v40[9] = 0;
    v40[11] = v41;
    if (v41)
    {
      v51 = (unint64_t *)(v41 + 8);
      do
        v52 = __ldxr(v51);
      while (__stxr(v52 + 1, v51));
    }
    v40[12] = v44;
    v40[13] = v45;
    do
      v53 = __ldxr(v46);
    while (__stxr(v53 + 1, v46));
    v54 = CFGetTypeID(this);
    *((_BYTE *)v40 + 112) = v54 == CFURLGetTypeID();
    do
      v55 = __ldaxr(v46);
    while (__stlxr(v55 - 1, v46));
    if (!v55)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
    v56 = v91;
    if (v91)
    {
      v57 = (unint64_t *)&v91->__shared_owners_;
      do
        v58 = __ldaxr(v57);
      while (__stlxr(v58 - 1, v57));
      if (!v58)
      {
        ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
        std::__shared_weak_count::__release_weak(v56);
      }
    }
    *(_QWORD *)&v59 = v40 + 3;
    *((_QWORD *)&v59 + 1) = v40;
    shared_weak_owners = (std::__shared_weak_count *)v36[2].__shared_weak_owners_;
    *(_OWORD *)&v36[2].__shared_owners_ = v59;
    if (shared_weak_owners)
    {
      v61 = (unint64_t *)&shared_weak_owners->__shared_owners_;
      do
        v62 = __ldaxr(v61);
      while (__stlxr(v62 - 1, v61));
      if (!v62)
      {
        ((void (*)(std::__shared_weak_count *))shared_weak_owners->__on_zero_shared)(shared_weak_owners);
        std::__shared_weak_count::__release_weak(shared_weak_owners);
      }
    }
    equal = aBlock.equal;
    if (aBlock.equal)
    {
      v64 = (unint64_t *)((char *)aBlock.equal + 8);
      do
        v65 = __ldaxr(v64);
      while (__stlxr(v65 - 1, v64));
      if (!v65)
      {
        (*(void (**)(Boolean (__cdecl *)(const void *, const void *)))(*(_QWORD *)equal + 16))(equal);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)equal);
      }
    }
  }
  v66 = (std::__shared_weak_count *)*((_QWORD *)&v87 + 1);
  if (*((_QWORD *)&v87 + 1))
  {
    v67 = (unint64_t *)(*((_QWORD *)&v87 + 1) + 8);
    do
      v68 = __ldaxr(v67);
    while (__stlxr(v68 - 1, v67));
    if (!v68)
    {
      ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
      std::__shared_weak_count::__release_weak(v66);
    }
  }
  memset(&aBlock.retain, 0, 40);
  aBlock.version = 0;
  v69 = v85;
  aBlock.schedule = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))PAC::rlsSchedule;
  aBlock.info = v85;
  aBlock.cancel = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))PAC::rlsCancel;
  aBlock.perform = (void (__cdecl *)(void *))PAC::rlsPerform;
  v70 = CFRunLoopSourceCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &aBlock);
  v71 = v70;
  if (v70)
    v72 = CFRetain(v70);
  else
    v72 = 0;
  v73 = (const void *)v69[3].__shared_owners_;
  v69[3].__shared_owners_ = (uint64_t)v72;
  if (v73)
    CFRelease(v73);
  v74 = v86;
  if (v86)
  {
    v75 = (unint64_t *)&v86->__shared_owners_;
    do
      v76 = __ldaxr(v75);
    while (__stlxr(v76 - 1, v75));
    if (!v76)
    {
      ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
      std::__shared_weak_count::__release_weak(v74);
    }
  }
  if (contexta)
    CFRelease(contexta);
  if (v23)
    CFRelease(v23);
  return v71;
}

void sub_184062B90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, CFTypeRef a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, CFTypeRef cf, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  const void **v23;
  std::__shared_weak_count *v24;
  const void **v25;
  uint64_t v26;
  const void *shared_owners;
  std::__shared_weak_count_vtbl *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  void *v33;

  shared_owners = (const void *)v24[2].__shared_owners_;
  v24[2].__shared_owners_ = 0;
  if (shared_owners)
    CFRelease(shared_owners);
  v29 = v24[2].__vftable;
  v24[2].__vftable = 0;
  if (v29)
    CFRelease(v29);
  v30 = *v23;
  *v23 = 0;
  if (v30)
    CFRelease(v30);
  v31 = (const void *)v24[1].__shared_owners_;
  v24[1].__shared_owners_ = 0;
  if (v31)
    CFRelease(v31);
  v32 = *v25;
  *v25 = 0;
  if (v32)
    CFRelease(v32);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v26 - 120);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v26 - 104);
  std::__shared_weak_count::~__shared_weak_count(v24);
  operator delete(v33);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a23);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v26 - 136);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v26 - 152);
  if (cf)
    CFRelease(cf);
  if (a13)
    CFRelease(a13);
  _Unwind_Resume(a1);
}

void PAC::rlsSchedule(PAC *this, void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  _QWORD *v5;
  CFTypeRef v6;
  const void *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count_vtbl *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  const __CFString *v18;
  unint64_t v19;
  int64_t v20;
  unint64_t v21;
  const __CFURL *v22;
  const __CFString *v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  NSObject *v33;
  const __CFData *v34;
  const UInt8 *BytePtr;
  size_t Length;
  unint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  _QWORD *v53;
  std::__shared_weak_count *v54;
  std::__shared_weak_count_vtbl *v55;
  uint64_t v56;
  void (*v57)(uint64_t, int, xpc_object_t);
  void *v58;
  uint64_t v59;
  std::__shared_weak_count *v60;
  xpc_object_t v61[2];
  xpc_object_t v62[2];
  xpc_object_t v63[2];
  std::__shared_weak_count_vtbl *v64;
  std::__shared_weak_count *v65;
  uint8_t buf[4];
  uint64_t v67;
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v53, *(_QWORD *)this, *((std::__shared_weak_count **)this + 1));
  v5 = v53;
  v6 = CFRetain(a2);
  v7 = (const void *)v5[11];
  v5[11] = v6;
  if (v7)
    CFRelease(v7);
  if (CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once != -1)
    dispatch_once(&CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once, &__block_literal_global_9684);
  v8 = CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::client;
  v10 = v5[7];
  v9 = (std::__shared_weak_count *)v5[8];
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v13 = (std::__shared_weak_count_vtbl *)xpc_dictionary_create(0, 0, 0);
  v14 = (std::__shared_weak_count *)operator new();
  v15 = v14;
  v14->__shared_owners_ = 0;
  v16 = (unint64_t *)&v14->__shared_owners_;
  v14->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1BA8;
  v14->__shared_weak_owners_ = 0;
  v14[1].__vftable = v13;
  if (*(_BYTE *)(v10 + 88))
  {
    v55 = v13;
    v56 = (uint64_t)v14;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
    v18 = CFURLGetString(*(CFURLRef *)v10);
    PAC::PACQuery::setStringInDict((xpc_object_t *)&v55, "source", v18);
    do
      v19 = __ldaxr(v16);
    while (__stlxr(v19 - 1, v16));
    v20 = 1;
    if (!v19)
    {
LABEL_14:
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  else
  {
    v55 = v13;
    v56 = (uint64_t)v14;
    do
      v24 = __ldxr(v16);
    while (__stxr(v24 + 1, v16));
    PAC::PACQuery::setStringInDict((xpc_object_t *)&v55, "source", *(CFStringRef *)v10);
    do
      v25 = __ldaxr(v16);
    while (__stlxr(v25 - 1, v16));
    v20 = 2;
    if (!v25)
      goto LABEL_14;
  }
  xpc_dictionary_set_int64(v13, "dtype", v20);
  v64 = v13;
  v65 = v15;
  do
    v21 = __ldxr(v16);
  while (__stxr(v21 + 1, v16));
  v22 = *(const __CFURL **)(v10 + 8);
  if (v22)
    v23 = CFURLGetString(v22);
  else
    v23 = 0;
  PAC::PACQuery::setStringInDict((xpc_object_t *)&v64, "target", v23);
  do
    v26 = __ldaxr(v16);
  while (__stlxr(v26 - 1, v16));
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  v63[0] = v13;
  v63[1] = v15;
  do
    v27 = __ldxr(v16);
  while (__stxr(v27 + 1, v16));
  PAC::PACQuery::setStringInDict(v63, "user", *(CFStringRef *)(v10 + 16));
  do
    v28 = __ldaxr(v16);
  while (__stlxr(v28 - 1, v16));
  if (!v28)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  v62[0] = v13;
  v62[1] = v15;
  do
    v29 = __ldxr(v16);
  while (__stxr(v29 + 1, v16));
  PAC::PACQuery::setStringInDict(v62, "pass", *(CFStringRef *)(v10 + 24));
  do
    v30 = __ldaxr(v16);
  while (__stlxr(v30 - 1, v16));
  if (!v30)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  v61[0] = v13;
  v61[1] = v15;
  do
    v31 = __ldxr(v16);
  while (__stxr(v31 + 1, v16));
  PAC::PACQuery::setStringInDict(v61, "bundle", *(CFStringRef *)(v10 + 40));
  do
    v32 = __ldaxr(v16);
  while (__stlxr(v32 - 1, v16));
  if (!v32)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  if (PAC::PACQuery::xpcDict(void)::onceToken != -1)
    dispatch_once(&PAC::PACQuery::xpcDict(void)::onceToken, &__block_literal_global_7455);
  if (PAC::PACQuery::xpcDict(void)::prefix)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v33 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      v67 = PAC::PACQuery::xpcDict(void)::prefix;
      _os_log_impl(&dword_183ECA000, v33, OS_LOG_TYPE_DEFAULT, "PAC found %s proc name", buf, 0xCu);
    }
    xpc_dictionary_set_string(v13, "prefix", (const char *)PAC::PACQuery::xpcDict(void)::prefix);
  }
  v34 = *(const __CFData **)(v10 + 32);
  if (v34)
  {
    BytePtr = CFDataGetBytePtr(v34);
    Length = CFDataGetLength(*(CFDataRef *)(v10 + 32));
    xpc_dictionary_set_data(v13, "audit", BytePtr, Length);
  }
  xpc_dictionary_set_int64(v13, "type", 3);
  do
    v37 = __ldxr(v16);
  while (__stxr(v37 + 1, v16));
  v55 = (std::__shared_weak_count_vtbl *)MEMORY[0x1E0C809B0];
  v56 = 3321888768;
  v57 = ___ZN4CFNA20CFNetworkAgentClient10executePACENSt3__110shared_ptrIN3PAC8PACQueryEEE_block_invoke;
  v58 = &__block_descriptor_48_e8_32c41_ZTSNSt3__110shared_ptrIN3PAC8PACQueryEEE_e36_v20__0B8__NSObject_OS_xpc_object__12l;
  v59 = v10;
  v60 = v9;
  if (v9)
  {
    v38 = (unint64_t *)&v9->__shared_owners_;
    do
      v39 = __ldxr(v38);
    while (__stxr(v39 + 1, v38));
  }
  SmartBlockWithArgs<BOOL,NSObject  {objcproto13OS_xpc_object}*>::SmartBlockWithArgs((uint64_t *)&v64, &v55);
  CFNA::CFNetworkAgentClient::sendMessage(v8, (uint64_t)v13, v15, 3, (uint64_t *)&v64);
  v40 = v65;
  if (v65)
  {
    v41 = (unint64_t *)&v65->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
  do
    v43 = __ldaxr(v16);
  while (__stlxr(v43 - 1, v16));
  if (!v43)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  v44 = v60;
  if (v60)
  {
    v45 = (unint64_t *)&v60->__shared_owners_;
    do
      v46 = __ldaxr(v45);
    while (__stlxr(v46 - 1, v45));
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }
  do
    v47 = __ldaxr(v16);
  while (__stlxr(v47 - 1, v16));
  if (!v47)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  if (v9)
  {
    v48 = (unint64_t *)&v9->__shared_owners_;
    do
      v49 = __ldaxr(v48);
    while (__stlxr(v49 - 1, v48));
    if (!v49)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v50 = v54;
  if (v54)
  {
    v51 = (unint64_t *)&v54->__shared_owners_;
    do
      v52 = __ldaxr(v51);
    while (__stlxr(v52 - 1, v51));
    if (!v52)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }
}

void sub_184063350(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  std::__shared_weak_count *v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v20;
  unint64_t v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;

  do
    v20 = __ldaxr(v18);
  while (__stlxr(v20 - 1, v18));
  if (!v20)
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  do
    v21 = __ldaxr(v18);
  while (__stlxr(v21 - 1, v18));
  if (!v21)
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v23 = __ldaxr(p_shared_owners);
    while (__stlxr(v23 - 1, p_shared_owners));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  if (a10)
  {
    v24 = (unint64_t *)&a10->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

void PAC::rlsCancel(PAC *this, void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t v4;
  std::mutex *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v9, *(_QWORD *)this, *((std::__shared_weak_count **)this + 1));
  v4 = v9;
  v5 = (std::mutex *)(v9 + 136);
  std::mutex::lock((std::mutex *)(v9 + 136));
  if (*(_BYTE *)(v4 + 128))
    PAC::PACClient::invalidate(*(PAC::PACClient **)(v4 + 56));
  else
    *(_BYTE *)(v4 + 129) = 1;
  std::mutex::unlock(v5);
  v6 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_1840635D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  std::mutex *v10;
  std::mutex *v11;
  unint64_t *p_shared_owners;
  unint64_t v14;

  v11 = v10;
  std::mutex::unlock(v11);
  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(a1);
}

void PAC::rlsPerform(PAC *this, void *a2)
{
  uint64_t v2;
  std::mutex *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;

  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v7, *(_QWORD *)this, *((std::__shared_weak_count **)this + 1));
  v2 = v7;
  v3 = (std::mutex *)(v7 + 136);
  std::mutex::lock((std::mutex *)(v7 + 136));
  *(_BYTE *)(v2 + 128) = 1;
  std::mutex::unlock(v3);
  (*(void (**)(_QWORD, _QWORD, _QWORD))(v2 + 72))(*(_QWORD *)(v2 + 24), *(_QWORD *)(v2 + 96), *(_QWORD *)(v2 + 112));
  v4 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1840636C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  unint64_t *p_shared_owners;
  unint64_t v12;

  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

void PAC::PACClient::invalidate(PAC::PACClient *this)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void ___ZN3PAC9PACClient10initializeEPKvPK7__CFURLPK8__CFDataPK10__CFString_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  const void *v14;
  __CFRunLoopSource *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  const void *v21;
  __CFRunLoop *v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;

  v5 = *(_QWORD *)(a1 + 32);
  v6 = *a4;
  v7 = a4[1];
  v27 = (std::__shared_weak_count *)v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = *a5;
  v11 = (std::__shared_weak_count *)a5[1];
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }
  std::mutex::lock((std::mutex *)(v5 + 136));
  if (!*(_QWORD *)(v5 + 96) && !*(_QWORD *)(v5 + 112))
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v5 + 96), v6, v7);
    if (v11)
    {
      v16 = (unint64_t *)&v11->__shared_owners_;
      do
        v17 = __ldxr(v16);
      while (__stxr(v17 + 1, v16));
    }
    v18 = *(std::__shared_weak_count **)(v5 + 120);
    *(_QWORD *)(v5 + 112) = v10;
    *(_QWORD *)(v5 + 120) = v11;
    if (v18)
    {
      v19 = (unint64_t *)&v18->__shared_owners_;
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
  }
  std::mutex::unlock((std::mutex *)(v5 + 136));
  std::mutex::lock((std::mutex *)(v5 + 136));
  if (!*(_BYTE *)(v5 + 129))
  {
    v14 = *(const void **)(v5 + 80);
    if (v14)
      v15 = (__CFRunLoopSource *)CFRetain(v14);
    else
      v15 = 0;
    v21 = *(const void **)(v5 + 88);
    if (!v21)
    {
      std::mutex::unlock((std::mutex *)(v5 + 136));
      if (!v15)
        goto LABEL_31;
      goto LABEL_30;
    }
    v22 = (__CFRunLoop *)CFRetain(v21);
    std::mutex::unlock((std::mutex *)(v5 + 136));
    if (v15)
    {
      if (!v22)
        goto LABEL_30;
      CFRunLoopSourceSignal(v15);
      CFRunLoopWakeUp(v22);
    }
    else if (!v22)
    {
      goto LABEL_31;
    }
    CFRelease(v22);
    if (!v15)
      goto LABEL_31;
LABEL_30:
    CFRelease(v15);
    goto LABEL_31;
  }
  PAC::PACClient::invalidate(*(PAC::PACClient **)(v5 + 56));
  std::mutex::unlock((std::mutex *)(v5 + 136));
LABEL_31:
  if (v11)
  {
    v23 = (unint64_t *)&v11->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  if (v27)
  {
    v25 = (unint64_t *)&v27->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
}

void sub_184063980(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  const void *v11;
  const void *v12;
  const void *v13;

  v13 = v12;
  CFRelease(v13);
  CFRelease(v11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke_initial(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;

  a1[1] = (uint64_t)BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke_normal;
  a1[2] = 0;
  v5 = *a1;
  v6 = (std::__shared_weak_count *)a4[1];
  v20 = *a4;
  v21 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v9 = (std::__shared_weak_count *)a5[1];
  v18 = *a5;
  v19 = v9;
  if (v9)
  {
    v10 = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t *))(v5 + 16))(v5, a2, a3, &v20, &v18);
  v12 = v19;
  if (v19)
  {
    v13 = (unint64_t *)&v19->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = v21;
  if (v21)
  {
    v16 = (unint64_t *)&v21->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

void sub_184063AD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>> *,SmartBlockWithArgs<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::Deleter,std::allocator<BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>> *,SmartBlockWithArgs<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::Deleter,std::allocator<BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  void (*v2)(uint64_t *, uint64_t, uint64_t, uint64_t *, uint64_t *);
  BOOL v3;
  int v4;
  uint64_t v6[2];

  v1 = *(_QWORD *)(a1 + 24);
  v2 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *, uint64_t *))(v1 + 8);
  if (*(_QWORD *)(v1 + 16))
    v3 = (*(_QWORD *)(v1 + 16) & 1 | (unint64_t)v2) == 0;
  else
    v3 = 1;
  v4 = v3;
  if (v2 == BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke_initial
    && v4 != 0)
  {
    v6[0] = 0;
    v6[1] = 0;
    BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke(v1, 0, 0, 0, 0, v6);
  }
  _Block_release(*(const void **)v1);
  JUMPOUT(0x186DB748CLL);
}

void BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5, uint64_t *a6)
{
  void (*v6)(_QWORD *, uint64_t, uint64_t, uint64_t *, uint64_t *);
  uint64_t v7;
  _QWORD *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;

  v6 = *(void (**)(_QWORD *, uint64_t, uint64_t, uint64_t *, uint64_t *))(a1 + 8);
  v7 = *(_QWORD *)(a1 + 16);
  v8 = (_QWORD *)(a1 + (v7 >> 1));
  if ((v7 & 1) != 0)
    v6 = *(void (**)(_QWORD *, uint64_t, uint64_t, uint64_t *, uint64_t *))(*v8 + v6);
  v22 = a4;
  v23 = a5;
  if (a5)
  {
    p_shared_owners = (unint64_t *)&a5->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v11 = (std::__shared_weak_count *)a6[1];
  v20 = *a6;
  v21 = v11;
  if (v11)
  {
    v12 = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v6(v8, a2, a3, &v22, &v20);
  v14 = v21;
  if (v21)
  {
    v15 = (unint64_t *)&v21->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v23;
  if (v23)
  {
    v18 = (unint64_t *)&v23->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
}

void sub_184063C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke_normal(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;

  v5 = *a1;
  v6 = (std::__shared_weak_count *)a4[1];
  v20 = *a4;
  v21 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v9 = (std::__shared_weak_count *)a5[1];
  v18 = *a5;
  v19 = v9;
  if (v9)
  {
    v10 = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t *))(v5 + 16))(v5, a2, a3, &v20, &v18);
  v12 = v19;
  if (v19)
  {
    v13 = (unint64_t *)&v19->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = v21;
  if (v21)
  {
    v16 = (unint64_t *)&v21->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

void sub_184063D90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PAC::PACQuery>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0FA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PAC::PACQuery>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0FA0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_emplace<PAC::PACQuery>::__on_zero_shared(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(a1 + 12));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(a1 + 10));
  v2 = (const void *)a1[9];
  a1[9] = 0;
  if (v2)
    CFRelease(v2);
  v3 = (const void *)a1[8];
  a1[8] = 0;
  if (v3)
    CFRelease(v3);
  v4 = (const void *)a1[7];
  a1[7] = 0;
  if (v4)
    CFRelease(v4);
  v5 = (const void *)a1[6];
  a1[6] = 0;
  if (v5)
    CFRelease(v5);
  v6 = (const void *)a1[5];
  a1[5] = 0;
  if (v6)
    CFRelease(v6);
  v7 = (const void *)a1[4];
  a1[4] = 0;
  if (v7)
    CFRelease(v7);
  v8 = (const void *)a1[3];
  a1[3] = 0;
  if (v8)
    CFRelease(v8);
}

uint64_t __copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrIN3PAC9PACClientEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrIN3PAC9PACClientEEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void std::__shared_ptr_emplace<PAC::PACClient>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0FD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PAC::PACClient>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0FD8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_emplace<PAC::PACClient>::__on_zero_shared(uint64_t a1)
{
  void (*v2)(void);
  const void *v3;
  const void *v4;
  std::__shared_weak_count *v5;

  if (*(_QWORD *)(a1 + 48))
  {
    v2 = *(void (**)(void))(a1 + 64);
    if (v2)
      v2();
  }
  std::mutex::~mutex((std::mutex *)(a1 + 160));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 136);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 120);
  v3 = *(const void **)(a1 + 112);
  *(_QWORD *)(a1 + 112) = 0;
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 104);
  *(_QWORD *)(a1 + 104) = 0;
  if (v4)
    CFRelease(v4);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 80);
  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

void sub_184063F84(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;
  const void *v4;
  std::__shared_weak_count *v5;

  std::mutex::~mutex((std::mutex *)(v1 + 160));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 136);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 120);
  v3 = *(const void **)(v1 + 112);
  *(_QWORD *)(v1 + 112) = 0;
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(v1 + 104);
  *(_QWORD *)(v1 + 104) = 0;
  if (v4)
    CFRelease(v4);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 80);
  v5 = *(std::__shared_weak_count **)(v1 + 32);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
  _Unwind_Resume(a1);
}

CFArrayRef CFNetworkCopyProxiesForAutoConfigurationScript(CFStringRef proxyAutoConfigurationScript, CFURLRef targetURL, CFErrorRef *error)
{
  CFStreamClientContext *v6;
  __CFRunLoopSource *PACTicket;
  _QWORD v9[5];
  const __CFArray *v10;
  CFTypeRef cf;
  CFRunLoopRef rl;

  v10 = 0;
  cf = 0;
  rl = 0;
  v9[0] = 0;
  v9[1] = &v10;
  memset(&v9[2], 0, 24);
  rl = CFRunLoopGetCurrent();
  PACTicket = PAC::CreatePACTicket((PAC *)proxyAutoConfigurationScript, targetURL, 0, 0, (std::__shared_weak_count_vtbl *)CFNetworkCopyProxiesForAutoConfigurationScriptCallback, (void (*)(void *, const __CFArray *, __CFError *))v9, v6);
  CFRunLoopAddSource(rl, PACTicket, CFSTR("__CFNetworkCopyProxiesForAutoConfigurationScript_privatemode__"));
  CFRunLoopRunInMode(CFSTR("__CFNetworkCopyProxiesForAutoConfigurationScript_privatemode__"), 1.0e10, 0);
  CFRunLoopSourceInvalidate(PACTicket);
  CFRelease(PACTicket);
  if (error)
  {
    *error = (CFErrorRef)cf;
  }
  else if (cf)
  {
    CFRelease(cf);
  }
  return v10;
}

void CFNetworkCopyProxiesForAutoConfigurationScriptCallback(void *a1, CFTypeRef cf, __CFError *a3)
{
  CFTypeRef v5;
  CFTypeRef v6;

  if (cf)
    v5 = CFRetain(cf);
  else
    v5 = 0;
  *(_QWORD *)a1 = v5;
  if (a3)
    v6 = CFRetain(a3);
  else
    v6 = 0;
  *((_QWORD *)a1 + 1) = v6;
  CFRunLoopStop(*((CFRunLoopRef *)a1 + 2));
}

void ClassicStreamClient::~ClassicStreamClient(ClassicStreamClient *this)
{
  void (*v1)(void);

  *(_QWORD *)this = off_1E14E9D28;
  if (*((_QWORD *)this + 4))
  {
    v1 = (void (*)(void))*((_QWORD *)this + 6);
    if (v1)
      v1();
  }
}

{
  void (*v2)(void);

  *(_QWORD *)this = off_1E14E9D28;
  if (*((_QWORD *)this + 4))
  {
    v2 = (void (*)(void))*((_QWORD *)this + 6);
    if (v2)
      v2();
  }
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

void ClassicStreamClient::ClassicStreamClient(ClassicStreamClient *this, const __CFAllocator *a2, const CFStreamClientContext *a3)
{
  CFStringRef (__cdecl *copyDescription)(void *);
  __int128 v4;
  uint64_t (*v5)(void);

  *(_QWORD *)this = off_1E14EF578;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = 1;
  if ((((unint64_t)this + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)this = off_1E14E9D28;
  copyDescription = a3->copyDescription;
  v4 = *(_OWORD *)&a3->retain;
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)&a3->version;
  *((_QWORD *)this + 7) = copyDescription;
  *(_OWORD *)((char *)this + 40) = v4;
  if (*((_QWORD *)this + 4))
  {
    v5 = (uint64_t (*)(void))*((_QWORD *)this + 5);
    if (v5)
      *((_QWORD *)this + 4) = v5();
  }
}

CFStringRef ClassicStreamClient::clientCopyDescription(ClassicStreamClient *this)
{
  uint64_t (*v2)(_QWORD);
  CFStringRef result;

  v2 = (uint64_t (*)(_QWORD))*((_QWORD *)this + 7);
  if (!v2)
    return CFStringCreateWithFormat(*((CFAllocatorRef *)this + 1), 0, CFSTR("Classic Stream Client <%p>"), *((_QWORD *)this + 4));
  result = (CFStringRef)v2(*((_QWORD *)this + 4));
  if (!result)
    return CFStringCreateWithFormat(*((CFAllocatorRef *)this + 1), 0, CFSTR("Classic Stream Client <%p>"), *((_QWORD *)this + 4));
  return result;
}

void KerberosAccountStore::~KerberosAccountStore(KerberosAccountStore *this)
{
  uint64_t v2;

  KerberosAccountStore::~KerberosAccountStore(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  NSObject *v2;
  NSObject *v3;
  uint64_t v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;

  *(_QWORD *)this = off_1E14EB8E0;
  *((_QWORD *)this + 3) = &unk_1E14EB938;
  v2 = *((_QWORD *)this + 12);
  if (v2)
    dispatch_release(v2);
  v3 = *((_QWORD *)this + 11);
  if (v3)
    dispatch_release(v3);
  v4 = *((_QWORD *)this + 10);
  if (v4)
    CFRelease((CFTypeRef)(v4 - 16));
  v5 = (const void *)*((_QWORD *)this + 9);
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 8);
  if (v6)
    CFRelease(v6);
  v7 = (const void *)*((_QWORD *)this + 7);
  if (v7)
    CFRelease(v7);
  v8 = (const void *)*((_QWORD *)this + 6);
  if (v8)
    CFRelease(v8);
  CFNAccountStore::~CFNAccountStore(this);
}

CFStringRef KerberosAccountStore::copyDebugDesc(KerberosAccountStore *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<KerberosAccountStore@%p>"), this);
}

void `non-virtual thunk to'KerberosAccountStore::~KerberosAccountStore(KerberosAccountStore *this)
{
  KerberosAccountStore::~KerberosAccountStore((KerberosAccountStore *)((char *)this - 24));
}

void `non-virtual thunk to'KerberosAccountStore::~KerberosAccountStore(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  KerberosAccountStore::~KerberosAccountStore((KerberosAccountStore *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

void sub_1840643A0(_Unwind_Exception *a1)
{
  CFNAccountStore *v1;

  CFNAccountStore::~CFNAccountStore(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN20KerberosAccountStore42getKerberosCredentialWithCompletionHandlerEPK16_CFURLCredentialU13block_pointerFvS2_E_block_invoke(uint64_t a1)
{
  const void *v2;
  uint64_t v3;
  const void *v4;
  const __CFURL *v5;
  const __CFArray *v6;
  const void *v7;

  v3 = *(_QWORD *)(a1 + 40);
  v2 = *(const void **)(a1 + 48);
  if (v2 && (v4 = *(const void **)(v3 + 72)) != 0)
    v5 = (const __CFURL *)(CFEqual(v2, v4) != 0);
  else
    v5 = 0;
  CFArrayAppendValue(*(CFMutableArrayRef *)(v3 + 56), *(const void **)(a1 + 32));
  v6 = *(const __CFArray **)(v3 + 56);
  if (!v6 || CFArrayGetCount(v6) <= 1)
    KerberosAccountStore::fetchKerberosCredential((KerberosAccountStore *)v3, v5);
  v7 = *(const void **)(a1 + 48);
  if (v7)
    CFRelease(v7);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
}

void KerberosAccountStore::fetchKerberosCredential(KerberosAccountStore *this, const __CFURL *a2)
{
  const _CFURLCredential *v3;
  NSObject *v4;
  _QWORD *v5;
  _QWORD v6[5];
  _QWORD v7[5];

  if ((_DWORD)a2)
  {
    if (*(_BYTE *)(*((_QWORD *)this + 10) + 48))
    {
      KerberosAccountStore::useCredentialFromNextAccountOrDieTrying(this, a2);
      return;
    }
    (*(void (**)(KerberosAccountStore *))(*(_QWORD *)this + 40))(this);
    v4 = *((_QWORD *)this + 12);
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = ___ZN20KerberosAccountStore40renewKerberosCredentialForCurrentAccountEv_block_invoke;
    v7[3] = &__block_descriptor_40_e5_v8__0l;
    v7[4] = this;
    v5 = v7;
  }
  else
  {
    v3 = (const _CFURLCredential *)*((_QWORD *)this + 9);
    if (v3)
    {
      KerberosAccountStore::sendKerberosCredentialToClients(this, v3);
      return;
    }
    (*(void (**)(KerberosAccountStore *))(*(_QWORD *)this + 40))(this);
    v4 = *((_QWORD *)this + 12);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke;
    v6[3] = &__block_descriptor_40_e5_v8__0l;
    v6[4] = this;
    v5 = v6;
  }
  dispatch_async(v4, v5);
}

void KerberosAccountStore::sendKerberosCredentialToClients(KerberosAccountStore *this, const _CFURLCredential *a2)
{
  const __CFArray *v3;
  CFArrayRef Copy;
  CFArrayRef v6;
  dispatch_queue_t v7;
  NSObject *v8;
  _QWORD block[7];

  v3 = (const __CFArray *)*((_QWORD *)this + 7);
  if (v3)
  {
    Copy = CFArrayCreateCopy(*((CFAllocatorRef *)this + 1), v3);
    if (Copy)
    {
      v6 = Copy;
      v7 = dispatch_queue_create("com.apple.kerberosaccountstore.cbqueue", 0);
      if (v7)
      {
        v8 = v7;
        if (a2)
          CFRetain(a2);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3221225472;
        block[2] = ___ZN20KerberosAccountStore31sendKerberosCredentialToClientsEPK16_CFURLCredential_block_invoke;
        block[3] = &unk_1E14FB048;
        block[5] = v6;
        block[6] = a2;
        block[4] = v8;
        dispatch_async(v8, block);
      }
      else
      {
        CFRelease(v6);
      }
      CFArrayRemoveAllValues(*((CFMutableArrayRef *)this + 7));
    }
  }
}

uint64_t ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  void *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[5];
  __int128 buf;
  uint64_t (*v13)(uint64_t, const void *, const void *);
  void *v14;
  NSObject *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD **)(a1 + 32);
  (*(void (**)(_QWORD *))(*v1 + 40))(v1);
  v2 = v1[8];
  v3 = v1[11];
  v4 = MEMORY[0x1E0C809B0];
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke_2;
  v11[3] = &__block_descriptor_40_e35_v24__0____CFArray__8____CFError__16l;
  v11[4] = v1;
  (*(void (**)(_QWORD *))(*v1 + 40))(v1);
  dispatch_retain(v3);
  v5 = (void *)v1[4];
  *(_QWORD *)&buf = v4;
  *((_QWORD *)&buf + 1) = 3221225472;
  v13 = ___ZN15CFNAccountStore32kerberosAccountsForDomainFromURLEPK7__CFURLPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvPK9__CFArrayP9__CFErrorE_block_invoke;
  v14 = &unk_1E14FBCD8;
  v15 = v3;
  v16 = v11;
  v17 = v1;
  objc_msgSend(v5, "kerberosAccountsForDomainFromURL:completion:", v2, &buf);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v7 = v1[8];
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = v7;
    _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, "Fetching Account for domain %p", (uint8_t *)&buf, 0xCu);
  }
  v8 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_14_6380, 3);
  if (v8)
  {
    v9 = v8;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v8 + 16))(v8, "Fetching Account for domain", 0))
    {
      (*(void (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v9 + 40))(v9, "URL", v1[8]);
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
    }
  }
  return (*(uint64_t (**)(_QWORD *))(*v1 + 48))(v1);
}

uint64_t ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke_2(uint64_t a1, const __CFArray *a2, __CFError *a3)
{
  uint64_t v5;
  NSObject *v6;
  CFIndex Count;
  CFIndex Code;
  uint64_t v9;
  const __CFURL *v10;
  uint64_t v11;
  const __CFAllocator *v12;
  CFStringRef v13;
  CFStringRef v14;
  _BYTE v16[24];
  CFIndex v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a1 + 32);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    if (a2)
    {
      Count = CFArrayGetCount(a2);
      if (a3)
      {
LABEL_6:
        Code = CFErrorGetCode(a3);
LABEL_9:
        *(_DWORD *)v16 = 134218498;
        *(_QWORD *)&v16[4] = Count;
        *(_WORD *)&v16[12] = 2112;
        *(_QWORD *)&v16[14] = a3;
        *(_WORD *)&v16[22] = 2048;
        v17 = Code;
        _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, "Accounts sent %ld account(s), error=%@ [%ld]", v16, 0x20u);
        goto LABEL_10;
      }
    }
    else
    {
      Count = 0;
      if (a3)
        goto LABEL_6;
    }
    Code = 0;
    goto LABEL_9;
  }
LABEL_10:
  v9 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_6388, 3);
  v11 = v9;
  if (v9
    && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v9 + 16))(v9, "Received Accounts", 0))
  {
    (*(void (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v11 + 40))(v11, "URL", *(_QWORD *)(v5 + 64));
    v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    *(_QWORD *)v16 = &off_1E14E4818;
    v13 = CFStringCreateWithCString(v12, "Accounts", 0x8000100u);
    v17 = 0;
    *(_OWORD *)&v16[8] = (unint64_t)v13;
    if (a2)
    {
      v14 = CFCopyDescription(a2);
      v13 = *(CFStringRef *)&v16[8];
    }
    else
    {
      v14 = CFSTR("null");
    }
    (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(_QWORD *)v11 + 64))(v11, v13, v14);
    if (a2 && v14)
      CFRelease(v14);
    AutoString::~AutoString((AutoString *)v16);
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
  }
  if (a2 && !a3 && CFArrayGetCount(a2) >= 1)
    *(_QWORD *)(v5 + 48) = CFArrayCreateMutableCopy(*(CFAllocatorRef *)(v5 + 8), 0, a2);
  KerberosAccountStore::useCredentialFromNextAccountOrDieTrying((KerberosAccountStore *)v5, v10);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
}

void sub_184064A28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  AutoString::~AutoString((AutoString *)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke_13@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 112;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void KerberosAccountStore::useCredentialFromNextAccountOrDieTrying(KerberosAccountStore *this, const __CFURL *a2)
{
  uint64_t v3;
  const __CFArray *v4;
  objc_object *ValueAtIndex;
  objc_object *v6;
  uint64_t Instance;
  CFNAccountKerberos *v8;
  uint64_t v9;
  const void *v10;

  v3 = *((_QWORD *)this + 10);
  if (v3)
  {
    CFRelease((CFTypeRef)(v3 - 16));
    *((_QWORD *)this + 10) = 0;
  }
  *((_QWORD *)this + 9) = 0;
  v4 = (const __CFArray *)*((_QWORD *)this + 6);
  if (v4 && CFArrayGetCount(v4) >= 1)
  {
    ValueAtIndex = (objc_object *)CFArrayGetValueAtIndex(*((CFArrayRef *)this + 6), 0);
    if (ValueAtIndex)
    {
      v6 = ValueAtIndex;
      if (CFNAccountKerberos::Class(void)::sOnce_CFNAccountKerberos != -1)
        dispatch_once(&CFNAccountKerberos::Class(void)::sOnce_CFNAccountKerberos, &__block_literal_global_16802);
      Instance = _CFRuntimeCreateInstance();
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      Instance += 16;
      *(_OWORD *)(Instance + 32) = 0u;
      *(_OWORD *)(Instance + 48) = 0u;
      *(_QWORD *)(Instance + 16) = 0;
      *(_QWORD *)(Instance + 24) = 0;
      *(_QWORD *)(Instance + 32) = 0;
      *(_QWORD *)Instance = &off_1E14E9158;
      *(_QWORD *)(Instance + 8) = &unk_1E14E91A8;
      *(_QWORD *)(Instance + 56) = 0;
      *((_QWORD *)this + 10) = Instance;
      if (!CFNAccountKerberos::initialize((CFNAccountKerberos *)Instance, v6))
      {
        CFRelease((CFTypeRef)(*((_QWORD *)this + 10) - 16));
        *((_QWORD *)this + 10) = 0;
      }
    }
    CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)this + 6), 0);
  }
  v8 = (CFNAccountKerberos *)*((_QWORD *)this + 10);
  if (v8)
  {
    v9 = CFNAccountKerberos::kerberosCredential(v8, a2);
    *((_QWORD *)this + 9) = v9;
    KerberosAccountStore::fetchKerberosCredential(this, v9 == 0);
  }
  else
  {
    v10 = (const void *)*((_QWORD *)this + 6);
    *((_QWORD *)this + 6) = 0;
    if (v10)
      CFRelease(v10);
    KerberosAccountStore::sendKerberosCredentialToClients(this, 0);
  }
}

uint64_t ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke_4@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 101;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN20KerberosAccountStore31sendKerberosCredentialToClientsEPK16_CFURLCredential_block_invoke(uint64_t a1)
{
  CFIndex i;
  CFIndex Count;
  const __CFArray *v4;
  void (**ValueAtIndex)(const void *, _QWORD);
  const void *v6;

  for (i = 0; ; ++i)
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
    v4 = *(const __CFArray **)(a1 + 40);
    if (i >= Count)
      break;
    ValueAtIndex = (void (**)(const void *, _QWORD))CFArrayGetValueAtIndex(v4, i);
    ValueAtIndex[2](ValueAtIndex, *(_QWORD *)(a1 + 48));
    _Block_release(ValueAtIndex);
  }
  if (v4)
    CFRelease(v4);
  v6 = *(const void **)(a1 + 48);
  if (v6)
    CFRelease(v6);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

uint64_t ___ZN20KerberosAccountStore40renewKerberosCredentialForCurrentAccountEv_block_invoke(uint64_t a1)
{
  _QWORD *v1;
  NSObject *v2;
  void *v3;
  uint64_t v4;
  id v5;
  void *v6;
  NSObject *v7;
  _QWORD v9[5];
  uint8_t buf[8];
  uint64_t v11;
  uint64_t (*v12)(uint64_t, uint64_t, const void *);
  void *v13;
  NSObject *v14;
  void *v15;
  _QWORD *v16;
  _QWORD *v17;

  v1 = *(_QWORD **)(a1 + 32);
  (*(void (**)(_QWORD *))(*v1 + 40))(v1);
  v2 = v1[11];
  v3 = *(void **)(v1[10] + 16);
  v4 = MEMORY[0x1E0C809B0];
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___ZN20KerberosAccountStore40renewKerberosCredentialForCurrentAccountEv_block_invoke_2;
  v9[3] = &__block_descriptor_40_e23_v24__0q8____CFError__16l;
  v9[4] = v1;
  (*(void (**)(_QWORD *))(*v1 + 40))(v1);
  dispatch_retain(v2);
  v5 = v3;
  v6 = (void *)v1[4];
  *(_QWORD *)buf = v4;
  v11 = 3221225472;
  v12 = ___ZN15CFNAccountStore26renewCredentialsForAccountEP11objc_objectPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvlP9__CFErrorE_block_invoke;
  v13 = &unk_1E14FBCB0;
  v16 = v9;
  v17 = v1;
  v14 = v2;
  v15 = v3;
  objc_msgSend(v6, "renewCredentialsForAccount:completion:", v3, buf);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v7 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_183ECA000, v7, OS_LOG_TYPE_DEFAULT, "Renewing current credential for account", buf, 2u);
  }
  return (*(uint64_t (**)(_QWORD *))(*v1 + 48))(v1);
}

uint64_t ___ZN20KerberosAccountStore40renewKerberosCredentialForCurrentAccountEv_block_invoke_2(uint64_t a1, uint64_t a2, __CFError *a3)
{
  KerberosAccountStore *v5;
  NSObject *v6;
  const __CFURL *v7;
  CFIndex Code;
  uint64_t v9;
  const void *v10;
  void *v11;
  CFNAccountKerberos *v12;
  const _CFURLCredential *v13;
  KerberosAccountStore *v14;
  int v16;
  uint64_t v17;
  __int16 v18;
  __CFError *v19;
  __int16 v20;
  CFIndex v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v5 = *(KerberosAccountStore **)(a1 + 32);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    if (a3)
      Code = CFErrorGetCode(a3);
    else
      Code = 0;
    v16 = 134218498;
    v17 = a2;
    v18 = 2112;
    v19 = a3;
    v20 = 2048;
    v21 = Code;
    _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, "Accounts renewed credential result=%ld, error=%@ [%ld]", (uint8_t *)&v16, 0x20u);
  }
  if (a2 == 1)
  {
    v14 = v5;
    v13 = 0;
  }
  else
  {
    if (a2)
    {
      KerberosAccountStore::useCredentialFromNextAccountOrDieTrying(v5, v7);
      return (*(uint64_t (**)(KerberosAccountStore *))(*(_QWORD *)v5 + 48))(v5);
    }
    v9 = *((_QWORD *)v5 + 10);
    v10 = *(const void **)(v9 + 32);
    *(_QWORD *)(v9 + 32) = 0;
    if (v10)
      CFRelease(v10);
    v11 = *(void **)(v9 + 24);
    if (v11)
    {

      *(_QWORD *)(v9 + 24) = 0;
    }
    v12 = (CFNAccountKerberos *)*((_QWORD *)v5 + 10);
    *((_BYTE *)v12 + 48) = 1;
    v13 = (const _CFURLCredential *)CFNAccountKerberos::kerberosCredential(v12, v7);
    *((_QWORD *)v5 + 9) = v13;
    v14 = v5;
  }
  KerberosAccountStore::sendKerberosCredentialToClients(v14, v13);
  return (*(uint64_t (**)(KerberosAccountStore *))(*(_QWORD *)v5 + 48))(v5);
}

uint64_t ___ZN20KerberosAccountStore24clearAccountRefreshStateEv_block_invoke(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;

  v1 = *(_QWORD **)(a1 + 32);
  v2 = v1[10];
  if (v2)
    *(_BYTE *)(v2 + 48) = 0;
  return (*(uint64_t (**)(_QWORD *))(*v1 + 48))(v1);
}

unsigned __int8 *_DNSServiceConvertDomainLabelToCString_withescape(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3;
  uint64_t v4;
  unsigned int v5;
  unsigned __int8 *v6;
  unsigned __int8 v7;
  unsigned __int8 v8;

  v5 = *a1;
  v3 = a1 + 1;
  v4 = v5;
  if (v5 > 0x3F)
    return 0;
  if ((_DWORD)v4)
  {
    v6 = &v3[v4];
    do
    {
      v8 = *v3++;
      v7 = v8;
      if (a3)
      {
        if (v7 == 46 || v7 == a3)
        {
          *a2++ = a3;
        }
        else if (v7 <= 0x20u)
        {
          *a2 = a3;
          a2[1] = 48;
          a2[2] = (v7 / 0xAu) | 0x30;
          a2 += 3;
          v7 = (v7 % 0xAu) | 0x30;
        }
      }
      *a2++ = v7;
    }
    while (v3 < v6);
  }
  *a2 = 0;
  return a2;
}

unsigned __int8 *_DNSServiceConvertDomainNameToCString_withescape(unsigned __int8 *result, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  unsigned int v3;
  uint64_t v4;

  v2 = result;
  v3 = *result;
  if (*result || (*a2 = 46, ++a2, (v3 = *result) != 0))
  {
    v4 = 0;
    while (v4 + 1 + (unint64_t)v3 <= 0xFF)
    {
      result = _DNSServiceConvertDomainLabelToCString_withescape(result, a2, 92);
      if (!result)
        break;
      v4 += 1 + v2[v4];
      *result = 46;
      a2 = result + 1;
      result = &v2[v4];
      v3 = v2[v4];
      if (!v2[v4])
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    *a2 = 0;
  }
  return result;
}

void Tube::generateProxyAuthentication(_QWORD **a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  _QWORD v40[5];
  std::__shared_weak_count *v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  uint64_t v46;
  std::__shared_weak_count *v47;
  uint64_t v48;
  std::__shared_weak_count *v49;
  _QWORD **v50;
  std::__shared_weak_count *v51;

  if (a1[14])
  {
    ((void (*)(_QWORD **))(*a1)[5])(a1);
    v50 = a1;
    v8 = (std::__shared_weak_count *)operator new();
    v8->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    v8->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F18D0;
    v8->__shared_weak_owners_ = 0;
    v8[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
    v51 = v8;
    v10 = (*(uint64_t (**)(_QWORD *))(*a1[14] + 80))(a1[14]);
    if (v10)
    {
      v11 = (std::__shared_weak_count *)a2[1];
      v48 = *a2;
      v49 = v11;
      if (v11)
      {
        v12 = (unint64_t *)&v11->__shared_owners_;
        do
          v13 = __ldxr(v12);
        while (__stxr(v13 + 1, v12));
      }
      v14 = v10 - 176;
      v15 = (std::__shared_weak_count *)a3[1];
      v46 = *a3;
      v47 = v15;
      if (v15)
      {
        v16 = (unint64_t *)&v15->__shared_owners_;
        do
          v17 = __ldxr(v16);
        while (__stxr(v17 + 1, v16));
      }
      v40[0] = MEMORY[0x1E0C809B0];
      v40[1] = 3321888768;
      v40[2] = ___ZN4Tube27generateProxyAuthenticationENSt3__110shared_ptrI12NetworkProxyEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJNS1_I19AuthenticationStateEEEE_block_invoke;
      v40[3] = &__block_descriptor_64_e8_32c31_ZTSNSt3__110shared_ptrI4TubeEE48c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE_e85_v24__0_shared_ptr_AuthenticationState____AuthenticationState_____shared_weak_count__8l;
      v40[4] = a1;
      v41 = v8;
      do
        v18 = __ldxr(p_shared_owners);
      while (__stxr(v18 + 1, p_shared_owners));
      v19 = a4[1];
      v42 = *a4;
      v43 = (std::__shared_weak_count *)v19;
      if (v19)
      {
        v20 = (unint64_t *)(v19 + 8);
        do
          v21 = __ldxr(v20);
        while (__stxr(v21 + 1, v20));
      }
      SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::SmartBlockWithArgs(&v44, v40);
      (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *))(*(_QWORD *)v14 + 248))(v14, &v48, &v46, &v44);
      v22 = v45;
      if (v45)
      {
        v23 = (unint64_t *)&v45->__shared_owners_;
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
      v25 = v47;
      if (v47)
      {
        v26 = (unint64_t *)&v47->__shared_owners_;
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
      v28 = v49;
      if (v49)
      {
        v29 = (unint64_t *)&v49->__shared_owners_;
        do
          v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
      v31 = v43;
      if (v43)
      {
        v32 = (unint64_t *)&v43->__shared_owners_;
        do
          v33 = __ldaxr(v32);
        while (__stlxr(v33 - 1, v32));
        if (!v33)
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
        }
      }
      v34 = v41;
      if (v41)
      {
        v35 = (unint64_t *)&v41->__shared_owners_;
        do
          v36 = __ldaxr(v35);
        while (__stlxr(v36 - 1, v35));
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }
    }
    else
    {
      SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::operator()(*a4, 0, 0);
    }
    v37 = v51;
    if (v51)
    {
      v38 = (unint64_t *)&v51->__shared_owners_;
      do
        v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }
  }
  else
  {
    SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::operator()(*a4, 0, 0);
  }
}

void sub_1840653FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3 - 64);
  _Unwind_Resume(a1);
}

uint64_t Tube::resetAuthState(Tube *this)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 14) + 80))(*((_QWORD *)this + 14));
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(result - 176) + 256))(result - 176);
  return result;
}

uint64_t Tube::clientDescription(Tube *this)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 14) + 80))(*((_QWORD *)this + 14));
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(result - 176) + 264))(result - 176);
  return result;
}

void Tube::needClientCert(int *a1, CFTypeRef cf, void *aBlock)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  uint64_t v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  _QWORD v19[6];
  std::__shared_weak_count *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;

  if (*((_QWORD *)a1 + 31))
    __assert_rtn("needClientCert", "Tube.cpp", 1773, "!fSSLDistNames");
  *((_QWORD *)a1 + 31) = cf;
  if (cf)
    CFRetain(cf);
  *((_QWORD *)a1 + 38) = _Block_copy(aBlock);
  if (a1[55] < 10)
  {
    a1[55] = 8;
    v5 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a1 + 14) + 80))(*((_QWORD *)a1 + 14));
    v6 = v5;
    if (v5)
      v7 = v5 - 176;
    else
      v7 = 0;
    if (v5)
      CFRetain((CFTypeRef)(v5 - 192));
    if (v6)
      v8 = v7 + 120;
    else
      v8 = 0;
    v21 = v8;
    v9 = (std::__shared_weak_count *)operator new();
    v9->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    v9->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F10F0;
    v9->__shared_weak_owners_ = 0;
    v9[1].__vftable = (std::__shared_weak_count_vtbl *)v7;
    v22 = v9;
    (*(void (**)(int *))(*(_QWORD *)a1 + 40))(a1);
    (*(void (**)(int *))(*(_QWORD *)a1 + 40))(a1);
    v11 = *(_QWORD *)(v7 + 24);
    v19[0] = MEMORY[0x1E0C809B0];
    v19[1] = 3321888768;
    v19[2] = ___ZN4Tube23_onqueue_needClientCertEv_block_invoke;
    v19[3] = &__block_descriptor_56_e8_40c82_ZTSNSt3__110shared_ptrIN19TransportConnection31ConnectionEstablishmentDelegateEEE_e5_v8__0l;
    v19[4] = a1;
    v19[5] = v8;
    v20 = v9;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v11 + 96))(v11, v19);
    v13 = v20;
    if (v20)
    {
      v14 = (unint64_t *)&v20->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    v16 = v22;
    if (v22)
    {
      v17 = (unint64_t *)&v22->__shared_owners_;
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
  else
  {
    Tube::_onqueue_complete_needClientCert((Tube *)a1, 0, 1);
  }
}

void sub_1840656EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t Tube::connectionWaitingNotification(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  if (*(_DWORD *)(a1 + 220) != 10)
    *(_DWORD *)(a1 + 220) = 5;
  *(_QWORD *)(a1 + 288) = a2;
  v4 = *(_QWORD *)(a1 + 112);
  if (v4)
  {
    v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 80))(v4);
    if (v5)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 240))(v5, a2);
  }
  result = *(_QWORD *)(a1 + 280);
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(result + 16))(result, a2);
  return result;
}

void `non-virtual thunk to'Tube::~Tube(Tube *this)
{
  Tube::~Tube((Tube *)((char *)this - 24));
}

{
  Tube::~Tube((Tube *)((char *)this - 32));
}

{
  Tube::~Tube((Tube *)((char *)this - 40));
}

{
  Tube::~Tube((Tube *)((char *)this - 96));
}

void `non-virtual thunk to'Tube::~Tube(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  Tube::~Tube((Tube *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

{
  CFAllocatorRef *v2;

  v2 = this - 4;
  Tube::~Tube((Tube *)(this - 4));
  CFAllocatorDeallocate(*(this - 3), v2);
}

{
  CFAllocatorRef *v2;

  v2 = this - 5;
  Tube::~Tube((Tube *)(this - 5));
  CFAllocatorDeallocate(*(this - 4), v2);
}

{
  CFAllocatorRef *v2;

  v2 = this - 12;
  Tube::~Tube((Tube *)(this - 12));
  CFAllocatorDeallocate(*(this - 11), v2);
}

void GlueConnectionEstablishment::ceRetain(GlueConnectionEstablishment *this)
{
  abort();
}

void GlueConnectionEstablishment::ceRelease(GlueConnectionEstablishment *this)
{
  abort();
}

void GlueConnectionEstablishment::ssPreConnectConfiguration()
{
  abort();
}

void GlueConnectionEstablishment::ssNeedServerTrust()
{
  abort();
}

void GlueConnectionEstablishment::ssNeedClientCert()
{
  abort();
}

void GlueConnectionEstablishment::ssPostConnectConfiguration()
{
  abort();
}

void GlueConnectionEstablishment::ssPostHandshakesStreamsAvailable(GlueConnectionEstablishment *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  abort();
}

void GlueConnectionEstablishment::ssConnectionWaitingNotification()
{
  abort();
}

void `non-virtual thunk to'Tube::needClientCert(uint64_t a1, const void *a2, void *a3)
{
  Tube::needClientCert((int *)(a1 - 32), a2, a3);
}

{
  Tube::needClientCert((int *)(a1 - 40), a2, a3);
}

uint64_t `non-virtual thunk to'Tube::connectionWaitingNotification(uint64_t a1, uint64_t a2)
{
  return Tube::connectionWaitingNotification(a1 - 32, a2);
}

{
  return Tube::connectionWaitingNotification(a1 - 40, a2);
}

void `non-virtual thunk to'Tube::generateProxyAuthentication(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  Tube::generateProxyAuthentication((_QWORD **)(a1 - 96), a2, a3, a4);
}

uint64_t `non-virtual thunk to'Tube::resetAuthState(Tube *this)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 80))(*((_QWORD *)this + 2));
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(result - 176) + 256))(result - 176);
  return result;
}

uint64_t `non-virtual thunk to'Tube::clientDescription(Tube *this)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 80))(*((_QWORD *)this + 2));
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(result - 176) + 264))(result - 176);
  return result;
}

void Tube::_onqueue_complete_needClientCert(Tube *this, const __CFArray *a2, uint64_t a3)
{
  void (**v6)(_QWORD, _QWORD, _QWORD);
  const void *v7;

  v6 = (void (**)(_QWORD, _QWORD, _QWORD))*((_QWORD *)this + 38);
  *((_QWORD *)this + 38) = 0;
  v7 = (const void *)*((_QWORD *)this + 31);
  *((_QWORD *)this + 31) = 0;
  if (v7)
    CFRelease(v7);
  if (v6)
  {
    ((void (**)(_QWORD, const __CFArray *, uint64_t))v6)[2](v6, a2, a3);
    _Block_release(v6);
  }
  if ((_DWORD)a3)
    Tube::_onqueue_cancel(this);
}

uint64_t ___ZN4Tube23_onqueue_needClientCertEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v6[5];
  _QWORD block[6];
  char v8;

  v1 = *(_QWORD *)(a1 + 32);
  if (*(int *)(v1 + 220) < 10)
  {
    v3 = *(_QWORD *)(a1 + 40);
    v4 = *(_QWORD *)(v1 + 248);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = ___ZN4Tube23_onqueue_needClientCertEv_block_invoke_2;
    v6[3] = &__block_descriptor_40_e23_v20__0____CFArray__8B16l;
    v6[4] = v1;
    (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v3 + 40))(v3, v4, v6);
  }
  else
  {
    (*(void (**)(_QWORD))(*(_QWORD *)v1 + 40))(*(_QWORD *)(a1 + 32));
    v2 = *(NSObject **)(v1 + 160);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___ZN4Tube24_complete_needClientCertEPK9__CFArrayb_block_invoke;
    block[3] = &__block_descriptor_49_e5_v8__0l;
    block[4] = v1;
    block[5] = 0;
    v8 = 1;
    dispatch_async(v2, block);
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

uint64_t ___ZN4Tube24_complete_needClientCertEPK9__CFArrayb_block_invoke(uint64_t a1)
{
  Tube *v2;
  const void *v3;

  v2 = *(Tube **)(a1 + 32);
  Tube::_onqueue_complete_needClientCert(v2, *(const __CFArray **)(a1 + 40), *(unsigned __int8 *)(a1 + 48));
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
  return (*(uint64_t (**)(Tube *))(*(_QWORD *)v2 + 48))(v2);
}

uint64_t ___ZN4Tube23_onqueue_needClientCertEv_block_invoke_2(uint64_t a1, const void *a2, char a3)
{
  _QWORD *v5;
  NSObject *v6;
  _QWORD block[6];
  char v9;

  v5 = *(_QWORD **)(a1 + 32);
  (*(void (**)(_QWORD *))(*v5 + 40))(v5);
  if (a2)
    CFRetain(a2);
  v6 = v5[20];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN4Tube24_complete_needClientCertEPK9__CFArrayb_block_invoke;
  block[3] = &__block_descriptor_49_e5_v8__0l;
  block[4] = v5;
  block[5] = a2;
  v9 = a3;
  dispatch_async(v6, block);
  return (*(uint64_t (**)(_QWORD *))(*v5 + 48))(v5);
}

void std::__shared_ptr_pointer<Tube *,Tube::postConnectConfiguration(NSObject  {objcproto17OS_tcp_connection}*,NSObject {objcproto16OS_nw_parameters}*,void({block_pointer})(void))::$_0,std::allocator<Tube>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_pointer<Tube *,Tube::postConnectConfiguration(NSObject  {objcproto17OS_tcp_connection}*,NSObject {objcproto16OS_nw_parameters}*,void({block_pointer})(void))::$_0,std::allocator<Tube>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

void ___ZN4Tube16_onqueue_connectEv_block_invoke_3(uint64_t a1, unsigned int a2)
{
  CFStreamError v2;

  if (!a2)
    __assert_rtn("_onqueue_errorHandler", "Tube.cpp", 1112, "posixErrorCode != 0");
  *(_QWORD *)&v2.error = a2;
  v2.domain = 1;
  Tube::_onqueue_errorHandler(*(Tube **)(a1 + 32), v2);
}

void std::__shared_ptr_pointer<Tube *,Deleter_CustomBlock,std::allocator<Tube>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t __copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void ___ZN4Tube23preConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0_U13block_pointerFvvE_block_invoke(uint64_t a1, const void *a2, int a3, std::__shared_weak_count_vtbl *cf, int a5, uint64_t *a6)
{
  uint64_t v7;
  AuthBrokerAgentClient *v13;
  uint64_t v14;
  void (*v15)(_QWORD *, _QWORD, _QWORD);
  uint64_t v16;
  _QWORD *v17;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  std::__shared_weak_count_vtbl *v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  unint64_t *v55;
  unint64_t v56;
  uint64_t v57;
  std::__shared_weak_count *v58;
  _QWORD v59[7];
  std::__shared_weak_count *v60;
  uint64_t v61;
  std::__shared_weak_count *v62;
  std::__shared_weak_count_vtbl *v63;
  std::__shared_weak_count *v64;
  uint64_t v65;
  std::__shared_weak_count *v66;
  int v67;
  int v68;
  uint64_t v69;
  std::__shared_weak_count *v70;
  std::__shared_weak_count_vtbl *v71;
  std::__shared_weak_count *v72;
  std::__shared_weak_count_vtbl *v73;
  std::__shared_weak_count *v74;

  v7 = *(_QWORD *)(a1 + 40);
  if (!v7)
    goto LABEL_7;
  if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 88) != 2)
  {
    v13 = *(AuthBrokerAgentClient **)(v7 + 80);
    if (!v13
      || (v13 = (AuthBrokerAgentClient *)-[AuthBrokerAgentClient _preventsSystemHTTPProxyAuthentication](v13, "_preventsSystemHTTPProxyAuthentication"), (v13 & 1) == 0))
    {
      if (((*(unsigned int *)(v7 + 192) | ((unint64_t)*(unsigned __int16 *)(v7 + 196) << 32)) & 0x2000000000) == 0
        && (AuthBrokerAgentClient::AuthBrokerIsAvailable(v13) & 1) != 0)
      {
LABEL_7:
        v14 = *a6;
        if (*a6)
        {
          v15 = *(void (**)(_QWORD *, _QWORD, _QWORD))(v14 + 8);
          v16 = *(_QWORD *)(v14 + 16);
          v17 = (_QWORD *)(v14 + (v16 >> 1));
          if ((v16 & 1) != 0)
            v15 = *(void (**)(_QWORD *, _QWORD, _QWORD))(*v17 + v15);
          v15(v17, 0, 0);
        }
        return;
      }
    }
    v7 = *(_QWORD *)(a1 + 40);
  }
  v18 = (std::__shared_weak_count *)a6[1];
  v57 = *a6;
  v58 = v18;
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v20 = __ldxr(p_shared_owners);
    while (__stxr(v20 + 1, p_shared_owners));
  }
  if (cf)
    cf = (std::__shared_weak_count_vtbl *)CFRetain(cf);
  v73 = cf;
  v21 = (std::__shared_weak_count *)operator new();
  v21->__shared_owners_ = 0;
  v22 = (unint64_t *)&v21->__shared_owners_;
  v21->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19E8;
  v21->__shared_weak_owners_ = 0;
  v21[1].__vftable = cf;
  v74 = v21;
  if (a2)
    v23 = (std::__shared_weak_count_vtbl *)CFRetain(a2);
  else
    v23 = 0;
  v71 = v23;
  v24 = (std::__shared_weak_count *)operator new();
  v24->__shared_owners_ = 0;
  v25 = (unint64_t *)&v24->__shared_owners_;
  v24->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1630;
  v24->__shared_weak_owners_ = 0;
  v24[1].__vftable = v23;
  v72 = v24;
  if (v7)
    CFRetain((CFTypeRef)(v7 - 16));
  v69 = v7;
  v26 = (std::__shared_weak_count *)operator new();
  v26->__shared_owners_ = 0;
  v27 = (unint64_t *)&v26->__shared_owners_;
  v26->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F10F0;
  v26->__shared_weak_owners_ = 0;
  v26[1].__vftable = (std::__shared_weak_count_vtbl *)v7;
  v70 = v26;
  v28 = *(_QWORD *)(v7 + 24);
  v59[0] = MEMORY[0x1E0C809B0];
  v59[1] = 3321888768;
  v59[2] = ___ZN12HTTPProtocol24handleProxyAuthChallengeEP15__CFHTTPMessagejPK10__CFStringi18SmartBlockWithArgsIJPK16_CFURLCredentialbEE_block_invoke;
  v59[3] = &__block_descriptor_120_e8_48c39_ZTSNSt3__110shared_ptrIK10__CFStringEE64c49_ZTS18SmartBlockWithArgsIJPK16_CFURLCredentialbEE80c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE96c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e5_v8__0l;
  v59[4] = v7;
  v59[5] = a2;
  v59[6] = cf;
  v60 = v21;
  do
    v29 = __ldxr(v22);
  while (__stxr(v29 + 1, v22));
  v67 = a5;
  v61 = v57;
  v62 = v58;
  if (v58)
  {
    v30 = (unint64_t *)&v58->__shared_owners_;
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  v63 = v23;
  v64 = v24;
  do
    v32 = __ldxr(v25);
  while (__stxr(v32 + 1, v25));
  v68 = a3;
  v65 = v7;
  v66 = v26;
  do
    v33 = __ldxr(v27);
  while (__stxr(v33 + 1, v27));
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v28 + 96))(v28, v59);
  v34 = v66;
  if (v66)
  {
    v35 = (unint64_t *)&v66->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v37 = v64;
  if (v64)
  {
    v38 = (unint64_t *)&v64->__shared_owners_;
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
  v40 = v62;
  if (v62)
  {
    v41 = (unint64_t *)&v62->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
  v43 = v60;
  if (v60)
  {
    v44 = (unint64_t *)&v60->__shared_owners_;
    do
      v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }
  v46 = v70;
  if (v70)
  {
    v47 = (unint64_t *)&v70->__shared_owners_;
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
  v49 = v72;
  if (v72)
  {
    v50 = (unint64_t *)&v72->__shared_owners_;
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
  v52 = v74;
  if (v74)
  {
    v53 = (unint64_t *)&v74->__shared_owners_;
    do
      v54 = __ldaxr(v53);
    while (__stlxr(v54 - 1, v53));
    if (!v54)
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
  }
  if (v58)
  {
    v55 = (unint64_t *)&v58->__shared_owners_;
    do
      v56 = __ldaxr(v55);
    while (__stlxr(v56 - 1, v55));
    if (!v56)
    {
      ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
      std::__shared_weak_count::__release_weak(v58);
    }
  }
}

void sub_184066114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v29);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v28);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v26);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a26);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v30 - 120);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v30 - 104);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::invoke_normal(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;

  v6 = *a1;
  v7 = (std::__shared_weak_count *)a6[1];
  v13 = *a6;
  v14 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(v6 + 16))(v6, a2, a3, a4, a5, &v13);
  v10 = v14;
  if (v14)
  {
    v11 = (unint64_t *)&v14->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_184066200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t BlockHolderVar<void *>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a1 + 16))();
}

void BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::invoke_initial(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;

  a1[1] = (uint64_t)BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::invoke_normal;
  a1[2] = 0;
  v6 = *a1;
  v7 = (std::__shared_weak_count *)a6[1];
  v13 = *a6;
  v14 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(v6 + 16))(v6, a2, a3, a4, a5, &v13);
  v10 = v14;
  if (v14)
  {
    v11 = (unint64_t *)&v14->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_1840662B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>> *,SmartBlockWithArgs<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::Deleter,std::allocator<BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t ___ZN4Tube27_onqueue_saveSSLCertContextEv_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 136) + 216))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 136));
}

void ___ZN4Tube27generateProxyAuthenticationENSt3__110shared_ptrI12NetworkProxyEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJNS1_I19AuthenticationStateEEEE_block_invoke(_QWORD *a1, uint64_t *a2)
{
  NSObject *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD v17[5];
  std::__shared_weak_count *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;

  v3 = *(NSObject **)(a1[4] + 160);
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 3321888768;
  v17[2] = ___ZN4Tube27generateProxyAuthenticationENSt3__110shared_ptrI12NetworkProxyEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJNS1_I19AuthenticationStateEEEE_block_invoke_2;
  v17[3] = &__block_descriptor_64_e8_32c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE48c47_ZTSNSt3__110shared_ptrI19AuthenticationStateEE_e5_v8__0l;
  v5 = a1[6];
  v4 = (std::__shared_weak_count *)a1[7];
  v17[4] = v5;
  v18 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = (std::__shared_weak_count *)a2[1];
  v19 = *a2;
  v20 = v8;
  if (v8)
  {
    v9 = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  dispatch_async(v3, v17);
  v11 = v20;
  if (v20)
  {
    v12 = (unint64_t *)&v20->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v18;
  if (v18)
  {
    v15 = (unint64_t *)&v18->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

void SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::operator()(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  unint64_t *p_shared_owners;
  unint64_t v4;
  void (*v5)(_QWORD *, uint64_t *);
  uint64_t v6;
  _QWORD *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v16;
  std::__shared_weak_count *v17;

  if (a1)
  {
    if (a3)
    {
      p_shared_owners = (unint64_t *)&a3->__shared_owners_;
      do
        v4 = __ldxr(p_shared_owners);
      while (__stxr(v4 + 1, p_shared_owners));
    }
    v5 = *(void (**)(_QWORD *, uint64_t *))(a1 + 8);
    v6 = *(_QWORD *)(a1 + 16);
    v7 = (_QWORD *)(a1 + (v6 >> 1));
    if ((v6 & 1) != 0)
      v5 = *(void (**)(_QWORD *, uint64_t *))(*v7 + v5);
    v16 = a2;
    v17 = a3;
    if (a3)
    {
      v8 = (unint64_t *)&a3->__shared_owners_;
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
    v5(v7, &v16);
    v10 = v17;
    if (v17)
    {
      v11 = (unint64_t *)&v17->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    if (a3)
    {
      v13 = (unint64_t *)&a3->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
        std::__shared_weak_count::__release_weak(a3);
      }
    }
  }
}

void sub_184066500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_32c31_ZTSNSt3__110shared_ptrI4TubeEE48c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c31_ZTSNSt3__110shared_ptrI4TubeEE48c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 32;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void ___ZN4Tube27generateProxyAuthenticationENSt3__110shared_ptrI12NetworkProxyEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJNS1_I19AuthenticationStateEEEE_block_invoke_2(uint64_t *a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v1 = a1[6];
  v2 = (std::__shared_weak_count *)a1[7];
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::operator()(a1[4], v1, v2);
  if (v2)
  {
    v5 = (unint64_t *)&v2->__shared_owners_;
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
}

void sub_184066614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_32c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE48c47_ZTSNSt3__110shared_ptrI19AuthenticationStateEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE48c47_ZTSNSt3__110shared_ptrI19AuthenticationStateEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 32;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void std::__shared_ptr_pointer<Tube *,Tube::generateProxyAuthentication(std::shared_ptr<NetworkProxy>,std::shared_ptr<HTTPResponseMessage>,SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>)::$_0,std::allocator<Tube>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_pointer<Tube *,Tube::generateProxyAuthentication(std::shared_ptr<NetworkProxy>,std::shared_ptr<HTTPResponseMessage>,SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>)::$_0,std::allocator<Tube>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

void sub_184067044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1840672B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1840681F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  _Unwind_Resume(exception_object);
}

void __Block_byref_object_copy__6654(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__6655(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_18406AAC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL FTPProtocol::_canHandleRequest(FTPProtocol *this, const _CFURLRequest *a2, const void *a3)
{
  const __CFURL *v3;
  const __CFString *v4;
  const __CFString *v5;
  _BOOL8 v6;

  if (!this)
    return 0;
  v3 = *(const __CFURL **)(-[FTPProtocol _inner](this, "_inner", a3) + 8);
  if (!v3)
    return 0;
  v4 = CFURLCopyScheme(v3);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = CFStringCompare(v4, CFSTR("ftp"), 1uLL) == kCFCompareEqualTo;
  CFRelease(v5);
  return v6;
}

const __CFAllocator *FTPProtocol::_createCanonicalRequest(FTPProtocol *this, const __CFAllocator *a2, const _CFURLRequest *a3, NSURLSessionTask *a4, const void *a5)
{
  const __CFAllocator *v5;
  const __CFURL *v6;
  const __CFURL *v7;
  const __CFURL *v8;
  BOOL v9;
  unsigned __int8 v11;

  v5 = a2;
  v6 = *(const __CFURL **)(-[__CFAllocator _inner](a2, "_inner", a3, a4, a5) + 8);
  v11 = 0;
  v7 = _createCanonicalURL(v6, 1, 0, &v11);
  v8 = v7;
  if (v7)
    v9 = v7 == v6;
  else
    v9 = 1;
  if (v9)
  {
    if (v7)
      CFRelease(v7);
    if (v5)
      return (const __CFAllocator *)CFRetain(v5);
  }
  else
  {
    v5 = (const __CFAllocator *)-[__CFAllocator mutableCopy](v5, "mutableCopy");
    CFURLRequestSetURL(v5, v8);
    CFRelease(v8);
  }
  return v5;
}

uint64_t FTPProtocol::_requestsAreCacheEquivalent(FTPProtocol *this, const _CFURLRequest *a2, const _CFURLRequest *a3, const void *a4)
{
  return 0;
}

uint64_t FTPProtocol::_instantiateProtocol(FTPProtocol *this, NSURLSessionTask *a2, URLProtocolClient *a3, URLProtocolClient *a4, const void *a5)
{
  uint64_t Instance;
  uint64_t v8;

  if (TCFObject<URLProtocol>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLProtocol>::Class(void)::sOnce, &__block_literal_global_22);
  Instance = _CFRuntimeCreateInstance();
  v8 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    v8 = Instance + 16;
    *(_QWORD *)(Instance + 176) = 0;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
  }
  *(_OWORD *)(v8 + 152) = 0u;
  *(_OWORD *)(v8 + 136) = 0u;
  *(_OWORD *)(v8 + 120) = 0u;
  *(_OWORD *)(v8 + 104) = 0u;
  *(_OWORD *)(v8 + 88) = 0u;
  *(_OWORD *)(v8 + 72) = 0u;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 40) = 0u;
  *(_OWORD *)(v8 + 24) = 0u;
  *(_QWORD *)v8 = &off_1E14E4DD8;
  *(_QWORD *)(v8 + 8) = &unk_1E14E4ED8;
  *(_QWORD *)(v8 + 16) = &unk_1E14E4EF8;
  URLProtocol::initialize((URLProtocol *)v8, a2, a3);
  return v8 - 16;
}

CFStringRef FTPProtocol::copyDebugDesc(FTPProtocol *this)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<FTP protocol instance %p>"), this);
}

void FTPProtocol::_protocolInterface_startLoad(FTPProtocol *this, const _CFCachedURLResponse *a2)
{
  void *v3;
  CFTypeRef v4;
  CFURLRef v5;
  CFURLRef v6;
  CFTypeID v7;
  CFURLRef v8;
  const __CFString *v9;
  const __CFString *v10;
  char v11;
  char v12;
  const __CFAllocator *v13;
  __CFReadStream *v14;
  __CFError *CFError;
  const __CFAllocator *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __CFError *v22;
  CFStreamClientContext clientContext;

  if ((*((_BYTE *)this + 112) & 4) == 0)
  {
    v3 = (void *)*((_QWORD *)this + 11);
    v4 = (CFTypeRef)objc_msgSend(v3, "cfURL");
    if (v4)
      v4 = CFRetain(v4);
    *((_QWORD *)this + 20) = v4;
    v5 = _CFURLRequestCopyProtocolPropertyForKey(v3, CFSTR("kCFFTPProtocolPropertyReturnDirectoryListing"));
    if (v5)
    {
      v6 = v5;
      v7 = CFGetTypeID(v5);
      if (v7 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        LOWORD(clientContext.version) = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&clientContext, 2u);
      }
      v8 = (CFURLRef)*MEMORY[0x1E0C9AE40];
      CFRelease(v6);
      if (v8 == v6)
        *((_BYTE *)this + 112) |= 0x10u;
    }
  }
  v9 = CFURLCopyPath(*((CFURLRef *)this + 20));
  if (v9)
  {
    v10 = v9;
    if (CFStringGetLength(v9) && !CFURLHasDirectoryPath(*((CFURLRef *)this + 20)))
      v11 = *((_BYTE *)this + 112) & 0xF7;
    else
      v11 = *((_BYTE *)this + 112) | 8;
    *((_BYTE *)this + 112) = v11;
    CFRelease(v10);
    v12 = *((_BYTE *)this + 112);
  }
  else
  {
    v12 = *((_BYTE *)this + 112) | 8;
    *((_BYTE *)this + 112) = v12;
  }
  if ((v12 & 0x1C) == 0x18)
  {
    FTPProtocol::checkAndSendDidReceiveResponse(this);
    URLProtocol::sendDidFinishLoading((URLProtocol *)this);
    return;
  }
  v13 = CFGetAllocator((char *)this - 16);
  v14 = CFReadStreamCreateWithFTPURL(v13, *((CFURLRef *)this + 20));
  *((_QWORD *)this + 18) = v14;
  if (v14)
  {
    clientContext.version = 0;
    clientContext.info = this;
    memset(&clientContext.retain, 0, 24);
    CFReadStreamSetClient(v14, 0x1AuLL, (CFReadStreamClientCallBack)FTPProtocol::_ftpReadStreamCB, &clientContext);
    CFReadStreamSetProperty(*((CFReadStreamRef *)this + 18), CFSTR("kCFStreamPropertyFTPFetchResourceInfo"), (CFTypeRef)*MEMORY[0x1E0C9AE50]);
    *((_QWORD *)this + 19) = 0;
    CoreSchedulingSet::scheduleStream(*((CoreSchedulingSet **)this + 3), *((__CFReadStream **)this + 18));
    if (CFReadStreamOpen(*((CFReadStreamRef *)this + 18)))
      return;
    CFError = CFReadStreamCopyError(*((CFReadStreamRef *)this + 18));
  }
  else
  {
    v16 = CFGetAllocator((char *)this - 16);
    CFError = __cfnCreateCFError(v16, CFSTR("kCFErrorDomainCFNetwork"), -998, v17, v18, v19, v20, v21, 0);
  }
  v22 = CFError;
  URLProtocol::sendDidFail((URLProtocol *)this, CFError);
  if (v22)
    CFRelease(v22);
}

void FTPProtocol::_protocolInterface_cancelLoad(FTPProtocol *this)
{
  if ((*((_BYTE *)this + 112) & 0x20) == 0)
  {
    *((_BYTE *)this + 112) |= 0x20u;
    FTPProtocol::destroyReadStream(this);
  }
}

uint64_t FTPProtocol::_protocolInterface_haltLoad(uint64_t this)
{
  *(_BYTE *)(this + 112) |= 1u;
  return this;
}

void FTPProtocol::_protocolInterface_resumeLoad(FTPProtocol *this)
{
  *((_BYTE *)this + 112) &= ~1u;
  if (*((_QWORD *)this + 18))
  {
    if (*((_QWORD *)this + 19))
    {
      FTPProtocol::ftpReadStreamEvent(this);
      *((_QWORD *)this + 19) = 0;
    }
  }
}

void FTPProtocol::subclassUpdateScheduling(FTPProtocol *this, const CoreSchedulingSet *a2, CoreSchedulingSet *a3)
{
  __CFReadStream *v4;
  CoreSchedulingSet *v6;

  if ((*((_BYTE *)this + 112) & 1) != 0)
  {
    v4 = (__CFReadStream *)*((_QWORD *)this + 18);
    if (v4)
    {
      v6 = (CoreSchedulingSet *)*((_QWORD *)this + 3);
      if (v6)
      {
        CoreSchedulingSet::unscheduleStream(v6, v4);
        v4 = (__CFReadStream *)*((_QWORD *)this + 18);
      }
      CoreSchedulingSet::scheduleStream(a3, v4);
    }
  }
}

uint64_t FTPProtocol::needsThrottler(FTPProtocol *this)
{
  return 1;
}

void `non-virtual thunk to'FTPProtocol::~FTPProtocol(FTPProtocol *this)
{
  FTPProtocol::~FTPProtocol((FTPProtocol *)((char *)this - 8));
}

{
  FTPProtocol::~FTPProtocol((FTPProtocol *)((char *)this - 8));
}

{
  FTPProtocol::~FTPProtocol((FTPProtocol *)((char *)this - 16));
}

{
  FTPProtocol::~FTPProtocol((FTPProtocol *)((char *)this - 16));
}

void FTPProtocol::~FTPProtocol(FTPProtocol *this)
{
  const void *v2;
  const void *v3;

  *(_QWORD *)this = &off_1E14E4DD8;
  *((_QWORD *)this + 1) = &unk_1E14E4ED8;
  *((_QWORD *)this + 2) = &unk_1E14E4EF8;
  v2 = (const void *)*((_QWORD *)this + 15);
  if (v2)
    CFRelease(v2);
  FTPProtocol::destroyReadStream(this);
  v3 = (const void *)*((_QWORD *)this + 20);
  if (v3)
    CFRelease(v3);
  URLProtocol::~URLProtocol((URLProtocol *)this);
}

void sub_18406B1B4(_Unwind_Exception *a1)
{
  URLProtocol *v1;

  URLProtocol::~URLProtocol(v1);
  _Unwind_Resume(a1);
}

void FTPProtocol::destroyReadStream(FTPProtocol *this)
{
  __CFReadStream *v2;
  const void *v3;

  v2 = (__CFReadStream *)*((_QWORD *)this + 18);
  if (v2)
  {
    CFReadStreamSetClient(v2, 0, 0, 0);
    CFReadStreamClose(*((CFReadStreamRef *)this + 18));
    v3 = (const void *)*((_QWORD *)this + 18);
    if (v3)
      CFRelease(v3);
    *((_QWORD *)this + 18) = 0;
  }
}

void FTPProtocol::ftpReadStreamEvent(FTPProtocol *this)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const __CFAllocator *v6;
  const __CFData *v7;
  const __CFData *v8;
  Throttler *v9;
  CFIndex Length;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  CFErrorRef v14;
  CFStreamError Error;
  CFIndex v16;
  const __CFAllocator *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __CFError *CFError;
  const __CFAllocator *v24;
  CFStringRef v25;
  const __CFString *v26;
  const void *v27;
  const __CFAllocator *v28;
  UInt8 buffer[4];
  const char *v30;
  uint64_t v31;

  v1 = MEMORY[0x1E0C80A78](this);
  v3 = v2;
  v4 = v1;
  v31 = *MEMORY[0x1E0C80C00];
  if ((v2 > 0x10 || ((1 << v2) & 0x10104) == 0) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buffer = 136315138;
    v30 = "ftpReadStreamEvent";
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "%s(): Called back for an event we don't recognize!", buffer, 0xCu);
  }
  if ((*(_BYTE *)(v4 + 112) & 1) != 0)
  {
    *(_QWORD *)(v4 + 152) = v3;
    return;
  }
  if (v3 == 16)
  {
    if ((*(_BYTE *)(v4 + 112) & 4) == 0)
    {
      FTPProtocol::checkAndSendDidReceiveResponse((FTPProtocol *)v4);
      URLProtocol::sendDidFinishLoading((URLProtocol *)v4);
      return;
    }
    goto LABEL_28;
  }
  if (v3 != 8)
  {
    if (v3 != 2)
      return;
    if ((*(_BYTE *)(v4 + 112) & 4) == 0)
    {
      FTPProtocol::checkAndSendDidReceiveResponse((FTPProtocol *)v4);
      v5 = CFReadStreamRead(*(CFReadStreamRef *)(v4 + 144), buffer, 0x10000);
      if (v5 >= 1)
      {
        v6 = CFGetAllocator((CFTypeRef)(v4 - 16));
        v7 = CFDataCreate(v6, buffer, v5);
        v8 = v7;
        if (v7)
        {
          v9 = *(Throttler **)(v4 + 64);
          if (v9)
          {
            Length = CFDataGetLength(v7);
            Throttler::noteOutstandingBytes(v9, Length);
          }
        }
        v11 = *(_QWORD *)(v4 + 96);
        if (v11)
        {
          v12 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v11 + 16))(*(_QWORD *)(v4 + 96));
          v13 = (void *)MEMORY[0x186DB8C8C](v12);
          (*(void (**)(_QWORD, const __CFData *, uint64_t))(**(_QWORD **)(v4 + 96) + 72))(*(_QWORD *)(v4 + 96), v8, v5);
          objc_autoreleasePoolPop(v13);
          (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
        }
        CFRelease(v8);
      }
      return;
    }
LABEL_28:
    FTPProtocol::redirectToCurrentURL((FTPProtocol *)v4);
    return;
  }
  v14 = CFReadStreamCopyError(*(CFReadStreamRef *)(v4 + 144));
  Error = CFReadStreamGetError((CFReadStreamRef)*(_QWORD *)(v4 + 144));
  *(CFStreamError *)(v4 + 128) = Error;
  if ((*(_BYTE *)(v4 + 112) & 0xC) == 0)
  {
    if (Error.domain == 6 || Error.error == 550)
    {
      *(_BYTE *)(v4 + 112) |= 4u;
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 96))(v4);
      v24 = CFGetAllocator((CFTypeRef)(v4 - 16));
      v25 = CFURLGetString(*(CFURLRef *)(v4 + 160));
      v26 = CFStringCreateWithFormat(v24, 0, CFSTR("%@/"), v25);
      v27 = *(const void **)(v4 + 160);
      if (v27)
        CFRelease(v27);
      v28 = CFGetAllocator((CFTypeRef)(v4 - 16));
      *(_QWORD *)(v4 + 160) = CFURLCreateWithString(v28, v26, 0);
      if (v26)
        CFRelease(v26);
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 88))(v4, 0);
      goto LABEL_40;
    }
    goto LABEL_32;
  }
  if (Error.domain != 6)
    goto LABEL_32;
  v16 = -1004;
  if (Error.error > 521)
  {
    if (Error.error <= 549)
    {
      if (Error.error == 522)
        goto LABEL_33;
      if (Error.error == 530)
      {
        v16 = -1102;
        goto LABEL_33;
      }
      goto LABEL_32;
    }
    if (Error.error != 550 && Error.error != 553)
      goto LABEL_32;
LABEL_51:
    v16 = -1008;
    goto LABEL_33;
  }
  if (Error.error > 425)
  {
    if (Error.error == 426)
    {
      v16 = -1005;
      goto LABEL_33;
    }
    if (Error.error != 450)
    {
LABEL_32:
      v16 = -998;
      goto LABEL_33;
    }
    goto LABEL_51;
  }
  if (Error.error != 421 && Error.error != 425)
    goto LABEL_32;
LABEL_33:
  v17 = CFGetAllocator((CFTypeRef)(v4 - 16));
  CFError = __cfnCreateCFError(v17, CFSTR("kCFErrorDomainCFNetwork"), v16, v18, v19, v20, v21, v22, 0);
  URLProtocol::sendDidFail((URLProtocol *)v4, CFError);
  if (CFError)
    CFRelease(CFError);
LABEL_40:
  if (v14)
    CFRelease(v14);
}

void FTPProtocol::redirectToCurrentURL(FTPProtocol *this)
{
  void *v2;
  CFAllocatorRef v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  v2 = (void *)*((_QWORD *)this + 11);
  if (v2)
  {
    CFGetAllocator((char *)this - 16);
    v2 = (void *)objc_msgSend(v2, "mutableCopy");
  }
  CFURLRequestSetURL(v2, *((const void **)this + 20));
  v3 = CFGetAllocator((char *)this - 16);
  v4 = CFURLResponseCreate((uint64_t)v3, *((const void **)this + 20), CFSTR("application/x-ftp-directory"), -1, 0, 0);
  v5 = *((_QWORD *)this + 12);
  if (v5)
  {
    v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v5 + 16))(*((_QWORD *)this + 12));
    v7 = (void *)MEMORY[0x186DB8C8C](v6);
    (*(void (**)(_QWORD, void *, id))(**((_QWORD **)this + 12) + 40))(*((_QWORD *)this + 12), v2, v4);
    objc_autoreleasePoolPop(v7);
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  }
  if (v4)
    CFRelease(v4);
  if (v2)
    CFRelease(v2);
  *((_BYTE *)this + 112) &= ~4u;
}

void FTPProtocol::checkAndSendDidReceiveResponse(FTPProtocol *this)
{
  char v1;
  const __CFString *v3;
  __CFReadStream *v4;
  const __CFNumber *v5;
  const __CFNumber *v6;
  CFAllocatorRef v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t valuePtr;

  v1 = *((_BYTE *)this + 112);
  if ((v1 & 2) == 0)
  {
    *((_BYTE *)this + 112) = v1 | 2;
    if (!*((_QWORD *)this + 15))
    {
      valuePtr = -1;
      if ((v1 & 8) != 0)
        v3 = (const __CFString *)CFRetain(&unk_1EDCFFAE8);
      else
        v3 = 0;
      v4 = (__CFReadStream *)*((_QWORD *)this + 18);
      if (v4)
      {
        v5 = (const __CFNumber *)CFReadStreamCopyProperty(v4, CFSTR("kCFStreamPropertyFTPResourceSize"));
        if (v5)
        {
          v6 = v5;
          CFNumberGetValue(v5, kCFNumberLongLongType, &valuePtr);
          CFRelease(v6);
        }
      }
      v7 = CFGetAllocator((char *)this - 16);
      *((_QWORD *)this + 15) = CFURLResponseCreate((uint64_t)v7, *((const void **)this + 20), v3, valuePtr, 0, 0);
      if (v3)
        CFRelease(v3);
    }
    v8 = *((_QWORD *)this + 12);
    if (v8)
    {
      v9 = *((_QWORD *)this + 15);
      v10 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v8 + 16))(*((_QWORD *)this + 12));
      v11 = (void *)MEMORY[0x186DB8C8C](v10);
      (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 12) + 64))(*((_QWORD *)this + 12), v9);
      objc_autoreleasePoolPop(v11);
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
    }
  }
}

void FTPProtocol::_ftpReadStreamCB(FTPProtocol *this, __CFReadStream *a2, FTPProtocol *a3, void *a4)
{
  FTPProtocol::ftpReadStreamEvent(a3);
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_6876()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  *(_DWORD *)((char *)_PNAME<URLProtocol>::GET(void)::p + 7) = 1819239279;
  _PNAME<URLProtocol>::GET(void)::p[0] = *(_QWORD *)"URLProtocol>::GET() [OBJTYPE = URLProtocol]";
  CFClass::CFClass(v0, (const char *)_PNAME<URLProtocol>::GET(void)::p);
  TCFObject<URLProtocol>::Class(void)::clazz = (uint64_t)v0;
}

void sub_18406B844(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

BOOL DataProtocol::_canHandleRequest(DataProtocol *this, const _CFURLRequest *a2, const void *a3)
{
  const __CFURL *v3;
  const __CFString *v4;
  const __CFString *v5;
  _BOOL8 v6;
  int v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (!this)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      v8 = 136315138;
      v9 = "_canHandleRequest";
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "%s(): called with a NULL request", (uint8_t *)&v8, 0xCu);
    }
    return 0;
  }
  v3 = *(const __CFURL **)(-[DataProtocol _inner](this, "_inner", a3) + 8);
  if (!v3)
    return 0;
  v4 = CFURLCopyScheme(v3);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = CFStringCompare(v4, (CFStringRef)&qword_1EDD006B8[91], 1uLL) == kCFCompareEqualTo;
  CFRelease(v5);
  return v6;
}

CFTypeRef DataProtocol::_createCanonicalRequest(DataProtocol *this, CFTypeRef cf, const _CFURLRequest *a3, NSURLSessionTask *a4, const void *a5)
{
  if (cf)
    return CFRetain(cf);
  else
    return 0;
}

uint64_t DataProtocol::_requestsAreCacheEquivalent(DataProtocol *this, const _CFURLRequest *a2, const _CFURLRequest *a3, const void *a4)
{
  return 0;
}

_OWORD *DataProtocol::_instantiateProtocol(DataProtocol *this, NSURLSessionTask *a2, URLProtocolClient *a3, URLProtocolClient *a4, const void *a5)
{
  _OWORD *Instance;
  _OWORD *v8;

  if (TCFObject<URLProtocol>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLProtocol>::Class(void)::sOnce, &__block_literal_global_24_6881);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v8 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v8 = Instance + 1;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  *((_QWORD *)v8 + 13) = 0;
  *(_OWORD *)((char *)v8 + 88) = 0u;
  *(_OWORD *)((char *)v8 + 72) = 0u;
  *(_OWORD *)((char *)v8 + 56) = 0u;
  *(_OWORD *)((char *)v8 + 40) = 0u;
  *(_OWORD *)((char *)v8 + 24) = 0u;
  *(_QWORD *)v8 = &off_1E14E5858;
  *((_QWORD *)v8 + 1) = &unk_1E14E5958;
  *((_QWORD *)v8 + 2) = &unk_1E14E5978;
  URLProtocol::initialize((URLProtocol *)v8, a2, a3);
  return v8 - 1;
}

CFStringRef DataProtocol::copyDebugDesc(DataProtocol *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<data URL instance at %p>"), this);
}

void DataProtocol::_protocolInterface_startLoad(id *this, const _CFCachedURLResponse *a2)
{
  const void *v3;
  const __CFAllocator *v4;
  const __CFString *Value;
  const __CFString *v6;
  const __CFString *v7;
  CFIndex Length;
  CFAllocatorRef v9;
  __CFError *v10;
  __CFError *CFError;
  id v12;
  uint64_t v13;
  void *v14;
  CFDataRef v15;
  Throttler *v16;
  CFIndex v17;
  id v18;
  uint64_t v19;
  void *v20;
  const __CFAllocator *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __CFError *v27;
  const __CFAllocator *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  CFDataRef resourceData;
  SInt32 errorCode;
  CFDictionaryRef properties;

  v3 = (const void *)objc_msgSend(this[11], "cfURL");
  properties = 0;
  errorCode = 0;
  resourceData = 0;
  v4 = CFGetAllocator(this - 2);
  if (CFURLCreateDataAndPropertiesFromResource(v4, (CFURLRef)v3, &resourceData, &properties, 0, &errorCode))
  {
    Value = (const __CFString *)CFDictionaryGetValue(properties, CFSTR("kCFDataURLMimeType"));
    if (Value)
      v6 = Value;
    else
      v6 = CFSTR("text/plain");
    v7 = (const __CFString *)CFDictionaryGetValue(properties, CFSTR("kCFDataURLTextEncodingName"));
    Length = CFDataGetLength(resourceData);
    v9 = CFGetAllocator(this - 2);
    v10 = (__CFError *)CFURLResponseCreate((uint64_t)v9, v3, v6, Length, v7, 2);
    if (v10)
    {
      CFError = v10;
      v12 = this[12];
      if (v12)
      {
        v13 = (*(uint64_t (**)(id))(*(_QWORD *)v12 + 16))(this[12]);
        v14 = (void *)MEMORY[0x186DB8C8C](v13);
        (*(void (**)(id, __CFError *))(*(_QWORD *)this[12] + 64))(this[12], CFError);
        objc_autoreleasePoolPop(v14);
        (*(void (**)(id))(*(_QWORD *)v12 + 24))(v12);
      }
      v15 = resourceData;
      if (resourceData)
      {
        v16 = (Throttler *)this[8];
        if (v16)
        {
          v17 = CFDataGetLength(resourceData);
          Throttler::noteOutstandingBytes(v16, v17);
        }
      }
      v18 = this[12];
      if (v18)
      {
        v19 = (*(uint64_t (**)(id))(*(_QWORD *)v18 + 16))(this[12]);
        v20 = (void *)MEMORY[0x186DB8C8C](v19);
        (*(void (**)(id, CFDataRef, CFIndex))(*(_QWORD *)this[12] + 72))(this[12], v15, Length);
        objc_autoreleasePoolPop(v20);
        (*(void (**)(id))(*(_QWORD *)v18 + 24))(v18);
      }
      URLProtocol::sendDidFinishLoading((URLProtocol *)this);
    }
    else
    {
      v28 = CFGetAllocator(this - 2);
      CFError = __cfnCreateCFError(v28, CFSTR("kCFErrorDomainCFNetwork"), -998, v29, v30, v31, v32, v33, 0);
      URLProtocol::sendDidFail((URLProtocol *)this, CFError);
      if (!CFError)
        goto LABEL_18;
    }
    CFRelease(CFError);
LABEL_18:
    CFRelease(properties);
    v27 = resourceData;
    if (!resourceData)
      return;
    goto LABEL_19;
  }
  v21 = CFGetAllocator(this - 2);
  v27 = __cfnCreateCFError(v21, CFSTR("kCFErrorDomainCFNetwork"), errorCode, v22, v23, v24, v25, v26, 0);
  URLProtocol::sendDidFail((URLProtocol *)this, v27);
  if (v27)
LABEL_19:
    CFRelease(v27);
}

void `non-virtual thunk to'DataProtocol::~DataProtocol(DataProtocol *this)
{
  URLProtocol::~URLProtocol((URLProtocol *)((char *)this - 8));
}

{
  URLProtocol::~URLProtocol((URLProtocol *)((char *)this - 8));
}

{
  URLProtocol::~URLProtocol((URLProtocol *)((char *)this - 16));
}

{
  URLProtocol::~URLProtocol((URLProtocol *)((char *)this - 16));
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_6890()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  *(_DWORD *)((char *)_PNAME<URLProtocol>::GET(void)::p + 7) = 1819239279;
  _PNAME<URLProtocol>::GET(void)::p[0] = *(_QWORD *)"URLProtocol>::GET() [OBJTYPE = URLProtocol]";
  CFClass::CFClass(v0, (const char *)_PNAME<URLProtocol>::GET(void)::p);
  TCFObject<URLProtocol>::Class(void)::clazz = (uint64_t)v0;
}

void sub_18406BD54(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

BOOL FileURLProtocol::_canHandleRequest(FileURLProtocol *this, const _CFURLRequest *a2, const void *a3)
{
  const __CFURL *v3;
  const __CFString *v4;
  const __CFString *v5;
  _BOOL8 v6;
  int v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (!this)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      v8 = 136315138;
      v9 = "_canHandleRequest";
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "%s(): called with a NULL request", (uint8_t *)&v8, 0xCu);
    }
    return 0;
  }
  v3 = *(const __CFURL **)(-[FileURLProtocol _inner](this, "_inner", a3) + 8);
  if (!v3)
    return 0;
  v4 = CFURLCopyScheme(v3);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = CFStringCompare(v4, CFSTR("file"), 1uLL) == kCFCompareEqualTo;
  CFRelease(v5);
  return v6;
}

CFTypeRef FileURLProtocol::_createCanonicalRequest(FileURLProtocol *this, const __CFAllocator *a2, const _CFURLRequest *a3, NSURLSessionTask *a4, const void *a5)
{
  const __CFURL *v6;
  const __CFURL *v7;
  const __CFURL *v8;
  void *v9;
  void *v10;
  unsigned __int8 v12;

  v6 = *(const __CFURL **)(-[__CFAllocator _inner](a2, "_inner", a3, a4, a5) + 8);
  v12 = 0;
  v7 = _createCanonicalURL(v6, 0, 0, &v12);
  if (v7)
  {
    v8 = v7;
    if (v7 != v6)
    {
      v9 = (void *)-[__CFAllocator mutableCopy](a2, "mutableCopy");
      if (v9)
      {
        v10 = v9;
        CFURLRequestSetURL(v9, v8);
        CFRelease(v8);
        return v10;
      }
    }
    CFRelease(v8);
  }
  if (a2)
    return CFRetain(a2);
  return 0;
}

uint64_t FileURLProtocol::_requestsAreCacheEquivalent(FileURLProtocol *this, const _CFURLRequest *a2, const _CFURLRequest *a3, const void *a4)
{
  return 0;
}

uint64_t FileURLProtocol::_instantiateProtocol(FileURLProtocol *this, NSURLSessionTask *a2, URLProtocolClient *a3, URLProtocolClient *a4, const void *a5)
{
  uint64_t Instance;
  uint64_t v8;

  if (TCFObject<URLProtocol>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLProtocol>::Class(void)::sOnce, &__block_literal_global_23);
  Instance = _CFRuntimeCreateInstance();
  v8 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    v8 = Instance + 16;
    *(_QWORD *)(Instance + 160) = 0;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }
  *(_OWORD *)(v8 + 136) = 0u;
  *(_OWORD *)(v8 + 120) = 0u;
  *(_OWORD *)(v8 + 104) = 0u;
  *(_OWORD *)(v8 + 88) = 0u;
  *(_OWORD *)(v8 + 72) = 0u;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 40) = 0u;
  *(_OWORD *)(v8 + 24) = 0u;
  *(_QWORD *)v8 = &off_1E14E75C8;
  *(_QWORD *)(v8 + 8) = &unk_1E14E76C8;
  *(_QWORD *)(v8 + 16) = &unk_1E14E76E8;
  URLProtocol::initialize((URLProtocol *)v8, a2, a3);
  return v8 - 16;
}

CFStringRef FileURLProtocol::copyDebugDesc(FileURLProtocol *this)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<File protocol instance %p>"), this);
}

void FileURLProtocol::_protocolInterface_startLoad(FileURLProtocol *this, const _CFCachedURLResponse *a2)
{
  __darwin_ino64_t v2;
  const __CFURL *v3;
  off_t st_size;
  const __CFURL *v5;
  const __CFString *v6;
  const __CFString *v7;
  const __CFString *v8;
  const __CFAllocator *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __CFError *CFError;
  CFAllocatorRef v16;
  uint64_t v17;
  int v18;
  int *v19;
  CFIndex v20;
  const __CFAllocator *v21;
  __CFReadStream *v22;
  __CFError *v23;
  __CFError *v24;
  const __CFString *Domain;
  CFIndex Code;
  CFIndex v27;
  const __CFAllocator *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const __CFNumber *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  ssize_t v39;
  const __CFAllocator *v40;
  const __CFData *v41;
  const __CFData *v42;
  Throttler *v43;
  CFIndex Length;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  const __CFAllocator *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  __CFError *v54;
  int v55;
  const __CFAllocator *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int valuePtr;
  char v63;
  char v64[1035];
  stat propertyValueTypeRefPtr;
  uint64_t v66;

  v2 = MEMORY[0x1E0C80A78](this);
  v66 = *MEMORY[0x1E0C80C00];
  v3 = (const __CFURL *)objc_msgSend(*(id *)(v2 + 88), "cfURL");
  FilePathStorage<unsigned char>::FilePathStorage((uint64_t)&v63, v3, 0, 0, 0);
  *(_QWORD *)(v2 + 144) = _CFURLRequestCopyProtocolPropertyForKey(*(void **)(v2 + 88), CFSTR("NSURLRequestFileProtocolExpectedDevice"));
  if (!v63
    || stat(v64, &propertyValueTypeRefPtr)
    || (st_size = propertyValueTypeRefPtr.st_size, propertyValueTypeRefPtr.st_size == -1))
  {
    v9 = CFGetAllocator((CFTypeRef)(v2 - 16));
    CFError = __cfnCreateCFError(v9, CFSTR("kCFErrorDomainCFNetwork"), -1100, v10, v11, v12, v13, v14, 0);
    URLProtocol::sendDidFail((URLProtocol *)v2, CFError);
    if (!CFError)
      return;
    goto LABEL_10;
  }
  v5 = (const __CFURL *)-[__CFURL URLByResolvingSymlinksInPath](v3, "URLByResolvingSymlinksInPath");
  *(_QWORD *)&propertyValueTypeRefPtr.st_dev = 0;
  if (!CFURLCopyResourcePropertyForKey(v5, (CFStringRef)*MEMORY[0x1E0C9B5E0], &propertyValueTypeRefPtr, 0)
    || !*(_QWORD *)&propertyValueTypeRefPtr.st_dev
    || (v6 = UTTypeCopyPreferredTagWithClass(*(CFStringRef *)&propertyValueTypeRefPtr.st_dev, (CFStringRef)*MEMORY[0x1E0CA5A90]), CFRelease(*(CFTypeRef *)&propertyValueTypeRefPtr.st_dev), !v6))
  {
    v7 = _CFURLCopyPathExtension_WorksWithMoreSchemes(v5);
    v8 = v7;
    if (v7)
    {
      v6 = copyMIMETypeForExtension(v7);
      CFRelease(v8);
    }
    else
    {
      v6 = 0;
    }
  }
  v16 = CFGetAllocator((CFTypeRef)(v2 - 16));
  if (st_size)
    v17 = st_size;
  else
    v17 = -1;
  *(_QWORD *)(v2 + 120) = CFURLResponseCreate((uint64_t)v16, v3, v6, v17, 0, 2);
  if (v6)
    CFRelease(v6);
  if (st_size < 0x4000 && st_size)
  {
    if (!v63)
      goto LABEL_58;
    v18 = open(v64, 0);
    if ((v18 & 0x80000000) == 0 || (v19 = __error(), v18 != -1))
    {
      if (!*(_QWORD *)(v2 + 144)
        || !fstat(v18, &propertyValueTypeRefPtr)
        && (valuePtr = 0, (v34 = *(const __CFNumber **)(v2 + 144)) != 0)
        && CFNumberGetValue(v34, kCFNumberIntType, &valuePtr)
        && valuePtr == propertyValueTypeRefPtr.st_dev)
      {
        if ((*(_BYTE *)(v2 + 112) & 2) == 0)
        {
          *(_BYTE *)(v2 + 112) |= 2u;
          v35 = *(_QWORD *)(v2 + 96);
          if (v35)
          {
            v36 = *(_QWORD *)(v2 + 120);
            v37 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v35 + 16))(*(_QWORD *)(v2 + 96));
            v38 = (void *)MEMORY[0x186DB8C8C](v37);
            (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 96) + 64))(*(_QWORD *)(v2 + 96), v36);
            objc_autoreleasePoolPop(v38);
            (*(void (**)(uint64_t))(*(_QWORD *)v35 + 24))(v35);
          }
        }
        v39 = read(v18, &propertyValueTypeRefPtr, 0x4000uLL);
        if (v39 == -1)
        {
          v55 = *__error();
          switch(v55)
          {
            case 2:
              v20 = -1100;
              break;
            case 13:
              v20 = -1102;
              break;
            case 21:
              v20 = -1101;
              break;
            default:
              v20 = v55;
              break;
          }
        }
        else
        {
          v40 = CFGetAllocator((CFTypeRef)(v2 - 16));
          v41 = CFDataCreate(v40, (const UInt8 *)&propertyValueTypeRefPtr, v39);
          v42 = v41;
          if (v41)
          {
            v43 = *(Throttler **)(v2 + 64);
            if (v43)
            {
              Length = CFDataGetLength(v41);
              Throttler::noteOutstandingBytes(v43, Length);
            }
          }
          v45 = *(_QWORD *)(v2 + 96);
          if (v45)
          {
            v46 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v45 + 16))(*(_QWORD *)(v2 + 96));
            v47 = (void *)MEMORY[0x186DB8C8C](v46);
            (*(void (**)(_QWORD, const __CFData *, ssize_t))(**(_QWORD **)(v2 + 96) + 72))(*(_QWORD *)(v2 + 96), v42, v39);
            objc_autoreleasePoolPop(v47);
            (*(void (**)(uint64_t))(*(_QWORD *)v45 + 24))(v45);
          }
          if (v42)
            CFRelease(v42);
          URLProtocol::sendDidFinishLoading((URLProtocol *)v2);
          v20 = 0;
        }
      }
      else
      {
        v20 = -1104;
      }
      close(v18);
LABEL_52:
      if (!v20)
        return;
      goto LABEL_59;
    }
    v20 = *v19;
    switch((_DWORD)v20)
    {
      case 2:
LABEL_58:
        v20 = -1100;
        break;
      case 0xD:
        v20 = -1102;
        break;
      case 0x15:
        v20 = -1101;
        break;
      default:
        goto LABEL_52;
    }
LABEL_59:
    v48 = CFGetAllocator((CFTypeRef)(v2 - 16));
    v54 = __cfnCreateCFError(v48, CFSTR("kCFErrorDomainCFNetwork"), v20, v49, v50, v51, v52, v53, 0);
    URLProtocol::sendDidFail((URLProtocol *)v2, v54);
    if (v54)
      CFRelease(v54);
    return;
  }
  *(_QWORD *)(v2 + 136) = 0;
  v21 = CFGetAllocator((CFTypeRef)(v2 - 16));
  v22 = CFReadStreamCreateWithFile(v21, v3);
  *(_QWORD *)(v2 + 128) = v22;
  if (!v22)
  {
    v28 = CFGetAllocator((CFTypeRef)(v2 - 16));
    CFError = __cfnCreateCFError(v28, CFSTR("kCFErrorDomainCFNetwork"), -998, v29, v30, v31, v32, v33, 0);
    URLProtocol::sendDidFail((URLProtocol *)v2, CFError);
    if (!CFError)
      return;
LABEL_10:
    CFRelease(CFError);
    return;
  }
  *(_QWORD *)&propertyValueTypeRefPtr.st_dev = 0;
  propertyValueTypeRefPtr.st_ino = v2;
  memset(&propertyValueTypeRefPtr.st_uid, 0, 24);
  CFReadStreamSetClient(v22, 0x1BuLL, (CFReadStreamClientCallBack)FileURLProtocol::_fileReadStreamCB, (CFStreamClientContext *)&propertyValueTypeRefPtr);
  CoreSchedulingSet::scheduleStream(*(CoreSchedulingSet **)(v2 + 24), *(__CFReadStream **)(v2 + 128));
  if (!CFReadStreamOpen(*(CFReadStreamRef *)(v2 + 128)))
  {
    v23 = CFReadStreamCopyError(*(CFReadStreamRef *)(v2 + 128));
    v24 = v23;
    if (!v23)
    {
      URLProtocol::sendDidFail((URLProtocol *)v2, 0);
      return;
    }
    Domain = CFErrorGetDomain(v23);
    if (CFStringCompare((CFStringRef)*MEMORY[0x1E0C9AFD0], Domain, 0)
      || ((Code = CFErrorGetCode(v24), (_DWORD)Code == 2)
        ? (v27 = -1100)
        : (_DWORD)Code == 13
        ? (v27 = -1102)
        : (_DWORD)Code != 21
        ? (v27 = (int)Code)
        : (v27 = -1101),
          Code == v27))
    {
      URLProtocol::sendDidFail((URLProtocol *)v2, v24);
    }
    else
    {
      CFRelease(v24);
      v56 = CFGetAllocator((CFTypeRef)(v2 - 16));
      v24 = __cfnCreateCFError(v56, CFSTR("kCFErrorDomainCFNetwork"), v27, v57, v58, v59, v60, v61, 0);
      URLProtocol::sendDidFail((URLProtocol *)v2, v24);
      if (!v24)
        return;
    }
    CFRelease(v24);
  }
}

void FileURLProtocol::_protocolInterface_cancelLoad(FileURLProtocol *this)
{
  if ((*((_BYTE *)this + 112) & 4) == 0)
  {
    *((_BYTE *)this + 112) |= 4u;
    if (*((_QWORD *)this + 16))
      FileURLProtocol::destroyReadStream(this);
  }
}

uint64_t FileURLProtocol::_protocolInterface_haltLoad(uint64_t this)
{
  *(_BYTE *)(this + 112) |= 1u;
  return this;
}

void FileURLProtocol::_protocolInterface_resumeLoad(FileURLProtocol *this)
{
  *((_BYTE *)this + 112) &= ~1u;
  if (*((_QWORD *)this + 16))
  {
    if (*((_QWORD *)this + 17))
    {
      FileURLProtocol::fileStreamEvent(this);
      *((_QWORD *)this + 17) = 0;
    }
  }
}

void FileURLProtocol::subclassUpdateScheduling(FileURLProtocol *this, CoreSchedulingSet *a2, CoreSchedulingSet *a3)
{
  __CFReadStream *v4;

  if ((*((_BYTE *)this + 112) & 1) != 0)
  {
    v4 = (__CFReadStream *)*((_QWORD *)this + 16);
    if (v4)
    {
      CoreSchedulingSet::unscheduleStream(a2, v4);
      CoreSchedulingSet::scheduleStream(a3, *((__CFReadStream **)this + 16));
    }
  }
}

uint64_t FileURLProtocol::needsThrottler(FileURLProtocol *this)
{
  return 1;
}

void `non-virtual thunk to'FileURLProtocol::~FileURLProtocol(FileURLProtocol *this)
{
  FileURLProtocol::~FileURLProtocol((FileURLProtocol *)((char *)this - 8));
}

{
  FileURLProtocol::~FileURLProtocol((FileURLProtocol *)((char *)this - 8));
}

{
  FileURLProtocol::~FileURLProtocol((FileURLProtocol *)((char *)this - 16));
}

{
  FileURLProtocol::~FileURLProtocol((FileURLProtocol *)((char *)this - 16));
}

void FileURLProtocol::~FileURLProtocol(FileURLProtocol *this)
{
  const void *v2;
  const void *v3;

  *(_QWORD *)this = &off_1E14E75C8;
  *((_QWORD *)this + 1) = &unk_1E14E76C8;
  *((_QWORD *)this + 2) = &unk_1E14E76E8;
  v2 = (const void *)*((_QWORD *)this + 15);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 18);
  if (v3)
    CFRelease(v3);
  FileURLProtocol::destroyReadStream(this);
  URLProtocol::~URLProtocol((URLProtocol *)this);
}

void sub_18406C744(_Unwind_Exception *a1)
{
  URLProtocol *v1;

  URLProtocol::~URLProtocol(v1);
  _Unwind_Resume(a1);
}

void FileURLProtocol::destroyReadStream(FileURLProtocol *this)
{
  __CFReadStream *v1;
  NSObject *v2;

  v1 = (__CFReadStream *)*((_QWORD *)this + 16);
  if (v1)
  {
    *((_QWORD *)this + 16) = 0;
    v2 = MEMORY[0x186DB6220](v1);
    MEMORY[0x186DB62D4](v1, 0);
    CFReadStreamSetClient(v1, 0, 0, 0);
    CFReadStreamClose(v1);
    if (v2)
    {
      dispatch_async_f(v2, v1, (dispatch_function_t)_release_ReadStream);
      dispatch_release(v2);
    }
    else
    {
      CFRelease(v1);
    }
  }
}

void FileURLProtocol::fileStreamEvent(FileURLProtocol *this)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  const __CFAllocator *v11;
  const __CFData *v12;
  __CFError *CFErrorWithStreamError;
  Throttler *v14;
  CFIndex Length;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  const __CFData *v23;
  const __CFData *v24;
  int *BytePtr;
  const __CFAllocator *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __CFError *CFError;
  CFStreamError Error;
  const __CFAllocator *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  const __CFNumber *v39;
  BOOL v40;
  int valuePtr;
  stat buffer[455];
  uint64_t v43;

  v1 = MEMORY[0x1E0C80A78](this);
  v3 = v2;
  v4 = v1;
  v43 = *MEMORY[0x1E0C80C00];
  if ((v2 > 0x10 || ((1 << v2) & 0x10106) == 0) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(buffer[0].st_dev) = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "fileReadStreamCB(): unrecognized event", (uint8_t *)buffer, 2u);
  }
  v5 = *(_BYTE *)(v4 + 112);
  if ((v5 & 1) != 0)
  {
    *(_QWORD *)(v4 + 136) = v3;
  }
  else if (v3 > 7)
  {
    if (v3 == 8)
    {
      Error = CFReadStreamGetError((CFReadStreamRef)*(_QWORD *)(v4 + 128));
      *(_QWORD *)&buffer[0].st_dev = Error.domain;
      buffer[0].st_ino = *(_QWORD *)&Error.error;
      v34 = CFGetAllocator((CFTypeRef)(v4 - 16));
      CFErrorWithStreamError = __cfnCreateCFErrorWithStreamError(v34, &buffer[0].st_dev);
      URLProtocol::sendDidFail((URLProtocol *)v4, CFErrorWithStreamError);
      if (CFErrorWithStreamError)
LABEL_17:
        CFRelease(CFErrorWithStreamError);
    }
    else if (v3 == 16)
    {
      if ((*(_BYTE *)(v4 + 112) & 2) == 0)
      {
        *(_BYTE *)(v4 + 112) = v5 | 2;
        v19 = *(_QWORD *)(v4 + 96);
        if (v19)
        {
          v20 = *(_QWORD *)(v4 + 120);
          v21 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v19 + 16))(*(_QWORD *)(v4 + 96));
          v22 = (void *)MEMORY[0x186DB8C8C](v21);
          (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 96) + 64))(*(_QWORD *)(v4 + 96), v20);
          objc_autoreleasePoolPop(v22);
          (*(void (**)(uint64_t))(*(_QWORD *)v19 + 24))(v19);
        }
      }
      URLProtocol::sendDidFinishLoading((URLProtocol *)v4);
    }
  }
  else if (v3 == 1)
  {
    if (*(_QWORD *)(v4 + 144))
    {
      v23 = (const __CFData *)CFReadStreamCopyProperty(*(CFReadStreamRef *)(v4 + 128), (CFStreamPropertyKey)*MEMORY[0x1E0C9AB40]);
      v24 = v23;
      if (v23)
      {
        BytePtr = (int *)CFDataGetBytePtr(v23);
        if (!fstat(*BytePtr, buffer)
          && (valuePtr = 0, (v39 = *(const __CFNumber **)(v4 + 144)) != 0)
          && CFNumberGetValue(v39, kCFNumberIntType, &valuePtr))
        {
          v40 = valuePtr == buffer[0].st_dev;
          CFRelease(v24);
          if (v40)
          {
            FileURLProtocol::checkAndSendDidReceiveResponse(v4);
            return;
          }
        }
        else
        {
          CFRelease(v24);
        }
      }
      FileURLProtocol::destroyReadStream((FileURLProtocol *)v4);
      v26 = CFGetAllocator((CFTypeRef)(v4 - 16));
      CFError = __cfnCreateCFError(v26, CFSTR("kCFErrorDomainCFNetwork"), -1104, v27, v28, v29, v30, v31, 0);
      URLProtocol::sendDidFail((URLProtocol *)v4, CFError);
      if (CFError)
        CFRelease(CFError);
    }
    else if ((*(_BYTE *)(v4 + 112) & 2) == 0)
    {
      *(_BYTE *)(v4 + 112) = v5 | 2;
      v35 = *(_QWORD *)(v4 + 96);
      if (v35)
      {
        v36 = *(_QWORD *)(v4 + 120);
        v37 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v35 + 16))(*(_QWORD *)(v4 + 96));
        v38 = (void *)MEMORY[0x186DB8C8C](v37);
        (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 96) + 64))(*(_QWORD *)(v4 + 96), v36);
        objc_autoreleasePoolPop(v38);
        (*(void (**)(uint64_t))(*(_QWORD *)v35 + 24))(v35);
      }
    }
  }
  else if (v3 == 2)
  {
    if ((*(_BYTE *)(v4 + 112) & 2) == 0)
    {
      *(_BYTE *)(v4 + 112) = v5 | 2;
      v6 = *(_QWORD *)(v4 + 96);
      if (v6)
      {
        v7 = *(_QWORD *)(v4 + 120);
        v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v6 + 16))(*(_QWORD *)(v4 + 96));
        v9 = (void *)MEMORY[0x186DB8C8C](v8);
        (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 96) + 64))(*(_QWORD *)(v4 + 96), v7);
        objc_autoreleasePoolPop(v9);
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
      }
    }
    v10 = CFReadStreamRead(*(CFReadStreamRef *)(v4 + 128), (UInt8 *)buffer, 0x10000);
    if (v10 >= 1)
    {
      v11 = CFGetAllocator((CFTypeRef)(v4 - 16));
      v12 = CFDataCreate(v11, (const UInt8 *)buffer, v10);
      CFErrorWithStreamError = v12;
      if (v12)
      {
        v14 = *(Throttler **)(v4 + 64);
        if (v14)
        {
          Length = CFDataGetLength(v12);
          Throttler::noteOutstandingBytes(v14, Length);
        }
      }
      v16 = *(_QWORD *)(v4 + 96);
      if (v16)
      {
        v17 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v16 + 16))(*(_QWORD *)(v4 + 96));
        v18 = (void *)MEMORY[0x186DB8C8C](v17);
        (*(void (**)(_QWORD, __CFError *, uint64_t))(**(_QWORD **)(v4 + 96) + 72))(*(_QWORD *)(v4 + 96), CFErrorWithStreamError, v10);
        objc_autoreleasePoolPop(v18);
        (*(void (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
      }
      if (CFErrorWithStreamError)
        goto LABEL_17;
    }
  }
}

uint64_t FileURLProtocol::checkAndSendDidReceiveResponse(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  if ((*(_BYTE *)(this + 112) & 2) == 0)
  {
    v1 = this;
    *(_BYTE *)(this + 112) |= 2u;
    v2 = *(_QWORD *)(this + 96);
    if (v2)
    {
      v3 = *(_QWORD *)(this + 120);
      v4 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v2 + 16))(*(_QWORD *)(this + 96));
      v5 = (void *)MEMORY[0x186DB8C8C](v4);
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v1 + 96) + 64))(*(_QWORD *)(v1 + 96), v3);
      objc_autoreleasePoolPop(v5);
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
    }
  }
  return this;
}

void FileURLProtocol::_fileReadStreamCB(FileURLProtocol *this, __CFReadStream *a2, FileURLProtocol *a3, void *a4)
{
  FileURLProtocol::fileStreamEvent(a3);
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_6901()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  *(_DWORD *)((char *)_PNAME<URLProtocol>::GET(void)::p + 7) = 1819239279;
  _PNAME<URLProtocol>::GET(void)::p[0] = *(_QWORD *)"URLProtocol>::GET() [OBJTYPE = URLProtocol]";
  CFClass::CFClass(v0, (const char *)_PNAME<URLProtocol>::GET(void)::p);
  TCFObject<URLProtocol>::Class(void)::clazz = (uint64_t)v0;
}

void sub_18406CCE0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void sub_18406CE24(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_18406D06C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_18406D194(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_18406D618(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_18406DA08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_18406DC9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void sub_18406DD88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_18406DE10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_18406DEB4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_18406E13C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

CFStringRef HTTPProtocol::copyDebugDesc(HTTPProtocol *this)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<HTTP protocol instance %p>"), this);
}

CFTypeRef HTTPProtocol::copyDebugSummary(HTTPProtocol *this)
{
  void *v1;
  uint64_t v2;

  v1 = (void *)*((_QWORD *)this + 11);
  if (!v1)
    return CFRetain(CFSTR("nullptr request"));
  v2 = objc_msgSend(v1, "_inner");
  return (CFTypeRef)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
}

uint64_t HTTPProtocol::initialize(HTTPProtocol *this, NSURLSessionTask *a2, URLProtocolClient *a3)
{
  return (*(uint64_t (**)(HTTPProtocol *, NSURLSessionTask *, URLProtocolClient *, _QWORD))(*(_QWORD *)this + 240))(this, a2, a3, 0);
}

void HTTPProtocol::_protocolInterface_setIsDownload(HTTPProtocol *this, int a2)
{
  const void *v4;
  const __CFDictionary *v5;
  const __CFDictionary *v6;
  char v7;
  char *v8;
  int v9;
  __int16 v10;
  _QWORD *v11;
  uint64_t v12;

  if (!*((_QWORD *)this + 34))
    return;
  if (!*((_QWORD *)this + 10) || (v4 = (const void *)*((_QWORD *)this + 94)) == 0)
  {
    v6 = 0;
    goto LABEL_11;
  }
  v5 = (const __CFDictionary *)CFRetain(v4);
  v6 = v5;
  if (!v5)
  {
LABEL_11:
    v7 = 1;
    goto LABEL_12;
  }
  if (CFDictionaryGetCount(v5)
    && (CFDictionaryContainsKey(v6, &unk_1EDCFA918)
     || CFDictionaryContainsKey(v6, &unk_1EDCFA950)
     || CFDictionaryContainsKey(v6, CFSTR("_kCFStreamPropertyLargeDownload"))))
  {
LABEL_18:
    CFRelease(v6);
    return;
  }
  v7 = 0;
LABEL_12:
  v9 = *((_DWORD *)this + 48);
  v8 = (char *)this + 192;
  v10 = *((_WORD *)v8 + 2);
  *(_DWORD *)v8 = v9 & 0xFFFDFFFF | ((a2 != 0) << 17);
  *((_WORD *)v8 + 2) = v10;
  v11 = (_QWORD *)MEMORY[0x1E0C9AE50];
  if (!a2)
    v11 = (_QWORD *)MEMORY[0x1E0C9AE40];
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)v8 + 10) + 40))(*((_QWORD *)v8 + 10), 16, *v11);
  v12 = *((_QWORD *)v8 + 10);
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 128))(v12);
  if ((v7 & 1) == 0)
    goto LABEL_18;
}

uint64_t HTTPProtocol::expectedProgressTargetChanged(HTTPProtocol *this)
{
  uint64_t v2;
  uint64_t result;

  v2 = *((_QWORD *)this + 34);
  if (v2)
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, 7, *MEMORY[0x1E0C9AE50]);
  result = *((_QWORD *)this + 111);
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)result + 56))(result, 0x1EDCF9878, *MEMORY[0x1E0C9AE50]);
  return result;
}

void HTTPProtocol::generateProxyAuthentication(std::__shared_weak_count_vtbl *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  const void *(__cdecl *get_deleter)(const std::__shared_weak_count *__hidden, const std::type_info *);
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  _QWORD v37[6];
  std::__shared_weak_count *v38;
  uint64_t v39;
  std::__shared_weak_count *v40;
  std::__shared_weak_count_vtbl *v41;
  std::__shared_weak_count *v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  std::__shared_weak_count_vtbl *v45;
  std::__shared_weak_count *v46;

  if (a1)
    CFRetain(&a1[-1].__get_deleter);
  v45 = a1;
  v8 = (std::__shared_weak_count *)operator new();
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F10F0;
  v8->__shared_weak_owners_ = 0;
  v8[1].__vftable = a1;
  v46 = v8;
  get_deleter = a1->__get_deleter;
  v37[0] = MEMORY[0x1E0C809B0];
  v37[1] = 3321888768;
  v37[2] = ___ZN12HTTPProtocol27generateProxyAuthenticationENSt3__110shared_ptrI12NetworkProxyEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJNS1_I19AuthenticationStateEEEE_block_invoke;
  v37[3] = &__block_descriptor_104_e8_40c41_ZTSKNSt3__110shared_ptrI12NetworkProxyEE56c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE72c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE88c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE_e5_v8__0l;
  v12 = *a2;
  v11 = (std::__shared_weak_count *)a2[1];
  v37[4] = a1;
  v37[5] = v12;
  v38 = v11;
  if (v11)
  {
    v13 = (unint64_t *)&v11->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  v15 = (std::__shared_weak_count *)a4[1];
  v39 = *a4;
  v40 = v15;
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  v41 = a1;
  v42 = v8;
  do
    v18 = __ldxr(p_shared_owners);
  while (__stxr(v18 + 1, p_shared_owners));
  v19 = (std::__shared_weak_count *)a3[1];
  v43 = *a3;
  v44 = v19;
  if (v19)
  {
    v20 = (unint64_t *)&v19->__shared_owners_;
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  (*(void (**)(const void *(__cdecl *)(const std::__shared_weak_count *__hidden, const std::type_info *), _QWORD *))(*(_QWORD *)get_deleter + 96))(get_deleter, v37);
  v22 = v44;
  if (v44)
  {
    v23 = (unint64_t *)&v44->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = v42;
  if (v42)
  {
    v26 = (unint64_t *)&v42->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  v28 = v40;
  if (v40)
  {
    v29 = (unint64_t *)&v40->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v31 = v38;
  if (v38)
  {
    v32 = (unint64_t *)&v38->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = v46;
  if (v46)
  {
    v35 = (unint64_t *)&v46->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
}

void sub_18406E604(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v4);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 64);
  _Unwind_Resume(a1);
}

void HTTPProtocol::resetAuthState(HTTPProtocol *this)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  uint64_t v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  _QWORD v12[5];
  std::__shared_weak_count *v13;
  HTTPProtocol *v14;
  std::__shared_weak_count *v15;

  if (this)
    CFRetain((char *)this - 16);
  v14 = this;
  v2 = (std::__shared_weak_count *)operator new();
  v2->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F10F0;
  v2->__shared_weak_owners_ = 0;
  v2[1].__vftable = (std::__shared_weak_count_vtbl *)this;
  v15 = v2;
  v12[4] = this;
  v13 = v2;
  v2->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  v4 = *((_QWORD *)this + 3);
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 3321888768;
  v12[2] = ___ZN12HTTPProtocol14resetAuthStateEv_block_invoke;
  v12[3] = &__block_descriptor_48_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e5_v8__0l;
  do
    v5 = __ldxr(p_shared_owners);
  while (__stxr(v5 + 1, p_shared_owners));
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 96))(v4, v12);
  v6 = v13;
  if (v13)
  {
    v7 = (unint64_t *)&v13->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  v9 = v15;
  if (v15)
  {
    v10 = (unint64_t *)&v15->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void sub_18406E76C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32);
  _Unwind_Resume(a1);
}

uint64_t HTTPProtocol::clientDescription(HTTPProtocol *this)
{
  return *((_QWORD *)this + 99);
}

CFTypeRef HTTPProtocol::ceRetain(HTTPProtocol *this)
{
  return CFRetain((char *)this - 16);
}

void HTTPProtocol::ceRelease(HTTPProtocol *this)
{
  CFRelease((char *)this - 16);
}

uint64_t HTTPProtocol::ssPreConnectConfiguration(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD v8[7];

  CFRetain((CFTypeRef)(a1 - 16));
  nw_retain(a2);
  v6 = *(_QWORD *)(a1 + 24);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN12HTTPProtocol25ssPreConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvvE_block_invoke;
  v8[3] = &unk_1E14FDBE0;
  v8[5] = a3;
  v8[6] = a1;
  v8[4] = a2;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v8);
}

uint64_t HTTPProtocol::ssNeedServerTrust(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD v8[7];

  CFRetain((CFTypeRef)(a1 - 16));
  if (a2)
    CFRetain(a2);
  v6 = *(_QWORD *)(a1 + 24);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN12HTTPProtocol17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke;
  v8[3] = &unk_1E14FDB30;
  v8[5] = a1;
  v8[6] = a2;
  v8[4] = a3;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v8);
}

uint64_t HTTPProtocol::ssNeedClientCert(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD v8[7];

  CFRetain((CFTypeRef)(a1 - 16));
  if (a2)
    CFRetain(a2);
  v6 = *(_QWORD *)(a1 + 24);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN12HTTPProtocol16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke;
  v8[3] = &unk_1E14FDB30;
  v8[5] = a1;
  v8[6] = a2;
  v8[4] = a3;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v8);
}

uint64_t HTTPProtocol::ssPostConnectConfiguration(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD v8[7];

  CFRetain((CFTypeRef)(a1 - 16));
  nw_retain(a2);
  v6 = *(_QWORD *)(a1 + 24);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN12HTTPProtocol26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke;
  v8[3] = &unk_1E14FDBE0;
  v8[5] = a3;
  v8[6] = a1;
  v8[4] = a2;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v8);
}

void HTTPProtocol::ssPostHandshakesStreamsAvailable(HTTPProtocol *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  abort();
}

uint64_t HTTPProtocol::ssConnectionWaitingNotification(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 392))(a1);
}

uint64_t HTTPProtocol::preConnectConfiguration(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;

  v8 = (void *)a1[11];
  if (!v8)
  {
    v9 = 0;
    if (a2)
      goto LABEL_3;
LABEL_5:
    v10 = 0;
    goto LABEL_6;
  }
  v9 = *(_QWORD *)(objc_msgSend(v8, "_inner") + 8);
  if (!a2)
    goto LABEL_5;
LABEL_3:
  v10 = tcp_connection_id();
LABEL_6:
  (*(void (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(a1[14] + 128))(a1 + 14, v10, a2, a3, v9, a1[76]);
  return (*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
}

void HTTPProtocol::needClientCert(uint64_t a1, uint64_t a2, void (**a3)(_QWORD, _QWORD, _QWORD))
{
  void *v6;
  const __CFURL *v7;
  const __CFString *v8;
  SInt32 v9;
  int v10;
  uint64_t Challenge;
  _QWORD v12[5];

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 520))(a1) || (v6 = *(void **)(a1 + 88)) == 0)
  {
    a3[2](a3, 0, 1);
  }
  else
  {
    if (*(_QWORD *)(a1 + 408))
      __assert_rtn("needClientCert", "HTTPProtocol.cpp", 7157, "fClientCertChallenge == nullptr");
    if (*(_QWORD *)(a1 + 416))
      __assert_rtn("needClientCert", "HTTPProtocol.cpp", 7158, "fClientCertChallengeCompletion == nullptr");
    v7 = *(const __CFURL **)(objc_msgSend(v6, "_inner") + 8);
    v8 = CFURLCopyHostName(v7);
    v9 = CFURLGetPortNumber(v7);
    if (v9 == -1)
      v10 = 443;
    else
      v10 = v9;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = ___ZN22HTTPProtocolSSLSupport40CreateClientCertChallengeWithHostAndPortEPK10__CFStringlPK9__CFArray_block_invoke;
    v12[3] = &__block_descriptor_40_e32_v16__0___CFURLProtectionSpace__8l;
    v12[4] = a2;
    Challenge = createChallenge(7, v8, v10, (uint64_t)v12);
    if (v8)
      CFRelease(v8);
    *(_QWORD *)(a1 + 408) = Challenge;
    *(_QWORD *)(a1 + 416) = _Block_copy(a3);
    HTTPProtocol::sendDidReceiveAuthChallenge((HTTPProtocol *)a1, *(_CFURLAuthChallenge **)(a1 + 408));
  }
}

void HTTPProtocol::postConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFHTTPMessageRef v7;
  CFAllocatorRef v8;
  uint64_t v9;
  _QWORD v10[6];

  v7 = CFURLRequestCopyHTTPRequest(*(void **)(a1 + 88));
  v8 = CFGetAllocator((CFTypeRef)(a1 - 16));
  v9 = *(_QWORD *)(a1 + 280);
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = ___ZN12HTTPProtocol24postConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0_U13block_pointerFvvE_block_invoke;
  v10[3] = &unk_1E14FDC08;
  v10[4] = a4;
  v10[5] = a1;
  (*(void (**)(uint64_t, CFAllocatorRef, uint64_t, CFHTTPMessageRef, uint64_t, _QWORD *))(*(_QWORD *)(a1 + 112)
                                                                                                + 144))(a1 + 112, v8, a2, v7, v9, v10);
  if (v7)
    CFRelease(v7);
}

void HTTPProtocol::connectionEstablished(HTTPProtocol *this, CFStreamError a2)
{
  abort();
}

uint64_t HTTPProtocol::connectionWaitingNotification(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 408))(a1);
}

uint64_t HTTPProtocol::waitsForConnectivity(HTTPProtocol *this)
{
  void *v1;

  if (*((_QWORD *)this + 93) && (v1 = (void *)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration")) != 0)
    return objc_msgSend(v1, "waitsForConnectivity");
  else
    return 0;
}

uint64_t HTTPProtocol::handleConnectionWaitingNotification(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD v5[6];

  if (*(_BYTE *)(result + 43))
  {
    v3 = result;
    CFRetain((CFTypeRef)(result - 16));
    v4 = *(_QWORD *)(v3 + 24);
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = ___ZN12HTTPProtocol35handleConnectionWaitingNotificationE40tcp_connection_unmet_conditions_reason_t_block_invoke;
    v5[3] = &__block_descriptor_48_e5_v8__0l;
    v5[4] = v3;
    v5[5] = a2;
    return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 96))(v4, v5);
  }
  return result;
}

uint64_t HTTPProtocol::handleAlternatePathNotification(uint64_t result, int a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD v5[5];
  int v6;

  if (*(_BYTE *)(result + 45))
  {
    v3 = result;
    CFRetain((CFTypeRef)(result - 16));
    v4 = *(_QWORD *)(v3 + 24);
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = ___ZN12HTTPProtocol31handleAlternatePathNotificationE36nw_connection_alternate_path_state_t_block_invoke;
    v5[3] = &__block_descriptor_44_e5_v8__0l;
    v5[4] = v3;
    v6 = a2;
    return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 96))(v4, v5);
  }
  return result;
}

CFTypeRef HTTPProtocol::_meta_retain(HTTPProtocol *this)
{
  return CFRetain((char *)this - 16);
}

void HTTPProtocol::_meta_release(HTTPProtocol *this)
{
  CFRelease((char *)this - 16);
}

uint64_t HTTPProtocol::creds(HTTPProtocol *this)
{
  return *((_QWORD *)this + 44);
}

uint64_t HTTPProtocol::authFailureResponse(HTTPProtocol *this)
{
  return *((_QWORD *)this + 39);
}

uint64_t HTTPProtocol::trustRef(HTTPProtocol *this)
{
  return *((_QWORD *)this + 57);
}

uint64_t HTTPProtocol::hcc_getUseCredentialStorage(HTTPProtocol *this)
{
  return *((unsigned __int8 *)this + 40);
}

uint64_t HTTPProtocol::proxyAuthFailureResponse(HTTPProtocol *this)
{
  return *((_QWORD *)this + 42);
}

uint64_t HTTPProtocol::requiresConnectionBasedAuth(HTTPProtocol *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;

  v2 = *((_QWORD *)this + 35);
  if (v2 && ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 88))(v2) & 0xFFFFFFFE) == 2)
    v3 = 81;
  else
    v3 = 59;
  result = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 8 * v3))(this);
  if (result)
  {
    v5 = result;
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
    v6 = *(_QWORD *)(v5 + 40);
    if (v6)
    {
      if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
        dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
      return (*(_DWORD *)(v6 + 72) - 5) < 2;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL HTTPProtocol::isValidForTube(HTTPProtocol *this)
{
  return !(*(unsigned int (**)(HTTPProtocol *))(*(_QWORD *)this + 520))(this)
      && !*((_QWORD *)this + 34)
      && *((_QWORD *)this + 11) != 0;
}

void HTTPProtocol::hcc_touchProtocol(HTTPProtocol *this)
{
  *((CFAbsoluteTime *)this + 4) = CFAbsoluteTimeGetCurrent();
}

HTTPProtocol *HTTPProtocol::copyTaskLoggableDescription@<X0>(HTTPProtocol *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *((_QWORD *)this + 100);
  *a2 = *((_QWORD *)this + 99);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

uint64_t HTTPProtocol::getUserName(HTTPProtocol *this)
{
  const _CFURLCredential *v2;
  uint64_t v3;
  uint64_t v4;

  if (!*((_QWORD *)this + 44) && !(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this))
    return 0;
  if (*((_QWORD *)this + 74)
    || (*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 35) + 88))(*((_QWORD *)this + 35)) == 2
    || (*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 35) + 88))(*((_QWORD *)this + 35)) == 3)
  {
    v3 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this);
    if (!v3)
      return 0;
  }
  else
  {
    v3 = *((_QWORD *)this + 44);
    if (!v3)
      return 0;
  }
  v4 = URLCredential_PasswordBased::safelyCast(v3, v2);
  if (v4)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 112))(v4);
  return 0;
}

uint64_t HTTPProtocol::getUserPrincipal(HTTPProtocol *this)
{
  __CFHTTPMessage *v2;
  uint64_t v3;

  if (!*((_QWORD *)this + 44) && !(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this))
    return 0;
  v2 = (__CFHTTPMessage *)*((_QWORD *)this + 39);
  if (v2 && CFHTTPMessageGetResponseStatusCode(v2) == 407)
  {
    v3 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this);
    if (!v3)
      return 0;
  }
  else
  {
    v3 = *((_QWORD *)this + 44);
    if (!v3)
      return 0;
  }
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  if (*(_DWORD *)(v3 + 48) == 2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v3 + 16) + 128))(v3 + 16);
  return 0;
}

uint64_t HTTPProtocol::getServicePrincipal(HTTPProtocol *this)
{
  __CFHTTPMessage *v2;
  uint64_t v3;

  if (!*((_QWORD *)this + 44) && !(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this))
    return 0;
  v2 = (__CFHTTPMessage *)*((_QWORD *)this + 39);
  if (v2 && CFHTTPMessageGetResponseStatusCode(v2) == 407)
  {
    v3 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this);
    if (!v3)
      return 0;
  }
  else
  {
    v3 = *((_QWORD *)this + 44);
    if (!v3)
      return 0;
  }
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  if (*(_DWORD *)(v3 + 48) == 2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v3 + 16) + 136))(v3 + 16);
  return 0;
}

void HTTPProtocol::setProxy(_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;

  v3 = *a2;
  if (a1[74] != v3)
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100](a1 + 74, v3, a2[1]);
    v5 = a1[35];
    if (v5)
    {
      v6 = (std::__shared_weak_count *)a1[75];
      v12 = a1[74];
      v13 = v6;
      if (v6)
      {
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          v8 = __ldxr(p_shared_owners);
        while (__stxr(v8 + 1, p_shared_owners));
      }
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v5 + 56))(v5, &v12);
      v9 = v13;
      if (v13)
      {
        v10 = (unint64_t *)&v13->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
    }
  }
}

void sub_18406F24C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void HTTPProtocol::setProxyCreds(HTTPProtocol *this, NetworkProxyCredential *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  char *v7;
  const __CFAllocator *v8;
  NetworkProxyAuthorizationElements *v9;
  const __CFAllocator *v10;

  v2 = *((_QWORD *)this + 46);
  if (a2)
  {
    if (v2)
    {
      v4 = *(_QWORD *)(v2 + 40);
      if (v4)
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
      *(_QWORD *)(v2 + 40) = a2;
      (*(void (**)(NetworkProxyCredential *))(*(_QWORD *)a2 + 40))(a2);
    }
    else
    {
      v7 = (char *)this - 16;
      v8 = CFGetAllocator((char *)this - 16);
      v9 = (NetworkProxyAuthorizationElements *)CFAllocatorAllocate(v8, 80, 0);
      *(_OWORD *)v9 = 0u;
      *((_OWORD *)v9 + 1) = 0u;
      *((_OWORD *)v9 + 2) = 0u;
      *((_OWORD *)v9 + 3) = 0u;
      *((_OWORD *)v9 + 4) = 0u;
      v10 = CFGetAllocator(v7);
      NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements(v9, v10, a2, 0, 0, *((CFTypeRef *)this + 99));
      *((_QWORD *)this + 46) = v9;
    }
  }
  else if (v2)
  {
    v5 = *(_QWORD *)(v2 + 40);
    if (v5)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
      *(_QWORD *)(v2 + 40) = 0;
    }
  }
}

uint64_t HTTPProtocol::setProxyCFCreds(HTTPProtocol *this, const _CFURLCredential *a2)
{
  const void *v4;
  uint64_t result;
  const __CFAllocator *v6;
  NetworkProxyCredential *v7;
  const __CFAllocator *v8;

  if (!a2)
  {
    v7 = 0;
LABEL_6:
    result = (*(uint64_t (**)(HTTPProtocol *, NetworkProxyCredential *))(*(_QWORD *)this + 608))(this, v7);
    if (v7)
      return (*(uint64_t (**)(NetworkProxyCredential *))(*(_QWORD *)v7 + 48))(v7);
    return result;
  }
  if (!(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this)
    || (v4 = (const void *)(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this),
        result = CFEqual(a2, v4),
        !(_DWORD)result))
  {
    v6 = CFGetAllocator((char *)this - 16);
    v7 = (NetworkProxyCredential *)CFAllocatorAllocate(v6, 56, 0);
    *(_OWORD *)v7 = 0u;
    *((_OWORD *)v7 + 1) = 0u;
    *((_OWORD *)v7 + 2) = 0u;
    *((_QWORD *)v7 + 6) = 0;
    v8 = CFGetAllocator((char *)this - 16);
    NetworkProxyCredential::NetworkProxyCredential(v7, v8, a2);
    goto LABEL_6;
  }
  return result;
}

void HTTPProtocol::setProxyProtectionSpace(HTTPProtocol *this, CFTypeRef cf)
{
  NetworkProxyAuthorizationElements *v3;
  const void *v5;
  const __CFAllocator *v6;
  NetworkProxyAuthorizationElements *v7;
  const __CFAllocator *v8;

  v3 = (NetworkProxyAuthorizationElements *)*((_QWORD *)this + 46);
  if (cf)
  {
    if (v3)
    {
      NetworkProxyAuthorizationElements::setProtectionSpace(v3, cf);
    }
    else
    {
      v6 = CFGetAllocator((char *)this - 16);
      v7 = (NetworkProxyAuthorizationElements *)CFAllocatorAllocate(v6, 80, 0);
      *(_OWORD *)v7 = 0u;
      *((_OWORD *)v7 + 1) = 0u;
      *((_OWORD *)v7 + 2) = 0u;
      *((_OWORD *)v7 + 3) = 0u;
      *((_OWORD *)v7 + 4) = 0u;
      v8 = CFGetAllocator((char *)this - 16);
      NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements(v7, v8, 0, cf, 0, *((CFTypeRef *)this + 99));
      *((_QWORD *)this + 46) = v7;
    }
  }
  else if (v3)
  {
    v5 = (const void *)*((_QWORD *)v3 + 6);
    *((_QWORD *)v3 + 6) = 0;
    if (v5)
      CFRelease(v5);
  }
}

void HTTPProtocol::setProxyChallenge(HTTPProtocol *this, CFTypeRef cf)
{
  NetworkProxyAuthorizationElements *v3;
  const void *v5;
  const __CFAllocator *v6;
  NetworkProxyAuthorizationElements *v7;
  const __CFAllocator *v8;

  v3 = (NetworkProxyAuthorizationElements *)*((_QWORD *)this + 46);
  if (cf)
  {
    if (v3)
    {
      NetworkProxyAuthorizationElements::setChallenge(v3, cf);
    }
    else
    {
      v6 = CFGetAllocator((char *)this - 16);
      v7 = (NetworkProxyAuthorizationElements *)CFAllocatorAllocate(v6, 80, 0);
      *(_OWORD *)v7 = 0u;
      *((_OWORD *)v7 + 1) = 0u;
      *((_OWORD *)v7 + 2) = 0u;
      *((_OWORD *)v7 + 3) = 0u;
      *((_OWORD *)v7 + 4) = 0u;
      v8 = CFGetAllocator((char *)this - 16);
      NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements(v7, v8, 0, 0, cf, *((CFTypeRef *)this + 99));
      *((_QWORD *)this + 46) = v7;
    }
  }
  else if (v3)
  {
    v5 = (const void *)*((_QWORD *)v3 + 7);
    *((_QWORD *)v3 + 7) = 0;
    if (v5)
      CFRelease(v5);
  }
}

uint64_t HTTPProtocol::proxyChallenge(HTTPProtocol *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 46);
  if (v1)
    return *(_QWORD *)(v1 + 56);
  else
    return 0;
}

HTTPProtocol *HTTPProtocol::markProxyAuthorizationUnviable(HTTPProtocol *this)
{
  uint64_t v1;
  uint64_t v2;

  if ((*((_DWORD *)this + 48) & 0x400000) != 0)
  {
    v1 = *((_QWORD *)this + 46);
    if (v1)
    {
      v2 = *(_QWORD *)(v1 + 40);
      if (v2)
        *(_DWORD *)(v2 + 40) = 2;
    }
  }
  return this;
}

uint64_t HTTPProtocol::failedProxyAuth(HTTPProtocol *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 46);
  if (v1)
    return *(unsigned __int8 *)(v1 + 32);
  else
    return 0;
}

void HTTPProtocol::setFailedProxyAuth(HTTPProtocol *this, char a2)
{
  NetworkProxyAuthorizationElements *v3;
  char *v5;
  const __CFAllocator *v6;
  const __CFAllocator *v7;

  v3 = (NetworkProxyAuthorizationElements *)*((_QWORD *)this + 46);
  if (!v3)
  {
    v5 = (char *)this - 16;
    v6 = CFGetAllocator((char *)this - 16);
    v3 = (NetworkProxyAuthorizationElements *)CFAllocatorAllocate(v6, 80, 0);
    *(_OWORD *)v3 = 0u;
    *((_OWORD *)v3 + 1) = 0u;
    *((_OWORD *)v3 + 2) = 0u;
    *((_OWORD *)v3 + 3) = 0u;
    *((_OWORD *)v3 + 4) = 0u;
    v7 = CFGetAllocator(v5);
    NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements(v3, v7, 0, 0, 0, *((CFTypeRef *)this + 99));
    *((_QWORD *)this + 46) = v3;
  }
  *((_BYTE *)v3 + 32) = a2;
}

uint64_t HTTPProtocol::proxyAuthenticationIsComplete(HTTPProtocol *this)
{
  return *((unsigned __int8 *)this + 616);
}

HTTPProtocol *HTTPProtocol::socketStreamsForUpgradeHeaderAvailable(HTTPProtocol *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  uint64_t v3;
  HTTPProtocol *v4;
  uint64_t v5;
  void *v6;
  _QWORD v7[6];

  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN12HTTPProtocol38socketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke;
  v7[3] = &__block_descriptor_48_e31_v16__0__URLProtocolClient_____8l;
  v7[4] = a2;
  v7[5] = a3;
  v3 = *((_QWORD *)this + 12);
  if (v3)
  {
    v4 = this;
    v5 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v3 + 16))(*((_QWORD *)this + 12));
    v6 = (void *)MEMORY[0x186DB8C8C](v5);
    ___ZN12HTTPProtocol38socketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke((uint64_t)v7, *((_QWORD *)v4 + 12));
    objc_autoreleasePoolPop(v6);
    return (HTTPProtocol *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  }
  return this;
}

void HTTPProtocol::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  unint64_t *v10;
  unint64_t v11;
  _QWORD v12[2];
  void (*v13)(_QWORD *, uint64_t);
  void *v14;
  uint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;

  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 3321888768;
  v13 = ___ZN12HTTPProtocol38tcpConnectionForUpgradeHeaderAvailableENSt3__110shared_ptrI19TransportConnectionEEPU27objcproto16OS_dispatch_data8NSObject_block_invoke;
  v14 = &unk_1E14F31C8;
  v4 = (std::__shared_weak_count *)a2[1];
  v16 = *a2;
  v17 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v15 = a3;
  v7 = *(_QWORD *)(a1 + 96);
  if (v7)
  {
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v7 + 16))(*(_QWORD *)(a1 + 96));
    v9 = (void *)MEMORY[0x186DB8C8C](v8);
    v13(v12, *(_QWORD *)(a1 + 96));
    objc_autoreleasePoolPop(v9);
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
    v4 = v17;
  }
  if (v4)
  {
    v10 = (unint64_t *)&v4->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_18406F83C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'HTTPProtocol::~HTTPProtocol(HTTPProtocol *this)
{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 8));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 8));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 16));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 16));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 112));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 112));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 120));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 120));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 176));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 176));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 184));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 184));
}

CFTypeRef `non-virtual thunk to'HTTPProtocol::ceRetain(HTTPProtocol *this)
{
  return CFRetain((char *)this - 128);
}

void `non-virtual thunk to'HTTPProtocol::ceRelease(HTTPProtocol *this)
{
  CFRelease((char *)this - 128);
}

uint64_t `non-virtual thunk to'HTTPProtocol::ssPreConnectConfiguration(uint64_t a1, void *a2, uint64_t a3)
{
  return HTTPProtocol::ssPreConnectConfiguration(a1 - 112, a2, a3);
}

uint64_t `non-virtual thunk to'HTTPProtocol::ssNeedServerTrust(uint64_t a1, const void *a2, uint64_t a3)
{
  return HTTPProtocol::ssNeedServerTrust(a1 - 112, a2, a3);
}

uint64_t `non-virtual thunk to'HTTPProtocol::ssNeedClientCert(uint64_t a1, const void *a2, uint64_t a3)
{
  return HTTPProtocol::ssNeedClientCert(a1 - 112, a2, a3);
}

uint64_t `non-virtual thunk to'HTTPProtocol::ssPostConnectConfiguration(uint64_t a1, void *a2, uint64_t a3)
{
  return HTTPProtocol::ssPostConnectConfiguration(a1 - 112, a2, a3);
}

void `non-virtual thunk to'HTTPProtocol::ssPostHandshakesStreamsAvailable(HTTPProtocol *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  abort();
}

uint64_t `non-virtual thunk to'HTTPProtocol::ssConnectionWaitingNotification(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 - 112) + 392))(a1 - 112);
}

void `non-virtual thunk to'HTTPProtocol::needClientCert(uint64_t a1, uint64_t a2, void (**a3)(_QWORD, _QWORD, _QWORD))
{
  HTTPProtocol::needClientCert(a1 - 112, a2, a3);
}

{
  HTTPProtocol::needClientCert(a1 - 120, a2, a3);
}

uint64_t `non-virtual thunk to'HTTPProtocol::preConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return HTTPProtocol::preConnectConfiguration((_QWORD *)(a1 - 112), a2, a3, a4);
}

{
  return HTTPProtocol::preConnectConfiguration((_QWORD *)(a1 - 120), a2, a3, a4);
}

void `non-virtual thunk to'HTTPProtocol::postConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  HTTPProtocol::postConnectConfiguration(a1 - 112, a2, a3, a4);
}

{
  HTTPProtocol::postConnectConfiguration(a1 - 120, a2, a3, a4);
}

uint64_t `non-virtual thunk to'HTTPProtocol::connectionWaitingNotification(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 - 112) + 408))(a1 - 112);
}

{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 - 120) + 408))(a1 - 120);
}

void `non-virtual thunk to'HTTPProtocol::connectionEstablished(HTTPProtocol *this, CFStreamError a2)
{
  abort();
}

{
  abort();
}

void `non-virtual thunk to'HTTPProtocol::setProxy(uint64_t a1, uint64_t *a2)
{
  HTTPProtocol::setProxy((_QWORD *)(a1 - 176), a2);
}

uint64_t `non-virtual thunk to'HTTPProtocol::proxyAuthenticationIsComplete(HTTPProtocol *this)
{
  return *((unsigned __int8 *)this + 440);
}

void `non-virtual thunk to'HTTPProtocol::handleStreamError(HTTPProtocol *this, CFStreamError a2, const __CFDictionary *a3)
{
  HTTPProtocol::handleStreamError((HTTPProtocol *)((char *)this - 176), a2, a3);
}

uint64_t `non-virtual thunk to'HTTPProtocol::creds(HTTPProtocol *this)
{
  return *((_QWORD *)this + 22);
}

uint64_t `non-virtual thunk to'HTTPProtocol::challenge(HTTPProtocol *this)
{
  return *((_QWORD *)this + 25);
}

uint64_t `non-virtual thunk to'HTTPProtocol::authFailureResponse(HTTPProtocol *this)
{
  return *((_QWORD *)this + 17);
}

uint64_t `non-virtual thunk to'HTTPProtocol::proxyCreds(HTTPProtocol *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *((_QWORD *)this + 24);
  if (v1 && (v2 = *(_QWORD *)(v1 + 40)) != 0)
    return *(_QWORD *)(v2 + 32);
  else
    return 0;
}

uint64_t `non-virtual thunk to'HTTPProtocol::proxyChallenge(HTTPProtocol *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 24);
  if (v1)
    return *(_QWORD *)(v1 + 56);
  else
    return 0;
}

uint64_t `non-virtual thunk to'HTTPProtocol::proxyAuthFailureResponse(HTTPProtocol *this)
{
  return *((_QWORD *)this + 20);
}

uint64_t `non-virtual thunk to'HTTPProtocol::requiresConnectionBasedAuth(HTTPProtocol *this)
{
  return HTTPProtocol::requiresConnectionBasedAuth((HTTPProtocol *)((char *)this - 176));
}

uint64_t `non-virtual thunk to'HTTPProtocol::trustRef(HTTPProtocol *this)
{
  return *((_QWORD *)this + 35);
}

uint64_t `non-virtual thunk to'HTTPProtocol::hcc_getUseCredentialStorage(HTTPProtocol *this)
{
  return *((unsigned __int8 *)this - 136);
}

uint64_t `non-virtual thunk to'HTTPProtocol::getUserName(HTTPProtocol *this)
{
  return HTTPProtocol::getUserName((HTTPProtocol *)((char *)this - 176));
}

uint64_t `non-virtual thunk to'HTTPProtocol::getUserPrincipal(HTTPProtocol *this)
{
  return HTTPProtocol::getUserPrincipal((HTTPProtocol *)((char *)this - 176));
}

uint64_t `non-virtual thunk to'HTTPProtocol::getServicePrincipal(HTTPProtocol *this)
{
  return HTTPProtocol::getServicePrincipal((HTTPProtocol *)((char *)this - 176));
}

uint64_t `non-virtual thunk to'HTTPProtocol::getUUID(HTTPProtocol *this)
{
  return HTTPProtocol::getUUID((HTTPProtocol *)((char *)this - 176));
}

uint64_t `non-virtual thunk to'HTTPProtocol::handleConnectionWaitingNotification(uint64_t a1, uint64_t a2)
{
  return HTTPProtocol::handleConnectionWaitingNotification(a1 - 176, a2);
}

uint64_t `non-virtual thunk to'HTTPProtocol::handleAlternatePathNotification(uint64_t a1, int a2)
{
  return HTTPProtocol::handleAlternatePathNotification(a1 - 176, a2);
}

HTTPProtocol *`non-virtual thunk to'HTTPProtocol::socketStreamsForUpgradeHeaderAvailable(HTTPProtocol *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  return HTTPProtocol::socketStreamsForUpgradeHeaderAvailable((HTTPProtocol *)((char *)this - 176), a2, a3);
}

void `non-virtual thunk to'HTTPProtocol::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  HTTPProtocol::tcpConnectionForUpgradeHeaderAvailable(a1 - 176, a2, a3);
}

uint64_t `non-virtual thunk to'HTTPProtocol::canRetryRequestAfterError(HTTPProtocol *this, const CFStreamError *a2, int a3)
{
  return HTTPProtocol::canRetryRequestAfterError((HTTPProtocol *)((char *)this - 176), a2, a3);
}

void `non-virtual thunk to'HTTPProtocol::generateProxyAuthentication(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  HTTPProtocol::generateProxyAuthentication((std::__shared_weak_count_vtbl *)(a1 - 184), a2, a3, a4);
}

void `non-virtual thunk to'HTTPProtocol::resetAuthState(HTTPProtocol *this)
{
  HTTPProtocol::resetAuthState((HTTPProtocol *)((char *)this - 184));
}

uint64_t `non-virtual thunk to'HTTPProtocol::clientDescription(HTTPProtocol *this)
{
  return *((_QWORD *)this + 76);
}

uint64_t std::deque<SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::~deque[abi:nn180100](uint64_t a1)
{
  void **v2;
  void **v3;
  _QWORD *v4;
  unint64_t v5;
  void **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;

  v2 = *(void ***)(a1 + 8);
  v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    v4 = (_QWORD *)(a1 + 40);
    v3 = *(void ***)(a1 + 8);
  }
  else
  {
    v4 = (_QWORD *)(a1 + 40);
    v5 = *(_QWORD *)(a1 + 32);
    v6 = &v2[v5 >> 8];
    v7 = (uint64_t)*v6 + 16 * v5;
    v8 = *(uint64_t *)((char *)v2 + (((*(_QWORD *)(a1 + 40) + v5) >> 5) & 0x7FFFFFFFFFFFFF8))
       + 16 * (*(_BYTE *)(a1 + 40) + v5);
    if (v7 != v8)
    {
      do
      {
        v7 = std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v7) + 16;
        if (v7 - (_QWORD)*v6 == 4096)
        {
          v9 = (uint64_t)v6[1];
          ++v6;
          v7 = v9;
        }
      }
      while (v7 != v8);
      v2 = *(void ***)(a1 + 8);
      v3 = *(void ***)(a1 + 16);
    }
  }
  *v4 = 0;
  v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = *(void ***)(a1 + 16);
      v2 = (void **)(*(_QWORD *)(a1 + 8) + 8);
      *(_QWORD *)(a1 + 8) = v2;
      v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v11 = v10 >> 3;
  if (v11 == 1)
  {
    v12 = 128;
    goto LABEL_14;
  }
  if (v11 == 2)
  {
    v12 = 256;
LABEL_14:
    *(_QWORD *)(a1 + 32) = v12;
  }
  if (v2 != v3)
  {
    do
    {
      v13 = *v2++;
      operator delete(v13);
    }
    while (v2 != v3);
    v15 = *(_QWORD *)(a1 + 8);
    v14 = *(_QWORD *)(a1 + 16);
    if (v14 != v15)
      *(_QWORD *)(a1 + 16) = v14 + ((v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void ___ZN9TCFObjectI12SocketStreamE5ClassEv_block_invoke_7115()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  dword_1EDD01068 = 1835099506;
  _PNAME<SocketStream>::GET(void)::p = *(_QWORD *)"SocketStream>::GET() [OBJTYPE = SocketStream]";
  CFClass::CFClass(v0, (const char *)&_PNAME<SocketStream>::GET(void)::p);
  TCFObject<SocketStream>::Class(void)::clazz = (uint64_t)v0;
}

void sub_18406FBEC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN9TCFObjectIN19TransportConnection17RefCountedWrapperEE5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  qmemcpy(&_PNAME<TransportConnection::RefCountedWrapper>::GET(void)::p, "TransportConnection::RefCountedWrapper", 38);
  CFClass::CFClass(v0, (const char *)&_PNAME<TransportConnection::RefCountedWrapper>::GET(void)::p);
  TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::clazz = (uint64_t)v0;
}

void sub_18406FC70(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t ___ZN12HTTPProtocol17destroyReadStreamEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 2457;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12HTTPProtocolD2Ev_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 563;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN12HTTPProtocol38tcpConnectionForUpgradeHeaderAvailableENSt3__110shared_ptrI19TransportConnectionEEPU27objcproto16OS_dispatch_data8NSObject_block_invoke(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  if (a2)
  {
    v2 = (std::__shared_weak_count *)a1[6];
    v8 = a1[5];
    v9 = v2;
    if (v2)
    {
      p_shared_owners = (unint64_t *)&v2->__shared_owners_;
      do
        v4 = __ldxr(p_shared_owners);
      while (__stxr(v4 + 1, p_shared_owners));
    }
    (*(void (**)(uint64_t, uint64_t *, _QWORD))(*(_QWORD *)a2 + 168))(a2, &v8, a1[4]);
    v5 = v9;
    if (v9)
    {
      v6 = (unint64_t *)&v9->__shared_owners_;
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
  else
  {
    (*(void (**)(_QWORD))(*(_QWORD *)a1[5] + 152))(a1[5]);
  }
}

void sub_18406FE0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_40c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

void ___ZN12HTTPProtocol38socketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __CFWriteStream *v5;

  v4 = *(_QWORD *)(a1 + 32);
  if (a2)
  {
    (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)a2 + 160))(a2, v4, *(_QWORD *)(a1 + 40));
  }
  else
  {
    if (v4)
      CFReadStreamClose(*(CFReadStreamRef *)(a1 + 32));
    v5 = *(__CFWriteStream **)(a1 + 40);
    if (v5)
      CFWriteStreamClose(v5);
  }
}

URLProtocol *URLProtocol::sendNeedNewBodyStream(URLProtocol *this)
{
  uint64_t v1;
  URLProtocol *v2;
  uint64_t v3;
  void *v4;

  v1 = *((_QWORD *)this + 12);
  if (v1)
  {
    v2 = this;
    v3 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v1 + 16))(*((_QWORD *)this + 12));
    v4 = (void *)MEMORY[0x186DB8C8C](v3);
    (*(void (**)(_QWORD))(**((_QWORD **)v2 + 12) + 112))(*((_QWORD *)v2 + 12));
    objc_autoreleasePoolPop(v4);
    return (URLProtocol *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  }
  return this;
}

void ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_113(_QWORD *a1, uint64_t a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const __CFAllocator *v8;
  const char *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  _QWORD v18[6];
  std::__shared_weak_count *v19;
  char v20;
  void (**v21)(AutoString *__hidden);
  CFStringRef v22;
  uint64_t v23;
  uint64_t v24;
  void (**v25)(AutoString *__hidden);
  CFStringRef v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v5 = a1[4];
  v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_115, 2);
  if (v6)
  {
    v7 = v6;
    if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)v6 + 24))(v6, "_kCFStreamPropertyConditionalRequirementsChangedBlock called", v5))
    {
      v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (a3)
        v9 = "true";
      else
        v9 = "false";
      (*(void (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v7 + 48))(v7, "Request", *(_QWORD *)(v5 + 88));
      v25 = &off_1E14E4818;
      v27 = 0;
      v28 = 0;
      v26 = CFStringCreateWithCString(v8, "satisfied", 0x8000100u);
      v21 = &off_1E14E4818;
      v23 = 0;
      v24 = 0;
      v22 = CFStringCreateWithCString(v8, v9, 0x8000100u);
      (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(_QWORD *)v7 + 64))(v7, v26, v22);
      AutoString::~AutoString((AutoString *)&v21);
      AutoString::~AutoString((AutoString *)&v25);
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
    }
  }
  v11 = a1[5];
  v10 = (std::__shared_weak_count *)a1[6];
  v12 = *(_QWORD *)(v11 + 24);
  v18[0] = MEMORY[0x1E0C809B0];
  v18[1] = 3321888768;
  v18[2] = ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_3_120;
  v18[3] = &__block_descriptor_57_e8_40c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e5_v8__0l;
  v20 = a3;
  v18[4] = v5;
  v18[5] = v11;
  v19 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v12 + 96))(v12, v18);
  v15 = v19;
  if (v19)
  {
    v16 = (unint64_t *)&v19->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

void sub_18407013C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  AutoString::~AutoString((AutoString *)&a18);
  AutoString::~AutoString((AutoString *)&a37);
  _Unwind_Resume(a1);
}

void ___ZN12HTTPProtocol10openStreamEv_block_invoke_2(uint64_t a1, uint64_t a2, NSObject *a3, CFStreamError *a4)
{
  uint64_t v5;

  v5 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v5 + 272) == *(_QWORD *)(a1 + 40))
    HTTPProtocol::handleStreamEvent(v5, a2, a3, a4);
}

const unsigned __int8 *_findDelimiterInBytes(unsigned __int8 *__s, size_t __n, const unsigned __int8 *a3, size_t a4, const unsigned __int8 **a5, unsigned __int8 *a6)
{
  size_t v10;
  unsigned __int8 *v11;
  const unsigned __int8 *v12;
  int v13;
  char *v14;
  unint64_t v15;
  const unsigned __int8 *v16;
  char *v17;
  const unsigned __int8 *v18;

  v10 = __n;
  v11 = __s;
  v12 = &__s[__n];
  *a5 = 0;
  *a6 = 0;
  v13 = *a3;
  while (1)
  {
    v14 = (char *)memchr(v11, v13, v10);
    v15 = (unint64_t)v14;
    if (!v14)
      break;
    v16 = (const unsigned __int8 *)&v14[a4];
    if (&v14[a4] >= (char *)v12)
      break;
    if (!memcmp(a3, v14, a4))
    {
      if (v16 + 2 < v12 && *v16 == 45 && v16[1] == 45)
      {
        *a5 = v16 + 2;
        *a6 = 1;
      }
      else
      {
        v17 = (char *)memchr((void *)(v15 + a4), 10, v12 - v16);
        if (!v17)
          v17 = (char *)memchr((void *)(v15 + a4), 13, v12 - v16 - 1);
        if (v17)
          v18 = (const unsigned __int8 *)(v17 + 1);
        else
          v18 = 0;
        *a5 = v18;
      }
      return (const unsigned __int8 *)v15;
    }
    v10 += (size_t)&v11[~v15];
    v11 = (unsigned __int8 *)(v15 + 1);
  }
  if (!v14)
    return v12;
  return (const unsigned __int8 *)v15;
}

void HTTPProtocol::fixupAndSendMultiPartData(HTTPProtocol *this, UInt8 *newBytes, CFIndex numBytes, int a4)
{
  unint64_t v7;
  __CFHTTPMessage *v8;
  const __CFData *v9;
  const void *v10;
  const __CFAllocator *v11;
  _BOOL4 v12;
  char *v13;
  CFIndex Length;
  __CFHTTPMessage *Response;
  const __CFAllocator *v16;
  const __CFAllocator *v17;
  uint64_t v18;
  __CFHTTPMessage *v19;
  __CFHTTPMessage *Copy;
  CFDictionaryRef v21;
  const __CFDictionary *v22;
  unint64_t Count;
  const void **v24;
  const __CFData *v25;
  const __CFAllocator *v26;
  const __CFAllocator *v27;
  const __CFAllocator *v28;
  _BOOL4 v29;
  CFDataRef v30;
  int64_t v31;
  const __CFString *v32;
  const __CFString *Value;
  uint64_t v34;
  id v35;
  uint64_t v36;
  const void *v37;
  const void *v38;
  CFTypeRef v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  __CFHTTPMessage *v44;
  const __CFData *v45;
  const void *v46;
  const __CFAllocator *v47;
  _BOOL4 v48;
  char *v49;
  CFIndex v50;
  CFDataRef v51;
  CFDataRef theData;
  int64_t v53;
  const void **v54;
  _BYTE v55[248];
  int64_t v56;

  if (a4)
  {
    v7 = *((_DWORD *)this + 48) & 0xFFFFF7FF | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
    *((_DWORD *)this + 48) &= ~0x800u;
    *((_WORD *)this + 98) = WORD2(v7);
    v8 = (__CFHTTPMessage *)*((_QWORD *)this + 31);
    if (v8)
    {
      v9 = CFHTTPMessageCopyBody(v8);
      theData = v9;
      v10 = (const void *)*((_QWORD *)this + 31);
      *((_QWORD *)this + 31) = 0;
      if (v10)
        CFRelease(v10);
      if (v9)
      {
        v11 = CFGetAllocator((char *)this - 16);
        v12 = _checkForDataToDeliver(v11, (uint64_t *)this + 33, &theData);
        v13 = (char *)theData;
        if (v12)
        {
          Length = CFDataGetLength(theData);
          HTTPProtocol::sendDidLoadData(this, v13, Length);
        }
        if (v13)
          CFRelease(v13);
      }
    }
  }
  if (numBytes)
  {
    if ((*((_DWORD *)this + 48) & 0x800) != 0)
    {
      v25 = (const __CFData *)*((_QWORD *)this + 32);
      if (v25 && CFDataGetLength(v25) == numBytes)
      {
        v26 = CFGetAllocator((char *)this - 16);
        if (_checkForDataToDeliver(v26, (uint64_t *)this + 33, (const __CFData **)this + 32))
          HTTPProtocol::sendDidLoadData(this, *((char **)this + 32), numBytes);
      }
      else
      {
        v27 = CFGetAllocator((char *)this - 16);
        theData = CFDataCreate(v27, newBytes, numBytes);
        v28 = CFGetAllocator((char *)this - 16);
        v29 = _checkForDataToDeliver(v28, (uint64_t *)this + 33, &theData);
        v30 = theData;
        if (v29)
          HTTPProtocol::sendDidLoadData(this, (char *)theData, numBytes);
        if (v30)
          CFRelease(v30);
      }
    }
    else
    {
      Response = (__CFHTTPMessage *)*((_QWORD *)this + 31);
      if (!Response)
      {
        v16 = CFGetAllocator((char *)this - 16);
        Response = CFHTTPMessageCreateResponse(v16, 200, 0, CFSTR("HTTP/1.0"));
        *((_QWORD *)this + 31) = Response;
      }
      CFHTTPMessageAppendBytes(Response, newBytes, numBytes);
      if (CFHTTPMessageIsHeaderComplete(*((CFHTTPMessageRef *)this + 31)))
      {
        *((_DWORD *)this + 48) |= 0x800u;
        v17 = CFGetAllocator((char *)this - 16);
        v18 = *(_QWORD *)(objc_msgSend(*((id *)this + 26), "_inner") + 88);
        if (v18)
          v19 = (__CFHTTPMessage *)(v18 - 16);
        else
          v19 = 0;
        Copy = CFHTTPMessageCreateCopy(v17, v19);
        v21 = CFHTTPMessageCopyAllHeaderFields(*((CFHTTPMessageRef *)this + 31));
        v22 = v21;
        if (!v21)
        {
          theData = 0;
          v53 = 0;
          v54 = (const void **)v55;
          goto LABEL_34;
        }
        theData = (CFDataRef)CFRetain(v21);
        Count = CFDictionaryGetCount(v22);
        v53 = Count;
        if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
        {
          v54 = 0;
          goto LABEL_34;
        }
        if (Count > 0x1E)
        {
          v24 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
          v54 = v24;
          if (!v24)
            goto LABEL_34;
        }
        else
        {
          v24 = (const void **)v55;
          v54 = (const void **)v55;
        }
        CFDictionaryGetKeysAndValues(v22, v24, 0);
LABEL_34:
        v56 = 0;
        while (1)
        {
          v31 = v56;
          if (v56 >= v53)
            break;
          ++v56;
          v32 = (const __CFString *)v54[v31];
          Value = (const __CFString *)CFDictionaryGetValue(v22, v32);
          CFHTTPMessageSetHeaderFieldValue(Copy, v32, Value);
        }
        if (v22)
          CFRelease(v22);
        CFGetAllocator((char *)this - 16);
        v34 = objc_msgSend(*((id *)this + 26), "_inner");
        v35 = CFURLResponseCreateWithHTTPResponse(v34, *(const void **)(v34 + 8), (uint64_t)Copy, 2);
        *((_QWORD *)this + 33) = CFURLResponseGetExpectedContentLength(v35);
        if (*((_QWORD *)this + 59))
        {
          v36 = objc_msgSend(v35, "_inner");
          v37 = (const void *)*((_QWORD *)this + 59);
          v38 = *(const void **)(v36 + 80);
          if (v38 != v37)
          {
            if (v38)
              CFRelease(v38);
            if (v37)
              v39 = CFRetain(v37);
            else
              v39 = 0;
            *(_QWORD *)(v36 + 80) = v39;
          }
        }
        v40 = *((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
        if ((v40 & 0x200000000) != 0)
        {
          *(_BYTE *)(objc_msgSend(v35, "_inner") + 97) = 1;
          v40 = *((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
        }
        if ((v40 & 0x400000000) != 0)
          *(_BYTE *)(objc_msgSend(v35, "_inner") + 96) = 1;
        CFRelease(Copy);
        v41 = *((_QWORD *)this + 12);
        if (v41)
        {
          v42 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v41 + 16))(*((_QWORD *)this + 12));
          v43 = (void *)MEMORY[0x186DB8C8C](v42);
          (*(void (**)(_QWORD, id))(**((_QWORD **)this + 12) + 64))(*((_QWORD *)this + 12), v35);
          objc_autoreleasePoolPop(v43);
          (*(void (**)(uint64_t))(*(_QWORD *)v41 + 24))(v41);
        }

        v44 = (__CFHTTPMessage *)*((_QWORD *)this + 31);
        if (v44)
        {
          v45 = CFHTTPMessageCopyBody(v44);
          v51 = v45;
          v46 = (const void *)*((_QWORD *)this + 31);
          *((_QWORD *)this + 31) = 0;
          if (v46)
            CFRelease(v46);
          if (v45)
          {
            v47 = CFGetAllocator((char *)this - 16);
            v48 = _checkForDataToDeliver(v47, (uint64_t *)this + 33, &v51);
            v49 = (char *)v51;
            if (v48)
            {
              v50 = CFDataGetLength(v51);
              HTTPProtocol::sendDidLoadData(this, v49, v50);
            }
            if (v49)
              CFRelease(v49);
          }
        }
        CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&theData);
      }
    }
  }
}

void sub_18407074C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

BOOL _checkForDataToDeliver(const __CFAllocator *a1, uint64_t *a2, const __CFData **a3)
{
  CFIndex v6;
  CFIndex Length;
  __CFData *Mutable;
  const UInt8 *BytePtr;

  if (*a2 < 0)
  {
    Length = CFDataGetLength(*a3);
  }
  else if (*a2)
  {
    v6 = CFDataGetLength(*a3);
    Length = *a2;
    if (v6 <= *a2)
    {
      Length = CFDataGetLength(*a3);
    }
    else
    {
      Mutable = CFDataCreateMutable(a1, *a2);
      BytePtr = CFDataGetBytePtr(*a3);
      CFDataAppendBytes(Mutable, BytePtr, Length);
      if (*a3)
        CFRelease(*a3);
      *a3 = Mutable;
    }
    *a2 -= Length;
  }
  else
  {
    Length = 0;
  }
  return Length > 0;
}

void HTTPProtocol::deliverUnhandledResponse(HTTPProtocol *this)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;

  if ((*((_DWORD *)this + 183) | 2) == 2)
  {
    v2 = *((_QWORD *)this + 90);
    if (v2)
    {
      HTTPProtocol::bytesAvailable((uint64_t)this, v2);
      dispatch_release(*((dispatch_object_t *)this + 90));
      *((_QWORD *)this + 90) = 0;
    }
    v3 = *((unsigned int *)this + 48);
    v4 = *((unsigned __int16 *)this + 98);
    *((_DWORD *)this + 48) = v3;
    *((_WORD *)this + 98) = v4 & 0xDBFF;
    *((_DWORD *)this + 183) = 0;
    if ((v3 & 0x80) == 0)
    {
      *((_DWORD *)this + 48) = v3 & 0xFFFFFFFB;
      *((_WORD *)this + 98) = ((v3 | (v4 << 32)) & 0xDBFFFFFFFFFBuLL) >> 32;
      HTTPProtocol::endEncountered(this);
    }
  }
}

void HTTPProtocol::storeCredentials(HTTPProtocol *this)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;

  v1 = *((_QWORD *)this + 44);
  if (v1 && *((_QWORD *)this + 47))
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1)
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
    if (*(_DWORD *)(v1 + 52) != 1)
    {
      v3 = *((_QWORD *)this + 47);
      if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
        dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
      v4 = v3 + 16;
      if (!v3)
        v4 = 0;
      (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 87) + 56))(*((_QWORD *)this + 87), *((_QWORD *)this + 44), *(_QWORD *)(v4 + 24), *((_QWORD *)this + 10));
    }
  }
}

void _ZNSt3__115allocate_sharedB8nn180100I19AuthenticationStateNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(std::__shared_weak_count_vtbl **a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  std::__shared_weak_count_vtbl *v4;
  std::__shared_weak_count *shared_owners;
  unint64_t v6;
  unint64_t *p_shared_weak_owners;
  unint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;

  v2 = (std::__shared_weak_count *)operator new(0xB0uLL);
  v2->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  v2->__shared_weak_owners_ = 0;
  v2->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0C90;
  AuthenticationState::AuthenticationState((AuthenticationState *)&v2[1]);
  *a1 = v4;
  a1[1] = (std::__shared_weak_count_vtbl *)v2;
  shared_owners = (std::__shared_weak_count *)v2[4].__shared_owners_;
  if (shared_owners)
  {
    if (shared_owners->__shared_owners_ != -1)
      return;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v2->__shared_weak_owners_;
    do
      v8 = __ldxr(p_shared_weak_owners);
    while (__stxr(v8 + 1, p_shared_weak_owners));
    v2[4].__vftable = v4;
    v2[4].__shared_owners_ = (uint64_t)v2;
    std::__shared_weak_count::__release_weak(shared_owners);
  }
  else
  {
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    v10 = (unint64_t *)&v2->__shared_weak_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
    v2[4].__vftable = v4;
    v2[4].__shared_owners_ = (uint64_t)v2;
  }
  do
    v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_184070A80(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v3;

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<_CFURLRequest const*,Deleter_CFRelease,std::allocator<_CFURLRequest const>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_emplace<APSRelayTransaction>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0C58;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<APSRelayTransaction>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0C58;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_emplace<APSRelayTransaction>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void APSRelayTransactionWrapper::~APSRelayTransactionWrapper(APSRelayTransactionWrapper *this)
{
  *(_QWORD *)this = off_1E14ED7B8;
  *((_QWORD *)this + 3) = &unk_1E14ED890;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 32);
}

{
  *(_QWORD *)this = off_1E14ED7B8;
  *((_QWORD *)this + 3) = &unk_1E14ED890;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 32);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

uint64_t APSRelayTransactionWrapper::copyProperty()
{
  return 0;
}

BOOL APSRelayTransactionWrapper::setProperty(uint64_t a1, int a2, const void *a3)
{
  return APSRelayTransaction::setProperty(*(_QWORD *)(a1 + 32), a2, a3);
}

uint64_t APSRelayTransactionWrapper::canScheduleAndOpenWithHandlerAsync(APSRelayTransactionWrapper *this)
{
  return 1;
}

uint64_t APSRelayTransactionWrapper::scheduleAndOpenWithHandler(uint64_t a1, const CoreSchedulingSet *a2, void *a3, void (**a4)(_QWORD, _QWORD))
{
  APSRelayTransaction::scheduleAndOpenWithHandler(*(APSRelayTransaction **)(a1 + 32), a2, a3, a4);
  return 1;
}

void APSRelayTransactionWrapper::closeAndClearHandler(APSRelayTransaction **this)
{
  APSRelayTransaction::closeAndClearHandler(this[4]);
}

void APSRelayTransactionWrapper::updateScheduling(APSRelayTransaction **this, const CoreSchedulingSet *a2)
{
  APSRelayTransaction::_updateScheduling(this[4], a2, 1);
}

void APSRelayTransactionWrapper::setBodyStreamBeforeOpening(APSRelayTransaction **this, __CFReadStream *a2)
{
  APSRelayTransaction::setBodyStreamBeforeOpening(this[4], a2);
}

uint64_t APSRelayTransactionWrapper::rawBytesSent(APSRelayTransactionWrapper *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 4) + 248);
}

uint64_t APSRelayTransactionWrapper::rawBytesReceived(APSRelayTransactionWrapper *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 4) + 256);
}

uint64_t APSRelayTransactionWrapper::getConnectionIdentifier(APSRelayTransactionWrapper *this)
{
  return 0;
}

uint64_t APSRelayTransactionWrapper::copyTrust(APSRelayTransactionWrapper *this)
{
  return 0;
}

void APSRelayTransactionWrapper::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;

  v3 = *(_QWORD *)(a1 + 32);
  v4 = *a2;
  v5 = (std::__shared_weak_count *)a2[1];
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v3 + 128), v4, (uint64_t)v5);
    v8 = (unint64_t *)&v5->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  else
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v3 + 128), v4, 0);
  }
}

uint64_t APSRelayTransactionWrapper::getProxy@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v2 = *(_QWORD *)(this + 32);
  v4 = *(_QWORD *)(v2 + 128);
  v3 = *(_QWORD *)(v2 + 136);
  *a2 = v4;
  a2[1] = v3;
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return this;
}

uint64_t APSRelayTransactionWrapper::setTransactionMetrics(uint64_t this, __CFN_TransactionMetrics *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(this + 32);
  *(_QWORD *)(v2 + 280) = a2;
  *(_QWORD *)(*(_QWORD *)(v2 + 48) + 176) = a2;
  return this;
}

uint64_t APSRelayTransactionWrapper::_meta_retain(APSRelayTransactionWrapper *this)
{
  return (*(uint64_t (**)(APSRelayTransactionWrapper *))(*(_QWORD *)this + 40))(this);
}

uint64_t APSRelayTransactionWrapper::_meta_release(APSRelayTransactionWrapper *this)
{
  return (*(uint64_t (**)(APSRelayTransactionWrapper *))(*(_QWORD *)this + 48))(this);
}

void `non-virtual thunk to'APSRelayTransactionWrapper::~APSRelayTransactionWrapper(APSRelayTransactionWrapper *this)
{
  *((_QWORD *)this - 3) = off_1E14ED7B8;
  *(_QWORD *)this = &unk_1E14ED890;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
}

{
  char *v2;

  *((_QWORD *)this - 3) = off_1E14ED7B8;
  v2 = (char *)this - 24;
  *(_QWORD *)this = &unk_1E14ED890;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this - 2), v2);
}

uint64_t `non-virtual thunk to'APSRelayTransactionWrapper::_meta_retain(APSRelayTransactionWrapper *this)
{
  return (*(uint64_t (**)(char *))(*((_QWORD *)this - 3) + 40))((char *)this - 24);
}

uint64_t `non-virtual thunk to'APSRelayTransactionWrapper::_meta_release(APSRelayTransactionWrapper *this)
{
  return (*(uint64_t (**)(char *))(*((_QWORD *)this - 3) + 48))((char *)this - 24);
}

uint64_t `non-virtual thunk to'APSRelayTransactionWrapper::copyProperty()
{
  return 0;
}

BOOL `non-virtual thunk to'APSRelayTransactionWrapper::setProperty(uint64_t a1, int a2, const void *a3)
{
  return APSRelayTransaction::setProperty(*(_QWORD *)(a1 + 8), a2, a3);
}

uint64_t `non-virtual thunk to'APSRelayTransactionWrapper::canScheduleAndOpenWithHandlerAsync(APSRelayTransactionWrapper *this)
{
  return 1;
}

uint64_t `non-virtual thunk to'APSRelayTransactionWrapper::scheduleAndOpenWithHandler(uint64_t a1, const CoreSchedulingSet *a2, void *a3, void (**a4)(_QWORD, _QWORD))
{
  APSRelayTransaction::scheduleAndOpenWithHandler(*(APSRelayTransaction **)(a1 + 8), a2, a3, a4);
  return 1;
}

void `non-virtual thunk to'APSRelayTransactionWrapper::closeAndClearHandler(APSRelayTransaction **this)
{
  APSRelayTransaction::closeAndClearHandler(this[1]);
}

void `non-virtual thunk to'APSRelayTransactionWrapper::updateScheduling(APSRelayTransaction **this, const CoreSchedulingSet *a2)
{
  APSRelayTransaction::_updateScheduling(this[1], a2, 1);
}

void `non-virtual thunk to'APSRelayTransactionWrapper::setBodyStreamBeforeOpening(APSRelayTransaction **this, __CFReadStream *a2)
{
  APSRelayTransaction::setBodyStreamBeforeOpening(this[1], a2);
}

uint64_t `non-virtual thunk to'APSRelayTransactionWrapper::rawBytesSent(APSRelayTransactionWrapper *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 1) + 248);
}

uint64_t `non-virtual thunk to'APSRelayTransactionWrapper::rawBytesReceived(APSRelayTransactionWrapper *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 1) + 256);
}

uint64_t `non-virtual thunk to'APSRelayTransactionWrapper::getConnectionIdentifier(APSRelayTransactionWrapper *this)
{
  return 0;
}

uint64_t `non-virtual thunk to'APSRelayTransactionWrapper::copyTrust(APSRelayTransactionWrapper *this)
{
  return 0;
}

void `non-virtual thunk to'APSRelayTransactionWrapper::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;

  v3 = *(_QWORD *)(a1 + 8);
  v4 = *a2;
  v5 = (std::__shared_weak_count *)a2[1];
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v3 + 128), v4, (uint64_t)v5);
    v8 = (unint64_t *)&v5->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  else
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v3 + 128), v4, 0);
  }
}

uint64_t `non-virtual thunk to'APSRelayTransactionWrapper::getProxy@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v2 = *(_QWORD *)(this + 8);
  v4 = *(_QWORD *)(v2 + 128);
  v3 = *(_QWORD *)(v2 + 136);
  *a2 = v4;
  a2[1] = v3;
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return this;
}

uint64_t `non-virtual thunk to'APSRelayTransactionWrapper::setTransactionMetrics(uint64_t this, __CFN_TransactionMetrics *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(this + 8);
  *(_QWORD *)(v2 + 280) = a2;
  *(_QWORD *)(*(_QWORD *)(v2 + 48) + 176) = a2;
  return this;
}

uint64_t ___ZN12HTTPProtocol81asynchronouslyCreateAndOpenStream_WithMessage_AfterCookiesAndAuthenticatorHeadersEP15__CFHTTPMessage_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 3196;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void std::__shared_ptr_pointer<__CFHTTPMessage *,Deleter_CFRelease,std::allocator<__CFHTTPMessage>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t ___ZN12HTTPProtocol35asynchronouslyAddCookiesAndContinueEP15__CFHTTPMessage_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 3650;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void std::__shared_ptr_emplace<AuthenticationState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0C90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<AuthenticationState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0C90;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t HTTPProtocol::_CFHTTPProtHasCredentialsForChallenge(HTTPProtocol *this, __CFHTTPMessage *a2)
{
  uint64_t v4;
  CFIndex ResponseStatusCode;
  double v7;
  CFIndex v8;
  _BOOL4 v9;
  uint64_t v10;
  CFIndex v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  HTTPAuthentication *v15;
  _BOOL4 v16;
  NSURLSessionTask *v17;
  __n128 v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  _BOOL4 v22;
  _CFHTTPAuthentication *Authentication;
  uint64_t v24;
  const __CFDictionary *v25;
  const __CFBoolean *Value;
  const __CFBoolean *v27;
  CFTypeID v28;
  void *v29;
  const __CFString *v30;
  uint64_t v31;
  const __CFData *v32;
  double v33;
  CFAllocatorRef v34;
  id v35;
  _QWORD *v36;
  _CFURLProtectionSpace *v37;
  unint64_t *v38;
  unint64_t v39;
  const void *EndpointCred;
  NSObject *v41;
  CFIndex v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  char *v46;
  unsigned __int8 *v47;
  int v48;
  uint64_t KerberosAccountBroker;
  _BOOL4 v50;
  char i;
  uint64_t v52;
  int v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t Auth;
  uint64_t v59;
  uint64_t v60;
  const void *v61;
  AuthenticationState *v62;
  HTTPResponseMessage *v63;
  const _CFURLCredential *v64;
  uint64_t v65;
  _CFHTTPAuthentication *v66;
  uint64_t v67;
  int v68;
  int v69;
  const __CFURL *v70;
  const __CFString *v71;
  double v72;
  double Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher;
  uint64_t v74;
  void *v75;
  CFStringRef v76;
  void *v77;
  __CFArray *v78;
  BOOL isFirstPartyResource;
  NSObject *v80;
  uint64_t v81;
  const char *v82;
  uint8_t *p_error;
  const void *v84;
  _BOOL8 v85;
  int v86;
  const __CFDictionary *v87;
  BOOL v88;
  char v89;
  int v90;
  const __CFArray *v91;
  const __CFString *v92;
  const __CFDictionary *v93;
  const __CFDictionary *v94;
  const __CFString *v95;
  const __CFNumber *v96;
  int v97;
  const __CFString *v98;
  const __CFString *v99;
  const __CFString *v100;
  const __CFURL *v101;
  SInt32 v102;
  int v103;
  CFTypeRef v104;
  const __CFString *v105;
  CFAllocatorRef v106;
  uint64_t XMobileMeAuthToken;
  const void *v108;
  char *v109;
  int v110;
  __int16 v111;
  std::__shared_weak_count *v112;
  unint64_t *v113;
  std::__shared_weak_count *v114;
  unint64_t *v115;
  uint64_t v116;
  std::__shared_weak_count *v117;
  unint64_t *v118;
  unint64_t v119;
  uint64_t v120;
  unint64_t v121;
  unint64_t v122;
  std::__shared_weak_count *v123;
  unint64_t *v124;
  unint64_t v125;
  std::__shared_weak_count *v126;
  unint64_t *v127;
  unint64_t v128;
  int v129;
  __int16 v130;
  std::__shared_weak_count *v131;
  unint64_t *v132;
  unint64_t v133;
  std::__shared_weak_count *v134;
  unint64_t *v135;
  unint64_t v136;
  std::__shared_weak_count *v137;
  unint64_t *v138;
  unint64_t v139;
  std::__shared_weak_count *v140;
  unint64_t *v141;
  unint64_t v142;
  std::__shared_weak_count *v143;
  unint64_t *v144;
  unint64_t v145;
  CFIndex v146;
  const void *ValueAtIndex;
  _QWORD *v148;
  const __CFString *v149;
  int v150;
  _CFURLProtectionSpace *v151;
  int v152;
  _BOOL4 v153;
  _BOOL4 v154;
  uint64_t v155;
  CFTypeRef v156;
  uint64_t v157;
  uint64_t v158;
  _CFURLProtectionSpace *v159;
  double v160;
  uint64_t v161;
  const __CFString *v162;
  char v163;
  const void *v164;
  const _CFURLCredential *v165;
  const void *v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  const void *v171;
  CFAllocatorRef v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  id v176;
  CFAllocatorRef v177;
  const void *v178;
  uint64_t v179;
  URLAuthChallenge *v180;
  _BOOL4 v181;
  const void *v182;
  void *v183;
  uint64_t v184;
  CFTypeRef v185;
  const void *v186;
  uint64_t v187;
  CFTypeRef v188;
  uint64_t v189;
  unint64_t v190;
  CFAllocatorRef v191;
  uint64_t v192;
  const void *v193;
  uint64_t v194;
  const __CFDictionary *v195;
  const __CFDictionary *v196;
  const void *v197;
  const void *v198;
  uint64_t v199;
  _CFURLProtectionSpace *v200;
  const void *v201;
  void *v202;
  unsigned __int8 v203;
  uint64_t v204;
  uint64_t v205;
  const __CFString *v206;
  uint64_t v207;
  id v208;
  const void *v209;
  CFAllocatorRef v210;
  const void *v211;
  uint64_t v212;
  _BOOL4 v213;
  const _CFURLCredential *v214;
  AuthenticationState *v215;
  HTTPResponseMessage *v216;
  std::__shared_weak_count *v217;
  unint64_t *v218;
  unint64_t v219;
  std::__shared_weak_count *v220;
  unint64_t *v221;
  unint64_t v222;
  std::__shared_weak_count *v223;
  unint64_t *v224;
  unint64_t v225;
  uint64_t v226;
  unint64_t v227;
  int v228;
  const __CFString *v229;
  char v230;
  const __CFString *v231;
  int v232;
  _BYTE *v233;
  CFDictionaryRef v234;
  uint64_t v235;
  std::__shared_weak_count *v236;
  uint64_t v237;
  std::__shared_weak_count *v238;
  uint64_t valuePtr;
  std::__shared_weak_count *v240;
  __int128 cf;
  _CFURLProtectionSpace *v242;
  std::__shared_weak_count *v243;
  CFStreamError error;
  void (*v245)(_QWORD *, std::__shared_weak_count_vtbl *, std::__shared_weak_count_vtbl *);
  void *v246;
  HTTPProtocol *v247;
  std::__shared_weak_count *v248;
  _CFURLProtectionSpace *v249;
  std::__shared_weak_count *v250;
  __int128 v251;
  uint64_t v252;

  v252 = *MEMORY[0x1E0C80C00];
  if (((*((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32)) & 0x4000000000) != 0)
    return 0;
  if ((*(unsigned int (**)(HTTPProtocol *))(*(_QWORD *)this + 520))(this))
    return 0;
  ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(a2);
  v8 = ResponseStatusCode;
  v9 = ResponseStatusCode == 407;
  if (ResponseStatusCode != 407 && ResponseStatusCode != 401)
    return 0;
  if (ResponseStatusCode == 407 || (v10 = *((_QWORD *)this + 34)) == 0)
  {
    v235 = 0;
    v236 = 0;
  }
  else
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v10 + 176))(&v235);
    if (v235)
    {
      v11 = *(_QWORD *)(v235 + 104);
      v12 = *(std::__shared_weak_count **)(v235 + 112);
      error.domain = v11;
      *(_QWORD *)&error.error = v12;
      if (v12)
      {
        p_shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          v14 = __ldxr(p_shared_owners);
        while (__stxr(v14 + 1, p_shared_owners));
      }
      v16 = v11
         && (*(_DWORD *)(v11 + 24) & 0xFFFFFFFE) == 2
         && (v15 = *(HTTPAuthentication **)(v11 + 8)) != 0
         && HTTPAuthentication::isConnectionBasedAuth(v15) != 0;
      if (v12)
      {
        v38 = (unint64_t *)&v12->__shared_owners_;
        do
          v39 = __ldaxr(v38);
        while (__stlxr(v39 - 1, v38));
        if (!v39)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      if (v16)
      {
        EndpointCred = (const void *)AuthenticationState::getEndpointCred(*(AuthenticationState **)(v235 + 104), *(std::__shared_weak_count **)(v235 + 112));
        if (EndpointCred)
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v41 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            v42 = *((_QWORD *)this + 99);
            LODWORD(error.domain) = 138543362;
            *(CFIndex *)((char *)&error.domain + 4) = v42;
            _os_log_impl(&dword_183ECA000, v41, OS_LOG_TYPE_DEFAULT, "%{public}@ will use existing endpoint credentials", (uint8_t *)&error, 0xCu);
          }
          setTypeProperty<_CFURLCredential const*>((CFTypeRef *)this + 44, EndpointCred);
          _ZNSt3__115allocate_sharedB8nn180100I19AuthenticationStateNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((std::__shared_weak_count_vtbl **)&error);
          std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 776, (__int128 *)&error.domain);
          std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&error);
          v43 = *((_QWORD *)this + 97);
          v44 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 35) + 88))(*((_QWORD *)this + 35));
          AuthenticationState::setConnectionType(v43, v44);
          v45 = *((_QWORD *)this + 97);
          if (a2)
          {
            if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
              dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
            if (*((_BYTE *)a2 + 40))
              v46 = (char *)a2 + 16;
            else
              v46 = 0;
          }
          else
          {
            v46 = 0;
          }
          (*(void (**)(uint64_t, char *, _QWORD))(*(_QWORD *)v45 + 16))(v45, v46, 0);
          (*(void (**)(_QWORD))(**((_QWORD **)this + 34) + 184))(*((_QWORD *)this + 34));
LABEL_179:
          v4 = 1;
          goto LABEL_422;
        }
      }
    }
  }
  v18.n128_f64[0] = gotLoadHelper_x8__SOErrorDomain(v7);
  v20 = *(_QWORD *)(v19 + 1776);
  v21 = v21 || v20 == 0;
  if (v21 || v8 != 401 || *((_BYTE *)this + 856))
  {
    if (v8 == 407)
    {
      v22 = CFHTTPMessageGetResponseStatusCode(a2) == 407;
      Authentication = (_CFHTTPAuthentication *)_CFHTTPMessageGetAuthentication(a2, v22);
      if (Authentication)
      {
        CFHTTPAuthenticationIsValid(Authentication, &error);
      }
      else
      {
        error.error = 0;
        error.domain = 0;
      }
    }
  }
  else
  {
    v24 = *((_QWORD *)this + 35);
    if (!v24
      || (v25 = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, __n128))(*(_QWORD *)v24 + 64))(v24, v18)) == 0
      || (Value = (const __CFBoolean *)CFDictionaryGetValue(v25, &unk_1EDCFA790), (v27 = Value) == 0)
      || (v28 = CFGetTypeID(Value), v28 != CFBooleanGetTypeID())
      || !CFBooleanGetValue(v27))
    {
      v29 = (void *)*((_QWORD *)this + 11);
      if (v29)
      {
        v30 = (const __CFString *)objc_msgSend(v29, "cfURL", v18.n128_f64[0]);
        if (v30)
        {
          v31 = objc_msgSend((id)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration"), "_sourceApplicationAuditTokenData");
          if (AppSSO::shouldManageURL(*((AppSSO **)this + 99), v30, (const __CFURL *)0x191, v31, v32, v33))
          {
            v34 = CFGetAllocator((char *)this - 16);
            v35 = CFURLResponseCreateWithHTTPResponse((uint64_t)v34, v30, (uint64_t)a2, 0);
            *(_QWORD *)&v251 = v35;
            v36 = (_QWORD *)operator new();
            *v36 = &off_1E14F1550;
            v36[1] = 0;
            v36[2] = 0;
            v36[3] = v35;
            *((_QWORD *)&v251 + 1) = v36;
            if (a2)
              v37 = (_CFURLProtectionSpace *)CFRetain(a2);
            else
              v37 = 0;
            v242 = v37;
            v112 = (std::__shared_weak_count *)operator new();
            v112->__shared_owners_ = 0;
            v113 = (unint64_t *)&v112->__shared_owners_;
            v112->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1630;
            v112->__shared_weak_owners_ = 0;
            v112[1].__vftable = (std::__shared_weak_count_vtbl *)v37;
            v243 = v112;
            v234 = CFHTTPMessageCopyAllHeaderFields(a2);
            CFRetain((char *)this - 16);
            *(_QWORD *)&cf = this;
            v114 = (std::__shared_weak_count *)operator new();
            v114->__shared_owners_ = 0;
            v115 = (unint64_t *)&v114->__shared_owners_;
            v114->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F10F0;
            v114->__shared_weak_owners_ = 0;
            v114[1].__vftable = (std::__shared_weak_count_vtbl *)this;
            *((_QWORD *)&cf + 1) = v114;
            v116 = objc_msgSend((id)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration"), "_sourceApplicationBundleIdentifier");
            v117 = (std::__shared_weak_count *)*((_QWORD *)this + 100);
            valuePtr = *((_QWORD *)this + 99);
            v240 = v117;
            if (v117)
            {
              v118 = (unint64_t *)&v117->__shared_owners_;
              do
                v119 = __ldxr(v118);
              while (__stxr(v119 + 1, v118));
            }
            v120 = *((_QWORD *)this + 41);
            error.domain = MEMORY[0x1E0C809B0];
            *(_QWORD *)&error.error = 3321888768;
            v245 = ___ZN12HTTPProtocol17askAppSSOForCredsElP15__CFHTTPMessage_block_invoke;
            v246 = &__block_descriptor_64_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE_e40_v24__0____CFDictionary__8____CFError__16l;
            v247 = this;
            v248 = v114;
            do
              v121 = __ldxr(v115);
            while (__stxr(v121 + 1, v115));
            v249 = v37;
            v250 = v112;
            do
              v122 = __ldxr(v113);
            while (__stxr(v122 + 1, v113));
            SmartBlockWithArgs<__CFDictionary const*,__CFError *>::SmartBlockWithArgs(&v237, &error);
            AppSSO::getAuthHeaders((AppSSO *)&valuePtr, (uint64_t)v30, (uint64_t)v234, v120, v31, v116, (uint64_t)&v237);
            v123 = v238;
            if (v238)
            {
              v124 = (unint64_t *)&v238->__shared_owners_;
              do
                v125 = __ldaxr(v124);
              while (__stlxr(v125 - 1, v124));
              if (!v125)
              {
                ((void (*)(std::__shared_weak_count *))v123->__on_zero_shared)(v123);
                std::__shared_weak_count::__release_weak(v123);
              }
            }
            v126 = v240;
            if (v240)
            {
              v127 = (unint64_t *)&v240->__shared_owners_;
              do
                v128 = __ldaxr(v127);
              while (__stlxr(v128 - 1, v127));
              if (!v128)
              {
                ((void (*)(std::__shared_weak_count *))v126->__on_zero_shared)(v126);
                std::__shared_weak_count::__release_weak(v126);
              }
            }
            v129 = *((_DWORD *)this + 48);
            v130 = *((_WORD *)this + 98);
            *((_DWORD *)this + 183) = 1;
            *((_DWORD *)this + 48) = v129;
            *((_WORD *)this + 98) = v130 | 0x600;
            v131 = v250;
            if (v250)
            {
              v132 = (unint64_t *)&v250->__shared_owners_;
              do
                v133 = __ldaxr(v132);
              while (__stlxr(v133 - 1, v132));
              if (!v133)
              {
                ((void (*)(std::__shared_weak_count *))v131->__on_zero_shared)(v131);
                std::__shared_weak_count::__release_weak(v131);
              }
            }
            v134 = v248;
            if (v248)
            {
              v135 = (unint64_t *)&v248->__shared_owners_;
              do
                v136 = __ldaxr(v135);
              while (__stlxr(v136 - 1, v135));
              if (!v136)
              {
                ((void (*)(std::__shared_weak_count *))v134->__on_zero_shared)(v134);
                std::__shared_weak_count::__release_weak(v134);
              }
            }
            v137 = (std::__shared_weak_count *)*((_QWORD *)&cf + 1);
            if (*((_QWORD *)&cf + 1))
            {
              v138 = (unint64_t *)(*((_QWORD *)&cf + 1) + 8);
              do
                v139 = __ldaxr(v138);
              while (__stlxr(v139 - 1, v138));
              if (!v139)
              {
                ((void (*)(std::__shared_weak_count *))v137->__on_zero_shared)(v137);
                std::__shared_weak_count::__release_weak(v137);
              }
            }
            if (v234)
              CFRelease(v234);
            v140 = v243;
            if (v243)
            {
              v141 = (unint64_t *)&v243->__shared_owners_;
              do
                v142 = __ldaxr(v141);
              while (__stlxr(v142 - 1, v141));
              if (!v142)
              {
                ((void (*)(std::__shared_weak_count *))v140->__on_zero_shared)(v140);
                std::__shared_weak_count::__release_weak(v140);
              }
            }
            v143 = (std::__shared_weak_count *)*((_QWORD *)&v251 + 1);
            if (*((_QWORD *)&v251 + 1))
            {
              v144 = (unint64_t *)(*((_QWORD *)&v251 + 1) + 8);
              do
                v145 = __ldaxr(v144);
              while (__stlxr(v145 - 1, v144));
              if (!v145)
              {
                ((void (*)(std::__shared_weak_count *))v143->__on_zero_shared)(v143);
                std::__shared_weak_count::__release_weak(v143);
              }
            }
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v80 = CFNLog::logger;
            v4 = 0;
            if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
              goto LABEL_422;
            v146 = *((_QWORD *)this + 99);
            LODWORD(error.domain) = 138543362;
            *(CFIndex *)((char *)&error.domain + 4) = v146;
            v82 = "%{public}@ will wait on AppSSO for creds";
            p_error = (uint8_t *)&error;
            goto LABEL_229;
          }
        }
      }
    }
  }
  v233 = (char *)this + 40;
  if (*((_BYTE *)this + 41))
    v47 = (unsigned __int8 *)&HTTPProtocol::inUnitTestMode;
  else
    v47 = (unsigned __int8 *)this + 40;
  v48 = *v47;
  KerberosAccountBroker = KerberosAccountBroker::getKerberosAccountBroker(*((KerberosAccountBroker **)this + 10), v17);
  v50 = 0;
  v232 = v9;
  if (v8 != 407 && KerberosAccountBroker)
    v50 = (*((_DWORD *)this + 48) & 0x8000000) == 0;
  for (i = 0; ; i = 1)
  {
    v52 = *((_QWORD *)this + 97);
    v53 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 35) + 88))(*((_QWORD *)this + 35));
    AuthenticationState::setConnectionType(v52, v53);
    AuthenticationState::setOption(*((_QWORD *)this + 97), 0, v48 != 0);
    AuthenticationState::setOption(*((_QWORD *)this + 97), 1, v50);
    AuthenticationState::setOption(*((_QWORD *)this + 97), 2, objc_msgSend((id)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration"), "_enableOAuthBearerTokenChallenges"));
    v54 = *((_QWORD *)this + 97);
    if (a2)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v55 = *((_BYTE *)a2 + 40) ? (char *)a2 + 16 : 0;
    }
    else
    {
      v55 = 0;
    }
    v56 = *((_QWORD *)this + 34);
    v57 = v56 ? (*(uint64_t (**)(uint64_t))(*(_QWORD *)v56 + 112))(v56) : 0;
    (*(void (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v54 + 16))(v54, v55, v57);
    if ((i & 1) != 0
      || AuthenticationState::isEmpty(*((AuthenticationState **)this + 97))
      || AuthenticationState::isValid(*((_QWORD *)this + 97), 0))
    {
      break;
    }
    if (v8 == 407 && (*((_DWORD *)this + 48) & 0x400000) == 0)
    {
      Auth = AuthenticationState::getAuth(*((AuthenticationState **)this + 97), 1);
      if (Auth)
      {
        if (*(_QWORD *)(Auth + 88) == 4 && *(_DWORD *)(Auth + 96) == 4294966295)
        {
          v59 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 648))(this);
          if (v59)
          {
            if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
              dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
            v60 = *(_QWORD *)(v59 + 40);
            if (v60)
            {
              v61 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)this + 87) + 80))(*((_QWORD *)this + 87), v60, *((_QWORD *)this + 10));
              if (v61)
              {
                (*(void (**)(_QWORD, const void *, uint64_t, _QWORD))(**((_QWORD **)this + 87) + 72))(*((_QWORD *)this + 87), v61, v60, *((_QWORD *)this + 10));
                CFRelease(v61);
              }
            }
          }
        }
      }
    }
    AuthenticationState::resetInvalid(*((AuthenticationState **)this + 97));
  }
  if (v8 == 407)
  {
    if (!(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this))
      goto LABEL_104;
  }
  else if (!*((_QWORD *)this + 44))
  {
    goto LABEL_104;
  }
  v62 = (AuthenticationState *)*((_QWORD *)this + 97);
  if (a2)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*((_BYTE *)a2 + 40))
      v63 = (__CFHTTPMessage *)((char *)a2 + 16);
    else
      v63 = 0;
  }
  else
  {
    v63 = 0;
  }
  if (v8 == 407)
    v64 = (const _CFURLCredential *)(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this);
  else
    v64 = (const _CFURLCredential *)*((_QWORD *)this + 44);
  AuthenticationState::updateState(v62, v63, 0, v64, *((__SecTrust **)this + 57));
LABEL_104:
  v65 = AuthenticationState::getAuth(*((AuthenticationState **)this + 97), v8 == 407);
  v67 = v65;
  if (!v65)
  {
LABEL_230:
    v4 = 0;
    goto LABEL_422;
  }
  v68 = URLProtectionSpace::authSchemeForAuth((URLProtectionSpace *)(v65 - 16), v66);
  v69 = v68;
  if (v68 == 9)
  {
    if (!*((_QWORD *)this + 44) && (*((_DWORD *)this + 48) & 0x40000000) != 0)
    {
      v70 = *(const __CFURL **)(objc_msgSend(*((id *)this + 11), "_inner") + 8);
      if (v70)
        v71 = CFURLCopyUserName(v70);
      else
        v71 = 0;
      v105 = (const __CFString *)HTTPAuthentication::copyRealm((HTTPAuthentication *)v67);
      v106 = CFGetAllocator((char *)this - 16);
      XMobileMeAuthToken = _CFURLCredentialCreateXMobileMeAuthToken((uint64_t)v106, v71, 0, v105);
      *((_QWORD *)this + 44) = XMobileMeAuthToken;
      if (XMobileMeAuthToken)
      {
        if (URLCredential::Class(void)::sOnce_URLCredential != -1)
          dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
        if (*(_DWORD *)(XMobileMeAuthToken + 48) != 4
          || !(*(unsigned int (**)(uint64_t))(*(_QWORD *)(XMobileMeAuthToken + 16) + 144))(XMobileMeAuthToken + 16))
        {
          v108 = (const void *)*((_QWORD *)this + 44);
          *((_QWORD *)this + 44) = 0;
          if (v108)
            CFRelease(v108);
        }
      }
      else
      {
        *((_QWORD *)this + 44) = 0;
      }
      v110 = *((_DWORD *)this + 48);
      v109 = (char *)this + 192;
      v111 = *((_WORD *)v109 + 2);
      *(_DWORD *)v109 = v110 & 0xBFFFFFFF;
      *((_WORD *)v109 + 2) = v111;
      if (v71)
        CFRelease(v71);
      if (v105)
        CFRelease(v105);
      goto LABEL_179;
    }
LABEL_121:
    if (!AuthenticationState::isValid(*((_QWORD *)this + 97), 0))
    {
      v85 = 0;
      *((_DWORD *)this + 48) |= 0x40000u;
LABEL_421:
      v4 = v85;
      goto LABEL_422;
    }
    v251 = 0uLL;
    if (v8 == 407
      || !(*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 35) + 88))(*((_QWORD *)this + 35))
      || (*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 35) + 88))(*((_QWORD *)this + 35)) == 1)
    {
      v84 = (const void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 35) + 72))(*((_QWORD *)this + 35));
      if (v84)
        v231 = (const __CFString *)CFRetain(v84);
      else
        v231 = 0;
      v228 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 35) + 80))(*((_QWORD *)this + 35));
      v86 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 35) + 88))(*((_QWORD *)this + 35));
      v87 = (const __CFDictionary *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 35) + 64))(*((_QWORD *)this + 35));
    }
    else
    {
      v101 = *(const __CFURL **)(objc_msgSend(*((id *)this + 11), "_inner") + 8);
      v86 = connectionTypeFromURL(v101);
      v231 = CFURLCopyHostName(v101);
      v102 = CFURLGetPortNumber(v101);
      v87 = 0;
      if (v86)
        v103 = 443;
      else
        v103 = 80;
      if (v102 != -1)
        v103 = v102;
      v228 = v103;
    }
    v229 = 0;
    if (*v233)
      v88 = v69 == 6;
    else
      v88 = 0;
    v89 = !v88;
    v230 = v89;
    if (v69 == 9 && *v233)
    {
      v229 = (const __CFString *)HTTPAuthentication::copyRealm((HTTPAuthentication *)v67);
      v230 = 0;
    }
    if ((v86 - 1) > 3)
      v90 = 1;
    else
      v90 = dword_1841E3AA0[v86 - 1];
    v91 = HTTPAuthentication::copyRealm((HTTPAuthentication *)v67);
    v92 = (const __CFString *)v91;
    v242 = 0;
    v243 = 0;
    if (v90 == 6)
    {
      LODWORD(valuePtr) = 0;
      v93 = (const __CFDictionary *)CFDictionaryGetValue(v87, &unk_1EDD003E0);
      v94 = v93;
      if (v93
        && (v95 = (const __CFString *)CFDictionaryGetValue(v93, &unk_1EDD00418),
            v96 = (const __CFNumber *)CFDictionaryGetValue(v94, &unk_1EDD00450),
            CFNumberGetValue(v96, kCFNumberSInt32Type, &valuePtr),
            v95))
      {
        v97 = valuePtr;
        v98 = v231;
      }
      else
      {
        v97 = v228;
        LODWORD(valuePtr) = v228;
        v98 = v231;
        v95 = v231;
      }
      v100 = v95;
      v99 = v92;
      HTTPAuthentication::buildProtectionSpacesFromAuthSchemes((CFArrayRef *)&cf, v67 - 16, v100, v97, 6, v92);
      std::shared_ptr<__CFArray const>::operator=[abi:nn180100]<__CFArray const,Deleter_CFRelease,void>(&v251, (uint64_t *)&cf);
      if ((_QWORD)cf)
        CFRelease((CFTypeRef)cf);
      if ((_QWORD)v251)
      {
        if (!CFArrayGetValueAtIndex((CFArrayRef)v251, 0))
        {
          v104 = 0;
LABEL_238:
          *(_QWORD *)&cf = v104;
          v148 = (_QWORD *)operator new();
          *v148 = &off_1E14F1780;
          v148[1] = 0;
          v148[2] = 0;
          v148[3] = v104;
          *((_QWORD *)&cf + 1) = v148;
          std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)&v242, &cf);
          std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&cf);
          v99 = v92;
          goto LABEL_239;
        }
LABEL_236:
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v251, 0);
        v104 = CFRetain(ValueAtIndex);
        goto LABEL_238;
      }
    }
    else
    {
      v99 = (const __CFString *)v91;
      if (!v91)
      {
        if (v69 == 12 || v69 == 10)
          v99 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &stru_1E1500C68);
        else
          v99 = 0;
      }
      HTTPAuthentication::buildProtectionSpacesFromAuthSchemes((CFArrayRef *)&cf, v67 - 16, v231, v228, v90, v99);
      std::shared_ptr<__CFArray const>::operator=[abi:nn180100]<__CFArray const,Deleter_CFRelease,void>(&v251, (uint64_t *)&cf);
      v98 = v231;
      if ((_QWORD)cf)
        CFRelease((CFTypeRef)cf);
      if ((_QWORD)v251)
      {
        v92 = v99;
        if (!CFArrayGetValueAtIndex((CFArrayRef)v251, 0))
        {
          v104 = 0;
          goto LABEL_238;
        }
        goto LABEL_236;
      }
    }
LABEL_239:
    if (v98)
      CFRelease(v98);
    if (v99)
      CFRelease(v99);
    v149 = v99;
    v150 = *(unsigned __int8 *)(v67 + 224);
    v151 = v242;
    if (v8 == 407)
    {
      if (v242)
      {
        v152 = v232;
        if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
          dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
        v153 = *((_DWORD *)v151 + 18) == 6;
      }
      else
      {
        v153 = 0;
        v152 = v232;
      }
      if (v69 != 6 && !v153)
      {
        if ((*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this))
        {
          v155 = *((_QWORD *)this + 43);
          if (v155 != 0x7FFFFFFFFFFFFFFFLL)
            *((_QWORD *)this + 43) = v155 + 1;
        }
        if (a2)
          v156 = CFRetain(a2);
        else
          v156 = 0;
        v164 = (const void *)*((_QWORD *)this + 42);
        *((_QWORD *)this + 42) = v156;
        if (v164)
          CFRelease(v164);
        if ((v230 & 1) == 0)
        {
          v172 = CFGetAllocator((char *)this - 16);
          v166 = (const void *)CFURLCredentialCreate((uint64_t)v172, &stru_1E1500C68, &stru_1E1500C68, v173, 1);
          (*(void (**)(HTTPProtocol *, const void *))(*(_QWORD *)this + 624))(this, v166);
          if (v166)
          {
            CFRelease(v166);
            LODWORD(v166) = 0;
          }
          goto LABEL_282;
        }
        if ((*(unsigned int (**)(HTTPProtocol *))(*(_QWORD *)this + 664))(this))
          goto LABEL_273;
        (*(void (**)(HTTPProtocol *, _CFURLProtectionSpace *))(*(_QWORD *)this + 632))(this, v242);
        v183 = (void *)*((_QWORD *)this + 10);
        if (v183 && objc_msgSend(v183, "_preventsSystemHTTPProxyAuthentication"))
        {
          if ((*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this))
            (*(void (**)(HTTPProtocol *, _QWORD))(*(_QWORD *)this + 624))(this, 0);
          goto LABEL_273;
        }
        v199 = *((_QWORD *)this + 46);
        if (v199 && (v200 = *(_CFURLProtectionSpace **)(v199 + 48)) != 0 && !*((_QWORD *)this + 43))
        {
          AuthBrokerAgentClient::cachedProxyCredentialForProtectionSpace((AuthBrokerAgentClient *)&cf, v200);
          v226 = cf;
          if ((_QWORD)cf)
          {
            (*(void (**)(HTTPProtocol *, _QWORD))(*(_QWORD *)this + 608))(this, cf);
            *((_DWORD *)this + 48) |= 0x400000u;
            (*(void (**)(uint64_t))(*(_QWORD *)v226 + 48))(v226);
            goto LABEL_429;
          }
        }
        else
        {
          *(_QWORD *)&cf = 0;
        }
        if (HTTPProtocol::asynchronouslyQueryAuthBroker(this))
        {
LABEL_273:
          LODWORD(v166) = 0;
LABEL_274:
          v167 = *((_QWORD *)this + 46);
          if (v167)
          {
            v168 = *(_QWORD *)(v167 + 40);
            if (v168)
            {
              v169 = *(_QWORD *)(v168 + 32);
              if (v169)
              {
                v170 = URLCredential_PasswordBased::safelyCast(v169, v165);
                if (v170
                  && (v171 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v170 + 128))(v170)) != 0)
                {
                  CFRelease(v171);
                }
                else
                {
                  (*(void (**)(_QWORD))(**((_QWORD **)this + 46) + 48))(*((_QWORD *)this + 46));
                  *((_QWORD *)this + 46) = 0;
                }
              }
            }
          }
LABEL_282:
          v174 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this);
          if ((_DWORD)v166 || !v174)
          {
            CFGetAllocator((char *)this - 16);
            v175 = objc_msgSend(*((id *)this + 11), "_inner");
            v176 = CFURLResponseCreateWithHTTPResponse(v175, *(const void **)(v175 + 8), (uint64_t)a2, 2);
            (*(void (**)(HTTPProtocol *, _QWORD))(*(_QWORD *)this + 640))(this, 0);
            v177 = CFGetAllocator((char *)this - 16);
            v178 = (const void *)CFURLAuthChallengeCreate((uint64_t)v177, v242, 0, *((_QWORD *)this + 43), v176, 0);
            if (v178)
            {
              (*(void (**)(HTTPProtocol *, const void *))(*(_QWORD *)this + 640))(this, v178);
              v179 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 648))(this);
              if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
                dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
              if (v179)
                v180 = (URLAuthChallenge *)(v179 + 16);
              else
                v180 = 0;
              URLAuthChallenge::setListOfProtectionSpaces(v180, (CFTypeRef)v251);
              CFRelease(v178);
            }

          }
          v85 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this) != 0;
LABEL_409:
          v4 = 1;
          v163 = 1;
          goto LABEL_410;
        }
        v201 = (const void *)(*(uint64_t (**)(_QWORD, _CFURLProtectionSpace *, _QWORD))(**((_QWORD **)this + 87)
                                                                                                + 80))(*((_QWORD *)this + 87), v242, *((_QWORD *)this + 10));
        (*(void (**)(HTTPProtocol *, const void *))(*(_QWORD *)this + 624))(this, v201);
        if (v201)
          CFRelease(v201);
LABEL_429:
        LODWORD(v166) = 1;
        goto LABEL_274;
      }
      v157 = HTTPProtocol::handleKerberosChallenge(this, v150, a2, v242, (const __CFArray *)v251, v152);
LABEL_267:
      v4 = v157;
      v163 = 0;
      v85 = v157;
LABEL_410:
      v217 = v243;
      if (v243)
      {
        v218 = (unint64_t *)&v243->__shared_owners_;
        do
          v219 = __ldaxr(v218);
        while (__stlxr(v219 - 1, v218));
        if (!v219)
        {
          ((void (*)(std::__shared_weak_count *))v217->__on_zero_shared)(v217);
          std::__shared_weak_count::__release_weak(v217);
        }
      }
      v220 = (std::__shared_weak_count *)*((_QWORD *)&v251 + 1);
      if (*((_QWORD *)&v251 + 1))
      {
        v221 = (unint64_t *)(*((_QWORD *)&v251 + 1) + 8);
        do
          v222 = __ldaxr(v221);
        while (__stlxr(v222 - 1, v221));
        if (!v222)
        {
          ((void (*)(std::__shared_weak_count *))v220->__on_zero_shared)(v220);
          std::__shared_weak_count::__release_weak(v220);
        }
      }
      if ((v163 & 1) == 0)
        goto LABEL_422;
      goto LABEL_421;
    }
    if (v242)
    {
      if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
        dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
      v154 = *((_DWORD *)v151 + 18) == 6;
    }
    else
    {
      v154 = 0;
    }
    if (v69 == 6 || v154)
    {
      v157 = HTTPProtocol::handleKerberosChallenge(this, v150, a2, v242, (const __CFArray *)v251, v232);
      goto LABEL_267;
    }
    v158 = objc_msgSend(*((id *)this + 11), "_inner");
    v161 = *(_QWORD *)(v158 + 8);
    if (v161)
      v162 = CFURLCopyUserName(*(CFURLRef *)(v158 + 8));
    else
      v162 = 0;
    if (*((_QWORD *)this + 44) && (*((_QWORD *)this + 47) || !*((_BYTE *)this + 41)))
    {
      if (v162)
        v181 = CFStringGetLength(v162) == 0;
      else
        v181 = 1;
      v184 = *((_QWORD *)this + 40);
      if (v184 != 0x7FFFFFFFFFFFFFFFLL)
        *((_QWORD *)this + 40) = v184 + 1;
      HTTPProtocol::RemoveCredentialPasswordForProtectionSpace(this, *((const _CFURLCredential **)this + 44), v242, v181);
      v182 = (const void *)*((_QWORD *)this + 44);
      *((_QWORD *)this + 44) = 0;
    }
    else
    {
      v182 = 0;
    }
    if (a2)
      v185 = CFRetain(a2);
    else
      v185 = 0;
    v186 = (const void *)*((_QWORD *)this + 39);
    *((_QWORD *)this + 39) = v185;
    if (v186)
      CFRelease(v186);
    if (v69 == 9)
    {
      v187 = *((_QWORD *)this + 40);
      if (v187 < 1 || !*((_QWORD *)this + 44))
        *((_DWORD *)this + 48) |= 0x40000000u;
      if (v182 && v187 == 1)
      {
        v188 = CFRetain(v182);
        v189 = *((unsigned int *)this + 48);
        *((_QWORD *)this + 44) = v188;
        v190 = v189 & 0xFFFFFFFFBFFFFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
        *((_DWORD *)this + 48) = v190;
        *((_WORD *)this + 98) = WORD2(v190);
      }
      if ((v230 & 1) == 0)
      {
        if (!*((_BYTE *)this + 41))
          goto LABEL_377;
        if (*v233 && v162 && v229)
        {
          if ((*((_DWORD *)this + 48) & 0x40000000) != 0)
          {
            v191 = CFGetAllocator((char *)this - 16);
            v192 = _CFURLCredentialCreateXMobileMeAuthToken((uint64_t)v191, v162, 0, v229);
            *((_QWORD *)this + 44) = v192;
            if (v192)
            {
              if (URLCredential::Class(void)::sOnce_URLCredential != -1)
                dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
              if (*(_DWORD *)(v192 + 48) != 4
                || !(*(unsigned int (**)(uint64_t))(*(_QWORD *)(v192 + 16) + 144))(v192 + 16))
              {
                v193 = (const void *)*((_QWORD *)this + 44);
                *((_QWORD *)this + 44) = 0;
                if (v193)
                  CFRelease(v193);
              }
            }
            else
            {
              *((_QWORD *)this + 44) = 0;
            }
            v227 = *((_DWORD *)this + 48) & 0xBFFFFFFF | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
            *((_DWORD *)this + 48) &= ~0x40000000u;
            *((_WORD *)this + 98) = WORD2(v227);
            goto LABEL_378;
          }
        }
        else if (!*v233)
        {
          goto LABEL_377;
        }
        v202 = (void *)*((_QWORD *)this + 10);
        if (v202)
          v203 = objc_msgSend(v202, "_prohibitAuthUI") ^ 1;
        else
          v203 = 1;
        *((_DWORD *)this + 48) |= 0x20000000u;
        v204 = *((_QWORD *)this + 44);
        if (v204 && (v205 = URLCredential_PasswordBased::safelyCast(v204, (const _CFURLCredential *)v159)) != 0)
          v206 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v205 + 128))(v205);
        else
          v206 = 0;
        HTTPProtocol::performAsyncCallout(this, v162, v206, v149, v203, a2, v160);
        if (v206)
          CFRelease(v206);
LABEL_377:
        if (!v162)
        {
LABEL_379:
          if (v229)
            CFRelease(v229);
          if (*((_QWORD *)this + 44) && !*((_BYTE *)this + 41) && *((uint64_t *)this + 40) < 1)
            goto LABEL_395;
          CFGetAllocator((char *)this - 16);
          v207 = objc_msgSend(*((id *)this + 11), "_inner");
          v208 = CFURLResponseCreateWithHTTPResponse(v207, *(const void **)(v207 + 8), (uint64_t)a2, 2);
          v209 = (const void *)*((_QWORD *)this + 47);
          if (v209)
            CFRelease(v209);
          v210 = CFGetAllocator((char *)this - 16);
          v211 = *((_QWORD *)this + 44) ? (const void *)*((_QWORD *)this + 44) : v182;
          v212 = CFURLAuthChallengeCreate((uint64_t)v210, v242, v211, *((_QWORD *)this + 40), v208, 0);
          *((_QWORD *)this + 47) = v212;
          if (v212)
          {
            if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
              dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
            URLAuthChallenge::setListOfProtectionSpaces((URLAuthChallenge *)(v212 + 16), (CFTypeRef)v251);
            v213 = 0;
          }
          else
          {
            v213 = *((_QWORD *)this + 44) != 0;
          }

          if (v213)
          {
LABEL_395:
            v85 = 1;
          }
          else
          {
            v214 = (const _CFURLCredential *)*((_QWORD *)this + 44);
            if (v214)
            {
              v215 = (AuthenticationState *)*((_QWORD *)this + 97);
              if (a2)
              {
                if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
                  dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
                if (*((_BYTE *)a2 + 40))
                  v216 = (__CFHTTPMessage *)((char *)a2 + 16);
                else
                  v216 = 0;
                v214 = (const _CFURLCredential *)*((_QWORD *)this + 44);
              }
              else
              {
                v216 = 0;
              }
              AuthenticationState::updateState(v215, v216, *((_QWORD *)this + 47), v214, *((__SecTrust **)this + 57));
            }
            v85 = 0;
          }
          if (v182)
            CFRelease(v182);
          goto LABEL_409;
        }
LABEL_378:
        CFRelease(v162);
        goto LABEL_379;
      }
    }
    else if ((v230 & 1) == 0)
    {
      if (v69 == 10 && *((_BYTE *)this + 41) && *v233 && v161)
        *((_QWORD *)this + 44) = (*(uint64_t (**)(_QWORD, _CFURLProtectionSpace *, _QWORD))(**((_QWORD **)this + 87) + 80))(*((_QWORD *)this + 87), v242, *((_QWORD *)this + 10));
      goto LABEL_377;
    }
    if (*v233)
    {
      if (v161)
      {
        v159 = v242;
        if (v242)
        {
          v194 = *((_QWORD *)this + 87);
          if (!v162)
          {
            if (v194)
              v194 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v194 + 80))(v194);
            *((_QWORD *)this + 44) = v194;
            if (!v194)
              goto LABEL_377;
LABEL_343:
            v198 = (const void *)URLCredential_PasswordBased::safelyCast(v194, (const _CFURLCredential *)v159);
            if (v198)
              v198 = (const void *)(*(uint64_t (**)(const void *))(*(_QWORD *)v198 + 128))(v198);
            if (!v198 && v69 != 9)
            {
              v198 = (const void *)*((_QWORD *)this + 44);
              *((_QWORD *)this + 44) = 0;
            }
            if (v198)
              CFRelease(v198);
            goto LABEL_377;
          }
          v195 = (const __CFDictionary *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v194 + 88))(v194);
          v196 = v195;
          if (v195)
          {
            v197 = CFDictionaryGetValue(v195, v162);
            if (v197)
              v197 = CFRetain(v197);
            *((_QWORD *)this + 44) = v197;
            CFRelease(v196);
          }
        }
      }
    }
    v194 = *((_QWORD *)this + 44);
    if (!v194)
      goto LABEL_377;
    goto LABEL_343;
  }
  if (v8 != 401)
    goto LABEL_121;
  if (*((_BYTE *)this + 857))
    goto LABEL_121;
  if (v68 != 11)
    goto LABEL_121;
  if (!HTTPConnectionCacheKey::isFirstPartyResource(*((HTTPConnectionCacheKey **)this + 35))
    && (objc_msgSend(*((id *)this + 11), "_allowPrivateAccessTokensForThirdParty") & 1) == 0)
  {
    Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher(v72);
    v75 = *(void **)(v74 + 2736);
    v76 = CFURLCopyHostName(*(CFURLRef *)(objc_msgSend(*((id *)this + 11), "_inner", Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher)+ 8));
    if (!objc_msgSend(v75, "checkOriginAllowedAsThirdParty:", (id)CFMakeCollectable(v76)))goto LABEL_121;
  }
  if (*((_QWORD *)this + 10))
  {
    v77 = (void *)*((_QWORD *)this + 11);
    v78 = *(__CFArray **)(v67 + 232);
    isFirstPartyResource = HTTPConnectionCacheKey::isFirstPartyResource(*((HTTPConnectionCacheKey **)this + 35));
    HTTPProtocol::askPATForCreds(this, a2, v78, !isFirstPartyResource, objc_msgSend(v77, "_allowPrivateAccessTokensForThirdParty"), *(const __CFURL **)(objc_msgSend(v77, "_inner") + 32));
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v80 = CFNLog::logger;
    v4 = 0;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      goto LABEL_422;
    v81 = *((_QWORD *)this + 99);
    LODWORD(v251) = 138543362;
    *(_QWORD *)((char *)&v251 + 4) = v81;
    v82 = "%{public}@ will wait on PAT for creds";
    p_error = (uint8_t *)&v251;
LABEL_229:
    _os_log_impl(&dword_183ECA000, v80, OS_LOG_TYPE_DEFAULT, v82, p_error, 0xCu);
    goto LABEL_230;
  }
  v4 = 0;
  *((_DWORD *)this + 48) |= 0x40000u;
LABEL_422:
  v223 = v236;
  if (v236)
  {
    v224 = (unint64_t *)&v236->__shared_owners_;
    do
      v225 = __ldaxr(v224);
    while (__stlxr(v225 - 1, v224));
    if (!v225)
    {
      ((void (*)(std::__shared_weak_count *))v223->__on_zero_shared)(v223);
      std::__shared_weak_count::__release_weak(v223);
    }
  }
  return v4;
}

void sub_184072A24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, CFTypeRef cf, char a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,CFTypeRef a21,uint64_t a22,char a23,uint64_t a24,char a25)
{
  uint64_t v25;
  uint64_t v26;

  a21 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)v25 + 48))(v25);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a23);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v26 - 112);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void setTypeProperty<_CFURLCredential const*>(CFTypeRef *a1, CFTypeRef cf)
{
  CFRetain(cf);
  if (*a1)
    CFRelease(*a1);
  *a1 = cf;
}

void HTTPProtocol::askPATForCreds(HTTPProtocol *this, __CFHTTPMessage *a2, __CFArray *a3, char a4, char a5, const __CFURL *a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  HTTPProtocol *v16;
  CFURLRef v17;
  _QWORD *v18;
  unint64_t *v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  const __CFData *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  int v27;
  unint64_t v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  char *v33;
  int v34;
  __int16 v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  uint64_t v48;
  char v49;
  char v50;
  const __CFArray *v51;
  const __CFURL *v52;
  HTTPProtocol *v53;
  const __CFURL *v54;
  _QWORD v55[5];
  std::__shared_weak_count *v56;
  __CFHTTPMessage *v57;
  std::__shared_weak_count *v58;
  uint64_t v59;
  std::__shared_weak_count *v60;
  __CFHTTPMessage *v61;
  uint64_t v62;
  _QWORD *(*v63)(_QWORD *, uint64_t);
  void *v64;
  HTTPProtocol **v65;
  uint64_t v66;
  HTTPProtocol *v67;
  HTTPProtocol **v68;
  uint64_t v69;
  void (*v70)(uint64_t, uint64_t);
  void (*v71)(uint64_t);
  uint64_t v72;

  v12 = *((_QWORD *)this + 93);
  if (v12 && (v13 = *((_QWORD *)this + 35)) != 0 && (v14 = *(_QWORD *)(v12 + 168)) != 0)
  {
    v15 = (const void *)*((_QWORD *)this + 3);
    v67 = 0;
    v68 = &v67;
    v69 = 0x3052000000;
    v70 = __Block_byref_object_copy_;
    v71 = __Block_byref_object_dispose_;
    v72 = 0;
    v61 = (__CFHTTPMessage *)MEMORY[0x1E0C809B0];
    v62 = 3221225472;
    v63 = ___ZN12XTubeManager22getPATTimestampsForKeyEPK22HTTPConnectionCacheKeyPK17CoreSchedulingSet_block_invoke;
    v64 = &unk_1E14FD7F0;
    v65 = &v67;
    v66 = v13;
    XTubeManager::withTubeManager(v14, v15, (uint64_t)&v61);
    v16 = v68[5];
    _Block_object_dispose(&v67, 8);
  }
  else
  {
    v16 = 0;
  }
  v17 = CFHTTPMessageCopyRequestURL(a2);
  CFRetain((char *)this - 16);
  v67 = this;
  v18 = (_QWORD *)operator new();
  v53 = v16;
  v18[1] = 0;
  v19 = v18 + 1;
  *v18 = &off_1E14F10F0;
  v18[2] = 0;
  v18[3] = this;
  v68 = (HTTPProtocol **)v18;
  if (a2)
    a2 = (__CFHTTPMessage *)CFRetain(a2);
  v61 = a2;
  v20 = (std::__shared_weak_count *)operator new();
  v49 = a5;
  v50 = a4;
  v51 = a3;
  v52 = a6;
  v54 = v17;
  v20->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v20->__shared_owners_;
  v20->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1630;
  v20->__shared_weak_owners_ = 0;
  v20[1].__vftable = (std::__shared_weak_count_vtbl *)a2;
  v62 = (uint64_t)v20;
  v48 = *((_QWORD *)this + 99);
  v22 = (const __CFData *)objc_msgSend((id)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration"), "_sourceApplicationAuditTokenData");
  v23 = objc_msgSend((id)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration"), "_sourceApplicationBundleIdentifier");
  v24 = *((_QWORD *)this + 3);
  if (*(_DWORD *)(v24 + 40) != 3)
    __assert_rtn("getDispatchQueue", "CoreSchedulingSet.h", 64, "fKind == eDispatchQueueBased");
  v25 = v23;
  v26 = *(void **)(v24 + 56);
  v27 = objc_msgSend((id)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration"), "_inPrivateBrowsing");
  v55[0] = MEMORY[0x1E0C809B0];
  v55[1] = 3321888768;
  v55[2] = ___ZN12HTTPProtocol14askPATForCredsEP15__CFHTTPMessageP9__CFArraybbPK7__CFURL_block_invoke;
  v55[3] = &__block_descriptor_64_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE_e40_v24__0____CFDictionary__8____CFError__16l;
  v55[4] = this;
  v56 = (std::__shared_weak_count *)v18;
  do
    v28 = __ldxr(v19);
  while (__stxr(v28 + 1, v19));
  v57 = a2;
  v58 = v20;
  do
    v29 = __ldxr(p_shared_owners);
  while (__stxr(v29 + 1, p_shared_owners));
  SmartBlockWithArgs<__CFDictionary const*,__CFError *>::SmartBlockWithArgs(&v59, v55);
  PrivateAccessTokens::getPATAuthHeaders(v48, v51, v22, v25, v54, v52, v26, v27, v50, v49, v53, &v59);
  v30 = v60;
  if (v60)
  {
    v31 = (unint64_t *)&v60->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  v34 = *((_DWORD *)this + 48);
  v33 = (char *)this + 192;
  v35 = *((_WORD *)v33 + 2);
  *((_DWORD *)v33 + 135) = 1;
  *(_DWORD *)v33 = v34;
  *((_WORD *)v33 + 2) = v35 | 0x3000;
  v36 = v58;
  if (v58)
  {
    v37 = (unint64_t *)&v58->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  v39 = v56;
  if (v56)
  {
    v40 = (unint64_t *)&v56->__shared_owners_;
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
  v42 = (std::__shared_weak_count *)v62;
  if (v62)
  {
    v43 = (unint64_t *)(v62 + 8);
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }
  v45 = (std::__shared_weak_count *)v68;
  if (v68)
  {
    v46 = (unint64_t *)(v68 + 1);
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  if (v54)
    CFRelease(v54);
}

void sub_184073020(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

BOOL connectionTypeFromURL(const __CFURL *a1)
{
  const __CFString *v1;
  CFComparisonResult v2;

  v1 = CFURLCopyScheme(a1);
  v2 = CFStringCompare(v1, (CFStringRef)&unk_1EDD00AE0, 1uLL);
  if (v1)
    CFRelease(v1);
  return v2 == kCFCompareEqualTo;
}

uint64_t HTTPProtocol::handleKerberosChallenge(HTTPProtocol *this, int a2, __CFHTTPMessage *a3, _CFURLProtectionSpace *a4, const __CFArray *a5, int a6)
{
  const void *v12;
  CFTypeRef v13;
  const void *v14;
  uint64_t *v15;
  const void *v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  id v20;
  CFAllocatorRef v21;
  uint64_t v22;
  const void *v23;
  uint64_t v24;
  NSURLSessionTask *v25;
  uint64_t KerberosAccountBroker;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  const void *v30;
  unint64_t v31;
  const void *v32;
  unint64_t v33;
  const void *v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  const __CFAllocator *v38;
  CFStringRef v39;
  const void *v40;
  CFTypeRef v41;
  CFTypeRef v42;
  const void *v43;
  CFTypeRef v45;
  CFTypeRef cf;
  _QWORD v47[5];
  char v48;
  __int128 buf;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (a6)
  {
    if ((*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 648))(this))
    {
      v12 = (const void *)(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 648))(this);
      v13 = CFRetain(v12);
    }
    else
    {
      v13 = 0;
    }
    v15 = (uint64_t *)((char *)this + 344);
    if ((*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this))
    {
      v16 = (const void *)(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this);
      goto LABEL_11;
    }
LABEL_13:
    cf = 0;
    if (!v13)
      goto LABEL_16;
    goto LABEL_14;
  }
  v14 = (const void *)*((_QWORD *)this + 47);
  if (v14)
    v13 = CFRetain(v14);
  else
    v13 = 0;
  v15 = (uint64_t *)((char *)this + 320);
  v16 = (const void *)*((_QWORD *)this + 44);
  if (!v16)
    goto LABEL_13;
LABEL_11:
  cf = CFRetain(v16);
  if (!v13)
    goto LABEL_16;
LABEL_14:
  if (*v15 != 0x7FFFFFFFFFFFFFFFLL)
    ++*v15;
LABEL_16:
  v45 = v13;
  if (*((_BYTE *)this + 40) && *v15 <= 1)
  {
    if (HTTPAuthentication::isSafariProcess(void)::onceToken != -1)
      dispatch_once(&HTTPAuthentication::isSafariProcess(void)::onceToken, &__block_literal_global_2_7921);
    if (HTTPAuthentication::isSafariProcess(void)::isSafari)
      v17 = a2 == 0;
    else
      v17 = *((_BYTE *)this + 41) == 0;
    v18 = v17;
  }
  else
  {
    v18 = 0;
  }
  CFGetAllocator((char *)this - 16);
  v19 = objc_msgSend(*((id *)this + 11), "_inner");
  v20 = CFURLResponseCreateWithHTTPResponse(v19, *(const void **)(v19 + 8), (uint64_t)a3, 2);
  v21 = CFGetAllocator((char *)this - 16);
  v22 = CFURLAuthChallengeCreate((uint64_t)v21, a4, cf, *v15, v20, 0);
  if (v22)
  {
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
    URLAuthChallenge::setListOfProtectionSpaces((URLAuthChallenge *)(v22 + 16), a5);
  }
  if (a6)
  {
    (*(void (**)(HTTPProtocol *, uint64_t))(*(_QWORD *)this + 640))(this, v22);
  }
  else
  {
    v23 = (const void *)*((_QWORD *)this + 47);
    if (v23)
      CFRelease(v23);
    *((_QWORD *)this + 47) = v22;
    if (v22)
      CFRetain((CFTypeRef)v22);
  }
  v24 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 592))(this);
  if (a2 || v24)
  {
    KerberosAccountBroker = KerberosAccountBroker::getKerberosAccountBroker(*((KerberosAccountBroker **)this + 10), v25);
    if (KerberosAccountBroker)
    {
      v27 = (_QWORD *)KerberosAccountBroker;
      if (a6)
      {
        if ((*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this)
          && (v28 = *((unsigned int *)this + 48), (v28 & 0x1000000) != 0))
        {
          v31 = v28 & 0xFFFFFFFFFEFFFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
          *((_DWORD *)this + 48) = v28 & 0xFEFFFFFF;
          *((_WORD *)this + 98) = WORD2(v31);
        }
        else
        {
          (*(void (**)(HTTPProtocol *, _QWORD))(*(_QWORD *)this + 624))(this, 0);
        }
        CFRetain((char *)this - 16);
        v32 = (const void *)(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this);
      }
      else
      {
        v29 = *((unsigned int *)this + 48);
        if ((v29 & 0x800000) != 0)
        {
          v33 = v29 & 0xFFFFFFFFFF7FFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
          *((_DWORD *)this + 48) = v29 & 0xFF7FFFFF;
          *((_WORD *)this + 98) = WORD2(v33);
        }
        else
        {
          v30 = (const void *)*((_QWORD *)this + 44);
          *((_QWORD *)this + 44) = 0;
          if (v30)
            CFRelease(v30);
        }
        CFRetain((char *)this - 16);
        v32 = (const void *)*((_QWORD *)this + 44);
      }
      v34 = (const void *)objc_msgSend(*((id *)this + 11), "cfURL", v45);
      v47[0] = MEMORY[0x1E0C809B0];
      v47[1] = 3221225472;
      v47[2] = ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke;
      v47[3] = &__block_descriptor_41_e27_v16__0___CFURLCredential__8l;
      v47[4] = this;
      v48 = a6;
      KerberosAccountBroker::getKerberosCredentialForURL(v27, v32, v34, (uint64_t)v47);
      *((_DWORD *)this + 48) |= 0x4000000u;
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v35 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(_QWORD *)((char *)&buf + 4) = this;
        _os_log_impl(&dword_183ECA000, v35, OS_LOG_TYPE_DEFAULT, "Waiting for Accounts to provide credential %p", (uint8_t *)&buf, 0xCu);
      }
      v36 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_63, 3);
      v37 = v36;
      if (v36
        && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v36 + 16))(v36, "Waiting for Accounts", 0))
      {
        v38 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        *(_QWORD *)&buf = &off_1E14E4818;
        v39 = CFStringCreateWithCString(v38, "Protocol", 0x8000100u);
        v50 = 0;
        v51 = 0;
        *((_QWORD *)&buf + 1) = v39;
        v40 = (const void *)(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 32))(this);
        (*(void (**)(uint64_t, _QWORD, const void *))(*(_QWORD *)v37 + 64))(v37, *((_QWORD *)&buf + 1), v40);
        if (v40)
          CFRelease(v40);
        AutoString::~AutoString((AutoString *)&buf);
        (*(void (**)(uint64_t))(*(_QWORD *)v37 + 8))(v37);
      }
      HTTPProtocol::destroyReadStream(this);
      v18 = 0;
    }
  }
  if (a6)
  {
    if (a3)
      v41 = CFRetain(a3);
    else
      v41 = 0;
    v43 = (const void *)*((_QWORD *)this + 42);
    *((_QWORD *)this + 42) = v41;
    if (v43)
LABEL_68:
      CFRelease(v43);
  }
  else
  {
    if (a3)
      v42 = CFRetain(a3);
    else
      v42 = 0;
    v43 = (const void *)*((_QWORD *)this + 39);
    *((_QWORD *)this + 39) = v42;
    if (v43)
      goto LABEL_68;
  }
  if (v22)
    CFRelease((CFTypeRef)v22);
  if (v20)
    CFRelease(v20);
  if (cf)
    CFRelease(cf);
  if (v45)
    CFRelease(v45);
  return v18;
}

void sub_184073640(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef a9, CFTypeRef cf, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  const void *v17;
  const void *v18;

  if (v18)
    CFRelease(v18);
  if (v17)
    CFRelease(v17);
  if (cf)
    CFRelease(cf);
  if (a9)
    CFRelease(a9);
  _Unwind_Resume(exception_object);
}

void HTTPProtocol::RemoveCredentialPasswordForProtectionSpace(HTTPProtocol *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, int a4)
{
  CFAllocatorRef v7;
  const __CFString *Username;
  uint64_t v9;
  uint64_t v10;
  const void *v11;
  uint64_t v12;

  v7 = CFGetAllocator((char *)this - 16);
  Username = (const __CFString *)CFURLCredentialGetUsername((uint64_t)a2);
  v10 = CFURLCredentialCreate((uint64_t)v7, Username, 0, v9, 2);
  if (v10)
  {
    v11 = (const void *)v10;
    v12 = 56;
    if (!a4)
      v12 = 64;
    (*(void (**)(void))(**((_QWORD **)this + 87) + v12))();
    CFRelease(v11);
  }
}

void HTTPProtocol::performAsyncCallout(HTTPProtocol *this, const __CFString *a2, const __CFString *a3, const __CFString *a4, unsigned __int8 a5, __CFHTTPMessage *a6, double a7)
{
  uint64_t v8;
  __CFHTTPMessage *v9;
  double Helper_x8__kAOSAuthTrustInfoKey;
  uint64_t v11;
  _QWORD *v12;
  BOOL v13;
  __CFHTTPMessage *v14;
  void *v15;
  const __CFAllocator *v16;
  CFDictionaryRef v17;
  uint64_t delayInitStub;
  const void *v19;
  BOOL v20;
  int v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  uint64_t v25;
  const void *inited;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  NSObject *v33;
  uint64_t v34;
  _QWORD v35[6];
  std::__shared_weak_count *v36;
  void *values;
  std::__shared_weak_count *v38;
  _BYTE keys[24];
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  Helper_x8__kAOSAuthTrustInfoKey = gotLoadHelper_x8__kAOSAuthTrustInfoKey(a7);
  v12 = *(_QWORD **)(v11 + 2112);
  if (v12)
    v13 = v8 == 0;
  else
    v13 = 1;
  if (!v13)
  {
    v14 = v9;
    v15 = (void *)*((_QWORD *)this + 57);
    v16 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (v15)
    {
      *(_QWORD *)keys = *v12;
      values = v15;
      v17 = CFDictionaryCreate(v16, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
    }
    else
    {
      v17 = 0;
    }
    delayInitStub = AOSAccountCreate_delayInitStub(Helper_x8__kAOSAuthTrustInfoKey);
    v19 = (const void *)delayInitStub;
    if (v14)
      v20 = delayInitStub == 0;
    else
      v20 = 1;
    v21 = v20;
    if (v20)
      goto LABEL_29;
    CFHTTPMessageCopyRequestURL(v14);
    v42 = 0;
    v41 = 0u;
    v40 = 0u;
    *(_OWORD *)&keys[8] = 0u;
    *(_QWORD *)keys = 1;
    CFRetain((char *)this - 16);
    values = this;
    v22 = (std::__shared_weak_count *)operator new();
    v22->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    v22->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F10F0;
    v22->__shared_weak_owners_ = 0;
    v22[1].__vftable = (std::__shared_weak_count_vtbl *)this;
    v38 = v22;
    v35[0] = MEMORY[0x1E0C809B0];
    v35[1] = 3321888768;
    v35[2] = ___ZN12HTTPProtocol19performAsyncCalloutEPK10__CFStringS2_S2_hP15__CFHTTPMessage_block_invoke;
    v35[3] = &__block_descriptor_56_e8_40c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e26_v16__0__AOSTransactionC__8l;
    v35[4] = this;
    v35[5] = this;
    v36 = v22;
    do
      v24 = __ldxr(p_shared_owners);
    while (__stxr(v24 + 1, p_shared_owners));
    *((_QWORD *)&v41 + 1) = v35;
    v25 = *((_QWORD *)this + 3);
    if (*(_DWORD *)(v25 + 40) != 3)
      __assert_rtn("getDispatchQueue", "CoreSchedulingSet.h", 64, "fKind == eDispatchQueueBased");
    v42 = *(_QWORD *)(v25 + 56);
    inited = (const void *)_AOSAccountResolveAuthFailure_delayInitStub(COERCE_DOUBLE(3321888768));
    if (inited)
      CFRelease(inited);
    CFRelease(v19);
    v27 = v36;
    if (v36)
    {
      v28 = (unint64_t *)&v36->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    v30 = v38;
    if (!v38)
      goto LABEL_29;
    v31 = (unint64_t *)&v38->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (v32)
    {
LABEL_29:
      if (!v17)
        goto LABEL_31;
    }
    else
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
      if (!v17)
      {
LABEL_31:
        if (!v21)
          return;
        goto LABEL_32;
      }
    }
    CFRelease(v17);
    goto LABEL_31;
  }
LABEL_32:
  *((_DWORD *)this + 48) &= 0xDFFFFFFB;
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v33 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    v34 = *((_QWORD *)this + 99);
    *(_DWORD *)keys = 138543362;
    *(_QWORD *)&keys[4] = v34;
    _os_log_error_impl(&dword_183ECA000, v33, OS_LOG_TYPE_ERROR, "%{public}@ AOS authentication failed, canceling auth", keys, 0xCu);
  }
  HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFC0CLL);
}

void sub_184073AB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

char *HTTPProtocol::asynchronouslyQueryAuthBroker(HTTPProtocol *this)
{
  AuthBrokerAgentClient *v2;
  char *v3;
  NSObject *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  uint64_t v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const __CFAllocator *v23;
  CFStringRef v24;
  const void *v25;
  uint64_t v27;
  _QWORD v28[6];
  std::__shared_weak_count *v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  __int128 buf;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v2 = (AuthBrokerAgentClient *)(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 656))(this);
  v3 = AuthBrokerAgentClient::AuthBrokerIsAvailable(v2);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v4 = CFNLog::logger;
  if ((_DWORD)v3)
  {
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *((_QWORD *)this + 99);
      LODWORD(buf) = 138543362;
      *(_QWORD *)((char *)&buf + 4) = v5;
      _os_log_impl(&dword_183ECA000, v4, OS_LOG_TYPE_DEFAULT, "%{public}@ querying AuthBrokerAgent", (uint8_t *)&buf, 0xCu);
    }
    CFRetain((char *)this - 16);
    *(_QWORD *)&buf = this;
    v6 = (std::__shared_weak_count *)operator new();
    v6->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    v6->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F10F0;
    v6->__shared_weak_owners_ = 0;
    v6[1].__vftable = (std::__shared_weak_count_vtbl *)this;
    *((_QWORD *)&buf + 1) = v6;
    v8 = *((_QWORD *)this + 46);
    v28[0] = MEMORY[0x1E0C809B0];
    v28[1] = 3321888768;
    v28[2] = ___ZN12HTTPProtocol29asynchronouslyQueryAuthBrokerEv_block_invoke;
    v28[3] = &__block_descriptor_56_e8_40c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e77_v16__0__NetworkProxyCredential________CFAllocator_i______CFURLCredential_iQ_8l;
    v28[4] = this;
    v28[5] = this;
    v29 = v6;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    SmartBlockWithArgs<NetworkProxyCredential *>::SmartBlockWithArgs(&v30, v28);
    AuthBrokerAgentClient::FetchProxyCredentials(v8, &v30);
    v10 = v31;
    if (v31)
    {
      v11 = (unint64_t *)&v31->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    v13 = *((unsigned int *)this + 48);
    v14 = v13 | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
    *((_DWORD *)this + 48) = v13 | 0x200000;
    if ((v14 & 0x8000000000) == 0)
      HTTPProtocol::destroyReadStream(this);
    (*(void (**)(HTTPProtocol *, _QWORD))(*(_QWORD *)this + 608))(this, 0);
    v15 = v29;
    if (v29)
    {
      v16 = (unint64_t *)&v29->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    v18 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
    if (*((_QWORD *)&buf + 1))
    {
      v19 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v27 = *((_QWORD *)this + 99);
      LODWORD(buf) = 138543362;
      *(_QWORD *)((char *)&buf + 4) = v27;
      _os_log_error_impl(&dword_183ECA000, v4, OS_LOG_TYPE_ERROR, "Failed to query AuthBrokerAgent %{public}@", (uint8_t *)&buf, 0xCu);
    }
    v21 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_53, 3);
    v22 = v21;
    if (v21
      && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v21 + 16))(v21, "Failed to query AuthBrokerAgent", 0))
    {
      v23 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      *(_QWORD *)&buf = &off_1E14E4818;
      v24 = CFStringCreateWithCString(v23, "Protocol", 0x8000100u);
      v33 = 0;
      v34 = 0;
      *((_QWORD *)&buf + 1) = v24;
      v25 = (const void *)(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 32))(this);
      (*(void (**)(uint64_t, _QWORD, const void *))(*(_QWORD *)v22 + 64))(v22, *((_QWORD *)&buf + 1), v25);
      if (v25)
        CFRelease(v25);
      AutoString::~AutoString((AutoString *)&buf);
      (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
    }
  }
  return v3;
}

void sub_184073E64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void ___ZN12HTTPProtocol29asynchronouslyQueryAuthBrokerEv_block_invoke(_QWORD *a1, std::__shared_weak_count_vtbl *a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  _QWORD v24[6];
  std::__shared_weak_count *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  __int128 buf;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v4 = a1[4];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v5 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *(_QWORD *)(a1[5] + 792);
    LODWORD(buf) = 138543362;
    *(_QWORD *)((char *)&buf + 4) = v6;
    _os_log_impl(&dword_183ECA000, v5, OS_LOG_TYPE_DEFAULT, "AuthBrokerAgent query finished %{public}@", (uint8_t *)&buf, 0xCu);
  }
  if (a2)
    (*((void (**)(std::__shared_weak_count_vtbl *))a2->~__shared_weak_count + 5))(a2);
  *(_QWORD *)&buf = a2;
  v7 = (std::__shared_weak_count *)operator new();
  v7->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v7->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F17F0;
  v7->__shared_weak_owners_ = 0;
  v7[1].__vftable = a2;
  *((_QWORD *)&buf + 1) = v7;
  v9 = a1[5];
  v10 = *(_QWORD *)(v9 + 24);
  v24[0] = MEMORY[0x1E0C809B0];
  v24[1] = 3321888768;
  v24[2] = ___ZN12HTTPProtocol29asynchronouslyQueryAuthBrokerEv_block_invoke_44;
  v24[3] = &__block_descriptor_72_e8_40c50_ZTSNSt3__110shared_ptrI22NetworkProxyCredentialEE56c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e5_v8__0l;
  v24[4] = v4;
  v24[5] = a2;
  v25 = v7;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v12 = (std::__shared_weak_count *)a1[6];
  v26 = v9;
  v27 = v12;
  if (v12)
  {
    v13 = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v10 + 96))(v10, v24);
  v15 = v27;
  if (v27)
  {
    v16 = (unint64_t *)&v27->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v25;
  if (v25)
  {
    v19 = (unint64_t *)&v25->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
  if (*((_QWORD *)&buf + 1))
  {
    v22 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
}

void sub_18407410C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3 - 64);
  _Unwind_Resume(a1);
}

uint64_t ___ZN12HTTPProtocol29asynchronouslyQueryAuthBrokerEv_block_invoke_52@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 1219;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN12HTTPProtocol29asynchronouslyQueryAuthBrokerEv_block_invoke_44(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const __CFAllocator *v9;
  uint64_t v10;
  CFStringRef v11;
  const __CFString *v12;
  uint64_t v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE v21[24];
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
    v4 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  else
    v4 = 0;
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v5 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *(_QWORD *)(v3 + 792);
    *(_DWORD *)v21 = 138412546;
    *(_QWORD *)&v21[4] = v4;
    *(_WORD *)&v21[12] = 2114;
    *(_QWORD *)&v21[14] = v6;
    _os_log_impl(&dword_183ECA000, v5, OS_LOG_TYPE_DEFAULT, "AuthBrokerAgent sent cred %@ %{public}@", v21, 0x16u);
  }
  v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_46_7189, 3);
  v8 = v7;
  if (v7
    && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v7 + 16))(v7, "AuthBrokerAgent Callback", 0))
  {
    v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v10 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)v21 = &off_1E14E4818;
    v11 = CFStringCreateWithCString(v9, "Protocol", 0x8000100u);
    v22 = 0;
    *(_OWORD *)&v21[8] = (unint64_t)v11;
    if (v10)
    {
      v12 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 32))(v10);
      v11 = *(CFStringRef *)&v21[8];
    }
    else
    {
      v12 = CFSTR("null");
    }
    (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v8 + 64))(v8, v11, v12);
    if (v10 && v12)
      CFRelease(v12);
    AutoString::~AutoString((AutoString *)v21);
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  }
  v13 = *(_QWORD *)(a1 + 56);
  v14 = *(_DWORD *)(v13 + 192);
  v13 += 192;
  v15 = *(_WORD *)(v13 + 4);
  *(_DWORD *)v13 = v14 & 0xFFDFFFFF;
  *(_WORD *)(v13 + 4) = v15;
  v16 = *(_QWORD *)(a1 + 56);
  if (((*(unsigned int *)(v16 + 192) | ((unint64_t)*(unsigned __int16 *)(v16 + 196) << 32)) & 0x4000000000) == 0
    && !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v16 + 520))(v16))
  {
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 56) + 608))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 40));
    if (!*(_QWORD *)(a1 + 40))
      goto LABEL_26;
    if ((*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 56) + 648))(*(_QWORD *)(a1 + 56)))
    {
      *(_DWORD *)(*(_QWORD *)(a1 + 56) + 192) |= 0x400000u;
      v17 = *(_QWORD *)(a1 + 56);
      v18 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 32);
      v19 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v17 + 648))(v17);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v17 + 120))(v17, v18, v19);
      goto LABEL_19;
    }
    if (!*(_QWORD *)(a1 + 40))
LABEL_26:
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 56) + 672))(*(_QWORD *)(a1 + 56), 1);
    v20 = *(_QWORD *)(a1 + 56);
    if (((*(unsigned int *)(v20 + 192) | ((unint64_t)*(unsigned __int16 *)(v20 + 196) << 32)) & 0x8000000000) != 0)
    {
      HTTPProtocol::challengeDelegateOrFinishBrokeringProxyAuth((HTTPProtocol *)v20);
    }
    else
    {
      -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*(_QWORD *)(v20 + 832), 3, 0);
      HTTPProtocol::createAndOpenStream(*(HTTPProtocol **)(a1 + 56), 0);
    }
  }
LABEL_19:
  if (v4)
    CFRelease(v4);
}

void sub_184074494(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  const void *v9;

  AutoString::~AutoString((AutoString *)&a9);
  if (v9)
    CFRelease(v9);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_40c50_ZTSNSt3__110shared_ptrI22NetworkProxyCredentialEE56c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[8];
  result[7] = a2[7];
  result[8] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c50_ZTSNSt3__110shared_ptrI22NetworkProxyCredentialEE56c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 40;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 56);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void HTTPProtocol::challengeDelegateOrFinishBrokeringProxyAuth(HTTPProtocol *this)
{
  uint64_t v2;
  unint64_t v3;
  _CFURLAuthChallenge *v4;
  _CFURLAuthChallenge *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  char *v9;
  unsigned int v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;

  v2 = *((unsigned int *)this + 48);
  v3 = v2 | ((unint64_t)*((unsigned __int16 *)this + 98) << 32) | 0x10000000000;
  *((_DWORD *)this + 48) = v2;
  *((_WORD *)this + 98) = WORD2(v3);
  v4 = (_CFURLAuthChallenge *)(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 648))(this);
  if (v4)
  {
    v5 = v4;
    CFRetain(v4);
    HTTPProtocol::sendDidReceiveAuthChallenge(this, v5);
    CFRelease(v5);
  }
  else
  {
    *((_DWORD *)this + 48) |= 0x8000u;
    v13 = 0;
    v14 = 0;
    SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::operator()(*((_QWORD *)this + 78), 0, 0);
    SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::SmartBlockWithArgs((uint64_t *)&v12, 0);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 624, &v12);
    v6 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
    if (*((_QWORD *)&v12 + 1))
    {
      v7 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    v10 = *((_DWORD *)this + 48);
    v9 = (char *)this + 192;
    v11 = *((unsigned __int16 *)v9 + 2);
    *(_DWORD *)v9 = v10;
    *((_WORD *)v9 + 2) = ((v10 | (unint64_t)(v11 << 32)) & 0xFFFFFF7FFFFFFFFFLL) >> 32;
  }
}

void sub_184074640(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN12HTTPProtocol29asynchronouslyQueryAuthBrokerEv_block_invoke_45@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 1183;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void std::__shared_ptr_pointer<NetworkProxyCredential *,Deleter_release<NetworkProxyCredential>,std::allocator<NetworkProxyCredential>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_pointer<NetworkProxyCredential *,Deleter_release<NetworkProxyCredential>,std::allocator<NetworkProxyCredential>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

void ___ZN12HTTPProtocol19performAsyncCalloutEPK10__CFStringS2_S2_hP15__CFHTTPMessage_block_invoke(uint64_t a1, double a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  __int16 v6;
  double v7;
  uint64_t Error_delayInitStub;
  NSObject *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  v5 = *(_DWORD *)(v3 + 192);
  v3 += 192;
  v6 = *(_WORD *)(v3 + 4);
  *(_DWORD *)v3 = v5 & 0xDFFFFFFF;
  *(_WORD *)(v3 + 4) = v6;
  if (AOSTransactionSuccessful_delayInitStub(a2))
  {
    *(_DWORD *)(*(_QWORD *)(a1 + 40) + 192) |= 0x40000000u;
    HTTPProtocol::createAndOpenStream(*(HTTPProtocol **)(a1 + 40), 0);
  }
  else
  {
    Error_delayInitStub = AOSTransactionGetError_delayInitStub(v7);
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v9 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *(_QWORD *)(v4 + 792);
      v11 = 138543618;
      v12 = v10;
      v13 = 2112;
      v14 = Error_delayInitStub;
      _os_log_impl(&dword_183ECA000, v9, OS_LOG_TYPE_DEFAULT, "%{public}@ _AOSAccountResolveAuthFailure failed with error %@, canceling auth", (uint8_t *)&v11, 0x16u);
    }
    HTTPProtocol::sendError((HTTPProtocol *)v4, (const __CFString *)0xFFFFFFFFFFFFFC0CLL);
  }
}

void ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  const __CFAllocator *v9;
  CFStringRef v10;
  const __CFString *v11;
  CFStringRef v12;
  CFStringRef v13;
  uint64_t v14;
  _QWORD v15[6];
  char v16;
  __int128 buf;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 32);
  CFRetain((CFTypeRef)(v4 - 16));
  if (a2)
  {
    CFRetain(a2);
  }
  else
  {
    if (*(_BYTE *)(a1 + 40))
      v5 = *(_DWORD *)(v4 + 192) | 0x10000000;
    else
      v5 = *(_DWORD *)(v4 + 192) | 0x8000000;
    *(_WORD *)(v4 + 196) = *(_WORD *)(v4 + 196);
    *(_DWORD *)(v4 + 192) = v5;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = a2;
    _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, "Accounts sent cred %p", (uint8_t *)&buf, 0xCu);
  }
  v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_56, 3);
  v8 = v7;
  if (v7
    && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v7 + 16))(v7, "Accounts Completed Credential Fetch", 0))
  {
    v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    *(_QWORD *)&buf = &off_1E14E4818;
    v10 = CFStringCreateWithCString(v9, "Protocol", 0x8000100u);
    v18 = 0;
    v19 = 0;
    *((_QWORD *)&buf + 1) = v10;
    if (v4)
    {
      v11 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 32))(v4);
      v10 = (CFStringRef)*((_QWORD *)&buf + 1);
    }
    else
    {
      v11 = CFSTR("null");
    }
    (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v8 + 64))(v8, v10, v11);
    if (v4 && v11)
      CFRelease(v11);
    AutoString::~AutoString((AutoString *)&buf);
    *(_QWORD *)&buf = &off_1E14E4818;
    v12 = CFStringCreateWithCString(v9, "Credential", 0x8000100u);
    v18 = 0;
    v19 = 0;
    *((_QWORD *)&buf + 1) = v12;
    if (a2)
    {
      v13 = CFCopyDescription(a2);
      v12 = (CFStringRef)*((_QWORD *)&buf + 1);
    }
    else
    {
      v13 = CFSTR("null");
    }
    (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(_QWORD *)v8 + 64))(v8, v12, v13);
    if (a2 && v13)
      CFRelease(v13);
    AutoString::~AutoString((AutoString *)&buf);
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  }
  v14 = *(_QWORD *)(v4 + 24);
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3221225472;
  v15[2] = ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke_2;
  v15[3] = &__block_descriptor_49_e5_v8__0l;
  v16 = *(_BYTE *)(a1 + 40);
  v15[4] = v4;
  v15[5] = a2;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v14 + 96))(v14, v15);
  CFRelease((CFTypeRef)(v4 - 16));
}

void sub_184074B44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke_62@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 1316;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke_2(uint64_t a1)
{
  HTTPProtocol *v2;
  int v3;
  unint64_t v4;
  const void *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  URLAuthChallenge *v11;
  uint64_t v12;
  const void *v13;
  const void *v14;

  v2 = *(HTTPProtocol **)(a1 + 32);
  v3 = *((_DWORD *)v2 + 48);
  v4 = v3 & 0xFBFFFFFF | ((unint64_t)*((unsigned __int16 *)v2 + 98) << 32);
  *((_DWORD *)v2 + 48) = v3 & 0xFBFFFFFF;
  if (*(_BYTE *)(a1 + 48))
  {
    *((_WORD *)v2 + 98) = WORD2(v4);
    *((_DWORD *)v2 + 48) = v4 | 0x1000000;
    (*(void (**)(HTTPProtocol *, _QWORD))(*(_QWORD *)v2 + 624))(v2, 0);
  }
  else
  {
    *((_WORD *)v2 + 98) = WORD2(v4);
    *((_DWORD *)v2 + 48) = v4 | 0x800000;
    v5 = (const void *)*((_QWORD *)v2 + 44);
    *((_QWORD *)v2 + 44) = 0;
    if (v5)
      CFRelease(v5);
  }
  v6 = *(_QWORD *)(a1 + 40);
  v7 = *(unsigned __int8 *)(a1 + 48);
  if (v6)
  {
    if (!*(_BYTE *)(a1 + 48))
    {
      v9 = *((_QWORD *)v2 + 47);
      if (v9)
      {
LABEL_29:
        (*(void (**)(HTTPProtocol *, uint64_t, uint64_t))(*(_QWORD *)v2 + 120))(v2, v6, v9);
        goto LABEL_30;
      }
      goto LABEL_18;
    }
    v8 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)v2 + 648))(v2);
    v7 = *(unsigned __int8 *)(a1 + 48);
    if (v8)
    {
      v6 = *(_QWORD *)(a1 + 40);
      if (*(_BYTE *)(a1 + 48))
        v9 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)v2 + 648))(v2);
      else
        v9 = *((_QWORD *)v2 + 47);
      goto LABEL_29;
    }
  }
  if (v7 && (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)v2 + 648))(v2))
  {
    v10 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)v2 + 648))(v2);
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
    if (v10)
      v11 = (URLAuthChallenge *)(v10 + 16);
    else
      v11 = 0;
LABEL_22:
    URLAuthChallenge::tryNextProtectionSpace(v11);
    goto LABEL_23;
  }
LABEL_18:
  v12 = *((_QWORD *)v2 + 47);
  if (v12)
  {
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
    v11 = (URLAuthChallenge *)(v12 + 16);
    goto LABEL_22;
  }
LABEL_23:
  v13 = *(const void **)(a1 + 40);
  if (*(_BYTE *)(a1 + 48))
  {
    (*(void (**)(HTTPProtocol *, const void *))(*(_QWORD *)v2 + 624))(v2, v13);
  }
  else
  {
    *((_QWORD *)v2 + 44) = v13;
    if (v13)
      CFRetain(v13);
  }
  -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*((_QWORD *)v2 + 104), 3, 0);
  HTTPProtocol::createAndOpenStream(v2, 0);
LABEL_30:
  v14 = *(const void **)(a1 + 40);
  if (v14)
    CFRelease(v14);
  CFRelease((char *)v2 - 16);
}

uint64_t ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke_55@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 1267;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void std::__shared_ptr_pointer<_CFURLProtectionSpace *,Deleter_CFRelease,std::allocator<_CFURLProtectionSpace>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<_CFURLProtectionSpace *,Deleter_CFRelease,std::allocator<_CFURLProtectionSpace>>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 24);
  if (v1)
    CFRelease(v1);
}

void ___ZN12HTTPProtocol14askPATForCredsEP15__CFHTTPMessageP9__CFArraybbPK7__CFURL_block_invoke(_QWORD *a1, std::__shared_weak_count_vtbl *a2, std::__shared_weak_count_vtbl *a3)
{
  NSObject *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  _QWORD v40[5];
  std::__shared_weak_count *v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  std::__shared_weak_count_vtbl *v44;
  std::__shared_weak_count *v45;
  std::__shared_weak_count_vtbl *v46;
  std::__shared_weak_count *v47;
  std::__shared_weak_count_vtbl *v48;
  std::__shared_weak_count *v49;
  _BYTE buf[22];
  __int16 v51;
  std::__shared_weak_count_vtbl *v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *(_QWORD *)(a1[4] + 792);
    *(_DWORD *)buf = 138543874;
    *(_QWORD *)&buf[4] = v7;
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = a2;
    v51 = 2112;
    v52 = a3;
    _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, "%{public}@ received PAT headers %@ error %@", buf, 0x20u);
  }
  if (a2)
    a2 = (std::__shared_weak_count_vtbl *)CFRetain(a2);
  *(_QWORD *)buf = a2;
  v8 = (std::__shared_weak_count *)operator new();
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1A58;
  v8->__shared_weak_owners_ = 0;
  v8[1].__vftable = a2;
  *(_QWORD *)&buf[8] = v8;
  if (a3)
    a3 = (std::__shared_weak_count_vtbl *)CFRetain(a3);
  v48 = a3;
  v10 = (std::__shared_weak_count *)operator new();
  v10->__shared_owners_ = 0;
  v11 = (unint64_t *)&v10->__shared_owners_;
  v10->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19B0;
  v10->__shared_weak_owners_ = 0;
  v10[1].__vftable = a3;
  v49 = v10;
  v13 = a1[4];
  v12 = (std::__shared_weak_count *)a1[5];
  v14 = *(_QWORD *)(v13 + 24);
  v40[0] = MEMORY[0x1E0C809B0];
  v40[1] = 3321888768;
  v40[2] = ___ZN12HTTPProtocol14askPATForCredsEP15__CFHTTPMessageP9__CFArraybbPK7__CFURL_block_invoke_69;
  v40[3] = &__block_descriptor_96_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE64c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE80c36_ZTSNSt3__110shared_ptrI9__CFErrorEE_e5_v8__0l;
  v40[4] = v13;
  v41 = v12;
  if (v12)
  {
    v15 = (unint64_t *)&v12->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  v17 = (std::__shared_weak_count *)a1[7];
  v42 = a1[6];
  v43 = v17;
  if (v17)
  {
    v18 = (unint64_t *)&v17->__shared_owners_;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  v44 = a2;
  v45 = v8;
  do
    v20 = __ldxr(p_shared_owners);
  while (__stxr(v20 + 1, p_shared_owners));
  v46 = a3;
  v47 = v10;
  do
    v21 = __ldxr(v11);
  while (__stxr(v21 + 1, v11));
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v14 + 96))(v14, v40);
  v22 = v47;
  if (v47)
  {
    v23 = (unint64_t *)&v47->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = v45;
  if (v45)
  {
    v26 = (unint64_t *)&v45->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  v28 = v43;
  if (v43)
  {
    v29 = (unint64_t *)&v43->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v31 = v41;
  if (v41)
  {
    v32 = (unint64_t *)&v41->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = v49;
  if (v49)
  {
    v35 = (unint64_t *)&v49->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v37 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v38 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
}

void sub_184075200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  va_list va;
  uint64_t v21;
  va_list va1;

  va_start(va1, a13);
  va_start(va, a13);
  v19 = va_arg(va1, _QWORD);
  v21 = va_arg(va1, _QWORD);
  v17 = v13;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v14);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v17);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v16);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v15);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void ___ZN12HTTPProtocol14askPATForCredsEP15__CFHTTPMessageP9__CFArraybbPK7__CFURL_block_invoke_69(_QWORD *a1)
{
  uint64_t v1;
  __CFHTTPMessage *v2;
  const void *v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  unint64_t v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  NSObject *size;
  CFTypeRef v12;
  const void *v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  _BYTE v17[18];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = a1[4];
  v2 = (__CFHTTPMessage *)a1[6];
  v3 = (const void *)a1[8];
  v4 = a1[10];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v5 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *(_QWORD *)(v1 + 792);
    v14 = 138543874;
    v15 = v6;
    v16 = 2112;
    *(_QWORD *)v17 = v3;
    *(_WORD *)&v17[8] = 2112;
    *(_QWORD *)&v17[10] = v4;
    _os_log_impl(&dword_183ECA000, v5, OS_LOG_TYPE_DEFAULT, "%{public}@ handling PAT headers %@ error %@", (uint8_t *)&v14, 0x20u);
  }
  v7 = (*(unsigned int *)(v1 + 192) | ((unint64_t)*(unsigned __int16 *)(v1 + 196) << 32)) & 0xEFFFFFFFFFFDLL;
  *(_DWORD *)(v1 + 192) &= ~2u;
  *(_WORD *)(v1 + 196) = WORD2(v7);
  if (v4)
  {
    *(_BYTE *)(v1 + 857) = 1;
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v8 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v9 = *(_QWORD *)(v1 + 792);
      v10 = *(_DWORD *)(v1 + 732);
      size = *(NSObject **)(v1 + 720);
      if (size)
        size = dispatch_data_get_size(size);
      v14 = 138543874;
      v15 = v9;
      v16 = 1024;
      *(_DWORD *)v17 = v10;
      *(_WORD *)&v17[4] = 2048;
      *(_QWORD *)&v17[6] = size;
      _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_DEFAULT, "%{public}@ PAT default delivering response recorded(%d, %zu)", (uint8_t *)&v14, 0x1Cu);
    }
    HTTPProtocol::performHeaderReadPostProcessing((HTTPProtocol *)v1, v2, 1);
    HTTPProtocol::deliverUnhandledResponse((HTTPProtocol *)v1);
  }
  else
  {
    if (v3)
      v12 = CFRetain(v3);
    else
      v12 = 0;
    v13 = *(const void **)(v1 + 848);
    *(_QWORD *)(v1 + 848) = v12;
    if (v13)
      CFRelease(v13);
    -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*(_QWORD *)(v1 + 832), 3, 0);
    HTTPProtocol::destroyReadStream((HTTPProtocol *)v1);
    HTTPProtocol::createAndOpenStream((HTTPProtocol *)v1, 0);
  }
}

