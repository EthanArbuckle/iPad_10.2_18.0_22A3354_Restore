BOOL _key_equal(const __CFString *a1, const __CFString *a2)
{
  int isa;
  int v6;

  if (a1 == a2)
    return 1;
  if ((uint64_t)a1 >= (uint64_t)((char *)&gConstantCFStringValueTable + 15176)
    && (uint64_t)a1 < (uint64_t)((char *)&gConstantCFStringValueTable + 18984))
  {
    isa = (int)a1[1].isa;
  }
  else
  {
    isa = 568;
  }
  if ((uint64_t)a2 >= (uint64_t)((char *)&gConstantCFStringValueTable + 15176)
    && (uint64_t)a2 < (uint64_t)((char *)&gConstantCFStringValueTable + 18984))
  {
    v6 = (int)a2[1].isa;
  }
  else
  {
    v6 = 568;
  }
  return isa != 568 && isa == v6 || CFStringCompare(a1, a2, 1uLL) == kCFCompareEqualTo;
}

CFTypeRef _key_retain(const __CFAllocator *a1, CFTypeRef cf)
{
  if (cf)
    return CFRetain(cf);
  else
    return 0;
}

void _key_release(const __CFAllocator *a1, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

BOOL CStringKeyCallbacks::_caseInsensitiveEqual(CStringKeyCallbacks *this, const char *a2, const void *a3)
{
  return this == (CStringKeyCallbacks *)a2 || strcasecmp((const char *)this, a2) == 0;
}

void _merge_array_string(const void *a1, CFTypeRef cf, void *a3)
{
  CFTypeID v6;
  CFTypeID TypeID;
  const __CFAllocator *v8;
  CFStringRef v9;
  CFStringRef v10;

  if (a1)
  {
    if (cf)
    {
      v6 = CFGetTypeID(cf);
      TypeID = CFArrayGetTypeID();
      if (a3)
      {
        if (v6 == TypeID)
        {
          v8 = CFGetAllocator(a3);
          v9 = CFStringCreateByCombiningStrings(v8, (CFArrayRef)cf, CFSTR(", "));
          if (v9)
          {
            v10 = v9;
            CFDictionarySetValue((CFMutableDictionaryRef)a3, a1, v9);
            CFRelease(v10);
          }
        }
      }
    }
  }
}

void *CStringKeyCallbacks::_retain(CStringKeyCallbacks *this, const __CFAllocator *__s, const void *a3)
{
  size_t v5;
  void *v6;
  void *v7;

  if (!__s)
    return 0;
  v5 = strlen((const char *)__s) + 1;
  v6 = CFAllocatorAllocate(this, v5, 0);
  v7 = v6;
  if (v6)
    memcpy(v6, __s, v5);
  return v7;
}

uint64_t CFClass::FinalizeObj(CFClass *this, const void *a2)
{
  if (this)
    return (*(uint64_t (**)(char *))(*((_QWORD *)this + 2) + 40))((char *)this + 16);
  else
    return (*(uint64_t (**)(_QWORD))(MEMORY[0] + 40))(0);
}

void HTTPRequestMessage::~HTTPRequestMessage(HTTPRequestMessage *this)
{
  void **v2;
  void *v3;

  *(_QWORD *)this = &off_1E14E96D8;
  *((_QWORD *)this + 1) = &unk_1E14E9758;
  *((_QWORD *)this + 2) = &unk_1E14E9778;
  *((_QWORD *)this + 16) = &unk_1E14E97A8;
  v2 = (void **)((char *)this + 128);
  v3 = (void *)*((_QWORD *)this + 22);
  if (v3)
    free(v3);
  HTTPRequestParserClient::~HTTPRequestParserClient(v2);
  HTTPMessage::~HTTPMessage(this);
}

void HTTPRequestParserClient::~HTTPRequestParserClient(void **this)
{
  const void *v2;
  const void *v3;
  const void *v4;

  *this = off_1E14ECB28;
  free(this[4]);
  v2 = this[5];
  if (v2)
    CFRelease(v2);
  v3 = this[1];
  if (v3)
    CFRelease(v3);
  this[2] = &off_1E14E9A00;
  v4 = this[3];
  if (v4)
    CFRelease(v4);
}

void sub_183ECCA88(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  const void *v3;

  *(_QWORD *)(v1 + 16) = &off_1E14E9A00;
  v3 = *(const void **)(v1 + 24);
  if (v3)
    CFRelease(v3);
  _Unwind_Resume(exception_object);
}

CFStringRef createCookieString(const void *a1, const char *a2)
{
  const __CFAllocator *v3;

  if (!a2)
    return 0;
  v3 = CFGetAllocator(a1);
  return CFStringCreateWithCString(v3, a2, 0x8000100u);
}

void URLRequest::~URLRequest(URLRequest *this)
{
  __CFURL *fURL;
  __CFURL *fMainDocumentURL;
  __CFDictionary *fProtocolProperties;
  __CFDictionary *fSSLProps;
  __CFDictionary *fProxyDict;
  __CFArray *fContentDispositionHeaderEncodingFallbackArray;
  __CFString *fBoundInterfaceIdentifier;
  __CFDictionary *fATSOverrides;
  HTTPRequest *fHTTPRequest;
  __CFURLStorageSession *explicitStorageSession;
  __CFString *fTrackerContext;
  _CFHSTSPolicy *value;

  this->_vptr$CoreLoggable = (void **)&off_1E14E4C50;
  fURL = this->fURL;
  if (fURL)
    CFRelease(fURL);
  fMainDocumentURL = this->fMainDocumentURL;
  if (fMainDocumentURL)
    CFRelease(fMainDocumentURL);
  fProtocolProperties = this->fProtocolProperties;
  if (fProtocolProperties)
    CFRelease(fProtocolProperties);
  fSSLProps = this->fSSLProps;
  if (fSSLProps)
    CFRelease(fSSLProps);
  fProxyDict = this->fProxyDict;
  if (fProxyDict)
    CFRelease(fProxyDict);
  fContentDispositionHeaderEncodingFallbackArray = this->fContentDispositionHeaderEncodingFallbackArray;
  if (fContentDispositionHeaderEncodingFallbackArray)
    CFRelease(fContentDispositionHeaderEncodingFallbackArray);
  fBoundInterfaceIdentifier = this->fBoundInterfaceIdentifier;
  if (fBoundInterfaceIdentifier)
    CFRelease(fBoundInterfaceIdentifier);
  fATSOverrides = this->fATSOverrides;
  if (fATSOverrides)
    CFRelease(fATSOverrides);
  fHTTPRequest = this->fHTTPRequest;
  if (fHTTPRequest)
    CFRelease((char *)fHTTPRequest - 16);
  explicitStorageSession = this->_explicitStorageSession;
  if (explicitStorageSession)
    CFRelease(explicitStorageSession);
  fTrackerContext = this->fTrackerContext;
  if (fTrackerContext)
    CFRelease(fTrackerContext);
  value = this->fHSTSPolicy.__ptr_.__value_;
  this->fHSTSPolicy.__ptr_.__value_ = 0;
  if (value)
    CFRelease(value);
  this->_vptr$CoreLoggable = (void **)&off_1E14E5838;
}

{
  URLRequest::~URLRequest(this);
  JUMPOUT(0x186DB748CLL);
}

void sub_183ECCDE4(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  const void *v3;

  v3 = (const void *)v1[25];
  v1[25] = 0;
  if (v3)
    CFRelease(v3);
  *v1 = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

void HTTPRequest::~HTTPRequest(HTTPRequest *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  *(_QWORD *)this = &off_1E14E5170;
  *((_QWORD *)this + 1) = &unk_1E14E51F0;
  *((_QWORD *)this + 2) = &unk_1E14E5210;
  *((_QWORD *)this + 16) = &unk_1E14E5240;
  v2 = (const void *)*((_QWORD *)this + 23);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 24);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 26);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 25);
  if (v5)
    CFRelease(v5);
  HTTPRequestMessage::~HTTPRequestMessage((HTTPRequestMessage *)this);
}

void sub_183ECCE7C(_Unwind_Exception *a1)
{
  HTTPRequestMessage *v1;

  HTTPRequestMessage::~HTTPRequestMessage(v1);
  _Unwind_Resume(a1);
}

const char *CStringKeyCallbacks::_caseInsensitiveHash(const char *this, const void *a2)
{
  const char *v2;
  int64_t v3;
  unint64_t v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 v21;
  uint64_t v22;
  const char *v23;
  unsigned __int8 *v24;
  uint64_t v25;
  uint64_t v26;
  unsigned __int8 v27;
  int64_t v28;
  __darwin_ct_rune_t v29;

  if (this)
  {
    v2 = this;
    v3 = strlen(this);
    v4 = v3;
    if (v3 >= 97)
    {
      v12 = 0;
      v7 = v3;
      do
      {
        v13 = 16974593 * __tolower(v2[v12]) + 67503105 * v7;
        v14 = 66049 * __tolower(v2[v12 + 1]);
        v15 = __tolower(v2[v12 + 2]);
        v7 = v13 + v14 + (v15 | (v15 << 8)) + __tolower(v2[v12 + 3]);
        v16 = v12 >= 0x1C;
        v12 += 4;
      }
      while (!v16);
      v17 = 0;
      v18 = (uint64_t)&v2[(v4 >> 1) - 16];
      do
      {
        v19 = 16974593 * __tolower(*(unsigned __int8 *)(v18 + v17)) + 67503105 * v7;
        v20 = 66049 * __tolower(*(unsigned __int8 *)(v18 + v17 + 1));
        v21 = __tolower(*(unsigned __int8 *)(v18 + v17 + 2));
        v7 = v19 + v20 + (v21 | (v21 << 8)) + __tolower(*(unsigned __int8 *)(v18 + v17 + 3));
        v22 = v17 - 16;
        v17 += 4;
      }
      while (v22 < 12);
      v23 = &v2[v4];
      v24 = (unsigned __int8 *)(v23 - 32);
      do
      {
        v25 = 16974593 * __tolower(*v24) + 67503105 * v7;
        v26 = 66049 * __tolower(v24[1]);
        v27 = __tolower(v24[2]);
        v7 = v25 + v26 + (v27 | (v27 << 8)) + __tolower(v24[3]);
        v24 += 4;
      }
      while (v24 < (unsigned __int8 *)v23);
    }
    else
    {
      v5 = &v2[v3];
      if ((uint64_t)(v3 & 0xFFFFFFFFFFFFFFFCLL) < 1)
      {
        v8 = (unsigned __int8 *)v2;
        v7 = v3;
      }
      else
      {
        v6 = &v2[v3 & 0xFFFFFFFFFFFFFFFCLL];
        v7 = v3;
        v8 = (unsigned __int8 *)v2;
        do
        {
          v9 = 16974593 * __tolower(*v8) + 67503105 * v7;
          v10 = 66049 * __tolower(v8[1]);
          v11 = __tolower(v8[2]);
          v7 = v9 + v10 + (v11 | (v11 << 8)) + __tolower(v8[3]);
          v8 += 4;
        }
        while (v8 < (unsigned __int8 *)v6);
      }
      if (v8 < (unsigned __int8 *)v5)
      {
        v28 = &v2[v4] - (const char *)v8;
        do
        {
          v29 = *v8++;
          v7 = 257 * v7 + __tolower(v29);
          --v28;
        }
        while (v28);
      }
    }
    return (const char *)((v7 << (v4 & 0x1F)) + v7);
  }
  return this;
}

void CompactCookieArray::~CompactCookieArray(CompactCookieArray *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1E14E92A8;
  *((_QWORD *)this + 1) = &unk_1E14E92F0;
  v2 = (const void *)*((_QWORD *)this + 2);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 2) = 0;
  }
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

void sub_183ECD1F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t RetainableTypedArray<BaseAwaitingTube *>::_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t _apply_block(const void *a1, const void *a2, uint64_t (**a3)(_QWORD, _QWORD, _QWORD))
{
  return ((uint64_t (**)(_QWORD, const void *, const void *))a3)[2](a3, a1, a2);
}

uint64_t ___ZN12HTTPProtocol29setProtocolPropertiesToStreamEv_block_invoke(uint64_t a1, const __CFString *this, uint64_t a3)
{
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;

  v5 = *(_QWORD *)(a1 + 32);
  result = MetaNetStreamInfo::propertyNameToApplicableProperty(this, this);
  if ((_DWORD)result)
  {
    v7 = result;
    v8 = *(_QWORD *)(v5 + 272);
    if (v8)
    {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8 + 40))(v8, v7, a3);
    }
    else
    {
      result = *(_QWORD *)(v5 + 888);
      if (result)
        return (*(uint64_t (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)result + 56))(result, this, a3);
    }
  }
  return result;
}

void createSSLCertificateContext(CFDictionaryRef *a1, uint64_t a2)
{
  CFIndex v4;
  const void *v5;
  const void *v6;
  const void *v7;
  unint64_t v8;
  uint64_t v9;
  const void *v10;
  const void *v11[4];
  void *keys[2];
  __int128 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  *a1 = 0;
  *(_OWORD *)keys = 0u;
  v13 = 0u;
  memset(&v11[1], 0, 24);
  v11[0] = (const void *)(*(uint64_t (**)(uint64_t, void *))(a2 + 16))(a2, &unk_1EDCFC010);
  if (v11[0])
  {
    keys[0] = &unk_1EDCFC010;
    v4 = 1;
  }
  else
  {
    v4 = 0;
  }
  v5 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 0x1EDCFAB10);
  v11[v4] = v5;
  if (v5)
    *(_QWORD *)((unint64_t)keys | (8 * v4++)) = 0x1EDCFAB10;
  v6 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 0x1EDCFAB48);
  v11[v4] = v6;
  if (v6)
    keys[v4++] = &unk_1EDCFAB48;
  v7 = (const void *)(*(uint64_t (**)(uint64_t, void *))(a2 + 16))(a2, &unk_1EDCFC048);
  v11[v4] = v7;
  if (v7)
    keys[v4++] = &unk_1EDCFC048;
  *a1 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, v11, v4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v4)
  {
    v8 = 0;
    v9 = 8 * v4;
    do
    {
      v10 = v11[v8 / 8];
      if (v10)
        CFRelease(v10);
      v8 += 8;
    }
    while (v9 != v8);
  }
}

void sub_183ECD464(_Unwind_Exception *exception_object)
{
  _QWORD *v1;

  *v1 = 0;
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN12HTTPProtocol23constructSSLCertContextEv_block_invoke(uint64_t a1, const __CFString *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 272);
  v3 = MetaNetStreamInfo::propertyNameToApplicableProperty(this, this);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 32))(v2, v3);
}

uint64_t MetaNetStreamInfo::propertyNameToApplicableProperty(const __CFString *this, const __CFString *a2)
{
  int ExactString;

  ExactString = _findExactString(this, 0);
  if (ExactString <= 117680231)
  {
    if (ExactString <= 50668408)
    {
      if (ExactString <= 36061769)
      {
        if (ExactString > 29721048)
        {
          if (ExactString == 29721049)
            return 33;
          if (ExactString == 32842260)
            return 3;
        }
        else
        {
          if (ExactString == 11870276)
            return 1;
          if (ExactString == 21324027)
            return 6;
        }
      }
      else if (ExactString <= 38142589)
      {
        if (ExactString == 36061770)
          return 9;
        if (ExactString == 37110372)
          return 8;
      }
      else
      {
        switch(ExactString)
        {
          case 38142590:
            return 11;
          case 39191191:
            return 10;
          case 40239792:
            return 7;
        }
      }
    }
    else if (ExactString > 83273190)
    {
      if (ExactString <= 90506881)
      {
        if (ExactString == 83273191)
          return 12;
        if (ExactString == 87361088)
          return 27;
      }
      else
      {
        switch(ExactString)
        {
          case 90506882:
            return 13;
          case 92538537:
            return 17;
          case 104064896:
            return 16;
        }
      }
    }
    else if (ExactString <= 56869867)
    {
      if (ExactString == 50668409)
        return 38;
      if (ExactString == 51700622)
        return 5;
    }
    else
    {
      switch(ExactString)
      {
        case 56869868:
          return 2;
        case 68551902:
          return 4;
        case 69510391:
          return 39;
      }
    }
  }
  else if (ExactString > 140716566)
  {
    if (ExactString > 231968870)
    {
      if (ExactString <= 406214148)
      {
        if (ExactString == 231968871)
          return 37;
        if (ExactString == 398906741)
          return 14;
      }
      else
      {
        switch(ExactString)
        {
          case 406214149:
            return 15;
          case 413529750:
            return 30;
          case 444889076:
            return 34;
        }
      }
    }
    else if (ExactString <= 197438962)
    {
      if (ExactString == 140716567)
        return 28;
      if (ExactString == 194301361)
        return 31;
    }
    else
    {
      switch(ExactString)
      {
        case 197438963:
          return 32;
        case 229937221:
          return 35;
        case 230928472:
          return 36;
      }
    }
  }
  else if (ExactString > 130378060)
  {
    if (ExactString <= 134539680)
    {
      if (ExactString == 130378061)
        return 19;
      if (ExactString == 133474702)
        return 22;
    }
    else
    {
      switch(ExactString)
      {
        case 134539681:
          return 21;
        case 135580085:
          return 23;
        case 139782659:
          return 29;
      }
    }
  }
  else if (ExactString <= 120965282)
  {
    if (ExactString == 117680232)
      return 18;
    if (ExactString == 119892109)
      return 24;
  }
  else
  {
    switch(ExactString)
    {
      case 120965283:
        return 25;
      case 124045535:
        return 26;
      case 129296697:
        return 20;
    }
  }
  return 0;
}

uint64_t cf_nghttp2_on_header_callback(uint64_t a1, uint64_t a2, void *a3, size_t a4, void *a5, size_t a6, uint64_t a7, uint64_t a8)
{
  int v14;
  uint64_t *v15;
  uint64_t v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  size_t v19;
  std::string *v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  void **v25;
  std::string::size_type v26;
  std::string *v27;
  std::string::size_type v28;
  char v29;
  char *v30;
  char *v31;
  uint64_t v32;
  uint64_t result;
  void *v34;
  HTTP2Stream *v35;
  const __CFAllocator *v36;
  CFMutableArrayRef Mutable;
  const void *v38;
  CFStringRef v39;
  CFStringRef v40;
  void *__p[2];
  char v42;
  __int128 v43;
  char v44;
  void *v45[2];
  unsigned __int8 v46;
  void *__dst[2];
  char v48;
  std::string v49;
  void *v50;
  char v51;
  _BYTE v52[15];
  char v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  if (!nghttp2_check_header_name() || !nghttp2_check_header_value())
    return 4294966775;
  v14 = *(unsigned __int8 *)(a2 + 12);
  if (v14 == 5)
  {
    std::string::basic_string[abi:nn180100](&v43, a3, a4);
    std::string::basic_string[abi:nn180100](__p, a5, a6);
    HTTP2ServerPush::addPromisedHeaderToStream(a8 + 288, &v43, (__int128 *)__p, *(_DWORD *)(a2 + 40));
    if (v42 < 0)
      operator delete(__p[0]);
    if ((v44 & 0x80000000) == 0)
      return 0;
    v34 = (void *)v43;
LABEL_63:
    operator delete(v34);
    return 0;
  }
  if (v14 == 1)
  {
    if (*(_DWORD *)(a2 + 56) == 2)
    {
      std::string::basic_string[abi:nn180100](__dst, a3, a4);
      std::string::basic_string[abi:nn180100](v45, a5, a6);
      v15 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>((_QWORD *)(a8 + 336), *(_DWORD *)(a2 + 8));
      if (v15)
      {
        v16 = v15[3];
        if (v16)
        {
          v17 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>((_QWORD *)(v16 + 80), (uint64_t)__dst);
          if (v17)
          {
            v18 = v17;
            if ((v17[63] & 0x80u) == 0)
              v19 = v17[63];
            else
              v19 = *((_QWORD *)v17 + 6);
            v20 = &v49;
            std::string::basic_string[abi:nn180100]((uint64_t)&v49, v19 + 2);
            if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v20 = (std::string *)v49.__r_.__value_.__r.__words[0];
            if (v19)
            {
              v23 = (char *)*((_QWORD *)v18 + 5);
              v22 = (char *)(v18 + 40);
              v21 = v23;
              if (v22[23] >= 0)
                v24 = v22;
              else
                v24 = v21;
              memmove(v20, v24, v19);
            }
            strcpy((char *)v20 + v19, ", ");
            if ((v46 & 0x80u) == 0)
              v25 = v45;
            else
              v25 = (void **)v45[0];
            if ((v46 & 0x80u) == 0)
              v26 = v46;
            else
              v26 = (std::string::size_type)v45[1];
            v27 = std::string::append(&v49, (const std::string::value_type *)v25, v26);
            v28 = v27->__r_.__value_.__r.__words[0];
            *(_QWORD *)v52 = v27->__r_.__value_.__l.__size_;
            *(_QWORD *)&v52[7] = *(std::string::size_type *)((char *)&v27->__r_.__value_.__r.__words[1] + 7);
            v29 = HIBYTE(v27->__r_.__value_.__r.__words[2]);
            v27->__r_.__value_.__l.__size_ = 0;
            v27->__r_.__value_.__r.__words[2] = 0;
            v27->__r_.__value_.__r.__words[0] = 0;
            v30 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v16 + 80, (uint64_t)__dst, (uint64_t)__dst);
            v31 = v30;
            if (v30[63] < 0)
              operator delete(*((void **)v30 + 5));
            v32 = *(_QWORD *)v52;
            *((_QWORD *)v31 + 5) = v28;
            *((_QWORD *)v31 + 6) = v32;
            *(_QWORD *)(v31 + 55) = *(_QWORD *)&v52[7];
            v31[63] = v29;
          }
          else
          {
            std::pair<std::string,std::string>::pair[abi:nn180100]<std::string&,std::string&,0>(&v49, (__int128 *)__dst, (__int128 *)v45);
            std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::pair<std::string,std::string>>(v16 + 80, (uint64_t)&v49, (uint64_t)&v49);
            if (v51 < 0)
              operator delete(v50);
          }
          if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v49.__r_.__value_.__l.__data_);
          if (DiagnosticLogging::userDiagnosticLevel(void)::onceToken != -1)
            dispatch_once(&DiagnosticLogging::userDiagnosticLevel(void)::onceToken, &__block_literal_global_13840);
          if (DiagnosticLogging::userDiagnosticLevel(void)::sChecked >= 2)
          {
            std::pair<std::string,std::string>::pair[abi:nn180100]<std::string&,std::string&,0>(&v49, (__int128 *)__dst, (__int128 *)v45);
            std::vector<std::pair<std::string,std::string>>::emplace_back<std::pair<std::string,std::string>>((char **)(v16 + 120), (__int128 *)&v49);
            if (v51 < 0)
              operator delete(v50);
            if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v49.__r_.__value_.__l.__data_);
          }
        }
      }
      if ((char)v46 < 0)
        operator delete(v45[0]);
      if ((v48 & 0x80000000) == 0)
        return 0;
      v34 = __dst[0];
      goto LABEL_63;
    }
    result = nghttp2_session_get_stream_user_data();
    if (!result)
      return result;
    v35 = *(HTTP2Stream **)result;
    if (*(_QWORD *)result && (*(_DWORD *)(a2 + 56) | 2) == 3)
    {
      if (*((_BYTE *)v35 + 353))
      {
        if (DiagnosticLogging::userDiagnosticLevel(void)::onceToken != -1)
          dispatch_once(&DiagnosticLogging::userDiagnosticLevel(void)::onceToken, &__block_literal_global_13840);
        if (DiagnosticLogging::userDiagnosticLevel(void)::sChecked >= 2)
        {
          std::string::basic_string[abi:nn180100](&v49, a3, a4);
          std::string::basic_string[abi:nn180100](v52, a5, a6);
          HTTP2Diagnostic::APPEND_RECV_HEADER((std::string *)((char *)v35 + 328), (uint64_t)&v49, (uint64_t)v52, *((_DWORD *)v35 + 20), *(_QWORD *)(*((_QWORD *)v35 + 8) + 72));
          if (v53 < 0)
            operator delete(*(void **)v52);
          if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v49.__r_.__value_.__l.__data_);
        }
        v36 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        if (!*((_QWORD *)v35 + 31))
        {
          Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
          v38 = (const void *)*((_QWORD *)v35 + 31);
          *((_QWORD *)v35 + 31) = Mutable;
          if (v38)
            CFRelease(v38);
        }
        v39 = CFStringCreateWithBytes(v36, (const UInt8 *)a3, a4, 0x600u, 0);
        v40 = CFStringCreateWithBytes(v36, (const UInt8 *)a5, a6, 0x600u, 0);
        CFArrayAppendValue(*((CFMutableArrayRef *)v35 + 31), v39);
        CFArrayAppendValue(*((CFMutableArrayRef *)v35 + 31), v40);
        CFRelease(v39);
        CFRelease(v40);
      }
      else
      {
        HTTP2Stream::processHeaderLine(*(HTTP2Stream **)result, (unsigned __int8 *)a3, a4, (unsigned __int8 *)a5, a6);
      }
    }
  }
  return 0;
}

void sub_183ECDE24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  uint64_t v38;

  if (*(char *)(v38 - 73) < 0)
    operator delete(*(void **)(v38 - 96));
  if (a38 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void HTTP2Stream::processHeaderLine(HTTP2Stream *this, unsigned __int8 *__src, size_t __len, unsigned __int8 *a4, size_t a5)
{
  const __CFAllocator *v10;
  CFMutableArrayRef Mutable;
  const void *v12;
  CFStringRef v13;
  CFStringRef v14;
  void *__p[2];
  char v16;
  void *__dst[2];
  char v18;

  if (DiagnosticLogging::userDiagnosticLevel(void)::onceToken != -1)
    dispatch_once(&DiagnosticLogging::userDiagnosticLevel(void)::onceToken, &__block_literal_global_13840);
  if (DiagnosticLogging::userDiagnosticLevel(void)::sChecked >= 2)
  {
    std::string::basic_string[abi:nn180100](__dst, __src, __len);
    std::string::basic_string[abi:nn180100](__p, a4, a5);
    HTTP2Diagnostic::APPEND_RECV_HEADER((std::string *)((char *)this + 328), (uint64_t)__dst, (uint64_t)__p, *((_DWORD *)this + 20), *(_QWORD *)(*((_QWORD *)this + 8) + 72));
    if (v16 < 0)
      operator delete(__p[0]);
    if (v18 < 0)
      operator delete(__dst[0]);
  }
  if (!strcmp((const char *)__src, ":status") && *a4 != 49)
    *((_BYTE *)this + 352) = 1;
  v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (!*((_QWORD *)this + 30))
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    v12 = (const void *)*((_QWORD *)this + 30);
    *((_QWORD *)this + 30) = Mutable;
    if (v12)
      CFRelease(v12);
  }
  v13 = CFStringCreateWithBytes(v10, __src, __len, 0x600u, 0);
  v14 = CFStringCreateWithBytes(v10, a4, a5, 0x600u, 0);
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 30), v13);
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 30), v14);
  CFRelease(v13);
  CFRelease(v14);
}

void sub_183ECE098(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void sub_183ECE1B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183ECE644(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

void sub_183ECEA4C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183ECEB90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183ECEE1C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183ECEF44(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183ECF290(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183ECF440(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183ECF514(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_56c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(result + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 64) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_56c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 56);
}

uint64_t CFAllocatedReferenceCountedObject::_retainable_hash(CFAllocatedReferenceCountedObject *this, const void *a2)
{
  return (*(uint64_t (**)(CFAllocatedReferenceCountedObject *))(*(_QWORD *)this + 32))(this);
}

void HTTPHeaderDict::~HTTPHeaderDict(HTTPHeaderDict *this)
{
  const void *v1;

  *(_QWORD *)this = &off_1E14E6D78;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
}

{
  const void *v1;

  *(_QWORD *)this = &off_1E14E6D78;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
}

uint64_t ConnectionProtocolGetInputFrames(uint64_t a1)
{
  uint64_t v2;
  const char *v3;
  NSObject *v4;
  uint32_t v5;
  uint64_t v6;
  int v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v2 = CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      return 0;
    LOWORD(v7) = 0;
    v3 = "protocol is nullptr";
    v4 = v2;
    v5 = 2;
    goto LABEL_13;
  }
  if (*(_QWORD *)(a1 + 40))
    return (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) + 80))();
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    v7 = 136315138;
    v8 = "ConnectionProtocolGetInputFrames";
    v3 = "Connection is invalid in %s";
    v4 = v6;
    v5 = 12;
LABEL_13:
    _os_log_error_impl(&dword_183ECA000, v4, OS_LOG_TYPE_ERROR, v3, (uint8_t *)&v7, v5);
  }
  return 0;
}

CFTypeRef _key_copyDescription(CFTypeRef cf)
{
  if (cf)
    return CFRetain(cf);
  return cf;
}

void ___ZN14StrictSecurity33performSystemTrustEvaluationAsyncEPK8__CFDataNS_21SessionStrengthPolicyEN14CFNetworkTrust26SignatureAlgorithmStrengthEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFviE_block_invoke(uint64_t a1, int a2)
{
  NSObject *v4;
  NSObject *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  __int128 v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v4 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v9) = 67109120;
    DWORD1(v9) = a2;
    _os_log_impl(&dword_183ECA000, v4, OS_LOG_TYPE_DEFAULT, "System Trust Evaluation yielded status(%d)", (uint8_t *)&v9, 8u);
  }
  if (a2)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v5 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v9) = 0;
      _os_log_error_impl(&dword_183ECA000, v5, OS_LOG_TYPE_ERROR, "ATS failed system trust", (uint8_t *)&v9, 2u);
    }
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  v9 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48, &v9);
  v6 = (std::__shared_weak_count *)*((_QWORD *)&v9 + 1);
  if (*((_QWORD *)&v9 + 1))
  {
    v7 = (unint64_t *)(*((_QWORD *)&v9 + 1) + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void ___ZN14NWIOConnection30_tlsProcessTrust_PolicyDefaultEU13block_pointerFviE_block_invoke(_QWORD *a1, int a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  _BYTE v13[18];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if ((a2 - 1) < 2)
  {
    v3 = a1[7];
    v4 = CFNetworkTrust::errorForEvaluationFalure(*(CFNetworkTrust **)(*(_QWORD *)(a1[5] + 8) + 48));
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v5 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v6 = *(_QWORD *)(v3 + 288);
      *(_DWORD *)v13 = 134218240;
      *(_QWORD *)&v13[4] = v6;
      *(_WORD *)&v13[12] = 1024;
      *(_DWORD *)&v13[14] = v4;
      _os_log_error_impl(&dword_183ECA000, v5, OS_LOG_TYPE_ERROR, "Connection %llu: default TLS Trust evaluation failed(%d)", v13, 0x12u);
    }
  }
  (*(void (**)(void))(a1[4] + 16))();
  *(_QWORD *)v13 = 0;
  *(_QWORD *)&v13[8] = 0;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(_QWORD *)(a1[5] + 8) + 48, (__int128 *)v13);
  v7 = *(std::__shared_weak_count **)&v13[8];
  if (*(_QWORD *)&v13[8])
  {
    v8 = (unint64_t *)(*(_QWORD *)&v13[8] + 8);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  *(_QWORD *)v13 = 0;
  *(_QWORD *)&v13[8] = 0;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(_QWORD *)(a1[6] + 8) + 48, (__int128 *)v13);
  v10 = *(std::__shared_weak_count **)&v13[8];
  if (*(_QWORD *)&v13[8])
  {
    v11 = (unint64_t *)(*(_QWORD *)&v13[8] + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void ___ZN14NWIOConnection37_tlsProcessValidateServerTrust_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEENS1_IK9__CFArrayEEU13block_pointerFvbS6_S9_13CFStreamErrorE_block_invoke_4(_QWORD *a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v6;
  int v7;
  NSObject *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  __int128 v47;
  uint64_t v48;
  std::__shared_weak_count *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _BYTE buf[18];
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v3 = a1[7];
  if ((*(_WORD *)(v3 + 248) & 0x60) != 0 || (*(_DWORD *)(v3 + 136) - 5) <= 2)
  {
    v4 = *(_QWORD *)(a1[5] + 8);
    *(_QWORD *)(v4 + 48) = 1;
    *(_DWORD *)(v4 + 56) = 89;
    v52 = 0;
    v53 = 0;
    v50 = 0;
    v51 = 0;
    (*(void (**)(void))(a1[4] + 16))();
  }
  else
  {
    v6 = (_QWORD *)a1[6];
    if (a2)
      v7 = *MEMORY[0x1E0C9B298];
    else
      v7 = 0;
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v8 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v9 = v6[36];
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)&buf[4] = v9;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a2;
      _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_DEFAULT, "Connection %llu: TLS Trust result %d", buf, 0x12u);
    }
    v11 = v6[56];
    v10 = (std::__shared_weak_count *)v6[57];
    *(_QWORD *)buf = v11;
    *(_QWORD *)&buf[8] = v10;
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }
    v14 = (std::__shared_weak_count *)v6[61];
    v48 = v6[60];
    v49 = v14;
    if (v14)
    {
      v15 = (unint64_t *)&v14->__shared_owners_;
      do
        v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
    }
    if (!a2)
    {
      v47 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v6 + 56), &v47);
      v17 = (std::__shared_weak_count *)*((_QWORD *)&v47 + 1);
      if (*((_QWORD *)&v47 + 1))
      {
        v18 = (unint64_t *)(*((_QWORD *)&v47 + 1) + 8);
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      v47 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v6 + 58), &v47);
      v20 = (std::__shared_weak_count *)*((_QWORD *)&v47 + 1);
      if (*((_QWORD *)&v47 + 1))
      {
        v21 = (unint64_t *)(*((_QWORD *)&v47 + 1) + 8);
        do
          v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
      v47 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v6 + 60), &v47);
      v23 = (std::__shared_weak_count *)*((_QWORD *)&v47 + 1);
      if (*((_QWORD *)&v47 + 1))
      {
        v24 = (unint64_t *)(*((_QWORD *)&v47 + 1) + 8);
        do
          v25 = __ldaxr(v24);
        while (__stlxr(v25 - 1, v24));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
      }
      v11 = *(_QWORD *)buf;
      v10 = *(std::__shared_weak_count **)&buf[8];
    }
    v26 = a1[4];
    v45 = v11;
    v46 = v10;
    if (v10)
    {
      v27 = (unint64_t *)&v10->__shared_owners_;
      do
        v28 = __ldxr(v27);
      while (__stxr(v28 + 1, v27));
    }
    v43 = v48;
    v44 = v49;
    if (v49)
    {
      v29 = (unint64_t *)&v49->__shared_owners_;
      do
        v30 = __ldxr(v29);
      while (__stxr(v30 + 1, v29));
    }
    (*(void (**)(uint64_t, BOOL, uint64_t *, uint64_t *, _QWORD, _QWORD))(v26 + 16))(v26, a2 == 0, &v45, &v43, v7, a2);
    v31 = v44;
    if (v44)
    {
      v32 = (unint64_t *)&v44->__shared_owners_;
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    v34 = v46;
    if (v46)
    {
      v35 = (unint64_t *)&v46->__shared_owners_;
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 - 1, v35));
      if (!v36)
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
      }
    }
    v37 = v49;
    if (v49)
    {
      v38 = (unint64_t *)&v49->__shared_owners_;
      do
        v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }
    v40 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v41 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v42 = __ldaxr(v41);
      while (__stlxr(v42 - 1, v41));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
        std::__shared_weak_count::__release_weak(v40);
      }
    }
  }
}

void sub_183ED05D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  uint64_t v15;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a15);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v15 - 80);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection37_tlsProcessValidateServerTrust_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEENS1_IK9__CFArrayEEU13block_pointerFvbS6_S9_13CFStreamErrorE_block_invoke_3(uint64_t a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  uint64_t v37[2];
  _QWORD v38[2];
  void (*v39)(_QWORD *, unsigned int);
  void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  int v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  uint64_t v49;
  std::__shared_weak_count *v50;
  uint64_t v51;
  std::__shared_weak_count *v52;
  uint64_t v53;
  std::__shared_weak_count *v54;

  if (*(_BYTE *)(a1 + 76))
  {
    v1 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    *(_QWORD *)(v1 + 48) = 1;
    *(_DWORD *)(v1 + 56) = 89;
    v53 = 0;
    v54 = 0;
    v51 = 0;
    v52 = 0;
    (*(void (**)(_QWORD, _QWORD, uint64_t *, uint64_t *, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), 0, &v53, &v51, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 56));
    v2 = v52;
    if (v52)
    {
      p_shared_owners = (unint64_t *)&v52->__shared_owners_;
      do
        v4 = __ldaxr(p_shared_owners);
      while (__stlxr(v4 - 1, p_shared_owners));
      if (!v4)
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }
    v5 = v54;
    if (v54)
    {
      v6 = (unint64_t *)&v54->__shared_owners_;
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
LABEL_21:
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
      return;
    }
    return;
  }
  v8 = *(_QWORD *)(a1 + 56);
  if ((*(_WORD *)(v8 + 248) & 0x60) == 0 && (*(_DWORD *)(v8 + 136) - 5) > 2)
  {
    v14 = *(_QWORD *)(a1 + 48);
    v38[0] = MEMORY[0x1E0C809B0];
    v38[1] = 3321888768;
    v39 = ___ZN14NWIOConnection37_tlsProcessValidateServerTrust_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEENS1_IK9__CFArrayEEU13block_pointerFvbS6_S9_13CFStreamErrorE_block_invoke_4;
    v40 = &unk_1E14F4518;
    v43 = v14;
    v44 = v8;
    v15 = *(std::__shared_weak_count **)(a1 + 64);
    v45 = v15;
    if (v15)
    {
      v16 = (unint64_t *)&v15->__shared_owners_;
      do
        v17 = __ldxr(v16);
      while (__stxr(v17 + 1, v16));
    }
    v18 = *(_QWORD *)(a1 + 40);
    v41 = *(_QWORD *)(a1 + 32);
    v42 = v18;
    v19 = *(_DWORD *)(a1 + 72);
    v46 = v19;
    if (v19)
    {
      if (v19 == 2)
      {
        v21 = *(_QWORD *)(a1 + 56);
        v22 = *(std::__shared_weak_count **)(v14 + 472);
        v37[0] = *(_QWORD *)(v14 + 464);
        v37[1] = (uint64_t)v22;
        if (v22)
        {
          v23 = (unint64_t *)&v22->__shared_owners_;
          do
            v24 = __ldxr(v23);
          while (__stxr(v24 + 1, v23));
        }
        NWIOConnection::_tlsProcessTrust_PolicyStrict(v21, v37, (uint64_t)v38);
        if (!v22)
          goto LABEL_51;
        v25 = (unint64_t *)&v22->__shared_owners_;
        do
          v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
      }
      else
      {
        if (v19 == 1)
        {
          v20 = *(_QWORD *)(a1 + 56);
          if (TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce != -1)
            dispatch_once(&TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce, &__block_literal_global_1699);
          TrustExceptionManager::storeTrustExceptions((TrustExceptionManager *)TrustExceptionManager::sharedTrustExceptionManager(void)::singleton, *(const __CFData **)(v20 + 432), *(SecTrustRef *)(v20 + 448));
          v39(v38, 0);
          goto LABEL_51;
        }
        v27 = *(_QWORD *)(v18 + 8);
        *(_QWORD *)(v27 + 48) = 1;
        *(_DWORD *)(v27 + 56) = 22;
        v35 = 0;
        v36 = 0;
        v33 = 0;
        v34 = 0;
        (*(void (**)(_QWORD, _QWORD, uint64_t *, uint64_t *, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), 0, &v35, &v33, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 56));
        v28 = v34;
        if (v34)
        {
          v29 = (unint64_t *)&v34->__shared_owners_;
          do
            v30 = __ldaxr(v29);
          while (__stlxr(v30 - 1, v29));
          if (!v30)
          {
            ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
            std::__shared_weak_count::__release_weak(v28);
          }
        }
        v22 = v36;
        if (!v36)
          goto LABEL_51;
        v31 = (unint64_t *)&v36->__shared_owners_;
        do
          v26 = __ldaxr(v31);
        while (__stlxr(v26 - 1, v31));
      }
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
      goto LABEL_51;
    }
    NWIOConnection::_tlsProcessTrust_PolicyDefault(*(_QWORD *)(a1 + 56), (uint64_t)v38);
LABEL_51:
    v5 = v45;
    if (!v45)
      return;
    v32 = (unint64_t *)&v45->__shared_owners_;
    do
      v7 = __ldaxr(v32);
    while (__stlxr(v7 - 1, v32));
    goto LABEL_21;
  }
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  *(_QWORD *)(v9 + 48) = 1;
  *(_DWORD *)(v9 + 56) = 89;
  v49 = 0;
  v50 = 0;
  v47 = 0;
  v48 = 0;
  (*(void (**)(_QWORD, _QWORD, uint64_t *, uint64_t *, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), 0, &v49, &v47, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 56));
  v10 = v48;
  if (v48)
  {
    v11 = (unint64_t *)&v48->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v5 = v50;
  if (v50)
  {
    v13 = (unint64_t *)&v50->__shared_owners_;
    do
      v7 = __ldaxr(v13);
    while (__stlxr(v7 - 1, v13));
    goto LABEL_21;
  }
}

void sub_183ED09A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void NWIOConnection::_tlsProcessTrust_PolicyStrict(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  const __CFDictionary *Value;
  const __CFDictionary *v7;
  const __CFDictionary *ATSVersion;
  uint64_t v9;
  const void *v10;
  CFTypeID v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void *v16;
  const void *v17;
  BOOL v18;
  BOOL v19;
  NSObject *v20;
  CFErrorRef v21;
  CFIndex Code;
  uint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  _QWORD v30[2];
  void (*v31)(uint64_t, int);
  void *v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  const __CFDictionary *v36;
  int v37;
  _QWORD v38[6];
  uint64_t v39;
  std::__shared_weak_count *v40;
  _QWORD v41[6];
  CFErrorRef err;
  _BYTE buf[24];
  __n128 (*v44)(__n128 *, __n128 *);
  uint64_t (*v45)(uint64_t);
  void *v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EDCFC080);
  ATSVersion = StrictSecurity::getATSVersion(Value, v7);
  if (Value)
  {
    v10 = CFDictionaryGetValue(Value, &unk_1EDCFAF70);
    v9 = (uint64_t)v10;
    if (v10)
    {
      v11 = CFGetTypeID(v10);
      if (v11 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
      }
      v9 = *MEMORY[0x1E0C9AE50] == v9;
    }
  }
  else
  {
    v9 = 0;
  }
  v38[0] = 0;
  v38[1] = v38;
  v38[2] = 0x4012000000;
  v38[3] = __Block_byref_object_copy__165;
  v38[4] = __Block_byref_object_dispose__166;
  v39 = 0;
  v40 = 0;
  v38[5] = &unk_18422E08D;
  v12 = *(std::__shared_weak_count **)(a1 + 264);
  if (v12)
  {
    v40 = std::__shared_weak_count::lock(v12);
    if (v40)
      v39 = *(_QWORD *)(a1 + 256);
  }
  v13 = *a2;
  v14 = *(_QWORD *)(a1 + 120);
  v15 = MEMORY[0x1E0C809B0];
  v30[0] = MEMORY[0x1E0C809B0];
  v30[1] = 3221225472;
  v31 = ___ZN14NWIOConnection29_tlsProcessTrust_PolicyStrictENSt3__110shared_ptrIK8__CFDataEEU13block_pointerFviE_block_invoke;
  v32 = &unk_1E14F7F58;
  v35 = a1;
  v36 = ATSVersion;
  v37 = v9;
  v33 = a3;
  v34 = v38;
  if (!v13 || !ATSVersion || !dyld_program_sdk_at_least())
    goto LABEL_40;
  err = 0;
  v16 = (const void *)SecTrustDeserialize();
  v17 = v16;
  v18 = err || v16 == 0;
  v19 = v18;
  if (v18)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v20 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v21 = err;
      if (err)
        Code = CFErrorGetCode(err);
      else
        Code = 0;
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = v21;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = Code;
      _os_log_error_impl(&dword_183ECA000, v20, OS_LOG_TYPE_ERROR, "Failed to deserialize cloned ATS trust %@ [%ld]", buf, 0x16u);
    }
  }
  else
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x4012000000;
    v44 = __Block_byref_object_copy__131;
    v45 = __Block_byref_object_dispose__132;
    v46 = &unk_18422E08D;
    std::allocate_shared[abi:nn180100]<CFNetworkTrust,std::allocator<CFNetworkTrust>,__SecTrust *,void>(&v47, v16);
    v23 = *(_QWORD *)(*(_QWORD *)&buf[8] + 48);
    v41[0] = v15;
    v41[1] = 3221225472;
    v41[2] = ___ZN14StrictSecurity33performSystemTrustEvaluationAsyncEPK8__CFDataNS_21SessionStrengthPolicyEN14CFNetworkTrust26SignatureAlgorithmStrengthEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFviE_block_invoke;
    v41[3] = &unk_1E14FBFC0;
    v41[4] = v30;
    v41[5] = buf;
    CFNetworkTrust::strictEvaluateAsync(v23, 1, v9, v14, (uint64_t)v41);
    _Block_object_dispose(buf, 8);
    v24 = v48;
    if (v48)
    {
      p_shared_owners = (unint64_t *)&v48->__shared_owners_;
      do
        v26 = __ldaxr(p_shared_owners);
      while (__stlxr(v26 - 1, p_shared_owners));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
  }
  if (err)
    CFRelease(err);
  if (v17)
    CFRelease(v17);
  if (v19)
LABEL_40:
    v31((uint64_t)v30, 0);
  _Block_object_dispose(v38, 8);
  v27 = v40;
  if (v40)
  {
    v28 = (unint64_t *)&v40->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
}

void sub_183ED0DF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  const void *v18;
  uint64_t v19;

  if (v18)
    CFRelease(v18);
  _Block_object_dispose(&a18, 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v19 + 48);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection29_tlsProcessTrust_PolicyStrictENSt3__110shared_ptrIK8__CFDataEEU13block_pointerFviE_block_invoke(uint64_t a1, int a2)
{
  uint64_t v3;
  NSObject *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t *p_shared_owners;
  uint64_t v15;
  _QWORD v16[8];
  _BYTE buf[24];
  __n128 (*v18)(__n128 *, __n128 *);
  uint64_t (*v19)(uint64_t);
  void *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 48);
  if (!a2)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x4012000000;
    v18 = __Block_byref_object_copy__168;
    v19 = __Block_byref_object_dispose__169;
    v20 = &unk_18422E08D;
    std::allocate_shared[abi:nn180100]<CFNetworkTrust,std::allocator<CFNetworkTrust>,__SecTrust *,void>(&v21, *(const void **)(v3 + 448));
    v9 = *(_QWORD *)(*(_QWORD *)&buf[8] + 48);
    v10 = *(_QWORD *)(a1 + 56);
    v11 = *(unsigned int *)(a1 + 64);
    v12 = *(_QWORD *)(v3 + 120);
    v16[0] = MEMORY[0x1E0C809B0];
    v16[1] = 3221225472;
    v16[2] = ___ZN14NWIOConnection29_tlsProcessTrust_PolicyStrictENSt3__110shared_ptrIK8__CFDataEEU13block_pointerFviE_block_invoke_171;
    v16[3] = &unk_1E14F7F80;
    v13 = *(_QWORD *)(a1 + 40);
    v16[4] = *(_QWORD *)(a1 + 32);
    v16[5] = buf;
    v16[6] = v13;
    v16[7] = v3;
    CFNetworkTrust::strictEvaluateAsync(v9, v10, v11, v12, (uint64_t)v16);
    _Block_object_dispose(buf, 8);
    v6 = v22;
    if (!v22)
      return;
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    goto LABEL_13;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v5 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    v15 = *(_QWORD *)(v3 + 288);
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)&buf[4] = v15;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    _os_log_error_impl(&dword_183ECA000, v5, OS_LOG_TYPE_ERROR, "Connection %llu: system TLS Trust evaluation failed(%d)", buf, 0x12u);
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48, (__int128 *)buf);
  v6 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v7 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
LABEL_13:
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_183ED1064(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9);
  _Unwind_Resume(a1);
}

uint64_t CFNetworkTrust::strictEvaluateAsync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;

  result = SecTrustEvaluateFastAsync();
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 16))(a5, 4294957494);
  return result;
}

void NWIOConnection::_tlsProcessTrust_PolicyDefault(uint64_t a1, uint64_t a2)
{
  const __CFDictionary *Value;
  const void *v6;
  const void *v7;
  CFTypeID v8;
  const void *v9;
  const void *v10;
  CFTypeID v11;
  const void *v12;
  const void *v13;
  CFTypeID v14;
  const void *v15;
  const void *v16;
  CFTypeID v17;
  const void *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  int v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  _QWORD v29[2];
  void (*v30)(_QWORD *, int);
  void *v31;
  uint64_t v32;
  uint8_t *v33;
  uint8_t *v34;
  uint64_t v35;
  uint8_t v36[8];
  uint8_t *v37;
  uint64_t v38;
  __n128 (*v39)(__n128 *, __n128 *);
  uint64_t (*v40)(uint64_t);
  void *v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  uint8_t buf[8];
  uint8_t *v45;
  uint64_t v46;
  __n128 (*v47)(__n128 *, __n128 *);
  uint64_t (*v48)(uint64_t);
  void *v49;
  uint64_t v50;
  std::__shared_weak_count *v51;
  BOOL v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t (*v55)(uint64_t, int, SecTrustResultType);
  void *v56;
  _QWORD *v57;
  uint64_t v58;

  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EDCFC080);
  if (os_variant_allows_internal_security_policies())
  {
    if (Value && &unk_1EDCFC588 != 0)
    {
      v6 = CFDictionaryGetValue(Value, &unk_1EDCFC588);
      if (v6)
      {
        v7 = v6;
        v8 = CFGetTypeID(v6);
        if (v8 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
        }
        if ((const void *)*MEMORY[0x1E0C9AE40] == v7)
          goto LABEL_14;
      }
    }
  }
  v52 = 0;
  if (TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce != -1)
    dispatch_once(&TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce, &__block_literal_global_1699);
  TrustExceptionManager::applyTrustExceptions((TrustExceptionManager *)TrustExceptionManager::sharedTrustExceptionManager(void)::singleton, *(const __CFData **)(a1 + 432), *(__SecTrust **)(a1 + 448), &v52);
  if (v52)
  {
LABEL_14:
    (*(void (**)(uint64_t, _QWORD))(a2 + 16))(a2, 0);
  }
  else
  {
    *(_QWORD *)buf = 0;
    v45 = buf;
    v46 = 0x4012000000;
    v47 = __Block_byref_object_copy__168;
    v48 = __Block_byref_object_dispose__169;
    v49 = &unk_18422E08D;
    std::allocate_shared[abi:nn180100]<CFNetworkTrust,std::allocator<CFNetworkTrust>,__SecTrust *,void>(&v50, *(const void **)(a1 + 448));
    if (Value)
    {
      if (os_variant_allows_internal_security_policies())
      {
        if (&unk_1EDCFC358)
        {
          v9 = CFDictionaryGetValue(Value, &unk_1EDCFC358);
          v10 = v9;
          if (v9)
          {
            v11 = CFGetTypeID(v9);
            if (v11 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)v36 = 0;
              _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v36, 2u);
            }
            if ((const void *)*MEMORY[0x1E0C9AE50] == v10)
              *(_BYTE *)(*((_QWORD *)v45 + 6) + 33) |= 1u;
          }
        }
        if (&unk_1EDCFC390)
        {
          v12 = CFDictionaryGetValue(Value, &unk_1EDCFC390);
          v13 = v12;
          if (v12)
          {
            v14 = CFGetTypeID(v12);
            if (v14 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)v36 = 0;
              _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v36, 2u);
            }
            if ((const void *)*MEMORY[0x1E0C9AE50] == v13)
              *(_BYTE *)(*((_QWORD *)v45 + 6) + 33) |= 2u;
          }
        }
        if (&unk_1EDCFC320)
        {
          v15 = CFDictionaryGetValue(Value, &unk_1EDCFC320);
          v16 = v15;
          if (v15)
          {
            v17 = CFGetTypeID(v15);
            if (v17 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)v36 = 0;
              _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v36, 2u);
            }
            if ((const void *)*MEMORY[0x1E0C9AE50] == v16)
              *(_BYTE *)(*((_QWORD *)v45 + 6) + 33) |= 4u;
          }
        }
      }
      v18 = CFDictionaryGetValue(Value, &unk_1EDCFB2F0);
      if (v18)
      {
        v19 = *((_QWORD *)v45 + 6);
        *(_QWORD *)(v19 + 24) = CFRetain(v18);
      }
    }
    *(_QWORD *)v36 = 0;
    v37 = v36;
    v38 = 0x4012000000;
    v39 = __Block_byref_object_copy__165;
    v40 = __Block_byref_object_dispose__166;
    v42 = 0;
    v43 = 0;
    v41 = &unk_18422E08D;
    v20 = *(std::__shared_weak_count **)(a1 + 264);
    if (v20)
    {
      v43 = std::__shared_weak_count::lock(v20);
      if (v43)
        v42 = *(_QWORD *)(a1 + 256);
    }
    v21 = *((_QWORD *)v45 + 6);
    v29[0] = MEMORY[0x1E0C809B0];
    v29[1] = 3221225472;
    v30 = ___ZN14NWIOConnection30_tlsProcessTrust_PolicyDefaultEU13block_pointerFviE_block_invoke;
    v31 = &unk_1E14F7F80;
    v32 = a2;
    v33 = buf;
    v34 = v36;
    v35 = a1;
    v53 = MEMORY[0x1E0C809B0];
    v54 = 3221225472;
    v55 = ___ZN14CFNetworkTrust13evaluateAsyncEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvNS_14QuantizedErrorEE_block_invoke;
    v56 = &unk_1E14FB508;
    v57 = v29;
    v58 = v21;
    v22 = SecTrustEvaluateFastAsync();
    if (v22)
    {
      *(_DWORD *)(v21 + 40) = v22;
      *(_BYTE *)(v21 + 32) |= 0x20u;
      v30(v29, 2);
    }
    _Block_object_dispose(v36, 8);
    v23 = v43;
    if (v43)
    {
      p_shared_owners = (unint64_t *)&v43->__shared_owners_;
      do
        v25 = __ldaxr(p_shared_owners);
      while (__stlxr(v25 - 1, p_shared_owners));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    _Block_object_dispose(buf, 8);
    v26 = v51;
    if (v51)
    {
      v27 = (unint64_t *)&v51->__shared_owners_;
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
  }
}

void sub_183ED1650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  uint64_t v17;
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v17);
  _Unwind_Resume(a1);
}

void TrustExceptionManager::applyTrustExceptions(TrustExceptionManager *this, const __CFData *a2, __SecTrust *a3, BOOL *a4)
{
  os_unfair_lock_s *v7;
  const void *Value;
  const __CFData *v9;

  *a4 = 0;
  if (a2)
  {
    v7 = (os_unfair_lock_s *)((char *)this + 8);
    os_unfair_lock_lock((os_unfair_lock_t)this + 2);
    Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 3), a2);
    if (Value)
    {
      v9 = (const __CFData *)CFRetain(Value);
      os_unfair_lock_unlock(v7);
      if (v9)
      {
        if (a3)
          SecTrustSetExceptions(a3, v9);
        CFRelease(v9);
      }
    }
    else
    {
      os_unfair_lock_unlock(v7);
    }
  }
}

uint64_t ___ZN14NWIOConnection13setPropertiesEPK14__CFDictionary_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 200))(*(_QWORD *)(a1 + 32));
}

uint64_t CoreSchedulingSet::hash(CoreSchedulingSet *this)
{
  uint64_t v2;
  CFHashCode v3;
  CFHashCode v4;

  v2 = *((unsigned int *)this + 10);
  switch((_DWORD)v2)
  {
    case 3:
      v4 = *((_QWORD *)this + 7);
      goto LABEL_6;
    case 2:
      v2 += CFHash(*((CFTypeRef *)this + 6));
      return v2;
    case 1:
      v3 = CFHash(*((CFTypeRef *)this + 9));
      v4 = v3 + CFHash(*((CFTypeRef *)this + 10));
LABEL_6:
      v2 += v4;
      break;
  }
  return v2;
}

uint64_t CFAllocatedReferenceCountedObject::_retainable_release(CFAllocatedReferenceCountedObject *this, const __CFAllocator *a2, const void *a3)
{
  return (*(uint64_t (**)(const __CFAllocator *))(*(_QWORD *)a2 + 48))(a2);
}

void ___ZN14NWIOConnection13_tlsConfigureEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke(_QWORD *a1, std::__shared_weak_count_vtbl *a2, NSObject *a3, uint64_t a4)
{
  CFDictionaryRef *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  __SecTrust *v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  const void *Value;
  const void *v20;
  const void *v21;
  unint64_t v22;
  unint64_t v23;
  NSObject *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  TLSCallbackQueue **v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  void (*v39)(uint64_t);
  std::__shared_weak_count *v40;
  unint64_t *p_shared_weak_owners;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  char *v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t *v54;
  unint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  std::__shared_weak_count *shared_weak_owners;
  unint64_t v60;
  unint64_t *v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t *v64;
  unint64_t v65;
  unint64_t v66;
  std::__shared_weak_count *v67;
  std::__shared_weak_count *v68;
  uint64_t shared_owners;
  std::__shared_weak_count *v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  std::__shared_weak_count *v74;
  unint64_t *v75;
  unint64_t v76;
  TLSCallbackQueue *v77;
  std::__shared_weak_count *v78;
  std::__shared_weak_count *v79;
  unint64_t *v80;
  unint64_t v81;
  uint64_t *v82;
  _QWORD *v83;
  unint64_t *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t *v87;
  unint64_t v88;
  std::__shared_weak_count *v89;
  unint64_t *v90;
  unint64_t v91;
  std::__shared_weak_count *v92;
  unint64_t *v93;
  unint64_t v94;
  std::__shared_weak_count *v95;
  unint64_t *v96;
  unint64_t v97;
  TLSCallbackQueue **v98;
  uint64_t v99;
  std::__shared_weak_count *v100;
  _QWORD v101[7];
  std::__shared_weak_count *v102;
  std::__shared_weak_count_vtbl *v103;
  std::__shared_weak_count *v104;
  uint64_t v105;
  std::__shared_weak_count *v106;
  std::__shared_weak_count *v107;
  std::__shared_weak_count *v108;
  _QWORD aBlock[6];
  std::__shared_weak_count *v110;
  uint64_t v111;
  std::__shared_weak_count *v112;
  __int128 buf;
  uint64_t v114;
  uint64_t (*v115)(uint64_t, uint64_t);
  void (*v116)(uint64_t);
  std::__shared_weak_count *v117;
  const void *v118;
  std::__shared_weak_count *v119;
  __SecTrust *v120;
  std::__shared_weak_count *v121;
  uint64_t v122;

  v122 = *MEMORY[0x1E0C80C00];
  v6 = (CFDictionaryRef *)a1[4];
  v105 = 0;
  v106 = 0;
  v7 = (std::__shared_weak_count *)a1[6];
  if (!v7)
  {
    v10 = 0;
    goto LABEL_8;
  }
  v10 = std::__shared_weak_count::lock(v7);
  v106 = v10;
  if (!v10 || (v11 = a1[5], (v105 = v11) == 0))
  {
LABEL_8:
    (*(void (**)(uint64_t, _QWORD))(a4 + 16))(a4, 0);
    if (!v10)
      return;
    goto LABEL_9;
  }
  if ((*(_WORD *)(v11 + 248) & 0x60) != 0 || (*(_DWORD *)(v11 + 136) - 5) <= 2)
  {
    (*(void (**)(uint64_t, _QWORD))(a4 + 16))(a4, 0);
LABEL_9:
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    return;
  }
  sec_retain(a2);
  v103 = a2;
  v14 = (std::__shared_weak_count *)operator new();
  v14->__shared_owners_ = 0;
  v15 = (unint64_t *)&v14->__shared_owners_;
  v14->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1D68;
  v14->__shared_weak_owners_ = 0;
  v14[1].__vftable = a2;
  v104 = v14;
  v16 = sec_trust_copy_ref(a3);
  v101[6] = v16;
  v17 = (std::__shared_weak_count *)operator new();
  v17->__shared_owners_ = 0;
  v18 = (unint64_t *)&v17->__shared_owners_;
  v17->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1048;
  v17->__shared_weak_owners_ = 0;
  v17[1].__vftable = (std::__shared_weak_count_vtbl *)v16;
  v102 = v17;
  Value = CFDictionaryGetValue(v6[46], &unk_1EDCF9300);
  if (Value)
  {
    *(_QWORD *)&buf = 0;
    *((_QWORD *)&buf + 1) = &buf;
    v114 = 0x3812000000;
    v115 = __Block_byref_object_copy__131_3670;
    v116 = __Block_byref_object_dispose__132_3671;
    v117 = 0;
    v118 = 0;
    v101[0] = MEMORY[0x1E0C809B0];
    v101[1] = 3221225472;
    v101[2] = ___ZN14NWIOConnection13_tlsConfigureEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_133;
    v101[3] = &unk_1E14F7EE0;
    v101[4] = &buf;
    v101[5] = Value;
    (*((void (**)(CFDictionaryRef *, _QWORD *))*v6 + 43))(v6, v101);
    v20 = *(const void **)(*((_QWORD *)&buf + 1) + 48);
    if (v20)
      SecTrustSetPolicies(v16, v20);
    _Block_object_dispose(&buf, 8);
    v21 = v118;
    v118 = 0;
    if (v21)
      CFRelease(v21);
  }
  v99 = (uint64_t)a2;
  v100 = v14;
  do
    v22 = __ldxr(v15);
  while (__stxr(v22 + 1, v15));
  do
    v23 = __ldxr(v18);
  while (__stxr(v23 + 1, v18));
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v24 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v25 = *(_QWORD *)(v11 + 288);
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = v25;
    _os_log_impl(&dword_183ECA000, v24, OS_LOG_TYPE_DEFAULT, "Connection %llu: asked to evaluate TLS Trust", (uint8_t *)&buf, 0xCu);
  }
  if ((*(_WORD *)(v11 + 248) & 0x60) != 0 || (*(_DWORD *)(v11 + 136) - 5) <= 2)
  {
    (*(void (**)(uint64_t, _QWORD))(a4 + 16))(a4, 0);
    goto LABEL_29;
  }
  NWIOConnection::_watchdogTouch((NWIOConnection *)v11, 0);
  v35 = (TLSCallbackQueue **)(v11 + 400);
  if (!*(_QWORD *)(v11 + 400))
  {
    _ZNSt3__115allocate_sharedB8nn180100I16TLSCallbackQueueNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&buf);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v11 + 400, &buf);
    v36 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
    if (*((_QWORD *)&buf + 1))
    {
      v37 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }
    TLSCallbackQueue::initialize(*v35);
  }
  v39 = *(void (**)(uint64_t))(v11 + 256);
  v40 = *(std::__shared_weak_count **)(v11 + 264);
  v98 = v35;
  if (v40)
  {
    p_shared_weak_owners = (unint64_t *)&v40->__shared_weak_owners_;
    do
      v42 = __ldxr(p_shared_weak_owners);
    while (__stxr(v42 + 1, p_shared_weak_owners));
    *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
    *((_QWORD *)&buf + 1) = 3321888768;
    v114 = (uint64_t)___ZN14NWIOConnection36_tlsProcessValidateServerTrust_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEEU13block_pointerFvbE_block_invoke;
    v115 = (uint64_t (*)(uint64_t, uint64_t))&__block_descriptor_80_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE64c38_ZTSNSt3__110shared_ptrI10__SecTrustEE_e145_v16__0___v__B_shared_ptr___SecTrust______SecTrust_____shared_weak_count___shared_ptr_const___CFArray______CFArray_____shared_weak_count_____qi__8l;
    v116 = v39;
    v117 = v40;
    v43 = (unint64_t *)&v40->__shared_weak_owners_;
    do
      v44 = __ldxr(v43);
    while (__stxr(v44 + 1, v43));
  }
  else
  {
    *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
    *((_QWORD *)&buf + 1) = 3321888768;
    v114 = (uint64_t)___ZN14NWIOConnection36_tlsProcessValidateServerTrust_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEEU13block_pointerFvbE_block_invoke;
    v115 = (uint64_t (*)(uint64_t, uint64_t))&__block_descriptor_80_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE64c38_ZTSNSt3__110shared_ptrI10__SecTrustEE_e145_v16__0___v__B_shared_ptr___SecTrust______SecTrust_____shared_weak_count___shared_ptr_const___CFArray______CFArray_____shared_weak_count_____qi__8l;
    v116 = v39;
    v117 = 0;
  }
  v118 = (const void *)v99;
  v119 = v14;
  if (v14)
  {
    v45 = (unint64_t *)&v14->__shared_owners_;
    do
      v46 = __ldxr(v45);
    while (__stxr(v46 + 1, v45));
  }
  v120 = v16;
  v121 = v17;
  if (v17)
  {
    v47 = (unint64_t *)&v17->__shared_owners_;
    do
      v48 = __ldxr(v47);
    while (__stxr(v48 + 1, v47));
  }
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3321888768;
  aBlock[2] = ___ZN14NWIOConnection36_tlsProcessValidateServerTrust_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEEU13block_pointerFvbE_block_invoke_158;
  aBlock[3] = &unk_1E14F2ED0;
  aBlock[5] = v39;
  v110 = v40;
  if (v40)
  {
    v49 = (unint64_t *)&v40->__shared_weak_owners_;
    do
      v50 = __ldxr(v49);
    while (__stxr(v50 + 1, v49));
  }
  aBlock[4] = a4;
  v51 = (char *)operator new(0x88uLL);
  v52 = (std::__shared_weak_count *)v51;
  *((_QWORD *)v51 + 1) = 0;
  v53 = (unint64_t *)(v51 + 8);
  *((_QWORD *)v51 + 2) = 0;
  *(_QWORD *)v51 = &off_1E14F0D00;
  v111 = v99;
  v112 = v14;
  if (v14)
  {
    v54 = (unint64_t *)&v14->__shared_owners_;
    do
      v55 = __ldxr(v54);
    while (__stxr(v55 + 1, v54));
  }
  *(_OWORD *)(v51 + 120) = 0u;
  *((_QWORD *)v51 + 4) = 0;
  *((_QWORD *)v51 + 5) = 0;
  *((_QWORD *)v51 + 3) = &off_1E14EC6B0;
  *((_OWORD *)v51 + 4) = 0u;
  *(_OWORD *)(v51 + 104) = 0u;
  *((_OWORD *)v51 + 3) = 0u;
  *((_OWORD *)v51 + 5) = 0u;
  v51[96] = 0;
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)v51 + 8, v99, (uint64_t)v14);
  v52[3].__shared_owners_ = (uint64_t)_Block_copy(&buf);
  v56 = v52 + 1;
  v52[3].__shared_weak_owners_ = (uint64_t)_Block_copy(aBlock);
  if (v100)
  {
    v57 = (unint64_t *)&v100->__shared_owners_;
    do
      v58 = __ldaxr(v57);
    while (__stlxr(v58 - 1, v57));
    if (!v58)
    {
      ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
      std::__shared_weak_count::__release_weak(v100);
    }
  }
  v107 = v52 + 1;
  v108 = v52;
  shared_weak_owners = (std::__shared_weak_count *)v52[1].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    do
      v63 = __ldxr(v53);
    while (__stxr(v63 + 1, v53));
    v64 = (unint64_t *)&v52->__shared_weak_owners_;
    do
      v65 = __ldxr(v64);
    while (__stxr(v65 + 1, v64));
    v52[1].__shared_owners_ = (uint64_t)v56;
    v52[1].__shared_weak_owners_ = (uint64_t)v52;
    do
LABEL_90:
      v66 = __ldaxr(v53);
    while (__stlxr(v66 - 1, v53));
    if (!v66)
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
    goto LABEL_93;
  }
  if (shared_weak_owners->__shared_owners_ == -1)
  {
    do
      v60 = __ldxr(v53);
    while (__stxr(v60 + 1, v53));
    v61 = (unint64_t *)&v52->__shared_weak_owners_;
    do
      v62 = __ldxr(v61);
    while (__stxr(v62 + 1, v61));
    v52[1].__shared_owners_ = (uint64_t)v56;
    v52[1].__shared_weak_owners_ = (uint64_t)v52;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
    goto LABEL_90;
  }
LABEL_93:
  v67 = v107;
  v68 = (std::__shared_weak_count *)v107->__shared_weak_owners_;
  if (!v68 || (shared_owners = v107->__shared_owners_, (v70 = std::__shared_weak_count::lock(v68)) == 0))
  {
    std::__throw_bad_weak_ptr[abi:nn180100]();
    __break(1u);
    return;
  }
  v71 = v70;
  v72 = (unint64_t *)&v70->__shared_weak_owners_;
  do
    v73 = __ldxr(v72);
  while (__stxr(v73 + 1, v72));
  v74 = (std::__shared_weak_count *)v67[1].__shared_owners_;
  v67[1].__vftable = (std::__shared_weak_count_vtbl *)shared_owners;
  v67[1].__shared_owners_ = (uint64_t)v71;
  if (v74)
    std::__shared_weak_count::__release_weak(v74);
  v75 = (unint64_t *)&v71->__shared_owners_;
  do
    v76 = __ldaxr(v75);
  while (__stlxr(v76 - 1, v75));
  if (!v76)
  {
    ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
    std::__shared_weak_count::__release_weak(v71);
  }
  v77 = *v98;
  v79 = v107;
  v78 = v108;
  v111 = (uint64_t)v107;
  v112 = v108;
  if (v108)
  {
    v80 = (unint64_t *)&v108->__shared_owners_;
    do
      v81 = __ldxr(v80);
    while (__stxr(v81 + 1, v80));
  }
  v82 = (uint64_t *)*((_QWORD *)v77 + 6);
  v83 = operator new(0x30uLL);
  v83[2] = v79;
  v83[3] = v78;
  if (v78)
  {
    v84 = (unint64_t *)&v78->__shared_owners_;
    do
      v85 = __ldxr(v84);
    while (__stxr(v85 + 1, v84));
  }
  v83[4] = 0;
  v83[5] = 0;
  v83[1] = v82;
  v86 = *v82;
  *v83 = *v82;
  *(_QWORD *)(v86 + 8) = v83;
  *v82 = (uint64_t)v83;
  ++v82[2];
  TLSCallbackQueue::_invokeNextCallback(v77);
  if (v78)
  {
    v87 = (unint64_t *)&v78->__shared_owners_;
    do
      v88 = __ldaxr(v87);
    while (__stlxr(v88 - 1, v87));
    if (!v88)
    {
      ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
      std::__shared_weak_count::__release_weak(v78);
    }
  }
  v89 = v108;
  if (v108)
  {
    v90 = (unint64_t *)&v108->__shared_owners_;
    do
      v91 = __ldaxr(v90);
    while (__stlxr(v91 - 1, v90));
    if (!v91)
    {
      ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
      std::__shared_weak_count::__release_weak(v89);
    }
  }
  if (v110)
    std::__shared_weak_count::__release_weak(v110);
  v92 = v121;
  if (v121)
  {
    v93 = (unint64_t *)&v121->__shared_owners_;
    do
      v94 = __ldaxr(v93);
    while (__stlxr(v94 - 1, v93));
    if (!v94)
    {
      ((void (*)(std::__shared_weak_count *))v92->__on_zero_shared)(v92);
      std::__shared_weak_count::__release_weak(v92);
    }
  }
  v95 = v119;
  if (v119)
  {
    v96 = (unint64_t *)&v119->__shared_owners_;
    do
      v97 = __ldaxr(v96);
    while (__stlxr(v97 - 1, v96));
    if (!v97)
    {
      ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
      std::__shared_weak_count::__release_weak(v95);
    }
  }
  if (v117)
    std::__shared_weak_count::__release_weak(v117);
  if (v40)
    std::__shared_weak_count::__release_weak(v40);
  do
LABEL_29:
    v26 = __ldaxr(v18);
  while (__stlxr(v26 - 1, v18));
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  if (v100)
  {
    v27 = (unint64_t *)&v100->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
      std::__shared_weak_count::__release_weak(v100);
    }
  }
  v29 = v102;
  if (v102)
  {
    v30 = (unint64_t *)&v102->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v32 = v104;
  if (v104)
  {
    v33 = (unint64_t *)&v104->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  v10 = v106;
  if (v106)
    goto LABEL_9;
}

void sub_183ED20C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,char a22,uint64_t a23,char a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,std::__shared_weak_count *a34)
{
  std::__shared_weak_count *v34;
  uint64_t v35;
  std::__shared_weak_count *v37;

  if (a34)
    std::__shared_weak_count::__release_weak(a34);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v35 - 112);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v35 - 128);
  v37 = *(std::__shared_weak_count **)(v35 - 136);
  if (v37)
    std::__shared_weak_count::__release_weak(v37);
  if (v34)
    std::__shared_weak_count::__release_weak(v34);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a12);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a20);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a22);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a24);
  _Unwind_Resume(a1);
}

void NWIOConnection::withHostname(uint64_t a1, uint64_t a2)
{
  nw_endpoint_type_t type;
  NSObject *v5;
  BOOL v6;
  const __CFAllocator *v7;
  const char *hostname;
  CFStringRef v9;

  type = nw_endpoint_get_type(*(nw_endpoint_t *)(a1 + 304));
  v5 = *(NSObject **)(a1 + 304);
  if (v5)
    v6 = type - 1 > 1;
  else
    v6 = 1;
  if (v6)
  {
    v9 = 0;
  }
  else
  {
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    hostname = nw_endpoint_get_hostname(v5);
    v9 = CFStringCreateWithCString(v7, hostname, 0x8000100u);
  }
  (*(void (**)(uint64_t, CFStringRef, BOOL))(a2 + 16))(a2, v9, type == nw_endpoint_type_address);
  if (v9)
    CFRelease(v9);
}

void sub_183ED22A4(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void TLSCallbackQueue::initialize(TLSCallbackQueue *this)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_weak_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  void *v11;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v2 && (v3 = *((_QWORD *)this + 1), (v4 = std::__shared_weak_count::lock(v2)) != 0))
  {
    v5 = v4;
    p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v7 = __ldxr(p_shared_weak_owners);
    while (__stxr(v7 + 1, p_shared_weak_owners));
    v8 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
    *((_QWORD *)this + 3) = v3;
    *((_QWORD *)this + 4) = v5;
    if (v8)
      std::__shared_weak_count::__release_weak(v8);
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  else
  {
    v11 = (void *)std::__throw_bad_weak_ptr[abi:nn180100]();
    std::__shared_ptr_emplace<TLSCallbackServerTrust>::__on_zero_shared_weak(v11);
  }
}

CFHashCode _key_hash(const __CFString *cf)
{
  unint64_t isa_low;
  const __CFAllocator *v4;
  CFIndex Length;
  __CFString *MutableCopy;
  const __CFLocale *System;
  CFHashCode v8;

  if ((uint64_t)cf >= (uint64_t)&gConstantCFStringValueTable[1897]
    && (uint64_t)cf < (uint64_t)&gConstantCFStringValueTable[2373])
  {
    isa_low = LODWORD(cf[1].isa);
    if ((_DWORD)isa_low != 568)
      return gConstantCFStringValueTable[7 * ((isa_low >> 20) & 0x3FF) + 6];
  }
  v4 = CFGetAllocator(cf);
  Length = CFStringGetLength(cf);
  MutableCopy = CFStringCreateMutableCopy(v4, Length, cf);
  System = CFLocaleGetSystem();
  CFStringLowercase(MutableCopy, System);
  v8 = CFHash(MutableCopy);
  if (MutableCopy)
    CFRelease(MutableCopy);
  return v8;
}

CFStringRef CFHTTPCookieCopyName(void *a1)
{
  uint64_t v2;
  unsigned int *v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  const char *v7;
  const char *v8;

  v2 = objc_msgSend(a1, "_inner");
  v3 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  if (*v3 >= 0x18 && (v4 = v3[5], (_DWORD)v4) && (v5 = *v3, v5 > v4))
  {
    v6 = (char *)v3 + v4;
    v7 = (char *)v3 + v5;
    v8 = v6;
    while (*v8)
    {
      if (++v8 >= v7)
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    v6 = 0;
  }
  return createCookieString(a1, v6);
}

CFIndex CFHTTPMessageGetResponseStatusCode(CFHTTPMessageRef response)
{
  CFIndex result;
  int v3;

  if (!response)
    return 200;
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (!*((_BYTE *)response + 40))
    return 200;
  if (*((_QWORD *)response + 38))
    return *((int *)response + 36);
  if (*((_BYTE *)response + 176))
    return *((int *)response + 36);
  v3 = *((_DWORD *)response + 36);
  result = 200;
  if (v3 != -1 && v3 != 200)
    return *((int *)response + 36);
  return result;
}

CFTypeID CFNetServiceGetTypeID(void)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_1613;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = _CFNetServiceRegisterClass;
  if (_kCFNetServiceRegisterClass != -1)
    dispatch_once(&_kCFNetServiceRegisterClass, block);
  return _kCFNetServiceTypeID;
}

void CFURLRequestSetHTTPHeaderFieldValue(void *a1, const __CFString *a2, const __CFString *a3)
{
  URLRequest *v5;
  HTTPMessage *fHTTPRequest;
  void (**v7)(StringSerializable *__hidden);
  CFTypeRef cf;

  v5 = (URLRequest *)objc_msgSend(a1, "_inner");
  fHTTPRequest = (HTTPMessage *)v5->fHTTPRequest;
  if (!fHTTPRequest)
  {
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v7);
    URLRequest::createHTTPRequest(v5, (CFTypeRef *)&v7);
    v7 = &off_1E14E9A00;
    if (cf)
      CFRelease(cf);
    fHTTPRequest = (HTTPMessage *)v5->fHTTPRequest;
  }
  HTTPMessage::setHeaderFieldStringValue(fHTTPRequest, a2, a3);
}

void sub_183ED2610(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

CFStringRef CFHTTPCookieCopyDomain(void *a1)
{
  uint64_t v2;
  unsigned int *v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  const char *v7;
  const char *v8;

  v2 = objc_msgSend(a1, "_inner");
  v3 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  if (*v3 >= 0x14 && (v4 = v3[4], (_DWORD)v4) && (v5 = *v3, v5 > v4))
  {
    v6 = (char *)v3 + v4;
    v7 = (char *)v3 + v5;
    v8 = v6;
    while (*v8)
    {
      if (++v8 >= v7)
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    v6 = 0;
  }
  return createCookieString(a1, v6);
}

CFURLRef _CFURLRequestCopyProtocolPropertyForKey(void *a1, const __CFString *cf1)
{
  const __CFString *v4;
  CFURLRef v5;
  _QWORD v7[2];
  void (*v8)(uint64_t);
  void *v9;
  const __CFString *v10;

  if (!CFEqual(cf1, CFSTR("_kCFHTTPCookiePolicyPropertySiteForCookies")))
    return (CFURLRef)URLRequest::copyProtocolPropertyForKey(*(URLRequest **)(objc_msgSend(a1, "_inner") + 40), cf1);
  v4 = (const __CFString *)URLRequest::copyProtocolPropertyForKey(*(URLRequest **)(objc_msgSend(a1, "_inner") + 40), cf1);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v8 = ___CFURLRequestCopyProtocolPropertyForKey_block_invoke;
  v9 = &__block_descriptor_40_e5_v8__0l;
  v10 = v4;
  if (!v4)
    return (CFURLRef)URLRequest::copyProtocolPropertyForKey(*(URLRequest **)(objc_msgSend(a1, "_inner") + 40), cf1);
  v5 = CFURLCreateWithString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v4, 0);
  v8((uint64_t)v7);
  return v5;
}

void sub_183ED2778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  a12(&a10);
  _Unwind_Resume(a1);
}

CFStringRef CFHTTPCookieCopyPath(void *a1)
{
  uint64_t v2;
  unsigned int *v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  const char *v7;
  const char *v8;

  v2 = objc_msgSend(a1, "_inner");
  v3 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  if (*v3 >= 0x1C && (v4 = v3[6], (_DWORD)v4) && (v5 = *v3, v5 > v4))
  {
    v6 = (char *)v3 + v4;
    v7 = (char *)v3 + v5;
    v8 = v6;
    while (*v8)
    {
      if (++v8 >= v7)
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    v6 = 0;
  }
  return createCookieString(a1, v6);
}

CFStringRef CFHTTPMessageCopyRequestMethod(CFHTTPMessageRef request)
{
  const void *v3;

  if (!request)
    return 0;
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (!*((_BYTE *)request + 40) && (CFGetAllocator(request), (v3 = (const void *)*((_QWORD *)request + 21)) != 0))
    return (CFStringRef)CFRetain(v3);
  else
    return 0;
}

CFURLRef CFHTTPMessageCopyRequestURL(CFHTTPMessageRef request)
{
  const void *v2;

  if (request)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*((_BYTE *)request + 40))
    {
      v2 = (const void *)*((_QWORD *)request + 20);
      if (v2)
        return (CFURLRef)CFRetain(v2);
    }
    else
    {
      v2 = (const void *)HTTPRequestParserClient::requestURL((CFHTTPMessageRef)((char *)request + 144));
      if (v2)
        return (CFURLRef)CFRetain(v2);
    }
  }
  return 0;
}

CFStringRef CFHTTPMessageCopyHeaderFieldValue(CFHTTPMessageRef message, CFStringRef headerField)
{
  HTTPMessage *v4;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (message)
    v4 = (CFHTTPMessageRef)((char *)message + 16);
  else
    v4 = 0;
  return HTTPMessage::copyHeaderFieldValue(v4, headerField);
}

uint64_t _CookieSortForCopy(void *a1, void *a2, void *a3)
{
  uint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  const char *v10;
  const char *v11;
  uint64_t v12;
  unsigned int *v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  const char *v17;
  const char *v18;
  int v19;
  int v20;
  uint64_t v22;
  uint64_t v23;
  double v24;
  double v25;
  uint64_t v26;
  uint64_t v27;

  v5 = objc_msgSend(a1, "_inner", a3);
  v6 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 16))(v5);
  if (*v6 >= 0x1C && (v7 = v6[6], (_DWORD)v7) && (v8 = *v6, v8 > v7))
  {
    v9 = (char *)v6 + v7;
    v10 = (char *)v6 + v8;
    v11 = v9;
    while (*v11)
    {
      if (++v11 >= v10)
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    v9 = 0;
  }
  v12 = objc_msgSend(a2, "_inner");
  v13 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12);
  if (*v13 >= 0x1C)
  {
    v14 = v13[6];
    if ((_DWORD)v14)
    {
      v15 = *v13;
      if (v15 > v14)
      {
        v16 = (char *)v13 + v14;
        v17 = (char *)v13 + v15;
        v18 = v16;
        while (*v18)
        {
          if (++v18 >= v17)
            goto LABEL_14;
        }
        v19 = strlen(v16);
        if (!v9)
          goto LABEL_17;
LABEL_15:
        v20 = strlen(v9);
        goto LABEL_18;
      }
    }
  }
LABEL_14:
  v19 = 0;
  if (v9)
    goto LABEL_15;
LABEL_17:
  v20 = 0;
LABEL_18:
  if (v19 < v20)
    return -1;
  if (v19 != v20)
    return 1;
  v22 = objc_msgSend(a2, "_inner");
  v23 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v22 + 16))(v22);
  v24 = 0.0;
  v25 = 0.0;
  if (*(_DWORD *)v23 >= 0x38u)
    v25 = floor(*(double *)(v23 + 48));
  v26 = objc_msgSend(a1, "_inner");
  v27 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v26 + 16))(v26);
  if (*(_DWORD *)v27 >= 0x38u)
    v24 = floor(*(double *)(v27 + 48));
  if (v25 - v24 < 0.0)
    return -1;
  else
    return v25 - v24 > 0.0;
}

uint64_t _cookiePathDomainAndNameComparator(void *a1, void *a2, void *a3)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  _BYTE *v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  _BYTE *v17;
  int64_t v18;
  int64_t v19;
  unsigned int *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  _BYTE *v25;
  unsigned int *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  _BYTE *v31;
  unsigned int *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  _BYTE *v37;
  unsigned int *v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  char *v42;
  _BYTE *v43;
  int v45;
  int v46;
  int v47;

  v4 = objc_msgSend(a1, "_inner", a3);
  v5 = objc_msgSend(a2, "_inner");
  v6 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
  if (*v6 >= 0x1C && (v7 = v6[6], (_DWORD)v7) && (v8 = *v6, v8 > v7))
  {
    v9 = (unint64_t)v6 + v7;
    v10 = (char *)v6 + v8;
    v11 = (_BYTE *)v9;
    while (*v11)
    {
      if (++v11 >= v10)
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    v9 = 0;
  }
  v12 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 16))(v5);
  if (*v12 >= 0x1C && (v13 = v12[6], (_DWORD)v13) && (v14 = *v12, v14 > v13))
  {
    v15 = (unint64_t)v12 + v13;
    v16 = (char *)v12 + v14;
    v17 = (_BYTE *)v15;
    while (*v17)
    {
      if (++v17 >= v16)
        goto LABEL_14;
    }
  }
  else
  {
LABEL_14:
    v15 = 0;
  }
  if (v9)
  {
    v18 = strlen((const char *)v9);
    if (v15)
    {
LABEL_17:
      v19 = strlen((const char *)v15);
      goto LABEL_20;
    }
  }
  else
  {
    v18 = 0;
    if (v15)
      goto LABEL_17;
  }
  v19 = 0;
LABEL_20:
  if (v18 != v19)
  {
    if (v18 > v19)
      return -1;
    else
      return 1;
  }
  if (v9 | v15)
  {
    if (!v9 && v15)
      return 1;
    if (v9 && !v15)
      return -1;
    v45 = strcmp((const char *)v9, (const char *)v15);
    if (v45 < 0)
      return -1;
    if (v45)
      return 1;
  }
  v20 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
  if (*v20 >= 0x14 && (v21 = v20[4], (_DWORD)v21) && (v22 = *v20, v22 > v21))
  {
    v23 = (unint64_t)v20 + v21;
    v24 = (char *)v20 + v22;
    v25 = (_BYTE *)v23;
    while (*v25)
    {
      if (++v25 >= v24)
        goto LABEL_28;
    }
  }
  else
  {
LABEL_28:
    v23 = 0;
  }
  v26 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 16))(v5);
  if (*v26 >= 0x14 && (v27 = v26[4], (_DWORD)v27) && (v28 = *v26, v28 > v27))
  {
    v29 = (unint64_t)v26 + v27;
    v30 = (char *)v26 + v28;
    v31 = (_BYTE *)v29;
    while (*v31)
    {
      if (++v31 >= v30)
        goto LABEL_35;
    }
  }
  else
  {
LABEL_35:
    v29 = 0;
  }
  if (!(v23 | v29))
    goto LABEL_37;
  if (!v23 && v29)
    return 1;
  if (v23 && !v29)
    return -1;
  v46 = strcmp((const char *)v23, (const char *)v29);
  if (v46 < 0)
    return -1;
  if (v46)
    return 1;
LABEL_37:
  v32 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
  if (*v32 >= 0x18 && (v33 = v32[5], (_DWORD)v33) && (v34 = *v32, v34 > v33))
  {
    v35 = (unint64_t)v32 + v33;
    v36 = (char *)v32 + v34;
    v37 = (_BYTE *)v35;
    while (*v37)
    {
      if (++v37 >= v36)
        goto LABEL_43;
    }
  }
  else
  {
LABEL_43:
    v35 = 0;
  }
  v38 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 16))(v5);
  if (*v38 >= 0x18 && (v39 = v38[5], (_DWORD)v39) && (v40 = *v38, v40 > v39))
  {
    v41 = (unint64_t)v38 + v39;
    v42 = (char *)v38 + v40;
    v43 = (_BYTE *)v41;
    while (*v43)
    {
      if (++v43 >= v42)
        goto LABEL_50;
    }
  }
  else
  {
LABEL_50:
    v41 = 0;
  }
  if (!(v35 | v41))
    return 0;
  if (!v35 && v41)
    return 1;
  if (v35 && !v41)
    return -1;
  v47 = strcmp((const char *)v35, (const char *)v41);
  if (v47 < 0)
    return -1;
  else
    return v47 != 0;
}

CompactCookieHeader *CompactHTTPCookieReference::cookieHeader(CompactHTTPCookieReference *this)
{
  return this->var2;
}

CFTypeRef CFURLRequestCopyHTTPRequestMethod(void *a1)
{
  uint64_t v1;
  const void *v2;

  v1 = *(_QWORD *)(objc_msgSend(a1, "_inner") + 56);
  if (!v1)
  {
    v2 = &unk_1EDCFE118;
    return CFRetain(v2);
  }
  CFGetAllocator((CFTypeRef)(v1 - 16));
  v2 = *(const void **)(v1 + 152);
  if (v2)
    return CFRetain(v2);
  return 0;
}

uint64_t CFURLResponseGetExpectedContentLength(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  const __CFString *HeaderFieldValue;
  const __CFString *v4;
  uint64_t v5;

  v1 = objc_msgSend(a1, "_inner");
  v2 = *(_QWORD *)(v1 + 88);
  if (v2 && (*(_WORD *)(v2 + 297) & 0x100) == 0)
  {
    HeaderFieldValue = HTTPMessage::copyLastHeaderFieldValue((HTTPMessage *)v2, 0x11D1D2CFu);
    if (HeaderFieldValue)
    {
      v4 = HeaderFieldValue;
      v5 = CFNGetContentLengthFromHeaderFieldValue(HeaderFieldValue);
      CFRelease(v4);
    }
    else
    {
      v5 = -1;
    }
    *(_QWORD *)(v1 + 32) = v5;
    *(_WORD *)(*(_QWORD *)(v1 + 88) + 297) |= 0x100u;
  }
  return *(_QWORD *)(v1 + 32);
}

void HTTPMessage::setHeaderFieldStringValue(HTTPMessage *this, const __CFString *a2, const __CFString *a3)
{
  HTTPHeaderDict *v6;
  void (**v7)(StringSerializable *__hidden);
  CFTypeRef cf;
  void (**v9)(StringSerializable *__hidden);
  CFTypeRef v10;

  if (a3)
  {
    if (HTTPHeaderValue::isValid(a3, a2))
    {
      HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v9, a2);
      HTTPHeaderValueMixedValue::HTTPHeaderValueMixedValue((HTTPHeaderValueMixedValue *)&v7, a3);
      v6 = HTTPMessage::mutableHeaders(this);
      HTTPHeaderDict::setValue((uint64_t)v6, (uint64_t)&v9, (uint64_t)&v7);
      v7 = &off_1E14E9A00;
      if (cf)
        CFRelease(cf);
      v9 = &off_1E14E9A00;
      if (v10)
        CFRelease(v10);
    }
  }
  else
  {
    HTTPMessage::removeHeaderFieldValue(this, a2);
  }
}

void sub_183ED309C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef a10, uint64_t a11, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void HTTPHeaderDict::setValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const void *v6;
  const void *v7;
  CFTypeRef v8;
  void *v9;
  const __CFAllocator *v10;
  CFArrayRef v11;
  void *values;

  v6 = (const void *)(a1 - 16);
  CFGetAllocator((CFTypeRef)(a1 - 16));
  v7 = *(const void **)(a2 + 8);
  if (v7)
    v8 = CFRetain(v7);
  else
    v8 = 0;
  CFGetAllocator(v6);
  v9 = *(void **)(a3 + 8);
  if (v9)
    v9 = (void *)CFRetain(v9);
  values = v9;
  v10 = CFGetAllocator(v6);
  v11 = CFArrayCreate(v10, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 8), v8, v11);
  if (v11)
    CFRelease(v11);
  if (v8)
    CFRelease(v8);
  if (values)
    CFRelease(values);
}

CFDictionaryRef CFHTTPMessageCopyAllHeaderFields(CFHTTPMessageRef message)
{
  HTTPMessage *v2;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (message)
    v2 = (CFHTTPMessageRef)((char *)message + 16);
  else
    v2 = 0;
  return HTTPMessage::copyAllHeaderFields(v2);
}

void CompactHTTPCookieReference::~CompactHTTPCookieReference(CompactHTTPCookieReference *this)
{
  this->var0 = (void **)&off_1E14ED960;
  CFRelease((char *)this->var1 - 16);
  this->var0 = (void **)&off_1E14E5838;
  JUMPOUT(0x186DB748CLL);
}

{
  this->var0 = (void **)&off_1E14ED960;
  CFRelease((char *)this->var1 - 16);
  this->var0 = (void **)&off_1E14E5838;
}

void sub_183ED32A8(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t HTTPHeaderValue::isValid(const __CFString *this, const __CFString *a2)
{
  CFIndex Length;
  CFIndex v4;
  BOOL v5;
  CFIndex v6;
  int v7;
  int CharacterAtIndex;

  Length = CFStringGetLength(this);
  if (Length >= 1)
  {
    v4 = Length;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    while (1)
    {
      CharacterAtIndex = CFStringGetCharacterAtIndex(this, v6);
      if (CharacterAtIndex > 12)
      {
        if (CharacterAtIndex == 32)
        {
LABEL_12:
          if (v7 == 2)
          {
            v7 = 0;
          }
          else if (v7 == 1)
          {
            return v5 & (v7 == 0);
          }
          goto LABEL_18;
        }
        if (CharacterAtIndex != 13)
        {
LABEL_15:
          if (v7)
            return v5 & (v7 == 0);
          goto LABEL_18;
        }
        if (v7)
          return v5 & (v7 == 0);
        v7 = 1;
      }
      else
      {
        if (CharacterAtIndex == 9)
          goto LABEL_12;
        if (CharacterAtIndex != 10)
          goto LABEL_15;
        if (v7 != 1)
          return v5 & (v7 == 0);
        v7 = 2;
      }
LABEL_18:
      v5 = ++v6 >= v4;
      if (v4 == v6)
        return v5 & (v7 == 0);
    }
  }
  v7 = 0;
  v5 = 1;
  return v5 & (v7 == 0);
}

CFStringRef CFHTTPCookieCopyValue(void *a1)
{
  uint64_t v2;
  unsigned int *v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  const char *v7;
  const char *v8;

  v2 = objc_msgSend(a1, "_inner");
  v3 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  if (*v3 >= 0x20 && (v4 = v3[7], (_DWORD)v4) && (v5 = *v3, v5 > v4))
  {
    v6 = (char *)v3 + v4;
    v7 = (char *)v3 + v5;
    v8 = v6;
    while (*v8)
    {
      if (++v8 >= v7)
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    v6 = 0;
  }
  return createCookieString(a1, v6);
}

void CFHTTPCookieStorageSetCookie(_QWORD *a1, OpaqueCFHTTPCookie *a2)
{
  PrivateHTTPCookieStorage *v4;
  int CookieAcceptPolicy;
  _BYTE v6[104];

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
  {
    objc_msgSend(a1, "setCookie:", a2);
  }
  else
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
    v4 = (PrivateHTTPCookieStorage *)a1[4];
    if (v4)
      CookieAcceptPolicy = PrivateHTTPCookieStorage::getCookieAcceptPolicy(v4);
    else
      CookieAcceptPolicy = 2;
    HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v6, 0, 0, 0, CookieAcceptPolicy, 2, 0);
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
    HTTPCookieStorage::setCookie((HTTPCookieStorage *)(a1 + 2), a2, (const HTTPCookieStoragePolicy *)v6, 0, 1);
    HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v6);
  }
}

void sub_183ED3530(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

CFDataRef CFHTTPMessageCopyBody(CFHTTPMessageRef message)
{
  HTTPMessage *v2;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (message)
    v2 = (CFHTTPMessageRef)((char *)message + 16);
  else
    v2 = 0;
  return HTTPMessage::copyBody(v2);
}

uint64_t HTTPRequestParserClient::requestURL(HTTPRequestParserClient *this)
{
  unsigned __int8 *v2;
  int v3;
  int v4;
  CFDictionaryRef *v5;
  const __CFAllocator *v6;
  CFStringRef v7;
  const __CFString *v8;
  const __CFURL *v9;
  BOOL v10;
  size_t v11;
  CFURLRef v12;
  CFDictionaryRef *v13;
  const __CFAllocator *v14;
  CFStringRef v15;
  const char *v16;
  NSObject *v17;
  const char *v19;
  const __CFString *v20;
  _BYTE buf[22];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 5))
    return *((_QWORD *)this + 5);
  v2 = (unsigned __int8 *)*((_QWORD *)this + 4);
  if (!v2)
    goto LABEL_18;
  do
  {
    v4 = *v2++;
    v3 = v4;
    if (!v4)
      break;
    if (v3 == 58)
    {
      v9 = 0;
LABEL_15:
      v10 = v9 == 0;
      goto LABEL_16;
    }
  }
  while (v3 != 47);
  v5 = (CFDictionaryRef *)(*(uint64_t (**)(HTTPRequestParserClient *))(*(_QWORD *)this + 40))(this);
  v6 = (const __CFAllocator *)*((_QWORD *)this + 1);
  HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(buf, 0x12709302u);
  v7 = HTTPHeaderDict::copyStringValue(v5, v6, (const HTTPHeaderKeyMixedValue *)buf);
  *(_QWORD *)buf = &off_1E14E9A00;
  if (*(_QWORD *)&buf[8])
    CFRelease(*(CFTypeRef *)&buf[8]);
  if (v7)
  {
    v8 = CFStringCreateWithFormat(*((CFAllocatorRef *)this + 1), 0, CFSTR("http://%@/"), v7);
    v9 = CFURLCreateWithString(*((CFAllocatorRef *)this + 1), v8, 0);
    if (v8)
      CFRelease(v8);
    CFRelease(v7);
    if (v9)
      goto LABEL_15;
  }
  v9 = CFURLCreateWithString(*((CFAllocatorRef *)this + 1), CFSTR("fake://host/"), 0);
  if (!v9)
    goto LABEL_18;
  v10 = 0;
LABEL_16:
  v11 = strlen(*((const char **)this + 4));
  v12 = CFURLCreateWithBytes(*((CFAllocatorRef *)this + 1), *((const UInt8 **)this + 4), v11, 0x8000100u, v9);
  *((_QWORD *)this + 5) = v12;
  if (!v10)
  {
    CFRelease(v9);
LABEL_18:
    v12 = (CFURLRef)*((_QWORD *)this + 5);
  }
  if (!v12)
  {
    v13 = (CFDictionaryRef *)(*(uint64_t (**)(HTTPRequestParserClient *))(*(_QWORD *)this + 40))(this);
    v14 = (const __CFAllocator *)*((_QWORD *)this + 1);
    HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(buf, 0x12709302u);
    v15 = HTTPHeaderDict::copyStringValue(v13, v14, (const HTTPHeaderKeyMixedValue *)buf);
    *(_QWORD *)buf = &off_1E14E9A00;
    if (*(_QWORD *)&buf[8])
      CFRelease(*(CFTypeRef *)&buf[8]);
    v16 = (const char *)*((_QWORD *)this + 4);
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v17 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v19 = "null url string";
      if (v16)
        v19 = v16;
      v20 = CFSTR("no host header");
      if (v15)
        v20 = v15;
      *(_DWORD *)buf = 136380931;
      *(_QWORD *)&buf[4] = v19;
      *(_WORD *)&buf[12] = 2113;
      *(_QWORD *)&buf[14] = v20;
      _os_log_error_impl(&dword_183ECA000, v17, OS_LOG_TYPE_ERROR, "HTTPRequestParserClient: String '%{private}s' with base host '%{private}@' cannot create URL", buf, 0x16u);
      if (v15)
        goto LABEL_26;
    }
    else if (v15)
    {
LABEL_26:
      CFRelease(v15);
    }
  }
  return *((_QWORD *)this + 5);
}

void sub_183ED3844(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

CFTypeRef CFCachedURLResponseCopyReceiverDataArray(uint64_t a1)
{
  uint64_t v1;
  os_unfair_lock_s *v2;
  CFArrayRef v3;
  CFTypeRef v4;

  if (!a1)
    return 0;
  v1 = *(_QWORD *)(a1 + 16);
  v2 = (os_unfair_lock_s *)(v1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 88));
  v3 = *(CFArrayRef *)(v1 + 80);
  if (v3
    || *(_QWORD *)(v1 + 72)
    && (v3 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)(v1 + 72), 1, MEMORY[0x1E0C9B378]),
        (*(_QWORD *)(v1 + 80) = v3) != 0))
  {
    v4 = CFRetain(v3);
  }
  else
  {
    v4 = 0;
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

uint64_t estimatedPropertyListSize(void *a1)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  _QWORD v11[5];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE v16[128];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return objc_msgSend(a1, "length");
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return objc_msgSend(a1, "length");
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return 8;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return 8;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v12 = 0;
    v13 = &v12;
    v14 = 0x2020000000;
    v15 = 0;
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 3221225472;
    v11[2] = __estimatedPropertyListSize_block_invoke;
    v11[3] = &unk_1E14FD520;
    v11[4] = &v12;
    objc_msgSend(a1, "enumerateKeysAndObjectsUsingBlock:", v11);
    v3 = v13[3];
    _Block_object_dispose(&v12, 8);
  }
  else
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0
      && (v9 = 0u,
          v10 = 0u,
          v7 = 0u,
          v8 = 0u,
          (v4 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v7, v16, 16)) != 0))
    {
      v3 = 0;
      v5 = *(_QWORD *)v8;
      do
      {
        for (i = 0; i != v4; ++i)
        {
          if (*(_QWORD *)v8 != v5)
            objc_enumerationMutation(a1);
          v3 += estimatedPropertyListSize(*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8 * i));
        }
        v4 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v7, v16, 16);
      }
      while (v4);
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

void sub_183ED3B40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFTypeRef CFURLRequestCopyHTTPRequestBodyStream(void *a1)
{
  uint64_t v1;
  const void *v3;

  v1 = *(_QWORD *)(objc_msgSend(a1, "_inner") + 56);
  if (!v1)
    return 0;
  if (*(_QWORD *)(v1 + 208))
    return (CFTypeRef)CFReadStreamCreate();
  v3 = *(const void **)(v1 + 200);
  if (v3)
    return CFRetain(v3);
  else
    return 0;
}

void CompactHTTPCookieWithData::~CompactHTTPCookieWithData(CompactHTTPCookieWithData *this)
{
  this->var0 = (void **)&off_1E14ED370;
  CFAllocatorDeallocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], this->var1);
  this->var0 = (void **)&off_1E14E5838;
  JUMPOUT(0x186DB748CLL);
}

{
  this->var0 = (void **)&off_1E14ED370;
  CFAllocatorDeallocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], this->var1);
  this->var0 = (void **)&off_1E14E5838;
}

void sub_183ED3C70(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t CFURLRequestSetHTTPRequestBody(void *a1, uint64_t a2)
{
  URLRequest *v3;
  HTTPRequest *fHTTPRequest;
  void (**v6)(StringSerializable *__hidden);
  CFTypeRef cf;

  v3 = (URLRequest *)objc_msgSend(a1, "_inner");
  fHTTPRequest = v3->fHTTPRequest;
  if (!fHTTPRequest)
  {
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v6);
    URLRequest::createHTTPRequest(v3, (CFTypeRef *)&v6);
    v6 = &off_1E14E9A00;
    if (cf)
      CFRelease(cf);
    fHTTPRequest = v3->fHTTPRequest;
  }
  return (*(uint64_t (**)(HTTPRequest *, uint64_t))(*(_QWORD *)fHTTPRequest + 64))(fHTTPRequest, a2);
}

void sub_183ED3CF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

CFHTTPMessageRef CFHTTPMessageCreateCopy(CFAllocatorRef alloc, CFHTTPMessageRef message)
{
  HTTPResponseMessage *Instance;
  uint64_t v4;
  uint64_t v5;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (*((_BYTE *)message + 40))
  {
    Instance = (HTTPResponseMessage *)_CFRuntimeCreateInstance();
    if (Instance)
    {
      *((_OWORD *)Instance + 1) = 0u;
      Instance = (HTTPResponseMessage *)((char *)Instance + 16);
      *((_OWORD *)Instance + 17) = 0u;
      *((_OWORD *)Instance + 18) = 0u;
      *((_OWORD *)Instance + 15) = 0u;
      *((_OWORD *)Instance + 16) = 0u;
      *((_OWORD *)Instance + 13) = 0u;
      *((_OWORD *)Instance + 14) = 0u;
      *((_OWORD *)Instance + 11) = 0u;
      *((_OWORD *)Instance + 12) = 0u;
      *((_OWORD *)Instance + 9) = 0u;
      *((_OWORD *)Instance + 10) = 0u;
      *((_OWORD *)Instance + 7) = 0u;
      *((_OWORD *)Instance + 8) = 0u;
      *((_OWORD *)Instance + 5) = 0u;
      *((_OWORD *)Instance + 6) = 0u;
      *((_OWORD *)Instance + 3) = 0u;
      *((_OWORD *)Instance + 4) = 0u;
      *((_OWORD *)Instance + 1) = 0u;
      *((_OWORD *)Instance + 2) = 0u;
    }
    HTTPResponseMessage::HTTPResponseMessage(Instance, (const char **)message + 2);
  }
  else
  {
    v5 = _CFRuntimeCreateInstance();
    if (v5)
    {
      *(_OWORD *)(v5 + 16) = 0u;
      v5 += 16;
      *(_QWORD *)(v5 + 176) = 0;
      *(_OWORD *)(v5 + 144) = 0u;
      *(_OWORD *)(v5 + 160) = 0u;
      *(_OWORD *)(v5 + 112) = 0u;
      *(_OWORD *)(v5 + 128) = 0u;
      *(_OWORD *)(v5 + 80) = 0u;
      *(_OWORD *)(v5 + 96) = 0u;
      *(_OWORD *)(v5 + 48) = 0u;
      *(_OWORD *)(v5 + 64) = 0u;
      *(_OWORD *)(v5 + 16) = 0u;
      *(_OWORD *)(v5 + 32) = 0u;
    }
    HTTPRequestMessage::HTTPRequestMessage((HTTPRequestMessage *)v5, (CFHTTPMessageRef)((char *)message + 16));
  }
  return (CFHTTPMessageRef)(v4 - 16);
}

CFTypeRef _CFNetworkCopyPreferredLanguageCode()
{
  int v0;
  CFStringRef v1;
  BOOL v2;
  uint32_t v3;
  void *v5;
  double v6;
  double Helper_x8__InternationalSupportVersionNumber;
  uint64_t v8;
  void *v9;
  const __CFArray *v10;
  const __CFArray *v11;
  CFTypeID v12;
  const void *v13;
  CFTypeID v14;
  const __CFString *ValueAtIndex;
  const __CFString *v16;
  const __CFString *v17;
  CFIndex v18;
  CFMutableStringRef MutableCopy;
  CFIndex Length;
  CFStringRef v21;
  uint64_t v22;
  unint64_t v23;
  __CFString *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t i;
  __CFString *v28;
  CFTypeRef v29;
  uint8_t buf[4];
  int check;
  uint64_t v33;
  CFRange v34;

  os_unfair_lock_lock((os_unfair_lock_t)&_CFNetworkCopyPreferredLanguageCode::sLangLock);
  v0 = _CFNetworkCopyPreferredLanguageCode::sPreferredLanguageCodeChangedTokenChecked;
  if (!_CFNetworkCopyPreferredLanguageCode::sPreferredLanguageCodeChangedTokenChecked)
  {
    _CFNetworkCopyPreferredLanguageCode::sPreferredLanguageCodeChangedTokenChecked = 2;
    if (notify_register_check("AppleLanguagePreferencesChangedNotification", &_CFNetworkCopyPreferredLanguageCode::sPreferredLanguageCodeChangedToken))
    {
      v0 = _CFNetworkCopyPreferredLanguageCode::sPreferredLanguageCodeChangedTokenChecked;
    }
    else
    {
      v0 = 1;
      _CFNetworkCopyPreferredLanguageCode::sPreferredLanguageCodeChangedTokenChecked = 1;
    }
  }
  v1 = (CFStringRef)_CFNetworkCopyPreferredLanguageCode::sPreferredLanguageCode;
  if (_CFNetworkCopyPreferredLanguageCode::sPreferredLanguageCode)
    v2 = v0 == 1;
  else
    v2 = 0;
  if (v2)
  {
    check = 0;
    v3 = notify_check(_CFNetworkCopyPreferredLanguageCode::sPreferredLanguageCodeChangedToken, &check);
    v1 = (CFStringRef)_CFNetworkCopyPreferredLanguageCode::sPreferredLanguageCode;
    if (!v3 && check != 0)
    {
      _CFNetworkCopyPreferredLanguageCode::sPreferredLanguageCode = 0;
      if (v1)
      {
        CFRelease(v1);
        v1 = (CFStringRef)_CFNetworkCopyPreferredLanguageCode::sPreferredLanguageCode;
      }
    }
  }
  if (v1)
    goto LABEL_48;
  if (dyld_program_sdk_at_least())
  {
    v5 = (void *)MEMORY[0x186DB8C8C]();
    Helper_x8__InternationalSupportVersionNumber = gotLoadHelper_x8__InternationalSupportVersionNumber(v6);
    v9 = *(_QWORD *)(v8 + 3944)
       ? (void *)objc_msgSend(MEMORY[0x1E0C99DC8], "minimizedLanguagesFromLanguages:", objc_msgSend(MEMORY[0x1E0C99DC8], "preferredLanguages", Helper_x8__InternationalSupportVersionNumber)): 0;
    v22 = objc_msgSend(v9, "count");
    if (v22)
    {
      v23 = v22;
      v24 = (__CFString *)objc_msgSend(MEMORY[0x1E0CB37A0], "stringWithString:", objc_msgSend(v9, "objectAtIndexedSubscript:", 0));
      v25 = v23 >= 5 ? 5 : v23;
      if (v25 >= 2)
      {
        v26 = 9;
        for (i = 1; i != v25; ++i)
        {
          -[__CFString appendFormat:](v24, "appendFormat:", CFSTR(",%@;q=0.%u"),
            objc_msgSend(v9, "objectAtIndexedSubscript:", i),
            v26);
          v26 = (v26 - 1);
        }
      }
      v28 = v24;
    }
    else
    {
      v28 = CFSTR("en");
    }
    v1 = (CFStringRef)-[__CFString copy](v28, "copy");
    objc_autoreleasePoolPop(v5);
  }
  else
  {
    v10 = (const __CFArray *)CFPreferencesCopyAppValue(CFSTR("AppleLanguages"), (CFStringRef)*MEMORY[0x1E0C9B248]);
    if (v10)
    {
      v11 = v10;
      v12 = CFGetTypeID(v10);
      if (v12 == CFArrayGetTypeID()
        && CFArrayGetCount(v11)
        && (v13 = CFArrayGetValueAtIndex(v11, 0), v14 = CFGetTypeID(v13), v14 == CFStringGetTypeID()))
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v11, 0);
        v33 = 0;
        if (!CFBundleGetLocalizationInfoForLocalization()
          || (v16 = (const __CFString *)CFBundleCopyLocalizationForLocalizationInfo()) == 0
          || (v17 = v16,
              v18 = CFStringGetLength(v16),
              MutableCopy = CFStringCreateMutableCopy(0, v18, v17),
              CFRelease(v17),
              !MutableCopy))
        {
          Length = CFStringGetLength(ValueAtIndex);
          MutableCopy = CFStringCreateMutableCopy(0, Length, ValueAtIndex);
        }
        CFStringLowercase(MutableCopy, 0);
        if (CFStringGetLength(MutableCopy) >= 4 && CFStringGetCharacterAtIndex(MutableCopy, 2) == 95)
        {
          v34.location = 2;
          v34.length = 1;
          CFStringReplace(MutableCopy, v34, CFSTR("-"));
        }
        v21 = CFStringCompare(MutableCopy, CFSTR("ru-ru"), 0)
            ? CFStringCreateCopy(0, MutableCopy)
            : CFStringCreateWithBytes(0, (const UInt8 *)"ru", 2, 0x600u, 0);
        v1 = v21;
        CFRelease(MutableCopy);
      }
      else
      {
        v1 = (CFStringRef)objc_msgSend(CFSTR("en"), "copy");
      }
      CFRelease(v11);
    }
    else
    {
      v1 = (CFStringRef)objc_msgSend(CFSTR("en"), "copy");
    }
  }
  _CFNetworkCopyPreferredLanguageCode::sPreferredLanguageCode = (uint64_t)v1;
  if (v1
    || os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
    && (*(_WORD *)buf = 0,
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "We should have *something* here for language code", buf, 2u), (v1 = (CFStringRef)_CFNetworkCopyPreferredLanguageCode::sPreferredLanguageCode) != 0))
  {
LABEL_48:
    v29 = CFRetain(v1);
  }
  else
  {
    v29 = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFNetworkCopyPreferredLanguageCode::sLangLock);
  return v29;
}

CFTypeRef URLRequest::copyProtocolPropertyForKey(URLRequest *this, const __CFString *a2)
{
  const void *Value;

  if (this && (Value = CFDictionaryGetValue((CFDictionaryRef)this, a2)) != 0)
    return CFRetain(Value);
  else
    return 0;
}

const __CFArray *CFHTTPCookieStorageCopyCookiesForURL(_QWORD *a1, const void *a2, unsigned int a3)
{
  PrivateHTTPCookieStorage *v7;
  int CookieAcceptPolicy;
  const __CFArray *v9;
  _BYTE v10[104];

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
    return (const __CFArray *)(id)objc_msgSend(a1, "cookiesForURL:", a2);
  if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
    dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
  v7 = (PrivateHTTPCookieStorage *)a1[4];
  if (v7)
    CookieAcceptPolicy = PrivateHTTPCookieStorage::getCookieAcceptPolicy(v7);
  else
    CookieAcceptPolicy = 2;
  HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v10, a2, 0, 0, CookieAcceptPolicy, 0, 0);
  if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
    dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
  v9 = HTTPCookieStorage::copyCookiesForURL((HTTPCookieStorage *)(a1 + 2), (const HTTPCookieStoragePolicy *)v10, a3);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v10);
  return v9;
}

void sub_183ED437C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

CFTypeRef CFURLRequestSetHTTPRequestBodyStream(void *a1, CFTypeRef a2)
{
  uint64_t v3;
  HTTPRequest *fHTTPRequest;
  URLRequest *v5;
  CFTypeRef result;
  void (**v7)(StringSerializable *__hidden);
  CFTypeRef cf;

  v3 = objc_msgSend(a1, "_inner");
  fHTTPRequest = *(HTTPRequest **)(v3 + 56);
  if (!fHTTPRequest)
  {
    v5 = (URLRequest *)v3;
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v7);
    URLRequest::createHTTPRequest(v5, (CFTypeRef *)&v7);
    v7 = &off_1E14E9A00;
    if (cf)
      CFRelease(cf);
    fHTTPRequest = v5->fHTTPRequest;
  }
  (*(void (**)(HTTPRequest *, _QWORD))(*(_QWORD *)fHTTPRequest + 64))(fHTTPRequest, 0);
  result = (CFTypeRef)*((_QWORD *)fHTTPRequest + 25);
  if (result != a2)
  {
    if (result)
      CFRelease(result);
    if (a2)
      result = CFRetain(a2);
    else
      result = 0;
    *((_QWORD *)fHTTPRequest + 25) = result;
  }
  return result;
}

void sub_183ED443C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void HTTPRequest::setBody(HTTPRequest *this, const __CFData *a2)
{
  const void *v4;
  const void *v5;

  v4 = (const void *)*((_QWORD *)this + 26);
  if (v4)
  {
    CFRelease(v4);
    *((_QWORD *)this + 26) = 0;
  }
  v5 = (const void *)*((_QWORD *)this + 25);
  if (v5)
  {
    CFRelease(v5);
    *((_QWORD *)this + 25) = 0;
  }
  HTTPMessage::setBody((HTTPMessage *)this, a2);
}

void HTTPMessage::setBody(HTTPMessage *this, const __CFData *a2)
{
  const char *v4;
  void *v5;
  const __CFAllocator *v6;
  CFAllocatorRef v7;
  const void *v8;
  const void *v9;
  void *Copy;
  const char *v11;

  HTTPMessage::ensureParserFinished(this);
  v5 = (void *)*((_QWORD *)this + 6);
  if (a2)
  {
    if (!v5)
    {
      v6 = CFGetAllocator((char *)this - 16);
      v5 = CFAllocatorAllocate(v6, 32, 0);
      *(_OWORD *)v5 = 0u;
      *((_OWORD *)v5 + 1) = 0u;
      v7 = CFGetAllocator((char *)this - 16);
      *(_QWORD *)v5 = off_1E14E5A48;
      *((_QWORD *)v5 + 1) = v7;
      *((_QWORD *)this + 6) = v5;
    }
    if (*((const __CFData **)v5 + 2) != a2 && *((const __CFData **)v5 + 3) != a2)
    {
      HTTPBodyData::logit((HTTPBodyData *)v5, v4);
      v8 = (const void *)*((_QWORD *)v5 + 2);
      *((_QWORD *)v5 + 2) = 0;
      if (v8)
        CFRelease(v8);
      v9 = (const void *)*((_QWORD *)v5 + 3);
      *((_QWORD *)v5 + 3) = 0;
      if (v9)
        CFRelease(v9);
      if (dyld_program_sdk_at_least())
      {
        Copy = CFDataCreateCopy(*((CFAllocatorRef *)v5 + 1), a2);
      }
      else
      {
        if (__CFDataMtbl())
        {
          *((_QWORD *)v5 + 3) = CFDataCreateMutableCopy(*((CFAllocatorRef *)v5 + 1), 0, a2);
LABEL_20:
          HTTPBodyData::logit((HTTPBodyData *)v5, v11);
          return;
        }
        Copy = (void *)CFRetain(a2);
      }
      *((_QWORD *)v5 + 2) = Copy;
      goto LABEL_20;
    }
  }
  else
  {
    if (v5)
      (*(void (**)(_QWORD))(*(_QWORD *)v5 + 8))(*((_QWORD *)this + 6));
    *((_QWORD *)this + 6) = 0;
  }
}

CFHTTPMessageRef CFURLRequestCopyHTTPRequest(void *a1)
{
  uint64_t v1;
  const __CFURL *v2;
  const HTTPRequestMessage *v3;
  uint64_t Instance;
  uint64_t v5;

  v1 = objc_msgSend(a1, "_inner");
  v2 = *(const __CFURL **)(v1 + 8);
  if (!v2)
    return 0;
  v3 = *(const HTTPRequestMessage **)(v1 + 56);
  if (!v3)
    return CFHTTPMessageCreateRequest((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("GET"), v2, CFSTR("HTTP/1.1"));
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    Instance += 16;
    *(_QWORD *)(Instance + 176) = 0;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
  }
  HTTPRequestMessage::HTTPRequestMessage((HTTPRequestMessage *)Instance, v3);
  if (v5)
    return (CFHTTPMessageRef)(v5 - 16);
  else
    return 0;
}

id CFURLResponseCreateWithHTTPResponse(uint64_t a1, const void *a2, uint64_t a3, int a4)
{
  NSURLResponseInternal *v7;
  uint64_t v8;
  CFTypeRef v9;
  uint64_t Instance;
  uint64_t v11;
  const char **v12;
  id v13;

  v7 = objc_alloc_init(NSURLResponseInternal);
  v8 = -[NSURLResponseInternal _inner](v7, "_inner");
  if (a2)
    v9 = CFRetain(a2);
  else
    v9 = 0;
  *(_QWORD *)(v8 + 8) = v9;
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  Instance = _CFRuntimeCreateInstance();
  v11 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    v11 = Instance + 16;
    *(_QWORD *)(Instance + 352) = 0;
    *(_OWORD *)(Instance + 320) = 0u;
    *(_OWORD *)(Instance + 336) = 0u;
    *(_OWORD *)(Instance + 288) = 0u;
    *(_OWORD *)(Instance + 304) = 0u;
    *(_OWORD *)(Instance + 256) = 0u;
    *(_OWORD *)(Instance + 272) = 0u;
    *(_OWORD *)(Instance + 224) = 0u;
    *(_OWORD *)(Instance + 240) = 0u;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 208) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }
  if (a3)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*(_BYTE *)(a3 + 40))
      v12 = (const char **)(a3 + 16);
    else
      v12 = 0;
  }
  else
  {
    v12 = 0;
  }
  HTTPResponseMessage::HTTPResponseMessage((HTTPResponseMessage *)v11, v12);
  *(_QWORD *)v11 = &off_1E14E6048;
  *(_QWORD *)(v11 + 8) = &unk_1E14E60B8;
  *(_QWORD *)(v11 + 16) = &unk_1E14E60D8;
  *(_WORD *)(v11 + 297) = 0;
  *(_BYTE *)(v11 + 299) = 0;
  *(_QWORD *)(v8 + 88) = v11;
  *(_DWORD *)(v8 + 72) = a4;
  v13 = -[NSURLResponse _initWithInternal:]([NSHTTPURLResponse alloc], "_initWithInternal:", v7);

  return v13;
}

id _CFURLRequestCreateFromArchiveList(uint64_t a1, uint64_t a2, const void **a3, uint64_t a4, const __CFDictionary *a5)
{
  NSURLRequestInternal *v9;
  id v10;

  v9 = objc_alloc_init(NSURLRequestInternal);
  if (URLRequest::initialize((URLRequest *)-[NSURLRequestInternal _inner](v9, "_inner"), a2, a3, a4, a5))
  {
    if (v9)
    {
      v10 = -[NSURLRequest _initWithInternal:]([NSMutableURLRequest alloc], "_initWithInternal:", v9);

      return v10;
    }
  }
  else
  {

  }
  return 0;
}

CFDictionaryRef CFHTTPCookieCopyRequestHeaderFields(CFAllocatorRef allocator, CFArrayRef theArray)
{
  CFIndex Count;
  CFIndex v5;
  CFMutableStringRef Mutable;
  CFIndex i;
  uint64_t v8;
  __CFString *v9;
  __CFString *v10;
  unsigned int *v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  _BYTE *v15;
  unsigned int *v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  _BYTE *v20;
  CFIndex Length;
  __CFString *Copy;
  CFDictionaryRef v23;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  values = 0;
  keys[0] = &unk_1EDCFCF28;
  if (!theArray)
    return CFDictionaryCreate(allocator, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  Count = CFArrayGetCount(theArray);
  if (Count < 1)
    return CFDictionaryCreate(allocator, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v5 = Count;
  Mutable = CFStringCreateMutable(allocator, 0);
  for (i = 0; i != v5; ++i)
  {
    v8 = objc_msgSend((id)CFArrayGetValueAtIndex(theArray, i), "_inner");
    v9 = CFStringCreateMutable(allocator, 0);
    v10 = v9;
    if (i)
      CFStringAppendCString(v9, "; ", 0x8000100u);
    v11 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8);
    if (*v11 >= 0x18
      && (v12 = v11[5], (_DWORD)v12)
      && (v13 = (char *)v11 + v12, v14 = *v11, v15 = (char *)v11 + v12, v14 > v12))
    {
      while (*v15)
      {
        if (++v15 >= (_BYTE *)v11 + v14)
          goto LABEL_11;
      }
    }
    else
    {
LABEL_11:
      v13 = 0;
    }
    v16 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8);
    if (*v16 < 0x20
      || (v17 = v16[7], !(_DWORD)v17)
      || (v18 = (char *)v16 + v17, v19 = *v16, v20 = (char *)v16 + v17, v19 <= v17))
    {
LABEL_17:
      if (!v13)
        goto LABEL_19;
      goto LABEL_18;
    }
    while (*v20)
    {
      if (++v20 >= (_BYTE *)v16 + v19)
        goto LABEL_17;
    }
    if (v13)
    {
      CFStringAppendCString(v10, v13, 0x8000100u);
      CFStringAppendCString(v10, "=", 0x8000100u);
      v13 = v18;
LABEL_18:
      CFStringAppendCString(v10, v13, 0x8000100u);
    }
LABEL_19:
    Length = CFStringGetLength(Mutable);
    if (CFStringGetLength(v10) + Length <= 204842)
      CFStringAppend(Mutable, v10);
    CFRelease(v10);
  }
  Copy = (__CFString *)CFStringCreateCopy(allocator, Mutable);
  CFRelease(Mutable);
  if (!Copy)
    return CFDictionaryCreate(allocator, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  values = Copy;
  v23 = CFDictionaryCreate(allocator, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFRelease(Copy);
  if (!v23)
    return CFDictionaryCreate(allocator, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  return v23;
}

void HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy(HTTPCookieStoragePolicy *this)
{
  uint64_t v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  *(_QWORD *)this = &off_1E14ECAE8;
  v2 = *((_QWORD *)this + 1);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    *((_QWORD *)this + 1) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 2);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 3);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 4);
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 6);
  if (v6)
    CFRelease(v6);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 80);
}

{
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy(this);
  JUMPOUT(0x186DB748CLL);
}

void sub_183ED4C08(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 80);
  _Unwind_Resume(a1);
}

uint64_t HTTPCookieStoragePolicy::HTTPCookieStoragePolicy(uint64_t a1, const void *a2, const void *a3, uint64_t a4, int a5, int a6, const __CFDictionary *a7)
{
  *(_QWORD *)a1 = &off_1E14ECAE8;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_WORD *)(a1 + 96) = 0;
  HTTPCookieStoragePolicy::init(a1, a2, a3, a4, a5, a6, 0, 0, a7);
  return a1;
}

void sub_183ED4C70(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void HTTPCookieStoragePolicy::init(uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8, const __CFDictionary *a9)
{
  CFTypeRef v13;
  CFTypeRef v14;
  CFAllocatorRef *v15;
  CFStringRef v16;
  CFMutableDictionaryRef MutableCopy;
  _QWORD *v18;
  __int128 v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;

  *(_QWORD *)(a1 + 56) = a7;
  *(_QWORD *)(a1 + 64) = a8;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 40) = a5;
  if (cf)
    v13 = CFRetain(cf);
  else
    v13 = 0;
  *(_QWORD *)(a1 + 16) = v13;
  if (a3)
    v14 = CFRetain(a3);
  else
    v14 = 0;
  *(_QWORD *)(a1 + 24) = v14;
  v15 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (a4)
    v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@"), a4);
  else
    v16 = 0;
  *(_QWORD *)(a1 + 32) = v16;
  *(_QWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 72) = a6;
  if (a9)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(*v15, 0, a9);
    v18 = (_QWORD *)operator new();
    *v18 = &off_1E14F1588;
    v18[1] = 0;
    v18[2] = 0;
    v18[3] = MutableCopy;
    *(_QWORD *)&v19 = MutableCopy;
    *((_QWORD *)&v19 + 1) = v18;
    v20 = *(std::__shared_weak_count **)(a1 + 88);
    *(_OWORD *)(a1 + 80) = v19;
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        v22 = __ldaxr(p_shared_owners);
      while (__stlxr(v22 - 1, p_shared_owners));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
  }
  if (*(_BYTE *)(a1 + 97))
    *(_BYTE *)(a1 + 97) = 0;
}

uint64_t CFURLAuthChallengeCreate(uint64_t a1, const void *a2, const void *a3, uint64_t a4, void *a5, const void *a6)
{
  uint64_t Instance;
  CFTypeRef v12;
  CFTypeRef v13;
  CFTypeRef v14;

  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3745];
  *(_QWORD *)(Instance + 16) = &off_1E14E8348;
  *(_QWORD *)(Instance + 24) = &unk_1E14E83A0;
  if (a2)
    v12 = CFRetain(a2);
  else
    v12 = 0;
  *(_QWORD *)(Instance + 40) = v12;
  if (a3)
    v13 = CFRetain(a3);
  else
    v13 = 0;
  *(_QWORD *)(Instance + 48) = v13;
  *(_QWORD *)(Instance + 56) = a4;
  *(_QWORD *)(Instance + 64) = a5;
  if (a6)
    v14 = CFRetain(a6);
  else
    v14 = 0;
  *(_QWORD *)(Instance + 80) = 0;
  *(_QWORD *)(Instance + 88) = 0;
  *(_QWORD *)(Instance + 72) = v14;
  return Instance;
}

uint64_t PrivateHTTPCookieStorage::getCookieAcceptPolicy(PrivateHTTPCookieStorage *this)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  v2 = dispatch_semaphore_create(0);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZNK24PrivateHTTPCookieStorage21getCookieAcceptPolicyEv_block_invoke;
  v6[3] = &unk_1E14FB348;
  v6[4] = v2;
  v6[5] = &v7;
  v3 = *((_QWORD *)this + 4);
  if (v3)
    pthread_mutex_lock((pthread_mutex_t *)(v3 + 8));
  (*(void (**)(PrivateHTTPCookieStorage *, _QWORD *))(*(_QWORD *)this + 176))(this, v6);
  if (v3)
    pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
  dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v2);
  v4 = *((unsigned int *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_183ED4FBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

intptr_t ___ZNK24PrivateHTTPCookieStorage21getCookieAcceptPolicyEv_block_invoke(uint64_t a1, int a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a2;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t DiskCookieStorage::getCookieAcceptPolicyLocked(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a2 + 16))(a2, *(unsigned int *)(a1 + 320));
}

void HTTPMessage::setMultipleHeaderFields(HTTPMessage *this, CFDictionaryRef theDict)
{
  const void *Value;
  const __CFString *v5;
  const __CFString *v6;
  const __CFAllocator *v7;
  const __CFData *v8;
  CFPropertyListRef v9;
  const void *v10;
  CFTypeID v11;
  unint64_t Count;
  const void **v13;
  unint64_t v14;
  const void **v15;
  unint64_t v16;
  const void **v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  const void **v21;
  uint64_t v22;
  uint64_t v23;
  const __CFString *v24;
  CFTypeID v25;
  const void *v26;
  CFTypeID v27;
  unint64_t v28;
  CFRange v29;
  const void **v30;
  CFIndex v31;
  const void *v32;
  CFTypeID v33;
  HTTPHeaderDict *v34;
  void (**v35)(StringSerializable *__hidden);
  CFTypeRef cf;
  void (**v37)(StringSerializable *__hidden);
  CFTypeRef v38;
  CFTypeRef v39;
  CFIndex range;
  const void **v41;
  _BYTE v42[248];
  CFIndex v43;
  void (**v44)(StringSerializable *__hidden);
  CFTypeRef v45;
  CFTypeRef v46;
  unint64_t v47;
  const void **v48;
  _BYTE v49[248];
  CFTypeRef v50;
  uint64_t v51;
  const void **v52;
  _BYTE v53[256];

  Value = CFDictionaryGetValue(theDict, CFSTR("__hhaa__"));
  if (Value)
  {
    v5 = (const __CFString *)CFRetain(Value);
    if (v5)
    {
      v6 = v5;
      v7 = CFGetAllocator((char *)this - 16);
      if (CFStringGetLength(v6) < 5)
        goto LABEL_64;
      v8 = (const __CFData *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBase64EncodedString:options:", v6, 1);
      if (!v8)
        goto LABEL_64;
      v9 = CFPropertyListCreateWithData(v7, v8, 0, 0, 0);
      v10 = v9;
      if (!v9)
        goto LABEL_63;
      v11 = CFGetTypeID(v9);
      if (v11 != CFDictionaryGetTypeID())
      {
        CFRelease(v10);
LABEL_63:
        CFRelease(v8);
        goto LABEL_64;
      }
      CFRelease(v8);
      v8 = (const __CFData *)CFRetain(v10);
      CFRelease(v10);
      if (!v8)
      {
LABEL_64:
        CFRelease(v6);
        return;
      }
      v46 = CFRetain(v8);
      Count = CFDictionaryGetCount(v8);
      v47 = Count;
      if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
      {
        v48 = 0;
        goto LABEL_33;
      }
      if (Count > 0x1E)
      {
        v13 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
        v48 = v13;
        if (!v13)
          goto LABEL_33;
      }
      else
      {
        v13 = (const void **)v49;
        v48 = (const void **)v49;
      }
      CFDictionaryGetKeysAndValues(v8, v13, 0);
LABEL_33:
      v50 = CFRetain(v8);
      v20 = CFDictionaryGetCount(v8);
      v51 = v20;
      if (v20 - 1 > 0x1FFFFFFFFFFFFFFDLL)
      {
        v52 = 0;
      }
      else
      {
        if (v20 <= 0x1E)
        {
          v21 = (const void **)v53;
          v52 = (const void **)v53;
LABEL_38:
          CFDictionaryGetKeysAndValues(v8, 0, v21);
          goto LABEL_39;
        }
        v21 = (const void **)malloc_type_malloc(8 * v20, 0x89ED541CuLL);
        v52 = v21;
        if (v21)
          goto LABEL_38;
      }
LABEL_39:
      v22 = v51;
      if (v51 >= 1)
      {
        v23 = 0;
        while (1)
        {
          v24 = (const __CFString *)v48[v23];
          v25 = CFGetTypeID(v24);
          if (v25 != CFStringGetTypeID())
            goto LABEL_61;
          v26 = v52[v23];
          v27 = CFGetTypeID(v26);
          if (v27 != CFArrayGetTypeID())
            goto LABEL_61;
          HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v44, v24);
          if (v26)
            break;
          v39 = 0;
          range = 0;
          v41 = (const void **)v42;
          v43 = 0;
LABEL_59:
          CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v39);
          v44 = &off_1E14E9A00;
          if (v45)
            CFRelease(v45);
LABEL_61:
          if (++v23 == v22)
            goto LABEL_62;
        }
        v39 = CFRetain(v26);
        v28 = CFArrayGetCount((CFArrayRef)v26);
        v29.length = v28;
        range = v28;
        if (v28 - 1 > 0x1FFFFFFFFFFFFFFDLL)
        {
          v41 = 0;
          goto LABEL_51;
        }
        if (v28 > 0x1E)
        {
          v30 = (const void **)malloc_type_malloc(8 * v28, 0x89ED541CuLL);
          v41 = v30;
          v29.length = range;
          if (!v30)
            goto LABEL_51;
        }
        else
        {
          v41 = (const void **)v42;
          v30 = (const void **)v42;
        }
        v29.location = 0;
        CFArrayGetValues((CFArrayRef)v26, v29, v30);
        v29.length = range;
LABEL_51:
        v43 = 0;
        if (v29.length >= 1)
        {
          v31 = 0;
          do
          {
            v43 = v31 + 1;
            v32 = v41[v31];
            v33 = CFGetTypeID(v32);
            if (v33 == CFStringGetTypeID())
            {
              HTTPHeaderValueMixedValue::HTTPHeaderValueMixedValue((HTTPHeaderValueMixedValue *)&v37, v32);
              v34 = HTTPMessage::mutableHeaders(this);
              HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v35, v24);
              HTTPHeaderDict::addValue((uint64_t)v34, (uint64_t)&v35, (uint64_t)&v37);
              v35 = &off_1E14E9A00;
              if (cf)
                CFRelease(cf);
              v37 = &off_1E14E9A00;
              if (v38)
                CFRelease(v38);
            }
            v31 = v43;
          }
          while (v43 < range);
        }
        goto LABEL_59;
      }
LABEL_62:
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v50);
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v46);
      goto LABEL_63;
    }
  }
  if (!theDict)
  {
    v46 = 0;
    v47 = 0;
    v48 = (const void **)v49;
    v50 = 0;
    v51 = 0;
    v52 = (const void **)v53;
    goto LABEL_25;
  }
  v46 = CFRetain(theDict);
  v14 = CFDictionaryGetCount(theDict);
  v47 = v14;
  if (v14 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v48 = 0;
    goto LABEL_19;
  }
  if (v14 > 0x1E)
  {
    v15 = (const void **)malloc_type_malloc(8 * v14, 0x89ED541CuLL);
    v48 = v15;
    if (!v15)
      goto LABEL_19;
  }
  else
  {
    v15 = (const void **)v49;
    v48 = (const void **)v49;
  }
  CFDictionaryGetKeysAndValues(theDict, v15, 0);
LABEL_19:
  v50 = CFRetain(theDict);
  v16 = CFDictionaryGetCount(theDict);
  v51 = v16;
  if (v16 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v52 = 0;
  }
  else
  {
    if (v16 <= 0x1E)
    {
      v17 = (const void **)v53;
      v52 = (const void **)v53;
LABEL_24:
      CFDictionaryGetKeysAndValues(theDict, 0, v17);
      goto LABEL_25;
    }
    v17 = (const void **)malloc_type_malloc(8 * v16, 0x89ED541CuLL);
    v52 = v17;
    if (v17)
      goto LABEL_24;
  }
LABEL_25:
  v18 = v51;
  if (v51 >= 1)
  {
    v19 = 0;
    do
    {
      HTTPMessage::setHeaderFieldStringValue(this, (const __CFString *)v48[v19], (const __CFString *)v52[v19]);
      ++v19;
    }
    while (v18 != v19);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v50);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v46);
}

void sub_183ED5550(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFContainerEnumeratorBase *a10, uint64_t a11, CFTypeRef a12, uint64_t a13, CFTypeRef a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,CFTypeRef cf,char a52)
{
  const void *v52;
  const void *v53;
  CFContainerEnumeratorBase *v54;

  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v54);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&a52);
  CFRelease(v53);
  CFRelease(v52);
  _Unwind_Resume(a1);
}

void HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(HTTPHeaderKeyMixedValue *this, CFStringRef theString)
{
  const __CFString *v2;
  __darwin_ct_rune_t CharacterAtIndex;
  unsigned int CanonicalString;
  CFTypeRef v6;

  v2 = theString;
  *(_QWORD *)this = &off_1E14ECB08;
  *((_QWORD *)this + 1) = 0;
  if (CFStringGetLength(theString) < 2
    || (CharacterAtIndex = CFStringGetCharacterAtIndex(v2, 0), __tolower(CharacterAtIndex) != 120)
    || CFStringGetCharacterAtIndex(v2, 1) != 45)
  {
    CanonicalString = _findCanonicalString(v2, 5u);
    if (CanonicalString == 568)
    {
      if (!v2)
        goto LABEL_8;
    }
    else
    {
      v2 = (const __CFString *)&gConstantCFStringValueTable[7 * ((CanonicalString >> 20) & 0x3FF)];
    }
LABEL_10:
    v6 = CFRetain(v2);
    goto LABEL_11;
  }
  if (v2)
    goto LABEL_10;
LABEL_8:
  v6 = 0;
LABEL_11:
  *((_QWORD *)this + 1) = v6;
}

void sub_183ED5708(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  const void *v3;

  *v1 = &off_1E14E9A00;
  v3 = (const void *)v1[1];
  if (v3)
    CFRelease(v3);
  _Unwind_Resume(exception_object);
}

uint64_t _findCanonicalString(CFStringRef theString, unsigned int a2)
{
  uint64_t v4;
  uint64_t result;
  CFIndex Length;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  CFIndex FastestEncoding;
  _DWORD *v13;
  size_t v14;
  size_t v15;
  _DWORD *v16;
  int v17;
  uint64_t v18;
  char *v19;
  size_t v20;
  size_t v21;
  _QWORD *v22;
  unsigned __int16 *v23;
  unsigned __int16 *v24;
  unsigned int v25;
  _QWORD v26[6];
  _QWORD v27[2];
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (!theString)
    return 568;
  v4 = a2;
  if ((uint64_t)&gConstantCFStringValueTable[7 * sDomainRanges[8 * a2]] <= (uint64_t)theString
    && (uint64_t)&gConstantCFStringValueTable[7 * sDomainRanges[8 * a2 + 1]] > (uint64_t)theString)
  {
    result = LODWORD(theString[1].isa);
    if ((_DWORD)result != 568)
      return result;
  }
  Length = CFStringGetLength(theString);
  if (Length >= 0x8000)
    return 568;
  v7 = &sDomainRanges[8 * v4];
  v8 = v7[2];
  if (v8 > (unsigned __int16)Length || v7[3] < (unsigned __int16)Length || a2 == 16)
    return 568;
  v9 = *(_QWORD *)&sDomainRanges[8 * v4 + 4];
  v10 = (unsigned __int16)Length - v8;
  v11 = (int *)(v9 + 16 * v10);
  v31 = 0uLL;
  v32 = 0;
  FastestEncoding = CFStringGetFastestEncoding(theString);
  if ((int)FastestEncoding > 1535)
  {
    if ((int)FastestEncoding > 3070)
    {
      if ((_DWORD)FastestEncoding != 134217984 && (_DWORD)FastestEncoding != 3071)
        goto LABEL_40;
    }
    else if ((_DWORD)FastestEncoding != 1536 && (_DWORD)FastestEncoding != 2817)
    {
      goto LABEL_40;
    }
  }
  else if ((int)FastestEncoding > 512)
  {
    if ((_DWORD)FastestEncoding != 513 && (_DWORD)FastestEncoding != 1280)
      goto LABEL_40;
  }
  else if ((_DWORD)FastestEncoding && (_DWORD)FastestEncoding != 256)
  {
    goto LABEL_40;
  }
  FastestEncoding = (CFIndex)CFStringGetCStringPtr(theString, FastestEncoding);
  if (FastestEncoding)
  {
    v13 = (_DWORD *)FastestEncoding;
    v14 = strlen((const char *)FastestEncoding);
    FastestEncoding = CFStringGetLength(theString);
    if (FastestEncoding == v14)
    {
      if (!v14)
      {
        v31 = 0uLL;
        v32 = 0;
LABEL_51:
        v27[0] = v13;
        v27[1] = v14;
        v28 = v31;
        v29 = v32;
        v30 = 0;
        v22 = v27;
        return findSaneCStringInIndices((uint64_t)v22, (unsigned int *)(v9 + 16 * v10));
      }
      v15 = v14;
      v16 = v13;
      while ((v15 & 3) - 2 >= 2)
      {
        if ((v15 & 3) == 1)
        {
LABEL_34:
          if (*(char *)v16 < 0)
            goto LABEL_40;
          v16 = (_DWORD *)((char *)v16 + 1);
          if (!--v15)
            goto LABEL_39;
        }
        else
        {
          if ((*v16 & 0x80808080) != 0)
            goto LABEL_40;
          ++v16;
          v15 -= 4;
          if (!v15)
          {
LABEL_39:
            v31 = 0uLL;
            v32 = 0;
            goto LABEL_51;
          }
        }
      }
      if ((*(_WORD *)v16 & 0x8080) != 0)
        goto LABEL_40;
      v15 -= 2;
      if (!v15)
        goto LABEL_39;
      v16 = (_DWORD *)((char *)v16 + 2);
      goto LABEL_34;
    }
  }
LABEL_40:
  v31 = 0uLL;
  v32 = 0;
  v17 = *v11;
  if (*v11 >= 6)
  {
    MEMORY[0x1E0C80A78](FastestEncoding);
    v19 = (char *)v26 - ((v18 + 16) & 0xFFFFFFFFFFFFFFF0);
    bzero(v19, v20);
    if (CFStringGetCString(theString, v19, 8, 0x8000100u))
    {
      v21 = strlen(v19);
      memset(&v26[2], 0, 32);
      v26[0] = v19;
      v26[1] = v21;
      v22 = v26;
      return findSaneCStringInIndices((uint64_t)v22, (unsigned int *)(v9 + 16 * v10));
    }
    v17 = *v11;
  }
  if (v17 < 1)
    return 568;
  v23 = *(unsigned __int16 **)(v9 + 16 * v10 + 8);
  v24 = &v23[v17];
  while (1)
  {
    v25 = *v23;
    if (CFStringCompare((CFStringRef)&gConstantCFStringValueTable[7 * *v23], theString, 1uLL) == kCFCompareEqualTo)
      break;
    if (++v23 >= v24)
      return 568;
  }
  return LODWORD(gConstantCFStringValueTable[7 * v25 + 4]);
}

uint64_t findSaneCStringInIndices(uint64_t a1, unsigned int *a2)
{
  uint64_t v2;
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  unsigned int v7;
  int v8;

  v2 = *a2;
  if ((int)v2 < 1)
    return 568;
  v4 = (unsigned __int16 *)*((_QWORD *)a2 + 1);
  v5 = &v4[v2];
  while (1)
  {
    v6 = (unsigned __int16 *)((char *)v4 + ((v5 - v4 + (v5 - v4 < 0)) & 0xFFFFFFFFFFFFFFFELL));
    v7 = *v6;
    v8 = strncasecmp_l(*(const char **)a1, (const char *)gConstantCFStringValueTable[7 * *v6 + 2], *(_QWORD *)(a1 + 8), (locale_t)0xFFFFFFFFFFFFFFFFLL);
    if (!v8)
      break;
    if (v8 < 0)
      v5 = (unsigned __int16 *)((char *)v4 + ((v5 - v4 + (v5 - v4 < 0)) & 0xFFFFFFFFFFFFFFFELL));
    else
      v4 = v6 + 1;
    if (v4 >= v5)
      return 568;
  }
  return LODWORD(gConstantCFStringValueTable[7 * v7 + 4]);
}

HTTPHeaderDict *HTTPMessage::mutableHeaders(HTTPMessage *this)
{
  HTTPHeaderDict *v1;
  uint64_t v3;
  uint64_t Instance;
  uint64_t v5;
  const __CFAllocator *v6;

  v1 = (HTTPHeaderDict *)*((_QWORD *)this + 12);
  if (!v1)
  {
    v3 = *((_QWORD *)this + 13);
    CFGetAllocator((char *)this - 16);
    if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1)
      dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_14190);
    Instance = _CFRuntimeCreateInstance();
    v1 = (HTTPHeaderDict *)Instance;
    if (Instance)
    {
      *(_QWORD *)(Instance + 16) = 0;
      *(_QWORD *)(Instance + 24) = 0;
      v1 = (HTTPHeaderDict *)(Instance + 16);
    }
    if (v3)
    {
      v5 = *((_QWORD *)this + 13);
      *(_QWORD *)v1 = &off_1E14E6D78;
      v6 = CFGetAllocator((char *)v1 - 16);
      *((_QWORD *)v1 + 1) = CFDictionaryCreateMutableCopy(v6, 0, *(CFDictionaryRef *)(v5 + 8));
      *((_QWORD *)this + 12) = v1;
      CFRelease((CFTypeRef)(*((_QWORD *)this + 13) - 16));
      *((_QWORD *)this + 13) = 0;
      return (HTTPHeaderDict *)*((_QWORD *)this + 12);
    }
    else
    {
      HTTPHeaderDict::HTTPHeaderDict(v1);
      *((_QWORD *)this + 12) = v1;
    }
  }
  return v1;
}

void HTTPHeaderValueMixedValue::HTTPHeaderValueMixedValue(HTTPHeaderValueMixedValue *this, CFTypeRef cf)
{
  CFTypeRef v3;

  *(_QWORD *)this = &off_1E14ED488;
  *((_QWORD *)this + 1) = 0;
  if (cf)
    v3 = CFRetain(cf);
  else
    v3 = 0;
  *((_QWORD *)this + 1) = v3;
}

void sub_183ED5C48(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  const void *v3;

  *v1 = &off_1E14E9A00;
  v3 = (const void *)v1[1];
  if (v3)
    CFRelease(v3);
  _Unwind_Resume(exception_object);
}

void CFContainerEnumeratorBase::~CFContainerEnumeratorBase(CFContainerEnumeratorBase *this)
{
  const void *v2;
  char *v3;

  v2 = *(const void **)this;
  if (v2)
    CFRelease(v2);
  v3 = (char *)*((_QWORD *)this + 2);
  if ((char *)this + 24 != v3)
    free(v3);
}

void HTTPHeaderDict::addValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const void *v6;
  const void *v7;
  CFTypeRef v8;
  const void *v9;
  void *v10;
  const __CFArray *Value;
  const __CFAllocator *v12;
  __CFArray *MutableCopy;
  void *values;

  v6 = (const void *)(a1 - 16);
  CFGetAllocator((CFTypeRef)(a1 - 16));
  v7 = *(const void **)(a2 + 8);
  if (v7)
    v8 = CFRetain(v7);
  else
    v8 = 0;
  CFGetAllocator(v6);
  v9 = *(const void **)(a3 + 8);
  if (v9)
    v10 = (void *)CFRetain(v9);
  else
    v10 = 0;
  values = v10;
  Value = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 8), v8);
  v12 = CFGetAllocator(v6);
  if (Value)
  {
    MutableCopy = CFArrayCreateMutableCopy(v12, 0, Value);
    CFArrayAppendValue(MutableCopy, v10);
  }
  else
  {
    MutableCopy = CFArrayCreate(v12, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 8), v8, MutableCopy);
  if (MutableCopy)
    CFRelease(MutableCopy);
  if (v8)
    CFRelease(v8);
  if (values)
    CFRelease(values);
}

void HTTPHeaderDict::HTTPHeaderDict(HTTPHeaderDict *this)
{
  const __CFAllocator *v2;

  *(_QWORD *)this = &off_1E14E6D78;
  v2 = CFGetAllocator((char *)this - 16);
  *((_QWORD *)this + 1) = CFDictionaryCreateMutable(v2, 0, &kCaseInsensitiveKeyCallBacks, MEMORY[0x1E0C9B3A0]);
}

void CFHTTPMessageSetHeaderFieldValue(CFHTTPMessageRef message, CFStringRef headerField, CFStringRef value)
{
  HTTPMessage *v6;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (message)
    v6 = (CFHTTPMessageRef)((char *)message + 16);
  else
    v6 = 0;
  HTTPMessage::setHeaderFieldStringValue(v6, headerField, value);
}

void CFURLRequestSetHTTPRequestMethod(void *a1, const __CFString *a2)
{
  URLRequest *v3;
  _OWORD *Instance;
  HTTPMessage *v5;
  HTTPRequest *fHTTPRequest;
  CFAllocatorRef v7;
  void (**v8)(StringSerializable *__hidden);
  CFTypeRef cf;

  v3 = (URLRequest *)objc_msgSend(a1, "_inner");
  HTTPMethodMixedValue::HTTPMethodMixedValue((HTTPMethodMixedValue *)&v8, a2);
  if (v3->fHTTPRequest)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    Instance = (_OWORD *)_CFRuntimeCreateInstance();
    v5 = (HTTPMessage *)Instance;
    if (Instance)
    {
      Instance[1] = 0u;
      v5 = (HTTPMessage *)(Instance + 1);
      Instance[13] = 0u;
      Instance[14] = 0u;
      Instance[11] = 0u;
      Instance[12] = 0u;
      Instance[9] = 0u;
      Instance[10] = 0u;
      Instance[7] = 0u;
      Instance[8] = 0u;
      Instance[5] = 0u;
      Instance[6] = 0u;
      Instance[3] = 0u;
      Instance[4] = 0u;
      Instance[2] = 0u;
    }
    fHTTPRequest = v3->fHTTPRequest;
    HTTPMessage::HTTPMessage(v5, (const HTTPMessage *)fHTTPRequest);
    *(_QWORD *)v5 = &off_1E14E96D8;
    *((_QWORD *)v5 + 1) = &unk_1E14E9758;
    *((_QWORD *)v5 + 2) = &unk_1E14E9778;
    *((_QWORD *)v5 + 16) = &unk_1E14E97A8;
    v7 = CFGetAllocator((char *)v5 - 16);
    HTTPRequestParserClient::HTTPRequestParserClient((_QWORD *)v5 + 16, v7, cf, *((const char **)fHTTPRequest + 20), *((const __CFURL **)fHTTPRequest + 21));
    *(_QWORD *)v5 = &off_1E14E5170;
    *((_QWORD *)v5 + 1) = &unk_1E14E51F0;
    *((_QWORD *)v5 + 2) = &unk_1E14E5210;
    *((_QWORD *)v5 + 16) = &unk_1E14E5240;
    HTTPRequest::commonInitialization((HTTPRequest *)v5, fHTTPRequest);
    CFRelease((char *)v3->fHTTPRequest - 16);
    v3->fHTTPRequest = (HTTPRequest *)v5;
  }
  else
  {
    URLRequest::createHTTPRequest(v3, (CFTypeRef *)&v8);
  }
  v8 = &off_1E14E9A00;
  if (cf)
    CFRelease(cf);
}

void sub_183ED5FE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void HTTPResponseMessage::HTTPResponseMessage(HTTPResponseMessage *this, const char **a2)
{
  _QWORD *v4;
  const char *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  const char *v12;

  HTTPMessage::HTTPMessage(this, (const HTTPMessage *)a2);
  *v4 = &off_1E14E9F38;
  v4[1] = &unk_1E14E9FA8;
  v4[2] = &unk_1E14E9FC8;
  v5 = a2[17];
  *((_DWORD *)this + 32) = *((_DWORD *)a2 + 32);
  if (v5)
    v5 = (const char *)CFRetain(v5);
  *((_QWORD *)this + 17) = v5;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_BYTE *)this + 296) = 0;
  v6 = *((_OWORD *)a2 + 10);
  v7 = *((_OWORD *)a2 + 11);
  v8 = *((_OWORD *)a2 + 13);
  *((_OWORD *)this + 12) = *((_OWORD *)a2 + 12);
  *((_OWORD *)this + 13) = v8;
  *((_OWORD *)this + 10) = v6;
  *((_OWORD *)this + 11) = v7;
  v9 = *((_OWORD *)a2 + 14);
  v10 = *((_OWORD *)a2 + 15);
  v11 = *((_OWORD *)a2 + 17);
  *((_OWORD *)this + 16) = *((_OWORD *)a2 + 16);
  *((_OWORD *)this + 17) = v11;
  *((_OWORD *)this + 14) = v9;
  *((_OWORD *)this + 15) = v10;
  v12 = a2[36];
  if (v12)
    *((_QWORD *)this + 36) = strdup(v12);
}

void sub_183ED60C8(_Unwind_Exception *a1)
{
  HTTPMessage *v1;

  HTTPMessage::~HTTPMessage(v1);
  _Unwind_Resume(a1);
}

uint64_t _CFURLResponseMustRevalidate(void *a1)
{
  URLResponse *v1;
  HTTPResponse *fHTTP;
  __int16 v3;
  URLResponse *v4;

  v1 = (URLResponse *)objc_msgSend(a1, "_inner");
  fHTTP = v1->fHTTP;
  if (!fHTTP)
    return 0;
  v3 = *(_WORD *)((char *)fHTTP + 297);
  if ((v3 & 0x80) == 0)
  {
    v4 = v1;
    URLResponse::parseCacheControl(v1);
    LOBYTE(v3) = *((_BYTE *)v4->fHTTP + 297);
  }
  return v3 & 1;
}

void HTTPMessage::removeHeaderFieldValue(HTTPMessage *this, const __CFString *a2)
{
  HTTPHeaderDict *v3;
  void (**v4)(StringSerializable *__hidden);
  CFTypeRef cf;

  if (a2)
  {
    v3 = HTTPMessage::mutableHeaders(this);
    HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v4, a2);
    HTTPHeaderDict::removeValue((uint64_t)v3, (uint64_t)&v4);
    v4 = &off_1E14E9A00;
    if (cf)
      CFRelease(cf);
  }
}

void sub_183ED6220(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void HTTPHeaderDict::removeValue(uint64_t a1, uint64_t a2)
{
  const void *v4;
  CFTypeRef v5;

  CFGetAllocator((CFTypeRef)(a1 - 16));
  v4 = *(const void **)(a2 + 8);
  if (v4)
  {
    v5 = CFRetain(v4);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 8), v5);
    if (v5)
      CFRelease(v5);
  }
  else
  {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 8), 0);
  }
}

double CFURLResponseGetExpirationTime(void *a1)
{
  URLResponse *v1;
  HTTPResponse *fHTTP;
  const __CFString *v3;
  double IntValue;
  const __CFString *v5;
  double CreationTime;
  double v7;
  double fCreationTime;
  double v9;

  v1 = (URLResponse *)objc_msgSend(a1, "_inner");
  fHTTP = v1->fHTTP;
  if (fHTTP && (*(_WORD *)((char *)fHTTP + 297) & 0x1000) == 0)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v3 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)fHTTP, 0x1140728Fu);
    IntValue = 0.0;
    if (v3)
    {
      v5 = v3;
      IntValue = (double)CFStringGetIntValue(v3);
      CFRelease(v5);
    }
    CreationTime = URLResponse::getCreationTime(v1);
    URLResponse::freshnessLifetimeForResponse(v1);
    fCreationTime = v1->fCreationTime;
    v9 = fCreationTime - CreationTime;
    if (fCreationTime - CreationTime < 0.0)
      v9 = 0.0;
    if (v9 <= IntValue)
      v9 = IntValue;
    v1->fExpiration = fCreationTime + v7 - v9;
    *(_WORD *)((char *)v1->fHTTP + 297) |= 0x1000u;
  }
  return v1->fExpiration;
}

uint64_t HTTPCookieStorage::setCookie(HTTPCookieStorage *this, OpaqueCFHTTPCookie *a2, const HTTPCookieStoragePolicy *a3, const __CFArray *a4, int a5)
{
  uint64_t v10;
  uint64_t v11;
  const __CFAllocator *v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int *v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  void *v22;
  void *v23;
  CFIndex Count;
  CFIndex v25;
  void *ValueAtIndex;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  NSObject *v35;
  NSObject *v37;
  _QWORD block[7];
  _QWORD v39[2];
  void (*v40)(uint64_t);
  void *v41;
  uint64_t v42;
  void (**v43)(AutoString *__hidden);
  CFStringRef v44;
  uint64_t v45;
  uint64_t v46;
  uint8_t buf[8];
  CFStringRef v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v10 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_4_9789, 3);
  if (v10)
  {
    v11 = v10;
    if ((*(unsigned int (**)(uint64_t, const char *, HTTPCookieStorage *))(*(_QWORD *)v10 + 24))(v10, "HTTPCookieStorage::setCookie", this))
    {
      v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v13 = -[OpaqueCFHTTPCookie _inner](a2, "_inner");
      v14 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v13 + 16))(v13);
      v15 = v14;
      if (*v14 >= 0x14 && (v16 = v14[4], (_DWORD)v16) && (v17 = *v14, v17 > v16))
      {
        v18 = (char *)v14 + v16;
        v19 = (char *)v14 + v17;
        v20 = v18;
        while (*v20)
        {
          if (++v20 >= v19)
            goto LABEL_9;
        }
        *(_QWORD *)buf = &off_1E14E4818;
        v49 = 0;
        v50 = 0;
        v48 = CFStringCreateWithCString(v12, "Cookie URL", 0x8000100u);
        v43 = &off_1E14E4818;
        v45 = 0;
        v46 = 0;
        v44 = CFStringCreateWithCString(v12, v18, 0x8000100u);
        (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(_QWORD *)v11 + 64))(v11, v48, v44);
        AutoString::~AutoString((AutoString *)&v43);
      }
      else
      {
LABEL_9:
        *(_QWORD *)buf = &off_1E14E4818;
        v49 = 0;
        v50 = 0;
        v48 = CFStringCreateWithCString(v12, "Cookie URL", 0x8000100u);
        (*(void (**)(uint64_t, CFStringRef, _QWORD))(*(_QWORD *)v11 + 64))(v11, v48, 0);
      }
      AutoString::~AutoString((AutoString *)buf);
      logCookie(v11, 0, v15);
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
    }
  }
  v21 = MEMORY[0x1E0C809B0];
  v39[0] = MEMORY[0x1E0C809B0];
  v39[1] = 3221225472;
  v40 = ___ZN17HTTPCookieStorage9setCookieEPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicyPK9__CFArrayh_block_invoke_2;
  v41 = &__block_descriptor_40_e5_v8__0l;
  v42 = 0;
  if (!a4)
  {
    v22 = (void *)*((_QWORD *)a3 + 2);
    if (v22)
    {
      v23 = (void *)objc_msgSend(v22, "scheme");
      if (!v23 || objc_msgSend(v23, "caseInsensitiveCompare:", 0x1EDD00AA8))
        goto LABEL_24;
      a4 = HTTPCookieStorage::copyCookiesForURL(this, a3, 1u);
    }
  }
  if (!a4 || (Count = CFArrayGetCount(a4), Count < 1))
  {
LABEL_24:
    v28 = (_QWORD *)*((_QWORD *)this + 2);
    v29 = -[OpaqueCFHTTPCookie _inner](a2, "_inner");
    v30 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v29 + 16))(v29);
    v31 = v28[4];
    if (v31)
      pthread_mutex_lock((pthread_mutex_t *)(v31 + 8));
    v32 = (*(uint64_t (**)(_QWORD *, uint64_t, const HTTPCookieStoragePolicy *))(*v28 + 120))(v28, v30, a3);
    if (v31)
      pthread_mutex_unlock((pthread_mutex_t *)(v31 + 8));
    HTTPCookieStorage::notifyObserversOfChanges(this);
    os_unfair_lock_lock((os_unfair_lock_t)this + 30);
    if (a5)
    {
      if (*((_QWORD *)this + 13))
      {
        if ((_DWORD)v32)
        {
          v33 = (void *)objc_msgSend(*((id *)this + 10), "objectForKeyedSubscript:", -[OpaqueCFHTTPCookie domain](a2, "domain"));
          if (objc_msgSend(v33, "count"))
          {
            v34 = *((_QWORD *)this + 13);
            v35 = *((_QWORD *)this + 11);
            block[0] = v21;
            block[1] = 3221225472;
            block[2] = ___ZN17HTTPCookieStorage9setCookieEPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicyPK9__CFArrayh_block_invoke_10;
            block[3] = &unk_1E14FE070;
            block[5] = a2;
            block[6] = v34;
            block[4] = v33;
            dispatch_async(v35, block);
          }
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 30);
    goto LABEL_34;
  }
  v25 = 0;
  while (1)
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(a4, v25);
    if (objc_msgSend(ValueAtIndex, "isSecure"))
    {
      if (objc_msgSend((id)-[OpaqueCFHTTPCookie name](a2, "name"), "isEqualToString:", objc_msgSend(ValueAtIndex, "name")))
      {
        v27 = -[OpaqueCFHTTPCookie _storagePartition](a2, "_storagePartition");
        if (v27 == objc_msgSend(ValueAtIndex, "_storagePartition")
          || objc_msgSend((id)-[OpaqueCFHTTPCookie _storagePartition](a2, "_storagePartition"), "isEqualToString:", objc_msgSend(ValueAtIndex, "_storagePartition")))
        {
          break;
        }
      }
    }
    if (Count == ++v25)
      goto LABEL_24;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v37 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl(&dword_183ECA000, v37, OS_LOG_TYPE_DEBUG, "website http cookie not overwriting existing https cookie", buf, 2u);
  }
  v32 = 0;
LABEL_34:
  v40((uint64_t)v39);
  return v32;
}

void sub_183ED6810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  AutoString::~AutoString((AutoString *)&a22);
  AutoString::~AutoString((AutoString *)&a41);
  _Unwind_Resume(a1);
}

void ___ZN17HTTPCookieStorage9setCookieEPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicyPK9__CFArrayh_block_invoke_2(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void HTTPCookieStorage::notifyObserversOfChanges(HTTPCookieStorage *this)
{
  const __CFAllocator *v2;
  const __CFSet *Copy;
  __CFRunLoopTimer *v4;
  double Current;
  double v6;
  BOOL v7;
  double v8;
  __CFRunLoop *v9;

  if (*((_QWORD *)this + 3))
  {
    v2 = CFGetAllocator((char *)this - 16);
    Copy = CFSetCreateCopy(v2, *((CFSetRef *)this + 3));
    CFSetApplyFunction(Copy, (CFSetApplierFunction)_signalObservers, *((void **)this + 3));
    if (Copy)
      CFRelease(Copy);
  }
  v4 = (__CFRunLoopTimer *)*((_QWORD *)this + 4);
  if (v4)
  {
    Current = CFAbsoluteTimeGetCurrent();
    v6 = *((double *)this + 6);
    v7 = v6 + 10.0 < Current || v6 == 0.0;
    v8 = 2.0;
    if (!v7)
      v8 = 10.0;
    CFRunLoopTimerSetNextFireDate(v4, Current + v8);
  }
  else if (*((_BYTE *)this + 64))
  {
    *((_BYTE *)this + 64) = 0;
    v9 = +[NSURLConnection resourceLoaderRunLoop](NSURLConnection, "resourceLoaderRunLoop");
    HTTPCookieStorage::scheduleWithRunLoop(this, v9, (const __CFString *)*MEMORY[0x1E0C9B280]);
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 30);
  if (*((_QWORD *)this + 7))
  {
    if (HTTPCookieStorage::notifyObserversOfChanges(void)::onceToken != -1)
      dispatch_once(&HTTPCookieStorage::notifyObserversOfChanges(void)::onceToken, &__block_literal_global_26_9798);
    dispatch_async((dispatch_queue_t)HTTPCookieStorage::notifyObserversOfChanges(void)::notificaionQueue, *((dispatch_block_t *)this + 7));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 30);
}

CFStringRef CFHTTPMessageCopyVersion(CFHTTPMessageRef message)
{
  char *v2;
  const void *v3;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (message)
    v2 = (char *)message + 16;
  else
    v2 = 0;
  if (*((_QWORD *)v2 + 5) && (CFGetAllocator(v2 - 16), (v3 = (const void *)*((_QWORD *)v2 + 5)) != 0))
    return (CFStringRef)CFRetain(v3);
  else
    return 0;
}

uint64_t URLRequest::initialize(URLRequest *this, uint64_t a2, const void **a3, uint64_t a4, const __CFDictionary *a5)
{
  uint64_t result;
  CFTypeID v11;
  const void *v12;
  CFTypeID v13;
  CFTypeID v14;
  CFTypeID v15;
  const void *v16;
  CFTypeID v17;
  CFTypeID v18;
  CFTypeID v19;
  CFTypeID v20;
  CFTypeID v21;
  CFTypeID v22;
  CFTypeID v23;
  CFTypeID v24;
  int v25;
  int v26;
  int v27;
  const void *v28;
  CFTypeID v29;
  const void *v30;
  CFTypeID v31;
  CFTypeID v32;
  CFTypeID v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  CFTypeID v37;
  const void **v38;
  const void *v39;
  CFTypeID v40;
  const void *v41;
  CFTypeID v42;
  const void *v43;
  CFTypeID v44;
  CFTypeID TypeID;
  uint64_t v46;
  const void *v47;
  CFTypeID v48;
  CFTypeID v49;
  void *v50;
  const __CFNumber *v51;
  int Value;
  double v53;
  const __CFNumber *v54;
  int v55;
  unint64_t v56;
  void *v57;
  audit_token_t *v58;
  const __CFNumber *v59;
  __int16 v60;
  const __CFNumber *v61;
  int v62;
  int64_t v63;
  void *v64;
  const __CFDictionary *v65;
  const __CFArray *v66;
  const __CFArray *v67;
  CFTypeID v68;
  const void *ValueAtIndex;
  CFTypeID v70;
  CFIndex Count;
  CFIndex v72;
  CFIndex v73;
  CFIndex v74;
  const __CFData *v75;
  const __CFData *v76;
  CFTypeID v77;
  SecCertificateRef v78;
  SecCertificateRef v79;
  __CFDictionary *MutableCopy;
  __CFDictionary *v81;
  char v82;
  const __CFNumber *v83;
  int v84;
  double v85;
  const __CFNumber *v86;
  int v87;
  double v88;
  const __CFNumber *v89;
  int v90;
  int v91;
  __int16 fFlags;
  int v93;
  __int16 v94;
  const __CFArray *v95;
  _QWORD *v96;
  uint64_t v97;
  const void **v98;
  const void *v99;
  const __CFDictionary *v100;
  const __CFString *v101;
  const __CFAllocator *v102;
  _OWORD *Instance;
  HTTPRequest *fHTTPRequest;
  const __CFArray *v105;
  CFMutableArrayRef v106;
  const __CFAllocator *v107;
  __CFArray *theArray;
  const __CFAllocator *allocator;
  uint64_t v110;
  char v111;
  const __CFAllocator *v112;
  uint64_t valuePtr;
  CFTypeRef cf;

  if (a4 >= 1 && !*a3)
    return 0;
  if (a2)
  {
    switch(a2)
    {
      case 1:
        if ((a4 | 4) != 0xD)
          return 0;
        goto LABEL_8;
      case 2:
        if (a4 != 9 && a4 != 14)
          return 0;
        goto LABEL_8;
      case 3:
        if (a4 != 10 && a4 != 15)
          return 0;
        goto LABEL_8;
      case 4:
        if (a4 == 11)
          goto LABEL_8;
        goto LABEL_58;
      case 5:
        if (a4 != 12 && a4 != 17)
          return 0;
        goto LABEL_8;
      case 6:
        if (a4 != 14 && a4 != 19)
          return 0;
        goto LABEL_8;
      case 7:
        if (a4 != 14 && a4 != 20)
          return 0;
        goto LABEL_8;
      case 8:
        if (a4 != 15 && a4 != 21)
          return 0;
        goto LABEL_8;
      case 9:
        if (a4 == 22)
          goto LABEL_8;
LABEL_58:
        if (a4 != 16)
          return 0;
        goto LABEL_8;
      default:
        return 0;
    }
  }
  if ((a4 | 4) != 0xC)
    return 0;
LABEL_8:
  result = (uint64_t)*a3;
  if (!*a3)
    return result;
  v11 = CFGetTypeID((CFTypeRef)result);
  if (v11 != CFBooleanGetTypeID())
    return 0;
  v12 = a3[1];
  if (v12)
  {
    v13 = CFGetTypeID(v12);
    if (v13 != CFURLGetTypeID())
      return 0;
  }
  result = (uint64_t)a3[2];
  if (!result)
    return result;
  v14 = CFGetTypeID((CFTypeRef)result);
  if (v14 != CFNumberGetTypeID())
    return 0;
  result = (uint64_t)a3[3];
  if (!result)
    return result;
  v15 = CFGetTypeID((CFTypeRef)result);
  if (v15 != CFNumberGetTypeID())
    return 0;
  v16 = a3[4];
  if (v16)
  {
    v17 = CFGetTypeID(v16);
    if (v17 != CFURLGetTypeID())
      return 0;
  }
  result = (uint64_t)a3[5];
  if (!result)
    return result;
  v18 = CFGetTypeID((CFTypeRef)result);
  if (v18 != CFBooleanGetTypeID())
    return 0;
  if ((unint64_t)a2 < 5)
    goto LABEL_61;
  result = (uint64_t)a3[11];
  if (!result)
    return result;
  v19 = CFGetTypeID((CFTypeRef)result);
  if (v19 != CFNumberGetTypeID())
    return 0;
  result = (uint64_t)a3[6];
  if (!result)
    return result;
  v20 = CFGetTypeID((CFTypeRef)result);
  if (v20 != CFNumberGetTypeID())
    return 0;
  if ((unint64_t)a2 < 6)
  {
LABEL_61:
    v25 = 0;
    v26 = 0;
    v27 = 0;
  }
  else
  {
    result = (uint64_t)a3[12];
    if (!result)
      return result;
    v21 = CFGetTypeID((CFTypeRef)result);
    if (v21 != CFNumberGetTypeID())
      return 0;
    result = (uint64_t)a3[13];
    if (!result)
      return result;
    v22 = CFGetTypeID((CFTypeRef)result);
    if (v22 != CFNumberGetTypeID())
      return 0;
    if ((unint64_t)a2 < 8)
    {
      v25 = 0;
      v27 = 0;
      v26 = 1;
    }
    else
    {
      result = (uint64_t)a3[14];
      if (!result)
        return result;
      v23 = CFGetTypeID((CFTypeRef)result);
      if (v23 != CFNumberGetTypeID())
        return 0;
      if ((unint64_t)a2 < 9)
      {
        v25 = 0;
      }
      else
      {
        result = (uint64_t)a3[15];
        if (!result)
          return result;
        v24 = CFGetTypeID((CFTypeRef)result);
        if (v24 != CFNumberGetTypeID())
          return 0;
        v25 = 1;
      }
      v26 = 1;
      v27 = 1;
    }
  }
  v28 = a3[7];
  if (v28)
  {
    v29 = CFGetTypeID(v28);
    if (v29 != CFDictionaryGetTypeID())
      return 0;
  }
  if (!a2)
  {
    v34 = 0;
    if (a4 != 12)
    {
LABEL_88:
      v111 = 1;
      v35 = 0;
      goto LABEL_115;
    }
    v35 = 8;
LABEL_78:
    v36 = v34 + v35;
    result = (uint64_t)*(&a3[v35 + 1] + v34);
    if (!result)
      return result;
    v37 = CFGetTypeID((CFTypeRef)result);
    if (v37 == CFStringGetTypeID())
    {
      v38 = &a3[v36];
      v39 = v38[3];
      if (!v39 || (v40 = CFGetTypeID(v39), v40 == CFDataGetTypeID()))
      {
        v41 = v38[2];
        if (!v41 || (v42 = CFGetTypeID(v41), v42 == CFDictionaryGetTypeID()))
        {
          if ((unint64_t)a2 >= 7 && (v43 = a3[v35 + 5]) != 0)
          {
            v44 = CFGetTypeID(v43);
            TypeID = CFArrayGetTypeID();
            v111 = 0;
            result = 0;
            if (v44 != TypeID)
              return result;
          }
          else
          {
            v111 = 0;
          }
LABEL_115:
          if (CFBooleanGetValue((CFBooleanRef)*a3))
            *(_WORD *)&this->fFlags |= 2u;
          v50 = (void *)a3[1];
          if (v50)
            v50 = (void *)CFRetain(v50);
          this->fURL = (__CFURL *)v50;
          v51 = (const __CFNumber *)a3[2];
          valuePtr = 0;
          Value = CFNumberGetValue(v51, kCFNumberDoubleType, &valuePtr);
          v53 = *(double *)&valuePtr;
          if (!Value)
            v53 = 0.0;
          this->fTimeout = v53;
          v54 = (const __CFNumber *)a3[3];
          valuePtr = 0;
          v55 = CFNumberGetValue(v54, kCFNumberCFIndexType, &valuePtr);
          v56 = valuePtr;
          if (!v55)
            v56 = 0;
          this->fCachePolicy = v56;
          v57 = (void *)a3[4];
          if (v57)
            v57 = (void *)CFRetain(v57);
          this->fMainDocumentURL = (__CFURL *)v57;
          *(_WORD *)&this->fFlags = *(_WORD *)&this->fFlags & 0xFFFE | (CFBooleanGetValue((CFBooleanRef)a3[5]) != 0);
          if ((unint64_t)a2 < 5)
            goto LABEL_139;
          v59 = (const __CFNumber *)a3[6];
          valuePtr = 0;
          if (!CFNumberGetValue(v59, kCFNumberCFIndexType, &valuePtr))
            goto LABEL_139;
          v60 = valuePtr;
          if (!valuePtr)
            goto LABEL_139;
          if ((valuePtr & 2) != 0)
          {
            *(_WORD *)&this->fFlags |= 0x20u;
            if ((v60 & 4) == 0)
            {
LABEL_130:
              if ((v60 & 8) == 0)
                goto LABEL_131;
              goto LABEL_179;
            }
          }
          else if ((valuePtr & 4) == 0)
          {
            goto LABEL_130;
          }
          *(_WORD *)&this->fFlags |= 0x40u;
          if ((v60 & 8) == 0)
          {
LABEL_131:
            if ((v60 & 0x10) == 0)
              goto LABEL_132;
            goto LABEL_180;
          }
LABEL_179:
          *(_WORD *)&this->fFlags |= 0x80u;
          if ((v60 & 0x10) == 0)
          {
LABEL_132:
            if ((v60 & 0x40) == 0)
              goto LABEL_133;
            goto LABEL_181;
          }
LABEL_180:
          *(_WORD *)&this->fFlags |= 0x100u;
          if ((v60 & 0x40) == 0)
          {
LABEL_133:
            if ((v60 & 0x80) == 0)
              goto LABEL_134;
            goto LABEL_182;
          }
LABEL_181:
          *(_WORD *)&this->fFlags |= 0x200u;
          if ((v60 & 0x80) == 0)
          {
LABEL_134:
            if ((v60 & 0x100) == 0)
              goto LABEL_135;
            goto LABEL_183;
          }
LABEL_182:
          *(_WORD *)&this->fFlags |= 0x400u;
          if ((v60 & 0x100) == 0)
          {
LABEL_135:
            if ((v60 & 0x200) == 0)
              goto LABEL_136;
            goto LABEL_184;
          }
LABEL_183:
          *(_WORD *)&this->fFlags |= 0x800u;
          if ((v60 & 0x200) == 0)
          {
LABEL_136:
            if ((v60 & 0x400) == 0)
              goto LABEL_137;
LABEL_185:
            *(_WORD *)&this->fFlags |= 0x2000u;
            if ((v60 & 0x1000) != 0)
LABEL_138:
              *(_WORD *)&this->fFlags |= 0x4000u;
LABEL_139:
            if (v26)
            {
              v83 = (const __CFNumber *)a3[12];
              valuePtr = 0;
              v84 = CFNumberGetValue(v83, kCFNumberDoubleType, &valuePtr);
              v85 = *(double *)&valuePtr;
              if (!v84)
                v85 = 0.0;
              this->fTimeWindowDelay = v85;
              v86 = (const __CFNumber *)a3[13];
              valuePtr = 0;
              v87 = CFNumberGetValue(v86, kCFNumberDoubleType, &valuePtr);
              v88 = *(double *)&valuePtr;
              if (!v87)
                v88 = 0.0;
              this->fTimeWindowDuration = v88;
              if (!v27)
              {
LABEL_141:
                if (!v25)
                  goto LABEL_145;
                goto LABEL_142;
              }
            }
            else if (!v27)
            {
              goto LABEL_141;
            }
            v89 = (const __CFNumber *)a3[14];
            valuePtr = 0;
            v90 = CFNumberGetValue(v89, kCFNumberCFIndexType, &valuePtr);
            v91 = valuePtr;
            if (!v90)
              v91 = 0;
            this->fNetworkServiceType = v91;
            if (!v25)
            {
LABEL_145:
              v64 = (void *)a3[7];
              if (!a2)
              {
                if (v64)
                  v64 = (void *)CFRetain(v64);
                this->fSSLProps = (__CFDictionary *)v64;
                v82 = v111;
                goto LABEL_196;
              }
              if (v64)
                v64 = (void *)CFRetain(v64);
              this->fProxyDict = (__CFDictionary *)v64;
              v65 = (const __CFDictionary *)a3[8];
              if (v65)
              {
                v110 = v35;
                if (CFDictionaryContainsKey(v65, &unk_1EDCFB2F0))
                {
                  v66 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a3[8], &unk_1EDCFB2F0);
                  if (v66)
                  {
                    v67 = v66;
                    v68 = CFGetTypeID(v66);
                    if (v68 == CFArrayGetTypeID())
                    {
                      if (CFArrayGetValueAtIndex(v67, 0))
                      {
                        ValueAtIndex = CFArrayGetValueAtIndex(v67, 0);
                        v70 = CFGetTypeID(ValueAtIndex);
                        if (v70 == CFDataGetTypeID())
                        {
                          allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
                          theArray = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
                          Count = CFArrayGetCount(v67);
                          if (Count >= 1)
                          {
                            v72 = Count;
                            v73 = 0;
                            do
                            {
                              v74 = v73;
                              v75 = (const __CFData *)CFArrayGetValueAtIndex(v67, v73);
                              if (v75)
                              {
                                v76 = v75;
                                v77 = CFGetTypeID(v75);
                                if (v77 == CFDataGetTypeID())
                                {
                                  v78 = SecCertificateCreateWithData(allocator, v76);
                                  if (v78)
                                  {
                                    v79 = v78;
                                    CFArrayInsertValueAtIndex(theArray, v74, v78);
                                    CFRelease(v79);
                                  }
                                }
                              }
                              v73 = v74 + 1;
                            }
                            while (v72 != v74 + 1);
                          }
                          if (theArray)
                          {
                            if (CFArrayGetCount(theArray) >= 1)
                            {
                              MutableCopy = CFDictionaryCreateMutableCopy(allocator, 0, (CFDictionaryRef)a3[8]);
                              if (MutableCopy)
                              {
                                v81 = MutableCopy;
                                CFDictionaryReplaceValue(MutableCopy, &unk_1EDCFB2F0, theArray);
                                CFRelease(theArray);
                                this->fSSLProps = (__CFDictionary *)CFRetain(v81);
                                CFRelease(v81);
                                v35 = v110;
                                v82 = v111;
LABEL_194:
                                if (a2 >= 3 && !CFBooleanGetValue((CFBooleanRef)a3[9]))
                                {
                                  fFlags = *(_WORD *)&this->fFlags & 0xFFF7;
LABEL_197:
                                  *(_WORD *)&this->fFlags = fFlags;
                                  if (a2 >= 4
                                    && (v93 = CFBooleanGetValue((CFBooleanRef)a3[10]),
                                        fFlags = (__int16)this->fFlags,
                                        v93))
                                  {
                                    v94 = fFlags | 0x10;
                                  }
                                  else
                                  {
                                    v94 = fFlags & 0xFFEF;
                                  }
                                  *(_WORD *)&this->fFlags = v94;
                                  if ((v82 & 1) == 0)
                                  {
                                    if (a2 < 2)
                                    {
                                      v97 = 0;
                                      v96 = 0;
                                    }
                                    else
                                    {
                                      v95 = (const __CFArray *)a3[v35];
                                      if (v95)
                                        v96 = _CFHTTPCookieStorageCreateFromArchive(0, v95, v58);
                                      else
                                        v96 = 0;
                                      v97 = 1;
                                    }
                                    v98 = &a3[v35] + v97;
                                    v100 = (const __CFDictionary *)v98[2];
                                    v99 = v98[3];
                                    v101 = (const __CFString *)v98[1];
                                    if (this->fHTTPRequest
                                      && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
                                    {
                                      LOWORD(valuePtr) = 0;
                                      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "can't be here", (uint8_t *)&valuePtr, 2u);
                                    }
                                    v102 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
                                    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
                                    {
                                      v107 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
                                      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
                                      v102 = v107;
                                    }
                                    v112 = v102;
                                    Instance = (_OWORD *)_CFRuntimeCreateInstance();
                                    fHTTPRequest = (HTTPRequest *)Instance;
                                    if (Instance)
                                    {
                                      Instance[1] = 0u;
                                      fHTTPRequest = (HTTPRequest *)(Instance + 1);
                                      Instance[13] = 0u;
                                      Instance[14] = 0u;
                                      Instance[11] = 0u;
                                      Instance[12] = 0u;
                                      Instance[9] = 0u;
                                      Instance[10] = 0u;
                                      Instance[7] = 0u;
                                      Instance[8] = 0u;
                                      Instance[5] = 0u;
                                      Instance[6] = 0u;
                                      Instance[3] = 0u;
                                      Instance[4] = 0u;
                                      Instance[2] = 0u;
                                    }
                                    HTTPMethodMixedValue::HTTPMethodMixedValue((HTTPMethodMixedValue *)&valuePtr, v101);
                                    HTTPRequest::HTTPRequest(fHTTPRequest, (CFTypeRef *)&valuePtr, this->fURL);
                                    this->fHTTPRequest = fHTTPRequest;
                                    valuePtr = (uint64_t)&off_1E14E9A00;
                                    if (cf)
                                    {
                                      CFRelease(cf);
                                      fHTTPRequest = this->fHTTPRequest;
                                    }
                                    HTTPMessage::ensureParserFinished((HTTPMessage *)fHTTPRequest);
                                    (*(void (**)(HTTPRequest *, const void *))(*(_QWORD *)this->fHTTPRequest
                                                                                        + 64))(this->fHTTPRequest, v99);
                                    if (v96)
                                    {
                                      HTTPRequest::setCookieStorage(this->fHTTPRequest, v96);
                                      CFRelease(v96);
                                    }
                                    if (v100)
                                      HTTPMessage::setMultipleHeaderFields((HTTPMessage *)this->fHTTPRequest, v100);
                                    if (a2 >= 7)
                                    {
                                      v105 = (const __CFArray *)a3[v35 + 5];
                                      if (v105)
                                      {
                                        v106 = CFArrayCreateMutableCopy(v112, 0, v105);
                                        HTTPRequest::setBodyParts(this->fHTTPRequest, v106);
                                        if (v106)
                                          CFRelease(v106);
                                      }
                                    }
                                  }
                                  if (a5)
                                    this->fProtocolProperties = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a5);
                                  return 1;
                                }
LABEL_196:
                                fFlags = *(_WORD *)&this->fFlags | 8;
                                goto LABEL_197;
                              }
                            }
                            CFRelease(theArray);
                          }
                        }
                      }
                    }
                  }
                }
                v65 = (const __CFDictionary *)a3[8];
                if (v65)
                  v65 = (const __CFDictionary *)CFRetain(v65);
                v35 = v110;
              }
              v82 = v111;
              this->fSSLProps = v65;
              goto LABEL_194;
            }
LABEL_142:
            v61 = (const __CFNumber *)a3[15];
            valuePtr = -1;
            v62 = CFNumberGetValue(v61, kCFNumberCFIndexType, &valuePtr);
            v63 = valuePtr;
            if (!v62)
              v63 = -1;
            this->fRequestPriority = v63;
            goto LABEL_145;
          }
LABEL_184:
          *(_WORD *)&this->fFlags |= 0x1000u;
          if ((v60 & 0x400) == 0)
          {
LABEL_137:
            if ((v60 & 0x1000) == 0)
              goto LABEL_139;
            goto LABEL_138;
          }
          goto LABEL_185;
        }
      }
    }
    return 0;
  }
  v30 = a3[8];
  if (v30)
  {
    v31 = CFGetTypeID(v30);
    if (v31 != CFDictionaryGetTypeID())
      return 0;
  }
  if ((unint64_t)a2 < 3)
  {
LABEL_73:
    switch(a2)
    {
      case 1:
        v34 = 0;
        if (a4 != 13)
          goto LABEL_88;
        v35 = 9;
        goto LABEL_78;
      case 2:
        if (a4 != 14)
          goto LABEL_114;
        v46 = 9;
        goto LABEL_109;
      case 4:
        if (a4 != 16)
          goto LABEL_114;
        v46 = 11;
        goto LABEL_109;
      case 5:
        if (a4 != 17)
          goto LABEL_114;
        v46 = 12;
        goto LABEL_109;
      case 6:
        if (a4 == 20)
          goto LABEL_106;
        if (a4 == 19)
          v46 = 14;
        else
          v46 = 0;
        if (a4 != 19)
          goto LABEL_114;
        goto LABEL_109;
      case 7:
        if (a4 != 20)
          goto LABEL_114;
LABEL_106:
        v46 = 14;
        goto LABEL_109;
      case 8:
        if (a4 != 21)
          goto LABEL_114;
        v46 = 15;
        goto LABEL_109;
      default:
        if ((unint64_t)a4 <= 0x15)
          goto LABEL_114;
        v46 = 16;
        goto LABEL_109;
    }
  }
  result = (uint64_t)a3[9];
  if (!result)
    return result;
  v32 = CFGetTypeID((CFTypeRef)result);
  if (v32 != CFBooleanGetTypeID())
    return 0;
  if ((unint64_t)a2 < 4)
  {
    if (a4 != 15)
    {
LABEL_114:
      v35 = 0;
      v111 = 1;
      goto LABEL_115;
    }
    v46 = 10;
LABEL_109:
    v47 = a3[v46];
    if (!v47 || (v48 = CFGetTypeID(v47), v48 == CFArrayGetTypeID()))
    {
      result = (uint64_t)a3[v46 + 1];
      if (!result)
        return result;
      v35 = v46;
      v49 = CFGetTypeID((CFTypeRef)result);
      if (v49 == CFNumberGetTypeID())
      {
        v34 = 1;
        goto LABEL_78;
      }
    }
    return 0;
  }
  result = (uint64_t)a3[10];
  if (result)
  {
    v33 = CFGetTypeID((CFTypeRef)result);
    if (v33 == CFBooleanGetTypeID())
      goto LABEL_73;
    return 0;
  }
  return result;
}

void sub_183ED75B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void HTTPMethodMixedValue::HTTPMethodMixedValue(HTTPMethodMixedValue *this, CFStringRef theString)
{
  CFStringRef v2;
  unsigned int CanonicalString;
  CFTypeRef v5;

  v2 = theString;
  *(_QWORD *)this = &off_1E14EB4B8;
  *((_QWORD *)this + 1) = 0;
  CanonicalString = _findCanonicalString(theString, 7u);
  if (CanonicalString != 568)
  {
    v2 = (CFStringRef)&gConstantCFStringValueTable[7 * ((CanonicalString >> 20) & 0x3FF)];
    goto LABEL_5;
  }
  if (v2)
  {
LABEL_5:
    v5 = CFRetain(v2);
    goto LABEL_6;
  }
  v5 = 0;
LABEL_6:
  *((_QWORD *)this + 1) = v5;
}

void sub_183ED764C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  const void *v3;

  *v1 = &off_1E14E9A00;
  v3 = (const void *)v1[1];
  if (v3)
    CFRelease(v3);
  _Unwind_Resume(exception_object);
}

uint64_t DiskCookieStorage::setCookieInternalLocked(DiskCookieStorage *this, CompactCookieHeader *a2, const HTTPCookieStoragePolicy *a3, const MemoryCookies *a4)
{
  uint64_t v6;
  uint64_t v7;

  if (!PrivateHTTPCookieStorage::allowCookieToBeWrittenConsideringHTTPOnly((PrivateHTTPCookieStorage *)a2, (const CompactCookieHeader *)*((unsigned int *)a3 + 18), *((const HTTPCookieStoragePolicy **)this + 37), a4))return 0;
  ++*((_QWORD *)this + 39);
  if (*(_DWORD *)a2 >= 0xCu && (*((_DWORD *)a2 + 2) & 2) != 0)
  {
    MemoryCookies::deleteCookie(*((MemoryCookies **)this + 36), a2);
    v6 = MemoryCookies::setCookie(*((CompactCookieArray ***)this + 35), a2);
  }
  else
  {
    MemoryCookies::deleteCookie(*((MemoryCookies **)this + 35), a2);
    v6 = MemoryCookies::setCookie(*((CompactCookieArray ***)this + 36), a2);
    v7 = *((_QWORD *)this + 38);
    if (v7)
      DiskCookieStorage::Journal::record(v7, 0, (const UInt8 *)a2);
  }
  if (MemoryCookies::setCookie(*((CompactCookieArray ***)this + 37), a2))
    DiskCookieStorage::setDirtyAndNotifyInstantOff((os_unfair_lock_s *)this);
  return v6;
}

uint64_t PrivateHTTPCookieStorage::allowCookieToBeWrittenConsideringHTTPOnly(PrivateHTTPCookieStorage *this, const CompactCookieHeader *a2, const HTTPCookieStoragePolicy *a3, const MemoryCookies *a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  const char *v10;
  const char *v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  const char *v16;
  const char *v17;
  size_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  const char *v22;
  const char *v23;
  size_t v24;
  char v25;
  _QWORD v27[11];
  char v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  char v32;

  v29 = 0;
  v30 = &v29;
  v31 = 0x2020000000;
  v4 = 1;
  v32 = 1;
  if ((_DWORD)a2 == 2 && (*(_DWORD *)this < 0xCu || (*((_DWORD *)this + 2) & 4) == 0))
  {
    if (*(_DWORD *)this >= 0x14u
      && (v7 = *((unsigned int *)this + 4), (_DWORD)v7)
      && (v8 = *(unsigned int *)this, v8 > v7))
    {
      v9 = (char *)this + v7;
      v10 = (char *)this + v8;
      v11 = v9;
      while (*v11)
      {
        if (++v11 >= v10)
          goto LABEL_10;
      }
      v12 = strlen(v9);
    }
    else
    {
LABEL_10:
      v9 = 0;
      v12 = 0;
    }
    if (*(_DWORD *)this >= 0x18u
      && (v13 = *((unsigned int *)this + 5), (_DWORD)v13)
      && (v14 = *(unsigned int *)this, v14 > v13))
    {
      v15 = (char *)this + v13;
      v16 = (char *)this + v14;
      v17 = v15;
      while (*v17)
      {
        if (++v17 >= v16)
          goto LABEL_17;
      }
      v18 = strlen(v15);
    }
    else
    {
LABEL_17:
      v15 = 0;
      v18 = 0;
    }
    if (*(_DWORD *)this >= 0x1Cu
      && (v19 = *((unsigned int *)this + 6), (_DWORD)v19)
      && (v20 = *(unsigned int *)this, v20 > v19))
    {
      v21 = (char *)this + v19;
      v22 = (char *)this + v20;
      v23 = v21;
      while (*v23)
      {
        if (++v23 >= v22)
          goto LABEL_24;
      }
      v24 = strlen(v21);
    }
    else
    {
LABEL_24:
      v21 = 0;
      v24 = 0;
    }
    if (*(_DWORD *)this >= 0xCu)
    {
      v25 = *((_DWORD *)this + 2) & 1;
      if (!v12)
      {
LABEL_32:
        v4 = 0;
        v32 = 0;
        goto LABEL_33;
      }
    }
    else
    {
      v25 = 0;
      if (!v12)
        goto LABEL_32;
    }
    if (!v18 || !v24)
      goto LABEL_32;
    v27[0] = MEMORY[0x1E0C809B0];
    v27[1] = 3321888768;
    v27[2] = ___ZN24PrivateHTTPCookieStorage41allowCookieToBeWrittenConsideringHTTPOnlyEPK19CompactCookieHeaderRK23HTTPCookieStoragePolicyPK13MemoryCookies_block_invoke;
    v27[3] = &unk_1E14F48C8;
    v27[6] = v12;
    v27[7] = v15;
    v27[8] = v18;
    v27[9] = v21;
    v27[10] = v24;
    v28 = v25;
    v27[4] = &v29;
    v27[5] = v9;
    MemoryCookies::visitCookies((uint64_t)a3, (uint64_t)v27);
    v4 = *((unsigned __int8 *)v30 + 24);
  }
LABEL_33:
  _Block_object_dispose(&v29, 8);
  return v4;
}

void sub_183ED7960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void MemoryCookies::visitCookies(uint64_t a1, uint64_t a2)
{
  _QWORD v2[6];
  _QWORD v3[3];
  char v4;

  v3[0] = 0;
  v3[1] = v3;
  v3[2] = 0x2020000000;
  v4 = 0;
  v2[0] = MEMORY[0x1E0C809B0];
  v2[1] = 3221225472;
  v2[2] = ___ZNK13MemoryCookies12visitCookiesEU13block_pointerFvPK19CompactCookieHeaderPbE_block_invoke;
  v2[3] = &unk_1E14FB3B0;
  v2[4] = a2;
  v2[5] = v3;
  MemoryCookies::withImmutableDomains(a1, (uint64_t)v2);
  _Block_object_dispose(v3, 8);
}

void sub_183ED79F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void MemoryCookies::withImmutableDomains(uint64_t a1, uint64_t a2)
{
  const __CFDictionary *v3;
  CFDictionaryRef Copy;

  v3 = *(const __CFDictionary **)(a1 + 24);
  if (v3)
  {
    Copy = CFDictionaryCreateCopy(*(CFAllocatorRef *)(a1 + 8), v3);
    (*(void (**)(uint64_t, CFDictionaryRef))(a2 + 16))(a2, Copy);
    CFRelease(Copy);
  }
}

void ___ZNK13MemoryCookies12visitCookiesEU13block_pointerFvPK19CompactCookieHeaderPbE_block_invoke(uint64_t a1, CFTypeRef cf)
{
  unint64_t Count;
  const void **v5;
  uint64_t v6;
  const void *v7;
  uint64_t v8;
  const __CFData *v9;
  const UInt8 *BytePtr;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFData *v15;
  const UInt8 *v16;
  const UInt8 *v17;
  uint64_t v18;
  const UInt8 *v19;
  CFTypeRef v20;
  uint64_t v21;
  const void **v22;
  _BYTE v23[248];
  uint64_t v24;

  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
    return;
  if (cf)
  {
    v20 = CFRetain(cf);
    Count = CFDictionaryGetCount((CFDictionaryRef)cf);
    v21 = Count;
    if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      v22 = 0;
    }
    else
    {
      if (Count <= 0x1E)
      {
        v5 = (const void **)v23;
        v22 = (const void **)v23;
LABEL_9:
        CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, 0, v5);
        goto LABEL_10;
      }
      v5 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
      v22 = v5;
      if (v5)
        goto LABEL_9;
    }
  }
  else
  {
    v20 = 0;
    v21 = 0;
    v22 = (const void **)v23;
  }
LABEL_10:
  v24 = 0;
  if (v21 >= 1)
  {
    v6 = 0;
    do
    {
      if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
        break;
      v24 = v6 + 1;
      v7 = v22[v6];
      if (v7)
      {
        if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
          dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
        v8 = (uint64_t)v7 + 16;
      }
      else
      {
        v8 = 0;
      }
      v9 = *(const __CFData **)(v8 + 16);
      if (v9)
      {
        BytePtr = CFDataGetBytePtr(v9);
        if (BytePtr)
        {
          v11 = *((unsigned int *)BytePtr + 1);
          if ((_DWORD)v11)
          {
            v12 = 0;
            v13 = 4 * v11;
            do
            {
              v14 = *(_QWORD *)(a1 + 32);
              v15 = *(const __CFData **)(v8 + 16);
              if (v15 && CFDataGetBytePtr(v15))
              {
                v16 = CFDataGetBytePtr(*(CFDataRef *)(v8 + 16));
                v17 = *(const UInt8 **)(v8 + 16);
                v18 = *(unsigned int *)&v16[v12 + 8];
                if (v17)
                  v17 = CFDataGetBytePtr((CFDataRef)v17);
                v19 = &v17[v18];
              }
              else
              {
                v19 = 0;
              }
              (*(void (**)(uint64_t, const UInt8 *, uint64_t))(v14 + 16))(v14, v19, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
              v12 += 4;
            }
            while (v13 != v12);
          }
        }
      }
      v6 = v24;
    }
    while (v24 < v21);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v20);
}

void sub_183ED7C54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

size_t ___ZN24PrivateHTTPCookieStorage41allowCookieToBeWrittenConsideringHTTPOnlyEPK19CompactCookieHeaderRK23HTTPCookieStoragePolicyPK13MemoryCookies_block_invoke(size_t result, unsigned int *a2, _BYTE *a3)
{
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  const char *v9;
  const char *v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  const char *v15;
  const char *v16;
  size_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  const char *v21;
  const char *v22;
  size_t v23;
  int v24;

  if (*a2 >= 0xC && (a2[2] & 4) != 0)
  {
    v5 = result;
    if (*a2 >= 0x14 && (v6 = a2[4], (_DWORD)v6) && (v7 = *a2, v7 > v6))
    {
      v8 = (char *)a2 + v6;
      v9 = (char *)a2 + v7;
      v10 = v8;
      while (*v10)
      {
        if (++v10 >= v9)
          goto LABEL_9;
      }
      result = strlen(v8);
      v11 = result;
    }
    else
    {
LABEL_9:
      v8 = 0;
      v11 = 0;
    }
    if (*a2 >= 0x18 && (v12 = a2[5], (_DWORD)v12) && (v13 = *a2, v13 > v12))
    {
      v14 = (char *)a2 + v12;
      v15 = (char *)a2 + v13;
      v16 = v14;
      while (*v16)
      {
        if (++v16 >= v15)
          goto LABEL_16;
      }
      result = strlen(v14);
      v17 = result;
    }
    else
    {
LABEL_16:
      v14 = 0;
      v17 = 0;
    }
    if (*a2 >= 0x1C && (v18 = a2[6], (_DWORD)v18) && (v19 = *a2, v19 > v18))
    {
      v20 = (char *)a2 + v18;
      v21 = (char *)a2 + v19;
      v22 = v20;
      while (*v22)
      {
        if (++v22 >= v21)
          goto LABEL_23;
      }
      result = strlen(v20);
      v23 = result;
    }
    else
    {
LABEL_23:
      v20 = 0;
      v23 = 0;
    }
    if (*a2 >= 0xC)
      v24 = a2[2] & 1;
    else
      v24 = 0;
    if (v24 == *(unsigned __int8 *)(v5 + 88) && v11 == *(_QWORD *)(v5 + 48))
    {
      result = strncasecmp(v8, *(const char **)(v5 + 40), v11);
      if (!(_DWORD)result && v17 == *(_QWORD *)(v5 + 64))
      {
        result = strncasecmp(v14, *(const char **)(v5 + 56), v17);
        if (!(_DWORD)result && v23 == *(_QWORD *)(v5 + 80))
        {
          result = strncasecmp(v20, *(const char **)(v5 + 72), v23);
          if (!(_DWORD)result)
          {
            *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v5 + 32) + 8) + 24) = 0;
            *a3 = 1;
          }
        }
      }
    }
  }
  return result;
}

void DiskCookieStorage::setDirtyAndNotifyInstantOff(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  double Current;

  v2 = this + 22;
  os_unfair_lock_lock(this + 22);
  Current = CFAbsoluteTimeGetCurrent();
  *(double *)&this[26]._os_unfair_lock_opaque = Current;
  if (*(double *)&this[24]._os_unfair_lock_opaque == 0.0)
    *(double *)&this[24]._os_unfair_lock_opaque = Current;
  os_unfair_lock_unlock(v2);
}

uint64_t MemoryCookies::deleteCookie(MemoryCookies *this, CompactCookieHeader *a2)
{
  uint64_t v3;
  uint64_t v4;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  CompactCookieArray *CompactCookieArray;
  CompactCookieArray *v12;
  char *EnumeratedString;
  uint64_t v14;
  char *Value;
  CompactCookieArray *v16;
  CompactCookieArray *v17;
  const __CFData *v18;
  const UInt8 *BytePtr;
  const CompactCookieHeader *v20;
  void (**v21)(DomainAndPartition *__hidden);
  uint64_t v22;
  void *v23;
  void *key;
  double v25[3];
  uint64_t v26;
  void *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v20 = a2;
  if (*(_DWORD *)a2 < 0x14u)
    return 0;
  v3 = *((unsigned int *)a2 + 4);
  if (!(_DWORD)v3)
    return 0;
  v4 = *(_DWORD *)a2;
  if (v4 <= v3)
    return 0;
  v6 = (char *)a2 + v3;
  v7 = (char *)a2 + v4;
  v8 = v6;
  while (*v8)
  {
    if (++v8 >= v7)
      return 0;
  }
  CompactCookieArray = CompactCookieArray::makeCompactCookieArray(*((CompactCookieArray **)this + 1), &v20, (const CompactCookieHeader **)1);
  if (!CompactCookieArray)
  {
    CompactCookieArray::newEmptyArray(0);
    CompactCookieArray = v12;
  }
  EnumeratedString = (char *)CompactCookieHeader::getEnumeratedString(a2, 15, 0);
  v14 = 0;
  if (*(_DWORD *)a2 >= 0x38u)
  {
    v25[0] = *((double *)a2 + 6);
    v14 = floor(v25[0]);
  }
  DomainAndPartition::DomainAndPartition(v25, v6, EnumeratedString, 1, v14);
  DomainAndPartition::DomainAndPartition((uint64_t)&v21, (uint64_t)v25);
  Value = (char *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 3), key);
  if (!Value)
    goto LABEL_22;
  if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
    dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
  v16 = CompactCookieArray::_mungeCookies((CompactCookieArray *)(Value + 16), CompactCookieArray, 0);
  v17 = v16;
  if (v16 != (CompactCookieArray *)(Value + 16))
  {
    if (v16)
    {
      v18 = (const __CFData *)*((_QWORD *)v16 + 2);
      if (v18 && (BytePtr = CFDataGetBytePtr(v18)) != 0 && *((_DWORD *)BytePtr + 1))
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 3), key, (char *)v17 - 16);
      else
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 3), key);
      Value = (char *)v17 - 16;
      v9 = 1;
      goto LABEL_26;
    }
LABEL_22:
    v9 = 0;
    goto LABEL_27;
  }
  v9 = 0;
LABEL_26:
  CFRelease(Value);
LABEL_27:
  v21 = &off_1E14E9488;
  if (v23 && v23 != &v22)
    free(v23);
  CFRelease((char *)CompactCookieArray - 16);
  *(_QWORD *)&v25[0] = &off_1E14E9488;
  if (v27 && v27 != &v26)
    free(v27);
  return v9;
}

void sub_183ED80E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53)
{
  uint64_t *v54;

  v54 = (uint64_t *)STACK[0x260];
  if (STACK[0x260])
  {
    if (v54 != &a53)
      free(v54);
  }
  _Unwind_Resume(a1);
}

void DiskCookieStorage::Journal::record(uint64_t a1, int a2, const UInt8 *a3)
{
  CFIndex v5;
  UInt8 bytes[4];

  *(_DWORD *)bytes = a2;
  CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 16), bytes, 4);
  if (a3)
  {
    if (*(_DWORD *)a3 >= 4u)
      v5 = *(unsigned int *)a3;
    else
      v5 = 0;
    CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 16), a3, v5);
  }
}

void URLRequest::createHTTPRequest(URLRequest *this, CFTypeRef *a2)
{
  uint64_t Instance;
  HTTPRequest *v5;
  uint8_t v6[16];

  if (this->fHTTPRequest && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "can't be here", v6, 2u);
  }
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    Instance += 16;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 208) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 16) = 0u;
  }
  HTTPRequest::HTTPRequest((HTTPRequest *)Instance, a2, this->fURL);
  this->fHTTPRequest = v5;
  HTTPMessage::ensureParserFinished((HTTPMessage *)v5);
}

void HTTPRequest::HTTPRequest(HTTPRequest *this, CFTypeRef *a2, const __CFURL *a3)
{
  const __CFURL *v3;
  CFTypeRef v6;

  v3 = a3;
  if (!a3)
  {
    v3 = (const __CFURL *)HTTPRequest::ensureSomeURL(__CFURL const*)::sBogusURL;
    if (!HTTPRequest::ensureSomeURL(__CFURL const*)::sBogusURL)
    {
      v3 = CFURLCreateWithBytes(0, (const UInt8 *)"CFNETWORK_BOGUS_URL", 19, 0x600u, 0);
      HTTPRequest::ensureSomeURL(__CFURL const*)::sBogusURL = (uint64_t)v3;
    }
  }
  v6 = CFRetain(&gConstantCFStringValueTable[2849]);
  HTTPRequestMessage::HTTPRequestMessage((HTTPRequestMessage *)this, a2, v3, v6);
  if (v6)
    CFRelease(v6);
  *(_QWORD *)this = &off_1E14E5170;
  *((_QWORD *)this + 1) = &unk_1E14E51F0;
  *((_QWORD *)this + 2) = &unk_1E14E5210;
  *((_QWORD *)this + 16) = &unk_1E14E5240;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *((_DWORD *)this + 54) = 256;
}

void sub_183ED8388(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void HTTPRequestMessage::HTTPRequestMessage(HTTPRequestMessage *this, CFTypeRef *a2, const __CFURL *a3, CFTypeRef cf)
{
  _QWORD *v7;
  _QWORD *v8;
  CFAllocatorRef v9;

  HTTPMessage::HTTPMessage(this, "httprequest", cf);
  *v7 = &off_1E14E96D8;
  v7[1] = &unk_1E14E9758;
  v7[2] = &unk_1E14E9778;
  v7[16] = &unk_1E14E97A8;
  v8 = v7 + 16;
  v9 = CFGetAllocator(v7 - 2);
  HTTPRequestParserClient::HTTPRequestParserClient(v8, v9, a2[1], 0, a3);
  *(_QWORD *)this = &off_1E14E96D8;
  *((_QWORD *)this + 1) = &unk_1E14E9758;
  *((_QWORD *)this + 2) = &unk_1E14E9778;
  *((_QWORD *)this + 16) = &unk_1E14E97A8;
}

void sub_183ED8444(_Unwind_Exception *a1)
{
  HTTPMessage *v1;

  HTTPMessage::~HTTPMessage(v1);
  _Unwind_Resume(a1);
}

void HTTPMessage::HTTPMessage(HTTPMessage *this, const char *a2, CFTypeRef cf)
{
  CFTypeRef v5;
  uint64_t v6;

  *(_QWORD *)this = &off_1E14E50B0;
  *((_QWORD *)this + 1) = &unk_1E14E5120;
  *((_QWORD *)this + 2) = &unk_1E14E5140;
  *((_QWORD *)this + 4) = &off_1E14E9A00;
  if (cf)
    v5 = CFRetain(cf);
  else
    v5 = 0;
  *((_QWORD *)this + 4) = &off_1E14EBF58;
  *((_QWORD *)this + 5) = v5;
  HTTPMessage::commonInitialization((uint64_t)this, a2 == "httpresponse", 0);
  v6 = *((_QWORD *)this + 11);
  *(_BYTE *)(v6 + 32) = 1;
  *(_DWORD *)(v6 + 36) = 1;
}

void sub_183ED84F4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

uint64_t CFURLProtectionSpaceCreate(uint64_t a1, const __CFString *a2, int a3, int a4, const __CFString *a5, int a6)
{
  uint64_t Instance;

  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3759];
  *(_QWORD *)(Instance + 16) = &off_1E14E9A20;
  *(_QWORD *)(Instance + 24) = &unk_1E14E9A78;
  *(_BYTE *)(Instance + 96) = 0;
  *(_BYTE *)(Instance + 104) = 0;
  *(_QWORD *)(Instance + 112) = 1;
  URLProtectionSpace::initialize(Instance + 16, a2, a3, a4, a5, a6);
  return Instance;
}

void CFURLRequestSetURL(void *a1, const void *a2)
{
  uint64_t v3;
  const void *v4;
  CFTypeRef v5;
  _OWORD *Instance;
  HTTPRequestMessage *v7;
  const HTTPRequestMessage *v8;
  HTTPRequest *v9;

  v3 = objc_msgSend(a1, "_inner");
  v4 = *(const void **)(v3 + 8);
  if (v4 != a2)
  {
    if (v4)
      CFRelease(v4);
    if (a2)
      v5 = CFRetain(a2);
    else
      v5 = 0;
    *(_QWORD *)(v3 + 8) = v5;
  }
  if (*(_QWORD *)(v3 + 56))
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    Instance = (_OWORD *)_CFRuntimeCreateInstance();
    v7 = (HTTPRequestMessage *)Instance;
    if (Instance)
    {
      Instance[1] = 0u;
      v7 = (HTTPRequestMessage *)(Instance + 1);
      Instance[13] = 0u;
      Instance[14] = 0u;
      Instance[11] = 0u;
      Instance[12] = 0u;
      Instance[9] = 0u;
      Instance[10] = 0u;
      Instance[7] = 0u;
      Instance[8] = 0u;
      Instance[5] = 0u;
      Instance[6] = 0u;
      Instance[3] = 0u;
      Instance[4] = 0u;
      Instance[2] = 0u;
    }
    v8 = *(const HTTPRequestMessage **)(v3 + 56);
    HTTPRequestMessage::HTTPRequestMessage(v7, v8, (const __CFURL *)a2);
    *(_QWORD *)v7 = &off_1E14E5170;
    *((_QWORD *)v7 + 1) = &unk_1E14E51F0;
    *((_QWORD *)v7 + 2) = &unk_1E14E5210;
    *((_QWORD *)v7 + 16) = &unk_1E14E5240;
    HTTPRequest::commonInitialization(v9, (const HTTPRequest *)v8);
    CFRelease((CFTypeRef)(*(_QWORD *)(v3 + 56) - 16));
    *(_QWORD *)(v3 + 56) = v7;
  }
}

void sub_183ED873C(_Unwind_Exception *a1)
{
  HTTPRequestMessage *v1;

  HTTPRequestMessage::~HTTPRequestMessage(v1);
  _Unwind_Resume(a1);
}

CFDictionaryRef HTTPCookie::copyProperties_CF(HTTPCookie *this)
{
  const __CFAllocator *v2;
  const __CFAllocator *v3;
  unsigned int *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  const char *v8;
  const char *v9;
  __CFString *v10;
  __CFDictionary *MutableDict;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  const char *v16;
  const char *v17;
  __CFString *v18;
  __CFDictionary *v19;
  _DWORD *v20;
  _DWORD *v21;
  uint64_t v22;
  __CFString *v23;
  __CFDictionary *v24;
  unsigned int *v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  const char *v29;
  const char *v30;
  __CFString *v31;
  __CFDictionary *v32;
  unsigned int *v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  const char *v37;
  const char *v38;
  __CFString *v39;
  __CFDictionary *v40;
  unsigned int *v41;
  uint64_t v42;
  uint64_t v43;
  const char *v44;
  const char *v45;
  const char *v46;
  __CFString *v47;
  __CFDictionary *v48;
  unsigned int *v49;
  uint64_t v50;
  uint64_t v51;
  const char *v52;
  const char *v53;
  const char *v54;
  __CFString *v55;
  __CFDictionary *v56;
  _DWORD *v57;
  char v58;
  int v59;
  unsigned int v60;
  __CFDictionary *v61;
  uint64_t *v62;
  uint64_t v63;
  double v64;
  CFDateRef v65;
  __CFDictionary *v66;
  CompactCookieHeader *v67;
  const char *EnumeratedString;
  __CFString *v69;
  __CFDictionary *v70;
  uint64_t v71;
  double v72;
  CFNumberRef v73;
  __CFDictionary *v74;
  _DWORD *v75;
  __CFDictionary *v76;
  _DWORD *v77;
  __CFDictionary *v78;
  _DWORD *v79;
  __CFDictionary *v80;
  _DWORD *v81;
  __CFDictionary *v82;
  _DWORD *v83;
  uint64_t v84;
  __CFArray *Mutable;
  uint64_t v86;
  unsigned int *v87;
  uint64_t v88;
  uint64_t v89;
  const __CFAllocator *v91;
  __CFDictionary *v92;
  CFDictionaryRef v93;
  void (**v95)(HetergeneousCFDict *__hidden);
  CFAllocatorRef alloc;
  uint64_t v97;
  uint64_t v98;
  char __str[25];
  void (**valuePtr)(AutoString *__hidden);
  void *value;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;

  v104 = *MEMORY[0x1E0C80C00];
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (*MEMORY[0x1E0C9AE00])
    v3 = (const __CFAllocator *)CFRetain((CFTypeRef)*MEMORY[0x1E0C9AE00]);
  else
    v3 = 0;
  v97 = 0;
  v98 = 0;
  v95 = &off_1E14E98F8;
  alloc = v3;
  v4 = (unsigned int *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v4 >= 0x18)
  {
    v5 = v4[5];
    if ((_DWORD)v5)
    {
      v6 = *v4;
      if (v6 > v5)
      {
        v7 = (char *)v4 + v5;
        v8 = (char *)v4 + v6;
        v9 = v7;
        while (*v9)
        {
          if (++v9 >= v8)
            goto LABEL_15;
        }
        valuePtr = &off_1E14E4818;
        v10 = (__CFString *)CFStringCreateWithCString(alloc, v7, 0x8000100u);
        v102 = 0;
        v103 = 0;
        value = v10;
        MutableDict = AutoDict::getMutableDict((AutoDict *)&v95);
        if (v10)
          CFDictionarySetValue(MutableDict, &unk_1EDCFC828, v10);
        else
          CFDictionaryRemoveValue(MutableDict, &unk_1EDCFC828);
        AutoString::~AutoString((AutoString *)&valuePtr);
      }
    }
  }
LABEL_15:
  v12 = (unsigned int *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v12 >= 0x20)
  {
    v13 = v12[7];
    if ((_DWORD)v13)
    {
      v14 = *v12;
      if (v14 > v13)
      {
        v15 = (char *)v12 + v13;
        v16 = (char *)v12 + v14;
        v17 = v15;
        while (*v17)
        {
          if (++v17 >= v16)
            goto LABEL_26;
        }
        valuePtr = &off_1E14E4818;
        v18 = (__CFString *)CFStringCreateWithCString(alloc, v15, 0x8000100u);
        v102 = 0;
        v103 = 0;
        value = v18;
        v19 = AutoDict::getMutableDict((AutoDict *)&v95);
        if (v18)
          CFDictionarySetValue(v19, &unk_1EDCFC9E8, v18);
        else
          CFDictionaryRemoveValue(v19, &unk_1EDCFC9E8);
        AutoString::~AutoString((AutoString *)&valuePtr);
      }
    }
  }
LABEL_26:
  v20 = (_DWORD *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v20 >= 8u && v20[1])
  {
    v21 = (_DWORD *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
    if (*v21 >= 8u)
      v22 = v21[1];
    else
      v22 = 0;
    snprintf(__str, 0x19uLL, "%lu", v22);
    valuePtr = &off_1E14E4818;
    v23 = (__CFString *)CFStringCreateWithCString(alloc, __str, 0x8000100u);
    v102 = 0;
    v103 = 0;
    value = v23;
    v24 = AutoDict::getMutableDict((AutoDict *)&v95);
    if (v23)
      CFDictionarySetValue(v24, &unk_1EDCFCA20, v23);
    else
      CFDictionaryRemoveValue(v24, &unk_1EDCFCA20);
    AutoString::~AutoString((AutoString *)&valuePtr);
  }
  v25 = (unsigned int *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v25 >= 0x14)
  {
    v26 = v25[4];
    if ((_DWORD)v26)
    {
      v27 = *v25;
      if (v27 > v26)
      {
        v28 = (char *)v25 + v26;
        v29 = (char *)v25 + v27;
        v30 = v28;
        while (*v30)
        {
          if (++v30 >= v29)
            goto LABEL_46;
        }
        valuePtr = &off_1E14E4818;
        v31 = (__CFString *)CFStringCreateWithCString(alloc, v28, 0x8000100u);
        v102 = 0;
        v103 = 0;
        value = v31;
        v32 = AutoDict::getMutableDict((AutoDict *)&v95);
        if (v31)
          CFDictionarySetValue(v32, &unk_1EDCFC710, v31);
        else
          CFDictionaryRemoveValue(v32, &unk_1EDCFC710);
        AutoString::~AutoString((AutoString *)&valuePtr);
      }
    }
  }
LABEL_46:
  v33 = (unsigned int *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v33 >= 0x1C)
  {
    v34 = v33[6];
    if ((_DWORD)v34)
    {
      v35 = *v33;
      if (v35 > v34)
      {
        v36 = (char *)v33 + v34;
        v37 = (char *)v33 + v35;
        v38 = v36;
        while (*v38)
        {
          if (++v38 >= v37)
            goto LABEL_57;
        }
        valuePtr = &off_1E14E4818;
        v39 = (__CFString *)CFStringCreateWithCString(alloc, v36, 0x8000100u);
        v102 = 0;
        v103 = 0;
        value = v39;
        v40 = AutoDict::getMutableDict((AutoDict *)&v95);
        if (v39)
          CFDictionarySetValue(v40, &unk_1EDCFC898, v39);
        else
          CFDictionaryRemoveValue(v40, &unk_1EDCFC898);
        AutoString::~AutoString((AutoString *)&valuePtr);
      }
    }
  }
LABEL_57:
  v41 = (unsigned int *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v41 >= 0x24)
  {
    v42 = v41[8];
    if ((_DWORD)v42)
    {
      v43 = *v41;
      if (v43 > v42)
      {
        v44 = (char *)v41 + v42;
        v45 = (char *)v41 + v43;
        v46 = v44;
        while (*v46)
        {
          if (++v46 >= v45)
            goto LABEL_68;
        }
        valuePtr = &off_1E14E4818;
        v47 = (__CFString *)CFStringCreateWithCString(alloc, v44, 0x8000100u);
        v102 = 0;
        v103 = 0;
        value = v47;
        v48 = AutoDict::getMutableDict((AutoDict *)&v95);
        if (v47)
          CFDictionarySetValue(v48, &unk_1EDCFC630, v47);
        else
          CFDictionaryRemoveValue(v48, &unk_1EDCFC630);
        AutoString::~AutoString((AutoString *)&valuePtr);
      }
    }
  }
LABEL_68:
  v49 = (unsigned int *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v49 >= 0x28)
  {
    v50 = v49[9];
    if ((_DWORD)v50)
    {
      v51 = *v49;
      if (v51 > v50)
      {
        v52 = (char *)v49 + v50;
        v53 = (char *)v49 + v51;
        v54 = v52;
        while (*v54)
        {
          if (++v54 >= v53)
            goto LABEL_79;
        }
        valuePtr = &off_1E14E4818;
        v55 = (__CFString *)CFStringCreateWithCString(alloc, v52, 0x8000100u);
        v102 = 0;
        v103 = 0;
        value = v55;
        v56 = AutoDict::getMutableDict((AutoDict *)&v95);
        if (v55)
          CFDictionarySetValue(v56, &unk_1EDCFC668, v55);
        else
          CFDictionaryRemoveValue(v56, &unk_1EDCFC668);
        AutoString::~AutoString((AutoString *)&valuePtr);
      }
    }
  }
LABEL_79:
  v57 = (_DWORD *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v57 >= 0xCu)
    v58 = v57[2] & 0x7F;
  else
    v58 = 0;
  if ((v58 & 0x10) != 0)
    v59 = 3;
  else
    v59 = 1;
  if ((v58 & 8) != 0)
    v60 = v59;
  else
    v60 = ((v58 & 0x10) >> 3) ^ 2;
  if (v60 >= 2)
  {
    if (v60 != 3)
      goto LABEL_95;
    v61 = AutoDict::getMutableDict((AutoDict *)&v95);
    v62 = &_kCFHTTPCookieSameSiteStrict;
  }
  else
  {
    v61 = AutoDict::getMutableDict((AutoDict *)&v95);
    v62 = &_kCFHTTPCookieSameSiteLax;
  }
  if (*v62)
    CFDictionarySetValue(v61, &unk_1EDCFC908, (const void *)*v62);
  else
    CFDictionaryRemoveValue(v61, &unk_1EDCFC908);
LABEL_95:
  v63 = (*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*(_DWORD *)v63 < 0xCu || (*(_DWORD *)(v63 + 8) & 2) == 0)
  {
    v64 = 0.0;
    if (*(_DWORD *)v63 >= 0x30u)
    {
      valuePtr = *(void (***)(AutoString *__hidden))(v63 + 40);
      v64 = floor(*(double *)&valuePtr);
    }
    v65 = CFDateCreate(alloc, v64);
    v66 = AutoDict::getMutableDict((AutoDict *)&v95);
    if (v65)
    {
      CFDictionarySetValue(v66, &unk_1EDCFC748, v65);
      CFRelease(v65);
    }
    else
    {
      CFDictionaryRemoveValue(v66, &unk_1EDCFC748);
    }
  }
  v67 = (CompactCookieHeader *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  EnumeratedString = (const char *)CompactCookieHeader::getEnumeratedString(v67, 15, 0);
  if (EnumeratedString)
  {
    valuePtr = &off_1E14E4818;
    v69 = (__CFString *)CFStringCreateWithCString(alloc, EnumeratedString, 0x8000100u);
    v102 = 0;
    v103 = 0;
    value = v69;
    v70 = AutoDict::getMutableDict((AutoDict *)&v95);
    if (v69)
      CFDictionarySetValue(v70, &unk_1EDCFC9B0, v69);
    else
      CFDictionaryRemoveValue(v70, &unk_1EDCFC9B0);
    AutoString::~AutoString((AutoString *)&valuePtr);
  }
  v71 = (*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*(_DWORD *)v71 >= 0x38u)
  {
    valuePtr = *(void (***)(AutoString *__hidden))(v71 + 48);
    v72 = floor(*(double *)&valuePtr);
    if (v72 != 0.0)
    {
      valuePtr = *(void (***)(AutoString *__hidden))&v72;
      v73 = CFNumberCreate(v2, kCFNumberFloat64Type, &valuePtr);
      v74 = AutoDict::getMutableDict((AutoDict *)&v95);
      if (v73)
      {
        CFDictionarySetValue(v74, &unk_1EDCFC6A0, v73);
        CFRelease(v73);
      }
      else
      {
        CFDictionaryRemoveValue(v74, &unk_1EDCFC6A0);
      }
    }
  }
  v75 = (_DWORD *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v75 >= 0xCu && (v75[2] & 1) != 0)
  {
    v76 = AutoDict::getMutableDict((AutoDict *)&v95);
    CFDictionarySetValue(v76, &unk_1EDCFC940, CFSTR("TRUE"));
  }
  v77 = (_DWORD *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v77 >= 0xCu && (v77[2] & 4) != 0)
  {
    v78 = AutoDict::getMutableDict((AutoDict *)&v95);
    CFDictionarySetValue(v78, &unk_1EDCFC7B8, CFSTR("TRUE"));
  }
  v79 = (_DWORD *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v79 >= 0xCu && (v79[2] & 2) != 0)
  {
    v80 = AutoDict::getMutableDict((AutoDict *)&v95);
    CFDictionarySetValue(v80, &unk_1EDCFC6D8, CFSTR("TRUE"));
  }
  v81 = (_DWORD *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v81 >= 0xCu && (v81[2] & 0x40) != 0)
  {
    v82 = AutoDict::getMutableDict((AutoDict *)&v95);
    CFDictionarySetValue(v82, &unk_1EDCFC978, CFSTR("TRUE"));
  }
  v83 = (_DWORD *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v83 >= 0x10u)
  {
    v84 = v83[3];
    if ((_DWORD)v84)
    {
      Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E0C9B378]);
      v86 = 0;
      do
      {
        v87 = (unsigned int *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
        v88 = (v86 + 56);
        v89 = *v87;
        if (v89 <= v88 || (char *)v87 + v88 + 2 > (char *)v87 + v89)
          v91 = 0;
        else
          v91 = (const __CFAllocator *)*(unsigned __int16 *)((char *)v87 + v88);
        AutoScalar::AutoScalar((AutoScalar *)&valuePtr, v91);
        if (value)
        {
          CFArrayAppendValue(Mutable, value);
          valuePtr = &off_1E14E47E8;
          if (value)
            CFRelease(value);
        }
        else
        {
          valuePtr = &off_1E14E47E8;
        }
        v86 += 2;
      }
      while (2 * v84 != v86);
      v92 = AutoDict::getMutableDict((AutoDict *)&v95);
      if (Mutable)
      {
        CFDictionarySetValue(v92, &unk_1EDCFC8D0, Mutable);
        CFRelease(Mutable);
      }
      else
      {
        CFDictionaryRemoveValue(v92, &unk_1EDCFC8D0);
      }
    }
  }
  v93 = AutoDict::copyDictAndSetEmpty((AutoDict *)&v95);
  AutoDict::~AutoDict((AutoDict *)&v95);
  return v93;
}

void sub_183ED90D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, CFTypeRef cf)
{
  AutoDict::~AutoDict((AutoDict *)&a11);
  _Unwind_Resume(a1);
}

char *CompactHTTPCookieWithData::cookieHeader(CompactHTTPCookieWithData *this)
{
  return this->var1;
}

CFMutableDictionaryRef AutoDict::getMutableDict(AutoDict *this)
{
  CFMutableDictionaryRef result;
  const __CFAllocator *v3;
  const __CFDictionary *v4;
  const void *v5;

  result = (CFMutableDictionaryRef)*((_QWORD *)this + 3);
  if (!result)
  {
    v3 = (const __CFAllocator *)*((_QWORD *)this + 1);
    v4 = (const __CFDictionary *)*((_QWORD *)this + 2);
    if (v4)
    {
      result = CFDictionaryCreateMutableCopy(v3, 0, v4);
      v5 = (const void *)*((_QWORD *)this + 2);
      *((_QWORD *)this + 2) = 0;
      *((_QWORD *)this + 3) = result;
      if (v5)
      {
        CFRelease(v5);
        return (CFMutableDictionaryRef)*((_QWORD *)this + 3);
      }
    }
    else
    {
      result = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      *((_QWORD *)this + 3) = result;
    }
  }
  return result;
}

void AutoString::~AutoString(AutoString *this)
{
  const void *v2;
  void *v3;
  const __CFAllocator *v4;
  const void *v5;

  *(_QWORD *)this = &off_1E14E4818;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  v3 = (void *)*((_QWORD *)this + 2);
  if (v3)
  {
    v4 = (const __CFAllocator *)*((_QWORD *)this + 3);
    if (v4)
    {
      CFAllocatorDeallocate(v4, v3);
      v5 = (const void *)*((_QWORD *)this + 3);
      *((_QWORD *)this + 2) = 0;
      *((_QWORD *)this + 3) = 0;
      if (v5)
        CFRelease(v5);
    }
  }
}

{
  AutoString::~AutoString(this);
  JUMPOUT(0x186DB748CLL);
}

void AutoDict::~AutoDict(AutoDict *this)
{
  const void *v2;
  const void *v3;
  const void *v4;

  *(_QWORD *)this = &off_1E14EFC70;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 2);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 3);
  if (v4)
    CFRelease(v4);
}

{
  AutoDict::~AutoDict(this);
  JUMPOUT(0x186DB748CLL);
}

CFDictionaryRef AutoDict::copyDictAndSetEmpty(AutoDict *this)
{
  CFDictionaryRef Copy;
  const __CFAllocator *v3;
  const __CFDictionary *v5;
  const __CFAllocator *v6;
  const void *v7;
  AutoDict *Mutable;
  const void *EmptyDict;

  Copy = (CFDictionaryRef)*((_QWORD *)this + 3);
  if (Copy)
    goto LABEL_2;
  v5 = (const __CFDictionary *)*((_QWORD *)this + 2);
  if (v5)
  {
    v6 = CFGetAllocator(*((CFTypeRef *)this + 2));
    Copy = CFDictionaryCreateCopy(v6, v5);
    v7 = (const void *)*((_QWORD *)this + 2);
    *((_QWORD *)this + 2) = 0;
    if (v7)
      CFRelease(v7);
    if (Copy)
    {
LABEL_2:
      v3 = CFGetAllocator(Copy);
      *((_QWORD *)this + 3) = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      return Copy;
    }
  }
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *((_QWORD *)this + 3) = Mutable;
  EmptyDict = (const void *)AutoDict::getEmptyDict(Mutable);
  if (!EmptyDict)
    return 0;
  return (CFDictionaryRef)CFRetain(EmptyDict);
}

uint64_t forceHTTPSByHSTSPreload(const __CFString *a1)
{
  __CFString *IDNAEncodedDomain;
  const char *v2;
  size_t v3;
  char v4;
  size_t v5;
  char *v6;
  unsigned int ResultForCurrentSequence;
  int v8;
  size_t v10;
  net::FixedSetIncrementalLookup *v11[2];
  char v12;

  if (!a1)
  {
    v4 = 0;
    return v4 & 1;
  }
  IDNAEncodedDomain = (__CFString *)createIDNAEncodedDomain(a1);
  v2 = (const char *)-[__CFString UTF8String](IDNAEncodedDomain, "UTF8String");
  v3 = strlen(v2);
  v4 = 0;
  if (v2 && v3)
  {
    if (*v2 == 46)
    {
      if (!--v3)
        goto LABEL_24;
      ++v2;
    }
    v5 = v3 - 1;
    if (v2[v3 - 1] != 46 || (--v3, v5))
    {
      if (getDafsa(void)::mmapDafsaOnceToken != -1)
      {
        v10 = v3;
        dispatch_once(&getDafsa(void)::mmapDafsaOnceToken, &__block_literal_global_1204);
        v3 = v10;
      }
      v4 = 0;
      v11[0] = (net::FixedSetIncrementalLookup *)getDafsa(void)::dafsaToBeReturned;
      v11[1] = (net::FixedSetIncrementalLookup *)(getDafsa(void)::dafsaToBeReturned + getDafsa(void)::dafsaToBeReturned);
      v12 = 0;
      v6 = (char *)&v2[v3 - 1];
      do
      {
        if (!net::FixedSetIncrementalLookup::Advance((char **)v11, *v6))
          break;
        if (--v6 < v2 || *v6 == 46)
        {
          ResultForCurrentSequence = net::FixedSetIncrementalLookup::GetResultForCurrentSequence(v11[0], v12);
          v8 = (ResultForCurrentSequence >> 1) & 1;
          if (v6 < v2)
            LOBYTE(v8) = 1;
          if (ResultForCurrentSequence != -1)
            v4 = v8;
        }
      }
      while (v6 >= v2);
      goto LABEL_20;
    }
LABEL_24:
    v4 = 0;
    if (!IDNAEncodedDomain)
      return v4 & 1;
    goto LABEL_21;
  }
LABEL_20:
  if (IDNAEncodedDomain)
LABEL_21:
    CFRelease(IDNAEncodedDomain);
  return v4 & 1;
}

void sub_183ED94B0(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

char *_CFHostGetTopLevelDomain(unint64_t a1, uint64_t a2, int a3)
{
  BOOL v6;
  char *v7;
  char *i;
  char *v9;
  unsigned int ResultForCurrentSequence;
  int v11;
  char *v12;
  char *v13;
  net::FixedSetIncrementalLookup *v15[2];
  char v16;

  if (!a2)
    return 0;
  if (getDafsa(void)::mmapDafsaOnceToken != -1)
    dispatch_once(&getDafsa(void)::mmapDafsaOnceToken, &__block_literal_global_1204);
  v6 = 0;
  v7 = 0;
  v15[0] = (net::FixedSetIncrementalLookup *)getDafsa(void)::dafsaToBeReturned;
  v15[1] = (net::FixedSetIncrementalLookup *)(getDafsa(void)::dafsaToBeReturned + getDafsa(void)::dafsaToBeReturned);
  v16 = 0;
  for (i = (char *)(a2 + a1 - 1);
        (net::FixedSetIncrementalLookup::Advance((char **)v15, *i) & 1) != 0;
        --i)
  {
    v9 = i - 1;
    if ((unint64_t)(i - 1) < a1 || *v9 == 46)
    {
      ResultForCurrentSequence = net::FixedSetIncrementalLookup::GetResultForCurrentSequence(v15[0], v16);
      if (ResultForCurrentSequence == -1 || (ResultForCurrentSequence & 4) != 0 && !a3)
      {
        v11 = 0;
      }
      else
      {
        if ((ResultForCurrentSequence & 1) != 0)
          return v7;
        v11 = (ResultForCurrentSequence >> 1) & 1;
        v7 = i;
      }
      if (v6)
        v7 = i;
      v6 = v11 != 0;
    }
    if ((unint64_t)v9 < a1)
      return v7;
  }
  if (v6)
  {
    v12 = i - 1;
    do
    {
      v13 = v12;
      if ((unint64_t)v12 < a1)
        break;
      --v12;
    }
    while (*v13 != 46);
    return v13 + 1;
  }
  return v7;
}

char *net::FixedSetIncrementalLookup::Advance(char **this, char a2)
{
  char *v2;
  char v3;
  char v4;
  char *v5;
  char v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  char v10;

  v2 = *this;
  if (!*this)
    return v2;
  if (a2 < 32)
    goto LABEL_18;
  if (!*((_BYTE *)this + 16))
  {
    v5 = *this;
    while (v2)
    {
      v6 = *v2;
      v7 = *v2 & 0x60;
      if (v7 == 64)
      {
        v8 = v2[1] | ((v6 & 0x1F) << 8);
        v9 = 2;
      }
      else if (v7 == 96)
      {
        v8 = ((v6 & 0x1F) << 16) | (v2[1] << 8) | v2[2];
        v9 = 3;
      }
      else
      {
        v8 = v6 & 0x3F;
        v9 = 1;
      }
      v5 += v8;
      v2 += v9;
      if (v6 < 0)
        v2 = 0;
      *this = v2;
      v10 = *v5;
      if ((*v5 & 0x7F) == a2)
      {
        *this = v5 + 1;
        v4 = ~v10;
        goto LABEL_17;
      }
    }
    goto LABEL_18;
  }
  v3 = *v2;
  if ((*v2 & 0x7F) != a2)
  {
LABEL_18:
    v2 = 0;
    *this = 0;
    *((_BYTE *)this + 16) = 0;
    return v2;
  }
  *this = v2 + 1;
  v4 = ~v3;
LABEL_17:
  *((_BYTE *)this + 16) = v4 < 0;
  return (char *)1;
}

uint64_t net::FixedSetIncrementalLookup::GetResultForCurrentSequence(net::FixedSetIncrementalLookup *this, char a2)
{
  net::FixedSetIncrementalLookup *v3;
  char v4;
  int v5;
  unsigned int v6;
  uint64_t v7;

  if (a2)
  {
    if ((*(_BYTE *)this & 0xE0) == 0x80)
      return *(_BYTE *)this & 0x1F;
    else
      return 0xFFFFFFFFLL;
  }
  else
  {
    v3 = this;
    while (this)
    {
      v4 = *(_BYTE *)this;
      v5 = *(_BYTE *)this & 0x60;
      if (v5 == 64)
      {
        v6 = *((unsigned __int8 *)this + 1) | ((v4 & 0x1F) << 8);
        v7 = 2;
      }
      else if (v5 == 96)
      {
        v6 = ((v4 & 0x1F) << 16) | (*((unsigned __int8 *)this + 1) << 8) | *((unsigned __int8 *)this + 2);
        v7 = 3;
      }
      else
      {
        v6 = v4 & 0x3F;
        v7 = 1;
      }
      v3 = (net::FixedSetIncrementalLookup *)((char *)v3 + v6);
      if (v4 < 0)
        this = 0;
      else
        this = (net::FixedSetIncrementalLookup *)((char *)this + v7);
      if ((*(_BYTE *)v3 & 0xE0) == 0x80)
        return *(_BYTE *)v3 & 0x1F;
    }
    return 0xFFFFFFFFLL;
  }
}

_QWORD *CFURLCacheSetMemoryCapacity(_QWORD *result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t TypeID;
  uint64_t v5;
  int64x2_t v6;
  const char *v7;

  if (result)
  {
    v3 = result;
    TypeID = CFURLCacheGetTypeID();
    result = (_QWORD *)CFGetTypeID(v3);
    if ((_QWORD *)TypeID == result)
    {
      v5 = v3[2];
      *(_QWORD *)(v5 + 168) = a2;
      v6.i64[0] = a2;
      v6.i64[1] = *(_QWORD *)(v5 + 176);
      *(int64x2_t *)(v5 + 184) = vcvtq_s64_f64(vmulq_n_f64(vcvtq_f64_s64(v6), *(double *)(v5 + 200)));
    }
    else
    {
      v7 = (const char *)CFURLCacheSetMemoryCapacity::s;
      if (!CFURLCacheSetMemoryCapacity::s)
      {
        v7 = sel_registerName("_nscfBridgeURLCacheSetMemoryCapacity:");
        CFURLCacheSetMemoryCapacity::s = (uint64_t)v7;
      }
      return objc_msgSend(v3, v7, a2);
    }
  }
  return result;
}

void CFURLCacheSetDiskCapacity(_QWORD *a1, uint64_t a2)
{
  uint64_t TypeID;
  const char *v5;
  uint64_t v6;
  int64x2_t v7;
  uint64_t v8;

  if (a1)
  {
    TypeID = CFURLCacheGetTypeID();
    if (TypeID == CFGetTypeID(a1))
    {
      if (a2 >= 5242880 || !a2)
      {
        v6 = a1[2];
        *(_QWORD *)(v6 + 176) = a2;
        v7.i64[0] = *(_QWORD *)(v6 + 168);
        v7.i64[1] = a2;
        *(int64x2_t *)(v6 + 184) = vcvtq_s64_f64(vmulq_n_f64(vcvtq_f64_s64(v7), *(double *)(v6 + 200)));
        os_unfair_lock_lock((os_unfair_lock_t)(v6 + 124));
        v8 = *(_QWORD *)(v6 + 128);
        if (v8)
          *(_QWORD *)(v8 + 176) = a2;
        os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 124));
      }
    }
    else
    {
      v5 = (const char *)CFURLCacheSetDiskCapacity::s;
      if (!CFURLCacheSetDiskCapacity::s)
      {
        v5 = sel_registerName("_nscfBridgeURLCacheSetDiskCapacity:");
        CFURLCacheSetDiskCapacity::s = (uint64_t)v5;
      }
      objc_msgSend(a1, v5, a2);
    }
  }
}

void _CFHTTPMessageSetResponseURL(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*(_BYTE *)(a1 + 40))
      HTTPResponseMessage::setResponseURL((HTTPResponseMessage *)(a1 + 16), cf, 0);
  }
}

CFHTTPMessageRef CFHTTPMessageCreateEmpty(CFAllocatorRef alloc, Boolean isRequest)
{
  int v2;
  uint64_t Instance;
  _OWORD *v4;
  CFAllocatorRef v5;
  _OWORD *v6;

  v2 = isRequest;
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (v2)
  {
    Instance = _CFRuntimeCreateInstance();
    v4 = (_OWORD *)Instance;
    if (Instance)
    {
      *(_OWORD *)(Instance + 16) = 0u;
      v4 = (_OWORD *)(Instance + 16);
      *(_QWORD *)(Instance + 192) = 0;
      *(_OWORD *)(Instance + 160) = 0u;
      *(_OWORD *)(Instance + 176) = 0u;
      *(_OWORD *)(Instance + 128) = 0u;
      *(_OWORD *)(Instance + 144) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(_OWORD *)(Instance + 48) = 0u;
    }
    HTTPMessage::HTTPMessage((HTTPMessage *)v4, "httprequest");
    *(_QWORD *)v4 = &off_1E14E96D8;
    *((_QWORD *)v4 + 1) = &unk_1E14E9758;
    *((_QWORD *)v4 + 2) = &unk_1E14E9778;
    *((_QWORD *)v4 + 16) = &unk_1E14E97A8;
    v5 = CFGetAllocator(v4 - 1);
    HTTPRequestParserClient::HTTPRequestParserClient((HTTPRequestParserClient *)(v4 + 8), v5);
    *(_QWORD *)v4 = &off_1E14E96D8;
    *((_QWORD *)v4 + 1) = &unk_1E14E9758;
    *((_QWORD *)v4 + 2) = &unk_1E14E9778;
    *((_QWORD *)v4 + 16) = &unk_1E14E97A8;
  }
  else
  {
    v6 = (_OWORD *)_CFRuntimeCreateInstance();
    v4 = v6;
    if (v6)
    {
      v6[1] = 0u;
      v4 = v6 + 1;
      v6[18] = 0u;
      v6[19] = 0u;
      v6[16] = 0u;
      v6[17] = 0u;
      v6[14] = 0u;
      v6[15] = 0u;
      v6[12] = 0u;
      v6[13] = 0u;
      v6[10] = 0u;
      v6[11] = 0u;
      v6[8] = 0u;
      v6[9] = 0u;
      v6[6] = 0u;
      v6[7] = 0u;
      v6[4] = 0u;
      v6[5] = 0u;
      v6[2] = 0u;
      v6[3] = 0u;
    }
    HTTPMessage::HTTPMessage((HTTPMessage *)v4, "httpresponse");
    *(_QWORD *)v4 = &off_1E14E9F38;
    *((_QWORD *)v4 + 1) = &unk_1E14E9FA8;
    *((_QWORD *)v4 + 2) = &unk_1E14E9FC8;
    *((_DWORD *)v4 + 32) = -1;
    *((_QWORD *)v4 + 17) = 0;
    v4[10] = 0u;
    v4[11] = 0u;
    v4[12] = 0u;
    v4[13] = 0u;
    v4[14] = 0u;
    v4[15] = 0u;
    v4[16] = 0u;
    v4[17] = 0u;
    *((_BYTE *)v4 + 296) = 0;
  }
  return (CFHTTPMessageRef)(v4 - 1);
}

void sub_183ED9B10(_Unwind_Exception *a1)
{
  HTTPMessage *v1;

  HTTPMessage::~HTTPMessage(v1);
  _Unwind_Resume(a1);
}

Boolean CFHTTPMessageAppendBytes(CFHTTPMessageRef message, const UInt8 *newBytes, CFIndex numBytes)
{
  HTTPMessage *v6;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (message)
    v6 = (CFHTTPMessageRef)((char *)message + 16);
  else
    v6 = 0;
  return HTTPMessage::appendBytes(v6, (const char *)newBytes, numBytes) != 0;
}

_QWORD *HTTPMethodMixedValue::HTTPMethodMixedValue(_QWORD *a1)
{
  *a1 = &off_1E14EB4B8;
  a1[1] = 0;
  a1[1] = CFRetain(&gConstantCFStringValueTable[2590]);
  return a1;
}

void sub_183ED9BDC(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  const void *v3;

  *v1 = &off_1E14E9A00;
  v3 = (const void *)v1[1];
  if (v3)
    CFRelease(v3);
  _Unwind_Resume(exception_object);
}

void _CFURLRequestSetProtocolProperty(void *a1, const __CFString *cf1, CFStringRef a3)
{
  int v6;
  CFTypeID v7;

  if (!CFEqual(cf1, CFSTR("_kNSURLRequestKey")))
  {
    v6 = CFEqual(cf1, CFSTR("_kCFHTTPCookiePolicyPropertySiteForCookies"));
    if (a3 && v6)
    {
      v7 = CFGetTypeID(a3);
      if (v7 != CFURLGetTypeID())
        return;
      a3 = CFURLGetString((CFURLRef)a3);
    }
    URLRequest::setProtocolProperty((URLRequest *)objc_msgSend(a1, "_inner"), cf1, a3);
    return;
  }
  if (_CFURLRequestSetProtocolProperty::sOnce != -1)
    dispatch_once(&_CFURLRequestSetProtocolProperty::sOnce, &__block_literal_global_6_1906);
}

id CFURLCacheCopyResponseForRequest(void *a1, _CFURLRequest *a2)
{
  NSObject *v4;
  uint64_t v5;
  const char *v7;
  _QWORD v8[6];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  if (IsCFURLCache((_BOOL8)a1))
  {
    v9 = 0;
    v10 = &v9;
    v11 = 0x2020000000;
    v12 = 0;
    v4 = dispatch_semaphore_create(0);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = ____CFURLCacheCopyResponseForRequest_block_invoke;
    v8[3] = &unk_1E14F7180;
    v8[4] = v4;
    v8[5] = &v9;
    __CFURLCacheCopyResponseForRequestWithCompletionHandler((uint64_t)a1, a2, 0, (uint64_t)v8);
    dispatch_semaphore_wait(v4, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v4);
    v5 = v10[3];
    _Block_object_dispose(&v9, 8);
    return (id)v5;
  }
  else
  {
    v7 = (const char *)__CFURLCacheCopyResponseForRequestInternalWithSession(_CFURLCache const*,_CFURLRequest const*,unsigned char,NSURLSession *)::s;
    if (!__CFURLCacheCopyResponseForRequestInternalWithSession(_CFURLCache const*,_CFURLRequest const*,unsigned char,NSURLSession *)::s)
    {
      v7 = sel_registerName("_nscfBridgeURLCacheCopyResponseForRequest:");
      __CFURLCacheCopyResponseForRequestInternalWithSession(_CFURLCache const*,_CFURLRequest const*,unsigned char,NSURLSession *)::s = (uint64_t)v7;
    }
    return objc_msgSend(a1, v7, a2);
  }
}

void sub_183ED9DD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void CFURLRequestSetMultipleHTTPHeaderFields(void *a1, const __CFDictionary *a2)
{
  URLRequest *v3;
  HTTPMessage *fHTTPRequest;
  void (**v5)(StringSerializable *__hidden);
  CFTypeRef cf;

  v3 = (URLRequest *)objc_msgSend(a1, "_inner");
  fHTTPRequest = (HTTPMessage *)v3->fHTTPRequest;
  if (!fHTTPRequest)
  {
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v5);
    URLRequest::createHTTPRequest(v3, (CFTypeRef *)&v5);
    v5 = &off_1E14E9A00;
    if (cf)
      CFRelease(cf);
    fHTTPRequest = (HTTPMessage *)v3->fHTTPRequest;
  }
  HTTPMessage::setMultipleHeaderFields(fHTTPRequest, a2);
}

void sub_183ED9E58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t _CFURLResponseCreateFromArchiveList(uint64_t a1, uint64_t a2, const void **a3, uint64_t a4)
{
  NSURLResponseInternal *v7;
  uint64_t v8;

  v7 = objc_alloc_init(NSURLResponseInternal);
  URLResponse::initialize(-[NSURLResponseInternal _inner](v7, "_inner"), a2, a3, a4);
  -[NSURLResponseInternal _inner](v7, "_inner");
  v8 = objc_msgSend(objc_alloc((Class)objc_opt_class()), "_initWithInternal:", v7);

  return v8;
}

uint64_t CFNGetContentLengthFromHeaderFieldValue(const __CFString *a1)
{
  CFIndex Length;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  CFIndex maxBufLen;
  UInt8 buffer[32];
  uint64_t v9;
  CFRange v10;
  CFRange v11;
  CFRange v12;

  v9 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  maxBufLen = 0;
  v3 = (char *)buffer;
  v10.location = 0;
  v10.length = Length;
  if (CFStringGetBytes(a1, v10, 0x8000100u, 0, 0, buffer, 31, &maxBufLen) == Length
    || (v11.location = 0,
        v11.length = Length,
        CFStringGetBytes(a1, v11, 0x8000100u, 0, 0, 0, 0, &maxBufLen),
        v3 = (char *)malloc_type_malloc(maxBufLen + 1, 0x21AF1F85uLL),
        v12.location = 0,
        v12.length = Length,
        CFStringGetBytes(a1, v12, 0x8000100u, 0, 0, (UInt8 *)v3, maxBufLen, &maxBufLen) == Length))
  {
    v3[maxBufLen] = 0;
    v4 = strtoll(v3, 0, 10);
    if (v4 < 0)
      v5 = -1;
    else
      v5 = v4;
    if (v3 != (char *)buffer)
      free(v3);
  }
  else
  {
    free(v3);
    return -1;
  }
  return v5;
}

uint64_t HTTPProtocol::_requestsAreCacheEquivalent(HTTPProtocol *this, HTTPProtocol *a2, const _CFURLRequest *a3, const void *a4)
{
  const __CFURL *v6;
  const __CFURL *v7;
  uint64_t v8;
  const __CFURL *v9;
  const __CFURL *v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  const void *v14;
  _BOOL4 v15;
  const __CFBoolean *v16;
  const __CFBoolean *v17;
  HTTPMessage *v18;
  CFStringRef v19;
  HTTPMessage *v20;
  CFStringRef v21;
  CFStringRef v22;
  _BOOL4 v23;
  _BOOL4 v24;
  int v25;
  HTTPMessage *v26;
  CFStringRef v27;
  CFStringRef v28;
  int v29;
  uint64_t v30;
  const void *v31;
  CFHashCode v32;
  uint64_t v33;
  size_t v34;
  const __CFData *v35;
  HTTPMessage *v36;
  const __CFData *v37;
  HTTPMessage *v38;
  const __CFData *v39;
  HTTPMessage *v40;
  const __CFData *v41;
  _BOOL4 v42;
  HTTPMessage *v43;
  CFDataRef v44;
  char v46[32];
  uint8_t buf[6];
  unsigned __int8 v48;
  unsigned __int8 v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  if ((!this || !a2) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "httpRequestAreCacheEquivalent(): called with a NULL argument", buf, 2u);
  }
  if (this == a2)
    return 1;
  v6 = *(const __CFURL **)(-[HTTPProtocol _inner](this, "_inner", a3, a4) + 8);
  if (v6)
  {
    v48 = 0;
    v7 = _createCanonicalURL(v6, 1, 0, &v48);
  }
  else
  {
    v7 = 0;
  }
  v9 = *(const __CFURL **)(-[HTTPProtocol _inner](a2, "_inner") + 8);
  if (v9)
  {
    v49 = 0;
    v10 = _createCanonicalURL(v9, 1, 0, &v49);
  }
  else
  {
    v10 = 0;
  }
  v11 = CFEqual(v7, v10);
  if (v7)
    CFRelease(v7);
  if (v10)
    CFRelease(v10);
  if (!v11)
    return 0;
  v12 = (unint64_t)CFURLRequestCopyHTTPRequestMethod(this);
  v13 = (unint64_t)CFURLRequestCopyHTTPRequestMethod(a2);
  v14 = (const void *)v13;
  if (v12 && v13)
  {
    v15 = CFEqual((CFTypeRef)v12, (CFTypeRef)v13) != 0;
  }
  else
  {
    v15 = (v12 | v13) == 0;
    if (!v12)
      goto LABEL_23;
  }
  CFRelease((CFTypeRef)v12);
LABEL_23:
  if (v14)
    CFRelease(v14);
  if (!v15)
    return 0;
  v16 = _CFURLRequestCopyProtocolPropertyForKey(this, CFSTR("__SKIP_USER_AGENT_IN_REQUEST_EQUIVALENCY_CHECK__"));
  v17 = v16;
  if (!v16 || !CFBooleanGetValue(v16))
  {
    v18 = *(HTTPMessage **)(-[HTTPProtocol _inner](this, "_inner") + 56);
    if (v18)
      v19 = HTTPMessage::copyHeaderFieldValue(v18, 0x14C15415u);
    else
      v19 = 0;
    v20 = *(HTTPMessage **)(-[HTTPProtocol _inner](a2, "_inner") + 56);
    if (v20)
    {
      v21 = HTTPMessage::copyHeaderFieldValue(v20, 0x14C15415u);
      v22 = v21;
      v23 = v19 != 0;
      v24 = v21 != 0;
      if (v19 && v21)
      {
        v25 = CFEqual(v19, v21) != 0;
LABEL_38:
        CFRelease(v19);
LABEL_39:
        if (v22)
          CFRelease(v22);
        if (!v25)
          goto LABEL_73;
        goto LABEL_42;
      }
    }
    else
    {
      v24 = 0;
      v22 = 0;
      v23 = v19 != 0;
    }
    v25 = !v23 && !v24;
    if (!v19)
      goto LABEL_39;
    goto LABEL_38;
  }
LABEL_42:
  v26 = *(HTTPMessage **)(-[HTTPProtocol _inner](a2, "_inner") + 56);
  if (v26
    && (v27 = CFHTTPMessageCopyRequestMethod((HTTPMessage *)((char *)v26 - 16)), (v28 = v27) != 0)
    && (v29 = CFEqual(v27, &unk_1EDCFE1C0), CFRelease(v28), v29))
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    HTTPMessage::ensureParserFinished(v26);
    v30 = *((_QWORD *)v26 + 6);
    if (!v30 || (v31 = *(const void **)(v30 + 16)) == 0 && (v31 = *(const void **)(v30 + 24)) == 0)
    {
      v43 = *(HTTPMessage **)(-[HTTPProtocol _inner](this, "_inner") + 56);
      if (!v43 || (v44 = HTTPMessage::copyBody(v43)) == 0)
      {
LABEL_71:
        v8 = 1;
        if (!v17)
          return v8;
        goto LABEL_74;
      }
      CFRelease(v44);
      goto LABEL_73;
    }
    v32 = CFHash(v31);
    v33 = MEMORY[0x1E0C80A78](v32);
    snprintf(v46, 0x11uLL, "%ld", v33);
    v34 = strlen(v46);
    v35 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v46, v34);
    v36 = *(HTTPMessage **)(-[HTTPProtocol _inner](this, "_inner") + 56);
    if (v36)
      v37 = HTTPMessage::copyBody(v36);
    else
      v37 = 0;
    v42 = equalData(v37, v35);
    if (v37)
      CFRelease(v37);
    if (v35)
      CFRelease(v35);
  }
  else
  {
    v38 = *(HTTPMessage **)(-[HTTPProtocol _inner](this, "_inner") + 56);
    if (v38)
      v39 = HTTPMessage::copyBody(v38);
    else
      v39 = 0;
    v40 = *(HTTPMessage **)(-[HTTPProtocol _inner](a2, "_inner") + 56);
    if (v40)
      v41 = HTTPMessage::copyBody(v40);
    else
      v41 = 0;
    v42 = equalData(v39, v41);
    if (v39)
      CFRelease(v39);
    if (v41)
      CFRelease(v41);
  }
  if (v42)
    goto LABEL_71;
LABEL_73:
  v8 = 0;
  if (v17)
LABEL_74:
    CFRelease(v17);
  return v8;
}

void sub_183EDA4E4(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

CFStringRef HTTPMessage::copyHeaderFieldValue(HTTPMessage *this, unsigned int a2)
{
  CFDictionaryRef *v4;
  const __CFAllocator *v5;
  CFStringRef v6;
  void (**v8)(StringSerializable *__hidden);
  CFTypeRef cf;

  HTTPMessage::ensureParserFinished(this);
  v4 = (CFDictionaryRef *)HTTPMessage::headers((os_unfair_lock_s *)this);
  v5 = CFGetAllocator((char *)this - 16);
  HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v8, a2);
  v6 = HTTPHeaderDict::copyStringValue(v4, v5, (const HTTPHeaderKeyMixedValue *)&v8);
  v8 = &off_1E14E9A00;
  if (cf)
    CFRelease(cf);
  return v6;
}

void sub_183EDA5C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void *HTTPProtocol::_createCanonicalRequest(HTTPProtocol *this, const __CFAllocator *a2, _CFURLRequest *a3, NSURLSessionTask *a4, const void *a5)
{
  const __CFURL *v7;
  os_unfair_lock_s *v8;
  const void *v9;
  os_unfair_lock_s *v10;
  void *v11;
  HSTSPolicy *v12;
  const __CFURL *v13;
  void *v14;
  void *v15;
  void *v16;
  const __CFString *v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *v20;
  NSObject *v21;
  uint64_t v22;
  const __CFString *v23;
  const __CFString *v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  const __CFString *v28;
  const __CFString *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned __int8 v36;
  uint8_t buf[4];
  const __CFURL *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 0;
  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  v7 = *(const __CFURL **)(-[__CFAllocator _inner](a2, "_inner") + 8);
  if (!v7)
    goto LABEL_28;
  v36 = 0;
  if (*(_QWORD *)(-[__CFAllocator _inner](a2, "_inner") + 200))
  {
    v8 = (os_unfair_lock_s *)CFRetain(*(CFTypeRef *)(-[__CFAllocator _inner](a2, "_inner") + 200));
    if (v8)
      goto LABEL_19;
  }
  v9 = *(const void **)(-[__CFAllocator _inner](a2, "_inner") + 224);
  if (!v9)
  {
    v8 = 0;
    if (!a3)
      goto LABEL_18;
    goto LABEL_16;
  }
  v8 = (os_unfair_lock_s *)CFRetain(v9);
  if (v8)
  {
    if (StorageSession::Class(void)::sOnce_StorageSession != -1)
      dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_16297);
    v10 = (os_unfair_lock_s *)StorageSession::copyHSTSStorage(v8 + 4);
    CFRelease(v8);
    v8 = v10;
  }
  if (a3)
  {
LABEL_16:
    if (!v8)
      v8 = (os_unfair_lock_s *)-[_CFURLRequest _copyHSTSPolicy](a3, "_copyHSTSPolicy");
  }
LABEL_18:
  if (!v8)
  {
    v12 = 0;
    goto LABEL_23;
  }
LABEL_19:
  if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1)
    dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_313);
  v12 = (HSTSPolicy *)&v8[4];
LABEL_23:
  v13 = _createCanonicalURL(v7, 1, v12, &v36);
  if (v8)
    CFRelease(v8);
  if (v13)
  {
    v14 = (void *)-[_CFURLRequest _effectiveConfiguration](a3, "_effectiveConfiguration");
    if (v14)
      v15 = (void *)objc_msgSend(v14, "_suppressedAutoAddedHTTPHeaders");
    else
      v15 = 0;
    v16 = (void *)-[__CFAllocator mutableCopy](a2, "mutableCopy");
    v11 = v16;
    if (v13 != v7)
    {
      CFURLRequestSetURL(v16, v13);
      v17 = CFURLCopyScheme(v7);
      v18 = v17;
      if (v17)
      {
        if (CFStringCompare(v17, CFSTR("http"), 1uLL) == kCFCompareEqualTo)
        {
          v19 = CFURLCopyScheme(v13);
          v20 = v19;
          if (v19)
          {
            if (CFStringCompare(v19, (CFStringRef)&unk_1EDD00AE0, 1uLL) == kCFCompareEqualTo && !v36)
            {
              if (CFNLog::onceToken != -1)
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
              v21 = CFNLog::logger;
              if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 138412290;
                v38 = v13;
                _os_log_debug_impl(&dword_183ECA000, v21, OS_LOG_TYPE_DEBUG, "%@ scheme was upgraded due to dynamic HSTS", buf, 0xCu);
              }
              *(_BYTE *)(objc_msgSend(v11, "_inner") + 155) = 1;
            }
            CFRelease(v20);
          }
        }
        CFRelease(v18);
      }
    }
    CFRelease(v13);
    addHeaderIfMissing(v11, 0x10F0D266u, (uint64_t)&__block_literal_global_7318, v15);
    addHeaderIfMissing(v11, 0x1111F272u, (uint64_t)&__block_literal_global_2_7319, v15);
    v22 = *(_QWORD *)(-[__CFAllocator _inner](a2, "_inner") + 56);
    if (v22 && *(_BYTE *)(v22 + 216))
    {
      if ((v23 = *(const __CFString **)(v22 + 152)) != 0
        && (CFStringCompare(v23, (CFStringRef)&gConstantCFStringValueTable[2590], 0) == kCFCompareEqualTo
         || ((v24 = *(const __CFString **)(v22 + 152)) != 0
          || os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
          && (*(_WORD *)buf = 0,
              _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u), (v24 = *(const __CFString **)(v22 + 152)) != 0))&& CFStringCompare(v24, (CFStringRef)&gConstantCFStringValueTable[2597], 0) == kCFCompareEqualTo)|| *(_BYTE *)(v22 + 218))
      {
        v25 = *(_QWORD *)(-[__CFAllocator _inner](a2, "_inner") + 56);
        if (v25)
          v26 = *(_BYTE *)(v25 + 217) != 0;
        else
          v26 = 0;
        CFURLRequestSetShouldPipelineHTTP(v11, 1, v26);
      }
    }
    v27 = *(_QWORD *)(-[__CFAllocator _inner](a2, "_inner") + 88);
    *(_QWORD *)(objc_msgSend(v11, "_inner") + 88) = v27;
    addHeaderIfMissing(v11, 0x1101F26Au, (uint64_t)&__block_literal_global_3, v15);
    v28 = (const __CFString *)CFURLRequestCopyHTTPRequestMethod(v11);
    v29 = v28;
    if (v28)
    {
      if (CFStringCompare(v28, (CFStringRef)&unk_1EDCFE1C0, 1uLL) == kCFCompareEqualTo)
      {
        v30 = objc_msgSend(v11, "_inner");
        v31 = v30;
        v32 = *(_QWORD *)(v30 + 56);
        if (v32)
        {
          HTTPMessage::ensureParserFinished(*(HTTPMessage **)(v30 + 56));
          if (*(_QWORD *)(v32 + 48) || (v33 = *(_QWORD *)(v31 + 56), *(_QWORD *)(v33 + 208)) || *(_QWORD *)(v33 + 200))
            addHeaderIfMissing(v11, 0x11F192E0u, (uint64_t)&__block_literal_global_6_7320, v15);
        }
      }
      CFRelease(v29);
    }
    goto LABEL_64;
  }
LABEL_28:
  v11 = 0;
LABEL_64:
  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  if (v11)
  {
    v34 = objc_msgSend(v11, "_inner");
    *(_WORD *)(v34 + 64) &= ~2u;
  }
  return v11;
}

void sub_183EDAAF0(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;

  CFRelease(v2);
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void addHeaderIfMissing(void *a1, unsigned int a2, uint64_t a3, void *a4)
{
  uint64_t v7;
  const __CFString *v8;
  os_unfair_lock_s *v9;
  URLRequest *v10;
  HTTPMessage *fHTTPRequest;
  unsigned int v12;
  const __CFString *v13;
  const __CFURL *v14;
  URLRequest *v15;
  const __CFString *v16;
  const __CFString *v17;
  const __CFString *v18;
  CFComparisonResult v19;
  void (**v20)(StringSerializable *__hidden);
  CFTypeRef cf;

  if (!a4 || (objc_msgSend(a4, "containsObject:", &gConstantCFStringValueTable[7 * ((a2 >> 20) & 0x3FF)]) & 1) == 0)
  {
    v7 = (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
    if (v7)
    {
      v8 = (const __CFString *)v7;
      v9 = *(os_unfair_lock_s **)(objc_msgSend(a1, "_inner") + 56);
      if (v9 && HTTPMessage::hasHeaderField(v9, a2))
        goto LABEL_14;
      if (a2 == 285340266 && CFStringCompare(v8, CFSTR("gzip, deflate"), 1uLL) == kCFCompareEqualTo)
      {
        v14 = *(const __CFURL **)(objc_msgSend(a1, "_inner") + 8);
        if (!v14)
          goto LABEL_14;
        v15 = (URLRequest *)objc_msgSend(a1, "_inner");
        if (dyld_program_sdk_at_least())
        {
          v16 = CFURLCopyScheme(v14);
          v17 = CFSTR("gzip, deflate");
          if (v16)
          {
            v18 = v16;
            v19 = CFStringCompare(v16, (CFStringRef)&unk_1EDD00AE0, 1uLL);
            CFRelease(v18);
            if (v19 == kCFCompareEqualTo)
              v17 = CFSTR("gzip, deflate, br");
          }
        }
        else
        {
          v17 = CFSTR("gzip, deflate");
        }
        fHTTPRequest = (HTTPMessage *)v15->fHTTPRequest;
        if (!fHTTPRequest)
        {
          HTTPMethodMixedValue::HTTPMethodMixedValue(&v20);
          URLRequest::createHTTPRequest(v15, (CFTypeRef *)&v20);
          v20 = &off_1E14E9A00;
          if (cf)
            CFRelease(cf);
          fHTTPRequest = (HTTPMessage *)v15->fHTTPRequest;
        }
        v12 = 285340266;
        v13 = v17;
      }
      else
      {
        v10 = (URLRequest *)objc_msgSend(a1, "_inner");
        fHTTPRequest = (HTTPMessage *)v10->fHTTPRequest;
        if (!fHTTPRequest)
        {
          HTTPMethodMixedValue::HTTPMethodMixedValue(&v20);
          URLRequest::createHTTPRequest(v10, (CFTypeRef *)&v20);
          v20 = &off_1E14E9A00;
          if (cf)
            CFRelease(cf);
          fHTTPRequest = (HTTPMessage *)v10->fHTTPRequest;
        }
        v12 = a2;
        v13 = v8;
      }
      HTTPMessage::setHeaderFieldStringValue(fHTTPRequest, v12, v13);
LABEL_14:
      CFRelease(v8);
    }
  }
}

void sub_183EDAD10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t HTTPMessage::hasHeaderField(os_unfair_lock_s *this, unsigned int a2)
{
  CFDictionaryRef *v3;
  uint64_t v4;
  void (**v6)(StringSerializable *__hidden);
  CFTypeRef cf;

  v3 = (CFDictionaryRef *)HTTPMessage::headers(this);
  HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v6, a2);
  v4 = HTTPHeaderDict::containsKey(v3, (const HTTPHeaderKeyMixedValue *)&v6);
  v6 = &off_1E14E9A00;
  if (cf)
    CFRelease(cf);
  return v4;
}

void sub_183EDAD9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(HTTPHeaderKeyMixedValue *this, unsigned int a2)
{
  *(_QWORD *)this = &off_1E14ECB08;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 1) = CFRetain(&gConstantCFStringValueTable[7 * ((a2 >> 20) & 0x3FF)]);
}

void sub_183EDAE08(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  const void *v3;

  *v1 = &off_1E14E9A00;
  v3 = (const void *)v1[1];
  if (v3)
    CFRelease(v3);
  _Unwind_Resume(exception_object);
}

uint64_t HTTPHeaderDict::containsKey(CFDictionaryRef *this, const HTTPHeaderKeyMixedValue *a2)
{
  const void *v4;
  CFTypeRef v5;
  uint64_t v6;

  CFGetAllocator(this - 2);
  v4 = (const void *)*((_QWORD *)a2 + 1);
  if (!v4)
    return CFDictionaryContainsKey(this[1], 0);
  v5 = CFRetain(v4);
  v6 = CFDictionaryContainsKey(this[1], v5);
  if (v5)
    CFRelease(v5);
  return v6;
}

void HTTPMessage::setHeaderFieldStringValue(HTTPMessage *a1, unsigned int a2, const void *a3)
{
  HTTPHeaderDict *v5;
  void (**v6)(StringSerializable *__hidden);
  CFTypeRef cf;
  void (**v8)(StringSerializable *__hidden);
  CFTypeRef v9;

  if (a3)
  {
    v5 = HTTPMessage::mutableHeaders(a1);
    HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(&v8, a2);
    HTTPHeaderValueMixedValue::HTTPHeaderValueMixedValue((HTTPHeaderValueMixedValue *)&v6, a3);
    HTTPHeaderDict::setValue((uint64_t)v5, (uint64_t)&v8, (uint64_t)&v6);
    v6 = &off_1E14E9A00;
    if (cf)
      CFRelease(cf);
    v8 = &off_1E14E9A00;
    if (v9)
      CFRelease(v9);
  }
  else
  {
    HTTPMessage::removeHeaderFieldValue(a1, a2);
  }
}

void sub_183EDAF3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf, uint64_t a11, CFTypeRef a12)
{
  if (cf)
    CFRelease(cf);
  if (a12)
    CFRelease(a12);
  _Unwind_Resume(exception_object);
}

__CFString *_createCacheKeyForRequest(_CFURLRequest *a1, int a2, __CFString *a3)
{
  const __CFURL *v6;
  const __CFURL *CanonicalURL;
  const __CFURL *v8;
  CFStringRef v9;
  const __CFString *v10;
  uint64_t v11;
  const __CFDictionary *v12;
  const __CFBoolean *Value;
  __CFString *v14;
  HTTPMessage *v16;
  __CFHTTPMessage *v17;
  __CFHTTPMessage *v18;
  uint64_t v19;
  const void *v20;
  const __CFString *v21;
  const __CFString *v22;
  CFHashCode v23;
  uint64_t v24;
  size_t v25;
  CFIndex Length;
  CFIndex v27;
  const __CFAllocator *v28;
  const UInt8 *BytePtr;
  void *v30;
  void *v31;
  void *v32;
  uint64_t v33;
  uint64_t i;
  void *v35;
  const __CFDictionary *v36;
  void *v37;
  char v38;
  void *v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  __CFString *MutableCopy;
  char v48[16];
  CFHTTPMessageRef v49;
  _BOOL4 v50;
  CFStringRef v51;
  CFStringRef v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  unsigned __int8 v57[128];
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v6 = *(const __CFURL **)(-[_CFURLRequest _inner](a1, "_inner") + 8);
  if (!v6)
    return 0;
  v57[0] = 0;
  CanonicalURL = _createCanonicalURL(v6, 1, 0, v57);
  v8 = CanonicalURL;
  if (!CanonicalURL)
    return 0;
  v9 = CFURLGetString(CanonicalURL);
  if (!v9)
  {
    CFRelease(v8);
    return 0;
  }
  v10 = v9;
  CFRetain(v9);
  CFRelease(v8);
  v11 = -[_CFURLRequest _inner](a1, "_inner");
  v12 = *(const __CFDictionary **)(v11 + 40);
  if (v12)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(v11 + 40), CFSTR("kCFURLRequestDoNotDecodeData"));
    if (Value)
      v50 = CFBooleanGetValue(Value) != 0;
    else
      v50 = 0;
    v51 = (CFStringRef)CFDictionaryGetValue(v12, CFSTR("_kCFURLCachePartitionKey"));
  }
  else
  {
    v50 = 0;
    v51 = 0;
  }
  v16 = *(HTTPMessage **)(-[_CFURLRequest _inner](a1, "_inner") + 56);
  v17 = (HTTPMessage *)((char *)v16 - 16);
  if (v16)
    v18 = (HTTPMessage *)((char *)v16 - 16);
  else
    v18 = 0;
  v49 = v18;
  if (!v16)
  {
    v22 = 0;
    v52 = 0;
    goto LABEL_52;
  }
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  HTTPMessage::ensureParserFinished(v16);
  v19 = *((_QWORD *)v16 + 6);
  if (!v19)
  {
    v52 = CFHTTPMessageCopyRequestMethod((HTTPMessage *)((char *)v16 - 16));
    goto LABEL_34;
  }
  v20 = *(const void **)(v19 + 16);
  if (v20)
  {
    v21 = CFHTTPMessageCopyRequestMethod(v17);
  }
  else
  {
    v20 = *(const void **)(v19 + 24);
    v52 = CFHTTPMessageCopyRequestMethod(v17);
    if (!v20)
      goto LABEL_34;
    v21 = v52;
  }
  v52 = v21;
  if (v21 && CFStringCompare(v52, (CFStringRef)&unk_1EDCFE1C0, 1uLL) == kCFCompareEqualTo && a2)
  {
    v23 = CFHash(v20);
    v24 = MEMORY[0x1E0C80A78](v23);
    snprintf(v48, 0x11uLL, "%ld", v24);
    v25 = strlen(v48);
    v22 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v48, v25, 0x8000100u, 0);
    if (!a3)
      goto LABEL_53;
    goto LABEL_35;
  }
  Length = CFDataGetLength((CFDataRef)v20);
  if (Length >= 1)
  {
    v27 = Length;
    v28 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    BytePtr = CFDataGetBytePtr((CFDataRef)v20);
    v22 = CFStringCreateWithBytes(v28, BytePtr, v27, 0x8000100u, 0);
    if (!a3)
      goto LABEL_53;
    goto LABEL_35;
  }
LABEL_34:
  v22 = 0;
  if (a3)
  {
LABEL_35:
    v30 = (void *)-[__CFString stringByTrimmingCharactersInSet:](a3, "stringByTrimmingCharactersInSet:", objc_msgSend(MEMORY[0x1E0CB3500], "whitespaceCharacterSet", v49));
    v31 = (void *)objc_msgSend(v30, "componentsSeparatedByString:", CFSTR(","));
    if (objc_msgSend(v31, "count"))
    {
      v32 = (void *)objc_msgSend(MEMORY[0x1E0C99E20], "set");
      v33 = objc_msgSend(v31, "count");
      if (v33)
      {
        for (i = 0; i != v33; ++i)
        {
          v35 = (void *)objc_msgSend(v31, "objectAtIndexedSubscript:", i);
          objc_msgSend(v32, "addObject:", objc_msgSend(v35, "stringByTrimmingCharactersInSet:", objc_msgSend(MEMORY[0x1E0CB3500], "whitespaceCharacterSet")));
        }
      }
      v36 = CFHTTPMessageCopyAllHeaderFields(v49);
      v37 = (void *)objc_msgSend(MEMORY[0x1E0CB37A0], "string");
      v38 = objc_msgSend(v30, "isEqualToString:", CFSTR("*"));
      v39 = (void *)MEMORY[0x1E0C99DE8];
      if ((v38 & 1) != 0)
        v40 = -[__CFDictionary allKeys](v36, "allKeys");
      else
        v40 = objc_msgSend(v32, "allObjects");
      v41 = (void *)objc_msgSend(v39, "arrayWithArray:", v40);
      objc_msgSend(v41, "sortUsingComparator:", &__block_literal_global_18090);
      v55 = 0u;
      v56 = 0u;
      v54 = 0u;
      v53 = 0u;
      v42 = objc_msgSend(v41, "countByEnumeratingWithState:objects:count:", &v53, v57, 16);
      if (v42)
      {
        v43 = *(_QWORD *)v54;
LABEL_44:
        v44 = 0;
        while (1)
        {
          if (*(_QWORD *)v54 != v43)
            objc_enumerationMutation(v41);
          v45 = *(_QWORD *)(*((_QWORD *)&v53 + 1) + 8 * v44);
          v46 = -[__CFDictionary objectForKeyedSubscript:](v36, "objectForKeyedSubscript:", v45);
          if (!v46)
            goto LABEL_52;
          objc_msgSend(v37, "appendFormat:", CFSTR("%@: %@\n"), v45, v46);
          if (v42 == ++v44)
          {
            v42 = objc_msgSend(v41, "countByEnumeratingWithState:objects:count:", &v53, v57, 16);
            if (v42)
              goto LABEL_44;
            break;
          }
        }
      }
      if (objc_msgSend(v37, "length"))
      {
        a3 = v37;
        goto LABEL_53;
      }
    }
LABEL_52:
    a3 = 0;
  }
LABEL_53:
  if (v50 || v22 || v51 || a3)
  {
    MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v10);
    v14 = MutableCopy;
    if (v22)
      CFStringAppend(MutableCopy, v22);
    if (v50)
      CFStringAppend(v14, CFSTR(";*__%%%SKIP_DECODING%%%__*;"));
    if (v51)
    {
      CFStringAppend(v14, CFSTR("["));
      CFStringAppend(v14, v51);
      CFStringAppend(v14, CFSTR("]"));
    }
    if (a3)
    {
      CFStringAppend(v14, CFSTR("\n"));
      CFStringAppend(v14, a3);
      CFStringAppend(v14, CFSTR("\n"));
    }
    if (v14)
    {
      CFRelease(v10);
      if (!v22)
        goto LABEL_71;
    }
    else
    {
      v14 = (__CFString *)v10;
      if (!v22)
        goto LABEL_71;
    }
    CFRelease(v22);
    goto LABEL_71;
  }
  v14 = (__CFString *)v10;
LABEL_71:
  if (v52)
    CFRelease(v52);
  if (a3)
    CFRelease(a3);
  return v14;
}

void sub_183EDB57C(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

const __CFURL *_createCanonicalURL(const __CFURL *a1, uint64_t a2, HSTSPolicy *a3, unsigned __int8 *a4)
{
  const __CFURL *CanonicalURL;
  const __CFAllocator *v8;
  CFRange v9;
  UInt8 *v11;
  unint64_t v12;
  CFIndex v13;
  UInt8 *v14;
  unint64_t v15;
  char v16;
  int v17;
  int v18;
  CFRange v19;
  UInt8 *v20;
  unint64_t v21;
  char v22;
  UInt8 *v23;
  int v24;
  CFIndex v25;
  UInt8 *v26;
  int v27;
  int v28;
  int v29;
  CFIndex location;
  CFIndex v31;
  int v32;
  UInt8 *v33;
  int v34;
  CFRange v36;
  CFIndex v37;
  CFIndex v38;
  CFIndex v39;
  CFRange v40;
  CFRange v41;
  CFIndex length;
  const char *v43;
  _BYTE *v44;
  UInt8 *v45;
  _BYTE *v46;
  CFIndex v47;
  char v48;
  size_t v49;
  uint64_t v50;
  CFIndex v51;
  char *v52;
  CFRange v53;
  uint64_t v54;
  CFStringEncoding v55;
  CFURLRef v56;
  CFStringEncoding v57;
  _BYTE *v58;
  unsigned __int8 *v59;
  CFRange rangeIncludingSeparators;
  uint8_t buf[256];
  UInt8 buffer[128];
  uint64_t v63;

  CanonicalURL = a1;
  v63 = *MEMORY[0x1E0C80C00];
  v8 = CFGetAllocator(a1);
  if (!CanonicalURL && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "createCanonicalURL(): Passed a NULL URL!", buf, 2u);
  }
  v9 = CFURLGetByteRangeForComponent(CanonicalURL, kCFURLComponentScheme, 0);
  if (v9.location == -1 || CFURLGetBaseURL(CanonicalURL))
    return 0;
  v59 = a4;
  v11 = buffer;
  v12 = CFURLGetBytes(CanonicalURL, buffer, 114);
  if (v12 >= 0x72)
  {
    v13 = CFURLGetBytes(CanonicalURL, 0, 0);
    v11 = (UInt8 *)CFAllocatorAllocate(v8, v13 + 14, 0);
    CFURLGetBytes(CanonicalURL, v11, v13);
  }
  else
  {
    v13 = v12;
  }
  if (v9.length < 1)
  {
LABEL_19:
    v18 = 0;
  }
  else
  {
    v14 = &v11[v9.location];
    v15 = (unint64_t)&v11[v9.location + v9.length];
    v16 = 1;
    do
    {
      while (1)
      {
        v17 = *v14;
        if ((v17 - 65) >= 0x1A)
          break;
        v16 = 0;
        *v14++ = v17 + 32;
        if ((unint64_t)v14 >= v15)
          goto LABEL_20;
      }
      ++v14;
    }
    while ((unint64_t)v14 < v15);
    if ((v16 & 1) != 0)
      goto LABEL_19;
LABEL_20:
    v18 = 1;
  }
  if (v9.length + 2 > v13)
    goto LABEL_22;
  v25 = v9.length + 1;
  v26 = &v11[v9.length + 1];
  v27 = *v26;
  if (v27 == 47 && (v9.length + 3 > v13 || v11[v9.length + 2] == 47))
    goto LABEL_22;
  if (v9.length == 3)
  {
    if (*v11 != 102 || v11[1] != 116 || v11[2] != 112)
      goto LABEL_22;
    v29 = v11[3];
    goto LABEL_96;
  }
  if (v9.length == 5)
  {
    if (*v11 != 104 || v11[1] != 116 || v11[2] != 116 || v11[3] != 112 || v11[4] != 115)
      goto LABEL_22;
    v29 = v11[5];
    goto LABEL_96;
  }
  if (v9.length != 4)
    goto LABEL_22;
  v28 = *v11;
  if (v28 != 102)
  {
    if (v28 != 104 || v11[1] != 116 || v11[2] != 116 || v11[3] != 112)
      goto LABEL_22;
    v29 = v11[4];
LABEL_96:
    if (v29 == 58)
    {
      v49 = v13 - v25;
      if (v27 == 47)
      {
        memmove(v26 + 1, &v11[v9.length + 1], v49);
        *v26 = 47;
        v50 = 1;
      }
      else
      {
        memmove(v26 + 2, &v11[v9.length + 1], v49);
        *(_WORD *)v26 = 12079;
        v50 = 2;
      }
      v51 = v13 + v50;
LABEL_127:
      v55 = _CFURLGetEncoding();
      v56 = CFURLCreateWithBytes(v8, v11, v51, v55, 0);
      CanonicalURL = (const __CFURL *)_createCanonicalURL(v56, a2, a3, v59);
      if (v11 != buffer)
        CFAllocatorDeallocate(v8, v11);
      CFRelease(v56);
      return CanonicalURL;
    }
    goto LABEL_22;
  }
  if (v11[1] == 105 && v11[2] == 108 && v11[3] == 101 && v11[4] == 58)
  {
    memmove(v26 + 2, v11 + 5, v13 - v25);
    *(_WORD *)&v11[v25] = 12079;
    v51 = v13 + 2;
    goto LABEL_127;
  }
LABEL_22:
  v19 = CFURLGetByteRangeForComponent(CanonicalURL, kCFURLComponentHost, &rangeIncludingSeparators);
  if (v19.location != -1 && v19.length)
  {
    v20 = &v11[v19.location];
    if (v19.length >= 1)
    {
      v21 = (unint64_t)&v20[v19.length];
      v22 = 1;
      v23 = &v11[v19.location];
      do
      {
        while (1)
        {
          v24 = *v23;
          if ((v24 - 65) >= 0x1A)
            break;
          v22 = 0;
          *v23++ = v24 + 32;
          if ((unint64_t)v23 >= v21)
            goto LABEL_53;
        }
        ++v23;
      }
      while ((unint64_t)v23 < v21);
      if ((v22 & 1) != 0)
        goto LABEL_54;
LABEL_53:
      v18 = 1;
    }
LABEL_54:
    v34 = 1;
    if ((_DWORD)a2 || v19.length != 9)
      goto LABEL_66;
    if (*(_QWORD *)v20 != 0x736F686C61636F6CLL || v20[8] != 116)
      goto LABEL_66;
    if (v13 - v19.location != 9)
      memmove(&v11[v19.location], v20 + 9, v13 - v19.location - 9);
    v34 = 0;
    v13 -= 9;
    v32 = 1;
LABEL_64:
    v18 = 1;
    goto LABEL_67;
  }
  if ((_DWORD)a2)
  {
    location = rangeIncludingSeparators.location;
    if (v19.location != -1)
      location = v19.location;
    if (location == -1)
      v31 = v13;
    else
      v31 = location;
    if (v13 > v31)
      memmove(&v11[v31 + 9], &v11[v31], v13 - v31);
    v32 = 0;
    v33 = &v11[v31];
    *(_QWORD *)v33 = *(_QWORD *)"localhost";
    v33[8] = 116;
    v13 += 9;
    v34 = 1;
    goto LABEL_64;
  }
  v34 = 1;
LABEL_66:
  v32 = 1;
LABEL_67:
  v36 = CFURLGetByteRangeForComponent(CanonicalURL, kCFURLComponentPath, &rangeIncludingSeparators);
  if (v36.location == -1 || !v36.length)
  {
    v37 = rangeIncludingSeparators.location;
    if (v36.location != -1)
      v37 = v36.location;
    v38 = v37 + 9;
    if (v32)
      v38 = v37;
    if (!v34)
      v38 -= 9;
    if (v37 == -1)
      v39 = v13;
    else
      v39 = v38;
    if (v13 > v39)
      memmove(&v11[v39 + 1], &v11[v39], v13 - v39);
    v11[v39] = 47;
    ++v13;
    v18 = 1;
  }
  v40 = CFURLGetByteRangeForComponent(CanonicalURL, kCFURLComponentScheme, 0);
  if (v40.length == 4 && v13 >= 5 && *v11 == 104 && v11[1] == 116 && v11[2] == 116 && v11[3] == 112)
  {
    if (v32)
    {
      v41 = CFURLGetByteRangeForComponent(CanonicalURL, kCFURLComponentHost, 0);
      length = v41.length;
      v43 = (const char *)&v11[v41.location];
      v44 = malloc_type_malloc(v41.length + 1, 0x100004077774924uLL);
      if (v41.length >= 1)
      {
        v45 = &v11[v41.location];
        v46 = v44;
        v47 = v41.length;
        do
        {
          v48 = *v45++;
          *v46++ = v48;
          --v47;
        }
        while (v47);
      }
      v44[v41.length] = 0;
    }
    else
    {
      v44 = 0;
      v43 = "localhost";
      length = 9;
    }
    if (a3)
    {
      v58 = v44;
      if (v44)
        v52 = v44;
      else
        v52 = (char *)v43;
      if ((unint64_t)(length - 1) <= 0x37 && (inet_pton(2, v52, buf) == 1 || inet_pton(30, v52, buf) == 1)
        || !HSTSPolicy::isKnownHSTSHost(a3, (unsigned __int8 *)v52, length, v59))
      {
        v44 = v58;
      }
      else
      {
        memmove(&v11[v40.location + 5], &v11[v40.location + 4], v13 - 4);
        v11[v40.location + 4] = 115;
        v53 = CFURLGetByteRangeForComponent(CanonicalURL, kCFURLComponentPort, 0);
        v54 = 1;
        if (v53.location == -1)
        {
          v44 = v58;
        }
        else
        {
          v44 = v58;
          if (v53.length == 2)
          {
            if (v11[v53.location + 1] == 56 && v11[v53.location + 2] == 48)
            {
              memmove(&v11[v53.location + 4], &v11[v53.location + 3], v13 - v53.location - 2);
              v44 = v58;
              v11[v53.location + 1] = 52;
              v11[v53.location + 2] = 52;
              v11[v53.location + 3] = 51;
              v54 = 2;
            }
            else
            {
              v54 = 1;
            }
          }
        }
        v13 += v54;
        v18 = 1;
      }
    }
    if (v44)
      free(v44);
  }
  if (v18)
  {
    v57 = _CFURLGetEncoding();
    CanonicalURL = CFURLCreateWithBytes(v8, v11, v13, v57, 0);
  }
  else
  {
    CFRetain(CanonicalURL);
  }
  if (v11 != buffer)
    CFAllocatorDeallocate(v8, v11);
  return CanonicalURL;
}

CFTypeRef ___ZN12HTTPProtocol30_createMutableCanonicalRequestEPK13__CFAllocatorPK13_CFURLRequestP16NSURLSessionTaskPKv_block_invoke_3()
{
  return CFRetain(CFSTR("gzip, deflate"));
}

CFTypeRef ___ZN12HTTPProtocol30_createMutableCanonicalRequestEPK13__CFAllocatorPK13_CFURLRequestP16NSURLSessionTaskPKv_block_invoke()
{
  return CFRetain(CFSTR("*/*"));
}

void HTTPConnectionCacheEntry::_findOrCreateEmptyConnection(_QWORD *a1, uint64_t a2, const __CFString *a3, int *a4)
{
  const __CFString *v4;
  uint64_t v7;
  AuthenticationState *v8;
  const __CFArray *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  uint64_t v24;
  const __CFString *v25;
  const __CFString *v26;
  _BOOL4 v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  BOOL canPipelineOnConnection;
  BOOL v37;
  unint64_t *v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  HTTPConnectionCacheEntry::EnqueuedRequest *info;
  unint64_t *v44;
  unint64_t v45;
  BOOL doesConnAuthApply;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  _BOOL4 v52;
  BOOL v53;
  int *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  std::__shared_weak_count *v58;
  unint64_t *v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  AuthenticationState *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  __int128 v67;
  unint64_t *v68;
  unint64_t v69;
  AuthenticationState *v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  BOOL v74;
  BOOL v75;
  unint64_t *v76;
  unint64_t v77;
  int v78;
  std::__shared_weak_count *v79;
  unint64_t *v80;
  unint64_t v81;
  int v82;
  uint64_t v83;
  unint64_t *v84;
  unint64_t v85;
  unint64_t *v86;
  unint64_t v87;
  char *v88;
  char *v89;
  char *v90;
  unint64_t v91;
  unint64_t v92;
  char *v93;
  char *v94;
  char *v95;
  __int128 v96;
  char *v97;
  std::__shared_weak_count *v98;
  unint64_t *v99;
  unint64_t v100;
  std::__shared_weak_count *v101;
  unint64_t *v102;
  unint64_t v103;
  std::__shared_weak_count *v104;
  unint64_t *v105;
  unint64_t v106;
  uint64_t v107;
  int *isa;
  std::__shared_weak_count *v109;
  unint64_t *v110;
  unint64_t v111;
  uint64_t *v112;
  uint64_t v113;
  std::__shared_weak_count *v114;
  unint64_t *v115;
  unint64_t v116;
  unint64_t *v117;
  unint64_t v118;
  char *v119;
  char *v120;
  char *v121;
  BOOL v123;
  unint64_t *v124;
  unint64_t v125;
  unint64_t *v126;
  unint64_t v127;
  unint64_t *v128;
  unint64_t v129;
  int v130;
  BOOL isConnectionBased;
  char *v132;
  BOOL v133;
  unint64_t v134;
  uint64_t v135;
  char *v136;
  uint64_t v137;
  std::__shared_weak_count *v138;
  unint64_t *v139;
  unint64_t v140;
  int v141;
  uint64_t v142;
  unint64_t v143;
  uint64_t v144;
  BOOL v145;
  uint64_t *v148;
  unint64_t *v149;
  unint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  int *v154;
  uint64_t v155;
  std::__shared_weak_count *v156;
  unint64_t *v157;
  unint64_t v158;
  std::__shared_weak_count *v159;
  unint64_t *v160;
  unint64_t v161;
  int v162;
  BaseAwaitingTube *v164;
  uint64_t v165;
  std::__shared_weak_count *v166;
  unint64_t *p_shared_weak_owners;
  unint64_t v168;
  CFArrayRef *v169;
  uint64_t v170;
  unint64_t *v171;
  unint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  CFDictionaryRef v176;
  const void *v177;
  const __CFAllocator *v178;
  _OWORD *v179;
  _BYTE *v180;
  CFArrayRef v181;
  unint64_t *v182;
  unint64_t v183;
  std::__shared_weak_count *v184;
  unint64_t *v185;
  unint64_t v186;
  uint64_t v187;
  uint64_t v188;
  _BOOL4 v189;
  uint64_t v190;
  std::__shared_weak_count *v191;
  HTTPConnectionCacheEntry::RequestQueue *v192;
  unint64_t *v193;
  unint64_t v194;
  uint64_t v195;
  unint64_t *v196;
  unint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  BaseAwaitingTube **v201;
  BaseAwaitingTube *v202;
  std::__shared_weak_count *v203;
  unint64_t *v204;
  unint64_t v205;
  unint64_t *v206;
  unint64_t v207;
  uint64_t v208;
  AuthenticationState *v209;
  uint64_t v210;
  __int128 v211;
  std::__shared_weak_count *v212;
  unint64_t *v213;
  unint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  __int128 v219;
  std::__shared_weak_count *v220;
  unint64_t *v221;
  unint64_t v222;
  uint64_t v223;
  uint64_t v224;
  _BOOL4 isEquivalent;
  std::__shared_weak_count *v226;
  unint64_t *v227;
  unint64_t v228;
  unint64_t *v229;
  unint64_t v230;
  unint64_t *v231;
  unint64_t v232;
  std::__shared_weak_count *v233;
  unint64_t *v234;
  unint64_t v235;
  std::__shared_weak_count *v236;
  unint64_t *v237;
  unint64_t v238;
  uint64_t i;
  char *v240;
  const char *v241;
  int v242;
  std::__shared_weak_count *v243;
  uint64_t v244;
  uint64_t v245;
  _QWORD *v246;
  char v247;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  char v252;
  int v253;
  CFStringRef theString2;
  std::__shared_weak_count *theString2a;
  _QWORD v256[2];
  void (*v257)(_QWORD *, _BYTE *);
  void *v258;
  uint64_t v259;
  uint64_t v260;
  std::__shared_weak_count *v261;
  AuthenticationState *v262;
  std::__shared_weak_count *v263;
  char v264;
  __int128 v265;
  HTTPConnectionCacheEntry::EnqueuedRequest *v266[2];
  __int128 v267;
  HTTPConnection *v268[2];
  _QWORD v269[2];
  AuthenticationState *v270;
  std::__shared_weak_count *v271;
  __int128 context;
  uint64_t v273;
  void *v274;
  CFArrayRef *v275;
  AuthenticationState *v276;
  char *v277;
  char *v278;
  unint64_t v279;
  uint64_t v280;
  AuthenticationState *v281;
  std::__shared_weak_count *v282;
  __int128 v283;
  CFRange v284;

  v4 = a3;
  v7 = (*(uint64_t (**)(void *))(*(_QWORD *)a3->isa + 80))(a3->isa);
  (*(void (**)(AuthenticationState **__return_ptr))(*(_QWORD *)v7 + 88))(&v270);
  *a1 = 0;
  a1[1] = 0;
  v246 = a1;
  v8 = v270;
  v277 = 0;
  v278 = (char *)&v277;
  v279 = 0x2020000000;
  v280 = 0;
  *(_QWORD *)&context = MEMORY[0x1E0C809B0];
  *((_QWORD *)&context + 1) = 3221225472;
  v273 = (uint64_t)___ZNK24HTTPConnectionCacheEntry36_countPendingTubesWithAuthenticationEP19AuthenticationState_block_invoke;
  v274 = &unk_1E14FD7F0;
  v275 = (CFArrayRef *)&v277;
  v276 = v270;
  v9 = *(const __CFArray **)(a2 + 80);
  v284.length = CFArrayGetCount(v9);
  v284.location = 0;
  CFArrayApplyFunction(v9, v284, (CFArrayApplierFunction)RetainableTypedArray<Tube *>::_invoke, &context);
  if (AuthenticationState::isConnectionBased(v8))
  {
    v10 = *((_QWORD *)v278 + 3);
  }
  else
  {
    v10 = *((_QWORD *)v278 + 3) + *(_QWORD *)(a2 + 88);
    *((_QWORD *)v278 + 3) = v10;
  }
  _Block_object_dispose(&v277, 8);
  v11 = HTTPConnectionCacheEntry::ConnectionArray::countWithAuthentication(*(HTTPConnectionCacheEntry::ConnectionArray **)(a2 + 96), v270);
  v12 = v11 + v10;
  v278 = 0;
  v279 = 0;
  v277 = 0;
  v13 = *(_QWORD *)(*(_QWORD *)(a2 + 96) + 8);
  v14 = *(_QWORD *)(*(_QWORD *)(a2 + 96) + 16);
  v251 = a2;
  if (v14 - v13 < 1)
  {
    v250 = v11 + v10;
    goto LABEL_193;
  }
  v15 = 0;
  v252 = 0;
  do
  {
    if (v15 < 0 || v15 >= (v14 - v13) >> 4)
    {
      v17 = 0;
      v18 = 0;
      v283 = 0uLL;
    }
    else
    {
      v16 = *(_OWORD *)(v13 + 16 * v15);
      v283 = v16;
      v17 = (std::__shared_weak_count *)*((_QWORD *)&v16 + 1);
      v18 = v16;
      if (*((_QWORD *)&v16 + 1))
      {
        v19 = (unint64_t *)(*((_QWORD *)&v16 + 1) + 8);
        do
          v20 = __ldxr(v19);
        while (__stxr(v20 + 1, v19));
      }
    }
    v21 = *(std::__shared_weak_count **)(v18 + 184);
    v281 = *(AuthenticationState **)(v18 + 176);
    v282 = v21;
    if (v21)
    {
      p_shared_owners = (unint64_t *)&v21->__shared_owners_;
      do
        v23 = __ldxr(p_shared_owners);
      while (__stxr(v23 + 1, p_shared_owners));
    }
    v24 = (*(uint64_t (**)(void *))(*(_QWORD *)v4->isa + 88))(v4->isa);
    v25 = *(const __CFString **)(v24 + 152);
    if (!v25)
    {
LABEL_22:
      v27 = 0;
      goto LABEL_23;
    }
    if (CFStringCompare(v25, (CFStringRef)&gConstantCFStringValueTable[2590], 0))
    {
      v26 = *(const __CFString **)(v24 + 152);
      if (!v26)
      {
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          goto LABEL_22;
        LOWORD(context) = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", (uint8_t *)&context, 2u);
        v26 = *(const __CFString **)(v24 + 152);
        if (!v26)
          goto LABEL_22;
      }
      v27 = CFStringCompare(v26, (CFStringRef)&gConstantCFStringValueTable[2597], 0) == kCFCompareEqualTo;
    }
    else
    {
      v27 = 1;
    }
LABEL_23:
    if (HTTPConnection::willEnqueueRequests((HTTPConnection *)v18, !v27) == 2)
    {
      v269[0] = v18;
      v269[1] = v17;
      if (v17)
      {
        v28 = (unint64_t *)&v17->__shared_owners_;
        do
          v29 = __ldxr(v28);
        while (__stxr(v29 + 1, v28));
      }
      HTTPConnectionCacheEntry::_removeConnection(a2, v269);
      if (v17)
      {
        v30 = (unint64_t *)&v17->__shared_owners_;
        do
          v31 = __ldaxr(v30);
        while (__stlxr(v31 - 1, v30));
        if (!v31)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      v12 = HTTPConnectionCacheEntry::ConnectionArray::countWithAuthentication(*(HTTPConnectionCacheEntry::ConnectionArray **)(a2 + 96), v270)+ v10;
      v252 = 1;
      goto LABEL_139;
    }
    *(_QWORD *)&context = 0;
    *((_QWORD *)&context + 1) = &context;
    v273 = 0x2020000000;
    v32 = (*(_QWORD *)(v18 + 128) - *(_QWORD *)(v18 + 120)) >> 4;
    LODWORD(v274) = v32;
    _Block_object_dispose(&context, 8);
    if ((int)v32 >= 1 && *((_DWORD *)v4->isa + 12) > *(_DWORD *)(v18 + 240))
      goto LABEL_138;
    *(_QWORD *)&context = 0;
    *((_QWORD *)&context + 1) = &context;
    v273 = 0x2020000000;
    v33 = (*(_QWORD *)(v18 + 128) - *(_QWORD *)(v18 + 120)) >> 4;
    LODWORD(v274) = v33;
    _Block_object_dispose(&context, 8);
    if ((int)v33 >= 1)
    {
      v268[0] = (HTTPConnection *)v18;
      v268[1] = (HTTPConnection *)v17;
      if (v17)
      {
        v34 = (unint64_t *)&v17->__shared_owners_;
        do
          v35 = __ldxr(v34);
        while (__stxr(v35 + 1, v34));
      }
      canPipelineOnConnection = HTTPConnectionCacheEntry::_canPipelineOnConnection(a2, v268);
      v37 = canPipelineOnConnection;
      if (!v17)
        goto LABEL_43;
      v38 = (unint64_t *)&v17->__shared_owners_;
      do
        v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
        if (!v37)
          goto LABEL_138;
      }
      else
      {
LABEL_43:
        if (!canPipelineOnConnection)
          goto LABEL_138;
      }
    }
    v40 = v283;
    v267 = v283;
    if (*((_QWORD *)&v283 + 1))
    {
      v41 = (unint64_t *)(*((_QWORD *)&v283 + 1) + 8);
      do
        v42 = __ldxr(v41);
      while (__stxr(v42 + 1, v41));
    }
    info = (HTTPConnectionCacheEntry::EnqueuedRequest *)v4->info;
    v266[0] = (HTTPConnectionCacheEntry::EnqueuedRequest *)v4->isa;
    v266[1] = info;
    if (info)
    {
      v44 = (unint64_t *)((char *)info + 8);
      do
        v45 = __ldxr(v44);
      while (__stxr(v45 + 1, v44));
    }
    doesConnAuthApply = HTTPConnectionCacheEntry::_doesConnAuthApply(*(_QWORD *)(v40 + 176), *(std::__shared_weak_count **)(v40 + 184), v266);
    if (info)
    {
      v47 = (unint64_t *)((char *)info + 8);
      do
        v48 = __ldaxr(v47);
      while (__stlxr(v48 - 1, v47));
      if (!v48)
      {
        (*(void (**)(HTTPConnectionCacheEntry::EnqueuedRequest *))(*(_QWORD *)info + 16))(info);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)info);
      }
    }
    v49 = (std::__shared_weak_count *)*((_QWORD *)&v267 + 1);
    if (!*((_QWORD *)&v267 + 1))
      goto LABEL_59;
    v50 = (unint64_t *)(*((_QWORD *)&v267 + 1) + 8);
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
      if (!doesConnAuthApply)
        goto LABEL_138;
    }
    else
    {
LABEL_59:
      if (!doesConnAuthApply)
        goto LABEL_138;
    }
    v52 = AuthenticationState::addsConnectionAuth(v281, v270);
    v53 = v52;
    v54 = *(int **)(a2 + 56);
    if (v52)
    {
      if (v12 < *v54)
        goto LABEL_112;
      goto LABEL_138;
    }
    if (*((_DWORD *)v4->isa + 12) >= v54[5])
      goto LABEL_112;
    v245 = v10;
    v55 = *v54;
    v56 = *(_QWORD *)(a2 + 96);
    v58 = (std::__shared_weak_count *)*((_QWORD *)&v283 + 1);
    v57 = v283;
    v265 = v283;
    if (*((_QWORD *)&v283 + 1))
    {
      v59 = (unint64_t *)(*((_QWORD *)&v283 + 1) + 8);
      do
        v60 = __ldxr(v59);
      while (__stxr(v60 + 1, v59));
    }
    if (!v57 || (v61 = *(_QWORD *)(v56 + 16) - *(_QWORD *)(v56 + 8), v61 < 1))
    {
      v83 = -1;
      goto LABEL_106;
    }
    v243 = v58;
    v244 = v55;
    v249 = v12;
    v62 = 0;
    v247 = 0;
    v63 = v270;
    v64 = (unint64_t)v61 >> 4;
    if (v64 <= 1)
      v65 = 1;
    else
      v65 = v64;
    v66 = -1;
    do
    {
      v67 = *(_OWORD *)(*(_QWORD *)(v56 + 8) + 16 * v62);
      context = v67;
      if (*((_QWORD *)&v67 + 1))
      {
        v68 = (unint64_t *)(*((_QWORD *)&v67 + 1) + 8);
        do
          v69 = __ldxr(v68);
        while (__stxr(v69 + 1, v68));
      }
      v70 = *(AuthenticationState **)(v67 + 176);
      v71 = *(std::__shared_weak_count **)(v67 + 184);
      v262 = v70;
      v263 = v71;
      if (v71)
      {
        v72 = (unint64_t *)&v71->__shared_owners_;
        do
          v73 = __ldxr(v72);
        while (__stxr(v73 + 1, v72));
      }
      v74 = AuthenticationState::addsConnectionAuth(v70, v63);
      v75 = v74;
      if (!v71)
        goto LABEL_83;
      v76 = (unint64_t *)&v71->__shared_owners_;
      do
        v77 = __ldaxr(v76);
      while (__stlxr(v77 - 1, v76));
      if (!v77)
      {
        ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
        std::__shared_weak_count::__release_weak(v71);
        if (v75)
        {
LABEL_87:
          v78 = 0;
          goto LABEL_88;
        }
      }
      else
      {
LABEL_83:
        if (v74)
          goto LABEL_87;
      }
      ++v66;
      if ((_QWORD)context != (_QWORD)v265)
        goto LABEL_87;
      v247 = 1;
      v78 = 1;
LABEL_88:
      v79 = (std::__shared_weak_count *)*((_QWORD *)&context + 1);
      if (*((_QWORD *)&context + 1))
      {
        v80 = (unint64_t *)(*((_QWORD *)&context + 1) + 8);
        do
          v81 = __ldaxr(v80);
        while (__stlxr(v81 - 1, v80));
        if (!v81)
        {
          ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
          std::__shared_weak_count::__release_weak(v79);
        }
      }
      if (++v62 == v65)
        v82 = 1;
      else
        v82 = v78;
    }
    while (v82 != 1);
    if ((v247 & 1) != 0)
      v83 = v66;
    else
      v83 = -1;
    v12 = v249;
    a2 = v251;
    v58 = v243;
    v55 = v244;
LABEL_106:
    v10 = v245;
    if (v58)
    {
      v84 = (unint64_t *)&v58->__shared_owners_;
      do
        v85 = __ldaxr(v84);
      while (__stlxr(v85 - 1, v84));
      if (!v85)
      {
        ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
        std::__shared_weak_count::__release_weak(v58);
      }
    }
    if (v55 - v83 > *(int *)(*(_QWORD *)(a2 + 56) + 16))
    {
LABEL_112:
      context = v283;
      if (*((_QWORD *)&v283 + 1))
      {
        v86 = (unint64_t *)(*((_QWORD *)&v283 + 1) + 8);
        do
          v87 = __ldxr(v86);
        while (__stxr(v87 + 1, v86));
      }
      LOBYTE(v273) = v53;
      v88 = v278;
      if ((unint64_t)v278 < v279)
      {
        *(_OWORD *)v278 = context;
        context = 0uLL;
        v88[16] = v53;
        v89 = v88 + 24;
        goto LABEL_137;
      }
      v90 = v277;
      v91 = 0xAAAAAAAAAAAAAAABLL * ((v278 - v277) >> 3) + 1;
      if (v91 > 0xAAAAAAAAAAAAAAALL)
        abort();
      if (0x5555555555555556 * ((uint64_t)(v279 - (_QWORD)v277) >> 3) > v91)
        v91 = 0x5555555555555556 * ((uint64_t)(v279 - (_QWORD)v277) >> 3);
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v279 - (_QWORD)v277) >> 3) >= 0x555555555555555)
        v92 = 0xAAAAAAAAAAAAAAALL;
      else
        v92 = v91;
      if (v92 > 0xAAAAAAAAAAAAAAALL)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v93 = (char *)operator new(24 * v92);
      v94 = &v93[8 * ((v88 - v90) >> 3)];
      *(_OWORD *)v94 = context;
      v95 = &v93[24 * v92];
      context = 0uLL;
      v94[16] = v53;
      v89 = v94 + 24;
      if (v88 == v90)
      {
        v277 = &v93[8 * ((v88 - v90) >> 3)];
        v278 = v94 + 24;
        v279 = (unint64_t)&v93[24 * v92];
        a2 = v251;
        if (v88)
          goto LABEL_131;
      }
      else
      {
        a2 = v251;
        do
        {
          v96 = *(_OWORD *)(v88 - 24);
          v88 -= 24;
          *(_OWORD *)(v94 - 24) = v96;
          v94 -= 24;
          *(_QWORD *)v88 = 0;
          *((_QWORD *)v88 + 1) = 0;
          v94[16] = v88[16];
        }
        while (v88 != v90);
        v97 = v277;
        v88 = v278;
        v277 = v94;
        v278 = v89;
        v279 = (unint64_t)v95;
        if (v88 != v97)
        {
          do
          {
            v88 -= 24;
            std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v88);
          }
          while (v88 != v97);
          v88 = v97;
        }
        if (v88)
        {
LABEL_131:
          operator delete(v88);
          v98 = (std::__shared_weak_count *)*((_QWORD *)&context + 1);
          v278 = v89;
          if (*((_QWORD *)&context + 1))
          {
            v99 = (unint64_t *)(*((_QWORD *)&context + 1) + 8);
            do
              v100 = __ldaxr(v99);
            while (__stlxr(v100 - 1, v99));
            if (!v100)
            {
              ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
              std::__shared_weak_count::__release_weak(v98);
            }
          }
          goto LABEL_138;
        }
      }
LABEL_137:
      v278 = v89;
    }
LABEL_138:
    ++v15;
LABEL_139:
    v101 = v282;
    if (v282)
    {
      v102 = (unint64_t *)&v282->__shared_owners_;
      do
        v103 = __ldaxr(v102);
      while (__stlxr(v103 - 1, v102));
      if (!v103)
      {
        ((void (*)(std::__shared_weak_count *))v101->__on_zero_shared)(v101);
        std::__shared_weak_count::__release_weak(v101);
      }
    }
    v104 = (std::__shared_weak_count *)*((_QWORD *)&v283 + 1);
    if (*((_QWORD *)&v283 + 1))
    {
      v105 = (unint64_t *)(*((_QWORD *)&v283 + 1) + 8);
      do
        v106 = __ldaxr(v105);
      while (__stlxr(v106 - 1, v105));
      if (!v106)
      {
        ((void (*)(std::__shared_weak_count *))v104->__on_zero_shared)(v104);
        std::__shared_weak_count::__release_weak(v104);
      }
    }
    v13 = *(_QWORD *)(*(_QWORD *)(a2 + 96) + 8);
    v14 = *(_QWORD *)(*(_QWORD *)(a2 + 96) + 16);
  }
  while (v15 < (v14 - v13) >> 4);
  v250 = v12;
  if ((v252 & 1) == 0)
    goto LABEL_193;
  v107 = *(_QWORD *)(a2 + 104);
  isa = (int *)v4->isa;
  v109 = (std::__shared_weak_count *)v4->info;
  if (v109)
  {
    v110 = (unint64_t *)&v109->__shared_owners_;
    do
      v111 = __ldxr(v110);
    while (__stxr(v111 + 1, v110));
  }
  if (isa)
  {
    v112 = (uint64_t *)(*(_QWORD *)(v107 + 8) + 16 * isa[12]);
    v113 = *v112;
    v114 = (std::__shared_weak_count *)v112[1];
    if (v114)
    {
      v115 = (unint64_t *)&v114->__shared_owners_;
      do
        v116 = __ldxr(v115);
      while (__stxr(v116 + 1, v115));
    }
    if (v113)
    {
      if (v109)
      {
        v117 = (unint64_t *)&v109->__shared_owners_;
        do
          v118 = __ldxr(v117);
        while (__stxr(v118 + 1, v117));
      }
      v120 = *(char **)(v113 + 16);
      v119 = *(char **)(v113 + 24);
      v121 = v120;
      if (v120 != v119)
      {
        while (*(int **)v121 != isa)
        {
          v121 += 16;
          if (v121 == v119)
          {
            v121 = v119;
            break;
          }
        }
      }
      v123 = v121 - v120 != -16 && v121 != v119;
      if (v109)
      {
        v124 = (unint64_t *)&v109->__shared_owners_;
        do
          v125 = __ldaxr(v124);
        while (__stlxr(v125 - 1, v124));
        if (!v125)
        {
          ((void (*)(std::__shared_weak_count *))v109->__on_zero_shared)(v109);
          std::__shared_weak_count::__release_weak(v109);
        }
      }
    }
    else
    {
      v123 = 0;
    }
    if (v114)
    {
      v126 = (unint64_t *)&v114->__shared_owners_;
      do
        v127 = __ldaxr(v126);
      while (__stlxr(v127 - 1, v126));
      if (!v127)
      {
        ((void (*)(std::__shared_weak_count *))v114->__on_zero_shared)(v114);
        std::__shared_weak_count::__release_weak(v114);
      }
    }
  }
  else
  {
    v123 = 0;
  }
  if (!v109)
    goto LABEL_192;
  v128 = (unint64_t *)&v109->__shared_owners_;
  do
    v129 = __ldaxr(v128);
  while (__stlxr(v129 - 1, v128));
  if (!v129)
  {
    ((void (*)(std::__shared_weak_count *))v109->__on_zero_shared)(v109);
    std::__shared_weak_count::__release_weak(v109);
    if (!v123)
      goto LABEL_372;
LABEL_193:
    v130 = 0;
  }
  else
  {
LABEL_192:
    if (v123)
      goto LABEL_193;
LABEL_372:
    v240 = v277;
    for (i = (uint64_t)v278; (char *)i != v240; i = std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](i - 24))
      ;
    v278 = v240;
    v130 = 1;
  }
  isConnectionBased = AuthenticationState::isConnectionBased(v270);
  v262 = 0;
  v263 = 0;
  v264 = 0;
  v132 = v277;
  if (v278 == v277)
  {
LABEL_235:
    if ((v130 & 1) == 0)
      goto LABEL_242;
    goto LABEL_236;
  }
  v133 = isConnectionBased;
  v253 = v130;
  theString2 = v4;
  v134 = 0;
  v135 = -1;
  while (2)
  {
    v136 = &v132[24 * v134];
    v137 = *(_QWORD *)v136;
    v138 = (std::__shared_weak_count *)*((_QWORD *)v136 + 1);
    if (v138)
    {
      v139 = (unint64_t *)&v138->__shared_owners_;
      do
        v140 = __ldxr(v139);
      while (__stxr(v140 + 1, v139));
    }
    v141 = v132[24 * v134 + 16];
    *(_QWORD *)&context = 0;
    *((_QWORD *)&context + 1) = &context;
    v273 = 0x2020000000;
    v142 = *(_QWORD *)(v137 + 128) - *(_QWORD *)(v137 + 120);
    v143 = (unint64_t)v142 >> 4;
    LODWORD(v274) = (unint64_t)v142 >> 4;
    _Block_object_dispose(&context, 8);
    v144 = (int)(v142 >> 4);
    if (!v262)
      goto LABEL_218;
    if (!v133)
    {
      if (v135 > v144)
        goto LABEL_218;
      goto LABEL_219;
    }
    if (v135 <= v144)
    {
      if (v135)
        goto LABEL_219;
      if (v141 || v264 == 0)
        goto LABEL_219;
LABEL_218:
      v148 = (uint64_t *)&v277[24 * v134];
      std::shared_ptr<__CFString const>::operator=[abi:nn180100](&v262, *v148, v148[1]);
      v264 = *((_BYTE *)v148 + 16);
      v135 = v144;
      goto LABEL_219;
    }
    if (v141)
      v145 = (_DWORD)v143 == 0;
    else
      v145 = 1;
    if (v145 || v264 != 0)
      goto LABEL_218;
LABEL_219:
    if (v138)
    {
      v149 = (unint64_t *)&v138->__shared_owners_;
      do
        v150 = __ldaxr(v149);
      while (__stlxr(v150 - 1, v149));
      if (!v150)
      {
        ((void (*)(std::__shared_weak_count *))v138->__on_zero_shared)(v138);
        std::__shared_weak_count::__release_weak(v138);
      }
    }
    ++v134;
    v132 = v277;
    if (v134 < 0xAAAAAAAAAAAAAAABLL * ((v278 - v277) >> 3))
      continue;
    break;
  }
  v151 = (uint64_t)v262;
  v4 = theString2;
  v130 = v253;
  if (!v262)
    goto LABEL_235;
  if (v135 < 1
    || (v152 = v250, v153 = v251, v154 = *(int **)(v251 + 56), v155 = *v154, v155 <= v250)
    || *((_DWORD *)theString2->isa + 12) < v154[5] && v155 - v250 <= v154[4])
  {
LABEL_248:
    std::shared_ptr<__CFString const>::operator=[abi:nn180100](v246, v151, (uint64_t)v263);
    v162 = 1;
    goto LABEL_360;
  }
  v156 = v263;
  v262 = 0;
  v263 = 0;
  if (v156)
  {
    v157 = (unint64_t *)&v156->__shared_owners_;
    do
      v158 = __ldaxr(v157);
    while (__stlxr(v158 - 1, v157));
    if (!v158)
    {
      ((void (*)(std::__shared_weak_count *))v156->__on_zero_shared)(v156);
      std::__shared_weak_count::__release_weak(v156);
    }
LABEL_242:
    v151 = (uint64_t)v262;
    v152 = v250;
    v153 = v251;
    v155 = **(int **)(v251 + 56);
  }
  else
  {
    v151 = 0;
  }
  if (v152 < v155 && v151 == 0)
  {
    if (((*(uint64_t (**)(void *, uint64_t))(*(_QWORD *)v4->isa + 128))(v4->isa, v151) & 1) == 0
      && (*(unsigned int (**)(void *))(*(_QWORD *)v4->isa + 112))(v4->isa))
    {
      v164 = (BaseAwaitingTube *)v4->isa;
      goto LABEL_252;
    }
    v208 = *(unsigned int *)(v153 + 120);
    if ((int)v208 < 1)
      goto LABEL_359;
    v209 = v270;
    while (1)
    {
      if ((_DWORD)v208 - 1 < 0
        || (v210 = *(_QWORD *)(*(_QWORD *)(v153 + 104) + 8),
            (v208 - 1) > (unint64_t)((*(_QWORD *)(*(_QWORD *)(v153 + 104) + 16) - v210) >> 4)))
      {
        v164 = 0;
        goto LABEL_312;
      }
      v211 = *(_OWORD *)(v210 + 16 * (v208 - 1));
      context = v211;
      v212 = (std::__shared_weak_count *)*((_QWORD *)&v211 + 1);
      if (*((_QWORD *)&v211 + 1))
      {
        v213 = (unint64_t *)(*((_QWORD *)&v211 + 1) + 8);
        do
          v214 = __ldxr(v213);
        while (__stxr(v214 + 1, v213));
      }
      if (!(_QWORD)v211 || (v215 = *(_QWORD *)(v211 + 24) - *(_QWORD *)(v211 + 16), v215 < 1))
      {
        v164 = 0;
        if (*((_QWORD *)&v211 + 1))
          goto LABEL_349;
        goto LABEL_312;
      }
      v216 = 0;
      v217 = v215 >> 4;
      do
      {
        v218 = *(_QWORD *)(context + 16);
        if (v216 >= (*(_QWORD *)(context + 24) - v218) >> 4)
        {
          v164 = 0;
          goto LABEL_344;
        }
        v219 = *(_OWORD *)(v218 + 16 * v216);
        v283 = v219;
        v220 = (std::__shared_weak_count *)*((_QWORD *)&v219 + 1);
        if (*((_QWORD *)&v219 + 1))
        {
          v221 = (unint64_t *)(*((_QWORD *)&v219 + 1) + 8);
          do
            v222 = __ldxr(v221);
          while (__stxr(v222 + 1, v221));
        }
        v223 = v219;
        if (!(_QWORD)v219
          || ((*(uint64_t (**)(_QWORD))(*(_QWORD *)v219 + 128))(v219) & 1) != 0
          || !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v223 + 112))(v223))
        {
          v164 = 0;
          if (!v220)
            goto LABEL_344;
LABEL_340:
          v229 = (unint64_t *)&v220->__shared_owners_;
          do
            v230 = __ldaxr(v229);
          while (__stlxr(v230 - 1, v229));
          if (!v230)
          {
            ((void (*)(std::__shared_weak_count *))v220->__on_zero_shared)(v220);
            std::__shared_weak_count::__release_weak(v220);
          }
          goto LABEL_344;
        }
        v224 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v223 + 80))(v223);
        (*(void (**)(AuthenticationState **__return_ptr))(*(_QWORD *)v224 + 88))(&v281);
        isEquivalent = AuthenticationState::isEquivalent(v281, v209);
        v226 = v282;
        if (v282)
        {
          v227 = (unint64_t *)&v282->__shared_owners_;
          do
            v228 = __ldaxr(v227);
          while (__stlxr(v228 - 1, v227));
          if (!v228)
          {
            ((void (*)(std::__shared_weak_count *))v226->__on_zero_shared)(v226);
            std::__shared_weak_count::__release_weak(v226);
          }
        }
        v220 = (std::__shared_weak_count *)*((_QWORD *)&v283 + 1);
        if (isEquivalent)
          v164 = (BaseAwaitingTube *)v283;
        else
          v164 = 0;
        if (*((_QWORD *)&v283 + 1))
          goto LABEL_340;
LABEL_344:
        ++v216;
      }
      while (v216 < v217 && !v164);
      v212 = (std::__shared_weak_count *)*((_QWORD *)&context + 1);
      if (!*((_QWORD *)&context + 1))
        goto LABEL_312;
LABEL_349:
      v231 = (unint64_t *)&v212->__shared_owners_;
      do
        v232 = __ldaxr(v231);
      while (__stlxr(v232 - 1, v231));
      if (!v232)
      {
        ((void (*)(std::__shared_weak_count *))v212->__on_zero_shared)(v212);
        std::__shared_weak_count::__release_weak(v212);
      }
LABEL_312:
      if (v208 >= 2)
      {
        --v208;
        if (!v164)
          continue;
      }
LABEL_252:
      if (!v164)
        goto LABEL_359;
      v165 = *(_QWORD *)(v153 + 40);
      v166 = *(std::__shared_weak_count **)(v153 + 48);
      if (v166)
      {
        p_shared_weak_owners = (unint64_t *)&v166->__shared_weak_owners_;
        do
          v168 = __ldxr(p_shared_weak_owners);
        while (__stxr(v168 + 1, p_shared_weak_owners));
      }
      v169 = *(CFArrayRef **)(v153 + 72);
      v170 = MEMORY[0x1E0C809B0];
      v256[0] = MEMORY[0x1E0C809B0];
      v256[1] = 3321888768;
      v257 = (void (*)(_QWORD *, _BYTE *))___ZN24HTTPConnectionCacheEntry28_findOrCreateEmptyConnectionENSt3__110shared_ptrINS_15EnqueuedRequestEEEPNS_22ConnectionSearchStatusE_block_invoke;
      v258 = &__block_descriptor_56_e8_40c49_ZTSNSt3__18weak_ptrI24HTTPConnectionCacheEntryEE_e9_v16__0_v8l;
      v259 = v153;
      v260 = v165;
      v261 = v166;
      if (v166)
      {
        v171 = (unint64_t *)&v166->__shared_weak_owners_;
        do
          v172 = __ldxr(v171);
        while (__stxr(v172 + 1, v171));
      }
      v173 = (*(uint64_t (**)(BaseAwaitingTube *))(*(_QWORD *)v164 + 80))(v164);
      if (v173)
      {
        v174 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v173 + 32))(v173);
        v175 = v174;
        if (v174)
        {
          v176 = CFDictionaryCreate(*(CFAllocatorRef *)(v174 + 8), 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          v177 = *(const void **)(v175 + 128);
          *(_QWORD *)(v175 + 128) = v176;
          if (v177)
            CFRelease(v177);
          (*((void (**)(CFArrayRef *))*v169 + 5))(v169);
          v178 = v169[1];
          *(_QWORD *)&context = v170;
          *((_QWORD *)&context + 1) = 3221225472;
          v273 = (uint64_t)___ZN11TubeManager14requestNewTubeEP16BaseAwaitingTubeU13block_pointerFvP4TubeE_block_invoke;
          v274 = &__block_descriptor_40_e17_v32__0_v8___qi_16l;
          v275 = v169;
          v179 = Tube::createNewTube(v178, (CFStringRef *)v175, &context);
          v180 = v179;
          v181 = v169[22];
          *(_QWORD *)&v283 = v169[21];
          *((_QWORD *)&v283 + 1) = v181;
          if (v181)
          {
            v182 = (unint64_t *)((char *)v181 + 8);
            do
              v183 = __ldxr(v182);
            while (__stxr(v183 + 1, v182));
          }
          (*(void (**)(_OWORD *, __int128 *))(*(_QWORD *)v179 + 88))(v179, &v283);
          v184 = (std::__shared_weak_count *)*((_QWORD *)&v283 + 1);
          if (*((_QWORD *)&v283 + 1))
          {
            v185 = (unint64_t *)(*((_QWORD *)&v283 + 1) + 8);
            do
              v186 = __ldaxr(v185);
            while (__stlxr(v186 - 1, v185));
            if (!v186)
            {
              ((void (*)(std::__shared_weak_count *))v184->__on_zero_shared)(v184);
              std::__shared_weak_count::__release_weak(v184);
            }
          }
          v180[216] = 1;
          v257(v256, v180);
          (*(void (**)(BaseAwaitingTube *, _BYTE *))(*(_QWORD *)v164 + 56))(v164, v180);
          Tube::initialize((uint64_t)v180, (uint64_t)v164, 0);
          CFArrayAppendValue(v169[18], v180);
          TubeManager::_onqueue_rdar53306264_addWaiter(v169, v164, 1);
          (*(void (**)(_BYTE *))(*(_QWORD *)v180 + 48))(v180);
          theString2a = v166;
          v187 = *(unsigned int *)(v153 + 120);
          if ((int)v187 < 1)
          {
LABEL_353:
            if (v261)
              std::__shared_weak_count::__release_weak(v261);
            if (theString2a)
              std::__shared_weak_count::__release_weak(theString2a);
            v162 = 2;
            goto LABEL_360;
          }
          while (2)
          {
            if ((_DWORD)v187 - 1 < 0
              || (v188 = *(_QWORD *)(*(_QWORD *)(v251 + 104) + 8),
                  (v187 - 1) > (unint64_t)((*(_QWORD *)(*(_QWORD *)(v251 + 104) + 16) - v188) >> 4)))
            {
              v189 = 0;
              goto LABEL_275;
            }
            v190 = v188 + 16 * (v187 - 1);
            v192 = *(HTTPConnectionCacheEntry::RequestQueue **)v190;
            v191 = *(std::__shared_weak_count **)(v190 + 8);
            if (v191)
            {
              v193 = (unint64_t *)&v191->__shared_owners_;
              do
                v194 = __ldxr(v193);
              while (__stxr(v194 + 1, v193));
            }
            if (!v192 || (v195 = *((_QWORD *)v192 + 3) - *((_QWORD *)v192 + 2), v195 < 16))
            {
              v189 = 0;
LABEL_284:
              if (v191)
              {
                v196 = (unint64_t *)&v191->__shared_owners_;
                do
                  v197 = __ldaxr(v196);
                while (__stlxr(v197 - 1, v196));
                if (!v197)
                {
                  ((void (*)(std::__shared_weak_count *))v191->__on_zero_shared)(v191);
                  std::__shared_weak_count::__release_weak(v191);
                }
              }
LABEL_275:
              if (v187 < 2)
                goto LABEL_353;
              --v187;
              if (v189)
                goto LABEL_353;
              continue;
            }
            break;
          }
          v198 = 0;
          v199 = v195 >> 4;
          while (2)
          {
            v200 = *((_QWORD *)v192 + 2);
            if (v198 >= (*((_QWORD *)v192 + 3) - v200) >> 4)
            {
              v202 = 0;
              v203 = 0;
            }
            else
            {
              v201 = (BaseAwaitingTube **)(v200 + 16 * v198);
              v202 = *v201;
              v203 = (std::__shared_weak_count *)v201[1];
              if (v203)
              {
                v204 = (unint64_t *)&v203->__shared_owners_;
                do
                  v205 = __ldxr(v204);
                while (__stxr(v205 + 1, v204));
              }
            }
            v189 = v202 == v164;
            if (v202 == v164)
            {
              HTTPConnectionCacheEntry::RequestQueue::removeRequest(v192, v198);
              if (v203)
                goto LABEL_300;
            }
            else
            {
              if (!v203)
                goto LABEL_304;
LABEL_300:
              v206 = (unint64_t *)&v203->__shared_owners_;
              do
                v207 = __ldaxr(v206);
              while (__stlxr(v207 - 1, v206));
              if (!v207)
              {
                ((void (*)(std::__shared_weak_count *))v203->__on_zero_shared)(v203);
                std::__shared_weak_count::__release_weak(v203);
              }
            }
LABEL_304:
            if (++v198 >= v199 || v202 == v164)
              goto LABEL_284;
            continue;
          }
        }
        v241 = "key";
        v242 = 216;
      }
      else
      {
        v241 = "client";
        v242 = 214;
      }
      __assert_rtn("requestNewTube", "TubeManager.cpp", v242, v241);
    }
  }
  if (v151)
    goto LABEL_248;
  if (!v130)
  {
LABEL_359:
    v162 = 0;
    goto LABEL_360;
  }
LABEL_236:
  context = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v246, &context);
  v159 = (std::__shared_weak_count *)*((_QWORD *)&context + 1);
  if (*((_QWORD *)&context + 1))
  {
    v160 = (unint64_t *)(*((_QWORD *)&context + 1) + 8);
    do
      v161 = __ldaxr(v160);
    while (__stlxr(v161 - 1, v160));
    if (!v161)
    {
      ((void (*)(std::__shared_weak_count *))v159->__on_zero_shared)(v159);
      std::__shared_weak_count::__release_weak(v159);
    }
  }
  v162 = 3;
LABEL_360:
  *a4 = v162;
  v233 = v263;
  if (v263)
  {
    v234 = (unint64_t *)&v263->__shared_owners_;
    do
      v235 = __ldaxr(v234);
    while (__stlxr(v235 - 1, v234));
    if (!v235)
    {
      ((void (*)(std::__shared_weak_count *))v233->__on_zero_shared)(v233);
      std::__shared_weak_count::__release_weak(v233);
    }
  }
  *(_QWORD *)&context = &v277;
  std::vector<std::pair<std::shared_ptr<HTTPConnection>,BOOL>>::__destroy_vector::operator()[abi:nn180100]((void ***)&context);
  v236 = v271;
  if (v271)
  {
    v237 = (unint64_t *)&v271->__shared_owners_;
    do
      v238 = __ldaxr(v237);
    while (__stlxr(v238 - 1, v237));
    if (!v238)
    {
      ((void (*)(std::__shared_weak_count *))v236->__on_zero_shared)(v236);
      std::__shared_weak_count::__release_weak(v236);
    }
  }
}

void sub_183EDD0C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,char a33,uint64_t a34,char a35,uint64_t a36,char a37,uint64_t a38,char a39)
{
  std::__shared_weak_count *v39;
  uint64_t v40;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v40 - 128);
  if (a26)
    std::__shared_weak_count::__release_weak(a26);
  if (v39)
    std::__shared_weak_count::__release_weak(v39);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a27);
  a27 = v40 - 176;
  std::vector<std::pair<std::shared_ptr<HTTPConnection>,BOOL>>::__destroy_vector::operator()[abi:nn180100]((void ***)&a27);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a12);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v40 - 240);
  _Unwind_Resume(a1);
}

uint64_t HTTPConnectionCacheEntry::EnqueuedRequest::getRequest(HTTPConnectionCacheEntry::EnqueuedRequest *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 5);
  if (!v1)
    return *((_QWORD *)this + 4);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (*(_BYTE *)(v1 + 40))
    return 0;
  else
    return v1 + 16;
}

uint64_t HTTPConnection::willEnqueueRequests(HTTPConnection *this, int a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  int v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v7 = 0;
  v2 = HTTPConnection::_onqueue_willEnqueueRequests(this, 0, a2);
  *((_DWORD *)v5 + 6) = v2;
  _Block_object_dispose(&v4, 8);
  return v2;
}

void sub_183EDD2AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t HTTPConnection::_onqueue_willEnqueueRequests(HTTPConnection *this, int a2, int a3)
{
  HTTPEngine *v5;
  CFTypeRef v6;
  const void *v7;
  CFTypeID v8;
  uint8_t v10[16];
  CFStreamError v11;

  if ((*((_WORD *)this + 16) & 0x101) == 1
    && (*((_QWORD *)this + 15) != *((_QWORD *)this + 16)
     || CFAbsoluteTimeGetCurrent() - *((double *)this + 26) < (double)(*((_DWORD *)this + 56) - a3)))
  {
    v5 = (HTTPEngine *)*((_QWORD *)this + 8);
    if (!v5)
      return (a2 ^ 1) & (*((unsigned __int16 *)this + 16) >> 1);
    v6 = HTTPEngine::copyProperty(v5, CFSTR("__kCFStreamPropertyDoNotReuse"));
    if (!v6)
      return (a2 ^ 1) & (*((unsigned __int16 *)this + 16) >> 1);
    v7 = v6;
    v8 = CFGetTypeID(v6);
    if (v8 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v10 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v10, 2u);
    }
    if ((const void *)*MEMORY[0x1E0C9AE50] != v7)
    {
      CFRelease(v7);
      return (a2 ^ 1) & (*((unsigned __int16 *)this + 16) >> 1);
    }
    v11.domain = 4;
    *(_QWORD *)&v11.error = 4294967292;
    HTTPConnection::_onqueue_doNotAllowMoreRequests(this, v11, 0);
    CFRelease(v7);
  }
  return 2;
}

void AuthenticationCache::processRequest(_QWORD *a1, uint64_t a2, HTTPRequestMessage *a3)
{
  uint64_t *v5;
  uint64_t *v6;
  std::__shared_weak_count *v8;
  AuthenticationState *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _BOOL4 canApplyHeadersToRequest;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t *v15;
  unint64_t *v16;
  unint64_t v17;
  BOOL isEquivalent;
  AuthenticationState *v19;
  _BOOL4 v20;
  AuthenticationState *v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  __int128 *v27;
  __int128 *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  _OWORD *v35;
  unint64_t *v36;
  unint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  unint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  __int128 v54;
  AuthenticationState *v55;
  std::__shared_weak_count *v56;
  AuthenticationState *v57;
  std::__shared_weak_count *v58;
  AuthenticationState *v59;
  __int128 v60;
  __int128 v61;
  __int128 *v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  v57 = 0;
  v58 = 0;
  v5 = a1 + 1;
  v6 = (uint64_t *)a1[2];
  if (v6 != a1 + 1)
  {
    while (1)
    {
      v9 = (AuthenticationState *)v6[2];
      v8 = (std::__shared_weak_count *)v6[3];
      *(_QWORD *)&v61 = v9;
      *((_QWORD *)&v61 + 1) = v8;
      if (v8)
      {
        p_shared_owners = (unint64_t *)&v8->__shared_owners_;
        do
          v11 = __ldxr(p_shared_owners);
        while (__stxr(v11 + 1, p_shared_owners));
      }
      if (AuthenticationState::isValid((uint64_t)v9, 0))
        break;
      v14 = *v6;
      v15 = (uint64_t *)v6[1];
      *(_QWORD *)(v14 + 8) = v15;
      *(_QWORD *)v6[1] = v14;
      --a1[3];
      std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v6 + 2));
      operator delete(v6);
      v8 = (std::__shared_weak_count *)*((_QWORD *)&v61 + 1);
      v6 = v15;
      if (*((_QWORD *)&v61 + 1))
        goto LABEL_14;
LABEL_18:
      if (v6 == v5)
        goto LABEL_19;
    }
    canApplyHeadersToRequest = AuthenticationState::canApplyHeadersToRequest(v9, a3);
    if (v57)
      v13 = 0;
    else
      v13 = canApplyHeadersToRequest;
    if (v13)
      std::shared_ptr<__CFString const>::operator=[abi:nn180100](&v57, (uint64_t)v9, (uint64_t)v8);
    v6 = (uint64_t *)v6[1];
    if (!v8)
      goto LABEL_18;
LABEL_14:
    v16 = (unint64_t *)&v8->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    goto LABEL_18;
  }
LABEL_19:
  (*(void (**)(AuthenticationState **__return_ptr, uint64_t))(*(_QWORD *)a2 + 88))(&v55, a2);
  if (!v55)
    __assert_rtn("processRequest", "AuthenticationCache.cpp", 104, "existing");
  AuthenticationState::resetInvalid(v55);
  if (v57)
  {
    isEquivalent = AuthenticationState::isEquivalent(v57, v55);
    v19 = v57;
    if (isEquivalent)
    {
      v20 = 0;
      if (!v57)
        goto LABEL_26;
    }
    else
    {
      v20 = AuthenticationState::incorporate(v55, v57);
      v19 = v57;
      if (!v57)
        goto LABEL_26;
    }
    if (!v20)
      goto LABEL_62;
  }
LABEL_26:
  v21 = v55;
  if (v55)
    pthread_mutex_lock((pthread_mutex_t *)((char *)v55 + 8));
  v54 = 0uLL;
  if (*((_QWORD *)v21 + 13) || *((_QWORD *)v21 + 16))
  {
    _ZNSt3__115allocate_sharedB8nn180100I19AuthenticationStateNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((std::__shared_weak_count_vtbl **)&v61);
    v22 = v61;
    v61 = 0uLL;
    v54 = v22;
    v24 = *((_QWORD *)&v22 + 1);
    v23 = v22;
    v59 = v21;
    v60 = v22;
    if (*((_QWORD *)&v22 + 1))
    {
      v25 = (unint64_t *)(*((_QWORD *)&v22 + 1) + 8);
      do
        v26 = __ldxr(v25);
      while (__stxr(v26 + 1, v25));
    }
  }
  else
  {
    v23 = 0;
    v24 = 0;
    v60 = 0uLL;
    v59 = v21;
  }
  v62 = 0;
  v27 = (__int128 *)operator new(0x20uLL);
  *(_QWORD *)v27 = &off_1E14F02D0;
  *((_QWORD *)v27 + 1) = v21;
  *((_QWORD *)v27 + 2) = v23;
  *((_QWORD *)v27 + 3) = v24;
  v60 = 0uLL;
  v62 = v27;
  AuthenticationState::_foreachAuthenticationInfo((uint64_t)v21, (uint64_t)&v61);
  v28 = v62;
  if (v62 == &v61)
  {
    v29 = 4;
    v28 = &v61;
    goto LABEL_39;
  }
  if (v62)
  {
    v29 = 5;
LABEL_39:
    (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
  }
  if ((_QWORD)v54)
  {
    if (*(_QWORD *)(v54 + 104) || *(_QWORD *)(v54 + 128))
    {
      v30 = *((_QWORD *)v21 + 18);
      v31 = operator new();
      *(_QWORD *)v31 = &off_1E14EDAF8;
      *(_BYTE *)(v31 + 8) = *(_BYTE *)(v30 + 8);
      *(_DWORD *)(v31 + 12) = *(_DWORD *)(v30 + 12);
      v32 = *(_QWORD *)(v54 + 144);
      *(_QWORD *)(v54 + 144) = v31;
      if (v32)
        (*(void (**)(uint64_t))(*(_QWORD *)v32 + 8))(v32);
    }
    else
    {
      v51 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
      v54 = 0uLL;
      if (v51)
      {
        v52 = (unint64_t *)&v51->__shared_owners_;
        do
          v53 = __ldaxr(v52);
        while (__stlxr(v53 - 1, v52));
        if (!v53)
        {
          ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
          std::__shared_weak_count::__release_weak(v51);
        }
      }
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)v21 + 8));
  if ((_QWORD)v54)
  {
    if (*((_QWORD *)&v54 + 1))
    {
      v33 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
      do
        v34 = __ldxr(v33);
      while (__stxr(v34 + 1, v33));
    }
    v35 = operator new(0x20uLL);
    v35[1] = v54;
    if (*((_QWORD *)&v54 + 1))
    {
      v36 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
      do
        v37 = __ldxr(v36);
      while (__stxr(v37 + 1, v36));
      v38 = (_QWORD *)a1[2];
      *(_QWORD *)v35 = v5;
      *((_QWORD *)v35 + 1) = v38;
      *v38 = v35;
      v39 = a1[3] + 1;
      a1[2] = v35;
      a1[3] = v39;
      do
        v40 = __ldaxr(v36);
      while (__stlxr(v40 - 1, v36));
      if (!v40)
      {
        (*(void (**)(_QWORD))(**((_QWORD **)&v54 + 1) + 16))(*((_QWORD *)&v54 + 1));
        std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v54 + 1));
      }
    }
    else
    {
      v41 = (_QWORD *)a1[2];
      *(_QWORD *)v35 = v5;
      *((_QWORD *)v35 + 1) = v41;
      *v41 = v35;
      v42 = a1[3] + 1;
      a1[2] = v35;
      a1[3] = v42;
    }
  }
  if (*((_QWORD *)&v54 + 1))
  {
    v43 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v54 + 1) + 16))(*((_QWORD *)&v54 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v54 + 1));
    }
  }
LABEL_62:
  v45 = v56;
  if (v56)
  {
    v46 = (unint64_t *)&v56->__shared_owners_;
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *, AuthenticationState *))v45->__on_zero_shared)(v45, v19);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  v48 = v58;
  if (v58)
  {
    v49 = (unint64_t *)&v58->__shared_owners_;
    do
      v50 = __ldaxr(v49);
    while (__stlxr(v50 - 1, v49));
    if (!v50)
    {
      ((void (*)(std::__shared_weak_count *, AuthenticationState *))v48->__on_zero_shared)(v48, v19);
      std::__shared_weak_count::__release_weak(v48);
    }
  }
}

void sub_183EDD93C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;
  uint64_t v11;
  va_list va2;

  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v9 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  _Unwind_Resume(a1);
}

BOOL AuthenticationState::isConnectionBased(AuthenticationState *this)
{
  _QWORD *v2;
  uint64_t v3;
  int v4;
  unsigned __int8 v6;
  _QWORD v7[3];
  _QWORD *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (this)
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  v6 = 0;
  v7[0] = &off_1E14F04C8;
  v7[1] = &v6;
  v8 = v7;
  AuthenticationState::_foreachAuthenticationInfo((uint64_t)this, (uint64_t)v7);
  v2 = v8;
  if (v8 == v7)
  {
    v3 = 4;
    v2 = v7;
  }
  else
  {
    if (!v8)
      goto LABEL_8;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_8:
  v4 = v6;
  if (this)
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
  return v4 != 0;
}

void sub_183EDDAB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == &a10)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  if (v13)
    pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8));
  _Unwind_Resume(exception_object);
}

BOOL AuthenticationState::addsConnectionAuth(AuthenticationState *this, AuthenticationState *a2)
{
  _BOOL8 v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  char v9;
  _BYTE v10[24];
  _BYTE *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (this)
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  v4 = 0;
  if (a2 && a2 != this)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)a2 + 8));
    v9 = 0;
    v5 = operator new(0x20uLL);
    *v5 = &off_1E14F0510;
    v5[1] = this;
    v5[2] = a2;
    v5[3] = &v9;
    v11 = v5;
    AuthenticationState::_foreachAuthenticationInfo((uint64_t)a2, (uint64_t)v10);
    v6 = v11;
    if (v11 == v10)
    {
      v7 = 4;
      v6 = v10;
    }
    else
    {
      if (!v11)
      {
LABEL_10:
        v4 = v9 != 0;
        pthread_mutex_unlock((pthread_mutex_t *)((char *)a2 + 8));
        goto LABEL_11;
      }
      v7 = 5;
    }
    (*(void (**)(void))(*v6 + 8 * v7))();
    goto LABEL_10;
  }
LABEL_11:
  if (this)
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
  return v4;
}

void sub_183EDDC08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v13;
  pthread_mutex_t *v14;
  char *v15;
  char *v17;
  uint64_t v18;

  v17 = a13;
  if (a13 == v15)
  {
    v18 = 4;
    v17 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v18 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_6:
  pthread_mutex_unlock(v14);
  if (v13)
    pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8));
  _Unwind_Resume(a1);
}

uint64_t AuthenticationState::_foreachAuthenticationInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  int *v10;
  _DWORD *v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t i;
  uint64_t result;
  int v18;
  _DWORD v19[2];
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v19[0] = *(_DWORD *)(a1 + 96);
  v3 = *(_QWORD *)(a1 + 112);
  v20 = *(_QWORD *)(a1 + 104);
  v21 = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v22 = *(_DWORD *)(a1 + 120);
  v6 = *(_QWORD *)(a1 + 136);
  v23 = *(_QWORD *)(a1 + 128);
  v24 = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v9 = 0;
  v10 = v19;
  do
  {
    v11 = &v19[6 * v9];
    v13 = *((_QWORD *)v11 + 1);
    v12 = v11 + 2;
    if (v13)
    {
      v18 = *v10;
      v14 = *(_QWORD *)(a2 + 24);
      if (!v14)
      {
        std::__throw_bad_function_call[abi:nn180100]();
        __break(1u);
      }
      if (((*(uint64_t (**)(uint64_t, int *, _DWORD *))(*(_QWORD *)v14 + 48))(v14, &v18, v12) & 1) == 0)
        break;
    }
    v15 = v9 + 1;
    v10 = &v19[6 * v9 + 6];
    v9 = 1;
  }
  while (v15 != 2);
  for (i = 8; i != -4; i -= 6)
    result = std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&v19[i]);
  return result;
}

void sub_183EDDD84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  uint64_t i;

  for (i = 32; i != -16; i -= 24)
    std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(&a10 + i));
  _Unwind_Resume(a1);
}

uint64_t ___ZNK24HTTPConnectionCacheEntry36_countPendingTubesWithAuthenticationEP19AuthenticationState_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  AuthenticationState *v13;
  std::__shared_weak_count *v14;

  v3 = Tube::copyWaiter(*(Tube **)(a2 + 112));
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 80))(v3);
  v5 = v4 - 176;
  if (!v4)
    v5 = 0;
  v6 = v5 + 176;
  if (v4)
    v7 = v6;
  else
    v7 = 0;
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v7 + 176))(v7))
  {
    (*(void (**)(AuthenticationState **__return_ptr, uint64_t))(*(_QWORD *)v7 + 88))(&v13, v7);
    v8 = AuthenticationState::addsConnectionAuth(v13, *(AuthenticationState **)(a1 + 40));
    v9 = v14;
    if (v14)
    {
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    if (!v8)
      ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
}

void sub_183EDDEA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'HTTPProtocol::authState(HTTPProtocol *this@<X0>, _QWORD *a2@<X8>)
{
  HTTPProtocol::authState((HTTPProtocol *)((char *)this - 176), a2);
}

void HTTPProtocol::authState(HTTPProtocol *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  uint64_t *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  __int128 v12;

  v4 = *((_QWORD *)this + 97);
  if (!v4)
  {
    v5 = (uint64_t *)((char *)this + 776);
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
      || (LOWORD(v12) = 0,
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Missing authentication state", (uint8_t *)&v12, 2u), (v4 = *v5) == 0))
    {
      _ZNSt3__115allocate_sharedB8nn180100I19AuthenticationStateNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((std::__shared_weak_count_vtbl **)&v12);
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 776, &v12);
      v6 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
      if (*((_QWORD *)&v12 + 1))
      {
        v7 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
        do
          v8 = __ldaxr(v7);
        while (__stlxr(v8 - 1, v7));
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
      v4 = *v5;
    }
  }
  v9 = *((_QWORD *)this + 98);
  *a2 = v4;
  a2[1] = v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
}

uint64_t Tube::copyWaiter(Tube *this)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  Tube *v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v6 = this;
  if (this)
  {
    (*(void (**)(Tube *))(*(_QWORD *)this + 40))(this);
    v1 = v4[3];
  }
  else
  {
    v1 = 0;
  }
  _Block_object_dispose(&v3, 8);
  return v1;
}

void sub_183EDE01C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'HTTPProtocol::isCancelled(HTTPProtocol *this)
{
  return (*((_DWORD *)this + 4) >> 20) & 1;
}

uint64_t *AuthenticationState::resetInvalid(AuthenticationState *this)
{
  uint64_t *result;
  uint64_t v3;
  _DWORD *v4;
  uint64_t v5;
  void *__p;
  _QWORD v7[3];
  uint64_t *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (this)
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  __p = 0;
  v7[0] = &off_1E14F03F0;
  v7[1] = this;
  v7[2] = &__p;
  v8 = v7;
  AuthenticationState::_foreachAuthenticationInfo((uint64_t)this, (uint64_t)v7);
  result = v8;
  if (v8 == v7)
  {
    v3 = 4;
    result = v7;
    goto LABEL_7;
  }
  if (v8)
  {
    v3 = 5;
LABEL_7:
    result = (uint64_t *)(*(uint64_t (**)(void))(*result + 8 * v3))();
  }
  v4 = __p;
  if (__p)
  {
    do
    {
      AuthenticationState::_removeAuthenticationInfo((uint64_t)this, v4[2]);
      v4 = *(_DWORD **)v4;
    }
    while (v4);
    result = (uint64_t *)__p;
    if (__p)
    {
      do
      {
        v5 = *result;
        operator delete(result);
        result = (uint64_t *)v5;
      }
      while (v5);
    }
  }
  if (this)
    return (uint64_t *)pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
  return result;
}

void sub_183EDE138(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _QWORD *__p, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v13;
  char *v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;

  v15 = a13;
  if (a13 == &a10)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  v17 = __p;
  if (__p)
  {
    do
    {
      v18 = (_QWORD *)*v17;
      operator delete(v17);
      v17 = v18;
    }
    while (v18);
  }
  if (v13)
    pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8));
  _Unwind_Resume(exception_object);
}

void TubeManager::_onqueue_rdar53306264_addWaiter(CFArrayRef *this, BaseAwaitingTube *value, int a3)
{
  uint64_t v6;
  const void *v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  BOOL v11;
  const void *ValueAtIndex;
  NSObject *v13;
  int v14;
  BaseAwaitingTube *v15;
  __int16 v16;
  const void *v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (value
    && (v6 = (*(uint64_t (**)(BaseAwaitingTube *))(*(_QWORD *)value + 80))(value)) != 0
    && (v7 = (const void *)v6, Count = CFArrayGetCount(this[17]), Count >= 1))
  {
    v9 = Count;
    v10 = 0;
    v11 = 1;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(this[17], v10);
      if (ValueAtIndex)
        ValueAtIndex = (const void *)(*(uint64_t (**)(const void *))(*(_QWORD *)ValueAtIndex + 80))(ValueAtIndex);
      if (v7 == ValueAtIndex)
        break;
      v11 = ++v10 < v9;
      if (v9 == v10)
        goto LABEL_9;
    }
    CFArrayAppendValue(this[17], value);
    if (v11)
    {
      TubeManager::_onqueue_rdar53306264_logWaiters(this);
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v13 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
      {
        v14 = 134218496;
        v15 = value;
        v16 = 2048;
        v17 = v7;
        v18 = 1024;
        v19 = a3;
        _os_log_fault_impl(&dword_183ECA000, v13, OS_LOG_TYPE_FAULT, "[rdar53306264-AW] NW(%p) NW.C(%p) R(%d)", (uint8_t *)&v14, 0x1Cu);
      }
      __assert_rtn("_onqueue_rdar53306264_addWaiter", "TubeManager.cpp", 1122, "false");
    }
  }
  else
  {
LABEL_9:
    CFArrayAppendValue(this[17], value);
  }
}

uint64_t HTTPConnectionCacheEntry::EnqueuedRequest::getClient(HTTPConnectionCacheEntry::EnqueuedRequest *this)
{
  return *((_QWORD *)this + 3);
}

BOOL HTTPProtocol::useNetStreamInfoForRequest(HTTPProtocol *this, MetaNetStreamInfo *a2, const HTTPRequestMessage *a3, int a4)
{
  NSURLRequest *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFString *v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  __CFReadStream *v24;
  const void *v25;
  const void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  const __CFAllocator *v33;
  CFArrayRef v34;
  uint64_t v35;
  __CFReadStream *v36;
  uint64_t v37;
  const __CFString *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  const char *v44;
  _QWORD *v45;
  CFTypeID v46;
  std::__shared_weak_count *v47;
  unint64_t *p_shared_owners;
  uint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  unint64_t v53;
  const char *v54;
  unint64_t v55;
  unint64_t *v56;
  unint64_t v57;
  void *v58;
  _BYTE *Property;
  uint64_t v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  void *v64;
  unint64_t *v65;
  unint64_t v66;
  std::__shared_weak_count *v67;
  unint64_t *v68;
  unint64_t v69;
  MetaNetStreamInfo *v70;
  uint64_t v71;
  void *v72;
  id v73;
  uint64_t v74;
  unint64_t *v75;
  unint64_t v76;
  std::__shared_weak_count *v77;
  unint64_t *v78;
  unint64_t v79;
  const void *v80;
  const __CFDictionary *v81;
  const __CFDictionary *v82;
  const void *Value;
  const void *v84;
  const void *v85;
  _QWORD *v86;
  CFURLRef v87;
  uint64_t v88;
  uint64_t v89;
  std::__shared_weak_count *v90;
  unint64_t *v91;
  unint64_t v92;
  const __CFURL *v93;
  HTTPProtocol *v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v97;
  uint64_t v98;
  std::__shared_weak_count *v99;
  unint64_t *v100;
  uint64_t v101;
  unint64_t v102;
  std::__shared_weak_count *v103;
  unint64_t *v104;
  unint64_t v105;
  std::__shared_weak_count *v106;
  unint64_t *v107;
  unint64_t v108;
  std::__shared_weak_count *v109;
  unint64_t *v110;
  uint64_t v111;
  unint64_t v112;
  std::__shared_weak_count *v113;
  unint64_t *v114;
  unint64_t v115;
  std::__shared_weak_count *v116;
  unint64_t *v117;
  unint64_t v118;
  __CFDictionary *v119;
  __CFDictionary *v120;
  void *v121;
  float v122;
  uint64_t v123;
  int v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  _QWORD v128[6];
  std::__shared_weak_count *v129;
  _QWORD v130[6];
  std::__shared_weak_count *v131;
  uint64_t v132;
  std::__shared_weak_count *v133;
  uint64_t v134;
  uint64_t v135;
  void (*v136)(uint64_t, uint64_t, NSObject *, CFStreamError *);
  void *v137;
  HTTPProtocol *v138;
  uint64_t v139;
  uint8_t buf[8];
  uint64_t v141;
  void (*v142)(uint64_t, uint64_t, NSObject *, CFStreamError *);
  void *v143;
  HTTPProtocol *v144;
  uint64_t v145;
  _QWORD v146[2];
  void (*v147)(uint64_t, int);
  void *v148;
  HTTPProtocol *v149;
  _QWORD context[6];

  v8 = (NSURLRequest *)*((_QWORD *)this + 11);
  (*(void (**)(HTTPProtocol *))(*(_QWORD *)this + 704))(this);
  if (!v8)
    return 0;
  v9 = *((_QWORD *)this + 110);
  if (v9)
  {
    v10 = (*(uint64_t (**)(MetaNetStreamInfo *))(*(_QWORD *)a2 + 160))(a2);
    (*(void (**)(uint64_t, uint64_t))(v9 + 16))(v9, v10);
  }
  v11 = *((_DWORD *)this + 48) & 0xFFFFFDFF | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
  *((_DWORD *)this + 48) = *((_DWORD *)this + 48) & 0xFFFFFDFF | ((a4 != 0) << 9);
  *((_WORD *)this + 98) = WORD2(v11);
  v12 = *(_QWORD *)(-[NSURLRequest _inner](v8, "_inner") + 56);
  if (!v12 || !*(_QWORD *)(v12 + 208) && !*(_QWORD *)(v12 + 200))
  {
    *((_QWORD *)this + 34) = a2;
    (*(void (**)(MetaNetStreamInfo *))(*(_QWORD *)a2 + 16))(a2);
    v19 = *((_QWORD *)this + 34);
    v20 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 728))(this);
    (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v19 + 88))(v19, 0, v20);
    goto LABEL_52;
  }
  v13 = *(_QWORD *)(-[NSURLRequest _inner](v8, "_inner") + 56);
  if (!dyld_program_sdk_at_least()
    || !v13
    || (v14 = *(const __CFString **)(v13 + 152)) == 0
    && (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
     || (*(_WORD *)buf = 0,
         _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u), (v14 = *(const __CFString **)(v13 + 152)) == 0))|| CFStringCompare(v14, (CFStringRef)&gConstantCFStringValueTable[2590], 0))
  {
    v21 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 72))(this);
    v22 = (void *)*((_QWORD *)this + 10);
    if (v21)
      goto LABEL_45;
    v23 = *(_QWORD *)(-[NSURLRequest _inner](v8, "_inner") + 56);
    if (v23)
    {
      if (*(_QWORD *)(v23 + 208))
      {
        v24 = (__CFReadStream *)CFReadStreamCreate();
        goto LABEL_25;
      }
      v25 = *(const void **)(v23 + 200);
      if (v25)
      {
        v24 = (__CFReadStream *)CFRetain(v25);
LABEL_25:
        v26 = v24;
        if (v24)
        {
          if (CFReadStreamGetStatus(v24) == kCFStreamStatusNotOpen)
          {
            (*(void (**)(HTTPProtocol *, const void *))(*(_QWORD *)this + 80))(this, v26);
LABEL_44:
            CFRelease(v26);
            goto LABEL_45;
          }
          CFRelease(v26);
        }
      }
    }
    if ((*((_DWORD *)this + 48) & 0x80000000) == 0)
    {
      v27 = objc_msgSend(v22, "resumableUploadState");
      if (v27 && *(_DWORD *)(v27 + 12) == 1 && *(_DWORD *)(v27 + 16) == 2 && *(uint64_t *)(v27 + 24) >= 1)
      {
        *((_DWORD *)this + 48) |= 0x80000000;
        v28 = objc_msgSend(v22, "resumableUploadState");
        if (v28)
          v29 = *(_QWORD *)(v28 + 24);
        else
          v29 = 0;
        v30 = *((_QWORD *)this + 12);
        if (v30)
        {
          v31 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v30 + 16))(*((_QWORD *)this + 12));
          v32 = (void *)MEMORY[0x186DB8C8C](v31);
          (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 12) + 120))(*((_QWORD *)this + 12), v29);
          objc_autoreleasePoolPop(v32);
          (*(void (**)(uint64_t))(*(_QWORD *)v30 + 24))(v30);
        }
        goto LABEL_45;
      }
      if (objc_msgSend((id)objc_msgSend(v22, "resumableUploadState"), "isResumable"))
      {
        v33 = CFGetAllocator((char *)this - 16);
        v34 = CFArrayCreate(v33, 0, 0, 0);
        CFGetAllocator((char *)this - 16);
        v26 = (const void *)CFReadStreamCreate();
        if (v34)
          CFRelease(v34);
        (*(void (**)(HTTPProtocol *, const void *))(*(_QWORD *)this + 80))(this, v26);
        if (!v26)
          goto LABEL_45;
        goto LABEL_44;
      }
      *((_DWORD *)this + 48) |= 0x80000000;
      URLProtocol::sendNeedNewBodyStream((URLProtocol *)this);
    }
LABEL_45:
    v35 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 72))(this);
    if (!v35)
    {
      v16 = -1021;
      v17 = -1021;
      goto LABEL_53;
    }
    v36 = (__CFReadStream *)v35;
    if (objc_msgSend((id)objc_msgSend(v22, "resumableUploadState"), "isResumable"))
    {
      v37 = objc_msgSend(v22, "resumableUploadState");
      if (v37)
      {
        if (*(_DWORD *)(v37 + 12) == 1 && *(uint64_t *)(v37 + 24) >= 1)
        {
          v38 = (const __CFString *)*MEMORY[0x1E0C9B2B0];
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:");
          v39 = (void *)objc_claimAutoreleasedReturnValue();
          CFReadStreamSetProperty(v36, v38, v39);

        }
      }
    }
    *((_QWORD *)this + 34) = a2;
    (*(void (**)(MetaNetStreamInfo *))(*(_QWORD *)a2 + 16))(a2);
    v40 = *((_QWORD *)this + 34);
    v41 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 728))(this);
    (*(void (**)(uint64_t, __CFReadStream *, uint64_t))(*(_QWORD *)v40 + 88))(v40, v36, v41);
    *((_BYTE *)this + 492) = 1;
    (*(void (**)(HTTPProtocol *, _QWORD))(*(_QWORD *)this + 80))(this, 0);
LABEL_52:
    v17 = 0;
    v16 = -1004;
    goto LABEL_53;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v15 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_183ECA000, v15, OS_LOG_TYPE_ERROR, "GET method must not have a body", buf, 2u);
  }
  v16 = -1103;
  v17 = -1103;
LABEL_53:
  v42 = *((_QWORD *)this + 34);
  if (v42)
  {
    v43 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v42 + 32))(v42, 26);
    if (v43)
    {
      v45 = v43;
      v46 = CFGetTypeID(v43);
      if (TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::sOnce != -1)
        dispatch_once(&TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::sOnce, &__block_literal_global_211_7114);
      if (v46 == *(_QWORD *)(TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::clazz + 96))
      {
        CFRetain((char *)this - 16);
        *(_QWORD *)buf = (char *)this + 120;
        v47 = (std::__shared_weak_count *)operator new();
        v47->__shared_owners_ = 0;
        p_shared_owners = (unint64_t *)&v47->__shared_owners_;
        v47->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F10F0;
        v47->__shared_weak_owners_ = 0;
        v47[1].__vftable = (std::__shared_weak_count_vtbl *)this;
        v141 = (uint64_t)v47;
        if (TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::sOnce != -1)
          dispatch_once(&TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::sOnce, &__block_literal_global_211_7114);
        v49 = v45[3];
        v50 = (std::__shared_weak_count *)v45[4];
        if (v50)
        {
          v51 = (unint64_t *)&v50->__shared_owners_;
          do
            v52 = __ldxr(v51);
          while (__stxr(v52 + 1, v51));
        }
        do
          v53 = __ldxr(p_shared_owners);
        while (__stxr(v53 + 1, p_shared_owners));
        std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v49 + 144), (uint64_t)this + 120, (uint64_t)v47);
        do
          v55 = __ldaxr(p_shared_owners);
        while (__stlxr(v55 - 1, p_shared_owners));
        if (!v55)
        {
          ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
          std::__shared_weak_count::__release_weak(v47);
        }
        if (v50)
        {
          v56 = (unint64_t *)&v50->__shared_owners_;
          do
            v57 = __ldaxr(v56);
          while (__stlxr(v57 - 1, v56));
          if (!v57)
          {
            ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
            std::__shared_weak_count::__release_weak(v50);
          }
        }
        v58 = (void *)*((_QWORD *)this + 104);
        if (v58)
          Property = objc_getProperty(v58, v54, 96, 1);
        else
          Property = 0;
        if (TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::sOnce != -1)
          dispatch_once(&TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::sOnce, &__block_literal_global_211_7114);
        v60 = v45[3];
        v61 = (std::__shared_weak_count *)v45[4];
        v134 = v60;
        v135 = (uint64_t)v61;
        if (v61)
        {
          v62 = (unint64_t *)&v61->__shared_owners_;
          do
            v63 = __ldxr(v62);
          while (__stxr(v63 + 1, v62));
        }
        v64 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v60 + 248))(v60);
        -[__CFN_TransactionMetrics linkWithConnection:](Property, v64);
        if (v61)
        {
          v65 = (unint64_t *)&v61->__shared_owners_;
          do
            v66 = __ldaxr(v65);
          while (__stlxr(v66 - 1, v65));
          if (!v66)
          {
            ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
            std::__shared_weak_count::__release_weak(v61);
          }
        }
        v67 = (std::__shared_weak_count *)v141;
        if (v141)
        {
          v68 = (unint64_t *)(v141 + 8);
          do
            v69 = __ldaxr(v68);
          while (__stlxr(v69 - 1, v68));
          if (!v69)
          {
            ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
            std::__shared_weak_count::__release_weak(v67);
          }
        }
      }
      else
      {
        if (TCFObject<SocketStream>::Class(void)::sOnce != -1)
          dispatch_once(&TCFObject<SocketStream>::Class(void)::sOnce, &__block_literal_global_212);
        (*(void (**)(_QWORD *, char *))(v45[2] + 176))(v45 + 2, (char *)this + 112);
      }
      CFRelease(v45);
    }
    v71 = *((_QWORD *)this + 34);
    v72 = (void *)*((_QWORD *)this + 104);
    if (v72)
      v73 = objc_getProperty(v72, v44, 96, 1);
    else
      v73 = 0;
    (*(void (**)(uint64_t, id))(*(_QWORD *)v71 + 152))(v71, v73);
    v74 = objc_msgSend(*((id *)this + 10), "_dependencyInfo");
    if (v74)
      (*(void (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 34) + 40))(*((_QWORD *)this + 34), 17, v74);
    (*(void (**)(uint8_t *__return_ptr))(**((_QWORD **)this + 34) + 144))(buf);
    if (*(_QWORD *)buf)
    {
      v132 = *(_QWORD *)buf;
      v133 = (std::__shared_weak_count *)v141;
      if (v141)
      {
        v75 = (unint64_t *)(v141 + 8);
        do
          v76 = __ldxr(v75);
        while (__stxr(v76 + 1, v75));
      }
      (*(void (**)(HTTPProtocol *, uint64_t *))(*(_QWORD *)this + 600))(this, &v132);
      v77 = v133;
      if (v133)
      {
        v78 = (unint64_t *)&v133->__shared_owners_;
        do
          v79 = __ldaxr(v78);
        while (__stlxr(v79 - 1, v78));
        if (!v79)
        {
          ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
          std::__shared_weak_count::__release_weak(v77);
        }
      }
    }
    if (*((_QWORD *)this + 93))
    {
      if (*((_QWORD *)this + 10))
      {
        v80 = (const void *)*((_QWORD *)this + 94);
        if (v80)
        {
          v81 = (const __CFDictionary *)CFRetain(v80);
          v82 = v81;
          if (v81)
          {
            Value = CFDictionaryGetValue(v81, &unk_1EDCFA5D0);
            if (Value)
              (*(void (**)(_QWORD, uint64_t, const void *))(**((_QWORD **)this + 34) + 40))(*((_QWORD *)this + 34), 16, Value);
            v84 = CFDictionaryGetValue(v82, &unk_1EDCFA250);
            if (v84)
            {
              v85 = (const void *)*((_QWORD *)this + 73);
              if (v85)
                CFRelease(v85);
              *((_QWORD *)this + 73) = CFRetain(v84);
            }
            CFRelease(v82);
          }
        }
      }
    }
    else
    {
      if ((*((_DWORD *)this + 48) & 0x20000) != 0)
        v86 = (_QWORD *)MEMORY[0x1E0C9AE50];
      else
        v86 = (_QWORD *)MEMORY[0x1E0C9AE40];
      (*(void (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)this + 34) + 40))(*((_QWORD *)this + 34), 16, *v86);
    }
    if ((*(unsigned int (**)(HTTPProtocol *))(*(_QWORD *)this + 552))(this))
      (*(void (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)this + 34) + 40))(*((_QWORD *)this + 34), 4, *MEMORY[0x1E0C9AE50]);
    v87 = _CFURLRequestCopyProtocolPropertyForKey(v8, (const __CFString *)&unk_1EDCFE658);
    if (v87)
    {
      (*(void (**)(_QWORD, uint64_t, CFURLRef))(**((_QWORD **)this + 34) + 40))(*((_QWORD *)this + 34), 30, v87);
      CFRelease(v87);
    }
    if (*((_QWORD *)this + 73))
      (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 34) + 40))(*((_QWORD *)this + 34), 27);
    v88 = objc_msgSend(*((id *)this + 10), "_DuetActivityProperties");
    if (v88)
      (*(void (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 34) + 40))(*((_QWORD *)this + 34), 3, v88);
    v89 = objc_msgSend(*((id *)this + 10), "_TCPConnectionMetadata", v88);
    if (v89)
      (*(void (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 34) + 40))(*((_QWORD *)this + 34), 29, v89);
    v90 = (std::__shared_weak_count *)v141;
    if (v141)
    {
      v91 = (unint64_t *)(v141 + 8);
      do
        v92 = __ldaxr(v91);
      while (__stlxr(v92 - 1, v91));
      if (!v92)
      {
        ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
        std::__shared_weak_count::__release_weak(v90);
      }
    }
    v70 = (MetaNetStreamInfo *)*((_QWORD *)this + 34);
  }
  else
  {
    v70 = 0;
    v17 = v16;
  }
  v93 = (const __CFURL *)HTTPRequestParserClient::requestURL((const HTTPRequestMessage *)((char *)a3 + 128));
  HTTPProtocol::applyPreAuthenticationToCurrentRequest(this, v70, v8, v93);
  if (v17)
  {
    if (v17 != -1021)
    {
      v94 = this;
      v95 = v17;
LABEL_185:
      HTTPProtocol::sendError(v94, (const __CFString *)v95);
    }
  }
  else
  {
    v96 = *((_QWORD *)this + 34);
    if (v96)
    {
      if (*((_BYTE *)this + 42))
        v97 = (_QWORD *)MEMORY[0x1E0C9AE50];
      else
        v97 = (_QWORD *)MEMORY[0x1E0C9AE40];
      (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v96 + 40))(v96, 15, *v97);
      v98 = MEMORY[0x1E0C809B0];
      if (*((_BYTE *)this + 46) || *((_BYTE *)this + 42))
      {
        CFRetain((char *)this - 16);
        *(_QWORD *)buf = this;
        v99 = (std::__shared_weak_count *)operator new();
        v99->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F10F0;
        v99->__shared_weak_owners_ = 0;
        v99[1].__vftable = (std::__shared_weak_count_vtbl *)this;
        v141 = (uint64_t)v99;
        v130[5] = this;
        v131 = v99;
        v99->__shared_owners_ = 0;
        v100 = (unint64_t *)&v99->__shared_owners_;
        v101 = *((_QWORD *)this + 34);
        v130[0] = v98;
        v130[1] = 3321888768;
        v130[2] = ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke;
        v130[3] = &__block_descriptor_56_e8_40c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e25_v16__0____CFDictionary__8l;
        v130[4] = this;
        do
          v102 = __ldxr(v100);
        while (__stxr(v102 + 1, v100));
        (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v101 + 40))(v101, 14, v130);
        v103 = v131;
        if (v131)
        {
          v104 = (unint64_t *)&v131->__shared_owners_;
          do
            v105 = __ldaxr(v104);
          while (__stlxr(v105 - 1, v104));
          if (!v105)
          {
            ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
            std::__shared_weak_count::__release_weak(v103);
          }
        }
        v106 = (std::__shared_weak_count *)v141;
        if (v141)
        {
          v107 = (unint64_t *)(v141 + 8);
          do
            v108 = __ldaxr(v107);
          while (__stlxr(v108 - 1, v107));
          if (!v108)
          {
            ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
            std::__shared_weak_count::__release_weak(v106);
          }
        }
      }
      else
      {
        (*(void (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)this + 34) + 40))(*((_QWORD *)this + 34), 14, 0);
      }
      if (*((_BYTE *)this + 44))
      {
        CFRetain((char *)this - 16);
        *(_QWORD *)buf = this;
        v109 = (std::__shared_weak_count *)operator new();
        v109->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F10F0;
        v109->__shared_weak_owners_ = 0;
        v109[1].__vftable = (std::__shared_weak_count_vtbl *)this;
        v141 = (uint64_t)v109;
        v128[5] = this;
        v129 = v109;
        v109->__shared_owners_ = 0;
        v110 = (unint64_t *)&v109->__shared_owners_;
        v111 = *((_QWORD *)this + 34);
        v128[0] = v98;
        v128[1] = 3321888768;
        v128[2] = ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_113;
        v128[3] = &__block_descriptor_56_e8_40c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e28_v20__0____CFReadStream__8C16l;
        v128[4] = this;
        do
          v112 = __ldxr(v110);
        while (__stxr(v112 + 1, v110));
        (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v111 + 40))(v111, 12, v128);
        v113 = v129;
        if (v129)
        {
          v114 = (unint64_t *)&v129->__shared_owners_;
          do
            v115 = __ldaxr(v114);
          while (__stlxr(v115 - 1, v114));
          if (!v115)
          {
            ((void (*)(std::__shared_weak_count *))v113->__on_zero_shared)(v113);
            std::__shared_weak_count::__release_weak(v113);
          }
        }
        v116 = (std::__shared_weak_count *)v141;
        if (v141)
        {
          v117 = (unint64_t *)(v141 + 8);
          do
            v118 = __ldaxr(v117);
          while (__stlxr(v118 - 1, v117));
          if (!v118)
          {
            ((void (*)(std::__shared_weak_count *))v116->__on_zero_shared)(v116);
            std::__shared_weak_count::__release_weak(v116);
          }
        }
      }
      HTTPProtocol::handleCellularResponseInfo(this);
      if (*((_QWORD *)this + 34))
      {
        if (nw_settings_get_signposts_enabled())
          kdebug_trace();
        v119 = HTTPProtocol::copyProtocolPropertiesForStream(this);
        if (v119)
        {
          v120 = v119;
          context[0] = v98;
          context[1] = 3221225472;
          context[2] = ___ZN12HTTPProtocol29setProtocolPropertiesToStreamEv_block_invoke;
          context[3] = &__block_descriptor_40_e25_v24__0____CFString__8_v16l;
          context[4] = this;
          CFDictionaryApplyFunction(v119, (CFDictionaryApplierFunction)_apply_block, context);
          CFRelease(v120);
        }
        v121 = (void *)*((_QWORD *)this + 10);
        if (v121)
        {
          objc_msgSend(*((id *)this + 10), "priority");
          (*(void (**)(HTTPProtocol *, uint64_t, float))(*(_QWORD *)this + 152))(this, objc_msgSend(v121, "prefersIncrementalDelivery"), v122);
        }
        v146[0] = v98;
        v146[1] = 3221225472;
        v147 = ___ZN12HTTPProtocol10openStreamEv_block_invoke;
        v148 = &__block_descriptor_40_e8_v12__0C8l;
        v149 = this;
        v123 = *((_QWORD *)this + 34);
        v124 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v123 + 48))(v123);
        v125 = *((_QWORD *)this + 34);
        v126 = *((_QWORD *)this + 3);
        if (v124)
        {
          v134 = v98;
          v135 = 3221225472;
          v136 = ___ZN12HTTPProtocol10openStreamEv_block_invoke_3;
          v137 = &__block_descriptor_48_e67_v32__0____CFHTTPMessage__8__NSObject_OS_dispatch_data__16r____qi_24l;
          v138 = this;
          v139 = v123;
          (*(void (**)(uint64_t, uint64_t, uint64_t *, _QWORD *))(*(_QWORD *)v125 + 56))(v125, v126, &v134, v146);
        }
        else
        {
          *(_QWORD *)buf = v98;
          v141 = 3221225472;
          v142 = ___ZN12HTTPProtocol10openStreamEv_block_invoke_2;
          v143 = &__block_descriptor_48_e67_v32__0____CFHTTPMessage__8__NSObject_OS_dispatch_data__16r____qi_24l;
          v144 = this;
          v145 = v123;
          v127 = (*(uint64_t (**)(uint64_t, uint64_t, uint8_t *, _QWORD))(*(_QWORD *)v125 + 56))(v125, v126, buf, 0);
          v147((uint64_t)v146, v127);
        }
        return v17 == 0;
      }
      v94 = this;
      v95 = -1004;
      goto LABEL_185;
    }
  }
  return v17 == 0;
}

void sub_183EDF234(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t TransportConnection::getMetrics(TransportConnection *this)
{
  return *((_QWORD *)this + 25);
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::setProperty(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 56))(*(_QWORD *)(a1 + 8));
}

uint64_t `non-virtual thunk to'HTTP2StreamBridge::setProperty(uint64_t a1, int a2, const void *a3)
{
  return HTTP2Stream::setProperty(*(_QWORD *)(a1 + 16), a2, a3);
}

uint64_t HTTP2Stream::setProperty(uint64_t a1, int a2, const void *a3)
{
  const __CFString *v5;
  int ExactString;
  uint64_t v7;
  int v8;
  CFTypeID v9;
  BOOL v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  double v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  HTTPMessage *v17;
  const void *v18;
  CFTypeRef v19;
  const void *v20;
  double v22[2];

  v5 = (const __CFString *)MetaNetStreamInfo::applicableToPropertyName(a2);
  ExactString = _findExactString(v5, 0);
  v7 = 1;
  if (ExactString <= 87361087)
  {
    if (ExactString <= 38142589)
    {
      if (ExactString <= 36061769)
      {
        if (ExactString != 11870276)
        {
          v8 = 32842260;
          goto LABEL_34;
        }
        v17 = *(HTTPMessage **)(a1 + 40);
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        HTTPMessage::setHeaderFieldStringValue(v17, 0x1171B29Fu, a3);
        return v7;
      }
      if (ExactString == 36061770)
        goto LABEL_35;
      v8 = 37110372;
    }
    else if (ExactString <= 40239791)
    {
      if (ExactString == 38142590)
        goto LABEL_35;
      v8 = 39191191;
    }
    else
    {
      if (ExactString == 40239792 || ExactString == 68551902)
        goto LABEL_35;
      v8 = 83273191;
    }
LABEL_34:
    if (ExactString != v8)
      return v7;
    goto LABEL_35;
  }
  if (ExactString <= 120965282)
  {
    if (ExactString > 92538536)
    {
      switch(ExactString)
      {
        case 92538537:
          if (a3)
            v19 = CFRetain(a3);
          else
            v19 = 0;
          v20 = *(const void **)(a1 + 432);
          *(_QWORD *)(a1 + 432) = v19;
          if (v20)
            CFRelease(v20);
          break;
        case 104064896:
          if (CFEqual(a3, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
          {
            *(_QWORD *)(a1 + 360) = 0x40000;
            *(_QWORD *)(a1 + 376) = 0x3FB99999A0000000;
          }
          break;
        case 119892109:
          LODWORD(v22[0]) = 0;
          CFNumberGetValue((CFNumberRef)a3, kCFNumberIntType, v22);
          if (SLODWORD(v22[0]) >= 1)
            *(_QWORD *)(a1 + 360) = LODWORD(v22[0]);
          break;
      }
      return v7;
    }
    if (ExactString == 87361088)
      goto LABEL_35;
    v8 = 90506882;
    goto LABEL_34;
  }
  if (ExactString > 135580084)
  {
    if (ExactString != 135580085)
    {
      if (ExactString == 398906741)
      {
        v18 = *(const void **)(a1 + 312);
        if (v18)
          _Block_release(v18);
        *(_QWORD *)(a1 + 312) = a3;
        if (a3)
          *(_QWORD *)(a1 + 312) = _Block_copy(a3);
      }
      else if (ExactString == 406214149)
      {
        if (a3)
        {
          v9 = CFGetTypeID(a3);
          if (v9 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            LOWORD(v22[0]) = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)v22, 2u);
          }
          v10 = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
        }
        else
        {
          v10 = 0;
        }
        *(_BYTE *)(a1 + 320) = v10;
        return 1;
      }
      return v7;
    }
LABEL_35:
    v11 = *(std::__shared_weak_count **)(a1 + 96);
    if (!v11)
      return 0;
    v12 = std::__shared_weak_count::lock(v11);
    *(_QWORD *)&v22[1] = v12;
    if (!v12)
      return 0;
    v13 = v12;
    v14 = *(double *)(a1 + 88);
    v22[0] = v14;
    if (v14 == 0.0)
    {
      v7 = 0;
    }
    else if (**(_DWORD **)&v14 != 2)
    {
      if (**(_DWORD **)&v14 != 1)
        __assert_rtn("setProperty_offqueue", "TCPIOConnectionTest.hpp", 237, "false");
      v7 = (*(uint64_t (**)(_QWORD, const __CFString *, const void *))(**(_QWORD **)(*(_QWORD *)&v14 + 8)
                                                                               + 224))(*(_QWORD *)(*(_QWORD *)&v14 + 8), v5, a3);
    }
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
    return v7;
  }
  if (ExactString != 120965283)
  {
    v8 = 129296697;
    goto LABEL_34;
  }
  v22[0] = 0.0;
  CFNumberGetValue((CFNumberRef)a3, kCFNumberDoubleType, v22);
  if (v22[0] > 0.0)
    *(double *)(a1 + 376) = v22[0];
  return v7;
}

void sub_183EDF70C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14NWIOConnection16writeWithContextEPU32objcproto21OS_nw_content_context8NSObjectN26ContextReadWriteConnection17WriteContextStateEPU27objcproto16OS_dispatch_dataS0_U13block_pointerFv13CFStreamErrorE_block_invoke(uint64_t result, NSObject *a2)
{
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  IOLogger *v6;
  int v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  int v12;
  NSObject *v13;
  uint64_t v14;
  size_t size_ptr;
  _BYTE buffer_ptr[12];
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(result + 56);
  if ((*(_WORD *)(v2 + 248) & 0x60) == 0 && (*(_DWORD *)(v2 + 136) - 5) >= 2)
  {
    v4 = (_QWORD *)result;
    v5 = *(_QWORD *)(result + 48);
    if (nw_settings_get_signposts_enabled())
      kdebug_trace();
    NWIOConnection::_watchdogTouch((NWIOConnection *)v5, 0);
    v6 = *(IOLogger **)(v5 + 392);
    if (v6 && !a2 && v4[9])
    {
      v7 = (*(unsigned __int16 *)(v5 + 248) >> 12) & 1;
      v8 = v4[4];
      size_ptr = 0;
      *(_QWORD *)buffer_ptr = 0;
      v9 = dispatch_data_create_map(v8, (const void **)buffer_ptr, &size_ptr);
      IOLogger::logBytesSent(v6, v7, *(const unsigned __int8 **)buffer_ptr, size_ptr);
      dispatch_release(v9);
    }
    else if (a2)
    {
      v10 = NWIOConnection::_convertError(v5, a2);
      v12 = v11;
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v13 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        v14 = *(_QWORD *)(v5 + 288);
        *(_DWORD *)buffer_ptr = 134218496;
        *(_QWORD *)&buffer_ptr[4] = v14;
        v17 = 2048;
        v18 = v10;
        v19 = 1024;
        v20 = v12;
        _os_log_error_impl(&dword_183ECA000, v13, OS_LOG_TYPE_ERROR, "Connection %llu: write error %ld:%d", buffer_ptr, 0x1Cu);
      }
    }
    return (*(uint64_t (**)(void))(v4[5] + 16))();
  }
  return result;
}

uint64_t ___ZN14NWIOConnection15readWithContextEPU32objcproto21OS_nw_content_context8NSObjectjjU13block_pointerFvS2_PU27objcproto16OS_dispatch_dataS0_b13CFStreamErrorE_block_invoke(uint64_t result, dispatch_data_t data, uint64_t a3, int a4, NSObject *a5)
{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  size_t size;
  uint64_t v12;
  _BOOL8 isCellular;
  _BOOL8 isExpensive;
  IOLogger *v15;
  int v16;
  NSObject *v17;
  uint64_t v18;
  int v19;
  NSObject *v20;
  int v21;
  NSObject *v22;
  uint64_t v23;
  int v24;
  size_t size_ptr;
  _BYTE buffer_ptr[12];
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(result + 56);
  if ((*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2)
  {
    v9 = result;
    v10 = *(_QWORD *)(result + 48);
    if (data)
      size = dispatch_data_get_size(data);
    else
      size = 0;
    if (nw_settings_get_signposts_enabled())
      kdebug_trace();
    NWIOConnection::_watchdogTouch((NWIOConnection *)v10, 0);
    if (size)
    {
      v12 = *(_QWORD *)(v10 + 584);
      if (v12)
      {
        isCellular = NWIOConnection::_isCellular((NWIOConnection *)v10);
        isExpensive = NWIOConnection::_isExpensive((NWIOConnection *)v10);
        __ConditionalConnectionDUETSupport_ReportBytes(v12, size, isCellular, isExpensive, 0);
      }
    }
    if (data)
    {
      v15 = *(IOLogger **)(v10 + 392);
      if (v15)
      {
        v16 = (*(unsigned __int16 *)(v10 + 248) >> 12) & 1;
        size_ptr = 0;
        *(_QWORD *)buffer_ptr = 0;
        v17 = dispatch_data_create_map(data, (const void **)buffer_ptr, &size_ptr);
        IOLogger::logBytesRead(v15, v16, *(const unsigned __int8 **)buffer_ptr, size_ptr);
        dispatch_release(v17);
      }
    }
    if (a5)
    {
      v18 = NWIOConnection::_convertError(v10, a5);
      LODWORD(a5) = v19;
      if (!size)
        goto LABEL_18;
    }
    else
    {
      v18 = 0;
      if (!size)
      {
LABEL_18:
        v20 = *(NSObject **)(v9 + 32);
        v21 = 78;
        if (v20)
        {
          if (nw_content_context_get_is_final(v20))
            v21 = 89;
          else
            v21 = 78;
        }
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v22 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          v23 = *(_QWORD *)(v10 + 288);
          if (a4)
            v24 = 89;
          else
            v24 = 78;
          *(_DWORD *)buffer_ptr = 134219008;
          *(_QWORD *)&buffer_ptr[4] = v23;
          v27 = 2048;
          v28 = v18;
          v29 = 1024;
          v30 = (int)a5;
          v31 = 1024;
          v32 = v24;
          v33 = 1024;
          v34 = v21;
          _os_log_impl(&dword_183ECA000, v22, OS_LOG_TYPE_DEFAULT, "Connection %llu: final read %ld:%d, complete[%c], final[%c]", buffer_ptr, 0x28u);
        }
      }
    }
    return (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 40) + 16))();
  }
  return result;
}

void NWIOConnection::_watchdogTouch(NWIOConnection *this, int a2)
{
  double v2;
  double v4;
  double v5;
  dispatch_source_t v6;
  NSObject *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_weak_owners;
  unint64_t v11;
  NSObject *v12;
  unint64_t *v13;
  unint64_t v14;
  NSObject *v15;
  dispatch_time_t v16;
  _QWORD handler[5];
  std::__shared_weak_count *v18;
  double v19;

  v2 = *((double *)this + 69);
  if (v2 > 0.0)
  {
    v4 = fmin(v2, 10.0);
    if (a2)
      v5 = v4;
    else
      v5 = *((double *)this + 69);
    if (!*((_QWORD *)this + 70))
    {
      v6 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *((dispatch_queue_t *)this + 15));
      v7 = *((_QWORD *)this + 70);
      *((_QWORD *)this + 70) = v6;
      if (v7)
        dispatch_release(v7);
      v8 = *((_QWORD *)this + 32);
      v9 = (std::__shared_weak_count *)*((_QWORD *)this + 33);
      if (v9)
      {
        p_shared_weak_owners = (unint64_t *)&v9->__shared_weak_owners_;
        do
          v11 = __ldxr(p_shared_weak_owners);
        while (__stxr(v11 + 1, p_shared_weak_owners));
      }
      v12 = *((_QWORD *)this + 70);
      handler[0] = MEMORY[0x1E0C809B0];
      handler[1] = 3321888768;
      handler[2] = ___ZN14NWIOConnection14_watchdogTouchEb_block_invoke;
      handler[3] = &__block_descriptor_56_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e5_v8__0l;
      handler[4] = v8;
      v18 = v9;
      if (v9)
      {
        v13 = (unint64_t *)&v9->__shared_weak_owners_;
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
      }
      v19 = v5;
      dispatch_source_set_event_handler(v12, handler);
      dispatch_resume(*((dispatch_object_t *)this + 70));
      if (v18)
        std::__shared_weak_count::__release_weak(v18);
      if (v9)
        std::__shared_weak_count::__release_weak(v9);
    }
    v15 = *((_QWORD *)this + 70);
    v16 = dispatch_time(0x8000000000000000, (uint64_t)(v5 * 1000000000.0));
    dispatch_source_set_timer(v15, v16, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
  }
}

void ConnectionReadAggregator::_evaluate(ConnectionReadAggregator *this)
{
  NSObject *v2;
  unsigned int size;
  double v4;
  int v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;

  if (*((_QWORD *)this + 12))
  {
    v2 = *((_QWORD *)this + 7);
    if (v2)
      size = dispatch_data_get_size(*((dispatch_data_t *)this + 7));
    else
      size = 0;
    if (size >= *((_DWORD *)this + 19) || *((_BYTE *)this + 105))
    {
      if (*((_DWORD *)this + 18) == 1)
        dispatch_source_set_timer(*((dispatch_source_t *)this + 8), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
      *((_DWORD *)this + 18) = 0;
      ConnectionReadAggregator::_invokeCB(this);
    }
    else
    {
      v4 = *((double *)this + 11);
      if (*((_BYTE *)this + 104))
      {
        if (v4 != 0.0 && *((int *)this + 18) <= 0)
          ConnectionReadAggregator::_timerStart(this);
      }
      else
      {
        if (v4 != 0.0 && *((int *)this + 18) <= 0)
        {
          ConnectionReadAggregator::_timerStart(this);
          v2 = *((_QWORD *)this + 7);
        }
        if (v2)
          v5 = dispatch_data_get_size(v2);
        else
          v5 = 0;
        if (*((double *)this + 11) == 0.0)
          v6 = (*((_DWORD *)this + 19) - v5);
        else
          v6 = 1;
        if (v2)
          dispatch_data_get_size(v2);
        v16 = 0;
        v7 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
        if (v7)
        {
          v7 = std::__shared_weak_count::lock(v7);
          v16 = v7;
        }
        *((_BYTE *)this + 104) = 1;
        v8 = *((_QWORD *)this + 6);
        v15 = v7;
        if (v7)
        {
          p_shared_owners = (unint64_t *)&v7->__shared_owners_;
          do
            v10 = __ldxr(p_shared_owners);
          while (__stxr(v10 + 1, p_shared_owners));
        }
        (*(void (**)(uint64_t, uint64_t))(v8 + 16))(v8, v6);
        if (v15)
        {
          v11 = (unint64_t *)&v15->__shared_owners_;
          do
            v12 = __ldaxr(v11);
          while (__stlxr(v12 - 1, v11));
          if (!v12)
          {
            ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
            std::__shared_weak_count::__release_weak(v15);
          }
        }
        if (v16)
        {
          v13 = (unint64_t *)&v16->__shared_owners_;
          do
            v14 = __ldaxr(v13);
          while (__stlxr(v14 - 1, v13));
          if (!v14)
          {
            ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
            std::__shared_weak_count::__release_weak(v16);
          }
        }
      }
    }
  }
}

void sub_183EDFF1C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 48);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14NWIOConnection4readEjjU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorE_block_invoke(uint64_t a1, nw_content_context_t context, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  uint64_t is_final;

  v9 = *(_QWORD *)(a1 + 32);
  if (context)
    is_final = 0;
  else
    is_final = a4;
  if (context && a4)
    is_final = nw_content_context_get_is_final(context);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 16))(v9, a3, is_final, a5, a6);
}

void ___ZN10HTTPEngine10initializeE21_CFHTTPConnectionType_block_invoke(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;

  v6 = a1[4];
  v7 = (std::__shared_weak_count *)a1[6];
  if (!v7)
  {
    v10 = 0;
    goto LABEL_7;
  }
  v10 = std::__shared_weak_count::lock(v7);
  if (!v10 || (v11 = a1[5]) == 0 || !*(_QWORD *)(v11 + 56))
  {
LABEL_7:
    (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t, uint64_t))(a4 + 16))(a4, 0, 1, 1, 57);
    if (!v10)
      return;
    goto LABEL_8;
  }
  (*(void (**)(_QWORD, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(v6 + 56) + 40))(*(_QWORD *)(v6 + 56), a2, a3, a4);
LABEL_8:
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
}

void sub_183EE0094(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::read(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD v5[5];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN14NWIOConnection4readEjjU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorE_block_invoke;
  v5[3] = &unk_1E14F7D10;
  v5[4] = a4;
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 56))(a1, 0, a2, a3, v5);
}

void NWIOConnection::readWithContext(uint64_t a1, uint64_t a2, uint32_t a3, uint32_t a4, uint64_t a5)
{
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  _QWORD v20[8];
  std::__shared_weak_count *v21;
  uint32_t v22;
  uint32_t v23;
  uint64_t v24;
  std::__shared_weak_count *v25;

  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  v24 = 0;
  v25 = 0;
  v10 = *(std::__shared_weak_count **)(a1 + 264);
  if (v10 && (v10 = std::__shared_weak_count::lock(v10), (v25 = v10) != 0))
  {
    v11 = *(_QWORD *)(a1 + 256);
    v24 = v11;
  }
  else
  {
    v11 = 0;
  }
  v20[0] = MEMORY[0x1E0C809B0];
  v20[1] = 3321888768;
  v20[2] = ___ZN14NWIOConnection15readWithContextEPU32objcproto21OS_nw_content_context8NSObjectjjU13block_pointerFvS2_PU27objcproto16OS_dispatch_dataS0_b13CFStreamErrorE_block_invoke;
  v20[3] = &unk_1E14F4660;
  v20[6] = a1;
  v20[7] = v11;
  v21 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }
  v22 = a3;
  v23 = a4;
  v20[4] = a2;
  v20[5] = a5;
  if (a2)
    nw_connection_receive_with_context();
  else
    nw_connection_receive(*(nw_connection_t *)(a1 + 272), a3, a4, v20);
  v14 = v21;
  if (v21)
  {
    v15 = (unint64_t *)&v21->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v25;
  if (v25)
  {
    v18 = (unint64_t *)&v25->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
}

void sub_183EE029C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 64);
  _Unwind_Resume(a1);
}

uint64_t ___ZN24ConnectionReadAggregator10_issueReadEv_block_invoke(uint64_t a1, dispatch_data_t data, char a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  NSObject *v11;
  size_t size;
  dispatch_data_t concat;
  NSObject *v14;

  v9 = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(*(_QWORD *)(a1 + 40) + 104) = 0;
  if (data)
  {
    v11 = *(NSObject **)(v9 + 56);
    size = dispatch_data_get_size(data);
    if (v11)
    {
      if (!size)
        goto LABEL_12;
      if (dispatch_data_get_size(v11))
      {
        concat = dispatch_data_create_concat(v11, data);
        v14 = *(NSObject **)(v9 + 56);
        *(_QWORD *)(v9 + 56) = concat;
        if (!v14)
          goto LABEL_12;
        goto LABEL_11;
      }
    }
    else if (!size)
    {
      goto LABEL_12;
    }
    dispatch_retain(data);
    v14 = *(NSObject **)(v9 + 56);
    *(_QWORD *)(v9 + 56) = data;
    if (v14)
LABEL_11:
      dispatch_release(v14);
LABEL_12:
    *(_BYTE *)(v9 + 105) = a3;
    *(_QWORD *)(v9 + 112) = a4;
    *(_QWORD *)(v9 + 120) = a5;
    return ConnectionReadAggregator::_evaluate(*(ConnectionReadAggregator **)(a1 + 40));
  }
  *(_BYTE *)(v9 + 105) = a3;
  *(_QWORD *)(v9 + 112) = a4;
  *(_QWORD *)(v9 + 120) = a5;
  if ((_DWORD)a5)
    *(_BYTE *)(v9 + 105) = 1;
  return ConnectionReadAggregator::_evaluate(*(ConnectionReadAggregator **)(a1 + 40));
}

void ConnectionReadAggregator::_invokeCB(ConnectionReadAggregator *this)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *subrange;
  unsigned int size;
  size_t v6;
  uint64_t v7;
  dispatch_data_t v8;
  NSObject *v9;
  uint64_t v10;
  void (**v11)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

  v2 = *((_QWORD *)this + 14);
  v3 = *((_QWORD *)this + 15);
  subrange = *((_QWORD *)this + 7);
  if (!subrange || (size = dispatch_data_get_size(*((dispatch_data_t *)this + 7))) == 0)
  {
    if (!*((_BYTE *)this + 105))
      __assert_rtn("_invokeCB", "ConnectionReadAggregator.mm", 232, "_readEOF");
    subrange = 0;
    goto LABEL_8;
  }
  v6 = *((unsigned int *)this + 20);
  if (v6 < size)
  {
    v7 = size;
    subrange = dispatch_data_create_subrange(subrange, 0, v6);
    v8 = dispatch_data_create_subrange(*((dispatch_data_t *)this + 7), *((unsigned int *)this + 20), v7 - *((unsigned int *)this + 20));
    v9 = *((_QWORD *)this + 7);
    *((_QWORD *)this + 7) = v8;
    if (v9)
      dispatch_release(v9);
    goto LABEL_12;
  }
  *((_QWORD *)this + 7) = 0;
  if (*((_DWORD *)this + 19) > size)
  {
    if (!*((_BYTE *)this + 105))
      __assert_rtn("_invokeCB", "ConnectionReadAggregator.mm", 222, "_readEOF");
LABEL_8:
    v10 = 1;
    goto LABEL_13;
  }
LABEL_12:
  v10 = 0;
LABEL_13:
  *((_DWORD *)this + 19) = 0;
  *((_DWORD *)this + 20) = 0;
  v11 = (void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))*((_QWORD *)this + 12);
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  ((void (**)(_QWORD, NSObject *, uint64_t, uint64_t, uint64_t))v11)[2](v11, subrange, v10, v2, v3);
  _Block_release(v11);
  if (subrange)
    dispatch_release(subrange);
}

void sub_183EE04D8(_Unwind_Exception *exception_object)
{
  NSObject *v1;

  if (v1)
    dispatch_release(v1);
  _Unwind_Resume(exception_object);
}

void ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  size_t size;
  int v4;
  uint64_t v5;
  NSObject *v6;

  v2 = a1[8];
  size = *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 40);
  if (size)
    size = dispatch_data_get_size((dispatch_data_t)size);
  *(_QWORD *)(v2 + 184) += size;
  if ((*(_BYTE *)(v2 + 33) & 0x20) != 0
    || ((v4 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 56), v4 == 57) || v4 == 54)
    && (*(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1, (*(_BYTE *)(v2 + 33) & 0x20) != 0))
  {
    v5 = *(_QWORD *)(a1[7] + 8);
    if (*(_BYTE *)(v5 + 24) && !*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 56))
    {
      *(_BYTE *)(v5 + 24) = 0;
      *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 48) = 4;
      *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 56) = -4;
    }
  }
  (*(void (**)(void))(a1[4] + 16))();
  v6 = *(NSObject **)(*(_QWORD *)(a1[5] + 8) + 40);
  if (v6)
    dispatch_release(v6);
}

void HTTPEngine::_deliverBodyBytes(HTTPEngine *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v5;
  unint64_t v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  _DWORD v13[2];
  __int16 v14;
  int v15;
  uint64_t v16;

  v5 = a4;
  v16 = *MEMORY[0x1E0C80C00];
  v9 = a4 & 0xFFFFFFFF00000000;
  if ((_DWORD)a4)
  {
    if ((*((_BYTE *)this + 34) & 6) == 0)
    {
LABEL_14:
      HTTPEngine::_readBodyFinish((uint64_t)this, a2, a3, v5 | v9, a5);
      return;
    }
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v10 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      if ((*((_DWORD *)this + 8) & 0x20000) != 0)
        v11 = 300;
      else
        v11 = 401;
      v13[0] = 67109376;
      v13[1] = v5;
      v14 = 1024;
      v15 = v11;
      _os_log_impl(&dword_183ECA000, v10, OS_LOG_TYPE_DEFAULT, "Received readError %d but saw a %d status so sending EOF", (uint8_t *)v13, 0xEu);
    }
    v5 = 0;
    a3 = 0;
LABEL_13:
    a5 = 1;
    goto LABEL_14;
  }
  if ((_DWORD)a5)
  {
    v5 = 0;
    goto LABEL_13;
  }
  HTTPEngine::_updateBytesTransferred(this);
  v12 = *((_QWORD *)this + 26);
  if (v12)
    (*(void (**)(uint64_t, uint64_t, uint64_t, unint64_t, _QWORD))(v12 + 16))(v12, a2, a3, v9, 0);
  HTTPEngine::_readBodyStartNextRead(this);
}

void HTTPEngine::_updateBytesTransferred(HTTPEngine *this)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  if (*((_QWORD *)this + 21) || *((_QWORD *)this + 35))
  {
    v2 = (std::__shared_weak_count *)*((_QWORD *)this + 11);
    if (v2)
    {
      v3 = std::__shared_weak_count::lock(v2);
      if (v3)
      {
        v4 = v3;
        v5 = *((_QWORD *)this + 10);
        if (v5)
        {
          (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v5 + 16))(v5, *((_QWORD *)this + 21), *((_QWORD *)this + 35));
          *((_QWORD *)this + 21) = 0;
          *((_QWORD *)this + 35) = 0;
        }
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v7 = __ldaxr(p_shared_owners);
        while (__stlxr(v7 - 1, p_shared_owners));
        if (!v7)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
    }
  }
}

void sub_183EE083C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t HTTPConnection::bytesTransferred(uint64_t this, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;

  if (a2)
  {
    v3 = *(_QWORD *)(this + 160);
    if (v3)
      *(_QWORD *)(v3 + 264) += a2;
  }
  if (a3)
  {
    v4 = *(_QWORD *)(this + 144);
    if (v4)
      *(_QWORD *)(v4 + 256) += a3;
  }
  return this;
}

uint64_t HTTPConnection::_onqueue_checkAndUpdateLargeDownload(uint64_t this)
{
  uint64_t v1;
  const void **v2;

  v1 = *(_QWORD *)(this + 160);
  if (v1 && *(_QWORD *)(this + 64) && (*(_WORD *)(v1 + 32) & 0x200) != 0)
  {
    *(_WORD *)(v1 + 32) &= ~0x200u;
    if ((*(_WORD *)(*(_QWORD *)(this + 160) + 32) & 0x400) != 0)
      v2 = (const void **)MEMORY[0x1E0C9AE50];
    else
      v2 = (const void **)MEMORY[0x1E0C9AE40];
    return HTTPEngine::setProperty(*(HTTPEngine **)(this + 64), (CFStringRef)&unk_1EDCFA5D0, *v2);
  }
  return this;
}

void ___ZN10HTTPEngine14_readBodyPlainEv_block_invoke(uint64_t a1, dispatch_data_t data, uint64_t a3, uint64_t a4, uint64_t a5)
{
  HTTPEngine *v9;
  uint64_t v10;
  size_t size;

  v9 = *(HTTPEngine **)(a1 + 32);
  v10 = *((_QWORD *)v9 + 41);
  if (!data)
  {
    size = 0;
    if (!v10)
      goto LABEL_4;
    goto LABEL_3;
  }
  size = dispatch_data_get_size(data);
  if (v10)
LABEL_3:
    *(_QWORD *)(v10 + 136) += size;
LABEL_4:
  HTTPEngine::_deliverBodyBytes(v9, (uint64_t)data, a3, a4, a5);
}

uint64_t HTTP3Stream::copyProperty(uint64_t a1, int a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;

  v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (!v3)
    return 0;
  v5 = std::__shared_weak_count::lock(v3);
  if (!v5)
    return 0;
  v6 = v5;
  v7 = *(_QWORD *)(a1 + 48);
  if (v7 && (v8 = *(_QWORD *)(v7 + 1008)) != 0)
  {
    v9 = MetaNetStreamInfo::applicableToPropertyName(a2);
    v10 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 216))(v8, v9);
  }
  else
  {
    v10 = 0;
  }
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  do
    v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  return v10;
}

void sub_183EE0A20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

CFNumberRef HTTP2Stream::copyProperty(_QWORD *a1, int a2)
{
  const __CFString *v3;
  int ExactString;
  const void *v5;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  _QWORD v15[2];

  v3 = (const __CFString *)MetaNetStreamInfo::applicableToPropertyName(a2);
  ExactString = _findExactString(v3, 0);
  if (ExactString == 443922397)
  {
    v7 = a1[33];
    if (v7)
      v7 = *(_QWORD *)(v7 + 96);
    v15[0] = v7;
    return CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberLongLongType, v15);
  }
  if (ExactString == 444889076)
  {
    v5 = (const void *)a1[15];
    if (v5)
      return (CFNumberRef)CFRetain(v5);
  }
  else
  {
    v9 = (std::__shared_weak_count *)a1[12];
    if (v9)
    {
      v10 = std::__shared_weak_count::lock(v9);
      v15[1] = v10;
      if (v10)
      {
        v11 = v10;
        v12 = a1[11];
        v15[0] = v12;
        if (!v12 || *(_DWORD *)v12 == 2)
        {
          v8 = 0;
        }
        else
        {
          if (*(_DWORD *)v12 != 1)
            __assert_rtn("copyProperty_offqueue", "TCPIOConnectionTest.hpp", 227, "false");
          v8 = (*(uint64_t (**)(_QWORD, const __CFString *))(**(_QWORD **)(v12 + 8) + 232))(*(_QWORD *)(v12 + 8), v3);
        }
        p_shared_owners = (unint64_t *)&v11->__shared_owners_;
        do
          v14 = __ldaxr(p_shared_owners);
        while (__stlxr(v14 - 1, p_shared_owners));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
        return (CFNumberRef)v8;
      }
    }
  }
  return 0;
}

void sub_183EE0B98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t HTTPTransaction::copyProperty(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2020000000;
  v9 = 0;
  v3 = MetaNetStreamInfo::applicableToPropertyName(a2);
  v4 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 200))(a1, v3);
  v7[3] = v4;
  _Block_object_dispose(&v6, 8);
  return v4;
}

void sub_183EE0C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t MetaNetStreamInfo::applicableToPropertyName(int a1)
{
  uint64_t *v1;
  uint64_t result;

  switch(a1)
  {
    case 1:
      v1 = &__kCFStreamPropertyApplyPreAuthentication;
      goto LABEL_42;
    case 2:
      v1 = &__kCFStreamPropertyPeerAddress;
      goto LABEL_42;
    case 3:
      v1 = &__kCFStreamPropertyDuetActivityProperties;
      goto LABEL_42;
    case 4:
      v1 = &__kCFStreamPropertyRequiresSustainedDataDelivery;
      goto LABEL_42;
    case 5:
      v1 = &__kCFStreamPropertyMultipathServiceType;
      goto LABEL_42;
    case 6:
      v1 = &__kCFStreamPropertyCompanionProxyPreference;
      goto LABEL_42;
    case 7:
      v1 = &__kCFStreamPropertyExpectedProgressTargetChanged;
      goto LABEL_42;
    case 8:
      v1 = &__kCFStreamPropertyEstimatedBytesDownloadIncrement;
      goto LABEL_42;
    case 9:
      v1 = &__kCFStreamPropertyEstimatedBytesDownloadDecrement;
      goto LABEL_42;
    case 10:
      v1 = &__kCFStreamPropertyEstimatedBytesUploadIncrement;
      goto LABEL_42;
    case 11:
      v1 = &__kCFStreamPropertyEstimatedBytesUploadDecrement;
      goto LABEL_42;
    case 12:
      v1 = &_kCFStreamPropertyConditionalRequirementsChangedBlock;
      goto LABEL_42;
    case 13:
      v1 = &_kCFStreamPropertyConnectionWaitingBlock;
      goto LABEL_42;
    case 14:
      v1 = &_kCFStreamPropertyHTTPFilterEstablishedConnectionBlock;
      goto LABEL_42;
    case 15:
      v1 = &_kCFStreamPropertyHTTPWaitForEstablishedConnection;
      goto LABEL_42;
    case 16:
      v1 = &_kCFStreamPropertyLargeDownload;
      goto LABEL_42;
    case 17:
      v1 = &_kCFStreamPropertyDependencyInfo;
      goto LABEL_42;
    case 18:
      v1 = &_kCFStreamPropertyReadTimeout;
      goto LABEL_42;
    case 19:
      v1 = &_kCFStreamPropertySSLClientCertificateState;
      goto LABEL_42;
    case 20:
      v1 = &_kCFStreamPropertySSLClientCertificates;
      goto LABEL_42;
    case 21:
      v1 = &_kCFStreamPropertySSLNegotiatedProtocol;
      goto LABEL_42;
    case 22:
      v1 = &_kCFStreamPropertySSLNegotiatedCipher;
      goto LABEL_42;
    case 23:
      v1 = &_kCFStreamPropertySSLPinningPolicyName;
      goto LABEL_42;
    case 24:
      v1 = &_kCFStreamPropertySocketImmediateBufferSize;
      goto LABEL_42;
    case 25:
      v1 = &_kCFStreamPropertySocketImmediateBufferTimeOut;
      goto LABEL_42;
    case 26:
      v1 = &_kCFStreamPropertySocketStreamInstance;
      goto LABEL_42;
    case 27:
      v1 = &_kCFStreamPropertyConnectionPoolPriority;
      goto LABEL_42;
    case 28:
      v1 = &_kCFStreamPropertyTCPInfo;
      goto LABEL_42;
    case 29:
      v1 = &_kCFStreamPropertyTCPConnectionMetadata;
      goto LABEL_42;
    case 30:
      v1 = &_kCFURLConnectionPropertyRespectConnectionClose;
      goto LABEL_42;
    case 31:
      v1 = &kCFStreamPropertyConnectionDidFallback;
      goto LABEL_42;
    case 32:
      v1 = (uint64_t *)&kCFStreamPropertyConnectionIsCellular;
      goto LABEL_42;
    case 33:
      v1 = &__kCFStreamPropertyConnectionIsCompanionLink;
      goto LABEL_42;
    case 34:
      v1 = (uint64_t *)&kCFStreamPropertyHTTPResponseHeader;
      goto LABEL_42;
    case 35:
      v1 = (uint64_t *)&kCFStreamPropertySSLPeerCertificates;
      goto LABEL_42;
    case 36:
      v1 = (uint64_t *)&kCFStreamPropertySSLPeerTrust;
      goto LABEL_42;
    case 37:
      v1 = (uint64_t *)&kCFStreamPropertySSLSettings;
      goto LABEL_42;
    case 38:
      v1 = &__kCFStreamPropertyMultipathAlternatePort;
      goto LABEL_42;
    case 39:
      v1 = &__kCFStreamPropertyResolvedCNAMEChain;
LABEL_42:
      result = *v1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

CFNumberRef HTTPTransaction::_onqueue_copyProperty(HTTPTransaction *this, CFStringRef theString)
{
  int ExactString;
  uint64_t v5;
  CFTypeRef v6;
  CFTypeRef *v7;
  uint64_t v8;
  const void *Value;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  HTTPEngine *v14;
  unint64_t *p_shared_owners;
  unint64_t v17;
  _QWORD v18[2];

  ExactString = _findExactString(theString, 0);
  switch(ExactString)
  {
    case 406214149:
      if ((*((_WORD *)this + 16) & 0x800) != 0)
        v7 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
      else
        v7 = (CFTypeRef *)MEMORY[0x1E0C9AE40];
      if (*v7)
        return (CFNumberRef)CFRetain(*v7);
      return 0;
    case 444889076:
      return 0;
    case 443922397:
      v5 = *((_QWORD *)this + 24);
      if (v5)
        v5 = *(_QWORD *)(v5 + 96);
      v18[0] = v5;
      return CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberLongLongType, v18);
  }
  v8 = *((_QWORD *)this + 13);
  if (!v8
    || (Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v8 + 8), theString)) == 0
    || (v6 = CFRetain(Value)) == 0)
  {
    v10 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
    if (v10)
    {
      v11 = std::__shared_weak_count::lock(v10);
      v18[1] = v11;
      if (v11)
      {
        v12 = v11;
        v13 = *((_QWORD *)this + 7);
        v18[0] = v13;
        if (v13 && (_findExactString(theString, 0), (v14 = *(HTTPEngine **)(v13 + 64)) != 0))
          v6 = HTTPEngine::copyProperty(v14, theString);
        else
          v6 = 0;
        p_shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          v17 = __ldaxr(p_shared_owners);
        while (__stlxr(v17 - 1, p_shared_owners));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
        return (CFNumberRef)v6;
      }
    }
    return 0;
  }
  return (CFNumberRef)v6;
}

void sub_183EE0FBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

CFNumberRef NWIOConnection::copyProperty(NWIOConnection *this, const __CFString *a2)
{
  void *Value;
  _BOOL4 v5;
  _BOOL4 v6;
  CFTypeID v7;
  const __CFAllocator *v8;
  void *Copy;
  int ExactString;
  int v11;
  const __CFAllocator *v12;
  NSObject *v13;
  const sockaddr *address;
  const __CFAllocator *v15;
  NSObject *v16;
  int is_expensive;
  NSObject *v18;
  const sockaddr *v19;
  int sa_family;
  const __CFAllocator *v21;
  void **v22;
  void *v23;
  int v24;
  NSObject *v25;
  const __CFAllocator *v26;
  NSObject *v27;
  NSObject *v28;
  const char *name;
  const void *v30;
  const void *v31;
  _QWORD *v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  void *v39;
  NSObject *v40;
  NSObject *v41;
  const char *v42;
  void **v43;
  BOOL v44;
  NSObject *v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  CFMutableArrayRef Mutable;
  _QWORD *v56;
  unint64_t *v57;
  unint64_t v58;
  CFIndex Count;
  uint64_t v60;
  _QWORD v61[2];
  _QWORD v62[3];
  _QWORD v63[3];
  __int128 valuePtr;
  uint64_t v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  Value = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), a2);
  if (Value)
    goto LABEL_2;
  ExactString = _findExactString(a2, 0);
  if (ExactString <= 139782658)
  {
    if (ExactString > 85255704)
    {
      if (ExactString > 124045534)
      {
        if (ExactString <= 130378060)
        {
          if (ExactString == 124045535)
            return (CFNumberRef)TransportConnection::_createRefCountedWrapper((TransportConnection *)this);
          if (ExactString != 129296697)
            return (CFNumberRef)Value;
          v5 = 0;
          Value = (void *)*((_QWORD *)this + 64);
          goto LABEL_3;
        }
        if (ExactString == 130378061)
          return CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (char *)this + 528);
        if (ExactString != 132442490)
          return (CFNumberRef)Value;
        if ((*((_WORD *)this + 124) & 0x800) == 0)
          return 0;
        Value = (void *)*((_QWORD *)this + 62);
        if (!Value)
          return (CFNumberRef)Value;
        goto LABEL_2;
      }
      if (ExactString == 85255705)
      {
LABEL_95:
        v25 = *((_QWORD *)this + 42);
        if (!v25)
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v45 = CFNLog::logger;
          if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
            return 0;
          v46 = *((_QWORD *)this + 36);
          LODWORD(valuePtr) = 134217984;
          *(_QWORD *)((char *)&valuePtr + 4) = v46;
          v47 = "Connection %llu: unable to determine interface classification without an established connection";
          goto LABEL_197;
        }
        is_expensive = nw_path_is_expensive(v25);
        goto LABEL_136;
      }
      if (ExactString == 88393301)
      {
        valuePtr = 0uLL;
        v65 = 0;
        if (*((_QWORD *)this + 34) && nw_connection_fillout_tcp_statistics())
        {
          v62[0] = CFSTR("_kCFStreamStatsDNS_ResolutionTimeMs");
          v63[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", valuePtr);
          v62[1] = CFSTR("_kCFStreamStatsConnectionEstablishmentTimeMs");
          v63[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", DWORD2(valuePtr));
          v62[2] = CFSTR("_kCFStreamStatsTLS_HandshakeTimeMs");
          v63[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v65);
          v39 = (void *)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v63, v62, 3);
          Value = v39;
          if (v39)
            CFRetain(v39);
          v6 = 0;
        }
        else
        {
          Value = 0;
          v6 = 1;
        }
        v5 = 0;
        goto LABEL_4;
      }
      if (ExactString != 99878707)
        return (CFNumberRef)Value;
      if (*((int *)this + 34) < 3 || *((_QWORD *)this + 34) && nw_connection_better_path_available())
      {
        v5 = 0;
        v22 = (void **)MEMORY[0x1E0C9AE50];
        goto LABEL_109;
      }
      goto LABEL_62;
    }
    if (ExactString <= 52716449)
    {
      if (ExactString == 17121436)
      {
        v34 = *((_QWORD *)this + 44);
        if (!v34)
          return 0;
        if (nw_endpoint_get_type(v34) != nw_endpoint_type_address)
          return 0;
        v35 = *((_QWORD *)this + 42);
        if (!v35)
          return 0;
        (*(void (**)(__int128 *__return_ptr, NWIOConnection *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)this
                                                                                                  + 400))(&valuePtr, this, v35, *((_QWORD *)this + 44), 0);
        if ((_QWORD)valuePtr)
        {
          Value = (void *)CFRetain((CFTypeRef)valuePtr);
          v31 = (const void *)valuePtr;
          *(_QWORD *)&valuePtr = 0;
          if (!v31)
            goto LABEL_165;
          goto LABEL_104;
        }
LABEL_164:
        Value = 0;
        goto LABEL_165;
      }
      if (ExactString != 29721049)
      {
        if (ExactString != 31695365)
          return (CFNumberRef)Value;
        v5 = 0;
        if ((*((_WORD *)this + 124) & 0x80) != 0)
          v22 = (void **)MEMORY[0x1E0C9AE50];
        else
          v22 = (void **)MEMORY[0x1E0C9AE40];
LABEL_109:
        Value = *v22;
        goto LABEL_3;
      }
      if (!*((_QWORD *)this + 42))
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v45 = CFNLog::logger;
        if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
          return 0;
        v54 = *((_QWORD *)this + 36);
        LODWORD(valuePtr) = 134217984;
        *(_QWORD *)((char *)&valuePtr + 4) = v54;
        v47 = "Connection %llu: unable to determine interface classification without an established connection";
        goto LABEL_197;
      }
      is_expensive = nw_path_uses_interface_subtype();
    }
    else
    {
      if (ExactString <= 65242280)
      {
        if (ExactString != 52716450)
        {
          if (ExactString != 56869868)
            return (CFNumberRef)Value;
          v13 = *((_QWORD *)this + 44);
          if (v13 && nw_endpoint_get_type(v13) == nw_endpoint_type_address)
          {
            address = nw_endpoint_get_address(*((nw_endpoint_t *)this + 44));
            v5 = address != 0;
            if (address)
              Value = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &address->sa_len, address->sa_len);
            else
              Value = 0;
            v6 = address == 0;
LABEL_4:
            if (v6 && Value)
            {
              v7 = CFGetTypeID(Value);
              if (v7 == CFDictionaryGetTypeID())
              {
                v8 = CFGetAllocator(Value);
                Copy = CFDictionaryCreateCopy(v8, (CFDictionaryRef)Value);
              }
              else if (v7 == CFArrayGetTypeID())
              {
                v12 = CFGetAllocator(Value);
                Copy = CFArrayCreateCopy(v12, (CFArrayRef)Value);
              }
              else
              {
                if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
                  dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
                if (v7 == *(_QWORD *)(HTTPMessage::Class(void)::sClass_OBJTYPE + 96))
                {
                  v15 = CFGetAllocator(Value);
                  Copy = CFHTTPMessageCreateCopy(v15, (CFHTTPMessageRef)Value);
                }
                else
                {
                  if (HostBase::Class(void)::sOnce_HostBase != -1)
                    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
                  if (v7 == *(_QWORD *)(HostBase::Class(void)::sClass_OBJTYPE + 96))
                  {
                    v21 = CFGetAllocator(Value);
                    Copy = CFHostCreateCopy(v21, (CFHostRef)Value);
                  }
                  else if (v7 == CFNetServiceGetTypeID())
                  {
                    v26 = CFGetAllocator(Value);
                    Copy = CFNetServiceCreateCopy(v26, (CFNetServiceRef)Value);
                  }
                  else
                  {
                    Copy = (void *)CFRetain(Value);
                  }
                }
              }
              Value = Copy;
            }
            goto LABEL_145;
          }
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v45 = CFNLog::logger;
          if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
            return 0;
          v48 = *((_QWORD *)this + 36);
          LODWORD(valuePtr) = 134217984;
          *(_QWORD *)((char *)&valuePtr + 4) = v48;
          v47 = "Connection %llu: unable to determine peer address without an established connection";
          goto LABEL_197;
        }
        NWIOConnection::_copyNetworkSignature((uint64_t)&valuePtr, (uint64_t)this);
        v30 = (const void *)valuePtr;
        if ((_QWORD)valuePtr)
        {
          Value = (void *)CFRetain((CFTypeRef)valuePtr);
          v31 = v30;
LABEL_104:
          CFRelease(v31);
          goto LABEL_165;
        }
        goto LABEL_164;
      }
      if (ExactString != 65242281)
      {
        if (ExactString != 69510391)
          return (CFNumberRef)Value;
        if (*((_QWORD *)this + 44))
        {
          v23 = (void *)nw_endpoint_copy_proxy_original_endpoint();
          if (!v23)
          {
            if (*((_QWORD *)this + 34) && nw_connection_get_privacy_stance() == 2)
              return 0;
            Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
            *(_QWORD *)&valuePtr = Mutable;
            v56 = (_QWORD *)operator new();
            v56[1] = 0;
            v57 = v56 + 1;
            *v56 = &off_1E14F1978;
            v56[2] = 0;
            v56[3] = Mutable;
            *((_QWORD *)&valuePtr + 1) = v56;
            v61[0] = Mutable;
            v61[1] = v56;
            do
              v58 = __ldxr(v57);
            while (__stxr(v58 + 1, v57));
            nw_endpoint_enumerate_cnames();
            Count = CFArrayGetCount((CFArrayRef)valuePtr);
            v6 = Count < 1;
            if (Count >= 1 && (_QWORD)valuePtr)
              Value = (void *)CFRetain((CFTypeRef)valuePtr);
            else
              Value = 0;
            std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v61);
            std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&valuePtr);
LABEL_204:
            v5 = 1;
            goto LABEL_4;
          }
          nw_release(v23);
          return 0;
        }
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v45 = CFNLog::logger;
        if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
          return 0;
        v51 = *((_QWORD *)this + 36);
        LODWORD(valuePtr) = 134217984;
        *(_QWORD *)((char *)&valuePtr + 4) = v51;
        v47 = "Connection %llu: unable to determine peer CNAME chain without an established connection";
LABEL_197:
        _os_log_debug_impl(&dword_183ECA000, v45, OS_LOG_TYPE_DEBUG, v47, (uint8_t *)&valuePtr, 0xCu);
        return 0;
      }
      if (*((int *)this + 34) < 3 || !*((_QWORD *)this + 34))
        return 0;
      is_expensive = NWIOConnection::_isQUICTransport(this);
    }
LABEL_136:
    v43 = (void **)MEMORY[0x1E0C9AE50];
    if (!is_expensive)
      v43 = (void **)MEMORY[0x1E0C9AE40];
    Value = *v43;
    v5 = 1;
    goto LABEL_3;
  }
  if (ExactString <= 206868128)
  {
    if (ExactString > 194301360)
    {
      if (ExactString <= 198495749)
      {
        if (ExactString != 194301361)
        {
          if (ExactString != 197438963)
            return (CFNumberRef)Value;
          v16 = *((_QWORD *)this + 42);
          if (!v16)
          {
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v45 = CFNLog::logger;
            if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
              return 0;
            v50 = *((_QWORD *)this + 36);
            LODWORD(valuePtr) = 134217984;
            *(_QWORD *)((char *)&valuePtr + 4) = v50;
            v47 = "Connection %llu: unable to determine interface type without an established connection";
            goto LABEL_197;
          }
          is_expensive = nw_path_uses_interface_type(v16, nw_interface_type_cellular);
          goto LABEL_136;
        }
        if (!*((_QWORD *)this + 34))
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v45 = CFNLog::logger;
          if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
            return 0;
          v53 = *((_QWORD *)this + 36);
          LODWORD(valuePtr) = 134217984;
          *(_QWORD *)((char *)&valuePtr + 4) = v53;
          v47 = "Connection %llu: unable to determine fallback status without a connection";
          goto LABEL_197;
        }
        v24 = nw_connection_used_fallback();
        v5 = v24;
        goto LABEL_107;
      }
      if (ExactString != 198495750)
      {
        if (ExactString != 199544346)
          return (CFNumberRef)Value;
        if (!*((_QWORD *)this + 34))
          return 0;
        v24 = nw_connection_uses_multipath();
        v5 = 0;
LABEL_107:
        v22 = (void **)MEMORY[0x1E0C9AE50];
        if (!v24)
          v22 = (void **)MEMORY[0x1E0C9AE40];
        goto LABEL_109;
      }
      goto LABEL_95;
    }
    if (ExactString == 139782659)
    {
      if (*((_QWORD *)this + 34))
      {
        v36 = nw_connection_copy_metadata();
        if (v36)
        {
          v37 = (void *)v36;
          v38 = _CFXPCCreateCFObjectFromXPCObject();
          xpc_release(v37);
          return (CFNumberRef)v38;
        }
      }
      return 0;
    }
    if (ExactString == 140716567)
    {
      v33 = -[__CFN_ConnectionMetrics tcpInfo](*((os_unfair_lock_s **)this + 25));
      return (CFNumberRef)v33;
    }
    if (ExactString != 143911500)
      return (CFNumberRef)Value;
LABEL_62:
    v5 = 0;
    v22 = (void **)MEMORY[0x1E0C9AE40];
    goto LABEL_109;
  }
  if (ExactString > 211103476)
  {
    if (ExactString <= 229937220)
    {
      if (ExactString != 211103477)
      {
        if (ExactString != 222621637)
          return (CFNumberRef)Value;
        v18 = *((_QWORD *)this + 44);
        if (v18 && nw_endpoint_get_type(v18) == nw_endpoint_type_address)
        {
          v19 = nw_endpoint_get_address(*((nw_endpoint_t *)this + 44));
          if (v19)
          {
            sa_family = v19->sa_family;
            if (sa_family != 30 && sa_family != 2)
            {
              v5 = 0;
              Value = 0;
              goto LABEL_3;
            }
            LODWORD(valuePtr) = bswap32(*(unsigned __int16 *)v19->sa_data) >> 16;
            Value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
            v6 = 0;
            goto LABEL_204;
          }
          return 0;
        }
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v45 = CFNLog::logger;
        if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
          return 0;
        v49 = *((_QWORD *)this + 36);
        LODWORD(valuePtr) = 134217984;
        *(_QWORD *)((char *)&valuePtr + 4) = v49;
        v47 = "Connection %llu: unable to determine port without an established connection";
        goto LABEL_197;
      }
      v33 = -[__CFN_ConnectionMetrics subflowCounts](*((os_unfair_lock_s **)this + 25));
      return (CFNumberRef)v33;
    }
    if (ExactString == 229937221)
    {
      if ((*((_WORD *)this + 124) & 0x800) == 0)
        return 0;
      Value = (void *)*((_QWORD *)this + 60);
      if (!Value)
        return (CFNumberRef)Value;
    }
    else
    {
      if (ExactString != 230928472)
        return (CFNumberRef)Value;
      if ((*((_WORD *)this + 124) & 0x800) == 0)
        return 0;
      Value = (void *)*((_QWORD *)this + 56);
      if (!Value)
        return (CFNumberRef)Value;
    }
LABEL_2:
    v5 = 0;
LABEL_3:
    v6 = 1;
    goto LABEL_4;
  }
  if (ExactString <= 209071817)
  {
    if (ExactString != 206868129)
    {
      v11 = 207974068;
      goto LABEL_72;
    }
    if (*((_QWORD *)this + 42))
    {
      v27 = nw_path_copy_interface();
      if (v27)
      {
        v28 = v27;
        name = nw_interface_get_name(v27);
        Value = (void *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], name, 0x8000100u);
        nw_release(v28);
LABEL_165:
        v5 = 1;
LABEL_145:
        if (Value)
          v44 = !v5;
        else
          v44 = 1;
        if (!v44)
          CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), a2, Value);
        return (CFNumberRef)Value;
      }
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v45 = CFNLog::logger;
      if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
        return 0;
      v60 = *((_QWORD *)this + 36);
      LODWORD(valuePtr) = 134217984;
      *(_QWORD *)((char *)&valuePtr + 4) = v60;
      v47 = "Connection %llu: unable to obtain interface from established connection";
    }
    else
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v45 = CFNLog::logger;
      if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
        return 0;
      v52 = *((_QWORD *)this + 36);
      LODWORD(valuePtr) = 134217984;
      *(_QWORD *)((char *)&valuePtr + 4) = v52;
      v47 = "Connection %llu: unable to determine interface without an established connection";
    }
    goto LABEL_197;
  }
  if (ExactString != 209071818)
  {
    v11 = 209997539;
LABEL_72:
    if (ExactString == v11)
    {
      *(_QWORD *)&valuePtr = 0;
      if (*((_QWORD *)this + 34))
        *(_QWORD *)&valuePtr = nw_connection_multipath_get_subflow_count();
      return CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberCFIndexType, &valuePtr);
    }
    return (CFNumberRef)Value;
  }
  if (!*((_QWORD *)this + 34))
    return 0;
  nw_connection_multipath_get_primary_subflow_interface_index();
  v40 = nw_interface_create_with_index();
  if (!v40)
    return 0;
  v41 = v40;
  v42 = nw_interface_get_name(v40);
  Value = (void *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v42, 0x8000100u);
  nw_release(v41);
  return (CFNumberRef)Value;
}

void sub_183EE1E6C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 - 80);
  *(_QWORD *)(v1 - 80) = 0;
  if (v3)
    CFRelease(v3);
  _Unwind_Resume(exception_object);
}

CFTypeRef HTTPEngine::copyProperty(HTTPEngine *this, CFStringRef theString)
{
  int ExactString;
  uint64_t v5;
  NSObject *v7;
  CFTypeRef *v8;

  ExactString = _findExactString(theString, 0);
  if (ExactString == 31695365)
  {
    if ((*((_BYTE *)this + 32) & 2) != 0)
      goto LABEL_11;
    goto LABEL_7;
  }
  if (ExactString == 396711238)
  {
    v7 = *((_QWORD *)this + 24);
    if (!v7 || !dispatch_data_get_size(v7))
      goto LABEL_12;
LABEL_11:
    v8 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
    goto LABEL_13;
  }
  if (ExactString != 400823713)
  {
LABEL_7:
    v5 = *((_QWORD *)this + 7);
    if (v5)
      return (CFTypeRef)(*(uint64_t (**)(uint64_t, CFStringRef))(*(_QWORD *)v5 + 216))(v5, theString);
    return 0;
  }
  if ((*((_BYTE *)this + 32) & 0x10) != 0)
    goto LABEL_11;
LABEL_12:
  v8 = (CFTypeRef *)MEMORY[0x1E0C9AE40];
LABEL_13:
  if (*v8)
    return CFRetain(*v8);
  return 0;
}

uint64_t NWIOConnection::copyProperty_offqueue(NWIOConnection *this, const __CFString *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v7 = 0;
  v2 = (*(uint64_t (**)(NWIOConnection *, const __CFString *))(*(_QWORD *)this + 216))(this, a2);
  v5[3] = v2;
  _Block_object_dispose(&v4, 8);
  return v2;
}

void sub_183EE2004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

void HTTPConnection::_onqueue_responseDataArrived(HTTPConnection *this, dispatch_object_t object, CFStreamError a3, unsigned int a4)
{
  uint64_t v5;
  CFIndex domain;
  std::__shared_weak_count *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  HTTPEngine *v25;
  int v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  NSObject *v35;
  int v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  const char *v42;
  int v43;
  const char *v44;
  std::__shared_weak_count *v45;
  uint64_t v46;
  std::__shared_weak_count *v47;
  uint64_t v48;
  std::__shared_weak_count *v49;
  uint64_t v50;
  std::__shared_weak_count *v51;
  uint64_t v52;
  std::__shared_weak_count *v53;
  CFStreamError v54;

  v5 = *(_QWORD *)&a3.error;
  domain = a3.domain;
  v48 = 0;
  v49 = 0;
  v9 = (std::__shared_weak_count *)*((_QWORD *)this + 11);
  if (!v9)
    goto LABEL_8;
  v49 = std::__shared_weak_count::lock(v9);
  if (!v49)
    goto LABEL_8;
  v10 = *((_QWORD *)this + 10);
  v48 = v10;
  if (!v10)
    goto LABEL_8;
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v46, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v10 + 32))(v10, &v46);
  v11 = v47;
  if (!v47)
    goto LABEL_8;
  p_shared_owners = (unint64_t *)&v47->__shared_owners_;
  do
    v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
    if ((_DWORD)v5)
      goto LABEL_9;
  }
  else
  {
LABEL_8:
    if ((_DWORD)v5)
    {
LABEL_9:
      v54.domain = domain;
      *(_QWORD *)&v54.error = v5;
      HTTPConnection::_onqueue_errorOccurred(this, v54, a4);
      if ((a4 & 1) == 0)
        goto LABEL_61;
      v15 = *((_QWORD *)this + 20);
      v14 = (std::__shared_weak_count *)*((_QWORD *)this + 21);
      v45 = v14;
      if (v14)
      {
        v16 = (unint64_t *)&v14->__shared_owners_;
        do
          v17 = __ldxr(v16);
        while (__stxr(v17 + 1, v16));
      }
      goto LABEL_20;
    }
  }
  v15 = *((_QWORD *)this + 20);
  if (!v15)
    __assert_rtn("_onqueue_responseDataArrived", "HTTPConnection.cpp", 1511, "_currentResponse");
  v18 = (std::__shared_weak_count *)*((_QWORD *)this + 21);
  v45 = v18;
  if (v18)
  {
    v19 = (unint64_t *)&v18->__shared_owners_;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  if ((a4 & 1) != 0)
  {
LABEL_20:
    v21 = *((unsigned __int16 *)this + 16);
    ++*((_QWORD *)this + 29);
    v22 = v21 | (*((unsigned __int8 *)this + 34) << 16);
    if ((v21 & 8) != 0)
      v23 = 16769013;
    else
      v23 = 16769023;
    v24 = v22 & v23;
    *((_WORD *)this + 16) = v24;
    if (*((_QWORD *)this + 20) == *((_QWORD *)this + 18))
    {
      *((_BYTE *)this + 34) = BYTE2(v24);
      *((_WORD *)this + 16) = v24 | 0x4000;
    }
    else
    {
      if ((v22 & 0x40) != 0 && (v22 & 0x100) == 0)
      {
        v25 = (HTTPEngine *)*((_QWORD *)this + 8);
        if (v25)
        {
          *((_BYTE *)this + 34) = BYTE2(v24);
          *((_WORD *)this + 16) = v24 | 0x100;
          HTTPEngine::_cleanupConnection(v25, 0);
        }
      }
      HTTPConnection::_onqueue_advanceCurrentResponse(this);
      if (*((_QWORD *)this + 20))
      {
        if (*((_QWORD *)this + 8))
        {
          v26 = *((unsigned __int16 *)this + 16);
          if ((v26 & 0x100) == 0)
          {
            if (((v26 | (*((unsigned __int8 *)this + 34) << 16)) & 0x20004) == 0x20000)
              HTTPConnection::_onqueue_attemptNextResponse(this);
            else
              HTTPConnection::_onqueue_attemptNextRequest(this);
          }
        }
      }
    }
    v52 = 0;
    v53 = 0;
    v27 = (std::__shared_weak_count *)*((_QWORD *)this + 11);
    if (v27)
    {
      v53 = std::__shared_weak_count::lock(v27);
      if (v53)
      {
        v28 = *((_QWORD *)this + 10);
        v52 = v28;
        if (v28)
        {
          std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v50, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
          (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v28 + 24))(v28, &v50);
          v29 = v51;
          if (v51)
          {
            v30 = (unint64_t *)&v51->__shared_owners_;
            do
              v31 = __ldaxr(v30);
            while (__stlxr(v31 - 1, v30));
            if (!v31)
            {
              ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
              std::__shared_weak_count::__release_weak(v29);
            }
          }
        }
      }
    }
    v32 = v53;
    if (v53)
    {
      v33 = (unint64_t *)&v53->__shared_owners_;
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
  }
  if (*(_DWORD *)(v15 + 80) != 7)
  {
    v42 = "_state == State::ReceivingResponse";
    v43 = 454;
    v44 = "consumeData";
    goto LABEL_69;
  }
  if (!object)
  {
LABEL_51:
    if (!a4)
      goto LABEL_56;
    goto LABEL_52;
  }
  v35 = *(NSObject **)(v15 + 232);
  if (v35)
  {
    *(_QWORD *)(v15 + 232) = dispatch_data_create_concat(*(dispatch_data_t *)(v15 + 232), object);
    dispatch_release(v35);
    goto LABEL_51;
  }
  *(_QWORD *)(v15 + 232) = object;
  dispatch_retain(object);
  if (!a4)
    goto LABEL_56;
LABEL_52:
  v36 = *(_DWORD *)(v15 + 80);
  if (v36 != 11)
  {
    if (v36 < 9)
    {
      *(_DWORD *)(v15 + 80) = 8;
      goto LABEL_56;
    }
    v42 = "newState >= _state";
    v43 = 1664;
    v44 = "_onqueue_changeState";
LABEL_69:
    __assert_rtn(v44, "HTTPTransaction.cpp", v43, v42);
  }
LABEL_56:
  HTTPTransaction::_onqueue_invokeHandler((HTTPTransaction *)v15);
  if (v45)
  {
    v37 = (unint64_t *)&v45->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
LABEL_61:
  v39 = v49;
  if (v49)
  {
    v40 = (unint64_t *)&v49->__shared_owners_;
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
}

void sub_183EE2410(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a15);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void HTTPConnectionCacheEntry::connActivityOccurred(_QWORD *a1, uint64_t *a2)
{
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  _QWORD v22[6];
  std::__shared_weak_count *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;

  v26 = 0;
  v27 = 0;
  v4 = (std::__shared_weak_count *)a1[6];
  if (v4 && (v4 = std::__shared_weak_count::lock(v4), (v27 = v4) != 0))
  {
    v5 = a1[5];
    v26 = v5;
  }
  else
  {
    v5 = 0;
  }
  v6 = a1[8];
  v22[0] = MEMORY[0x1E0C809B0];
  v22[1] = 3321888768;
  v22[2] = ___ZN24HTTPConnectionCacheEntry20connActivityOccurredENSt3__110shared_ptrI14HTTPConnectionEE_block_invoke;
  v22[3] = &__block_descriptor_72_e8_40c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE56c52_ZTSNSt3__110shared_ptrI24HTTPConnectionCacheEntryEE_e5_v8__0l;
  v8 = *a2;
  v7 = (std::__shared_weak_count *)a2[1];
  v22[4] = a1;
  v22[5] = v8;
  v23 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v24 = v5;
  v25 = v4;
  if (v4)
  {
    v11 = (unint64_t *)&v4->__shared_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v22);
  v13 = v25;
  if (v25)
  {
    v14 = (unint64_t *)&v25->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = v23;
  if (v23)
  {
    v17 = (unint64_t *)&v23->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = v27;
  if (v27)
  {
    v20 = (unint64_t *)&v27->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
}

void sub_183EE25F8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3 - 48);
  _Unwind_Resume(a1);
}

void HTTPTransaction::_onqueue_invokeHandler(HTTPTransaction *this)
{
  void (**v2)(_QWORD, _QWORD);
  uint64_t v3;
  __int16 v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  void *v8;
  const void *v9;
  __int16 v10;
  char *v11;
  NSObject *v12;
  void (**v13)(void *, uint64_t, NSObject *, char *);
  void (**v14)(void *, uint64_t, _QWORD, char *);

  v2 = (void (**)(_QWORD, _QWORD))*((_QWORD *)this + 30);
  if (v2)
  {
    v3 = *((_QWORD *)this + 27);
    if (v3 && *(_DWORD *)(v3 + 40))
    {
      *((_QWORD *)this + 30) = 0;
      if (*((_BYTE *)this + 249))
        v2[2](v2, *((unsigned __int8 *)this + 248));
      _Block_release(v2);
    }
    else
    {
      *((_WORD *)this + 16) |= 0x80u;
    }
  }
  v4 = *((_WORD *)this + 16);
  if ((v4 & 4) != 0)
  {
    v5 = *((_QWORD *)this + 27);
    if (!v5 || !*(_DWORD *)(v5 + 40))
    {
      v10 = v4 | 0x100;
      goto LABEL_17;
    }
    if ((v4 & 8) != 0)
      return;
    v6 = *((_DWORD *)this + 20);
    v7 = *((_QWORD *)this + 22);
    if (v6 < 8)
    {
      if (!v7)
        return;
    }
    else if (!v7)
    {
      if (*((_BYTE *)this + 249))
      {
        v8 = _Block_copy(*((const void **)this + 28));
        (*((void (**)(void *, _QWORD, _QWORD, char *))v8 + 2))(v8, 0, 0, (char *)this + 88);
        v9 = v8;
LABEL_32:
        _Block_release(v9);
        v4 = *((_WORD *)this + 16);
        goto LABEL_33;
      }
      goto LABEL_33;
    }
    if (*((_DWORD *)this + 24))
      v11 = (char *)this + 88;
    else
      v11 = 0;
    v12 = *((_QWORD *)this + 29);
    if (v12)
    {
      *((_QWORD *)this + 29) = 0;
      if (*((_BYTE *)this + 249))
      {
        v13 = (void (**)(void *, uint64_t, NSObject *, char *))_Block_copy(*((const void **)this + 28));
        v13[2](v13, *((_QWORD *)this + 22) - 16, v12, v11);
        _Block_release(v13);
      }
      dispatch_release(v12);
      v6 = *((_DWORD *)this + 20);
    }
    if (v6 >= 8)
    {
      v4 = *((_WORD *)this + 16);
      if ((v4 & 0x40) != 0)
      {
        if (*((_BYTE *)this + 249))
        {
          v14 = (void (**)(void *, uint64_t, _QWORD, char *))_Block_copy(*((const void **)this + 28));
          v14[2](v14, *((_QWORD *)this + 22) - 16, 0, v11);
          v9 = v14;
          goto LABEL_32;
        }
LABEL_33:
        v10 = v4 | 8;
        goto LABEL_17;
      }
      v10 = v4 | 0x10;
LABEL_17:
      *((_WORD *)this + 16) = v10;
    }
  }
}

void ___ZN12HTTPProtocol10openStreamEv_block_invoke_3(uint64_t a1, uint64_t a2, NSObject *a3, CFStreamError *a4)
{
  uint64_t v5;

  v5 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v5 + 272) == *(_QWORD *)(a1 + 40))
    HTTPProtocol::handleStreamEvent(v5, a2, a3, a4);
}

void HTTPProtocol::handleStreamEvent(uint64_t a1, uint64_t a2, NSObject *concat, CFStreamError *a4)
{
  const void *v8;
  uint64_t v9;
  unint64_t v10;
  void *v11;
  uint64_t v12;
  const void *v13;
  const void *v14;
  CFTypeRef v15;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  HTTPProtocol *v20;
  __CFHTTPMessage *v21;
  NSObject *v22;
  unint64_t v23;
  NSObject *v24;
  CFIndex v25;
  CFStreamError v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = (const void *)(a1 - 16);
  CFRetain((CFTypeRef)(a1 - 16));
  *(CFAbsoluteTime *)(a1 + 32) = CFAbsoluteTimeGetCurrent();
  if (!*(_QWORD *)(a1 + 472))
  {
    v9 = *(_QWORD *)(a1 + 272);
    if (v9)
      v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 32))(v9, 2);
    *(_QWORD *)(a1 + 472) = v9;
  }
  HTTPProtocol::handleCellularResponseInfo((HTTPProtocol *)a1);
  v10 = *(unsigned int *)(a1 + 192) | ((unint64_t)*(unsigned __int16 *)(a1 + 196) << 32);
  if ((v10 & 0x80000000000) == 0)
  {
    *(_DWORD *)(a1 + 192) = *(_DWORD *)(a1 + 192);
    *(_WORD *)(a1 + 196) = (v10 | 0x80000000000) >> 32;
    v11 = *(void **)(a1 + 80);
    if (v11)
    {
      v12 = *(_QWORD *)(a1 + 272);
      if (v12)
      {
        v13 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v12 + 32))(v12, 39);
        objc_msgSend(v11, "set_resolvedCNAMEChain:", v13);
        if (v13)
          CFRelease(v13);
      }
    }
  }
  if (a4)
  {
    HTTPProtocol::streamError((HTTPProtocol *)a1, a4);
    goto LABEL_12;
  }
  if ((*(_DWORD *)(a1 + 192) & 2) != 0)
  {
    if (a2 && *(_QWORD *)(a1 + 208))
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v14 = *(const void **)(a2 + 128);
      if (v14)
      {
        v15 = CFRetain(v14);
        if (v15)
        {
          v16 = v15;
          v17 = *(_QWORD *)(objc_msgSend(*(id *)(a1 + 208), "_inner") + 88);
          if (v17)
            v18 = v17 - 16;
          else
            v18 = 0;
          if (v17)
          {
            if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
              dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
            HTTPMessage::setTrailerFields((HTTPMessage *)(v18 + 16), v16);
          }
          CFRelease(v16);
        }
      }
    }
    v19 = 1;
  }
  else
  {
    if (a2)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (*(_QWORD *)(a2 + 104) || *(int *)(a2 + 72) < 2)
      {
        v26.domain = 4;
        v26.error = -1;
        HTTPProtocol::streamError((HTTPProtocol *)a1, &v26);
        if (*(_DWORD *)(a1 + 732) != 1)
          goto LABEL_12;
        goto LABEL_40;
      }
      v20 = (HTTPProtocol *)a1;
      v21 = (__CFHTTPMessage *)a2;
    }
    else
    {
      v20 = (HTTPProtocol *)a1;
      v21 = 0;
    }
    v19 = HTTPProtocol::performHeaderRead(v20, v21);
  }
  if (*(_DWORD *)(a1 + 732) == 1)
  {
LABEL_40:
    if (concat)
    {
      v22 = *(NSObject **)(a1 + 720);
      if (v22)
      {
        concat = dispatch_data_create_concat(v22, concat);
        dispatch_release(*(dispatch_object_t *)(a1 + 720));
      }
      else
      {
        dispatch_retain(concat);
      }
      *(_QWORD *)(a1 + 720) = concat;
    }
    else
    {
      *(_DWORD *)(a1 + 732) = 2;
      v23 = *(unsigned int *)(a1 + 192) | ((unint64_t)*(unsigned __int16 *)(a1 + 196) << 32);
      if ((v23 & 0x40000000000) != 0 && *(_BYTE *)(a1 + 856) || (v23 & 0x200000000000) != 0 && *(_BYTE *)(a1 + 857))
        HTTPProtocol::deliverUnhandledResponse((HTTPProtocol *)a1);
    }
    goto LABEL_12;
  }
  if (v19)
  {
    if (concat)
    {
      HTTPProtocol::bytesAvailable(a1, concat);
    }
    else
    {
      if (*(_QWORD *)(a1 + 792))
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v24 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          v25 = *(_QWORD *)(a1 + 792);
          LODWORD(v26.domain) = 138543362;
          *(CFIndex *)((char *)&v26.domain + 4) = v25;
          _os_log_impl(&dword_183ECA000, v24, OS_LOG_TYPE_DEFAULT, "%{public}@ response ended", (uint8_t *)&v26, 0xCu);
        }
      }
      HTTPProtocol::endEncountered((HTTPProtocol *)a1);
    }
  }
LABEL_12:
  CFRelease(v8);
}

void sub_183EE2B48(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void HTTPProtocol::handleCellularResponseInfo(HTTPProtocol *this)
{
  uint64_t v2;
  const __CFBoolean *v3;
  uint64_t v4;
  const __CFBoolean *v5;
  uint64_t v6;
  const __CFBoolean *v7;
  int Value;
  _BOOL4 v9;
  BOOL v10;
  __int16 v11;
  uint64_t v12;
  unint64_t v13;
  void *v14;
  char *v15;
  unsigned int v16;
  unint64_t v17;

  if (((*((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32)) & 0x800000040) != 0)
    return;
  v2 = *((_QWORD *)this + 34);
  if (!v2)
  {
    Value = 0;
    v9 = 0;
    v5 = 0;
LABEL_22:
    LODWORD(v3) = 0;
    goto LABEL_23;
  }
  v3 = (const __CFBoolean *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 32))(v2, 32);
  v4 = *((_QWORD *)this + 34);
  if (v4)
  {
    v5 = (const __CFBoolean *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 32))(v4, 31);
    v6 = *((_QWORD *)this + 34);
    if (v6)
      v7 = (const __CFBoolean *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 32))(v6, 33);
    else
      v7 = 0;
    v9 = v5 != 0;
    if (v3)
      v10 = v5 == 0;
    else
      v10 = 1;
    if (v10)
    {
      if (!v3)
      {
        Value = 0;
        goto LABEL_20;
      }
    }
    else
    {
      v11 = *((_WORD *)this + 98);
      *((_DWORD *)this + 48) = *((_DWORD *)this + 48);
      *((_WORD *)this + 98) = v11 | 8;
      v9 = 1;
    }
  }
  else
  {
    v5 = 0;
    if (!v3)
    {
      Value = 0;
      v9 = 0;
      goto LABEL_23;
    }
    v9 = 0;
    v7 = 0;
  }
  Value = CFBooleanGetValue(v3);
  if (Value)
  {
    v12 = *((unsigned int *)this + 48);
    v13 = v12 | ((unint64_t)*((unsigned __int16 *)this + 98) << 32) | 0x200000000;
    *((_DWORD *)this + 48) = v12;
    *((_WORD *)this + 98) = WORD2(v13);
  }
  CFRelease(v3);
LABEL_20:
  if (!v7)
    goto LABEL_22;
  LODWORD(v3) = CFBooleanGetValue(v7);
  CFRelease(v7);
LABEL_23:
  v14 = (void *)*((_QWORD *)this + 10);
  if (v14)
  {
    objc_msgSend(*((id *)this + 10), "_setConnectionIsCellular:", Value != 0);
    objc_msgSend(v14, "set_connectionIsCompanionLink:", (_DWORD)v3 != 0);
  }
  if (v9)
  {
    if (CFBooleanGetValue(v5))
    {
      v16 = *((_DWORD *)this + 48);
      v15 = (char *)this + 192;
      v17 = v16 | ((unint64_t)*((unsigned __int16 *)v15 + 2) << 32) | 0x400000000;
      *(_DWORD *)v15 = v16;
      *((_WORD *)v15 + 2) = WORD2(v17);
    }
    CFRelease(v5);
  }
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::copyProperty(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 48))(*(_QWORD *)(a1 + 8));
}

CFNumberRef `non-virtual thunk to'HTTP2StreamBridge::copyProperty(uint64_t a1, int a2)
{
  return HTTP2Stream::copyProperty(*(_QWORD **)(a1 + 16), a2);
}

void HTTPProtocol::bytesAvailable(uint64_t a1, NSObject *a2)
{
  unint64_t v4;
  size_t size;
  _QWORD applier[5];
  uint8_t buf[16];

  if (nw_settings_get_signposts_enabled())
  {
    dispatch_data_get_size(a2);
    kdebug_trace();
  }
  v4 = *(unsigned int *)(a1 + 192) | ((unint64_t)*(unsigned __int16 *)(a1 + 196) << 32);
  if ((v4 & 0x240000000000) != 0
    || (*(_DWORD *)(a1 + 192) & 0x104) == 0
    && ((v4 & 0x10000000000) != 0 || *(_DWORD *)(a1 + 728) == 3 || *(_QWORD *)(a1 + 272)))
  {
    if ((*(_DWORD *)(a1 + 192) & 0x40) == 0
      && *(_DWORD *)(a1 + 728) != 3
      && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "bytesAvailable(): Never reported a response, but we are about to process bytes", buf, 2u);
    }
    if (*(_DWORD *)(a1 + 200) == 2 && !*(_QWORD *)(a1 + 232) && (size = dispatch_data_get_size(a2)) != 0)
    {
      *(_QWORD *)(a1 + 520) += size;
      HTTPProtocol::sendDidLoadData((HTTPProtocol *)a1, (char *)a2, size);
    }
    else
    {
      applier[0] = MEMORY[0x1E0C809B0];
      applier[1] = 3221225472;
      applier[2] = ___ZN12HTTPProtocol14bytesAvailableEPU27objcproto16OS_dispatch_data8NSObject_block_invoke;
      applier[3] = &__block_descriptor_40_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
      applier[4] = a1;
      dispatch_data_apply(a2, applier);
    }
  }
}

CFTypeRef HTTPMessage::copyHeadersWithShadowedArrayValues(HTTPMessage *this)
{
  const __CFDictionary *v2;
  std::__shared_weak_count *v3;
  CFDictionaryRef v4;
  std::__shared_weak_count *v5;
  char *v6;
  const __CFAllocator *v7;
  __CFDictionary *MutableCopy;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  const __CFAllocator *v11;
  CFDataRef Data;
  CFDataRef v13;
  uint64_t v14;
  CFStringRef v15;
  CFStringRef v16;
  CFTypeRef v17;
  unint64_t v18;
  CFTypeRef v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v28;
  std::__shared_weak_count *v29;
  CFTypeRef cf;
  std::__shared_weak_count *v31;

  cf = 0;
  v31 = 0;
  v2 = HTTPMessage::copyAllHeaderFields(this);
  v3 = (std::__shared_weak_count *)operator new();
  v3->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1A58;
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
  v29 = v3;
  v4 = HTTPMessage::copyAsMultiValueDict(this);
  v5 = (std::__shared_weak_count *)operator new();
  v5->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1A58;
  v5->__shared_owners_ = 0;
  v5->__shared_weak_owners_ = 0;
  v5[1].__vftable = (std::__shared_weak_count_vtbl *)v4;
  v28 = v5;
  if (!v4)
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100](&cf, (uint64_t)v2, (uint64_t)v3);
    goto LABEL_15;
  }
  v6 = (char *)this - 16;
  v7 = CFGetAllocator((char *)this - 16);
  MutableCopy = CFDictionaryCreateMutableCopy(v7, 0, v2);
  v9 = (std::__shared_weak_count *)operator new();
  v9->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  v9->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1588;
  v9->__shared_weak_owners_ = 0;
  v9[1].__vftable = (std::__shared_weak_count_vtbl *)MutableCopy;
  if (MutableCopy)
  {
    v11 = CFGetAllocator(v6);
    Data = CFPropertyListCreateData(v11, v4, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    v13 = Data;
    if (Data)
    {
      v14 = -[__CFData base64EncodedStringWithOptions:](Data, "base64EncodedStringWithOptions:", 0);
      if (v14 && (v15 = CFStringCreateWithFormat(v11, 0, CFSTR("\r\n\r\n%@"), v14), (v16 = v15) != 0))
      {
        v17 = CFRetain(v15);
        CFRelease(v16);
        CFRelease(v13);
        if (v17)
        {
          CFDictionarySetValue(MutableCopy, CFSTR("__hhaa__"), v17);
          std::shared_ptr<__CFString const>::operator=[abi:nn180100](&cf, (uint64_t)MutableCopy, (uint64_t)v9);
          CFRelease(v17);
          goto LABEL_12;
        }
      }
      else
      {
        CFRelease(v13);
      }
    }
    std::shared_ptr<__CFString const>::operator=[abi:nn180100](&cf, (uint64_t)MutableCopy, (uint64_t)v9);
  }
  else
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100](&cf, (uint64_t)v2, (uint64_t)v3);
  }
  do
LABEL_12:
    v18 = __ldaxr(p_shared_owners);
  while (__stlxr(v18 - 1, p_shared_owners));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
LABEL_15:
  if (cf)
    v19 = CFRetain(cf);
  else
    v19 = 0;
  if (v28)
  {
    v20 = (unint64_t *)&v28->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  if (v29)
  {
    v22 = (unint64_t *)&v29->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v24 = v31;
  if (v31)
  {
    v25 = (unint64_t *)&v31->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  return v19;
}

void sub_183EE319C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
  const void *v17;

  CFRelease(v17);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a13);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a15);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<__CFString const*,Deleter_CFRelease,std::allocator<__CFString const>>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 24);
  if (v1)
    CFRelease(v1);
}

void std::__shared_ptr_pointer<__CFString *,Deleter_CFRelease,std::allocator<__CFString>>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 24);
  if (v1)
    CFRelease(v1);
}

void std::__shared_ptr_pointer<__CFDictionary const*,Deleter_CFRelease,std::allocator<__CFDictionary const>>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 24);
  if (v1)
    CFRelease(v1);
}

void std::__shared_ptr_pointer<__CFDictionary *,Deleter_CFRelease,std::allocator<__CFDictionary>>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 24);
  if (v1)
    CFRelease(v1);
}

CFDictionaryRef HTTPMessage::copyAsMultiValueDict(HTTPMessage *this)
{
  uint64_t v2;
  const __CFAllocator *v3;

  HTTPMessage::ensureParserFinished(this);
  v2 = HTTPMessage::headers((os_unfair_lock_s *)this);
  v3 = CFGetAllocator((char *)this - 16);
  return CFDictionaryCreateCopy(v3, *(CFDictionaryRef *)(v2 + 8));
}

void std::__shared_ptr_pointer<__CFArray *,Deleter_CFRelease,std::allocator<__CFArray>>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 24);
  if (v1)
    CFRelease(v1);
}

uint64_t `non-virtual thunk to'HTTP3StreamWrapper::copyProperty(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
}

_QWORD *TransportConnection::_createRefCountedWrapper(TransportConnection *this)
{
  _QWORD *Instance;
  _QWORD *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t v10;

  if (TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::sOnce, &__block_literal_global_15_16404);
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  v3 = Instance;
  if (Instance)
  {
    Instance[2] = 0;
    Instance[3] = 0;
    v3 = Instance + 2;
    Instance[4] = 0;
  }
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 27);
  if (v4 && (v5 = std::__shared_weak_count::lock(v4)) != 0)
  {
    v6 = v5;
    v7 = *((_QWORD *)this + 26);
    *v3 = &off_1E14EFFD0;
    v3[1] = v7;
    v3[2] = v5;
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  else
  {
    v3[1] = 0;
    v3[2] = 0;
    *v3 = &off_1E14EFFD0;
  }
  return v3 - 2;
}

__CFDictionary *HTTPProtocol::copyProtocolPropertiesForStream(HTTPProtocol *this)
{
  __CFDictionary *Mutable;
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  uint64_t v5;
  const __CFAllocator *v6;
  CFNumberRef v7;
  void *v8;
  const void *v9;
  const void *v10;
  uint64_t valuePtr;

  if ((*((_DWORD *)this + 48) & 0x100000) != 0)
    return 0;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v3 = HTTPProtocol::copySSLPropertiesForStream(this, 0);
  v4 = v3;
  if (v3 && CFDictionaryGetCount(v3) >= 1)
    CFDictionaryAddValue(Mutable, &unk_1EDCFC080, v4);
  objc_msgSend(*((id *)this + 10), "_timeoutInterval");
  valuePtr = v5;
  v6 = CFGetAllocator((char *)this - 16);
  v7 = CFNumberCreate(v6, kCFNumberDoubleType, &valuePtr);
  if (v7)
    CFDictionaryAddValue(Mutable, &unk_1EDCFA8A8, v7);
  v8 = (void *)*((_QWORD *)this + 10);
  if (v8)
  {
    v9 = (const void *)objc_msgSend(v8, "_DuetActivityProperties");
    if (v9)
      CFDictionaryAddValue(Mutable, &unk_1EDCF96F0, v9);
    v10 = (const void *)objc_msgSend(v8, "_TCPConnectionMetadata", v9);
    if (v10)
      CFDictionaryAddValue(Mutable, &unk_1EDCFAD40, v10);
  }
  if (v7)
    CFRelease(v7);
  if (v4)
    CFRelease(v4);
  return Mutable;
}

void sub_183EE350C(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;

  CFRelease(v2);
  if (v1)
    CFRelease(v1);
  _Unwind_Resume(a1);
}

const __CFDictionary *HTTPProtocol::copySSLPropertiesForStream(HTTPProtocol *this, int a2)
{
  const __CFDictionary *v2;
  const __CFDictionary *v5;
  const __CFAllocator *v6;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v8;
  void *v9;
  const __CFURL *v10;
  const __CFString *v11;
  const __CFString *v12;
  int v13;
  uint64_t v14;
  const __CFDictionary *ATSExceptionForHost;
  char v16;
  BOOL IsWebKit;
  BOOL IsMediaserver;
  _BOOL4 v19;
  int isIPAddress;
  int v21;
  int v22;
  int v23;
  const __CFString *v24;
  CFTypeID TypeID;
  uint8x8_t v26;
  int v27;
  int v28;
  char v29;
  const void *v30;
  const void *v31;
  CFTypeID v32;
  const void *v33;
  const void *v34;
  CFTypeID v35;
  const void *v36;
  const void *v37;
  CFTypeID v38;
  const void *v39;
  const void *v40;
  CFTypeID v41;
  void *v42;
  int v43;
  const __CFAllocator *v44;
  CFNumberRef v45;
  uint64_t v46;
  const __CFNumber *v47;
  uint64_t v48;
  const __CFAllocator *v49;
  CFNumberRef v50;
  uint64_t v51;
  int v52;
  int v53;
  int v54;
  NSObject *v55;
  uint64_t v56;
  unint64_t v57;
  const void *v58;
  const void *v59;
  const __CFAllocator *v61;
  const void *v62;
  const void *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  const void *v67;
  uint64_t v68;
  int v69;
  int v70;
  int v71;
  int v72;
  uint64_t valuePtr;
  __int128 v74;
  uint64_t v75;
  void *value;
  int v77;
  _BYTE buffer[24];
  void *v79;
  __int128 v80;
  __int16 v81;
  int v82;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  if ((*((_DWORD *)this + 48) & 0x4000) == 0)
    return 0;
  if (!*((_QWORD *)this + 112))
  {
    v5 = (const __CFDictionary *)objc_msgSend(*((id *)this + 10), "_sslSettings");
    v6 = CFGetAllocator((char *)this - 16);
    if (v5)
      MutableCopy = CFDictionaryCreateMutableCopy(v6, 0, v5);
    else
      MutableCopy = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v8 = MutableCopy;
    v9 = (void *)*((_QWORD *)this + 11);
    v74 = xmmword_1841E3910;
    LOWORD(v75) = 0;
    BYTE2(v75) = 0;
    HIDWORD(v75) = 8;
    if (ATSTLSCiphers::DefaultPFSCipherSuites(void)::cipherDataToken != -1)
      dispatch_once(&ATSTLSCiphers::DefaultPFSCipherSuites(void)::cipherDataToken, &__block_literal_global_40);
    value = (void *)ATSTLSCiphers::DefaultPFSCipherSuites(void)::cipherData;
    v77 = 1;
    if (!v9)
      goto LABEL_87;
    if (!*((_QWORD *)this + 92))
      goto LABEL_87;
    v10 = *(const __CFURL **)(objc_msgSend(v9, "_inner") + 8);
    if (!v10)
      goto LABEL_87;
    v11 = CFURLCopyHostName(v10);
    if (!v11)
      goto LABEL_87;
    v12 = v11;
    v13 = a2;
    v14 = *((_QWORD *)this + 92);
    ATSExceptionForHost = (const __CFDictionary *)StrictSecurityPolicy::getATSExceptionForHost((const __CFDictionary **)v14, v11);
    v16 = *(_BYTE *)(v14 + 32);
    v19 = (v16 & 2) != 0
       && (IsWebKit = StrictSecurityPolicy::clientIsWebKit((StrictSecurityPolicy *)*(unsigned __int8 *)(v14 + 33)),
           v16 = *(_BYTE *)(v14 + 32),
           IsWebKit)
       || (v16 & 8) != 0
       && (IsMediaserver = StrictSecurityPolicy::clientIsMediaserver((StrictSecurityPolicy *)*(unsigned __int8 *)(v14 + 34)),
           v16 = *(_BYTE *)(v14 + 32),
           IsMediaserver)
       || (v16 & 1) == 0;
    isIPAddress = _isIPAddress(v12, 1);
    if (isIPAddress)
    {
      if ((_os_feature_enabled_impl() & 1) == 0)
      {
        v22 = dyld_program_sdk_at_least();
        if ((v22 & ((v16 & 4) >> 2) & 1) == 0)
        {
          v21 = v22 ^ 1;
          goto LABEL_29;
        }
        goto LABEL_27;
      }
      if ((v16 & 4) != 0)
      {
LABEL_27:
        v21 = isLocalIPAddress(v12);
        goto LABEL_29;
      }
    }
    else if ((v16 & 4) != 0)
    {
      v21 = isLocalTLD(v12);
LABEL_29:
      v23 = v21 ^ 1;
      if (!isIPAddress)
        v23 = 1;
      if (!ATSExceptionForHost || !v23)
      {
        if ((v19 | v21) == 1)
        {
          *((_QWORD *)&v74 + 1) = 0;
          HIDWORD(v75) = 4;
          LOBYTE(v74) = 1;
          value = 0;
          v77 = 0;
        }
        BYTE1(v75) = (*(_BYTE *)(v14 + 32) & 0x10) != 0;
        if (!ATSExceptionForHost)
          goto LABEL_86;
        goto LABEL_85;
      }
      v24 = (const __CFString *)CFDictionaryGetValue(ATSExceptionForHost, CFSTR("NSExceptionMinimumTLSVersion"));
      if (!v24)
      {
        v24 = (const __CFString *)CFDictionaryGetValue(ATSExceptionForHost, CFSTR("NSThirdPartyExceptionMinimumTLSVersion"));
        if (!v24)
        {
          v24 = (const __CFString *)CFDictionaryGetValue(ATSExceptionForHost, CFSTR("NSTemporaryExceptionMinimumTLSVersion"));
          if (!v24)
          {
            v24 = (const __CFString *)CFDictionaryGetValue(ATSExceptionForHost, CFSTR("NSTemporaryThirdPartyExceptionMinimumTLSVersion"));
            if (!v24)
            {
LABEL_51:
              v28 = exceptionAllowsInsecureLoad(ATSExceptionForHost);
              v29 = v28;
              if (v28)
                *((_QWORD *)&v74 + 1) = 0;
              v30 = CFDictionaryGetValue(ATSExceptionForHost, CFSTR("NSExceptionRequiresForwardSecrecy"));
              v31 = v30;
              if (v30)
              {
                v32 = CFGetTypeID(v30);
                if (v32 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
                {
                  *(_WORD *)buffer = 0;
                  _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buffer, 2u);
                }
                if ((const void *)*MEMORY[0x1E0C9AE40] == v31)
                  goto LABEL_73;
              }
              v33 = CFDictionaryGetValue(ATSExceptionForHost, CFSTR("NSThirdPartyExceptionRequiresForwardSecrecy"));
              v34 = v33;
              if (v33)
              {
                v35 = CFGetTypeID(v33);
                if (v35 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
                {
                  *(_WORD *)buffer = 0;
                  _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buffer, 2u);
                }
                if ((const void *)*MEMORY[0x1E0C9AE40] == v34)
                  goto LABEL_73;
              }
              v36 = CFDictionaryGetValue(ATSExceptionForHost, CFSTR("NSTemporaryExceptionRequiresForwardSecrecy"));
              v37 = v36;
              if (v36)
              {
                v38 = CFGetTypeID(v36);
                if (v38 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
                {
                  *(_WORD *)buffer = 0;
                  _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buffer, 2u);
                }
                if ((const void *)*MEMORY[0x1E0C9AE40] == v37)
                  goto LABEL_73;
              }
              v39 = CFDictionaryGetValue(ATSExceptionForHost, CFSTR("NSTemporaryThirdPartyExceptionRequiresForwardSecrecy"));
              v40 = v39;
              if (v39)
              {
                v41 = CFGetTypeID(v39);
                if (v41 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
                {
                  *(_WORD *)buffer = 0;
                  _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buffer, 2u);
                }
                if ((const void *)*MEMORY[0x1E0C9AE40] == v40)
                {
LABEL_73:
                  if ((v29 & 1) != 0)
                  {
                    v42 = 0;
                    v43 = 0;
                  }
                  else
                  {
                    if (ATSTLSCiphers::DefaultNonPFSCipherSuites(void)::cipherDataToken != -1)
                      dispatch_once(&ATSTLSCiphers::DefaultNonPFSCipherSuites(void)::cipherDataToken, &__block_literal_global_39_9077);
                    v42 = (void *)ATSTLSCiphers::DefaultNonPFSCipherSuites(void)::cipherData;
                    v43 = 2;
                  }
                  value = v42;
                  v77 = v43;
                  if (isAppleBundle(void)::onceToken != -1)
                    dispatch_once(&isAppleBundle(void)::onceToken, &__block_literal_global_92);
                  if (isAppleBundle(void)::_isAppleBundle || (dyld_program_sdk_at_least() & 1) == 0)
                    LOBYTE(v74) = 1;
                  *((_QWORD *)&v74 + 1) = 0;
                }
              }
              BYTE1(v75) = (*(_BYTE *)(v14 + 32) & 0x10) != 0;
LABEL_85:
              BYTE2(v75) = CFDictionaryGetValue(ATSExceptionForHost, CFSTR("NSATSBuiltinOverride")) == (const void *)*MEMORY[0x1E0C9AE50];
LABEL_86:
              *((_OWORD *)this + 54) = v74;
              CFRelease(v12);
              a2 = v13;
LABEL_87:
              v44 = CFGetAllocator((char *)this - 16);
              v45 = CFNumberCreate(v44, kCFNumberCFIndexType, (char *)&v74 + 8);
              CFDictionarySetValue(v8, &unk_1EDCFB018, v45);
              v46 = SHIDWORD(v75);
              valuePtr = SHIDWORD(v75);
              v47 = (const __CFNumber *)CFDictionaryGetValue(v8, &unk_1EDCFB3D0);
              if (v47)
              {
                *(_QWORD *)buffer = 0;
                CFNumberGetValue(v47, kCFNumberCFIndexType, buffer);
                v48 = *(_QWORD *)buffer;
                if (*(uint64_t *)buffer <= v46)
                  v48 = v46;
                valuePtr = v48;
              }
              v49 = CFGetAllocator((char *)this - 16);
              v50 = CFNumberCreate(v49, kCFNumberCFIndexType, &valuePtr);
              CFDictionarySetValue(v8, &unk_1EDCFB3D0, v50);
              if ((_BYTE)v75)
                CFDictionarySetValue(v8, &unk_1EDCFAF38, (const void *)*MEMORY[0x1E0C9AE50]);
              if ((_BYTE)v74)
                CFDictionarySetValue(v8, &unk_1EDCFAF70, (const void *)*MEMORY[0x1E0C9AE50]);
              if (value)
                CFDictionarySetValue(v8, &unk_1EDCFAF00, value);
              if (BYTE1(v75))
                CFDictionarySetValue(v8, &unk_1EDCFAFE0, (const void *)*MEMORY[0x1E0C9AE50]);
              if (BYTE2(v75))
                CFDictionarySetValue(v8, &unk_1EDCFAFA8, (const void *)*MEMORY[0x1E0C9AE50]);
              if (((*((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32)) & 0x100000000) == 0)
              {
                v51 = *((_QWORD *)this + 99);
                v52 = DWORD2(v74);
                v53 = v75;
                v70 = v74;
                v71 = BYTE1(v75);
                v72 = BYTE2(v75);
                v69 = v77;
                v54 = valuePtr;
                if (ATSLog(void)::onceToken != -1)
                  dispatch_once(&ATSLog(void)::onceToken, &__block_literal_global_84_8989);
                v55 = ATSLog(void)::atsLog;
                if (os_log_type_enabled((os_log_t)ATSLog(void)::atsLog, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buffer = 138545154;
                  *(_QWORD *)&buffer[4] = v51;
                  *(_WORD *)&buffer[12] = 1024;
                  *(_DWORD *)&buffer[14] = v52;
                  *(_WORD *)&buffer[18] = 1024;
                  *(_DWORD *)&buffer[20] = v54;
                  LOWORD(v79) = 1024;
                  *(_DWORD *)((char *)&v79 + 2) = v53;
                  HIWORD(v79) = 1024;
                  LODWORD(v80) = v70;
                  WORD2(v80) = 1024;
                  *(_DWORD *)((char *)&v80 + 6) = v69;
                  WORD5(v80) = 1024;
                  HIDWORD(v80) = v71;
                  v81 = 1024;
                  v82 = v72;
                  _os_log_debug_impl(&dword_183ECA000, v55, OS_LOG_TYPE_DEBUG, "%{public}@ {strength %d, tls %d, sub %d, sig %d, ciphers %d, bundle %d, builtin %d}", buffer, 0x36u);
                }
                v56 = *((unsigned int *)this + 48);
                v57 = v56 | ((unint64_t)*((unsigned __int16 *)this + 98) << 32) | 0x100000000;
                *((_DWORD *)this + 48) = v56;
                *((_WORD *)this + 98) = WORD2(v57);
              }
              if (v50)
                CFRelease(v50);
              if (v45)
                CFRelease(v45);
              v58 = (const void *)*((_QWORD *)this + 112);
              *((_QWORD *)this + 112) = v8;
              if (v58)
                CFRelease(v58);
              goto LABEL_113;
            }
          }
        }
      }
      TypeID = CFStringGetTypeID();
      if (TypeID != CFGetTypeID(v24))
        goto LABEL_49;
      if (CFStringGetLength(v24) != 7)
        goto LABEL_49;
      *(_QWORD *)buffer = 0;
      if (!CFStringGetCString(v24, buffer, 8, 0x600u))
        goto LABEL_49;
      v26.i32[0] = *(_DWORD *)buffer;
      v27 = 8;
      if (vmovn_s16((int16x8_t)vmovl_u8(v26)).u32[0] != 1985170516 || buffer[4] != 49 || buffer[5] != 46)
        goto LABEL_50;
      if ((buffer[6] - 48) <= 3u)
        v27 = dword_1841E3AB0[(buffer[6] - 48)];
      else
LABEL_49:
        v27 = 8;
LABEL_50:
      HIDWORD(v75) = v27;
      goto LABEL_51;
    }
    v21 = 0;
    goto LABEL_29;
  }
LABEL_113:
  if (!a2)
  {
    v61 = CFGetAllocator((char *)this - 16);
    v2 = CFDictionaryCreateMutableCopy(v61, 0, *((CFDictionaryRef *)this + 112));
    if (!CFDictionaryGetValue(v2, &unk_1EDCFC550))
    {
      v64 = *((_QWORD *)this + 93);
      if (v64)
      {
        v65 = *((_QWORD *)this + 35);
        if (v65)
        {
          v66 = *(_QWORD *)(v64 + 168);
          if (v66)
          {
            v67 = (const void *)*((_QWORD *)this + 3);
            *(_QWORD *)&v74 = 0;
            *((_QWORD *)&v74 + 1) = &v74;
            v75 = 0x2020000000;
            value = 0;
            *(_QWORD *)buffer = MEMORY[0x1E0C809B0];
            *(_QWORD *)&buffer[8] = 3221225472;
            *(_QWORD *)&buffer[16] = ___ZN12XTubeManager25getCurrentSSLMethodForKeyEPK22HTTPConnectionCacheKeyPK17CoreSchedulingSet_block_invoke;
            v79 = &unk_1E14FD7F0;
            *(_QWORD *)&v80 = &v74;
            *((_QWORD *)&v80 + 1) = v65;
            XTubeManager::withTubeManager(v66, v67, (uint64_t)buffer);
            v68 = *(_QWORD *)(*((_QWORD *)&v74 + 1) + 24);
            _Block_object_dispose(&v74, 8);
          }
          else
          {
            v68 = 0;
          }
          *((_QWORD *)this + 36) = v68;
        }
      }
    }
    v62 = (const void *)*((_QWORD *)this + 36);
    v63 = (const void *)*MEMORY[0x1E0CD6888];
    if (!v62)
    {
      *((_QWORD *)this + 36) = v63;
      v62 = v63;
    }
    CFDictionarySetValue(v2, &unk_1EDCFC550, v62);
    if (!CFEqual(*((CFTypeRef *)this + 36), v63))
      CFDictionarySetValue(v2, &unk_1EDCFB280, (const void *)*MEMORY[0x1E0C9AE50]);
    return v2;
  }
  v59 = (const void *)*((_QWORD *)this + 112);
  if (v59)
    return (const __CFDictionary *)CFRetain(v59);
  return 0;
}

void sub_183EE4020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void HTTPEngine::_readBodyStartNextRead(HTTPEngine *this)
{
  int v1;
  void (*v2)(uint64_t, dispatch_data_t, uint64_t, uint64_t, uint64_t);
  uint64_t v3;
  _QWORD v4[5];
  CFStreamError v5;

  v1 = *((_DWORD *)this + 8);
  if ((v1 & 0x400) != 0)
  {
    *((_DWORD *)this + 8) = v1 | 0x1000;
  }
  else
  {
    if ((v1 & 0x2000) == 0)
    {
      v4[0] = MEMORY[0x1E0C809B0];
      v2 = ___ZN10HTTPEngine14_readBodyPlainEv_block_invoke;
LABEL_4:
      v4[1] = 3221225472;
      v4[2] = v2;
      v4[3] = &__block_descriptor_40_e47_v36__0__NSObject_OS_dispatch_data__8___qi_16B32l;
      v4[4] = this;
      HTTPEngine::_getBodyIntelligently((uint64_t)this, (uint64_t)v4);
      return;
    }
    if ((v1 & 0x8000) != 0)
    {
      HTTPEngine::_chunkedReadTrailer(this);
    }
    else
    {
      v3 = *((_QWORD *)this + 22);
      if (v3 != -3 && v3 != *((_QWORD *)this + 23))
      {
        v4[0] = MEMORY[0x1E0C809B0];
        v2 = ___ZN10HTTPEngine16_chunkedReadBodyEv_block_invoke;
        goto LABEL_4;
      }
      v5.domain = 0;
      *(_QWORD *)&v5.error = 0;
      HTTPEngine::_chunkedParseHeader(this, v5);
    }
  }
}

void HTTPEngine::_getBodyIntelligently(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  unsigned int v10;
  double v11;
  uint64_t v12;
  unint64_t v13;
  size_t v14;
  NSObject *v15;
  size_t size;
  std::__shared_weak_count *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  dispatch_data_t subrange;
  std::__shared_weak_count *v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  NSObject *v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  _QWORD aBlock[6];
  std::__shared_weak_count *v52;
  int v53;
  unsigned int v54;
  _QWORD v55[6];
  std::__shared_weak_count *v56;
  int v57;
  unsigned int v58;
  _QWORD v59[10];
  std::__shared_weak_count *v60;
  uint64_t v61;
  std::__shared_weak_count *v62;
  _QWORD block[7];
  std::__shared_weak_count *v64;
  int v65;
  unsigned int v66;
  _QWORD v67[9];
  uint64_t v68;
  uint64_t *v69;
  uint64_t v70;
  char v71;
  uint64_t v72;
  uint64_t *v73;
  uint64_t v74;
  __n128 (*v75)(__n128 *, __n128 *);
  uint64_t (*v76)();
  void *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t *v81;
  uint64_t v82;
  void (*v83)(uint64_t, uint64_t);
  void (*v84)(uint64_t);
  uint64_t v85;

  v80 = 0;
  v81 = &v80;
  v4 = 132000;
  v82 = 0x3052000000;
  v83 = __Block_byref_object_copy__28;
  v84 = __Block_byref_object_dispose__29;
  v85 = 0;
  v72 = 0;
  v73 = &v72;
  v74 = 0x4012000000;
  v75 = __Block_byref_object_copy__15809;
  v76 = __Block_byref_object_dispose__15810;
  v78 = 0;
  v79 = 0;
  v77 = &unk_18422E08D;
  v68 = 0;
  v69 = &v68;
  v70 = 0x2020000000;
  v71 = 0;
  v5 = MEMORY[0x1E0C809B0];
  v67[0] = MEMORY[0x1E0C809B0];
  v67[1] = 3221225472;
  v67[2] = ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke;
  v67[3] = &unk_1E14FD110;
  v67[7] = &v68;
  v67[8] = a1;
  v67[5] = &v80;
  v67[6] = &v72;
  v67[4] = a2;
  v6 = *(_QWORD *)(a1 + 160);
  if (v6)
  {
    v7 = (*(uint64_t (**)(void))(v6 + 16))();
    if (v7 <= 132001)
      v4 = 132000;
    else
      v4 = v7 - 1;
  }
  v8 = *(_DWORD *)(a1 + 32);
  v9 = v8 & 0x700000;
  if ((v8 & 0x700000) != 0)
  {
    v10 = *(_DWORD *)(a1 + 224);
    v11 = *(double *)(a1 + 232);
    if ((v8 & 0x600000) != 0)
    {
      if ((v8 & 0x400000) != 0)
        v4 = 0x10000;
      else
        v4 = *(_DWORD *)(a1 + 224);
      if ((v8 & 0x400000) != 0)
        v11 = 0.2;
      v10 = v4;
    }
  }
  else
  {
    v10 = 1;
    v11 = 0.0;
  }
  v12 = *(_QWORD *)(a1 + 176);
  if (v12 != -1)
  {
    v13 = v12 - *(_QWORD *)(a1 + 184);
    if (v13 < v4)
      v4 = v13;
  }
  if (v10 >= v4)
    v14 = v4;
  else
    v14 = v10;
  if (!v4)
  {
    *((_BYTE *)v69 + 24) = 1;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a2 + 16))(a2, v81[5], v73[6], v73[7], 1);
    goto LABEL_89;
  }
  v15 = *(NSObject **)(a1 + 192);
  if (!v15 || (size = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 192))) == 0)
  {
LABEL_26:
    if ((v8 & 1) != 0)
    {
      v19 = v73;
      *((_OWORD *)v73 + 3) = *(_OWORD *)(a1 + 96);
      if (*((_DWORD *)v19 + 14))
      {
        v20 = v19[6];
      }
      else
      {
        v20 = 4;
        v19[6] = 4;
        *((_DWORD *)v19 + 14) = -4;
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(a2 + 16))(a2, v81[5], v20, v19[7], *((unsigned __int8 *)v69 + 24));
      goto LABEL_89;
    }
    v61 = 0;
    v62 = 0;
    v17 = *(std::__shared_weak_count **)(a1 + 48);
    if (v17 && (v17 = std::__shared_weak_count::lock(v17), (v62 = v17) != 0))
    {
      v18 = *(_QWORD *)(a1 + 40);
      v61 = v18;
    }
    else
    {
      v18 = 0;
    }
    v59[0] = v5;
    v59[1] = 3321888768;
    v59[2] = ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke_32;
    v59[3] = &unk_1E14F47C0;
    v59[5] = &v72;
    v59[6] = &v68;
    v59[8] = a1;
    v59[9] = v18;
    v60 = v17;
    if (v17)
    {
      p_shared_owners = (unint64_t *)&v17->__shared_owners_;
      do
        v22 = __ldxr(p_shared_owners);
      while (__stxr(v22 + 1, p_shared_owners));
    }
    v59[7] = &v80;
    v59[4] = v67;
    if ((*(_BYTE *)(a1 + 34) & 1) != 0)
    {
      ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke_32(v59, 0, 0, 0, 0);
      goto LABEL_63;
    }
    v23 = *(_QWORD *)(a1 + 112);
    if (v9)
    {
      aBlock[0] = v5;
      aBlock[1] = 3321888768;
      aBlock[2] = ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke_34;
      aBlock[3] = &unk_1E14F3B68;
      aBlock[5] = v18;
      v52 = v17;
      if (v17)
      {
        v24 = (unint64_t *)&v17->__shared_owners_;
        do
          v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
      }
      v53 = v14;
      v54 = v4;
      aBlock[4] = v59;
      ConnectionReadAggregator::read(v23, v14, v4, aBlock, v11);
      v26 = v52;
      if (v52)
      {
        v27 = (unint64_t *)&v52->__shared_owners_;
        do
          v28 = __ldaxr(v27);
        while (__stlxr(v28 - 1, v27));
        goto LABEL_61;
      }
    }
    else
    {
      v55[0] = v5;
      v55[1] = 3321888768;
      v55[2] = ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke_33;
      v55[3] = &unk_1E14F3B68;
      v55[5] = v18;
      v56 = v17;
      if (v17)
      {
        v33 = (unint64_t *)&v17->__shared_owners_;
        do
          v34 = __ldxr(v33);
        while (__stxr(v34 + 1, v33));
      }
      v57 = v14;
      v58 = v4;
      v55[4] = v59;
      ConnectionReadAggregator::read(v23, v14, v4, v55, 0.0);
      v26 = v56;
      if (v56)
      {
        v35 = (unint64_t *)&v56->__shared_owners_;
        do
          v28 = __ldaxr(v35);
        while (__stlxr(v28 - 1, v35));
LABEL_61:
        if (!v28)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
    }
LABEL_63:
    v36 = v60;
    if (v60)
    {
      v37 = (unint64_t *)&v60->__shared_owners_;
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }
    v39 = v62;
    if (v62)
    {
      v40 = (unint64_t *)&v62->__shared_owners_;
      do
        v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        v42 = v39;
LABEL_88:
        std::__shared_weak_count::__release_weak(v42);
        goto LABEL_89;
      }
    }
    goto LABEL_89;
  }
  if (v9 && size < v14)
  {
    LODWORD(v14) = v14 - size;
    v4 -= size;
    goto LABEL_26;
  }
  if (size <= v4)
  {
    v81[5] = (uint64_t)v15;
    *(_QWORD *)(a1 + 192) = 0;
  }
  else
  {
    subrange = dispatch_data_create_subrange(v15, 0, v4);
    v81[5] = (uint64_t)subrange;
    HTTPEngine::_readBufferConsume((HTTPEngine *)a1, v4);
  }
  v30 = *(std::__shared_weak_count **)(a1 + 48);
  if (v30)
  {
    v31 = std::__shared_weak_count::lock(v30);
    if (v31)
      v32 = *(_QWORD *)(a1 + 40);
    else
      v32 = 0;
  }
  else
  {
    v32 = 0;
    v31 = 0;
  }
  v43 = *(NSObject **)(a1 + 72);
  block[0] = v5;
  block[1] = 3321888768;
  block[2] = ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke_2;
  block[3] = &unk_1E14F41F0;
  block[6] = v32;
  v64 = v31;
  if (v31)
  {
    v44 = (unint64_t *)&v31->__shared_owners_;
    do
      v45 = __ldxr(v44);
    while (__stxr(v45 + 1, v44));
  }
  v65 = v14;
  v66 = v4;
  block[4] = v67;
  block[5] = &v80;
  dispatch_async(v43, block);
  v46 = v64;
  if (v64)
  {
    v47 = (unint64_t *)&v64->__shared_owners_;
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
  if (v31)
  {
    v49 = (unint64_t *)&v31->__shared_owners_;
    do
      v50 = __ldaxr(v49);
    while (__stlxr(v50 - 1, v49));
    if (!v50)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      v42 = v31;
      goto LABEL_88;
    }
  }
LABEL_89:
  _Block_object_dispose(&v68, 8);
  _Block_object_dispose(&v72, 8);
  _Block_object_dispose(&v80, 8);
}

void sub_183EE472C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  uint64_t v37;
  uint64_t v38;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v37);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a35);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a37);
  _Block_object_dispose((const void *)(v38 - 240), 8);
  _Block_object_dispose((const void *)(v38 - 208), 8);
  _Block_object_dispose((const void *)(v38 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN9Throttler24getByteHeadroomInfoBlockEv_block_invoke(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 32) + 104) - *(_QWORD *)(*(_QWORD *)(a1 + 32) + 88);
}

void ConnectionReadAggregator::read(uint64_t a1, int a2, int a3, void *aBlock, double a5)
{
  if (*(_DWORD *)(a1 + 76) || *(_DWORD *)(a1 + 80) || *(double *)(a1 + 88) != 0.0 || *(_QWORD *)(a1 + 96))
    __assert_rtn("read", "ConnectionReadAggregator.mm", 85, "_minLen == 0 && _maxLen == 0 && _timeout == 0.0 && _cb == nullptr");
  *(_DWORD *)(a1 + 76) = a2;
  *(_DWORD *)(a1 + 80) = a3;
  *(double *)(a1 + 88) = a5;
  *(_QWORD *)(a1 + 96) = _Block_copy(aBlock);
  ConnectionReadAggregator::_evaluate((ConnectionReadAggregator *)a1);
}

void std::__shared_ptr_pointer<HTTPProtocol *,Deleter_release<HTTPProtocol>,std::allocator<HTTPProtocol>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
    CFRelease((CFTypeRef)(v1 - 16));
}

void HTTPProtocol::applyPreAuthenticationToCurrentRequest(HTTPProtocol *this, MetaNetStreamInfo *a2, NSURLRequest *a3, const __CFURL *a4)
{
  CFURLRef v7;
  CFURLRef v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  const __CFAllocator *v12;
  CFStringRef v13;
  const __CFURL *v14;
  HTTPProtocol *v15;
  __SecTrust *v16;
  double v17;
  __CFString *XMobileMeAuthTokenForHTTPHeader;
  __CFString *v19;
  uint64_t v20;

  if (a3)
  {
    v7 = _CFURLRequestCopyProtocolPropertyForKey(a3, CFSTR("kCFURLRequestPreAuthXMMeAuthToken"));
    if (v7)
    {
      v8 = v7;
      if (a4 && v7 == (CFURLRef)*MEMORY[0x1E0C9AE50])
      {
        if (a2)
        {
          if (!*((_QWORD *)this + 57))
          {
            v9 = (*(uint64_t (**)(MetaNetStreamInfo *))(*(_QWORD *)a2 + 120))(a2);
            if (v9)
              *((_QWORD *)this + 57) = v9;
          }
        }
        v10 = (void *)*((_QWORD *)this + 11);
        if (v10)
        {
          v11 = objc_msgSend(v10, "_inner");
          v12 = *(const __CFAllocator **)(v11 + 8);
          if (v12)
          {
            v13 = CFURLCopyUserName(*(CFURLRef *)(v11 + 8));
            if (v13)
            {
              v14 = (const __CFURL *)v13;
              v15 = (HTTPProtocol *)CFGetAllocator((char *)this - 16);
              XMobileMeAuthTokenForHTTPHeader = HTTPAuthentication::createXMobileMeAuthTokenForHTTPHeader((HTTPAuthentication *)this, v15, v12, v14, 0, 0, *((const __CFString **)this + 57), v16, v17);
              if (XMobileMeAuthTokenForHTTPHeader)
              {
                v19 = XMobileMeAuthTokenForHTTPHeader;
                v20 = *((_QWORD *)this + 34);
                if (v20)
                  (*(void (**)(uint64_t, uint64_t, __CFString *))(*(_QWORD *)v20 + 40))(v20, 1, v19);
                CFRelease(v19);
              }
              CFRelease(v14);
            }
          }
        }
      }
      CFRelease(v8);
    }
  }
}

void std::__shared_ptr_pointer<__CFData const*,Deleter_CFRelease,std::allocator<__CFData const>>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 24);
  if (v1)
    CFRelease(v1);
}

void std::__shared_ptr_emplace<CoreSchedulingSetOneOff>::__on_zero_shared(uint64_t a1)
{
  NSObject *v2;
  const void *v3;

  v2 = *(NSObject **)(a1 + 24);
  if (v2)
    dispatch_release(v2);
  v3 = *(const void **)(a1 + 32);
  if (v3)
    _Block_release(v3);
}

uint64_t URLProtocol::initialize(URLProtocol *this, NSURLSessionTask *a2, URLProtocolClient *a3)
{
  NSURLSessionTask *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  uint64_t v11;

  v6 = a2;
  *((_QWORD *)this + 10) = v6;
  if (v6)
  {
    v6 = -[NSURLSessionTask currentRequest](v6, "currentRequest");
    *((_QWORD *)this + 11) = v6;
  }
  *((_QWORD *)this + 3) = CoreSchedulingSet::createEmpty((CoreSchedulingSet *)v6);
  *((_QWORD *)this + 12) = a3;
  if (a3)
    (*((void (**)(URLProtocolClient *))a3->var0 + 2))(a3);
  *((_BYTE *)this + 40) = 1;
  if ((*(unsigned int (**)(URLProtocol *))(*(_QWORD *)this + 232))(this))
  {
    if (a2)
      v7 = objc_msgSend(*((id *)this + 10), "_suspensionThreshhold");
    else
      v7 = 0x200000;
    v8 = *MEMORY[0x1E0C9AE00];
    v9 = (char *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 120, 0);
    *(_OWORD *)(v9 + 20) = 0u;
    *(_OWORD *)(v9 + 36) = 0u;
    *(_OWORD *)(v9 + 52) = 0u;
    *(_OWORD *)(v9 + 68) = 0u;
    *(_OWORD *)(v9 + 84) = 0u;
    *(_OWORD *)(v9 + 100) = 0u;
    *(_QWORD *)v9 = off_1E14EF578;
    *((_QWORD *)v9 + 1) = v8;
    *((_DWORD *)v9 + 29) = 0;
    *((_DWORD *)v9 + 4) = 1;
    if (((unint64_t)(v9 + 16) & 3) != 0)
      __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
    v10 = v9;
    *(_QWORD *)v9 = off_1E14EFE68;
    *((_QWORD *)v9 + 3) = &unk_1E14EFEB0;
    *((_QWORD *)v9 + 10) = (char *)this + 16;
    *((_QWORD *)v9 + 9) = CoreSchedulingSet::copyLoaderQueueSet((CoreSchedulingSet *)v9);
    *((_OWORD *)v10 + 6) = xmmword_1841E38B0;
    *((_QWORD *)this + 8) = v10;
    *((_QWORD *)v10 + 13) = v7;
    *((_QWORD *)v10 + 14) = 0;
    if (a2)
    {
      v11 = objc_msgSend(*((id *)this + 10), "_bytesPerSecondLimit");
      if (v11)
        Throttler::setMaximumBPSTarget(*((Throttler **)this + 8), v11);
    }
  }
  *((_BYTE *)this + 72) = 0;
  return 1;
}

void sub_183EE4B14(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(CFAllocatedReferenceCountedObject *this, const __CFAllocator *a2)
{
  *(_QWORD *)this = off_1E14EF578;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = 1;
  if ((((unint64_t)this + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
}

uint64_t CoreSchedulingSet::copyLoaderQueueSet(CoreSchedulingSet *this)
{
  if (CoreSchedulingSet::copyLoaderQueueSet(void)::sOnce != -1)
    dispatch_once(&CoreSchedulingSet::copyLoaderQueueSet(void)::sOnce, &__block_literal_global_14_16983);
  (*(void (**)(uint64_t))(*(_QWORD *)CoreSchedulingSet::copyLoaderQueueSet(void)::sLoaderQueueSet + 40))(CoreSchedulingSet::copyLoaderQueueSet(void)::sLoaderQueueSet);
  return CoreSchedulingSet::copyLoaderQueueSet(void)::sLoaderQueueSet;
}

uint64_t CoreSchedulingSet::createEmpty(CoreSchedulingSet *this)
{
  uint64_t v1;

  if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
    dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16941);
  v1 = CoreSchedulingSet::getEmptySet(void)::sEmptySet;
  (*(void (**)(uint64_t))(*(_QWORD *)CoreSchedulingSet::getEmptySet(void)::sEmptySet + 40))(CoreSchedulingSet::getEmptySet(void)::sEmptySet);
  return v1;
}

uint64_t EmptyCoreSchedulingSet::retain(uint64_t this)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(this + 16);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 + 1, v1));
  return this;
}

uint64_t HTTPProtocol::needsThrottler(HTTPProtocol *this)
{
  if (HTTPProtocol::needsThrottler(void)::sOnce != -1)
    dispatch_once(&HTTPProtocol::needsThrottler(void)::sOnce, &__block_literal_global_181);
  return HTTPProtocol::needsThrottler(void)::okToThrottle;
}

uint64_t `non-virtual thunk to'HTTP3StreamWrapper::setProperty(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8));
}

uint64_t HTTP3Stream::setProperty(uint64_t a1, int a2, void *aBlock)
{
  uint64_t v3;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  HTTPMessage *v15;
  void *v16;
  void *v17;
  CFTypeID v18;
  BOOL v19;
  _QWORD v21[2];

  v3 = 0;
  switch(a2)
  {
    case 1:
      v15 = *(HTTPMessage **)(a1 + 64);
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      HTTPMessage::setHeaderFieldStringValue(v15, 0x1171B29Fu, aBlock);
      goto LABEL_24;
    case 3:
    case 4:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 20:
    case 23:
    case 27:
      v6 = *(std::__shared_weak_count **)(a1 + 56);
      if (!v6)
        return 0;
      v8 = std::__shared_weak_count::lock(v6);
      v21[1] = v8;
      if (!v8)
        return 0;
      v9 = v8;
      v10 = *(_QWORD *)(a1 + 48);
      v21[0] = v10;
      if (v10 && (v11 = *(_QWORD *)(v10 + 1008)) != 0)
      {
        v12 = MetaNetStreamInfo::applicableToPropertyName(a2);
        v3 = (*(uint64_t (**)(uint64_t, uint64_t, void *))(*(_QWORD *)v11 + 200))(v11, v12, aBlock);
      }
      else
      {
        v3 = 0;
      }
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v14 = __ldaxr(p_shared_owners);
      while (__stlxr(v14 - 1, p_shared_owners));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
      return v3;
    case 14:
      v16 = _Block_copy(aBlock);
      v17 = *(void **)(a1 + 376);
      *(_QWORD *)(a1 + 376) = v16;

      goto LABEL_24;
    case 15:
      if (aBlock)
      {
        v18 = CFGetTypeID(aBlock);
        if (v18 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          LOWORD(v21[0]) = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)v21, 2u);
        }
        v19 = *MEMORY[0x1E0C9AE50] == (_QWORD)aBlock;
      }
      else
      {
        v19 = 0;
      }
      *(_BYTE *)(a1 + 369) = v19;
LABEL_24:
      v3 = 1;
      break;
    default:
      return v3;
  }
  return v3;
}

void sub_183EE4E7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void Deleter_CustomBlock::operator()(const void **a1)
{
  const void **v1;
  void (**v2)(void);
  void (**v3)(void);

  v1 = a1;
  v2 = (void (**)(void))*a1;
  if (v2 || (v3 = (void (**)(void))v1[1], ++v1, (v2 = v3) != 0))
  {
    v2[2]();
    _Block_release(*v1);
  }
}

uint64_t StrictSecurityPolicy::strictSecurityPolicyInEffectForURL(StrictSecurityPolicy *this, CFURLRef anURL, const __CFDictionary *a3)
{
  char v6;
  const __CFString *v7;
  _BOOL4 v8;
  int v9;
  const __CFString *v10;
  char v11;
  const __CFString *v12;
  const __CFString *v13;
  const __CFString *v14;
  const __CFString *v15;
  int v16;
  const __CFString *v17;
  const __CFDictionary *ATSExceptionForHost;
  const __CFDictionary *v19;
  const __CFString *v20;
  const void *Value;
  char v22;
  const __CFString *v23;
  const __CFDictionary *v24;
  const void *v25;
  const void *v26;
  CFTypeID v27;
  const __CFString *v28;
  const __CFString *v29;
  uint64_t v30;
  uint64_t v31;
  void *const *v32;
  unint64_t v33;
  unint64_t v34;
  CFStringRef v35;
  NSObject *v36;
  char v37;
  HSTSPolicy *v38;
  NSString *v39;
  unsigned int v40;
  uint64_t result;
  uint8_t buf[4];
  CFStringRef v43;
  __int16 v44;
  int v45;
  __int16 v46;
  image_offset *p_image_offsets;
  image_offset image_offsets;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v6 = *((_BYTE *)this + 32);
  v7 = CFURLCopyScheme(anURL);
  if (v7)
    v8 = CFStringCompare(CFSTR("http"), v7, 0) == kCFCompareEqualTo;
  else
    v8 = 0;
  v9 = (v6 & 1) == 0;
  if ((*((_BYTE *)this + 32) & 2) != 0
    && StrictSecurityPolicy::clientIsWebKit((StrictSecurityPolicy *)*((unsigned __int8 *)this + 33)))
  {
    StrictSecurityPolicy::reportATSExceptionEvent(CFSTR("NSAllowsArbitraryLoadsInWebContent"), v10);
    v11 = 1;
    v9 = 1;
  }
  else
  {
    v11 = 0;
  }
  if ((*((_BYTE *)this + 32) & 8) != 0
    && StrictSecurityPolicy::clientIsMediaserver((StrictSecurityPolicy *)*((unsigned __int8 *)this + 34)))
  {
    StrictSecurityPolicy::reportATSExceptionEvent(CFSTR("NSAllowsArbitraryLoadsForMedia"), v12);
    v11 = 1;
    v9 = 1;
  }
  v13 = CFURLCopyHostName(anURL);
  v14 = v13;
  if (!v13)
    goto LABEL_35;
  if (_isIPAddress(v13, 1))
  {
    if ((_os_feature_enabled_impl() & 1) == 0 && !dyld_program_sdk_at_least()
      || (*((_BYTE *)this + 32) & 4) != 0 && isLocalIPAddress(v14))
    {
      StrictSecurityPolicy::reportATSExceptionEvent(CFSTR("NSAllowsLocalNetworking"), v15);
      v16 = 1;
LABEL_82:
      CFRelease(v14);
      goto LABEL_83;
    }
  }
  else if ((*((_BYTE *)this + 32) & 4) != 0 && isLocalTLD(v14))
  {
    StrictSecurityPolicy::reportATSExceptionEvent(CFSTR("NSAllowsLocalNetworking"), v17);
    v11 = 1;
    v9 = 1;
  }
  ATSExceptionForHost = (const __CFDictionary *)StrictSecurityPolicy::getATSExceptionForHost((const __CFDictionary **)this, v14);
  v19 = ATSExceptionForHost;
  if (ATSExceptionForHost)
  {
    v9 = exceptionAllowsInsecureLoad(ATSExceptionForHost);
    if (v9)
    {
      StrictSecurityPolicy::reportATSExceptionEvent(CFSTR("NSExceptionDomains"), v20);
      v11 = 1;
    }
    Value = CFDictionaryGetValue(v19, CFSTR("NSATSBuiltinOverride"));
    if (v9 && Value == (const void *)*MEMORY[0x1E0C9AE50] && v8)
      logAppleATSViolation(1, v14, 0, 0);
    goto LABEL_35;
  }
  if (a3)
  {
    v22 = *((_BYTE *)this + 32);
    if ((v22 & 2) != 0)
    {
      if (CFDictionaryGetValue(a3, CFSTR("NSAllowsArbitraryLoadsInWebContent")) == (const void *)*MEMORY[0x1E0C9AE50])
      {
        v29 = CFSTR("NSAllowsArbitraryLoadsInWebContent");
        goto LABEL_47;
      }
      v22 = *((_BYTE *)this + 32);
    }
    if ((v22 & 8) != 0
      && CFDictionaryGetValue(a3, CFSTR("NSAllowsArbitraryLoadsForMedia")) == (const void *)*MEMORY[0x1E0C9AE50])
    {
      v29 = CFSTR("NSAllowsArbitraryLoadsForMedia");
    }
    else
    {
      if (CFDictionaryGetValue(a3, CFSTR("NSAllowsArbitraryLoads")) != (const void *)*MEMORY[0x1E0C9AE50])
        goto LABEL_35;
      v29 = CFSTR("NSAllowsArbitraryLoads");
    }
LABEL_47:
    StrictSecurityPolicy::reportATSExceptionEvent(v29, v23);
    goto LABEL_48;
  }
LABEL_35:
  if ((v11 & 1) == 0 && (v8 & v9) != 0)
  {
    v24 = (const __CFDictionary *)*((_QWORD *)this + 1);
    if (v24)
    {
      v25 = CFDictionaryGetValue(v24, CFSTR("NSAllowsArbitraryLoads"));
      v26 = v25;
      if (v25)
      {
        v27 = CFGetTypeID(v25);
        if (v27 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)image_offsets.uuid = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", image_offsets.uuid, 2u);
        }
        if ((const void *)*MEMORY[0x1E0C9AE50] == v26)
          StrictSecurityPolicy::reportATSExceptionEvent(CFSTR("NSAllowsArbitraryLoads"), v28);
      }
    }
  }
LABEL_48:
  if ((v9 & 1) != 0)
  {
    v16 = 1;
  }
  else
  {
    if (v8)
    {
      if (StrictSecurityPolicy::ATSLogLevel(void)::logATSOnce != -1)
        dispatch_once(&StrictSecurityPolicy::ATSLogLevel(void)::logATSOnce, &__block_literal_global_31);
      if (StrictSecurityPolicy::ATSLogLevel(void)::atslogLevel == 2)
      {
        CFLog();
      }
      else
      {
        v30 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_60_9100, 1);
        v31 = v30;
        if (v30
          && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v30 + 16))(v30, "ATS Resource Blocked", 0))
        {
          (*(void (**)(uint64_t, const char *, CFURLRef))(*(_QWORD *)v31 + 40))(v31, "Blocked", anURL);
          (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
        }
        if (__CFNIsRunningInXcode::envCheckOnce != -1)
          dispatch_once(&__CFNIsRunningInXcode::envCheckOnce, &__block_literal_global_29);
        if ((__CFNIsRunningInXcode::runningInXcode & 1) != 0)
        {
          v32 = (void *const *)objc_msgSend(*((id *)this + 5), "bytes");
          v33 = objc_msgSend(*((id *)this + 5), "length");
          if (v33 >> 3 >= 0x33)
            LODWORD(v34) = 51;
          else
            v34 = v33 >> 3;
          backtrace_image_offsets(v32, &image_offsets, v34);
          v35 = CFURLCopyHostName(anURL);
          if (__CFNRuntimeIssuesLogHandle::onceToken != -1)
            dispatch_once(&__CFNRuntimeIssuesLogHandle::onceToken, &__block_literal_global_4_4760);
          v36 = __CFNRuntimeIssuesLogHandle::logger;
          if (os_log_type_enabled((os_log_t)__CFNRuntimeIssuesLogHandle::logger, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 138412802;
            v43 = v35;
            v44 = 1040;
            v45 = 20 * v34;
            v46 = 2096;
            p_image_offsets = &image_offsets;
            _os_log_fault_impl(&dword_183ECA000, v36, OS_LOG_TYPE_FAULT, "App Transport Security has blocked a cleartext HTTP connection to %@ since it is insecure. Use HTTPS instead or add this domain to Exception Domains in your Info.plist.%{xcode:text-backtrace}.*P", buf, 0x1Cu);
          }
          CFRelease(v35);
        }
      }
    }
    if (StrictSecurityPolicy::HardATSFailures(void)::hardATSFailuresOnce != -1)
      dispatch_once(&StrictSecurityPolicy::HardATSFailures(void)::hardATSFailuresOnce, &__block_literal_global_27);
    v16 = StrictSecurityPolicy::HardATSFailures(void)::hardATSFailures;
  }
  if ((*((_BYTE *)this + 32) & 0x10) != 0 && v16)
  {
    if (isSafariApp(void)::onceToken != -1)
      dispatch_once(&isSafariApp(void)::onceToken, &__block_literal_global_150);
    if (isSafariApp(void)::isSafariProcess)
      v37 = 1;
    else
      v37 = !v8;
    if ((v37 & 1) == 0)
      logAppleATSViolation(0, v14, 0, 0);
  }
  if (v14)
    goto LABEL_82;
LABEL_83:
  if (v7)
    CFRelease(v7);
  if (!v16)
    return 2;
  image_offsets.uuid[0] = 0;
  if (!anURL)
    return 0;
  v38 = *(HSTSPolicy **)this;
  v39 = (NSString *)-[__CFURL host](anURL, "host");
  if (!v39)
    return 0;
  v40 = HSTSPolicy::isKnownHSTSHost(v38, v39, image_offsets.uuid);
  result = image_offsets.uuid[0] ? 3 : 1;
  if (!v40)
    return 0;
  return result;
}

void sub_183EE5528(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;

  CFRelease(v2);
  if (v1)
    CFRelease(v1);
  _Unwind_Resume(a1);
}

CFIndex isLocalTLD(const __CFString *a1)
{
  CFIndex result;

  result = CFStringGetLength(a1);
  if (result)
    return CFStringHasSuffix(a1, CFSTR(".local"))
        || CFStringHasSuffix(a1, CFSTR(".local."))
        || CFStringFind(a1, CFSTR("."), 4uLL).location == -1;
  return result;
}

void *StrictSecurityPolicy::getATSExceptionForHost(const __CFDictionary **this, const __CFString *a2)
{
  UInt8 *v4;
  uint64_t v5;
  void *Exception;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  CFMutableDictionaryRef Mutable;
  const __CFDictionary *v10;
  uint64_t v11;
  const __CFString *v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  const __CFDictionary *v15;
  const void *Value;
  const void *v17;
  CFTypeID v18;
  char v19;
  unint64_t v20;
  const __CFDictionary *v21;
  char v22;
  BOOL v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  const void *v28;
  CFStringRef theString;
  std::__shared_weak_count *v30;
  uint8_t buf[16];
  const __CFString *v32;
  uint64_t v33;
  void (*v34)(uint64_t, __CFString *);
  void *v35;
  CFMutableDictionaryRef v36;
  CFAllocatorRef allocator;
  uint64_t v38;
  void *ptr;
  UInt8 v40[1024];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  StrictSecurityPolicy::SanitizedString((StrictSecurityPolicy *)&theString, a2);
  if (!theString)
  {
    Exception = 0;
    goto LABEL_49;
  }
  allocator = 0;
  v38 = 1023;
  v4 = _CFStringGetOrCreateCString(0, theString, v40, &v38, 0x8000100u);
  ptr = v4;
  if (!v4)
    goto LABEL_43;
  v5 = v38;
  Exception = (void *)StrictSecurityPolicy::getException((StrictSecurityPolicy *)this, a2);
  if (Exception)
    goto LABEL_44;
  if (!_isIPAddress(a2, 1))
  {
    v11 = 0;
    Exception = 0;
    v28 = (const void *)*MEMORY[0x1E0C9AE50];
    while (1)
    {
      if (v11 >= v5)
        goto LABEL_44;
      while (v4[v11] != 46)
      {
        if (v5 == ++v11)
        {
          v11 = v5;
          break;
        }
      }
      if (v5 <= ++v11)
        goto LABEL_44;
      v12 = CFStringCreateWithBytes(0, &v4[v11], v5 - v11, 0x8000100u, 0);
      v32 = v12;
      v13 = (std::__shared_weak_count *)operator new();
      v13->__shared_owners_ = 0;
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      v13->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19E8;
      v13->__shared_weak_owners_ = 0;
      v13[1].__vftable = (std::__shared_weak_count_vtbl *)v12;
      v33 = (uint64_t)v13;
      if (v12)
      {
        v15 = (const __CFDictionary *)StrictSecurityPolicy::getException((StrictSecurityPolicy *)this, v12);
        Exception = v15;
        if (v15)
        {
          Value = CFDictionaryGetValue(v15, CFSTR("NSIncludesSubdomains"));
          v17 = Value;
          if (Value)
          {
            v18 = CFGetTypeID(Value);
            if (v18 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
            }
            if (v28 == v17)
            {
              v19 = 0;
              goto LABEL_25;
            }
          }
          Exception = 0;
        }
      }
      v19 = 1;
      do
LABEL_25:
        v20 = __ldaxr(p_shared_owners);
      while (__stlxr(v20 - 1, p_shared_owners));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
      if ((v19 & 1) == 0)
        goto LABEL_44;
    }
  }
  v7 = this[3];
  if (v7)
    goto LABEL_37;
  v8 = StrictSecurityPolicy::exceptionDomains((StrictSecurityPolicy *)this);
  if (v8)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v32 = (const __CFString *)MEMORY[0x1E0C809B0];
    v33 = 3221225472;
    v34 = ___ZN20StrictSecurityPolicy19parseCIDRExceptionsEv_block_invoke;
    v35 = &__block_descriptor_40_e15_v32__0_8_16_B24l;
    v36 = Mutable;
    -[__CFDictionary enumerateKeysAndObjectsUsingBlock:](v8, "enumerateKeysAndObjectsUsingBlock:", &v32);
    if (Mutable)
      v10 = (const __CFDictionary *)CFRetain(Mutable);
    else
      v10 = 0;
    v21 = this[3];
    this[3] = v10;
    if (v21)
      CFRelease(v21);
    if (Mutable)
      CFRelease(Mutable);
  }
  v7 = this[3];
  if (v7)
  {
LABEL_37:
    if (CFDictionaryGetCount(v7) >= 1)
    {
      v32 = 0;
      v33 = 0;
      LODWORD(v35) = 0;
      v34 = 0;
      if (convertIPAddress(a2, 2, (char *)&v32 + 4))
      {
        v22 = 2;
LABEL_42:
        Exception = (void *)StrictSecurityPolicy::getCIDRException((StrictSecurityPolicy *)this, (uint64_t)&v32, v22);
        goto LABEL_44;
      }
      if (convertIPAddress(a2, 30, &v33))
      {
        v22 = 30;
        goto LABEL_42;
      }
    }
  }
LABEL_43:
  Exception = 0;
LABEL_44:
  if (ptr)
    v23 = v40 == ptr;
  else
    v23 = 1;
  if (!v23)
    CFAllocatorDeallocate(allocator, ptr);
LABEL_49:
  v24 = v30;
  if (v30)
  {
    v25 = (unint64_t *)&v30->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  return Exception;
}

void sub_183EE59B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, CFAllocatorRef allocator,uint64_t a21,void *ptr)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

const void *StrictSecurityPolicy::getException(StrictSecurityPolicy *this, const __CFString *a2)
{
  const __CFDictionary *v4;
  const void *Value;
  CFTypeID TypeID;
  NSObject *v7;
  uint8_t v9[16];

  v4 = StrictSecurityPolicy::exceptionDomains(this);
  if (!v4)
    return 0;
  Value = CFDictionaryGetValue(v4, a2);
  if (Value)
  {
    TypeID = CFDictionaryGetTypeID();
    if (TypeID != CFGetTypeID(Value))
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v7 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v9 = 0;
        _os_log_error_impl(&dword_183ECA000, v7, OS_LOG_TYPE_ERROR, "Invalid Exception Format", v9, 2u);
      }
      StrictSecurityPolicy::_fallbackToATSMode(this, "Invalid Exception Format");
      return 0;
    }
  }
  return Value;
}

const __CFDictionary *StrictSecurityPolicy::exceptionDomains(StrictSecurityPolicy *this)
{
  const __CFDictionary *result;
  const __CFDictionary *v3;
  CFTypeID TypeID;
  NSObject *v5;
  const void *v6;
  uint8_t v7[16];

  result = (const __CFDictionary *)*((_QWORD *)this + 2);
  if (!result)
  {
    result = (const __CFDictionary *)*((_QWORD *)this + 1);
    if (result)
    {
      result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("NSExceptionDomains"));
      if (result)
      {
        v3 = result;
        TypeID = CFDictionaryGetTypeID();
        if (TypeID == CFGetTypeID(v3))
        {
          result = (const __CFDictionary *)CFRetain(v3);
        }
        else
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v5 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)v7 = 0;
            _os_log_error_impl(&dword_183ECA000, v5, OS_LOG_TYPE_ERROR, "Invalid ATS format (Domains)", v7, 2u);
          }
          StrictSecurityPolicy::_fallbackToATSMode(this, "Invalid ATS format (Domains)");
          result = 0;
        }
      }
    }
    v6 = (const void *)*((_QWORD *)this + 2);
    *((_QWORD *)this + 2) = result;
    if (v6)
    {
      CFRelease(v6);
      return (const __CFDictionary *)*((_QWORD *)this + 2);
    }
  }
  return result;
}

uint64_t _isIPAddress(const __CFString *a1, int a2)
{
  CFIndex Length;
  uint64_t result;
  _BYTE v6[255];
  char buffer[57];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  result = 0;
  if (Length)
  {
    if (Length <= 56)
    {
      result = CFStringGetCString(a1, buffer, 57, 0x600u);
      if ((_DWORD)result)
      {
        result = inet_pton(30, buffer, v6);
        if ((_DWORD)result != 1)
          return a2 && inet_pton(2, buffer, v6) == 1;
      }
    }
  }
  return result;
}

uint64_t HSTSPolicy::isKnownHSTSHost(HSTSPolicy *this, unsigned __int8 *a2, CFIndex a3, unsigned __int8 *a4)
{
  uint64_t v8;
  const __CFString *v10;
  unint64_t v11;
  double v12;
  NSObject *v13;
  const __CFDictionary *v14;
  const __CFNumber *Value;
  const __CFNumber *v16;
  CFTypeID v17;
  const void *v18;
  CFTypeID v19;
  const void *v21;
  const void *v22;
  CFTypeID v23;
  int v24;
  std::__shared_weak_count *v25;
  unint64_t *p_shared_owners;
  unint64_t v27;
  const unsigned __int8 *DotInDomainName;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  const void *v32;
  CFTypeRef cf;
  std::__shared_weak_count *v34;
  CFStringRef theString1;
  std::__shared_weak_count *v36;
  double block[7];
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;

  if (_HSTSIsDisabled(void)::sDisableHSTSOnce != -1)
    dispatch_once(&_HSTSIsDisabled(void)::sDisableHSTSOnce, &__block_literal_global_11);
  if (_HSTSIsDisabled(void)::sHSTSIsDisabled)
    return 0;
  StrictSecurityPolicy::SanitizedString((StrictSecurityPolicy *)&theString1, a2, a3);
  v10 = theString1;
  if (theString1)
  {
    if (CFStringCompare(theString1, CFSTR("adobepass.ios.app"), 1uLL) == kCFCompareEqualTo
      || CFStringCompare(theString1, CFSTR("mms.um.idmobile.co.uk"), 1uLL) == kCFCompareEqualTo)
    {
      goto LABEL_49;
    }
    v10 = theString1;
  }
  if ((forceHTTPSByHSTSPreload(v10) & 1) == 0)
  {
    if (a3 >= 2)
    {
      if (a2[a3 - 1] == 46)
        --a3;
      goto LABEL_17;
    }
    if (a3)
    {
LABEL_17:
      v11 = 0;
      v32 = (const void *)*MEMORY[0x1E0C9AE50];
      while (1)
      {
        StrictSecurityPolicy::SanitizedString((StrictSecurityPolicy *)&cf, &a2[v11], a3 - v11);
        if (!cf)
          goto LABEL_35;
        v12 = *((double *)this + 2);
        v38 = 0;
        v39 = &v38;
        v40 = 0x2020000000;
        v41 = 0;
        v13 = *(NSObject **)(*(_QWORD *)&v12 + 16);
        *(_QWORD *)&block[0] = MEMORY[0x1E0C809B0];
        *(_QWORD *)&block[1] = 3221225472;
        *(_QWORD *)&block[2] = ___ZN9HSTSCache22copyHSTSInfoDictionaryEPK10__CFString_block_invoke;
        *(_QWORD *)&block[3] = &unk_1E14FD7A8;
        *(_QWORD *)&block[4] = &v38;
        block[5] = v12;
        *(_QWORD *)&block[6] = cf;
        dispatch_sync(v13, block);
        v14 = (const __CFDictionary *)v39[3];
        _Block_object_dispose(&v38, 8);
        if (!v14)
        {
LABEL_35:
          v24 = 0;
          v8 = 0;
          goto LABEL_39;
        }
        Value = (const __CFNumber *)CFDictionaryGetValue(v14, CFSTR("Expiry"));
        v16 = Value;
        if (!Value)
          break;
        v17 = CFGetTypeID(Value);
        if (v17 != CFNumberGetTypeID())
          break;
        block[0] = -1.0;
        CFNumberGetValue(v16, kCFNumberDoubleType, block);
        if (CFAbsoluteTimeGetCurrent() >= block[0])
          break;
        v18 = CFDictionaryGetValue(v14, CFSTR("HSTS Host"));
        v8 = (uint64_t)v18;
        if (v18)
        {
          v19 = CFGetTypeID(v18);
          v8 = v19 == CFBooleanGetTypeID() && v8 == (_QWORD)v32;
        }
        if (!v11)
          goto LABEL_37;
        v21 = CFDictionaryGetValue(v14, CFSTR("Include Subdomains"));
        v22 = v21;
        if (v21)
        {
          v23 = CFGetTypeID(v21);
          if (v23 == CFBooleanGetTypeID() && v22 == v32)
            goto LABEL_37;
        }
        v8 = 0;
        v24 = 6;
LABEL_38:
        CFRelease(v14);
LABEL_39:
        v25 = v34;
        if (v34)
        {
          p_shared_owners = (unint64_t *)&v34->__shared_owners_;
          do
            v27 = __ldaxr(p_shared_owners);
          while (__stlxr(v27 - 1, p_shared_owners));
          if (!v27)
          {
            ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
            std::__shared_weak_count::__release_weak(v25);
          }
        }
        if (v24 == 6 || !v24)
        {
          DotInDomainName = HSTSParser::indexOfFirstDotInDomainName((HSTSParser *)&a2[v11], (const unsigned __int8 *)a3);
          if (!(_DWORD)v8)
          {
            v11 += (unint64_t)(DotInDomainName + 1);
            if (v11 < a3)
              continue;
          }
        }
        goto LABEL_50;
      }
      HSTSCache::modifyHSTSStore(*((HSTSCache **)this + 2), cf, 0, 0);
      v8 = 0;
LABEL_37:
      v24 = 4;
      goto LABEL_38;
    }
LABEL_49:
    v8 = 0;
    goto LABEL_50;
  }
  v8 = 1;
  *a4 = 1;
LABEL_50:
  v29 = v36;
  if (v36)
  {
    v30 = (unint64_t *)&v36->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  return v8;
}

void sub_183EE6028(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  const void *v12;

  CFRelease(v12);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a12);
  _Unwind_Resume(a1);
}

void StrictSecurityPolicy::SanitizedString(StrictSecurityPolicy *this, const unsigned __int8 *a2, CFIndex a3)
{
  const __CFString *v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  __int128 v8;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  v4 = CFStringCreateWithBytes(0, a2, a3, 0x8000100u, 0);
  if (v4)
  {
    StrictSecurityPolicy::SanitizedString((StrictSecurityPolicy *)&v8, v4);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this, &v8);
    v5 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
    if (*((_QWORD *)&v8 + 1))
    {
      v6 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    CFRelease(v4);
  }
}

void sub_183EE6110(_Unwind_Exception *a1)
{
  const void *v1;
  uint64_t v2;

  CFRelease(v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  _Unwind_Resume(a1);
}

void StrictSecurityPolicy::SanitizedString(StrictSecurityPolicy *this, const __CFString *a2)
{
  const __CFString *v3;
  const __CFString *v4;
  CFIndex Length;
  __CFString *MutableCopy;
  _QWORD *v7;

  v3 = CFURLCreateStringByReplacingPercentEscapes(0, a2, &stru_1E1500C68);
  v4 = v3;
  if (v3)
  {
    Length = CFStringGetLength(v3);
    MutableCopy = CFStringCreateMutableCopy(0, Length, v4);
    v7 = (_QWORD *)operator new();
    *v7 = &off_1E14F1010;
    v7[1] = 0;
    v7[2] = 0;
    v7[3] = MutableCopy;
    CFStringLowercase(MutableCopy, 0);
    *(_QWORD *)this = MutableCopy;
    *((_QWORD *)this + 1) = v7;
    CFRelease(v4);
  }
  else
  {
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = 0;
  }
}

void sub_183EE61F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  const void *v9;

  CFRelease(v9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

const unsigned __int8 *HSTSParser::indexOfFirstDotInDomainName(HSTSParser *this, const unsigned __int8 *a2)
{
  size_t v4;
  uint64_t v5;
  uint64_t v6;

  if (this)
  {
    v4 = strlen((const char *)this);
    v5 = 64;
    if (v4 < 0x40)
      v5 = v4;
    if (v5)
    {
      v6 = 0;
      while (*((_BYTE *)this + v6) != 46)
      {
        if (v5 == ++v6)
          return a2;
      }
      return (const unsigned __int8 *)v6;
    }
  }
  return a2;
}

void AuthenticationState::~AuthenticationState(AuthenticationState *this)
{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(_QWORD *)this = &off_1E14E9AE8;
  *((_QWORD *)this + 11) = &unk_1E14E9B18;
  v2 = *((_QWORD *)this + 18);
  *((_QWORD *)this + 18) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 128);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 104);
  *((_QWORD *)this + 11) = &off_1E14E5838;
  *(_QWORD *)this = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

{
  AuthenticationState::~AuthenticationState(this);
  JUMPOUT(0x186DB748CLL);
}

void AuthenticationConfiguration::~AuthenticationConfiguration(AuthenticationConfiguration *this)
{
  *(_QWORD *)this = &off_1E14E5838;
  JUMPOUT(0x186DB748CLL);
}

{
  *(_QWORD *)this = &off_1E14E5838;
}

uint64_t ___ZN12HTTPProtocol14bytesAvailableEPU27objcproto16OS_dispatch_data8NSObject_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, const UInt8 *a4, uint64_t a5)
{
  uint64_t v7;
  int v8;
  const __CFAllocator *v10;
  _OWORD *v11;
  const void *v12;
  CFIndex v13;
  const __CFAllocator *v14;
  __CFData *MutableCopy;
  const __CFData *v16;
  CFIndex Length;
  const void *v18;
  const __CFAllocator *v20;
  const __CFData *v21;
  uint64_t v22;
  const __CFAllocator *v23;
  uint64_t v24;
  BOOL v25;
  UInt8 *BytePtr;
  CFIndex v27;
  const UInt8 *v28;
  CFIndex v29;
  const unsigned __int8 *v30;
  size_t v31;
  const __CFData *v32;
  CFIndex v33;
  UInt8 *v34;
  int64_t v35;
  const __CFAllocator *v36;
  const __CFData *v37;
  const unsigned __int8 *v39;
  _BOOL4 v40;
  const unsigned __int8 *DelimiterInBytes;
  const void *v42;
  const unsigned __int8 *v43;
  const void *v44;
  unsigned __int8 *v45;
  _BOOL4 v46;
  CFTypeRef v49;
  uint64_t v50;
  unint64_t v51;
  const __CFAllocator *v52;
  __CFData *Mutable;
  const void *v54;
  const char *v55;
  void *v56;
  CFAbsoluteTime *Property;
  CFAbsoluteTime *v58;
  const void *v59;
  const __CFAllocator *v60;
  __CFData *v61;
  CFTypeRef cf;
  const __CFData *v63;
  size_t v64;
  const unsigned __int8 *v65;
  unsigned __int8 v66[2];
  unsigned __int8 *v67;
  uint8_t buf[8];

  if (!a5)
    return 1;
  v7 = *(_QWORD *)(a1 + 32);
  v8 = *(_DWORD *)(v7 + 200);
  *(_QWORD *)(v7 + 520) += a5;
  if (v8 - 5 < 2 || v8 == 3)
  {
    if (*(_QWORD *)(v7 + 216)
      || (v10 = CFGetAllocator((CFTypeRef)(v7 - 16)),
          v11 = CFURLDataDecoderCreateWithContentEncoding(v10, v8),
          (*(_QWORD *)(v7 + 216) = v11) != 0))
    {
      v12 = *(const void **)(v7 + 224);
      if (v12)
      {
        v13 = CFDataGetLength(*(CFDataRef *)(v7 + 224)) + a5;
        v14 = CFGetAllocator(v12);
        MutableCopy = CFDataCreateMutableCopy(v14, v13, (CFDataRef)v12);
        v16 = MutableCopy;
        if (MutableCopy)
        {
          CFDataAppendBytes(MutableCopy, a4, a5);
          Length = CFDataGetLength(v16);
          if (Length != CFDataGetLength((CFDataRef)v12) + a5
            && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "unable to append to this buffer", buf, 2u);
          }
        }
        v18 = *(const void **)(v7 + 224);
        *(_QWORD *)(v7 + 224) = 0;
        if (v18)
          CFRelease(v18);
        if (!v16)
          goto LABEL_38;
      }
      else
      {
        v23 = CFGetAllocator((CFTypeRef)(v7 - 16));
        v16 = CFDataCreateWithBytesNoCopy(v23, a4, a5, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
        if (!v16)
        {
LABEL_38:
          v22 = -998;
          goto LABEL_39;
        }
      }
      buf[0] = 0;
      v24 = CFURLDataDecoderDecodeData(*(_QWORD *)(v7 + 216), (uint64_t)v16, (uint64_t)buf);
      if (v24)
        v25 = 1;
      else
        v25 = buf[0] == 0;
      if (!v25)
      {
        v36 = CFGetAllocator((CFTypeRef)(v7 - 16));
        *(_QWORD *)(v7 + 224) = CFDataCreateCopy(v36, v16);
        v37 = v16;
        goto LABEL_94;
      }
      v21 = (const __CFData *)v24;
      CFRelease(v16);
      if (!v21)
      {
        v22 = -1015;
        goto LABEL_39;
      }
      goto LABEL_30;
    }
LABEL_22:
    v22 = -1016;
LABEL_39:
    HTTPProtocol::sendError((HTTPProtocol *)v7, (const __CFString *)v22);
    HTTPProtocol::cleanupStreams((HTTPProtocol *)v7);
    return 0;
  }
  if (v8 != 2)
    goto LABEL_22;
  v20 = CFGetAllocator((CFTypeRef)(v7 - 16));
  v21 = CFDataCreate(v20, a4, a5);
  if (!v21)
    goto LABEL_38;
LABEL_30:
  if (!*(_QWORD *)(v7 + 232))
  {
    if (v8 <= 6u && ((1 << v8) & 0x68) != 0)
    {
      *(_QWORD *)(v7 + 528) += CFDataGetLength(v21);
      objc_msgSend(*(id *)(v7 + 80), "_appendCountOfPendingBytesReceivedEncoded:", a5);
    }
    HTTPProtocol::sendDidLoadData((HTTPProtocol *)v7, (char *)v21, a5);
    goto LABEL_93;
  }
  BytePtr = (UInt8 *)CFDataGetBytePtr(v21);
  v27 = CFDataGetLength(v21);
  v28 = CFDataGetBytePtr(*(CFDataRef *)(v7 + 240));
  v29 = CFDataGetLength(*(CFDataRef *)(v7 + 240));
  v30 = CFDataGetBytePtr(*(CFDataRef *)(v7 + 232));
  v31 = CFDataGetLength(*(CFDataRef *)(v7 + 232));
  v32 = *(const __CFData **)(v7 + 256);
  v63 = v21;
  v64 = v29;
  v65 = v28;
  if (v32)
  {
    v33 = CFDataGetLength(v32);
    CFDataAppendBytes(*(CFMutableDataRef *)(v7 + 256), BytePtr, v27);
    v34 = (UInt8 *)CFDataGetBytePtr(*(CFDataRef *)(v7 + 256));
    v27 = CFDataGetLength(*(CFDataRef *)(v7 + 256));
    if (*v34 == *v28)
      v35 = v29;
    else
      v35 = v31;
    if (v33 <= v35)
      BytePtr = v34;
    else
      BytePtr = &v34[v33 - v35];
  }
  else
  {
    v34 = BytePtr;
  }
  v67 = 0;
  *(_QWORD *)buf = 0;
  v39 = &v34[v27];
  cf = (CFTypeRef)(v7 - 16);
  LOBYTE(v40) = 1;
  while (1)
  {
    *(_WORD *)v66 = 0;
    if (v40)
    {
      DelimiterInBytes = _findDelimiterInBytes(BytePtr, v39 - BytePtr, v65, v64, (const unsigned __int8 **)&v67, v66);
      v40 = DelimiterInBytes != &BytePtr[v27];
    }
    else
    {
      v40 = 0;
      DelimiterInBytes = 0;
    }
    v42 = *(const void **)(v7 + 232);
    if (v42 == *(const void **)(v7 + 240))
    {
      v43 = 0;
      v45 = v67;
LABEL_67:
      v44 = v42;
      goto LABEL_68;
    }
    v43 = _findDelimiterInBytes(BytePtr, v39 - BytePtr, v30, v31, (const unsigned __int8 **)buf, &v66[1]);
    v42 = *(const void **)(v7 + 232);
    v44 = *(const void **)(v7 + 240);
    v45 = v67;
    if (v42 == v44)
      goto LABEL_67;
    if (v67)
      v46 = v40;
    else
      v46 = 0;
    if (!v46 || *(_QWORD *)buf == 0 || DelimiterInBytes >= v43)
    {
      v45 = *(unsigned __int8 **)buf;
      DelimiterInBytes = v43;
      goto LABEL_76;
    }
LABEL_68:
    *(_QWORD *)buf = v45;
    v66[1] = v66[0];
    if (v42 != v44 && v43 - DelimiterInBytes == 2)
    {
      if (v42)
      {
        CFRelease(v42);
        v44 = *(const void **)(v7 + 240);
      }
      v31 = v64;
      if (v44)
        v49 = CFRetain(v44);
      else
        v49 = 0;
      *(_QWORD *)(v7 + 232) = v49;
      v30 = v65;
    }
LABEL_76:
    if (DelimiterInBytes != v34)
    {
      v50 = *(unsigned int *)(v7 + 192);
      v51 = v50 | ((unint64_t)*(unsigned __int16 *)(v7 + 196) << 32);
      if ((v50 & 0x400) != 0)
      {
        HTTPProtocol::fixupAndSendMultiPartData((HTTPProtocol *)v7, v34, DelimiterInBytes - v34, (v50 >> 12) & 1);
        v51 = *(unsigned int *)(v7 + 192) | ((unint64_t)*(unsigned __int16 *)(v7 + 196) << 32);
      }
      *(_WORD *)(v7 + 196) = WORD2(v51);
      *(_DWORD *)(v7 + 192) = v51 & 0xFFFFEFFF;
    }
    if (!v45)
      break;
    *(_DWORD *)(v7 + 192) |= 0x1400u;
    if (v66[1])
    {
      HTTPProtocol::fixupAndSendMultiPartData((HTTPProtocol *)v7, 0, 0, 1);
      v56 = *(void **)(v7 + 832);
      if (v56)
      {
        Property = (CFAbsoluteTime *)objc_getProperty(v56, v55, 96, 1);
        if (Property)
        {
          v58 = Property;
          Property[25] = CFAbsoluteTimeGetCurrent();
          *((_OWORD *)v58 + 2) = *((_OWORD *)v58 + 8);
        }
      }
      URLProtocol::sendDidFinishLoading((URLProtocol *)v7);
LABEL_92:
      v21 = v63;
      goto LABEL_93;
    }
    v27 = v39 - v45;
    BytePtr = v45;
    v34 = v45;
  }
  if (DelimiterInBytes == v39)
  {
    v59 = *(const void **)(v7 + 256);
    *(_QWORD *)(v7 + 256) = 0;
    v21 = v63;
    if (v59)
      CFRelease(v59);
  }
  else
  {
    if (DelimiterInBytes != BytePtr)
    {
      v52 = CFGetAllocator(cf);
      Mutable = CFDataCreateMutable(v52, 0);
      CFDataAppendBytes(Mutable, DelimiterInBytes, v39 - DelimiterInBytes);
      v54 = *(const void **)(v7 + 256);
      if (v54)
        CFRelease(v54);
      *(_QWORD *)(v7 + 256) = Mutable;
      goto LABEL_92;
    }
    v21 = v63;
    if (!*(_QWORD *)(v7 + 256))
    {
      v60 = CFGetAllocator(cf);
      v61 = CFDataCreateMutable(v60, 0);
      *(_QWORD *)(v7 + 256) = v61;
      CFDataAppendBytes(v61, v34, v27);
    }
  }
LABEL_93:
  v37 = v21;
LABEL_94:
  CFRelease(v37);
  return 1;
}

uint64_t CFURLDataDecoderDecodeData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  const void *v7;
  uint64_t v8;
  CFAllocatorRef v9;

  if (URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder != -1)
    dispatch_once(&URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder, &__block_literal_global_2558);
  if (a1)
    v6 = a1 + 16;
  else
    v6 = 0;
  v7 = (const void *)(v6 - 16);
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 56))(v6);
  v9 = CFGetAllocator(v7);
  return (*(uint64_t (**)(uint64_t, CFAllocatorRef, uint64_t, uint64_t))(*(_QWORD *)v8 + 24))(v8, v9, a2, a3);
}

uint64_t GZIPDataDecoderHolder::decoder(GZIPDataDecoderHolder *this)
{
  return (uint64_t)this + 8;
}

void std::__shared_ptr_pointer<__CFHTTPMessage *,Deleter_CFRelease,std::allocator<__CFHTTPMessage>>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 24);
  if (v1)
    CFRelease(v1);
}

void HTTPProtocol::asynchronouslyCreateAndOpenStream(HTTPProtocol *this, const _CFCachedURLResponse *a2)
{
  int v3;
  const void *v5;
  void *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  const __CFArray *v10;
  _CFCachedURLResponse *v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  NSObject *v15;
  _BOOL4 v16;
  int v17;
  int v18;
  NSObject *v19;
  NSObject *v20;
  CFHTTPMessageRef v21;
  const _CFURLRequest *v22;
  CFHTTPMessageRef Request;
  CFStringRef v24;
  uint64_t v25;
  uint64_t v26;
  __CFHTTPMessage *v27;
  const __CFString *v28;
  SEL v29;
  const __CFURL *v30;
  HTTPMessage *v31;
  const __CFDictionary *v32;
  const __CFDictionary *v33;
  CFStringRef v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const char *v42;
  uint64_t v43;
  const char *v44;
  const __CFString *v45;
  uint64_t *v46;
  void *v47;
  SEL v48;
  id Property;
  SEL v50;
  const char *v51;
  const __CFString *v52;
  uint64_t *v53;
  const char *v54;
  const __CFString *v55;
  __CFString *v56;
  __CFString *v57;
  SEL v58;
  const __CFString *v59;
  unsigned int v60;
  const __CFString *v61;
  const char *v62;
  const __CFString *v63;
  const __CFAllocator *v64;
  const __CFString *v65;
  const char *v66;
  id v67;
  uint64_t v68;
  SEL v69;
  id v70;
  void *v71;
  void *v72;
  void *v73;
  id v74;
  void *v75;
  const __CFArray *v76;
  uint64_t v77;
  uint64_t v78;
  BOOL v79;
  uint64_t v80;
  const __CFString *v81;
  uint64_t v82;
  __int128 buf;
  uint64_t (*v84)(uint64_t, CFDictionaryRef);
  void *v85;
  HTTPProtocol *v86;
  CFHTTPMessageRef v87;
  uint64_t v88;

  v88 = *MEMORY[0x1E0C80C00];
  v3 = *((_DWORD *)this + 48);
  if ((v3 & 1) == 0)
  {
    *((_WORD *)this + 98) = *((_WORD *)this + 98);
    *((_DWORD *)this + 48) = v3 | 1;
    v5 = (const void *)*((_QWORD *)this + 50);
    if (v5)
    {
      CFRelease(v5);
      *((_QWORD *)this + 50) = 0;
    }
    v6 = (void *)*((_QWORD *)this + 10);
    if (v6)
    {
      v7 = (*((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32)) & 0xFFFFF7FFFFFFFFFFLL;
      *((_DWORD *)this + 48) = *((_DWORD *)this + 48);
      *((_WORD *)this + 98) = WORD2(v7);
      objc_msgSend(v6, "set_resolvedCNAMEChain:", 0);
      objc_msgSend(v6, "set_TLSNegotiatedCipherSuite:", 0);
    }
    v8 = *((_QWORD *)this + 35);
    if (v8)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 48))(v8);
      *((_QWORD *)this + 35) = 0;
    }
    v9 = *((_DWORD *)this + 48) & 0xFFFFFF7F | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
    *((_DWORD *)this + 48) = *((_DWORD *)this + 48) & 0xFFFFFD7F | 0x200;
    *((_WORD *)this + 98) = WORD2(v9);
    v10 = (const __CFArray *)*((_QWORD *)this + 37);
    if (!v10)
      goto LABEL_101;
    if (!CFArrayGetCount(v10))
      goto LABEL_101;
    v11 = (_CFCachedURLResponse *)*((_QWORD *)this + 11);
    if (!v11)
      goto LABEL_101;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v12 = objc_msgSend(v6, "resumableUploadState");
      if (!v12)
        goto LABEL_101;
      v13 = v12;
      v14 = *(_BYTE *)(v12 + 10);
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v15 = (id)CFNLog::logger;
      v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG);
      if ((v14 & 1) == 0)
      {
        if (v16)
        {
          v60 = *(_DWORD *)(v13 + 12) + 1;
          if (v60 > 5)
            v61 = CFSTR("unknown");
          else
            v61 = off_1E14F6E70[v60];
          LODWORD(buf) = 138412290;
          *(_QWORD *)((char *)&buf + 4) = v61;
          _os_log_debug_impl(&dword_183ECA000, v15, OS_LOG_TYPE_DEBUG, "ResumableUploadState: copyMessageForRequest with state: %@", (uint8_t *)&buf, 0xCu);
        }

        v17 = *(char *)(v13 + 9);
        v18 = *(_DWORD *)(v13 + 12);
        if (v17 < 4)
        {
          switch(v18)
          {
            case 0:
              goto LABEL_69;
            case 1:
              if (*(_DWORD *)(v13 + 16) == -1)
                goto LABEL_78;
              *(_BYTE *)(v13 + 9) = v17 + 1;
              v47 = (void *)-[_CFCachedURLResponse mutableCopy](v11, "mutableCopy");
              CFURLRequestSetHTTPRequestMethod(v47, CFSTR("PATCH"));
              Property = objc_getProperty((id)v13, v48, 48, 1);
              CFURLRequestSetURL(v47, Property);
              if ((objc_msgSend(objc_getProperty((id)v13, v50, 56, 1), "isEqualToString:", CFSTR("5")) & 1) != 0)
              {
                v52 = CFSTR("?1");
                v53 = &kCFHTTPHeaderUploadComplete;
              }
              else
              {
                if (!objc_msgSend(objc_getProperty((id)v13, v51, 56, 1), "isEqualToString:", CFSTR("3")))goto LABEL_96;
                v52 = CFSTR("?0");
                v53 = &kCFHTTPHeaderUploadIncomplete;
              }
              CFURLRequestSetHTTPHeaderFieldValue(v47, (const __CFString *)*v53, v52);
LABEL_96:
              v63 = (const __CFString *)objc_getProperty((id)v13, v62, 56, 1);
              CFURLRequestSetHTTPHeaderFieldValue(v47, (const __CFString *)&unk_1EDCFD820, v63);
              v64 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
              v65 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%lld"), *(_QWORD *)(v13 + 24));
              CFURLRequestSetHTTPHeaderFieldValue(v47, CFSTR("Upload-Offset"), v65);
              if (v65)
                CFRelease(v65);
              switch(*(_DWORD *)(v13 + 16))
              {
                case 0xFFFFFFFF:
                  if (v47)
                    CFRelease(v47);
                  goto LABEL_101;
                case 0:
                  v67 = objc_getProperty((id)v13, v66, 40, 1);
                  v68 = *(_QWORD *)(v13 + 24);
                  v70 = objc_getProperty((id)v13, v69, 40, 1);
                  objc_msgSend(v67, "subdataWithRange:", v68, objc_msgSend(v70, "length") - *(_QWORD *)(v13 + 24));
                  v71 = (void *)objc_claimAutoreleasedReturnValue();

                  URLRequest::_setHTTPBodyParts((URLRequest *)objc_msgSend(v47, "_inner"), (const __CFArray *)objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObject:", v71), 0);
                  break;
                case 1:
                  v72 = (void *)MEMORY[0x1E0C99D20];
                  v73 = (void *)MEMORY[0x1E0CB3940];
                  objc_msgSend((id)v13, "uploadFile");
                  v74 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                  objc_msgSend(v73, "stringWithUTF8String:", objc_msgSend(v74, "fileSystemRepresentation"));
                  v75 = (void *)objc_claimAutoreleasedReturnValue();
                  v76 = (const __CFArray *)objc_msgSend(v72, "arrayWithObject:", v75);

                  URLRequest::_setHTTPBodyParts((URLRequest *)objc_msgSend(v47, "_inner"), v76, *(_QWORD *)(v13 + 24));
                  break;
                case 2:
                  v77 = *(_QWORD *)(v13 + 64);
                  if ((v77 & 0x8000000000000000) == 0)
                  {
                    v78 = *(_QWORD *)(v13 + 24);
                    v79 = v77 < v78;
                    v80 = v77 - v78;
                    if (!v79)
                    {
                      v81 = CFStringCreateWithFormat(v64, 0, CFSTR("%lld"), v80);
                      CFURLRequestSetHTTPHeaderFieldValue(v47, (const __CFString *)&unk_1EDCFCE80, v81);
                      if (v81)
                        CFRelease(v81);
                    }
                  }
                  break;
                default:
                  break;
              }
              v82 = *(_QWORD *)(objc_msgSend(v47, "_inner") + 56);
              if (v82)
                Request = (CFHTTPMessageRef)(v82 - 16);
              else
                Request = 0;
              if (v82)
                CFRetain((CFTypeRef)(v82 - 16));
              if (v47)
                CFRelease(v47);
              break;
            case 2:
            case 3:
              *(_BYTE *)(v13 + 9) = v17 + 1;
              v26 = *(_QWORD *)(-[_CFCachedURLResponse _inner](v11, "_inner") + 56);
              if (v26)
                v27 = (__CFHTTPMessage *)(v26 - 16);
              else
                v27 = 0;
              v28 = CFHTTPMessageCopyVersion(v27);
              v30 = (const __CFURL *)objc_getProperty((id)v13, v29, 48, 1);
              Request = CFHTTPMessageCreateRequest((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("HEAD"), v30, v28);
              if (v28)
                CFRelease(v28);
              v31 = *(HTTPMessage **)(-[_CFCachedURLResponse _inner](v11, "_inner") + 56);
              if (v31)
              {
                v32 = HTTPMessage::copyAllHeaderFields(v31);
                _CFHTTPMessageSetMultipleHeaderFields(Request, v32);
                if (v32)
                  CFRelease(v32);
              }
              else
              {
                _CFHTTPMessageSetMultipleHeaderFields(Request, 0);
              }
              CFHTTPMessageSetHeaderFieldValue(Request, (CFStringRef)&unk_1EDCFCE80, CFSTR("0"));
              v59 = (const __CFString *)objc_getProperty((id)v13, v58, 56, 1);
              CFHTTPMessageSetHeaderFieldValue(Request, (CFStringRef)&unk_1EDCFD820, v59);
              *(_DWORD *)(v13 + 12) = 3;
              if (!a2)
                goto LABEL_37;
              goto LABEL_36;
            case 4:
LABEL_78:
              *(_DWORD *)(v13 + 12) = -1;
              goto LABEL_79;
            default:
LABEL_79:
              v21 = CFURLRequestCopyHTTPRequest(v11);
              goto LABEL_33;
          }
        }
        else
        {
          if (v18)
          {
            *(_DWORD *)(v13 + 12) = -1;
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v19 = (id)CFNLog::logger;
            if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              _os_log_error_impl(&dword_183ECA000, v19, OS_LOG_TYPE_ERROR, "ResumableUploadState: too many repeated stream openings for resumable upload, returning nil", (uint8_t *)&buf, 2u);
            }

            goto LABEL_101;
          }
LABEL_69:
          Request = CFURLRequestCopyHTTPRequest(v11);
          v39 = -[_CFCachedURLResponse _inner](v11, "_inner");
          v40 = v39;
          v41 = *(_QWORD *)(v39 + 56);
          if (v41)
          {
            HTTPMessage::ensureParserFinished(*(HTTPMessage **)(v39 + 56));
            if (*(_QWORD *)(v41 + 48)
              || (v43 = *(_QWORD *)(v40 + 56), *(_QWORD *)(v43 + 208))
              || *(_QWORD *)(v43 + 200))
            {
              if ((objc_msgSend(objc_getProperty((id)v13, v42, 56, 1), "isEqualToString:", CFSTR("5")) & 1) != 0)
              {
                v45 = CFSTR("?1");
                v46 = &kCFHTTPHeaderUploadComplete;
              }
              else
              {
                if (!objc_msgSend(objc_getProperty((id)v13, v44, 56, 1), "isEqualToString:", CFSTR("3")))
                {
LABEL_83:
                  v55 = (const __CFString *)objc_getProperty((id)v13, v54, 56, 1);
                  CFHTTPMessageSetHeaderFieldValue(Request, (CFStringRef)&unk_1EDCFD820, v55);
                  if (*(_DWORD *)(v13 + 16) == 2)
                  {
                    v56 = (__CFString *)CFHTTPMessageCopyHeaderFieldValue(Request, (CFStringRef)&unk_1EDCFCE80);
                    v57 = v56;
                    if (v56)
                    {
                      *(_QWORD *)(v13 + 64) = -[__CFString longLongValue](v56, "longLongValue");
                      CFRelease(v57);
                    }
                  }
                  goto LABEL_34;
                }
                v45 = CFSTR("?0");
                v46 = &kCFHTTPHeaderUploadIncomplete;
              }
              CFHTTPMessageSetHeaderFieldValue(Request, (CFStringRef)*v46, v45);
              goto LABEL_83;
            }
          }
        }
LABEL_34:
        if (Request)
        {
          if (a2)
          {
LABEL_36:
            HTTPProtocol::updateHTTPMessageWithCondtionalHeaders((HTTPProtocol *)Request, a2, v11, v22);
            *((_QWORD *)this + 62) = CFRetain(a2);
          }
LABEL_37:
          if (*((_QWORD *)this + 95) == 4)
          {
            if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
              dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
            v24 = HTTPMessage::copyHeaderFieldValue((CFHTTPMessageRef)((char *)Request + 16), 0x1181B2A6u);
            if (v24)
            {
              CFRelease(v24);
            }
            else
            {
              if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
                dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
              HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)Request + 16), 0x1181B2A6u, &unk_1EDCFDE40);
            }
          }
          v33 = (const __CFDictionary *)*((_QWORD *)this + 105);
          if (v33 || (v33 = (const __CFDictionary *)*((_QWORD *)this + 106)) != 0)
            _CFHTTPMessageSetMultipleHeaderFields(Request, v33);
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
          v34 = HTTPMessage::copyHeaderFieldValue((CFHTTPMessageRef)((char *)Request + 16), 0x1200D2E7u);
          if (v34)
          {
            CFRelease(v34);
          }
          else
          {
            v35 = (void *)*((_QWORD *)this + 10);
            v36 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_127, 1);
            if (v36)
            {
              v37 = v36;
              if ((*(unsigned int (**)(uint64_t, const char *, HTTPProtocol *))(*(_QWORD *)v36 + 24))(v36, "AddCookies Continue", this))
              {
                (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v37 + 72))(v37, "HTTPProtocol", CFSTR("Task: %p"));
                (*(void (**)(uint64_t))(*(_QWORD *)v37 + 8))(v37);
              }
            }
            if ((*(unsigned int (**)(HTTPProtocol *))(*(_QWORD *)this + 696))(this)
              && *((_DWORD *)this + 206) != 1)
            {
              CFRetain((char *)this - 16);
              CFRetain(Request);
              v38 = *((_QWORD *)this + 93);
              *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
              *((_QWORD *)&buf + 1) = 3221225472;
              v84 = ___ZN12HTTPProtocol35asynchronouslyAddCookiesAndContinueEP15__CFHTTPMessage_block_invoke_2;
              v85 = &__block_descriptor_48_e25_v16__0____CFDictionary__8l;
              v86 = this;
              v87 = Request;
              -[__NSURLSessionLocal _getCookieHeadersForTask:completionHandler:](v38, v35, (uint64_t)&buf);
              goto LABEL_62;
            }
          }
          HTTPProtocol::asynchronouslyAddAuthenticatorHeadersAndContinue(this, Request);
LABEL_62:
          CFRelease(Request);
          return;
        }
LABEL_101:
        HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFC14);
        return;
      }
      if (v16)
      {
        LOWORD(buf) = 0;
        _os_log_debug_impl(&dword_183ECA000, v15, OS_LOG_TYPE_DEBUG, "ResumableUploadState: not processing request since userOverride is true", (uint8_t *)&buf, 2u);
      }

      v21 = CFURLRequestCopyHTTPRequest(v11);
    }
    else
    {
      v21 = CFURLRequestCopyHTTPRequest(v11);
    }
LABEL_33:
    Request = v21;
    goto LABEL_34;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v20 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
  {
    v25 = *((_QWORD *)this + 99);
    LODWORD(buf) = 138543362;
    *(_QWORD *)((char *)&buf + 4) = v25;
    _os_log_fault_impl(&dword_183ECA000, v20, OS_LOG_TYPE_FAULT, "%{public}@ already has an ongoing transaction, not starting a new one", (uint8_t *)&buf, 0xCu);
  }
}

void sub_183EE7470(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void HTTPProtocol::asynchronouslyCreateAndOpenStream_WithMessage_AfterCookiesAndAuthenticatorHeaders(HTTPProtocol *this, os_unfair_lock_s *a2)
{
  const __CFArray *v3;
  void *v5;
  const __CFDictionary *v6;
  const void *v7;
  const __CFAllocator *v8;
  __CFDictionary *Mutable;
  const __CFAllocator *v10;
  const __CFAllocator *v11;
  CFUUIDRef v12;
  const __CFDictionary *ValueAtIndex;
  const void *Value;
  uint64_t v15;
  HTTPMessage *v16;
  const __CFDictionary *v17;
  unint64_t Count;
  const void **v19;
  unint64_t v20;
  const void **v21;
  uint64_t v22;
  uint64_t v23;
  __CFString *v24;
  int v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const __CFAllocator *v30;
  CFStringRef v31;
  int v32;
  int v33;
  int v34;
  char v35;
  uint64_t v36;
  char v37;
  char v38;
  char v39;
  void *v40;
  os_unfair_lock_s *v41;
  int v42;
  const __CFDictionary *v43;
  void *v44;
  SEL v45;
  void *v46;
  uint64_t v47;
  NSObject *v48;
  uint64_t v49;
  const __CFAllocator *v50;
  _QWORD *v51;
  void *v52;
  const void *v53;
  const char *v54;
  uint64_t v55;
  CFTypeRef v56;
  CFTypeRef v57;
  void *v58;
  const __CFDictionary *Property;
  const __CFDictionary *v60;
  uint64_t v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  _QWORD *v65;
  _BOOL4 v66;
  uint64_t *v67;
  NSObject *v68;
  _QWORD *v69;
  BOOL v70;
  CFTypeRef v71;
  const void *v72;
  uint64_t v73;
  int *v74;
  os_unfair_lock_s *v75;
  CFStringRef v76;
  const __CFString *v77;
  uint64_t v78;
  uint64_t v79;
  std::__shared_weak_count *v80;
  unint64_t *p_shared_owners;
  unint64_t v82;
  std::__shared_weak_count *v83;
  unint64_t *v84;
  unint64_t v85;
  std::__shared_weak_count *v86;
  uint64_t v87;
  os_unfair_lock_s *v88;
  uint64_t v89;
  os_unfair_lock_s *v90;
  _OWORD *v91;
  _OWORD *v92;
  unint64_t *v93;
  unint64_t v94;
  char *v95;
  std::__shared_weak_count *v96;
  unint64_t *v97;
  unint64_t *v98;
  unint64_t v99;
  char *v100;
  std::__shared_weak_count *v101;
  unint64_t *v102;
  std::__shared_weak_count *v103;
  unint64_t *v104;
  unint64_t v105;
  std::__shared_weak_count *v106;
  std::__shared_weak_count *v107;
  unint64_t *v108;
  unint64_t v109;
  std::__shared_weak_count *v110;
  unint64_t *v111;
  unint64_t v112;
  std::__shared_weak_count *v113;
  unint64_t *v114;
  unint64_t v115;
  std::__shared_weak_count *v116;
  unint64_t *v117;
  unint64_t v118;
  std::__shared_weak_count *v119;
  unint64_t *v120;
  unint64_t v121;
  std::__shared_count v122;
  std::__shared_weak_count *v123;
  unint64_t v124;
  unint64_t *p_shared_weak_owners;
  unint64_t v126;
  unint64_t v127;
  unint64_t *v128;
  unint64_t v129;
  unint64_t v130;
  std::__shared_weak_count *shared_owners;
  unint64_t *v132;
  unint64_t v133;
  std::__shared_weak_count_vtbl *v134;
  std::__shared_weak_count *on_zero_shared;
  void (__cdecl *v136)(std::__shared_weak_count *__hidden);
  std::__shared_weak_count *v137;
  std::__shared_weak_count *v138;
  std::__shared_weak_count_vtbl *v139;
  std::__shared_weak_count *v140;
  unint64_t *v141;
  unint64_t v142;
  std::__shared_weak_count *v143;
  unint64_t *v144;
  unint64_t v145;
  std::__shared_weak_count *v146;
  unint64_t *v147;
  unint64_t v148;
  _QWORD *v149;
  std::__shared_weak_count *v150;
  unint64_t *v151;
  unint64_t v152;
  std::__shared_weak_count *v153;
  unint64_t *v154;
  unint64_t v155;
  std::__shared_weak_count *v156;
  unint64_t *v157;
  unint64_t v158;
  std::__shared_weak_count *v159;
  unint64_t *v160;
  unint64_t v161;
  std::__shared_weak_count *v162;
  unint64_t *v163;
  unint64_t v164;
  std::__shared_weak_count *v165;
  unint64_t *v166;
  unint64_t v167;
  __int128 v168;
  std::__shared_weak_count *v169;
  unint64_t v170;
  unint64_t *v171;
  unint64_t v172;
  unint64_t v173;
  unint64_t *v174;
  unint64_t v175;
  unint64_t v176;
  std::__shared_weak_count *v177;
  unint64_t *v178;
  unint64_t v179;
  _QWORD *v180;
  std::__shared_weak_count *v181;
  uint64_t v182;
  std::__shared_weak_count *v183;
  std::__shared_weak_count *v184;
  unint64_t *v185;
  unint64_t v186;
  std::__shared_weak_count *v187;
  unint64_t *v188;
  unint64_t v189;
  unint64_t *v190;
  unint64_t v191;
  uint64_t v192;
  const void *v193;
  unint64_t *v194;
  unint64_t v195;
  std::__shared_weak_count *v196;
  unint64_t *v197;
  unint64_t v198;
  std::__shared_weak_count *v199;
  size_t v200;
  uint64_t v201;
  uint64_t v202;
  unsigned __int8 *v203;
  unsigned __int8 *v204;
  uint64_t v205;
  void *v206;
  unint64_t *v207;
  unint64_t v208;
  char *v209;
  _OWORD *v210;
  uint64_t shared_weak_owners;
  std::__shared_weak_count *v212;
  uint64_t v213;
  uint64_t v214;
  char *v215;
  os_unfair_lock_s *v216;
  __CFDictionary *v217;
  char v218;
  uint64_t v219;
  char v220;
  uint64_t v221;
  int v222;
  uint64_t v223;
  char v224;
  uint64_t v225;
  char v226;
  std::__shared_weak_count *v227;
  std::__shared_count v228;
  std::__shared_count v229;
  __int128 v230;
  __int128 v231;
  std::__shared_weak_count *v232;
  std::__shared_weak_count *v233;
  uint64_t v234;
  std::__shared_weak_count *v235;
  CFTypeRef cf;
  int v237;
  SInt32 v238;
  CFTypeRef v239;
  uint64_t v240;
  std::__shared_weak_count *v241;
  _BYTE buf[24];
  void *v243;
  int *v244;
  os_unfair_lock_s *v245;
  int v246;
  int v247;
  uint64_t v248;
  char v249;
  char v250;
  char v251;
  char v252;
  CFTypeRef v253;
  uint64_t v254;
  const void **v255;
  _QWORD v256[33];

  v256[31] = *MEMORY[0x1E0C80C00];
  v3 = (const __CFArray *)*((_QWORD *)this + 37);
  if (!v3 || !CFArrayGetCount(v3))
  {
    HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFC14);
    return;
  }
  v5 = (void *)*((_QWORD *)this + 10);
  if (v5 && *((_QWORD *)this + 94))
  {
    v6 = (const __CFDictionary *)CFRetain(*((CFTypeRef *)this + 94));
    if (v6)
      goto LABEL_9;
    v5 = (void *)*((_QWORD *)this + 10);
  }
  v7 = (const void *)objc_msgSend(v5, "_sslSettings");
  if (!v7 || (v6 = (const __CFDictionary *)CFRetain(v7)) == 0)
  {
    v10 = CFGetAllocator((char *)this - 16);
    Mutable = CFDictionaryCreateMutable(v10, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    goto LABEL_12;
  }
LABEL_9:
  v8 = CFGetAllocator((char *)this - 16);
  Mutable = CFDictionaryCreateMutableCopy(v8, 0, v6);
  CFRelease(v6);
LABEL_12:
  if (*((_DWORD *)this + 206) == 1)
  {
    v11 = CFGetAllocator((char *)this - 16);
    v12 = CFUUIDCreate(v11);
    CFDictionaryAddValue(Mutable, CFSTR("__CFNetworkUniqueKey"), v12);
    if (v12)
      CFRelease(v12);
  }
  if (*((_QWORD *)this + 101))
    CFDictionaryAddValue(Mutable, &unk_1EDCFAC98, (const void *)*MEMORY[0x1E0C9AE50]);
  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*((CFArrayRef *)this + 37), 0);
  Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("kCFProxyTypeKey"));
  if (CFEqual(Value, CFSTR("kCFProxyTypeHTTP")))
  {
    v15 = *((_QWORD *)this + 95);
    if (v15 == 4 || v15 == 1)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (a2)
        v16 = (HTTPMessage *)&a2[4];
      else
        v16 = 0;
      HTTPMessage::setHeaderFieldStringValue(v16, 0x1320D33Fu, &unk_1EDCFDE40);
    }
  }
  v239 = 0;
  v237 = 0;
  v238 = 80;
  cf = 0;
  _getConnectionInfoForProxy(ValueAtIndex, (__CFHTTPMessage *)a2, &v239, &v238, (_BOOL4 *)&v237, (CFDictionaryRef *)&cf);
  v17 = (const __CFDictionary *)cf;
  if (cf)
  {
    *(_QWORD *)buf = CFRetain(cf);
    Count = CFDictionaryGetCount(v17);
    *(_QWORD *)&buf[8] = Count;
    if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      *(_QWORD *)&buf[16] = 0;
      goto LABEL_33;
    }
    if (Count > 0x1E)
    {
      v19 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
      *(_QWORD *)&buf[16] = v19;
      if (!v19)
        goto LABEL_33;
    }
    else
    {
      v19 = (const void **)&v243;
      *(_QWORD *)&buf[16] = &v243;
    }
    CFDictionaryGetKeysAndValues(v17, v19, 0);
LABEL_33:
    v253 = CFRetain(v17);
    v20 = CFDictionaryGetCount(v17);
    v254 = v20;
    if (v20 - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      v255 = 0;
    }
    else
    {
      if (v20 <= 0x1E)
      {
        v21 = (const void **)v256;
        v255 = (const void **)v256;
LABEL_38:
        CFDictionaryGetKeysAndValues(v17, 0, v21);
        goto LABEL_39;
      }
      v21 = (const void **)malloc_type_malloc(8 * v20, 0x89ED541CuLL);
      v255 = v21;
      if (v21)
        goto LABEL_38;
    }
LABEL_39:
    v22 = v254;
    if (v254 >= 1)
    {
      v23 = 0;
      do
      {
        CFDictionarySetValue(Mutable, *(const void **)(*(_QWORD *)&buf[16] + 8 * v23), v255[v23]);
        ++v23;
      }
      while (v22 != v23);
    }
    CFRelease(v17);
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v253);
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)buf);
  }
  v24 = (__CFString *)v239;
  if (v239)
  {
    v25 = CFDictionaryContainsKey(Mutable, &unk_1EDCFA918);
    if (v25 | CFDictionaryContainsKey(Mutable, &unk_1EDCFA950))
    {
      v26 = (const void *)*((_QWORD *)this + 67);
      if (v26)
        CFRelease(v26);
      v27 = CFDictionaryGetValue(Mutable, &unk_1EDCFA918);
      if (v27)
        v27 = CFRetain(v27);
      *((_QWORD *)this + 67) = v27;
      v28 = (const void *)*((_QWORD *)this + 68);
      if (v28)
        CFRelease(v28);
      v29 = CFDictionaryGetValue(Mutable, &unk_1EDCFA950);
      if (v29)
        v29 = CFRetain(v29);
      *((_QWORD *)this + 68) = v29;
      CFDictionaryRemoveValue(Mutable, &unk_1EDCFA918);
      CFDictionaryRemoveValue(Mutable, &unk_1EDCFA950);
      v30 = CFGetAllocator((char *)this - 16);
      v31 = CFStringCreateWithFormat(v30, 0, CFSTR("s=%@,o=%@"), *((_QWORD *)this + 67), *((_QWORD *)this + 68));
      if (v31)
      {
        CFDictionarySetValue(Mutable, CFSTR("_immediate_buffer_was_set"), v31);
        CFRelease(v31);
      }
    }
    v32 = objc_msgSend(*((id *)this + 10), "_requestPriority");
    objc_msgSend(*((id *)this + 10), "priority");
    v34 = v33;
    v35 = objc_msgSend(*((id *)this + 10), "prefersIncrementalDelivery");
    v36 = objc_msgSend(*((id *)this + 10), "_allowedProtocolTypes");
    v37 = objc_msgSend(*((id *)this + 10), "_shouldUsePipelineHeuristics");
    v38 = objc_msgSend(*((id *)this + 10), "_shouldSkipPipelineProbe");
    v39 = objc_msgSend(*((id *)this + 10), "_shouldPipelineHTTP");
    v40 = (void *)objc_msgSend(*((id *)this + 10), "currentRequest");
    v222 = v32;
    v220 = v35;
    if (v40)
    {
      v41 = *(os_unfair_lock_s **)(objc_msgSend(v40, "_inner") + 56);
      if (v41)
      {
        if (HTTPMessage::hasHeaderField(v41, 0x1470F3EAu))
        {
          v37 = 0;
          v38 = 0;
          v39 = 0;
          v36 = 1;
        }
      }
    }
    v218 = v37;
    v42 = v237;
    if (v237 == 1)
    {
      v43 = HTTPProtocol::copySSLPropertiesForStream(this, 1);
      if (v43)
      {
        CFDictionarySetValue(Mutable, CFSTR("__kCFStreamPropertyCoalescingDomainSSLSettings"), v43);
        CFRelease(v43);
      }
    }
    v44 = (void *)*((_QWORD *)this + 93);
    if (v44)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&_httpFallbackHostsLock);
      v46 = (void *)objc_msgSend(objc_getProperty(v44, v45, 144, 1), "objectForKeyedSubscript:", v24);
      if (v46)
      {
        v47 = objc_msgSend(v46, "unsignedIntegerValue");
        os_unfair_lock_unlock((os_unfair_lock_t)&_httpFallbackHostsLock);
        if (v47)
        {
          if ((v47 & 0x10) != 0)
            CFDictionarySetValue(Mutable, &unk_1EDCF9B50, (const void *)*MEMORY[0x1E0C9AE50]);
          if ((v47 & 0x40) != 0)
            CFDictionarySetValue(Mutable, &unk_1EDCF9B88, (const void *)*MEMORY[0x1E0C9AE50]);
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v48 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_INFO))
          {
            v49 = *((_QWORD *)this + 99);
            *(_DWORD *)buf = 138543874;
            *(_QWORD *)&buf[4] = v49;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v36;
            *(_WORD *)&buf[22] = 2048;
            v243 = (void *)v47;
            _os_log_impl(&dword_183ECA000, v48, OS_LOG_TYPE_INFO, "%{public}@ has forbidden protocols (o=%lu f=%lu)", buf, 0x20u);
          }
        }
      }
      else
      {
        os_unfair_lock_unlock((os_unfair_lock_t)&_httpFallbackHostsLock);
      }
    }
    v226 = v39;
    v224 = v38;
    v50 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v51 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 152, 0);
    v51[18] = 0;
    *((_OWORD *)v51 + 7) = 0u;
    *((_OWORD *)v51 + 8) = 0u;
    *((_OWORD *)v51 + 5) = 0u;
    *((_OWORD *)v51 + 6) = 0u;
    *((_OWORD *)v51 + 3) = 0u;
    *((_OWORD *)v51 + 4) = 0u;
    *((_OWORD *)v51 + 1) = 0u;
    *((_OWORD *)v51 + 2) = 0u;
    *(_OWORD *)v51 = 0u;
    HTTPConnectionCacheKey::HTTPConnectionCacheKey((uint64_t)v51, (uint64_t)v50, v24, v238, v42, Mutable, v36);
    v52 = (void *)*((_QWORD *)this + 10);
    v53 = (const void *)objc_msgSend((id)objc_msgSend(*((id *)this + 11), "mainDocumentURL"), "host");
    v55 = objc_msgSend(v52, "_DuetActivityProperties");
    v56 = v53;
    if (v55)
      v56 = (CFTypeRef)objc_msgSend((id)objc_msgSend(v52, "_effectiveConfiguration"), "_sourceApplicationBundleIdentifier");
    if (v56)
      v56 = CFRetain(v56);
    v51[6] = v56;
    if (v53)
      v57 = CFRetain(v53);
    else
      v57 = 0;
    v51[5] = v57;
    if (v42 != 1)
      goto LABEL_105;
    v58 = (void *)*((_QWORD *)this + 93);
    if (!v58)
      goto LABEL_105;
    Property = (const __CFDictionary *)objc_getProperty(v58, v54, 152, 1);
    v60 = Property;
    if (!Property || CFDictionaryGetCount(Property) < 1)
      goto LABEL_105;
    v61 = -[__CFDictionary objectForKeyedSubscript:](v60, "objectForKeyedSubscript:", HTTPConnectionCacheKey::hostlessKey((CFAllocatorRef *)v51));
    if (!v61)
    {
      v70 = v24 == 0;
      goto LABEL_108;
    }
    std::string::basic_string[abi:nn180100]<0>(buf, (char *)-[__CFString UTF8String](v24, "UTF8String"));
    v64 = *(_QWORD *)(v61 + 88);
    v62 = (_QWORD *)(v61 + 88);
    v63 = v64;
    if (!v64)
    {
LABEL_96:
      if ((buf[23] & 0x80000000) != 0)
        operator delete(*(void **)buf);
      if (v63)
      {
        if (H2CoalescingLog(void)::onceToken != -1)
          dispatch_once(&H2CoalescingLog(void)::onceToken, &__block_literal_global_6187);
        v68 = H2CoalescingLog(void)::onceLog;
        if (os_log_type_enabled((os_log_t)H2CoalescingLog(void)::onceLog, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 138412802;
          *(_QWORD *)&buf[4] = v24;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v63;
          *(_WORD *)&buf[22] = 2048;
          v243 = v60;
          _os_log_debug_impl(&dword_183ECA000, v68, OS_LOG_TYPE_DEBUG, "using found mapping %@ to %@ config %p", buf, 0x20u);
        }
        v69 = CFAllocatorAllocate(v50, 152, 0);
        v69[18] = 0;
        *((_OWORD *)v69 + 7) = 0u;
        *((_OWORD *)v69 + 8) = 0u;
        *((_OWORD *)v69 + 5) = 0u;
        *((_OWORD *)v69 + 6) = 0u;
        *((_OWORD *)v69 + 3) = 0u;
        *((_OWORD *)v69 + 4) = 0u;
        *((_OWORD *)v69 + 1) = 0u;
        *((_OWORD *)v69 + 2) = 0u;
        *(_OWORD *)v69 = 0u;
        HTTPConnectionCacheKey::HTTPConnectionCacheKey((uint64_t)v69, (uint64_t)v50, (const __CFString *)v63, v238, v237, Mutable, v36);
        if (v51)
          (*(void (**)(_QWORD *))(*v51 + 48))(v51);
        goto LABEL_106;
      }
LABEL_105:
      v69 = v51;
LABEL_106:
      v24 = (__CFString *)v239;
      v70 = v239 == 0;
      if (!v239)
      {
        v71 = 0;
LABEL_110:
        v72 = (const void *)v69[17];
        v69[17] = v71;
        if (v72)
          CFRelease(v72);
        *((_QWORD *)this + 35) = v69;
        v239 = 0;
        if (!v70)
        {
          CFRelease(v24);
          v69 = (_QWORD *)*((_QWORD *)this + 35);
          if (!v69)
          {
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "couldn't create connection cache key", buf, 2u);
              v69 = (_QWORD *)*((_QWORD *)this + 35);
            }
            else
            {
              v69 = 0;
            }
          }
        }
        objc_msgSend(*((id *)this + 10), "_setConnectionCacheKey:", v69);
        v73 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_102_7159, 1);
        v74 = (int *)v73;
        if (v73
          && (*(unsigned int (**)(uint64_t, const char *, HTTPProtocol *))(*(_QWORD *)v73 + 24))(v73, "Protocol Enqueue", this))
        {
          (*(void (**)(int *, const char *, _QWORD))(*(_QWORD *)v74 + 48))(v74, "Request", *((_QWORD *)this + 11));
          if (a2)
          {
            if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
              dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
            v75 = a2 + 4;
          }
          else
          {
            v75 = 0;
          }
          *(_QWORD *)buf = &off_1E14E4818;
          v76 = CFStringCreateWithCString(v50, "Message", 0x8000100u);
          *(_QWORD *)&buf[16] = 0;
          v243 = 0;
          *(_QWORD *)&buf[8] = v76;
          if (v75)
          {
            v77 = (const __CFString *)(*(uint64_t (**)(os_unfair_lock_s *))(*(_QWORD *)&v75->_os_unfair_lock_opaque
                                                                                    + 32))(v75);
            v76 = *(CFStringRef *)&buf[8];
          }
          else
          {
            v77 = CFSTR("null");
          }
          (*(void (**)(int *, CFStringRef, const __CFString *))(*(_QWORD *)v74 + 64))(v74, v76, v77);
          if (v75 && v77)
            CFRelease(v77);
          AutoString::~AutoString((AutoString *)buf);
          if (a2 && v74[2] >= 2)
          {
            if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
              dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
            v78 = HTTPMessage::headers(a2 + 4);
            *(_QWORD *)buf = MEMORY[0x1E0C809B0];
            *(_QWORD *)&buf[8] = 3221225472;
            *(_QWORD *)&buf[16] = ___ZN11HTTPMessage13logMsgHeadersEP17DiagnosticLoggingPKc_block_invoke;
            v243 = &__block_descriptor_40_e36_v24__0____CFString__8____CFArray__16l;
            v244 = v74;
            HTTPHeaderDict::visitHeaders(v78, 1, (uint64_t)buf);
          }
          (*(void (**)(int *))(*(_QWORD *)v74 + 8))(v74);
        }
        if (*((_QWORD *)this + 74))
        {
          v79 = *((_QWORD *)this + 35);
          v80 = (std::__shared_weak_count *)*((_QWORD *)this + 75);
          v234 = *((_QWORD *)this + 74);
          v235 = v80;
          if (v80)
          {
            p_shared_owners = (unint64_t *)&v80->__shared_owners_;
            do
              v82 = __ldxr(p_shared_owners);
            while (__stxr(v82 + 1, p_shared_owners));
          }
          (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v79 + 56))(v79, &v234);
          v83 = v235;
          if (v235)
          {
            v84 = (unint64_t *)&v235->__shared_owners_;
            do
              v85 = __ldaxr(v84);
            while (__stlxr(v85 - 1, v84));
            if (!v85)
            {
              ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
              std::__shared_weak_count::__release_weak(v83);
            }
          }
        }
        (*(void (**)(_BYTE *__return_ptr, HTTPProtocol *))(*(_QWORD *)this + 680))(buf, this);
        v87 = *(_QWORD *)buf;
        v86 = *(std::__shared_weak_count **)&buf[8];
        v233 = *(std::__shared_weak_count **)&buf[8];
        if (!*(_QWORD *)buf)
        {
          v89 = *((_QWORD *)this + 93);
          if (!v89)
            goto LABEL_298;
          if (a2)
          {
            if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
              dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
            v90 = a2 + 4;
            if (LOBYTE(a2[10]._os_unfair_lock_opaque))
              v90 = 0;
          }
          else
          {
            v90 = 0;
          }
          v192 = *(_QWORD *)(v89 + 168);
          if (v192)
          {
            v193 = (const void *)*((_QWORD *)this + 3);
            v246 = v222;
            v247 = v34;
            v248 = v36;
            v249 = v220;
            v250 = v218;
            v251 = v224;
            v252 = v226;
            *(_QWORD *)buf = MEMORY[0x1E0C809B0];
            *(_QWORD *)&buf[8] = 3221225472;
            *(_QWORD *)&buf[16] = ___ZN12XTubeManager25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptionsPK17CoreSchedulingSet_block_invoke;
            v243 = &__block_descriptor_72_e9_v16__0_v8l;
            v244 = (int *)((char *)this + 176);
            v245 = v90;
            XTubeManager::withTubeManager(v192, v193, (uint64_t)buf);
          }
          else
          {
LABEL_298:
            HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFC14);
          }
          goto LABEL_299;
        }
        if (a2)
        {
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
          v88 = a2 + 4;
          if (LOBYTE(a2[10]._os_unfair_lock_opaque))
            v88 = 0;
          v216 = v88;
        }
        else
        {
          v216 = 0;
        }
        v91 = CFAllocatorAllocate(v50, 48, 0);
        v92 = v91;
        v91[1] = 0u;
        v91[2] = 0u;
        *v91 = 0u;
        v232 = v86;
        if (v86)
        {
          v93 = (unint64_t *)&v86->__shared_owners_;
          do
            v94 = __ldxr(v93);
          while (__stxr(v94 + 1, v93));
        }
        *(_QWORD *)v91 = off_1E14EF578;
        *((_QWORD *)v91 + 1) = v50;
        *((_DWORD *)v91 + 4) = 1;
        if (((unint64_t)(v91 + 1) & 3) != 0)
          __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
        *((_QWORD *)v91 + 3) = &unk_1E14ED890;
        *(_QWORD *)v91 = off_1E14ED7B8;
        *((_QWORD *)v91 + 4) = 0;
        v215 = (char *)(v91 + 2);
        *((_QWORD *)v91 + 5) = 0;
        v95 = (char *)operator new(0x138uLL);
        v96 = (std::__shared_weak_count *)v95;
        *((_QWORD *)v95 + 1) = 0;
        v97 = (unint64_t *)(v95 + 8);
        *((_QWORD *)v95 + 2) = 0;
        *(_QWORD *)v95 = &off_1E14F0C58;
        v240 = v87;
        v241 = v86;
        if (v86)
        {
          v98 = (unint64_t *)&v86->__shared_owners_;
          do
            v99 = __ldxr(v98);
          while (__stxr(v99 + 1, v98));
        }
        *((_QWORD *)v95 + 3) = &off_1E14E9AA8;
        *((_QWORD *)v95 + 4) = 0;
        *(_OWORD *)(v95 + 72) = 0u;
        *(_OWORD *)(v95 + 88) = 0u;
        *((_QWORD *)v95 + 5) = 0;
        *((_DWORD *)v95 + 32) = v222;
        *((_DWORD *)v95 + 33) = v34;
        *((_QWORD *)v95 + 17) = v36;
        v95[144] = v220;
        v95[145] = v218;
        v95[146] = v224;
        v95[147] = v226;
        *((_QWORD *)v95 + 29) = 0;
        *((_QWORD *)v95 + 28) = 0;
        v219 = (uint64_t)(v95 + 224);
        *((_QWORD *)v95 + 36) = 0;
        *((_QWORD *)v95 + 37) = 0;
        v95[48] = 0;
        *((_QWORD *)v95 + 7) = 0;
        *((_QWORD *)v95 + 8) = 0;
        *(_OWORD *)(v95 + 152) = 0u;
        *(_OWORD *)(v95 + 168) = 0u;
        *(_OWORD *)(v95 + 184) = 0u;
        v223 = (uint64_t)(v95 + 184);
        v225 = (uint64_t)(v95 + 168);
        v213 = (uint64_t)(v95 + 288);
        v214 = (uint64_t)(v95 + 152);
        *(_OWORD *)(v95 + 200) = 0u;
        v221 = (uint64_t)(v95 + 200);
        std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)v95 + 11, v87, (uint64_t)v86);
        v100 = (char *)operator new(0xD0uLL);
        v101 = (std::__shared_weak_count *)v100;
        v209 = (char *)v92 + 24;
        v210 = v92;
        *((_QWORD *)v100 + 1) = 0;
        v102 = (unint64_t *)(v100 + 8);
        *((_QWORD *)v100 + 2) = 0;
        *(_QWORD *)v100 = &off_1E14F0910;
        v103 = (std::__shared_weak_count *)v96[4].__vftable;
        shared_weak_owners = v96[3].__shared_weak_owners_;
        v212 = v96 + 3;
        if (v103)
        {
          v104 = (unint64_t *)&v103->__shared_owners_;
          do
            v105 = __ldxr(v104);
          while (__stxr(v105 + 1, v104));
        }
        v227 = v103;
        *(_OWORD *)(v100 + 152) = 0u;
        *((_QWORD *)v100 + 4) = 0;
        *((_QWORD *)v100 + 5) = 0;
        *((_QWORD *)v100 + 3) = &off_1E14E69B0;
        *(_OWORD *)(v100 + 72) = 0u;
        *(_OWORD *)(v100 + 88) = 0u;
        *(_OWORD *)(v100 + 120) = 0u;
        *(_OWORD *)(v100 + 136) = 0u;
        *(_OWORD *)(v100 + 56) = 0u;
        gotLoadHelper_x8__OBJC_CLASS___FTURLRequestMessage(0.0);
        if (!objc_opt_class())
        {
LABEL_344:
          _os_crash();
          __break(1u);
          return;
        }
        LOBYTE(v101[2].__vftable) = 0;
        v106 = (std::__shared_weak_count *)v101[2].__shared_weak_owners_;
        v101[2].__shared_owners_ = 0;
        v101[2].__shared_weak_owners_ = 0;
        if (v106)
          std::__shared_weak_count::__release_weak(v106);
        std::shared_ptr<__CFString const>::operator=[abi:nn180100](&v101[3].__vftable, shared_weak_owners, (uint64_t)v227);
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = 0;
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)&v101[3].__shared_weak_owners_, (__int128 *)buf);
        v107 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v108 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v109 = __ldaxr(v108);
          while (__stlxr(v109 - 1, v108));
          if (!v109)
          {
            ((void (*)(std::__shared_weak_count *))v107->__on_zero_shared)(v107);
            std::__shared_weak_count::__release_weak(v107);
          }
        }
        v101[4].__shared_owners_ = 0;
        LODWORD(v101[4].__shared_weak_owners_) = 0;
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = 0;
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)&v101[5], (__int128 *)buf);
        v110 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v111 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v112 = __ldaxr(v111);
          while (__stlxr(v112 - 1, v111));
          if (!v112)
          {
            ((void (*)(std::__shared_weak_count *))v110->__on_zero_shared)(v110);
            std::__shared_weak_count::__release_weak(v110);
          }
        }
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = 0;
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)&v101[5].__shared_weak_owners_, (__int128 *)buf);
        v113 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v114 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v115 = __ldaxr(v114);
          while (__stlxr(v115 - 1, v114));
          if (!v115)
          {
            ((void (*)(std::__shared_weak_count *))v113->__on_zero_shared)(v113);
            std::__shared_weak_count::__release_weak(v113);
          }
        }
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = 0;
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)&v101[6].__shared_owners_, (__int128 *)buf);
        v116 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v117 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v118 = __ldaxr(v117);
          while (__stlxr(v118 - 1, v117));
          if (!v118)
          {
            ((void (*)(std::__shared_weak_count *))v116->__on_zero_shared)(v116);
            std::__shared_weak_count::__release_weak(v116);
          }
        }
        v119 = v101 + 1;
        *(_OWORD *)&v101[7].__shared_weak_owners_ = 0u;
        v101[7].std::__shared_count = 0u;
        if (v227)
        {
          v120 = (unint64_t *)&v227->__shared_owners_;
          do
            v121 = __ldaxr(v120);
          while (__stlxr(v121 - 1, v120));
          if (!v121)
          {
            ((void (*)(std::__shared_weak_count *))v227->__on_zero_shared)(v227);
            std::__shared_weak_count::__release_weak(v227);
          }
        }
        v122.__vftable = (std::__shared_count_vtbl *)&v101[1];
        v122.__shared_owners_ = (uint64_t)v101;
        v123 = (std::__shared_weak_count *)v101[1].__shared_weak_owners_;
        if (v123)
        {
          if (v123->__shared_owners_ != -1)
            goto LABEL_210;
          do
            v124 = __ldxr(v102);
          while (__stxr(v124 + 1, v102));
          v228 = v122;
          p_shared_weak_owners = (unint64_t *)&v101->__shared_weak_owners_;
          do
            v126 = __ldxr(p_shared_weak_owners);
          while (__stxr(v126 + 1, p_shared_weak_owners));
          v101[1].__shared_owners_ = (uint64_t)v119;
          v101[1].__shared_weak_owners_ = (uint64_t)v101;
          std::__shared_weak_count::__release_weak(v123);
          v122 = v228;
        }
        else
        {
          do
            v127 = __ldxr(v102);
          while (__stxr(v127 + 1, v102));
          v128 = (unint64_t *)&v101->__shared_weak_owners_;
          do
            v129 = __ldxr(v128);
          while (__stxr(v129 + 1, v128));
          v101[1].__shared_owners_ = (uint64_t)v119;
          v101[1].__shared_weak_owners_ = (uint64_t)v101;
        }
        do
          v130 = __ldaxr(v102);
        while (__stlxr(v130 - 1, v102));
        if (!v130)
        {
          v229 = v122;
          ((void (*)(std::__shared_weak_count *))v101->__on_zero_shared)(v101);
          std::__shared_weak_count::__release_weak(v101);
          v122 = v229;
        }
LABEL_210:
        shared_owners = (std::__shared_weak_count *)v96[3].__shared_owners_;
        v96[3].std::__shared_count = v122;
        if (shared_owners)
        {
          v132 = (unint64_t *)&shared_owners->__shared_owners_;
          do
            v133 = __ldaxr(v132);
          while (__stlxr(v133 - 1, v132));
          if (!v133)
          {
            ((void (*)(std::__shared_weak_count *))shared_owners->__on_zero_shared)(shared_owners);
            std::__shared_weak_count::__release_weak(shared_owners);
          }
        }
        v134 = v212->__vftable;
        on_zero_shared = (std::__shared_weak_count *)v212->__on_zero_shared;
        if (!on_zero_shared
          || (v136 = v134->~__shared_weak_count_0, (v137 = std::__shared_weak_count::lock(on_zero_shared)) == 0))
        {
LABEL_343:
          std::__throw_bad_weak_ptr[abi:nn180100]();
          __break(1u);
          goto LABEL_344;
        }
        v138 = v137;
        v139 = (std::__shared_weak_count_vtbl *)((char *)this + 176);
        v140 = v96 + 1;
        v141 = (unint64_t *)&v137->__shared_weak_owners_;
        do
          v142 = __ldxr(v141);
        while (__stxr(v142 + 1, v141));
        v143 = (std::__shared_weak_count *)v134[1].~__shared_weak_count;
        v134->__on_zero_shared_weak = v136;
        v134[1].~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v138;
        if (v143)
          std::__shared_weak_count::__release_weak(v143);
        v144 = (unint64_t *)&v138->__shared_owners_;
        do
          v145 = __ldaxr(v144);
        while (__stlxr(v145 - 1, v144));
        if (!v145)
        {
          ((void (*)(std::__shared_weak_count *))v138->__on_zero_shared)(v138);
          std::__shared_weak_count::__release_weak(v138);
        }
        LODWORD(v96[4].__shared_owners_) = 0;
        v96[4].__shared_weak_owners_ = 0;
        LODWORD(v96[5].__vftable) = 0;
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = 0;
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v214, (__int128 *)buf);
        v146 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v147 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v148 = __ldaxr(v147);
          while (__stlxr(v148 - 1, v147));
          if (!v148)
          {
            ((void (*)(std::__shared_weak_count *))v146->__on_zero_shared)(v146);
            std::__shared_weak_count::__release_weak(v146);
          }
        }
        if (!v216)
          __assert_rtn("APSRelayTransaction", "APSRelayTransaction.cpp", 63, "request");
        CFRetain(&v216[-4]);
        *(_QWORD *)buf = v216;
        v149 = (_QWORD *)operator new();
        *v149 = &off_1E14F16D8;
        v149[1] = 0;
        v149[2] = 0;
        v149[3] = v216;
        *(_QWORD *)&buf[8] = v149;
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v225, (__int128 *)buf);
        v150 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v151 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v152 = __ldaxr(v151);
          while (__stlxr(v152 - 1, v151));
          if (!v152)
          {
            ((void (*)(std::__shared_weak_count *))v150->__on_zero_shared)(v150);
            std::__shared_weak_count::__release_weak(v150);
          }
        }
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = 0;
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v223, (__int128 *)buf);
        v153 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v154 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v155 = __ldaxr(v154);
          while (__stlxr(v155 - 1, v154));
          if (!v155)
          {
            ((void (*)(std::__shared_weak_count *))v153->__on_zero_shared)(v153);
            std::__shared_weak_count::__release_weak(v153);
          }
        }
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = 0;
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v221, (__int128 *)buf);
        v156 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v157 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v158 = __ldaxr(v157);
          while (__stlxr(v158 - 1, v157));
          if (!v158)
          {
            ((void (*)(std::__shared_weak_count *))v156->__on_zero_shared)(v156);
            std::__shared_weak_count::__release_weak(v156);
          }
        }
        v96[9].__vftable = v139;
        (*((void (**)(char *))v139->~__shared_weak_count + 2))((char *)this + 176);
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = 0;
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v219, (__int128 *)buf);
        v159 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v160 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v161 = __ldaxr(v160);
          while (__stlxr(v161 - 1, v160));
          if (!v161)
          {
            ((void (*)(std::__shared_weak_count *))v159->__on_zero_shared)(v159);
            std::__shared_weak_count::__release_weak(v159);
          }
        }
        v96[10].__vftable = 0;
        v96[10].__shared_owners_ = 0;
        LOBYTE(v96[11].__vftable) = 0;
        v96[10].__shared_weak_owners_ = 0;
        v96[11].__shared_owners_ = 0;
        v96[11].__shared_weak_owners_ = 0;
        (*((void (**)(_BYTE *__return_ptr))v96[9].~__shared_weak_count + 9))(buf);
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v213, (__int128 *)buf);
        v162 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v163 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v164 = __ldaxr(v163);
          while (__stlxr(v164 - 1, v163));
          if (!v164)
          {
            ((void (*)(std::__shared_weak_count *))v162->__on_zero_shared)(v162);
            std::__shared_weak_count::__release_weak(v162);
          }
        }
        v165 = v241;
        if (v241)
        {
          v166 = (unint64_t *)&v241->__shared_owners_;
          do
            v167 = __ldaxr(v166);
          while (__stlxr(v167 - 1, v166));
          if (!v167)
          {
            ((void (*)(std::__shared_weak_count *))v165->__on_zero_shared)(v165);
            std::__shared_weak_count::__release_weak(v165);
          }
        }
        *(_QWORD *)&v168 = v96 + 1;
        *((_QWORD *)&v168 + 1) = v96;
        v169 = (std::__shared_weak_count *)v96[1].__shared_weak_owners_;
        if (v169)
        {
          if (v169->__shared_owners_ != -1)
            goto LABEL_274;
          do
            v170 = __ldxr(v97);
          while (__stxr(v170 + 1, v97));
          v230 = v168;
          v171 = (unint64_t *)&v96->__shared_weak_owners_;
          do
            v172 = __ldxr(v171);
          while (__stxr(v172 + 1, v171));
          v96[1].__shared_owners_ = (uint64_t)v140;
          v96[1].__shared_weak_owners_ = (uint64_t)v96;
          std::__shared_weak_count::__release_weak(v169);
          v168 = v230;
        }
        else
        {
          do
            v173 = __ldxr(v97);
          while (__stxr(v173 + 1, v97));
          v174 = (unint64_t *)&v96->__shared_weak_owners_;
          do
            v175 = __ldxr(v174);
          while (__stxr(v175 + 1, v174));
          v96[1].__shared_owners_ = (uint64_t)v140;
          v96[1].__shared_weak_owners_ = (uint64_t)v96;
        }
        do
          v176 = __ldaxr(v97);
        while (__stlxr(v176 - 1, v97));
        if (!v176)
        {
          v231 = v168;
          ((void (*)(std::__shared_weak_count *))v96->__on_zero_shared)(v96);
          std::__shared_weak_count::__release_weak(v96);
          v168 = v231;
        }
LABEL_274:
        v177 = (std::__shared_weak_count *)*((_QWORD *)v210 + 5);
        v210[2] = v168;
        if (v177)
        {
          v178 = (unint64_t *)&v177->__shared_owners_;
          do
            v179 = __ldaxr(v178);
          while (__stlxr(v179 - 1, v178));
          if (!v179)
          {
            ((void (*)(std::__shared_weak_count *))v177->__on_zero_shared)(v177);
            std::__shared_weak_count::__release_weak(v177);
          }
        }
        v180 = *(_QWORD **)v215;
        v181 = *(std::__shared_weak_count **)(*(_QWORD *)v215 + 16);
        if (v181)
        {
          v182 = v180[1];
          v183 = std::__shared_weak_count::lock(v181);
          if (v183)
          {
            v184 = v183;
            v185 = (unint64_t *)&v183->__shared_weak_owners_;
            do
              v186 = __ldxr(v185);
            while (__stxr(v186 + 1, v185));
            v187 = (std::__shared_weak_count *)v180[5];
            v180[4] = v182;
            v180[5] = v184;
            if (v187)
              std::__shared_weak_count::__release_weak(v187);
            v188 = (unint64_t *)&v184->__shared_owners_;
            do
              v189 = __ldaxr(v188);
            while (__stlxr(v189 - 1, v188));
            if (!v189)
            {
              ((void (*)(std::__shared_weak_count *))v184->__on_zero_shared)(v184);
              std::__shared_weak_count::__release_weak(v184);
            }
            if (v232)
            {
              v190 = (unint64_t *)&v232->__shared_owners_;
              do
                v191 = __ldaxr(v190);
              while (__stlxr(v191 - 1, v190));
              if (!v191)
              {
                ((void (*)(std::__shared_weak_count *))v232->__on_zero_shared)(v232);
                std::__shared_weak_count::__release_weak(v232);
              }
            }
            (*(void (**)(HTTPProtocol *, char *, os_unfair_lock_s *, uint64_t))(*(_QWORD *)this + 560))(this, v209, v216, 1);
            (*(void (**)(_OWORD *))(*(_QWORD *)v210 + 48))(v210);
            v86 = v233;
LABEL_299:
            if (v86)
            {
              v194 = (unint64_t *)&v86->__shared_owners_;
              do
                v195 = __ldaxr(v194);
              while (__stlxr(v195 - 1, v194));
              if (!v195)
              {
                ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
                std::__shared_weak_count::__release_weak(v86);
              }
            }
            goto LABEL_304;
          }
        }
        goto LABEL_343;
      }
      v51 = v69;
LABEL_108:
      v71 = CFRetain(v24);
      v69 = v51;
      goto LABEL_110;
    }
    v217 = Mutable;
    v65 = v62;
    do
    {
      v66 = std::less<std::string>::operator()[abi:nn180100]((_QWORD *)(v63 + 32), buf);
      v67 = (uint64_t *)(v63 + 8);
      if (!v66)
      {
        v67 = (uint64_t *)v63;
        v65 = (_QWORD *)v63;
      }
      v63 = *v67;
    }
    while (*v67);
    if (v65 == v62 || std::less<std::string>::operator()[abi:nn180100](buf, v65 + 4))
    {
      v63 = 0;
LABEL_95:
      Mutable = v217;
      goto LABEL_96;
    }
    v63 = v65[7];
    v196 = (std::__shared_weak_count *)v65[8];
    v240 = v63;
    v241 = v196;
    if (v196)
    {
      v197 = (unint64_t *)&v196->__shared_owners_;
      do
        v198 = __ldxr(v197);
      while (__stxr(v198 + 1, v197));
      v199 = v196;
    }
    else
    {
      v199 = 0;
    }
    if (!v63)
    {
LABEL_336:
      if (v199)
      {
        v207 = (unint64_t *)&v199->__shared_owners_;
        do
          v208 = __ldaxr(v207);
        while (__stlxr(v208 - 1, v207));
        if (!v208)
        {
          ((void (*)(std::__shared_weak_count *))v199->__on_zero_shared)(v199);
          std::__shared_weak_count::__release_weak(v199);
        }
      }
      goto LABEL_95;
    }
    v200 = *(_QWORD *)(v63 + 8);
    if (*(char *)(v63 + 23) >= 0)
      v201 = *(unsigned __int8 *)(v63 + 23);
    else
      v201 = *(_QWORD *)(v63 + 8);
    v202 = buf[23];
    if (buf[23] < 0)
      v202 = *(_QWORD *)&buf[8];
    if (v201 != v202)
      goto LABEL_330;
    if (buf[23] >= 0)
      v203 = buf;
    else
      v203 = *(unsigned __int8 **)buf;
    if ((*(_BYTE *)(v63 + 23) & 0x80) != 0)
    {
      v63 = *(_QWORD *)v63;
      if (memcmp((const void *)v63, v203, v200))
      {
        v206 = (void *)MEMORY[0x1E0CB3940];
LABEL_334:
        v63 = objc_msgSend(v206, "stringWithUTF8String:", v63);
        v199 = v196;
        goto LABEL_336;
      }
    }
    else if (*(_BYTE *)(v63 + 23))
    {
      v204 = (unsigned __int8 *)v63;
      v205 = *(unsigned __int8 *)(v63 + 23);
      while (*v204 == *v203)
      {
        ++v204;
        ++v203;
        if (!--v205)
          goto LABEL_335;
      }
LABEL_330:
      v206 = (void *)MEMORY[0x1E0CB3940];
      if ((*(_BYTE *)(v63 + 23) & 0x80) != 0)
        v63 = *(_QWORD *)v63;
      goto LABEL_334;
    }
LABEL_335:
    v63 = 0;
    goto LABEL_336;
  }
  HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFC18);
LABEL_304:
  if (Mutable)
    CFRelease(Mutable);
}

void sub_183EE8D44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, CFTypeRef cf,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,char a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  uint64_t v44;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a37);
  if (a44 < 0)
    operator delete(__p);
  if (v44)
    (*(void (**)(uint64_t))(*(_QWORD *)v44 + 48))(v44);
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(a1);
}

void HTTPProtocol::shouldUseAPSRelay(HTTPProtocol *this@<X0>, _QWORD *a2@<X8>)
{
  void *v2;
  const void *v4;
  CFTypeRef v5;
  _QWORD *v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  __int128 v10;

  *a2 = 0;
  a2[1] = 0;
  v2 = (void *)*((_QWORD *)this + 10);
  if (v2)
  {
    v4 = (const void *)objc_msgSend(v2, "_APSRelayTopic");
    if (v4)
      v5 = CFRetain(v4);
    else
      v5 = 0;
    *(_QWORD *)&v10 = v5;
    v6 = (_QWORD *)operator new();
    *v6 = &off_1E14F19E8;
    v6[1] = 0;
    v6[2] = 0;
    v6[3] = v5;
    *((_QWORD *)&v10 + 1) = v6;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)a2, &v10);
    v7 = (std::__shared_weak_count *)*((_QWORD *)&v10 + 1);
    if (*((_QWORD *)&v10 + 1))
    {
      v8 = (unint64_t *)(*((_QWORD *)&v10 + 1) + 8);
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
}

void sub_183EE90CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t HTTPConnectionCacheKey::HTTPConnectionCacheKey(uint64_t a1, uint64_t a2, const __CFString *cf, int a4, int a5, const void *a6, uint64_t a7)
{
  uint64_t v13;
  uint64_t v14;
  const __CFAllocator *v15;
  CFStringRef Copy;
  const __CFAllocator *v17;
  CFDictionaryRef v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  CFTypeRef v25;
  const void *v26;
  __int128 v28;

  *(_QWORD *)a1 = off_1E14EF578;
  *(_QWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 16) = 1;
  if (((a1 + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)a1 = off_1E14EC400;
  *(_OWORD *)(a1 + 88) = 0u;
  v13 = a1 + 88;
  *(_OWORD *)(a1 + 104) = 0u;
  v14 = a1 + 104;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  if (cf)
  {
    v15 = CFGetAllocator(cf);
    Copy = CFStringCreateCopy(v15, cf);
  }
  else
  {
    Copy = 0;
  }
  *(_QWORD *)(a1 + 32) = Copy;
  *(_DWORD *)(a1 + 56) = a4;
  *(_DWORD *)(a1 + 60) = a5;
  if (a6)
  {
    v17 = CFGetAllocator(a6);
    v18 = CFDictionaryCreateCopy(v17, (CFDictionaryRef)a6);
    Copy = *(CFStringRef *)(a1 + 32);
  }
  else
  {
    v18 = 0;
  }
  *(_QWORD *)(a1 + 64) = v18;
  *(_QWORD *)(a1 + 72) = a7;
  *(_QWORD *)(a1 + 24) = CFHash(Copy) | (int)(*(_DWORD *)(a1 + 56) << 17) | (8 * *(_DWORD *)(a1 + 60)) | (*(_QWORD *)(a1 + 64) == 0) | (16 * *(_QWORD *)(a1 + 72));
  *(_QWORD *)(a1 + 80) = 0;
  v28 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v13, &v28);
  v19 = (std::__shared_weak_count *)*((_QWORD *)&v28 + 1);
  if (*((_QWORD *)&v28 + 1))
  {
    v20 = (unint64_t *)(*((_QWORD *)&v28 + 1) + 8);
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v28 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v14, &v28);
  v22 = (std::__shared_weak_count *)*((_QWORD *)&v28 + 1);
  if (*((_QWORD *)&v28 + 1))
  {
    v23 = (unint64_t *)(*((_QWORD *)&v28 + 1) + 8);
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 120) = 0x2FFFFFFFFLL;
  v25 = *(CFTypeRef *)(a1 + 32);
  if (v25)
    v25 = CFRetain(v25);
  v26 = *(const void **)(a1 + 136);
  *(_QWORD *)(a1 + 136) = v25;
  if (v26)
    CFRelease(v26);
  *(_QWORD *)(a1 + 144) = 0;
  return a1;
}

void sub_183EE92F4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  const void **v4;
  const void *v6;
  const void *v7;

  v6 = *(const void **)(v1 + 136);
  *(_QWORD *)(v1 + 136) = 0;
  if (v6)
    CFRelease(v6);
  v7 = *v4;
  *v4 = 0;
  if (v7)
    CFRelease(v7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  _Unwind_Resume(a1);
}

void _getConnectionInfoForProxy(const void *a1, __CFHTTPMessage *a2, _QWORD *a3, SInt32 *a4, _BOOL4 *a5, CFDictionaryRef *a6)
{
  const __CFURL *v12;
  const __CFString *v13;
  _BOOL4 v14;
  SInt32 v15;
  int v16;
  const __CFURL *v17;
  const void *Value;
  const __CFNumber *v19;
  __CFString *v20;
  const __CFURL *v21;
  const __CFAllocator *v22;
  const __CFString *v23;
  const __CFString *v24;
  const __CFAllocator *v25;
  _BOOL4 v26;
  SInt32 v27;
  int v28;
  __CFString *v29;
  CFStringRef cf1;

  if (CFEqual(a1, &unk_1E152A808))
  {
    v12 = CFHTTPMessageCopyRequestURL(a2);
    v13 = CFURLCopyScheme(v12);
    v14 = 1;
    if (CFStringCompare(v13, (CFStringRef)&unk_1EDD00AE0, 1uLL))
      v14 = CFStringCompare(v13, CFSTR("wss"), 1uLL) == kCFCompareEqualTo;
    *a5 = v14;
    CFRelease(v13);
    *a3 = CFURLCopyHostName(v12);
    v15 = CFURLGetPortNumber(v12);
    *a4 = v15;
    if (v15 == -1)
    {
      if (*a5)
        v16 = 443;
      else
        v16 = 80;
      *a4 = v16;
    }
    *a6 = 0;
    v17 = v12;
LABEL_10:
    CFRelease(v17);
    return;
  }
  Value = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("kCFProxyTypeKey"));
  v19 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("kCFProxyPortNumberKey"));
  v20 = (__CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("kCFProxyHostNameKey"));
  CFNumberGetValue(v19, kCFNumberSInt32Type, a4);
  if (CFEqual(Value, CFSTR("kCFProxyTypeHTTP")) || CFEqual(Value, CFSTR("kCFProxyTypeFTP")))
  {
    *a5 = 2;
    *a3 = CFRetain(v20);
    *a6 = 0;
  }
  else if (CFEqual(Value, CFSTR("kCFProxyTypeHTTPS")) || CFEqual(Value, CFSTR("kCFProxyTypeSOCKS")))
  {
    v21 = CFHTTPMessageCopyRequestURL(a2);
    if (CFEqual(Value, CFSTR("kCFProxyTypeHTTPS")))
    {
      v22 = CFGetAllocator(a2);
      *a6 = _newConnPropsForHTTPSProxy(v22, a2, v20, v19);
      *a5 = 3;
    }
    else
    {
      cf1 = CFURLCopyScheme(v21);
      v29 = (__CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("kCFProxyUsernameKey"));
      v23 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("kCFProxyPasswordKey"));
      v24 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, (const void *)*MEMORY[0x1E0C9B2E0]);
      v25 = CFGetAllocator(a2);
      *a6 = newConnPropsForSOCKSProxy(v25, v20, v19, v29, v23, v24);
      if (CFEqual(cf1, &unk_1EDD00AE0))
        v26 = 1;
      else
        v26 = CFEqual(cf1, CFSTR("wss")) != 0;
      *a5 = v26;
      if (cf1)
        CFRelease(cf1);
    }
    *a3 = CFURLCopyHostName(v21);
    v27 = CFURLGetPortNumber(v21);
    *a4 = v27;
    if (v27 == -1)
    {
      if (*a5)
        v28 = 443;
      else
        v28 = 80;
      *a4 = v28;
    }
    v17 = v21;
    goto LABEL_10;
  }
}

uint64_t ___ZN14NWIOConnection5writeEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFv13CFStreamErrorE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

BOOL HTTPProtocol::canRelinquishControlToTask(HTTPProtocol *this)
{
  void *v1;

  v1 = (void *)*((_QWORD *)this + 10);
  return v1
      && !(*(unsigned int (**)(HTTPProtocol *))(*(_QWORD *)this + 520))(this)
      && objc_msgSend(v1, "session") != 0;
}

dispatch_data_t GZipDataDecoder::decodeData(GZipDataDecoder *this, const __CFAllocator *a2, CFDataRef theData, unsigned __int8 *a4)
{
  const __CFData *v7;
  int v8;
  __CFData *v10;

  v7 = 0;
  LODWORD(v10) = 0;
  if (!*((_BYTE *)this + 121))
  {
    v8 = gzipDecodeHeader(theData, (uInt *)&v10, 0, 0, 0, a4);
    *((_BYTE *)this + 121) = v8;
    if (!v8)
      return 0;
    v7 = (const __CFData *)v10;
  }
  *a4 = 0;
  return createGzipDecodedData((z_stream_s *)((char *)this + 8), (unsigned __int8 *)this + 122, theData, v7);
}

dispatch_data_t createGzipDecodedData(z_stream_s *a1, unsigned __int8 *a2, CFDataRef theData, const __CFData *a4)
{
  dispatch_data_t subrange;
  int v5;
  uint64_t alloc;
  NSObject *v10;
  uInt v11;
  int v12;
  uInt avail_out;
  NSObject *v14;
  NSObject *v15;
  dispatch_data_t concat;
  size_t size;

  if (*a2)
  {
    subrange = (dispatch_data_t)MEMORY[0x1E0C80D00];
    dispatch_retain(MEMORY[0x1E0C80D00]);
  }
  else
  {
    v5 = (int)a4;
    a1->next_in = (Bytef *)&CFDataGetBytePtr(theData)[(int)a4];
    a1->avail_in = CFDataGetLength(theData) - v5;
    a1->avail_out = 0x4000;
    alloc = dispatch_data_create_alloc();
    if (alloc)
    {
      v10 = alloc;
      v11 = 0x4000;
      while (1)
      {
        v12 = inflate(a1, 0);
        if (v12 != -5)
        {
          if (v12)
            break;
        }
        avail_out = a1->avail_out;
        if (avail_out)
          goto LABEL_12;
        v11 <<= v11 >> 26 == 0;
        a1->avail_out = v11;
        v14 = dispatch_data_create_alloc();
        if (!v14)
          goto LABEL_13;
        v15 = v14;
        concat = dispatch_data_create_concat(v10, v14);
        dispatch_release(v15);
        dispatch_release(v10);
        v10 = concat;
      }
      if (v12 == 1)
      {
        *a2 = 1;
        avail_out = a1->avail_out;
LABEL_12:
        size = dispatch_data_get_size(v10);
        subrange = dispatch_data_create_subrange(v10, 0, size - avail_out);
        dispatch_release(v10);
        return subrange;
      }
LABEL_13:
      dispatch_release(v10);
    }
    return 0;
  }
  return subrange;
}

const char *HSTSPolicy::isKnownHSTSHost(HSTSPolicy *this, NSString *a2, unsigned __int8 *a3)
{
  const char *result;
  unsigned __int8 *v6;
  size_t v7;

  result = -[NSString UTF8String](a2, "UTF8String");
  if (result)
  {
    v6 = (unsigned __int8 *)result;
    v7 = strlen(result);
    return (const char *)HSTSPolicy::isKnownHSTSHost(this, v6, v7, a3);
  }
  return result;
}

uint64_t HTTPProtocol::getSuspensionThreshold(HTTPProtocol *this)
{
  return objc_msgSend(*((id *)this + 10), "_suspensionThreshhold");
}

void *HTTPProtocol::takePreventIdleSleepAssertionIfAppropriate(HTTPProtocol *this)
{
  void *result;

  result = (void *)*((_QWORD *)this + 10);
  if (result)
    return (void *)objc_msgSend(result, "_takePreventIdleSleepAssertionIfAppropriate");
  return result;
}

uint64_t HTTPProtocol::requiresSustainedDataDelivery(HTTPProtocol *this)
{
  void *v1;

  if (*((_QWORD *)this + 93) && (v1 = (void *)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration")) != 0)
    return objc_msgSend(v1, "_requiresSustainedDataDelivery");
  else
    return 0;
}

uint64_t HTTPProtocol::setPriorityHint(HTTPProtocol *this, float a2)
{
  uint64_t result;

  result = *((_QWORD *)this + 34);
  if (result)
    return (*(uint64_t (**)(uint64_t, float))(*(_QWORD *)result + 80))(result, a2);
  return result;
}

void sub_183EE9CF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<AuthenticationState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void ___ZN12HTTPProtocol10openStreamEv_block_invoke(uint64_t a1, int a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  HTTPMessage *v7;
  const __CFString *v8;
  const __CFString *v9;
  CFIndex Length;
  BOOL v11;
  CFIndex v12;
  int CharacterAtIndex;
  uint64_t v14;
  char v15;
  HTTPMessage *v16;
  const __CFData *v17;
  unsigned int v18;
  uint64_t v19;
  const __CFAllocator *v20;
  CFNumberRef v21;
  uint64_t valuePtr;

  v3 = *(_QWORD *)(a1 + 32);
  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  if (!a2)
    HTTPProtocol::sendError((HTTPProtocol *)v3, (const __CFString *)0xFFFFFFFFFFFFFC14);
  v4 = *(unsigned int *)(v3 + 192) | ((unint64_t)*(unsigned __int16 *)(v3 + 196) << 32);
  if ((v4 & 0x400000000000) != 0)
  {
    *(_QWORD *)(v3 + 56) = 0;
    v6 = v4 & 0xFFFFBFFFFFFFFFFFLL;
    *(_DWORD *)(v3 + 192) = v6;
    *(_WORD *)(v3 + 196) = WORD2(v6);
    goto LABEL_10;
  }
  v5 = *(_QWORD *)(v3 + 56);
  if (v5 > 0)
  {
LABEL_11:
    v7 = *(HTTPMessage **)(objc_msgSend(*(id *)(v3 + 88), "_inner") + 56);
    if (v7)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v8 = HTTPMessage::copyHeaderFieldValue(v7, 0x11D1D2CFu);
      if (v8)
      {
        v9 = v8;
        Length = CFStringGetLength(v8);
        if (Length < 1)
        {
          v12 = 0;
          v11 = 1;
        }
        else
        {
          v11 = 0;
          v12 = 0;
          while (1)
          {
            CharacterAtIndex = CFStringGetCharacterAtIndex(v9, v12);
            if (CharacterAtIndex != 32 && CharacterAtIndex != 9)
              break;
            v11 = ++v12 >= Length;
            if (Length == v12)
            {
              v14 = 0;
              v15 = v12 >= Length;
              goto LABEL_35;
            }
          }
        }
        v15 = v11;
        if (v12 >= Length)
        {
          v14 = 0;
        }
        else
        {
          v14 = 0;
          while (1)
          {
            v18 = CFStringGetCharacterAtIndex(v9, v12);
            if (v18 - 48 > 9)
              break;
            ++v12;
            v19 = 10 * v14 + v18;
            if (v12 < Length && v19 > 0xCCCCCCCCCCCCCF2)
              goto LABEL_24;
            v14 = v19 - 48;
            v15 = 1;
            if (Length == v12)
            {
              CFRelease(v9);
              goto LABEL_36;
            }
          }
        }
LABEL_35:
        CFRelease(v9);
        if (v15)
        {
LABEL_36:
          v5 = *(_QWORD *)(v3 + 56) + v14;
          *(_QWORD *)(v3 + 56) = v5;
          goto LABEL_38;
        }
      }
      else
      {
        v16 = *(HTTPMessage **)(objc_msgSend(*(id *)(v3 + 88), "_inner") + 56);
        if (!v16 || (v17 = HTTPMessage::copyBody(v16)) == 0)
        {
          *(_QWORD *)(v3 + 56) = -1;
          return;
        }
        v9 = (const __CFString *)v17;
        *(_QWORD *)(v3 + 56) += CFDataGetLength(v17);
LABEL_24:
        CFRelease(v9);
      }
    }
LABEL_37:
    v5 = *(_QWORD *)(v3 + 56);
    goto LABEL_38;
  }
  if (!v5)
  {
LABEL_10:
    if (!*(_BYTE *)(v3 + 492))
      goto LABEL_37;
    goto LABEL_11;
  }
LABEL_38:
  if (v5 != -1 && *(_QWORD *)(v3 + 272))
  {
    valuePtr = v5;
    v20 = CFGetAllocator((CFTypeRef)(v3 - 16));
    v21 = CFNumberCreate(v20, kCFNumberSInt64Type, &valuePtr);
    (*(void (**)(_QWORD, uint64_t, CFNumberRef))(**(_QWORD **)(v3 + 272) + 40))(*(_QWORD *)(v3 + 272), 10, v21);
    if (v21)
      CFRelease(v21);
  }
}

void sub_183EEA2C8(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t NWIOConnection::setProperty_offqueue(NWIOConnection *this, const __CFString *a2, const void *a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  v3 = (*(uint64_t (**)(NWIOConnection *, const __CFString *, const void *))(*(_QWORD *)this + 200))(this, a2, a3);
  *((_BYTE *)v6 + 24) = v3;
  _Block_object_dispose(&v5, 8);
  return v3;
}

void sub_183EEA340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<CoreSchedulingSet *,Deleter_release<CoreSchedulingSet>,std::allocator<CoreSchedulingSet>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

uint64_t std::__shared_ptr_emplace<AuthenticationInfo>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void AuthenticationInfo::~AuthenticationInfo(AuthenticationInfo *this)
{
  const void *v2;
  uint64_t v3;
  uint64_t v4;
  const void *v5;
  uint64_t v6;

  *(_QWORD *)this = &off_1E14E9138;
  v2 = (const void *)*((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (v2)
    CFRelease(v2);
  v3 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v3)
    CFRelease((CFTypeRef)(v3 - 16));
  v4 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v4)
    CFRelease((CFTypeRef)(v4 - 16));
  v5 = (const void *)*((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v5)
    CFRelease(v5);
  v6 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (v6)
    CFRelease((CFTypeRef)(v6 - 16));
  *(_QWORD *)this = &off_1E14E5838;
}

{
  AuthenticationInfo::~AuthenticationInfo(this);
  JUMPOUT(0x186DB748CLL);
}

void ___ZN15HTTP2Connection24setupReadCompletionBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke(uint64_t a1, dispatch_data_t data, char a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v8;
  NSObject *v9;
  dispatch_time_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v19;
  uint64_t v20;
  HTTP2Connection *v21;
  NSObject *v22;
  HTTP2Connection *v23;
  __int16 v24[8];
  _QWORD applier[5];
  std::__shared_weak_count *v26;

  v6 = *(_QWORD *)(a1 + 32);
  *(_WORD *)(v6 + 80) = 256;
  if (data)
  {
    v8 = *(_QWORD *)(v6 + 648);
    if (*(_QWORD *)(*(_QWORD *)(v8 + 40) + 16))
    {
      v9 = *(NSObject **)(v8 + 32);
      v10 = dispatch_time(0x8000000000000000, 3000000000);
      dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
      v6 = *(_QWORD *)(a1 + 32);
    }
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3321888768;
    applier[2] = ___ZN15HTTP2Connection24setupReadCompletionBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke_2;
    applier[3] = &__block_descriptor_48_e8_32c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
    v11 = *(std::__shared_weak_count **)(a1 + 40);
    applier[4] = v6;
    v26 = v11;
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }
    dispatch_data_apply(data, applier);
    v14 = v26;
    if (v26)
    {
      v15 = (unint64_t *)&v26->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }
  else
  {
    v19 = a5;
    if (a4 | a5)
    {
      *(_DWORD *)(v6 + 176) = 4;
      HTTP2Connection::closeConnection((HTTP2Connection *)v6, 0);
      if (a4 != 1 || v19 != 57)
      {
        v20 = *(_QWORD *)(a1 + 32);
        *(_QWORD *)(v20 + 144) = a4;
        *(_QWORD *)(v20 + 152) = a5;
      }
      v21 = *(HTTP2Connection **)(a1 + 32);
      if (!*((_BYTE *)v21 + 136))
      {
        *((_BYTE *)v21 + 136) = 1;
        HTTP2Connection::closeConnection(v21, 0);
      }
    }
    else
    {
      if ((a3 & 1) == 0)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v22 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
        {
          v24[0] = 0;
          _os_log_fault_impl(&dword_183ECA000, v22, OS_LOG_TYPE_FAULT, "Unexpected API behavior: received no bytes, no error, and no EOF from connection", (uint8_t *)v24, 2u);
        }
      }
      HTTP2Connection::_onqueue_closeConnection(*(HTTP2Connection **)(a1 + 32), 0, 0);
    }
  }
  HTTP2Connection::flushAllBatchedData(*(HTTP2Connection **)(a1 + 32));
  v23 = *(HTTP2Connection **)(a1 + 32);
  *((_BYTE *)v23 + 81) = 0;
  HTTP2Connection::_onqueue_scheduleIO(v23);
}

void HTTP2Connection::_onqueue_scheduleIO(HTTP2Connection *this)
{
  int v1;
  int local_window_size;
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  _QWORD *v7;
  _QWORD *v8;
  _OWORD *v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  uint64_t *v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;

  v1 = *((_DWORD *)this + 44);
  if ((v1 - 3) < 2 || *((_BYTE *)this + 81))
    return;
  if (v1 == 1)
    goto LABEL_7;
  if (!v1)
  {
    if (!*((_BYTE *)this + 596))
    {
      *((_DWORD *)this + 44) = 4;
      HTTP2Connection::closeConnection(this, 0);
      return;
    }
    *((_DWORD *)this + 44) = 1;
LABEL_7:
    if (*((_BYTE *)this + 228))
      *((_DWORD *)this + 44) = 2;
  }
  if (!*((_BYTE *)this + 104) && *((_DWORD *)this + 27) <= 2u && nghttp2_session_want_write())
    HTTP2Connection::_onqueue_performWrite(this);
  if (*((_QWORD *)this + 78))
    __assert_rtn("_onqueue_scheduleIO", "HTTP2Connection.cpp", 1661, "_batchedStreamData.size() == 0");
  if (!*((_BYTE *)this + 80) && nghttp2_session_want_read())
  {
    local_window_size = nghttp2_session_get_local_window_size();
    if (local_window_size <= 0)
      v4 = 132000;
    else
      v4 = (local_window_size + 132000);
    *((_BYTE *)this + 80) = 1;
    v5 = *((_QWORD *)this + 7);
    v6 = (const void *)*((_QWORD *)this + 15);
    if (*(_DWORD *)v5 == 2)
    {
      v7 = *(_QWORD **)(v5 + 8);
      v8 = operator new(0x30uLL);
      v8[1] = 0;
      v8[2] = 0;
      *v8 = &off_1E14F0F30;
      v8[3] = 1;
      v8[4] = v4;
      v8[5] = 0;
      if (v6)
        v8[5] = _Block_copy(v6);
      v9 = operator new(0x20uLL);
      *(_QWORD *)&v10 = v8 + 3;
      *((_QWORD *)&v10 + 1) = v8;
      v9[1] = v10;
      v11 = v7[21];
      *(_QWORD *)v9 = v11;
      *((_QWORD *)v9 + 1) = v7 + 21;
      *(_QWORD *)(v11 + 8) = v9;
      v7[21] = v9;
      v12 = v7[23];
      v7[23] = v12 + 1;
      if (v12 != -1)
      {
        do
        {
          if (!v7[26])
            break;
          v13 = v7[22];
          v15 = *(_QWORD *)(v13 + 16);
          v14 = *(std::__shared_weak_count **)(v13 + 24);
          if (v14)
          {
            p_shared_owners = (unint64_t *)&v14->__shared_owners_;
            do
              v17 = __ldxr(p_shared_owners);
            while (__stxr(v17 + 1, p_shared_owners));
          }
          v18 = (uint64_t *)v7[25];
          v19 = (std::__shared_weak_count *)v18[3];
          if (v19)
          {
            v20 = (unint64_t *)&v19->__shared_owners_;
            do
              v21 = __ldxr(v20);
            while (__stxr(v21 + 1, v20));
            v18 = (uint64_t *)v7[25];
          }
          v22 = *v18;
          *(_QWORD *)(v22 + 8) = v18[1];
          *(_QWORD *)v18[1] = v22;
          --v7[26];
          std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v18 + 2));
          operator delete(v18);
          v24 = (uint64_t *)v7[22];
          v23 = v7[23];
          v25 = *v24;
          *(_QWORD *)(v25 + 8) = v24[1];
          *(_QWORD *)v24[1] = v25;
          v7[23] = v23 - 1;
          std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v24 + 2));
          operator delete(v24);
          (*(void (**)(void))(*(_QWORD *)(v15 + 16) + 16))();
          if (v19)
          {
            v26 = (unint64_t *)&v19->__shared_owners_;
            do
              v27 = __ldaxr(v26);
            while (__stlxr(v27 - 1, v26));
            if (!v27)
            {
              ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
              std::__shared_weak_count::__release_weak(v19);
            }
          }
          if (v14)
          {
            v28 = (unint64_t *)&v14->__shared_owners_;
            do
              v29 = __ldaxr(v28);
            while (__stlxr(v29 - 1, v28));
            if (!v29)
            {
              ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
              std::__shared_weak_count::__release_weak(v14);
            }
          }
        }
        while (v7[23]);
      }
    }
    else
    {
      if (*(_DWORD *)v5 != 1)
        __assert_rtn("read", "TCPIOConnectionTest.hpp", 286, "false");
      (*(void (**)(_QWORD, uint64_t, uint64_t, _QWORD))(**(_QWORD **)(v5 + 8) + 40))(*(_QWORD *)(v5 + 8), 1, v4, *((_QWORD *)this + 15));
    }
  }
}

void sub_183EEA954(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v3;

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

BOOL ___ZN15HTTP2Connection24setupReadCompletionBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke_2(uint64_t a1, dispatch_object_t object, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  HTTP2Connection *v10;
  uint64_t v11;

  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 88) = object;
  dispatch_retain(object);
  v8 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(v8 + 96) = a4;
  v9 = MEMORY[0x186DB7E58](*(_QWORD *)(v8 + 160), a4, a5);
  if (v9 != a5)
  {
    v10 = *(HTTP2Connection **)(a1 + 32);
    *((_DWORD *)v10 + 44) = 4;
    HTTP2Connection::closeConnection(v10, 0);
  }
  dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(a1 + 32) + 88));
  v11 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(v11 + 88) = 0;
  *(_QWORD *)(v11 + 96) = 0;
  return v9 == a5;
}

double HTTP2Connection::flushAllBatchedData(HTTP2Connection *this)
{
  _QWORD *v2;
  _OWORD *v3;
  NSObject *v4;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;
  double result;

  v2 = (_QWORD *)*((_QWORD *)this + 76);
  v3 = (_OWORD *)((char *)this + 616);
  if (v2 != (_QWORD *)((char *)this + 616))
  {
    do
    {
      v4 = v2[5];
      if (v4)
      {
        HTTP2Stream::bufferDataFromDataFrame(v2[4], (dispatch_object_t)v2[5], 0);
        dispatch_release(v4);
      }
      v5 = (_QWORD *)v2[1];
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = (_QWORD *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (_QWORD *)v2[2];
          v7 = *v6 == (_QWORD)v2;
          v2 = v6;
        }
        while (!v7);
      }
      v2 = v6;
    }
    while (v6 != (_QWORD *)v3);
  }
  std::__tree<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,std::__map_value_compare<HTTP2Stream *,std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,BOOL (*)(HTTP2Stream const*,HTTP2Stream const*),false>,std::allocator<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>>>::destroy(*((_QWORD **)this + 77));
  *((_QWORD *)this + 76) = v3;
  result = 0.0;
  *v3 = 0u;
  return result;
}

void std::__tree<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,std::__map_value_compare<HTTP2Stream *,std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,BOOL (*)(HTTP2Stream const*,HTTP2Stream const*),false>,std::allocator<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,std::__map_value_compare<HTTP2Stream *,std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,BOOL (*)(HTTP2Stream const*,HTTP2Stream const*),false>,std::allocator<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>>>::destroy(*a1);
    std::__tree<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,std::__map_value_compare<HTTP2Stream *,std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,BOOL (*)(HTTP2Stream const*,HTTP2Stream const*),false>,std::allocator<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>>>::destroy(a1[1]);
    operator delete(a1);
  }
}

BOOL URLCanUseCookies(const __CFURL *a1)
{
  const __CFString *v1;
  const __CFString *v2;
  _BOOL8 v3;

  if (!a1)
    return 0;
  v1 = CFURLCopyScheme(a1);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = 1;
  if (CFStringCompare(v1, CFSTR("http"), 1uLL))
  {
    v3 = 1;
    if (CFStringCompare(v2, (CFStringRef)&unk_1EDD00AE0, 1uLL))
    {
      v3 = 1;
      if (CFStringCompare(v2, (CFStringRef)&unk_1EDD00A00, 1uLL))
      {
        v3 = 1;
        if (CFStringCompare(v2, CFSTR("ws"), 1uLL))
          v3 = CFStringCompare(v2, CFSTR("wss"), 1uLL) == kCFCompareEqualTo;
      }
    }
  }
  CFRelease(v2);
  return v3;
}

uint64_t std::__shared_ptr_pointer<HTTPConnectionCacheEntry::EnqueuedRequest *,HTTPConnectionCacheEntry::_prepareNewRequest(MetaConnectionCacheClient *,HTTPRequestMessage const*,MetaConnectionOptions)::$_0,std::allocator<HTTPConnectionCacheEntry::EnqueuedRequest>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

uint64_t ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_24(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

void std::__shared_ptr_pointer<Tube *,Deleter_CustomBlock,std::allocator<Tube>>::__on_zero_shared(uint64_t a1)
{
  Deleter_CustomBlock::operator()((const void **)(a1 + 32));
}

BOOL HTTPConnectionCacheEntry::_canPipelineOnConnection(uint64_t a1, HTTPConnection **a2)
{
  HTTPConnection *v2;
  unsigned __int16 v5;
  __int16 v6;
  _BOOL8 result;
  int PendingResponseCount;
  uint64_t v9;
  HTTPConnection *v10;
  int v11;
  unsigned int v12;
  _QWORD v13[3];
  BOOL v14;

  v2 = *a2;
  if (*a2
    && (*(_BYTE *)(a1 + 32) & 8) != 0
    && ((*(_BYTE *)(a1 + 32) & 0x10) == 0 || (*(_BYTE *)(a1 + 32) & 0x60) == 0x20))
  {
    v13[0] = 0;
    v13[1] = v13;
    v13[2] = 0x2020000000;
    v5 = *((unsigned __int8 *)v2 + 34);
    v6 = v5 >> 1;
    v14 = (v5 & 2) != 0;
    _Block_object_dispose(v13, 8);
    if ((v6 & 1) != 0)
    {
      PendingResponseCount = HTTPConnection::getPendingResponseCount(*a2);
      v9 = *(_QWORD *)(a1 + 56);
      v10 = *a2;
      v11 = *((unsigned __int16 *)*a2 + 16) | (*((unsigned __int8 *)*a2 + 34) << 16);
      result = PendingResponseCount < *(_DWORD *)(v9 + 4);
      if (PendingResponseCount < *(_DWORD *)(v9 + 4))
      {
        if ((v11 & 0x100000) == 0)
          return 1;
        if (PendingResponseCount > *(_DWORD *)(v9 + 8))
          return 0;
        v12 = v11 & 0xFFEFFFFF;
      }
      else
      {
        v12 = v11 | 0x100000;
      }
      *((_WORD *)v10 + 16) = v12;
      *((_BYTE *)v10 + 34) = BYTE2(v12);
      return result;
    }
  }
  return 0;
}

void std::__shared_ptr_pointer<NSObject  {objcproto16OS_nw_parameters}*,Deleter_NWRelease<NSObject  {objcproto16OS_nw_parameters}*>,std::allocator<NSObject  {objcproto16OS_nw_parameters}>>::__on_zero_shared(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 24);
  if (v1)
    nw_release(v1);
}

uint64_t ___ZN4Tube10initializeEP16BaseAwaitingTubeP7NSArrayIP30_NSHTTPAlternativeServiceEntryE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL4 isFirstPartyResource;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  int v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 56);
  if (*(_DWORD *)(v2 + 220) != 10)
    *(_DWORD *)(v2 + 220) = 1;
  v3 = (uint64_t *)MEMORY[0x1E0C9AE50];
  if (*(_BYTE *)(a1 + 64))
    (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v2 + 136) + 200))(*(_QWORD *)(v2 + 136), 0x1EDCF92C8, *MEMORY[0x1E0C9AE50]);
  if (*(_QWORD *)(a1 + 32) && *(_QWORD *)(a1 + 40))
  {
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 136) + 200))(*(_QWORD *)(v2 + 136), 0x1EDCF99C8);
    (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v2 + 136) + 200))(*(_QWORD *)(v2 + 136), 0x1EDCF9A00, *(_QWORD *)(a1 + 40));
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v4 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_INFO))
    {
      v5 = objc_msgSend(*(id *)(a1 + 48), "_loggableDescription");
      v15 = 138543362;
      v16 = v5;
      _os_log_impl(&dword_183ECA000, v4, OS_LOG_TYPE_INFO, "%{public}@ Alt-Svc entry found", (uint8_t *)&v15, 0xCu);
    }
  }
  v6 = *(_QWORD *)(v2 + 136);
  isFirstPartyResource = HTTPConnectionCacheKey::isFirstPartyResource(*(HTTPConnectionCacheKey **)(v2 + 104));
  v8 = *v3;
  v9 = *MEMORY[0x1E0C9AE40];
  if (isFirstPartyResource)
    v10 = v8;
  else
    v10 = *MEMORY[0x1E0C9AE40];
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 200))(v6, 0x1EDCF9920, v10);
  v11 = *(_QWORD *)(v2 + 136);
  v12 = *(_QWORD *)(v2 + 104);
  v13 = *(const void **)(v12 + 40);
  if (v13 && !CFEqual(*(CFTypeRef *)(v12 + 32), v13))
    v8 = v9;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v11 + 200))(v11, 0x1EDCF9958, v8);
  Tube::_onqueue_connect((Tube *)v2);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

uint64_t HTTPTransaction::setProperty(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2020000000;
  v11 = 0;
  v5 = MetaNetStreamInfo::applicableToPropertyName(a2);
  v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 208))(a1, v5, a3);
  *((_BYTE *)v9 + 24) = v6;
  _Block_object_dispose(&v8, 8);
  return v6;
}

void sub_183EEB004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t HTTPTransaction::_onqueue_setProperty(HTTPMessage **this, CFStringRef theString, const void *a3)
{
  int ExactString;
  int v7;
  CFTypeID v8;
  CFTypeID v9;
  __int16 v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  HTTPConnection *v14;
  HTTPEngine *v15;
  unint64_t *v16;
  unint64_t v17;
  CFTypeID v18;
  const void *v19;
  HTTPMessage *v20;
  HTTPMessage *v21;
  CFTypeID v22;
  CFTypeID v23;
  std::__shared_weak_count *v24;
  std::__shared_weak_count *v25;
  HTTPConnection *v26;
  unint64_t *p_shared_owners;
  HTTPConnection *v29;
  std::__shared_weak_count *v30;

  ExactString = _findExactString(theString, 0);
  if (ExactString <= 83273190)
  {
    if (ExactString <= 38142589)
    {
      if (ExactString > 36061769)
      {
        if (ExactString == 36061770)
          goto LABEL_38;
        v7 = 37110372;
      }
      else
      {
        if (ExactString == 11870276)
        {
          HTTPMessage::setHeaderFieldStringValue(this[20], 0x1171B29Fu, a3);
          return 1;
        }
        v7 = 32842260;
      }
    }
    else if (ExactString <= 40239791)
    {
      if (ExactString == 38142590)
        goto LABEL_38;
      v7 = 39191191;
    }
    else
    {
      if (ExactString == 40239792 || ExactString == 66307256)
        goto LABEL_38;
      v7 = 68551902;
    }
    goto LABEL_37;
  }
  if (ExactString <= 120965282)
  {
    if (ExactString > 90506881)
    {
      if (ExactString != 90506882)
      {
        if (ExactString != 104064896)
        {
          v7 = 119892109;
          goto LABEL_37;
        }
        if (a3)
        {
          v18 = CFGetTypeID(a3);
          if (v18 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            LOWORD(v29) = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&v29, 2u);
          }
          v19 = (const void *)*MEMORY[0x1E0C9AE50];
          if ((const void *)*MEMORY[0x1E0C9AE50] == a3 && ((_WORD)this[4] & 0x400) == 0)
          {
            v10 = *((_WORD *)this + 16) | 0x600;
LABEL_78:
            *((_WORD *)this + 16) = v10;
            return 1;
          }
          v23 = CFGetTypeID(a3);
          if (v23 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            LOWORD(v29) = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&v29, 2u);
          }
          if (v19 == a3)
            return 1;
        }
        if (((_WORD)this[4] & 0x400) != 0)
        {
          v10 = (_WORD)this[4] & 0xF9FF | 0x200;
          goto LABEL_78;
        }
        return 1;
      }
      goto LABEL_38;
    }
    if (ExactString == 83273191)
      goto LABEL_38;
    v7 = 87361088;
LABEL_37:
    if (ExactString == v7)
      goto LABEL_38;
    goto LABEL_59;
  }
  if (ExactString <= 135580084)
  {
    if (ExactString == 120965283)
      goto LABEL_38;
    v7 = 129296697;
    goto LABEL_37;
  }
  if (ExactString != 135580085)
  {
    if (ExactString == 398906741)
    {
      v20 = this[19];
      if (v20)
        _Block_release(v20);
      if (a3)
        v21 = (HTTPMessage *)_Block_copy(a3);
      else
        v21 = 0;
      this[19] = v21;
      return 1;
    }
    if (ExactString != 406214149)
    {
LABEL_59:
      if (*((int *)this + 20) <= 1)
      {
        v15 = 0;
        if (ExactString == 216338253 || ExactString == 223645657)
          return (uint64_t)v15;
        if (ExactString == 413529750)
        {
          if (!a3)
            goto LABEL_68;
          v22 = CFGetTypeID(a3);
          if (v22 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            LOWORD(v29) = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&v29, 2u);
          }
          if ((const void *)*MEMORY[0x1E0C9AE50] == a3)
            v10 = *((_WORD *)this + 16) | 1;
          else
LABEL_68:
            v10 = (_WORD)this[4] & 0xFFFE;
          goto LABEL_78;
        }
        v24 = (std::__shared_weak_count *)this[8];
        if (v24)
        {
          v25 = std::__shared_weak_count::lock(v24);
          v30 = v25;
          if (v25)
          {
            v13 = v25;
            v26 = this[7];
            v29 = v26;
            if (v26)
              v15 = HTTPConnection::setProperty(v26, theString, a3);
            else
              v15 = 0;
            p_shared_owners = (unint64_t *)&v13->__shared_owners_;
            do
              v17 = __ldaxr(p_shared_owners);
            while (__stlxr(v17 - 1, p_shared_owners));
            goto LABEL_45;
          }
        }
      }
      return 0;
    }
    if (a3)
    {
      v8 = CFGetTypeID(a3);
      if (v8 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        LOWORD(v29) = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&v29, 2u);
      }
      if ((const void *)*MEMORY[0x1E0C9AE50] == a3)
      {
        v10 = *((_WORD *)this + 16) | 0x800;
      }
      else
      {
        v9 = CFGetTypeID(a3);
        if (v9 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          LOWORD(v29) = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&v29, 2u);
        }
        if ((const void *)*MEMORY[0x1E0C9AE40] != a3)
          return 1;
        v10 = (_WORD)this[4] & 0xF7FF;
      }
      goto LABEL_78;
    }
    return 1;
  }
LABEL_38:
  v11 = (std::__shared_weak_count *)this[8];
  if (!v11)
    return 0;
  v12 = std::__shared_weak_count::lock(v11);
  v30 = v12;
  if (!v12)
    return 0;
  v13 = v12;
  v14 = this[7];
  v29 = v14;
  if (v14)
    v15 = HTTPConnection::setProperty(v14, theString, a3);
  else
    v15 = 0;
  v16 = (unint64_t *)&v13->__shared_owners_;
  do
    v17 = __ldaxr(v16);
  while (__stlxr(v17 - 1, v16));
LABEL_45:
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  return (uint64_t)v15;
}

void sub_183EEB5C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::setProperty(NWIOConnection *this, CFStringRef theString, const void *a3)
{
  int ExactString;
  uint64_t result;
  int v8;
  int v9;
  int v10;
  CFTypeID v11;
  int v12;
  CFTypeID v13;
  CFIndex Count;
  CFIndex v15;
  CFIndex v16;
  const void *ValueAtIndex;
  CFTypeID v18;
  __CFDictionary *v19;
  ConnectionEPTManager *v20;
  __CFDictionary *v21;
  CFStringRef v22;
  __CFDictionary *v23;
  const CFStringRef *v24;
  CFTypeID v25;
  xpc_object_t v26;
  int v27;
  const void **v28;
  const void *v29;
  CFTypeID v30;
  CFTypeID v31;
  uint64_t v32;
  CFTypeID v33;
  int v34;
  CFTypeID v35;
  int v36;
  CFTypeID v37;
  int v38;
  __CFDictionary *v39;
  const __CFString *v40;
  CFDictionaryRef *v41;
  const void *v42;
  CFTypeID v43;
  NSObject *v44;
  uint64_t v45;
  const CFStringRef *v46;
  _BYTE value[22];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  ExactString = _findExactString(theString, 0);
  result = 0;
  if (ExactString > 86279724)
  {
    if (ExactString <= 143911499)
    {
      if (ExactString <= 107284407)
      {
        if (ExactString > 96814833)
        {
          if (ExactString > 102123346)
          {
            if (ExactString <= 105187215)
            {
              if (ExactString != 102123347)
              {
                v8 = 103057261;
                goto LABEL_171;
              }
              if (*((int *)this + 34) > 1)
                return 0;
              if (a3)
              {
                *(_QWORD *)value = 0;
                v30 = CFGetTypeID(a3);
                if (v30 == CFNumberGetTypeID()
                  && CFNumberGetValue((CFNumberRef)a3, kCFNumberDoubleType, value)
                  && *(double *)value > 0.0)
                {
                  CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), theString, a3);
                }
                else
                {
                  CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 46), theString);
                }
                return 1;
              }
LABEL_253:
              v19 = (__CFDictionary *)*((_QWORD *)this + 46);
              goto LABEL_254;
            }
            if (ExactString != 105187216)
            {
              v10 = 106203045;
              goto LABEL_176;
            }
LABEL_172:
            if (*((int *)this + 34) > 0)
              return 0;
            goto LABEL_189;
          }
          if (ExactString != 96814834)
          {
            if (ExactString != 97904392)
            {
              v8 = 98862880;
              goto LABEL_171;
            }
LABEL_132:
            v21 = (__CFDictionary *)*((_QWORD *)this + 46);
            v22 = theString;
            if (!a3)
            {
              CFDictionaryRemoveValue(v21, theString);
              goto LABEL_195;
            }
            goto LABEL_193;
          }
LABEL_177:
          v27 = _findExactString(theString, 2u);
          result = 1;
          if (v27 > 90506881)
          {
            switch(v27)
            {
              case 106203045:
                v28 = (const void **)((char *)this + 640);
                break;
              case 96814834:
                v28 = (const void **)((char *)this + 632);
                break;
              case 90506882:
                v28 = (const void **)((char *)this + 616);
                break;
              default:
                return result;
            }
          }
          else
          {
            switch(v27)
            {
              case 83273191:
                v28 = (const void **)((char *)this + 624);
                break;
              case 84248066:
                v28 = (const void **)((char *)this + 656);
                break;
              case 89532009:
                v28 = (const void **)((char *)this + 648);
                break;
              default:
                return result;
            }
          }
          if (*v28)
          {
            _Block_release(*v28);
            *v28 = 0;
          }
          if (a3)
            *v28 = _Block_copy(a3);
          return 1;
        }
        if (ExactString <= 90506881)
        {
          if (ExactString != 86279725 && ExactString != 87361088)
          {
            v10 = 89532009;
            goto LABEL_176;
          }
          goto LABEL_172;
        }
        if (ExactString == 90506882)
          goto LABEL_177;
        if (ExactString == 93587130)
          goto LABEL_172;
        v8 = 94627531;
LABEL_171:
        if (ExactString != v8)
          return result;
        goto LABEL_172;
      }
      if (ExactString <= 122947789)
      {
        if (ExactString > 111413250)
        {
          if (ExactString == 111413251 || ExactString == 113535013)
            goto LABEL_172;
          v8 = 121940155;
          goto LABEL_171;
        }
        if (ExactString == 107284408)
          goto LABEL_132;
        if (ExactString == 108242893)
          goto LABEL_172;
        if (ExactString != 109373404)
          return result;
        if (!a3)
          goto LABEL_253;
        v13 = CFGetTypeID(a3);
        if (v13 == CFArrayGetTypeID())
        {
          Count = CFArrayGetCount((CFArrayRef)a3);
          if (Count >= 1)
          {
            v15 = Count;
            v16 = 0;
            do
            {
              ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a3, v16);
              v18 = CFGetTypeID(ValueAtIndex);
              if (v18 != CFStringGetTypeID())
                return 0;
            }
            while (v15 != ++v16);
          }
          v19 = (__CFDictionary *)*((_QWORD *)this + 46);
          goto LABEL_190;
        }
        return 0;
      }
      if (ExactString > 136563144)
      {
        if (ExactString > 138750445)
        {
          if (ExactString != 138750446)
          {
            v8 = 139782659;
            goto LABEL_171;
          }
        }
        else
        {
          if (ExactString == 136563145)
            goto LABEL_172;
          if (ExactString != 137693657)
            return result;
        }
        if (!a3)
        {
          v29 = (const void *)*MEMORY[0x1E0C9B0D0];
          v21 = (__CFDictionary *)*((_QWORD *)this + 46);
          v22 = theString;
          goto LABEL_194;
        }
        v21 = (__CFDictionary *)*((_QWORD *)this + 46);
        v22 = theString;
LABEL_193:
        v29 = a3;
LABEL_194:
        CFDictionarySetValue(v21, v22, v29);
LABEL_195:
        if (*((int *)this + 34) >= 1)
          NWIOConnection::_applyPropertyToConnection(this, theString);
        return 1;
      }
      if (ExactString != 122947790)
      {
        if (ExactString == 129296697)
        {
          if (a3)
          {
            *(_QWORD *)value = CFRetain(a3);
            std::shared_ptr<__CFArray const>::operator=[abi:nn180100]<__CFArray const,Deleter_CFRelease,void>((_QWORD *)this + 64, (uint64_t *)value);
            if (*(_QWORD *)value)
              CFRelease(*(CFTypeRef *)value);
          }
          else
          {
            *(_QWORD *)value = 0;
            *(_QWORD *)&value[8] = 0;
            std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 512, (__int128 *)value);
            std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)value);
          }
          return 1;
        }
        if (ExactString != 135580085)
          return result;
        if ((*((_WORD *)this + 124) & 0x800) == 0)
          goto LABEL_189;
        return 0;
      }
      v39 = (__CFDictionary *)*((_QWORD *)this + 46);
      if (a3)
      {
        CFDictionarySetValue(v39, theString, a3);
        v24 = &kCFStreamSSLPeerName;
        goto LABEL_228;
      }
      CFDictionaryRemoveValue(v39, theString);
      v46 = &kCFStreamSSLPeerName;
      goto LABEL_262;
    }
    if (ExactString > 195382724)
    {
      if (ExactString <= 213192471)
      {
        if (ExactString > 204762747)
        {
          if (ExactString == 204762748 || ExactString == 205827726)
            goto LABEL_172;
          v8 = 212037386;
        }
        else
        {
          if (ExactString == 195382725 || ExactString == 200625710)
            goto LABEL_172;
          v8 = 201641540;
        }
        goto LABEL_171;
      }
      if (ExactString > 226775050)
      {
        if (ExactString <= 231968870)
        {
          if (ExactString == 226775051)
            goto LABEL_172;
          v8 = 227954717;
          goto LABEL_171;
        }
        if (ExactString == 231968871)
          goto LABEL_189;
        if (ExactString != 233173110)
          return result;
        v24 = (const CFStringRef *)&kCFStreamSocketSecurityLevelDiffieHellmanParams;
        goto LABEL_228;
      }
      if (ExactString == 213192472)
      {
        if (*((int *)this + 34) > 0)
          return 0;
        if (!a3)
          goto LABEL_238;
        v43 = CFGetTypeID(a3);
        if (v43 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)value = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", value, 2u);
        }
        if ((const void *)*MEMORY[0x1E0C9AE50] == a3)
          CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_1EDCFB478, &unk_1EDCFB520);
        else
LABEL_238:
          CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 46), &unk_1EDCFB478);
        return 1;
      }
      if (ExactString == 214216493)
        goto LABEL_172;
      if (ExactString != 223645657)
        return result;
      v23 = (__CFDictionary *)*((_QWORD *)this + 46);
      if (a3)
      {
        CFDictionarySetValue(v23, theString, a3);
        v24 = &kCFStreamSSLLevel;
LABEL_228:
        v40 = *v24;
        v41 = (CFDictionaryRef *)this;
        v42 = a3;
LABEL_263:
        NWIOConnection::_setPropertyForSSLSettings(v41, v40, v42);
        return 1;
      }
      CFDictionaryRemoveValue(v23, theString);
      v46 = &kCFStreamSSLLevel;
LABEL_262:
      v40 = *v46;
      v41 = (CFDictionaryRef *)this;
      v42 = 0;
      goto LABEL_263;
    }
    if (ExactString <= 186928406)
    {
      if (ExactString <= 160648035)
      {
        if (ExactString == 143911500)
          goto LABEL_189;
        if (ExactString == 144976476)
        {
          if (a3)
          {
            *(_QWORD *)value = 0;
            v31 = CFGetTypeID(a3);
            if (v31 == CFNumberGetTypeID()
              && CFNumberGetValue((CFNumberRef)a3, kCFNumberDoubleType, value)
              && *(double *)value > 0.0)
            {
              CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), theString, a3);
              v32 = *(_QWORD *)value;
            }
            else
            {
              CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 46), theString);
              v32 = 0;
            }
            *((_QWORD *)this + 69) = v32;
          }
          else
          {
            CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 46), theString);
            *((_QWORD *)this + 69) = 0;
          }
          return 1;
        }
        v8 = 157494066;
        goto LABEL_171;
      }
      if (ExactString == 160648036 || ExactString == 161713010)
        goto LABEL_172;
      if (ExactString != 174287922)
        return result;
      goto LABEL_132;
    }
    if (ExactString <= 190147927)
    {
      if (ExactString == 186928407 || ExactString == 188075305)
        goto LABEL_172;
      v8 = 189107521;
      goto LABEL_171;
    }
    if (ExactString > 192228738)
    {
      if (ExactString == 192228739)
        goto LABEL_172;
      v8 = 193334680;
      goto LABEL_171;
    }
    if (ExactString == 190147928)
      goto LABEL_172;
    v9 = 191171950;
LABEL_150:
    if (ExactString != v9)
      return result;
    goto LABEL_189;
  }
  if (ExactString > 48538453)
  {
    if (ExactString > 67462343)
    {
      if (ExactString <= 75834718)
      {
        if (ExactString > 72598832)
        {
          if (ExactString == 72598833 || ExactString == 73606465)
            goto LABEL_172;
          v8 = 74720590;
        }
        else
        {
          if (ExactString == 67462344 || ExactString == 70575370)
            goto LABEL_172;
          v8 = 71599390;
        }
      }
      else if (ExactString <= 78857631)
      {
        if (ExactString == 75834719 || ExactString == 76932468)
          goto LABEL_172;
        v8 = 77907340;
      }
      else
      {
        if (ExactString > 83273190)
        {
          if (ExactString != 83273191)
          {
            v10 = 84248066;
LABEL_176:
            if (ExactString != v10)
              return result;
            goto LABEL_177;
          }
          goto LABEL_177;
        }
        if (ExactString == 78857632)
          goto LABEL_172;
        v8 = 80020910;
      }
      goto LABEL_171;
    }
    if (ExactString > 59057171)
    {
      if (ExactString <= 62186601)
      {
        if (ExactString == 59057172 || ExactString == 60261417)
          goto LABEL_172;
        v8 = 61367368;
      }
      else
      {
        if (ExactString > 64332945)
        {
          if (ExactString != 64332946)
          {
            if (ExactString != 66307256)
              return result;
            if (a3)
            {
              if (*((_QWORD *)this + 34))
              {
                *(_QWORD *)value = 3;
                v25 = CFGetTypeID(a3);
                if (v25 == CFNumberGetTypeID())
                {
                  if (CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt64Type, value))
                  {
                    v26 = xpc_uint64_create(*(uint64_t *)value);
                    if (v26)
                    {
                      nw_connection_add_client_event();
                      xpc_release(v26);
                    }
                  }
                }
              }
            }
            return 1;
          }
          goto LABEL_172;
        }
        if (ExactString == 62186602)
          goto LABEL_172;
        v8 = 63235198;
      }
      goto LABEL_171;
    }
    if (ExactString <= 51700621)
    {
      if (ExactString == 48538454 || ExactString == 49537897)
        goto LABEL_172;
      v8 = 50668409;
      goto LABEL_171;
    }
    if (ExactString == 51700622 || ExactString == 55895000)
      goto LABEL_172;
    if (ExactString != 58057724)
      return result;
    if (*((int *)this + 34) <= 1)
    {
LABEL_189:
      v19 = (__CFDictionary *)*((_QWORD *)this + 46);
      if (a3)
      {
LABEL_190:
        CFDictionarySetValue(v19, theString, a3);
        return 1;
      }
LABEL_254:
      CFDictionaryRemoveValue(v19, theString);
      return 1;
    }
    return 0;
  }
  if (ExactString <= 34890295)
  {
    if (ExactString > 19259596)
    {
      if (ExactString > 30736879)
      {
        if (ExactString != 30736880)
        {
          if (ExactString == 32842260)
          {
            v19 = (__CFDictionary *)*((_QWORD *)this + 46);
            if (a3)
            {
              CFDictionarySetValue(v19, theString, a3);
              if (CFNLog::onceToken != -1)
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
              v44 = CFNLog::logger;
              if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
              {
                v45 = *((_QWORD *)this + 36);
                *(_DWORD *)value = 134218242;
                *(_QWORD *)&value[4] = v45;
                *(_WORD *)&value[12] = 2112;
                *(_QWORD *)&value[14] = a3;
                _os_log_impl(&dword_183ECA000, v44, OS_LOG_TYPE_DEFAULT, "Connection %llu: working for activity %@", value, 0x16u);
              }
              return 1;
            }
            goto LABEL_254;
          }
          v8 = 33792553;
          goto LABEL_171;
        }
        goto LABEL_172;
      }
      if (ExactString == 19259597 || ExactString == 20275429)
        goto LABEL_172;
      v8 = 22372625;
      goto LABEL_171;
    }
    if (ExactString <= 14925946)
    {
      if (ExactString == 10797104 || ExactString == 12894297)
        goto LABEL_172;
      v8 = 13852781;
      goto LABEL_171;
    }
    if (ExactString == 14925947 || ExactString == 15990923)
      goto LABEL_172;
    v9 = 18251954;
    goto LABEL_150;
  }
  if (ExactString > 41272008)
  {
    if (ExactString <= 44409614)
    {
      if (ExactString == 41272009)
        goto LABEL_132;
      if (ExactString == 42377953)
        goto LABEL_172;
      v8 = 43295484;
    }
    else if (ExactString > 46400309)
    {
      if (ExactString == 46400310)
        goto LABEL_172;
      v8 = 47416135;
    }
    else
    {
      if (ExactString == 44409615)
        goto LABEL_172;
      v8 = 45343526;
    }
    goto LABEL_171;
  }
  if (ExactString > 38142589)
  {
    if (ExactString != 38142590)
    {
      if (ExactString != 39191191)
      {
        if (ExactString != 40239792)
          return result;
        v20 = (ConnectionEPTManager *)*((_QWORD *)this + 24);
        if (v20)
          ConnectionEPTManager::taskTargetChanged(v20);
        return 1;
      }
      if (!a3)
        return 0;
      if (!*((_QWORD *)this + 34))
        return 0;
      *(_QWORD *)value = 0;
      v37 = CFGetTypeID(a3);
      if (v37 != CFNumberGetTypeID())
        return 0;
      v38 = CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt64Type, value);
      result = 0;
      if (v38 && *(_QWORD *)value)
        goto LABEL_70;
      return result;
    }
    if (!a3)
      return 0;
    if (!*((_QWORD *)this + 34))
      return 0;
    *(_QWORD *)value = 0;
    v35 = CFGetTypeID(a3);
    if (v35 != CFNumberGetTypeID())
      return 0;
    v36 = CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt64Type, value);
    result = 0;
    if (!v36 || !*(_QWORD *)value)
      return result;
LABEL_213:
    nw_connection_decrement_estimated_bytes();
    return 1;
  }
  switch(ExactString)
  {
    case 34890296:
      goto LABEL_172;
    case 36061770:
      if (!a3)
        return 0;
      if (!*((_QWORD *)this + 34))
        return 0;
      *(_QWORD *)value = 0;
      v33 = CFGetTypeID(a3);
      if (v33 != CFNumberGetTypeID())
        return 0;
      v34 = CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt64Type, value);
      result = 0;
      if (!v34 || !*(_QWORD *)value)
        return result;
      goto LABEL_213;
    case 37110372:
      if (!a3)
        return 0;
      if (!*((_QWORD *)this + 34))
        return 0;
      *(_QWORD *)value = 0;
      v11 = CFGetTypeID(a3);
      if (v11 != CFNumberGetTypeID())
        return 0;
      v12 = CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt64Type, value);
      result = 0;
      if (v12)
      {
        if (*(_QWORD *)value)
        {
LABEL_70:
          nw_connection_increment_estimated_bytes();
          return 1;
        }
      }
      break;
  }
  return result;
}

void sub_183EEC5CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t HTTPEngine::setProperty(HTTPEngine *this, CFStringRef theString, const void *a3)
{
  int ExactString;
  CFTypeID v7;
  uint64_t result;
  CFTypeID v9;
  unsigned int v10;
  CFTypeID v11;
  CFTypeID v12;
  CFTypeID v13;
  CFTypeID v14;
  unsigned int v15;
  CFTypeID v16;
  CFTypeID v17;
  uint8_t v18[16];

  ExactString = _findExactString(theString, 0);
  if (ExactString > 120965282)
  {
    switch(ExactString)
    {
      case 120965283:
        *(_QWORD *)v18 = 0;
        if (a3)
        {
          v16 = CFGetTypeID(a3);
          if (v16 == CFNumberGetTypeID())
          {
            result = CFNumberGetValue((CFNumberRef)a3, kCFNumberDoubleType, v18);
            if (!(_DWORD)result)
              return result;
            *((_DWORD *)this + 8) |= 0x200000u;
            *((_QWORD *)this + 29) = *(_QWORD *)v18;
            return 1;
          }
        }
        return 0;
      case 407246367:
        if (!a3)
          return 1;
        v17 = CFGetTypeID(a3);
        if (v17 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)v18 = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v18, 2u);
        }
        if ((const void *)*MEMORY[0x1E0C9AE50] != a3)
          return 1;
        v10 = *((_DWORD *)this + 8) | 0x10000;
        break;
      case 400823713:
        if (!a3)
          goto LABEL_17;
        v9 = CFGetTypeID(a3);
        if (v9 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)v18 = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v18, 2u);
        }
        if ((const void *)*MEMORY[0x1E0C9AE50] == a3)
          v10 = *((_DWORD *)this + 8) | 0x10;
        else
LABEL_17:
          v10 = *((_DWORD *)this + 8) & 0xFFFFFFEF;
        break;
      default:
        goto LABEL_46;
    }
LABEL_52:
    *((_DWORD *)this + 8) = v10;
    return 1;
  }
  switch(ExactString)
  {
    case 68551902:
      if (!a3)
        return 0;
      v11 = CFGetTypeID(a3);
      if (v11 != CFBooleanGetTypeID())
        return 0;
      v12 = CFGetTypeID(a3);
      if (v12 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v18 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v18, 2u);
      }
      if ((const void *)*MEMORY[0x1E0C9AE50] == a3)
      {
        v10 = *((_DWORD *)this + 8) | 0x400000;
      }
      else
      {
        v13 = CFGetTypeID(a3);
        if (v13 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)v18 = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v18, 2u);
        }
        if ((const void *)*MEMORY[0x1E0C9AE40] != a3)
          return 1;
        v10 = *((_DWORD *)this + 8) & 0xFFBFFFFF;
      }
      goto LABEL_52;
    case 104064896:
      if (!a3)
        goto LABEL_34;
      v14 = CFGetTypeID(a3);
      if (v14 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v18 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v18, 2u);
      }
      if ((const void *)*MEMORY[0x1E0C9AE50] == a3)
        v15 = *((_DWORD *)this + 8) | 0x80000;
      else
LABEL_34:
        v15 = *((_DWORD *)this + 8) & 0xFFF7FFFF;
      *((_DWORD *)this + 8) = v15;
      HTTPEngine::_readUpdateLargeDownloadSettings((uint64_t)this);
      return 1;
    case 119892109:
      *(_DWORD *)v18 = 0;
      if (a3)
      {
        v7 = CFGetTypeID(a3);
        if (v7 == CFNumberGetTypeID())
        {
          result = CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, v18);
          if (!(_DWORD)result)
            return result;
          *((_DWORD *)this + 8) |= 0x200000u;
          *((_DWORD *)this + 56) = *(_DWORD *)v18;
          return 1;
        }
      }
      return 0;
  }
LABEL_46:
  result = *((_QWORD *)this + 7);
  if (result)
    return (*(uint64_t (**)(uint64_t, CFStringRef, const void *))(*(_QWORD *)result + 200))(result, theString, a3);
  return result;
}

HTTPEngine *HTTPConnection::setProperty(HTTPConnection *this, CFStringRef theString, const void *a3)
{
  HTTPEngine *result;

  _findExactString(theString, 0);
  result = (HTTPEngine *)*((_QWORD *)this + 8);
  if (result)
    return (HTTPEngine *)HTTPEngine::setProperty(result, theString, a3);
  return result;
}

void Tube::_onqueue_connect(Tube *this)
{
  _QWORD v1[5];

  if (*((_DWORD *)this + 55) != 10)
    *((_DWORD *)this + 55) = 2;
  v1[0] = MEMORY[0x1E0C809B0];
  v1[1] = 3221225472;
  v1[2] = ___ZN4Tube16_onqueue_connectEv_block_invoke;
  v1[3] = &__block_descriptor_40_e5_v8__0l;
  v1[4] = this;
  ___ZN4Tube16_onqueue_connectEv_block_invoke((uint64_t)v1);
}

BOOL HTTPConnectionCacheKey::isFirstPartyResource(HTTPConnectionCacheKey *this)
{
  CFStringRef RegistrableDomain;
  CFStringRef v3;
  CFStringRef v4;
  BOOL v5;
  _BOOL8 v6;

  if (!*((_QWORD *)this + 5))
    return 1;
  RegistrableDomain = _cfnCreateRegistrableDomain(*((const __CFString **)this + 4));
  v3 = _cfnCreateRegistrableDomain(*((const __CFString **)this + 5));
  v4 = v3;
  if (RegistrableDomain)
    v5 = v3 == 0;
  else
    v5 = 1;
  if (v5)
  {
    v6 = CFEqual(*((CFTypeRef *)this + 4), *((CFTypeRef *)this + 5)) != 0;
    if (!v4)
    {
      if (!RegistrableDomain)
        return v6;
      goto LABEL_12;
    }
  }
  else
  {
    v6 = CFEqual(RegistrableDomain, v3) != 0;
  }
  CFRelease(v4);
  if (RegistrableDomain)
LABEL_12:
    CFRelease(RegistrableDomain);
  return v6;
}

void sub_183EECB80(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;

  CFRelease(v2);
  if (v1)
    CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t XCookieStorage::getRequestHeaderFieldsForTask(uint64_t a1, void *a2, uint64_t a3)
{
  const __CFString *v6;
  const __CFString *v7;
  _BOOL8 v8;
  _QWORD v10[5];

  v6 = CFURLCopyScheme((CFURLRef)objc_msgSend(a2, "currentRequest_URL"));
  if (v6)
  {
    v7 = v6;
    v8 = 1;
    if (CFStringCompare(v6, (CFStringRef)&unk_1EDD00AE0, 1uLL))
      v8 = CFStringCompare(v7, CFSTR("wss"), 1uLL) == kCFCompareEqualTo;
    CFRelease(v7);
  }
  else
  {
    v8 = 0;
  }
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = ___ZNK14XCookieStorage29getRequestHeaderFieldsForTaskEP16NSURLSessionTaskU13block_pointerFvPK14__CFDictionaryE_block_invoke;
  v10[3] = &unk_1E14FC778;
  v10[4] = a3;
  return (*(uint64_t (**)(uint64_t, void *, _BOOL8, _QWORD *))(*(_QWORD *)a1 + 56))(a1, a2, v8, v10);
}

uint64_t TubeManager::newTubeReady(TubeManager *this, Tube **a2, CFStreamError a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  const __CFArray *v8;
  CFIndex FirstIndexOfValue;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  const void *v14;
  const __CFArray *v15;
  CFIndex v16;
  void *v17;
  int v18;
  uint64_t v19;
  CFMutableArrayRef (*v20)(uint64_t, uint64_t);
  const void *v21;
  const __CFArray *v22;
  const __CFArray *v23;
  const __CFArray *v24;
  uint64_t v25;
  int v26;
  int v27;
  char v28;
  unsigned int v29;
  uint64_t v30;
  int v31;
  const void *Value;
  const void *v33;
  CFIndex v34;
  CFIndex v35;
  BOOL v36;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  BOOL v43;
  NSObject *v45;
  CFIndex j;
  uint64_t *v47;
  uint64_t v48;
  uint64_t v49;
  Tube *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v55;
  char v56;
  Tube *v57;
  void *v58;
  CFAllocatorRef v59;
  CFMutableArrayRef v60;
  Tube *v61;
  __CFArray *v62;
  Tube *v63;
  Tube *v64;
  const void *v65;
  Tube *v66;
  std::string *v67;
  const void *v68;
  uint64_t v69;
  const void *v70;
  uint64_t v71;
  const char *v72;
  int v73;
  const char *v74;
  const char *v75;
  CFIndex Count;
  CFIndex v77;
  int v78;
  int v79;
  uint64_t v80;
  const void *v81;
  __CFArray *v82;
  CFMutableArrayRef v83;
  __CFArray *theArray;
  CFMutableArrayRef theArraya;
  CFMutableArrayRef theArrayb;
  uint64_t v87;
  CFIndex domain;
  TubeManager *v89;
  uint64_t v90;
  uint64_t *v91;
  uint64_t v92;
  void *v93;
  void (*v94)(uint64_t);
  void *v95;
  CFTypeRef cf;
  uint64_t v97;
  int v98;
  _QWORD v99[4];
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  void *v103;
  Tube **v104;
  uint64_t v105;
  uint64_t v106;
  void (*v107)(uint64_t, BaseAwaitingTube *);
  void *v108;
  TubeManager *v109;
  uint64_t context;
  uint64_t v111;
  void *v112;
  void *v113;
  TubeManager *v114;
  uint64_t *v115;
  Tube **v116;
  _QWORD v117[2];
  uint64_t (*v118)(uint64_t);
  void *v119;
  Tube **v120;
  _BYTE buf[24];
  CFMutableArrayRef (*v122)(uint64_t, uint64_t);
  void (*v123)(uint64_t);
  _QWORD *v124;
  CFMutableArrayRef Mutable;
  const void *v126;
  Tube **v127;
  void *v128;
  uint64_t v129;
  CFRange v130;
  CFRange v131;
  CFRange v132;
  CFRange v133;
  CFRange v134;
  CFRange v135;
  CFRange v136;

  domain = a3.domain;
  v129 = *MEMORY[0x1E0C80C00];
  if (!a2)
    __assert_rtn("newTubeReady", "TubeManager.cpp", 360, "FALSE");
  v3 = *(_QWORD *)&a3.error;
  v6 = Tube::copyKey(a2[13]);
  if (!v6)
    __assert_rtn("newTubeReady", "TubeManager.cpp", 374, "FALSE");
  (*(void (**)(uint64_t))(*(_QWORD *)v6 + 48))(v6);
  (*((void (**)(Tube **))*a2 + 5))(a2);
  v7 = MEMORY[0x1E0C809B0];
  v117[0] = MEMORY[0x1E0C809B0];
  v117[1] = 3221225472;
  v118 = ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke;
  v119 = &__block_descriptor_40_e5_v8__0l;
  v120 = a2;
  v8 = (const __CFArray *)*((_QWORD *)this + 18);
  v130.length = CFArrayGetCount(v8);
  v130.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v8, v130, a2);
  if (FirstIndexOfValue != -1)
  {
    CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)this + 18), FirstIndexOfValue);
    v10 = (*((uint64_t (**)(Tube **))*a2 + 12))(a2);
    if ((_DWORD)v3)
      v11 = 0;
    else
      v11 = v10;
    if (v11 == 1)
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2020000000;
      v12 = *((_DWORD *)a2 + 55);
      LOBYTE(v122) = v12 == 10;
      _Block_object_dispose(buf, 8);
      if (v12 != 10)
      {
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x3812000000;
        v122 = __Block_byref_object_copy__5474;
        v123 = __Block_byref_object_dispose__5475;
        v124 = &unk_18422E08D;
        Mutable = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
        v90 = 0;
        v91 = &v90;
        v92 = 0x3812000000;
        v93 = __Block_byref_object_copy__5474;
        v94 = __Block_byref_object_dispose__5475;
        v95 = &unk_18422E08D;
        cf = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
        context = v7;
        v111 = 3221225472;
        v112 = ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_33;
        v113 = &unk_1E14F91F0;
        v115 = &v90;
        v116 = a2;
        v114 = (TubeManager *)buf;
        v22 = (const __CFArray *)*((_QWORD *)this + 17);
        v132.length = CFArrayGetCount(v22);
        v132.location = 0;
        CFArrayApplyFunction(v22, v132, (CFArrayApplierFunction)RetainableTypedArray<BaseAwaitingTube *>::_invoke, &context);
        CFArrayRemoveAllValues(*((CFMutableArrayRef *)this + 17));
        v105 = v7;
        v106 = 3221225472;
        v107 = ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_2;
        v108 = &__block_descriptor_40_e48_v16__0__BaseAwaitingTube________CFAllocator_iB_8l;
        v109 = this;
        v23 = (const __CFArray *)v91[6];
        v133.length = CFArrayGetCount(v23);
        v133.location = 0;
        CFArrayApplyFunction(v23, v133, (CFArrayApplierFunction)RetainableTypedArray<BaseAwaitingTube *>::_invoke, &v105);
        v100 = v7;
        v101 = 3221225472;
        v102 = (uint64_t)___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_3;
        v103 = &__block_descriptor_40_e48_v16__0__BaseAwaitingTube________CFAllocator_iB_8l;
        v104 = a2;
        v24 = *(const __CFArray **)(*(_QWORD *)&buf[8] + 48);
        v134.length = CFArrayGetCount(v24);
        v134.location = 0;
        CFArrayApplyFunction(v24, v134, (CFArrayApplierFunction)RetainableTypedArray<BaseAwaitingTube *>::_invoke, &v100);
        _Block_object_dispose(&v90, 8);
        CFRelease(cf);
        _Block_object_dispose(buf, 8);
        CFRelease(Mutable);
        return v118((uint64_t)v117);
      }
    }
    v13 = Tube::copyWaiter(a2[14]);
    v14 = (const void *)v13;
    if (!v13)
      __assert_rtn("_onqueue_newTubeReady", "TubeManager.cpp", 679, "firstWaiter != NULL");
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
    v15 = (const __CFArray *)*((_QWORD *)this + 17);
    v131.length = CFArrayGetCount(v15);
    v131.location = 0;
    v16 = CFArrayGetFirstIndexOfValue(v15, v131, v14);
    if (v16 == -1)
      __assert_rtn("_onqueue_newTubeReady", "TubeManager.cpp", 682, "firstWaiterIdx != -1");
    CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)this + 17), v16);
    v77 = v16;
    Count = CFArrayGetCount(*((CFArrayRef *)this + 17));
    v17 = (void *)Tube::copyKey(a2[13]);
    v100 = 0;
    v101 = (uint64_t)&v100;
    v102 = 0x2020000000;
    v103 = 0;
    v99[0] = 0;
    v99[1] = v99;
    v99[2] = 0x2020000000;
    v99[3] = 0;
    v90 = 0;
    v91 = &v90;
    v92 = 0x4812000000;
    v93 = __Block_byref_object_copy__37;
    v94 = (void (*)(uint64_t))__Block_byref_object_dispose__38;
    v95 = &unk_18422E08D;
    cf = (CFTypeRef)0x3F000000FFFFFFFFLL;
    v97 = 0;
    v98 = 0;
    v87 = (uint64_t)v14;
    v89 = this;
    if ((_DWORD)v3
      || (*(_QWORD *)buf = 0,
          *(_QWORD *)&buf[8] = buf,
          *(_QWORD *)&buf[16] = 0x2020000000,
          v18 = *((_DWORD *)a2 + 55),
          LOBYTE(v122) = v18 == 10,
          _Block_object_dispose(buf, 8),
          v18 == 10))
    {
      v19 = (*(uint64_t (**)(const void *))(*(_QWORD *)v14 + 80))(v14);
      *(_QWORD *)(v101 + 24) = v19;
      if ((_DWORD)v3)
      {
        if (domain == *MEMORY[0x1E0C9B298])
        {
          *(_QWORD *)buf = 0;
          *(_QWORD *)&buf[8] = buf;
          *(_QWORD *)&buf[16] = 0x2020000000;
          v20 = (CFMutableArrayRef (*)(uint64_t, uint64_t))a2[29];
          v122 = v20;
          if (v20)
          {
            CFRetain(v20);
            v21 = *(const void **)(*(_QWORD *)&buf[8] + 24);
          }
          else
          {
            v21 = 0;
          }
          _Block_object_dispose(buf, 8);
          v19 = *(_QWORD *)(v101 + 24);
        }
        else
        {
          v21 = 0;
        }
        if (v19)
          v30 = v19 - 176;
        else
          v30 = 0;
        (*(void (**)(uint64_t, CFIndex, uint64_t, const void *))(*(_QWORD *)v30 + 280))(v30, domain, v3, v21);
        if (v21)
          CFRelease(v21);
        v26 = v3;
      }
      else
      {
        if (v19)
          v25 = v19 - 176;
        else
          v25 = 0;
        domain = 1;
        (*(void (**)(uint64_t, uint64_t, unint64_t, _QWORD))(*(_QWORD *)v25 + 280))(v25, 1, v3 & 0xFFFFFFFF00000000 | 0x59, 0);
        v26 = 89;
      }
      *(_QWORD *)(v101 + 24) = 0;
      (*(void (**)(const void *, _QWORD))(*(_QWORD *)v14 + 56))(v14, 0);
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2020000000;
      LOBYTE(v122) = *((_BYTE *)a2 + 216);
      v31 = v122;
      _Block_object_dispose(buf, 8);
      if (!v31)
      {
        v33 = 0;
        goto LABEL_40;
      }
      Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 14), v17);
      v33 = Value;
      if (Value)
      {
        (*(void (**)(const void *, Tube **, _QWORD))(*(_QWORD *)Value + 88))(Value, a2, 0);
LABEL_40:
        v79 = 1;
        v29 = 3;
LABEL_41:
        theArray = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
        v82 = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
        v78 = v26;
        v81 = v33;
        v34 = CFArrayGetCount(*((CFArrayRef *)this + 17));
        v35 = CFArrayGetCount(*((CFArrayRef *)this + 17));
        if (v35 >= 1)
        {
          v36 = 0;
          for (i = 0; i != v35; v36 = i >= v35)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)v89 + 17), i);
            v39 = ValueAtIndex;
            if (!ValueAtIndex)
              break;
            v40 = (*(uint64_t (**)(const void *))(*(_QWORD *)ValueAtIndex + 72))(ValueAtIndex);
            v41 = (*(uint64_t (**)(const void *))(*(_QWORD *)v39 + 80))(v39);
            v42 = (*(uint64_t (**)(const void *))(*(_QWORD *)v39 + 64))(v39);
            v43 = !v40 || v41 == 0;
            if (v43 || v42 == 0)
              break;
            ++i;
          }
          v7 = MEMORY[0x1E0C809B0];
          if (!v36)
          {
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v45 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134218496;
              *(_QWORD *)&buf[4] = v87;
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v77;
              *(_WORD *)&buf[22] = 2048;
              v122 = (CFMutableArrayRef (*)(uint64_t, uint64_t))Count;
              _os_log_error_impl(&dword_183ECA000, v45, OS_LOG_TYPE_ERROR, "[rdar53306264-CW] FW(%p) FW.I(%ld) RWC(%ld)", buf, 0x20u);
            }
            TubeManager::_onqueue_rdar53306264_logWaiters((CFArrayRef *)v89);
          }
        }
        if (v34 >= 1)
        {
          for (j = 0; j != v34; ++j)
          {
            v47 = (uint64_t *)CFArrayGetValueAtIndex(*((CFArrayRef *)v89 + 17), j);
            rdar46818402((uint64_t)a2, domain, v78, (uint64_t)v17, v29, v87, v34, j, (uint64_t)v47);
            v48 = (*(uint64_t (**)(uint64_t *))(*v47 + 72))(v47);
            if ((*(unsigned int (**)(uint64_t, void *))(*(_QWORD *)v48 + 24))(v48, v17)
              && (Tube **)(*(uint64_t (**)(uint64_t *))(*v47 + 64))(v47) == a2)
            {
              v49 = (*(uint64_t (**)(uint64_t *))(*v47 + 80))(v47);
              *(_QWORD *)(v101 + 24) = v49;
              v50 = a2[17];
              if (v50)
              {
                if (v49)
                  v51 = v49 - 176;
                else
                  v51 = 0;
                (*(void (**)(Tube *, _QWORD, uint64_t, _QWORD))(*(_QWORD *)v50 + 280))(v50, *(_QWORD *)(v51 + 80), 3, 0);
              }
              if (((*(uint64_t (**)(uint64_t *))(*v47 + 112))(v47) & 1) != 0)
              {
                if (v79)
                {
                  (*(void (**)(uint64_t *, _QWORD))(*v47 + 56))(v47, 0);
                  (*(void (**)(uint64_t *))(*v47 + 40))(v47);
                  (*(void (**)(TubeManager *))(*(_QWORD *)v89 + 40))(v89);
                  v52 = *((_QWORD *)v89 + 4);
                  context = v7;
                  v111 = 3221225472;
                  v112 = ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_49;
                  v113 = &__block_descriptor_48_e5_v8__0l;
                  v114 = v89;
                  v115 = v47;
                  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v52 + 96))(v52, &context);
                }
                else
                {
                  if (!v81)
                    __assert_rtn("_onqueue_newTubeReady", "TubeManager.cpp", 897, "connCache != NULL");
                  CFArrayAppendValue(v82, v47);
                }
              }
              else
              {
                (*(void (**)(uint64_t *, _QWORD))(*v47 + 56))(v47, 0);
              }
            }
            else
            {
              CFArrayAppendValue(theArray, v47);
            }
          }
        }
        CFArrayRemoveAllValues(*((CFMutableArrayRef *)v89 + 17));
        v53 = v87;
        v105 = v7;
        v106 = 3221225472;
        v107 = ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_2_51;
        v108 = &__block_descriptor_40_e48_v16__0__BaseAwaitingTube________CFAllocator_iB_8l;
        v109 = v89;
        v135.length = CFArrayGetCount(theArray);
        v135.location = 0;
        CFArrayApplyFunction(theArray, v135, (CFArrayApplierFunction)RetainableTypedArray<BaseAwaitingTube *>::_invoke, &v105);
        *(_QWORD *)buf = v7;
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_3_52;
        v122 = (CFMutableArrayRef (*)(uint64_t, uint64_t))&unk_1E14F9258;
        v123 = (void (*)(uint64_t))&v100;
        v124 = v99;
        Mutable = (CFMutableArrayRef)&v90;
        v126 = v81;
        v127 = a2;
        v128 = v17;
        v136.length = CFArrayGetCount(v82);
        v136.location = 0;
        CFArrayApplyFunction(v82, v136, (CFArrayApplierFunction)RetainableTypedArray<BaseAwaitingTube *>::_invoke, buf);
        (*(void (**)(void *))(*(_QWORD *)v17 + 48))(v17);
        (*(void (**)(uint64_t))(*(_QWORD *)v53 + 48))(v53);
        (*(void (**)(uint64_t))(*(_QWORD *)v53 + 48))(v53);
        CFRelease(v82);
        CFRelease(theArray);
        _Block_object_dispose(&v90, 8);
        _Block_object_dispose(v99, 8);
        _Block_object_dispose(&v100, 8);
        return v118((uint64_t)v117);
      }
      v72 = "connCache";
      v73 = 766;
      goto LABEL_118;
    }
    v27 = *((_DWORD *)a2 + 46);
    switch(v27)
    {
      case 1:
        v28 = 0;
        v29 = 0;
        v26 = 1;
        break;
      case 3:
        v26 = 0;
        v28 = 0;
        v29 = 2;
        break;
      case 2:
        v26 = 0;
        v28 = 1;
        v29 = 1;
        break;
      default:
        v72 = "FALSE";
        v73 = 126;
        v74 = "TubeManager.h";
        v75 = "connectionCacheTypeForTubeType";
LABEL_119:
        __assert_rtn(v75, v74, v73, v72);
    }
    TubeManager::_onqueue_pairKeyWithConnectionCache((uint64_t)this, v17, v29);
    v33 = (const void *)*((_QWORD *)this + v29 + 10);
    if (!v33)
    {
      v72 = "connCache";
      v73 = 783;
LABEL_118:
      v74 = "TubeManager.cpp";
      v75 = "_onqueue_newTubeReady";
      goto LABEL_119;
    }
    if (TubeManager::_onqueue_newTubeReady(Tube *,CFStreamError)::onceToken != -1)
      dispatch_once(&TubeManager::_onqueue_newTubeReady(Tube *,CFStreamError)::onceToken, &__block_literal_global_42);
    v55 = (*(uint64_t (**)(void *))(*(_QWORD *)v17 + 88))(v17);
    v56 = v28 ^ 1;
    if (v55 != 1)
      v56 = 1;
    if ((v56 & 1) != 0
      || (TubeManager::_onqueue_newTubeReady(Tube *,CFStreamError)::disableH2ConnectionCoalescing & 1) != 0
      || (v57 = a2[17]) != 0 && ((*(uint64_t (**)(Tube *))(*(_QWORD *)v57 + 272))(v57) & 1) != 0)
    {
LABEL_108:
      (*(void (**)(const void *, Tube **, uint64_t))(*(_QWORD *)v33 + 88))(v33, a2, 1);
      if (v26)
      {
        if ((*(uint64_t (**)(void *))(*(_QWORD *)v17 + 72))(v17))
        {
          v71 = (*(uint64_t (**)(const void *))(*(_QWORD *)v14 + 80))(v14);
          TubeManager::addNewFastPathCache((uint64_t)this, (uint64_t)v17, v71);
        }
        v29 = 0;
        v79 = 0;
        v26 = 0;
      }
      else
      {
        v79 = 0;
      }
      goto LABEL_41;
    }
    v58 = (void *)*((_QWORD *)this + 20);
    v59 = HTTPConnectionCacheKey::hostlessKey((CFAllocatorRef *)v17);
    v60 = (CFMutableArrayRef)(*(uint64_t (**)(void *))(*(_QWORD *)v17 + 72))(v17);
    v61 = a2[17];
    if (!v61)
    {
      v65 = 0;
      v62 = 0;
      v68 = 0;
      v67 = 0;
LABEL_100:
      v69 = (uint64_t)v59;
      theArrayb = v62;
      v70 = v68;
      __NSURLSession_CoalescingAddConnectionEntry(v58, v69, v60, v62, v68, v65, v67);
      if (v67)
        CFRelease(v67);
      if (v65)
        CFRelease(v65);
      v14 = (const void *)v87;
      if (v70)
        CFRelease(v70);
      this = v89;
      if (theArrayb)
        CFRelease(theArrayb);
      goto LABEL_108;
    }
    v83 = v60;
    v62 = (__CFArray *)(*(uint64_t (**)(Tube *))(*(_QWORD *)v61 + 296))(v61);
    v63 = a2[17];
    if (!v63)
    {
      v65 = 0;
      v68 = 0;
      v67 = 0;
LABEL_99:
      v60 = v83;
      goto LABEL_100;
    }
    theArraya = v62;
    v80 = (*(uint64_t (**)(Tube *))(*(_QWORD *)v63 + 304))(v63);
    v64 = a2[17];
    if (v64)
    {
      v65 = (const void *)(*(uint64_t (**)(Tube *))(*(_QWORD *)v64 + 312))(v64);
      v66 = a2[17];
      if (v66)
      {
        v67 = (std::string *)(*(uint64_t (**)(Tube *))(*(_QWORD *)v66 + 320))(v66);
LABEL_98:
        v62 = theArraya;
        v68 = (const void *)v80;
        goto LABEL_99;
      }
    }
    else
    {
      v65 = 0;
    }
    v67 = 0;
    goto LABEL_98;
  }
  return v118((uint64_t)v117);
}

void sub_183EED9FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, CFTypeRef cf, uint64_t a16, CFTypeRef a17, CFTypeRef a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,CFTypeRef a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  const void *v35;
  uint64_t v36;

  if (v35)
    CFRelease(v35);
  if (cf)
    CFRelease(cf);
  if (a18)
    CFRelease(a18);
  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  (*(void (**)(uint64_t))(v36 - 232))(v36 - 248);
  _Unwind_Resume(a1);
}

unsigned int *CFAllocatedReferenceCountedObject::release(unsigned int *this)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = this + 4;
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  if (this)
  {
    if (v2 == 1)
      return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)this + 8))(this);
  }
  return this;
}

uint64_t Tube::copyKey(Tube *this)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  Tube *v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v6 = this;
  if (this)
  {
    (*(void (**)(Tube *))(*(_QWORD *)this + 40))(this);
    v1 = v4[3];
  }
  else
  {
    v1 = 0;
  }
  _Block_object_dispose(&v3, 8);
  return v1;
}

void sub_183EEDBCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t XTubeManager::withTubeManager(uint64_t a1, const void *a2, uint64_t a3)
{
  const void *v5;
  pthread_mutex_t *v6;
  const void *Value;
  const void *v8;
  _OWORD *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  void *v14;
  _QWORD *v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  __int128 v22;

  if (a2)
  {
    v5 = a2;
    (*(void (**)(const void *))(*(_QWORD *)a2 + 40))(a2);
  }
  else
  {
    v5 = (const void *)CoreSchedulingSet::copyLoaderQueueSet((CoreSchedulingSet *)a1);
  }
  v6 = (pthread_mutex_t *)(a1 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v5);
  if (Value)
  {
    v8 = Value;
    (*(void (**)(const void *))(*(_QWORD *)Value + 40))(Value);
  }
  else
  {
    v10 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 8), 112, 0);
    *v10 = 0u;
    v10[2] = 0u;
    v10[3] = 0u;
    v10[4] = 0u;
    v10[5] = 0u;
    v10[6] = 0u;
    v10[1] = 0u;
    v11 = *(_QWORD *)(a1 + 8);
    v21 = *(_QWORD *)(a1 + 136);
    v19 = *(_OWORD *)(a1 + 104);
    v20 = *(_OWORD *)(a1 + 120);
    *(_QWORD *)v10 = off_1E14EF578;
    *((_QWORD *)v10 + 1) = v11;
    *((_DWORD *)v10 + 4) = 1;
    if (((unint64_t)(v10 + 1) & 3) != 0)
      __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
    v8 = v10;
    *(_QWORD *)v10 = off_1E14E7760;
    *(_OWORD *)((char *)v10 + 56) = xmmword_1841E37E0;
    v12 = (char *)v10 + 56;
    *(_OWORD *)((char *)v10 + 72) = xmmword_1841E37F0;
    *((_QWORD *)v10 + 12) = 0;
    v13 = (uint64_t)(v10 + 6);
    *((_QWORD *)v10 + 11) = 0x7800000078;
    *((_QWORD *)v10 + 13) = 0;
    *((_QWORD *)v10 + 3) = &unk_1E14E77A8;
    *((_QWORD *)v10 + 4) = 0;
    *((_QWORD *)v10 + 5) = 0;
    *((_QWORD *)v10 + 6) = v5;
    if (v5)
      (*(void (**)(const void *))(*(_QWORD *)v5 + 40))(v5);
    *(_OWORD *)v12 = v19;
    *((_OWORD *)v12 + 1) = v20;
    *((_QWORD *)v12 + 4) = v21;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), v5, v8);
    v14 = *(void **)(a1 + 144);
    nw_retain(v14);
    *(_QWORD *)&v22 = v14;
    v15 = (_QWORD *)operator new();
    *v15 = &off_1E14F1B70;
    v15[1] = 0;
    v15[2] = 0;
    v15[3] = v14;
    *((_QWORD *)&v22 + 1) = v15;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v13, &v22);
    v16 = (std::__shared_weak_count *)*((_QWORD *)&v22 + 1);
    if (*((_QWORD *)&v22 + 1))
    {
      v17 = (unint64_t *)(*((_QWORD *)&v22 + 1) + 8);
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
  pthread_mutex_unlock(v6);
  (*(void (**)(uint64_t, const void *))(a3 + 16))(a3, v8);
  (*(void (**)(const void *))(*(_QWORD *)v8 + 48))(v8);
  return (*(uint64_t (**)(const void *))(*(_QWORD *)v5 + 48))(v5);
}

void sub_183EEDE2C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

const __CFAllocator *CFAllocatedReferenceCountedObject::_retainable_retain(CFAllocatedReferenceCountedObject *this, const __CFAllocator *a2, const void *a3)
{
  (*(void (**)(const __CFAllocator *))(*(_QWORD *)a2 + 40))(a2);
  return a2;
}

void QCoreSchedulingSet::performAsync(_QWORD *a1, uint64_t a2)
{
  NSObject *v4;
  _QWORD v5[6];

  (*(void (**)(_QWORD *))(*a1 + 40))(a1);
  v4 = a1[7];
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZNK18QCoreSchedulingSet12performAsyncEU13block_pointerFvvE_block_invoke;
  v5[3] = &unk_1E14FDA90;
  v5[4] = a2;
  v5[5] = a1;
  dispatch_async(v4, v5);
}

uint64_t CFAllocatedReferenceCountedObject::retain(uint64_t this)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(this + 16);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 + 1, v1));
  return this;
}

uint64_t CFAllocatedReferenceCountedObject::_retainable_equal(CFAllocatedReferenceCountedObject *this, const void *a2, const void *a3)
{
  return (*(uint64_t (**)(CFAllocatedReferenceCountedObject *, const void *, const void *))(*(_QWORD *)this + 24))(this, a2, a3);
}

uint64_t HTTPConnectionCacheKey::equals(HTTPConnectionCacheKey *this, const CFAllocatedReferenceCountedObject *a2)
{
  uint64_t result;
  const void *v5;
  const void *v6;

  if (*((_DWORD *)this + 15) != *((_DWORD *)a2 + 15)
    || *((_DWORD *)this + 14) != *((_DWORD *)a2 + 14)
    || CFStringCompare(*((CFStringRef *)this + 4), *((CFStringRef *)a2 + 4), 1uLL))
  {
    return 0;
  }
  v5 = (const void *)*((_QWORD *)this + 8);
  v6 = (const void *)*((_QWORD *)a2 + 8);
  if (!v5)
  {
    if (!v6)
      return *((_QWORD *)this + 9) == *((_QWORD *)a2 + 9);
    return 0;
  }
  if (!v6)
    return 0;
  result = CFEqual(v5, v6);
  if ((_DWORD)result)
    return *((_QWORD *)this + 9) == *((_QWORD *)a2 + 9);
  return result;
}

uint64_t HTTPConnectionCacheEntry::EnqueuedRequest::getKey(HTTPConnectionCacheEntry::EnqueuedRequest *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 3);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 32))(result);
  return result;
}

uint64_t HTTPConnectionCacheEntry::EnqueuedRequest::getTube(HTTPConnectionCacheEntry::EnqueuedRequest *this)
{
  return *((_QWORD *)this + 9);
}

uint64_t ___ZN12XTubeManager25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptionsPK17CoreSchedulingSet_block_invoke(uint64_t a1, GlueTubeManager *a2)
{
  uint64_t v3;
  id *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  _QWORD *SManager;
  uint64_t v9;
  CFArrayRef *TManager;
  uint64_t v12;
  unsigned int v13;
  __int128 v14;
  uint64_t (*v15)(uint64_t);
  void *v16;
  _QWORD *v17;
  id *v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;

  v4 = *(id **)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  v5 = *(_DWORD *)(a1 + 48);
  v6 = *(_DWORD *)(a1 + 52);
  v12 = *(_QWORD *)(a1 + 56);
  v7 = *(_DWORD *)(a1 + 68);
  v13 = *(_DWORD *)(a1 + 64);
  (*((void (**)(id *))*v4 + 4))(v4);
  if (GlueTubeManager::_getIOPathFromDefaults(void)::onceToken != -1)
    dispatch_once(&GlueTubeManager::_getIOPathFromDefaults(void)::onceToken, &__block_literal_global_931);
  if (GlueTubeManager::_getIOPathFromDefaults(void)::ioPath == 1)
  {
    SManager = GlueTubeManager::_findOrCreateSManager(a2);
    (*((void (**)(id *))*v4 + 2))(v4);
    if (v3)
      CFRetain((CFTypeRef)(v3 - 16));
    (*(void (**)(_QWORD *))(*SManager + 40))(SManager);
    v9 = SManager[4];
    *(_QWORD *)&v14 = MEMORY[0x1E0C809B0];
    *((_QWORD *)&v14 + 1) = 3221225472;
    v15 = ___ZN12STubeManager25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke;
    v16 = &__block_descriptor_80_e5_v8__0l;
    v17 = SManager;
    v18 = v4;
    v19 = v3;
    v20 = v5;
    v21 = v6;
    v22 = v12;
    v23 = v13;
    v24 = v7;
    return (*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)v9 + 96))(v9, &v14);
  }
  else
  {
    TManager = (CFArrayRef *)GlueTubeManager::_findOrCreateTManager((uint64_t)a2, v4);
    *((_QWORD *)&v14 + 1) = v12;
    *(_QWORD *)&v14 = __PAIR64__(v6, v5);
    v15 = (uint64_t (*)(uint64_t))__PAIR64__(v7, v13);
    return TubeManager::_onqueue_enqueueRequestForProtocol(TManager, (uint64_t)v4, v3, &v14, 0);
  }
}

uint64_t GlueTubeManager::_findOrCreateTManager(uint64_t a1, id *Property)
{
  char *v5;
  const __CFAllocator *v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  CFTypeRef v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;

  if (!*(_QWORD *)(a1 + 32))
  {
    v5 = (char *)CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 8), 184, 0);
    *(_OWORD *)v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    *((_OWORD *)v5 + 2) = 0u;
    *((_OWORD *)v5 + 3) = 0u;
    *((_OWORD *)v5 + 4) = 0u;
    *((_OWORD *)v5 + 5) = 0u;
    *((_OWORD *)v5 + 6) = 0u;
    *((_OWORD *)v5 + 7) = 0u;
    *((_OWORD *)v5 + 8) = 0u;
    *((_OWORD *)v5 + 9) = 0u;
    *((_OWORD *)v5 + 10) = 0u;
    *((_QWORD *)v5 + 22) = 0;
    v6 = *(const __CFAllocator **)(a1 + 8);
    v7 = *(_QWORD *)(a1 + 48);
    v21 = *(_QWORD *)(a1 + 88);
    v19 = *(_OWORD *)(a1 + 56);
    v20 = *(_OWORD *)(a1 + 72);
    if (Property)
    {
      v8 = (void *)objc_msgSend(*(Property - 12), "session");
      if (v8)
        Property = (id *)objc_getProperty(v8, v9, 152, 1);
      else
        Property = 0;
    }
    *(_QWORD *)v5 = off_1E14EF578;
    *((_QWORD *)v5 + 1) = v6;
    *((_DWORD *)v5 + 4) = 1;
    if (((unint64_t)(v5 + 16) & 3) != 0)
      __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
    *(_QWORD *)v5 = off_1E14E5390;
    *((_QWORD *)v5 + 3) = &unk_1E14E53E0;
    *(_OWORD *)(v5 + 40) = xmmword_1841E37E0;
    *(_OWORD *)(v5 + 56) = xmmword_1841E37F0;
    *((_QWORD *)v5 + 9) = 0x7800000078;
    *((_QWORD *)v5 + 13) = &off_1E14EA488;
    *((_QWORD *)v5 + 14) = CFDictionaryCreateMutable(v6, 0, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
    *((_QWORD *)v5 + 15) = &off_1E14EA528;
    *((_QWORD *)v5 + 16) = CFDictionaryCreateMutable(v6, 0, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks, MEMORY[0x1E0C9B3A0]);
    *((_QWORD *)v5 + 17) = CFArrayCreateMutable(v6, 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    *((_QWORD *)v5 + 18) = CFArrayCreateMutable(v6, 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    *((_QWORD *)v5 + 19) = 0;
    if (Property)
      v10 = CFRetain(Property);
    else
      v10 = 0;
    *((_QWORD *)v5 + 21) = 0;
    v11 = v5 + 168;
    *((_QWORD *)v5 + 20) = v10;
    *((_QWORD *)v5 + 22) = 0;
    if (!v7)
      __assert_rtn("TubeManager", "TubeManager.cpp", 28, "schedulingSet");
    *((_QWORD *)v5 + 4) = v7;
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
    *(_OWORD *)(v5 + 40) = v19;
    *(_OWORD *)(v5 + 56) = v20;
    *((_QWORD *)v5 + 9) = v21;
    *((_QWORD *)v5 + 11) = 0;
    *((_QWORD *)v5 + 12) = 0;
    *((_QWORD *)v5 + 10) = 0;
    v12 = *((_QWORD *)v5 + 19);
    *((_QWORD *)v5 + 19) = 0;
    if (v12)
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
    *(_QWORD *)(a1 + 32) = v5;
    v13 = *(_QWORD *)(a1 + 96);
    v14 = *(std::__shared_weak_count **)(a1 + 104);
    if (v14)
    {
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        v16 = __ldxr(p_shared_owners);
      while (__stxr(v16 + 1, p_shared_owners));
      std::shared_ptr<__CFString const>::operator=[abi:nn180100](v11, v13, (uint64_t)v14);
      v17 = (unint64_t *)&v14->__shared_owners_;
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    else
    {
      std::shared_ptr<__CFString const>::operator=[abi:nn180100](v11, v13, 0);
    }
  }
  return *(_QWORD *)(a1 + 32);
}

void sub_183EEE474(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;

  v5 = *(_QWORD *)(v1 + 152);
  *(_QWORD *)(v1 + 152) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  CFRelease(*(CFTypeRef *)(v1 + 144));
  CFRelease(*(CFTypeRef *)(v1 + 136));
  *(_QWORD *)(v1 + 120) = v3;
  CFRelease(*(CFTypeRef *)(v1 + 128));
  *(_QWORD *)(v1 + 104) = v2;
  CFRelease(*(CFTypeRef *)(v1 + 112));
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t TubeManager::_onqueue_enqueueRequestForProtocol(CFArrayRef *a1, uint64_t a2, uint64_t a3, __int128 *a4, _OWORD *a5)
{
  _QWORD *v10;
  uint64_t result;
  void *v12;
  uint64_t v13;
  void *v14;
  _NSHTTPAlternativeServicesFilter *v15;
  const void *Value;
  CFIndex Count;
  CFIndex v18;
  CFIndex v19;
  const void *ValueAtIndex;
  uint64_t v21;
  int v22;
  uint64_t v23;
  _OWORD *v24;
  _BOOL4 v25;
  int v26;
  _OWORD *v27;
  const char *v28;
  uint64_t v29;
  CFAbsoluteTime Current;
  uint64_t v31;
  const __CFDictionary *v32;
  CFArrayRef v33;
  const __CFArray *v34;
  CFIndex FirstIndexOfValue;
  double v36;
  BOOL v37;
  uint64_t v38;
  char v39;
  char v40;
  uint64_t v41;
  uint64_t i;
  void *v43;
  uint64_t v44;
  const __CFAllocator *v45;
  _OWORD *v46;
  CFArrayRef v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *p_shared_owners;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  uint64_t v62;
  int v63;
  const void *v64;
  uint64_t v65;
  __int128 *v66;
  _OWORD *v67;
  uint64_t v68;
  id obj;
  __int128 v70;
  uint64_t v71;
  __int128 v72;
  uint64_t v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  CFArrayRef *v78;
  std::__shared_weak_count *v79;
  CFArrayRef v80;
  std::__shared_weak_count *v81;
  uint64_t aBlock;
  uint64_t p_aBlock;
  uint64_t v84;
  void *v85;
  CFArrayRef *v86;
  std::__shared_weak_count *v87;
  const void *v88;
  uint64_t v89;
  CFRange v90;

  v89 = *MEMORY[0x1E0C80C00];
  v10 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 184))(a2);
  if (!(_DWORD)result)
    return result;
  v12 = *(void **)(a2 - 96);
  v13 = objc_msgSend((id)objc_msgSend(v12, "_effectiveConfiguration"), "_alternativeServicesStorage");
  v67 = a5;
  v68 = a2;
  v65 = a3;
  v66 = a4;
  if (v13)
  {
    v14 = (void *)v13;
    v15 = objc_alloc_init(_NSHTTPAlternativeServicesFilter);
    -[_NSHTTPAlternativeServicesFilter setHost:](v15, "setHost:", (*(uint64_t (**)(_QWORD *))(*v10 + 72))(v10));
    -[_NSHTTPAlternativeServicesFilter setPort:](v15, "setPort:", (*(int (**)(_QWORD *))(*v10 + 80))(v10));
    -[_NSHTTPAlternativeServicesFilter setPartition:](v15, "setPartition:", v10[6]);
    obj = (id)objc_msgSend(v14, "HTTPServiceEntriesWithFilter:", v15);

  }
  else
  {
    obj = 0;
  }
  Value = CFDictionaryGetValue(a1[14], v10);
  Count = CFArrayGetCount(a1[18]);
  if (Count < 1)
  {
LABEL_10:
    v24 = v67;
    v23 = v68;
    if (Value)
      goto LABEL_16;
    if ((objc_msgSend(v12, "_assumesHTTP3Capable") & 1) == 0)
    {
      LODWORD(v80) = 0;
      v25 = (*(unsigned int (**)(_QWORD *))(*v10 + 88))(v10) == 1
         || (*(unsigned int (**)(_QWORD *))(*v10 + 88))(v10) == 3;
      v31 = v10[9];
      v32 = (const __CFDictionary *)(*(uint64_t (**)(_QWORD *))(*v10 + 64))(v10);
      if (resolveTubeType(v31, v25, 1, v32, (int *)&v80, 0, 0))
      {
        if ((_DWORD)v80 == 1)
          goto LABEL_77;
        if (!(_DWORD)v80)
        {
          v33 = a1[19];
          if (v33)
          {
            if (CFArrayGetCount(*((CFArrayRef *)v33 + 1)) >= 1)
            {
              v34 = (const __CFArray *)*((_QWORD *)v33 + 1);
              v90.length = CFArrayGetCount(v34);
              v90.location = 0;
              FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v34, v90, v10);
              if (FirstIndexOfValue != -1)
              {
                v36 = *((double *)CFArrayGetValueAtIndex(*((CFArrayRef *)v33 + 1), FirstIndexOfValue) + 18);
                v37 = v36 + 1800.0 >= CFAbsoluteTimeGetCurrent();
                CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)v33 + 1), FirstIndexOfValue);
                if (v37)
                  goto LABEL_77;
              }
            }
          }
          if (obj)
          {
            v76 = 0u;
            v77 = 0u;
            v74 = 0u;
            v75 = 0u;
            v38 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v74, &aBlock, 16);
            if (v38)
            {
              v39 = 0;
              v40 = 0;
              v41 = *(_QWORD *)v75;
              do
              {
                for (i = 0; i != v38; ++i)
                {
                  if (*(_QWORD *)v75 != v41)
                    objc_enumerationMutation(obj);
                  v43 = *(void **)(*((_QWORD *)&v74 + 1) + 8 * i);
                  if (objc_msgSend(v43, "host") && objc_msgSend(v43, "port") >= 1)
                  {
                    if (objc_msgSend(v43, "serviceType") == -1)
                      v39 = 1;
                    else
                      v40 |= objc_msgSend(v43, "serviceType") == 1;
                  }
                }
                v38 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v74, &aBlock, 16);
              }
              while (v38);
              if (!(v40 & 1 | ((v39 & 1) == 0)))
              {
LABEL_77:
                TubeManager::_onqueue_pairKeyWithConnectionCache((uint64_t)a1, v10, 0);
                v64 = CFDictionaryGetValue(a1[14], v10);
                if (!v64)
                  __assert_rtn("_onqueue_enqueueRequestForProtocol", "TubeManager.cpp", 429, "connCache != NULL");
                Value = v64;
                (*(void (**)(const void *, _QWORD *))(*(_QWORD *)v64 + 72))(v64, v10);
                if (!v67)
                  goto LABEL_18;
                goto LABEL_17;
              }
            }
          }
        }
      }
    }
    (*((void (**)(CFArrayRef *))*a1 + 5))(a1);
    v44 = MEMORY[0x1E0C809B0];
    v45 = a1[1];
    *(_QWORD *)&v74 = MEMORY[0x1E0C809B0];
    *((_QWORD *)&v74 + 1) = 3221225472;
    *(_QWORD *)&v75 = ___ZN11TubeManager22_onqueue_createNewTubeEP22HTTPConnectionCacheKey_block_invoke;
    *((_QWORD *)&v75 + 1) = &__block_descriptor_40_e17_v32__0_v8___qi_16l;
    *(_QWORD *)&v76 = a1;
    v46 = Tube::createNewTube(v45, (CFStringRef *)v10, &v74);
    ValueAtIndex = v46;
    v47 = a1[22];
    v80 = a1[21];
    v81 = (std::__shared_weak_count *)v47;
    if (v47)
    {
      v48 = (unint64_t *)((char *)v47 + 8);
      do
        v49 = __ldxr(v48);
      while (__stxr(v49 + 1, v48));
    }
    (*(void (**)(_OWORD *, CFArrayRef *))(*(_QWORD *)v46 + 88))(v46, &v80);
    v50 = v81;
    if (v81)
    {
      p_shared_owners = (unint64_t *)&v81->__shared_owners_;
      do
        v52 = __ldaxr(p_shared_owners);
      while (__stlxr(v52 - 1, p_shared_owners));
      if (!v52)
      {
        ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
        std::__shared_weak_count::__release_weak(v50);
      }
    }
    (*((void (**)(CFArrayRef *))*a1 + 5))(a1);
    v78 = a1;
    v53 = (std::__shared_weak_count *)operator new();
    v53->__shared_owners_ = 0;
    v54 = (unint64_t *)&v53->__shared_owners_;
    v53->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F10B8;
    v53->__shared_weak_owners_ = 0;
    v53[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
    v79 = v53;
    aBlock = v44;
    p_aBlock = 3321888768;
    v84 = (uint64_t)___ZN11TubeManager22_onqueue_createNewTubeEP22HTTPConnectionCacheKey_block_invoke_2;
    v85 = &__block_descriptor_56_e8_32c39_ZTSNSt3__110shared_ptrI11TubeManagerEE_e8_v16__0q8l;
    v86 = a1;
    v87 = v53;
    do
      v55 = __ldxr(v54);
    while (__stxr(v55 + 1, v54));
    v88 = ValueAtIndex;
    Tube::setWaitingForConnectivityCallback((uint64_t)ValueAtIndex, &aBlock);
    CFArrayAppendValue(a1[18], ValueAtIndex);
    (*(void (**)(const void *))(*(_QWORD *)ValueAtIndex + 48))(ValueAtIndex);
    v56 = v87;
    if (v87)
    {
      v57 = (unint64_t *)&v87->__shared_owners_;
      do
        v58 = __ldaxr(v57);
      while (__stlxr(v58 - 1, v57));
      if (!v58)
      {
        ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
        std::__shared_weak_count::__release_weak(v56);
      }
    }
    v59 = v79;
    if (v79)
    {
      v60 = (unint64_t *)&v79->__shared_owners_;
      do
        v61 = __ldaxr(v60);
      while (__stlxr(v61 - 1, v60));
      if (!v61)
      {
        ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
        std::__shared_weak_count::__release_weak(v59);
      }
    }
    v26 = 1;
    if (!v67)
      goto LABEL_20;
  }
  else
  {
    v18 = Count;
    v19 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1[18], v19);
      v21 = Tube::copyKey(*((Tube **)ValueAtIndex + 13));
      if ((*(unsigned int (**)(uint64_t, _QWORD *))(*(_QWORD *)v21 + 24))(v21, v10))
      {
        aBlock = 0;
        p_aBlock = (uint64_t)&aBlock;
        v84 = 0x2020000000;
        v22 = *((_DWORD *)ValueAtIndex + 55);
        LOBYTE(v85) = v22 < 10;
        _Block_object_dispose(&aBlock, 8);
        if (v22 <= 9)
          break;
      }
      (*(void (**)(uint64_t))(*(_QWORD *)v21 + 48))(v21);
      if (v18 == ++v19)
        goto LABEL_10;
    }
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 48))(v21);
    v24 = v67;
    v23 = v68;
    if (Value)
    {
LABEL_16:
      if (!v24)
      {
LABEL_18:
        v72 = *v66;
        v73 = *((_QWORD *)v66 + 2);
        return (*(uint64_t (**)(const void *, uint64_t, uint64_t, __int128 *))(*(_QWORD *)Value + 80))(Value, v23, v65, &v72);
      }
LABEL_17:
      *(_QWORD *)&v74 = 0;
      v80 = 0;
      aBlock = 0x3F000000FFFFFFFFLL;
      p_aBlock = 0;
      LODWORD(v84) = 0;
      (*(void (**)(_OWORD *, __int128 *, CFArrayRef *, uint64_t *))(*(_QWORD *)v24 + 104))(v24, &v74, &v80, &aBlock);
      goto LABEL_18;
    }
    v26 = 0;
    if (!v67)
    {
LABEL_20:
      v27 = CFAllocatorAllocate(a1[1], 104, 0);
      *v27 = 0u;
      v27[1] = 0u;
      v27[2] = 0u;
      v27[3] = 0u;
      v27[4] = 0u;
      v27[5] = 0u;
      *((_QWORD *)v27 + 12) = 0;
      v70 = *v66;
      v71 = *((_QWORD *)v66 + 2);
      BaseAwaitingTube::BaseAwaitingTube((BaseAwaitingTube *)v27, a1[1], v28);
      *(_QWORD *)v27 = off_1E14E56D8;
      *((_QWORD *)v27 + 3) = &unk_1E14E5770;
      *(_OWORD *)((char *)v27 + 56) = v70;
      *((_QWORD *)v27 + 9) = v71;
      if (!v65)
        __assert_rtn("AwaitingTube", "AwaitingTube.cpp", 16, "httpMessage");
      *((_QWORD *)v27 + 5) = v65;
      CFRetain((CFTypeRef)(v65 - 16));
      *((_QWORD *)v27 + 6) = v23;
      (*(void (**)(uint64_t))(*(_QWORD *)v23 + 16))(v23);
      v29 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)v27 + 6) + 32))(*((_QWORD *)v27 + 6));
      *((_QWORD *)v27 + 4) = v29;
      (*(void (**)(uint64_t))(*(_QWORD *)v29 + 40))(v29);
      *((_QWORD *)v27 + 10) = 0;
      Current = CFAbsoluteTimeGetCurrent();
      *((CFAbsoluteTime *)v27 + 11) = Current;
      *((CFAbsoluteTime *)v27 + 12) = Current;
      (*(void (**)(_OWORD *, const void *))(*(_QWORD *)v27 + 56))(v27, ValueAtIndex);
      if (v26)
        goto LABEL_22;
LABEL_67:
      v62 = *((_QWORD *)ValueAtIndex + 17);
      if (v62)
        (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD))(*(_QWORD *)v62 + 280))(v62, *(_QWORD *)(v23 - 96), 2, 0);
      goto LABEL_69;
    }
  }
  (*(void (**)(_OWORD *, const void *))(*(_QWORD *)v24 + 56))(v24, ValueAtIndex);
  (*(void (**)(_OWORD *))(*(_QWORD *)v24 + 40))(v24);
  v27 = v24;
  if (!v26)
    goto LABEL_67;
LABEL_22:
  Tube::initialize((uint64_t)ValueAtIndex, (uint64_t)v27, obj);
LABEL_69:
  if (v24)
    v63 = 3;
  else
    v63 = 2;
  TubeManager::_onqueue_rdar53306264_addWaiter(a1, (BaseAwaitingTube *)v27, v63);
  result = (*(uint64_t (**)(_OWORD *))(*(_QWORD *)v27 + 48))(v27);
  if ((v26 & 1) == 0 && *((_DWORD *)ValueAtIndex + 55) == 5)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v23 + 232))(v23);
    if ((_DWORD)result)
      return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v23 + 240))(v23, *((_QWORD *)ValueAtIndex + 36));
  }
  return result;
}

void sub_183EEED74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  uint64_t v31;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v31);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a31);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'HTTPProtocol::connKey(HTTPProtocol *this)
{
  return *((_QWORD *)this + 13);
}

uint64_t HTTPConnectionCacheKey::getHost(HTTPConnectionCacheKey *this)
{
  uint64_t v2;
  uint64_t result;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v7;

  v2 = *((_QWORD *)this + 11);
  if (v2)
  {
    if (!*((_QWORD *)this + 13))
    {
      (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)v2 + 72))(&v7);
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 104, &v7);
      v4 = (std::__shared_weak_count *)*((_QWORD *)&v7 + 1);
      if (*((_QWORD *)&v7 + 1))
      {
        v5 = (unint64_t *)(*((_QWORD *)&v7 + 1) + 8);
        do
          v6 = __ldaxr(v5);
        while (__stlxr(v6 - 1, v5));
        if (!v6)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
    }
  }
  result = *((_QWORD *)this + 13);
  if (!result)
    return *((_QWORD *)this + 4);
  return result;
}

uint64_t HTTPProtocol::useTube(HTTPProtocol *this, GlueTube *a2)
{
  uint64_t result;
  void *v5;
  id Property;
  CFAllocatorRef *v7;
  CFAllocatorRef v8;

  result = *((_QWORD *)this + 111);
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  *((_QWORD *)this + 111) = a2;
  if (a2)
  {
    v5 = (void *)*((_QWORD *)this + 93);
    if (v5)
      Property = objc_getProperty(v5, (SEL)a2, 152, 1);
    else
      Property = 0;
    v7 = (CFAllocatorRef *)(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 432))(this);
    v8 = HTTPConnectionCacheKey::hostlessKey(v7);
    (*(void (**)(GlueTube *, id, CFAllocatorRef))(*(_QWORD *)a2 + 80))(a2, Property, v8);
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 111) + 40))(*((_QWORD *)this + 111));
  }
  return result;
}

unsigned int *CFAllocatedReferenceCountedObject_RequiringNamedRetains::release(unsigned int *this)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = this + 4;
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  if (this)
  {
    if (v2 == 1)
      return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)this + 8))(this);
  }
  return this;
}

BOOL `non-virtual thunk to'HTTPProtocol::isValidForTube(HTTPProtocol *this)
{
  return !(*(unsigned int (**)(char *))(*((_QWORD *)this - 22) + 520))((char *)this - 176)
      && !*((_QWORD *)this + 12)
      && *((_QWORD *)this - 11) != 0;
}

uint64_t HTTPProtocol::isCancelled(HTTPProtocol *this)
{
  return (*((_DWORD *)this + 48) >> 20) & 1;
}

uint64_t HTTPConnectionCacheKey::getPort(HTTPConnectionCacheKey *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 11);
  if (v2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 64))(v2);
  else
    return *((unsigned int *)this + 14);
}

CFAllocatorRef HTTPConnectionCacheKey::hostlessKey(CFAllocatorRef *this)
{
  CFStringRef v2;
  const __CFDictionary *v3;
  const __CFAllocator *v4;
  __CFDictionary *MutableCopy;
  const __CFDictionary *v6;
  CFDictionaryRef Copy;
  CFAllocatorRef v8;

  if (!this[16] && !this[11])
  {
    v2 = CFStringCreateWithFormat(this[1], 0, CFSTR("%.6d%.2d%.2lu"), *((unsigned int *)this + 14), *((unsigned int *)this + 15), this[9]);
    v3 = this[8];
    v4 = this[1];
    if (v3)
      MutableCopy = CFDictionaryCreateMutableCopy(v4, 0, v3);
    else
      MutableCopy = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v6 = MutableCopy;
    CFDictionaryAddValue(MutableCopy, CFSTR("__kCFStreamPropertyInternalHostlessKey"), v2);
    Copy = CFDictionaryCreateCopy(this[1], v6);
    v8 = this[16];
    this[16] = Copy;
    if (v8)
      CFRelease(v8);
    if (v6)
      CFRelease(v6);
    if (v2)
      CFRelease(v2);
  }
  return this[16];
}

void sub_183EEF10C(_Unwind_Exception *exception_object)
{
  const void *v1;
  const void *v2;

  if (v2)
    CFRelease(v2);
  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t HTTPProtocol::connKey(HTTPProtocol *this)
{
  return *((_QWORD *)this + 35);
}

void sub_183EEF234(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  void *v22;

  _Block_object_dispose(&a17, 8);

  _Unwind_Resume(a1);
}

void sub_183EEF2E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183EEF850(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183EEFB94(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void HTTPConnectionCache::enableCellTimer(HTTPConnectionCache *this)
{
  NSObject *v2;
  double v3;
  dispatch_time_t v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  _QWORD v8[5];
  _QWORD handler[5];

  if (!*((_QWORD *)this + 15))
  {
    v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 12) + 80))(*((_QWORD *)this + 12));
    v3 = (double)*((int *)this + 21);
    *((_QWORD *)this + 15) = v2;
    v4 = dispatch_time(0, (uint64_t)(v3 * 1000000000.0));
    dispatch_source_set_timer(v2, v4, 0xFFFFFFFFFFFFFFFFLL, 0x5F5E100uLL);
    (*(void (**)(HTTPConnectionCache *))(*(_QWORD *)this + 40))(this);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 13) + 40))(*((_QWORD *)this + 13));
    v5 = MEMORY[0x1E0C809B0];
    v6 = *((_QWORD *)this + 15);
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 3221225472;
    handler[2] = ___ZN19HTTPConnectionCache15enableCellTimerEv_block_invoke;
    handler[3] = &__block_descriptor_40_e5_v8__0l;
    handler[4] = this;
    dispatch_source_set_event_handler(v6, handler);
    v7 = *((_QWORD *)this + 15);
    v8[0] = v5;
    v8[1] = 3221225472;
    v8[2] = ___ZN19HTTPConnectionCache15enableCellTimerEv_block_invoke_2;
    v8[3] = &__block_descriptor_40_e5_v8__0l;
    v8[4] = this;
    dispatch_source_set_cancel_handler(v7, v8);
    dispatch_resume(*((dispatch_object_t *)this + 15));
  }
}

dispatch_source_t QCoreSchedulingSet::createDispatchTimer(dispatch_queue_t *this)
{
  return dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, this[7]);
}

uint64_t AwaitingTube::linkWithTube(AwaitingTube *this, Tube *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *((_QWORD *)this + 10);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
    *((_QWORD *)this + 10) = 0;
  }
  if (a2)
  {
    *((_QWORD *)this + 10) = a2;
    (*(void (**)(Tube *))(*(_QWORD *)a2 + 40))(a2);
    v5 = *((_QWORD *)this + 10);
  }
  else
  {
    v5 = 0;
  }
  return (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 6) + 56))(*((_QWORD *)this + 6), v5);
}

uint64_t Tube::isCoalesced(Tube *this)
{
  return *((unsigned __int8 *)this + 297);
}

uint64_t Tube::setCoalescingConfig(Tube *this, __CFDictionary *a2, const __CFDictionary *a3)
{
  uint64_t result;

  result = *((_QWORD *)this + 17);
  if (result)
    return (*(uint64_t (**)(uint64_t, __CFDictionary *, const __CFDictionary *))(*(_QWORD *)result + 328))(result, a2, a3);
  return result;
}

void NWIOConnection::setCoalescingConfig(NWIOConnection *this, CFTypeRef cf, const __CFDictionary *a3)
{
  CFTypeRef v5;
  const void *v6;
  CFTypeRef v7;
  const void *v8;

  if (cf)
    v5 = CFRetain(cf);
  else
    v5 = 0;
  v6 = (const void *)*((_QWORD *)this + 83);
  *((_QWORD *)this + 83) = v5;
  if (v6)
    CFRelease(v6);
  if (a3)
    v7 = CFRetain(a3);
  else
    v7 = 0;
  v8 = (const void *)*((_QWORD *)this + 84);
  *((_QWORD *)this + 84) = v7;
  if (v8)
    CFRelease(v8);
}

void TubeManager::_onqueue_pairKeyWithConnectionCache(uint64_t a1, void *key, unsigned int a3)
{
  uint64_t v5;
  char *v6;
  char **v7;
  char *v8;
  const __CFAllocator *v9;
  _QWORD *v10;
  __int128 v11;
  __int128 v12;
  _QWORD *v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v16;
  std::__shared_count v17;
  const __CFAllocator *v18;
  __int128 v19;
  std::__shared_weak_count *shared_weak_owners;
  unint64_t v21;
  unint64_t *p_shared_weak_owners;
  unint64_t v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  const __CFAllocator *v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  CFMutableDictionaryRef Mutable;
  __int128 v36;
  __int128 v37;

  v5 = a1 + 8 * a3;
  v8 = *(char **)(v5 + 80);
  v7 = (char **)(v5 + 80);
  v6 = v8;
  if (!v8)
  {
    if (a3 != 2)
    {
      if (a3 == 1)
      {
        v6 = (char *)CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 8), 136, 0);
        *(_OWORD *)v6 = 0u;
        *((_OWORD *)v6 + 1) = 0u;
        *((_OWORD *)v6 + 2) = 0u;
        *((_OWORD *)v6 + 3) = 0u;
        *((_OWORD *)v6 + 4) = 0u;
        *((_OWORD *)v6 + 5) = 0u;
        *((_OWORD *)v6 + 6) = 0u;
        *((_OWORD *)v6 + 7) = 0u;
        *((_QWORD *)v6 + 16) = 0;
        v31 = *(const __CFAllocator **)(a1 + 8);
        MetaConnectionCache::MetaConnectionCache((MetaConnectionCache *)v6, v31);
        *(_QWORD *)v32 = off_1E14EB3C8;
        *(_QWORD *)(v32 + 32) = &unk_1E14EB478;
        v33 = *(_OWORD *)(a1 + 40);
        v34 = *(_OWORD *)(a1 + 56);
        *(_QWORD *)(v32 + 72) = *(_QWORD *)(a1 + 72);
        *(_OWORD *)(v32 + 56) = v34;
        *(_OWORD *)(v32 + 40) = v33;
        *(_QWORD *)(v32 + 88) = &off_1E14EA4A8;
        Mutable = CFDictionaryCreateMutable(v31, 0, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks, &CFObject::skCFTypeDictionaryValueCallBacks);
        *((_QWORD *)v6 + 10) = 0;
        *((_QWORD *)v6 + 12) = Mutable;
        *((_QWORD *)v6 + 13) = 0;
        *((_QWORD *)v6 + 14) = 0;
        *((_QWORD *)v6 + 15) = 0;
        v6[128] = 0;
      }
      else
      {
        if (a3)
          __assert_rtn("_onqueue_createConnectionCache", "TubeManager.cpp", 973, "FALSE");
        v6 = (char *)CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 8), 128, 0);
        *(_OWORD *)v6 = 0u;
        *((_OWORD *)v6 + 1) = 0u;
        *((_OWORD *)v6 + 2) = 0u;
        *((_OWORD *)v6 + 3) = 0u;
        *((_OWORD *)v6 + 4) = 0u;
        *((_OWORD *)v6 + 5) = 0u;
        *((_OWORD *)v6 + 6) = 0u;
        *((_OWORD *)v6 + 7) = 0u;
        v9 = *(const __CFAllocator **)(a1 + 8);
        MetaConnectionCache::MetaConnectionCache((MetaConnectionCache *)v6, v9);
        *v10 = off_1E14E9E58;
        v10[4] = &unk_1E14E9F18;
        *((_QWORD *)v6 + 6) = CFSetCreateMutable(v9, 0, &CFAllocatedReferenceCountedObject::skCFTypeSetCallBacks);
        v11 = *(_OWORD *)(a1 + 40);
        v12 = *(_OWORD *)(a1 + 56);
        *((_QWORD *)v6 + 11) = *(_QWORD *)(a1 + 72);
        *(_OWORD *)(v6 + 72) = v12;
        *(_OWORD *)(v6 + 56) = v11;
      }
LABEL_25:
      (*(void (**)(char *, _QWORD, uint64_t))(*(_QWORD *)v6 + 56))(v6, *(_QWORD *)(a1 + 32), a1);
      *v7 = v6;
      goto LABEL_26;
    }
    v6 = (char *)CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 8), 48, 0);
    *(_OWORD *)v6 = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    MetaConnectionCache::MetaConnectionCache((MetaConnectionCache *)v6, *(const __CFAllocator **)(a1 + 8));
    *v13 = off_1E14EDCE0;
    v13[5] = 0;
    *((_QWORD *)v6 + 4) = 0;
    v14 = (std::__shared_weak_count *)operator new(0x90uLL);
    *(_OWORD *)&v14->__shared_owners_ = 0u;
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    v14->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0CC8;
    v14[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14EB498;
    v16 = v14 + 1;
    v17 = *(std::__shared_count *)(a1 + 40);
    *(_OWORD *)&v14[1].__shared_owners_ = 0u;
    v14[2].std::__shared_count = v17;
    *(_OWORD *)&v14[2].__shared_weak_owners_ = *(_OWORD *)(a1 + 56);
    v14[3].__shared_owners_ = *(_QWORD *)(a1 + 72);
    *(_OWORD *)&v14[3].__shared_weak_owners_ = 0u;
    v18 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v14[4].__shared_owners_ = (uint64_t)&off_1E14EA508;
    v14[4].__shared_weak_owners_ = (uint64_t)CFDictionaryCreateMutable(v18, 0, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
    LOBYTE(v14[5].__vftable) = 0;
    v14[5].__shared_owners_ = 0;
    v14[5].__shared_weak_owners_ = 0;
    *(_QWORD *)&v19 = v14 + 1;
    *((_QWORD *)&v19 + 1) = v14;
    shared_weak_owners = (std::__shared_weak_count *)v14[1].__shared_weak_owners_;
    if (shared_weak_owners)
    {
      if (shared_weak_owners->__shared_owners_ != -1)
      {
LABEL_19:
        v28 = (std::__shared_weak_count *)*((_QWORD *)v6 + 5);
        *((_OWORD *)v6 + 2) = v19;
        if (v28)
        {
          v29 = (unint64_t *)&v28->__shared_owners_;
          do
            v30 = __ldaxr(v29);
          while (__stlxr(v30 - 1, v29));
          if (!v30)
          {
            ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
            std::__shared_weak_count::__release_weak(v28);
          }
        }
        goto LABEL_25;
      }
      do
        v21 = __ldxr(p_shared_owners);
      while (__stxr(v21 + 1, p_shared_owners));
      v36 = v19;
      p_shared_weak_owners = (unint64_t *)&v14->__shared_weak_owners_;
      do
        v23 = __ldxr(p_shared_weak_owners);
      while (__stxr(v23 + 1, p_shared_weak_owners));
      v14[1].__shared_owners_ = (uint64_t)v16;
      v14[1].__shared_weak_owners_ = (uint64_t)v14;
      std::__shared_weak_count::__release_weak(shared_weak_owners);
      v19 = v36;
    }
    else
    {
      do
        v24 = __ldxr(p_shared_owners);
      while (__stxr(v24 + 1, p_shared_owners));
      v25 = (unint64_t *)&v14->__shared_weak_owners_;
      do
        v26 = __ldxr(v25);
      while (__stxr(v26 + 1, v25));
      v14[1].__shared_owners_ = (uint64_t)v16;
      v14[1].__shared_weak_owners_ = (uint64_t)v14;
    }
    do
      v27 = __ldaxr(p_shared_owners);
    while (__stlxr(v27 - 1, p_shared_owners));
    if (!v27)
    {
      v37 = v19;
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
      v19 = v37;
    }
    goto LABEL_19;
  }
LABEL_26:
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 112), key, v6);
}

void sub_183EF01A0(_Unwind_Exception *a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *shared_weak_owners;
  void *v6;

  v2[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14E5838;
  shared_weak_owners = (std::__shared_weak_count *)v2[1].__shared_weak_owners_;
  if (shared_weak_owners)
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  std::__shared_weak_count::~__shared_weak_count(v2);
  operator delete(v6);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  *(_QWORD *)v1 = off_1E14EA0F0;

  _Unwind_Resume(a1);
}

void HTTPConnectionCacheEntry::_prepareNewRequest(HTTPConnectionCacheEntry::EnqueuedRequest **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  const __CFAllocator *v14;
  _OWORD *v15;
  const char *v16;
  int v19;
  _QWORD *v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  HTTPRequestMessage *v27;
  __int128 v28;
  __int128 v29;
  int v30;

  *a1 = 0;
  a1[1] = 0;
  if (*(_BYTE *)(a5 + 19))
    *(_BYTE *)(a2 + 32) |= 8u;
  v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 32))(a3);
  v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 88))(v10);
  if (v11 == 2)
    *(_BYTE *)(a2 + 32) |= 0x40u;
  v12 = *(_DWORD *)a5;
  v13 = *(_DWORD *)(a2 + 120);
  v29 = *(_OWORD *)(a5 + 4);
  v30 = *(_DWORD *)(a5 + 20);
  v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v15 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 80, 0);
  v15[3] = 0u;
  v15[4] = 0u;
  v15[1] = 0u;
  v15[2] = 0u;
  *v15 = 0u;
  BaseAwaitingTube::BaseAwaitingTube((BaseAwaitingTube *)v15, v14, v16);
  if (v11 == 2 || v12 >= v13 || v12 < 0)
    v19 = 0;
  else
    v19 = v12;
  *(_QWORD *)v15 = off_1E14F0160;
  *((_DWORD *)v15 + 12) = v19;
  *((_DWORD *)v15 + 17) = v30;
  *(_OWORD *)((char *)v15 + 52) = v29;
  *((_QWORD *)v15 + 3) = a3;
  (*(void (**)(uint64_t))(*(_QWORD *)a3 + 16))(a3);
  *((_QWORD *)v15 + 4) = a4;
  CFRetain((CFTypeRef)(a4 - 16));
  *((_QWORD *)v15 + 5) = 0;
  *((_QWORD *)v15 + 9) = 0;
  *(_QWORD *)&v28 = v15;
  v20 = (_QWORD *)operator new();
  *v20 = &off_1E14F1B38;
  v20[1] = 0;
  v20[2] = 0;
  v20[3] = v15;
  *((_QWORD *)&v28 + 1) = v20;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)a1, &v28);
  v21 = (std::__shared_weak_count *)*((_QWORD *)&v28 + 1);
  if (*((_QWORD *)&v28 + 1))
  {
    v22 = (unint64_t *)(*((_QWORD *)&v28 + 1) + 8);
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = *(_QWORD **)(a2 + 112);
  v25 = (*(uint64_t (**)(HTTPConnectionCacheEntry::EnqueuedRequest *))(*(_QWORD *)*a1 + 80))(*a1);
  v26 = HTTPConnectionCacheEntry::EnqueuedRequest::mutableRequest(*a1);
  if (v26)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*(_BYTE *)(v26 + 40))
      v27 = 0;
    else
      v27 = (HTTPRequestMessage *)(v26 + 16);
  }
  else
  {
    v27 = 0;
  }
  AuthenticationCache::processRequest(v24, v25, v27);
}

void sub_183EF043C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

CFTypeRef `non-virtual thunk to'HTTPProtocol::_meta_retain(HTTPProtocol *this)
{
  return CFRetain((char *)this - 192);
}

void BaseAwaitingTube::BaseAwaitingTube(BaseAwaitingTube *this, const __CFAllocator *a2, const char *a3)
{
  unsigned int *v3;
  unsigned int v4;

  *(_QWORD *)this = off_1E14EF578;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = 1;
  v3 = (unsigned int *)((char *)this + 16);
  if ((((unint64_t)this + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)this = off_1E14E7DA0;
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 + 1, v3));
  (*(void (**)(BaseAwaitingTube *))(*(_QWORD *)this + 48))(this);
}

uint64_t ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

void ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_2(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  uint64_t v5;
  const void *v6;
  uint64_t v7;
  BOOL v8;
  const __CFDictionary *v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  const void *v14;
  uint64_t v15;
  uint64_t v16;
  _CFHTTPAuthentication *v17;
  __CFHTTPMessage *v18;
  const __CFDictionary *v19;
  const __CFDictionary *v20;
  const __CFDictionary *Value;
  const __CFDictionary *v22;
  const void *v23;
  CFHTTPMessageRef Copy;
  int v25;
  int v26;
  __CFString *v27;
  const __CFAllocator *v28;
  void *MutableCopy;
  CFIndex Count;
  const __CFAllocator *v31;
  CFIndex v32;
  __CFDictionary *v33;
  void *v34;
  std::__shared_weak_count *v35;
  unint64_t *p_shared_owners;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char v41;
  _QWORD aBlock[5];
  _QWORD context[6];
  void *values;
  void **p_values;
  uint64_t v46;
  BOOL v47;
  void *v48;

  v2 = a1[9];
  if (*(_DWORD *)(v2 + 220) == 10)
  {
    v3 = *(_QWORD *)(a1[6] + 8);
    v4 = *(const void **)(v3 + 24);
    *(_QWORD *)(v3 + 24) = 0;
    if (v4)
      CFRelease(v4);
    v5 = *(_QWORD *)(a1[7] + 8);
    v6 = *(const void **)(v5 + 24);
    *(_QWORD *)(v5 + 24) = 0;
    if (v6)
      CFRelease(v6);
    return;
  }
  v7 = MEMORY[0x1E0C809B0];
  if (*(_BYTE *)(*(_QWORD *)(a1[8] + 8) + 24))
  {
    values = 0;
    p_values = &values;
    v46 = 0x2020000000;
    v47 = 0;
    v8 = (*(unsigned int (**)(_QWORD))(**(_QWORD **)(v2 + 104) + 88))(*(_QWORD *)(v2 + 104)) == 1
      || (*(unsigned int (**)(_QWORD))(**(_QWORD **)(v2 + 104) + 88))(*(_QWORD *)(v2 + 104)) == 3;
    v47 = v8;
    v9 = *(const __CFDictionary **)(*(_QWORD *)(a1[6] + 8) + 24);
    if (v9)
    {
      context[0] = v7;
      context[1] = 3221225472;
      context[2] = ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_3;
      context[3] = &unk_1E14FDAE0;
      v10 = a1[7];
      context[4] = &values;
      context[5] = v10;
      CFDictionaryApplyFunction(v9, (CFDictionaryApplierFunction)_apply_block, context);
      v11 = *(_QWORD *)(a1[6] + 8);
      v12 = *(const void **)(v11 + 24);
      *(_QWORD *)(v11 + 24) = 0;
      if (v12)
        CFRelease(v12);
    }
    if (*((_BYTE *)p_values + 24))
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1[7] + 8) + 24), &unk_1EDCFBEC0, &unk_1EDCFC1D0);
    _Block_object_dispose(&values, 8);
    if (*(_BYTE *)(*(_QWORD *)(a1[8] + 8) + 24))
    {
      (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v2 + 136) + 208))(*(_QWORD *)(v2 + 136), *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24));
      if (*(_BYTE *)(v2 + 188))
        *(_BYTE *)(*(_QWORD *)(a1[8] + 8) + 24) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 136)
                                                                                                 + 24))(*(_QWORD *)(v2 + 136), 1);
    }
  }
  v13 = *(_QWORD *)(a1[7] + 8);
  v14 = *(const void **)(v13 + 24);
  *(_QWORD *)(v13 + 24) = 0;
  if (v14)
    CFRelease(v14);
  if (*(_BYTE *)(*(_QWORD *)(a1[8] + 8) + 24)
    && (*(unsigned int (**)(_QWORD))(**(_QWORD **)(v2 + 104) + 88))(*(_QWORD *)(v2 + 104)) == 3)
  {
    v15 = *(_QWORD *)(v2 + 112);
    if (!v15 || !(*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 88))(v15))
    {
LABEL_55:
      *(_BYTE *)(*(_QWORD *)(a1[8] + 8) + 24) = 0;
      goto LABEL_56;
    }
    v16 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 112) + 88))(*(_QWORD *)(v2 + 112));
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v17 = *(_CFHTTPAuthentication **)(v16 + 80);
    if (!v17)
      goto LABEL_56;
    v18 = (__CFHTTPMessage *)(v16 - 16);
    v19 = (const __CFDictionary *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 136) + 216))(*(_QWORD *)(v2 + 136));
    v20 = v19;
    if (v19)
    {
      Value = (const __CFDictionary *)CFDictionaryGetValue(v19, &unk_1EDD003A8);
      v22 = Value;
      if (Value)
      {
        v23 = CFDictionaryGetValue(Value, &unk_1EDCFD3F8);
        v41 = 0;
        goto LABEL_32;
      }
    }
    else
    {
      v22 = 0;
    }
    v23 = 0;
    v41 = 1;
LABEL_32:
    Copy = CFHTTPMessageCreateCopy(*(CFAllocatorRef *)(v2 + 8), v18);
    _CFHTTPAuthenticationApplyHeaderToRequest(v17, Copy, (const void *)v2);
    if (v25)
    {
      values = 0;
      CFRelease(Copy);
      v26 = 0;
    }
    else
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v27 = (__CFString *)HTTPMessage::copyHeaderFieldValue((CFHTTPMessageRef)((char *)Copy + 16), 0x1362735Fu);
      values = v27;
      CFRelease(Copy);
      if (!v27 || v23 && CFEqual(v23, v27))
      {
        v26 = 1;
      }
      else
      {
        v28 = *(const __CFAllocator **)(v2 + 8);
        if ((v41 & 1) != 0)
        {
          MutableCopy = CFDictionaryCreate(*(CFAllocatorRef *)(v2 + 8), (const void **)&kCFHTTPHeaderProxyAuthorization, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          v48 = MutableCopy;
        }
        else
        {
          Count = CFDictionaryGetCount(v22);
          MutableCopy = CFDictionaryCreateMutableCopy(v28, Count + 1, v22);
          v48 = MutableCopy;
          CFDictionarySetValue((CFMutableDictionaryRef)MutableCopy, &unk_1EDCFD3F8, v27);
        }
        v31 = *(const __CFAllocator **)(v2 + 8);
        if (v20)
        {
          v32 = CFDictionaryGetCount(v20);
          v33 = CFDictionaryCreateMutableCopy(v31, v32 + 1, v20);
          CFDictionarySetValue(v33, &unk_1EDD003A8, MutableCopy);
        }
        else
        {
          v33 = CFDictionaryCreate(*(CFAllocatorRef *)(v2 + 8), (const void **)&kCFStreamPropertyCONNECTAdditionalHeaders, (const void **)&v48, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          MutableCopy = v48;
        }
        if (MutableCopy)
          CFRelease(MutableCopy);
        v26 = (*(uint64_t (**)(_QWORD, uint64_t, __CFDictionary *))(**(_QWORD **)(v2 + 136) + 200))(*(_QWORD *)(v2 + 136), 0x1EDD003E0, v33);
        if (v33)
          CFRelease(v33);
      }
    }
    if (v20)
      CFRelease(v20);
    if (values)
      CFRelease(values);
    if (v26)
      goto LABEL_56;
    goto LABEL_55;
  }
  if (!*(_BYTE *)(*(_QWORD *)(a1[8] + 8) + 24))
    goto LABEL_68;
LABEL_56:
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
  aBlock[0] = v7;
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_24;
  aBlock[3] = &__block_descriptor_40_e5_v8__0l;
  aBlock[4] = v2;
  v34 = _Block_copy(aBlock);
  v35 = (std::__shared_weak_count *)operator new();
  v35->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v35->__shared_owners_;
  v35->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1860;
  v35->__shared_weak_owners_ = 0;
  v35[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
  v35[1].__shared_owners_ = (uint64_t)v34;
  v35[1].__shared_weak_owners_ = 0;
  v37 = *(_QWORD *)(v2 + 136);
  do
    v38 = __ldxr(p_shared_owners);
  while (__stxr(v38 + 1, p_shared_owners));
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v37 + 144), v2 + 40, (uint64_t)v35);
  do
    v39 = __ldaxr(p_shared_owners);
  while (__stlxr(v39 - 1, p_shared_owners));
  if (!v39)
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
  }
  do
    v40 = __ldaxr(p_shared_owners);
  while (__stlxr(v40 - 1, p_shared_owners));
  if (!v40)
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
  }
  if (*(_BYTE *)(*(_QWORD *)(a1[8] + 8) + 24))
    (*(void (**)(void))(a1[5] + 16))();
  else
LABEL_68:
    (*(void (**)(void))(a1[4] + 16))();
}

void sub_183EF0B2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HTTPConnectionCacheKey::getType(HTTPConnectionCacheKey *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 11);
  if (v2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 56))(v2);
  else
    return *((unsigned int *)this + 15);
}

uint64_t ___ZN4Tube16_onqueue_connectEv_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 128))(*(_QWORD *)(a1 + 32));
}

void ___ZN4Tube16_onqueue_connectEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  const void *v3;
  CFTypeRef v4;
  _QWORD *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  unint64_t v23;
  NSObject *v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  _BOOL4 v28;
  Tube *v29;
  CFStreamError v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  const __CFDictionary *v35;
  int v36;
  int v37;
  int v38;
  BOOL v39;
  const void *v40;
  const __CFDictionary *v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD v44[5];
  _QWORD v45[5];
  CFTypeRef cf;
  uint64_t v47;
  void (*v48)(_QWORD *);
  void *v49;
  _QWORD *v50;
  _QWORD *v51;
  _QWORD *v52;
  uint64_t *v53;
  _QWORD *v54;
  uint64_t v55;
  _QWORD v56[4];
  _QWORD v57[3];
  char v58;
  _QWORD context[5];
  uint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  CFMutableDictionaryRef Mutable;
  __int128 buf;
  uint64_t (*v65)(_QWORD *);
  void *v66;
  CFTypeRef *p_cf;
  _QWORD *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(v1 + 136);
  if (!v2)
    goto LABEL_40;
  v3 = *(const void **)(*(_QWORD *)(v1 + 104) + 32);
  if (v3)
    v4 = CFRetain(v3);
  else
    v4 = 0;
  cf = v4;
  v5 = (_QWORD *)operator new();
  *v5 = &off_1E14F19E8;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  v47 = (uint64_t)v5;
  (*(void (**)(uint64_t, CFTypeRef *, _QWORD))(*(_QWORD *)v2 + 16))(v2, &cf, *(unsigned int *)(*(_QWORD *)(v1 + 104) + 56));
  v6 = (std::__shared_weak_count *)v47;
  if (v47)
  {
    v7 = (unint64_t *)(v47 + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  v9 = *(_QWORD *)(v1 + 136);
  v10 = *(_QWORD *)(v1 + 176);
  *(_QWORD *)&buf = *(_QWORD *)(v1 + 168);
  *((_QWORD *)&buf + 1) = v10;
  if (v10)
  {
    v11 = (unint64_t *)(v10 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)v9 + 240))(v9, &buf);
  v13 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
  if (*((_QWORD *)&buf + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (!*(_QWORD *)(v1 + 136))
  {
LABEL_40:
    v29 = (Tube *)v1;
    v30.domain = 1;
    *(_QWORD *)&v30.error = 12;
LABEL_65:
    Tube::_onqueue_errorHandler(v29, v30);
    return;
  }
  if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(v1 + 104) + 88))(*(_QWORD *)(v1 + 104)) == 1
    || (*(unsigned int (**)(_QWORD))(**(_QWORD **)(v1 + 104) + 88))(*(_QWORD *)(v1 + 104)) == 3)
  {
    v16 = *(_QWORD *)(v1 + 112);
    if (!v16)
      goto LABEL_41;
    v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 80))(v16);
    if (!v17)
      goto LABEL_41;
    v18 = v17;
    v19 = *(_QWORD *)(v17 + 632);
    v20 = *(std::__shared_weak_count **)(v17 + 640);
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        v22 = __ldxr(p_shared_owners);
      while (__stxr(v22 + 1, p_shared_owners));
      do
        v23 = __ldaxr(p_shared_owners);
      while (__stlxr(v23 - 1, p_shared_owners));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    if (v19)
    {
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t))(*(_QWORD *)v18 + 72))(&cf, v18);
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v24 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138543362;
        *(_QWORD *)((char *)&buf + 4) = cf;
        _os_log_impl(&dword_183ECA000, v24, OS_LOG_TYPE_DEFAULT, "Stream%{public}@ not enabling TLS for terminal delegate", (uint8_t *)&buf, 0xCu);
      }
      v25 = (std::__shared_weak_count *)v47;
      if (v47)
      {
        v26 = (unint64_t *)(v47 + 8);
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
      v28 = 0;
    }
    else
    {
LABEL_41:
      v28 = 1;
    }
    *(_BYTE *)(v1 + 188) = v28;
  }
  else
  {
    v28 = *(_BYTE *)(v1 + 188) != 0;
  }
  v31 = *(uint64_t **)(v1 + 104);
  v32 = v31 + 9;
  if (*(_BYTE *)(v1 + 192))
    v32 = (uint64_t *)(v1 + 200);
  v33 = *v32;
  cf = 0;
  *(_QWORD *)&buf = 0;
  v34 = *(_QWORD *)(v1 + 208);
  v35 = (const __CFDictionary *)(*(uint64_t (**)(uint64_t *))(*v31 + 64))(v31);
  v36 = resolveTubeType(v33, v28, v34, v35, (int *)(v1 + 184), &cf, &buf);
  v37 = v36;
  if (cf)
    v38 = v36;
  else
    v38 = 0;
  if (v38 == 1)
    v37 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v1 + 136) + 200))(*(_QWORD *)(v1 + 136), 0x1EDCFA6E8);
  if (v37)
    v39 = (_QWORD)buf == 0;
  else
    v39 = 1;
  if (!v39)
    LOBYTE(v37) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v1 + 136) + 200))(*(_QWORD *)(v1 + 136), 0x1EDCF9D80);
  if (cf)
    CFRelease(cf);
  if ((_QWORD)buf)
    CFRelease((CFTypeRef)buf);
  if ((v37 & 1) == 0)
  {
    v29 = (Tube *)v1;
    v30.domain = 1;
    *(_QWORD *)&v30.error = 100;
    goto LABEL_65;
  }
  v40 = (const void *)MEMORY[0x1E0C809B0];
  v44[4] = v1;
  v45[0] = MEMORY[0x1E0C809B0];
  v45[1] = 3221225472;
  v45[2] = ___ZN4Tube16_onqueue_connectEv_block_invoke_2;
  v45[3] = &__block_descriptor_40_e5_v8__0l;
  v45[4] = v1;
  v44[0] = MEMORY[0x1E0C809B0];
  v44[1] = 3221225472;
  v44[2] = ___ZN4Tube16_onqueue_connectEv_block_invoke_3;
  v44[3] = &__block_descriptor_40_e8_v12__0i8l;
  v60 = 0;
  v61 = &v60;
  v62 = 0x2020000000;
  Mutable = 0;
  Mutable = CFDictionaryCreateMutable(*(CFAllocatorRef *)(v1 + 8), 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionarySetValue((CFMutableDictionaryRef)v61[3], &unk_1EDCFB1A0, (const void *)*MEMORY[0x1E0C9AE50]);
  if ((*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 104) + 64))(*(_QWORD *)(v1 + 104)))
  {
    v41 = (const __CFDictionary *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 104) + 64))(*(_QWORD *)(v1 + 104));
    context[0] = v40;
    context[1] = 3221225472;
    context[2] = ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke;
    context[3] = &unk_1E14FDAB8;
    context[4] = &v60;
    CFDictionaryApplyFunction(v41, (CFDictionaryApplierFunction)_apply_block, context);
  }
  v57[0] = 0;
  v57[1] = v57;
  v57[2] = 0x2020000000;
  v58 = 1;
  v56[0] = 0;
  v56[1] = v56;
  v56[2] = 0x2020000000;
  v56[3] = 0;
  cf = v40;
  v47 = 3221225472;
  v48 = ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_2;
  v49 = &unk_1E14FDB08;
  v52 = v56;
  v53 = &v60;
  v54 = v57;
  v55 = v1;
  v50 = v44;
  v51 = v45;
  v42 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 112) + 80))(*(_QWORD *)(v1 + 112));
  (*(void (**)(uint64_t))(*(_QWORD *)v42 + 16))(v42);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 40))(v1);
  v43 = *(_QWORD *)(v42 - 152);
  *(_QWORD *)&buf = v40;
  *((_QWORD *)&buf + 1) = 3221225472;
  v65 = ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_2_26;
  v66 = &unk_1E14F9898;
  v69 = v1;
  v70 = v42;
  p_cf = &cf;
  v68 = v56;
  (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)v43 + 96))(v43, &buf);
  _Block_object_dispose(v56, 8);
  _Block_object_dispose(v57, 8);
  _Block_object_dispose(&v60, 8);
}

void sub_183EF11AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  uint64_t v34;
  std::__shared_weak_count *v36;
  unint64_t *p_shared_owners;
  unint64_t v38;

  v36 = *(std::__shared_weak_count **)(v34 - 136);
  if (v36)
  {
    p_shared_owners = (unint64_t *)&v36->__shared_owners_;
    do
      v38 = __ldaxr(p_shared_owners);
    while (__stlxr(v38 - 1, p_shared_owners));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t HTTPConnectionCacheKey::getProps(HTTPConnectionCacheKey *this)
{
  uint64_t result;
  uint64_t v3;
  char *v4;

  v4 = (char *)this + 80;
  result = *((_QWORD *)this + 10);
  v3 = *((_QWORD *)v4 + 1);
  if (v3)
  {
    if (result)
      return result;
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 32))(v3);
    *((_QWORD *)this + 10) = result;
  }
  if (!result)
    return *((_QWORD *)this + 8);
  return result;
}

uint64_t resolveTubeType(uint64_t a1, int a2, uint64_t a3, CFDictionaryRef theDict, int *a5, CFTypeRef *a6, _QWORD *a7)
{
  const void **v13;
  const void *Value;
  const void *v15;
  CFTypeID v16;
  _BOOL4 v17;
  _BOOL4 v18;
  _BOOL4 v19;
  const void *v20;
  const void *v21;
  CFTypeID v22;
  _BOOL4 v23;
  const void *v24;
  const void *v25;
  CFTypeID v26;
  char *v27;
  uint64_t v28;
  _BOOL4 v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t result;
  CFTypeRef v33;
  int v34;
  __CFArray *Mutable;
  CFTypeRef v36;
  uint8_t buf[16];
  uint8_t v39[16];
  uint8_t v40[16];

  v13 = (const void **)MEMORY[0x1E0C9AE50];
  if (theDict)
  {
    Value = CFDictionaryGetValue(theDict, &unk_1EDCF9B50);
    if (Value)
    {
      v15 = Value;
      v16 = CFGetTypeID(Value);
      if (v16 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v40 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v40, 2u);
      }
      v17 = *v13 == v15;
    }
    else
    {
      v17 = 0;
    }
    v19 = !v17;
    v20 = CFDictionaryGetValue(theDict, &unk_1EDCF9B88);
    if (v20)
    {
      v21 = v20;
      v22 = CFGetTypeID(v20);
      if (v22 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v39 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v39, 2u);
      }
      v23 = *v13 == v21;
    }
    else
    {
      v23 = 0;
    }
    v18 = !v23;
  }
  else
  {
    v18 = 1;
    v19 = 1;
  }
  v24 = CFDictionaryGetValue(theDict, &unk_1EDCF9990);
  if (!v24)
    goto LABEL_21;
  v25 = v24;
  v26 = CFGetTypeID(v24);
  if (v26 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
  }
  if (*v13 != v25)
LABEL_21:
    v18 = 0;
  v27 = getenv("CFN_USE_HTTP2");
  if (v27)
  {
    v28 = strtol(v27, 0, 10);
    if (v28)
      v29 = v19;
    else
      v29 = 0;
    if (v28 == 1)
      a1 = 16;
    else
      v19 = v29;
  }
  if (a2)
  {
    if (__CFNGetHTTP3Override::onceToken != -1)
      dispatch_once(&__CFNGetHTTP3Override::onceToken, &__block_literal_global_45);
    if (__CFNGetHTTP3Override::value == 1)
      a1 = 64;
  }
  v30 = 81;
  if (a1)
    v30 = a1 & 0x51;
  if (!v19)
    v30 &= 0xFFFFFFFFFFFFFFCFLL;
  if (v18)
    v31 = v30;
  else
    v31 = v30 & 0x3F;
  if (!v31)
    return 0;
  if ((a2 & 1) == 0)
  {
    if ((v31 & 1) != 0)
    {
      v34 = 1;
    }
    else
    {
      if ((v31 & 0x10) == 0)
        return 0;
      v34 = 2;
    }
    *a5 = v34;
    return 1;
  }
  *a5 = 0;
  result = 1;
  if (a6 && a7)
  {
    if (v31 == 81)
    {
      *a6 = CFRetain(&unk_1E152A830);
      if (a3 == -1)
        v33 = 0;
      else
        v33 = CFRetain(&unk_1E152A848);
      *a7 = v33;
      return 1;
    }
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    v36 = 0;
    if (a3 != -1 && v31 >= 0x40)
      v36 = CFRetain(&unk_1E152A848);
    *a7 = v36;
    if ((v31 & 0x10) != 0)
      CFArrayAppendValue(Mutable, CFSTR("h2"));
    if ((v31 & 1) != 0)
      CFArrayAppendValue(Mutable, CFSTR("http/1.1"));
    if (CFArrayGetCount(Mutable) >= 1)
    {
      if (!Mutable)
      {
        *a6 = 0;
        return 1;
      }
      *a6 = CFRetain(Mutable);
      goto LABEL_67;
    }
    *a6 = 0;
    if (Mutable)
LABEL_67:
      CFRelease(Mutable);
    return 1;
  }
  return result;
}

void sub_183EF1674(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t Tube::_onqueue_startConnection(Tube *this)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  id *v8;
  SEL v9;
  void *v10;
  id v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const void *v17;
  uint64_t result;
  uint64_t v19;
  std::__shared_weak_count *v20;

  if (*((_DWORD *)this + 55) != 10)
    *((_DWORD *)this + 55) = 3;
  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 14) + 80))(*((_QWORD *)this + 14));
  v3 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 288))(v2);
  v4 = *((_QWORD *)this + 17);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 18);
  v19 = v4;
  v20 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 248))(v4);
    v8 = (id *)objc_claimAutoreleasedReturnValue();
    objc_setProperty_atomic(v3, v9, v8, 88);
    v10 = (void *)v3[6];
    v11 = v10;
    if (v8)
      objc_storeStrong(v8 + 10, v10);

  }
  if (v5)
  {
    v12 = (unint64_t *)&v5->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v14 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 14) + 80))(*((_QWORD *)this + 14));
  v15 = v14 - 176;
  if (!v14)
    v15 = 0;
  v16 = *(void **)(v15 + 80);
  v17 = (const void *)objc_msgSend(v16, "_copyATSState", v19, v20);
  (*(void (**)(_QWORD, uint64_t, const void *))(**((_QWORD **)this + 17) + 200))(*((_QWORD *)this + 17), 0x1EDCF9300, v17);
  if (v17)
    CFRelease(v17);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 17) + 32))(*((_QWORD *)this + 17));
  result = *((_QWORD *)this + 17);
  if (result)
    result = (*(uint64_t (**)(uint64_t, void *, _QWORD, _QWORD))(*(_QWORD *)result + 280))(result, v16, 0, 0);
  *((_BYTE *)this + 120) = 1;
  return result;
}

void sub_183EF182C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v9;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN11TubeManager32getPendingTubeForProtocolWithKeyEP25MetaConnectionCacheClientPK22HTTPConnectionCacheKey_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 80))(a2);
  if (result == *(_QWORD *)(a1 + 40))
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 64))(a2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  }
  return result;
}

uint64_t AwaitingTube::getClient(AwaitingTube *this)
{
  return *((_QWORD *)this + 6);
}

id `non-virtual thunk to'HTTPProtocol::getTransactionMetrics(HTTPProtocol *this, const char *a2)
{
  id result;

  result = (id)*((_QWORD *)this + 82);
  if (result)
    return objc_getProperty(result, a2, 96, 1);
  return result;
}

_QWORD *TransportConnection::setNWContext(uint64_t a1, uint64_t *a2)
{
  return std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(a1 + 176), *a2, a2[1]);
}

void NWIOConnection::open(NWIOConnection *this)
{
  int v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  int v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_weak_owners;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  const void *Value;
  BOOL v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t quic_connection;
  NSObject *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t *p_configure_tls;
  NSObject *v38;
  uint64_t v39;
  void *v40;
  nw_parameters_t secure_tcp;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  const __CFDictionary *v48;
  const __CFDictionary *v49;
  const __CFNumber *v50;
  const __CFDictionary *v51;
  _BOOL4 v52;
  uint64_t v53;
  BOOL v54;
  const __CFString *v55;
  const __CFString *v56;
  xpc_object_t v57;
  xpc_object_t v58;
  void *v59;
  CFIndex v60;
  const __CFDictionary *v61;
  const __CFDictionary *v62;
  uint64_t v63;
  char *v64;
  NSObject *v65;
  const __CFDictionary *v66;
  unint64_t Count;
  const void **v68;
  const __CFNumber *v69;
  double v70;
  uint64_t v71;
  const void *delayInitStub;
  double v73;
  unint64_t v74;
  const void **v75;
  uint64_t i;
  std::__shared_weak_count *v77;
  char *v78;
  unint64_t *v79;
  unint64_t v80;
  unint64_t *v81;
  unint64_t v82;
  std::__shared_weak_count *v83;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  uint8x8_t v87;
  _QWORD **v88;
  _QWORD *j;
  unint64_t v90;
  float v91;
  float v92;
  _BOOL8 v93;
  unint64_t v94;
  unint64_t v95;
  int8x8_t prime;
  void *v97;
  _QWORD *v98;
  uint64_t v99;
  _QWORD *v100;
  unint64_t v101;
  uint8x8_t v102;
  unint64_t v103;
  uint8x8_t v104;
  uint64_t v105;
  _QWORD *v106;
  unint64_t v107;
  _QWORD *v108;
  _QWORD *v109;
  unint64_t v110;
  unint64_t *v111;
  unint64_t v112;
  std::__shared_weak_count *v113;
  unint64_t *v114;
  unint64_t v115;
  std::__shared_weak_count *v116;
  unint64_t *v117;
  unint64_t v118;
  _QWORD *v119;
  void *protocol_parameters;
  std::__shared_weak_count *v121;
  std::__shared_weak_count *v122;
  char *v123;
  uint64_t v124;
  uint64_t v125;
  unint64_t *v126;
  unint64_t v127;
  std::__shared_weak_count *v128;
  unint64_t *v129;
  unint64_t v130;
  std::__shared_weak_count *v131;
  unint64_t *v132;
  unint64_t v133;
  std::__shared_weak_count *v134;
  unint64_t *v135;
  unint64_t v136;
  std::__shared_weak_count *v137;
  unint64_t *v138;
  unint64_t v139;
  unint64_t *v140;
  uint64_t v141;
  _QWORD *v142;
  const char *v143;
  int v144;
  _QWORD *v145;
  BOOL v146;
  _QWORD block[5];
  std::__shared_weak_count *v148;
  _QWORD v149[6];
  std::__shared_weak_count *v150;
  uint64_t v151;
  std::__shared_weak_count *v152;
  uint64_t v153;
  std::__shared_weak_count *v154;
  uint64_t configure_tls;
  uint64_t v156;
  void *v157;
  void *v158;
  _QWORD *v159;
  _QWORD *v160;
  _QWORD configure_tcp[6];
  std::__shared_weak_count *v162;
  _QWORD v163[6];
  std::__shared_weak_count *v164;
  _QWORD v165[6];
  std::__shared_weak_count *v166;
  uint64_t v167;
  char *valuePtr;
  std::__shared_weak_count *v169;
  uint8_t buf[32];
  _QWORD *v171;
  NWIOConnection *v172;
  char *v173;
  std::__shared_weak_count *v174;
  BOOL v175;
  CFTypeRef v176;
  uint64_t v177;
  const void **v178;
  _QWORD v179[97];
  CFStreamError v180;

  v179[94] = *MEMORY[0x1E0C80C00];
  v2 = *((_DWORD *)this + 34);
  if (v2 == 7)
  {
    if ((*((_WORD *)this + 124) & 0x10) == 0)
    {
      v3 = (std::__shared_weak_count *)*((_QWORD *)this + 33);
      if (v3)
      {
        v4 = std::__shared_weak_count::lock(v3);
        if (v4)
          v5 = *((_QWORD *)this + 32);
        else
          v5 = 0;
      }
      else
      {
        v5 = 0;
        v4 = 0;
      }
      v29 = *((_QWORD *)this + 15);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3321888768;
      block[2] = ___ZN14NWIOConnection4openEv_block_invoke;
      block[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE_e5_v8__0l;
      block[4] = v5;
      v148 = v4;
      if (v4)
      {
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v31 = __ldxr(p_shared_owners);
        while (__stxr(v31 + 1, p_shared_owners));
      }
      dispatch_async(v29, block);
      v32 = v148;
      if (v148)
      {
        v33 = (unint64_t *)&v148->__shared_owners_;
        do
          v34 = __ldaxr(v33);
        while (__stlxr(v34 - 1, v33));
        if (!v34)
        {
          ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
          std::__shared_weak_count::__release_weak(v32);
        }
      }
      if (v4)
      {
        v35 = (unint64_t *)&v4->__shared_owners_;
        do
          v36 = __ldaxr(v35);
        while (__stlxr(v36 - 1, v35));
LABEL_277:
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
        return;
      }
      return;
    }
LABEL_7:
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v7 = *((_QWORD *)this + 36);
      v8 = *((_DWORD *)this + 34);
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)&buf[4] = v7;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v8;
      _os_log_error_impl(&dword_183ECA000, v6, OS_LOG_TYPE_ERROR, "Connection %llu: already opened and in state %d", buf, 0x12u);
    }
    return;
  }
  if (v2 >= 1)
    goto LABEL_7;
  *((_DWORD *)this + 34) = 1;
  v151 = 0;
  v152 = 0;
  v9 = (std::__shared_weak_count *)*((_QWORD *)this + 33);
  if (v9 && (v9 = std::__shared_weak_count::lock(v9), (v152 = v9) != 0))
  {
    v10 = *((_QWORD *)this + 32);
    v151 = v10;
  }
  else
  {
    v10 = 0;
  }
  v11 = MEMORY[0x1E0C809B0];
  v149[0] = MEMORY[0x1E0C809B0];
  v149[1] = 3321888768;
  v149[2] = ___ZN14NWIOConnection16_startConnectionEv_block_invoke;
  v149[3] = &__block_descriptor_56_e8_40c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE_e5_v8__0l;
  v149[4] = this;
  v149[5] = v10;
  v150 = v9;
  if (v9)
  {
    v12 = (unint64_t *)&v9->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  if (*((_DWORD *)this + 34) == 1)
  {
    if (*((_QWORD *)this + 38))
    {
      if (*((_QWORD *)this + 37))
      {
        v143 = "!_connectionParams";
        v144 = 1675;
      }
      else
      {
        if (!*((_QWORD *)this + 34))
        {
          v14 = *((_QWORD *)this + 32);
          v15 = (std::__shared_weak_count *)*((_QWORD *)this + 33);
          if (v15)
          {
            p_shared_weak_owners = (unint64_t *)&v15->__shared_weak_owners_;
            do
              v17 = __ldxr(p_shared_weak_owners);
            while (__stxr(v17 + 1, p_shared_weak_owners));
          }
          v165[0] = v11;
          v165[1] = 3321888768;
          v165[2] = ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke;
          v165[3] = &__block_descriptor_56_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e43_v16__0__NSObject_OS_sec_protocol_options__8l;
          v165[4] = this;
          v165[5] = v14;
          v166 = v15;
          if (v15)
          {
            v18 = (unint64_t *)&v15->__shared_weak_owners_;
            do
              v19 = __ldxr(v18);
            while (__stxr(v19 + 1, v18));
          }
          v163[0] = v11;
          v163[1] = 3321888768;
          v163[2] = ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_43;
          v163[3] = &__block_descriptor_56_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e42_v16__0__NSObject_OS_nw_protocol_options__8l;
          v163[4] = this;
          v163[5] = v14;
          v164 = v15;
          if (v15)
          {
            v20 = (unint64_t *)&v15->__shared_weak_owners_;
            do
              v21 = __ldxr(v20);
            while (__stxr(v21 + 1, v20));
          }
          configure_tcp[0] = v11;
          configure_tcp[1] = 3321888768;
          configure_tcp[2] = ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_48;
          configure_tcp[3] = &__block_descriptor_56_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e42_v16__0__NSObject_OS_nw_protocol_options__8l;
          configure_tcp[4] = this;
          configure_tcp[5] = v14;
          v162 = v15;
          if (v15)
          {
            v22 = (unint64_t *)&v15->__shared_weak_owners_;
            do
              v23 = __ldxr(v22);
            while (__stxr(v23 + 1, v22));
          }
          Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCF9D80);
          v25 = Value != 0;
          if (Value)
          {
            if (!CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCFA6E8))
            {
              if (CFNLog::onceToken != -1)
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
              v38 = CFNLog::logger;
              if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
              {
                v39 = *((_QWORD *)this + 36);
                *(_DWORD *)buf = 134217984;
                *(_QWORD *)&buf[4] = v39;
                _os_log_impl(&dword_183ECA000, v38, OS_LOG_TYPE_DEFAULT, "Connection %llu: creating quic connection", buf, 0xCu);
              }
              configure_tls = v11;
              v156 = 3221225472;
              v157 = ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_49;
              v158 = &unk_1E14F7DC8;
              v159 = v163;
              v160 = v165;
              quic_connection = nw_parameters_create_quic_connection();
              goto LABEL_65;
            }
            if (!CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCF9760)
              || CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCF99C8)
              || CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCF92C8))
            {
              if (CFNLog::onceToken != -1)
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
              v26 = CFNLog::logger;
              if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
              {
                v27 = *((_QWORD *)this + 36);
                *(_DWORD *)buf = 134217984;
                *(_QWORD *)&buf[4] = v27;
                _os_log_impl(&dword_183ECA000, v26, OS_LOG_TYPE_DEFAULT, "Connection %llu: creating secure tcp or quic connection", buf, 0xCu);
              }
              quic_connection = nw_parameters_create_secure_tcp_or_quic_connection();
LABEL_65:
              v40 = (void *)*((_QWORD *)this + 37);
              *((_QWORD *)this + 37) = quic_connection;
              if (!v40)
                goto LABEL_73;
              nw_release(v40);
LABEL_72:
              quic_connection = *((_QWORD *)this + 37);
LABEL_73:
              if (!quic_connection)
              {
                v180.domain = 1;
                *(_QWORD *)&v180.error = 22;
                NWIOConnection::_handleError(this, v180);
LABEL_261:
                if (v162)
                  std::__shared_weak_count::__release_weak(v162);
                if (v164)
                  std::__shared_weak_count::__release_weak(v164);
                if (v166)
                  std::__shared_weak_count::__release_weak(v166);
                if (v15)
                  std::__shared_weak_count::__release_weak(v15);
                goto LABEL_269;
              }
              nw_parameters_set_indefinite();
              nw_parameters_set_skip_stack_trace_capture();
              v44 = *((_QWORD *)this + 22);
              v45 = (std::__shared_weak_count *)*((_QWORD *)this + 23);
              v153 = v44;
              v154 = v45;
              if (v45)
              {
                v46 = (unint64_t *)&v45->__shared_owners_;
                do
                  v47 = __ldxr(v46);
                while (__stxr(v47 + 1, v46));
                v44 = *((_QWORD *)this + 22);
              }
              if (v44)
                nw_parameters_set_context();
              if (!CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCFB830))
              {
                v55 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCFB9F0);
                v56 = v55;
                if (v55 && CFStringGetLength(v55) >= 1)
                {
                  v57 = xpc_array_create(0, 0);
                  v58 = xpc_array_create(0, 0);
                  if (v57)
                  {
                    v59 = v58;
                    if (v58)
                    {
                      xpc_array_set_string(v57, 0xFFFFFFFFFFFFFFFFLL, "Cellular");
                      v60 = CFStringHasPrefix(v56, CFSTR("kCTDataConnectionServiceType"))
                          ? CFStringGetLength(CFSTR("kCTDataConnectionServiceType"))
                          : 0;
                      *(_QWORD *)buf = CFGetAllocator(v56);
                      *(_QWORD *)&buf[8] = 1023;
                      *(_QWORD *)&buf[16] = _CFStringGetOrCreateCString(*(const __CFAllocator **)buf, v56, &buf[24], (uint64_t *)&buf[8], 0x8000100u);
                      xpc_array_set_string(v59, 0xFFFFFFFFFFFFFFFFLL, (const char *)(*(_QWORD *)&buf[16] + v60));
                      nw_parameters_set_required_netagent_classes();
                      xpc_release(v57);
                      xpc_release(v59);
                      if (*(_QWORD *)&buf[16])
                      {
                        if (&buf[24] != *(uint8_t **)&buf[16])
                          CFAllocatorDeallocate(*(CFAllocatorRef *)buf, *(void **)&buf[16]);
                      }
                    }
                  }
                }
                else
                {
                  v69 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCFBA28);
                  if (v69)
                  {
                    v171 = 0;
                    memset(buf, 0, sizeof(buf));
                    v70 = gotLoadHelper_x8___CTServerConnectionCreate(0.0);
                    if (*(_QWORD *)(v71 + 3856))
                    {
                      delayInitStub = (const void *)_CTServerConnectionCreate_delayInitStub(v70);
                      if (delayInitStub)
                      {
                        LODWORD(v167) = 0;
                        valuePtr = 0;
                        CFNumberGetValue(v69, kCFNumberSInt32Type, &v167);
                        _CTServerConnectionCopyPacketContextInterfaceName_delayInitStub(v73);
                        CFRelease(delayInitStub);
                        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_1EDCFB830, valuePtr);
                        if (valuePtr)
                          CFRelease(valuePtr);
                      }
                    }
                  }
                }
              }
              v48 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCF96F0);
              v49 = v48;
              if (v48)
              {
                v50 = (const __CFNumber *)CFDictionaryGetValue(v48, CFSTR("kConditionalConnectionRequirementUploadBytes"));
                v51 = (const __CFDictionary *)CFDictionaryGetValue(v49, CFSTR("kConditionalConnectionRequirementDownloadBytes"));
                v49 = v51;
                v52 = v50 == 0;
                v53 = v51 == 0;
                if (v50)
                  v54 = v51 == 0;
                else
                  v54 = 1;
                if (!v54)
                {
                  valuePtr = 0;
                  CFNumberGetValue(v50, kCFNumberLongLongType, &valuePtr);
                  v167 = 0;
                  goto LABEL_104;
                }
              }
              else
              {
                v50 = 0;
                v53 = 1;
                v52 = 1;
              }
              v61 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCFB868);
              v62 = v61;
              if (v61)
              {
                if (v52)
                  v50 = (const __CFNumber *)CFDictionaryGetValue(v61, CFSTR("kConditionalConnectionRequirementUploadBytes"));
                if ((_DWORD)v53)
                  v49 = (const __CFDictionary *)CFDictionaryGetValue(v62, CFSTR("kConditionalConnectionRequirementDownloadBytes"));
              }
              if (!((unint64_t)v50 | (unint64_t)v49))
              {
LABEL_110:
                v66 = (const __CFDictionary *)*((_QWORD *)this + 46);
                if (!v66)
                {
                  *(_QWORD *)buf = 0;
                  *(_QWORD *)&buf[8] = 0;
                  *(_QWORD *)&buf[16] = &buf[24];
                  v176 = 0;
                  v177 = 0;
                  v178 = (const void **)v179;
                  goto LABEL_129;
                }
                *(_QWORD *)buf = CFRetain(*((CFTypeRef *)this + 46));
                Count = CFDictionaryGetCount(v66);
                *(_QWORD *)&buf[8] = Count;
                if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
                {
                  *(_QWORD *)&buf[16] = 0;
                  goto LABEL_123;
                }
                if (Count > 0x1E)
                {
                  v68 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
                  *(_QWORD *)&buf[16] = v68;
                  if (!v68)
                    goto LABEL_123;
                }
                else
                {
                  v68 = (const void **)&buf[24];
                  *(_QWORD *)&buf[16] = &buf[24];
                }
                CFDictionaryGetKeysAndValues(v66, v68, 0);
LABEL_123:
                v176 = CFRetain(v66);
                v74 = CFDictionaryGetCount(v66);
                v177 = v74;
                if (v74 - 1 > 0x1FFFFFFFFFFFFFFDLL)
                {
                  v178 = 0;
                  goto LABEL_129;
                }
                if (v74 > 0x1E)
                {
                  v75 = (const void **)malloc_type_malloc(8 * v74, 0x89ED541CuLL);
                  v178 = v75;
                  if (!v75)
                    goto LABEL_129;
                }
                else
                {
                  v75 = (const void **)v179;
                  v178 = (const void **)v179;
                }
                CFDictionaryGetKeysAndValues(v66, 0, v75);
LABEL_129:
                if (v177 >= 1)
                {
                  for (i = 0; i < v177; ++i)
                    NWIOConnection::_applyPropertyToConnection(this, *(const __CFString **)(*(_QWORD *)&buf[16] + 8 * i));
                }
                CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v176);
                CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)buf);
                std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&valuePtr, *((_QWORD *)this + 29), *((std::__shared_weak_count **)this + 30));
                v78 = valuePtr;
                v77 = v169;
                *(_QWORD *)buf = valuePtr;
                *(_QWORD *)&buf[8] = v169;
                if (v169)
                {
                  v79 = (unint64_t *)&v169->__shared_owners_;
                  do
                    v80 = __ldxr(v79);
                  while (__stxr(v80 + 1, v79));
                  v81 = (unint64_t *)&v77->__shared_weak_owners_;
                  do
                    v82 = __ldxr(v81);
                  while (__stxr(v82 + 1, v81));
                  v83 = v77;
                }
                else
                {
                  v83 = 0;
                }
                os_unfair_lock_lock((os_unfair_lock_t)&WeakTracker<TransportConnection>::_lock);
                if (WeakTracker<TransportConnection>::_trackedObjects(void)::onceToken != -1)
                  dispatch_once(&WeakTracker<TransportConnection>::_trackedObjects(void)::onceToken, &__block_literal_global_3530);
                if (std::__hash_table<std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>>>::find<unsigned long long>((_QWORD *)WeakTracker<TransportConnection>::_trackedObjects(void)::trackedObjects, *((_QWORD *)this + 1)))
                {
                  goto LABEL_221;
                }
                v146 = v25;
                v84 = WeakTracker<TransportConnection>::_trackedObjects(void)::trackedObjects;
                v85 = *((_QWORD *)this + 1);
                v86 = *(_QWORD *)(WeakTracker<TransportConnection>::_trackedObjects(void)::trackedObjects + 8);
                if (v86)
                {
                  v87 = (uint8x8_t)vcnt_s8((int8x8_t)v86);
                  v87.i16[0] = vaddlv_u8(v87);
                  if (v87.u32[0] > 1uLL)
                  {
                    v53 = *((_QWORD *)this + 1);
                    if (v85 >= v86)
                      v53 = v85 % v86;
                  }
                  else
                  {
                    v53 = (v86 - 1) & v85;
                  }
                  v88 = *(_QWORD ***)(*(_QWORD *)WeakTracker<TransportConnection>::_trackedObjects(void)::trackedObjects
                                    + 8 * v53);
                  if (v88)
                  {
                    for (j = *v88; j; j = (_QWORD *)*j)
                    {
                      v90 = j[1];
                      if (v90 == v85)
                      {
                        if (j[2] == v85)
                        {
                          v25 = v146;
                          goto LABEL_216;
                        }
                      }
                      else
                      {
                        if (v87.u32[0] > 1uLL)
                        {
                          if (v90 >= v86)
                            v90 %= v86;
                        }
                        else
                        {
                          v90 &= v86 - 1;
                        }
                        if (v90 != v53)
                          break;
                      }
                    }
                  }
                }
                j = operator new(0x28uLL);
                v145 = (_QWORD *)(v84 + 16);
                *j = 0;
                j[1] = v85;
                j[3] = 0;
                j[4] = 0;
                j[2] = v85;
                v91 = (float)(unint64_t)(*(_QWORD *)(v84 + 24) + 1);
                v92 = *(float *)(v84 + 32);
                if (v86 && (float)(v92 * (float)v86) >= v91)
                {
LABEL_206:
                  v108 = *(_QWORD **)v84;
                  v109 = *(_QWORD **)(*(_QWORD *)v84 + 8 * v53);
                  if (v109)
                  {
                    *j = *v109;
                    v25 = v146;
                  }
                  else
                  {
                    *j = *v145;
                    *v145 = j;
                    v108[v53] = v145;
                    v25 = v146;
                    if (!*j)
                      goto LABEL_215;
                    v110 = *(_QWORD *)(*j + 8);
                    if ((v86 & (v86 - 1)) != 0)
                    {
                      if (v110 >= v86)
                        v110 %= v86;
                    }
                    else
                    {
                      v110 &= v86 - 1;
                    }
                    v109 = (_QWORD *)(*(_QWORD *)v84 + 8 * v110);
                  }
                  *v109 = j;
LABEL_215:
                  ++*(_QWORD *)(v84 + 24);
LABEL_216:
                  v11 = MEMORY[0x1E0C809B0];
                  if (v83)
                  {
                    v111 = (unint64_t *)&v83->__shared_weak_owners_;
                    do
                      v112 = __ldxr(v111);
                    while (__stxr(v112 + 1, v111));
                  }
                  v113 = (std::__shared_weak_count *)j[4];
                  j[3] = v78;
                  j[4] = v83;
                  if (v113)
                    std::__shared_weak_count::__release_weak(v113);
LABEL_221:
                  os_unfair_lock_unlock((os_unfair_lock_t)&WeakTracker<TransportConnection>::_lock);
                  if (v83)
                    std::__shared_weak_count::__release_weak(v83);
                  if (v77)
                  {
                    v114 = (unint64_t *)&v77->__shared_owners_;
                    do
                      v115 = __ldaxr(v114);
                    while (__stlxr(v115 - 1, v114));
                    if (!v115)
                    {
                      ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
                      std::__shared_weak_count::__release_weak(v77);
                    }
                  }
                  v116 = v169;
                  if (v169)
                  {
                    v117 = (unint64_t *)&v169->__shared_owners_;
                    do
                      v118 = __ldaxr(v117);
                    while (__stlxr(v118 - 1, v117));
                    if (!v118)
                    {
                      ((void (*)(std::__shared_weak_count *))v116->__on_zero_shared)(v116);
                      std::__shared_weak_count::__release_weak(v116);
                    }
                  }
                  v119 = xpc_uint64_create(*((_QWORD *)this + 1));
                  *(_QWORD *)buf = v11;
                  *(_QWORD *)&buf[8] = 3221225472;
                  *(_QWORD *)&buf[16] = ___ZN14NWIOConnection22_addConnectionProtocolEv_block_invoke;
                  *(_QWORD *)&buf[24] = &unk_1E14FE118;
                  v171 = v119;
                  if (_ConnectionProtocolIdentifier::onceToken != -1)
                    dispatch_once(&_ConnectionProtocolIdentifier::onceToken, &__block_literal_global_16326);
                  protocol_parameters = (void *)nw_parameters_create_protocol_parameters();
                  nw_parameters_set_protocol_value();
                  nw_parameters_add_protocol_stack_member();
                  if (protocol_parameters)
                    nw_release(protocol_parameters);
                  (*(void (**)(uint8_t *))&buf[16])(buf);
                  if (!*((_QWORD *)this + 18))
                    __assert_rtn("_setupConnection", "NWIOConnection.cpp", 1857, "_establishmentDelegate");
                  valuePtr = 0;
                  v169 = 0;
                  v121 = (std::__shared_weak_count *)*((_QWORD *)this + 33);
                  if (v121)
                  {
                    v122 = std::__shared_weak_count::lock(v121);
                    v169 = v122;
                    if (v122)
                    {
                      v123 = (char *)*((_QWORD *)this + 32);
                      valuePtr = v123;
LABEL_243:
                      v124 = *((_QWORD *)this + 18);
                      v125 = *((_QWORD *)this + 37);
                      *(_QWORD *)buf = v11;
                      *(_QWORD *)&buf[8] = 3321888768;
                      *(_QWORD *)&buf[16] = ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_2_52;
                      *(_QWORD *)&buf[24] = &unk_1E14F4150;
                      v172 = this;
                      v173 = v123;
                      v174 = v122;
                      if (v122)
                      {
                        v126 = (unint64_t *)&v122->__shared_owners_;
                        do
                          v127 = __ldxr(v126);
                        while (__stxr(v127 + 1, v126));
                      }
                      v175 = v25;
                      v171 = v149;
                      (*(void (**)(uint64_t, _QWORD, uint64_t, uint8_t *))(*(_QWORD *)v124 + 16))(v124, 0, v125, buf);
                      v128 = v174;
                      if (v174)
                      {
                        v129 = (unint64_t *)&v174->__shared_owners_;
                        do
                          v130 = __ldaxr(v129);
                        while (__stlxr(v130 - 1, v129));
                        if (!v130)
                        {
                          ((void (*)(std::__shared_weak_count *))v128->__on_zero_shared)(v128);
                          std::__shared_weak_count::__release_weak(v128);
                        }
                      }
                      v131 = v169;
                      if (v169)
                      {
                        v132 = (unint64_t *)&v169->__shared_owners_;
                        do
                          v133 = __ldaxr(v132);
                        while (__stlxr(v133 - 1, v132));
                        if (!v133)
                        {
                          ((void (*)(std::__shared_weak_count *))v131->__on_zero_shared)(v131);
                          std::__shared_weak_count::__release_weak(v131);
                        }
                      }
                      v134 = v154;
                      if (v154)
                      {
                        v135 = (unint64_t *)&v154->__shared_owners_;
                        do
                          v136 = __ldaxr(v135);
                        while (__stlxr(v136 - 1, v135));
                        if (!v136)
                        {
                          ((void (*)(std::__shared_weak_count *))v134->__on_zero_shared)(v134);
                          std::__shared_weak_count::__release_weak(v134);
                        }
                      }
                      goto LABEL_261;
                    }
                  }
                  else
                  {
                    v122 = 0;
                  }
                  v123 = 0;
                  goto LABEL_243;
                }
                v93 = 1;
                if (v86 >= 3)
                  v93 = (v86 & (v86 - 1)) != 0;
                v94 = v93 | (2 * v86);
                v95 = vcvtps_u32_f32(v91 / v92);
                if (v94 <= v95)
                  prime = (int8x8_t)v95;
                else
                  prime = (int8x8_t)v94;
                if (*(_QWORD *)&prime == 1)
                {
                  prime = (int8x8_t)2;
                }
                else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
                {
                  prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
                }
                v86 = *(_QWORD *)(v84 + 8);
                if (*(_QWORD *)&prime > v86)
                  goto LABEL_172;
                if (*(_QWORD *)&prime < v86)
                {
                  v103 = vcvtps_u32_f32((float)*(unint64_t *)(v84 + 24) / *(float *)(v84 + 32));
                  if (v86 < 3
                    || (v104 = (uint8x8_t)vcnt_s8((int8x8_t)v86), v104.i16[0] = vaddlv_u8(v104), v104.u32[0] > 1uLL))
                  {
                    v103 = std::__next_prime(v103);
                  }
                  else
                  {
                    v105 = 1 << -(char)__clz(v103 - 1);
                    if (v103 >= 2)
                      v103 = v105;
                  }
                  if (*(_QWORD *)&prime <= v103)
                    prime = (int8x8_t)v103;
                  if (*(_QWORD *)&prime >= v86)
                  {
                    v86 = *(_QWORD *)(v84 + 8);
                  }
                  else
                  {
                    if (prime)
                    {
LABEL_172:
                      if (*(_QWORD *)&prime >> 61)
                        std::__throw_bad_array_new_length[abi:nn180100]();
                      v97 = operator new(8 * *(_QWORD *)&prime);
                      v98 = *(_QWORD **)v84;
                      *(_QWORD *)v84 = v97;
                      if (v98)
                        operator delete(v98);
                      v99 = 0;
                      *(int8x8_t *)(v84 + 8) = prime;
                      do
                        *(_QWORD *)(*(_QWORD *)v84 + 8 * v99++) = 0;
                      while (*(_QWORD *)&prime != v99);
                      v100 = (_QWORD *)*v145;
                      if (*v145)
                      {
                        v101 = v100[1];
                        v102 = (uint8x8_t)vcnt_s8(prime);
                        v102.i16[0] = vaddlv_u8(v102);
                        if (v102.u32[0] > 1uLL)
                        {
                          if (v101 >= *(_QWORD *)&prime)
                            v101 %= *(_QWORD *)&prime;
                        }
                        else
                        {
                          v101 &= *(_QWORD *)&prime - 1;
                        }
                        *(_QWORD *)(*(_QWORD *)v84 + 8 * v101) = v145;
                        v106 = (_QWORD *)*v100;
                        if (*v100)
                        {
                          do
                          {
                            v107 = v106[1];
                            if (v102.u32[0] > 1uLL)
                            {
                              if (v107 >= *(_QWORD *)&prime)
                                v107 %= *(_QWORD *)&prime;
                            }
                            else
                            {
                              v107 &= *(_QWORD *)&prime - 1;
                            }
                            if (v107 != v101)
                            {
                              if (!*(_QWORD *)(*(_QWORD *)v84 + 8 * v107))
                              {
                                *(_QWORD *)(*(_QWORD *)v84 + 8 * v107) = v100;
                                goto LABEL_197;
                              }
                              *v100 = *v106;
                              *v106 = **(_QWORD **)(*(_QWORD *)v84 + 8 * v107);
                              **(_QWORD **)(*(_QWORD *)v84 + 8 * v107) = v106;
                              v106 = v100;
                            }
                            v107 = v101;
LABEL_197:
                            v100 = v106;
                            v106 = (_QWORD *)*v106;
                            v101 = v107;
                          }
                          while (v106);
                        }
                      }
                      v86 = (unint64_t)prime;
                      goto LABEL_201;
                    }
                    v142 = *(_QWORD **)v84;
                    *(_QWORD *)v84 = 0;
                    if (v142)
                      operator delete(v142);
                    v86 = 0;
                    *(_QWORD *)(v84 + 8) = 0;
                  }
                }
LABEL_201:
                if ((v86 & (v86 - 1)) != 0)
                {
                  if (v85 >= v86)
                    v53 = v85 % v86;
                  else
                    v53 = v85;
                }
                else
                {
                  v53 = (v86 - 1) & v85;
                }
                goto LABEL_206;
              }
              valuePtr = 0;
              if (v50)
                CFNumberGetValue(v50, kCFNumberLongLongType, &valuePtr);
              v167 = 0;
              if (!v49)
              {
                v63 = 0;
LABEL_105:
                v64 = &valuePtr[v63];
                if ((uint64_t)&valuePtr[v63] >= 1)
                {
                  nw_parameters_set_expected_workload();
                  if (CFNLog::onceToken != -1)
                    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
                  v65 = CFNLog::logger;
                  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
                  {
                    v141 = *((_QWORD *)this + 36);
                    *(_DWORD *)buf = 134218240;
                    *(_QWORD *)&buf[4] = v141;
                    *(_WORD *)&buf[12] = 2048;
                    *(_QWORD *)&buf[14] = v64;
                    _os_log_debug_impl(&dword_183ECA000, v65, OS_LOG_TYPE_DEBUG, "Connection %llu: Workload set(%lld)", buf, 0x16u);
                  }
                }
                goto LABEL_110;
              }
LABEL_104:
              CFNumberGetValue(v49, kCFNumberLongLongType, &v167);
              v63 = v167;
              goto LABEL_105;
            }
          }
          if ((*((_WORD *)this + 124) & 0x200) != 0)
          {
            configure_tls = v11;
            v156 = 3221225472;
            v157 = ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_50;
            v158 = &unk_1E14F7DF0;
            v159 = v165;
            p_configure_tls = &configure_tls;
          }
          else
          {
            p_configure_tls = (uint64_t *)*MEMORY[0x1E0CCED20];
          }
          secure_tcp = nw_parameters_create_secure_tcp(p_configure_tls, configure_tcp);
          v42 = (void *)*((_QWORD *)this + 37);
          *((_QWORD *)this + 37) = secure_tcp;
          if (v42)
            nw_release(v42);
          v43 = *((_QWORD *)this + 25);
          if (v43)
            *(_QWORD *)(v43 + 128) = 1;
          goto LABEL_72;
        }
        v143 = "!_connection";
        v144 = 1676;
      }
    }
    else
    {
      v143 = "_connectionEndpoint";
      v144 = 1674;
    }
    __assert_rtn("_setupConnection", "NWIOConnection.cpp", v144, v143);
  }
LABEL_269:
  v137 = v150;
  if (v150)
  {
    v138 = (unint64_t *)&v150->__shared_owners_;
    do
      v139 = __ldaxr(v138);
    while (__stlxr(v139 - 1, v138));
    if (!v139)
    {
      ((void (*)(std::__shared_weak_count *))v137->__on_zero_shared)(v137);
      std::__shared_weak_count::__release_weak(v137);
    }
  }
  v4 = v152;
  if (v152)
  {
    v140 = (unint64_t *)&v152->__shared_owners_;
    do
      v36 = __ldaxr(v140);
    while (__stlxr(v36 - 1, v140));
    goto LABEL_277;
  }
}

void sub_183EF2BE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,std::__shared_weak_count *a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,std::__shared_weak_count *a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,std::__shared_weak_count *a55,uint64_t a56,char a57,uint64_t a58,CFAllocatorRef allocator,uint64_t a60,void *ptr)
{
  std::__shared_weak_count *v61;
  std::__shared_weak_count *v62;
  _QWORD *v63;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::weak_ptr<TransportConnection>>,void *>>>::operator()[abi:nn180100](1, v63);
  os_unfair_lock_unlock((os_unfair_lock_t)&WeakTracker<TransportConnection>::_lock);
  if (v62)
    std::__shared_weak_count::__release_weak(v62);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&allocator);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a57);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a27);
  if (a41)
    std::__shared_weak_count::__release_weak(a41);
  if (a48)
    std::__shared_weak_count::__release_weak(a48);
  if (a55)
    std::__shared_weak_count::__release_weak(a55);
  if (v61)
    std::__shared_weak_count::__release_weak(v61);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a23);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a25);
  _Unwind_Resume(a1);
}

void NWIOConnection::_applyPropertyToConnection(NWIOConnection *this, const __CFString *a2)
{
  const __CFNumber *Value;
  const __CFNumber *v5;
  int ExactString;
  void *v7;
  CFTypeID v8;
  uint64_t v9;
  CFTypeID v10;
  _BOOL4 v11;
  void *v12;
  uint64_t v13;
  xpc_object_t v14;
  xpc_object_t v15;
  xpc_object_t v16;
  xpc_object_t v17;
  const UInt8 *BytePtr;
  size_t Length;
  NSObject *v20;
  NSObject *v21;
  CFTypeID v22;
  uint64_t v23;
  NSObject *v24;
  const __CFString *v25;
  CFTypeID v26;
  CFTypeID v27;
  CFTypeID v28;
  CFTypeID v29;
  uint64_t v30;
  CFTypeID v31;
  CFTypeID v32;
  CFTypeID v33;
  uint64_t v34;
  CFTypeID v35;
  NSObject *v36;
  uint64_t v37;
  NSObject *v38;
  NSObject *v39;
  NSObject *v40;
  NSObject *v41;
  CFTypeID v42;
  NSObject *v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  const UInt8 *v47;
  __int128 v48;
  int v49;
  uint64_t v50;
  NSObject *v51;
  uint64_t v52;
  _QWORD destructor[5];
  __int128 v54;
  __int128 v55;
  _QWORD applier[7];
  nw_multipath_service_t multipath_service;
  uint64_t v58;
  __int16 v59;
  const __CFNumber *v60;
  _BYTE valuePtr[24];
  UInt8 v62[1024];
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  Value = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), a2);
  if (!*((_QWORD *)this + 37))
    return;
  v5 = Value;
  ExactString = _findExactString(a2, 2u);
  if (ExactString > 97904391)
  {
    if (ExactString <= 174287921)
    {
      if (ExactString <= 111413250)
      {
        if (ExactString > 105187215)
        {
          if (ExactString == 105187216)
          {
            if (v5)
            {
              *(_DWORD *)valuePtr = 0;
              if (CFNumberGetValue(v5, kCFNumberIntType, valuePtr))
              {
                v38 = nw_parameters_copy_default_protocol_stack(*((nw_parameters_t *)this + 37));
                v39 = v38;
                if (v38)
                {
                  v40 = nw_protocol_stack_copy_internet_protocol(v38);
                  v41 = v40;
                  if (v40)
                  {
                    nw_ip_options_set_local_address_preference(v40, *(nw_ip_local_address_preference_t *)valuePtr);
                    nw_release(v41);
                  }
                  nw_release(v39);
                }
              }
            }
          }
          else if (ExactString == 107284408)
          {
            if (*((_QWORD *)this + 34))
              NWIOConnection::_applyPropertyToConnection_EventHandlerLowThroughput((uint64_t)this, 0, 1);
          }
          else if (ExactString == 108242893 && v5)
          {
            v22 = CFGetTypeID(v5);
            if (v22 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)valuePtr = 0;
              _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
            }
            v23 = *((_QWORD *)this + 37);
            if ((const __CFNumber *)*MEMORY[0x1E0C9AE50] == v5)
              addProhibitedNetworkSubtype(v23, 0x1389u);
            else
              removeProhibitedNetworkSubtype(v23, 5001);
          }
        }
        else
        {
          switch(ExactString)
          {
            case 97904392:
              if (*((_QWORD *)this + 34))
                NWIOConnection::_applyPropertyToConnection_EventHandlerExcessiveKeepalive((uint64_t)this, 0);
              break;
            case 98862880:
              if (v5)
              {
                *(_QWORD *)valuePtr = 0;
                CFNumberGetValue(v5, kCFNumberSInt64Type, valuePtr);
                nw_parameters_set_expired_dns_behavior(*((nw_parameters_t *)this + 37), *(nw_parameters_expired_dns_behavior_t *)valuePtr);
              }
              break;
            case 103057261:
              if (v5)
              {
                CFRetain(v5);
                BytePtr = CFDataGetBytePtr(v5);
                Length = CFDataGetLength(v5);
                v20 = *((_QWORD *)this + 15);
                destructor[0] = MEMORY[0x1E0C809B0];
                destructor[1] = 3221225472;
                destructor[2] = ___ZN14NWIOConnection26_applyPropertyToConnectionEPK10__CFString_block_invoke_117;
                destructor[3] = &__block_descriptor_40_e5_v8__0l;
                destructor[4] = v5;
                v21 = dispatch_data_create(BytePtr, Length, v20, destructor);
                nw_parameters_set_initial_data_payload();
                if (v21)
                  dispatch_release(v21);
              }
              break;
          }
        }
      }
      else if (ExactString <= 138750445)
      {
        if (ExactString == 111413251)
        {
          if (v5)
          {
            v32 = CFGetTypeID(v5);
            if (v32 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)valuePtr = 0;
              _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
            }
            nw_parameters_set_prefer_no_proxy(*((nw_parameters_t *)this + 37), *MEMORY[0x1E0C9AE50] == (_QWORD)v5);
          }
        }
        else if (ExactString == 113535013)
        {
          if (v5)
          {
            v33 = CFGetTypeID(v5);
            if (v33 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)valuePtr = 0;
              _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
            }
            v34 = *((_QWORD *)this + 37);
            if ((const __CFNumber *)*MEMORY[0x1E0C9AE50] == v5)
              addProhibitedNetworkSubtype(v34, 0x3E9u);
            else
              removeProhibitedNetworkSubtype(v34, 1001);
          }
        }
        else if (ExactString == 137693657 && *((_QWORD *)this + 34))
        {
          NWIOConnection::_applyPropertyToConnection_EventHandlerAdaptiveRead((uint64_t)this, 0);
        }
      }
      else if (ExactString > 157494065)
      {
        if (ExactString == 157494066)
        {
          if (v5)
          {
            CFBooleanGetValue(v5);
            nw_parameters_set_ecn_mode();
          }
        }
        else if (ExactString == 161713010 && v5)
        {
          CFBooleanGetValue(v5);
          nw_parameters_set_receive_any_interface();
        }
      }
      else if (ExactString == 138750446)
      {
        if (*((_QWORD *)this + 34))
          NWIOConnection::_applyPropertyToConnection_EventHandlerAdaptiveWrite((uint64_t)this, 0);
      }
      else if (ExactString == 139782659)
      {
        if (v5)
        {
          v7 = (void *)_CFXPCCreateXPCObjectFromCFObject();
          nw_parameters_set_metadata();
          if (v7)
            xpc_release(v7);
        }
        else
        {
          nw_parameters_set_metadata();
        }
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 46), a2);
      }
      return;
    }
    if (ExactString > 195382724)
    {
      if (ExactString <= 212037385)
      {
        if (ExactString == 195382725)
        {
          if (v5)
          {
            CFBooleanGetValue(v5);
            nw_parameters_set_no_fallback();
          }
        }
        else if (ExactString == 204762748)
        {
          if (v5)
          {
            v35 = CFGetTypeID(v5);
            if (v35 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)valuePtr = 0;
              _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
            }
            nw_parameters_set_multipath_service(*((nw_parameters_t *)this + 37), (nw_multipath_service_t)(2 * (*MEMORY[0x1E0C9AE50] == (_QWORD)v5)));
          }
        }
        else if (ExactString == 205827726 && v5)
        {
          CFBooleanGetValue(v5);
          nw_parameters_set_indefinite();
        }
        return;
      }
      if (ExactString <= 226775050)
      {
        if (ExactString != 212037386)
        {
          if (ExactString != 214216493 || !v5)
            return;
          v10 = CFGetTypeID(v5);
          if (v10 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)valuePtr = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
          }
          v11 = *MEMORY[0x1E0C9AE50] == (_QWORD)v5;
          v12 = (void *)nw_parameters_copy_preferred_netagent_domains();
          v13 = nw_parameters_copy_preferred_netagent_types();
          v14 = (xpc_object_t)v13;
          if (v11)
          {
            if (!v12)
              v12 = xpc_array_create(0, 0);
            if (!v14)
              v14 = xpc_array_create(0, 0);
            if (v12 && v14)
            {
              xpc_array_set_string(v12, 0xFFFFFFFFFFFFFFFFLL, "Persistent");
              xpc_array_set_string(v14, 0xFFFFFFFFFFFFFFFFLL, "Persistent");
            }
          }
          else if (v12 && v13 && xpc_array_get_count(v12))
          {
            v15 = xpc_array_create(0, 0);
            v16 = xpc_array_create(0, 0);
            v17 = v16;
            if (v15 && v16)
            {
              applier[0] = MEMORY[0x1E0C809B0];
              applier[1] = 3221225472;
              applier[2] = ___ZN14NWIOConnection26_applyPropertyToConnectionEPK10__CFString_block_invoke;
              applier[3] = &unk_1E14F7EB8;
              applier[4] = v14;
              applier[5] = v15;
              applier[6] = v16;
              xpc_array_apply(v12, applier);
            }
            xpc_release(v12);
            xpc_release(v14);
            v12 = v15;
            v14 = v17;
          }
          if (v12 && v14)
          {
            nw_parameters_set_preferred_netagent_classes();
          }
          else if (!v12)
          {
            goto LABEL_293;
          }
          xpc_release(v12);
LABEL_293:
          if (v14)
            xpc_release(v14);
          return;
        }
        if (v5)
        {
          v29 = CFGetTypeID(v5);
          if (v29 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)valuePtr = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
          }
          v30 = *((_QWORD *)this + 37);
          if ((const __CFNumber *)*MEMORY[0x1E0C9AE50] == v5)
            addProhibitedNetworkType(v30, 2u);
          else
            removeProhibitedNetworkType(v30, 2);
        }
        return;
      }
      if (ExactString == 226775051)
      {
        if (v5)
        {
          v47 = CFDataGetBytePtr(v5);
          if (v47)
          {
            v48 = *((_OWORD *)v47 + 1);
            v54 = *(_OWORD *)v47;
            v55 = v48;
            nw_parameters_set_source_application();
          }
        }
        return;
      }
      if (ExactString != 227954717 || !v5)
        return;
      *(_QWORD *)valuePtr = *MEMORY[0x1E0C9AE00];
      *(_QWORD *)&valuePtr[8] = 1023;
      *(_QWORD *)&valuePtr[16] = _CFStringGetOrCreateCString(*(const __CFAllocator **)valuePtr, (CFStringRef)v5, v62, (uint64_t *)&valuePtr[8], 0x8000100u);
      if (*(_QWORD *)&valuePtr[16])
      {
        v25 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCFB718);
        if (v25
          && CFStringCompare(v25, CFSTR("NSURLSessionSourceApplicationBundleIdentifierIsExternal"), 0) == kCFCompareEqualTo)
        {
          nw_parameters_set_source_application_by_external_bundle_id();
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v51 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            v52 = *((_QWORD *)this + 36);
            multipath_service = 134218242;
            v58 = v52;
            v59 = 2112;
            v60 = v5;
            _os_log_impl(&dword_183ECA000, v51, OS_LOG_TYPE_DEFAULT, "Connection %llu: source bundle id %@ is marked external", (uint8_t *)&multipath_service, 0x16u);
          }
        }
        else if (CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCFBF68))
        {
          nw_parameters_set_effective_bundle_id();
        }
        else
        {
          nw_parameters_set_source_application_by_bundle_id();
        }
      }
LABEL_302:
      if (*(_QWORD *)&valuePtr[16] && v62 != *(UInt8 **)&valuePtr[16])
        CFAllocatorDeallocate(*(CFAllocatorRef *)valuePtr, *(void **)&valuePtr[16]);
      return;
    }
    if (ExactString <= 189107520)
    {
      if (ExactString != 174287922)
      {
        if (ExactString == 186928407)
        {
          if (!v5)
            return;
          *(_QWORD *)valuePtr = *MEMORY[0x1E0C9AE00];
          *(_QWORD *)&valuePtr[8] = 1023;
          *(_QWORD *)&valuePtr[16] = _CFStringGetOrCreateCString(*(const __CFAllocator **)valuePtr, (CFStringRef)v5, v62, (uint64_t *)&valuePtr[8], 0x8000100u);
          if (!*(_QWORD *)&valuePtr[16])
            return;
          nw_parameters_set_account_id();
          goto LABEL_302;
        }
        if (ExactString != 188075305)
          return;
LABEL_134:
        if (v5)
        {
          v26 = CFGetTypeID(v5);
          if (v26 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)valuePtr = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
          }
          if ((const __CFNumber *)*MEMORY[0x1E0C9AE40] == v5)
            nw_parameters_set_prohibit_constrained(*((nw_parameters_t *)this + 37), 1);
        }
        return;
      }
      if (v5)
        stringToServiceType((uint64_t)v5);
      v49 = *((_DWORD *)this + 34);
      if (v49 >= 1)
      {
        v50 = *((_QWORD *)this + 34);
        if (v49 == 1)
        {
          if (!v50)
            goto LABEL_261;
        }
        else if (!v50)
        {
          return;
        }
        nw_connection_reset_traffic_class();
        return;
      }
LABEL_261:
      nw_parameters_set_traffic_class();
      return;
    }
    if (ExactString != 189107521)
    {
      if (ExactString == 190147928)
      {
        if (!v5)
          return;
        *(_QWORD *)valuePtr = *MEMORY[0x1E0C9AE00];
        *(_QWORD *)&valuePtr[8] = 1023;
        *(_QWORD *)&valuePtr[16] = _CFStringGetOrCreateCString(*(const __CFAllocator **)valuePtr, (CFStringRef)v5, v62, (uint64_t *)&valuePtr[8], 0x8000100u);
        if (!*(_QWORD *)&valuePtr[16])
          return;
        nw_parameters_set_attributed_bundle_identifier();
      }
      else
      {
        if (ExactString != 192228739 || !v5)
          return;
        *(_QWORD *)valuePtr = *MEMORY[0x1E0C9AE00];
        *(_QWORD *)&valuePtr[8] = 1023;
        *(_QWORD *)&valuePtr[16] = _CFStringGetOrCreateCString(*(const __CFAllocator **)valuePtr, (CFStringRef)v5, v62, (uint64_t *)&valuePtr[8], 0x8000100u);
        v24 = nw_interface_create_with_name();
        if (v24)
        {
          nw_parameters_require_interface(*((nw_parameters_t *)this + 37), v24);
          nw_release(v24);
        }
      }
      goto LABEL_302;
    }
LABEL_140:
    if (v5)
    {
      v27 = CFGetTypeID(v5);
      if (v27 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)valuePtr = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
      }
      if ((const __CFNumber *)*MEMORY[0x1E0C9AE40] == v5)
        nw_parameters_set_prohibit_expensive(*((nw_parameters_t *)this + 37), 1);
    }
    return;
  }
  if (ExactString <= 60261416)
  {
    if (ExactString <= 43295483)
    {
      if (ExactString > 30736879)
      {
        if (ExactString == 30736880)
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v36 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)valuePtr = 0;
            _os_log_impl(&dword_183ECA000, v36, OS_LOG_TYPE_DEFAULT, "Enabling no_wake_from_sleep when idle", valuePtr, 2u);
          }
          *((_BYTE *)this + 680) = 1;
          v37 = *((_QWORD *)this + 25);
          if (v37)
            *(_BYTE *)(v37 + 22) = 1;
        }
        else if (ExactString == 41272009)
        {
          if (*((_QWORD *)this + 34))
          {
            if (v5)
            {
              *(_QWORD *)valuePtr = 0;
              if (CFNumberGetValue(v5, kCFNumberLongLongType, valuePtr))
                nw_connection_reset_expected_progress_target();
            }
          }
        }
        else if (ExactString == 42377953 && (*((_WORD *)this + 124) & 0x200) == 0)
        {
          if (v5)
            CFBooleanGetValue(v5);
          nw_parameters_set_fail_if_svcb_received();
        }
      }
      else
      {
        switch(ExactString)
        {
          case 10797104:
            if (v5)
            {
              v31 = CFGetTypeID(v5);
              if (v31 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
              {
                *(_WORD *)valuePtr = 0;
                _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
              }
              if ((const __CFNumber *)*MEMORY[0x1E0C9AE50] == v5)
                nw_parameters_set_expired_dns_behavior(*((nw_parameters_t *)this + 37), nw_parameters_expired_dns_behavior_prohibit|nw_parameters_expired_dns_behavior_allow);
            }
            break;
          case 14925947:
            if (v5)
            {
              *(_QWORD *)valuePtr = 0;
              CFNumberGetValue(v5, kCFNumberCFIndexType, valuePtr);
              if (*(_QWORD *)valuePtr == 1)
              {
                nw_parameters_set_attribution(*((nw_parameters_t *)this + 37), nw_parameters_attribution_user);
              }
              else if (!*(_QWORD *)valuePtr)
              {
                nw_parameters_set_attribution(*((nw_parameters_t *)this + 37), nw_parameters_attribution_developer);
              }
            }
            break;
          case 15990923:
            if (v5)
              CFBooleanGetValue(v5);
            nw_parameters_set_block_trackers();
            break;
        }
      }
      return;
    }
    if (ExactString <= 50668408)
    {
      switch(ExactString)
      {
        case 43295484:
          if (v5)
            CFBooleanGetValue(v5);
          nw_parameters_set_is_third_party_web_content();
          break;
        case 48538454:
          if (v5)
            CFBooleanGetValue(v5);
          nw_parameters_set_web_search_content();
          break;
        case 49537897:
          if (v5)
            CFBooleanGetValue(v5);
          nw_parameters_set_is_known_tracker();
          break;
      }
      return;
    }
    if (ExactString == 50668409)
    {
      if (!v5)
        return;
      multipath_service = nw_multipath_service_disabled;
      if (!CFNumberGetValue(v5, kCFNumberIntType, &multipath_service))
        return;
      nw_endpoint_set_alternate_port();
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v43 = CFNLog::logger;
      if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
        return;
      v44 = *((_QWORD *)this + 36);
      *(_DWORD *)valuePtr = 134218240;
      *(_QWORD *)&valuePtr[4] = v44;
      *(_WORD *)&valuePtr[12] = 1024;
      *(_DWORD *)&valuePtr[14] = multipath_service;
      v45 = "Connection %llu: MPTCP alternate port set(%d)";
    }
    else
    {
      if (ExactString != 51700622)
      {
        if (ExactString == 59057172)
        {
          if (v5)
            CFBooleanGetValue(v5);
          nw_parameters_set_privacy_proxy_fail_closed();
        }
        return;
      }
      if (!v5)
        return;
      multipath_service = nw_multipath_service_disabled;
      if (!CFNumberGetValue(v5, kCFNumberIntType, &multipath_service))
        return;
      nw_parameters_set_multipath_service(*((nw_parameters_t *)this + 37), multipath_service);
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v43 = CFNLog::logger;
      if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
        return;
      v46 = *((_QWORD *)this + 36);
      *(_DWORD *)valuePtr = 134218240;
      *(_QWORD *)&valuePtr[4] = v46;
      *(_WORD *)&valuePtr[12] = 1024;
      *(_DWORD *)&valuePtr[14] = multipath_service;
      v45 = "Connection %llu: MPTCP service type set(%d)";
    }
    _os_log_debug_impl(&dword_183ECA000, v43, OS_LOG_TYPE_DEBUG, v45, valuePtr, 0x12u);
    return;
  }
  if (ExactString > 75834718)
  {
    if (ExactString > 78857631)
    {
      if (ExactString > 93587129)
      {
        if (ExactString == 93587130)
        {
          if (v5)
            CFBooleanGetValue(v5);
          nw_parameters_set_use_awdl();
        }
        else if (ExactString == 94627531)
        {
          if (v5)
            CFBooleanGetValue(v5);
          nw_parameters_set_use_p2p();
        }
      }
      else if (ExactString == 78857632)
      {
        if (v5)
        {
          v28 = CFGetTypeID(v5);
          if (v28 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)valuePtr = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
          }
          if ((const __CFNumber *)*MEMORY[0x1E0C9AE50] == v5)
            nw_parameters_set_allow_ultra_constrained();
        }
      }
      else if (ExactString == 80020910 && v5)
      {
        v8 = CFGetTypeID(v5);
        if (v8 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)valuePtr = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
        }
        v9 = *((_QWORD *)this + 37);
        if ((const __CFNumber *)*MEMORY[0x1E0C9AE40] == v5)
          addProhibitedNetworkType(v9, 0);
        else
          removeProhibitedNetworkType(v9, 0);
      }
      return;
    }
    if (ExactString == 75834719)
    {
      if (v5)
        CFBooleanGetValue(v5);
      nw_parameters_set_use_enhanced_privacy_mode();
      return;
    }
    if (ExactString == 76932468)
      goto LABEL_134;
    if (ExactString != 77907340)
      return;
    goto LABEL_140;
  }
  if (ExactString > 63235197)
  {
    if (ExactString == 63235198)
    {
      if (v5)
        CFBooleanGetValue(v5);
      nw_parameters_set_prohibit_privacy_proxy();
      return;
    }
    if (ExactString == 67462344)
    {
      if (v5)
      {
        v42 = CFGetTypeID(v5);
        if (v42 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)valuePtr = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
        }
        if ((const __CFNumber *)*MEMORY[0x1E0C9AE50] == v5)
          nw_parameters_set_requires_dnssec_validation(*((nw_parameters_t *)this + 37), 1);
      }
      return;
    }
    if (ExactString != 74720590)
      return;
    if (!v5)
      return;
    *(_QWORD *)valuePtr = *MEMORY[0x1E0C9AE00];
    *(_QWORD *)&valuePtr[8] = 1023;
    *(_QWORD *)&valuePtr[16] = _CFStringGetOrCreateCString(*(const __CFAllocator **)valuePtr, (CFStringRef)v5, v62, (uint64_t *)&valuePtr[8], 0x8000100u);
    if (!*(_QWORD *)&valuePtr[16])
      return;
    nw_parameters_set_tracker_context();
    goto LABEL_302;
  }
  if (ExactString == 60261417)
  {
    if (v5)
      CFBooleanGetValue(v5);
    goto LABEL_269;
  }
  if (ExactString != 61367368)
  {
    if (ExactString == 62186602)
    {
      if (v5)
        CFBooleanGetValue(v5);
      nw_parameters_set_prohibit_encrypted_dns();
    }
    return;
  }
  if (v5)
    CFBooleanGetValue(v5);
  if (CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCF9958) != (const void *)*MEMORY[0x1E0C9AE50])
LABEL_269:
    nw_parameters_set_privacy_proxy_fail_closed_for_unreachable_hosts();
}

void sub_183EF471C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,CFAllocatorRef allocator,uint64_t a32,void *ptr)
{
  void *v33;
  void *v34;

  nw_release(v34);
  nw_release(v33);
  _Unwind_Resume(a1);
}

BOOL ConnectionProtocolAddInputHandler(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v5;
  void *v6;
  uint64_t value;
  _QWORD *v8;
  _QWORD *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  _BOOL8 result;
  const char *v13;
  uint64_t v14;
  NSObject *v15;
  uint32_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v11 = CFNLog::logger;
    result = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    LOWORD(v22) = 0;
    v13 = "protocol is nullptr";
LABEL_36:
    v15 = v11;
    v16 = 2;
    goto LABEL_37;
  }
  v3 = *(_QWORD *)(a1 + 40);
  if (!v3)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v14 = CFNLog::logger;
    result = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
    if (result)
    {
      LODWORD(v22) = 136315138;
      *(_QWORD *)((char *)&v22 + 4) = "ConnectionProtocolAddInputHandler";
      v13 = "Connection is invalid in %s";
      v15 = v14;
      v16 = 12;
LABEL_37:
      _os_log_error_impl(&dword_183ECA000, v15, OS_LOG_TYPE_ERROR, v13, (uint8_t *)&v22, v16);
      return 0;
    }
    return result;
  }
  (*(void (**)(uint64_t))(*(_QWORD *)(a2 + 24) + 112))(a2);
  v5 = (void *)nw_parameters_copy_protocol_value();
  if (v5)
  {
    v6 = v5;
    value = xpc_uint64_get_value(v5);
    xpc_release(v6);
    if (value)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&WeakTracker<TransportConnection>::_lock);
      if (WeakTracker<TransportConnection>::_trackedObjects(void)::onceToken != -1)
        dispatch_once(&WeakTracker<TransportConnection>::_trackedObjects(void)::onceToken, &__block_literal_global_3530);
      v8 = std::__hash_table<std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>>>::find<unsigned long long>((_QWORD *)WeakTracker<TransportConnection>::_trackedObjects(void)::trackedObjects, value);
      if (v8)
      {
        v9 = v8;
        v22 = 0uLL;
        v10 = (std::__shared_weak_count *)v8[4];
        if (v10)
        {
          *((_QWORD *)&v22 + 1) = std::__shared_weak_count::lock(v10);
          if (*((_QWORD *)&v22 + 1))
            *(_QWORD *)&v22 = v9[3];
        }
      }
      else
      {
        v22 = 0uLL;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&WeakTracker<TransportConnection>::_lock);
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v3 + 64, &v22);
      v17 = (std::__shared_weak_count *)*((_QWORD *)&v22 + 1);
      if (*((_QWORD *)&v22 + 1))
      {
        v18 = (unint64_t *)(*((_QWORD *)&v22 + 1) + 8);
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
    }
  }
  v20 = *(_QWORD *)(v3 + 64);
  if (!v20)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v11 = CFNLog::logger;
    result = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    LOWORD(v22) = 0;
    v13 = "Failed to get TransportConnection in addInputHandler";
    goto LABEL_36;
  }
  v21 = *(_QWORD *)(v20 + 120);
  if (v21)
  {
    dispatch_retain(*(dispatch_object_t *)(v20 + 120));
    *(_QWORD *)(v3 + 80) = v21;
    uuid_copy((unsigned __int8 *)a1, (const unsigned __int8 *)a2);
    *(_QWORD *)(a1 + 48) = a2;
    *(_QWORD *)(a2 + 32) = v3;
    return 1;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v11 = CFNLog::logger;
  result = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
  if (result)
  {
    LOWORD(v22) = 0;
    v13 = "Failed to get _workQueue from TransportConnection in addInputHandler";
    goto LABEL_36;
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>>>::find<unsigned long long>(_QWORD *a1, unint64_t a2)
{
  int8x8_t v2;
  uint8x8_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *result;
  unint64_t v7;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (*(_QWORD *)&v2 <= a2)
      v4 = a2 % *(_QWORD *)&v2;
  }
  else
  {
    v4 = (*(_QWORD *)&v2 - 1) & a2;
  }
  v5 = *(_QWORD **)(*a1 + 8 * v4);
  if (!v5)
    return 0;
  result = (_QWORD *)*v5;
  if (*v5)
  {
    do
    {
      v7 = result[1];
      if (v7 == a2)
      {
        if (result[2] == a2)
          return result;
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= *(_QWORD *)&v2)
            v7 %= *(_QWORD *)&v2;
        }
        else
        {
          v7 &= *(_QWORD *)&v2 - 1;
        }
        if (v7 != v4)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

void ___ZN14NWIOConnection22_addConnectionProtocolEv_block_invoke(uint64_t a1)
{
  xpc_release(*(xpc_object_t *)(a1 + 32));
}

uint64_t `non-virtual thunk to'Tube::preConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return Tube::preConnectConfiguration(a1 - 40, a2, a3, a4);
}

{
  return Tube::preConnectConfiguration(a1 - 32, a2, a3, a4);
}

uint64_t Tube::preConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  void *v16;
  CFStringRef v17;
  const void *v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  __int128 v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  const __CFDictionary *v31;
  const void *Value;
  __int128 v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  BOOL v42;
  _BOOL4 v43;
  uint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  __int128 v50;
  _QWORD aBlock[6];
  std::__shared_weak_count *v52;
  uint64_t v53;
  std::__shared_weak_count *v54;

  if (*(int *)(a1 + 220) <= 3)
  {
    *(_DWORD *)(a1 + 220) = 4;
    v6 = *(_QWORD *)(a1 + 112);
    if (v6)
    {
      v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 88))(v6);
      v10 = HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(v9 + 128));
      v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 112) + 80))(*(_QWORD *)(a1 + 112));
      v12 = v11;
      if (v11)
        v13 = v11 - 176;
      else
        v13 = 0;
      if (v11)
        CFRetain((CFTypeRef)(v11 - 192));
      v53 = v13;
      v14 = (std::__shared_weak_count *)operator new();
      v14->__shared_owners_ = 0;
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      v14->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F10F0;
      v14->__shared_weak_owners_ = 0;
      v14[1].__vftable = (std::__shared_weak_count_vtbl *)v13;
      v54 = v14;
      if (v12)
        v12 = *(_QWORD *)(v12 + 432);
      v16 = *(void **)(v13 + 80);
      if (v16 && objc_msgSend(v16, "_requiresSecureHTTPSProxyConnection"))
        *(_DWORD *)(a1 + 88) = 2;
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v17 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)v9, 0x1362735Fu);
      v18 = *(const void **)(a1 + 80);
      *(_QWORD *)(a1 + 80) = v17;
      if (v18)
        CFRelease(v18);
      if (*(_DWORD *)(a1 + 88) == 2)
        goto LABEL_21;
      if (__CFNUseNWHTTPSProxies::useProxyOnce != -1)
        dispatch_once(&__CFNUseNWHTTPSProxies::useProxyOnce, &__block_literal_global_11_4775);
      if (__CFNUseNWHTTPSProxies::useNWHTTPSProxy)
      {
LABEL_21:
        aBlock[0] = MEMORY[0x1E0C809B0];
        aBlock[1] = 3321888768;
        aBlock[2] = ___ZN4Tube23preConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0_U13block_pointerFvvE_block_invoke;
        aBlock[3] = &__block_descriptor_56_e8_40c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e127_v48__0____CFHTTPMessage__8I16____CFString__20i28_SmartBlockWithArgs_const__CFURLCredential____BOOL___v____shared_weak_count__32l;
        aBlock[4] = a1;
        aBlock[5] = v13;
        v52 = v14;
        do
          v19 = __ldxr(p_shared_owners);
        while (__stxr(v19 + 1, p_shared_owners));
        v20 = (_QWORD *)operator new();
        v20[1] = BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::invoke_initial;
        v20[2] = 0;
        *v20 = _Block_copy(aBlock);
        v21 = (_QWORD *)operator new();
        *v21 = &off_1E14F12B0;
        v21[1] = 0;
        v21[2] = 0;
        v21[3] = v20;
        *(_QWORD *)&v22 = v20;
        *((_QWORD *)&v22 + 1) = v21;
        v23 = *(std::__shared_weak_count **)(a1 + 56);
        *(_OWORD *)(a1 + 48) = v22;
        if (v23)
        {
          v24 = (unint64_t *)&v23->__shared_owners_;
          do
            v25 = __ldaxr(v24);
          while (__stlxr(v25 - 1, v24));
          if (!v25)
          {
            ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
            std::__shared_weak_count::__release_weak(v23);
          }
        }
        v26 = *(_QWORD *)(a1 + 48);
        if (v26)
        {
          *(_QWORD *)(v26 + 8) = BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::invoke_normal;
          *(_QWORD *)(v26 + 16) = 0;
        }
        v27 = v52;
        if (v52)
        {
          v28 = (unint64_t *)&v52->__shared_owners_;
          do
            v29 = __ldaxr(v28);
          while (__stlxr(v29 - 1, v28));
          if (!v29)
          {
            ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
            std::__shared_weak_count::__release_weak(v27);
          }
        }
      }
      v30 = v53;
      if (v53)
      {
        if (__CFNIsInDevelopmentEnvironment::onceToken != -1)
          dispatch_once(&__CFNIsInDevelopmentEnvironment::onceToken, &__block_literal_global_21_4777);
        if (__CFNIsInDevelopmentEnvironment::ok)
        {
          v31 = *(const __CFDictionary **)(v30 + 752);
          if (v31 && (Value = CFDictionaryGetValue(v31, CFSTR("__kCFStreamPropertyNWProxyConfigurationBlock"))) != 0)
            SmartBlockWithArgs<void *>::SmartBlockWithArgs((uint64_t *)&v50, Value);
          else
            SmartBlockWithArgs<void *>::SmartBlockWithArgs((uint64_t *)&v50, 0);
          v33 = v50;
          v50 = 0uLL;
          v34 = *(std::__shared_weak_count **)(a1 + 72);
          *(_OWORD *)(a1 + 64) = v33;
          if (v34)
          {
            v35 = (unint64_t *)&v34->__shared_owners_;
            do
              v36 = __ldaxr(v35);
            while (__stlxr(v36 - 1, v35));
            if (!v36)
            {
              ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
              std::__shared_weak_count::__release_weak(v34);
            }
          }
          v37 = (std::__shared_weak_count *)*((_QWORD *)&v50 + 1);
          if (*((_QWORD *)&v50 + 1))
          {
            v38 = (unint64_t *)(*((_QWORD *)&v50 + 1) + 8);
            do
              v39 = __ldaxr(v38);
            while (__stlxr(v39 - 1, v38));
            if (!v39)
            {
              ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
              std::__shared_weak_count::__release_weak(v37);
            }
          }
          v40 = *(_QWORD *)(a1 + 64);
          if (v40)
          {
            v41 = *(_QWORD *)(v40 + 8);
            v42 = !*(_QWORD *)(v40 + 16) || (*(_QWORD *)(v40 + 16) & 1 | v41) == 0;
            v43 = !v42;
            if ((uint64_t (*)())v41 != BlockHolderVar<void *>::invoke_reseted || v43)
            {
              *(_QWORD *)(v40 + 8) = BlockHolderVar<void *>::invoke_normal;
              *(_QWORD *)(v40 + 16) = 0;
            }
          }
        }
      }
      v45 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 136) + 256))(*(_QWORD *)(a1 + 136));
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 32) + 128))(a1 + 32, v45, a2, a3, v10, v12);
      v46 = v54;
      if (v54)
      {
        v47 = (unint64_t *)&v54->__shared_owners_;
        do
          v48 = __ldaxr(v47);
        while (__stlxr(v48 - 1, v47));
        if (!v48)
        {
          ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
          std::__shared_weak_count::__release_weak(v46);
        }
      }
    }
  }
  return (*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
}

void sub_183EF5014(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection16_startConnectionEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  int v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  double v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  const __CFDictionary *Value;
  const void *v16;
  const __CFNumber *v17;
  const __CFNumber *v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  const __CFDictionary *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  NSObject *v44;
  uint64_t v45;
  unint64_t *v46;
  unint64_t v47;
  unint64_t *v48;
  unint64_t v49;
  _QWORD *v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  char v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  unint64_t v57;
  std::__shared_weak_count *v58;
  unint64_t *v59;
  unint64_t v60;
  unint64_t *v61;
  __int128 v62;
  void (*v63)(uint64_t, int, CFTypeRef);
  void *v64;
  uint64_t v65;
  uint64_t v66;
  std::__shared_weak_count *v67;
  uint64_t v68;
  uint64_t v69;
  void *v70;
  void *v71;
  uint64_t v72;
  uint64_t v73;
  std::__shared_weak_count *v74;
  __int128 buf;
  void *v76;
  void *v77;
  uint64_t v78;
  uint64_t v79;
  std::__shared_weak_count *v80;
  uint64_t v81;
  CFStreamError v82;

  v81 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 40);
  if ((*(_WORD *)(v1 + 248) & 0x60) != 0 || (*(_DWORD *)(v1 + 136) - 5) < 3)
    return;
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(unsigned __int16 *)(v3 + 248);
  v5 = v4 | (*(unsigned __int8 *)(v3 + 250) << 16);
  if ((v4 & 0x200) != 0)
  {
    *(_BYTE *)(v3 + 250) = BYTE2(v5);
    *(_WORD *)(v3 + 248) = v5 | 0x800;
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_QWORD *)(v3 + 288);
      LODWORD(buf) = 134217984;
      *(_QWORD *)((char *)&buf + 4) = v7;
      _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, "Connection %llu: enabling TLS", (uint8_t *)&buf, 0xCu);
    }
    if (nw_settings_get_signposts_enabled())
      kdebug_trace();
  }
  v8 = *(_QWORD *)(a1 + 40);
  if (!CFDictionaryGetValue(*(CFDictionaryRef *)(v8 + 368), &unk_1EDCFB868))
  {
    NWIOConnection::_startConnection_Completion((NWIOConnection *)v8);
    return;
  }
  gotLoadHelper_x8__OBJC_CLASS____DASActivity(v9);
  if (objc_opt_class())
  {
    nw_parameters_set_discretionary();
    v10 = *(std::__shared_weak_count **)(v8 + 264);
    if (v10)
    {
      v11 = std::__shared_weak_count::lock(v10);
      if (v11)
      {
        v12 = *(_QWORD *)(v8 + 256);
        goto LABEL_25;
      }
    }
    else
    {
      v11 = 0;
    }
    v12 = 0;
LABEL_25:
    v21 = *(const __CFDictionary **)(v8 + 368);
    v22 = *(_QWORD *)(v8 + 120);
    v24 = *(_QWORD *)(v8 + 296);
    v23 = *(_QWORD *)(v8 + 304);
    v25 = *(_QWORD *)(v8 + 200);
    v26 = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
    *((_QWORD *)&buf + 1) = 3321888768;
    v76 = ___ZN14NWIOConnection30_conditionalSchedulingDASSetupEv_block_invoke;
    v77 = &__block_descriptor_56_e8_40c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE_e9_C16__0_v8l;
    v78 = v8;
    v79 = v12;
    v80 = v11;
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        v28 = __ldxr(p_shared_owners);
      while (__stxr(v28 + 1, p_shared_owners));
    }
    v68 = v26;
    v69 = 3321888768;
    v70 = ___ZN14NWIOConnection30_conditionalSchedulingDASSetupEv_block_invoke_203;
    v71 = &__block_descriptor_56_e8_40c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE_e9_v16__0_v8l;
    v72 = v8;
    v73 = v12;
    v74 = v11;
    if (v11)
    {
      v29 = (unint64_t *)&v11->__shared_owners_;
      do
        v30 = __ldxr(v29);
      while (__stxr(v30 + 1, v29));
    }
    *(_QWORD *)&v62 = v26;
    *((_QWORD *)&v62 + 1) = 3321888768;
    v63 = ___ZN14NWIOConnection30_conditionalSchedulingDASSetupEv_block_invoke_206;
    v64 = &__block_descriptor_56_e8_40c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE_e12_v20__0C8_v12l;
    v65 = v8;
    v66 = v12;
    v67 = v11;
    if (v11)
    {
      v31 = (unint64_t *)&v11->__shared_owners_;
      do
        v32 = __ldxr(v31);
      while (__stxr(v32 + 1, v31));
    }
    __ConditionalConnectionDUETSupport_StartActivity(v21, v22, v23, v24, v25, (uint64_t)&buf, (uint64_t)&v68, (uint64_t)&v62);
    v33 = v67;
    if (v67)
    {
      v34 = (unint64_t *)&v67->__shared_owners_;
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }
    v36 = v74;
    if (v74)
    {
      v37 = (unint64_t *)&v74->__shared_owners_;
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }
    v39 = v80;
    if (v80)
    {
      v40 = (unint64_t *)&v80->__shared_owners_;
      do
        v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
    if (v11)
    {
      v42 = (unint64_t *)&v11->__shared_owners_;
      do
        v43 = __ldaxr(v42);
      while (__stlxr(v43 - 1, v42));
LABEL_81:
      if (!v43)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
      return;
    }
    return;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v13 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v14 = *(_QWORD *)(v8 + 288);
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = v14;
    _os_log_impl(&dword_183ECA000, v13, OS_LOG_TYPE_DEFAULT, "Connection %llu: setting up SIM scheduler", (uint8_t *)&buf, 0xCu);
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v8 + 368), &unk_1EDCFB868);
  v16 = CFDictionaryGetValue(Value, CFSTR("kConditionalConnectionRequirementTimeWindowStartTime"));
  v17 = (const __CFNumber *)CFDictionaryGetValue(Value, CFSTR("kConditionalConnectionRequirementTimeWindowDelay"));
  v18 = (const __CFNumber *)CFDictionaryGetValue(Value, CFSTR("kConditionalConnectionRequirementTimeWindowDuration"));
  nw_parameters_set_indefinite();
  v19 = *(std::__shared_weak_count **)(v8 + 264);
  if (v19)
  {
    v11 = std::__shared_weak_count::lock(v19);
    if (v11)
    {
      v20 = *(_QWORD *)(v8 + 256);
      goto LABEL_55;
    }
  }
  else
  {
    v11 = 0;
  }
  v20 = 0;
LABEL_55:
  v44 = *(NSObject **)(v8 + 120);
  v45 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
  *((_QWORD *)&buf + 1) = 3321888768;
  v76 = ___ZN14NWIOConnection30_conditionalSchedulingSIMSetupEv_block_invoke;
  v77 = &__block_descriptor_56_e8_40c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE_e5_v8__0l;
  v78 = v8;
  v79 = v20;
  v80 = v11;
  if (v11)
  {
    v46 = (unint64_t *)&v11->__shared_owners_;
    do
      v47 = __ldxr(v46);
    while (__stxr(v47 + 1, v46));
  }
  v68 = v45;
  v69 = 3321888768;
  v70 = ___ZN14NWIOConnection30_conditionalSchedulingSIMSetupEv_block_invoke_2;
  v71 = &__block_descriptor_56_e8_40c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE_e5_v8__0l;
  v72 = v8;
  v73 = v20;
  v74 = v11;
  if (v11)
  {
    v48 = (unint64_t *)&v11->__shared_owners_;
    do
      v49 = __ldxr(v48);
    while (__stxr(v49 + 1, v48));
  }
  v50 = operator new(0x80uLL);
  v50[1] = 0;
  v50[2] = 0;
  *v50 = &off_1E14F0EF8;
  ConditionalConnectionSIMScheduler::ConditionalConnectionSIMScheduler((uint64_t)(v50 + 3), (uint64_t)v16, v17, v18, v44, &buf, &v68);
  *(_QWORD *)&v62 = v50 + 3;
  *((_QWORD *)&v62 + 1) = v50;
  std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&v62, (_QWORD *)v62, v62);
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v8 + 600, &v62);
  v51 = (std::__shared_weak_count *)*((_QWORD *)&v62 + 1);
  if (*((_QWORD *)&v62 + 1))
  {
    v52 = (unint64_t *)(*((_QWORD *)&v62 + 1) + 8);
    do
      v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }
  ConditionalConnectionSIMScheduler::start(*(ConditionalConnectionSIMScheduler **)(v8 + 600));
  if ((v54 & 1) == 0)
  {
    v82.domain = 1;
    *(_QWORD *)&v82.error = 22;
    NWIOConnection::_handleError((NWIOConnection *)v8, v82);
  }
  v55 = v74;
  if (v74)
  {
    v56 = (unint64_t *)&v74->__shared_owners_;
    do
      v57 = __ldaxr(v56);
    while (__stlxr(v57 - 1, v56));
    if (!v57)
    {
      ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
      std::__shared_weak_count::__release_weak(v55);
    }
  }
  v58 = v80;
  if (v80)
  {
    v59 = (unint64_t *)&v80->__shared_owners_;
    do
      v60 = __ldaxr(v59);
    while (__stlxr(v60 - 1, v59));
    if (!v60)
    {
      ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
      std::__shared_weak_count::__release_weak(v58);
    }
  }
  if (v11)
  {
    v61 = (unint64_t *)&v11->__shared_owners_;
    do
      v43 = __ldaxr(v61);
    while (__stlxr(v43 - 1, v61));
    goto LABEL_81;
  }
}

void sub_183EF5694(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,std::__shared_weak_count *a29)
{
  std::__shared_weak_count *v29;
  unint64_t *p_shared_owners;
  unint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;

  if (a22)
  {
    p_shared_owners = (unint64_t *)&a22->__shared_owners_;
    do
      v32 = __ldaxr(p_shared_owners);
    while (__stlxr(v32 - 1, p_shared_owners));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))a22->__on_zero_shared)(a22);
      std::__shared_weak_count::__release_weak(a22);
    }
  }
  if (a29)
  {
    v33 = (unint64_t *)&a29->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))a29->__on_zero_shared)(a29);
      std::__shared_weak_count::__release_weak(a29);
    }
  }
  if (v29)
  {
    v35 = (unint64_t *)&v29->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  _Unwind_Resume(exception_object);
}

void ProxyConnectionEstablishment::preProxyConnectionConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, std::__shared_weak_count_vtbl *a4, const __CFURL *a5, uint64_t a6)
{
  uint64_t v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  BOOL v16;
  _BOOL4 v17;
  _QWORD *v18;
  const void *v19;
  const void *options;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  const __CFString *v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  std::__shared_weak_count *v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  const __CFAllocator *allocator;
  uint64_t v38;
  void *ptr;
  UInt8 v40[1024];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  ProxyConnectionEstablishment::SetProxyURL(a5, a3, (uint64_t)a4);
  if (a6)
    ProxyConnectionEstablishment::SetProxies(a3, (uint64_t)a4, a6);
  if (*(_DWORD *)(a1 + 56) == 2)
    goto LABEL_7;
  if (__CFNUseNWHTTPSProxies::useProxyOnce != -1)
    dispatch_once(&__CFNUseNWHTTPSProxies::useProxyOnce, &__block_literal_global_11_4775);
  if (__CFNUseNWHTTPSProxies::useNWHTTPSProxy)
  {
LABEL_7:
    v36 = 0;
    if (a3)
    {
      v10 = tcp_connection_copy_parameters();
      v11 = (std::__shared_weak_count *)operator new();
      v11->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1CF8;
      v11->__shared_owners_ = 0;
      v11->__shared_weak_owners_ = 0;
      v11[1].__vftable = (std::__shared_weak_count_vtbl *)v10;
      v35 = v10;
      v36 = v11;
      if (v10)
        goto LABEL_12;
    }
    else if (a4)
    {
      nw_retain(a4);
      v12 = (std::__shared_weak_count *)operator new();
      v12->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1CF8;
      v12->__shared_owners_ = 0;
      v12->__shared_weak_owners_ = 0;
      v12[1].__vftable = a4;
      v35 = (uint64_t)a4;
      v36 = v12;
LABEL_12:
      if (*(_DWORD *)(a1 + 56) == 2)
      {
        nw_parameters_set_https_proxy_over_tls();
        if (__CFNIsInDevelopmentEnvironment::onceToken != -1)
          dispatch_once(&__CFNIsInDevelopmentEnvironment::onceToken, &__block_literal_global_21_4777);
        if (__CFNIsInDevelopmentEnvironment::ok)
        {
          v13 = *(_QWORD *)(a1 + 32);
          if (v13)
          {
            v14 = *(_QWORD *)(v13 + 8);
            v15 = *(_QWORD *)(v13 + 16);
            v16 = !v15 || (*(_QWORD *)(v13 + 16) & 1 | v14) == 0;
            v17 = !v16;
            if ((uint64_t (*)())v14 != BlockHolderVar<void *>::invoke_reseted || v17)
            {
              v18 = (_QWORD *)(v13 + (v15 >> 1));
              if ((v15 & 1) != 0)
                v14 = *(_QWORD *)(*v18 + v14);
              ((void (*)(_QWORD *, uint64_t))v14)(v18, v35);
            }
          }
        }
      }
      v19 = (const void *)nw_proxy_copy_http_connect_definition();
      if (v19)
      {
        options = (const void *)nw_proxy_create_options();
        if (options)
        {
          v21 = *(std::__shared_weak_count **)(a1 + 24);
          v34 = v21;
          if (v21)
          {
            p_shared_owners = (unint64_t *)&v21->__shared_owners_;
            do
              v23 = __ldxr(p_shared_owners);
            while (__stxr(v23 + 1, p_shared_owners));
          }
          v33 = v21;
          if (v21)
          {
            v24 = (unint64_t *)&v21->__shared_owners_;
            do
              v25 = __ldxr(v24);
            while (__stxr(v25 + 1, v24));
          }
          nw_proxy_options_set_authentication_challenge_handler();
          v26 = *(const __CFString **)(a1 + 48);
          if (v26)
          {
            allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
            v38 = 1023;
            ptr = _CFStringGetOrCreateCString(allocator, v26, v40, &v38, 0x8000100u);
            nw_proxy_options_set_http_proxy_authorization_header();
            if (ptr)
            {
              if (v40 != ptr)
                CFAllocatorDeallocate(allocator, ptr);
            }
          }
          nw_parameters_add_proxy_options();
          if (v33)
          {
            v27 = (unint64_t *)&v33->__shared_owners_;
            do
              v28 = __ldaxr(v27);
            while (__stlxr(v28 - 1, v27));
            if (!v28)
            {
              ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
              std::__shared_weak_count::__release_weak(v33);
            }
          }
          if (v34)
          {
            v29 = (unint64_t *)&v34->__shared_owners_;
            do
              v30 = __ldaxr(v29);
            while (__stlxr(v30 - 1, v29));
            if (!v30)
            {
              ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
              std::__shared_weak_count::__release_weak(v34);
            }
          }
          CFRelease(options);
        }
        CFRelease(v19);
      }
    }
    if (v36)
    {
      v31 = (unint64_t *)&v36->__shared_owners_;
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }
    return;
  }
  if (a4)
    nw_parameters_set_https_proxy_is_opaque();
}

void sub_183EF5CC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,CFAllocatorRef allocator,uint64_t a22,void *ptr)
{
  void *v23;
  const void *v24;
  const void *v25;

  if (ptr)
  {
    if (v23 != ptr)
      CFAllocatorDeallocate(allocator, ptr);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a15);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  CFRelease(v25);
  CFRelease(v24);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a19);
  _Unwind_Resume(a1);
}

void ProxyConnectionEstablishment::SetProxyURL(const __CFURL *a1, uint64_t a2, uint64_t a3)
{
  const __CFString *v5;
  UInt8 *v6;
  uint64_t v7;
  void *ptr;
  UInt8 v9[1024];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v5 = CFURLGetString(a1);
    if (v5)
    {
      v7 = 1023;
      v6 = _CFStringGetOrCreateCString(0, v5, v9, &v7, 0x8000100u);
      ptr = v6;
      if (a2)
      {
        tcp_connection_set_url();
        v6 = (UInt8 *)ptr;
      }
      if (a3)
      {
        nw_parameters_set_url();
        v6 = (UInt8 *)ptr;
      }
      if (v6)
      {
        if (v9 != v6)
          CFAllocatorDeallocate(0, v6);
      }
    }
  }
}

void sub_183EF5E18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFAllocatorRef allocator, uint64_t a10, void *ptr)
{
  _Unwind_Resume(exception_object);
}

void TransportConnection::_flushPendingTaskAssociations(TransportConnection *this)
{
  void *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  _BYTE v11[128];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v1 = (void *)*((_QWORD *)this + 28);
  if (v1)
  {
    v9 = 0u;
    v10 = 0u;
    v7 = 0u;
    v8 = 0u;
    v3 = objc_msgSend(v1, "countByEnumeratingWithState:objects:count:", &v7, v11, 16);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)v8;
      do
      {
        v6 = 0;
        do
        {
          if (*(_QWORD *)v8 != v5)
            objc_enumerationMutation(v1);
          (*(void (**)(TransportConnection *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)this + 280))(this, objc_msgSend(*(id *)(*((_QWORD *)&v7 + 1) + 8 * v6), "objectForKeyedSubscript:", CFSTR("Task")), objc_msgSend((id)objc_msgSend(*(id *)(*((_QWORD *)&v7 + 1) + 8 * v6), "objectForKeyedSubscript:", CFSTR("Event")), "intValue"), 0);
          ++v6;
        }
        while (v4 != v6);
        v4 = objc_msgSend(v1, "countByEnumeratingWithState:objects:count:", &v7, v11, 16);
      }
      while (v4);
    }

    *((_QWORD *)this + 28) = 0;
  }
}

uint64_t *SmartBlockWithArgs<void *>::SmartBlockWithArgs(uint64_t *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  v4 = (_QWORD *)operator new();
  v4[1] = BlockHolderVar<void *>::invoke_initial;
  v4[2] = 0;
  *v4 = _Block_copy(a2);
  *a1 = (uint64_t)v4;
  v5 = (_QWORD *)operator new();
  *v5 = &off_1E14F13C8;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a1[1] = (uint64_t)v5;
  if (!a2)
  {
    v6 = *a1;
    *(_QWORD *)(v6 + 8) = BlockHolderVar<void *>::invoke_reseted;
    *(_QWORD *)(v6 + 16) = 0;
  }
  return a1;
}

void sub_183EF6034(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void NWIOConnection::_applyPropertyToConnection_EventHandlerExcessiveKeepalive(uint64_t a1, uint64_t a2)
{
  const __CFDictionary *Value;
  const __CFDictionary *v5;
  const __CFBoolean *v6;
  unint64_t v7;
  const __CFNumber *v8;
  const __CFNumber *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  _QWORD v17[2];
  uint64_t valuePtr;

  if (*(_QWORD *)(a1 + 272))
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EDCFA480);
    if (Value)
    {
      v5 = Value;
      valuePtr = 0;
      v6 = (const __CFBoolean *)CFDictionaryGetValue(Value, CFSTR("_kExcessiveKeepalivesParametersEnabled"));
      if (v6)
        v7 = CFBooleanGetValue(v6) != 0;
      else
        v7 = 0;
      v8 = (const __CFNumber *)CFDictionaryGetValue(v5, CFSTR("_kExcessiveKeepalivesParametersInterval"));
      if (v8)
        CFNumberGetValue(v8, kCFNumberSInt32Type, (char *)&valuePtr + 4);
      v9 = (const __CFNumber *)CFDictionaryGetValue(v5, CFSTR("_kExcessiveKeepalivesParametersCount"));
      if (v9)
        CFNumberGetValue(v9, kCFNumberSInt32Type, &valuePtr);
      if ((_DWORD)v7)
      {
        v10 = *(_QWORD *)(a1 + 256);
        v11 = *(std::__shared_weak_count **)(a1 + 264);
        if (v11)
        {
          p_shared_weak_owners = (unint64_t *)&v11->__shared_weak_owners_;
          do
            v13 = __ldxr(p_shared_weak_owners);
          while (__stxr(v13 + 1, p_shared_weak_owners));
        }
        if (!a2)
        {
          v7 = (unint64_t)v17;
          v17[0] = v10;
          v17[1] = v11;
          if (v11)
          {
            v14 = (unint64_t *)&v11->__shared_weak_owners_;
            do
              v15 = __ldxr(v14);
            while (__stxr(v15 + 1, v14));
          }
        }
        nw_connection_set_excessive_keepalive_handler();
        if (!a2)
        {
          v16 = *(std::__shared_weak_count **)(v7 + 8);
          if (v16)
            std::__shared_weak_count::__release_weak(v16);
        }
        if (v11)
          std::__shared_weak_count::__release_weak(v11);
      }
      else
      {
        nw_connection_set_excessive_keepalive_handler();
      }
    }
  }
}

void sub_183EF61CC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v5;

  if (!v1)
  {
    v5 = *(std::__shared_weak_count **)(v3 + 8);
    if (v5)
      std::__shared_weak_count::__release_weak(v5);
  }
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  _Unwind_Resume(exception_object);
}

void NWIOConnection::_applyPropertyToConnection_EventHandlerLowThroughput(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v3;
  const __CFNumber *Value;
  BOOL v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_weak_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  _QWORD v16[2];
  int valuePtr;

  if (*(_QWORD *)(a1 + 272))
  {
    valuePtr = 0;
    Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EDCFA678);
    if (Value)
      v8 = 1;
    else
      v8 = a3 == 0;
    if (v8)
    {
      if (!Value || !CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr))
        return;
    }
    else
    {
      valuePtr = 0;
    }
    v9 = *(_QWORD *)(a1 + 256);
    v10 = *(std::__shared_weak_count **)(a1 + 264);
    if (v10)
    {
      p_shared_weak_owners = (unint64_t *)&v10->__shared_weak_owners_;
      do
        v12 = __ldxr(p_shared_weak_owners);
      while (__stxr(v12 + 1, p_shared_weak_owners));
    }
    if (!a2)
    {
      v3 = v16;
      v16[0] = v9;
      v16[1] = v10;
      if (v10)
      {
        v13 = (unint64_t *)&v10->__shared_weak_owners_;
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
      }
    }
    nw_connection_set_low_throughput_handler();
    if (!a2)
    {
      v15 = (std::__shared_weak_count *)v3[1];
      if (v15)
        std::__shared_weak_count::__release_weak(v15);
    }
    if (v10)
      std::__shared_weak_count::__release_weak(v10);
  }
}

void sub_183EF6310(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v5;

  if (!v1)
  {
    v5 = *(std::__shared_weak_count **)(v3 + 8);
    if (v5)
      std::__shared_weak_count::__release_weak(v5);
  }
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  _Unwind_Resume(exception_object);
}

void NWIOConnection::_applyPropertyToConnection_EventHandlerAdaptiveWrite(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  const __CFNumber *Value;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_weak_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  _QWORD v15[2];
  int valuePtr;

  if (*(_QWORD *)(a1 + 272))
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EDCFAD08);
    if (Value)
    {
      if (Value == (const __CFNumber *)*MEMORY[0x1E0C9B0D0])
      {
        nw_connection_set_adaptive_write_handler();
      }
      else
      {
        valuePtr = 0;
        CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
        v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_123, 2);
        if (v6)
        {
          v7 = v6;
          if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v6 + 16))(v6, "updateTCPAdaptiveParameters", 0))
          {
            NWIOConnection::_toDiagnosticLog((NSObject **)a1, v7);
            (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v7 + 72))(v7, "Write Count", CFSTR("%d"));
            (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
          }
        }
        v8 = *(_QWORD *)(a1 + 256);
        v9 = *(std::__shared_weak_count **)(a1 + 264);
        if (v9)
        {
          p_shared_weak_owners = (unint64_t *)&v9->__shared_weak_owners_;
          do
            v11 = __ldxr(p_shared_weak_owners);
          while (__stxr(v11 + 1, p_shared_weak_owners));
        }
        if (!a2)
        {
          v2 = v15;
          v15[0] = v8;
          v15[1] = v9;
          if (v9)
          {
            v12 = (unint64_t *)&v9->__shared_weak_owners_;
            do
              v13 = __ldxr(v12);
            while (__stxr(v13 + 1, v12));
          }
        }
        nw_connection_set_adaptive_write_handler();
        if (!a2)
        {
          v14 = (std::__shared_weak_count *)v2[1];
          if (v14)
            std::__shared_weak_count::__release_weak(v14);
        }
        if (v9)
          std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
}

void sub_183EF64E4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v5;

  if (!v1)
  {
    v5 = *(std::__shared_weak_count **)(v3 + 8);
    if (v5)
      std::__shared_weak_count::__release_weak(v5);
  }
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  _Unwind_Resume(exception_object);
}

void NWIOConnection::_applyPropertyToConnection_EventHandlerAdaptiveRead(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  const __CFNumber *Value;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_weak_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  _QWORD v15[2];
  int valuePtr;

  if (*(_QWORD *)(a1 + 272))
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EDCFACD0);
    if (Value)
    {
      if (Value == (const __CFNumber *)*MEMORY[0x1E0C9B0D0])
      {
        nw_connection_set_adaptive_read_handler();
      }
      else
      {
        valuePtr = 0;
        CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
        v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_118, 2);
        if (v6)
        {
          v7 = v6;
          if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v6 + 16))(v6, "updateTCPAdaptiveParameters", 0))
          {
            NWIOConnection::_toDiagnosticLog((NSObject **)a1, v7);
            (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v7 + 72))(v7, "Read Count", CFSTR("%d"));
            (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
          }
        }
        v8 = *(_QWORD *)(a1 + 256);
        v9 = *(std::__shared_weak_count **)(a1 + 264);
        if (v9)
        {
          p_shared_weak_owners = (unint64_t *)&v9->__shared_weak_owners_;
          do
            v11 = __ldxr(p_shared_weak_owners);
          while (__stxr(v11 + 1, p_shared_weak_owners));
        }
        if (!a2)
        {
          v2 = v15;
          v15[0] = v8;
          v15[1] = v9;
          if (v9)
          {
            v12 = (unint64_t *)&v9->__shared_weak_owners_;
            do
              v13 = __ldxr(v12);
            while (__stxr(v13 + 1, v12));
          }
        }
        nw_connection_set_adaptive_read_handler();
        if (!a2)
        {
          v14 = (std::__shared_weak_count *)v2[1];
          if (v14)
            std::__shared_weak_count::__release_weak(v14);
        }
        if (v9)
          std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
}

void sub_183EF66B8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v5;

  if (!v1)
  {
    v5 = *(std::__shared_weak_count **)(v3 + 8);
    if (v5)
      std::__shared_weak_count::__release_weak(v5);
  }
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  _Unwind_Resume(exception_object);
}

uint64_t NWIOConnection::_signalEstablished(NWIOConnection *this)
{
  uint64_t v2;
  id v3;
  uint64_t v4;
  void *v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  int privacy_stance;
  uint64_t v14;
  void *v15;
  NSObject *v16;
  uint64_t v17;
  int v18;
  int v19;
  char *v20;
  __int16 v21;
  _BYTE v23[24];
  void *v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 25);
  if (v2)
  {
    v3 = *(id *)(v2 + 40);
    if (v3)
    {
      *(CFAbsoluteTime *)(v2 + 96) = CFAbsoluteTimeGetCurrent();
      v4 = nw_connection_copy_connected_local_endpoint();
      v5 = *(void **)(v2 + 136);
      *(_QWORD *)(v2 + 136) = v4;

      v6 = nw_connection_copy_connected_path();
      if (v6)
      {
        v7 = nw_path_copy_interface();
        v8 = v7;
        if (v7)
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", nw_interface_get_name(v7));
          v9 = objc_claimAutoreleasedReturnValue();
          v10 = *(void **)(v2 + 152);
          *(_QWORD *)(v2 + 152) = v9;

        }
        *(_BYTE *)(v2 + 15) = nw_path_uses_interface_type(v6, nw_interface_type_cellular);
        *(_BYTE *)(v2 + 16) = nw_path_is_expensive(v6);
        *(_BYTE *)(v2 + 17) = nw_path_is_constrained(v6);
      }

      *(_BYTE *)(v2 + 18) = nw_connection_uses_multipath();
      *(_BYTE *)(v2 + 19) = nw_connection_used_tfo();
      *(_BYTE *)(v2 + 20) = nw_connection_is_unlisted_tracker();
      v11 = nw_connection_copy_establishment_report_on_queue();
      v12 = *(void **)(v2 + 168);
      *(_QWORD *)(v2 + 168) = v11;

      privacy_stance = nw_connection_get_privacy_stance();
      *(_DWORD *)(v2 + 32) = privacy_stance;
      if (privacy_stance == 2)
      {
        if (*(_QWORD *)(v2 + 168))
        {
          *(_QWORD *)v23 = MEMORY[0x1E0C809B0];
          *(_QWORD *)&v23[8] = 3221225472;
          *(_QWORD *)&v23[16] = __36____CFN_ConnectionMetrics_establish__block_invoke;
          v24 = &unk_1E14FB720;
          v25 = v2;
          nw_establishment_report_enumerate_proxied_next_hop_endpoints();
        }
      }
      else
      {
        v14 = nw_connection_copy_connected_remote_endpoint();
        v15 = *(void **)(v2 + 144);
        *(_QWORD *)(v2 + 144) = v14;

      }
    }

  }
  if (!*((_QWORD *)this + 18))
    __assert_rtn("_signalEstablished", "NWIOConnection.cpp", 6038, "_establishmentDelegate");
  if (!*((_QWORD *)this + 47) && !*((_DWORD *)this + 96))
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v16 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v17 = *((_QWORD *)this + 36);
      if (NWIOConnection::_isCellular(this))
        v18 = 89;
      else
        v18 = 78;
      *(_DWORD *)v23 = 134218496;
      if (NWIOConnection::_isExpensive(this))
        v19 = 89;
      else
        v19 = 78;
      *(_QWORD *)&v23[4] = v17;
      *(_WORD *)&v23[12] = 1024;
      *(_DWORD *)&v23[14] = v18;
      *(_WORD *)&v23[18] = 1024;
      *(_DWORD *)&v23[20] = v19;
      _os_log_impl(&dword_183ECA000, v16, OS_LOG_TYPE_DEFAULT, "Connection %llu: ready C(%c) E(%c)", v23, 0x18u);
    }
  }
  v21 = *((_WORD *)this + 124);
  v20 = (char *)this + 248;
  *(_WORD *)v20 = v21 | 0x10;
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)v20 - 13) + 48))(*((_QWORD *)v20 - 13), *((_QWORD *)v20 + 16), *((_QWORD *)v20 + 17));
}

void sub_183EF69B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void Tube::_onqueue_invokeCB(Tube *this, CFStreamError a2)
{
  SInt32 error;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFError *CFErrorWithStreamError;
  void (**v8)(_QWORD, _QWORD, _QWORD, _QWORD);
  CFStreamError v9;

  v9 = a2;
  if (!*((_QWORD *)this + 16))
    return;
  error = a2.error;
  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  if (!*((_QWORD *)this + 17))
    goto LABEL_13;
  if (*((_BYTE *)this + 120))
  {
    v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 14) + 80))(*((_QWORD *)this + 14));
    v5 = *((_QWORD *)this + 17);
    if (v5)
    {
      if (v4)
        v6 = v4 - 176;
      else
        v6 = 0;
      (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD))(*(_QWORD *)v5 + 280))(v5, *(_QWORD *)(v6 + 80), 1, 0);
    }
    *((_BYTE *)this + 120) = 0;
  }
  if (!*((_BYTE *)this + 296))
  {
    TransportConnection::rstConnectionEstablishmentDelegate(*((TransportConnection **)this + 17));
    if (error)
    {
LABEL_14:
      CFErrorWithStreamError = __cfnCreateCFErrorWithStreamError((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (int *)&v9);
      Tube::_notifyOfTubeType(this, CFErrorWithStreamError);
      if (CFErrorWithStreamError)
        CFRelease(CFErrorWithStreamError);
      goto LABEL_18;
    }
  }
  else
  {
LABEL_13:
    if (error)
      goto LABEL_14;
  }
  Tube::_notifyOfTubeType(this, 0);
LABEL_18:
  if (v9.error)
    Tube::_onqueue_cleanupConnection(this);
  v8 = (void (**)(_QWORD, _QWORD, _QWORD, _QWORD))*((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  ((void (**)(_QWORD, Tube *, CFIndex, _QWORD))v8)[2](v8, this, v9.domain, *(_QWORD *)&v9.error);
  _Block_release(v8);
}

void `non-virtual thunk to'Tube::connectionEstablished(Tube *this, CFStreamError a2)
{
  Tube::connectionEstablished((Tube *)((char *)this - 40), a2);
}

{
  Tube::connectionEstablished((Tube *)((char *)this - 32), a2);
}

void Tube::_notifyOfTubeType(Tube *this, __CFError *a2)
{
  uint64_t v4;
  const __CFString *v5;
  const void *v6;
  uint64_t v7;
  const void *v8;
  const __CFString *v9;
  CFStringRef v10;

  if (GlueTube::notifyOfTubeType)
  {
    v4 = *((unsigned int *)this + 46);
    if (v4 > 3)
      v5 = CFSTR("Unknown");
    else
      v5 = off_1E14F9940[v4];
    v6 = (const void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 16))(*((_QWORD *)this + 13));
    v7 = *((_QWORD *)this + 17);
    if (v7)
      v8 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 216))(v7, 0x1EDCFA720);
    else
      v8 = 0;
    v9 = CFSTR("YES");
    if (!v8)
      v9 = CFSTR("NO");
    v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@, ALPN supported %@, Tube type: %@"), v6, v9, v5);
    (*(void (**)(uint64_t, CFStringRef, __CFError *))(GlueTube::notifyOfTubeType + 16))(GlueTube::notifyOfTubeType, v10, a2);
    if (v10)
      CFRelease(v10);
    if (v8)
      CFRelease(v8);
    if (v6)
      CFRelease(v6);
  }
}

void sub_183EF6C64(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void sub_183EF6CA0()
{
  uint64_t v0;

  if (v0)
    JUMPOUT(0x183EF6CA8);
  JUMPOUT(0x183EF6C7CLL);
}

uint64_t ConnectionProtocolConnect(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  void (*v10)(void);
  uint64_t v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  nw_endpoint_type_t type;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const __CFArray *v24;
  const __CFAllocator *v25;
  __CFArray *MutableCopy;
  const __CFArray *v27;
  CFArrayRef Copy;
  void *v29;
  uint64_t v30;
  void (*v31)(void);
  uint64_t v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t *v38;
  unint64_t v39;
  uint64_t v40;
  void (*v41)(void);
  uint64_t v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  _QWORD v47[5];
  std::__shared_weak_count *v48;
  void *value;
  __int128 buf;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v11 = CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      return 0;
    LOWORD(buf) = 0;
    v12 = "protocol is nullptr";
    v13 = v11;
    v14 = 2;
    goto LABEL_34;
  }
  v3 = a1[5];
  if (!v3)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v15 = CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      return 0;
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = "ConnectionProtocolConnect";
    v12 = "Connection is invalid in %s";
    v13 = v15;
    v14 = 12;
LABEL_34:
    _os_log_error_impl(&dword_183ECA000, v13, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&buf, v14);
    return 0;
  }
  v5 = *(_QWORD *)(v3 + 64);
  v6 = *(std::__shared_weak_count **)(v3 + 72);
  *(_QWORD *)&buf = v5;
  *((_QWORD *)&buf + 1) = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  if (!v5 || ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 264))(v5) & 1) != 0)
  {
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 360))(v5))
    {
      v9 = a1[6];
      if (v9)
      {
        v10 = *(void (**)(void))(*(_QWORD *)(v9 + 24) + 56);
        if (v10)
          v10();
      }
      goto LABEL_55;
    }
    v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a2 + 24) + 136))(a2);
    type = nw_endpoint_get_type(v17);
    v19 = (void *)nw_endpoint_copy_proxy_original_endpoint();
    if (v19)
    {
      nw_release(v19);
    }
    else if (type == nw_endpoint_type_address)
    {
      v23 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a2 + 24) + 120))(a2);
      (*(void (**)(void **__return_ptr, uint64_t, uint64_t, NSObject *, uint64_t))(*(_QWORD *)v5 + 400))(&value, v5, v23, v17, 1);
      if (!value || v23 && (nw_path_is_per_app_vpn() & 1) != 0)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 368))(v5);
      }
      else
      {
        v24 = (const __CFArray *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 216))(v5, 0x1EDCF93E0);
        v25 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        if (v24)
          MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v24);
        else
          MutableCopy = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
        v27 = MutableCopy;
        CFArrayAppendValue(MutableCopy, value);
        Copy = CFArrayCreateCopy(v25, v27);
        (*(void (**)(uint64_t, uint64_t, CFArrayRef))(*(_QWORD *)v5 + 200))(v5, 0x1EDCF93E0, Copy);
        if (Copy)
          CFRelease(Copy);
        if (v27)
          CFRelease(v27);
        if (v24)
          CFRelease(v24);
      }
      v29 = value;
      value = 0;
      if (v29)
        CFRelease(v29);
LABEL_46:
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 360))(v5))
      {
        v30 = a1[6];
        if (v30)
        {
          v31 = *(void (**)(void))(*(_QWORD *)(v30 + 24) + 56);
          if (v31)
            v31();
        }
        goto LABEL_55;
      }
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 376))(v5))
      {
        v32 = a1[4];
        if (v32)
        {
          v33 = *(_QWORD *)(v32 + 24);
          if (v33)
          {
            v22 = (*(uint64_t (**)(void))(v33 + 24))();
            goto LABEL_54;
          }
        }
LABEL_55:
        v16 = 0;
        goto LABEL_56;
      }
      v47[0] = MEMORY[0x1E0C809B0];
      v47[1] = 3321888768;
      v47[2] = ___ZL25ConnectionProtocolConnectP11nw_protocolS0__block_invoke;
      v47[3] = &__block_descriptor_48_e8_32c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE_e45_v24__0____CFDictionary__8____CFDictionary__16l;
      v47[4] = v5;
      v48 = v6;
      if (v6)
      {
        v38 = (unint64_t *)&v6->__shared_owners_;
        do
          v39 = __ldxr(v38);
        while (__stxr(v39 + 1, v38));
      }
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v5 + 336))(v5, v47);
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 360))(v5))
      {
        v40 = a1[6];
        if (v40)
        {
          v41 = *(void (**)(void))(*(_QWORD *)(v40 + 24) + 56);
          if (v41)
            v41();
        }
      }
      else
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 368))(v5);
        v42 = a1[4];
        if (v42)
        {
          v43 = *(_QWORD *)(v42 + 24);
          if (v43)
          {
            v16 = (*(uint64_t (**)(void))(v43 + 24))();
LABEL_73:
            v44 = v48;
            if (v48)
            {
              v45 = (unint64_t *)&v48->__shared_owners_;
              do
                v46 = __ldaxr(v45);
              while (__stlxr(v46 - 1, v45));
              if (!v46)
              {
                ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
                std::__shared_weak_count::__release_weak(v44);
              }
            }
            goto LABEL_56;
          }
        }
      }
      v16 = 0;
      goto LABEL_73;
    }
    if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 360))(v5) & 1) == 0
      && ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 376))(v5) & 1) == 0)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 368))(v5);
    }
    goto LABEL_46;
  }
  v20 = a1[4];
  if (!v20)
    goto LABEL_55;
  v21 = *(_QWORD *)(v20 + 24);
  if (!v21)
    goto LABEL_55;
  v22 = (*(uint64_t (**)(void))(v21 + 24))();
LABEL_54:
  v16 = v22;
LABEL_56:
  v34 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
  if (*((_QWORD *)&buf + 1))
  {
    v35 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  return v16;
}

void sub_183EF7208(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef cf, char a17)
{
  const void *v17;
  const void *v18;
  const void *v19;

  if (v19)
  {
    CFRelease(v19);
    if (!v18)
    {
LABEL_3:
      if (!v17)
      {
LABEL_8:
        if (cf)
          CFRelease(cf);
        std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
        _Unwind_Resume(a1);
      }
LABEL_7:
      CFRelease(v17);
      goto LABEL_8;
    }
  }
  else if (!v18)
  {
    goto LABEL_3;
  }
  CFRelease(v18);
  if (!v17)
    goto LABEL_8;
  goto LABEL_7;
}

void Tube::connectionEstablished(Tube *this, CFStreamError a2)
{
  uint64_t v2;
  CFIndex domain;
  uint64_t v5;
  uint64_t v6;
  const __CFDictionary *v7;
  const void *v8;
  __CFDictionary *Mutable;
  const void *v10;
  const void *v11;
  __CFDictionary *v12;
  const void *v13;
  const void *v14;
  __CFDictionary *v15;
  const void *v16;
  const void *v17;
  __CFDictionary *v18;
  const void *v19;
  const void *v20;
  __CFDictionary *v21;
  const void *v22;
  const void *v23;
  void (*v24)(uint64_t);
  __CFDictionary *v25;
  const void *v26;
  Tube *v27;
  CFStreamError v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const __CFDictionary *v33;
  std::__shared_weak_count *v34;
  unint64_t *p_shared_owners;
  unint64_t v36;
  const void *v37;
  const void *v38;
  const __CFBoolean *v39;
  const __CFBoolean *v40;
  unint64_t *v41;
  unint64_t v42;
  uint64_t v43;
  const void *v44;
  const void *v45;
  CFTypeID v46;
  _BOOL4 v47;
  _BOOL4 v48;
  int v49;
  const __CFString *v50;
  const __CFString *v51;
  uint64_t v52;
  Tube *v53;
  CFStreamError v54;
  NSObject *v55;
  uint64_t v56;
  void *v57;
  _QWORD v58[2];
  void (*v59)(uint64_t);
  void *v60;
  const void *v61;
  _QWORD v62[2];
  void (*v63)(uint64_t);
  void *v64;
  const void *v65;
  _QWORD v66[2];
  void (*v67)(uint64_t);
  void *v68;
  const void *v69;
  CFDictionaryRef v70[2];
  void (*v71)(uint64_t);
  void *v72;
  const void *v73;
  const __CFDictionary *v74;
  uint64_t v75;
  void (*v76)(uint64_t);
  void *v77;
  const void *v78;
  _BYTE buf[24];
  void *v80;
  Tube *v81;
  uint64_t v82;
  CFStreamError v83;

  v2 = *(_QWORD *)&a2.error;
  domain = a2.domain;
  v82 = *MEMORY[0x1E0C80C00];
  if (a2.domain)
  {
    if (a2.error)
    {
      v5 = *((_QWORD *)this + 17);
      if (v5)
      {
        v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 216))(v5, 0x1EDCF9530);
        v7 = (const __CFDictionary *)MEMORY[0x1E0C809B0];
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke;
        v80 = &__block_descriptor_40_e5_v8__0l;
        v81 = (Tube *)v6;
        if (v6)
        {
          v8 = (const void *)v6;
          Mutable = (__CFDictionary *)*((_QWORD *)this + 28);
          if (!Mutable)
          {
            Mutable = CFDictionaryCreateMutable(*((CFAllocatorRef *)this + 1), 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v10 = (const void *)*((_QWORD *)this + 28);
            *((_QWORD *)this + 28) = Mutable;
            if (v10)
            {
              CFRelease(v10);
              Mutable = (__CFDictionary *)*((_QWORD *)this + 28);
            }
          }
          CFDictionarySetValue(Mutable, &unk_1EDCF9530, v8);
        }
        v11 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 17) + 216))(*((_QWORD *)this + 17), 0x1EDCF95D8);
        v74 = v7;
        v75 = 3221225472;
        v76 = ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke_2;
        v77 = &__block_descriptor_40_e5_v8__0l;
        v78 = v11;
        if (v11)
        {
          v12 = (__CFDictionary *)*((_QWORD *)this + 28);
          if (!v12)
          {
            v12 = CFDictionaryCreateMutable(*((CFAllocatorRef *)this + 1), 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v13 = (const void *)*((_QWORD *)this + 28);
            *((_QWORD *)this + 28) = v12;
            if (v13)
            {
              CFRelease(v13);
              v12 = (__CFDictionary *)*((_QWORD *)this + 28);
            }
          }
          CFDictionarySetValue(v12, &unk_1EDCF95D8, v11);
        }
        v14 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 17) + 216))(*((_QWORD *)this + 17), 0x1EDCF9568);
        v70[0] = v7;
        v70[1] = (CFDictionaryRef)3221225472;
        v71 = ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke_3;
        v72 = &__block_descriptor_40_e5_v8__0l;
        v73 = v14;
        if (v14)
        {
          v15 = (__CFDictionary *)*((_QWORD *)this + 28);
          if (!v15)
          {
            v15 = CFDictionaryCreateMutable(*((CFAllocatorRef *)this + 1), 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v16 = (const void *)*((_QWORD *)this + 28);
            *((_QWORD *)this + 28) = v15;
            if (v16)
            {
              CFRelease(v16);
              v15 = (__CFDictionary *)*((_QWORD *)this + 28);
            }
          }
          CFDictionarySetValue(v15, &unk_1EDCF9568, v14);
        }
        v17 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 17) + 216))(*((_QWORD *)this + 17), 0x1EDCF94F8);
        v66[0] = v7;
        v66[1] = 3221225472;
        v67 = ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke_4;
        v68 = &__block_descriptor_40_e5_v8__0l;
        v69 = v17;
        if (v17)
        {
          v18 = (__CFDictionary *)*((_QWORD *)this + 28);
          if (!v18)
          {
            v18 = CFDictionaryCreateMutable(*((CFAllocatorRef *)this + 1), 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v19 = (const void *)*((_QWORD *)this + 28);
            *((_QWORD *)this + 28) = v18;
            if (v19)
            {
              CFRelease(v19);
              v18 = (__CFDictionary *)*((_QWORD *)this + 28);
            }
          }
          CFDictionarySetValue(v18, &unk_1EDCF94F8, v17);
        }
        v20 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 17) + 216))(*((_QWORD *)this + 17), 0x1EDCF95A0);
        v62[0] = v7;
        v62[1] = 3221225472;
        v63 = ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke_5;
        v64 = &__block_descriptor_40_e5_v8__0l;
        v65 = v20;
        if (v20)
        {
          v21 = (__CFDictionary *)*((_QWORD *)this + 28);
          if (!v21)
          {
            v21 = CFDictionaryCreateMutable(*((CFAllocatorRef *)this + 1), 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v22 = (const void *)*((_QWORD *)this + 28);
            *((_QWORD *)this + 28) = v21;
            if (v22)
            {
              CFRelease(v22);
              v21 = (__CFDictionary *)*((_QWORD *)this + 28);
            }
          }
          CFDictionarySetValue(v21, &unk_1EDCF95A0, v20);
        }
        v23 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 17) + 216))(*((_QWORD *)this + 17), 0x1EDCF9610);
        v58[0] = v7;
        v58[1] = 3221225472;
        v24 = ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke_6;
        v59 = ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke_6;
        v60 = &__block_descriptor_40_e5_v8__0l;
        v61 = v23;
        if (v23)
        {
          v25 = (__CFDictionary *)*((_QWORD *)this + 28);
          if (!v25)
          {
            v25 = CFDictionaryCreateMutable(*((CFAllocatorRef *)this + 1), 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v26 = (const void *)*((_QWORD *)this + 28);
            *((_QWORD *)this + 28) = v25;
            if (v26)
            {
              CFRelease(v26);
              v25 = (__CFDictionary *)*((_QWORD *)this + 28);
            }
          }
          CFDictionarySetValue(v25, &unk_1EDCF9610, v23);
          v24 = v59;
        }
        v24((uint64_t)v58);
        v63((uint64_t)v62);
        v67((uint64_t)v66);
        v71((uint64_t)v70);
        v76((uint64_t)&v74);
        (*(void (**)(_BYTE *))&buf[16])(buf);
      }
    }
  }
  if (*((_DWORD *)this + 55) == 10)
  {
    v27 = this;
    v28.domain = 1;
    *(_QWORD *)&v28.error = 89;
LABEL_49:
    Tube::_onqueue_errorHandler(v27, v28);
    return;
  }
  v29 = *((_QWORD *)this + 17);
  if (!v29)
  {
    v27 = this;
    v28.domain = 1;
    *(_QWORD *)&v28.error = 57;
    goto LABEL_49;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v29 + 360))(v29))
    *((_BYTE *)this + 297) = 1;
  if (!(_DWORD)v2)
  {
    if (*((_DWORD *)this + 55) != 10)
      *((_DWORD *)this + 55) = 9;
    if (*((_DWORD *)this + 46))
      goto LABEL_92;
    v43 = *((_QWORD *)this + 17);
    if (v43)
    {
      v44 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v43 + 216))(v43, 0x1EDCF9DB8);
      if (v44)
      {
        v45 = v44;
        v46 = CFGetTypeID(v44);
        if (v46 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
        }
        v47 = *MEMORY[0x1E0C9AE50] == (_QWORD)v45;
        CFRelease(v45);
      }
      else
      {
        v47 = 0;
      }
      if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 17) + 360))(*((_QWORD *)this + 17)))
      {
        v49 = 2;
LABEL_91:
        *((_DWORD *)this + 46) = v49;
        goto LABEL_92;
      }
      v48 = v47;
      v50 = (const __CFString *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 17) + 216))(*((_QWORD *)this + 17), 0x1EDCFA720);
      v51 = v50;
      if (v50)
      {
        if (CFStringGetLength(v50))
        {
          if (CFEqual(v51, CFSTR("http/1.1")))
          {
            *((_DWORD *)this + 46) = 1;
            CFRelease(v51);
LABEL_92:
            *(_QWORD *)&v54.error = v2 & 0xFFFFFFFF00000000;
            v53 = this;
            v54.domain = domain;
LABEL_93:
            Tube::_onqueue_invokeCB(v53, v54);
            return;
          }
          if (CFEqual(v51, CFSTR("h2")))
          {
            *((_DWORD *)this + 46) = 2;
            CFRelease(v51);
            if (!v47)
              goto LABEL_92;
            v48 = 1;
            goto LABEL_101;
          }
          if (CFEqual(v51, CFSTR("h3")))
          {
            *((_DWORD *)this + 46) = 3;
            CFRelease(v51);
            if (v47)
              goto LABEL_92;
            v48 = 0;
            goto LABEL_101;
          }
        }
        CFRelease(v51);
        goto LABEL_101;
      }
    }
    else
    {
      v48 = 0;
    }
    v52 = *(_QWORD *)(*((_QWORD *)this + 13) + 72);
    if (!v52 || (v52 & 1) != 0)
    {
      v49 = 1;
      goto LABEL_91;
    }
    v51 = 0;
LABEL_101:
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v55 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v56 = *((_QWORD *)this + 17);
      if (v56)
        v56 = *(_QWORD *)(v56 + 8);
      v57 = *(void **)(*((_QWORD *)this + 13) + 72);
      *(_DWORD *)buf = 134218754;
      *(_QWORD *)&buf[4] = v56;
      *(_WORD *)&buf[12] = 2114;
      *(_QWORD *)&buf[14] = v51;
      *(_WORD *)&buf[22] = 2048;
      v80 = v57;
      LOWORD(v81) = 1024;
      *(_DWORD *)((char *)&v81 + 2) = v48;
      _os_log_error_impl(&dword_183ECA000, v55, OS_LOG_TYPE_ERROR, "Connection %llu: invalid ALPN %{public}@ allowed=%lu isQUIC=%{BOOL}d", buf, 0x26u);
    }
    v53 = this;
    v54.domain = 1;
    *(_QWORD *)&v54.error = v2 & 0xFFFFFFFF00000000 | 0x64;
    goto LABEL_93;
  }
  v30 = *((_QWORD *)this + 14);
  if (!v30 || (v31 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v30 + 80))(v30)) == 0)
  {
    v34 = 0;
    v74 = 0;
    v75 = 0;
LABEL_51:
    if (domain == *MEMORY[0x1E0C9B298])
    {
      if (*((_QWORD *)this + 17))
      {
        v37 = (const void *)*((_QWORD *)this + 29);
        *((_QWORD *)this + 29) = 0;
        if (v37)
          CFRelease(v37);
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = ___ZN4Tube27_onqueue_saveSSLCertContextEv_block_invoke;
        v80 = &__block_descriptor_40_e22__v16__0____CFString__8l;
        v81 = this;
        createSSLCertificateContext(v70, (uint64_t)buf);
        v38 = (const void *)*((_QWORD *)this + 29);
        *((CFDictionaryRef *)this + 29) = v70[0];
        if (v38)
          CFRelease(v38);
      }
      if ((v2 + 9850) <= 0x2B && ((1 << (v2 + 122)) & 0xC7803E80081) != 0)
      {
        if ((v39 = (const __CFBoolean *)(*(uint64_t (**)(_QWORD, __CFString *))(**((_QWORD **)this + 17)
                                                                                         + 216))(*((_QWORD *)this + 17), CFSTR("kCFStreamPropertyConnectionIsCellular")), (v40 = v39) != 0)&& CFBooleanGetValue(v39)|| (__CFNReportSSLSymptom(domain, v2), v40))
        {
          CFRelease(v40);
        }
      }
    }
    v83.domain = domain;
    *(_QWORD *)&v83.error = v2;
    Tube::_onqueue_errorHandler(this, v83);
    goto LABEL_64;
  }
  v32 = v31;
  v33 = *(const __CFDictionary **)(v31 + 632);
  v34 = *(std::__shared_weak_count **)(v32 + 640);
  v74 = v33;
  v75 = (uint64_t)v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      v36 = __ldxr(p_shared_owners);
    while (__stxr(v36 + 1, p_shared_owners));
  }
  if (!v33)
    goto LABEL_51;
  (*(void (**)(const __CFDictionary *, CFIndex, uint64_t))(*(_QWORD *)v33 + 48))(v33, domain, v2);
  *((_BYTE *)this + 296) = 1;
LABEL_64:
  if (v34)
  {
    v41 = (unint64_t *)&v34->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
}

void sub_183EF7C40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32)
{
  const void *v32;

  CFRelease(v32);
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::isCoalesced(NWIOConnection *this)
{
  return (*((unsigned __int8 *)this + 250) >> 1) & 1;
}

uint64_t NWIOConnection::_startConnection_Completion(NWIOConnection *this)
{
  const __CFNumber *Value;
  dispatch_source_t v3;
  NSObject *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_weak_owners;
  unint64_t v8;
  NSObject *v9;
  unint64_t *v10;
  unint64_t v11;
  NSObject *v12;
  dispatch_time_t v13;
  NSObject *v14;
  uint64_t v15;
  int traffic_class;
  int v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  std::__shared_weak_count *v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  NSObject *v23;
  void *v24;
  SEL v25;
  nw_endpoint_t v26;
  void *v27;
  unint64_t *p_shared_owners;
  unint64_t v29;
  uint64_t result;
  uint64_t v31;
  const void *v32;
  const void *v33;
  CFTypeID v34;
  CFTypeID TypeID;
  const void *v36;
  const __CFAllocator *v37;
  CFStringRef v38;
  CFStringRef v39;
  const __CFNumber *v40;
  dispatch_source_t v41;
  NSObject *v42;
  NWIOConnection *v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  NSObject *v47;
  unint64_t *v48;
  unint64_t v49;
  NSObject *v50;
  dispatch_time_t v51;
  double valuePtr;
  CFStringRef v53;
  uint64_t v54;
  uint64_t v55;
  _BYTE handler[24];
  void *v57;
  NWIOConnection *v58;
  std::__shared_weak_count *v59;
  std::__shared_weak_count *v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  if (!*((_QWORD *)this + 34))
    __assert_rtn("_startConnection_Completion", "NWIOConnection.cpp", 2138, "_connection");
  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  Value = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCFA560);
  if (Value)
  {
    valuePtr = 0.0;
    if (CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr))
    {
      if (valuePtr > 0.0)
      {
        *((double *)this + 67) = valuePtr;
        v3 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *((dispatch_queue_t *)this + 15));
        v4 = *((_QWORD *)this + 68);
        *((_QWORD *)this + 68) = v3;
        if (v4)
          dispatch_release(v4);
        v5 = (std::__shared_weak_count *)*((_QWORD *)this + 32);
        v6 = (std::__shared_weak_count *)*((_QWORD *)this + 33);
        if (v6)
        {
          p_shared_weak_owners = (unint64_t *)&v6->__shared_weak_owners_;
          do
            v8 = __ldxr(p_shared_weak_owners);
          while (__stxr(v8 + 1, p_shared_weak_owners));
        }
        v9 = *((_QWORD *)this + 68);
        *(_QWORD *)handler = MEMORY[0x1E0C809B0];
        *(_QWORD *)&handler[8] = 3321888768;
        *(_QWORD *)&handler[16] = ___ZN14NWIOConnection16_kickTimerCreateEv_block_invoke;
        v57 = &__block_descriptor_56_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e5_v8__0l;
        v58 = this;
        v59 = v5;
        v60 = v6;
        if (v6)
        {
          v10 = (unint64_t *)&v6->__shared_weak_owners_;
          do
            v11 = __ldxr(v10);
          while (__stxr(v11 + 1, v10));
        }
        dispatch_source_set_event_handler(v9, handler);
        v12 = *((_QWORD *)this + 68);
        v13 = dispatch_time(0x8000000000000000, (uint64_t)(*((double *)this + 67) * 1000000000.0));
        dispatch_source_set_timer(v12, v13, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
        dispatch_resume(*((dispatch_object_t *)this + 68));
        if (v60)
          std::__shared_weak_count::__release_weak(v60);
        if (v6)
          std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  NWIOConnection::_watchdogTouch(this, 1);
  if (!*((_QWORD *)this + 71))
  {
    v40 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCF94C0);
    if (v40)
    {
      valuePtr = 0.0;
      if (CFNumberGetValue(v40, kCFNumberDoubleType, &valuePtr))
      {
        if (valuePtr > 0.0)
        {
          v41 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *((dispatch_queue_t *)this + 15));
          v42 = *((_QWORD *)this + 71);
          *((_QWORD *)this + 71) = v41;
          if (v42)
            dispatch_release(v42);
          v43 = (NWIOConnection *)*((_QWORD *)this + 32);
          v44 = (std::__shared_weak_count *)*((_QWORD *)this + 33);
          if (v44)
          {
            v45 = (unint64_t *)&v44->__shared_weak_owners_;
            do
              v46 = __ldxr(v45);
            while (__stxr(v46 + 1, v45));
          }
          v47 = *((_QWORD *)this + 71);
          *(_QWORD *)handler = MEMORY[0x1E0C809B0];
          *(_QWORD *)&handler[8] = 3321888768;
          *(_QWORD *)&handler[16] = ___ZN14NWIOConnection29_connectionAttemptTimerCreateEv_block_invoke;
          v57 = &__block_descriptor_56_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e5_v8__0l;
          v58 = v43;
          v59 = v44;
          if (v44)
          {
            v48 = (unint64_t *)&v44->__shared_weak_owners_;
            do
              v49 = __ldxr(v48);
            while (__stxr(v49 + 1, v48));
          }
          v60 = *(std::__shared_weak_count **)&valuePtr;
          dispatch_source_set_event_handler(v47, handler);
          v50 = *((_QWORD *)this + 71);
          v51 = dispatch_time(0x8000000000000000, (uint64_t)(valuePtr * 1000000000.0));
          dispatch_source_set_timer(v50, v51, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
          dispatch_resume(*((dispatch_object_t *)this + 71));
          if (v59)
            std::__shared_weak_count::__release_weak(v59);
          if (v44)
            std::__shared_weak_count::__release_weak(v44);
        }
      }
    }
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v14 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v15 = *((_QWORD *)this + 36);
    traffic_class = nw_parameters_get_traffic_class();
    *(_DWORD *)handler = 134218240;
    *(_QWORD *)&handler[4] = v15;
    *(_WORD *)&handler[12] = 1024;
    *(_DWORD *)&handler[14] = traffic_class;
    _os_log_impl(&dword_183ECA000, v14, OS_LOG_TYPE_DEFAULT, "Connection %llu: starting, TC(0x%x)", handler, 0x12u);
  }
  v17 = *((_DWORD *)this + 34);
  if (v17 != 7)
  {
    if (v17 >= 3)
      __assert_rtn("_changeState", "TransportConnection.cpp", 288, "newState >= _state");
    *((_DWORD *)this + 34) = 2;
  }
  nw_connection_start(*((nw_connection_t *)this + 34));
  v18 = *((_QWORD *)this + 25);
  if (v18)
  {
    v19 = *(std::__shared_weak_count **)(v18 + 192);
    if (v19)
    {
      v20 = std::__shared_weak_count::lock(v19);
      *(_QWORD *)&handler[8] = v20;
      if (v20)
      {
        v21 = v20;
        v22 = *(_QWORD *)(v18 + 184);
        *(_QWORD *)handler = v22;
        if (v22)
        {
          v23 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v22 + 424))(v22);
          if (v23)
          {
            os_unfair_lock_lock((os_unfair_lock_t)(v18 + 8));
            objc_storeStrong((id *)(v18 + 40), v23);
            os_unfair_lock_unlock((os_unfair_lock_t)(v18 + 8));
            *(CFAbsoluteTime *)(v18 + 88) = CFAbsoluteTimeGetCurrent();
            valuePtr = 0.0;
            v53 = 0;
            nw_connection_get_uuid();
            v24 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3A28]), "initWithUUIDBytes:", &valuePtr);
            objc_setProperty_atomic((id)v18, v25, v24, 64);

            *(_QWORD *)(v18 + 72) = nw_connection_get_id();
            v26 = nw_connection_copy_endpoint(v23);
            v27 = *(void **)(v18 + 120);
            *(_QWORD *)(v18 + 120) = v26;

            *(_BYTE *)(v18 + 14) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v22 + 264))(v22);
          }

        }
        p_shared_owners = (unint64_t *)&v21->__shared_owners_;
        do
          v29 = __ldaxr(p_shared_owners);
        while (__stlxr(v29 - 1, p_shared_owners));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
    }
  }
  result = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_3703, 2);
  v31 = result;
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)result + 16))(result, "Connection Start", 0);
    if ((_DWORD)result)
    {
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v31 + 72))(v31, "Connection ID", CFSTR("%llu"));
      v32 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCFBC58);
      v33 = v32;
      if (v32)
      {
        v34 = CFGetTypeID(v32);
        TypeID = CFBooleanGetTypeID();
        v36 = (const void *)*MEMORY[0x1E0C9AE50];
        if (v34 != TypeID && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)handler = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", handler, 2u);
        }
        if (v36 == v33)
        {
          v37 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          *(_QWORD *)handler = &off_1E14E4818;
          v38 = CFStringCreateWithCString(v37, "No Cellular", 0x8000100u);
          *(_QWORD *)&handler[16] = 0;
          v57 = 0;
          *(_QWORD *)&handler[8] = v38;
          valuePtr = COERCE_DOUBLE(&off_1E14E4818);
          v39 = CFStringCreateWithCString(v37, "True", 0x8000100u);
          v54 = 0;
          v55 = 0;
          v53 = v39;
          (*(void (**)(uint64_t, _QWORD, CFStringRef))(*(_QWORD *)v31 + 64))(v31, *(_QWORD *)&handler[8], v39);
          AutoString::~AutoString((AutoString *)&valuePtr);
          AutoString::~AutoString((AutoString *)handler);
        }
      }
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
    }
  }
  return result;
}

void sub_183EF83B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  AutoString::~AutoString((AutoString *)&a10);
  AutoString::~AutoString((AutoString *)&a29);
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::isTLSConfigured(NWIOConnection *this)
{
  return (*((unsigned __int16 *)this + 124) >> 9) & 1;
}

uint64_t NWIOConnection::copyUnderlyingConnection(NWIOConnection *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 34);
  if (v1)
    nw_retain(*((void **)this + 34));
  return v1;
}

void NWIOConnection::setProperties(NWIOConnection *this, CFDictionaryRef theDict)
{
  _QWORD context[5];

  if (theDict)
  {
    context[0] = MEMORY[0x1E0C809B0];
    context[1] = 3221225472;
    context[2] = ___ZN14NWIOConnection13setPropertiesEPK14__CFDictionary_block_invoke;
    context[3] = &__block_descriptor_40_e25_v24__0____CFString__8_v16l;
    context[4] = this;
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)_apply_block, context);
  }
}

void NWIOConnection::initialize(uint64_t a1, uint64_t a2)
{
  id receiver;
  std::__shared_weak_count *super_class;
  unint64_t *v6;
  unint64_t v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  id v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  const __CFString *v23;
  __CFString *v24;
  unint64_t *p_info;
  unint64_t v26;
  void *v27;
  unint64_t *v28;
  unint64_t v29;
  __CFN_ConnectionMetrics *v30;
  weak_ptr<TransportConnection> v31;
  id v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  int64x2_t v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *cntrl;
  unint64_t *v40;
  unint64_t v41;
  weak_ptr<TransportConnection> v42;
  weak_ptr<TransportConnection> v43;
  const __CFString *v44[2];
  objc_super v45;

  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v45, *(_QWORD *)(a1 + 232), *(std::__shared_weak_count **)(a1 + 240));
  receiver = v45.receiver;
  super_class = (std::__shared_weak_count *)v45.super_class;
  if (v45.super_class)
  {
    v6 = (unint64_t *)((char *)v45.super_class + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
    p_shared_weak_owners = (unint64_t *)&super_class->__shared_weak_owners_;
    do
      v9 = __ldxr(p_shared_weak_owners);
    while (__stxr(v9 + 1, p_shared_weak_owners));
  }
  v10 = *(std::__shared_weak_count **)(a1 + 216);
  *(_QWORD *)(a1 + 208) = receiver;
  *(_QWORD *)(a1 + 216) = super_class;
  if (v10)
    std::__shared_weak_count::__release_weak(v10);
  if (super_class)
  {
    p_shared_owners = (unint64_t *)&super_class->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))super_class->__on_zero_shared)(super_class);
      std::__shared_weak_count::__release_weak(super_class);
    }
  }
  v13 = (std::__shared_weak_count *)v45.super_class;
  if (v45.super_class)
  {
    v14 = (unint64_t *)((char *)v45.super_class + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v45, *(_QWORD *)(a1 + 232), *(std::__shared_weak_count **)(a1 + 240));
  v16 = v45.receiver;
  v17 = (std::__shared_weak_count *)v45.super_class;
  if (v45.super_class)
  {
    v18 = (unint64_t *)((char *)v45.super_class + 16);
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  v20 = *(std::__shared_weak_count **)(a1 + 264);
  *(_QWORD *)(a1 + 256) = v16;
  *(_QWORD *)(a1 + 264) = v17;
  if (v20)
  {
    std::__shared_weak_count::__release_weak(v20);
    v17 = (std::__shared_weak_count *)v45.super_class;
  }
  if (v17)
  {
    v21 = (unint64_t *)&v17->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v23 = *(const __CFString **)a2;
  v24 = *(__CFString **)(a2 + 8);
  v44[0] = v23;
  v44[1] = v24;
  if (v24)
  {
    p_info = (unint64_t *)&v24->info;
    do
      v26 = __ldxr(p_info);
    while (__stxr(v26 + 1, p_info));
  }
  NWIOConnection::_createEndpoint((uint64_t *)&v45, (NWIOConnection *)a1, v44);
  v27 = *(void **)(a1 + 304);
  *(_QWORD *)(a1 + 304) = v45.receiver;
  if (v27)
    nw_release(v27);
  v45.receiver = 0;
  if (v24)
  {
    v28 = (unint64_t *)&v24->info;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      (*((void (**)(__CFString *))v24->isa + 2))(v24);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v24);
    }
  }
  v30 = [__CFN_ConnectionMetrics alloc];
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v42, *(_QWORD *)(a1 + 232), *(std::__shared_weak_count **)(a1 + 240));
  v43 = v42;
  v42 = (weak_ptr<TransportConnection>)0;
  v31 = v43;
  if (v30)
  {
    v45.receiver = v30;
    v45.super_class = (Class)__CFN_ConnectionMetrics;
    v32 = objc_msgSendSuper2(&v45, sel_init);
    v30 = (__CFN_ConnectionMetrics *)v32;
    if (v32)
    {
      if (v31.__cntrl_)
      {
        v33 = (unint64_t *)((char *)v31.__cntrl_ + 16);
        do
          v34 = __ldxr(v33);
        while (__stxr(v34 + 1, v33));
      }
      v35 = (std::__shared_weak_count *)*((_QWORD *)v32 + 24);
      v30->_transportConnection = v31;
      if (v35)
        std::__shared_weak_count::__release_weak(v35);
      v36 = vdupq_n_s64(0x7FF8000000000000uLL);
      *(int64x2_t *)&v30->_beginTime = v36;
      *(int64x2_t *)&v30->_firstByteReceivedTime = v36;
      v30->_idleAtTime = NAN;
      v30->connectionLock._os_unfair_lock_opaque = 0;
      v30->_reusedAfterAPSleepWake = 0;
    }
  }
  *(_QWORD *)(a1 + 200) = v30;
  if (v31.__cntrl_)
  {
    v37 = (unint64_t *)((char *)v31.__cntrl_ + 8);
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      (*(void (**)(__shared_weak_count *))(*(_QWORD *)v31.__cntrl_ + 16))(v31.__cntrl_);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v31.__cntrl_);
    }
  }
  cntrl = (std::__shared_weak_count *)v42.__cntrl_;
  if (v42.__cntrl_)
  {
    v40 = (unint64_t *)((char *)v42.__cntrl_ + 8);
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))cntrl->__on_zero_shared)(cntrl);
      std::__shared_weak_count::__release_weak(cntrl);
    }
  }
}

void sub_183EF879C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void NWIOConnection::_createEndpoint(uint64_t *a1, NWIOConnection *a2, const __CFString **a3)
{
  const __CFString *v4;
  const __CFAllocator *v7;
  const __CFString *v8;
  UInt8 *v9;
  uint64_t host_with_numeric_port;
  const __CFAllocator *allocator;
  uint64_t v12;
  void *ptr;
  UInt8 v14[1024];
  uint64_t v15;
  CFStreamError v16;
  CFStreamError v17;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = *a3;
  if (!*a3)
    __assert_rtn("_createEndpoint", "NWIOConnection.cpp", 1633, "host");
  *a1 = 0;
  if (hostnameIsValid(v4))
  {
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v8 = *a3;
    allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v12 = 1023;
    if (v8)
    {
      v9 = _CFStringGetOrCreateCString(v7, v8, v14, &v12, 0x8000100u);
    }
    else
    {
      v14[0] = 0;
      v12 = 0;
      v9 = v14;
    }
    ptr = v9;
    host_with_numeric_port = nw_endpoint_create_host_with_numeric_port();
    *a1 = host_with_numeric_port;
    if (!host_with_numeric_port)
    {
      v17.domain = 1;
      *(_QWORD *)&v17.error = 22;
      NWIOConnection::_handleError(a2, v17);
    }
    if (ptr)
    {
      if (v14 != ptr)
        CFAllocatorDeallocate(allocator, ptr);
    }
  }
  else
  {
    v16.domain = 12;
    *(_QWORD *)&v16.error = 1;
    NWIOConnection::_handleError(a2, v16);
  }
}

void sub_183EF8900(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFAllocatorRef allocator, uint64_t a10, void *ptr)
{
  _QWORD *v11;
  void *v12;

  if (ptr)
  {
    if (v12 != ptr)
      CFAllocatorDeallocate(allocator, ptr);
  }
  *v11 = 0;
  _Unwind_Resume(exception_object);
}

uint64_t hostnameIsValid(CFStringRef theString)
{
  UInt8 *CString;
  uint64_t v2;
  UInt8 *v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  BOOL v8;
  const __CFAllocator *allocator;
  uint64_t v11[2];
  UInt8 v12[1024];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v11[0] = 1023;
  CString = _CFStringGetOrCreateCString(allocator, theString, v12, v11, 0x8000100u);
  v2 = v11[0];
  v11[1] = (uint64_t)CString;
  if (strlen((const char *)CString) == v11[0])
  {
    if (v11[0] < 1)
    {
LABEL_11:
      v4 = 1;
    }
    else
    {
      v3 = CString;
      while (1)
      {
        v4 = 0;
        v6 = (char)*v3++;
        v5 = v6;
        v7 = (1 << (v6 - 9)) & 0xC0004004800013;
        v8 = (v6 - 9) > 0x37 || v7 == 0;
        if (!v8 || (v5 - 91) < 3)
          break;
        if (!--v2)
          goto LABEL_11;
      }
    }
  }
  else
  {
    v4 = 0;
  }
  if (CString && v12 != CString)
    CFAllocatorDeallocate(allocator, CString);
  return v4;
}

void HTTPProtocol::setCurrentBodyStream(HTTPProtocol *this, CFTypeRef cf)
{
  CFTypeRef v3;
  CFTypeRef v5;
  uint64_t v6;
  unint64_t v7;

  v3 = (CFTypeRef)*((_QWORD *)this + 55);
  if (v3 != cf)
  {
    if (v3)
      CFRelease(v3);
    if (cf)
      v5 = CFRetain(cf);
    else
      v5 = 0;
    *((_QWORD *)this + 55) = v5;
  }
  v6 = *((unsigned int *)this + 48);
  if ((v6 & 0x80000000) != 0 && !*((_QWORD *)this + 34))
  {
    v7 = v6 & 0xFFFFFFFF7FFFFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
    *((_DWORD *)this + 48) = v6 & 0x7FFFFFFF;
    *((_WORD *)this + 98) = WORD2(v7);
    HTTPProtocol::destroyReadStream(this);
    HTTPProtocol::asynchronouslyCreateAndOpenStream(this, 0);
  }
}

uint64_t HTTPProtocol::getCurrentBodyStream(HTTPProtocol *this)
{
  return *((_QWORD *)this + 55);
}

void std::__shared_ptr_pointer<BlockHolderVar<void *> *,SmartBlockWithArgs<void *>::Deleter,std::allocator<BlockHolderVar<void *>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  BOOL v4;
  int v5;
  _QWORD *v7;

  v1 = *(_QWORD *)(a1 + 24);
  v3 = *(_QWORD *)(v1 + 8);
  v2 = *(_QWORD *)(v1 + 16);
  if (v2)
    v4 = (*(_QWORD *)(v1 + 16) & 1 | v3) == 0;
  else
    v4 = 1;
  v5 = v4;
  if ((uint64_t (*)(_QWORD *))v3 == BlockHolderVar<void *>::invoke_initial && v5 != 0)
  {
    v7 = (_QWORD *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0)
      (*(void (**)(_QWORD *, _QWORD))(*v7 + BlockHolderVar<void *>::invoke_initial))(v7, 0);
    else
      ((void (*)(_QWORD *, _QWORD))BlockHolderVar<void *>::invoke_initial)(v7, 0);
  }
  _Block_release(*(const void **)v1);
  JUMPOUT(0x186DB748CLL);
}

void Tube::~Tube(Tube *this)
{
  uint64_t v2;

  Tube::~Tube(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  ProxyConnectionEstablishment *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  const void *v10;
  const void *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  char v16;
  NSObject *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  _QWORD block[5];
  std::__shared_weak_count *v26;
  char v27;

  *(_QWORD *)this = off_1E14EF7F8;
  *((_QWORD *)this + 4) = &unk_1E14EF8E0;
  v2 = (Tube *)((char *)this + 32);
  *((_QWORD *)this + 3) = &unk_1E14EF8C0;
  *((_QWORD *)this + 5) = &unk_1E14EF988;
  *((_QWORD *)this + 12) = &unk_1E14EF9F0;
  v3 = (const void *)*((_QWORD *)this + 39);
  if (v3)
  {
    _Block_release(v3);
    *((_QWORD *)this + 39) = 0;
  }
  v4 = (const void *)*((_QWORD *)this + 38);
  if (v4)
  {
    _Block_release(v4);
    *((_QWORD *)this + 38) = 0;
  }
  v5 = (const void *)*((_QWORD *)this + 32);
  *((_QWORD *)this + 32) = 0;
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 31);
  *((_QWORD *)this + 31) = 0;
  if (v6)
    CFRelease(v6);
  if (!*((_BYTE *)this + 296))
  {
    v12 = *((_QWORD *)this + 17);
    v13 = (std::__shared_weak_count *)*((_QWORD *)this + 18);
    if (v13)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        v15 = __ldxr(p_shared_owners);
      while (__stxr(v15 + 1, p_shared_owners));
    }
    v16 = *((_BYTE *)this + 240);
    v17 = *((_QWORD *)this + 20);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3321888768;
    block[2] = ___ZN4TubeD2Ev_block_invoke;
    block[3] = &__block_descriptor_49_e8_32c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE_e5_v8__0l;
    block[4] = v12;
    v26 = v13;
    if (v13)
    {
      v18 = (unint64_t *)&v13->__shared_owners_;
      do
        v19 = __ldxr(v18);
      while (__stxr(v19 + 1, v18));
    }
    v27 = v16;
    dispatch_async(v17, block);
    v20 = v26;
    if (v26)
    {
      v21 = (unint64_t *)&v26->__shared_owners_;
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    if (v13)
    {
      v23 = (unint64_t *)&v13->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }
  v7 = *((_QWORD *)this + 14);
  if (v7)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 48))(v7);
    *((_QWORD *)this + 14) = 0;
  }
  v8 = *((_QWORD *)this + 16);
  if (v8)
  {
    (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(v8 + 16))(v8, 0, 0, 0);
    _Block_release(*((const void **)this + 16));
    *((_QWORD *)this + 16) = 0;
  }
  v9 = (const void *)*((_QWORD *)this + 35);
  if (v9)
  {
    _Block_release(v9);
    *((_QWORD *)this + 35) = 0;
  }
  (*(void (**)(_QWORD))(**((_QWORD **)this + 13) + 48))(*((_QWORD *)this + 13));
  *((_QWORD *)this + 13) = 0;
  dispatch_release(*((dispatch_object_t *)this + 20));
  *((_QWORD *)this + 20) = 0;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 264);
  v10 = (const void *)*((_QWORD *)this + 29);
  *((_QWORD *)this + 29) = 0;
  if (v10)
    CFRelease(v10);
  v11 = (const void *)*((_QWORD *)this + 28);
  *((_QWORD *)this + 28) = 0;
  if (v11)
    CFRelease(v11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 168);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 136);
  ProxyConnectionEstablishment::~ProxyConnectionEstablishment(v2);
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

void sub_183EF8E04(_Unwind_Exception *a1)
{
  _QWORD *v1;
  ProxyConnectionEstablishment *v2;
  const void *v4;
  const void *v5;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 33));
  v4 = (const void *)v1[29];
  v1[29] = 0;
  if (v4)
    CFRelease(v4);
  v5 = (const void *)v1[28];
  v1[28] = 0;
  if (v5)
    CFRelease(v5);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 21));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 17));
  ProxyConnectionEstablishment::~ProxyConnectionEstablishment(v2);
  v1[3] = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void ProxyConnectionEstablishment::~ProxyConnectionEstablishment(ProxyConnectionEstablishment *this)
{
  const void *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;

  *(_QWORD *)this = &off_1E14EE928;
  *((_QWORD *)this + 1) = &unk_1E14EE9D0;
  v2 = (const void *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v2)
    CFRelease(v2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 5);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 16);
}

{
  ProxyConnectionEstablishment::~ProxyConnectionEstablishment(this);
  JUMPOUT(0x186DB748CLL);
}

void HTTPConnectionCacheEntry::EnqueuedRequest::~EnqueuedRequest(HTTPConnectionCacheEntry::EnqueuedRequest *this)
{
  uint64_t v2;

  HTTPConnectionCacheEntry::EnqueuedRequest::~EnqueuedRequest(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  uint64_t v5;

  *(_QWORD *)this = off_1E14F0160;
  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    *((_QWORD *)this + 9) = 0;
  }
  v3 = *((_QWORD *)this + 3);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
    *((_QWORD *)this + 3) = 0;
  }
  v4 = (const void *)*((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v4)
    CFRelease(v4);
  v5 = *((_QWORD *)this + 4);
  if (v5)
  {
    CFRelease((CFTypeRef)(v5 - 16));
    *((_QWORD *)this + 4) = 0;
  }
}

void `non-virtual thunk to'HTTPProtocol::_meta_release(HTTPProtocol *this)
{
  CFRelease((char *)this - 192);
}

void HTTP2Stream::_onqueue_notifyDataAvailable(HTTP2Stream *this)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD v15[6];
  std::__shared_weak_count *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;

  v2 = *((_QWORD *)this + 4);
  if (v2 && *(_DWORD *)(v2 + 40))
  {
    if (!*((_BYTE *)this + 130) && *((_QWORD *)this + 3))
    {
      v3 = *((_QWORD *)this + 21);
      *((_QWORD *)this + 21) = 0;
      v17 = 0;
      v18 = 0;
      v4 = (std::__shared_weak_count *)*((_QWORD *)this + 36);
      if (v4 && (v4 = std::__shared_weak_count::lock(v4), (v18 = v4) != 0))
      {
        v5 = *((_QWORD *)this + 35);
        v17 = v5;
      }
      else
      {
        v5 = 0;
      }
      v6 = *((_QWORD *)this + 4);
      v15[0] = MEMORY[0x1E0C809B0];
      v15[1] = 3321888768;
      v15[2] = ___ZN11HTTP2Stream28_onqueue_notifyDataAvailableEv_block_invoke;
      v15[3] = &unk_1E14F3120;
      v15[5] = v5;
      v16 = v4;
      if (v4)
      {
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v8 = __ldxr(p_shared_owners);
        while (__stxr(v8 + 1, p_shared_owners));
      }
      v15[4] = v3;
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v15);
      v9 = v16;
      if (v16)
      {
        v10 = (unint64_t *)&v16->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
      v12 = v18;
      if (v18)
      {
        v13 = (unint64_t *)&v18->__shared_owners_;
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
    }
  }
  else
  {
    *((_DWORD *)this + 50) |= 2u;
  }
}

void sub_183EF90F0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32);
  _Unwind_Resume(a1);
}

uint64_t AwaitingTube::getTube(AwaitingTube *this)
{
  return *((_QWORD *)this + 10);
}

void std::__shared_ptr_pointer<__CFReadStream *,Deleter_CFRelease,std::allocator<__CFReadStream>>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 24);
  if (v1)
    CFRelease(v1);
}

void Tube::postConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __CFHTTPMessage *v7;
  __CFHTTPMessage *v8;
  uint64_t v9;
  _BYTE *v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t *v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  uint64_t v46;
  std::__shared_weak_count *v47;
  uint64_t v48;
  std::__shared_weak_count *v49;
  uint64_t v50;
  std::__shared_weak_count *v51;
  uint64_t v52;
  std::__shared_weak_count *v53;
  uint64_t v54;
  std::__shared_weak_count *v55;
  uint64_t v56;
  std::__shared_weak_count *v57;
  _QWORD v58[6];
  uint64_t v59;
  std::__shared_weak_count *v60;

  if (*(_DWORD *)(a1 + 220) != 10)
    *(_DWORD *)(a1 + 220) = 6;
  v7 = (__CFHTTPMessage *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 136) + 216))(*(_QWORD *)(a1 + 136), 0x1EDD00488);
  if (v7)
  {
    v8 = v7;
    CFHTTPMessageGetResponseStatusCode(v7);
    (*(void (**)(uint64_t))(a4 + 16))(a4);
    CFRelease(v8);
    return;
  }
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v58[0] = MEMORY[0x1E0C809B0];
  v58[1] = 3221225472;
  v58[2] = ___ZN4Tube24postConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0_U13block_pointerFvvE_block_invoke;
  v58[3] = &unk_1E14F98C0;
  v58[4] = a4;
  v58[5] = a1;
  SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::SmartBlockWithArgs(&v59, v58);
  v9 = v59;
  if (v59)
  {
    *(_QWORD *)(v59 + 8) = BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_normal;
    *(_QWORD *)(v9 + 16) = 0;
  }
  v10 = *(_BYTE **)(a1 + 264);
  if (v10 && v10[97])
  {
    v11 = *(std::__shared_weak_count **)(a1 + 144);
    v56 = *(_QWORD *)(a1 + 136);
    v57 = v11;
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }
    v54 = v9;
    v55 = v60;
    if (v60)
    {
      v14 = (unint64_t *)&v60->__shared_owners_;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    (*(void (**)(_BYTE *, uint64_t *, uint64_t *))(*(_QWORD *)v10 + 120))(v10, &v56, &v54);
    v16 = v55;
    if (v55)
    {
      v17 = (unint64_t *)&v55->__shared_owners_;
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
    v19 = v57;
    if (!v57)
      goto LABEL_52;
    v20 = (unint64_t *)&v57->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
  }
  else
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    v52 = a1;
    v22 = (std::__shared_weak_count *)operator new();
    v22->__shared_owners_ = 0;
    v23 = (unint64_t *)&v22->__shared_owners_;
    v22->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1898;
    v22->__shared_weak_owners_ = 0;
    v22[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
    v53 = v22;
    v24 = *(_QWORD *)(a1 + 8);
    v25 = *(std::__shared_weak_count **)(a1 + 144);
    v50 = *(_QWORD *)(a1 + 136);
    v51 = v25;
    if (v25)
    {
      v26 = (unint64_t *)&v25->__shared_owners_;
      do
        v27 = __ldxr(v26);
      while (__stxr(v27 + 1, v26));
    }
    v28 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 112) + 88))(*(_QWORD *)(a1 + 112)) - 16;
    v29 = *(_QWORD *)(a1 + 104);
    v48 = a1 + 96;
    v49 = v22;
    do
      v30 = __ldxr(v23);
    while (__stxr(v30 + 1, v23));
    v46 = v59;
    v47 = v60;
    if (v60)
    {
      v31 = (unint64_t *)&v60->__shared_owners_;
      do
        v32 = __ldxr(v31);
      while (__stxr(v32 + 1, v31));
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)(a1 + 32) + 136))(a1 + 32, v24, &v50, a3, v28, v29, &v48, &v46);
    v33 = v47;
    if (v47)
    {
      v34 = (unint64_t *)&v47->__shared_owners_;
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }
    v36 = v49;
    if (v49)
    {
      v37 = (unint64_t *)&v49->__shared_owners_;
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }
    v39 = v51;
    if (v51)
    {
      v40 = (unint64_t *)&v51->__shared_owners_;
      do
        v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
    v19 = v53;
    if (!v53)
      goto LABEL_52;
    v42 = (unint64_t *)&v53->__shared_owners_;
    do
      v21 = __ldaxr(v42);
    while (__stlxr(v21 - 1, v42));
  }
  if (!v21)
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
LABEL_52:
  v43 = v60;
  if (v60)
  {
    v44 = (unint64_t *)&v60->__shared_owners_;
    do
      v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }
}

void sub_183EF94E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  uint64_t v11;
  va_list va;
  uint64_t v13;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v11 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 64);
  _Unwind_Resume(a1);
}

uint64_t CFAllocatedReferenceCountedObject_RequiringNamedRetains::retain(uint64_t this)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(this + 16);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 + 1, v1));
  return this;
}

uint64_t AwaitingTube::getRequest(AwaitingTube *this)
{
  return *((_QWORD *)this + 5);
}

void ProxyConnectionEstablishment::postProxyConnectionConfiguration(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, _QWORD *a6, uint64_t *a7, uint64_t *a8)
{
  uint64_t v13;
  void *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  _QWORD v49[3];
  std::__shared_weak_count *v50;
  uint64_t v51;
  std::__shared_weak_count *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;

  if (*(_DWORD *)(a1 + 56) == 2)
  {
    v55 = 0;
    v56 = 0;
    SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::operator()(*a8, 0, 0, 0, 0, 0);
  }
  else if (a4 && (v13 = network_proxy_create_from_parameters()) != 0)
  {
    v14 = (void *)v13;
    v15 = operator new();
    NetworkProxyConfiguration::NetworkProxyConfiguration(v15, v14);
    nw_release(v14);
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v15 + 16))(v15))
    {
      v49[0] = v15;
      v49[1] = a5;
      v16 = (std::__shared_weak_count *)a3[1];
      v49[2] = *a3;
      v50 = v16;
      if (v16)
      {
        p_shared_owners = (unint64_t *)&v16->__shared_owners_;
        do
          v18 = __ldxr(p_shared_owners);
        while (__stxr(v18 + 1, p_shared_owners));
      }
      v19 = (std::__shared_weak_count *)a7[1];
      v51 = *a7;
      v52 = v19;
      if (v19)
      {
        v20 = (unint64_t *)&v19->__shared_owners_;
        do
          v21 = __ldxr(v20);
        while (__stxr(v21 + 1, v20));
      }
      makeProxy<>(&v47, v49);
      if (v47)
      {
        if (a6)
        {
          (*(void (**)(void))(*(_QWORD *)v47 + 104))();
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v47 + 88))(v47, a6[4]);
          v45 = v47;
          v46 = v48;
          if (v48)
          {
            v22 = (unint64_t *)&v48->__shared_owners_;
            do
              v23 = __ldxr(v22);
            while (__stxr(v23 + 1, v22));
          }
          (*(void (**)(_QWORD *, uint64_t *))(*a6 + 56))(a6, &v45);
          v24 = v46;
          if (v46)
          {
            v25 = (unint64_t *)&v46->__shared_owners_;
            do
              v26 = __ldaxr(v25);
            while (__stlxr(v26 - 1, v25));
            if (!v26)
            {
              ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
              std::__shared_weak_count::__release_weak(v24);
            }
          }
        }
        v27 = v47;
        v28 = a8[1];
        v43 = *a8;
        v44 = (std::__shared_weak_count *)v28;
        if (v28)
        {
          v29 = (unint64_t *)(v28 + 8);
          do
            v30 = __ldxr(v29);
          while (__stxr(v30 + 1, v29));
        }
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v27 + 112))(v27, &v43);
        v31 = v44;
        if (v44)
        {
          v32 = (unint64_t *)&v44->__shared_owners_;
          do
            v33 = __ldaxr(v32);
          while (__stlxr(v33 - 1, v32));
          if (!v33)
          {
            ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
            std::__shared_weak_count::__release_weak(v31);
          }
        }
      }
      else
      {
        SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::operator()(*a8, 0, 0, 0, 0, 0);
      }
      v34 = v48;
      if (v48)
      {
        v35 = (unint64_t *)&v48->__shared_owners_;
        do
          v36 = __ldaxr(v35);
        while (__stlxr(v36 - 1, v35));
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }
      v37 = v52;
      if (v52)
      {
        v38 = (unint64_t *)&v52->__shared_owners_;
        do
          v39 = __ldaxr(v38);
        while (__stlxr(v39 - 1, v38));
        if (!v39)
        {
          ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
          std::__shared_weak_count::__release_weak(v37);
        }
      }
      v40 = v50;
      if (v50)
      {
        v41 = (unint64_t *)&v50->__shared_owners_;
        do
          v42 = __ldaxr(v41);
        while (__stlxr(v42 - 1, v41));
        if (!v42)
        {
          ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
          std::__shared_weak_count::__release_weak(v40);
        }
      }
    }
    else
    {
      SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::operator()(*a8, 0, 0, 0, 0, 0);
    }
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  }
  else
  {
    v53 = 0;
    v54 = 0;
    SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::operator()(*a8, 0, 0, 0, 0, 0);
  }
}

void sub_183EF98AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va2;
  uint64_t v19;
  va_list va3;

  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v12 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  va_copy(va3, va2);
  v17 = va_arg(va3, _QWORD);
  v19 = va_arg(va3, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(a1);
}

uint64_t *SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::SmartBlockWithArgs(uint64_t *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  v4 = (_QWORD *)operator new();
  v4[1] = BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_initial;
  v4[2] = 0;
  *v4 = _Block_copy(a2);
  *a1 = (uint64_t)v4;
  v5 = (_QWORD *)operator new();
  *v5 = &off_1E14F11D0;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a1[1] = (uint64_t)v5;
  if (!a2)
  {
    v6 = *a1;
    *(_QWORD *)(v6 + 8) = BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_reseted;
    *(_QWORD *)(v6 + 16) = 0;
  }
  return a1;
}

void sub_183EF9A14(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

BOOL NWIOConnection::_isExpensive(NWIOConnection *this)
{
  const void *v1;
  const void *v2;
  CFTypeID v3;
  _BOOL8 v4;
  uint8_t v6[16];

  v1 = (const void *)(*(uint64_t (**)(NWIOConnection *, uint64_t))(*(_QWORD *)this + 216))(this, 0x1EDCFA1E0);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = CFGetTypeID(v1);
  if (v3 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v6, 2u);
  }
  v4 = *MEMORY[0x1E0C9AE50] == (_QWORD)v2;
  CFRelease(v2);
  return v4;
}

void sub_183EF9AF8(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

BOOL NWIOConnection::_isCellular(NWIOConnection *this)
{
  const void *v1;
  const void *v2;
  CFTypeID v3;
  _BOOL8 v4;
  uint8_t v6[16];

  v1 = (const void *)(*(uint64_t (**)(NWIOConnection *, void *))(*(_QWORD *)this + 216))(this, &unk_1EDCFB948);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = CFGetTypeID(v1);
  if (v3 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v6, 2u);
  }
  v4 = *MEMORY[0x1E0C9AE50] == (_QWORD)v2;
  CFRelease(v2);
  return v4;
}

void sub_183EF9BCC(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void ___ZNK14XCookieStorage29getRequestHeaderFieldsForTaskEP16NSURLSessionTaskU13block_pointerFvPK14__CFDictionaryE_block_invoke(uint64_t a1, CFTypeRef cf)
{
  const __CFAllocator *v4;
  CFDictionaryRef v5;

  v4 = CFGetAllocator(cf);
  v5 = CFHTTPCookieCopyRequestHeaderFields(v4, (CFArrayRef)cf);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (v5)
    CFRelease(v5);
}

uint64_t ___ZN12HTTPProtocol35asynchronouslyAddCookiesAndContinueEP15__CFHTTPMessage_block_invoke_2(uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[6];

  v3 = *(_QWORD *)(a1 + 32);
  if (theDict && CFDictionaryGetCount(theDict))
    _CFHTTPMessageSetMultipleHeaderFields(*(__CFHTTPMessage **)(a1 + 40), theDict);
  v5 = *(_QWORD *)(v3 + 24);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN12HTTPProtocol35asynchronouslyAddCookiesAndContinueEP15__CFHTTPMessage_block_invoke_3;
  v8[3] = &__block_descriptor_48_e5_v8__0l;
  v6 = *(_QWORD *)(a1 + 40);
  v8[4] = v3;
  v8[5] = v6;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v5 + 96))(v5, v8);
}

void Tube::setWaitingForConnectivityCallback(uint64_t a1, void *aBlock)
{
  const void *v4;

  v4 = *(const void **)(a1 + 280);
  if (v4)
  {
    _Block_release(v4);
    *(_QWORD *)(a1 + 280) = 0;
  }
  if (aBlock)
    *(_QWORD *)(a1 + 280) = _Block_copy(aBlock);
}

_OWORD *Tube::createNewTube(const __CFAllocator *a1, CFStringRef *a2, const void *a3)
{
  _OWORD *v6;
  _OWORD *v7;
  uint64_t v8;
  uint64_t v9;
  const __CFDictionary *v10;
  const __CFNumber *Value;
  NSObject *v12;
  void *v13;
  NSObject *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  const void *v18;
  const void *v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  const char *v24;
  int v25;
  __int128 v26;

  v6 = CFAllocatorAllocate(a1, 320, 0);
  *(_OWORD *)((char *)v6 + 36) = 0u;
  *(_OWORD *)((char *)v6 + 52) = 0u;
  *(_OWORD *)((char *)v6 + 68) = 0u;
  *(_OWORD *)((char *)v6 + 84) = 0u;
  *(_OWORD *)((char *)v6 + 100) = 0u;
  *(_OWORD *)((char *)v6 + 116) = 0u;
  *(_OWORD *)((char *)v6 + 132) = 0u;
  *(_OWORD *)((char *)v6 + 148) = 0u;
  *(_OWORD *)((char *)v6 + 164) = 0u;
  *(_OWORD *)((char *)v6 + 180) = 0u;
  *(_OWORD *)((char *)v6 + 196) = 0u;
  *(_OWORD *)((char *)v6 + 212) = 0u;
  *(_OWORD *)((char *)v6 + 228) = 0u;
  v6[19] = 0u;
  *(_OWORD *)((char *)v6 + 20) = 0u;
  *(_OWORD *)((char *)v6 + 260) = 0u;
  *(_OWORD *)((char *)v6 + 276) = 0u;
  *(_OWORD *)((char *)v6 + 292) = 0u;
  *(_QWORD *)v6 = off_1E14EF578;
  *((_QWORD *)v6 + 1) = a1;
  *(_OWORD *)((char *)v6 + 244) = 0u;
  *((_DWORD *)v6 + 4) = 1;
  if (((unint64_t)(v6 + 1) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  v7 = v6;
  *((_QWORD *)v6 + 4) = &unk_1E14EF8E0;
  *(_OWORD *)((char *)v6 + 76) = 0uLL;
  v6[3] = 0uLL;
  v6[4] = 0uLL;
  *(_QWORD *)v6 = off_1E14EF7F8;
  *((_QWORD *)v6 + 3) = &unk_1E14EF8C0;
  *((_QWORD *)v6 + 5) = &unk_1E14EF988;
  *((_QWORD *)v6 + 12) = &unk_1E14EF9F0;
  *((_QWORD *)v6 + 17) = 0;
  v8 = (uint64_t)v6 + 136;
  *((_QWORD *)v6 + 18) = 0;
  *((_QWORD *)v6 + 21) = 0;
  *((_QWORD *)v6 + 22) = 0;
  *((_QWORD *)v6 + 28) = 0;
  *((_QWORD *)v6 + 26) = 0;
  v9 = (uint64_t)v6 + 264;
  *((_QWORD *)v6 + 33) = 0;
  *((_QWORD *)v6 + 34) = 0;
  *((_WORD *)v6 + 148) = 0;
  *((_QWORD *)v6 + 29) = 0;
  if (!a2)
  {
    v24 = "key";
    v25 = 45;
    goto LABEL_31;
  }
  if (CFStringCompare(a2[4], a2[17], 0))
  {
    v24 = "key->isCoalesced() == false";
    v25 = 46;
    goto LABEL_31;
  }
  *((_QWORD *)v7 + 13) = a2;
  ((void (*)(CFStringRef *))(*a2)[1].info)(a2);
  if (!a3)
  {
    v24 = "cb";
    v25 = 50;
LABEL_31:
    __assert_rtn("Tube", "Tube.cpp", v25, v24);
  }
  *((_QWORD *)v7 + 16) = _Block_copy(a3);
  *((_QWORD *)v7 + 14) = 0;
  *((_BYTE *)v7 + 120) = 0;
  *((_DWORD *)v7 + 38) = 21;
  v10 = (const __CFDictionary *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)v7 + 13) + 64))(*((_QWORD *)v7 + 13));
  if (v10)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(v10, &unk_1EDCFA800);
    if (Value)
    {
      LODWORD(v26) = 0;
      if (CFNumberGetValue(Value, kCFNumberIntType, &v26))
        *((_DWORD *)v7 + 38) = v26;
    }
  }
  v12 = dispatch_queue_attr_make_with_qos_class(0, (dispatch_qos_class_t)*((_DWORD *)v7 + 38), 0);
  *((_QWORD *)v7 + 20) = dispatch_queue_create("com.apple.CFNetwork.Connection", v12);
  v13 = (void *)nw_context_copy_implicit_context();
  if (v13)
  {
    nw_queue_context_target_dispatch_queue();
    nw_release(v13);
  }
  v14 = *((_QWORD *)v7 + 20);
  if (!v14)
    __assert_rtn("Tube", "Tube.cpp", 81, "fDQ");
  GlueTubeManager::createTransportConnection((std::__shared_weak_count **)&v26, v14);
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v8, &v26);
  v15 = (std::__shared_weak_count *)*((_QWORD *)&v26 + 1);
  if (*((_QWORD *)&v26 + 1))
  {
    v16 = (unint64_t *)(*((_QWORD *)&v26 + 1) + 8);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  *((_DWORD *)v7 + 46) = 0;
  *((_BYTE *)v7 + 188) = 0;
  *((_BYTE *)v7 + 192) = 0;
  *((_BYTE *)v7 + 216) = 0;
  *((_DWORD *)v7 + 55) = 0;
  v18 = (const void *)*((_QWORD *)v7 + 28);
  *((_QWORD *)v7 + 28) = 0;
  if (v18)
    CFRelease(v18);
  v19 = (const void *)*((_QWORD *)v7 + 29);
  *((_QWORD *)v7 + 29) = 0;
  if (v19)
    CFRelease(v19);
  *((_BYTE *)v7 + 240) = 1;
  *((_QWORD *)v7 + 31) = 0;
  *((_QWORD *)v7 + 32) = 0;
  *((_QWORD *)v7 + 38) = 0;
  *((_QWORD *)v7 + 39) = 0;
  v26 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v9, &v26);
  v20 = (std::__shared_weak_count *)*((_QWORD *)&v26 + 1);
  if (*((_QWORD *)&v26 + 1))
  {
    v21 = (unint64_t *)(*((_QWORD *)&v26 + 1) + 8);
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  *((_QWORD *)v7 + 35) = 0;
  *((_QWORD *)v7 + 36) = 0;
  return v7;
}

void sub_183EFA104(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  ProxyConnectionEstablishment *v3;
  uint64_t v4;
  uint64_t v5;
  const void **v6;
  const void *v8;
  const void *v9;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  v8 = *(const void **)(v1 + 232);
  *(_QWORD *)(v1 + 232) = 0;
  if (v8)
    CFRelease(v8);
  v9 = *v6;
  *v6 = 0;
  if (v9)
    CFRelease(v9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v4);
  ProxyConnectionEstablishment::~ProxyConnectionEstablishment(v3);
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void GlueTubeManager::createTransportConnection(std::__shared_weak_count **a1, NSObject *a2)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  uint64_t v5;
  _QWORD *v6;
  std::__shared_count v7;
  std::__shared_weak_count *shared_owners;
  unint64_t *v9;
  unint64_t v10;
  const __CFAllocator *v11;
  uint64_t *v12;
  CFMutableDictionaryRef Mutable;
  const void *v14;
  _opaque_pthread_t *v15;
  const LineInfo *v16;
  uint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t v20;
  unint64_t *p_shared_weak_owners;
  unint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  std::__shared_weak_count *v30;
  CFAbsoluteTime Current;
  mach_port_t v32;
  pid_t v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  const char *v38;

  v3 = (std::__shared_weak_count *)operator new(0x2C8uLL);
  *(_OWORD *)&v3->__shared_owners_ = 0u;
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F09F0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14E5838;
  v30 = v3 + 1;
  *(_OWORD *)&v3[10].__shared_weak_owners_ = 0u;
  os_unfair_lock_lock((os_unfair_lock_t)&WeakTracker<TransportConnection>::_lock);
  v5 = WeakTracker<TransportConnection>::_current_id + 1;
  v3[1].__shared_owners_ = WeakTracker<TransportConnection>::_current_id + 1;
  WeakTracker<TransportConnection>::_current_id = v5;
  os_unfair_lock_unlock((os_unfair_lock_t)&WeakTracker<TransportConnection>::_lock);
  if (TransportConnection::observableProperties(void)::onceToken != -1)
    dispatch_once(&TransportConnection::observableProperties(void)::onceToken, &__block_literal_global_12_16394);
  NotificationStation::NotificationStation((NotificationStation *)&v3[1].__shared_weak_owners_, (CFTypeRef)TransportConnection::observableProperties(void)::observableProps);
  *(_OWORD *)&v3[8].__shared_owners_ = 0u;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)off_1E14EA660;
  v3[6].__vftable = 0;
  v3[7].std::__shared_count = 0u;
  v3[5].__shared_weak_owners_ = (uint64_t)&unk_1E14EA840;
  *(_OWORD *)&v3[7].__shared_weak_owners_ = 0u;
  v3[6].__shared_owners_ = 0;
  LODWORD(v3[6].__shared_weak_owners_) = 0;
  v3[9].std::__shared_count = 0u;
  *(_OWORD *)&v3[9].__shared_weak_owners_ = 0u;
  v3[10].__shared_owners_ = 0;
  if (TransportConnection::TransportConnection(NSObject  {objcproto17OS_dispatch_queue}*)::initOnce != -1)
  {
    dispatch_once(&TransportConnection::TransportConnection(NSObject  {objcproto17OS_dispatch_queue}*)::initOnce, &__block_literal_global_16395);
    if (a2)
      goto LABEL_5;
LABEL_33:
    __assert_rtn("TransportConnection", "TransportConnection.cpp", 70, "workQueue");
  }
  if (!a2)
    goto LABEL_33;
LABEL_5:
  dispatch_retain(a2);
  v6 = (_QWORD *)operator new();
  *v6 = &off_1E14F1D30;
  v6[1] = 0;
  v6[2] = 0;
  v6[3] = a2;
  v7.__vftable = (std::__shared_count_vtbl *)a2;
  v7.__shared_owners_ = (uint64_t)v6;
  shared_owners = (std::__shared_weak_count *)v3[6].__shared_owners_;
  v3[6].std::__shared_count = v7;
  if (shared_owners)
  {
    v9 = (unint64_t *)&shared_owners->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))shared_owners->__on_zero_shared)(shared_owners);
      std::__shared_weak_count::__release_weak(shared_owners);
    }
  }
  v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14E7088;
  v3[5].__shared_weak_owners_ = (uint64_t)&unk_1E14E7268;
  LOWORD(v3[11].__shared_owners_) = 0;
  BYTE2(v3[11].__shared_owners_) = 0;
  v12 = &v3[17].__shared_owners_;
  v3[25].__shared_owners_ = 0;
  LOBYTE(v3[25].__shared_weak_owners_) = 0;
  *(_OWORD *)&v3[11].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v3[12].__shared_owners_ = 0u;
  v3[13].std::__shared_count = 0u;
  *(_OWORD *)&v3[13].__shared_weak_owners_ = 0u;
  LODWORD(v3[14].__shared_owners_) = 0;
  *(_OWORD *)&v3[14].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v3[15].__shared_owners_ = 0u;
  v3[16].std::__shared_count = 0u;
  *(_OWORD *)((char *)&v3[16].__shared_owners_ + 4) = 0u;
  *(_OWORD *)&v3[17].__shared_owners_ = 0u;
  v3[18].std::__shared_count = 0u;
  *(_OWORD *)&v3[18].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v3[19].__shared_owners_ = 0u;
  v3[20].std::__shared_count = 0u;
  *(_OWORD *)&v3[20].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v3[21].__shared_owners_ = 0u;
  v3[22].std::__shared_count = 0u;
  *(_OWORD *)((char *)&v3[22].__shared_owners_ + 4) = 0u;
  *(_OWORD *)((char *)&v3[24].__shared_owners_ + 4) = 0u;
  v3[24].std::__shared_count = 0u;
  *(_OWORD *)&v3[23].__shared_owners_ = 0u;
  v3[26].std::__shared_count = 0u;
  LOWORD(v3[29].__shared_owners_) = 0;
  v3[28].std::__shared_count = 0u;
  *(_OWORD *)&v3[27].__shared_owners_ = 0u;
  *(_OWORD *)&v3[26].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v3[28].__shared_weak_owners_ = 0u;
  Mutable = CFDictionaryCreateMutable(v11, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v14 = (const void *)v3[16].__shared_owners_;
  v3[16].__shared_owners_ = (uint64_t)Mutable;
  if (v14)
    CFRelease(v14);
  Current = CFAbsoluteTimeGetCurrent();
  v15 = pthread_self();
  v32 = pthread_mach_thread_np(v15);
  v33 = getpid();
  v34 = "NWIOConnection";
  v35 = "ioLogger";
  v36 = 0;
  v37 = v3 + 1;
  v38 = "nwioconnection";
  v17 = IOLogger::newLogger((IOLogger *)&Current, v16);
  v18 = *v12;
  *v12 = v17;
  if (v18)
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
  v19 = (std::__shared_weak_count *)v3[11].__vftable;
  if (v19)
  {
    if (v19->__shared_owners_ != -1)
      goto LABEL_27;
    do
      v20 = __ldxr(p_shared_owners);
    while (__stxr(v20 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v3->__shared_weak_owners_;
    do
      v22 = __ldxr(p_shared_weak_owners);
    while (__stxr(v22 + 1, p_shared_weak_owners));
    v3[10].__shared_weak_owners_ = (uint64_t)v30;
    v3[11].__vftable = (std::__shared_weak_count_vtbl *)v3;
    std::__shared_weak_count::__release_weak(v19);
  }
  else
  {
    do
      v23 = __ldxr(p_shared_owners);
    while (__stxr(v23 + 1, p_shared_owners));
    v24 = (unint64_t *)&v3->__shared_weak_owners_;
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
    v3[10].__shared_weak_owners_ = (uint64_t)v30;
    v3[11].__vftable = (std::__shared_weak_count_vtbl *)v3;
  }
  do
    v26 = __ldaxr(p_shared_owners);
  while (__stlxr(v26 - 1, p_shared_owners));
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_27:
  *a1 = v30;
  a1[1] = v3;
  do
    v27 = __ldxr(p_shared_owners);
  while (__stxr(v27 + 1, p_shared_owners));
  do
    v28 = __ldaxr(p_shared_owners);
  while (__stlxr(v28 - 1, p_shared_owners));
  if (!v28)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_183EFA5E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, TransportConnection *a11)
{
  uint64_t v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  void **v14;
  uint64_t *v15;
  std::__shared_weak_count_vtbl *v17;
  const void *shared_weak_owners;
  const void *shared_owners;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  void *v23;
  std::__shared_weak_count_vtbl *v24;
  uint64_t v25;
  const void *v26;
  std::__shared_weak_count_vtbl *v27;
  void *v28;
  void *v29;
  std::__shared_weak_count_vtbl *v30;
  void *v31;
  void *v32;
  void *v33;
  std::__shared_weak_count *v34;
  std::__shared_weak_count *v35;
  void *v36;

  v17 = v12[29].__vftable;
  v12[29].__vftable = 0;
  if (v17)
    CFRelease(v17);
  shared_weak_owners = (const void *)v12[28].__shared_weak_owners_;
  v12[28].__shared_weak_owners_ = 0;
  if (shared_weak_owners)
    CFRelease(shared_weak_owners);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v13);
  shared_owners = (const void *)v12[25].__shared_owners_;
  v12[25].__shared_owners_ = 0;
  if (shared_owners)
    CFRelease(shared_owners);
  v20 = v12[24].__shared_weak_owners_;
  v12[24].__shared_weak_owners_ = 0;
  if (v20)
    dispatch_release(v20);
  v21 = v12[24].__shared_owners_;
  v12[24].__shared_owners_ = 0;
  if (v21)
    dispatch_release(v21);
  v22 = v12[23].__shared_weak_owners_;
  v12[23].__shared_weak_owners_ = 0;
  if (v22)
    dispatch_release(v22);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v11 + 512);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v11 + 496);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v11 + 480);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v11 + 464);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v11 + 448);
  v23 = (void *)v12[19].__shared_owners_;
  v12[19].__shared_owners_ = 0;
  if (v23)
    sec_release(v23);
  v24 = v12[19].__vftable;
  v12[19].__vftable = 0;
  if (v24)
    CFRelease(v24);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v11 + 416);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v11 + 400);
  v25 = *v15;
  *v15 = 0;
  if (v25)
    (*(void (**)(uint64_t))(*(_QWORD *)v25 + 8))(v25);
  v26 = (const void *)v12[16].__shared_owners_;
  v12[16].__shared_owners_ = 0;
  if (v26)
    CFRelease(v26);
  v27 = v12[16].__vftable;
  v12[16].__vftable = 0;
  if (v27)
    nw_release(v27);
  v28 = (void *)v12[15].__shared_weak_owners_;
  v12[15].__shared_weak_owners_ = 0;
  if (v28)
    nw_release(v28);
  v29 = (void *)v12[15].__shared_owners_;
  v12[15].__shared_owners_ = 0;
  if (v29)
    nw_release(v29);
  v30 = v12[15].__vftable;
  v12[15].__vftable = 0;
  if (v30)
    nw_release(v30);
  v31 = *v14;
  *v14 = 0;
  if (v31)
    nw_release(v31);
  v32 = (void *)v12[13].__shared_weak_owners_;
  v12[13].__shared_weak_owners_ = 0;
  if (v32)
    nw_release(v32);
  v33 = (void *)v12[13].__shared_owners_;
  v12[13].__shared_owners_ = 0;
  if (v33)
    nw_release(v33);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v11 + 272);
  v34 = (std::__shared_weak_count *)v12[12].__vftable;
  if (v34)
    std::__shared_weak_count::__release_weak(v34);
  TransportConnection::~TransportConnection(a11);
  v35 = (std::__shared_weak_count *)v12[11].__vftable;
  if (v35)
    std::__shared_weak_count::__release_weak(v35);
  std::__shared_weak_count::~__shared_weak_count(v12);
  operator delete(v36);
  _Unwind_Resume(a1);
}

uint64_t IOLogger::newLogger(IOLogger *this, const LineInfo *a2)
{
  uint64_t result;
  uint64_t v4;
  __int128 v5;

  pthread_once(&sLoggerOnce, (void (*)(void))IOLogger::_initLogger);
  if (!gIOLogger)
    return 0;
  result = operator new();
  v4 = gIOLogger;
  *(_QWORD *)result = &off_1E14EFD68;
  v5 = *((_OWORD *)this + 1);
  *(_OWORD *)(result + 280) = *(_OWORD *)this;
  *(_OWORD *)(result + 296) = v5;
  *(_OWORD *)(result + 312) = *((_OWORD *)this + 2);
  *(_QWORD *)(result + 328) = *((_QWORD *)this + 6);
  *(_BYTE *)(result + 12) = 0;
  *(_DWORD *)(result + 8) = -1;
  *(_QWORD *)(result + 272) = v4;
  return result;
}

void NotificationStation::NotificationStation(NotificationStation *this, CFTypeRef cf)
{
  CFTypeRef v3;

  *((_QWORD *)this + 1) = 850045863;
  *(_QWORD *)this = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_QWORD *)this + 8) = 0;
  if (cf)
    v3 = CFRetain(cf);
  else
    v3 = 0;
  *((_QWORD *)this + 9) = v3;
  *((_QWORD *)this + 10) = CFTypeRefRelease<__CFSet const*>;
  *((_BYTE *)this + 88) = 0;
}

void sub_183EFA940(_Unwind_Exception *a1)
{
  uint64_t *v1;
  std::mutex *v2;

  std::mutex::~mutex(v2);
  std::unique_ptr<std::map<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>,CFStringRefComp,std::allocator<std::pair<std::unique_ptr<__CFString const,void (*)(__CFString const*)> const,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>>::reset[abi:nn180100](v1, 0);
  _Unwind_Resume(a1);
}

_QWORD *Tube::setNWContext(uint64_t a1, uint64_t *a2)
{
  return std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(a1 + 168), *a2, a2[1]);
}

void Tube::initialize(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t i;
  void *v15;
  NSObject *v16;
  uint64_t v17;
  _QWORD block[8];
  char v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  _BYTE v24[128];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  if (!a2)
    __assert_rtn("initialize", "Tube.cpp", 182, "waiter");
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a2 + 128))(a2))
    __assert_rtn("initialize", "Tube.cpp", 183, "!waiter->hasBeenClaimed()");
  *(_QWORD *)(a1 + 112) = a2;
  (*(void (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 112) + 120))(*(_QWORD *)(a1 + 112));
  v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 112) + 80))(*(_QWORD *)(a1 + 112));
  v7 = v6 - 176;
  if (!v6)
    v7 = 0;
  v8 = objc_msgSend(*(id *)(v7 + 80), "_assumesHTTP3Capable", *(_QWORD *)(v7 + 80));
  v9 = 0;
  v10 = 0;
  if ((v8 & 1) == 0)
  {
    v9 = 0;
    if (a3)
    {
      v10 = 0;
      if (!*(_BYTE *)(a1 + 216))
      {
        v22 = 0u;
        v23 = 0u;
        v20 = 0u;
        v21 = 0u;
        v11 = objc_msgSend(a3, "countByEnumeratingWithState:objects:count:", &v20, v24, 16);
        if (v11)
        {
          v12 = v11;
          v9 = 0;
          v10 = 0;
          v13 = *(_QWORD *)v21;
          do
          {
            for (i = 0; i != v12; ++i)
            {
              if (*(_QWORD *)v21 != v13)
                objc_enumerationMutation(a3);
              v15 = *(void **)(*((_QWORD *)&v20 + 1) + 8 * i);
              if (objc_msgSend(v15, "host")
                && objc_msgSend(v15, "port") >= 1
                && objc_msgSend(v15, "serviceType") > *(_QWORD *)(a1 + 208))
              {
                v9 = objc_msgSend(v15, "alternateHost");
                v10 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", objc_msgSend(v15, "alternatePort"));
                *(_QWORD *)(a1 + 208) = objc_msgSend(v15, "serviceType");
              }
            }
            v12 = objc_msgSend(a3, "countByEnumeratingWithState:objects:count:", &v20, v24, 16);
          }
          while (v12);
        }
        else
        {
          v9 = 0;
          v10 = 0;
        }
      }
    }
    else
    {
      v10 = 0;
    }
  }
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v16 = *(NSObject **)(a1 + 160);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN4Tube10initializeEP16BaseAwaitingTubeP7NSArrayIP30_NSHTTPAlternativeServiceEntryE_block_invoke;
  block[3] = &unk_1E14F9848;
  v19 = v8;
  block[4] = v9;
  block[5] = v10;
  block[6] = v17;
  block[7] = a1;
  dispatch_async(v16, block);
}

uint64_t BaseAwaitingTube::hasBeenClaimed(BaseAwaitingTube *this)
{
  return *((unsigned __int8 *)this + 20);
}

uint64_t BaseAwaitingTube::markAsClaimed(uint64_t this)
{
  if (*(_BYTE *)(this + 20))
    __assert_rtn("markAsClaimed", "AwaitingTube.h", 57, "!claimedByTube");
  *(_BYTE *)(this + 20) = 1;
  return this;
}

void sub_183EFD838(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t hasConfigValue(BOOL *a1, NSURLSessionConfiguration *a2, const __CFString *a3)
{
  CFTypeID TypeID;
  uint64_t v7;
  CFTypeRef v8;
  CFTypeID v9;
  CFTypeRef cf;
  uint8_t buf[16];

  cf = 0;
  TypeID = CFBooleanGetTypeID();
  v7 = hasConfigValue(&cf, TypeID, a2, a3);
  if ((_DWORD)v7)
  {
    v8 = cf;
    if (cf)
    {
      v9 = CFGetTypeID(cf);
      if (v9 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
      }
      *a1 = *MEMORY[0x1E0C9AE50] == (_QWORD)v8;
      CFRelease(v8);
    }
    else
    {
      *a1 = 0;
    }
  }
  return v7;
}

uint64_t hasConfigValue(const void **a1, uint64_t a2, NSURLSessionConfiguration *a3, const __CFString *a4)
{
  uint64_t result;
  const void *v7;

  *a1 = 0;
  result = -[NSURLSessionConfiguration _copyAttribute:](a3, "_copyAttribute:", a4);
  if (result)
  {
    v7 = (const void *)result;
    if (CFGetTypeID((CFTypeRef)result) == a2)
    {
      *a1 = v7;
      return 1;
    }
    else
    {
      CFRelease(v7);
      return 0;
    }
  }
  return result;
}

uint64_t _findExactString(CFStringRef theString, unsigned int a2)
{
  uint64_t v4;
  uint64_t result;
  CFIndex Length;
  unsigned __int16 v7;
  unsigned __int16 *v8;
  uint64_t v9;
  unsigned int v10;
  int *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  CFHashCode v14;
  CFHashCode v15;
  unsigned __int16 *v16;
  unsigned int v17;

  if (!theString)
    return 568;
  v4 = a2;
  if ((uint64_t)&gConstantCFStringValueTable[7 * sDomainRanges[8 * a2]] > (uint64_t)theString
    || (uint64_t)&gConstantCFStringValueTable[7 * sDomainRanges[8 * a2 + 1]] <= (uint64_t)theString
    || (result = LODWORD(theString[1].isa), (_DWORD)result == 568))
  {
    Length = CFStringGetLength(theString);
    if (Length > 32766)
      return 568;
    v7 = Length;
    v8 = &sDomainRanges[8 * v4];
    v9 = v8[2];
    if (v9 > (unsigned __int16)Length)
      return 568;
    v10 = (unsigned __int16)Length;
    result = 568;
    if (v8[3] >= v10 && a2 != 16)
    {
      v11 = (int *)(*(_QWORD *)&sDomainRanges[8 * v4 + 4] + 16 * (v7 - v9));
      v12 = (unsigned __int16 *)*((_QWORD *)v11 + 1);
      v13 = *v11;
      v14 = CFHash(theString);
      if ((int)v13 < 1)
        return 568;
      v15 = v14;
      v16 = &v12[v13];
      while (1)
      {
        v17 = *v12;
        if (v15 == gConstantCFStringValueTable[7 * *v12 + 5])
        {
          if (CFEqual(&gConstantCFStringValueTable[7 * *v12], theString))
            break;
        }
        ++v12;
        result = 568;
        if (v12 >= v16)
          return result;
      }
      return LODWORD(gConstantCFStringValueTable[7 * v17 + 4]);
    }
  }
  return result;
}

BOOL hasConfigValue(uint64_t *a1, NSURLSessionConfiguration *a2, const __CFString *a3)
{
  CFTypeID TypeID;
  CFNumberRef v7;
  _BOOL8 v8;
  CFNumberRef number;

  number = 0;
  TypeID = CFNumberGetTypeID();
  if (!hasConfigValue((const void **)&number, TypeID, a2, a3))
    return 0;
  v7 = number;
  v8 = CFNumberGetValue(number, kCFNumberCFIndexType, a1) != 0;
  if (v7)
    CFRelease(v7);
  return v8;
}

CFMutableDictionaryRef HTTPHeaderDict::copyAsOrdinaryDict(CFDictionaryRef *this, const __CFAllocator *a2)
{
  CFIndex Count;
  CFMutableDictionaryRef Mutable;

  Count = CFDictionaryGetCount(this[1]);
  Mutable = CFDictionaryCreateMutable(a2, Count, &kCaseInsensitiveKeyCallBacks, MEMORY[0x1E0C9B3A0]);
  CFDictionaryApplyFunction(this[1], (CFDictionaryApplierFunction)_merge_array_string, Mutable);
  return Mutable;
}

CFMutableDictionaryRef HTTPMessage::copyAllHeaderFields(HTTPMessage *this)
{
  CFDictionaryRef *v2;
  const __CFAllocator *v3;

  HTTPMessage::ensureParserFinished(this);
  v2 = (CFDictionaryRef *)HTTPMessage::headers((os_unfair_lock_s *)this);
  v3 = CFGetAllocator((char *)this - 16);
  return HTTPHeaderDict::copyAsOrdinaryDict(v2, v3);
}

CFStringRef HTTPMessage::copyHeaderFieldValue(HTTPMessage *this, const __CFString *a2)
{
  CFDictionaryRef *v4;
  const __CFAllocator *v5;
  CFStringRef v6;
  void (**v8)(StringSerializable *__hidden);
  CFTypeRef cf;

  HTTPMessage::ensureParserFinished(this);
  v4 = (CFDictionaryRef *)HTTPMessage::headers((os_unfair_lock_s *)this);
  v5 = CFGetAllocator((char *)this - 16);
  HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v8, a2);
  v6 = HTTPHeaderDict::copyStringValue(v4, v5, (const HTTPHeaderKeyMixedValue *)&v8);
  v8 = &off_1E14E9A00;
  if (cf)
    CFRelease(cf);
  return v6;
}

void sub_183EFE128(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

CFStringRef HTTPMessage::copyHeaderFieldValue(HTTPMessage *a1, unsigned int a2)
{
  CFDictionaryRef *v4;
  const __CFAllocator *v5;
  CFStringRef v6;
  void (**v8)(StringSerializable *__hidden);
  CFTypeRef cf;

  HTTPMessage::ensureParserFinished(a1);
  v4 = (CFDictionaryRef *)HTTPMessage::headers((os_unfair_lock_s *)a1);
  v5 = CFGetAllocator((char *)a1 - 16);
  HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(&v8, a2);
  v6 = HTTPHeaderDict::copyStringValue(v4, v5, (const HTTPHeaderKeyMixedValue *)&v8);
  v8 = &off_1E14E9A00;
  if (cf)
    CFRelease(cf);
  return v6;
}

void sub_183EFE1D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void HTTPMessage::ensureParserFinished(HTTPMessage *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  int v4;
  int *v5;
  const char *v6;
  HTTPBodyData *v7;
  uint8_t v8[16];

  v2 = (os_unfair_lock_s *)((char *)this + 120);
  os_unfair_lock_lock((os_unfair_lock_t)this + 30);
  v3 = *((_QWORD *)this + 11);
  if (v3)
  {
    HTTPParser::commitAccumulatedLine(*((HTTPParser **)this + 11));
    if (*(_DWORD *)(v3 + 36) == 1)
    {
      v4 = *(_DWORD *)(v3 + 40);
      *(_DWORD *)(v3 + 36) = 2;
      if (!v4)
        *((_DWORD *)this + 14) = 2;
    }
    else
    {
      *(_DWORD *)(v3 + 36) = 2;
    }
    v5 = (int *)*((_QWORD *)this + 11);
    if (v5[9] > 1
      || !os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
      || (*(_WORD *)v8 = 0,
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Parsing should be done by now", v8, 2u), (v5 = (int *)*((_QWORD *)this + 11)) != 0))
    {
      (*(void (**)(int *))(*(_QWORD *)v5 + 8))(v5);
    }
    *((_QWORD *)this + 11) = 0;
    v7 = (HTTPBodyData *)*((_QWORD *)this + 6);
    if (v7 && *((_QWORD *)this + 5))
      HTTPBodyData::becomeEmpty(v7, v6);
  }
  os_unfair_lock_unlock(v2);
}

CFStringRef HTTPHeaderDict::copyStringValue(CFDictionaryRef *this, const __CFAllocator *a2, const HTTPHeaderKeyMixedValue *a3)
{
  const void *v6;
  CFTypeRef v7;
  const __CFArray *Value;
  CFStringRef v9;

  CFGetAllocator(this - 2);
  v6 = (const void *)*((_QWORD *)a3 + 1);
  if (v6)
    v7 = CFRetain(v6);
  else
    v7 = 0;
  Value = (const __CFArray *)CFDictionaryGetValue(this[1], v7);
  if (!Value)
  {
    v9 = 0;
    if (!v7)
      return v9;
    goto LABEL_6;
  }
  v9 = CFStringCreateByCombiningStrings(a2, Value, CFSTR(", "));
  if (v7)
LABEL_6:
    CFRelease(v7);
  return v9;
}

_QWORD *HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(_QWORD *a1, unsigned int a2)
{
  *a1 = &off_1E14ECB08;
  a1[1] = 0;
  a1[1] = CFRetain(&gConstantCFStringValueTable[7 * ((a2 >> 20) & 0x3FF)]);
  return a1;
}

void sub_183EFE3D0(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  const void *v3;

  *v1 = &off_1E14E9A00;
  v3 = (const void *)v1[1];
  if (v3)
    CFRelease(v3);
  _Unwind_Resume(exception_object);
}

double HTTPParser::commitAccumulatedLine(HTTPParser *this)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  char *v6;
  char *v7;
  const UInt8 *v8;
  CFIndex v9;
  BOOL v10;
  uint64_t v11;
  int v12;
  int v13;
  double result;
  CFIndex v15;
  unsigned int CanonicalCStringLen;
  const __CFAllocator *v17;
  const void *v18;
  void (**v19)(HTTPHeaderValueMixedValue *__hidden);
  CFTypeRef cf;
  void (**v21)(HTTPHeaderKeyMixedValue *__hidden);
  CFTypeRef v22;
  uint64_t v23;
  uint64_t v24;

  v2 = *((_DWORD *)this + 9);
  switch(v2)
  {
    case 2:
      if (!*((_BYTE *)this + 32))
      {
        if (HTTPParser::commitFirstLine(this))
          break;
        goto LABEL_35;
      }
      goto LABEL_7;
    case 1:
LABEL_7:
      v3 = *((_QWORD *)this + 72);
      if (v3 < 1)
        break;
      v4 = *((_QWORD *)this + 73);
      if (v4 < 1 || v4 >= v3)
        break;
      v24 = 0;
      v6 = HTTPParser::trimBuffer(*((HTTPParser **)this + 70), 0, v4, &v24);
      v23 = 0;
      v7 = HTTPParser::trimBuffer(*((HTTPParser **)this + 70), v4 + 1, v3, &v23);
      if (!v6)
        break;
      v8 = (const UInt8 *)v7;
      if (!v7)
        break;
      v9 = v23;
      if (v23 < 1)
      {
        v12 = 0;
        v10 = 1;
LABEL_38:
        if (v10 && !v12)
        {
          v15 = v24;
          v21 = &off_1E14ECB08;
          if (v24 >= 2 && __tolower(*v6) == 120 && v6[1] == 45
            || (CanonicalCStringLen = _findCanonicalCStringLen((uint64_t)v6, (int)v15, 5), CanonicalCStringLen == 568))
          {
            v17 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v18 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v6, v15, 0x201u, 0);
          }
          else
          {
            v18 = CFRetain(&gConstantCFStringValueTable[7 * ((CanonicalCStringLen >> 20) & 0x3FF)]);
            v17 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          }
          v22 = v18;
          v19 = &off_1E14ED488;
          cf = CFStringCreateWithBytes(v17, v8, v9, 0x201u, 0);
          (*(void (**)(_QWORD, void (***)(HTTPHeaderKeyMixedValue *__hidden), void (***)(HTTPHeaderValueMixedValue *__hidden)))(**((_QWORD **)this + 3) + 24))(*((_QWORD *)this + 3), &v21, &v19);
          v19 = &off_1E14E9A00;
          if (cf)
            CFRelease(cf);
          v21 = &off_1E14E9A00;
          if (v22)
            CFRelease(v22);
        }
        break;
      }
      v10 = 0;
      v11 = 0;
      v12 = 0;
      while (1)
      {
        v13 = v7[v11];
        if (v13 > 12)
        {
          if (v13 == 32)
          {
LABEL_26:
            if (v12 == 2)
            {
              v12 = 0;
            }
            else if (v12 == 1)
            {
              goto LABEL_36;
            }
            goto LABEL_32;
          }
          if (v13 != 13)
          {
LABEL_29:
            if (v12)
              goto LABEL_36;
            goto LABEL_32;
          }
          if (v12)
            goto LABEL_36;
          v12 = 1;
        }
        else
        {
          if (v13 == 9)
            goto LABEL_26;
          if (v13 != 10)
            goto LABEL_29;
          if (v12 != 1)
            goto LABEL_38;
          v12 = 2;
        }
LABEL_32:
        v10 = ++v11 >= v23;
        if (v23 == v11)
          goto LABEL_38;
      }
    case 0:
      *((_BYTE *)this + 32) = 1;
      if (HTTPParser::commitFirstLine(this))
      {
        *((_DWORD *)this + 9) = 1;
        break;
      }
LABEL_35:
      *((_DWORD *)this + 9) = 3;
      break;
  }
LABEL_36:
  result = 0.0;
  *((_OWORD *)this + 36) = xmmword_1841E38C0;
  return result;
}

void sub_183EFE690(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf, uint64_t a11, CFTypeRef a12)
{
  if (cf)
    CFRelease(cf);
  if (a12)
    CFRelease(a12);
  _Unwind_Resume(exception_object);
}

char *HTTPParser::trimBuffer(HTTPParser *this, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  char *result;
  unsigned __int8 *v6;
  int v7;
  unint64_t v9;
  int v10;
  int v11;

  result = (char *)this + a2;
  v6 = (unsigned __int8 *)this + a3;
  if (a2 < a3)
  {
    do
    {
      v7 = *result;
      if (v7 != 32 && v7 != 9)
        break;
      ++result;
    }
    while (result < (char *)v6);
  }
  if (v6 > (unsigned __int8 *)result)
  {
    v9 = (unint64_t)v6;
    while (1)
    {
      v11 = *(unsigned __int8 *)--v9;
      v10 = v11;
      if (v11 != 32 && v10 != 9)
        break;
      v6 = (unsigned __int8 *)v9;
      if (v9 <= (unint64_t)result)
      {
        v6 = (unsigned __int8 *)result;
        break;
      }
    }
  }
  *a4 = v6 - (unsigned __int8 *)result;
  return result;
}

CFTypeRef URLRequest::copyMainDocumentRegistrableDomain(URLRequest *this)
{
  __CFURL *fMainDocumentURL;
  const __CFString *v3;
  const __CFString *v4;
  CFStringRef RegistrableDomain;
  CFStringRef v6;
  CFTypeRef v7;

  fMainDocumentURL = this->fMainDocumentURL;
  if (!fMainDocumentURL)
    return 0;
  if (!_urlIsHTTPish(fMainDocumentURL))
    return 0;
  v3 = CFURLCopyHostName(this->fMainDocumentURL);
  if (!v3)
    return 0;
  v4 = v3;
  RegistrableDomain = _cfnCreateRegistrableDomain(v3);
  v6 = RegistrableDomain;
  if (RegistrableDomain)
  {
    v7 = CFRetain(RegistrableDomain);
    CFRelease(v6);
  }
  else
  {
    v7 = CFRetain(v4);
  }
  CFRelease(v4);
  return v7;
}

void sub_183EFE7EC(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void HTTPParser::~HTTPParser(HTTPParser *this)
{
  char *v2;

  *(_QWORD *)this = off_1E14E49E0;
  *((_QWORD *)this + 2) = &unk_1E14E4A00;
  *((_QWORD *)this + 3) = 0;
  v2 = (char *)*((_QWORD *)this + 70);
  if (v2 != (char *)this + 44)
    free(v2);
  *((_QWORD *)this + 2) = &off_1E14E5838;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

{
  char *v2;

  *(_QWORD *)this = off_1E14E49E0;
  *((_QWORD *)this + 2) = &unk_1E14E4A00;
  *((_QWORD *)this + 3) = 0;
  v2 = (char *)*((_QWORD *)this + 70);
  if (v2 != (char *)this + 44)
    free(v2);
  *((_QWORD *)this + 2) = &off_1E14E5838;
}

void `non-virtual thunk to'HTTPResponseMessage::parserAddHeader(HTTPResponseMessage *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  HTTPHeaderDict *v5;

  v5 = HTTPMessage::mutableHeaders((HTTPResponseMessage *)((char *)this - 16));
  HTTPHeaderDict::addValue((uint64_t)v5, (uint64_t)a2, (uint64_t)a3);
}

uint64_t _findCanonicalCStringLen(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  unsigned __int16 *v4;
  unsigned int *v6;
  _QWORD v8[2];
  __int128 v9;
  __int128 v10;

  v3 = sDomainRanges[8 * a3 + 2];
  if (v3 > (unsigned __int16)a2)
    return 568;
  v4 = &sDomainRanges[8 * a3];
  if (v4[3] < (unsigned __int16)a2 || a3 == 16)
    return 568;
  v6 = (unsigned int *)(*((_QWORD *)v4 + 1) + 16 * ((unsigned __int16)a2 - v3));
  v9 = 0u;
  v10 = 0u;
  v8[0] = a1;
  v8[1] = a2;
  return findSaneCStringInIndices((uint64_t)v8, v6);
}

void sub_183F00788(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    nw_release(v1);
  _Unwind_Resume(exception_object);
}

CFTypeRef StrictSecurityPolicy::CopyATSState(StrictSecurityPolicy *this)
{
  __CFBundle *MainBundle;
  __CFBundle *v2;
  const __CFDictionary *ValueForInfoDictionaryKey;
  const __CFDictionary *v4;
  CFTypeID v5;
  const __CFDictionary *v6;
  const __CFAllocator *v7;
  __CFDictionary *Mutable;
  CFMutableDictionaryRef MutableCopy;
  CFDataRef DefaultSerializedATSState;
  NSObject *v11;
  CFStringRef Identifier;
  NSObject *v13;
  const __CFDictionary *Value;
  CFMutableDictionaryRef v15;
  const __CFDictionary *v16;
  const __CFDictionary *v17;
  CFTypeID v18;
  const void *v19;
  BOOL v20;
  const void *v21;
  const void *v22;
  const void *v23;
  const __CFString *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  NSObject *v28;
  const void *v29;
  int v31;
  void *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  pthread_mutex_lock(&StrictSecurityPolicy::_Mutex);
  if (!StrictSecurityPolicy::_ATSData)
  {
    if ((dyld_program_sdk_at_least() & 1) == 0 && !getenv("CFN_FORCE_ATS"))
      goto LABEL_51;
    MainBundle = CFBundleGetMainBundle();
    if (!MainBundle)
      goto LABEL_51;
    v2 = MainBundle;
    ValueForInfoDictionaryKey = (const __CFDictionary *)CFBundleGetValueForInfoDictionaryKey(MainBundle, CFSTR("NSAppTransportSecurity"));
    if (!ValueForInfoDictionaryKey
      || (v4 = ValueForInfoDictionaryKey, v5 = CFGetTypeID(ValueForInfoDictionaryKey), v5 != CFDictionaryGetTypeID()))
    {
      if (isAppleBundle(void)::onceToken != -1)
        dispatch_once(&isAppleBundle(void)::onceToken, &__block_literal_global_92);
      if (!isAppleBundle(void)::_isAppleBundle)
      {
        Identifier = CFBundleGetIdentifier(v2);
        if (ATSLog(void)::onceToken != -1)
          dispatch_once(&ATSLog(void)::onceToken, &__block_literal_global_84_8989);
        v13 = ATSLog(void)::atsLog;
        if (os_log_type_enabled((os_log_t)ATSLog(void)::atsLog, OS_LOG_TYPE_DEBUG))
        {
          v31 = 138412290;
          v32 = (void *)Identifier;
          _os_log_debug_impl(&dword_183ECA000, v13, OS_LOG_TYPE_DEBUG, "No state found for %@", (uint8_t *)&v31, 0xCu);
        }
        goto LABEL_51;
      }
      DefaultSerializedATSState = StrictSecurityPolicy::CreateDefaultSerializedATSState((StrictSecurityPolicy *)1, 1);
      if (ATSLog(void)::onceToken != -1)
        dispatch_once(&ATSLog(void)::onceToken, &__block_literal_global_84_8989);
      v11 = ATSLog(void)::atsLog;
      if (os_log_type_enabled((os_log_t)ATSLog(void)::atsLog, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v31) = 0;
        _os_log_debug_impl(&dword_183ECA000, v11, OS_LOG_TYPE_DEBUG, "Apple bundle using default state", (uint8_t *)&v31, 2u);
      }
      goto LABEL_50;
    }
    if (getDefaultATSState(void)::defaultStateToken != -1)
      dispatch_once(&getDefaultATSState(void)::defaultStateToken, &__block_literal_global_95);
    v6 = (const __CFDictionary *)getDefaultATSState(void)::baseATSState;
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (atsDictionaryAllowsArbitraryLoads((uint64_t)v4))
    {
      MutableCopy = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    }
    else
    {
      Value = (const __CFDictionary *)CFDictionaryGetValue(v6, CFSTR("NSExceptionDomains"));
      MutableCopy = CFDictionaryCreateMutableCopy(v7, 0, Value);
    }
    v15 = MutableCopy;
    v16 = (const __CFDictionary *)CFDictionaryGetValue(v4, CFSTR("NSExceptionDomains"));
    if (v16)
    {
      v17 = v16;
      v18 = CFGetTypeID(v16);
      if (v18 == CFDictionaryGetTypeID())
        CFDictionaryApplyFunction(v17, (CFDictionaryApplierFunction)copyATSExceptionDomain, v15);
    }
    CFDictionaryAddValue(Mutable, CFSTR("NSExceptionDomains"), v15);
    CFRelease(v15);
    v19 = CFDictionaryGetValue(v4, CFSTR("NSAllowsArbitraryLoadsInWebContent"));
    v20 = v19 != 0;
    v21 = (const void *)*MEMORY[0x1E0C9AE50];
    if (v19 && v19 == v21)
      CFDictionarySetValue(Mutable, CFSTR("NSAllowsArbitraryLoadsInWebContent"), v19);
    v22 = CFDictionaryGetValue(v4, CFSTR("NSAllowsLocalNetworking"));
    if (v22)
    {
      if (v22 == v21)
        CFDictionarySetValue(Mutable, CFSTR("NSAllowsLocalNetworking"), v21);
      v20 = 1;
    }
    v23 = CFDictionaryGetValue(v4, CFSTR("NSAllowsArbitraryLoadsForMedia"));
    if (v23)
    {
      if (v23 != v21)
      {
LABEL_43:
        v27 = CFDictionaryGetValue(v4, CFSTR("NSPinnedDomains"));
        if (v27)
          CFDictionarySetValue(Mutable, CFSTR("NSPinnedDomains"), v27);
        if (ATSLog(void)::onceToken != -1)
          dispatch_once(&ATSLog(void)::onceToken, &__block_literal_global_84_8989);
        v28 = ATSLog(void)::atsLog;
        if (os_log_type_enabled((os_log_t)ATSLog(void)::atsLog, OS_LOG_TYPE_DEBUG))
        {
          v31 = 138412290;
          v32 = Mutable;
          _os_log_debug_impl(&dword_183ECA000, v28, OS_LOG_TYPE_DEBUG, "Using configuration %@", (uint8_t *)&v31, 0xCu);
        }
        DefaultSerializedATSState = StrictSecurityPolicy::CreateBinaryDataFromPropertyList(Mutable, v29);
        CFRelease(Mutable);
LABEL_50:
        if (DefaultSerializedATSState)
        {
LABEL_55:
          StrictSecurityPolicy::_ATSData = (uint64_t)DefaultSerializedATSState;
          goto LABEL_56;
        }
LABEL_51:
        DefaultSerializedATSState = StrictSecurityPolicy::CreateDefaultSerializedATSState(0, 0);
        if (!DefaultSerializedATSState)
        {
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            LOWORD(v31) = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Failed to create ATS Context.", (uint8_t *)&v31, 2u);
          }
          DefaultSerializedATSState = 0;
        }
        goto LABEL_55;
      }
      v24 = CFSTR("NSAllowsArbitraryLoadsForMedia");
    }
    else
    {
      if (v20)
        goto LABEL_43;
      v25 = CFDictionaryGetValue(v4, CFSTR("NSAllowsArbitraryLoads"));
      if (v25 && v25 == v21)
        CFDictionarySetValue(Mutable, CFSTR("NSAllowsArbitraryLoads"), v21);
      v24 = CFSTR("NSAllowsArbitraryLoads");
      v26 = CFDictionaryGetValue(v6, CFSTR("NSAllowsArbitraryLoads"));
      if (!v26 || v26 != v21)
        goto LABEL_43;
    }
    CFDictionarySetValue(Mutable, v24, v21);
    goto LABEL_43;
  }
LABEL_56:
  pthread_mutex_unlock(&StrictSecurityPolicy::_Mutex);
  return CFRetain((CFTypeRef)StrictSecurityPolicy::_ATSData);
}

BOOL HTTPProtocol::_canHandleRequest(HTTPProtocol *this, const _CFURLRequest *a2, const void *a3)
{
  const __CFURL *v3;
  const __CFString *v4;
  const __CFString *v5;
  CFRange v6;
  int v7;
  int v8;
  char v9;
  __darwin_ct_rune_t v10;
  _BOOL8 v11;
  char v12;
  BOOL v13;
  __darwin_ct_rune_t v14;
  char v15;
  UniChar buffer;
  unsigned __int16 v18;
  unsigned __int16 v19;
  UniChar v20;
  unsigned __int16 v21;
  unsigned __int16 v22;
  unsigned __int16 v23;
  unsigned __int16 v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (!this)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      v20 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "httpCanHandleRequest(): Called for a nullptr request!", (uint8_t *)&v20, 2u);
    }
    return 0;
  }
  v3 = *(const __CFURL **)(-[HTTPProtocol _inner](this, "_inner", a3) + 8);
  if (!v3)
    return 0;
  v4 = CFURLCopyScheme(v3);
  if (!v4)
    return 0;
  v5 = v4;
  v6.length = CFStringGetLength(v4);
  v7 = 0;
  v8 = 0;
  v9 = 1;
  switch(v6.length)
  {
    case 2:
      goto LABEL_6;
    case 3:
      v9 = 0;
      v7 = 115;
LABEL_6:
      v6.location = 0;
      CFStringGetCharacters(v5, v6, &buffer);
      if (__tolower(buffer) != 119)
        goto LABEL_27;
      v10 = __tolower(v18);
      v11 = v10 == 115;
      if (v10 == 115)
        v12 = v9;
      else
        v12 = 1;
      if ((v12 & 1) != 0)
        goto LABEL_28;
      v13 = __tolower(v19) == v7;
      goto LABEL_12;
    case 4:
      goto LABEL_19;
    case 5:
      v9 = 0;
      v8 = 115;
LABEL_19:
      v6.location = 0;
      CFStringGetCharacters(v5, v6, &v20);
      if (__tolower(v20) != 104 || __tolower(v21) != 116 || __tolower(v22) != 116)
        goto LABEL_27;
      v14 = __tolower(v23);
      v11 = v14 == 112;
      if (v14 == 112)
        v15 = v9;
      else
        v15 = 1;
      if ((v15 & 1) != 0)
        goto LABEL_28;
      v13 = __tolower(v24) == v8;
LABEL_12:
      v11 = v13;
LABEL_28:
      CFRelease(v5);
      break;
    default:
LABEL_27:
      v11 = 0;
      goto LABEL_28;
  }
  return v11;
}

uint64_t AppSSOProtocol::_canHandleTask(AppSSOProtocol *this, const NSURLSessionTask *a2, const void *a3)
{
  AppSSOProtocol *v3;
  double v4;
  double Helper_x8__SOErrorDomain;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  const __CFString *v13;
  void *v14;
  uint64_t v15;
  AppSSO *v16;
  const __CFData *v17;
  double v18;
  AppSSO *v19;
  NSObject *v20;
  void *v21;
  int v23;
  void *v24;
  __int16 v25;
  void *v26;
  __int16 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = this;
  if ((-[AppSSOProtocol _preventsAppSSO](v3, "_preventsAppSSO") & 1) != 0
    || ((Helper_x8__SOErrorDomain = gotLoadHelper_x8__SOErrorDomain(v4), v7 = *(_QWORD *)(v6 + 1776), !v8)
      ? (v8 = v7 == 0)
      : (v8 = 1),
        v8))
  {
    v9 = 0;
  }
  else
  {
    -[AppSSOProtocol currentRequest](v3, "currentRequest", Helper_x8__SOErrorDomain);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = v10;
    if (!v10)
      goto LABEL_15;
    v12 = objc_msgSend(v10, "_inner");
    v13 = *(const __CFString **)(v12 + 8);
    if (!v13)
      goto LABEL_15;
    if (_urlIsHTTPish(*(const __CFURL **)(v12 + 8))
      && (-[AppSSOProtocol _effectiveConfiguration](v3, "_effectiveConfiguration"),
          v14 = (void *)objc_claimAutoreleasedReturnValue(),
          v15 = objc_msgSend(v14, "_sourceApplicationAuditTokenData"),
          v14,
          v16 = (AppSSO *)-[AppSSOProtocol _loggableDescription](v3, "_loggableDescription"),
          v19 = AppSSO::shouldManageURL(v16, v13, 0, v15, v17, v18),
          (_DWORD)v19))
    {
      AppSSO::AppSSOProtocolLog(v19);
      v20 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        -[AppSSOProtocol _loggableDescription](v3, "_loggableDescription");
        v21 = (void *)objc_claimAutoreleasedReturnValue();
        v23 = 138543874;
        v24 = v21;
        v25 = 2112;
        v26 = v11;
        v27 = 2112;
        v28 = v15;
        _os_log_impl(&dword_183ECA000, v20, OS_LOG_TYPE_DEFAULT, "AppSSOProtocol can handle %{public}@ request %@ token %@", (uint8_t *)&v23, 0x20u);

      }
      v9 = 1;
    }
    else
    {
LABEL_15:
      v9 = 0;
    }

  }
  return v9;
}

void sub_183F011F0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

BOOL _urlIsHTTPish(const __CFURL *a1)
{
  const __CFString *v1;
  const __CFString *v2;
  _BOOL8 v3;

  if (!a1)
    return 0;
  v1 = CFURLCopyScheme(a1);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = 1;
  if (CFStringCompare(v1, CFSTR("http"), 1uLL))
    v3 = CFStringCompare(v2, (CFStringRef)&unk_1EDD00AE0, 1uLL) == kCFCompareEqualTo;
  CFRelease(v2);
  return v3;
}

AppSSO *AppSSO::shouldManageURL(AppSSO *this, const __CFString *a2, const __CFURL *a3, uint64_t a4, const __CFData *a5, double a6)
{
  uint64_t v10;
  AppSSO *inited;
  AppSSO *v12;
  NSObject *v13;
  int v15;
  AppSSO *v16;
  __int16 v17;
  const __CFString *v18;
  __int16 v19;
  const __CFURL *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (AppSSO::ssoOptionFlag(void)::onceToken != -1)
    dispatch_once(&AppSSO::ssoOptionFlag(void)::onceToken, &__block_literal_global_12_11654);
  if (AppSSO::ssoOptionFlag(void)::flag)
    v10 = 2;
  else
    v10 = 0;
  inited = (AppSSO *)appSSO_willHandle_delayInitStub(a6);
  v12 = inited;
  if ((_DWORD)inited)
  {
    AppSSO::AppSSOLog(inited);
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v15 = 138544386;
      v16 = this;
      v17 = 2112;
      v18 = a2;
      v19 = 2048;
      v20 = a3;
      v21 = 2112;
      v22 = a4;
      v23 = 2048;
      v24 = v10;
      _os_log_impl(&dword_183ECA000, v13, OS_LOG_TYPE_DEFAULT, "AppSSO will manage %{public}@ url %@ code %ld token %@ flag %lu", (uint8_t *)&v15, 0x34u);
    }

  }
  return v12;
}

double URLRequest::initialize(URLRequest *this, const URLRequest *a2)
{
  int fFlags;
  __CFURL *fURL;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unint64_t fCachePolicy;
  double fTimeout;
  void *fMainDocumentURL;
  __CFDictionary *fProtocolProperties;
  CFAllocatorRef *v13;
  void *fProxyDict;
  void *fSSLProps;
  void *fContentDispositionHeaderEncodingFallbackArray;
  _OWORD *Instance;
  HTTPRequestMessage *v18;
  HTTPRequest *fHTTPRequest;
  HTTPRequest *v20;
  int fNetworkServiceType;
  __CFString *fBoundInterfaceIdentifier;
  __CFString *Copy;
  __CFURLStorageSession *explicitStorageSession;
  void *fATSOverrides;
  __CFString *fTrackerContext;
  double result;
  uint8_t v28[16];
  uint8_t buf[16];

  fFlags = *(_WORD *)&this->fFlags | 2;
  *(_WORD *)&this->fFlags |= 2u;
  fURL = a2->fURL;
  if (fURL)
  {
    fURL = CFURLCopyAbsoluteURL(fURL);
    fFlags = (int)this->fFlags;
  }
  this->fURL = fURL;
  v6 = fFlags & 0xFFFFFFFE | *(_WORD *)&a2->fFlags & 1;
  *(_WORD *)&this->fFlags = v6;
  v7 = v6 & 0xFFFFFFF7 | (8 * ((*(_WORD *)&a2->fFlags >> 3) & 1));
  *(_WORD *)&this->fFlags = v7;
  v8 = v7 & 0xFFFFFFEF | (16 * ((*(_WORD *)&a2->fFlags >> 4) & 1));
  *(_WORD *)&this->fFlags = v8;
  fCachePolicy = a2->fCachePolicy;
  if ((*(_WORD *)&a2->fFlags & 0x400) != 0)
  {
    LOWORD(v8) = v8 | 0x400;
    *(_WORD *)&this->fFlags = v8;
  }
  this->fCachePolicy = fCachePolicy;
  fTimeout = a2->fTimeout;
  if ((*(_WORD *)&a2->fFlags & 0x800) != 0)
    *(_WORD *)&this->fFlags = v8 | 0x800;
  this->fTimeout = fTimeout;
  fMainDocumentURL = a2->fMainDocumentURL;
  if (fMainDocumentURL)
    fMainDocumentURL = (void *)CFRetain(fMainDocumentURL);
  this->fMainDocumentURL = (__CFURL *)fMainDocumentURL;
  fProtocolProperties = a2->fProtocolProperties;
  v13 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (fProtocolProperties)
    this->fProtocolProperties = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, fProtocolProperties);
  *(_WORD *)&this->fFlags = a2->fFlags;
  fProxyDict = a2->fProxyDict;
  if (fProxyDict)
    fProxyDict = (void *)CFRetain(fProxyDict);
  this->fProxyDict = (__CFDictionary *)fProxyDict;
  fSSLProps = a2->fSSLProps;
  if (fSSLProps)
    fSSLProps = (void *)CFRetain(fSSLProps);
  this->fSSLProps = (__CFDictionary *)fSSLProps;
  fContentDispositionHeaderEncodingFallbackArray = a2->fContentDispositionHeaderEncodingFallbackArray;
  if (fContentDispositionHeaderEncodingFallbackArray)
    fContentDispositionHeaderEncodingFallbackArray = (void *)CFRetain(fContentDispositionHeaderEncodingFallbackArray);
  this->fContentDispositionHeaderEncodingFallbackArray = (__CFArray *)fContentDispositionHeaderEncodingFallbackArray;
  if (this->fHTTPRequest && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Can't have an HTTP here already", buf, 2u);
  }
  if (a2->fHTTPRequest)
  {
    if (this->fHTTPRequest && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v28 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "can't be here", v28, 2u);
    }
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    Instance = (_OWORD *)_CFRuntimeCreateInstance();
    v18 = (HTTPRequestMessage *)Instance;
    if (Instance)
    {
      Instance[1] = 0u;
      v18 = (HTTPRequestMessage *)(Instance + 1);
      Instance[13] = 0u;
      Instance[14] = 0u;
      Instance[11] = 0u;
      Instance[12] = 0u;
      Instance[9] = 0u;
      Instance[10] = 0u;
      Instance[7] = 0u;
      Instance[8] = 0u;
      Instance[5] = 0u;
      Instance[6] = 0u;
      Instance[3] = 0u;
      Instance[4] = 0u;
      Instance[2] = 0u;
    }
    fHTTPRequest = a2->fHTTPRequest;
    HTTPRequestMessage::HTTPRequestMessage(v18, (const HTTPRequestMessage *)fHTTPRequest);
    *(_QWORD *)v18 = &off_1E14E5170;
    *((_QWORD *)v18 + 1) = &unk_1E14E51F0;
    *((_QWORD *)v18 + 2) = &unk_1E14E5210;
    *((_QWORD *)v18 + 16) = &unk_1E14E5240;
    HTTPRequest::commonInitialization(v20, fHTTPRequest);
    this->fHTTPRequest = (HTTPRequest *)v18;
  }
  fNetworkServiceType = a2->fNetworkServiceType;
  *(_WORD *)&this->fFlags |= 0x40u;
  this->fNetworkServiceType = fNetworkServiceType;
  fBoundInterfaceIdentifier = a2->fBoundInterfaceIdentifier;
  if (fBoundInterfaceIdentifier)
    Copy = (__CFString *)CFStringCreateCopy(*v13, fBoundInterfaceIdentifier);
  else
    Copy = 0;
  this->fBoundInterfaceIdentifier = Copy;
  explicitStorageSession = a2->_explicitStorageSession;
  if (explicitStorageSession)
    explicitStorageSession = (__CFURLStorageSession *)CFRetain(explicitStorageSession);
  this->_explicitStorageSession = explicitStorageSession;
  *(_OWORD *)&this->fRequestPriority = *(_OWORD *)&a2->fRequestPriority;
  *(_OWORD *)&this->fTimeWindowDelay = *(_OWORD *)&a2->fTimeWindowDelay;
  this->fStartTimeoutTime = a2->fStartTimeoutTime;
  this->fRequiresShortConnectionTimeout = a2->fRequiresShortConnectionTimeout;
  this->fPayloadTransmissionTimeout = a2->fPayloadTransmissionTimeout;
  fATSOverrides = a2->fATSOverrides;
  if (fATSOverrides)
    fATSOverrides = (void *)CFRetain(fATSOverrides);
  this->fATSOverrides = (__CFDictionary *)fATSOverrides;
  *(_QWORD *)&this->fAllowsExpensiveNetworkAccess = *(_QWORD *)&a2->fAllowsExpensiveNetworkAccess;
  this->fAllowsUCA = a2->fAllowsUCA;
  *(_DWORD *)&this->fPreventHSTSStorage = *(_DWORD *)&a2->fPreventHSTSStorage;
  this->fAttribution = a2->fAttribution;
  this->fKnownTracker = a2->fKnownTracker;
  fTrackerContext = a2->fTrackerContext;
  if (fTrackerContext)
    fTrackerContext = (__CFString *)CFRetain(fTrackerContext);
  this->fTrackerContext = fTrackerContext;
  this->fRequiresDNSSECValidation = a2->fRequiresDNSSECValidation;
  this->fAllowsPersistentDNS = a2->fAllowsPersistentDNS;
  result = *(double *)&a2->fPrivacyProxyFailClosed;
  *(double *)&this->fPrivacyProxyFailClosed = result;
  this->fIsWebSearchContent = a2->fIsWebSearchContent;
  return result;
}

void sub_183F022F8(_Unwind_Exception *a1)
{
  HTTPRequestMessage *v1;

  HTTPRequestMessage::~HTTPRequestMessage(v1);
  _Unwind_Resume(a1);
}

void HTTPRequestMessage::HTTPRequestMessage(HTTPRequestMessage *this, const HTTPRequestMessage *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  CFAllocatorRef v6;
  const void *v7;
  CFTypeRef v8;

  HTTPMessage::HTTPMessage(this, a2);
  *v4 = &off_1E14E96D8;
  v4[1] = &unk_1E14E9758;
  v4[2] = &unk_1E14E9778;
  v4[16] = &unk_1E14E97A8;
  v5 = v4 + 16;
  v6 = CFGetAllocator(v4 - 2);
  v7 = (const void *)*((_QWORD *)a2 + 19);
  if (v7)
    v8 = CFRetain(v7);
  else
    v8 = 0;
  HTTPRequestParserClient::HTTPRequestParserClient(v5, v6, v8, *((const char **)a2 + 20), *((const __CFURL **)a2 + 21));
  if (v8)
    CFRelease(v8);
  *(_QWORD *)this = &off_1E14E96D8;
  *((_QWORD *)this + 1) = &unk_1E14E9758;
  *((_QWORD *)this + 2) = &unk_1E14E9778;
  *((_QWORD *)this + 16) = &unk_1E14E97A8;
}

void sub_183F023C4(_Unwind_Exception *a1)
{
  HTTPMessage *v1;

  HTTPMessage::~HTTPMessage(v1);
  _Unwind_Resume(a1);
}

_QWORD *HTTPRequestParserClient::HTTPRequestParserClient(_QWORD *a1, const void *a2, CFTypeRef cf, const char *a4, const __CFURL *a5)
{
  CFTypeRef v9;
  CFTypeRef v10;
  void *v11;
  const void *v12;
  char *v13;

  *a1 = off_1E14ECB28;
  a1[2] = &off_1E14E9A00;
  if (cf)
    v9 = CFRetain(cf);
  else
    v9 = 0;
  a1[2] = &off_1E14EB4B8;
  a1[3] = v9;
  if (a2)
    v10 = CFRetain(a2);
  else
    v10 = 0;
  a1[1] = v10;
  v11 = (void *)a1[4];
  if (v11)
  {
    free(v11);
    a1[4] = 0;
  }
  v12 = (const void *)a1[5];
  a1[5] = 0;
  if (v12)
    CFRelease(v12);
  if (a5)
  {
    a1[5] = CFURLCopyAbsoluteURL(a5);
  }
  else
  {
    if (a4)
      v13 = strdup(a4);
    else
      v13 = 0;
    a1[4] = v13;
  }
  return a1;
}

void sub_183F024C8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  const void *v4;

  *(_QWORD *)(v1 + 16) = v2;
  v4 = *(const void **)(v1 + 24);
  if (v4)
    CFRelease(v4);
  _Unwind_Resume(exception_object);
}

void HTTPMessage::HTTPMessage(HTTPMessage *this, const HTTPMessage *a2)
{
  CFTypeRef v4;

  *(_QWORD *)this = &off_1E14E50B0;
  *((_QWORD *)this + 1) = &unk_1E14E5120;
  *((_QWORD *)this + 2) = &unk_1E14E5140;
  *((_QWORD *)this + 4) = &off_1E14E9A00;
  v4 = (CFTypeRef)*((_QWORD *)a2 + 5);
  if (v4)
    v4 = CFRetain(v4);
  *((_QWORD *)this + 4) = &off_1E14EBF58;
  *((_QWORD *)this + 5) = v4;
  HTTPMessage::commonInitialization((uint64_t)this, *((_BYTE *)a2 + 24), (uint64_t)a2);
}

void sub_183F0255C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

const void *HTTPMessage::commonInitialization(uint64_t a1, char a2, uint64_t a3)
{
  os_unfair_lock_s *v5;
  uint64_t v6;
  CFTypeRef v7;
  const __CFAllocator *v8;
  _OWORD *v9;
  const __CFAllocator *v10;
  uint64_t v11;
  const __CFAllocator *v12;
  _QWORD *v13;
  const void *result;
  const __CFData *v15;
  const __CFAllocator *v16;
  _QWORD *v17;
  CFAllocatorRef v18;
  uint64_t v19;
  __int128 v20;
  int64_t v21;
  void *v22;
  CFTypeRef v23;

  *(_BYTE *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  if (a3)
  {
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a3 + 56);
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 96) = 0;
    *(_DWORD *)(a1 + 120) = 0;
    v5 = (os_unfair_lock_s *)(a3 + 120);
    os_unfair_lock_lock((os_unfair_lock_t)(a3 + 120));
    v6 = *(_QWORD *)(a3 + 104);
    if (v6 || (v6 = *(_QWORD *)(a3 + 96), *(_QWORD *)(a3 + 96) = 0, (*(_QWORD *)(a3 + 104) = v6) != 0))
      CFRetain((CFTypeRef)(v6 - 16));
    os_unfair_lock_unlock(v5);
    *(_QWORD *)(a1 + 104) = v6;
    v7 = *(CFTypeRef *)(a3 + 112);
    if (v7)
      v7 = CFRetain(v7);
    *(_QWORD *)(a1 + 112) = v7;
    if (*(_QWORD *)(a3 + 48))
    {
      v8 = CFGetAllocator((CFTypeRef)(a1 - 16));
      v9 = CFAllocatorAllocate(v8, 32, 0);
      *v9 = 0u;
      v9[1] = 0u;
      v10 = CFGetAllocator((CFTypeRef)(a1 - 16));
      v11 = *(_QWORD *)(a3 + 48);
      *(_QWORD *)v9 = off_1E14E5A48;
      *((_QWORD *)v9 + 1) = v10;
      if (*(_QWORD *)(v11 + 16))
      {
        *((_QWORD *)v9 + 2) = CFRetain(*(CFTypeRef *)(v11 + 16));
      }
      else
      {
        v15 = *(const __CFData **)(v11 + 24);
        if (v15)
          *((_QWORD *)v9 + 3) = CFDataCreateMutableCopy(v10, 0, v15);
      }
      *(_QWORD *)(a1 + 48) = v9;
    }
    os_unfair_lock_lock(v5);
    if (*(_QWORD *)(a3 + 88))
    {
      v16 = CFGetAllocator((CFTypeRef)(a1 - 16));
      v17 = CFAllocatorAllocate(v16, 592, 0);
      bzero(v17, 0x250uLL);
      v18 = CFGetAllocator((CFTypeRef)(a1 - 16));
      v19 = *(_QWORD *)(a3 + 88);
      *v17 = off_1E14E49E0;
      v17[1] = v18;
      v17[2] = &unk_1E14E4A00;
      v17[3] = a1 + 16;
      *((_BYTE *)v17 + 32) = *(_BYTE *)(v19 + 32);
      *(_QWORD *)((char *)v17 + 36) = *(_QWORD *)(v19 + 36);
      v20 = *(_OWORD *)(v19 + 568);
      *(_OWORD *)(v17 + 71) = v20;
      v21 = *(_QWORD *)(v19 + 576);
      if (v21 > 511)
      {
        v22 = malloc_type_malloc(v20, 0xE61BA9BEuLL);
        v17[70] = v22;
        v21 = *(_QWORD *)(v19 + 576);
      }
      else
      {
        v22 = (char *)v17 + 44;
        v17[70] = (char *)v17 + 44;
      }
      memcpy(v22, *(const void **)(v19 + 560), v21);
      v17[73] = *(_QWORD *)(v19 + 584);
      *(_QWORD *)(a1 + 88) = v17;
    }
    os_unfair_lock_unlock(v5);
    v23 = *(CFTypeRef *)(a3 + 72);
    *(_QWORD *)(a1 + 64) = *(_QWORD *)(a3 + 64);
    if (v23)
      v23 = CFRetain(v23);
    *(_QWORD *)(a1 + 72) = v23;
    result = *(const void **)(a3 + 80);
    if (result)
      result = CFRetain(result);
    *(_QWORD *)(a1 + 80) = result;
  }
  else
  {
    *(_DWORD *)(a1 + 56) = 1;
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 96) = 0;
    *(_DWORD *)(a1 + 120) = 0;
    v12 = CFGetAllocator((CFTypeRef)(a1 - 16));
    v13 = CFAllocatorAllocate(v12, 592, 0);
    bzero(v13, 0x250uLL);
    result = CFGetAllocator((CFTypeRef)(a1 - 16));
    *v13 = off_1E14E49E0;
    v13[1] = result;
    v13[2] = &unk_1E14E4A00;
    v13[3] = a1 + 16;
    *((_BYTE *)v13 + 32) = 0;
    *((_DWORD *)v13 + 9) = 0;
    *((_DWORD *)v13 + 10) = 0;
    v13[71] = 512;
    v13[70] = (char *)v13 + 44;
    *((_OWORD *)v13 + 36) = xmmword_1841E38C0;
    *(_QWORD *)(a1 + 88) = v13;
  }
  return result;
}

void sub_183F02804(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 16) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

HTTPRequest *HTTPRequest::commonInitialization(HTTPRequest *this, const HTTPRequest *a2)
{
  HTTPRequest *v2;
  const __CFAllocator *v4;
  CFTypeRef v5;
  const __CFAllocator *v6;
  CFIndex Count;
  char v8;

  v2 = this;
  if (a2)
  {
    if (*((_QWORD *)a2 + 23))
    {
      v4 = CFGetAllocator((char *)this - 16);
      *((_QWORD *)v2 + 23) = CFArrayCreateCopy(v4, *((CFArrayRef *)a2 + 23));
    }
    v5 = (CFTypeRef)*((_QWORD *)a2 + 24);
    if (v5)
      v5 = CFRetain(v5);
    *((_QWORD *)v2 + 24) = v5;
    if (*((_QWORD *)a2 + 26))
    {
      v6 = CFGetAllocator((char *)v2 - 16);
      Count = CFArrayGetCount(*((CFArrayRef *)a2 + 26));
      *((_QWORD *)v2 + 26) = CFArrayCreateMutableCopy(v6, Count, *((CFArrayRef *)a2 + 26));
    }
    this = (HTTPRequest *)*((_QWORD *)a2 + 25);
    if (this)
      this = (HTTPRequest *)CFRetain(this);
    *((_QWORD *)v2 + 25) = this;
    *((_BYTE *)v2 + 216) = *((_BYTE *)a2 + 216);
    *((_WORD *)v2 + 108) = *((_WORD *)a2 + 108);
    *((_BYTE *)v2 + 218) = *((_BYTE *)a2 + 218);
    v8 = *((_BYTE *)a2 + 219);
  }
  else
  {
    v8 = 0;
    *(_OWORD *)((char *)this + 200) = 0u;
    *(_OWORD *)((char *)this + 184) = 0u;
    *((_WORD *)this + 108) = 256;
    *((_BYTE *)this + 218) = 0;
  }
  *((_BYTE *)v2 + 219) = v8;
  return this;
}

CFNumberRef URLRequest::createArchiveList(URLRequest *this, CFAllocatorRef allocator, uint64_t *a3, const void ***a4, uint64_t *a5, const __CFDictionary **a6)
{
  const void *fProtocolProperties;
  const void **v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *fURL;
  const void *fMainDocumentURL;
  const void *v19;
  const void *fProxyDict;
  const __CFDictionary *fSSLProps;
  __CFArray *Mutable;
  const __CFArray *Value;
  const __CFArray *v24;
  CFIndex Count;
  CFIndex v26;
  CFIndex i;
  __SecCertificate *ValueAtIndex;
  CFDataRef v29;
  CFDataRef v30;
  __CFDictionary *MutableCopy;
  __CFDictionary *v32;
  const void *v33;
  const void *v34;
  CFNumberRef result;
  __CFArray *Archive;
  uint64_t v37;
  uint64_t v38;
  const __CFArray *v39;
  const __CFAllocator *allocatora;
  uint64_t *v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t valuePtr;

  fProtocolProperties = this->fProtocolProperties;
  if (fProtocolProperties)
    fProtocolProperties = CFRetain(fProtocolProperties);
  *a6 = (const __CFDictionary *)fProtocolProperties;
  v13 = (const void **)CFAllocatorAllocate(allocator, 176, 0);
  *a4 = v13;
  *a3 = 9;
  v14 = (const void *)*MEMORY[0x1E0C9AE50];
  v15 = (const void *)*MEMORY[0x1E0C9AE40];
  if ((*(_WORD *)&this->fFlags & 2) != 0)
    v16 = (const void *)*MEMORY[0x1E0C9AE50];
  else
    v16 = (const void *)*MEMORY[0x1E0C9AE40];
  *v13 = v16;
  CFRetain(v16);
  fURL = this->fURL;
  if (fURL)
    fURL = CFRetain(fURL);
  v13[1] = fURL;
  v13[2] = CFNumberCreate(allocator, kCFNumberDoubleType, &this->fTimeout);
  valuePtr = this->fCachePolicy;
  v13[3] = CFNumberCreate(allocator, kCFNumberCFIndexType, &valuePtr);
  fMainDocumentURL = this->fMainDocumentURL;
  if (fMainDocumentURL)
    fMainDocumentURL = CFRetain(fMainDocumentURL);
  v13[4] = fMainDocumentURL;
  if ((*(_WORD *)&this->fFlags & 1) != 0)
    v19 = v14;
  else
    v19 = v15;
  v13[5] = v19;
  CFRetain(v19);
  v44 = (*(_WORD *)&this->fFlags >> 2) & 0x1000 | (*(_WORD *)&this->fFlags >> 3) & 0x7C0 | (*(_WORD *)&this->fFlags >> 4) & 0x1Eu;
  v13[6] = CFNumberCreate(allocator, kCFNumberCFIndexType, &v44);
  fProxyDict = this->fProxyDict;
  if (fProxyDict)
    fProxyDict = CFRetain(fProxyDict);
  v13[7] = fProxyDict;
  fSSLProps = this->fSSLProps;
  if (fSSLProps)
  {
    if (CFDictionaryContainsKey(fSSLProps, &unk_1EDCFB2F0))
    {
      v41 = a5;
      allocatora = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
      Value = (const __CFArray *)CFDictionaryGetValue(this->fSSLProps, &unk_1EDCFB2F0);
      if (Value)
      {
        v24 = Value;
        Count = CFArrayGetCount(Value);
        if (Count >= 1)
        {
          v26 = Count;
          for (i = 0; i != v26; ++i)
          {
            ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(v24, i);
            if (ValueAtIndex)
            {
              v29 = SecCertificateCopyData(ValueAtIndex);
              if (v29)
              {
                v30 = v29;
                CFArrayInsertValueAtIndex(Mutable, i, v29);
                CFRelease(v30);
              }
            }
          }
        }
      }
      a5 = v41;
      if (Mutable)
      {
        if (CFArrayGetCount(Mutable) >= 1)
        {
          MutableCopy = CFDictionaryCreateMutableCopy(allocatora, 0, this->fSSLProps);
          if (MutableCopy)
          {
            v32 = MutableCopy;
            CFDictionaryReplaceValue(MutableCopy, &unk_1EDCFB2F0, Mutable);
            CFRelease(Mutable);
            v13[8] = CFRetain(v32);
            CFRelease(v32);
            goto LABEL_32;
          }
        }
        CFRelease(Mutable);
      }
    }
    fSSLProps = this->fSSLProps;
    if (fSSLProps)
      fSSLProps = (const __CFDictionary *)CFRetain(fSSLProps);
  }
  v13[8] = fSSLProps;
LABEL_32:
  if ((*(_WORD *)&this->fFlags & 8) != 0)
    v33 = v14;
  else
    v33 = v15;
  v13[9] = v33;
  if (v33)
    CFRetain(v33);
  if ((*(_WORD *)&this->fFlags & 0x10) != 0)
    v34 = v14;
  else
    v34 = v15;
  v13[10] = v34;
  if (v34)
    CFRetain(v34);
  v43 = 0;
  v13[11] = CFNumberCreate(allocator, kCFNumberCFIndexType, &v43);
  v13[12] = CFNumberCreate(allocator, kCFNumberDoubleType, &this->fTimeWindowDelay);
  v13[13] = CFNumberCreate(allocator, kCFNumberDoubleType, &this->fTimeWindowDuration);
  v13[14] = CFNumberCreate(allocator, kCFNumberCFIndexType, &this->fNetworkServiceType);
  result = CFNumberCreate(allocator, kCFNumberCFIndexType, &this->fRequestPriority);
  v13[15] = result;
  if (this->fHTTPRequest)
  {
    if (newCookieStorageEnabled(void)::onceToken != -1)
      dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
    if (newCookieStorageEnabled(void)::enabled || (v38 = *((_QWORD *)this->fHTTPRequest + 24)) == 0)
    {
      Archive = 0;
    }
    else
    {
      if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
        dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
      Archive = HTTPCookieStorage::createArchive((HTTPCookieStorage *)(v38 + 16), 0);
    }
    v13[16] = Archive;
    v42 = 2;
    v13[17] = CFNumberCreate(allocator, kCFNumberIntType, &v42);
    v13[18] = CFHTTPMessageCopyRequestMethod((CFHTTPMessageRef)((char *)this->fHTTPRequest - 16));
    v13[19] = HTTPMessage::copyHeadersWithShadowedArrayValues((HTTPMessage *)this->fHTTPRequest);
    v13[20] = CFHTTPMessageCopyBody((CFHTTPMessageRef)((char *)this->fHTTPRequest - 16));
    v39 = (const __CFArray *)*((_QWORD *)this->fHTTPRequest + 26);
    if (v39)
      result = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v39);
    else
      result = 0;
    v13[21] = result;
    v37 = 22;
  }
  else
  {
    v37 = 16;
  }
  *a5 = v37;
  return result;
}

CFDataRef HTTPMessage::copyBody(HTTPMessage *this)
{
  const char *v2;
  uint64_t v3;
  const void *v4;

  HTTPMessage::ensureParserFinished(this);
  v3 = *((_QWORD *)this + 6);
  if (!v3)
    return 0;
  HTTPBodyData::logit((HTTPBodyData *)v3, v2);
  v4 = *(const void **)(v3 + 24);
  if (v4)
  {
    *(_QWORD *)(v3 + 16) = v4;
    *(_QWORD *)(v3 + 24) = 0;
    return (CFDataRef)CFRetain(v4);
  }
  v4 = *(const void **)(v3 + 16);
  if (v4)
    return (CFDataRef)CFRetain(v4);
  return CFDataCreate(*(CFAllocatorRef *)(v3 + 8), 0, 0);
}

__CFString *URLRequest::setBoundInterfaceIdentifier(URLRequest *this, __CFString *cf)
{
  __CFString *result;

  result = this->fBoundInterfaceIdentifier;
  if (result != cf)
  {
    if (result)
      CFRelease(result);
    if (cf)
      result = (__CFString *)CFRetain(cf);
    else
      result = 0;
    this->fBoundInterfaceIdentifier = result;
  }
  return result;
}

void sub_183F03B2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_183F047A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void sub_183F04AB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, void (*a20)(char *))
{
  a20(&a18);
  os_unfair_lock_unlock((os_unfair_lock_t)&_lock);
  _Unwind_Resume(a1);
}

void sub_183F04F0C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183F0520C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  _QWORD *v4;
  va_list va;

  va_start(va, a4);
  CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::~PropDecanter((uint64_t *)va);
  *v4 = &off_1E14E5838;
  MEMORY[0x186DB748C](v4, 0x91C40C859B4A5);
  _Unwind_Resume(a1);
}

_QWORD *CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::~PropDecanter(_QWORD *a1)
{
  const void *v2;
  uint64_t i;
  void *v4;

  *a1 = &off_1E14F1E00;
  v2 = (const void *)a1[42];
  if (v2)
    CFRelease(v2);
  for (i = 1; i != 20; ++i)
  {
    v4 = (void *)a1[i];
    if (v4)
      free(v4);
  }
  return a1;
}

unsigned int *Decanter::decant(Decanter *this, CFAllocatorRef allocator)
{
  uint64_t v4;
  __CFDictionary *Mutable;
  int *v6;
  const CFDictionaryValueCallBacks *v7;
  int v8;
  int v9;
  char *v10;
  char *v11;
  CFStringRef v12;
  char *v13;
  size_t v14;
  const __CFData *Data;
  CFIndex Length;
  unsigned int *v17;
  unsigned int v18;
  int v19;
  int v20;
  unsigned int v21;
  double v22;
  double v23;
  double v24;
  double v25;
  unint64_t v26;
  unsigned int v27;
  NSObject *v28;
  __int16 v29;
  unint64_t v30;
  uint64_t v31;
  int *v32;
  unint64_t v33;
  char *v34;
  void *v35;
  BOOL v37;
  uint64_t v39;
  size_t v40;
  char *v41;
  BOOL v42;
  const UInt8 *BytePtr;
  uint64_t v44;
  const __CFData *cf;
  char v46;
  uint64_t v47;
  uint8_t buf[16];

  v4 = 0;
  Mutable = 0;
  v6 = &dword_18411E208;
  v7 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  do
  {
    v9 = *v6;
    v6 += 5;
    v8 = v9;
    if (v9 == 8)
    {
      *((_DWORD *)this + 80) += (*(uint64_t (**)(Decanter *))(*(_QWORD *)this + 24))(this);
    }
    else if (v8 == 1)
    {
      v10 = (char *)(*(uint64_t (**)(Decanter *, uint64_t))(*(_QWORD *)this + 16))(this, v4);
      v11 = v10;
      if (v4 == 15)
      {
        if (v10)
        {
          if (!Mutable)
            Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], v7);
          v12 = CFStringCreateWithCString(allocator, v11, 0x8000100u);
          CFDictionarySetValue(Mutable, &gConstantCFStringValueTable[1841], v12);
          if (v12)
            CFRelease(v12);
          if ((*(unsigned int (**)(Decanter *))(*(_QWORD *)this + 72))(this))
            free(v11);
        }
      }
      else
      {
        v13 = (char *)this + 8 * v4;
        *((_QWORD *)v13 + 1) = v10;
        if (v10)
        {
          if (v4 == 10 && !*v10)
          {
            v11 = "/";
            if ((*(unsigned int (**)(Decanter *))(*(_QWORD *)this + 72))(this))
            {
              free(*((void **)v13 + 1));
              v11 = strdup("/");
            }
            *((_QWORD *)v13 + 1) = v11;
          }
          v14 = strlen(v11);
          *((_QWORD *)this + v4 + 20) = v14 + 1;
          *((_QWORD *)this + 39) += v14 + 1;
        }
        else if (((0x7DAEFuLL >> v4) & 1) == 0)
        {
          return 0;
        }
      }
    }
    ++v4;
  }
  while (v4 != 19);
  if (Mutable
    && (Data = CFPropertyListCreateData(allocator, Mutable, kCFPropertyListBinaryFormat_v1_0, 0, 0),
        CFRelease(Mutable),
        Data))
  {
    cf = Data;
    Length = CFDataGetLength(Data);
    v46 = 0;
  }
  else
  {
    cf = 0;
    Length = 0;
    v46 = 1;
  }
  v47 = *((_QWORD *)this + 39) + 2 * *((unsigned int *)this + 80) + 56;
  v17 = (unsigned int *)CFAllocatorAllocate(allocator, v47 + Length, 0);
  *v17 = v47 + Length;
  v18 = (*(uint64_t (**)(Decanter *))(*(_QWORD *)this + 32))(this);
  if (*v17 <= 3 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write offset start greater than length", buf, 2u);
  }
  if (*v17 <= 7 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write expectedLength plus offset greater than length", buf, 2u);
  }
  v17[1] = v18;
  v19 = (*(uint64_t (**)(Decanter *))(*(_QWORD *)this + 40))(this);
  if (*v17 <= 7 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write offset start greater than length", buf, 2u);
  }
  v20 = v19 | ((_DWORD)Length << 8);
  if (*v17 <= 0xB && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write expectedLength plus offset greater than length", buf, 2u);
  }
  v17[2] = v20;
  v21 = *((_DWORD *)this + 80);
  if (*v17 <= 0xB && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write offset start greater than length", buf, 2u);
  }
  if (*v17 <= 0xF && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write expectedLength plus offset greater than length", buf, 2u);
  }
  v17[3] = v21;
  if ((*(unsigned __int8 (**)(Decanter *))(*(_QWORD *)this + 56))(this))
  {
    v23 = v22;
    v24 = CFAbsoluteTimeGetCurrent() + 34560000.0;
    if (v24 < v23)
      v23 = v24;
    if (*v17 <= 0x27 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write offset start greater than length", buf, 2u);
    }
    if (*v17 <= 0x2F && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write expectedLength plus offset greater than length", buf, 2u);
    }
    *(_QWORD *)buf = floor(v23);
    *((_QWORD *)v17 + 5) = *(_QWORD *)buf;
  }
  v25 = (*(double (**)(Decanter *))(*(_QWORD *)this + 64))(this);
  if (*v17 <= 0x2F && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write offset start greater than length", buf, 2u);
  }
  v44 = Length;
  if (*v17 <= 0x37 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write expectedLength plus offset greater than length", buf, 2u);
  }
  *(_QWORD *)buf = floor(v25);
  *((_QWORD *)v17 + 6) = *(_QWORD *)buf;
  if (*((_DWORD *)this + 80))
  {
    v26 = 0;
    v27 = 58;
    v28 = MEMORY[0x1E0C81028];
    do
    {
      v29 = (*(uint64_t (**)(Decanter *, unint64_t))(*(_QWORD *)this + 48))(this, v26);
      if (*v17 < v27 - 2 && os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_183ECA000, v28, OS_LOG_TYPE_FAULT, "write offset start greater than length", buf, 2u);
      }
      if (v27 > *v17 && os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_183ECA000, v28, OS_LOG_TYPE_FAULT, "write expectedLength plus offset greater than length", buf, 2u);
      }
      *(_WORD *)((char *)v17 + v27 - 2) = v29;
      ++v26;
      v27 += 2;
    }
    while (v26 < *((unsigned int *)this + 80));
  }
  v30 = 0;
  v31 = v47 - *((_QWORD *)this + 39);
  v32 = CookieData::sCookieFieldInfo;
  do
  {
    if (v30 == 15)
    {
      LODWORD(v33) = 0;
    }
    else
    {
      v34 = (char *)this + 8 * v30;
      v35 = (void *)*((_QWORD *)v34 + 1);
      if (((0xA513uLL >> v30) & 1) == 0 || v35)
      {
        CompactCookieHeader::setEnumeratedStringValue(v17, *v32, v31, v35, *((_QWORD *)v34 + 20));
        LODWORD(v33) = 0;
        v31 += *((_QWORD *)v34 + 20);
      }
      else
      {
        v33 = (0x2510uLL >> v30) & 1;
        CompactCookieHeader::setEnumeratedStringValue(v17, *v32, 0, 0, 0);
        if ((_DWORD)v33)
          break;
      }
    }
    v32 += 5;
  }
  while (v30++ < 0x12);
  if ((_DWORD)v33)
  {
    v37 = 0;
  }
  else
  {
    v39 = *((_QWORD *)this + 33) + *((_QWORD *)this + 28);
    v37 = v39 < 4099;
    if (v44 >= 1 && v39 <= 4098)
    {
      if (*v17 >= 0xC)
        v40 = (unint64_t)v17[2] >> 8;
      else
        v40 = 0;
      if (CFDataGetLength(cf) != v40 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "external data length doesn't match data", buf, 2u);
      }
      v41 = (char *)v17 + *v17 - v40;
      v42 = __CFADD__(v40, v41);
      v37 = 1;
      if (v41 >= (char *)v17 && !v42)
      {
        BytePtr = CFDataGetBytePtr(cf);
        memcpy(v41, BytePtr, v40);
      }
    }
  }
  if ((v46 & 1) == 0)
    CFRelease(cf);
  if (!v37)
  {
    CFAllocatorDeallocate(allocator, v17);
    return 0;
  }
  return v17;
}

void CompactCookieHeader::setEnumeratedStringValue(unsigned int *a1, int a2, unsigned int a3, void *__src, unsigned int a5)
{
  unsigned int v9;
  uint8_t v10[16];

  switch(a2)
  {
    case 0:
      if (*a1 <= 0x1F && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v10 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write offset start greater than length", v10, 2u);
      }
      if (*a1 <= 0x23 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v10 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write expectedLength plus offset greater than length", v10, 2u);
      }
      a1[8] = a3;
      if (__src)
      {
        if (*a1 < 0x24)
          goto LABEL_55;
        v9 = a1[8];
        goto LABEL_56;
      }
      break;
    case 1:
      if (*a1 <= 0x23 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v10 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write offset start greater than length", v10, 2u);
      }
      if (*a1 <= 0x27 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v10 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write expectedLength plus offset greater than length", v10, 2u);
      }
      a1[9] = a3;
      if (__src)
      {
        if (*a1 < 0x28)
          goto LABEL_55;
        v9 = a1[9];
        goto LABEL_56;
      }
      break;
    case 4:
      if (*a1 <= 0xF && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v10 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write offset start greater than length", v10, 2u);
      }
      if (*a1 <= 0x13 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v10 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write expectedLength plus offset greater than length", v10, 2u);
      }
      a1[4] = a3;
      if (__src)
      {
        if (*a1 < 0x14)
          goto LABEL_55;
        v9 = a1[4];
        goto LABEL_56;
      }
      break;
    case 8:
      if (*a1 <= 0x13 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v10 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write offset start greater than length", v10, 2u);
      }
      if (*a1 <= 0x17 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v10 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write expectedLength plus offset greater than length", v10, 2u);
      }
      a1[5] = a3;
      if (__src)
      {
        if (*a1 < 0x18)
          goto LABEL_55;
        v9 = a1[5];
        goto LABEL_56;
      }
      break;
    case 10:
      if (*a1 <= 0x17 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v10 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write offset start greater than length", v10, 2u);
      }
      if (*a1 <= 0x1B && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v10 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write expectedLength plus offset greater than length", v10, 2u);
      }
      a1[6] = a3;
      if (__src)
      {
        if (*a1 < 0x1C)
          goto LABEL_55;
        v9 = a1[6];
        goto LABEL_56;
      }
      break;
    case 13:
      if (*a1 <= 0x1B && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v10 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write offset start greater than length", v10, 2u);
      }
      if (*a1 <= 0x1F && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v10 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write expectedLength plus offset greater than length", v10, 2u);
      }
      a1[7] = a3;
      if (__src)
      {
        if (*a1 >= 0x20)
          v9 = a1[7];
        else
LABEL_55:
          v9 = 0;
LABEL_56:
        if (a5 != 4 || v9)
        {
          if (*a1 < v9 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)v10 = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write offset start greater than length", v10, 2u);
          }
          if (v9 + a5 > *a1 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)v10 = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "write expectedLength plus offset greater than length", v10, 2u);
          }
        }
        memcpy((char *)a1 + v9, __src, a5);
      }
      break;
    case 15:
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v10 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "shouldn't get here for external fields", v10, 2u);
      }
      break;
    default:
      return;
  }
}

char *CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::getEnumeratedString(uint64_t a1, int a2)
{
  uint64_t (*v3)(uint64_t, const __CFString *);
  BOOL v4;
  const void *Value;
  const void *v6;
  const __CFString *v7;
  const __CFString *v8;
  const __CFString *v9;
  UInt8 *CString;
  char *v11;
  BOOL v12;
  const __CFAllocator *allocator;
  uint64_t v15[2];
  UInt8 v16[1024];
  uint64_t v17;

  v3 = 0;
  v17 = *MEMORY[0x1E0C80C00];
  v4 = 1;
  switch(a2)
  {
    case 4:
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 328), &unk_1EDCFC710);
      v4 = 0;
      if (Value)
        a2 = 4;
      else
        a2 = 9;
      if (Value)
        v3 = (uint64_t (*)(uint64_t, const __CFString *))CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::ensureDomain;
      else
        v3 = (uint64_t (*)(uint64_t, const __CFString *))CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::ensureOriginURLToDomain;
      break;
    case 8:
      v4 = 0;
      v3 = (uint64_t (*)(uint64_t, const __CFString *))CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::ensureValidName;
      break;
    case 9:
      v6 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 328), &unk_1EDCFC860);
      v4 = v6 != 0;
      if (v6)
        v3 = 0;
      else
        v3 = (uint64_t (*)(uint64_t, const __CFString *))CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::ensureDomainToOriginURL;
      a2 = 9;
      break;
    case 13:
      v4 = 0;
      v3 = (uint64_t (*)(uint64_t, const __CFString *))CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::ensureValidValue;
      break;
    default:
      break;
  }
  v7 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 328), &gConstantCFStringValueTable[7* ((CookieData::sCookieFieldInfo[5 * a2 + 1] >> 20) & 0x3FF)]);
  if (!v7)
    return 0;
  v8 = v7;
  if (!v4)
  {
    v9 = (const __CFString *)v3(a1, v7);
    if (v9)
      goto LABEL_18;
    return 0;
  }
  v9 = v7;
LABEL_18:
  allocator = CFGetAllocator(*(CFTypeRef *)(a1 + 328));
  v15[0] = 1023;
  CString = _CFStringGetOrCreateCString(allocator, v9, v16, v15, 0x8000100u);
  v15[1] = (uint64_t)CString;
  v11 = strdup((const char *)CString);
  if (CString)
    v12 = v16 == CString;
  else
    v12 = 1;
  if (!v12)
    CFAllocatorDeallocate(allocator, CString);
  if (v8 != v9)
    CFRelease(v9);
  return v11;
}

UInt8 *_CFStringGetOrCreateCString(const __CFAllocator *a1, CFStringRef theString, UInt8 *a3, uint64_t *a4, CFStringEncoding a5)
{
  CFIndex *usedBufLen;
  CFIndex Length;
  CFIndex v12;
  UInt8 *v13;
  CFIndex maxBufLen;
  uint64_t v16;
  CFRange v17;
  CFRange v18;

  v16 = 0;
  usedBufLen = a4;
  if (!a4)
  {
    v16 = 0;
    usedBufLen = &v16;
  }
  maxBufLen = 0;
  Length = CFStringGetLength(theString);
  v17.location = 0;
  v17.length = Length;
  CFStringGetBytes(theString, v17, a5, 0, 0, 0, 0, &maxBufLen);
  v12 = maxBufLen;
  if (a3 && *usedBufLen > maxBufLen)
    goto LABEL_7;
  v13 = (UInt8 *)CFAllocatorAllocate(a1, maxBufLen + 1, 0);
  if (v13)
  {
    v12 = maxBufLen;
    a3 = v13;
LABEL_7:
    v18.location = 0;
    v18.length = Length;
    CFStringGetBytes(theString, v18, a5, 0, 0, a3, v12, usedBufLen);
    a3[*usedBufLen] = 0;
    return a3;
  }
  if (a4)
  {
    if (a3 && *a4 >= 1)
      *a3 = 0;
    *a4 = 0;
  }
  return a3;
}

uint64_t CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::getExpireTime(uint64_t a1)
{
  uint64_t v2;
  const __CFNumber *Value;
  const __CFNumber *v5;
  CFTypeID v6;
  UInt8 *v7;
  UInt8 *v8;
  int64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  SInt32 v15;
  _BYTE *v16;
  _BYTE *v17;
  _BYTE *v18;
  int v19;
  _BYTE *v20;
  _BYTE *v21;
  int v22;
  _BYTE *v23;
  _BYTE *v24;
  int v25;
  uint64_t v26;
  CFGregorianDate v27;
  _BYTE v28[4];
  const __CFAllocator *valuePtr;
  uint64_t v30;
  UInt8 *v31;
  UInt8 v32[1024];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v26 = 0;
  if (CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::getNumberValue(*(const __CFDictionary **)(a1 + 328), &unk_1EDCFC7F0, &v26))
  {
    CFAbsoluteTimeGetCurrent();
    return 1;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 328), &unk_1EDCFC748);
  if (!Value)
    return 0;
  v5 = Value;
  v6 = CFGetTypeID(Value);
  if (v6 == CFDateGetTypeID())
  {
    MEMORY[0x186DB5F80](v5);
    return 1;
  }
  if (v6 != CFStringGetTypeID())
  {
    if (v6 == CFNumberGetTypeID())
    {
      valuePtr = 0;
      CFNumberGetValue(v5, kCFNumberDoubleType, &valuePtr);
      return 1;
    }
    return 0;
  }
  valuePtr = CFGetAllocator(v5);
  v30 = 1023;
  v7 = _CFStringGetOrCreateCString(valuePtr, (CFStringRef)v5, v32, &v30, 0x8000100u);
  v8 = v7;
  v31 = v7;
  *(_QWORD *)&v27.year = 0;
  v27.second = 0.0;
  if (v7)
  {
    v9 = strlen((const char *)v7);
    if (v9 >= 5)
    {
      v10 = 0;
      v11 = (unint64_t)&v8[v9];
      v12 = MEMORY[0x1E0C80978];
      while (1)
      {
        v13 = (char)v8[v10];
        v28[v10] = v8[v10];
        if (v13 < 0 || (*(_DWORD *)(v12 + 4 * v13 + 60) & 0x400) == 0)
          break;
        if (++v10 == 4)
        {
          v14 = 0;
          v15 = 0;
          do
            v15 = (char)v28[v14++] + 10 * v15 - 48;
          while (v14 != 4);
          v27.year = v15;
          if (v8[4] == 45)
          {
            if (v9 < 8)
            {
              v16 = v8 + 5;
            }
            else
            {
              if (!read2((const char *)v8[5], (signed __int8 *)v8[6], &v27.month))
                goto LABEL_43;
              v16 = v8 + 7;
            }
            if ((unint64_t)v16 < v11)
            {
              v17 = v16 + 1;
              if (*v16 == 45)
              {
                v18 = v16 + 3;
                if ((unint64_t)(v16 + 3) >= v11
                  || (v19 = read2((const char *)v16[1], (signed __int8 *)v16[2], &v27.day), v17 = v18, v19))
                {
                  if ((unint64_t)v17 < v11)
                  {
                    v20 = v17 + 1;
                    if (*v17 == 84)
                    {
                      v21 = v17 + 3;
                      if ((unint64_t)(v17 + 3) >= v11
                        || (v22 = read2((const char *)v17[1], (signed __int8 *)v17[2], &v27.hour), v20 = v21, v22))
                      {
                        if ((unint64_t)v20 < v11)
                        {
                          v23 = v20 + 1;
                          if (*v20 == 58)
                          {
                            v24 = v20 + 3;
                            if ((unint64_t)(v20 + 3) >= v11
                              || (v25 = read2((const char *)v20[1], (signed __int8 *)v20[2], &v27.minute), v23 = v24, v25))
                            {
                              if ((unint64_t)v23 < v11 && *v23 == 58 && (unint64_t)(v23 + 3) < v11)
                              {
                                v28[0] = 0;
                                if (read2((const char *)v23[1], (signed __int8 *)v23[2], v28))v27.second = (double)v28[0];
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          goto LABEL_43;
        }
      }
    }
    v2 = 0;
  }
  else
  {
LABEL_43:
    CFGregorianDateGetAbsoluteTime(v27, 0);
    v8 = v31;
    v2 = 1;
  }
  if (v8 && v32 != v8)
    CFAllocatorDeallocate(valuePtr, v8);
  return v2;
}

void sub_183F0677C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, CFAllocatorRef allocator, uint64_t a14, void *ptr)
{
  void *v15;

  if (ptr)
  {
    if (v15 != ptr)
      CFAllocatorDeallocate(allocator, ptr);
  }
  _Unwind_Resume(exception_object);
}

uint64_t read2(const char *a1, signed __int8 *a2, _BYTE *a3)
{
  unsigned __int8 v3;
  uint64_t result;

  if ((a1 & 0x80) != 0)
    return 0;
  v3 = a1;
  result = 0;
  if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v3 + 60) & 0x400) != 0 && (a2 & 0x80) == 0)
  {
    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * a2 + 60) & 0x400) != 0)
    {
      *a3 = (_BYTE)a2 + 10 * v3 - 16;
      return 1;
    }
    return 0;
  }
  return result;
}

const __CFString *CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::getNumberValue(const __CFDictionary *a1, const void *a2, _QWORD *a3)
{
  const __CFString *result;

  result = (const __CFString *)CFDictionaryGetValue(a1, a2);
  if (result)
    return (const __CFString *)CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::valueToCFIndex(result, a3);
  return result;
}

const __CFString *CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::ensureValidName(int a1, const __CFString *cf)
{
  const __CFString *v2;
  CFTypeID v3;

  if (!cf)
    return 0;
  v2 = cf;
  v3 = CFGetTypeID(cf);
  if (v3 != CFStringGetTypeID()
    || CFStringGetLength(v2) < 1
    || !CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::stringIsHTTPHeaderClean(v2))
  {
    return 0;
  }
  return v2;
}

BOOL CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::stringIsHTTPHeaderClean(CFStringRef theString)
{
  const __CFCharacterSet *v2;
  CFRange v4;
  CFRange v5;

  v2 = (const __CFCharacterSet *)CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::stringIsHTTPHeaderClean(__CFString const*)::sNotAllowedSymbolsSet;
  if (!CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::stringIsHTTPHeaderClean(__CFString const*)::sNotAllowedSymbolsSet)
  {
    v2 = CFCharacterSetCreateWithCharactersInString(0, CFSTR("\n\r"));
    CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::stringIsHTTPHeaderClean(__CFString const*)::sNotAllowedSymbolsSet = (uint64_t)v2;
  }
  v5.length = CFStringGetLength(theString);
  v5.location = 0;
  return CFStringFindCharacterFromSet(theString, v2, v5, 0, &v4) == 0;
}

CFIndex CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::getPortCount(uint64_t a1)
{
  const void *Value;
  const void *v3;
  CFTypeID v4;
  const void *Array;
  const __CFAllocator *v6;

  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 328), &unk_1EDCFC8D0);
  if (Value)
  {
    v3 = Value;
    v4 = CFGetTypeID(Value);
    if (v4 == CFArrayGetTypeID())
    {
      Array = v3;
LABEL_5:
      Array = CFRetain(Array);
      goto LABEL_9;
    }
    if (v4 != CFStringGetTypeID() && v4 != CFNumberGetTypeID())
    {
      Array = *(const void **)(a1 + 336);
      return CFArrayGetCount((CFArrayRef)Array);
    }
    v6 = CFGetAllocator(*(CFTypeRef *)(a1 + 328));
    Array = cfTypeCreateArray(v6, v3, 0);
  }
  else
  {
    Array = (const void *)AutoArray::getEmptyArray(0);
    if (Array)
      goto LABEL_5;
  }
LABEL_9:
  *(_QWORD *)(a1 + 336) = Array;
  return CFArrayGetCount((CFArrayRef)Array);
}

CFStringRef CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::ensureDomain(int a1, const __CFString *cf)
{
  CFStringRef v2;
  CFTypeID v3;
  const __CFAllocator *v4;
  CFMutableStringRef MutableCopy;
  const __CFLocale *System;
  const __CFAllocator *v7;
  CFRange v9;

  v2 = cf;
  if (cf)
  {
    v3 = CFGetTypeID(cf);
    if (v3 == CFStringGetTypeID())
    {
      v4 = CFGetAllocator(v2);
      MutableCopy = CFStringCreateMutableCopy(v4, 0, v2);
      System = CFLocaleGetSystem();
      CFStringLowercase(MutableCopy, System);
      if (CFStringHasSuffix(MutableCopy, CFSTR(".")))
      {
        v7 = CFGetAllocator(v2);
        v9.length = CFStringGetLength(MutableCopy) - 1;
        v9.location = 0;
        v2 = CFStringCreateWithSubstring(v7, MutableCopy, v9);
        if (MutableCopy)
          CFRelease(MutableCopy);
      }
      else
      {
        return MutableCopy;
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t AutoArray::getEmptyArray(AutoArray *this)
{
  CFMutableArrayRef Mutable;

  if (!AutoArray::getEmptyArray(void)::sEmptyArray)
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    while (!__ldaxr((unint64_t *)&AutoArray::getEmptyArray(void)::sEmptyArray))
    {
      if (!__stlxr((unint64_t)Mutable, (unint64_t *)&AutoArray::getEmptyArray(void)::sEmptyArray))
        return AutoArray::getEmptyArray(void)::sEmptyArray;
    }
    __clrex();
    CFRelease(Mutable);
  }
  return AutoArray::getEmptyArray(void)::sEmptyArray;
}

uint64_t CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::getFlags(CFDictionaryRef *a1)
{
  uint64_t v2;
  const __CFString *Value;
  int CanonicalString;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = CFDictionaryGetValue(a1[41], &unk_1EDCFC940) != 0;
  if (CFDictionaryGetValue(a1[41], &unk_1EDCFC7B8))
    v2 |= 4uLL;
  if (CFDictionaryGetValue(a1[41], &unk_1EDCFC6D8)
    || !(*((unsigned __int8 (**)(CFDictionaryRef *))*a1 + 7))(a1))
  {
    v2 |= 2uLL;
  }
  Value = (const __CFString *)CFDictionaryGetValue(a1[41], &unk_1EDCFC908);
  if (Value)
  {
    CanonicalString = _findCanonicalString(Value, 4u);
    v5 = v2 | 0x10;
    if (CanonicalString == 281047645)
      v5 = v2 | 8;
    if (CanonicalString == 282104415)
      v6 = v2;
    else
      v6 = v5;
    if (CanonicalString == 283169378)
      v7 = v2 | 0x18;
    else
      v7 = v6;
  }
  else
  {
    v7 = v2 | 0x10;
  }
  if (CFDictionaryGetValue(a1[41], &unk_1EDCFC780) == (const void *)*MEMORY[0x1E0C9AE50])
    v7 |= 0x20uLL;
  if (CFDictionaryGetValue(a1[41], &unk_1EDCFC978))
    return v7 | 0x40;
  else
    return v7;
}

const __CFString *CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::ensureValidValue(int a1, const __CFString *cf)
{
  const __CFString *v2;
  CFTypeID v3;

  if (!cf)
    return 0;
  v2 = cf;
  v3 = CFGetTypeID(cf);
  if (v3 != CFStringGetTypeID()
    || !CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::stringIsHTTPHeaderClean(v2))
  {
    return 0;
  }
  return v2;
}

double CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::getCreateTime(uint64_t a1)
{
  const __CFString *Value;
  const __CFString *v2;
  CFTypeID v3;
  double valuePtr;

  Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 328), &unk_1EDCFC6A0);
  if (!Value)
    return CFAbsoluteTimeGetCurrent();
  v2 = Value;
  v3 = CFGetTypeID(Value);
  if (v3 == CFStringGetTypeID())
    return CFStringGetDoubleValue(v2);
  if (v3 != CFNumberGetTypeID())
    return CFAbsoluteTimeGetCurrent();
  valuePtr = 0.0;
  CFNumberGetValue((CFNumberRef)v2, kCFNumberDoubleType, &valuePtr);
  return valuePtr;
}

uint64_t CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::getVersion(uint64_t a1)
{
  uint64_t v2;

  v2 = 0;
  if (CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::getNumberValue(*(const __CFDictionary **)(a1 + 328), &unk_1EDCFCA20, &v2))return v2;
  else
    return 0;
}

void sub_183F06F2C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZN11HTTP3Stream20_buildRequestHeadersEv_block_invoke(uint64_t a1, void *a2, void *a3)
{
  NSString *v5;
  const __CFString *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  NSString *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t j;
  id v16;
  id obj;
  NSString *v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _BYTE v27[128];
  _BYTE v28[128];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v16 = a3;
  v18 = v5;
  if ((HTTPUtilities::isHeaderAllowed((HTTPUtilities *)v5, v6) & 1) != 0)
  {
    v7 = -[NSString caseInsensitiveCompare:](v5, "caseInsensitiveCompare:", 0x1EDCFCF28);
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    obj = v16;
    v8 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v23, v28, 16);
    if (v8)
    {
      v9 = *(_QWORD *)v24;
      do
      {
        for (i = 0; i != v8; ++i)
        {
          if (*(_QWORD *)v24 != v9)
            objc_enumerationMutation(obj);
          v11 = *(NSString **)(*((_QWORD *)&v23 + 1) + 8 * i);
          if (v7)
          {
            HTTP3Fields::appendField((std::vector<char> *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), v18, v11);
          }
          else
          {
            v21 = 0u;
            v22 = 0u;
            v19 = 0u;
            v20 = 0u;
            -[NSString componentsSeparatedByString:](v11, "componentsSeparatedByString:", CFSTR("; "));
            v12 = (void *)objc_claimAutoreleasedReturnValue();
            v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v19, v27, 16);
            if (v13)
            {
              v14 = *(_QWORD *)v20;
              do
              {
                for (j = 0; j != v13; ++j)
                {
                  if (*(_QWORD *)v20 != v14)
                    objc_enumerationMutation(v12);
                  HTTP3Fields::appendField((std::vector<char> *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), "cookie", *(NSString **)(*((_QWORD *)&v19 + 1) + 8 * j));
                }
                v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v19, v27, 16);
              }
              while (v13);
            }

          }
        }
        v8 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v23, v28, 16);
      }
      while (v8);
    }

  }
}

void sub_183F07160(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{

  _Unwind_Resume(a1);
}

uint64_t CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::valueToCFIndex(const __CFString *a1, _QWORD *a2)
{
  CFTypeID v4;
  uint64_t IntValue;
  uint64_t valuePtr;

  v4 = CFGetTypeID(a1);
  if (v4 == CFStringGetTypeID())
  {
    IntValue = CFStringGetIntValue(a1);
LABEL_5:
    *a2 = IntValue;
    return 1;
  }
  if (v4 == CFNumberGetTypeID())
  {
    valuePtr = 0;
    CFNumberGetValue((CFNumberRef)a1, kCFNumberCFIndexType, &valuePtr);
    IntValue = valuePtr;
    goto LABEL_5;
  }
  return 0;
}

BOOL HTTPProtocol::initialize(uint64_t a1, NSURLSessionTask *a2, URLProtocolClient *a3, int a4)
{
  uint64_t v7;
  void *v8;
  const void **v9;
  uint64_t v10;
  BOOL v11;
  const __CFURL *v12;
  const __CFString *v13;
  const __CFString *v14;
  const __CFDictionary *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const __CFDictionary *v20;
  const __CFDictionary *Value;
  NSString *v22;
  CFTypeRef v23;
  _QWORD *v24;
  uint64_t *v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  _CFHSTSPolicy *v29;
  const __CFDictionary *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  const void **v35;
  const void *v36;
  _BOOL4 v37;
  BOOL v38;
  const void *v39;
  const void *v40;
  NSObject *v41;
  unsigned int v42;
  const void *v43;
  char v44;
  int v45;
  int v46;
  CFTypeRef v47;
  const void *v48;
  NSObject *v49;
  id v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  void *v55;
  uint64_t v56;
  uint8_t buf[24];
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  URLProtocol::initialize((URLProtocol *)a1, a2, a3);
  *(_DWORD *)(a1 + 824) = a4;
  v7 = -[NSURLSessionTask session](a2, "session");
  if (!v7)
    return v7 != 0;
  v56 = v7;
  *(_QWORD *)(a1 + 744) = -[NSURLSessionTask session](a2, "session");
  *(_QWORD *)(a1 + 696) = -[NSURLSessionTask _createXCredentialStorage](a2, "_createXCredentialStorage");
  *(_QWORD *)(a1 + 752) = -[NSURLSessionTask _copySocketStreamProperties](a2, "_copySocketStreamProperties");
  *(_BYTE *)(a1 + 448) = 0;
  v8 = *(void **)(a1 + 88);
  v9 = (const void **)MEMORY[0x1E0C9AE50];
  if (!v8)
    goto LABEL_22;
  if (*(_DWORD *)(a1 + 824) == 1)
  {
    *(_QWORD *)(a1 + 760) = 1;
  }
  else
  {
    v10 = -[NSURLSessionTask _cachePolicy](a2, "_cachePolicy");
    *(_QWORD *)(a1 + 760) = v10;
    v11 = v10 != 4;
    if (v10 != 1)
      goto LABEL_7;
  }
  v11 = 0;
LABEL_7:
  *(_BYTE *)(a1 + 448) = v11;
  v12 = (const __CFURL *)objc_msgSend(v8, "cfURL");
  if (v12)
  {
    v13 = CFURLCopyScheme(v12);
    if (v13)
    {
      v14 = v13;
      if (CFStringCompare(v13, (CFStringRef)&unk_1EDD00AE0, 1uLL) == kCFCompareEqualTo)
        *(_DWORD *)(a1 + 192) |= 0x4000u;
      CFRelease(v14);
    }
  }
  v15 = *(const __CFDictionary **)(objc_msgSend(v8, "_inner") + 192);
  if (v15)
    goto LABEL_13;
  v20 = *(const __CFDictionary **)(objc_msgSend(v8, "_inner") + 40);
  if (v20)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(v20, &unk_1EDCFE620);
    if (Value)
    {
      v15 = Value;
LABEL_13:
      v16 = CFDictionaryGetValue(v15, CFSTR("NSAllowsArbitraryLoadsInWebContent"));
      v17 = *v9;
      if (v16 == *v9)
        v18 = *v9;
      else
        v18 = 0;
      if (CFDictionaryGetValue(v15, CFSTR("NSAllowsArbitraryLoadsForMedia")) == v17)
        v19 = v17;
      else
        v19 = 0;
      goto LABEL_23;
    }
  }
LABEL_22:
  v19 = 0;
  v18 = 0;
LABEL_23:
  v22 = -[NSURLSessionTask _loggableDescription](a2, "_loggableDescription");
  if (v22)
    v23 = CFRetain(v22);
  else
    v23 = 0;
  *(_QWORD *)buf = v23;
  v24 = (_QWORD *)operator new();
  *v24 = &off_1E14F19E8;
  v24[1] = 0;
  v24[2] = 0;
  v24[3] = v23;
  *(_QWORD *)&buf[8] = v24;
  v25 = (uint64_t *)(a1 + 792);
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 792, (__int128 *)buf);
  v26 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v27 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  v29 = -[NSURLSessionTask _copyHSTSPolicy](a2, "_copyHSTSPolicy");
  v30 = -[NSURLSessionTask _copyATSState](a2, "_copyATSState");
  v31 = -[NSURLSessionTask _backtrace](a2, "_backtrace");
  v32 = operator new();
  v55 = (void *)v31;
  if (v29)
  {
    if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1)
      dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_313);
    v33 = *v25;
    CFRetain(v29);
    v34 = (char *)v29 + 16;
  }
  else
  {
    v34 = 0;
    v33 = *v25;
  }
  *(_QWORD *)v32 = v34;
  *(_QWORD *)(v32 + 8) = 0;
  v35 = (const void **)(v32 + 8);
  *(_QWORD *)(v32 + 16) = 0;
  *(_QWORD *)(v32 + 24) = 0;
  *(_BYTE *)(v32 + 32) = *(_BYTE *)(v32 + 32) & 0xE0 | 5;
  *(_WORD *)(v32 + 33) = 0;
  *(_QWORD *)(v32 + 40) = 0;
  if (v30)
  {
    v36 = CFDictionaryGetValue(v30, CFSTR("NSAllowsArbitraryLoadsInWebContent"));
    v37 = v36 != 0;
    if (v36)
    {
      v38 = v36 == *v9;
      *(_BYTE *)(v32 + 32) = *(_BYTE *)(v32 + 32) & 0xFD | (2 * v38);
      if (v38 && atsDictionaryClientIDHasPrefix(v30, CFSTR("com.apple.WebKit")))
        *(_BYTE *)(v32 + 33) = 1;
    }
    v39 = CFDictionaryGetValue(v30, CFSTR("NSAllowsLocalNetworking"));
    if (v39)
    {
      *(_BYTE *)(v32 + 32) = *(_BYTE *)(v32 + 32) & 0xFB | (4 * (v39 == *v9));
      v37 = 1;
    }
    v40 = CFDictionaryGetValue(v30, CFSTR("NSAllowsArbitraryLoadsForMedia"));
    if (v40)
    {
      v38 = v40 == *v9;
      *(_BYTE *)(v32 + 32) = *(_BYTE *)(v32 + 32) & 0xF7 | (8 * v38);
      if (v38)
      {
        v37 = 1;
        if (atsDictionaryClientIDHasPrefix(v30, CFSTR("mediaserverd")))
          *(_BYTE *)(v32 + 34) = 1;
      }
      else
      {
        v37 = 1;
      }
    }
    else if ((*(_BYTE *)(v32 + 32) & 2) != 0)
    {
      *(_BYTE *)(v32 + 32) |= 8u;
    }
    v42 = *(unsigned __int8 *)(v32 + 32);
    v43 = *v9;
    v44 = v42 & 0xFE;
    v45 = (v43 == v18) & (v42 >> 1);
    if (v45)
      v42 &= ~1u;
    v46 = (v43 == v19) & (v42 >> 3);
    if ((v45 & 1) != 0 || v46)
    {
      if (!v46)
        v44 = v42;
      *(_BYTE *)(v32 + 32) = v44;
    }
    v47 = CFRetain(v30);
    v48 = *v35;
    *v35 = v47;
    if (v48)
    {
      CFRelease(v48);
      v47 = *v35;
    }
    if (((v37 | atsDictionaryAllowsArbitraryLoads((uint64_t)v47) ^ 1) & 1) == 0)
    {
      *(_BYTE *)(v32 + 32) &= ~1u;
      if (StrictSecurityPolicy::ATSLogLevel(void)::logATSOnce != -1)
        dispatch_once(&StrictSecurityPolicy::ATSLogLevel(void)::logATSOnce, &__block_literal_global_31);
      if (StrictSecurityPolicy::ATSLogLevel(void)::atslogLevel >= 2)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v49 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_183ECA000, v49, OS_LOG_TYPE_DEFAULT, "ATS Mode is Off", buf, 2u);
        }
      }
    }
    *(_BYTE *)(v32 + 32) = *(_BYTE *)(v32 + 32) & 0xEF | (16
                                                        * (CFDictionaryGetValue(v30, CFSTR("_ATSHasAppleBundleException")) == v43));
    *(_QWORD *)(v32 + 40) = v55;
    v50 = v55;
    *(_QWORD *)(a1 + 736) = v32;
    CFRelease(v30);
  }
  else
  {
    if (ATSLog(void)::onceToken != -1)
      dispatch_once(&ATSLog(void)::onceToken, &__block_literal_global_84_8989);
    v41 = ATSLog(void)::atsLog;
    if (os_log_type_enabled((os_log_t)ATSLog(void)::atsLog, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = v33;
      _os_log_debug_impl(&dword_183ECA000, v41, OS_LOG_TYPE_DEBUG, "No state for %{public}@", buf, 0xCu);
    }
    *(_QWORD *)(a1 + 736) = v32;
  }
  if (v29)
    CFRelease(v29);
  *(_DWORD *)(a1 + 728) = -[NSURLSessionTask _getAuthenticatorStatusCodes](a2, "_getAuthenticatorStatusCodes", v55) != 0;
  *(_BYTE *)(a1 + 768) = 0;
  *(_DWORD *)(a1 + 732) = 0;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_QWORD *)(a1 + 512) = -1;
  *(_QWORD *)(a1 + 456) = 0;
  *(_QWORD *)(a1 + 464) = 0;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 592, (__int128 *)buf);
  v51 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v52 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }
  *(_BYTE *)(a1 + 616) = 0;
  *(_QWORD *)(a1 + 720) = 0;
  *(_QWORD *)(a1 + 832) = -[NSURLSessionTask _metrics](a2, "_metrics");
  *(_QWORD *)(a1 + 880) = _Block_copy(-[NSURLSessionTask _httpConnectionInfoCompletionBlock](a2, "_httpConnectionInfoCompletionBlock"));
  v7 = v56;
  return v7 != 0;
}

void sub_183F079FC(_Unwind_Exception *a1)
{
  uint64_t *v1;
  const void **v2;
  const void *v4;
  const void *v5;
  const void *v6;
  uint64_t v7;

  v4 = (const void *)v1[3];
  v1[3] = 0;
  if (v4)
    CFRelease(v4);
  v5 = (const void *)v1[2];
  v1[2] = 0;
  if (v5)
    CFRelease(v5);
  v6 = *v2;
  *v2 = 0;
  if (v6)
    CFRelease(v6);
  v7 = *v1;
  *v1 = 0;
  if (v7)
    CFRelease((CFTypeRef)(v7 - 16));
  MEMORY[0x186DB748C](v1, 0x10E0C40084E53DELL);
  _Unwind_Resume(a1);
}

void TransportConnection::associateTask(NSObject *a1, NSURLSessionTask *a2, uint64_t a3, uint64_t a4)
{
  nw_data_transfer_report_t new_data_transfer_report;
  Class isa;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_weak_owners;
  unint64_t v11;
  unint64_t v12;
  objc_class *v13;
  objc_class *v14;
  Class v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  const char *v31;
  id *v32;
  id *v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  uint64_t v37;
  const char *v38;
  id v39;
  id v40;
  id v41;
  void *v42;
  nw_data_transfer_report_t v43;
  void *v44;
  uint64_t v45;
  _QWORD aBlock[2];
  void (*v47)(uint64_t, uint64_t);
  void *v48;
  Class v49;
  std::__shared_weak_count *v50;
  uint64_t v51;
  uint64_t v52;
  void (*v53)(uint64_t, void *);
  void *v54;
  _BYTE *v55;
  _QWORD v56[2];
  _QWORD v57[2];
  _BYTE buf[24];
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(uint64_t);
  id v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    new_data_transfer_report = a1;
    if ((*((uint64_t (**))a1->isa + 32))(a1))
    {
      if (!new_data_transfer_report[24].isa)
      {
        isa = new_data_transfer_report[26].isa;
        v9 = (std::__shared_weak_count *)new_data_transfer_report[27].isa;
        if (v9)
        {
          p_shared_weak_owners = (unint64_t *)&v9->__shared_weak_owners_;
          do
            v11 = __ldxr(p_shared_weak_owners);
          while (__stxr(v11 + 1, p_shared_weak_owners));
          v47 = ___ZN19TransportConnection13associateTaskEP16NSURLSessionTaskNS_20TaskAssociationEventEP24__CFN_TransactionMetrics_block_invoke;
          v48 = &__block_descriptor_48_e8_32c44_ZTSNSt3__18weak_ptrI19TransportConnectionEE_e8_v16__0Q8l;
          v49 = isa;
          v50 = v9;
          do
            v12 = __ldxr(p_shared_weak_owners);
          while (__stxr(v12 + 1, p_shared_weak_owners));
        }
        else
        {
          v47 = ___ZN19TransportConnection13associateTaskEP16NSURLSessionTaskNS_20TaskAssociationEventEP24__CFN_TransactionMetrics_block_invoke;
          v48 = &__block_descriptor_48_e8_32c44_ZTSNSt3__18weak_ptrI19TransportConnectionEE_e8_v16__0Q8l;
          v49 = isa;
          v50 = 0;
        }
        aBlock[0] = MEMORY[0x1E0C809B0];
        aBlock[1] = 3321888768;
        v14 = (objc_class *)operator new();
        *(_QWORD *)v14 = &off_1E14EB358;
        *((_QWORD *)v14 + 1) = _Block_copy(aBlock);
        *((_QWORD *)v14 + 2) = 0;
        *((_QWORD *)v14 + 3) = objc_alloc_init(MEMORY[0x1E0C99E20]);
        v15 = new_data_transfer_report[24].isa;
        new_data_transfer_report[24].isa = v14;
        if (v15)
          (*(void (**)(Class))(*(_QWORD *)v15 + 8))(v15);
        if (v50)
          std::__shared_weak_count::__release_weak(v50);
        if (v9)
          std::__shared_weak_count::__release_weak(v9);
      }
      v16 = -[NSURLSessionTask _loggableDescription](a2, "_loggableDescription");
      v17 = -[NSURLSessionTask _private_nw_activity](a2, "_private_nw_activity");
      switch((int)a3)
      {
        case 0:
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v18 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            v19 = (*((uint64_t (**)(nw_data_transfer_report_t))new_data_transfer_report->isa + 32))(new_data_transfer_report);
            *(_DWORD *)buf = 138543618;
            *(_QWORD *)&buf[4] = v16;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v19;
            _os_log_impl(&dword_183ECA000, v18, OS_LOG_TYPE_DEFAULT, "%{public}@ setting up Connection %lld", buf, 0x16u);
          }
          (*((void (**)(nw_data_transfer_report_t, uint64_t, uint64_t))new_data_transfer_report->isa + 57))(new_data_transfer_report, v17, 1);
          ConnectionEPTManager::addTask((id *)new_data_transfer_report[24].isa, a2);
          break;
        case 1:
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v20 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
          {
            v45 = (*((uint64_t (**)(nw_data_transfer_report_t))new_data_transfer_report->isa + 32))(new_data_transfer_report);
            *(_DWORD *)buf = 138543618;
            *(_QWORD *)&buf[4] = v16;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v45;
            _os_log_debug_impl(&dword_183ECA000, v20, OS_LOG_TYPE_DEBUG, "%{public}@ done setting up Connection %lld", buf, 0x16u);
          }
          (*((void (**)(nw_data_transfer_report_t, uint64_t, _QWORD))new_data_transfer_report->isa + 57))(new_data_transfer_report, v17, 0);
          ConnectionEPTManager::removeTask((id *)new_data_transfer_report[24].isa, a2);
          break;
        case 2:
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v21 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            v22 = (*((uint64_t (**)(nw_data_transfer_report_t))new_data_transfer_report->isa + 32))(new_data_transfer_report);
            *(_DWORD *)buf = 138543618;
            *(_QWORD *)&buf[4] = v16;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v22;
            _os_log_impl(&dword_183ECA000, v21, OS_LOG_TYPE_DEFAULT, "%{public}@ waiting for setup of Connection %lld", buf, 0x16u);
          }
          ConnectionEPTManager::addTask((id *)new_data_transfer_report[24].isa, a2);
          break;
        case 3:
          ConnectionEPTManager::removeTask((id *)new_data_transfer_report[24].isa, a2);
          break;
        case 4:
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v23 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            v24 = (*((uint64_t (**)(nw_data_transfer_report_t))new_data_transfer_report->isa + 32))(new_data_transfer_report);
            *(_DWORD *)buf = 138543618;
            *(_QWORD *)&buf[4] = v16;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v24;
            _os_log_impl(&dword_183ECA000, v23, OS_LOG_TYPE_DEFAULT, "%{public}@ not allowed to create a new connection (existing Connection %lld)", buf, 0x16u);
          }
          break;
        case 5:
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v25 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
          {
            v26 = (*((uint64_t (**)(nw_data_transfer_report_t))new_data_transfer_report->isa + 32))(new_data_transfer_report);
            *(_DWORD *)buf = 138543618;
            *(_QWORD *)&buf[4] = v16;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v26;
            v27 = "%{public}@ preparing request for Connection %lld";
            goto LABEL_50;
          }
          break;
        case 6:
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v25 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
          {
            v28 = (*((uint64_t (**)(nw_data_transfer_report_t))new_data_transfer_report->isa + 32))(new_data_transfer_report);
            *(_DWORD *)buf = 138543618;
            *(_QWORD *)&buf[4] = v16;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v28;
            v27 = "%{public}@ done preparing request for Connection %lld";
LABEL_50:
            _os_log_debug_impl(&dword_183ECA000, v25, OS_LOG_TYPE_DEBUG, v27, buf, 0x16u);
          }
          break;
        case 7:
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v29 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            v30 = (*((uint64_t (**)(nw_data_transfer_report_t))new_data_transfer_report->isa + 32))(new_data_transfer_report);
            *(_DWORD *)buf = 138543618;
            *(_QWORD *)&buf[4] = v16;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v30;
            _os_log_impl(&dword_183ECA000, v29, OS_LOG_TYPE_DEFAULT, "%{public}@ now using Connection %llu", buf, 0x16u);
          }
          (*((void (**)(nw_data_transfer_report_t, uint64_t, uint64_t))new_data_transfer_report->isa + 57))(new_data_transfer_report, v17, 1);
          ConnectionEPTManager::addTask((id *)new_data_transfer_report[24].isa, a2);
          if (a4 && (*(_BYTE *)(a4 + 224) & 0x40) != 0)
          {
            v32 = (id *)objc_getProperty((id)a4, v31, 88, 1);
            v33 = v32;
            if (v32)
            {
              v34 = v32[5];
              v35 = v34;
              if (v34)
                new_data_transfer_report = nw_connection_create_new_data_transfer_report(v34);

              if (v35)
                v43 = new_data_transfer_report;
              else
                v43 = 0;
            }
            else
            {
              v43 = 0;
            }
            v44 = *(void **)(a4 + 240);
            *(_QWORD *)(a4 + 240) = v43;

          }
          -[NSURLSessionTask _logUnlistedTracker:](a2, "_logUnlistedTracker:", a4);
          break;
        case 8:
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v36 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            v37 = (*((uint64_t (**)(nw_data_transfer_report_t))new_data_transfer_report->isa + 32))(new_data_transfer_report);
            *(_DWORD *)buf = 138543618;
            *(_QWORD *)&buf[4] = v16;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v37;
            _os_log_impl(&dword_183ECA000, v36, OS_LOG_TYPE_DEFAULT, "%{public}@ done using Connection %llu", buf, 0x16u);
          }
          (*((void (**)(nw_data_transfer_report_t, uint64_t, _QWORD))new_data_transfer_report->isa + 57))(new_data_transfer_report, v17, 0);
          ConnectionEPTManager::removeTask((id *)new_data_transfer_report[24].isa, a2);
          if (a4 && (*(_BYTE *)(a4 + 224) & 0x40) != 0 && *(_QWORD *)(a4 + 240))
          {
            v39 = objc_getProperty((id)a4, v38, 88, 1);
            v40 = *(id *)(a4 + 240);
            if (v39)
            {
              *(_QWORD *)buf = 0;
              *(_QWORD *)&buf[8] = buf;
              *(_QWORD *)&buf[16] = 0x3032000000;
              v59 = __Block_byref_object_copy__10723;
              v60 = __Block_byref_object_dispose__10724;
              v61 = 0;
              v51 = MEMORY[0x1E0C809B0];
              v52 = 3221225472;
              v53 = __53____CFN_ConnectionMetrics_collectDataTransferReport___block_invoke;
              v54 = &unk_1E14FB770;
              v55 = buf;
              nw_data_transfer_report_collect_on_nw_queue();
              v41 = *(id *)(*(_QWORD *)&buf[8] + 40);
              _Block_object_dispose(buf, 8);

            }
            else
            {
              v41 = 0;
            }

            v42 = *(void **)(a4 + 240);
            *(_QWORD *)(a4 + 240) = v41;

          }
          break;
        default:
          return;
      }
    }
    else
    {
      v13 = new_data_transfer_report[28].isa;
      if (!v13)
      {
        v13 = (objc_class *)objc_alloc_init(MEMORY[0x1E0C99DE8]);
        new_data_transfer_report[28].isa = v13;
      }
      v56[0] = CFSTR("Task");
      v56[1] = CFSTR("Event");
      v57[0] = a2;
      v57[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a3);
      -[objc_class addObject:](v13, "addObject:", objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v57, v56, 2));
    }
  }
}

void sub_183F0858C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30)
{
  void *v30;
  void *v31;

  _Block_object_dispose(&a25, 8);

  _Unwind_Resume(a1);
}

void sub_183F0876C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::getConnectionID(NWIOConnection *this)
{
  return *((_QWORD *)this + 36);
}

uint64_t NWIOConnection::_associateActivity(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3;

  if (a2)
  {
    v3 = result;
    result = *(_QWORD *)(result + 272);
    if (result)
    {
      if ((*(_WORD *)(v3 + 248) & 0x60) == 0)
      {
        if (a3)
          return nw_connection_start_activity();
        else
          return nw_connection_end_activity();
      }
    }
  }
  return result;
}

void sub_183F08ABC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ConnectionEPTManager::removeTask(id *this, NSURLSessionTask *a2)
{
  unint64_t v4;
  uint64_t result;

  v4 = -[NSURLSessionTask _expectedProgressTarget](a2, "_expectedProgressTarget");
  result = objc_msgSend(this[3], "containsObject:", a2);
  if ((_DWORD)result)
  {
    result = objc_msgSend(this[3], "removeObject:", a2);
    if (v4)
    {
      result = ConnectionEPTManager::_computeNewTarget((ConnectionEPTManager *)this);
      if ((_DWORD)result)
      {
        result = (uint64_t)this[1];
        if (result)
          return (*(uint64_t (**)(uint64_t, id))(result + 16))(result, this[2]);
      }
    }
  }
  return result;
}

uint64_t ConnectionEPTManager::addTask(id *this, NSURLSessionTask *a2)
{
  unint64_t v4;
  uint64_t result;

  v4 = -[NSURLSessionTask _expectedProgressTarget](a2, "_expectedProgressTarget");
  result = objc_msgSend(this[3], "addObject:", a2);
  if (v4)
  {
    result = ConnectionEPTManager::_computeNewTarget((ConnectionEPTManager *)this);
    if ((_DWORD)result)
    {
      result = (uint64_t)this[1];
      if (result)
        return (*(uint64_t (**)(uint64_t, id))(result + 16))(result, this[2]);
    }
  }
  return result;
}

uint64_t atsDictionaryAllowsArbitraryLoads(uint64_t result)
{
  const __CFDictionary *v1;
  const void *Value;
  const void *v3;
  _BOOL4 v4;
  const void *v5;
  NSObject *v6;
  const char *v7;
  uint8_t *v8;
  const void *v9;
  _BOOL4 v10;
  int v11;
  uint64_t v13;
  CFTypeID v14;
  __int16 v15;
  __int16 v16;
  uint8_t buf[16];

  if (result)
  {
    v1 = (const __CFDictionary *)result;
    Value = CFDictionaryGetValue((CFDictionaryRef)result, CFSTR("NSAllowsArbitraryLoadsInWebContent"));
    if (Value)
    {
      v3 = Value;
      v4 = atsDictionaryClientIDHasPrefix(v1, CFSTR("com.apple.WebKit"));
      v5 = (const void *)*MEMORY[0x1E0C9AE50];
      if (v4 && v3 == v5)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v6 = CFNLog::logger;
        if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
          return 1;
        v16 = 0;
        v7 = "ATS WK exception found for WK client";
        v8 = (uint8_t *)&v16;
LABEL_37:
        _os_log_debug_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEBUG, v7, v8, 2u);
        return 1;
      }
      if (isWebkitProcess(void)::onceToken != -1)
        dispatch_once(&isWebkitProcess(void)::onceToken, &__block_literal_global_86_9022);
      v11 = isWebkitProcess(void)::isWebkitProcess;
      return v11 && v3 == v5;
    }
    v9 = CFDictionaryGetValue(v1, CFSTR("NSAllowsArbitraryLoadsForMedia"));
    if (v9)
    {
      v3 = v9;
      v10 = atsDictionaryClientIDHasPrefix(v1, CFSTR("mediaserverd"));
      v5 = (const void *)*MEMORY[0x1E0C9AE50];
      if (v10 && v3 == v5)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v6 = CFNLog::logger;
        if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
          return 1;
        v15 = 0;
        v7 = "ATS Media exception found for Media client";
        v8 = (uint8_t *)&v15;
        goto LABEL_37;
      }
      if (isMediaProcess(void)::onceToken != -1)
        dispatch_once(&isMediaProcess(void)::onceToken, &__block_literal_global_88);
      v11 = isMediaProcess(void)::isMediaProcess;
      return v11 && v3 == v5;
    }
    if (CFDictionaryGetValue(v1, CFSTR("NSAllowsLocalNetworking")))
      return 0;
    result = (uint64_t)CFDictionaryGetValue(v1, CFSTR("NSAllowsArbitraryLoads"));
    if (result)
    {
      v13 = result;
      v14 = CFGetTypeID((CFTypeRef)result);
      if (v14 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
      }
      return *MEMORY[0x1E0C9AE50] == v13;
    }
  }
  return result;
}

void NSXCredentialStorage::NSXCredentialStorage(NSXCredentialStorage *this, CFTypeRef cf)
{
  uint64_t v2;
  CFTypeRef v4;

  v2 = *MEMORY[0x1E0C9AE00];
  *(_QWORD *)this = off_1E14EF578;
  *((_QWORD *)this + 1) = v2;
  *((_DWORD *)this + 4) = 1;
  if ((((unint64_t)this + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)this = off_1E14EB958;
  if (cf)
    v4 = CFRetain(cf);
  else
    v4 = 0;
  *((_QWORD *)this + 3) = v4;
}

id summaryLog()
{
  if (summaryLog::onceToken != -1)
    dispatch_once(&summaryLog::onceToken, &__block_literal_global_15068);
  return (id)summaryLog::handle;
}

void sub_183F095B0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&_localProtocolClassesForDefaultSessionLock);
  _Unwind_Resume(a1);
}

const char *endReasonString(uint64_t a1)
{
  uint64_t v1;
  const char *result;

  if (a1 > 1023)
  {
    switch(a1)
    {
      case 1024:
        return "task failure";
      case 1025:
        return "pending retry";
      case 1026:
        return "pending next proxy";
      default:
        return 0;
    }
  }
  else
  {
    v1 = a1 - 1;
    result = "task success";
    switch(v1)
    {
      case 0:
        return result;
      case 1:
        result = "redirection";
        break;
      case 2:
        result = "auth challenge";
        break;
      case 3:
        result = "upload resumption";
        break;
      default:
        return 0;
    }
  }
  return result;
}

uint64_t HTTPProtocol::_protocolInterface_startLoad(HTTPProtocol *this, const _CFCachedURLResponse *a2)
{
  uint64_t v4;
  void *v5;
  const __CFURL *v6;
  const __CFURL *v7;
  const __CFString *v8;
  const __CFString *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v18;
  _QWORD v19[12];

  v19[11] = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)this + 3);
  if (!v4 || *(_DWORD *)(v4 + 40))
  {
    if (*((_QWORD *)this + 92))
    {
      v5 = (void *)*((_QWORD *)this + 11);
      if (v5)
      {
        v6 = (const __CFURL *)objc_msgSend(*((id *)this + 11), "cfURL");
        if (v6)
        {
          v7 = v6;
          v8 = CFURLCopyScheme(v6);
          if (v8)
          {
            v9 = v8;
            if (CFStringCompare(v8, CFSTR("http"), 1uLL) == kCFCompareEqualTo)
            {
              v18 = (char *)&loc_183F09AF0
                  + *((int *)qword_18406E1E8
                    + StrictSecurityPolicy::strictSecurityPolicyInEffectForURL(*((StrictSecurityPolicy **)this + 92), v7, *(const __CFDictionary **)(objc_msgSend(v5, "_inner") + 192)));
              __asm { BR              X10 }
            }
            CFRelease(v9);
          }
        }
      }
    }
    *((_QWORD *)this + 38) = 0;
    *((_QWORD *)this + 60) = 0;
    v10 = HTTPProtocol::validateCachedResponseForLoad(this, a2);
    if (v10)
      v11 = v10;
    else
      v11 = 2;
    if (v11 == 1)
      v11 = 3;
    if (*((_QWORD *)this + 95) == 5)
      v12 = v11;
    else
      v12 = v10;
    __asm { BR              X10 }
  }
  v13 = CoreSchedulingSet::copyLoaderQueueSet((CoreSchedulingSet *)this);
  v14 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 88))(*((_QWORD *)this + 3));
  v15 = *((_QWORD *)this + 3);
  (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
  (*(void (**)(uint64_t))(*(_QWORD *)v15 + 48))(v15);
  *((_QWORD *)this + 3) = v13;
  (*(void (**)(HTTPProtocol *, uint64_t, uint64_t))(*(_QWORD *)this + 192))(this, v14, v13);
  (*(void (**)(uint64_t))(*(_QWORD *)v14 + 48))(v14);
  (*(void (**)(uint64_t))(*(_QWORD *)v13 + 48))(v13);
  if (a2)
    CFRetain(a2);
  CFRetain((char *)this - 16);
  v16 = *((_QWORD *)this + 3);
  v19[0] = MEMORY[0x1E0C809B0];
  v19[1] = 3221225472;
  v19[2] = ___ZN12HTTPProtocol28_protocolInterface_startLoadEPK20_CFCachedURLResponse_block_invoke;
  v19[3] = &__block_descriptor_48_e5_v8__0l;
  v19[4] = this;
  v19[5] = a2;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v16 + 96))(v16, v19);
}

void sub_183F09FA8(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t HTTPProtocol::validateCachedResponseForLoad(HTTPProtocol *this, const _CFCachedURLResponse *a2)
{
  uint64_t v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE *v14;
  CFStringRef v15;
  const __CFString *v16;
  void *v17;
  void *v18;
  CFURLRef v19;
  const _CFURLRequest *v20;
  CFURLRef v21;
  __CFDictionary *v22;
  int v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  const __CFAllocator *v27;
  CFStringRef v28;
  CFStringRef v29;
  uint64_t v30;
  CFStringRef v31;
  HTTPMessage *v32;
  const __CFString *HeaderFieldValue;
  double ExpirationTime;
  double Current;
  _BOOL4 v36;
  int v37;
  double v38;
  uint64_t v39;
  HTTPRequestParserClient *v40;
  os_unfair_lock_s *v41;
  os_unfair_lock_s *v42;
  os_unfair_lock_s *v43;
  os_unfair_lock_s *v44;
  __CFDictionary *v45;
  const __CFAllocator *alloc;
  const char *v47;
  CFURLRef cf;
  uint64_t v49;
  void (**v50)(AutoString *__hidden);
  CFStringRef v51;
  uint64_t v52;
  uint64_t v53;
  void (**v54)(AutoString *__hidden);
  CFStringRef v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 2;
  if (!*((_QWORD *)this + 10))
    return 2;
  if (*((_DWORD *)a2->var1 + 14) == 2)
    return 2;
  v4 = CFCachedURLResponseCopyWrappedResponse(a2);
  if (!v4)
    return 2;
  v5 = (void *)v4;
  v6 = (void *)*((_QWORD *)this + 11);
  if (v6)
  {
    v7 = objc_msgSend(*((id *)this + 11), "_inner");
    v8 = *(_QWORD *)(v7 + 56);
    if (!v8
      || (v9 = v7, HTTPMessage::ensureParserFinished(*(HTTPMessage **)(v7 + 56)), !*(_QWORD *)(v8 + 48))
      && (v10 = *(_QWORD *)(v9 + 56), !*(_QWORD *)(v10 + 208))
      && !*(_QWORD *)(v10 + 200))
    {
      v13 = *(_QWORD *)(objc_msgSend(v5, "_inner") + 88);
      if (v13)
        v14 = (_BYTE *)(v13 - 16);
      else
        v14 = 0;
      if (!v13)
        goto LABEL_68;
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v15 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)(v14 + 16), 0x14D0941Bu);
      if (v15)
      {
        v16 = v15;
        if (CFEqual(v15, CFSTR("*")))
        {
          CFRelease(v16);
LABEL_70:

          return 2;
        }
        v17 = (void *)CFCachedURLResponseCopyWrappedRequest(a2);
        v18 = v17;
        if (v17 && (v19 = _CFURLRequestCopyProtocolPropertyForKey(v17, v16)) != 0)
        {
          v21 = v19;
          v22 = HTTPProtocol::copyVaryState(*((HTTPProtocol **)this + 93), v16, v6, v20);
          cf = v21;
          if (v22)
          {
            v23 = CFEqual(v21, v22);
            LOBYTE(v49) = 0;
            BYTE4(v49) = v23 != 0;
            v24 = "vary state mismatch";
            if (v23)
              v24 = 0;
          }
          else
          {
            v49 = 0;
            v24 = "newVaryState is nil";
          }
        }
        else
        {
          cf = 0;
          v22 = 0;
          v49 = 1;
          v24 = "cachedVaryState is nil";
        }
        v47 = v24;
        v25 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_34_7278, 1);
        if (v25)
        {
          v26 = v25;
          if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v25 + 16))(v25, "Vary Validation", 0))
          {
            v45 = v22;
            v27 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v54 = &off_1E14E4818;
            v56 = 0;
            v57 = 0;
            v55 = CFStringCreateWithCString(v27, "Evaluation", 0x8000100u);
            v50 = &off_1E14E4818;
            v52 = 0;
            v53 = 0;
            if ((v49 & 0x100000000) != 0)
            {
              v51 = CFStringCreateWithCString(v27, "PASS", 0x8000100u);
              (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(_QWORD *)v26 + 64))(v26, v55, v51);
              v22 = v45;
            }
            else
            {
              v51 = CFStringCreateWithCString(v27, "FAIL", 0x8000100u);
              (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(_QWORD *)v26 + 64))(v26, v55, v51);
              v22 = v45;
              AutoString::~AutoString((AutoString *)&v50);
              AutoString::~AutoString((AutoString *)&v54);
              v54 = &off_1E14E4818;
              v28 = CFStringCreateWithCString(alloc, "Failure", 0x8000100u);
              v56 = 0;
              v57 = 0;
              v55 = v28;
              v50 = &off_1E14E4818;
              v29 = CFStringCreateWithCString(alloc, v47, 0x8000100u);
              v52 = 0;
              v53 = 0;
              v51 = v29;
              (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(_QWORD *)v26 + 64))(v26, v55, v29);
            }
            AutoString::~AutoString((AutoString *)&v50);
            AutoString::~AutoString((AutoString *)&v54);
            if (v18)
              v30 = *(_QWORD *)(objc_msgSend(v18, "_inner") + 8);
            else
              v30 = 0;
            (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)v26 + 40))(v26, "Request", v30);
            v54 = &off_1E14E4818;
            v31 = CFStringCreateWithCString(alloc, "VaryHeader", 0x8000100u);
            v56 = 0;
            v57 = 0;
            v55 = v31;
            (*(void (**)(uint64_t))(*(_QWORD *)v26 + 64))(v26);
            AutoString::~AutoString((AutoString *)&v54);
            if (__CFNCanLogSensitiveContent::onceToken != -1)
              dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_26_4798);
            if (__CFNCanLogSensitiveContent::ok)
            {
              if ((v49 & 1) == 0)
                (*(void (**)(uint64_t, const char *, CFURLRef))(*(_QWORD *)v26 + 96))(v26, "CachedState", cf);
              if (v22)
                (*(void (**)(uint64_t, const char *, __CFDictionary *))(*(_QWORD *)v26 + 96))(v26, "NewStateState", v22);
            }
            (*(void (**)(uint64_t))(*(_QWORD *)v26 + 8))(v26);
          }
        }
        if (v18)
          CFRelease(v18);
        if ((v49 & 1) == 0)
          CFRelease(cf);
        if (v22)
          CFRelease(v22);
        CFRelease(v16);
        if ((v49 & 0x100000000) == 0)
          goto LABEL_70;
      }
      if (CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)v14) == 301
        || CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)v14) == 308)
      {
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        if (v14[40])
          v32 = (HTTPMessage *)(v14 + 16);
        else
          v32 = 0;
        HeaderFieldValue = HTTPMessage::copyLastHeaderFieldValue(v32, 0x12E1132Au);
        ExpirationTime = CFURLResponseGetExpirationTime(v5);
        Current = CFAbsoluteTimeGetCurrent();
        if (HeaderFieldValue)
        {
          v36 = ExpirationTime - Current < 1.0;
          if (CFStringGetLength(HeaderFieldValue))
            v37 = v36;
          else
            v37 = 1;
          if (v37)
            v11 = 2;
          else
            v11 = 0;
          CFRelease(HeaderFieldValue);
        }
        else
        {
          v11 = 2;
        }
      }
      else
      {
LABEL_68:
        if ((*((_QWORD *)this + 95) & 0xFFFFFFFFFFFFFFFELL) == 2)
        {

          return 1;
        }
        if (_CFURLResponseMustRevalidate(v5))
        {

          return 3;
        }
        v38 = CFURLResponseGetExpirationTime(v5);
        if (v38 - CFAbsoluteTimeGetCurrent() < 1.0
          || (v39 = *(_QWORD *)(objc_msgSend(v6, "_inner") + 56)) == 0
          || (v40 = (HTTPRequestParserClient *)(v39 + 128),
              !HTTPRequestParserClient::isGetMethod((HTTPRequestParserClient *)(v39 + 128)))
          && !HTTPRequestParserClient::isHeadRequest(v40)
          || (v41 = *(os_unfair_lock_s **)(objc_msgSend(v6, "_inner") + 56)) != 0
          && HTTPMessage::hasHeaderField(v41, 0x1301F333u)
          || (v42 = *(os_unfair_lock_s **)(objc_msgSend(v6, "_inner") + 56)) != 0
          && HTTPMessage::hasHeaderField(v42, 0x13821372u)
          || (v43 = *(os_unfair_lock_s **)(objc_msgSend(v6, "_inner") + 56)) != 0
          && HTTPMessage::hasHeaderField(v43, 0x12823305u))
        {
          v11 = 3;
        }
        else
        {
          v44 = *(os_unfair_lock_s **)(objc_msgSend(v6, "_inner") + 56);
          if (v44)
          {
            if (HTTPMessage::hasHeaderField(v44, 0x1181B2A6u))
              v11 = 3;
            else
              v11 = 1;
          }
          else
          {
            v11 = 1;
          }
        }
      }

      return v11;
    }
  }

  return 2;
}

void sub_183F0A6C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  AutoString::~AutoString((AutoString *)&a15);
  AutoString::~AutoString((AutoString *)&a34);
  _Unwind_Resume(a1);
}

const __CFData *createDictionaryFromData(const __CFData *cf)
{
  const __CFData *v1;
  CFTypeID v2;
  CFTypeID TypeID;
  CFErrorRef error;

  v1 = cf;
  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (v2 == CFDataGetTypeID())
    {
      error = 0;
      v1 = (const __CFData *)CFPropertyListCreateWithData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v1, 0, 0, &error);
      if (error)
      {
        CFRelease(error);
        return v1;
      }
      TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(v1))
        return v1;
      CFRelease(v1);
    }
    return 0;
  }
  return v1;
}

void *__CFNetworkCopyProxiesForURLWithInterface(const __CFURL *a1, __CFDictionary *a2, __CFString *a3)
{
  const __CFString *v6;
  const __CFString *v7;
  void *v8;

  if (!a1)
    return __CFNetworkCopyProxiesForInterface(0, 0, a2, a3);
  v6 = CFURLCopyScheme(a1);
  v7 = CFURLCopyHostName(a1);
  v8 = __CFNetworkCopyProxiesForInterface(v6, v7, a2, a3);
  if (v7)
    CFRelease(v7);
  if (v6)
    CFRelease(v6);
  return v8;
}

uint64_t AutoDict::getEmptyDict(AutoDict *this)
{
  CFMutableDictionaryRef Mutable;

  if (!AutoDict::getEmptyDict(void)::sEmptyDictionary)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    while (!__ldaxr((unint64_t *)&AutoDict::getEmptyDict(void)::sEmptyDictionary))
    {
      if (!__stlxr((unint64_t)Mutable, (unint64_t *)&AutoDict::getEmptyDict(void)::sEmptyDictionary))
        return AutoDict::getEmptyDict(void)::sEmptyDictionary;
    }
    __clrex();
    CFRelease(Mutable);
  }
  return AutoDict::getEmptyDict(void)::sEmptyDictionary;
}

void *__CFNetworkCopyProxiesForInterface(CFStringRef theString1, const __CFString *a2, const __CFDictionary *ValueAtIndex, const __CFString *a4)
{
  BOOL v7;
  const __CFArray *v8;
  const __CFArray *v9;
  const void *v10;
  BOOL v11;
  CFAllocatorRef *v12;
  int v13;
  CFDictionaryRef Copy;
  BOOL v15;
  int v16;
  const void *Value;
  const void *v18;
  const void *v19;
  const __CFArray *v20;
  const __CFArray *v21;
  const __CFString *v22;
  char v23;
  const void *v24;
  void *Mutable;
  const __CFAllocator *v26;
  __CFArray *v27;
  const __CFNumber *v28;
  const __CFNumber *v29;
  CFTypeID v30;
  const __CFString *v31;
  const __CFString *v32;
  CFTypeID v33;
  CFDictionaryRef v34;
  const __CFString *v35;
  const __CFString *v36;
  CFTypeID v37;
  const __CFString *v38;
  CFURLRef v39;
  const __CFNumber *v40;
  const __CFNumber *v41;
  CFTypeID v42;
  _BOOL4 v43;
  const void *v44;
  int v45;
  CFTypeRef v46;
  const void **v47;
  const CFStringRef *v48;
  const CFStringRef *v49;
  const __CFString *v50;
  const __CFString *v51;
  const __CFNumber *v52;
  const __CFNumber *v53;
  CFTypeID v54;
  const __CFString *v55;
  const __CFString *v56;
  CFTypeID v57;
  const __CFNumber *v58;
  const __CFNumber *v59;
  CFTypeID v60;
  int *p_valuePtr;
  CFNumberRef v62;
  CFStringRef v63;
  CFStringRef v64;
  __CFString *v65;
  CFDictionaryRef v66;
  CFDictionaryRef v67;
  const __CFNumber *v68;
  const __CFNumber *v69;
  CFTypeID v70;
  const void *v71;
  const void *v72;
  const __CFString *v73;
  uint64_t v74;
  CFTypeID v75;
  const __CFNumber *v76;
  CFNumberRef v77;
  CFTypeID v78;
  CFTypeID v79;
  CFTypeID v80;
  CFIndex v81;
  CFDictionaryRef v82;
  CFTypeRef v83;
  CFTypeRef v84;
  CFTypeRef v85;
  void *v87;
  _BOOL4 v88;
  int v89;
  int v90;
  void *values;
  CFStringRef v92;
  CFNumberRef v93;
  const void *v94;
  const void *v95;
  uint64_t v96;
  __int128 valuePtr;
  __int128 v98;
  __int128 v99;
  uint64_t v100;

  v100 = *MEMORY[0x1E0C80C00];
  if (theString1)
  {
    if (CFStringCompare(theString1, CFSTR("ftp"), 1uLL) == kCFCompareEqualTo)
    {
      v8 = 0;
      goto LABEL_11;
    }
    v7 = CFStringCompare(theString1, CFSTR("ftps"), 1uLL) == kCFCompareEqualTo;
  }
  else
  {
    v7 = 0;
  }
  v8 = 0;
  if (a2)
  {
    if (!v7)
    {
      v9 = (const __CFArray *)SCNetworkProxiesCopyMatching();
      v8 = v9;
      if (v9)
      {
        if (CFArrayGetCount(v9) >= 1)
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v8, 0);
      }
    }
  }
LABEL_11:
  os_unfair_lock_lock((os_unfair_lock_t)&__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::proxyArrayLock);
  v10 = (const void *)__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::oldProxyDict;
  if (__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::oldProxyDict)
    v11 = ValueAtIndex == 0;
  else
    v11 = 1;
  v12 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (v11
    || (v13 = CFEqual(ValueAtIndex, (CFTypeRef)__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::oldProxyDict), v10 = (const void *)__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::oldProxyDict, !v13))
  {
    if (v10)
      CFRelease(v10);
    if (ValueAtIndex)
      Copy = CFDictionaryCreateCopy(*v12, ValueAtIndex);
    else
      Copy = 0;
    __CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::oldProxyDict = (uint64_t)Copy;
    if (__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::httpProxyArray)
      CFRelease((CFTypeRef)__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::httpProxyArray);
    __CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::httpProxyArray = 0;
    if (__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::httpsProxyArray)
      CFRelease((CFTypeRef)__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::httpsProxyArray);
    __CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::httpsProxyArray = 0;
    if (__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::ftpProxyArray)
      CFRelease((CFTypeRef)__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::ftpProxyArray);
    __CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::ftpProxyArray = 0;
    if (__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::pacOnlyArray)
      CFRelease((CFTypeRef)__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::pacOnlyArray);
    __CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::pacOnlyArray = 0;
    v10 = (const void *)__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::oldProxyDict;
  }
  if (a2)
    v15 = v10 == 0;
  else
    v15 = 1;
  v16 = !v15;
  if (!v15)
  {
    Value = CFDictionaryGetValue((CFDictionaryRef)v10, &unk_1EDCFB440);
    v18 = (const void *)*MEMORY[0x1E0C9AE50];
    if (Value)
      v19 = (const void *)*MEMORY[0x1E0C9AE50];
    else
      v19 = (const void *)*MEMORY[0x1E0C9AE40];
    v20 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v10, CFSTR("ExceptionsList"));
    if (v20)
    {
      v21 = v20;
      v22 = a2;
    }
    else
    {
      if (!CFEqual(v19, v18))
        goto LABEL_45;
      v22 = a2;
      v21 = 0;
    }
    if (!_CFNetworkDoesNeedProxy(v22, v21, v19))
    {
      v24 = (const void *)__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::pacOnlyArray;
      if (!__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::pacOnlyArray)
      {
        v26 = *v12;
        Mutable = CFArrayCreateMutable(*v12, 0, MEMORY[0x1E0C9B378]);
        v23 = 1;
        goto LABEL_59;
      }
      v23 = 1;
      goto LABEL_57;
    }
  }
LABEL_45:
  if (!theString1)
  {
    v23 = 0;
    goto LABEL_58;
  }
  if (CFEqual(theString1, CFSTR("http")))
  {
    v23 = 0;
    v24 = (const void *)__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::httpProxyArray;
    if (!__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::httpProxyArray)
      goto LABEL_58;
  }
  else if (CFEqual(theString1, &unk_1EDD00AE0))
  {
    v23 = 0;
    v24 = (const void *)__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::httpsProxyArray;
    if (!__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::httpsProxyArray)
      goto LABEL_58;
  }
  else
  {
    v23 = 0;
    if (!CFEqual(theString1, CFSTR("ftp")))
      goto LABEL_58;
    v24 = (const void *)__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::ftpProxyArray;
    if (!__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::ftpProxyArray)
      goto LABEL_58;
  }
LABEL_57:
  Mutable = (void *)CFRetain(v24);
  if (Mutable)
    goto LABEL_176;
LABEL_58:
  v26 = *v12;
  v27 = CFArrayCreateMutable(*v12, 0, MEMORY[0x1E0C9B378]);
  Mutable = v27;
  if (!v16)
  {
    CFArrayAppendValue(v27, &unk_1E152A808);
    if ((v23 & 1) != 0)
    {
LABEL_88:
      if (Mutable)
        v46 = CFRetain(Mutable);
      else
        v46 = 0;
      __CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::pacOnlyArray = (uint64_t)v46;
      goto LABEL_176;
    }
    goto LABEL_160;
  }
LABEL_59:
  v28 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v10, CFSTR("ProxyAutoConfigEnable"));
  if (v28)
  {
    v29 = v28;
    v30 = CFGetTypeID(v28);
    if (v30 == CFNumberGetTypeID())
    {
      LODWORD(valuePtr) = 0;
      CFNumberGetValue(v29, kCFNumberSInt32Type, &valuePtr);
      if (!(_DWORD)valuePtr)
        goto LABEL_85;
    }
    else if ((const __CFNumber *)*MEMORY[0x1E0C9AE50] != v29)
    {
      goto LABEL_85;
    }
  }
  v31 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v10, CFSTR("ProxyAutoConfigJavaScript"));
  if (v31 && (v32 = v31, v33 = CFGetTypeID(v31), v33 == CFStringGetTypeID()))
  {
    *(_QWORD *)&valuePtr = CFSTR("kCFProxyTypeKey");
    *((_QWORD *)&valuePtr + 1) = CFSTR("kCFProxyAutoConfigurationJavaScriptKey");
    values = CFSTR("kCFProxyTypeAutoConfigurationJavaScript");
    v92 = v32;
    v34 = CFDictionaryCreate(v26, (const void **)&valuePtr, (const void **)&values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (!v34)
      goto LABEL_85;
  }
  else
  {
    v35 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v10, &unk_1EDCFEF18);
    if (!v35)
      goto LABEL_85;
    v36 = v35;
    v37 = CFGetTypeID(v35);
    if (v37 != CFStringGetTypeID())
      goto LABEL_85;
    v38 = CFURLCreateStringByAddingPercentEscapes(v26, v36, 0, 0, 0x8000100u);
    v39 = CFURLCreateWithString(v26, v38, 0);
    if (v38)
      CFRelease(v38);
    if (!v39)
      goto LABEL_85;
    *(_QWORD *)&valuePtr = CFSTR("kCFProxyTypeKey");
    *((_QWORD *)&valuePtr + 1) = CFSTR("kCFProxyAutoConfigurationURLKey");
    values = CFSTR("kCFProxyTypeAutoConfigurationURL");
    v92 = (CFStringRef)v39;
    v34 = CFDictionaryCreate(v26, (const void **)&valuePtr, (const void **)&values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFRelease(v39);
    if (!v34)
      goto LABEL_85;
  }
  CFArrayAppendValue((CFMutableArrayRef)Mutable, v34);
  CFRelease(v34);
  v40 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v10, (const void *)*MEMORY[0x1E0CE8E88]);
  if (v40)
  {
    v41 = v40;
    v42 = CFGetTypeID(v40);
    if (v42 == CFNumberGetTypeID())
    {
      LODWORD(valuePtr) = 0;
      CFNumberGetValue(v41, kCFNumberSInt32Type, &valuePtr);
      v43 = valuePtr != 0;
      if ((v23 & 1) != 0)
        goto LABEL_86;
      goto LABEL_79;
    }
  }
LABEL_85:
  v43 = 1;
  if ((v23 & 1) != 0)
  {
LABEL_86:
    if (v43)
      CFArrayAppendValue((CFMutableArrayRef)Mutable, &unk_1E152A808);
    goto LABEL_88;
  }
LABEL_79:
  v88 = v43;
  if (!theString1)
    goto LABEL_133;
  if (CFStringCompare(theString1, CFSTR("http"), 1uLL))
  {
    if (CFStringCompare(theString1, (CFStringRef)&unk_1EDD00AE0, 1uLL))
    {
      if (CFStringCompare(theString1, CFSTR("ftp"), 1uLL))
      {
        if (CFStringCompare(theString1, CFSTR("ftps"), 1uLL))
          goto LABEL_133;
        v44 = (const void *)*MEMORY[0x1E0CE8E60];
        v45 = 990;
      }
      else
      {
        v44 = (const void *)*MEMORY[0x1E0CE8E60];
        v45 = 21;
      }
      v90 = v45;
      v51 = CFSTR("FTPProxy");
      v50 = CFSTR("FTPPort");
      goto LABEL_99;
    }
    v47 = (const void **)MEMORY[0x1E0CE8EC8];
    v48 = &kCFStreamPropertyHTTPSProxyPort;
    v49 = &kCFStreamPropertyHTTPSProxyHost;
  }
  else
  {
    v47 = (const void **)MEMORY[0x1E0CE8EB0];
    v48 = &kCFStreamPropertyHTTPProxyPort;
    v49 = &kCFStreamPropertyHTTPProxyHost;
  }
  v44 = *v47;
  v50 = *v48;
  v51 = *v49;
  v90 = 80;
  if (!v51)
    goto LABEL_133;
LABEL_99:
  v52 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v10, v44);
  if (v52)
  {
    v53 = v52;
    v54 = CFGetTypeID(v52);
    if (v54 == CFNumberGetTypeID())
    {
      LODWORD(valuePtr) = 0;
      CFNumberGetValue(v53, kCFNumberSInt32Type, &valuePtr);
      if (!(_DWORD)valuePtr)
        goto LABEL_133;
    }
    else if ((const __CFNumber *)*MEMORY[0x1E0C9AE50] != v53)
    {
      goto LABEL_133;
    }
  }
  v55 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v10, v51);
  if (v55)
  {
    v56 = v55;
    v57 = CFGetTypeID(v55);
    if (v57 == CFStringGetTypeID())
    {
      values = 0;
      v92 = 0;
      v93 = 0;
      v58 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v10, v50);
      if (v58 && (v59 = v58, v60 = CFGetTypeID(v58), v60 == CFNumberGetTypeID()))
      {
        LODWORD(valuePtr) = 0;
        CFNumberGetValue(v59, kCFNumberSInt32Type, &valuePtr);
        p_valuePtr = (int *)&valuePtr;
      }
      else
      {
        p_valuePtr = &v90;
      }
      v62 = CFNumberCreate(v26, kCFNumberSInt32Type, p_valuePtr);
      v63 = CFStringCreateCopy(v26, v56);
      v64 = v63;
      *(_QWORD *)&valuePtr = CFSTR("kCFProxyTypeKey");
      *((_QWORD *)&valuePtr + 1) = CFSTR("kCFProxyHostNameKey");
      *(_QWORD *)&v98 = CFSTR("kCFProxyPortNumberKey");
      if (v51 == (const __CFString *)&unk_1EDCFEA10)
      {
        v65 = CFSTR("kCFProxyTypeHTTP");
      }
      else if (v51 == (const __CFString *)&unk_1EDCFEA80)
      {
        v65 = CFSTR("kCFProxyTypeHTTPS");
      }
      else if (v51 == CFSTR("FTPProxy"))
      {
        v65 = CFSTR("kCFProxyTypeFTP");
      }
      else
      {
        v65 = CFSTR("kCFProxyTypeNone");
      }
      values = v65;
      v92 = v63;
      v93 = v62;
      v66 = CFDictionaryCreate(v26, (const void **)&valuePtr, (const void **)&values, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v51 == CFSTR("FTPProxy"))
      {
        v89 = 0;
        values = CFSTR("kCFProxyTypeHTTP");
        v92 = v64;
        if (!CFNumberGetValue(v62, kCFNumberSInt32Type, &v89) || v89 == v90)
        {
          if (v62)
            CFRelease(v62);
          v89 = 80;
          v62 = CFNumberCreate(v26, kCFNumberSInt32Type, &v89);
        }
        v93 = v62;
        v67 = v66;
        v66 = CFDictionaryCreate(v26, (const void **)&valuePtr, (const void **)&values, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      }
      else
      {
        v67 = 0;
      }
      if (v62)
        CFRelease(v62);
      if (v64)
        CFRelease(v64);
      if (v66)
      {
        CFArrayAppendValue((CFMutableArrayRef)Mutable, v66);
        CFRelease(v66);
        v88 = 0;
      }
      if (v67)
      {
        CFArrayAppendValue((CFMutableArrayRef)Mutable, v67);
        CFRelease(v67);
      }
    }
  }
LABEL_133:
  v68 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v10, (const void *)*MEMORY[0x1E0CE8F30]);
  if (v68)
  {
    v69 = v68;
    v70 = CFGetTypeID(v68);
    if (v70 == CFNumberGetTypeID())
    {
      LODWORD(valuePtr) = 0;
      CFNumberGetValue(v69, kCFNumberSInt32Type, &valuePtr);
      if (!(_DWORD)valuePtr)
      {
LABEL_158:
        if (v88)
          CFArrayAppendValue((CFMutableArrayRef)Mutable, &unk_1E152A808);
        goto LABEL_160;
      }
    }
    else if ((const __CFNumber *)*MEMORY[0x1E0C9AE50] != v69)
    {
      goto LABEL_158;
    }
  }
  v71 = CFDictionaryGetValue((CFDictionaryRef)v10, (const void *)*MEMORY[0x1E0C9B2D8]);
  v72 = CFDictionaryGetValue((CFDictionaryRef)v10, (const void *)*MEMORY[0x1E0C9B2B8]);
  v73 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v10, (const void *)*MEMORY[0x1E0C9B2C8]);
  v74 = *MEMORY[0x1E0C9B2E0];
  v87 = (void *)CFDictionaryGetValue((CFDictionaryRef)v10, (const void *)*MEMORY[0x1E0C9B2E0]);
  if (!v73)
    goto LABEL_158;
  v75 = CFGetTypeID(v73);
  if (v75 != CFStringGetTypeID())
    goto LABEL_158;
  v98 = 0u;
  v99 = 0u;
  valuePtr = 0u;
  v94 = 0;
  v95 = 0;
  v96 = 0;
  v76 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v10, (const void *)*MEMORY[0x1E0C9B2D0]);
  if (v76 && (v77 = v76, v78 = CFGetTypeID(v76), v78 == CFNumberGetTypeID()))
  {
    CFRetain(v77);
  }
  else
  {
    v90 = 1080;
    v77 = CFNumberCreate(v26, kCFNumberSInt32Type, &v90);
  }
  if (!v71
    || !v72
    || (v79 = CFGetTypeID(v71), v79 != CFStringGetTypeID())
    || (v80 = CFGetTypeID(v72), v80 != CFStringGetTypeID()))
  {
    v71 = 0;
    v72 = 0;
  }
  *(_QWORD *)&valuePtr = CFSTR("kCFProxyTypeKey");
  *((_QWORD *)&valuePtr + 1) = CFSTR("kCFProxyHostNameKey");
  values = CFSTR("kCFProxyTypeSOCKS");
  v92 = v73;
  *(_QWORD *)&v98 = CFSTR("kCFProxyPortNumberKey");
  v93 = v77;
  if (v71)
  {
    *((_QWORD *)&v98 + 1) = CFSTR("kCFProxyUsernameKey");
    *(_QWORD *)&v99 = CFSTR("kCFProxyPasswordKey");
    v94 = v71;
    v95 = v72;
    v81 = 5;
  }
  else
  {
    v81 = 3;
  }
  if (v87)
  {
    *((_QWORD *)&valuePtr + v81) = v74;
    *(&values + v81++) = v87;
  }
  v82 = CFDictionaryCreate(v26, (const void **)&valuePtr, (const void **)&values, v81, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v77)
    CFRelease(v77);
  if (!v82)
    goto LABEL_158;
  CFArrayAppendValue((CFMutableArrayRef)Mutable, v82);
  CFRelease(v82);
LABEL_160:
  if (theString1)
  {
    if (CFEqual(theString1, CFSTR("http")))
    {
      if (Mutable)
        v83 = CFRetain(Mutable);
      else
        v83 = 0;
      __CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::httpProxyArray = (uint64_t)v83;
    }
    else if (CFEqual(theString1, &unk_1EDD00AE0))
    {
      if (Mutable)
        v84 = CFRetain(Mutable);
      else
        v84 = 0;
      __CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::httpsProxyArray = (uint64_t)v84;
    }
    else if (CFEqual(theString1, CFSTR("ftp")))
    {
      if (Mutable)
        v85 = CFRetain(Mutable);
      else
        v85 = 0;
      __CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::ftpProxyArray = (uint64_t)v85;
    }
  }
LABEL_176:
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFNetworkCopyProxiesForInterface(__CFString const*,__CFString const*,__CFDictionary const*,__CFString const*)::proxyArrayLock);
  if (v8)
    CFRelease(v8);
  return Mutable;
}

CFTypeRef HTTPProtocol::copyCustomProxySettings(HTTPProtocol *this)
{
  void *v2;
  uint64_t v3;
  unint64_t v4;
  const void *v5;
  CFTypeRef v6;
  const __CFDictionary *v7;
  const void *v8;
  char *v9;
  unsigned int v10;
  unint64_t v11;

  v2 = (void *)objc_msgSend((id)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration"), "_proxyConfigurations");
  if (v2 && objc_msgSend(v2, "count"))
  {
    v3 = *((unsigned int *)this + 48);
    v4 = v3 | ((unint64_t)*((unsigned __int16 *)this + 98) << 32) | 0x2000000000;
    *((_DWORD *)this + 48) = v3;
    *((_WORD *)this + 98) = WORD2(v4);
  }
  v5 = (const void *)objc_msgSend(*((id *)this + 10), "_proxySettings");
  if (v5)
  {
    v6 = v5;
    CFRetain(v5);
  }
  else
  {
    if (!__sProxyOverrideDict)
      return 0;
    v6 = CFRetain((CFTypeRef)__sProxyOverrideDict);
    if (!v6)
      return v6;
  }
  v7 = (const __CFDictionary *)CFRetain(v6);
  v8 = (const void *)*((_QWORD *)this + 76);
  *((_QWORD *)this + 76) = v7;
  if (v8)
  {
    CFRelease(v8);
    v7 = (const __CFDictionary *)*((_QWORD *)this + 76);
  }
  if (CFDictionaryGetCount(v7) >= 1)
    objc_msgSend(*((id *)this + 10), "set_proxyHandshakePending:", 1);
  v10 = *((_DWORD *)this + 48);
  v9 = (char *)this + 192;
  v11 = v10 | ((unint64_t)*((unsigned __int16 *)v9 + 2) << 32) | 0x2000000000;
  *(_DWORD *)v9 = v10;
  *((_WORD *)v9 + 2) = WORD2(v11);
  return v6;
}

void sub_183F0BC80(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183F0BFE8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183F0C084(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_183F0C37C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  v15 = v14;

  _Unwind_Resume(a1);
}

void sub_183F0C4EC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183F0C6CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void HTTP3Fields::appendField(std::vector<char> *this, char *a2, NSString *a3)
{
  NSString *v5;
  size_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  char *end;
  std::vector<char>::pointer begin;
  unint64_t v12;
  char *v13;
  std::vector<char>::pointer v14;
  unint64_t v15;
  char *v16;
  char *value;
  char *v18;
  NSObject *v19;
  unint64_t v20;
  std::vector<char>::pointer v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  char *v27;
  uint64_t v28;
  char *v29;
  std::vector<char>::pointer v30;
  std::vector<char>::pointer v31;
  int v32;
  uint8_t buf[4];
  NSString *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  v6 = strlen(a2);
  v7 = -[NSString lengthOfBytesUsingEncoding:](v5, "lengthOfBytesUsingEncoding:", 5);
  v8 = v7;
  if (v7 + v6 >= 0x10000)
  {
    CFN_LOG_h3stream();
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v34 = v5;
      _os_log_error_impl(&dword_183ECA000, v9, OS_LOG_TYPE_ERROR, "Dropping HTTP field due to overlong value %@", buf, 0xCu);
    }
LABEL_4:

    goto LABEL_33;
  }
  if (!v7 && -[NSString length](v5, "length"))
  {
    CFN_LOG_h3stream();
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v34 = v5;
      _os_log_error_impl(&dword_183ECA000, v9, OS_LOG_TYPE_ERROR, "Dropping HTTP field due to invalid value %@", buf, 0xCu);
    }
    goto LABEL_4;
  }
  begin = this->__begin_;
  end = this->__end_;
  std::vector<char>::__insert_with_size[abi:nn180100]<char const*,char const*>((uint64_t)this, end, a2, &a2[v6], v6);
  v12 = end - begin;
  v13 = (char *)(end - begin + v6);
  v14 = this->__begin_;
  v15 = this->__end_ - this->__begin_;
  if ((unint64_t)&v13[v8] <= v15)
  {
    if ((unint64_t)&v13[v8] < v15)
      this->__end_ = &v13[v8 + (_QWORD)v14];
  }
  else
  {
    std::vector<char>::__append(this, (std::vector<char>::size_type)&v13[v8 - v15]);
    v14 = this->__begin_;
  }
  if (-[NSString getBytes:maxLength:usedLength:encoding:options:range:remainingRange:](v5, "getBytes:maxLength:usedLength:encoding:options:range:remainingRange:", &v13[(_QWORD)v14], v8, 0, 5, 0, 0, -[NSString length](v5, "length"), 0))
  {
    v16 = this[1].__end_;
    value = this[1].__end_cap_.__value_;
    if (v16 >= value)
    {
      v21 = this[1].__begin_;
      v22 = (v16 - v21) >> 2;
      v23 = v22 + 1;
      if ((unint64_t)(v22 + 1) >> 62)
        abort();
      v24 = value - v21;
      if (v24 >> 1 > v23)
        v23 = v24 >> 1;
      if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL)
        v25 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v25 = v23;
      v26 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned short,unsigned short>>>(v25);
      v27 = &v26[4 * v22];
      v29 = &v26[4 * v28];
      *(_WORD *)v27 = v6;
      *((_WORD *)v27 + 1) = v8;
      v18 = v27 + 4;
      v31 = this[1].__begin_;
      v30 = this[1].__end_;
      if (v30 != v31)
      {
        do
        {
          v32 = *((_DWORD *)v30 - 1);
          v30 -= 4;
          *((_DWORD *)v27 - 1) = v32;
          v27 -= 4;
        }
        while (v30 != v31);
        v30 = this[1].__begin_;
      }
      this[1].__begin_ = v27;
      this[1].__end_ = v18;
      this[1].__end_cap_.__value_ = v29;
      if (v30)
        operator delete(v30);
    }
    else
    {
      *(_WORD *)v16 = v6;
      *((_WORD *)v16 + 1) = v8;
      v18 = v16 + 4;
    }
    this[1].__end_ = v18;
  }
  else
  {
    CFN_LOG_h3stream();
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v34 = v5;
      _os_log_error_impl(&dword_183ECA000, v19, OS_LOG_TYPE_ERROR, "Dropping HTTP field due to invalid value %@", buf, 0xCu);
    }

    v20 = this->__end_ - this->__begin_;
    if (v12 <= v20)
    {
      if (v12 < v20)
        this->__end_ = &this->__begin_[v12];
    }
    else
    {
      std::vector<char>::__append(this, v12 - v20);
    }
  }
LABEL_33:

}

void sub_183F0CA6C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void HTTP3Fields::appendField(std::vector<char> *this, NSString *a2, NSString *a3)
{
  NSString *v5;
  NSString *v6;
  NSString *v7;
  const char *v8;
  char *v9;
  size_t v10;
  NSObject *v11;
  int64_t v12;
  uint64_t v13;
  char *end;
  std::vector<char>::pointer begin;
  unint64_t v16;
  std::vector<char>::pointer v17;
  std::vector<char>::pointer v18;
  std::vector<char>::pointer v19;
  char *v20;
  char *v21;
  char *value;
  char *v23;
  NSObject *v24;
  unint64_t v25;
  std::vector<char>::pointer v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char *v31;
  char *v32;
  uint64_t v33;
  char *v34;
  std::vector<char>::pointer v35;
  std::vector<char>::pointer v36;
  int v37;
  uint8_t buf[4];
  NSString *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = a3;
  v7 = objc_retainAutorelease(v5);
  v8 = -[NSString UTF8String](v7, "UTF8String");
  v9 = (char *)v8;
  if (!v8)
  {
    CFN_LOG_h3stream();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v39 = v7;
      _os_log_error_impl(&dword_183ECA000, v11, OS_LOG_TYPE_ERROR, "Dropping HTTP field due to invalid name %@", buf, 0xCu);
    }
    goto LABEL_12;
  }
  v10 = strlen(v8);
  if (v10 >= 0x10000)
  {
    CFN_LOG_h3stream();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v39 = v7;
      _os_log_error_impl(&dword_183ECA000, v11, OS_LOG_TYPE_ERROR, "Dropping HTTP field due to overlong name %@", buf, 0xCu);
    }
LABEL_12:

    goto LABEL_39;
  }
  v12 = v10;
  v13 = -[NSString lengthOfBytesUsingEncoding:](v6, "lengthOfBytesUsingEncoding:", 5);
  if ((unint64_t)(v13 + v12) >= 0x10000)
  {
    CFN_LOG_h3stream();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v39 = v6;
      _os_log_error_impl(&dword_183ECA000, v11, OS_LOG_TYPE_ERROR, "Dropping HTTP field due to overlong value %@", buf, 0xCu);
    }
    goto LABEL_12;
  }
  begin = this->__begin_;
  end = this->__end_;
  std::vector<char>::__insert_with_size[abi:nn180100]<char const*,char const*>((uint64_t)this, end, v9, &v9[v12], v12);
  v16 = end - begin;
  v17 = this->__begin_;
  v18 = this->__end_;
  v19 = &this->__begin_[v16];
  if (v19 != v18)
  {
    do
    {
      *v19 = __tolower(*v19);
      ++v19;
    }
    while (v19 != v18);
    v17 = this->__begin_;
    v19 = this->__end_;
  }
  v20 = (char *)(v16 + v12 + v13);
  if ((unint64_t)v20 <= v19 - v17)
  {
    if ((unint64_t)v20 < v19 - v17)
      this->__end_ = &v20[(_QWORD)v17];
  }
  else
  {
    std::vector<char>::__append(this, (std::vector<char>::size_type)&v20[-(v19 - v17)]);
    v17 = this->__begin_;
  }
  if (-[NSString getBytes:maxLength:usedLength:encoding:options:range:remainingRange:](v6, "getBytes:maxLength:usedLength:encoding:options:range:remainingRange:", &v17[v16 + v12], v13, 0, 5, 0, 0, -[NSString length](v6, "length"), 0))
  {
    v21 = this[1].__end_;
    value = this[1].__end_cap_.__value_;
    if (v21 >= value)
    {
      v26 = this[1].__begin_;
      v27 = (v21 - v26) >> 2;
      v28 = v27 + 1;
      if ((unint64_t)(v27 + 1) >> 62)
        abort();
      v29 = value - v26;
      if (v29 >> 1 > v28)
        v28 = v29 >> 1;
      if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFFCLL)
        v30 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v30 = v28;
      v31 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned short,unsigned short>>>(v30);
      v32 = &v31[4 * v27];
      v34 = &v31[4 * v33];
      *(_WORD *)v32 = v12;
      *((_WORD *)v32 + 1) = v13;
      v23 = v32 + 4;
      v36 = this[1].__begin_;
      v35 = this[1].__end_;
      if (v35 != v36)
      {
        do
        {
          v37 = *((_DWORD *)v35 - 1);
          v35 -= 4;
          *((_DWORD *)v32 - 1) = v37;
          v32 -= 4;
        }
        while (v35 != v36);
        v35 = this[1].__begin_;
      }
      this[1].__begin_ = v32;
      this[1].__end_ = v23;
      this[1].__end_cap_.__value_ = v34;
      if (v35)
        operator delete(v35);
    }
    else
    {
      *(_WORD *)v21 = v12;
      *((_WORD *)v21 + 1) = v13;
      v23 = v21 + 4;
    }
    this[1].__end_ = v23;
  }
  else
  {
    CFN_LOG_h3stream();
    v24 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v39 = v6;
      _os_log_error_impl(&dword_183ECA000, v24, OS_LOG_TYPE_ERROR, "Dropping HTTP field due to invalid value %@", buf, 0xCu);
    }

    v25 = this->__end_ - this->__begin_;
    if (v16 <= v25)
    {
      if (v16 < v25)
        this->__end_ = &this->__begin_[v16];
    }
    else
    {
      std::vector<char>::__append(this, v16 - v25);
    }
  }
LABEL_39:

}

void sub_183F0CE38(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void std::vector<char>::__append(std::vector<char> *this, std::vector<char>::size_type __n)
{
  char *value;
  char *end;
  std::vector<char>::pointer begin;
  int64_t v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char v15;

  end = this->__end_;
  value = this->__end_cap_.__value_;
  if (value - end >= __n)
  {
    if (__n)
    {
      bzero(this->__end_, __n);
      end += __n;
    }
    this->__end_ = end;
  }
  else
  {
    begin = this->__begin_;
    v7 = end - this->__begin_;
    v8 = v7 + __n;
    if ((uint64_t)(v7 + __n) < 0)
      abort();
    v9 = value - begin;
    if (2 * v9 > v8)
      v8 = 2 * v9;
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v10 = v8;
    if (v10)
      v11 = (char *)operator new(v10);
    else
      v11 = 0;
    v12 = &v11[v7];
    v13 = &v11[v10];
    bzero(v12, __n);
    if (end == begin)
    {
      v11 = v12;
    }
    else
    {
      v14 = &end[~(unint64_t)begin];
      do
      {
        v15 = *--end;
        (v14--)[(_QWORD)v11] = v15;
      }
      while (end != begin);
      end = this->__begin_;
    }
    this->__begin_ = v11;
    this->__end_ = &v12[__n];
    this->__end_cap_.__value_ = v13;
    if (end)
      operator delete(end);
  }
}

void connectionTimingFromMetrics(__CFN_ConnectionMetrics *a1, void *a2)
{
  id v3;
  void *v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t attempt_started_after_milliseconds;
  uint64_t resolution_started_after_milliseconds;
  uint64_t flow_started_after_milliseconds;
  int v10;
  int64x2_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  float64x2_t *v17;
  unsigned int v18;
  float64x2_t *v19;
  float64x2_t v20;
  uint64_t v21;
  _QWORD v22[6];
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  void (*v31)(uint64_t);
  id v32;
  _QWORD enumerate_block[5];
  uint64_t v34;
  float64x2_t *v35;
  uint64_t v36;
  __n128 (*v37)(uint64_t, uint64_t);
  uint64_t (*v38)();
  void *v39;
  __int128 v40;
  __int128 v41;

  v3 = a2;
  v4 = v3;
  v34 = 0;
  v35 = (float64x2_t *)&v34;
  v36 = 0x5012000000;
  v37 = __Block_byref_object_copy__18519;
  v38 = __Block_byref_object_dispose__18520;
  v39 = &unk_18422E08D;
  v40 = xmmword_18411E4F8;
  v41 = unk_18411E508;
  if (!v3)
  {
    v6 = 0;
    goto LABEL_11;
  }
  v21 = *((_QWORD *)v3 + 11);
  v5 = *((id *)v3 + 21);
  v6 = v5;
  if (v5)
  {
    attempt_started_after_milliseconds = nw_establishment_report_get_attempt_started_after_milliseconds(v5);
    resolution_started_after_milliseconds = nw_establishment_report_get_resolution_started_after_milliseconds();
    flow_started_after_milliseconds = nw_establishment_report_get_flow_started_after_milliseconds();
    v10 = flow_started_after_milliseconds;
    v11.i64[0] = resolution_started_after_milliseconds;
    v11.i64[1] = flow_started_after_milliseconds;
    v35[3] = vaddq_f64((float64x2_t)vdupq_lane_s64(v21, 0), vdivq_f64(vcvtq_f64_u64((uint64x2_t)vaddq_s64(v11, vdupq_n_s64(attempt_started_after_milliseconds))), (float64x2_t)vdupq_n_s64(0x408F400000000000uLL)));
    v12 = MEMORY[0x1E0C809B0];
    enumerate_block[0] = MEMORY[0x1E0C809B0];
    enumerate_block[1] = 3221225472;
    enumerate_block[2] = ___Z27connectionTimingFromMetricsP23__CFN_ConnectionMetrics_block_invoke;
    enumerate_block[3] = &unk_1E14FE258;
    enumerate_block[4] = &v34;
    nw_establishment_report_enumerate_resolution_reports(v6, enumerate_block);
    v27 = 0;
    v28 = &v27;
    v29 = 0x3032000000;
    v30 = __Block_byref_object_copy__1;
    v31 = __Block_byref_object_dispose__2;
    v32 = 0;
    v23 = 0;
    v24 = &v23;
    v25 = 0x2020000000;
    v26 = 0;
    v22[0] = v12;
    v22[1] = 3221225472;
    v22[2] = ___Z27connectionTimingFromMetricsP23__CFN_ConnectionMetrics_block_invoke_3;
    v22[3] = &unk_1E14FE280;
    v22[4] = &v27;
    v22[5] = &v23;
    nw_establishment_report_enumerate_protocols(v6, v22);
    v13 = v28[5];
    if (v13)
    {
      v14 = (void *)MEMORY[0x186DB8944]();
      if (MEMORY[0x186DB895C](v13, v14))
      {

LABEL_7:
        v17 = v35;
        LODWORD(v35[4].f64[1]) = v24[3];
        BYTE4(v17[4].f64[1]) = 1;
        goto LABEL_8;
      }
      v15 = v28[5];
      v16 = (void *)nw_protocol_copy_quic_connection_definition();
      LODWORD(v15) = MEMORY[0x186DB895C](v15, v16);

      if ((_DWORD)v15)
        goto LABEL_7;
    }
LABEL_8:
    v18 = nw_establishment_report_get_duration_milliseconds(v6) - v10;
    v19 = v35;
    HIDWORD(v35[4].f64[0]) = v18;
    if (LODWORD(v19[4].f64[1]) > v18)
      LODWORD(v19[4].f64[1]) = v18;
    _Block_object_dispose(&v23, 8);
    _Block_object_dispose(&v27, 8);

  }
LABEL_11:

  v20 = v35[4];
  *(float64x2_t *)&a1->super.isa = v35[3];
  *(float64x2_t *)&a1->_expensive = v20;
  _Block_object_dispose(&v34, 8);

}

void sub_183F0D4BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,id a27)
{
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;

  _Block_object_dispose(&a18, 8);
  _Block_object_dispose(&a22, 8);

  _Block_object_dispose((const void *)(v31 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t CFCachedURLResponseCopyWrappedResponse(const _CFCachedURLResponse *a1)
{
  __CFCachedURLResponse *var1;
  _CFURLResponse *v2;
  const __CFAllocator *v3;

  if (!a1)
    return 0;
  var1 = a1->var1;
  v2 = (_CFURLResponse *)*((_QWORD *)var1 + 4);
  if (!v2)
    return 0;
  v3 = CFGetAllocator(*((CFTypeRef *)var1 + 4));
  return CFURLResponseCreateCopy(v3, v2);
}

uint64_t CFURLResponseCreateCopy(const __CFAllocator *a1, _CFURLResponse *a2)
{
  NSURLResponseInternal *v3;
  uint64_t v4;
  uint64_t v5;
  CFTypeRef v6;
  const __CFString *v7;
  CFStringRef Copy;
  CFTypeRef v9;
  uint64_t v10;
  CFTypeRef v11;
  CFTypeRef v12;
  CFTypeRef v13;
  uint64_t Instance;
  uint64_t v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;

  v3 = objc_alloc_init(NSURLResponseInternal);
  v4 = -[NSURLResponseInternal _inner](v3, "_inner");
  v5 = -[_CFURLResponse _inner](a2, "_inner");
  v6 = *(CFTypeRef *)(v5 + 8);
  if (v6)
    v6 = CFRetain(v6);
  *(_QWORD *)(v4 + 8) = v6;
  v7 = *(const __CFString **)(v5 + 16);
  if (v7)
    Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v7);
  else
    Copy = 0;
  *(_QWORD *)(v4 + 16) = Copy;
  v9 = *(CFTypeRef *)(v5 + 24);
  if (v9)
    v9 = CFRetain(v9);
  v10 = *(_QWORD *)(v5 + 32);
  *(_QWORD *)(v4 + 24) = v9;
  *(_QWORD *)(v4 + 32) = v10;
  *(_OWORD *)(v4 + 40) = *(_OWORD *)(v5 + 40);
  *(_DWORD *)(v4 + 72) = *(_DWORD *)(v5 + 72);
  v11 = *(CFTypeRef *)(v5 + 56);
  if (v11)
    v11 = CFRetain(v11);
  *(_QWORD *)(v4 + 56) = v11;
  v12 = *(CFTypeRef *)(v5 + 64);
  if (v12)
    v12 = CFRetain(v12);
  *(_QWORD *)(v4 + 64) = v12;
  v13 = *(CFTypeRef *)(v5 + 80);
  if (v13)
    v13 = CFRetain(v13);
  *(_QWORD *)(v4 + 80) = v13;
  *(_WORD *)(v4 + 96) = *(_WORD *)(v5 + 96);
  if (*(_QWORD *)(v5 + 88))
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      *(_OWORD *)(Instance + 16) = 0u;
      Instance += 16;
      *(_QWORD *)(Instance + 336) = 0;
      *(_OWORD *)(Instance + 304) = 0u;
      *(_OWORD *)(Instance + 320) = 0u;
      *(_OWORD *)(Instance + 272) = 0u;
      *(_OWORD *)(Instance + 288) = 0u;
      *(_OWORD *)(Instance + 240) = 0u;
      *(_OWORD *)(Instance + 256) = 0u;
      *(_OWORD *)(Instance + 208) = 0u;
      *(_OWORD *)(Instance + 224) = 0u;
      *(_OWORD *)(Instance + 176) = 0u;
      *(_OWORD *)(Instance + 192) = 0u;
      *(_OWORD *)(Instance + 144) = 0u;
      *(_OWORD *)(Instance + 160) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 128) = 0u;
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 48) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
    }
    v15 = *(_QWORD *)(v5 + 88);
    HTTPResponseMessage::HTTPResponseMessage((HTTPResponseMessage *)Instance, (const char **)v15);
    *(_QWORD *)v16 = &off_1E14E6048;
    *(_QWORD *)(v16 + 8) = &unk_1E14E60B8;
    *(_QWORD *)(v16 + 16) = &unk_1E14E60D8;
    v17 = *(_WORD *)(v15 + 297);
    *(_BYTE *)(v16 + 299) = *(_BYTE *)(v15 + 299);
    *(_WORD *)(v16 + 297) = v17;
    *(_OWORD *)(v16 + 304) = *(_OWORD *)(v15 + 304);
    *(_OWORD *)(v16 + 320) = *(_OWORD *)(v15 + 320);
    *(_QWORD *)(v16 + 336) = *(_QWORD *)(v15 + 336);
  }
  else
  {
    v16 = 0;
  }
  *(_QWORD *)(v4 + 88) = v16;
  -[NSURLResponseInternal _inner](v3, "_inner");
  v18 = objc_msgSend(objc_alloc((Class)objc_opt_class()), "_initWithInternal:", v3);

  return v18;
}

uint64_t `non-virtual thunk to'HTTPResponseMessage::parserCompleteFirstLine(HTTPResponseMessage *this, char *a2, int64_t a3)
{
  return HTTPResponseMessage::parserCompleteFirstLine((HTTPResponseMessage *)((char *)this - 16), a2, a3);
}

uint64_t HTTPResponseMessage::parserCompleteFirstLine(HTTPResponseMessage *this, char *__s1, int64_t __n)
{
  char *v4;
  char *v6;
  unint64_t v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  unsigned int v12;
  char *v13;
  BOOL v14;
  CFIndex v15;
  unsigned int CanonicalCStringLen;
  const __CFString *v17;
  char *v18;
  char *v19;
  const __CFString *v20;
  const __CFString *v21;
  const __CFString *v22;
  int v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  __int16 v30[8];
  char *v31;
  char *v32;
  char *v33;
  char *v34;

  if (*((_QWORD *)this + 36))
    return 0;
  v4 = (char *)this + 160;
  if (*((_BYTE *)this + 160))
    return 0;
  if (__n >= 128)
  {
    v6 = strndup(__s1, __n);
    *((_QWORD *)this + 36) = v6;
    v7 = (unint64_t)&v6[__n];
    v33 = 0;
    v34 = 0;
    v4 = v6;
    v31 = v6;
    v32 = 0;
LABEL_8:
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = MEMORY[0x1E0C80978];
    while (1)
    {
      v12 = *v4;
      if (!*v4)
      {
LABEL_26:
        v33 = v10;
        v34 = v9;
        v32 = v8;
        if (v9)
          goto LABEL_32;
        goto LABEL_31;
      }
      if (v9)
      {
        v33 = v10;
        v34 = v9;
        v32 = v8;
        goto LABEL_32;
      }
      if ((v12 & 0x80000000) != 0)
      {
        if (!__maskrune(v12, 0x4000uLL))
        {
LABEL_20:
          v9 = 0;
          if (v10)
            v14 = 1;
          else
            v14 = v8 == 0;
          if (!v14)
            v10 = v4;
          goto LABEL_25;
        }
      }
      else if ((*(_DWORD *)(v11 + 4 * v12 + 60) & 0x4000) == 0)
      {
        goto LABEL_20;
      }
      if (v10)
        v13 = v4;
      else
        v13 = 0;
      if (v8)
      {
        v9 = v13;
      }
      else
      {
        v8 = v4;
        v9 = 0;
      }
LABEL_25:
      if ((unint64_t)++v4 >= v7)
        goto LABEL_26;
    }
  }
  strncpy((char *)this + 160, __s1, __n);
  if (!__n)
  {
    *((_QWORD *)this + 5) = CFRetain(&gConstantCFStringValueTable[2835]);
    *((_DWORD *)this + 32) = 200;
    return 1;
  }
  v7 = (unint64_t)&v4[__n];
  v33 = 0;
  v34 = 0;
  v31 = v4;
  v32 = 0;
  if (__n > 0)
  {
    v6 = v4;
    goto LABEL_8;
  }
  v10 = 0;
  v33 = 0;
  v34 = 0;
  v6 = v4;
LABEL_31:
  v34 = v4;
  v9 = v4;
LABEL_32:
  if (!FirstLineFieldsBase::checkFields((uint64_t)&v31, 2, (unint64_t)v6, v7) || v9 - v10 >= 4)
    goto LABEL_60;
  v15 = v32 - v6;
  CanonicalCStringLen = _findCanonicalCStringLen((uint64_t)v6, (int)v32 - (int)v6, 8);
  v17 = CanonicalCStringLen == 568
      ? CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v6, v15, 0x201u, 0)
      : (const __CFString *)CFRetain(&gConstantCFStringValueTable[7 * ((CanonicalCStringLen >> 20) & 0x3FF)]);
  *((_QWORD *)this + 5) = v17;
  if (!v17)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      goto LABEL_60;
    v30[0] = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "should be", (uint8_t *)v30, 2u);
    v17 = (const __CFString *)*((_QWORD *)this + 5);
    if (!v17)
      goto LABEL_60;
  }
  v19 = v33;
  v18 = v34;
  if (CFStringCompare(v17, (CFStringRef)&gConstantCFStringValueTable[2842], 0) == kCFCompareEqualTo)
    goto LABEL_48;
  v20 = (const __CFString *)*((_QWORD *)this + 5);
  if (!v20)
    goto LABEL_60;
  if (CFStringCompare(v20, (CFStringRef)&gConstantCFStringValueTable[2849], 0) == kCFCompareEqualTo)
    goto LABEL_48;
  v21 = (const __CFString *)*((_QWORD *)this + 5);
  if (!v21)
    goto LABEL_60;
  if (CFStringCompare(v21, (CFStringRef)&gConstantCFStringValueTable[2856], 0))
  {
    v22 = (const __CFString *)*((_QWORD *)this + 5);
    if (!v22)
      goto LABEL_60;
    v23 = CFStringCompare(v22, (CFStringRef)&gConstantCFStringValueTable[2863], 0) == kCFCompareEqualTo;
  }
  else
  {
LABEL_48:
    v23 = 1;
  }
  v24 = 0;
  if (v19 && v19 < v18 && v23)
  {
    v24 = 0;
    v25 = (unint64_t)(v19 + 1);
    do
    {
      v26 = *(unsigned __int8 *)(v25 - 1);
      v27 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v26 + 60);
      v28 = v26 + 10 * v24 - 48;
      v23 &= v27 << 21 >> 31;
      if ((v27 & 0x400) != 0)
        v24 = v28;
      if (v25 >= (unint64_t)v18)
        break;
      ++v25;
    }
    while ((_BYTE)v23);
  }
  if ((_BYTE)v23)
  {
    *((_QWORD *)this + 16) = v24;
    return 1;
  }
LABEL_60:
  HTTPResponseMessage::uninitFirstLine(this);
  return 0;
}

BOOL FirstLineFieldsBase::checkFields(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  BOOL v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  BOOL v9;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;

  v4 = 0;
  v5 = 0;
LABEL_2:
  v6 = *(_QWORD *)(a1 + 16 * v5);
  if (v6)
    v7 = v6 >= a3;
  else
    v7 = 0;
  if (v7)
  {
    v8 = *(_QWORD *)(a1 + 16 * v5 + 8);
    v9 = v6 > v8 || v8 == 0;
    if (!v9 && v8 <= a4)
    {
      v11 = 0;
      v12 = (unint64_t *)(a1 + 8);
      while (1)
      {
        if (v5 != v11)
        {
          v13 = *(v12 - 1);
          if (v6 > v13 && v6 < *v12)
            break;
          if (v8 > v13 && v8 < *v12)
            break;
        }
        ++v11;
        v12 += 2;
        if (a2 == v11)
        {
          v4 = ++v5 >= a2;
          if (v5 != a2)
            goto LABEL_2;
          return v4;
        }
      }
    }
  }
  return v4;
}

uint64_t HTTPParser::commitFirstLine(HTTPParser *this)
{
  uint64_t v1;
  char *v3;
  uint64_t v5;

  v1 = *((_QWORD *)this + 72);
  if (!v1)
    return 0;
  v5 = 0;
  v3 = HTTPParser::trimBuffer(*((HTTPParser **)this + 70), 0, v1, &v5);
  return (*(uint64_t (**)(_QWORD, char *, uint64_t))(**((_QWORD **)this + 3) + 16))(*((_QWORD *)this + 3), v3, v5);
}

uint64_t AppSSOProtocol::_canHandleRequest(AppSSOProtocol *this, const _CFURLRequest *a2, const void *a3)
{
  return 0;
}

void ___ZN19URLConnectionLoader19initiateCacheLookupEP12NSURLRequestPK9XURLCache23NSURLRequestCachePolicy_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  const char *v3;
  void *v4;
  CFAbsoluteTime *Property;
  CFAbsoluteTime *v6;
  id v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  int v12;
  void *v13;
  void *v14;
  void *v15;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  id v20;
  NSURLRequest *v21;
  const void *v22;
  _QWORD v23[7];

  v2 = *(_QWORD *)(a1 + 40);
  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  v4 = *(void **)(v2 + 72);
  if (v4)
  {
    Property = (CFAbsoluteTime *)objc_getProperty(v4, v3, 96, 1);
    if (Property)
    {
      v6 = Property;
      v7 = *(id *)(a1 + 48);
      Property[21] = CFAbsoluteTimeGetCurrent();
      if (v7)
        v7 = -[NSCachedURLResponse _initWithCFCachedURLResponse:]([NSCachedURLResponse alloc], "_initWithCFCachedURLResponse:", v7);
      objc_msgSend(v7, "response");
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = (void *)*((_QWORD *)v6 + 9);
      *((_QWORD *)v6 + 9) = v8;

      objc_msgSend(v7, "data");
      v10 = (void *)objc_claimAutoreleasedReturnValue();

      if (v10)
      {
        v11 = (void *)*((_QWORD *)v6 + 6);
        v12 = *((_DWORD *)v6 + 4);
        objc_msgSend(v7, "data");
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        v14 = (void *)objc_msgSend(v13, "_createDispatchData");
        logHARResponseBody(v11, v12, v14);

      }
    }
  }
  v15 = *(void **)(a1 + 32);
  v16 = *(const void **)(a1 + 48);
  v17 = *(_QWORD *)(a1 + 56);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 40));
  if (!v16 || v17)
  {
    objc_msgSend(*(id *)(v2 + 64), "_cachePolicy");
    URLConnectionLoader::loadWithWhatToDo(v2, v15, v16, 0, 0);
  }
  else
  {
    v18 = *(_QWORD *)(v2 + 144);
    if (v18)
    {
      v19 = (*(uint64_t (**)(uint64_t, const void *))(*(_QWORD *)v18 + 136))(v18, v16);
      URLConnectionLoader::loadWithCacheValidity(v2, v15, v16, v19);
    }
    else
    {
      CFRetain(v16);
      v20 = v15;
      v23[0] = MEMORY[0x1E0C809B0];
      v23[1] = 3221225472;
      v23[2] = ___ZN19URLConnectionLoader29continueWithCacheLookupResultEP12NSURLRequestPK20_CFCachedURLResponse23NSURLRequestCachePolicy_block_invoke;
      v23[3] = &unk_1E14FC3C0;
      v23[4] = v15;
      v23[5] = v2;
      v23[6] = v16;
      URLConnectionLoader::ensureLoaderHasProtocolNoLock((URLConnectionLoader *)v2, v21);
      URLConnectionLoader::withExistingProtocolAsync(v2, (uint64_t)v23);
    }
  }

  (*(void (**)(_QWORD))(**(_QWORD **)(v2 + 32) + 72))(*(_QWORD *)(v2 + 32));
  v22 = *(const void **)(a1 + 48);
  if (v22)
    CFRelease(v22);
}

void sub_183F0DE74(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t URLConnectionLoader::loadWithWhatToDo(uint64_t a1, void *a2, const void *a3, uint64_t a4, int a5)
{
  uint64_t v9;
  uint64_t result;
  NSURLRequest *v11;
  uint64_t v12;
  uint64_t (*v13)(void);
  NSURLRequest *v14;
  uint64_t v15;
  _QWORD v16[7];

  v9 = objc_msgSend(*(id *)(a1 + 64), "_cachePolicy");
  result = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_99, 1);
  if (result)
  {
    v12 = result;
    result = (*(uint64_t (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)result + 16))(result, "LoaderWhatToDo", 0);
    if ((_DWORD)result)
    {
      (*(void (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)v12 + 40))(v12, "Request", objc_msgSend(a2, "cfURL"));
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v12 + 72))(v12, "CachePolicy", CFSTR("%lu"));
      switch(a5)
      {
        case 2:
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v12 + 72))(v12, "WhatToDo", CFSTR("fail %ld"));
          break;
        case 1:
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v12 + 72))(v12, "WhatToDo", CFSTR("use cached response %@"));
          break;
        case 0:
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v12 + 72))(v12, "WhatToDo", CFSTR("originload"));
          break;
      }
      CFAbsoluteTimeGetCurrent();
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v12 + 72))(v12, "CreateToNow", CFSTR("%.5fs"));
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
    }
  }
  if (a5)
  {
    if (a5 == 1)
    {
      if (nw_settings_get_signposts_enabled())
        kdebug_trace();
      if (a3)
        CFRetain(a3);
      v13 = *(uint64_t (**)(void))(**(_QWORD **)(a1 + 32) + 40);
      return v13();
    }
    if (a5 != 2)
      return result;
    goto LABEL_16;
  }
  if (!a3 && v9 == 3)
  {
LABEL_16:
    v13 = *(uint64_t (**)(void))(**(_QWORD **)(a1 + 32) + 40);
    return v13();
  }
  if (*(_BYTE *)(a1 + 201))
  {
    *(_BYTE *)(a1 + 160) = 0;
    if (!URLConnectionLoader::ensureLoaderHasProtocolNoLock((URLConnectionLoader *)a1, v11))
    {
      v13 = *(uint64_t (**)(void))(**(_QWORD **)(a1 + 32) + 40);
      return v13();
    }
    if (!*(_BYTE *)(a1 + 202) && *(double *)(a1 + 120) > 0.0)
    {
      *(_BYTE *)(a1 + 136) = 1;
      *(CFAbsoluteTime *)(a1 + 128) = CFAbsoluteTimeGetCurrent() + *(double *)(a1 + 120);
      URLConnectionLoader::scheduleTimeoutTimer((URLConnectionLoader *)a1);
    }
    *(CFAbsoluteTime *)(a1 + 184) = CFAbsoluteTimeGetCurrent();
    v15 = *(_QWORD *)(a1 + 168);
    if (!v15 || !*(_DWORD *)(v15 + 40))
      __assert_rtn("_private_ScheduleOriginLoad", "URLConnectionLoader.cpp", 1834, "fLoaderSchedulingSet && !fLoaderSchedulingSet->isEmpty()");
    if (a2)
      CFRetain(a2);
    if (a3)
      CFRetain(a3);
    v16[0] = MEMORY[0x1E0C809B0];
    v16[1] = 3221225472;
    v16[2] = ___ZN19URLConnectionLoader27_private_ScheduleOriginLoadEP12NSURLRequestPK20_CFCachedURLResponse_block_invoke_2;
    v16[3] = &unk_1E14FC3C0;
    v16[5] = a1;
    v16[6] = a3;
    v16[4] = a2;
    URLConnectionLoader::ensureLoaderHasProtocolNoLock((URLConnectionLoader *)a1, v14);
    return URLConnectionLoader::withExistingProtocolAsync(a1, (uint64_t)v16);
  }
  return result;
}

uint64_t URLConnectionLoader::withExistingProtocolAsync(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[7];

  v3 = *(_QWORD *)(a1 + 144);
  if (!v3)
    return (*(uint64_t (**)(uint64_t, _QWORD))(a2 + 16))(a2, 0);
  v5 = *(_QWORD *)(a1 + 168);
  if (!v5 || !*(_DWORD *)(v5 + 40))
    __assert_rtn("withExistingProtocolAsync", "URLConnectionLoader.cpp", 1190, "fLoaderSchedulingSet && !fLoaderSchedulingSet->isEmpty()");
  CFRetain((CFTypeRef)(v3 - 16));
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
  v6 = *(_QWORD *)(a1 + 168);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZNK19URLConnectionLoader25withExistingProtocolAsyncEU13block_pointerFvP11URLProtocolE_block_invoke;
  v8[3] = &unk_1E14FDB30;
  v8[4] = a2;
  v8[5] = a1;
  v8[6] = v3;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v8);
}

BOOL URLConnectionLoader::ensureLoaderHasProtocolNoLock(URLConnectionLoader *this, NSURLRequest *a2)
{
  uint64_t var21;
  id var16;
  NSObject *v5;
  uint64_t v6;
  id var9;
  void *v8;
  uint64_t v9;
  void *v10;
  double v11;
  const NSURLSessionTask *v12;
  const void *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  char var28;
  BOOL v25;
  void ***p_var8;
  _QWORD v28[5];
  _QWORD handler[6];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint8_t v34[128];
  uint8_t buf[4];
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  var21 = (uint64_t)this->var21;
  if (var21)
    return var21 != 0;
  if (!*((_BYTE *)&this->var28 + 1) || (var16 = this->var16) == 0)
  {
    var21 = 0;
    return var21 != 0;
  }
  if (!this->var22)
  {
    v5 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, (dispatch_queue_t)this->var6);
    (*(void (**)(InterfaceRequiredForLoader *))(*(_QWORD *)this->var5 + 64))(this->var5);
    v6 = MEMORY[0x1E0C809B0];
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 3221225472;
    handler[2] = ___ZN19URLConnectionLoader29ensureLoaderHasProtocolNoLockEP12NSURLRequest_block_invoke;
    handler[3] = &unk_1E14FE140;
    handler[4] = v5;
    handler[5] = this;
    dispatch_source_set_event_handler(v5, handler);
    v28[0] = v6;
    v28[1] = 3221225472;
    v28[2] = ___ZN19URLConnectionLoader29ensureLoaderHasProtocolNoLockEP12NSURLRequest_block_invoke_2;
    v28[3] = &__block_descriptor_40_e5_v8__0l;
    v28[4] = this;
    dispatch_source_set_cancel_handler(v5, v28);
    dispatch_source_set_timer(v5, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    this->var22 = v5;
    dispatch_resume(v5);
    var16 = this->var16;
    if (!var16)
    {
LABEL_31:
      var21 = 0;
      this->var21 = 0;
      return var21 != 0;
    }
  }
  var9 = this->var9;
  v8 = (void *)MEMORY[0x186DB8C8C](this, a2);
  v9 = objc_msgSend(var9, "_protocolForTask");
  if (v9)
  {
    v10 = (void *)v9;
    objc_msgSend(var9, "set_protocolForTask:", 0);
    if ((objc_msgSend(var9, "_preventsAppSSO") & 1) != 0
      || AppSSO::AppSSODisabled == 1
      || (gotLoadHelper_x8__SOErrorDomain(v11), !*(_QWORD *)(v14 + 1776))
      || !AppSSOProtocol::_canHandleTask((AppSSOProtocol *)var9, v12, v13))
    {
      v17 = -[__NSURLSessionLocal _newURLProtocolForTask:client:protocolClass:]((uint64_t)var9, (uint64_t)&this->var8, v10);
      if (v17)
      {
        var21 = v17;
        objc_autoreleasePoolPop(v8);
        this->var21 = (URLProtocol *)var21;
        goto LABEL_33;
      }
    }
    else
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v15 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v16 = objc_msgSend(var9, "currentRequest");
        *(_DWORD *)buf = 138412290;
        v36 = v16;
        _os_log_impl(&dword_183ECA000, v15, OS_LOG_TYPE_DEFAULT, "Not using cached URLProtocol since AppSSOProtocol can handle request %@", buf, 0xCu);
      }
    }
  }
  p_var8 = &this->var8;
  v33 = 0u;
  v31 = 0u;
  v32 = 0u;
  v30 = 0u;
  v18 = -[__NSURLSessionLocal _protocolClassesForTask:]((uint64_t)var16, var9);
  v19 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v30, v34, 16);
  if (!v19)
  {
LABEL_30:
    objc_autoreleasePoolPop(v8);
    goto LABEL_31;
  }
  v20 = v19;
  v21 = *(_QWORD *)v31;
LABEL_20:
  v22 = 0;
  while (1)
  {
    if (*(_QWORD *)v31 != v21)
      objc_enumerationMutation(v18);
    v23 = *(void **)(*((_QWORD *)&v30 + 1) + 8 * v22);
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0
      && (objc_msgSend(v23, "isSubclassOfClass:", objc_opt_class(), p_var8) & 1) == 0)
    {
      break;
    }
    if ((objc_msgSend(v23, "canInitWithTask:", var9, p_var8) & 1) != 0)
      goto LABEL_32;
LABEL_28:
    if (v20 == ++v22)
    {
      v20 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v30, v34, 16);
      if (v20)
        goto LABEL_20;
      goto LABEL_30;
    }
  }
  if ((objc_msgSend(v23, "canInitWithRequest:", objc_msgSend(var9, "currentRequest")) & 1) == 0)
    goto LABEL_28;
LABEL_32:
  var21 = -[__NSURLSessionLocal _newURLProtocolForTask:client:protocolClass:]((uint64_t)var9, (uint64_t)p_var8, v23);
  objc_autoreleasePoolPop(v8);
  this->var21 = (URLProtocol *)var21;
  if (!var21)
    return var21 != 0;
LABEL_33:
  var28 = (char)this->var28;
  if ((var28 & 4) != 0)
  {
    *(_BYTE *)(var21 + 40) = 0;
    var28 = (char)this->var28;
  }
  *(_BYTE *)(var21 + 41) = var28 & 1;
  *(_BYTE *)(var21 + 43) = (*(_BYTE *)&this->var28 & 0x10) != 0;
  *(_BYTE *)(var21 + 44) = (*(_BYTE *)&this->var28 & 0x20) != 0;
  v25 = (*(_BYTE *)&this->var28 & 8) != 0 && !this->var29;
  *(_BYTE *)(var21 + 42) = v25;
  *(_BYTE *)(var21 + 45) = (*(_BYTE *)&this->var28 & 0x40) != 0;
  *(_WORD *)(var21 + 46) = *((_WORD *)&this->var28 + 1);
  return var21 != 0;
}

void sub_183F0E92C(_Unwind_Exception *a1)
{
  URLProtocol *v1;

  URLProtocol::~URLProtocol(v1);
  _Unwind_Resume(a1);
}

uint64_t HTTPProtocol::_instantiateProtocol(uint64_t a1, NSURLSessionTask *a2, URLProtocolClient *a3, int a4)
{
  uint64_t Instance;
  uint64_t v8;

  if (TCFObject<URLProtocol>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLProtocol>::Class(void)::sOnce, &__block_literal_global_210);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v8 = Instance + 16;
    bzero((void *)(Instance + 16), 0x388uLL);
  }
  else
  {
    v8 = 0;
  }
  bzero((void *)(v8 + 24), 0x368uLL);
  *(_OWORD *)(v8 + 156) = 0u;
  *(_OWORD *)(v8 + 128) = 0u;
  *(_OWORD *)(v8 + 144) = 0u;
  *(_QWORD *)v8 = &off_1E14E5A68;
  *(_QWORD *)(v8 + 8) = &unk_1E14E5D68;
  *(_QWORD *)(v8 + 16) = &unk_1E14E5D88;
  *(_QWORD *)(v8 + 112) = &unk_1E14E5DC8;
  *(_QWORD *)(v8 + 120) = &unk_1E14E5E70;
  *(_QWORD *)(v8 + 176) = &unk_1E14E5ED8;
  *(_QWORD *)(v8 + 184) = &unk_1E14E6010;
  *(_QWORD *)(v8 + 480) = 0;
  *(_OWORD *)(v8 + 328) = 0u;
  *(_QWORD *)(v8 + 592) = 0;
  *(_OWORD *)(v8 + 600) = 0u;
  *(_OWORD *)(v8 + 624) = 0u;
  *(_OWORD *)(v8 + 640) = 0u;
  *(_OWORD *)(v8 + 656) = 0u;
  *(_OWORD *)(v8 + 672) = 0u;
  *(_OWORD *)(v8 + 704) = 0u;
  *(_OWORD *)(v8 + 776) = 0u;
  *(_OWORD *)(v8 + 792) = 0u;
  *(_OWORD *)(v8 + 808) = 0u;
  *(_DWORD *)(v8 + 824) = 0;
  *(_QWORD *)(v8 + 848) = 0;
  *(_OWORD *)(v8 + 832) = 0u;
  *(_WORD *)(v8 + 856) = 0;
  *(_QWORD *)(v8 + 872) = 1;
  *(_QWORD *)(v8 + 896) = 0;
  if (HTTPProtocol::initialize(v8, a2, a3, a4))
    return v8 - 16;
  (*(void (**)(uint64_t))(*(_QWORD *)v8 + 64))(v8);
  CFRelease((CFTypeRef)(v8 - 16));
  return 0;
}

uint64_t HTTPProtocol::_instantiateProtocol(HTTPProtocol *this, NSURLSessionTask *a2, URLProtocolClient *a3, URLProtocolClient *a4, const void *a5)
{
  return HTTPProtocol::_instantiateProtocol((uint64_t)this, a2, a3, 0);
}

void URLConnectionLoader::scheduleTimeoutTimer(URLConnectionLoader *this)
{
  double var18;
  double var19;
  double v4;
  unint64_t v5;
  NSObject *var22;
  dispatch_time_t v7;
  uint64_t v8;

  var18 = this->var18;
  if (var18 > 0.0)
  {
    if (this->var20)
    {
      var19 = this->var19;
      var18 = var19 - CFAbsoluteTimeGetCurrent();
    }
    v4 = var18 * 1000000000.0;
    v5 = (uint64_t)v4;
    if ((uint64_t)v4 >= 1)
    {
      var22 = this->var22;
      if (var22)
      {
        v7 = dispatch_time(0, (uint64_t)v4);
        if (v5 <= 0x2540BE400)
          v8 = 0;
        else
          v8 = 1000000000;
        dispatch_source_set_timer(var22, v7, 0xFFFFFFFFFFFFFFFFLL, v8);
      }
    }
  }
}

void URLConnectionLoader::_loaderEvent_StartLoad(URLConnectionLoader *this, NSURLSessionTask *a2)
{
  NSURLSessionTask *var9;
  NSURLSession *var16;
  __CFDictionary *v6;
  double v7;
  const __CFDictionary *v8;
  double v9;
  unint64_t v10;
  const __CFBoolean *v11;
  int v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  HTTPMessage *v16;
  CFStringRef v17;
  unint64_t v18;
  const __CFBoolean *Value;
  const __CFURL *v20;
  const __CFString *v21;
  const __CFString *v22;
  int CanonicalString;
  id v24;
  const __CFString *v25;
  int ExactString;
  id v27;
  int v28;
  unint64_t v29;
  double v30;
  int v31;
  unsigned int v32;
  double v33;
  _QWORD v34[8];
  _BYTE buf[24];
  char v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (this->var17)
    goto LABEL_2;
  var16 = (NSURLSession *)this->var16;
  if (!var16 || !a2 || this->var4)
    goto LABEL_2;
  this->var17 = 1;
  if (var16 != -[NSURLSessionTask session](a2, "session")
    && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    v27 = this->var16;
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)&buf[4] = v27;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = -[NSURLSessionTask session](a2, "session");
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "session %p != %p", buf, 0x16u);
  }
  v6 = -[NSURLSessionTask _copySocketStreamProperties](a2, "_copySocketStreamProperties");
  v8 = v6;
  if (v6)
  {
    if (CFDictionaryGetValue(v6, &unk_1EDCFB868)
      || (Value = (const __CFBoolean *)CFDictionaryGetValue(v8, &unk_1EDCFBB08)) != 0 && CFBooleanGetValue(Value))
    {
      *((_BYTE *)&this->var28 + 2) = 1;
    }
    if (!entr_shouldtrace_delayInitStub(v9))
      goto LABEL_80;
    do
      v10 = __ldaxr(&gURLLoaderEnergyTraceIdentifier);
    while (__stlxr(v10 + 1, &gURLLoaderEnergyTraceIdentifier));
    this->var33 = v10;
    v11 = (const __CFBoolean *)CFDictionaryGetValue(v8, &unk_1EDCFBC58);
    if (v11 && CFBooleanGetValue(v11))
      v12 = 0;
    else
      v12 = 2;
    v25 = (const __CFString *)CFDictionaryGetValue(v8, &unk_1EDCFB478);
    if (!v25)
      goto LABEL_76;
    ExactString = _findExactString(v25, 2u);
    if (ExactString > 181726395)
    {
      if (ExactString > 183766244)
      {
        switch(ExactString)
        {
          case 183766245:
            v12 |= 0x200000u;
            break;
          case 184814838:
            v12 |= 0x400000u;
            break;
          case 185855239:
            v12 |= 0x100000u;
            break;
        }
        goto LABEL_76;
      }
      if (ExactString != 181726396)
      {
        if (ExactString == 182791376)
          v12 |= 0x600000u;
        goto LABEL_76;
      }
      v28 = 9437184;
    }
    else
    {
      if (ExactString <= 177638502)
      {
        if (ExactString == 175426624)
        {
          v12 |= 0x800000u;
        }
        else if (ExactString == 176467028)
        {
          v12 |= 0x300000u;
        }
        goto LABEL_76;
      }
      if (ExactString == 177638503)
      {
        v28 = 5242880;
      }
      else
      {
        if (ExactString != 179645591)
        {
          if (ExactString == 180604076)
            v12 |= 0x700000u;
          goto LABEL_76;
        }
        v28 = 10485760;
      }
    }
    v12 |= v28;
  }
  else
  {
    if (!entr_shouldtrace_delayInitStub(v7))
      goto LABEL_80;
    do
      v18 = __ldaxr(&gURLLoaderEnergyTraceIdentifier);
    while (__stlxr(v18 + 1, &gURLLoaderEnergyTraceIdentifier));
    v12 = 0;
    this->var33 = v18;
  }
LABEL_76:
  v29 = -[NSURLSessionTask _cachePolicy](a2, "_cachePolicy");
  if (v29 - 1 > 3)
    v31 = 196608;
  else
    v31 = dword_1841E3AC0[v29 - 1];
  v32 = v12 | v31;
  entr_act_begin_delayInitStub(v30);
  this->var34 = v32;
  this->var35 = 1;
LABEL_80:
  *((_BYTE *)&this->var28 + 3) = -[NSURLSessionTask _strictContentLength](a2, "_strictContentLength");
  -[NSURLSessionTask _timeoutInterval](a2, "_timeoutInterval");
  this->var18 = v33;
  if (v8)
    CFRelease(v8);
LABEL_2:
  if (!this->var4)
  {
    var9 = (NSURLSessionTask *)this->var9;
    if (var9)
    {
      if (var9 != a2 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = var9;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = a2;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "ftask %p != %p", buf, 0x16u);
      }
    }
    else
    {
      this->var9 = a2;
      this->var10 = -[NSURLSessionTask _metrics](a2, "_metrics");
    }
    if (nw_settings_get_signposts_enabled())
      kdebug_trace();
    if (nw_settings_get_signposts_enabled())
      kdebug_trace();
    v13 = (void *)objc_msgSend(this->var9, "currentRequest");
    if (v13)
    {
      ++gLoaderLoadsStarted;
      if ((objc_msgSend(this->var9, "_preconnect") & 1) != 0)
        goto LABEL_33;
      v14 = objc_msgSend(this->var9, "_cachePolicy");
      v15 = v14;
      if (v14 == 1 || v14 == 4)
        goto LABEL_33;
      v16 = *(HTTPMessage **)(objc_msgSend(v13, "_inner") + 56);
      if (v16)
      {
        v17 = HTTPMessage::copyHeaderFieldValue(v16, 0x1390B37Bu);
        if (v17)
        {
          CFRelease(v17);
LABEL_33:
          objc_msgSend(this->var9, "_cachePolicy");
          URLConnectionLoader::loadWithWhatToDo((uint64_t)this, v13, 0, 0, 0);
          return;
        }
      }
      v20 = (const __CFURL *)objc_msgSend(v13, "cfURL");
      if (v20)
      {
        v21 = CFURLCopyScheme(v20);
        v22 = v21;
        if (v21)
        {
          CanonicalString = _findCanonicalString(v21, 0xFu);
          CFRelease(v22);
          if (CanonicalString == 584097179 || CanonicalString == 582000021)
            goto LABEL_33;
        }
      }
      if (objc_msgSend(this->var9, "session"))
      {
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x2020000000;
        v36 = 0;
        v24 = this->var9;
        v34[0] = MEMORY[0x1E0C809B0];
        v34[1] = 3221225472;
        v34[2] = ___ZN19URLConnectionLoader22_loaderEvent_StartLoadEP16NSURLSessionTask_block_invoke;
        v34[3] = &unk_1E14FAF30;
        v34[4] = v13;
        v34[5] = buf;
        v34[6] = this;
        v34[7] = v15;
        objc_msgSend(v24, "_withXURLCache:", v34);
        if (!*(_BYTE *)(*(_QWORD *)&buf[8] + 24))
        {
          objc_msgSend(this->var9, "_cachePolicy");
          URLConnectionLoader::loadWithWhatToDo((uint64_t)this, v13, 0, 0, 0);
        }
        _Block_object_dispose(buf, 8);
      }
      else
      {
        URLConnectionLoader::loadWithWhatToDo((uint64_t)this, v13, 0, -999, 2);
      }
    }
  }
}

void sub_183F0F1F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFXURLCache *XURLCache::createNSXURLCache(XURLCache *this, NSURLSession *a2, NSURLSession *a3)
{
  CFTypeID v5;
  XURLCache *v6;
  CFXURLCache *v7;
  CFTypeRef v8;
  uint64_t v9;

  if (!this)
  {
    v7 = (CFXURLCache *)operator new();
    v8 = 0;
    *(_QWORD *)v7 = &off_1E14E5280;
    goto LABEL_8;
  }
  v5 = CFGetTypeID(this);
  if (v5 != CFURLCacheGetTypeID())
  {
    v9 = objc_opt_class();
    if (v9 == objc_opt_class())
    {
      v6 = (XURLCache *)-[XURLCache _CFURLCache](this, "_CFURLCache");
      if (v6)
        goto LABEL_4;
    }
    v7 = (CFXURLCache *)operator new();
    *(_QWORD *)v7 = &off_1E14E5280;
    v8 = CFRetain(this);
LABEL_8:
    *((_QWORD *)v7 + 1) = v8;
    return v7;
  }
  v6 = this;
LABEL_4:
  v7 = (CFXURLCache *)operator new();
  CFXURLCache::CFXURLCache(v7, v6, a2);
  return v7;
}

void sub_183F0F4B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x81C40803F642BLL);
  _Unwind_Resume(a1);
}

uint64_t CFURLCacheGetTypeID(void)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_2382;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = _URLCacheRegisterClass;
  if (_CFURLCacheClassRegistration != -1)
    dispatch_once(&_CFURLCacheClassRegistration, block);
  return kCFURLCacheTypeID;
}

void CFXURLCache::CFXURLCache(CFXURLCache *this, CFTypeRef cf, NSURLSession *a3)
{
  CFTypeID v6;
  CFTypeRef v7;
  uint8_t v8[16];

  *(_QWORD *)this = &off_1E14E4CA8;
  v6 = CFGetTypeID(cf);
  if (v6 != CFURLCacheGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v8 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "We should've protected against creating a CFXURLCache that isn't a true CFURLCache", v8, 2u);
    if (cf)
      goto LABEL_4;
LABEL_6:
    v7 = 0;
    goto LABEL_7;
  }
  if (!cf)
    goto LABEL_6;
LABEL_4:
  v7 = CFRetain(cf);
LABEL_7:
  *((_QWORD *)this + 1) = v7;
  *((_QWORD *)this + 2) = a3;
}

void CFXURLCache::~CFXURLCache(CFXURLCache *this)
{
  const void *v1;

  *(_QWORD *)this = &off_1E14E4CA8;
  *((_QWORD *)this + 2) = 0;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x186DB748CLL);
}

{
  const void *v1;

  *(_QWORD *)this = &off_1E14E4CA8;
  *((_QWORD *)this + 2) = 0;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
}

uint64_t _CFURLCacheGetMaxCacheableEntrySize(_QWORD *a1)
{
  _QWORD *v1;
  uint64_t TypeID;
  const char *v3;

  if (!a1)
    return 0;
  v1 = a1;
  TypeID = CFURLCacheGetTypeID();
  if (TypeID != CFGetTypeID(v1))
  {
    v3 = (const char *)_CFURLCacheGetMaxCacheableEntrySize::s;
    if (!_CFURLCacheGetMaxCacheableEntrySize::s)
    {
      v3 = sel_registerName("_CFURLCache");
      _CFURLCacheGetMaxCacheableEntrySize::s = (uint64_t)v3;
    }
    v1 = objc_msgSend(v1, v3);
    if (!v1)
      return 0;
  }
  if (*(_QWORD *)(v1[2] + 192) <= *(_QWORD *)(v1[2] + 184))
    return *(_QWORD *)(v1[2] + 184);
  return *(_QWORD *)(v1[2] + 192);
}

uint64_t ___ZN19URLConnectionLoader22_loaderEvent_StartLoadEP16NSURLSessionTask_block_invoke(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  const char *v6;
  void *v7;
  CFAbsoluteTime *Property;
  id v9;
  uint64_t v10;
  _QWORD v12[7];

  v3 = a1[6];
  *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 1;
  v4 = (void *)a1[4];
  v5 = a1[7];
  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  v7 = *(void **)(v3 + 72);
  if (v7)
  {
    Property = (CFAbsoluteTime *)objc_getProperty(v7, v6, 96, 1);
    if (Property)
      Property[20] = CFAbsoluteTimeGetCurrent();
  }
  v9 = v4;
  (*(void (**)(_QWORD))(**(_QWORD **)(v3 + 32) + 64))(*(_QWORD *)(v3 + 32));
  v10 = *(_QWORD *)(v3 + 64);
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 3221225472;
  v12[2] = ___ZN19URLConnectionLoader19initiateCacheLookupEP12NSURLRequestPK9XURLCache23NSURLRequestCachePolicy_block_invoke;
  v12[3] = &unk_1E14FAF80;
  v12[4] = v4;
  v12[5] = v3;
  v12[6] = v5;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a2 + 32))(a2, v10, 1, v12);
}

uint64_t CFXURLCache::getMaxCacheableEntrySize(CFXURLCache *this)
{
  return _CFURLCacheGetMaxCacheableEntrySize(*((_QWORD **)this + 1));
}

uint64_t std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError> *,SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void (*v3)(uint64_t *, uint64_t *);
  BOOL v4;
  int v5;
  _QWORD *v7;
  void (*v8)(uint64_t *, uint64_t *);
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v13;
  std::__shared_weak_count *v14;

  v1 = *(_QWORD *)(a1 + 24);
  v3 = *(void (**)(uint64_t *, uint64_t *))(v1 + 8);
  v2 = *(_QWORD *)(v1 + 16);
  if (v2)
    v4 = (*(_QWORD *)(v1 + 16) & 1 | (unint64_t)v3) == 0;
  else
    v4 = 1;
  v5 = v4;
  if (v3 == BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_initial && v5 != 0)
  {
    v7 = (_QWORD *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0)
      v8 = *(void (**)(uint64_t *, uint64_t *))(*v7
                                                       + BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_initial);
    else
      v8 = BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_initial;
    v13 = 0;
    v14 = 0;
    ((void (*)(_QWORD *, uint64_t *, _QWORD, _QWORD, _QWORD))v8)(v7, &v13, 0, 0, 0);
    v9 = v14;
    if (v14)
    {
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
  _Block_release(*(const void **)v1);
  return MEMORY[0x186DB748C](v1, 0x80C40D6874129);
}

void sub_183F0F9F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  unint64_t *p_shared_owners;
  unint64_t v12;

  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_emplace<CFNetworkTrust>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void CFNetworkTrust::~CFNetworkTrust(CFNetworkTrust *this)
{
  const void *v2;
  const void *v3;
  const void *v4;

  *(_QWORD *)this = &off_1E14E6B30;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 3);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 2);
  if (v4)
    CFRelease(v4);
  *(_QWORD *)this = &off_1E14E5838;
}

{
  CFNetworkTrust::~CFNetworkTrust(this);
  JUMPOUT(0x186DB748CLL);
}

void sub_183F0FA9C(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t URLProtocol::sendDidFinishLoading(URLProtocol *this)
{
  uint64_t result;
  uint64_t v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[5];
  _QWORD v12[6];

  result = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_1404, 1);
  if (result)
  {
    v3 = result;
    result = (*(uint64_t (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)result + 16))(result, "Response Complete", 0);
    if ((_DWORD)result)
    {
      v4 = *((id *)this + 11);
      (*(void (**)(uint64_t, const char *, id))(*(_QWORD *)v3 + 48))(v3, "Request", v4);

      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    }
  }
  v5 = *((_QWORD *)this + 12);
  if (v5)
  {
    v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v5 + 16))(*((_QWORD *)this + 12));
    v7 = (void *)MEMORY[0x186DB8C8C](v6);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 12) + 88))(*((_QWORD *)this + 12));
    objc_autoreleasePoolPop(v7);
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  }
  v8 = (_QWORD *)*((_QWORD *)this + 8);
  if (v8)
  {
    *((_QWORD *)this + 8) = 0;
    CFRetain((char *)this - 16);
    v9 = MEMORY[0x1E0C809B0];
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 3221225472;
    v11[2] = ___ZN11URLProtocol19invalidateThrottlerEv_block_invoke;
    v11[3] = &__block_descriptor_40_e5_v8__0l;
    v11[4] = this;
    (*(void (**)(_QWORD *))(*v8 + 40))(v8);
    v10 = v8[9];
    v12[0] = v9;
    v12[1] = 3221225472;
    v12[2] = ___ZN9Throttler10invalidateEU13block_pointerFvvE_block_invoke;
    v12[3] = &unk_1E14FDA90;
    v12[4] = v11;
    v12[5] = v8;
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v10 + 96))(v10, v12);
    return (*(uint64_t (**)(_QWORD *))(*v8 + 48))(v8);
  }
  return result;
}

void sub_183F0FC38(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void `non-virtual thunk to'URLConnectionLoader_Classic::protocolDidFinishLoading(URLConnectionLoader_Classic *this)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  _QWORD v5[5];
  _QWORD block[6];

  v2 = MEMORY[0x1E0C809B0];
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN27URLConnectionLoader_Classic24protocolDidFinishLoadingEv_block_invoke;
  v5[3] = &__block_descriptor_40_e5_v8__0l;
  v5[4] = (char *)this - 56;
  v3 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this - 3) + 64))(*((_QWORD *)this - 3));
  v4 = *((_QWORD *)this - 2);
  block[0] = v2;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v5;
  block[5] = v3;
  dispatch_async(v4, block);
}

void NWIOConnection::ipAddressWithPolicyId(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char a4@<W3>, CFStringRef *a5@<X8>)
{
  const __CFString *v6;
  CFStringRef Copy;
  CFTypeRef v8;
  _QWORD v9[7];
  char v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t (*v14)(uint64_t, uint64_t);
  void (*v15)(uint64_t);
  uint64_t v16;
  CFTypeRef cf;

  v11 = 0;
  v12 = &v11;
  v13 = 0x3812000000;
  v14 = __Block_byref_object_copy__3541;
  v15 = __Block_byref_object_dispose__3542;
  v16 = 0;
  cf = 0;
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___ZN14NWIOConnection21ipAddressWithPolicyIdEPU21objcproto10OS_nw_path8NSObjectPU25objcproto14OS_nw_endpointS0_b_block_invoke;
  v9[3] = &unk_1E14F7DA0;
  v9[4] = a3;
  v9[5] = a2;
  v10 = a4;
  v9[6] = &v11;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 336))(a1, v9);
  v6 = (const __CFString *)v12[6];
  if (v6)
    Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6);
  else
    Copy = 0;
  *a5 = Copy;
  _Block_object_dispose(&v11, 8);
  v8 = cf;
  cf = 0;
  if (v8)
    CFRelease(v8);
}

void sub_183F0FDE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,CFTypeRef cf)
{
  CFTypeRef v25;

  _Block_object_dispose(&a18, 8);
  v25 = cf;
  cf = 0;
  if (v25)
    CFRelease(v25);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14NWIOConnection21ipAddressWithPolicyIdEPU21objcproto10OS_nw_path8NSObjectPU25objcproto14OS_nw_endpointS0_b_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  char *v6;
  char *v7;
  int v8;
  __CFN_CoalescingDomainHolder *v9;
  NSObject *v10;
  char *v11;
  void *v12;
  const char *name;
  uint64_t interface_index;
  uint64_t type;
  uint64_t subtype;
  uint64_t v17;
  CFStringRef v18;
  uint64_t v19;
  const void *v20;
  _QWORD v22[2];
  void (*v23)(uint64_t);
  void *v24;
  char *v25;
  char out[48];
  unsigned __int8 uu[8];
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v6 = nw_endpoint_copy_address_string(*(nw_endpoint_t *)(a1 + 32));
  if (!v6)
    __assert_rtn("ipAddressWithPolicyId_block_invoke", "NWIOConnection.cpp", 1615, "address");
  v7 = v6;
  v22[0] = MEMORY[0x1E0C809B0];
  v22[1] = 3221225472;
  v23 = ___ZN14NWIOConnection21ipAddressWithPolicyIdEPU21objcproto10OS_nw_path8NSObjectPU25objcproto14OS_nw_endpointS0_b_block_invoke_2;
  v24 = &__block_descriptor_40_e5_v8__0l;
  v25 = v6;
  if (a3)
  {
    v8 = *(unsigned __int8 *)(a1 + 56);
    v9 = (__CFN_CoalescingDomainHolder *)objc_msgSend(a2, "objectForKeyedSubscript:", a3);
    if (!v9 && !v8)
    {
      v9 = objc_alloc_init(__CFN_CoalescingDomainHolder);
      objc_msgSend(a2, "setObject:forKeyedSubscript:", v9, a3);
    }
    if (v9)
    {
      if (v9->_pathPolicyManager)
      {
        v10 = nw_path_copy_interface();
        if (v10)
        {
          *(_QWORD *)uu = 0;
          v28 = 0;
          memset(out, 0, 37);
          if (nw_path_get_vpn_config_id())
          {
            v11 = out;
            uuid_unparse_upper(uu, out);
          }
          else
          {
            v11 = "0";
          }
          v12 = (void *)MEMORY[0x1E0CB3940];
          name = nw_interface_get_name(v10);
          interface_index = nw_path_get_interface_index();
          type = nw_interface_get_type(v10);
          subtype = nw_interface_get_subtype();
          v17 = objc_msgSend(v12, "stringWithFormat:", CFSTR("{%s}{%d}{%d}{%d}{%s}{%d}"), name, interface_index, type, subtype, v11, nw_path_get_policy_id());
          nw_release(v10);
          if (v17)
          {
            v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%s@%@"), v7, v17);
            v19 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
            v20 = *(const void **)(v19 + 48);
            *(_QWORD *)(v19 + 48) = v18;
            if (v20)
              CFRelease(v20);
          }
        }
      }
    }
  }
  return ((uint64_t (*)(_QWORD *))v23)(v22);
}

void sub_183F10034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void (*a18)(char *))
{
  a18(&a16);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection21ipAddressWithPolicyIdEPU21objcproto10OS_nw_path8NSObjectPU25objcproto14OS_nw_endpointS0_b_block_invoke_2(uint64_t a1)
{
  free(*(void **)(a1 + 32));
}

uint64_t NWIOConnection::withCoalescingConfigAndHostlessKey(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(a2 + 16))(a2, *(_QWORD *)(a1 + 664), *(_QWORD *)(a1 + 672));
}

uint64_t HTTPConnectionCacheEntry::EnqueuedRequest::linkWithTube(HTTPConnectionCacheEntry::EnqueuedRequest *this, Tube *a2)
{
  uint64_t v4;
  uint64_t result;

  v4 = *((_QWORD *)this + 9);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
    *((_QWORD *)this + 9) = 0;
  }
  if (a2)
  {
    *((_QWORD *)this + 9) = a2;
    (*(void (**)(Tube *))(*(_QWORD *)a2 + 40))(a2);
  }
  result = *((_QWORD *)this + 3);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 56))(result, *((_QWORD *)this + 9));
  return result;
}

void BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_normal(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v2 = *a1;
  v3 = (std::__shared_weak_count *)a2[1];
  v9 = *a2;
  v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v9);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_183F10168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN4Tube24postConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0_U13block_pointerFvvE_block_invoke(uint64_t a1, uint64_t *a2, int a3, CFIndex a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  NSObject *v17;
  unint64_t *v18;
  unint64_t v19;
  NSObject *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  TransportConnection *v35;
  const void *v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  const char *v41;
  int v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  uint8_t buf[4];
  _BYTE v48[14];
  uint64_t v49;
  CFStreamError v50;

  v49 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 40);
  if ((*(_DWORD *)(v6 + 220) & 0xFFFFFFFE) == 0xA)
    goto LABEL_62;
  v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v6 + 112) + 80))(*(_QWORD *)(v6 + 112));
  if (!v11)
  {
    v14 = 0;
    v45 = 0;
    v46 = 0;
    if ((_DWORD)a5)
    {
LABEL_14:
      std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v6 + 264), *a2, a2[1]);
      v50.domain = a4;
      *(_QWORD *)&v50.error = a5;
      Tube::_onqueue_errorHandler((Tube *)v6, v50);
      goto LABEL_15;
    }
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v6 + 264), *a2, a2[1]);
    if (!a3)
      goto LABEL_62;
    v14 = 0;
LABEL_43:
    if (*(_DWORD *)(v6 + 220) == 6)
    {
      if (*(_QWORD *)(v6 + 248))
      {
        v41 = "!fSSLDistNames";
        v42 = 565;
      }
      else if (*(_QWORD *)(v6 + 304))
      {
        v41 = "!fSSLDistNamesCompletion";
        v42 = 566;
      }
      else if (*(_QWORD *)(v6 + 256))
      {
        v41 = "!fSSLTrust";
        v42 = 567;
      }
      else if (*(_QWORD *)(v6 + 312))
      {
        v41 = "!fSSLTrustCompletion";
        v42 = 568;
      }
      else
      {
        v35 = *(TransportConnection **)(v6 + 136);
        if (v35)
        {
          TransportConnection::rstConnectionEstablishmentDelegate(v35);
          (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v6 + 136) + 152))(*(_QWORD *)(v6 + 136), 0);
          *(_DWORD *)(v6 + 184) = 0;
          *(_BYTE *)(v6 + 188) = 0;
          if (*(_DWORD *)(v6 + 220) != 10)
            *(_DWORD *)(v6 + 220) = 1;
          v36 = *(const void **)(v6 + 232);
          *(_QWORD *)(v6 + 232) = 0;
          if (v36)
            CFRelease(v36);
          GlueTubeManager::createTransportConnection((std::__shared_weak_count **)buf, *(NSObject **)(v6 + 160));
          std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v6 + 136, (__int128 *)buf);
          v37 = *(std::__shared_weak_count **)&v48[4];
          if (*(_QWORD *)&v48[4])
          {
            v38 = (unint64_t *)(*(_QWORD *)&v48[4] + 8);
            do
              v39 = __ldaxr(v38);
            while (__stlxr(v39 - 1, v38));
            if (!v39)
            {
              ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
              std::__shared_weak_count::__release_weak(v37);
            }
          }
          Tube::_onqueue_connect((Tube *)v6);
LABEL_15:
          if (!v14)
            goto LABEL_62;
          goto LABEL_16;
        }
        v41 = "fConnection";
        v42 = 574;
      }
    }
    else
    {
      v41 = "fState == kTubeStatePostConnectConfiguration";
      v42 = 564;
    }
    __assert_rtn("_onqueue_resetAndReconnect", "Tube.cpp", v42, v41);
  }
  v12 = v11;
  v13 = *(_QWORD *)(v11 + 632);
  v14 = *(std::__shared_weak_count **)(v11 + 640);
  v45 = v13;
  v46 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  if ((_DWORD)a5)
  {
    if (v13)
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v17 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)v48 = a4;
        *(_WORD *)&v48[8] = 1024;
        *(_DWORD *)&v48[10] = a5;
        _os_log_error_impl(&dword_183ECA000, v17, OS_LOG_TYPE_ERROR, "Sending terminal establishment proxyError[%ld:%d]", buf, 0x12u);
      }
      (*(void (**)(uint64_t, CFIndex, uint64_t))(*(_QWORD *)v13 + 48))(v13, a4, a5);
    }
    goto LABEL_14;
  }
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v6 + 264), *a2, a2[1]);
  if ((a3 & 1) != 0)
    goto LABEL_43;
  if (!v13)
  {
    objc_msgSend(*(id *)(v12 - 96), "set_proxyHandshakePending:", 0);
    goto LABEL_15;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v20 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v21 = *(_QWORD *)(v6 + 136);
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)v48 = v21;
    _os_log_impl(&dword_183ECA000, v20, OS_LOG_TYPE_DEFAULT, "Tube handing off connection %p to terminal delegate", buf, 0xCu);
  }
  v22 = *(std::__shared_weak_count **)(v6 + 144);
  v43 = *(_QWORD *)(v6 + 136);
  v44 = v22;
  if (v22)
  {
    v23 = (unint64_t *)&v22->__shared_owners_;
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v13 + 80))(v13, &v43);
  v25 = v44;
  if (v44)
  {
    v26 = (unint64_t *)&v44->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  v28 = *(_QWORD *)(v6 + 136);
  v29 = v45;
  v30 = v46;
  if (v46)
  {
    v31 = (unint64_t *)&v46->__shared_owners_;
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v28 + 144), v29, (uint64_t)v30);
    v33 = (unint64_t *)&v30->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  else
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v28 + 144), v45, 0);
  }
  *(_BYTE *)(v6 + 296) = 1;
  v14 = v46;
  if (v46)
  {
LABEL_16:
    v18 = (unint64_t *)&v14->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
LABEL_62:
  (*(void (**)(_QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 48))(v6);
}

void sub_183F10654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection24_handleEvent_ReadyFinishEv_block_invoke(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  int v7;
  IOPMAssertionID v8;
  IOReturn v9;
  NSObject *v10;
  uint64_t v11;
  int v12;
  unsigned __int8 *v13;
  int v14;
  void *v15;
  uint64_t v16;
  int v17;
  unsigned __int8 *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  uint64_t v25;
  int v26;
  uint8_t buf[4];
  uint64_t v28;
  __int16 v29;
  int v30;
  __int16 v31;
  IOReturn v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    v3 = a1[4];
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      v6 = a1[5];
      if (v6)
      {
        v7 = *(_WORD *)(v3 + 248) & 0xFFF7 | (*(unsigned __int8 *)(v3 + 250) << 16);
        *(_WORD *)(v3 + 248) &= ~8u;
        *(_BYTE *)(v3 + 250) = BYTE2(v7);
        v8 = *(_DWORD *)(v3 + 576);
        if (v8)
        {
          v9 = IOPMAssertionRelease(v8);
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v10 = CFNLog::logger;
          if (v9)
          {
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
            {
              v11 = *(_QWORD *)(v3 + 288);
              v12 = *(_DWORD *)(v3 + 576);
              *(_DWORD *)buf = 134218496;
              v28 = v11;
              v29 = 1024;
              v30 = v12;
              v31 = 1024;
              v32 = v9;
              _os_log_error_impl(&dword_183ECA000, v10, OS_LOG_TYPE_ERROR, "Connection %llu: failed to release assertion(%d), result(%d)", buf, 0x18u);
            }
          }
          else if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
          {
            v25 = *(_QWORD *)(v3 + 288);
            v26 = *(_DWORD *)(v3 + 576);
            *(_DWORD *)buf = 134218240;
            v28 = v25;
            v29 = 1024;
            v30 = v26;
            _os_log_debug_impl(&dword_183ECA000, v10, OS_LOG_TYPE_DEBUG, "Connection %llu: successfully released assertion(%d)", buf, 0x12u);
          }
          *(_DWORD *)(v3 + 576) = 0;
        }
        if ((*(_WORD *)(v6 + 248) & 0x60) != 0 || (*(_DWORD *)(v6 + 136) - 5) <= 2)
        {
          v13 = *(unsigned __int8 **)(v3 + 400);
          if (v13)
          {
            v14 = v13[40];
            v13[40] = 0;
            if (v14)
              TLSCallbackQueue::_invokeNextCallback((TLSCallbackQueue *)v13);
          }
        }
        else
        {
          if (*(_QWORD *)(v3 + 328))
          {
            v15 = (void *)network_proxy_create_from_parameters();
            v16 = operator new();
            NetworkProxyConfiguration::NetworkProxyConfiguration(v16, v15);
            if (v15 && (network_proxy_is_transparent() & 1) == 0)
            {
              v17 = *(unsigned __int16 *)(v3 + 248);
              *(_BYTE *)(v3 + 250) = (v17 | (*(unsigned __int8 *)(v3 + 250) << 16) | 0x10000u) >> 16;
              *(_WORD *)(v3 + 248) = v17;
            }
            if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v16 + 16))(v16))
              *(_WORD *)(v3 + 248) |= 0x8000u;
            if (v15)
              nw_release(v15);
          }
          else
          {
            v16 = 0;
          }
          v18 = *(unsigned __int8 **)(v3 + 400);
          if (v18)
          {
            v19 = v18[40];
            v18[40] = 0;
            if (v19)
              TLSCallbackQueue::_invokeNextCallback((TLSCallbackQueue *)v18);
          }
          v20 = *(unsigned __int16 *)(v3 + 248) | (*(unsigned __int8 *)(v3 + 250) << 16);
          if ((~v20 & 0x18000) == 0
            && (*(_WORD *)(v3 + 248) & 0x200) != 0
            && v16
            && (v21 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 40))(v16),
                LOWORD(v20) = *(_WORD *)(v3 + 248),
                v21 == 3))
          {
            v22 = *(_WORD *)(v3 + 248) & 0xF7FF | (*(unsigned __int8 *)(v3 + 250) << 16);
            *(_WORD *)(v3 + 248) &= ~0x800u;
            *(_BYTE *)(v3 + 250) = BYTE2(v22);
            NWIOConnection::_startTLS((NWIOConnection *)v3);
          }
          else
          {
            if ((v20 & 0xA00) == 0x200)
            {
              NWIOConnection::_startTLS((NWIOConnection *)v3);
            }
            else
            {
              if ((v20 & 0x800) != 0)
                NWIOConnection::_tlsProcessHandshakeComplete((NWIOConnection *)v3);
              NWIOConnection::_completeEndpointSetup((NWIOConnection *)v3);
            }
            if (!v16)
              goto LABEL_42;
          }
          (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
        }
      }
LABEL_42:
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v24 = __ldaxr(p_shared_owners);
      while (__stlxr(v24 - 1, p_shared_owners));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
}

void sub_183F10A18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  void *v10;

  MEMORY[0x186DB748C](v9, 0x10A1C4084265165);
  if (v10)
    nw_release(v10);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL NetworkProxyConfiguration::proxyIsConfigured(NetworkProxyConfiguration *this)
{
  return *((_QWORD *)this + 1) != 0;
}

uint64_t NetworkProxyConfiguration::NetworkProxyConfiguration(uint64_t a1, void *obj)
{
  _QWORD *v3;
  void *v4;
  _QWORD *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  int type;
  int v10;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  __int128 v15;

  *(_QWORD *)a1 = &off_1E14ED4A8;
  *(_QWORD *)(a1 + 8) = 0;
  v3 = (_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  if (obj)
  {
    v4 = nw_retain(obj);
    *(_QWORD *)&v15 = v4;
    v5 = (_QWORD *)operator new();
    *v5 = &off_1E14F1C88;
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = v4;
    v5[4] = MEMORY[0x1E0C84910];
    *((_QWORD *)&v15 + 1) = v5;
  }
  else
  {
    v15 = 0uLL;
  }
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v3, &v15);
  v6 = (std::__shared_weak_count *)*((_QWORD *)&v15 + 1);
  if (*((_QWORD *)&v15 + 1))
  {
    v7 = (unint64_t *)(*((_QWORD *)&v15 + 1) + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  if (*v3)
  {
    type = network_proxy_get_type();
    switch(type)
    {
      case 1:
        v10 = 4;
        goto LABEL_16;
      case 2:
        v10 = 2;
        goto LABEL_16;
      case 3:
        v10 = 3;
LABEL_16:
        *(_DWORD *)(a1 + 24) = v10;
        return a1;
    }
    v15 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v3, &v15);
    v12 = (std::__shared_weak_count *)*((_QWORD *)&v15 + 1);
    if (*((_QWORD *)&v15 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v15 + 1) + 8);
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }
  return a1;
}

void sub_183F10C04(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void NetworkProxyConfiguration::~NetworkProxyConfiguration(NetworkProxyConfiguration *this)
{
  *(_QWORD *)this = &off_1E14ED4A8;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
  *(_QWORD *)this = &off_1E14E5838;
  JUMPOUT(0x186DB748CLL);
}

{
  *(_QWORD *)this = &off_1E14ED4A8;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
  *(_QWORD *)this = &off_1E14E5838;
}

NWIOConnection *NWIOConnection::_completeEndpointSetup(NWIOConnection *this)
{
  if (*((int *)this + 34) <= 3)
  {
    *((_DWORD *)this + 34) = 4;
    return (NWIOConnection *)NWIOConnection::_signalEstablished(this);
  }
  return this;
}

uint64_t HTTPConnectionCacheEntry::ConnectionArray::countWithAuthentication(HTTPConnectionCacheEntry::ConnectionArray *this, AuthenticationState *a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  unint64_t *v10;
  unint64_t v11;
  AuthenticationState *v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  _BOOL4 v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v22;

  v2 = *((_QWORD *)this + 2) - *((_QWORD *)this + 1);
  if (v2 < 1)
    return 0;
  v5 = 0;
  v6 = 0;
  v7 = (unint64_t)v2 >> 4;
  if (v7 <= 1)
    v8 = 1;
  else
    v8 = v7;
  do
  {
    v9 = *(_OWORD *)(*((_QWORD *)this + 1) + 16 * v5);
    v22 = (std::__shared_weak_count *)*((_QWORD *)&v9 + 1);
    if (*((_QWORD *)&v9 + 1))
    {
      v10 = (unint64_t *)(*((_QWORD *)&v9 + 1) + 8);
      do
        v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }
    v12 = *(AuthenticationState **)(v9 + 176);
    v13 = *(std::__shared_weak_count **)(v9 + 184);
    if (v13)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        v15 = __ldxr(p_shared_owners);
      while (__stxr(v15 + 1, p_shared_owners));
    }
    v16 = AuthenticationState::addsConnectionAuth(v12, a2);
    if (v13)
    {
      v17 = (unint64_t *)&v13->__shared_owners_;
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    if (v22)
    {
      v19 = (unint64_t *)&v22->__shared_owners_;
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    v6 += !v16;
    ++v5;
  }
  while (v5 != v8);
  return v6;
}

void sub_183F10DE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN12XTubeManager25getPendingTubeForProtocolEP25MetaConnectionCacheClientPK22HTTPConnectionCacheKeyPK17CoreSchedulingSet_block_invoke(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const __CFArray *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[6];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  CFRange v15;

  v4 = a1[5];
  v5 = a1[6];
  v6 = *(_QWORD *)(a2 + 32);
  if (!v6)
    goto LABEL_3;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2020000000;
  v14 = 0;
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = ___ZN11TubeManager32getPendingTubeForProtocolWithKeyEP25MetaConnectionCacheClientPK22HTTPConnectionCacheKey_block_invoke;
  v10[3] = &unk_1E14F9188;
  v10[4] = &v11;
  v10[5] = v4;
  v7 = *(const __CFArray **)(v6 + 136);
  v15.length = CFArrayGetCount(v7);
  v15.location = 0;
  CFArrayApplyFunction(v7, v15, (CFArrayApplierFunction)RetainableTypedArray<BaseAwaitingTube *>::_invoke, v10);
  v8 = v12[3];
  _Block_object_dispose(&v11, 8);
  if (!v8)
  {
LABEL_3:
    v9 = *(_QWORD *)(a2 + 40);
    if (v9)
      v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 80))(v9, v4, v5);
    else
      v8 = 0;
  }
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v8;
}

void sub_183F10F00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<Throttler *,Deleter_release<Throttler>,std::allocator<Throttler>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

void std::__shared_ptr_pointer<HTTPRequestMessage *,Deleter_release<HTTPRequestMessage>,std::allocator<HTTPRequestMessage>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
    CFRelease((CFTypeRef)(v1 - 16));
}

void sub_183F11B1C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183F12744(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_183F12CCC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183F12E38(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void HTTPProtocol::endEncountered(HTTPProtocol *this)
{
  int v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  void *v9;
  uint64_t v10;
  CFIndex ResponseStatusCode;
  void *v12;
  const __CFString *v13;
  const __CFString *v14;
  const char *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  CFTypeRef v21;
  void *v22;
  CFAbsoluteTime *Property;
  CFAbsoluteTime *v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint8_t buf[4];
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  uint64_t v36;
  __int16 v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v1 = *((_DWORD *)this + 48);
  if ((v1 & 4) != 0)
    return;
  *((_WORD *)this + 98) = *((_WORD *)this + 98);
  *((_DWORD *)this + 48) = v1 | 0x80;
  HTTPProtocol::checkAndSendDidReceiveResponse(this);
  v3 = *((_QWORD *)this + 27);
  if (v3)
  {
    if (!CFURLDataDecoderIsFinishedDecoding(v3))
    {
      HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFC08);
      HTTPProtocol::cleanupStreams(this);
      return;
    }
    v4 = *((_QWORD *)this + 66);
    v5 = objc_msgSend(*((id *)this + 26), "_inner");
    *(_QWORD *)(v5 + 32) = v4;
    v6 = *(_QWORD *)(v5 + 88);
    if (v6)
    {
      *(_WORD *)(v6 + 297) |= 0x100u;
      *(_WORD *)(*(_QWORD *)(v5 + 88) + 297) |= 0x2000u;
    }
  }
  if (!*((_BYTE *)this + 47))
    goto LABEL_21;
  v7 = *((_QWORD *)this + 64);
  if (v7 == -1)
    goto LABEL_21;
  if (v7 == *((_QWORD *)this + 65))
    goto LABEL_21;
  v8 = *((_DWORD *)this + 50);
  if (v8 <= 6 && ((1 << v8) & 0x68) != 0 && v7 == *((_QWORD *)this + 66))
    goto LABEL_21;
  v9 = (void *)*((_QWORD *)this + 26);
  if (!v9)
    goto LABEL_21;
  v10 = *(_QWORD *)(objc_msgSend(v9, "_inner") + 88);
  if (!v10)
    goto LABEL_21;
  ResponseStatusCode = CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)(v10 - 16));
  if (ResponseStatusCode != 206 && ResponseStatusCode != 200)
    goto LABEL_21;
  v12 = (void *)*((_QWORD *)this + 11);
  if (!v12)
    goto LABEL_21;
  v13 = (const __CFString *)CFURLRequestCopyHTTPRequestMethod(v12);
  if (!v13)
    goto LABEL_21;
  v14 = v13;
  if (CFStringCompare(v13, CFSTR("GET"), 1uLL) && CFStringCompare(v14, (CFStringRef)&unk_1EDCFE1C0, 1uLL))
  {
    CFRelease(v14);
LABEL_21:
    HTTPProtocol::cleanupStreams(this);
    v16 = (void *)*((_QWORD *)this + 26);
    if (v16)
    {
      v17 = *(_QWORD *)(objc_msgSend(v16, "_inner") + 88);
      v18 = v17 - 16;
      if (!v17)
        v18 = 0;
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      {
        v30 = v18;
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        v18 = v30;
      }
      v19 = v18 + 16;
      if (!v17)
        v19 = 0;
      v20 = *(const void **)(v19 + 112);
      if (v20)
        v21 = CFRetain(v20);
      else
        v21 = 0;
      objc_msgSend(*((id *)this + 10), "set_trailers:", v21);
      if (v21)
        CFRelease(v21);
    }
    v22 = (void *)*((_QWORD *)this + 104);
    if (v22)
    {
      Property = (CFAbsoluteTime *)objc_getProperty(v22, v15, 96, 1);
      if (Property)
      {
        v24 = Property;
        Property[25] = CFAbsoluteTimeGetCurrent();
        *((_OWORD *)v24 + 2) = *((_OWORD *)v24 + 8);
      }
    }
    URLProtocol::sendDidFinishLoading((URLProtocol *)this);
    return;
  }
  CFRelease(v14);
  HTTPProtocol::cleanupStreams(this);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v25 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    v26 = *((_QWORD *)this + 99);
    v27 = *((_QWORD *)this + 64);
    v28 = *((_QWORD *)this + 65);
    v29 = *((_QWORD *)this + 66);
    *(_DWORD *)buf = 138544130;
    v32 = v26;
    v33 = 2048;
    v34 = v27;
    v35 = 2048;
    v36 = v28;
    v37 = 2048;
    v38 = v29;
    _os_log_error_impl(&dword_183ECA000, v25, OS_LOG_TYPE_ERROR, "%{public}@ failed strict content length check - expected: %lld, received: %lld, received (uncompressed): %lld ", buf, 0x2Au);
  }
  HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFC13);
}

void sub_183F13A90(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void HTTPProtocol::cleanupStreams(HTTPProtocol *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  const void *v9;
  __int128 v10;

  HTTPProtocol::destroyReadStream(this);
  v2 = (const void *)*((_QWORD *)this + 27);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 27) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 39);
  if (v3)
  {
    *((_QWORD *)this + 39) = 0;
    CFRelease(v3);
    *((_QWORD *)this + 40) = 0;
  }
  *((_QWORD *)this + 41) = 0;
  v4 = (const void *)*((_QWORD *)this + 42);
  if (v4)
  {
    *((_QWORD *)this + 42) = 0;
    CFRelease(v4);
    *((_QWORD *)this + 43) = 0;
  }
  v5 = (const void *)*((_QWORD *)this + 44);
  *((_QWORD *)this + 44) = 0;
  if (v5)
    CFRelease(v5);
  v10 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 776, &v10);
  v6 = (std::__shared_weak_count *)*((_QWORD *)&v10 + 1);
  if (*((_QWORD *)&v10 + 1))
  {
    v7 = (unint64_t *)(*((_QWORD *)&v10 + 1) + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  v9 = (const void *)*((_QWORD *)this + 37);
  if (v9)
  {
    CFRelease(v9);
    *((_QWORD *)this + 37) = 0;
  }
}

void HTTPProtocol::destroyReadStream(HTTPProtocol *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const __CFAllocator *v5;
  CFNumberRef v6;
  uint64_t v7;
  uint64_t v8;
  const __CFAllocator *v9;
  CFNumberRef v10;
  void *v11;
  const void *v12;
  uint64_t v13;
  uint64_t v14;
  const __CFAllocator *v15;
  uint64_t v16;
  CFStringRef v17;
  CFStringRef v18;
  uint64_t v19;
  CFStringRef v20;
  CFStringRef v21;
  _QWORD *v22;
  _QWORD *v23;
  CFTypeID v24;
  TransportConnection *v25;
  std::__shared_weak_count *v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  const void *v31;
  void (**v32)(_QWORD, _QWORD, _QWORD);
  const void *v33;
  void (**v34)(_QWORD, _QWORD, _QWORD);
  void (**valuePtr)(AutoString *__hidden);
  CFStringRef v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 34);
  if (v2)
  {
    *((_QWORD *)this + 71) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2);
    *((_QWORD *)this + 72) = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 34) + 104))(*((_QWORD *)this + 34));
    v3 = *((_QWORD *)this + 64);
    if (v3 != -1)
    {
      v4 = v3 - *((_QWORD *)this + 65);
      if (v4 >= 1)
      {
        valuePtr = (void (**)(AutoString *__hidden))v4;
        v5 = CFGetAllocator((char *)this - 16);
        v6 = CFNumberCreate(v5, kCFNumberSInt64Type, &valuePtr);
        (*(void (**)(_QWORD, uint64_t, CFNumberRef))(**((_QWORD **)this + 34) + 40))(*((_QWORD *)this + 34), 9, v6);
        if (v6)
          CFRelease(v6);
      }
    }
    v7 = *((_QWORD *)this + 7);
    if (v7 != -1)
    {
      v8 = v7 - *((_QWORD *)this + 6);
      if (v8 >= 1)
      {
        valuePtr = (void (**)(AutoString *__hidden))v8;
        v9 = CFGetAllocator((char *)this - 16);
        v10 = CFNumberCreate(v9, kCFNumberSInt64Type, &valuePtr);
        (*(void (**)(_QWORD, uint64_t, CFNumberRef))(**((_QWORD **)this + 34) + 40))(*((_QWORD *)this + 34), 11, v10);
        *((_QWORD *)this + 7) = *((_QWORD *)this + 71);
        if (v10)
          CFRelease(v10);
      }
    }
    v11 = (void *)*((_QWORD *)this + 10);
    if (v11)
    {
      v12 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 34) + 32))(*((_QWORD *)this + 34), 29);
      objc_msgSend(v11, "set_TCPConnectionMetadata:", v12);
      if (v12)
        CFRelease(v12);
      objc_msgSend(v11, "_releasePreventIdleSleepAssertionIfAppropriate");
    }
    v13 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_86, 1);
    v14 = v13;
    if (v13
      && (*(unsigned int (**)(uint64_t, const char *, HTTPProtocol *))(*(_QWORD *)v13 + 24))(v13, "destroyReadStream", this))
    {
      (*(void (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v14 + 48))(v14, "Request", *((_QWORD *)this + 11));
      v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v16 = *((_QWORD *)this + 71);
      valuePtr = &off_1E14E4818;
      v17 = CFStringCreateWithCString(v15, "sent", 0x8000100u);
      v37 = 0;
      v38 = 0;
      v36 = v17;
      v18 = CFStringCreateWithFormat(v15, 0, CFSTR("%ld"), v16);
      (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(_QWORD *)v14 + 64))(v14, v36, v18);
      if (v18)
        CFRelease(v18);
      AutoString::~AutoString((AutoString *)&valuePtr);
      v19 = *((_QWORD *)this + 72);
      valuePtr = &off_1E14E4818;
      v20 = CFStringCreateWithCString(v15, "received", 0x8000100u);
      v37 = 0;
      v38 = 0;
      v36 = v20;
      v21 = CFStringCreateWithFormat(v15, 0, CFSTR("%ld"), v19);
      (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(_QWORD *)v14 + 64))(v14, v36, v21);
      if (v21)
        CFRelease(v21);
      AutoString::~AutoString((AutoString *)&valuePtr);
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
    }
    v22 = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 34) + 32))(*((_QWORD *)this + 34), 26);
    v23 = v22;
    if (v22)
    {
      v24 = CFGetTypeID(v22);
      if (TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::sOnce != -1)
        dispatch_once(&TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::sOnce, &__block_literal_global_211_7114);
      if (v24 == *(_QWORD *)(TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::clazz + 96))
      {
        v25 = (TransportConnection *)v23[3];
        v26 = (std::__shared_weak_count *)v23[4];
        if (v26)
        {
          p_shared_owners = (unint64_t *)&v26->__shared_owners_;
          do
            v28 = __ldxr(p_shared_owners);
          while (__stxr(v28 + 1, p_shared_owners));
          TransportConnection::rstConnectionEstablishmentDelegate(v25);
          do
            v29 = __ldaxr(p_shared_owners);
          while (__stlxr(v29 - 1, p_shared_owners));
          if (!v29)
          {
            ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
            std::__shared_weak_count::__release_weak(v26);
          }
        }
        else
        {
          TransportConnection::rstConnectionEstablishmentDelegate(v25);
        }
      }
      else
      {
        if (TCFObject<SocketStream>::Class(void)::sOnce != -1)
          dispatch_once(&TCFObject<SocketStream>::Class(void)::sOnce, &__block_literal_global_212);
        (*(void (**)(_QWORD *, _QWORD))(v23[2] + 176))(v23 + 2, 0);
      }
      CFRelease(v23);
    }
    (*(void (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)this + 34) + 40))(*((_QWORD *)this + 34), 12, 0);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 34) + 64))(*((_QWORD *)this + 34));
    (*(void (**)(_QWORD))(**((_QWORD **)this + 34) + 24))(*((_QWORD *)this + 34));
    *((_QWORD *)this + 34) = 0;
  }
  v30 = *((_QWORD *)this + 111);
  if (v30)
    (*(void (**)(uint64_t, char *))(*(_QWORD *)v30 + 72))(v30, (char *)this + 176);
  v31 = (const void *)*((_QWORD *)this + 51);
  *((_QWORD *)this + 51) = 0;
  if (v31)
    CFRelease(v31);
  v32 = (void (**)(_QWORD, _QWORD, _QWORD))*((_QWORD *)this + 52);
  if (v32)
  {
    *((_QWORD *)this + 52) = 0;
    v32[2](v32, 0, 1);
    _Block_release(v32);
  }
  v33 = (const void *)*((_QWORD *)this + 53);
  *((_QWORD *)this + 53) = 0;
  if (v33)
    CFRelease(v33);
  v34 = (void (**)(_QWORD, _QWORD, _QWORD))*((_QWORD *)this + 54);
  if (v34)
  {
    *((_QWORD *)this + 54) = 0;
    v34[2](v34, 0, 1);
    _Block_release(v34);
  }
  *((_DWORD *)this + 48) &= ~1u;
}

void sub_183F14038(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  const void *v11;

  if (v11)
    CFRelease(v11);
  _Unwind_Resume(exception_object);
}

void CFXCookieStorage::~CFXCookieStorage(id *this)
{
  uint64_t v2;

  CFXCookieStorage::~CFXCookieStorage(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  id v2;

  *this = off_1E14E8010;
  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
  {

  }
  else
  {
    v2 = this[3];
    if (v2)
      CFRelease(v2);
  }
}

void CFXCookieStorage::CFXCookieStorage(CFXCookieStorage *this, void *cf)
{
  uint64_t v2;
  CFTypeRef v5;

  v2 = *MEMORY[0x1E0C9AE00];
  *(_QWORD *)this = off_1E14EF578;
  *((_QWORD *)this + 1) = v2;
  *((_DWORD *)this + 4) = 1;
  if ((((unint64_t)this + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)this = off_1E14E8010;
  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
  {
    *((_QWORD *)this + 4) = cf;
  }
  else
  {
    if (cf)
      v5 = CFRetain(cf);
    else
      v5 = 0;
    *((_QWORD *)this + 3) = v5;
  }
}

void XCookieStorage::createNSXCookieStorage(XCookieStorage *this, const void *a2)
{
  const __CFAllocator *v3;
  NSXCookieStorage *v4;
  void *v5;
  _OWORD *v6;

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
  {
    v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
LABEL_5:
    v4 = (NSXCookieStorage *)CFAllocatorAllocate(v3, 32, 0);
    *(_OWORD *)v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    NSXCookieStorage::NSXCookieStorage(v4, this);
    return;
  }
  v5 = (void *)-[XCookieStorage _cookieStorage](this, "_cookieStorage");
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (!v5)
    goto LABEL_5;
  v6 = CFAllocatorAllocate(v3, 40, 0);
  *v6 = 0u;
  v6[1] = 0u;
  *((_QWORD *)v6 + 4) = 0;
  CFXCookieStorage::CFXCookieStorage((CFXCookieStorage *)v6, v5);
}

uint64_t HTTP2Connection::_onqueue_performWrite(HTTP2Connection *this)
{
  unint64_t v2;
  NSObject *v3;
  int64_t v4;
  NSObject *v5;
  dispatch_data_t concat;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  const char *v13;
  int v14;
  const char *v15;
  const char *v16;
  void *buffer;
  _QWORD v18[2];
  uint64_t (*v19)(uint64_t);
  void *v20;
  HTTP2Connection *v21;
  size_t size_ptr;
  void *buffer_ptr[2];

  buffer_ptr[1] = *(void **)MEMORY[0x1E0C80C00];
  *((_BYTE *)this + 104) = 1;
  v18[0] = MEMORY[0x1E0C809B0];
  v18[1] = 3221225472;
  v19 = ___ZN15HTTP2Connection21_onqueue_performWriteEv_block_invoke;
  v20 = &__block_descriptor_40_e5_v8__0l;
  v21 = this;
  if (*((_QWORD *)this + 18) | *((unsigned int *)this + 38))
  {
    *((_DWORD *)this + 44) = 4;
    HTTP2Connection::closeConnection(this, 0);
  }
  else
  {
    v2 = 0;
    v3 = 0;
    buffer = 0;
    while (1)
    {
      v4 = MEMORY[0x186DB7E64](*((_QWORD *)this + 20), &buffer);
      if (v4 < 1)
        break;
      v5 = dispatch_data_create(buffer, v4, *((dispatch_queue_t *)this + 21), 0);
      if (v3)
      {
        concat = dispatch_data_create_concat(v3, v5);
        dispatch_release(v3);
        dispatch_release(v5);
        v5 = concat;
      }
      v2 += v4;
      v3 = v5;
      if (v2 >= 0x80000)
      {
        if (!v5)
          goto LABEL_9;
LABEL_14:
        ++*((_DWORD *)this + 27);
        v8 = *((_QWORD *)this + 7);
        if (*(_DWORD *)v8 != 2)
        {
          if (*(_DWORD *)v8 == 1)
          {
            (*(void (**)(_QWORD, NSObject *, _QWORD))(**(_QWORD **)(v8 + 8) + 48))(*(_QWORD *)(v8 + 8), v5, *((_QWORD *)this + 14));
            goto LABEL_21;
          }
          v13 = "false";
          v14 = 296;
          v15 = "TCPIOConnectionTest.hpp";
          v16 = "write";
LABEL_25:
          __assert_rtn(v16, v15, v14, v13);
        }
        v9 = *(_QWORD *)(v8 + 8);
        if (!*(_BYTE *)(v9 + 144))
        {
          *(_BYTE *)(v9 + 144) = 1;
          buffer_ptr[0] = (void *)0x6400000003;
          nghttp2_submit_settings();
          HTTP2Server::write((HTTP2Server *)(v9 + 96));
        }
        size_ptr = 0;
        buffer_ptr[0] = 0;
        v10 = dispatch_data_create_map(v5, (const void **)buffer_ptr, &size_ptr);
        v11 = MEMORY[0x186DB7E58](*(_QWORD *)(v9 + 136), buffer_ptr[0], size_ptr);
        if (v11 != size_ptr)
        {
          v13 = "received == len";
          v14 = 112;
          v15 = "HTTP2Server.hpp";
          v16 = "read";
          goto LABEL_25;
        }
        dispatch_release(v10);
        HTTP2Server::write((HTTP2Server *)(v9 + 96));
LABEL_21:
        dispatch_release(v5);
        if (v4 < 0)
          goto LABEL_22;
        goto LABEL_10;
      }
    }
    v5 = v3;
    if (v3)
      goto LABEL_14;
LABEL_9:
    if (v4 < 0)
    {
LABEL_22:
      *((_DWORD *)this + 44) = 4;
      HTTP2Connection::closeConnection(this, 0);
      return v19((uint64_t)v18);
    }
LABEL_10:
    if (v2 >= 0x80000)
    {
      v7 = (void *)*((_QWORD *)this + 16);
      if (v7)
        dispatch_async(*((dispatch_queue_t *)this + 21), v7);
    }
  }
  return v19((uint64_t)v18);
}

void sub_183F14BBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void (*a13)(char *))
{
  a13(&a11);
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::write(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  _QWORD v6[5];

  v4 = *MEMORY[0x1E0CCECE8];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN14NWIOConnection5writeEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFv13CFStreamErrorE_block_invoke;
  v6[3] = &unk_1E14F7D38;
  v6[4] = a3;
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD *))(*(_QWORD *)a1 + 64))(a1, v4, 0, a2, v6);
}

void NWIOConnection::writeWithContext(NWIOConnection *a1, NSObject *a2, int a3, dispatch_data_t data, uint64_t a5)
{
  size_t size;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  _BOOL8 isCellular;
  _BOOL8 isExpensive;
  std::__shared_weak_count *v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  NSObject *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  _QWORD v28[8];
  std::__shared_weak_count *v29;
  uint64_t v30;
  uint64_t v31;
  std::__shared_weak_count *v32;

  if (data)
  {
    size = dispatch_data_get_size(data);
    v11 = size;
    v12 = *((_QWORD *)a1 + 73);
    if (v12)
      v13 = size == 0;
    else
      v13 = 1;
    if (!v13)
    {
      isCellular = NWIOConnection::_isCellular(a1);
      isExpensive = NWIOConnection::_isExpensive(a1);
      __ConditionalConnectionDUETSupport_ReportBytes(v12, v11, isCellular, isExpensive, 1);
    }
  }
  else
  {
    v11 = 0;
  }
  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  v31 = 0;
  v32 = 0;
  v16 = (std::__shared_weak_count *)*((_QWORD *)a1 + 33);
  if (v16)
  {
    v17 = std::__shared_weak_count::lock(v16);
    v32 = v17;
    if (v17)
    {
      v18 = *((_QWORD *)a1 + 32);
      v31 = v18;
      goto LABEL_15;
    }
  }
  else
  {
    v17 = 0;
  }
  v18 = 0;
LABEL_15:
  v19 = *((_QWORD *)a1 + 34);
  v28[0] = MEMORY[0x1E0C809B0];
  v28[1] = 3321888768;
  v28[2] = ___ZN14NWIOConnection16writeWithContextEPU32objcproto21OS_nw_content_context8NSObjectN26ContextReadWriteConnection17WriteContextStateEPU27objcproto16OS_dispatch_dataS0_U13block_pointerFv13CFStreamErrorE_block_invoke;
  v28[3] = &unk_1E14F4698;
  v28[6] = a1;
  v28[7] = v18;
  v29 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v21 = __ldxr(p_shared_owners);
    while (__stxr(v21 + 1, p_shared_owners));
  }
  v30 = v11;
  v28[4] = data;
  v28[5] = a5;
  nw_connection_send(v19, data, a2, a3 == 0, v28);
  v22 = v29;
  if (v29)
  {
    v23 = (unint64_t *)&v29->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = v32;
  if (v32)
  {
    v26 = (unint64_t *)&v32->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
}

void sub_183F14E24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void CFXCookieStorage::getCookiesForTask(uint64_t a1, NSURLSessionTask *a2, const __CFURL *a3, uint64_t a4)
{
  void *v8;
  void *v9;
  NSURL *v10;
  NSURL *v11;
  NSURL *PolicyPropertiesFromTask;
  int CookieAcceptPolicy;
  NSHTTPCookieStorage *v14;
  uint64_t v15;
  PrivateHTTPCookieStorage *v16;
  uint64_t v17;
  HTTPCookieStorage *v18;
  CFMutableArrayRef v19;
  _BYTE v20[104];
  _QWORD v21[5];

  v8 = (void *)MEMORY[0x186DB8C8C]();
  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
  {
    v9 = *(void **)(a1 + 32);
    v21[0] = MEMORY[0x1E0C809B0];
    v21[1] = 3221225472;
    v21[2] = ___ZNK16CFXCookieStorage17getCookiesForTaskEP16NSURLSessionTaskhU13block_pointerFvPK9__CFArrayE_block_invoke;
    v21[3] = &unk_1E14FC7C8;
    v21[4] = a4;
    objc_msgSend(v9, "getCookiesForTask:completionHandler:", a2, v21);
  }
  else
  {
    v10 = -[NSURLSessionTask currentRequest_URL](a2, "currentRequest_URL");
    v11 = -[NSURLSessionTask currentRequest_mainDocumentURL](a2, "currentRequest_mainDocumentURL");
    PolicyPropertiesFromTask = getPolicyPropertiesFromTask(a2);
    CookieAcceptPolicy = -[NSURLSessionTask _cookieAcceptPolicy](a2, "_cookieAcceptPolicy");
    v14 = -[NSURLSessionConfiguration HTTPCookieStorage](-[NSURLSessionTask _effectiveConfiguration](a2, "_effectiveConfiguration"), "HTTPCookieStorage");
    if ((objc_opt_respondsToSelector() & 1) != 0
      && -[NSHTTPCookieStorage _overrideSessionCookieAcceptPolicy](v14, "_overrideSessionCookieAcceptPolicy"))
    {
      v15 = *(_QWORD *)(a1 + 24);
      if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
        dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
      v16 = *(PrivateHTTPCookieStorage **)(v15 + 32);
      if (v16)
        CookieAcceptPolicy = PrivateHTTPCookieStorage::getCookieAcceptPolicy(v16);
      else
        CookieAcceptPolicy = 2;
    }
    HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v20, v10, v11, (uint64_t)-[NSURLSessionTask _storagePartitionIdentifier](a2, "_storagePartitionIdentifier"), CookieAcceptPolicy, 0, (const __CFDictionary *)PolicyPropertiesFromTask);
    v17 = *(_QWORD *)(a1 + 24);
    if (v17)
    {
      if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
        dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
      v18 = (HTTPCookieStorage *)(v17 + 16);
    }
    else
    {
      v18 = 0;
    }
    v19 = HTTPCookieStorage::copyCookiesForURLWithMainDocumentURL(v18, (const HTTPCookieStoragePolicy *)v20, a3);
    (*(void (**)(uint64_t, CFMutableArrayRef))(a4 + 16))(a4, v19);
    if (v19)
      CFRelease(v19);
    HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v20);
  }
  objc_autoreleasePoolPop(v8);
}

void sub_183F15050(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)&a9);
  _Unwind_Resume(a1);
}

NSURL *getPolicyPropertiesFromTask(NSURLSessionTask *a1)
{
  NSURL *result;
  _QWORD v3[3];
  _QWORD v4[4];

  v4[3] = *MEMORY[0x1E0C80C00];
  result = -[NSURLSessionTask _siteForCookies](a1, "_siteForCookies");
  if (result)
  {
    v3[0] = CFSTR("_kCFHTTPCookiePolicyPropertySiteForCookies");
    v4[0] = -[NSURLSessionTask _siteForCookies](a1, "_siteForCookies");
    v3[1] = CFSTR("_kCFHTTPCookiePolicyPropertyIsTopLevelNavigation");
    v4[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", -[NSURLSessionTask _isTopLevelNavigation](a1, "_isTopLevelNavigation"));
    v3[2] = CFSTR("_kCFHTTPCookiePolicyPropertyIsSafeRequest");
    v4[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", -[NSURLRequest _isIdempotent](-[NSURLSessionTask currentRequest](a1, "currentRequest"), "_isIdempotent"));
    return (NSURL *)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v4, v3, 3);
  }
  return result;
}

BOOL equalData(CFDataRef cf1, CFDataRef theData)
{
  const __CFData *v4;

  if (cf1 == theData)
    return 1;
  if (cf1 && theData)
  {
    if (CFEqual(cf1, theData))
      return 1;
  }
  else if (!cf1)
  {
    v4 = theData;
    return CFDataGetLength(v4) == 0;
  }
  v4 = cf1;
  return CFDataGetLength(v4) == 0;
}

uint64_t ___ZN15HTTP2Connection21_onqueue_performWriteEv_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(result + 32) + 104) = 0;
  return result;
}

void CFXURLCache::addCachedResponseForTask(CFXURLCache *this, _CFCachedURLResponse *a2, NSURLSessionTask *a3)
{
  void *v6;
  HTTPProtocol *v7;
  _CFURLCache *v8;
  NSURLRequest *v9;
  const void *v10;

  v6 = (void *)MEMORY[0x186DB8C8C]();
  v8 = (_CFURLCache *)*((_QWORD *)this + 1);
  v7 = (HTTPProtocol *)*((_QWORD *)this + 2);
  v9 = -[NSURLSessionTask currentRequest](a3, "currentRequest");
  _CFURLCacheAddCachedResponseForRequestWithSession(v8, v7, a2, (_CFURLRequest *)v9, v10);
  objc_autoreleasePoolPop(v6);
}

void _CFURLCacheAddCachedResponseForRequestWithSession(_CFURLCache *a1, HTTPProtocol *a2, _CFCachedURLResponse *a3, _CFURLRequest *a4, const void *a5)
{
  uint64_t TypeID;
  const char *v10;

  if (a1)
  {
    TypeID = CFURLCacheGetTypeID();
    if (TypeID == CFGetTypeID(a1))
    {
      __CFURLCacheAddCachedResponseForRequestWithSession(a1, a2, a3, a4, 0);
    }
    else
    {
      v10 = (const char *)_CFURLCacheAddCachedResponseForRequestWithSession(_CFURLCache const*,NSURLSession *,_CFCachedURLResponse const*,_CFURLRequest const*,void const*)::s;
      if (!_CFURLCacheAddCachedResponseForRequestWithSession(_CFURLCache const*,NSURLSession *,_CFCachedURLResponse const*,_CFURLRequest const*,void const*)::s)
      {
        v10 = sel_registerName("_nscfBridgeURLCacheStoreCachedResponse:forRequest:");
        _CFURLCacheAddCachedResponseForRequestWithSession(_CFURLCache const*,NSURLSession *,_CFCachedURLResponse const*,_CFURLRequest const*,void const*)::s = (uint64_t)v10;
      }
      objc_msgSend(a1, v10, a3, a4);
    }
  }
}

void rdar46818402(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BOOL4 v16;
  _BOOL4 v17;
  _BOOL4 v18;
  uint64_t v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _BOOL4 v27;
  _BOOL4 v28;
  NSObject *v29;
  int v30;
  int v31;
  std::__shared_weak_count *v32;
  unint64_t *p_shared_owners;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  const char *v41;
  int v42;
  const char *v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _BOOL4 v51;
  uint64_t v53;
  std::__shared_weak_count *v54;
  uint64_t v55;
  std::__shared_weak_count *v56;
  uint64_t v57;
  std::__shared_weak_count *v58;
  uint8_t buf[4];
  uint64_t v60;
  __int16 v61;
  uint64_t v62;
  __int16 v63;
  uint64_t v64;
  __int16 v65;
  int v66;
  __int16 v67;
  uint64_t v68;
  __int16 v69;
  int v70;
  __int16 v71;
  uint64_t v72;
  __int16 v73;
  uint64_t v74;
  __int16 v75;
  uint64_t v76;
  __int16 v77;
  uint64_t v78;
  __int16 v79;
  uint64_t v80;
  __int16 v81;
  uint64_t v82;
  __int16 v83;
  uint64_t v84;
  __int16 v85;
  uint64_t v86;
  __int16 v87;
  uint64_t v88;
  __int16 v89;
  uint64_t v90;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  if (a9)
  {
    v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a9 + 72))(a9);
    v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a9 + 64))(a9);
    v15 = v14;
    v16 = a4 != 0;
    v17 = v13 != 0;
    v18 = v14 != 0;
    if (a4)
    {
      if (v13 && v14 != 0)
        return;
    }
  }
  else
  {
    v18 = 0;
    v17 = 0;
    v15 = 0;
    v13 = 0;
    v16 = a4 != 0;
  }
  v46 = a8;
  v47 = a7;
  v20 = *(_QWORD *)(a1 + 136);
  if (v20)
    v21 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 320))(v20);
  else
    v21 = 0;
  v57 = v21;
  v22 = (std::__shared_weak_count *)operator new();
  v22->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19E8;
  v22->__shared_owners_ = 0;
  v22->__shared_weak_owners_ = 0;
  v22[1].__vftable = (std::__shared_weak_count_vtbl *)v21;
  v58 = v22;
  v23 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a6 + 80))(a6);
  v24 = v23;
  if (v23)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)v23 + 72))(&v55, v23);
  }
  else
  {
    v55 = 0;
    v56 = 0;
  }
  v51 = v17;
  v45 = a6;
  if (a9 && (v25 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a9 + 80))(a9), (v26 = v25) != 0))
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)v25 + 72))(&v53, v25);
  }
  else
  {
    v26 = 0;
    v53 = 0;
    v54 = 0;
  }
  v27 = v18;
  v28 = v16;
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v29 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 138547202;
    v60 = v21;
    v61 = 2048;
    v62 = a1;
    v63 = 2048;
    v64 = a2;
    v65 = 1024;
    v66 = a3;
    v67 = 2048;
    v68 = a4;
    v69 = 1024;
    v70 = a5;
    v71 = 2048;
    v72 = a9;
    v73 = 2048;
    v74 = v46;
    v75 = 2048;
    v76 = v47;
    v77 = 2048;
    v78 = v13;
    v79 = 2048;
    v80 = v15;
    v81 = 2048;
    v82 = v26;
    v83 = 2114;
    v84 = v53;
    v85 = 2048;
    v86 = v45;
    v87 = 2048;
    v88 = v24;
    v89 = 2114;
    v90 = v55;
    _os_log_fault_impl(&dword_183ECA000, v29, OS_LOG_TYPE_FAULT, "[rdar46818402] C(%{public}@) T(%p) T.E(%ld:%d) T.K(%p) T.T(%d), W(%p [%ld/%ld]) W.K(%p) W.T(%p) W.C(%p) W.CT(%{public}@), fW(%p) fW.C(%p) fW.CT(%{public}@)", buf, 0x9Au);
  }
  v30 = !v28;
  if (!a9)
    v30 = 1;
  v31 = v30 | !v51;
  if ((v31 & 1) != 0 || !v27)
  {
    v41 = "waiterKey";
    if (a9)
    {
      v42 = 615;
    }
    else
    {
      v41 = "waiter";
      v42 = 614;
    }
    if (!v28)
    {
      v41 = "newTubeKey";
      v42 = 613;
    }
    if (v31)
      v43 = v41;
    else
      v43 = "waiterTube";
    if (v31)
      v44 = v42;
    else
      v44 = 616;
    __assert_rtn("rdar46818402", "TubeManager.cpp", v44, v43);
  }
  v32 = v54;
  if (v54)
  {
    p_shared_owners = (unint64_t *)&v54->__shared_owners_;
    do
      v34 = __ldaxr(p_shared_owners);
    while (__stlxr(v34 - 1, p_shared_owners));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  v35 = v56;
  if (v56)
  {
    v36 = (unint64_t *)&v56->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  v38 = v58;
  if (v58)
  {
    v39 = (unint64_t *)&v58->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
}

void sub_183F15844(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12;
  va_list va;
  uint64_t v14;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v12 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void ___ZN15HTTP2Connection25setupWriteCompletionBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke(uint64_t a1, uint64_t a2, unsigned int a3)
{
  HTTP2Connection *v3;

  v3 = *(HTTP2Connection **)(a1 + 32);
  --*((_DWORD *)v3 + 27);
  if (a2 | a3)
  {
    if (!(*((_QWORD *)v3 + 18) | *((unsigned int *)v3 + 38)))
      (*(void (**)(HTTP2Connection *))(*(_QWORD *)v3 + 88))(v3);
  }
  else
  {
    HTTP2Connection::_onqueue_scheduleIO(v3);
  }
}

uint64_t NWIOConnection::isCoalescingStopped(NWIOConnection *this)
{
  return (*((unsigned __int8 *)this + 250) >> 2) & 1;
}

uint64_t NWIOConnection::stopCoalescing(NWIOConnection *this)
{
  uint64_t result;
  int v2;

  v2 = *((unsigned __int16 *)this + 124);
  result = (uint64_t)this + 248;
  *(_BYTE *)(result + 2) = (v2 | (*(unsigned __int8 *)(result + 2) << 16) | 0x40000u) >> 16;
  *(_WORD *)result = v2;
  return result;
}

uint64_t NWIOConnection::_tlsProcessHandshakeComplete(NWIOConnection *this)
{
  NSObject *v2;
  uint64_t v3;
  const __CFArray *Value;
  const __CFArray *v5;
  NSObject *v6;
  const char *negotiated_protocol;
  CFStringRef v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  SecTrustRef v12;
  _QWORD *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD *v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  NSObject *v21;
  __int128 v22;
  unint64_t *v23;
  unint64_t v24;
  int v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  NSObject *v37;
  uint64_t v38;
  CFMutableArrayRef Mutable;
  std::__shared_weak_count *v40;
  const void *v41;
  CFTypeRef v42;
  uint64_t v43;
  __int128 v44;
  _QWORD *v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  NSObject *v52;
  CFMutableArrayRef v53;
  std::__shared_weak_count *v54;
  const void *v55;
  CFTypeRef v56;
  uint64_t v57;
  __int128 v58;
  _QWORD *v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  NSObject *v66;
  NSObject *v67;
  NSObject *v68;
  SecIdentityRef v69;
  CFMutableArrayRef v70;
  std::__shared_weak_count *v71;
  const void *v72;
  CFTypeRef v73;
  std::__shared_weak_count *v74;
  unint64_t *v75;
  unint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  std::__shared_weak_count *v79;
  uint64_t v80;
  unint64_t *v81;
  unint64_t v82;
  NSObject *v83;
  __int128 v84;
  unint64_t *v85;
  unint64_t v86;
  int v87;
  unint64_t *v88;
  unint64_t v89;
  std::__shared_weak_count *v90;
  unint64_t *v91;
  unint64_t v92;
  NSObject *v93;
  _QWORD *v94;
  __int128 v95;
  std::__shared_weak_count *v96;
  unint64_t *v97;
  unint64_t v98;
  std::__shared_weak_count *v99;
  unint64_t *v100;
  unint64_t v101;
  SSLProtocol negotiated_protocol_version;
  const __CFAllocator *v103;
  CFNumberRef v104;
  StrictSecurityPolicy *negotiated_tls_ciphersuite;
  CFNumberRef v106;
  const __CFDictionary *v107;
  _BOOL4 v108;
  const void *v109;
  const void *v110;
  CFTypeID v111;
  const __CFDictionary *v112;
  const void *v113;
  const void *v114;
  CFTypeID v115;
  uint64_t v116;
  NSObject *v117;
  uint64_t result;
  uint64_t v119;
  __int128 v120;
  __int128 v121;
  uint8_t v122[16];
  uint64_t handler;
  uint64_t v124;
  void (*v125)(uint64_t, sec_certificate_t);
  void *v126;
  _BYTE *v127;
  _BYTE buf[24];
  __n128 (*v129)(__n128 *, __n128 *);
  uint64_t (*v130)(uint64_t);
  void *v131;
  CFMutableArrayRef v132;
  std::__shared_weak_count *v133;
  uint64_t v134;
  CFRange v135;
  CFRange v136;

  v134 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *((_QWORD *)this + 36);
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = v3;
    _os_log_impl(&dword_183ECA000, v2, OS_LOG_TYPE_DEFAULT, "Connection %llu: TLS handshake complete", buf, 0xCu);
  }
  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  *((_WORD *)this + 124) |= 0x1000u;
  NWIOConnection::_tlsCopyMetadata((nw_connection_t *)this);
  Value = (const __CFArray *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCFA6E8);
  v5 = (const __CFArray *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCF9D80);
  if ((unint64_t)Value | (unint64_t)v5)
  {
    NWIOConnection::_tlsCopyMetadata((nw_connection_t *)this);
    v6 = *((_QWORD *)this + 55);
    if (v6)
    {
      negotiated_protocol = sec_protocol_metadata_get_negotiated_protocol(v6);
      if (negotiated_protocol)
      {
        if (*negotiated_protocol)
        {
          v8 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], negotiated_protocol, 0x8000100u);
          if (CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCFAC98)
            || Value
            && (v135.length = CFArrayGetCount(Value), v135.location = 0, CFArrayContainsValue(Value, v135, v8))
            || v5 && (v136.length = CFArrayGetCount(v5), v136.location = 0, CFArrayContainsValue(v5, v136, v8)))
          {
            CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_1EDCFA720, v8);
          }
          else
          {
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v93 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
            {
              v119 = *((_QWORD *)this + 36);
              *(_DWORD *)buf = 134218242;
              *(_QWORD *)&buf[4] = v119;
              *(_WORD *)&buf[12] = 2114;
              *(_QWORD *)&buf[14] = v8;
              _os_log_error_impl(&dword_183ECA000, v93, OS_LOG_TYPE_ERROR, "Connection %llu: ALPN selected protocol (%{public}@) was not offered - ignoring it", buf, 0x16u);
            }
            CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_1EDCFA720, &stru_1E1500C68);
          }
          if (v8)
            CFRelease(v8);
        }
      }
    }
  }
  v9 = *((_QWORD *)this + 55);
  if (!v9)
    goto LABEL_177;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  v10 = sec_protocol_metadata_copy_sec_trust();
  v11 = v10;
  if (v10)
  {
    v12 = sec_trust_copy_ref(v10);
    v13 = (_QWORD *)operator new();
    *v13 = &off_1E14F1048;
    v13[1] = 0;
    v13[2] = 0;
    v13[3] = v12;
    *(_QWORD *)&v14 = v12;
    *((_QWORD *)&v14 + 1) = v13;
    *(_OWORD *)buf = v14;
    sec_release(v11);
    if (v12)
      goto LABEL_45;
  }
  v15 = *((_QWORD *)this + 50);
  if (!v15)
    goto LABEL_45;
  v16 = *(_QWORD **)(*(_QWORD *)(v15 + 56) + 8);
  while (v16 != *(_QWORD **)(v15 + 56))
  {
    v18 = v16[2];
    v17 = (std::__shared_weak_count *)v16[3];
    if (v17)
    {
      p_shared_owners = (unint64_t *)&v17->__shared_owners_;
      do
        v20 = __ldxr(p_shared_owners);
      while (__stxr(v20 + 1, p_shared_owners));
    }
    v21 = *(NSObject **)(v18 + 40);
    if (v21 && sec_protocol_metadata_peers_are_equal(v21, v9))
    {
      v22 = *(_OWORD *)(v18 + 80);
      v120 = v22;
      if (*((_QWORD *)&v22 + 1))
      {
        v23 = (unint64_t *)(*((_QWORD *)&v22 + 1) + 8);
        do
          v24 = __ldxr(v23);
        while (__stxr(v24 + 1, v23));
      }
      v25 = 1;
      if (!v17)
        goto LABEL_35;
LABEL_32:
      v26 = (unint64_t *)&v17->__shared_owners_;
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (v27)
        goto LABEL_35;
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
      if (v25)
        goto LABEL_40;
    }
    else
    {
      v25 = 0;
      v16 = (_QWORD *)v16[1];
      if (v17)
        goto LABEL_32;
LABEL_35:
      if (v25)
        goto LABEL_40;
    }
  }
  v120 = 0u;
LABEL_40:
  v28 = *(std::__shared_weak_count **)&buf[8];
  *(_OWORD *)buf = v120;
  if (v28)
  {
    v29 = (unint64_t *)&v28->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
LABEL_45:
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 448, (__int128 *)buf);
  v31 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v32 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  if ((*((_WORD *)this + 124) & 0x400) == 0 && !*((_QWORD *)this + 56))
    __assert_rtn("_tlsProcessSaveHandshakeProperties", "NWIOConnection.cpp", 5009, "_tlsTrust");
  NWIOConnection::_tlsTrustDataForTrust((NWIOConnection *)buf, (uint64_t)this);
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 464, (__int128 *)buf);
  v34 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v35 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v37 = *((_QWORD *)this + 55);
  v121 = 0uLL;
  v38 = MEMORY[0x1E0C809B0];
  if (v37)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x4012000000;
    v129 = __Block_byref_object_copy__147;
    v130 = __Block_byref_object_dispose__148;
    v131 = &unk_18422E08D;
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    v132 = Mutable;
    v40 = (std::__shared_weak_count *)operator new();
    v40->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1978;
    v40->__shared_owners_ = 0;
    v40->__shared_weak_owners_ = 0;
    v40[1].__vftable = (std::__shared_weak_count_vtbl *)Mutable;
    v133 = v40;
    handler = v38;
    v124 = 3221225472;
    v125 = ___ZN14NWIOConnection37_tlsCopyPeerCertificatesUsingMetadataEPU35objcproto24OS_sec_protocol_metadata8NSObject_block_invoke;
    v126 = &unk_1E14F7F08;
    v127 = buf;
    if (sec_protocol_metadata_access_peer_certificate_chain(v37, &handler))
    {
      v41 = *(const void **)(*(_QWORD *)&buf[8] + 48);
      if (v41)
        v42 = CFRetain(v41);
      else
        v42 = 0;
      v45 = (_QWORD *)operator new();
      *v45 = &off_1E14F1AC8;
      v45[1] = 0;
      v45[2] = 0;
      v45[3] = v42;
      *(_QWORD *)&v44 = v42;
      *((_QWORD *)&v44 + 1) = v45;
LABEL_65:
      v121 = v44;
    }
    else
    {
      v43 = *((_QWORD *)this + 50);
      if (v43)
      {
        TLSCallbackQueue::copyCachedPeerCertificates(v122, v43, v37);
        v44 = *(_OWORD *)v122;
        goto LABEL_65;
      }
    }
    _Block_object_dispose(buf, 8);
    v46 = v133;
    if (v133)
    {
      v47 = (unint64_t *)&v133->__shared_owners_;
      do
        v48 = __ldaxr(v47);
      while (__stlxr(v48 - 1, v47));
      if (!v48)
      {
        ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
        std::__shared_weak_count::__release_weak(v46);
      }
    }
  }
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 480, &v121);
  v49 = (std::__shared_weak_count *)*((_QWORD *)&v121 + 1);
  if (*((_QWORD *)&v121 + 1))
  {
    v50 = (unint64_t *)(*((_QWORD *)&v121 + 1) + 8);
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
  v52 = *((_QWORD *)this + 55);
  v121 = 0uLL;
  if (v52)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x4012000000;
    v129 = __Block_byref_object_copy__147;
    v130 = __Block_byref_object_dispose__148;
    v131 = &unk_18422E08D;
    v53 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    v132 = v53;
    v54 = (std::__shared_weak_count *)operator new();
    v54->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1978;
    v54->__shared_owners_ = 0;
    v54->__shared_weak_owners_ = 0;
    v54[1].__vftable = (std::__shared_weak_count_vtbl *)v53;
    v133 = v54;
    handler = v38;
    v124 = 3221225472;
    v125 = ___ZN14NWIOConnection39_tlsCopyDistinguishedNamesUsingMetadataEPU35objcproto24OS_sec_protocol_metadata8NSObject_block_invoke;
    v126 = &unk_1E14F7F30;
    v127 = buf;
    if (sec_protocol_metadata_access_distinguished_names(v52, &handler))
    {
      v55 = *(const void **)(*(_QWORD *)&buf[8] + 48);
      if (v55)
        v56 = CFRetain(v55);
      else
        v56 = 0;
      v59 = (_QWORD *)operator new();
      *v59 = &off_1E14F1AC8;
      v59[1] = 0;
      v59[2] = 0;
      v59[3] = v56;
      *(_QWORD *)&v58 = v56;
      *((_QWORD *)&v58 + 1) = v59;
LABEL_84:
      v121 = v58;
    }
    else
    {
      v57 = *((_QWORD *)this + 50);
      if (v57)
      {
        TLSCallbackQueue::copyCachedPeerCertificates(v122, v57, v52);
        v58 = *(_OWORD *)v122;
        goto LABEL_84;
      }
    }
    _Block_object_dispose(buf, 8);
    v60 = v133;
    if (v133)
    {
      v61 = (unint64_t *)&v133->__shared_owners_;
      do
        v62 = __ldaxr(v61);
      while (__stlxr(v62 - 1, v61));
      if (!v62)
      {
        ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
        std::__shared_weak_count::__release_weak(v60);
      }
    }
  }
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 496, &v121);
  v63 = (std::__shared_weak_count *)*((_QWORD *)&v121 + 1);
  if (*((_QWORD *)&v121 + 1))
  {
    v64 = (unint64_t *)(*((_QWORD *)&v121 + 1) + 8);
    do
      v65 = __ldaxr(v64);
    while (__stlxr(v65 - 1, v64));
    if (!v65)
    {
      ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
      std::__shared_weak_count::__release_weak(v63);
    }
  }
  v66 = *((_QWORD *)this + 55);
  memset(v122, 0, sizeof(v122));
  if (!v66)
    goto LABEL_151;
  v67 = sec_protocol_metadata_copy_sec_identity();
  v68 = v67;
  if (v67)
  {
    v69 = sec_identity_copy_ref(v67);
    sec_release(v68);
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x4012000000;
    v129 = __Block_byref_object_copy__147;
    v130 = __Block_byref_object_dispose__148;
    v131 = &unk_18422E08D;
    v70 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    v132 = v70;
    v71 = (std::__shared_weak_count *)operator new();
    v71->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1978;
    v71->__shared_owners_ = 0;
    v71->__shared_weak_owners_ = 0;
    v71[1].__vftable = (std::__shared_weak_count_vtbl *)v70;
    v133 = v71;
    CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)&buf[8] + 48), v69);
    handler = v38;
    v124 = 3221225472;
    v125 = ___ZN14NWIOConnection39_tlsCopyClientCertificatesUsingMetadataEPU35objcproto24OS_sec_protocol_metadata8NSObject_block_invoke;
    v126 = &unk_1E14F7F08;
    v127 = buf;
    if (sec_protocol_metadata_access_sent_certificates())
    {
      v72 = *(const void **)(*(_QWORD *)&buf[8] + 48);
      if (v72)
        v73 = CFRetain(v72);
      else
        v73 = 0;
      v94 = (_QWORD *)operator new();
      *v94 = &off_1E14F1AC8;
      v94[1] = 0;
      v94[2] = 0;
      v94[3] = v73;
      *(_QWORD *)&v95 = v73;
      *((_QWORD *)&v95 + 1) = v94;
      *(_OWORD *)v122 = v95;
      _Block_object_dispose(buf, 8);
      v96 = v133;
      if (v133)
      {
        v97 = (unint64_t *)&v133->__shared_owners_;
        do
          v98 = __ldaxr(v97);
        while (__stlxr(v98 - 1, v97));
        if (!v98)
        {
          ((void (*)(std::__shared_weak_count *))v96->__on_zero_shared)(v96);
          std::__shared_weak_count::__release_weak(v96);
        }
      }
      if (v69)
        CFRelease(v69);
      goto LABEL_151;
    }
    _Block_object_dispose(buf, 8);
    v74 = v133;
    if (v133)
    {
      v75 = (unint64_t *)&v133->__shared_owners_;
      do
        v76 = __ldaxr(v75);
      while (__stlxr(v76 - 1, v75));
      if (!v76)
      {
        ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
        std::__shared_weak_count::__release_weak(v74);
      }
    }
    if (v69)
      CFRelease(v69);
  }
  v77 = *((_QWORD *)this + 50);
  if (!v77)
    goto LABEL_151;
  v78 = *(_QWORD **)(*(_QWORD *)(v77 + 64) + 8);
  while (v78 != *(_QWORD **)(v77 + 64))
  {
    v80 = v78[2];
    v79 = (std::__shared_weak_count *)v78[3];
    if (v79)
    {
      v81 = (unint64_t *)&v79->__shared_owners_;
      do
        v82 = __ldxr(v81);
      while (__stxr(v82 + 1, v81));
    }
    v83 = *(NSObject **)(v80 + 40);
    if (v83 && sec_protocol_metadata_challenge_parameters_are_equal(v83, v66))
    {
      v84 = *(_OWORD *)(v80 + 72);
      v120 = v84;
      if (*((_QWORD *)&v84 + 1))
      {
        v85 = (unint64_t *)(*((_QWORD *)&v84 + 1) + 8);
        do
          v86 = __ldxr(v85);
        while (__stxr(v86 + 1, v85));
      }
      v87 = 1;
      if (!v79)
      {
LABEL_124:
        if (v87)
          goto LABEL_129;
        continue;
      }
    }
    else
    {
      v87 = 0;
      v78 = (_QWORD *)v78[1];
      if (!v79)
        goto LABEL_124;
    }
    v88 = (unint64_t *)&v79->__shared_owners_;
    do
      v89 = __ldaxr(v88);
    while (__stlxr(v89 - 1, v88));
    if (v89)
      goto LABEL_124;
    ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
    std::__shared_weak_count::__release_weak(v79);
    if (v87)
      goto LABEL_129;
  }
  v120 = 0u;
LABEL_129:
  v90 = *(std::__shared_weak_count **)&v122[8];
  *(_OWORD *)v122 = v120;
  if (v90)
  {
    v91 = (unint64_t *)&v90->__shared_owners_;
    do
      v92 = __ldaxr(v91);
    while (__stlxr(v92 - 1, v91));
    if (!v92)
    {
      ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
      std::__shared_weak_count::__release_weak(v90);
    }
  }
LABEL_151:
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 512, (__int128 *)v122);
  v99 = *(std::__shared_weak_count **)&v122[8];
  if (*(_QWORD *)&v122[8])
  {
    v100 = (unint64_t *)(*(_QWORD *)&v122[8] + 8);
    do
      v101 = __ldaxr(v100);
    while (__stlxr(v101 - 1, v100));
    if (!v101)
    {
      ((void (*)(std::__shared_weak_count *))v99->__on_zero_shared)(v99);
      std::__shared_weak_count::__release_weak(v99);
    }
  }
  negotiated_protocol_version = sec_protocol_metadata_get_negotiated_protocol_version(*((sec_protocol_metadata_t *)this
                                                                                      + 55));
  *(_QWORD *)buf = negotiated_protocol_version;
  v103 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v104 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberCFIndexType, buf);
  CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_1EDCFAC28, v104);
  negotiated_tls_ciphersuite = (StrictSecurityPolicy *)sec_protocol_metadata_get_negotiated_tls_ciphersuite(*((sec_protocol_metadata_t *)this + 55));
  handler = negotiated_tls_ciphersuite;
  v106 = CFNumberCreate(v103, kCFNumberCFIndexType, &handler);
  CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_1EDCFABF0, v106);
  v107 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCFC080);
  v108 = 0;
  if (v107)
  {
    v109 = CFDictionaryGetValue(v107, &unk_1EDCFAFE0);
    v110 = v109;
    if (v109)
    {
      v111 = CFGetTypeID(v109);
      if (v111 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v122 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v122, 2u);
      }
      v108 = *MEMORY[0x1E0C9AE50] == (_QWORD)v110;
    }
    else
    {
      v108 = 0;
    }
  }
  v112 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCFC080);
  LODWORD(v113) = 0;
  if (v112)
  {
    v114 = CFDictionaryGetValue(v112, &unk_1EDCFAFA8);
    v113 = v114;
    if (v114)
    {
      v115 = CFGetTypeID(v114);
      if (v115 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v122 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v122, 2u);
      }
      LODWORD(v113) = *MEMORY[0x1E0C9AE50] == (_QWORD)v113;
    }
  }
  if ((v108 | v113) == 1
    && (negotiated_protocol_version < kTLSProtocol12
     || !StrictSecurityPolicy::isATSCompliantCipher(negotiated_tls_ciphersuite)))
  {
    logAppleATSViolation((int)v113, *((const void **)this + 52), negotiated_protocol_version, (int)negotiated_tls_ciphersuite);
  }
  if (v106)
    CFRelease(v106);
  if (v104)
    CFRelease(v104);
LABEL_177:
  v116 = *((_QWORD *)this + 50);
  if (v116)
    std::__list_imp<std::shared_ptr<AuthenticationState>>::clear(*(uint64_t **)(v116 + 64));
  v117 = *((_QWORD *)this + 42);
  if (v117 && !nw_path_uses_interface_type(v117, nw_interface_type_cellular))
    ++gNonCellularSSLAttempts;
  result = *((_QWORD *)this + 18);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 56))(result);
  return result;
}

void sub_183F16708(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28)
{
  std::__shared_weak_count *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;

  _Block_object_dispose(&a21, 8);
  v29 = a28;
  if (a28)
  {
    p_shared_owners = (unint64_t *)&a28->__shared_owners_;
    do
      v31 = __ldaxr(p_shared_owners);
    while (__stlxr(v31 - 1, p_shared_owners));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  if (a12)
  {
    v32 = (unint64_t *)&a12->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
    }
  }
  _Unwind_Resume(a1);
}

void NWIOConnection::_tlsCopyMetadata(nw_connection_t *this)
{
  NSObject *v2;
  nw_protocol_metadata_t v3;
  NSObject *v4;
  nw_connection_t v5;
  BOOL v6;
  NSObject *v7;
  NSObject *v8;
  nw_connection_t v9;
  nw_connection_t v10;

  if (!this[55] && this[34])
  {
    if (!NWIOConnection::_isQUICTransport((NWIOConnection *)this))
      goto LABEL_11;
    v2 = nw_protocol_copy_quic_connection_definition();
    v3 = nw_connection_copy_protocol_metadata(this[34], v2);
    if (v3)
    {
      v4 = nw_quic_connection_copy_sec_protocol_metadata();
      v5 = this[55];
      this[55] = v4;
      if (v5)
      {
        sec_release(v5);
        v4 = this[55];
      }
      -[__CFN_ConnectionMetrics tlsMetadataReceived:](this[25], v4);
      v6 = this[55] == 0;
      nw_release(v3);
      if (v2)
        goto LABEL_9;
    }
    else
    {
      v6 = 1;
      if (v2)
LABEL_9:
        nw_release(v2);
    }
    if (!v6)
      return;
LABEL_11:
    v7 = MEMORY[0x186DB8944]();
    v8 = nw_connection_copy_protocol_metadata(this[34], v7);
    v9 = v8;
    if (v8)
    {
      if (!nw_protocol_metadata_is_tls(v8))
      {
        nw_release(v9);
        if (!v7)
          return;
        goto LABEL_19;
      }
      v10 = this[55];
      this[55] = v9;
      if (v10)
      {
        sec_release(v10);
        v9 = this[55];
      }
      -[__CFN_ConnectionMetrics tlsMetadataReceived:](this[25], v9);
    }
    if (!v7)
      return;
LABEL_19:
    nw_release(v7);
  }
}

void sub_183F16AC8(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    nw_release(v1);
  _Unwind_Resume(exception_object);
}

BOOL NWIOConnection::_isQUICTransport(NWIOConnection *this)
{
  NSObject *v2;
  nw_protocol_metadata_t v3;
  _BOOL8 v4;

  if (!*((_QWORD *)this + 34))
    return 0;
  v2 = nw_protocol_copy_quic_connection_definition();
  v3 = nw_connection_copy_protocol_metadata(*((nw_connection_t *)this + 34), v2);
  v4 = v3 != 0;
  if (v3)
    nw_release(v3);
  if (v2)
    nw_release(v2);
  return v4;
}

void sub_183F16B60(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    nw_release(v1);
  _Unwind_Resume(exception_object);
}

void NWIOConnection::_tlsTrustDataForTrust(NWIOConnection *this, uint64_t a2)
{
  const __CFDictionary *Value;
  const __CFDictionary *v5;
  const __CFDictionary *ATSVersion;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  NSObject *v14;
  uint64_t v15;
  _BYTE buf[22];
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 368), &unk_1EDCFC080);
  ATSVersion = StrictSecurity::getATSVersion(Value, v5);
  StrictSecurity::cloneSecTrust((uint64_t *)buf, (uint64_t)ATSVersion, *(_QWORD *)(a2 + 448));
  v7 = *(_QWORD *)buf;
  *(_QWORD *)this = *(_QWORD *)buf;
  v8 = (_QWORD *)operator new();
  *v8 = &off_1E14F1A90;
  v8[1] = 0;
  v8[2] = 0;
  v8[3] = v7;
  *((_QWORD *)this + 1) = v8;
  if (!v7)
  {
    v9 = SecTrustSerialize();
    *(_QWORD *)buf = v9;
    v10 = (_QWORD *)operator new();
    *v10 = &off_1E14F1A90;
    v10[1] = 0;
    v10[2] = 0;
    v10[3] = v9;
    *(_QWORD *)&buf[8] = v10;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this, (__int128 *)buf);
    v11 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v12 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    if (!*(_QWORD *)this)
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v14 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
      {
        v15 = *(_QWORD *)(a2 + 288);
        *(_DWORD *)buf = 134218498;
        *(_QWORD *)&buf[4] = v15;
        *(_WORD *)&buf[12] = 2112;
        *(_QWORD *)&buf[14] = 0;
        v17 = 2048;
        v18 = 0;
        _os_log_debug_impl(&dword_183ECA000, v14, OS_LOG_TYPE_DEBUG, "Connection %llu: failed to clone trust, error %@ [%ld]", buf, 0x20u);
      }
    }
  }
}

void sub_183F16D80(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

const __CFDictionary *StrictSecurity::getATSVersion(const __CFDictionary *this, const __CFDictionary *a2)
{
  uint64_t valuePtr;

  if (this)
  {
    this = (const __CFDictionary *)CFDictionaryGetValue(this, &unk_1EDCFB018);
    if (this)
    {
      valuePtr = -1;
      return (const __CFDictionary *)(CFNumberGetValue(this, kCFNumberCFIndexType, &valuePtr) && valuePtr == 1);
    }
  }
  return this;
}

void StrictSecurity::cloneSecTrust(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  NSObject *v5;
  uint8_t buf[4];
  uint64_t v7;
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  *a1 = 0;
  if (a2 >= 1)
  {
    if (a3)
    {
      if (dyld_program_sdk_at_least())
      {
        v4 = SecTrustSerialize();
        *a1 = v4;
        if (!v4)
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v5 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412546;
            v7 = 0;
            v8 = 2048;
            v9 = 0;
            _os_log_error_impl(&dword_183ECA000, v5, OS_LOG_TYPE_ERROR, "Failed to clone ATS trust %@ [%ld]", buf, 0x16u);
          }
        }
      }
    }
  }
}

void sub_183F16F44(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  const void *v2;

  *v1 = 0;
  if (v2)
    CFRelease(v2);
  _Unwind_Resume(exception_object);
}

void std::__list_imp<std::shared_ptr<AuthenticationState>>::clear(uint64_t *a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;

  if (a1[2])
  {
    v2 = *a1;
    v3 = (uint64_t *)a1[1];
    v4 = *v3;
    *(_QWORD *)(v4 + 8) = *(_QWORD *)(*a1 + 8);
    **(_QWORD **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        v5 = (uint64_t *)v3[1];
        std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v3 + 2));
        operator delete(v3);
        v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void ___ZN4Tube24_onqueue_needServerTrustEv_block_invoke(uint64_t a1)
{
  CFRelease((CFTypeRef)(*(_QWORD *)(a1 + 32) - 16));
}

void ___ZN22TLSCallbackServerTrust14invokeCallbackEU13block_pointerFvbE_block_invoke(_QWORD *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, unsigned int a6)
{
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *p_shared_owners;
  unint64_t v16;

  v9 = (std::__shared_weak_count *)a1[6];
  if (v9)
  {
    v13 = std::__shared_weak_count::lock(v9);
    if (v13)
    {
      v14 = a1[5];
      if (v14)
      {
        *(_BYTE *)(v14 + 72) = a2;
        std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v14 + 80), *a3, a3[1]);
        std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v14 + 96), *a4, a4[1]);
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v14 + 64) + 16))(*(_QWORD *)(v14 + 64), a2);
        _Block_release(*(const void **)(v14 + 64));
        *(_QWORD *)(v14 + 64) = 0;
      }
    }
  }
  else
  {
    v13 = 0;
  }
  (*(void (**)(_QWORD, BOOL))(a1[4] + 16))(a1[4], (a5 | a6) != 0);
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_183F17118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN16TLSCallbackQueue14_doServerTrustENSt3__110shared_ptrI22TLSCallbackServerTrustEE_block_invoke(_QWORD *a1, int a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t *v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;

  v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      v6 = v5;
      v7 = a1[4];
      if (v7)
      {
        if (a2)
        {
          *(_BYTE *)(v7 + 41) = 0;
          std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>::pop_front(*(_QWORD *)(v7 + 48));
        }
        else
        {
          v8 = *(uint64_t **)(v7 + 56);
          v9 = operator new(0x20uLL);
          v10 = a1[7];
          v9[2] = a1[6];
          v9[3] = v10;
          if (v10)
          {
            v11 = (unint64_t *)(v10 + 8);
            do
              v12 = __ldxr(v11);
            while (__stxr(v12 + 1, v11));
          }
          v9[1] = v8;
          v13 = *v8;
          *v9 = *v8;
          *(_QWORD *)(v13 + 8) = v9;
          *v8 = (uint64_t)v9;
          ++v8[2];
          *(_BYTE *)(v7 + 41) = 0;
          std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>::pop_front(*(_QWORD *)(v7 + 48));
          TLSCallbackQueue::_invokeNextCallback((TLSCallbackQueue *)v7);
        }
      }
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v15 = __ldaxr(p_shared_owners);
      while (__stlxr(v15 - 1, p_shared_owners));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void sub_183F17238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void TLSCallbackQueue::_invokeNextCallback(TLSCallbackQueue *this)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  _QWORD *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  NSObject *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  int v25;
  NSObject *v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  NSObject *v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  _QWORD *v37;
  std::__shared_weak_count *v38;
  _QWORD *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  NSObject *v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  int v48;
  NSObject *v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t *v52;
  unint64_t v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  unint64_t *v57;
  unint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  uint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  uint64_t v64;
  unint64_t *v65;
  unint64_t v66;
  NSObject *v67;
  uint64_t v68;
  unint64_t *v69;
  unint64_t v70;
  unint64_t *v71;
  unint64_t v72;
  uint64_t v73;
  std::__shared_weak_count *v74;
  unint64_t *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t *v78;
  unint64_t v79;
  std::__shared_weak_count *v80;
  unint64_t *v81;
  unint64_t v82;
  unint64_t *v83;
  unint64_t v84;
  uint64_t v85;
  std::__shared_weak_count *v86;
  unint64_t *p_shared_weak_owners;
  unint64_t v88;
  unint64_t *v89;
  unint64_t v90;
  unint64_t *v91;
  unint64_t v92;
  std::__shared_weak_count *v93;
  unint64_t *v94;
  unint64_t v95;
  unint64_t *v96;
  unint64_t v97;
  unint64_t *v98;
  unint64_t v99;
  unint64_t *v100;
  unint64_t v101;
  _QWORD *v102;
  uint64_t v103;
  std::__shared_weak_count *v104;
  std::__shared_weak_count *v105;
  uint8_t buf[8];
  uint64_t v107;
  void (*v108)(_QWORD *, int);
  void *v109;
  uint64_t v110;
  std::__shared_weak_count *v111;
  _QWORD *v112;
  std::__shared_weak_count *v113;
  _QWORD *v114;
  std::__shared_weak_count *v115;
  _QWORD *v116;
  std::__shared_weak_count *v117;
  uint64_t v118;
  uint64_t v119;
  void (*v120)(_QWORD *, uint64_t, uint64_t *, uint64_t *, uint64_t, unsigned int);
  void *v121;
  uint8_t *v122;
  uint64_t v123;
  std::__shared_weak_count *v124;

  if (*((_BYTE *)this + 41))
    return;
  if (*((_BYTE *)this + 40))
    return;
  v2 = *((_QWORD *)this + 6);
  if (!*(_QWORD *)(v2 + 16))
    return;
  *((_BYTE *)this + 41) = 1;
  v3 = *(_QWORD **)(v2 + 8);
  v4 = v3[2];
  v5 = (std::__shared_weak_count *)v3[3];
  v104 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = (_QWORD *)v3[4];
  v9 = (std::__shared_weak_count *)v3[5];
  v105 = v9;
  if (v9)
  {
    v10 = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  if (!v4)
  {
    if (!v8)
      goto LABEL_165;
    v102 = v8;
    if (v9)
    {
      v35 = (unint64_t *)&v9->__shared_owners_;
      do
        v36 = __ldxr(v35);
      while (__stxr(v36 + 1, v35));
    }
    v37 = *(_QWORD **)(*((_QWORD *)this + 8) + 8);
    while (1)
    {
      if (v37 == *((_QWORD **)this + 8))
      {
        v85 = *((_QWORD *)this + 3);
        v86 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
        if (v86)
        {
          p_shared_weak_owners = (unint64_t *)&v86->__shared_weak_owners_;
          do
            v88 = __ldxr(p_shared_weak_owners);
          while (__stxr(v88 + 1, p_shared_weak_owners));
        }
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        v107 = 3321888768;
        v108 = ___ZN16TLSCallbackQueue20_doClientCertificateENSt3__110shared_ptrI28TLSCallbackClientCertificateEE_block_invoke;
        v109 = &__block_descriptor_64_e8_32c41_ZTSNSt3__18weak_ptrI16TLSCallbackQueueEE48c56_ZTSNSt3__110shared_ptrI28TLSCallbackClientCertificateEE_e8_v12__0B8l;
        v110 = v85;
        v111 = v86;
        if (v86)
        {
          v89 = (unint64_t *)&v86->__shared_weak_owners_;
          do
            v90 = __ldxr(v89);
          while (__stxr(v90 + 1, v89));
        }
        v112 = v102;
        v113 = v9;
        if (v9)
        {
          v91 = (unint64_t *)&v9->__shared_owners_;
          do
            v92 = __ldxr(v91);
          while (__stxr(v92 + 1, v91));
        }
        TLSCallbackClientCertificate::invokeCallback((uint64_t)v102, (uint64_t)buf);
        v93 = v113;
        if (v113)
        {
          v94 = (unint64_t *)&v113->__shared_owners_;
          do
            v95 = __ldaxr(v94);
          while (__stlxr(v95 - 1, v94));
          if (!v95)
          {
            ((void (*)(std::__shared_weak_count *))v93->__on_zero_shared)(v93);
            std::__shared_weak_count::__release_weak(v93);
          }
        }
        if (v111)
          std::__shared_weak_count::__release_weak(v111);
        if (v86)
          std::__shared_weak_count::__release_weak(v86);
LABEL_160:
        if (v9)
        {
          v96 = (unint64_t *)&v9->__shared_owners_;
          do
            v97 = __ldaxr(v96);
          while (__stlxr(v97 - 1, v96));
          v5 = v9;
          if (!v97)
            goto LABEL_164;
        }
        goto LABEL_165;
      }
      v39 = (_QWORD *)v37[2];
      v38 = (std::__shared_weak_count *)v37[3];
      v116 = v39;
      v117 = v38;
      if (v38)
      {
        v40 = (unint64_t *)&v38->__shared_owners_;
        do
          v41 = __ldxr(v40);
        while (__stxr(v41 + 1, v40));
      }
      v114 = v102;
      v115 = v9;
      if (v9)
      {
        v42 = (unint64_t *)&v9->__shared_owners_;
        do
          v43 = __ldxr(v42);
        while (__stxr(v43 + 1, v42));
      }
      v44 = v102[5];
      v45 = (std::__shared_weak_count *)v102[6];
      *(_QWORD *)buf = v44;
      v107 = (uint64_t)v45;
      if (v45)
      {
        v46 = (unint64_t *)&v45->__shared_owners_;
        do
          v47 = __ldxr(v46);
        while (__stxr(v47 + 1, v46));
      }
      v48 = 0;
      if (!v44)
        goto LABEL_83;
      v49 = v39[5];
      if (!v49)
        goto LABEL_83;
      if (sec_protocol_metadata_challenge_parameters_are_equal(v49, v44))
        break;
      v48 = 0;
      if (!v45)
        goto LABEL_89;
LABEL_84:
      v57 = (unint64_t *)&v45->__shared_owners_;
      do
        v58 = __ldaxr(v57);
      while (__stlxr(v58 - 1, v57));
      if (!v58)
      {
        ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
        std::__shared_weak_count::__release_weak(v45);
      }
      if (!v9)
        goto LABEL_93;
LABEL_89:
      v59 = (unint64_t *)&v9->__shared_owners_;
      do
        v60 = __ldaxr(v59);
      while (__stlxr(v60 - 1, v59));
      if (!v60)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
        if (v48)
        {
LABEL_94:
          *((_BYTE *)this + 41) = 0;
          std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>::pop_front(*((_QWORD *)this + 6));
          TLSCallbackQueue::_invokeNextCallback(this);
          goto LABEL_97;
        }
      }
      else
      {
LABEL_93:
        if (v48)
          goto LABEL_94;
      }
      v37 = (_QWORD *)v37[1];
      if (!v117)
        goto LABEL_101;
LABEL_97:
      v61 = &v117->__shared_owners_;
      do
        v62 = __ldaxr((unint64_t *)v61);
      while (__stlxr(v62 - 1, (unint64_t *)v61));
      if (!v62)
      {
        ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
        std::__shared_weak_count::__release_weak(v117);
        if ((v48 & 1) != 0)
          goto LABEL_160;
      }
      else
      {
LABEL_101:
        if ((v48 & 1) != 0)
          goto LABEL_160;
      }
    }
    v50 = v102[8];
    v51 = v39[10];
    v118 = v39[9];
    v119 = v51;
    if (v51)
    {
      v52 = (unint64_t *)(v51 + 8);
      do
        v53 = __ldxr(v52);
      while (__stxr(v53 + 1, v52));
    }
    (*(void (**)(uint64_t, uint64_t *, _QWORD, _QWORD))(v50 + 16))(v50, &v118, 0, 0);
    v54 = (std::__shared_weak_count *)v119;
    if (v119)
    {
      v55 = (unint64_t *)(v119 + 8);
      do
        v56 = __ldaxr(v55);
      while (__stlxr(v56 - 1, v55));
      if (!v56)
      {
        ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
        std::__shared_weak_count::__release_weak(v54);
      }
    }
    _Block_release((const void *)v114[8]);
    v114[8] = 0;
    v48 = 1;
    v45 = (std::__shared_weak_count *)v107;
LABEL_83:
    if (!v45)
      goto LABEL_89;
    goto LABEL_84;
  }
  v103 = v4;
  if (v5)
  {
    v12 = (unint64_t *)&v5->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v14 = *(_QWORD **)(*((_QWORD *)this + 7) + 8);
  while (v14 != *((_QWORD **)this + 7))
  {
    v16 = v14[2];
    v15 = v14[3];
    v118 = v16;
    v119 = v15;
    if (v15)
    {
      v17 = (unint64_t *)(v15 + 8);
      do
        v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
    }
    v116 = (_QWORD *)v103;
    v117 = v5;
    if (v5)
    {
      v19 = (unint64_t *)&v5->__shared_owners_;
      do
        v20 = __ldxr(v19);
      while (__stxr(v20 + 1, v19));
    }
    v21 = *(NSObject **)(v103 + 40);
    v22 = *(std::__shared_weak_count **)(v103 + 48);
    *(_QWORD *)buf = v21;
    v107 = (uint64_t)v22;
    if (v22)
    {
      v23 = (unint64_t *)&v22->__shared_owners_;
      do
        v24 = __ldxr(v23);
      while (__stxr(v24 + 1, v23));
    }
    v25 = 0;
    if (!v21)
      goto LABEL_30;
    v26 = *(NSObject **)(v16 + 40);
    if (!v26)
      goto LABEL_30;
    if (sec_protocol_metadata_peers_are_equal(v26, v21))
    {
      (*(void (**)(void))(*(_QWORD *)(v103 + 64) + 16))();
      _Block_release(*(const void **)(v103 + 64));
      *(_QWORD *)(v103 + 64) = 0;
      v25 = 1;
LABEL_30:
      if (!v22)
        goto LABEL_36;
      goto LABEL_31;
    }
    v25 = 0;
    if (!v22)
      goto LABEL_36;
LABEL_31:
    v27 = (unint64_t *)&v22->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
    if (!v5)
      goto LABEL_40;
LABEL_36:
    v29 = (unint64_t *)&v5->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
      if (v25)
      {
LABEL_41:
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v31 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)buf = 0;
          _os_log_debug_impl(&dword_183ECA000, v31, OS_LOG_TYPE_DEBUG, "[TLSCBQ] Used cache to satisfy trust callback", buf, 2u);
        }
        *((_BYTE *)this + 41) = 0;
        std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>::pop_front(*((_QWORD *)this + 6));
        TLSCallbackQueue::_invokeNextCallback(this);
        goto LABEL_48;
      }
    }
    else
    {
LABEL_40:
      if (v25)
        goto LABEL_41;
    }
    v14 = (_QWORD *)v14[1];
LABEL_48:
    v32 = (std::__shared_weak_count *)v119;
    if (!v119)
      goto LABEL_52;
    v33 = (unint64_t *)(v119 + 8);
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
      if ((v25 & 1) != 0)
        goto LABEL_137;
    }
    else
    {
LABEL_52:
      if ((v25 & 1) != 0)
        goto LABEL_137;
    }
  }
  v64 = *((_QWORD *)this + 3);
  v63 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
  if (v63)
  {
    v65 = (unint64_t *)&v63->__shared_weak_owners_;
    do
      v66 = __ldxr(v65);
    while (__stxr(v66 + 1, v65));
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v67 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl(&dword_183ECA000, v67, OS_LOG_TYPE_DEBUG, "[TLSCBQ] Need to invoke to satisfy trust callback", buf, 2u);
  }
  v68 = MEMORY[0x1E0C809B0];
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  v107 = 3321888768;
  v108 = ___ZN16TLSCallbackQueue14_doServerTrustENSt3__110shared_ptrI22TLSCallbackServerTrustEE_block_invoke;
  v109 = &__block_descriptor_64_e8_32c41_ZTSNSt3__18weak_ptrI16TLSCallbackQueueEE48c50_ZTSNSt3__110shared_ptrI22TLSCallbackServerTrustEE_e8_v12__0B8l;
  v110 = v64;
  v111 = v63;
  if (v63)
  {
    v69 = (unint64_t *)&v63->__shared_weak_owners_;
    do
      v70 = __ldxr(v69);
    while (__stxr(v70 + 1, v69));
  }
  v112 = (_QWORD *)v103;
  v113 = v5;
  if (v5)
  {
    v71 = (unint64_t *)&v5->__shared_owners_;
    do
      v72 = __ldxr(v71);
    while (__stxr(v72 + 1, v71));
  }
  v73 = *(_QWORD *)(v103 + 24);
  v74 = *(std::__shared_weak_count **)(v103 + 32);
  if (v74)
  {
    v75 = (unint64_t *)&v74->__shared_weak_owners_;
    do
      v76 = __ldxr(v75);
    while (__stxr(v76 + 1, v75));
  }
  v77 = *(_QWORD *)(v103 + 56);
  v118 = v68;
  v119 = 3321888768;
  v120 = ___ZN22TLSCallbackServerTrust14invokeCallbackEU13block_pointerFvbE_block_invoke;
  v121 = &unk_1E14F3020;
  v123 = v73;
  v124 = v74;
  if (v74)
  {
    v78 = (unint64_t *)&v74->__shared_weak_owners_;
    do
      v79 = __ldxr(v78);
    while (__stxr(v79 + 1, v78));
  }
  v122 = buf;
  (*(void (**)(uint64_t, uint64_t *))(v77 + 16))(v77, &v118);
  _Block_release(*(const void **)(v103 + 56));
  *(_QWORD *)(v103 + 56) = 0;
  if (v124)
    std::__shared_weak_count::__release_weak(v124);
  if (v74)
    std::__shared_weak_count::__release_weak(v74);
  v80 = v113;
  if (v113)
  {
    v81 = (unint64_t *)&v113->__shared_owners_;
    do
      v82 = __ldaxr(v81);
    while (__stlxr(v82 - 1, v81));
    if (!v82)
    {
      ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
      std::__shared_weak_count::__release_weak(v80);
    }
  }
  if (v111)
    std::__shared_weak_count::__release_weak(v111);
  if (v63)
    std::__shared_weak_count::__release_weak(v63);
LABEL_137:
  if (v5)
  {
    v83 = (unint64_t *)&v5->__shared_owners_;
    do
      v84 = __ldaxr(v83);
    while (__stlxr(v84 - 1, v83));
    if (!v84)
    {
LABEL_164:
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
LABEL_165:
  if (v105)
  {
    v98 = (unint64_t *)&v105->__shared_owners_;
    do
      v99 = __ldaxr(v98);
    while (__stlxr(v99 - 1, v98));
    if (!v99)
    {
      ((void (*)(std::__shared_weak_count *))v105->__on_zero_shared)(v105);
      std::__shared_weak_count::__release_weak(v105);
    }
  }
  if (v104)
  {
    v100 = (unint64_t *)&v104->__shared_owners_;
    do
      v101 = __ldaxr(v100);
    while (__stlxr(v101 - 1, v100));
    if (!v101)
    {
      ((void (*)(std::__shared_weak_count *))v104->__on_zero_shared)(v104);
      std::__shared_weak_count::__release_weak(v104);
    }
  }
}

void sub_183F17AAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,char a27)
{
  std::__shared_weak_count *v27;
  uint64_t v28;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v28);
  if (a22)
    std::__shared_weak_count::__release_weak(a22);
  if (v27)
    std::__shared_weak_count::__release_weak(v27);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a15);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>::pop_front(uint64_t a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v3;

  v2 = *(uint64_t **)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  v3 = *v2;
  *(_QWORD *)(v3 + 8) = v2[1];
  *(_QWORD *)v2[1] = v3;
  *(_QWORD *)(a1 + 16) = v1 - 1;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v2 + 4));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v2 + 2));
  operator delete(v2);
}

void ___ZN14NWIOConnection36_tlsProcessValidateServerTrust_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEEU13block_pointerFvbE_block_invoke(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  uint64_t v29[4];
  void *v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;

  v32 = 0;
  v33 = 0;
  v4 = (std::__shared_weak_count *)a1[5];
  if (v4 && (v33 = std::__shared_weak_count::lock(v4)) != 0 && (v5 = a1[4], (v32 = v5) != 0))
  {
    v6 = (std::__shared_weak_count *)a1[7];
    v30 = (void *)a1[6];
    v31 = v6;
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }
    v9 = a1[8];
    v10 = (std::__shared_weak_count *)a1[9];
    v29[2] = v9;
    v29[3] = (uint64_t)v10;
    if (v10)
    {
      v11 = (unint64_t *)&v10->__shared_owners_;
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }
    v29[0] = 0;
    v29[1] = 0;
    NWIOConnection::_tlsProcessValidateServerTrust_Invoke(v5, &v30, v9, (uint64_t)v10, v29, a2);
    if (v10)
    {
      v13 = (unint64_t *)&v10->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    v15 = v31;
    if (v31)
    {
      v16 = (unint64_t *)&v31->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      goto LABEL_27;
    }
  }
  else
  {
    v27 = 0;
    v28 = 0;
    v25 = 0;
    v26 = 0;
    (*(void (**)(uint64_t, _QWORD, uint64_t *, uint64_t *, uint64_t, uint64_t))(a2 + 16))(a2, 0, &v27, &v25, 1, 89);
    v18 = v26;
    if (v26)
    {
      v19 = (unint64_t *)&v26->__shared_owners_;
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    v15 = v28;
    if (v28)
    {
      v21 = (unint64_t *)&v28->__shared_owners_;
      do
        v17 = __ldaxr(v21);
      while (__stlxr(v17 - 1, v21));
LABEL_27:
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
  v22 = v33;
  if (v33)
  {
    v23 = (unint64_t *)&v33->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
}

void sub_183F17DC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  uint64_t v7;
  va_list va;
  uint64_t v9;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 48);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32);
  _Unwind_Resume(a1);
}

uint64_t ___ZN10HTTPEngine9_readBlobEjU13block_pointerFv13CFStreamErrorbE_block_invoke(_QWORD *a1, dispatch_data_t data, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;

  if (data)
  {
    v9 = a1[6];
    *(_QWORD *)(a1[7] + 168) += dispatch_data_get_size(data);
    HTTPEngine::_readBufferStore(v9, data, 0);
  }
  v10 = *(_QWORD *)(a1[5] + 8);
  *(_QWORD *)(v10 + 48) = a4;
  *(_QWORD *)(v10 + 56) = a5;
  return (*(uint64_t (**)(void))(a1[4] + 16))();
}

void HTTPEngine::_readBufferStore(uint64_t a1, dispatch_object_t object, int a3)
{
  NSObject *v4;
  NSObject *v5;
  dispatch_data_t concat;

  v4 = *(NSObject **)(a1 + 192);
  if (v4)
  {
    if (a3)
    {
      v5 = object;
      object = v4;
    }
    else
    {
      v5 = *(NSObject **)(a1 + 192);
    }
    concat = dispatch_data_create_concat(v5, object);
    dispatch_release(*(dispatch_object_t *)(a1 + 192));
    *(_QWORD *)(a1 + 192) = concat;
  }
  else
  {
    *(_QWORD *)(a1 + 192) = object;
    dispatch_retain(object);
  }
}

void NWIOConnection::_tlsProcessValidateServerTrust_Invoke(uint64_t a1, void **a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  int v16;
  uint64_t *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  unint64_t *v32;
  CFMutableArrayRef Mutable;
  std::__shared_weak_count *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t *v42;
  NSObject *v43;
  _BOOL4 v44;
  BOOL v45;
  const void *v46;
  CFTypeRef v47;
  uint64_t *v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  _QWORD *v55;
  unint64_t *v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  _QWORD v60[8];
  std::__shared_weak_count *v61;
  uint64_t v62;
  std::__shared_weak_count *v63;
  uint64_t v64;
  std::__shared_weak_count *v65;
  __int128 v66;
  _QWORD handler[5];
  __int128 v68;
  uint64_t v69;
  __n128 (*v70)(__n128 *, __n128 *);
  uint64_t (*v71)(uint64_t);
  void *v72;
  CFMutableArrayRef v73;
  std::__shared_weak_count *v74;
  uint64_t v75;
  std::__shared_weak_count *v76;
  uint64_t v77;
  std::__shared_weak_count *v78;
  uint64_t v79;
  std::__shared_weak_count *v80;
  uint64_t v81;
  std::__shared_weak_count *v82;
  uint64_t v83;
  std::__shared_weak_count *v84;
  uint64_t v85;
  std::__shared_weak_count *v86;
  uint64_t v87;
  uint64_t *v88;
  uint64_t v89;
  __n128 (*v90)(__n128 *, __n128 *);
  uint64_t (*v91)();
  void *v92;
  uint64_t v93;
  uint64_t v94;

  v87 = 0;
  v88 = &v87;
  v89 = 0x4012000000;
  v90 = __Block_byref_object_copy__160;
  v91 = __Block_byref_object_dispose__161;
  v93 = 0;
  v94 = 0;
  v92 = &unk_18422E08D;
  if ((*(_WORD *)(a1 + 248) & 0x60) == 0 && (*(_DWORD *)(a1 + 136) - 5) > 2)
  {
    if ((*(_WORD *)(a1 + 248) & 0x1000) != 0 && !*(_QWORD *)(a1 + 144))
    {
      v81 = 0;
      v82 = 0;
      v79 = 0;
      v80 = 0;
      (*(void (**)(uint64_t, _QWORD, uint64_t *, uint64_t *, _QWORD, _QWORD))(a6 + 16))(a6, 0, &v81, &v79, 0, 0);
      v29 = v80;
      if (v80)
      {
        p_shared_owners = (unint64_t *)&v80->__shared_owners_;
        do
          v31 = __ldaxr(p_shared_owners);
        while (__stlxr(v31 - 1, p_shared_owners));
        if (!v31)
        {
          ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
          std::__shared_weak_count::__release_weak(v29);
        }
      }
      v11 = v82;
      if (!v82)
        goto LABEL_13;
      v32 = (unint64_t *)&v82->__shared_owners_;
      do
        v13 = __ldaxr(v32);
      while (__stlxr(v13 - 1, v32));
LABEL_11:
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
      goto LABEL_13;
    }
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(a1 + 448), a3, a4);
    if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EDCFAC60))
    {
      v16 = SecTrustSetPinningPolicyName();
      if (v16)
      {
        v17 = v88;
        v88[6] = (int)*MEMORY[0x1E0C9B298];
        *((_DWORD *)v17 + 14) = v16;
        v77 = 0;
        v78 = 0;
        v75 = 0;
        v76 = 0;
        (*(void (**)(uint64_t, _QWORD, uint64_t *, uint64_t *))(a6 + 16))(a6, 0, &v77, &v75);
        v18 = v76;
        if (v76)
        {
          v19 = (unint64_t *)&v76->__shared_owners_;
          do
            v20 = __ldaxr(v19);
          while (__stlxr(v20 - 1, v19));
          if (!v20)
          {
            ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
            std::__shared_weak_count::__release_weak(v18);
          }
        }
        v11 = v78;
        if (!v78)
          goto LABEL_13;
        v21 = (unint64_t *)&v78->__shared_owners_;
        do
          v13 = __ldaxr(v21);
        while (__stlxr(v13 - 1, v21));
        goto LABEL_11;
      }
    }
    NWIOConnection::_tlsTrustDataForTrust((NWIOConnection *)&v68, a1);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 464, &v68);
    v22 = (std::__shared_weak_count *)*((_QWORD *)&v68 + 1);
    if (*((_QWORD *)&v68 + 1))
    {
      v23 = (unint64_t *)(*((_QWORD *)&v68 + 1) + 8);
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    v25 = MEMORY[0x1E0C809B0];
    if (*a5)
    {
      std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(a1 + 480), *a5, a5[1]);
      goto LABEL_34;
    }
    if (!*a2)
    {
LABEL_34:
      -[__CFN_ConnectionMetrics tlsMetadataReceived:](*(_WORD **)(a1 + 200), *a2);
      if (!*(_QWORD *)(a1 + 144))
        __assert_rtn("_tlsProcessValidateServerTrust_Invoke", "NWIOConnection.cpp", 5421, "_establishmentDelegate");
      v68 = 0uLL;
      v26 = *(std::__shared_weak_count **)(a1 + 264);
      if (v26)
      {
        v27 = std::__shared_weak_count::lock(v26);
        *((_QWORD *)&v68 + 1) = v27;
        if (v27)
        {
          v28 = *(_QWORD *)(a1 + 256);
          *(_QWORD *)&v68 = v28;
LABEL_52:
          v35 = *(_QWORD *)(a1 + 144);
          v36 = *(_QWORD *)(a1 + 448);
          v60[0] = v25;
          v60[1] = 3321888768;
          v60[2] = ___ZN14NWIOConnection37_tlsProcessValidateServerTrust_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEENS1_IK9__CFArrayEEU13block_pointerFvbS6_S9_13CFStreamErrorE_block_invoke_2;
          v60[3] = &unk_1E14F4228;
          v60[6] = a1;
          v60[7] = v28;
          v61 = v27;
          if (v27)
          {
            v37 = (unint64_t *)&v27->__shared_owners_;
            do
              v38 = __ldxr(v37);
            while (__stxr(v38 + 1, v37));
          }
          v60[4] = a6;
          v60[5] = &v87;
          (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v35 + 32))(v35, v36, v60);
          v39 = v61;
          if (v61)
          {
            v40 = (unint64_t *)&v61->__shared_owners_;
            do
              v41 = __ldaxr(v40);
            while (__stlxr(v41 - 1, v40));
            if (!v41)
            {
              ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
              std::__shared_weak_count::__release_weak(v39);
            }
          }
          v11 = (std::__shared_weak_count *)*((_QWORD *)&v68 + 1);
          if (!*((_QWORD *)&v68 + 1))
            goto LABEL_13;
          v42 = (unint64_t *)(*((_QWORD *)&v68 + 1) + 8);
          do
            v13 = __ldaxr(v42);
          while (__stlxr(v13 - 1, v42));
          goto LABEL_11;
        }
      }
      else
      {
        v27 = 0;
      }
      v28 = 0;
      goto LABEL_52;
    }
    *(_QWORD *)&v68 = 0;
    *((_QWORD *)&v68 + 1) = &v68;
    v69 = 0x4012000000;
    v70 = __Block_byref_object_copy__147;
    v71 = __Block_byref_object_dispose__148;
    v72 = &unk_18422E08D;
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    v73 = Mutable;
    if (Mutable)
    {
      v34 = (std::__shared_weak_count *)operator new();
      v34->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1978;
      v34->__shared_owners_ = 0;
      v34->__shared_weak_owners_ = 0;
      v34[1].__vftable = (std::__shared_weak_count_vtbl *)Mutable;
    }
    else
    {
      v34 = 0;
    }
    v74 = v34;
    v43 = *a2;
    handler[0] = v25;
    handler[1] = 3221225472;
    handler[2] = ___ZN14NWIOConnection37_tlsProcessValidateServerTrust_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEENS1_IK9__CFArrayEEU13block_pointerFvbS6_S9_13CFStreamErrorE_block_invoke;
    handler[3] = &unk_1E14F7F08;
    handler[4] = &v68;
    v44 = sec_protocol_metadata_access_peer_certificate_chain(v43, handler);
    v45 = v44;
    if (v44)
    {
      v46 = *(const void **)(*((_QWORD *)&v68 + 1) + 48);
      if (v46)
        v47 = CFRetain(v46);
      else
        v47 = 0;
      *(_QWORD *)&v66 = v47;
      v55 = (_QWORD *)operator new();
      *v55 = &off_1E14F1AC8;
      v55[1] = 0;
      v55[2] = 0;
      v55[3] = v47;
      *((_QWORD *)&v66 + 1) = v55;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 480, &v66);
      v52 = (std::__shared_weak_count *)*((_QWORD *)&v66 + 1);
      if (!*((_QWORD *)&v66 + 1))
        goto LABEL_83;
      v56 = (unint64_t *)(*((_QWORD *)&v66 + 1) + 8);
      do
        v54 = __ldaxr(v56);
      while (__stlxr(v54 - 1, v56));
    }
    else
    {
      v48 = v88;
      v88[6] = (int)*MEMORY[0x1E0C9B298];
      *((_DWORD *)v48 + 14) = -9863;
      v64 = 0;
      v65 = 0;
      v62 = 0;
      v63 = 0;
      (*(void (**)(uint64_t, _QWORD, uint64_t *, uint64_t *))(a6 + 16))(a6, 0, &v64, &v62);
      v49 = v63;
      if (v63)
      {
        v50 = (unint64_t *)&v63->__shared_owners_;
        do
          v51 = __ldaxr(v50);
        while (__stlxr(v51 - 1, v50));
        if (!v51)
        {
          ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
          std::__shared_weak_count::__release_weak(v49);
        }
      }
      v52 = v65;
      if (!v65)
      {
LABEL_83:
        _Block_object_dispose(&v68, 8);
        v57 = v74;
        if (v74)
        {
          v58 = (unint64_t *)&v74->__shared_owners_;
          do
            v59 = __ldaxr(v58);
          while (__stlxr(v59 - 1, v58));
          if (!v59)
          {
            ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
            std::__shared_weak_count::__release_weak(v57);
          }
        }
        if (!v45)
          goto LABEL_13;
        goto LABEL_34;
      }
      v53 = (unint64_t *)&v65->__shared_owners_;
      do
        v54 = __ldaxr(v53);
      while (__stlxr(v54 - 1, v53));
    }
    if (!v54)
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
    goto LABEL_83;
  }
  v93 = 1;
  LODWORD(v94) = 89;
  v85 = 0;
  v86 = 0;
  v83 = 0;
  v84 = 0;
  (*(void (**)(uint64_t, _QWORD, uint64_t *, uint64_t *, uint64_t, uint64_t))(a6 + 16))(a6, 0, &v85, &v83, 1, v94);
  v8 = v84;
  if (v84)
  {
    v9 = (unint64_t *)&v84->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v86;
  if (v86)
  {
    v12 = (unint64_t *)&v86->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    goto LABEL_11;
  }
LABEL_13:
  _Block_object_dispose(&v87, 8);
}

void sub_183F18590(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;
  uint64_t v30;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a18);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a20);
  _Block_object_dispose(&a29, 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v29 + 48);
  _Block_object_dispose((const void *)(v30 - 144), 8);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'Tube::needServerTrust(uint64_t a1, const void *a2, void *a3)
{
  Tube::needServerTrust((int *)(a1 - 40), a2, a3);
}

{
  Tube::needServerTrust((int *)(a1 - 32), a2, a3);
}

void std::__shared_ptr_pointer<TransportConnection::ConnectionEstablishmentDelegate *,Deleter_CustomBlock,std::allocator<TransportConnection::ConnectionEstablishmentDelegate>>::__on_zero_shared(uint64_t a1)
{
  Deleter_CustomBlock::operator()((const void **)(a1 + 32));
}

void Tube::needServerTrust(int *a1, CFTypeRef cf, void *aBlock)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  uint64_t v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  _QWORD v20[6];
  std::__shared_weak_count *v21;
  _QWORD aBlocka[6];
  std::__shared_weak_count *v23;

  if (*((_QWORD *)a1 + 32))
    __assert_rtn("needServerTrust", "Tube.cpp", 1888, "!fSSLTrust");
  *((_QWORD *)a1 + 32) = cf;
  if (cf)
    CFRetain(cf);
  *((_QWORD *)a1 + 39) = _Block_copy(aBlock);
  if (a1[55] < 10)
  {
    a1[55] = 7;
    v5 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a1 + 14) + 80))(*((_QWORD *)a1 + 14));
    if (v5)
      v6 = v5 - 176;
    else
      v6 = 0;
    if (v5)
      v7 = v6 + 120;
    else
      v7 = 0;
    CFRetain((CFTypeRef)(v6 - 16));
    v8 = MEMORY[0x1E0C809B0];
    aBlocka[0] = MEMORY[0x1E0C809B0];
    aBlocka[1] = 3221225472;
    aBlocka[2] = ___ZN4Tube24_onqueue_needServerTrustEv_block_invoke;
    aBlocka[3] = &__block_descriptor_40_e5_v8__0l;
    aBlocka[4] = v6;
    v9 = _Block_copy(aBlocka);
    aBlocka[5] = v7;
    v10 = (std::__shared_weak_count *)operator new();
    v10->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    v10->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1B00;
    v10->__shared_weak_owners_ = 0;
    v10[1].__vftable = (std::__shared_weak_count_vtbl *)v7;
    v10[1].__shared_owners_ = (uint64_t)v9;
    v10[1].__shared_weak_owners_ = 0;
    v23 = v10;
    (*(void (**)(int *))(*(_QWORD *)a1 + 40))(a1);
    (*(void (**)(int *))(*(_QWORD *)a1 + 40))(a1);
    v12 = *(_QWORD *)(v6 + 24);
    v20[0] = v8;
    v20[1] = 3321888768;
    v20[2] = ___ZN4Tube24_onqueue_needServerTrustEv_block_invoke_2;
    v20[3] = &__block_descriptor_56_e8_40c82_ZTSNSt3__110shared_ptrIN19TransportConnection31ConnectionEstablishmentDelegateEEE_e5_v8__0l;
    v20[4] = a1;
    v20[5] = v7;
    v21 = v10;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v12 + 96))(v12, v20);
    v14 = v21;
    if (v21)
    {
      v15 = (unint64_t *)&v21->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    v17 = v23;
    if (v23)
    {
      v18 = (unint64_t *)&v23->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
  }
  else
  {
    Tube::_onqueue_complete_needServerTrust((Tube *)a1, 0, 1);
  }
}

void sub_183F188C0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 80);
  _Unwind_Resume(a1);
}

CFHashCode URLProtectionSpace::initialize(uint64_t a1, const __CFString *a2, int a3, int a4, const __CFString *a5, int a6)
{
  const void *v12;
  const __CFAllocator *v13;
  CFStringRef Copy;
  const __CFAllocator *v15;

  v12 = (const void *)(a1 - 16);
  CFGetAllocator((CFTypeRef)(a1 - 16));
  if (a2)
  {
    v13 = CFGetAllocator(a2);
    Copy = CFStringCreateCopy(v13, a2);
  }
  else
  {
    Copy = 0;
  }
  *(_QWORD *)(a1 + 32) = Copy;
  *(_DWORD *)(a1 + 40) = a3;
  *(_DWORD *)(a1 + 44) = a4;
  if (a5 && (a4 - 9) <= 0xFFFFFFFB)
  {
    v15 = CFGetAllocator(v12);
    *(_QWORD *)(a1 + 48) = CFStringCreateCopy(v15, a5);
  }
  *(_DWORD *)(a1 + 56) = a6;
  return URLProtectionSpace::calcHash((URLProtectionSpace *)a1);
}

void HTTPTransaction::~HTTPTransaction(HTTPTransaction *this)
{
  uint64_t v2;
  const void *v3;
  const void *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  const void *v8;
  NSObject *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;

  *(_QWORD *)this = &off_1E14E7948;
  *((_QWORD *)this + 3) = &unk_1E14E7A30;
  v2 = *((_QWORD *)this + 26);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
    *((_QWORD *)this + 26) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 30);
  if (v3)
  {
    _Block_release(v3);
    *((_QWORD *)this + 30) = 0;
  }
  v4 = (const void *)*((_QWORD *)this + 28);
  if (v4)
  {
    _Block_release(v4);
    *((_QWORD *)this + 28) = 0;
  }
  v5 = *((_QWORD *)this + 29);
  if (v5)
  {
    dispatch_release(v5);
    *((_QWORD *)this + 29) = 0;
  }
  v6 = *((_QWORD *)this + 24);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 64))(v6);
  v7 = *((_QWORD *)this + 27);
  if (v7)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 48))(v7);
    *((_QWORD *)this + 27) = 0;
  }
  v8 = (const void *)*((_QWORD *)this + 19);
  if (v8)
  {
    _Block_release(v8);
    *((_QWORD *)this + 19) = 0;
  }
  v9 = *((_QWORD *)this + 9);
  if (v9)
  {
    dispatch_release(v9);
    *((_QWORD *)this + 9) = 0;
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 280);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 192);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 176);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 160);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 136);
  v10 = *((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  v11 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
  if (v11)
    std::__shared_weak_count::__release_weak(v11);
  v12 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
  *((_QWORD *)this + 3) = &off_1E14E5838;
  v13 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v13)
    std::__shared_weak_count::__release_weak(v13);
}

{
  HTTPTransaction::~HTTPTransaction(this);
  JUMPOUT(0x186DB748CLL);
}

void sub_183F18AC4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 35));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 24));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 22));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 20));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 17));
  v3 = v1[13];
  v1[13] = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = (std::__shared_weak_count *)v1[8];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  v5 = (std::__shared_weak_count *)v1[6];
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
  v1[3] = &off_1E14E5838;
  v6 = (std::__shared_weak_count *)v1[2];
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
  _Unwind_Resume(a1);
}

void URLResponse::freshnessLifetimeForResponse(URLResponse *this)
{
  HTTPResponse *fHTTP;
  int v2;
  int v3;
  HTTPResponse *v5;
  __int16 v6;
  uint64_t v7;
  double v8;
  const __CFString *v9;
  HTTPResponse *v10;
  int v11;
  unsigned int v12;
  const __CFString *v13;
  double LastModifiedDate;
  double CreationTime;
  unsigned __int8 v16;

  fHTTP = this->fHTTP;
  v2 = *(unsigned __int16 *)((char *)fHTTP + 297);
  v3 = v2 | (*((unsigned __int8 *)fHTTP + 299) << 16);
  if ((v2 & 0x800) == 0)
  {
    *((_BYTE *)fHTTP + 299) = BYTE2(v3);
    *(_WORD *)((char *)fHTTP + 297) = v3 | 0x800;
    v5 = this->fHTTP;
    v6 = *(_WORD *)((char *)v5 + 297);
    if ((v6 & 0x80) == 0)
    {
      URLResponse::parseCacheControl(this);
      v5 = this->fHTTP;
      LOBYTE(v6) = *((_BYTE *)v5 + 297);
    }
    if ((v6 & 1) != 0)
    {
      v8 = 0.0;
    }
    else
    {
      v7 = *((_QWORD *)v5 + 42);
      if (v7 == -1)
      {
        if ((v6 & 0x20) == 0)
        {
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
          v9 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)v5, 0x1260F2FEu);
          *(_WORD *)((char *)this->fHTTP + 297) |= 0x20u;
          v10 = this->fHTTP;
          v11 = *(unsigned __int16 *)((char *)v10 + 297);
          v12 = v11 & 0xFFFFFFFD | (*((unsigned __int8 *)v10 + 299) << 16);
          *(_WORD *)((char *)v10 + 297) = v11 & 0xFFFD;
          *((_BYTE *)v10 + 299) = BYTE2(v12);
          v5 = this->fHTTP;
          if (v9)
          {
            v13 = v9;
            v16 = 0;
            *((double *)v5 + 39) = dateFromString(v9, &v16);
            if (v16)
              *(_WORD *)((char *)this->fHTTP + 297) |= 2u;
            CFRelease(v13);
            v5 = this->fHTTP;
          }
        }
        if ((*(_WORD *)((char *)v5 + 297) & 2) != 0)
        {
          CreationTime = URLResponse::getCreationTime(this);
          v5 = this->fHTTP;
          v8 = *((double *)v5 + 39) - CreationTime;
        }
        else
        {
          LastModifiedDate = URLResponse::getLastModifiedDate(this);
          v5 = this->fHTTP;
          v8 = 0.0;
          if ((*(_WORD *)((char *)v5 + 297) & 4) != 0)
          {
            v8 = (URLResponse::getCreationTime(this) - LastModifiedDate) * 0.1;
            v5 = this->fHTTP;
          }
        }
      }
      else
      {
        v8 = (double)v7;
      }
    }
    if (v8 < 1.0)
      v8 = 0.0;
    *((double *)v5 + 40) = v8;
  }
}

void URLResponse::parseCacheControl(URLResponse *this)
{
  URLResponse *v1;
  HTTPResponse *fHTTP;
  const __CFString *v3;
  HTTPResponse *v4;
  const __CFString *v5;
  CFIndex Length;
  const __CFCharacterSet *Predefined;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  CFIndex v10;
  _BOOL4 v11;
  int v12;
  CFIndex v13;
  CFIndex v14;
  uint64_t v15;
  int64_t v16;
  uint64_t v17;
  CFIndex v18;
  UniChar v19;
  _BOOL4 v20;
  int v21;
  int IsCharacterMember;
  int64_t v23;
  CFIndex v24;
  _BOOL4 v25;
  int64_t v26;
  uint64_t v27;
  CFIndex v28;
  int64_t v29;
  CFIndex v30;
  BOOL v31;
  CFIndex v32;
  HTTPResponse *v33;
  HTTPResponse *v34;
  CFIndex i;
  CFIndex v36;
  UniChar *v37;
  CFIndex v38;
  UniChar v39;
  UniChar CharacterAtIndex;
  const __CFString *v41;
  const __CFString *v42;
  HTTPResponse *v43;
  int64_t v44;
  CFIndex v45;
  CFStringRef v46;
  const __CFString *v47;
  const __CFCharacterSet *v48;
  CFIndex v49;
  CFIndex v50;
  CFIndex v51;
  UniChar v52;
  CFIndex v53;
  const __CFAllocator *alloc;
  const __CFString *v55;
  URLResponse *v56;
  int64_t v57;
  CFRange result;
  UniChar buffer[64];
  CFStringRef theString;
  UniChar *v61;
  const char *v62;
  uint64_t v63;
  CFIndex v64;
  int64_t v65;
  int64_t v66;
  CFRange v67;
  CFRange v68;
  CFRange v69;
  CFRange v70;
  CFRange v71;
  CFRange v72;
  CFRange v73;
  CFRange v74;

  v1 = this;
  fHTTP = this->fHTTP;
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v3 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)fHTTP, 0x1181B2A6u);
  *(_WORD *)((char *)v1->fHTTP + 297) |= 0x80u;
  *(_WORD *)((char *)v1->fHTTP + 297) &= ~1u;
  v4 = v1->fHTTP;
  *((_QWORD *)v4 + 42) = -1;
  if (v3)
  {
    v5 = v3;
    alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Length = CFStringGetLength(v3);
    Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
    theString = v5;
    v63 = 0;
    v64 = Length;
    v57 = Length;
    CharactersPtr = CFStringGetCharactersPtr(v5);
    CStringPtr = 0;
    v61 = (UniChar *)CharactersPtr;
    if (!CharactersPtr)
      CStringPtr = CFStringGetCStringPtr(v5, 0x600u);
    v10 = 0;
    v65 = 0;
    v66 = 0;
    v62 = CStringPtr;
    v55 = v5;
    v56 = v1;
    while (v10 < v57)
    {
      v11 = 0;
      v12 = 0;
      v13 = -v10;
      v14 = v10 + 64;
      v15 = -1;
      v16 = v10;
      do
      {
        if ((unint64_t)v16 >= 4)
          v17 = 4;
        else
          v17 = v16;
        if (v16 < 0 || (v18 = v64, v64 <= v16))
        {
          v19 = 0;
          v20 = !v11;
        }
        else
        {
          if (v61)
          {
            v19 = v61[v16 + v63];
          }
          else if (v62)
          {
            v19 = v62[v63 + v16];
          }
          else
          {
            if (v66 <= v16 || (v26 = v65, v65 > v16))
            {
              v27 = v17 + v13;
              v28 = v14 - v17;
              v29 = v16 - v17;
              v30 = v29 + 64;
              if (v29 + 64 >= v64)
                v30 = v64;
              v65 = v29;
              v66 = v30;
              if (v64 >= v28)
                v18 = v28;
              v67.length = v18 + v27;
              v67.location = v29 + v63;
              CFStringGetCharacters(theString, v67, buffer);
              v26 = v65;
            }
            v19 = buffer[v16 - v26];
          }
          v20 = !v11;
          if (!v11 && v19 == 44)
            goto LABEL_44;
        }
        v21 = v19;
        IsCharacterMember = CFCharacterSetIsCharacterMember(Predefined, v19);
        if (v12)
          v23 = v16;
        else
          v23 = v15;
        if (v12)
          v24 = v10;
        else
          v24 = v16;
        if (v21 == 34)
          v25 = v20;
        else
          v25 = v11;
        if (!IsCharacterMember)
        {
          v15 = v23;
          v12 = 1;
          v11 = v25;
          v10 = v24;
        }
        ++v16;
        --v13;
        ++v14;
      }
      while (v57 != v16);
      v16 = v57;
LABEL_44:
      v31 = __CFADD__(v15, 1);
      v32 = v15 + 1;
      v5 = v55;
      v1 = v56;
      if (v31)
        goto LABEL_46;
LABEL_47:
      v33 = v1->fHTTP;
      if ((*(_WORD *)((char *)v33 + 297) & 1) == 0)
      {
        v69.location = v10;
        v69.length = v32 - v10;
        if (CFStringFindWithOptions(v5, (CFStringRef)&unk_1EDCFDE40, v69, 9uLL, 0)
          || (v70.location = v10,
              v70.length = v32 - v10,
              CFStringFindWithOptions(v5, CFSTR("must-revalidate"), v70, 9uLL, 0)))
        {
          *(_WORD *)((char *)v1->fHTTP + 297) |= 1u;
          goto LABEL_53;
        }
        v33 = v1->fHTTP;
      }
      if (*((_QWORD *)v33 + 42) == -1)
      {
        v71.location = v10;
        v71.length = v32 - v10;
        if (CFStringFindWithOptions(v5, (CFStringRef)&unk_1EDCFD270, v71, 9uLL, &result))
        {
          for (i = result.length + result.location; ; ++i)
          {
            if (i >= v32)
              goto LABEL_53;
            if (i < 0 || (v36 = v64, v64 <= i))
            {
              v39 = 0;
              goto LABEL_67;
            }
            v37 = v61;
            if (v61)
              break;
            if (!v62)
            {
              if (v66 <= i || (v44 = v65, v65 > i))
              {
                v45 = i - 4;
                if ((unint64_t)i < 4)
                  v45 = 0;
                if (v45 + 64 < v64)
                  v36 = v45 + 64;
                v65 = v45;
                v66 = v36;
                v68.location = v63 + v45;
                v68.length = v36 - v45;
                CFStringGetCharacters(theString, v68, buffer);
                v44 = v65;
              }
              v38 = i - v44;
              v37 = buffer;
              goto LABEL_65;
            }
            v39 = v62[v63 + i];
LABEL_71:
            if (v39 == 61)
            {
              while (++i < v32)
              {
                CharacterAtIndex = CFStringGetCharacterAtIndex(v5, i);
                if (!CFCharacterSetIsCharacterMember(Predefined, CharacterAtIndex))
                {
                  v72.length = v32 - i;
                  v72.location = i;
                  v41 = CFStringCreateWithSubstring(alloc, v5, v72);
                  if (v41)
                  {
                    v42 = v41;
                    v43 = v1->fHTTP;
                    *((_QWORD *)v43 + 42) = CFStringGetIntValue(v41);
                    CFRelease(v42);
                  }
                  goto LABEL_68;
                }
              }
              continue;
            }
LABEL_67:
            if (!CFCharacterSetIsCharacterMember(Predefined, v39))
              goto LABEL_53;
LABEL_68:
            ;
          }
          v38 = v63 + i;
LABEL_65:
          v39 = v37[v38];
          goto LABEL_71;
        }
      }
LABEL_53:
      if (v16 == v57 || (v34 = v1->fHTTP, *((_QWORD *)v34 + 42) != -1) && (*(_WORD *)((char *)v34 + 297) & 1) != 0)
      {
        CFRelease(v5);
        v4 = v1->fHTTP;
        goto LABEL_85;
      }
      v10 = v16 + 1;
    }
    v16 = v10;
LABEL_46:
    v32 = v16;
    goto LABEL_47;
  }
LABEL_85:
  if ((*(_WORD *)((char *)v4 + 297) & 1) == 0)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v46 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)v4, 0x1320D33Fu);
    if (v46)
    {
      v47 = v46;
      v48 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
      v49 = CFStringGetLength(v47);
      if (v49 < 1)
      {
        v51 = 0;
      }
      else
      {
        v50 = v49;
        v51 = 0;
        while (1)
        {
          v52 = CFStringGetCharacterAtIndex(v47, v51);
          if (!CFCharacterSetIsCharacterMember(v48, v52))
            break;
          if (v50 == ++v51)
          {
            v51 = v50;
            break;
          }
        }
      }
      v53 = CFStringGetLength(v47) - v51;
      v73.location = v51;
      v73.length = v53;
      if (CFStringFindWithOptions(v47, (CFStringRef)&unk_1EDCFDE40, v73, 9uLL, 0)
        || (v74.location = v51, v74.length = v53, CFStringFindWithOptions(v47, CFSTR("must-revalidate"), v74, 9uLL, 0)))
      {
        *(_WORD *)((char *)v1->fHTTP + 297) |= 1u;
      }
      CFRelease(v47);
    }
  }
}

double URLResponse::getCreationTime(URLResponse *this)
{
  HTTPResponse *fHTTP;
  const __CFString *v3;
  HTTPResponse *v4;
  int v5;
  unsigned int v6;
  const __CFString *v7;
  double *p_fCreationTime;
  unsigned __int8 v10;

  fHTTP = this->fHTTP;
  if (!fHTTP)
    goto LABEL_10;
  if ((*(_WORD *)((char *)fHTTP + 297) & 0x10) == 0)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v3 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)fHTTP, 0x121092EBu);
    v4 = this->fHTTP;
    v5 = *(unsigned __int16 *)((char *)v4 + 297);
    v6 = v5 & 0xFFFFFFF7 | (*((unsigned __int8 *)v4 + 299) << 16);
    *(_WORD *)((char *)v4 + 297) = v5 & 0xFFF7;
    *((_BYTE *)v4 + 299) = BYTE2(v6);
    *(_WORD *)((char *)this->fHTTP + 297) |= 0x10u;
    fHTTP = this->fHTTP;
    if (v3)
    {
      v7 = v3;
      v10 = 0;
      *((double *)fHTTP + 41) = dateFromString(v3, &v10);
      if (v10)
        *(_WORD *)((char *)this->fHTTP + 297) |= 8u;
      CFRelease(v7);
      fHTTP = this->fHTTP;
    }
  }
  if ((*(_WORD *)((char *)fHTTP + 297) & 8) != 0)
    p_fCreationTime = (double *)((char *)fHTTP + 328);
  else
LABEL_10:
    p_fCreationTime = &this->fCreationTime;
  return *p_fCreationTime;
}

void HTTP2Stream::bufferDataAvailable(uint64_t a1, dispatch_object_t object)
{
  NSObject *v4;
  uint64_t v6;

  dispatch_retain(object);
  v4 = *(NSObject **)(a1 + 168);
  if (v4)
  {
    *(_QWORD *)(a1 + 168) = dispatch_data_create_concat(*(dispatch_data_t *)(a1 + 168), object);
    dispatch_release(v4);
    dispatch_release(object);
  }
  else
  {
    *(_QWORD *)(a1 + 168) = object;
  }
  if (*(_DWORD *)(a1 + 56) == 1
    && (*(_QWORD *)(a1 + 104) <= *(_QWORD *)(a1 + 112) / 2 || *(_QWORD *)(a1 + 112) - *(_QWORD *)(a1 + 104) >= 500001))
  {
    v6 = *(_QWORD *)(a1 + 32);
    if (v6 && *(_DWORD *)(v6 + 40))
      HTTP2Stream::_onqueue_sendWindowUpdate((HTTP2Stream *)a1);
    else
      *(_DWORD *)(a1 + 200) |= 4u;
  }
  HTTP2Stream::_onqueue_notifyDataAvailable((HTTP2Stream *)a1);
}

void HTTPRequestMessage::HTTPRequestMessage(HTTPRequestMessage *this, const HTTPRequestMessage *a2, const __CFURL *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  CFAllocatorRef v8;
  const void *v9;
  CFTypeRef v10;

  HTTPMessage::HTTPMessage(this, a2);
  *v6 = &off_1E14E96D8;
  v6[1] = &unk_1E14E9758;
  v6[2] = &unk_1E14E9778;
  v6[16] = &unk_1E14E97A8;
  v7 = v6 + 16;
  v8 = CFGetAllocator(v6 - 2);
  v9 = (const void *)*((_QWORD *)a2 + 19);
  if (v9)
    v10 = CFRetain(v9);
  else
    v10 = 0;
  HTTPRequestParserClient::HTTPRequestParserClient(v7, v8, v10, 0, a3);
  if (v10)
    CFRelease(v10);
  *(_QWORD *)this = &off_1E14E96D8;
  *((_QWORD *)this + 1) = &unk_1E14E9758;
  *((_QWORD *)this + 2) = &unk_1E14E9778;
  *((_QWORD *)this + 16) = &unk_1E14E97A8;
}

void sub_183F19638(_Unwind_Exception *a1)
{
  HTTPMessage *v1;

  HTTPMessage::~HTTPMessage(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN24HTTPConnectionCacheEntry10ingestTubeEP4Tubeb_block_invoke(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (result)
  {
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)result + 56))(result, 0);
    v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
  return result;
}

uint64_t `non-virtual thunk to'HTTPProtocol::useTube(HTTPProtocol *this, GlueTube *a2)
{
  return HTTPProtocol::useTube((HTTPProtocol *)((char *)this - 176), a2);
}

void HTTPConnectionCacheEntry::connCompletedResponse(_QWORD *a1, uint64_t *a2)
{
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  _QWORD v22[6];
  std::__shared_weak_count *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;

  v26 = 0;
  v27 = 0;
  v4 = (std::__shared_weak_count *)a1[6];
  if (v4 && (v4 = std::__shared_weak_count::lock(v4), (v27 = v4) != 0))
  {
    v5 = a1[5];
    v26 = v5;
  }
  else
  {
    v5 = 0;
  }
  v6 = a1[8];
  v22[0] = MEMORY[0x1E0C809B0];
  v22[1] = 3321888768;
  v22[2] = ___ZN24HTTPConnectionCacheEntry21connCompletedResponseENSt3__110shared_ptrI14HTTPConnectionEE_block_invoke;
  v22[3] = &__block_descriptor_72_e8_40c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE56c52_ZTSNSt3__110shared_ptrI24HTTPConnectionCacheEntryEE_e5_v8__0l;
  v8 = *a2;
  v7 = (std::__shared_weak_count *)a2[1];
  v22[4] = a1;
  v22[5] = v8;
  v23 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v24 = v5;
  v25 = v4;
  if (v4)
  {
    v11 = (unint64_t *)&v4->__shared_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v22);
  v13 = v25;
  if (v25)
  {
    v14 = (unint64_t *)&v25->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = v23;
  if (v23)
  {
    v17 = (unint64_t *)&v23->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = v27;
  if (v27)
  {
    v20 = (unint64_t *)&v27->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
}

void sub_183F1985C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3 - 48);
  _Unwind_Resume(a1);
}

CFHashCode URLProtectionSpace::calcHash(URLProtectionSpace *this)
{
  const void *v2;
  CFHashCode v3;
  CFHashCode result;

  *((_QWORD *)this + 3) = 0;
  v2 = (const void *)*((_QWORD *)this + 4);
  if (v2)
    v3 = *((_QWORD *)this + 3) ^ CFHash(v2);
  else
    v3 = 0;
  *((_QWORD *)this + 3) = v3 ^ *((int *)this + 10) ^ *((int *)this + 11);
  result = *((_QWORD *)this + 6);
  if (result)
  {
    result = CFHash((CFTypeRef)result);
    *((_QWORD *)this + 3) ^= result;
  }
  return result;
}

uint64_t NWIOConnection::enableTLS(NWIOConnection *this, int a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;

  v2 = *((unsigned __int16 *)this + 124) | (*((unsigned __int8 *)this + 250) << 16);
  if (a2)
  {
    if ((*((_WORD *)this + 124) & 0x200) == 0)
    {
      v3 = *((_DWORD *)this + 34);
      if (v3 <= 4)
      {
        *((_BYTE *)this + 250) = BYTE2(v2);
        *((_WORD *)this + 124) = v2 | 0x200;
        if (v3 == 4)
          NWIOConnection::_startTLS(this);
        return 1;
      }
    }
  }
  else if ((*((_WORD *)this + 124) & 0xA00) == 0x200)
  {
    v4 = *((_WORD *)this + 124) & 0xFDFF | (*((unsigned __int8 *)this + 250) << 16);
    *((_WORD *)this + 124) &= ~0x200u;
    *((_BYTE *)this + 250) = BYTE2(v4);
    v5 = *((_QWORD *)this + 18);
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 64))(v5);
    return 1;
  }
  return 0;
}

void ___ZN10HTTPEngine18_writeHeadersStartEv_block_invoke_3(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *(_QWORD *)(a1 + 40);
  if (a3)
  {
    *(_QWORD *)(v4 + 280) -= *(_QWORD *)(a1 + 48);
    HTTPEngine::_updateBytesTransferred((HTTPEngine *)v4);
    v5 = *(_QWORD *)(v4 + 336);
    if (v5)
      *(_QWORD *)(v5 + 96) -= *(_QWORD *)(a1 + 48);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48) = 4;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 56) = -4;
  }
  dispatch_release(*(dispatch_object_t *)(v4 + 304));
  *(_QWORD *)(v4 + 304) = 0;
  *(_DWORD *)(v4 + 32) |= 0x800000u;
  HTTPEngine::_writeHeadersFinish(*(HTTPEngine **)(a1 + 56), *(CFStreamError *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48));
}

void ___ZN10HTTPEngine18_readHeadersDoReadEv_block_invoke(uint64_t a1, CFStreamError a2, int a3)
{
  HTTPEngine::_readHeadersDoParse(*(HTTPEngine **)(a1 + 32), a2, a3);
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::getProxy(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 160))(*((_QWORD *)this + 1));
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::canScheduleAndOpenWithHandlerAsync(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 80))(*((_QWORD *)this + 1));
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::setBodyStreamBeforeOpening(HTTPTransactionWrapper *this, __CFReadStream *a2)
{
  return (*(uint64_t (**)(_QWORD, __CFReadStream *))(**((_QWORD **)this + 1) + 72))(*((_QWORD *)this + 1), a2);
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::scheduleAndOpenWithHandler(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 88))(*(_QWORD *)(a1 + 8));
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::setTransactionMetrics(HTTPTransactionWrapper *this, __CFN_TransactionMetrics *a2)
{
  return (*(uint64_t (**)(_QWORD, __CFN_TransactionMetrics *))(**((_QWORD **)this + 1) + 192))(*((_QWORD *)this + 1), a2);
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::setPriorityHint(HTTPTransactionWrapper *this, float a2)
{
  return (*(uint64_t (**)(_QWORD, float))(**((_QWORD **)this + 1) + 64))(*((_QWORD *)this + 1), a2);
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::_meta_retain(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(char *))(*((_QWORD *)this - 3) + 40))((char *)this - 24);
}

void HTTPTransaction::getProxy(HTTPTransaction *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  __n128 (*v12)(__n128 *, __n128 *);
  uint64_t (*v13)(uint64_t);
  void *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;

  v9 = 0;
  v10 = &v9;
  v11 = 0x4012000000;
  v12 = __Block_byref_object_copy__16088;
  v13 = __Block_byref_object_dispose__16089;
  v15 = 0;
  v16 = 0;
  v14 = &unk_18422E08D;
  std::shared_ptr<__CFString const>::operator=[abi:nn180100](&v15, *((_QWORD *)this + 17), *((_QWORD *)this + 18));
  v3 = v10[7];
  *a2 = v10[6];
  a2[1] = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  _Block_object_dispose(&v9, 8);
  v6 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

uint64_t HTTPTransaction::canScheduleAndOpenWithHandlerAsync(HTTPTransaction *this)
{
  return 1;
}

void HTTPTransaction::setBodyStreamBeforeOpening(HTTPTransaction *this, CFTypeRef cf, uint64_t a3)
{
  std::__shared_weak_count_vtbl *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  _QWORD v25[6];
  std::__shared_weak_count *v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  std::__shared_weak_count_vtbl *v32;
  std::__shared_weak_count *v33;

  if (cf)
    v5 = (std::__shared_weak_count_vtbl *)CFRetain(cf);
  else
    v5 = 0;
  v32 = v5;
  v6 = (std::__shared_weak_count *)operator new();
  v6->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F15C0;
  v6->__shared_weak_owners_ = 0;
  v6[1].__vftable = v5;
  v33 = v6;
  v30 = 0;
  v31 = 0;
  v8 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
  if (!v8)
  {
    v9 = 0;
    goto LABEL_8;
  }
  v9 = std::__shared_weak_count::lock(v8);
  v31 = v9;
  if (!v9)
  {
LABEL_8:
    v10 = 0;
    goto LABEL_9;
  }
  v10 = *((_QWORD *)this + 5);
  v30 = v10;
LABEL_9:
  v25[0] = MEMORY[0x1E0C809B0];
  v25[1] = 3321888768;
  v25[2] = ___ZN15HTTPTransaction26setBodyStreamBeforeOpeningEP14__CFReadStreamx_block_invoke;
  v25[3] = &__block_descriptor_80_e8_40c42_ZTSNSt3__110shared_ptrI14__CFReadStreamEE56c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE_e5_v8__0l;
  v25[4] = this;
  v25[5] = v5;
  v26 = v6;
  do
    v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  v27 = v10;
  v28 = v9;
  if (v9)
  {
    v12 = (unint64_t *)&v9->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v29 = a3;
  ___ZN15HTTPTransaction26setBodyStreamBeforeOpeningEP14__CFReadStreamx_block_invoke(v25);
  if (v9)
  {
    v14 = (unint64_t *)&v9->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v16 = v26;
  if (v26)
  {
    v17 = (unint64_t *)&v26->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = v31;
  if (v31)
  {
    v20 = (unint64_t *)&v31->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v22 = v33;
  if (v33)
  {
    v23 = (unint64_t *)&v33->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
}

void sub_183F19D98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  va_list va;

  va_start(va, a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v12);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v13 - 80);
  _Unwind_Resume(a1);
}

void ___ZN15HTTPTransaction26setBodyStreamBeforeOpeningEP14__CFReadStreamx_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  const __CFData *v15;
  std::__shared_weak_count_vtbl *v16;
  _QWORD *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  __int128 v22;
  __int128 v23;

  v3 = a1[4];
  v2 = a1[5];
  if (v2)
  {
    v4 = operator new(0xE0uLL);
    v5 = v4;
    v4[1] = 0;
    v4[2] = 0;
    *v4 = &off_1E14F0BE8;
    v6 = (uint64_t)(v4 + 3);
    v7 = (std::__shared_weak_count *)a1[6];
    *(_QWORD *)&v23 = v2;
    *((_QWORD *)&v23 + 1) = v7;
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }
    RequestBodyStream::RequestBodyStream((uint64_t)(v4 + 3), (uint64_t *)&v23, *(dispatch_object_t *)(v3 + 72), *(_QWORD *)(v3 + 208), a1[9], 0, 0);
    if (v7)
    {
      v10 = (unint64_t *)&v7->__shared_owners_;
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    *(_QWORD *)&v23 = v6;
    *((_QWORD *)&v23 + 1) = v5;
    std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&v23, v5 + 4, v6);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1[7] + 192, &v23);
    v12 = (std::__shared_weak_count *)*((_QWORD *)&v23 + 1);
    if (*((_QWORD *)&v23 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v23 + 1) + 8);
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
LABEL_13:
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }
  else
  {
    v15 = CFHTTPMessageCopyBody((CFHTTPMessageRef)(*(_QWORD *)(v3 + 160) - 16));
    if (v15)
    {
      v16 = (std::__shared_weak_count_vtbl *)v15;
      if (CFDataGetLength(v15) < 1)
      {
        CFRelease(v16);
        return;
      }
      v17 = operator new(0x98uLL);
      v17[1] = 0;
      v17[2] = 0;
      *v17 = &off_1E14F0B08;
      *(_QWORD *)&v23 = v16;
      v18 = (std::__shared_weak_count *)operator new();
      v18->__shared_owners_ = 0;
      v19 = (unint64_t *)&v18->__shared_owners_;
      v18->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1A90;
      v18->__shared_weak_owners_ = 0;
      v18[1].__vftable = v16;
      *((_QWORD *)&v23 + 1) = v18;
      RequestBody::RequestBody((uint64_t)(v17 + 3), *(dispatch_object_t *)(v3 + 72), *(_QWORD *)(v3 + 208), a1[9]);
      v17[17] = 0;
      v17[3] = &off_1E14E7BE8;
      v17[6] = &unk_1E14E7C58;
      v17[18] = 0;
      std::shared_ptr<__CFString const>::operator=[abi:nn180100](v17 + 17, (uint64_t)v16, (uint64_t)v18);
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
      *(_QWORD *)&v22 = v17 + 3;
      *((_QWORD *)&v22 + 1) = v17;
      std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&v22, v17 + 4, (uint64_t)(v17 + 3));
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1[7] + 192, &v22);
      v12 = (std::__shared_weak_count *)*((_QWORD *)&v22 + 1);
      if (*((_QWORD *)&v22 + 1))
      {
        v21 = (unint64_t *)(*((_QWORD *)&v22 + 1) + 8);
        do
          v14 = __ldaxr(v21);
        while (__stlxr(v14 - 1, v21));
        goto LABEL_13;
      }
    }
  }
}

void sub_183F1A04C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  std::__shared_weak_count *v3;
  void *v5;
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::__shared_weak_count::~__shared_weak_count(v3);
  operator delete(v5);
  _Unwind_Resume(a1);
}

uint64_t HTTPTransaction::scheduleAndOpenWithHandler(uint64_t a1, uint64_t a2, void *a3, const void *a4)
{
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v17;

  *(_BYTE *)(a1 + 249) = 1;
  if (a2)
    (*(void (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
  v17 = 0;
  v8 = *(std::__shared_weak_count **)(a1 + 48);
  if (v8)
  {
    v8 = std::__shared_weak_count::lock(v8);
    v9 = v8;
    v17 = v8;
    if (v8)
      v8 = *(std::__shared_weak_count **)(a1 + 40);
  }
  else
  {
    v9 = 0;
  }
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  HTTPTransaction::_onqueue_scheduleAndOpenWithHandler((uint64_t)v8, a2, a3, a4);
  if (a2)
    (*(void (**)(uint64_t))(*(_QWORD *)a2 + 48))(a2);
  if (v9)
  {
    v12 = (unint64_t *)&v9->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  if (v17)
  {
    v14 = (unint64_t *)&v17->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  return 1;
}

void sub_183F1A220(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 64);
  _Unwind_Resume(a1);
}

uint64_t ___ZN15HTTPTransaction26scheduleAndOpenWithHandlerEPK17CoreSchedulingSetU13block_pointerFvP15__CFHTTPMessagePU27objcproto16OS_dispatch_data8NSObjectPK13CFStreamErrorEU13block_pointerFvhE_block_invoke(uint64_t a1)
{
  uint64_t result;

  HTTPTransaction::_onqueue_scheduleAndOpenWithHandler(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 64), *(void **)(a1 + 32), *(const void **)(a1 + 40));
  result = *(_QWORD *)(a1 + 64);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

uint64_t HTTPTransaction::getTransactionMetrics(HTTPTransaction *this)
{
  return *((_QWORD *)this + 34);
}

void HTTPTransaction::_onqueue_updateScheduling(HTTPTransaction *this, const CoreSchedulingSet *a2, int a3)
{
  uint64_t v6;
  _BOOL8 v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  _BOOL4 v15;
  char v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  NSObject *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  _QWORD block[6];
  std::__shared_weak_count *v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  uint64_t v40;
  std::__shared_weak_count *v41;

  v6 = *((_QWORD *)this + 27);
  if (a2 && v6)
  {
    if (CoreSchedulingSet::isEqualTo((CoreSchedulingSet *)v6, a2))
      return;
    v6 = *((_QWORD *)this + 27);
  }
  if (v6)
  {
    v7 = *(_DWORD *)(v6 + 40) != 0;
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 48))(v6);
    *((_QWORD *)this + 27) = 0;
  }
  else
  {
    v7 = 0;
  }
  *((_QWORD *)this + 27) = a2;
  if (a2)
    (*(void (**)(const CoreSchedulingSet *))(*(_QWORD *)a2 + 40))(a2);
  v8 = *((_QWORD *)this + 24);
  v9 = (std::__shared_weak_count *)*((_QWORD *)this + 25);
  v40 = v8;
  v41 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  if (v8)
    (*(void (**)(uint64_t, _QWORD, _BOOL8))(*(_QWORD *)v8 + 40))(v8, *((_QWORD *)this + 27), v7);
  if (v9)
  {
    v12 = (unint64_t *)&v9->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v14 = *((_QWORD *)this + 27);
  if (v14)
    v15 = *(_DWORD *)(v14 + 40) != 0;
  else
    v15 = 0;
  if (v7)
    v16 = v15;
  else
    v16 = !v15;
  if ((v16 & 1) == 0)
  {
    if ((*((_DWORD *)this + 20) & 0xFFFFFFFC) == 4)
    {
      v40 = 0;
      v41 = 0;
      v17 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
      if (v17)
      {
        v41 = std::__shared_weak_count::lock(v17);
        if (v41)
        {
          v18 = *((_QWORD *)this + 7);
          v40 = v18;
          if (v18)
          {
            std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v38, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
            HTTPConnection::suspendTransaction(v18, &v38, !v15);
            v19 = v39;
            if (v39)
            {
              v20 = (unint64_t *)&v39->__shared_owners_;
              do
                v21 = __ldaxr(v20);
              while (__stlxr(v21 - 1, v20));
              if (!v21)
              {
                ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
                std::__shared_weak_count::__release_weak(v19);
              }
            }
          }
        }
      }
      v22 = v41;
      if (v41)
      {
        v23 = (unint64_t *)&v41->__shared_owners_;
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
    }
    if ((v15 & a3) == 1 && (*((_WORD *)this + 16) & 0x180) != 0)
    {
      v25 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
      if (v25)
      {
        v26 = std::__shared_weak_count::lock(v25);
        if (v26)
          v27 = *((_QWORD *)this + 5);
        else
          v27 = 0;
      }
      else
      {
        v27 = 0;
        v26 = 0;
      }
      v28 = *((_QWORD *)this + 9);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3321888768;
      block[2] = ___ZN15HTTPTransaction25_onqueue_updateSchedulingEPK17CoreSchedulingSetb_block_invoke;
      block[3] = &__block_descriptor_56_e8_40c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE_e5_v8__0l;
      block[4] = this;
      block[5] = v27;
      v37 = v26;
      if (v26)
      {
        v29 = (unint64_t *)&v26->__shared_owners_;
        do
          v30 = __ldxr(v29);
        while (__stxr(v30 + 1, v29));
      }
      dispatch_async(v28, block);
      v31 = v37;
      if (v37)
      {
        v32 = (unint64_t *)&v37->__shared_owners_;
        do
          v33 = __ldaxr(v32);
        while (__stlxr(v33 - 1, v32));
        if (!v33)
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
        }
      }
      if (v26)
      {
        v34 = (unint64_t *)&v26->__shared_owners_;
        do
          v35 = __ldaxr(v34);
        while (__stlxr(v35 - 1, v34));
        if (!v35)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
    }
  }
}

void sub_183F1A584(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 64);
  _Unwind_Resume(a1);
}

uint64_t HTTPTransaction::setTransactionMetrics(uint64_t this, __CFN_TransactionMetrics *a2)
{
  *(_QWORD *)(this + 272) = a2;
  return this;
}

void HTTPEngine::_writeHeadersFinish(HTTPEngine *this, CFStreamError a2)
{
  uint64_t v2;
  CFIndex domain;
  HTTPEngine *v5;
  CFStreamError v6;
  CFStreamError v7;

  v2 = *(_QWORD *)&a2.error;
  domain = a2.domain;
  HTTPEngine::_updateBytesTransferred(this);
  if ((_DWORD)v2)
  {
    v5 = this;
    v6.domain = domain;
    *(_QWORD *)&v6.error = v2;
LABEL_3:
    HTTPEngine::_writeFinish(v5, v6);
    return;
  }
  if (!*((_QWORD *)this + 30))
  {
    *(_QWORD *)&v6.error = v2 & 0xFFFFFFFF00000000;
    v5 = this;
    v6.domain = domain;
    goto LABEL_3;
  }
  if ((*((_BYTE *)this + 32) & 0x20) == 0)
  {
    if (*((_QWORD *)this + 32))
    {
      HTTPEngine::_writeBodyStart(this);
    }
    else
    {
      *(_QWORD *)&v7.error = v2 & 0xFFFFFFFF00000000;
      v7.domain = domain;
      HTTPEngine::_writeBodyFinish(this, v7);
    }
  }
}

void HTTPEngine::_readHeadersDoParse(HTTPEngine *this, CFStreamError a2, int a3)
{
  unint64_t v4;
  CFIndex domain;
  NSObject *v7;
  int v8;
  uint64_t v9;
  BOOL v10;
  int v11;
  const __CFData *v12;
  const __CFData *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  const __CFData **v18;
  CFStreamError v19;
  HTTPMessage *v20;
  const char *v21;
  const __CFData **v22;
  uint64_t v23;
  int v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  HTTPMessage **v28;
  CFIndex ResponseStatusCode;
  CFIndex v30;
  int v31;
  NSObject *v32;
  std::__shared_weak_count **v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  _OWORD *Instance;
  HTTPMessage *v39;
  _QWORD *v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  int v44;
  CFStringRef v45;
  const __CFString *v46;
  const __CFAllocator *v47;
  const __CFArray *ArrayBySeparatingStrings;
  uint64_t Count;
  CFIndex v50;
  const __CFString *ValueAtIndex;
  const void *v52;
  const __CFAllocator *v53;
  __CFArray *MutableCopy;
  const __CFAllocator *v55;
  int v56;
  _QWORD v57[2];
  _QWORD applier[7];
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  int v62;
  __int128 buf;
  uint64_t v64;
  uint64_t v65;
  CFStreamError v66;
  CFStreamError v67;
  CFStreamError v68;
  CFRange v69;

  v4 = *(_QWORD *)&a2.error;
  domain = a2.domain;
  v7 = *((_QWORD *)this + 24);
  if (v7 && dispatch_data_get_size(*((dispatch_data_t *)this + 24)))
  {
    if (!(_DWORD)v4)
      goto LABEL_10;
LABEL_9:
    if (dispatch_data_get_size(v7))
      goto LABEL_10;
    goto LABEL_27;
  }
  if (v4 == 57 || a3)
  {
    v16 = *((_QWORD *)this + 16);
    HTTPMessage::ensureParserFinished((HTTPMessage *)v16);
    if (!*(_QWORD *)(v16 + 40) || (v18 = *(const __CFData ***)(v16 + 48)) == 0 || !HTTPBodyData::getLength(v18, v17))
    {
      if (*(_QWORD *)(v16 + 88)
        || !*(_QWORD *)(v16 + 288)
        && !*(_BYTE *)(v16 + 160)
        && ((v24 = *(_DWORD *)(v16 + 128), v24 != -1) ? (v25 = v24 == 200) : (v25 = 1), v25))
      {
        *(_QWORD *)&v19.error = 4294967292;
LABEL_64:
        v33 = (std::__shared_weak_count **)this;
        v19.domain = 4;
LABEL_65:
        HTTPEngine::_readHeadersFinish(v33, v19);
        return;
      }
    }
    v26 = *((_QWORD *)this + 16);
    if (!*(_QWORD *)(v26 + 288) && !*(_BYTE *)(v26 + 160))
      (*(void (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v26 + 80))(v26, "", 0);
    goto LABEL_50;
  }
  if (!(_DWORD)v4)
  {
LABEL_10:
    v8 = *((_DWORD *)this + 8);
    if ((v8 & 0x80) == 0)
    {
      v9 = *((_QWORD *)this + 41);
      if (v9)
      {
        *(_QWORD *)(v9 + 200) = 0x7FF8000000000000;
        v8 = *((_DWORD *)this + 8);
      }
      *((_DWORD *)this + 8) = v8 | 0x80;
    }
    *(_QWORD *)&buf = 0;
    *((_QWORD *)&buf + 1) = &buf;
    v64 = 0x2020000000;
    v65 = 0;
    v59 = 0;
    v60 = &v59;
    v61 = 0x2020000000;
    v62 = 0;
    if (v7)
    {
      applier[0] = MEMORY[0x1E0C809B0];
      applier[1] = 3221225472;
      applier[2] = ___ZN10HTTPEngine19_readHeadersDoParseE13CFStreamErrorb_block_invoke;
      applier[3] = &unk_1E14FD0C8;
      applier[5] = &buf;
      applier[6] = this;
      applier[4] = &v59;
      v10 = dispatch_data_apply(v7, applier);
      v11 = *((_DWORD *)v60 + 6);
      if ((v11 - 2) >= 2)
      {
        if (v11 == 1)
        {
          v23 = *((_QWORD *)this + 41);
          if (v23)
            *(_QWORD *)(v23 + 120) += *(_QWORD *)(*((_QWORD *)&buf + 1) + 24);
        }
      }
      else
      {
        v12 = HTTPMessage::copyBody(*((HTTPMessage **)this + 16));
        v13 = v12;
        v14 = *((_QWORD *)this + 41);
        v15 = *(_QWORD *)(*((_QWORD *)&buf + 1) + 24);
        if (v12)
          v15 -= CFDataGetLength(v12);
        if (v14)
          *(_QWORD *)(v14 + 120) += v15;
        if (v13)
          CFRelease(v13);
      }
    }
    else
    {
      v10 = 1;
    }
    HTTPEngine::_readBufferConsume(this, *(_QWORD *)(*((_QWORD *)&buf + 1) + 24));
    _Block_object_dispose(&v59, 8);
    _Block_object_dispose(&buf, 8);
    if (!v10)
    {
      *(_QWORD *)&v19.error = 0xFFFFFFFFLL;
      goto LABEL_64;
    }
LABEL_50:
    v4 = 0;
    domain = 0;
    goto LABEL_51;
  }
  if (v7)
    goto LABEL_9;
LABEL_27:
  if ((_DWORD)v4)
  {
    if (domain == 1)
    {
      if ((_DWORD)v4 != 54 && (_DWORD)v4 != 32
        || (v20 = (HTTPMessage *)*((_QWORD *)this + 16), HTTPMessage::ensureParserFinished(v20), *((_QWORD *)v20 + 5))
        && (v22 = (const __CFData **)*((_QWORD *)v20 + 6)) != 0
        && HTTPBodyData::getLength(v22, v21))
      {
        domain = 1;
      }
      else
      {
        v4 = v4 & 0xFFFFFFFF00000000 | 0xFFFFFFFC;
        domain = 4;
      }
    }
    v66.domain = domain;
    *(_QWORD *)&v66.error = v4;
    HTTPEngine::_readHeadersFinish((std::__shared_weak_count **)this, v66);
    return;
  }
LABEL_51:
  v28 = (HTTPMessage **)((char *)this + 128);
  v27 = *((_QWORD *)this + 16);
  if (*(_QWORD *)(v27 + 88))
  {
    HTTPEngine::_readHeadersDoRead(this);
    return;
  }
  if (*(_QWORD *)(v27 + 288) || *(_BYTE *)(v27 + 160) || (v44 = *(_DWORD *)(v27 + 128), v44 != -1) && v44 != 200)
  {
    *((_DWORD *)this + 8) |= 0x100u;
  }
  else if ((*((_BYTE *)this + 33) & 1) != 0)
  {
    *(_QWORD *)&v19.error = v4 & 0xFFFFFFFF00000000 | 0xFFFFFFFC;
    goto LABEL_64;
  }
  if ((HTTPResponseMessage::isValid((os_unfair_lock_s *)v27) & 1) == 0)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v32 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl(&dword_183ECA000, v32, OS_LOG_TYPE_ERROR, "Rejecting invalid response header due to multiple values", (uint8_t *)&buf, 2u);
    }
    *(_QWORD *)&v19.error = v4 | 0xFFFFFFFF;
    goto LABEL_64;
  }
  HTTPEngine::_readBufferCaptureBody((uint64_t)this, *((HTTPBodyData ***)this + 16));
  ResponseStatusCode = CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)(*((_QWORD *)this + 16) - 16));
  v30 = ResponseStatusCode;
  if (ResponseStatusCode == 101)
  {
    v31 = *((_DWORD *)this + 8) | 0x200;
  }
  else
  {
    if ((unint64_t)(ResponseStatusCode - 100) <= 0x63)
    {
      v34 = *((_QWORD *)this + 27);
      if (v34)
      {
        v35 = *((_QWORD *)this + 17);
        v57[0] = *((_QWORD *)this + 16);
        v57[1] = v35;
        if (v35)
        {
          v36 = (unint64_t *)(v35 + 8);
          do
            v37 = __ldxr(v36);
          while (__stxr(v37 + 1, v36));
        }
        (*(void (**)(uint64_t, _QWORD *))(v34 + 16))(v34, v57);
        std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v57);
      }
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      Instance = (_OWORD *)_CFRuntimeCreateInstance();
      v39 = (HTTPMessage *)Instance;
      if (Instance)
      {
        Instance[1] = 0u;
        v39 = (HTTPMessage *)(Instance + 1);
        Instance[18] = 0u;
        Instance[19] = 0u;
        Instance[16] = 0u;
        Instance[17] = 0u;
        Instance[14] = 0u;
        Instance[15] = 0u;
        Instance[12] = 0u;
        Instance[13] = 0u;
        Instance[10] = 0u;
        Instance[11] = 0u;
        Instance[8] = 0u;
        Instance[9] = 0u;
        Instance[6] = 0u;
        Instance[7] = 0u;
        Instance[4] = 0u;
        Instance[5] = 0u;
        Instance[2] = 0u;
        Instance[3] = 0u;
      }
      HTTPMessage::HTTPMessage(v39, "httpresponse");
      *(_QWORD *)v39 = &off_1E14E9F38;
      *((_QWORD *)v39 + 1) = &unk_1E14E9FA8;
      *((_QWORD *)v39 + 2) = &unk_1E14E9FC8;
      *((_DWORD *)v39 + 32) = -1;
      *((_QWORD *)v39 + 17) = 0;
      *((_OWORD *)v39 + 10) = 0u;
      *((_OWORD *)v39 + 11) = 0u;
      *((_OWORD *)v39 + 12) = 0u;
      *((_OWORD *)v39 + 13) = 0u;
      *((_OWORD *)v39 + 14) = 0u;
      *((_OWORD *)v39 + 15) = 0u;
      *((_OWORD *)v39 + 16) = 0u;
      *((_OWORD *)v39 + 17) = 0u;
      *((_BYTE *)v39 + 296) = 0;
      *(_QWORD *)&buf = v39;
      v40 = (_QWORD *)operator new();
      *v40 = &off_1E14F1710;
      v40[1] = 0;
      v40[2] = 0;
      v40[3] = v39;
      *((_QWORD *)&buf + 1) = v40;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 128, &buf);
      v41 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
      if (*((_QWORD *)&buf + 1))
      {
        v42 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
        do
          v43 = __ldaxr(v42);
        while (__stlxr(v43 - 1, v42));
        if (!v43)
        {
          ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
          std::__shared_weak_count::__release_weak(v41);
        }
      }
      if (v30 == 100 && (*((_DWORD *)this + 8) & 0x20) != 0)
        HTTPEngine::_100ContinueProceed(this);
      HTTPEngine::_readHeadersStart(this);
      return;
    }
    if ((unint64_t)(ResponseStatusCode - 300) > 0x63)
    {
      v31 = *((_DWORD *)this + 8);
      if (ResponseStatusCode != 401)
        goto LABEL_97;
      v31 |= 0x40000u;
    }
    else
    {
      v31 = *((_DWORD *)this + 8) | 0x20000;
    }
  }
  *((_DWORD *)this + 8) = v31;
LABEL_97:
  if ((v31 & 0x20) != 0 && *((_QWORD *)this + 18) == *((_QWORD *)this + 30))
  {
    HTTPEngine::_100ContinueTimerCancel(this);
    *((_DWORD *)this + 8) &= ~0x20u;
    v67.domain = 0;
    *(_QWORD *)&v67.error = 0;
    HTTPEngine::_writeBodyFinish(this, v67);
    v31 = *((_DWORD *)this + 8);
  }
  if (v30 == 304 || (v31 & 0x10200) != 0)
  {
    *((_DWORD *)this + 8) = v31 & 0xFFFEFFFF;
    *((_QWORD *)this + 22) = 0;
    v33 = (std::__shared_weak_count **)this;
    v19.domain = domain;
    *(_QWORD *)&v19.error = v4;
    goto LABEL_65;
  }
  v45 = HTTPMessage::copyHeaderFieldValue(*v28, 0x146233E1u);
  v46 = v45;
  if (v45)
  {
    v47 = CFGetAllocator(v45);
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v47, v46, CFSTR(","));
    Count = CFArrayGetCount(ArrayBySeparatingStrings);
    if (Count >= 1)
    {
      v50 = 0;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v50);
        v69.length = CFStringGetLength(ValueAtIndex);
        v69.location = 0;
        if (CFStringFindWithOptions(ValueAtIndex, (CFStringRef)&unk_1EDCFDBA0, v69, 1uLL, 0))
          break;
        if (Count == ++v50)
          goto LABEL_115;
      }
      if (Count == 1)
      {
        v52 = CFRetain(&unk_1EDCFDCF0);
      }
      else
      {
        v53 = CFGetAllocator(v46);
        MutableCopy = CFArrayCreateMutableCopy(v53, Count, ArrayBySeparatingStrings);
        CFArrayRemoveValueAtIndex(MutableCopy, v50);
        v55 = CFGetAllocator(v46);
        v52 = CFStringCreateByCombiningStrings(v55, MutableCopy, CFSTR(","));
        if (MutableCopy)
          CFRelease(MutableCopy);
      }
      HTTPMessage::setHeaderFieldStringValue(*v28, 0x146233E1u, v52);
      *(_BYTE *)(*((_QWORD *)this + 16) + 296) = 1;
      *((_DWORD *)this + 8) |= 0x2000u;
      if (v52)
        CFRelease(v52);
    }
LABEL_115:
    if (ArrayBySeparatingStrings)
      CFRelease(ArrayBySeparatingStrings);
  }
  v56 = *((_DWORD *)this + 8);
  if ((v56 & 0x2000) != 0)
  {
    *((_DWORD *)this + 8) = v56 | 0x4000;
    *((_QWORD *)this + 22) = 0;
  }
  else
  {
    *((_QWORD *)this + 22) = HTTPEngine::_expectedSizeFromHeaders(this, *((HTTPMessage **)this + 16));
    HTTPEngine::_readUpdateLargeDownloadSettings((uint64_t)this);
  }
  v68.domain = domain;
  *(_QWORD *)&v68.error = v4;
  HTTPEngine::_readHeadersFinish((std::__shared_weak_count **)this, v68);
  if (v46)
    CFRelease(v46);
}

void sub_183F1AE64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  const void *v23;
  const void *v24;
  const void *v25;

  if (v25)
    CFRelease(v25);
  if (v24)
    CFRelease(v24);
  if (v23)
    CFRelease(v23);
  _Unwind_Resume(exception_object);
}

void HTTPEngine::_readBufferConsume(HTTPEngine *this, size_t a2)
{
  NSObject *v2;
  size_t size;
  dispatch_data_t subrange;

  v2 = *((_QWORD *)this + 24);
  if (v2)
  {
    size = dispatch_data_get_size(*((dispatch_data_t *)this + 24));
    if (size < a2)
      __assert_rtn("_readBufferConsume", "HTTPEngine.cpp", 3138, "length <= bufLen");
    if (size > a2)
    {
      subrange = dispatch_data_create_subrange(v2, a2, size - a2);
      dispatch_release(*((dispatch_object_t *)this + 24));
    }
    else
    {
      dispatch_release(v2);
      subrange = 0;
    }
    *((_QWORD *)this + 24) = subrange;
  }
}

void HTTPEngine::_readBufferCaptureBody(uint64_t a1, HTTPBodyData **this)
{
  const char *v4;
  HTTPBodyData *v5;
  const __CFData *v6;
  const __CFData *v7;
  const UInt8 *BytePtr;
  size_t Length;
  NSObject *v10;
  NSObject *v11;
  _QWORD destructor[5];

  HTTPMessage::ensureParserFinished((HTTPMessage *)this);
  v5 = this[6];
  this[6] = 0;
  if (v5)
  {
    HTTPBodyData::captureData(v5, v4);
    if (v6)
    {
      v7 = v6;
      BytePtr = CFDataGetBytePtr(v6);
      Length = CFDataGetLength(v7);
      destructor[0] = MEMORY[0x1E0C809B0];
      destructor[1] = 3221225472;
      destructor[2] = ___ZN10HTTPEngine22_readBufferCaptureBodyERNSt3__110shared_ptrI19HTTPResponseMessageEE_block_invoke;
      destructor[3] = &__block_descriptor_40_e5_v8__0l;
      destructor[4] = v7;
      v10 = dispatch_data_create(BytePtr, Length, 0, destructor);
      if (v10)
      {
        v11 = v10;
        HTTPEngine::_readBufferStore(a1, v10, 1);
        dispatch_release(v11);
      }
    }
    (*(void (**)(HTTPBodyData *))(*(_QWORD *)v5 + 8))(v5);
  }
}

void sub_183F1B078(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

BOOL ___ZN10HTTPEngine19_readHeadersDoParseE13CFStreamErrorb_block_invoke(_QWORD *a1, int a2, int a3, const char *a4, CFIndex a5)
{
  int v7;

  *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = HTTPMessage::appendBytes(*(HTTPMessage **)(a1[6] + 128), a4, a5);
  v7 = *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  if (v7)
    *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) += a5;
  return v7 != 0;
}

uint64_t HTTPMessage::appendBytes(HTTPMessage *this, const char *a2, CFIndex a3)
{
  HTTPParser *v6;
  uint64_t v7;
  _DWORD *v8;
  int v9;
  const char *v10;
  HTTPBodyData *v11;
  uint64_t v12;
  const char *v13;
  HTTPBodyData *v14;

  v6 = (HTTPParser *)*((_QWORD *)this + 11);
  if (!v6)
  {
    HTTPMessage::appendToBodyData(this, a2, a3);
    v12 = 3;
LABEL_17:
    *((_DWORD *)this + 14) = v12;
    return v12;
  }
  v7 = HTTPParser::parse(v6, (const unsigned __int8 *)a2, a3);
  v8 = (_DWORD *)*((_QWORD *)this + 11);
  v9 = v8[9];
  if (v9 == 3 && *((_BYTE *)this + 24) && !*((_QWORD *)this + 5))
  {
    (*(void (**)(_DWORD *))(*(_QWORD *)v8 + 8))(v8);
    *((_QWORD *)this + 11) = 0;
    v12 = 3;
    *((_DWORD *)this + 14) = 3;
    HTTPMessage::appendToBodyData(this, a2, a3);
    return v12;
  }
  if ((v7 & 0x8000000000000000) == 0)
  {
    if (a3 <= v7)
    {
      if (a3 != v7 || v9 < 2)
      {
        HTTPMessage::appendToBodyData(this, a2, a3);
        return 1;
      }
      (*(void (**)(_DWORD *))(*(_QWORD *)v8 + 8))(v8);
      *((_QWORD *)this + 11) = 0;
      v14 = (HTTPBodyData *)*((_QWORD *)this + 6);
      if (v14)
        HTTPBodyData::becomeEmpty(v14, v13);
    }
    else
    {
      (*(void (**)(_DWORD *))(*(_QWORD *)v8 + 8))(v8);
      *((_QWORD *)this + 11) = 0;
      v11 = (HTTPBodyData *)*((_QWORD *)this + 6);
      if (v11)
        HTTPBodyData::becomeEmpty(v11, v10);
      HTTPMessage::appendToBodyData(this, &a2[v7], a3 - v7);
    }
    v12 = 2;
    goto LABEL_17;
  }
  (*(void (**)(_DWORD *))(*(_QWORD *)v8 + 8))(v8);
  *((_QWORD *)this + 11) = 0;
  *((_DWORD *)this + 14) = 0;
  HTTPMessage::appendToBodyData(this, a2, a3);
  return 0;
}

uint64_t HTTPParser::parse(HTTPParser *this, const unsigned __int8 *a2, uint64_t a3)
{
  const unsigned __int8 *v5;
  const unsigned __int8 *v6;
  const unsigned __int8 *v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint8_t buf[4];
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  if (a3 < 1)
  {
LABEL_41:
    v8 = *((_DWORD *)this + 9);
    v7 = v5;
  }
  else
  {
    v6 = &a2[a3];
    v7 = a2;
    while (2)
    {
      v8 = *((_DWORD *)this + 9);
      if (v8 <= 1)
      {
        v5 = v7 + 1;
        v9 = *v7;
        v10 = *((_DWORD *)this + 10);
        switch(v10)
        {
          case 0:
            if (*v7 > 0xCu)
            {
              if (v9 == 32)
              {
LABEL_26:
                *((_DWORD *)this + 10) = 2;
                goto LABEL_28;
              }
              if (v9 == 13)
              {
                v12 = 1;
                goto LABEL_30;
              }
            }
            else
            {
              if (v9 == 9)
                goto LABEL_26;
              if (v9 == 10)
                goto LABEL_18;
            }
            v14 = *((_QWORD *)this + 72);
            if (v14 >= 1)
            {
              HTTPParser::commitAccumulatedLine(this);
              v14 = *((_QWORD *)this + 72);
            }
            if (v14 == *((_QWORD *)this + 71))
            {
              HTTPParser::growBuffer((char *)this);
              v14 = *((_QWORD *)this + 72);
            }
            v15 = *((_QWORD *)this + 70);
            *((_QWORD *)this + 72) = v14 + 1;
            *(_BYTE *)(v15 + v14) = v9;
            *((_DWORD *)this + 10) = 2;
LABEL_40:
            v7 = v5;
            if (v5 >= v6)
              goto LABEL_41;
            continue;
          case 1:
            if (v9 != 13)
            {
              if (v9 == 10)
              {
LABEL_18:
                *((_DWORD *)this + 9) = 2;
              }
              else
              {
                *((_DWORD *)this + 10) = 0;
LABEL_28:
                v5 = v7;
              }
            }
            goto LABEL_40;
          case 2:
            if (v9 == 10)
              goto LABEL_22;
            if (v9 == 13)
            {
              v12 = 3;
LABEL_30:
              *((_DWORD *)this + 10) = v12;
            }
            else
            {
              if (v9 == 58)
              {
                v11 = *((_QWORD *)this + 72);
                if (*((_QWORD *)this + 73) == -1)
                  *((_QWORD *)this + 73) = v11;
              }
              else
              {
                v11 = *((_QWORD *)this + 72);
              }
              if (v11 == *((_QWORD *)this + 71))
              {
                HTTPParser::growBuffer((char *)this);
                v11 = *((_QWORD *)this + 72);
              }
              v13 = *((_QWORD *)this + 70);
              *((_QWORD *)this + 72) = v11 + 1;
              *(_BYTE *)(v13 + v11) = v9;
            }
            goto LABEL_40;
          case 3:
            if (v9 == 10)
              goto LABEL_22;
            if (v9 != 13)
            {
              v5 = v7;
LABEL_22:
              *((_DWORD *)this + 10) = 0;
            }
            goto LABEL_40;
          default:
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 67109376;
              v18 = v10;
              v19 = 1024;
              v20 = v8;
              _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "unknown line state %d, parse state %d", buf, 0xEu);
            }
            goto LABEL_40;
        }
      }
      break;
    }
  }
  if (v8 == 2)
    HTTPParser::commitAccumulatedLine(this);
  return v7 - a2;
}

void HTTPEngine::_readHeadersFinish(std::__shared_weak_count **this, CFStreamError a2)
{
  uint64_t v2;
  CFIndex domain;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;

  v2 = *(_QWORD *)&a2.error;
  domain = a2.domain;
  HTTPEngine::_updateBytesTransferred((HTTPEngine *)this);
  v5 = this[25];
  if (v5)
  {
    this[25] = 0;
    v6 = this[17];
    v13 = this[16];
    v14 = v6;
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }
    ((void (*)(std::__shared_weak_count *, std::__shared_weak_count **, CFIndex, uint64_t))v5->__shared_weak_owners_)(v5, &v13, domain, v2);
    v9 = v14;
    if (v14)
    {
      v10 = (unint64_t *)&v14->__shared_owners_;
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    _Block_release(v5);
  }
  v12 = this[27];
  if (v12)
  {
    _Block_release(v12);
    this[27] = 0;
  }
  if ((_DWORD)v2)
  {
    HTTPEngine::_readBodyFinish((uint64_t)this, 0, domain, v2, 0);
  }
  else
  {
    if (this[22] == (std::__shared_weak_count *)-2)
      __assert_rtn("_readBodyStart", "HTTPEngine.cpp", 1168, "_inExpectedBytes != HEADERS_NOT_YET_CHECKED");
    HTTPEngine::_readBodyStartNextRead((HTTPEngine *)this);
  }
}

void sub_183F1B608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void HTTPEngine::_writeBodyFinish(HTTPEngine *this, CFStreamError a2)
{
  uint64_t v2;
  CFIndex domain;
  uint64_t v5;
  int v6;
  CFStreamError v7;

  v2 = *(_QWORD *)&a2.error;
  domain = a2.domain;
  v5 = *((_QWORD *)this + 32);
  if (v5)
  {
    v6 = *((_DWORD *)this + 8);
    if ((v6 & 0x10000000) != 0)
    {
      *((_DWORD *)this + 8) = v6 & 0xEFFFFFFF;
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
    }
  }
  v7.domain = domain;
  *(_QWORD *)&v7.error = v2;
  HTTPEngine::_writeFinish(this, v7);
}

void HTTPEngine::_writeFinish(HTTPEngine *this, CFStreamError a2)
{
  uint64_t v2;
  CFIndex domain;
  int v5;
  uint64_t v6;
  void (**v7)(_QWORD, _QWORD, _QWORD);
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  __int128 v14;

  v2 = *(_QWORD *)&a2.error;
  domain = a2.domain;
  v5 = *((_DWORD *)this + 8);
  if ((v5 & 0x10) != 0)
    *((_DWORD *)this + 8) = v5 | 0x1000000;
  HTTPEngine::_updateBytesTransferred(this);
  v6 = *((_QWORD *)this + 42);
  if (v6)
    *(CFAbsoluteTime *)(v6 + 184) = CFAbsoluteTimeGetCurrent();
  v7 = (void (**)(_QWORD, _QWORD, _QWORD))*((_QWORD *)this + 39);
  if (v7)
  {
    *((_QWORD *)this + 39) = 0;
    v7[2](v7, domain, v2);
    _Block_release(v7);
  }
  v14 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 240, &v14);
  v8 = (std::__shared_weak_count *)*((_QWORD *)&v14 + 1);
  if (*((_QWORD *)&v14 + 1))
  {
    v9 = (unint64_t *)(*((_QWORD *)&v14 + 1) + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v14 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 256, &v14);
  v11 = (std::__shared_weak_count *)*((_QWORD *)&v14 + 1);
  if (!*((_QWORD *)&v14 + 1))
    goto LABEL_16;
  v12 = (unint64_t *)(*((_QWORD *)&v14 + 1) + 8);
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
    if (!(_DWORD)v2)
      return;
  }
  else
  {
LABEL_16:
    if (!(_DWORD)v2)
      return;
  }
  if (!*((_QWORD *)this + 12) && !*((_DWORD *)this + 26))
  {
    *((_QWORD *)this + 12) = domain;
    *((_QWORD *)this + 13) = v2;
  }
  HTTPEngine::_cleanupConnection(this, 0);
}

void ___ZN14HTTPConnection21_onqueue_requestStartEv_block_invoke_2(uint64_t a1, CFStreamError a2)
{
  HTTPConnection::_onqueue_requestFinish(*(HTTPConnection **)(a1 + 32), a2);
}

void HTTPConnection::_onqueue_requestFinish(HTTPConnection *this, CFStreamError a2)
{
  uint64_t v2;
  CFIndex domain;
  uint64_t v5;
  uint64_t v6;
  const __CFString *v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  dispatch_time_t v12;
  uint64_t error;
  __int16 v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  int v21;
  std::__shared_weak_count *v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  uint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  _QWORD v59[6];
  std::__shared_weak_count *v60;
  uint64_t v61;
  std::__shared_weak_count *v62;
  uint64_t v63;
  std::__shared_weak_count *v64;
  _QWORD v65[2];
  void (*v66)(uint64_t);
  void *v67;
  HTTPConnection *v68;
  uint64_t v69;
  std::__shared_weak_count *v70;
  uint64_t v71;
  std::__shared_weak_count *v72;
  uint64_t v73;
  std::__shared_weak_count *v74;
  _BYTE handler[32];
  NSObject *v76;
  uint64_t v77;
  uint64_t v78;
  CFStreamError v79;
  CFStreamError v80;

  v2 = *(_QWORD *)&a2.error;
  domain = a2.domain;
  v78 = *MEMORY[0x1E0C80C00];
  v5 = *((_QWORD *)this + 18);
  if (!v5)
  {
    error = a2.error;
    goto LABEL_30;
  }
  if (*(int *)(v5 + 80) <= 5)
  {
    *(_DWORD *)(v5 + 80) = 6;
    v6 = *(_QWORD *)(v5 + 160);
    v7 = *(const __CFString **)(v6 + 152);
    if (v7
      || os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
      && (*(_WORD *)handler = 0,
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", handler, 2u), (v7 = *(const __CFString **)(v6 + 152)) != 0))
    {
      if (CFStringCompare(v7, (CFStringRef)&gConstantCFStringValueTable[2590], 0) == kCFCompareEqualTo
        && !*(_QWORD *)(v5 + 296))
      {
        v8 = *(NSObject **)(v5 + 72);
        if (v8)
        {
          v9 = *(_QWORD *)(v5 + 208);
          if (!v9)
            goto LABEL_10;
          if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v9 + 256))(v9))
          {
            v8 = *(NSObject **)(v5 + 72);
LABEL_10:
            v10 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, v8);
            if (v10)
            {
              v11 = v10;
              *(_QWORD *)handler = MEMORY[0x1E0C809B0];
              *(_QWORD *)&handler[8] = 3221225472;
              *(_QWORD *)&handler[16] = ___ZN15HTTPTransaction15startStallTimerEv_block_invoke;
              *(_QWORD *)&handler[24] = &unk_1E14FE140;
              v76 = v10;
              v77 = v5;
              dispatch_source_set_event_handler(v10, handler);
              v12 = dispatch_time(0x8000000000000000, 3000000000);
              dispatch_source_set_timer(v11, v12, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
              *(_QWORD *)(v5 + 296) = v11;
              dispatch_resume(v11);
            }
          }
        }
      }
    }
  }
  v14 = *(_WORD *)(v5 + 32);
  *(_WORD *)(v5 + 32) = v14 | 0x40;
  error = v2;
  if ((_DWORD)v2)
  {
    if ((v14 & 0x20) != 0)
    {
      v79.domain = domain;
      *(_QWORD *)&v79.error = v2;
      HTTPTransaction::errorOccurred((HTTPTransaction *)v5, v79);
LABEL_31:
      v80.domain = domain;
      *(_QWORD *)&v80.error = v2;
      HTTPConnection::_onqueue_errorOccurred(this, v80, 0);
      return;
    }
  }
  else
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v15 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *(_QWORD *)(v5 + 280);
      v17 = *(_QWORD *)(v5 + 192);
      if (v17)
      {
        if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v17 + 56))(v17) < 0)
          v18 = 83;
        else
          v18 = 68;
        v19 = *(_QWORD *)(v5 + 192);
        if (v19)
          v19 = *(_QWORD *)(v19 + 96);
      }
      else
      {
        v19 = 0;
        v18 = 78;
      }
      *(_DWORD *)handler = 138543874;
      *(_QWORD *)&handler[4] = v16;
      *(_WORD *)&handler[12] = 1024;
      *(_DWORD *)&handler[14] = v18;
      *(_WORD *)&handler[18] = 2048;
      *(_QWORD *)&handler[20] = v19;
      _os_log_impl(&dword_183ECA000, v15, OS_LOG_TYPE_DEFAULT, "%{public}@ sent request, body %c %lld", handler, 0x1Cu);
    }
  }
  v20 = *(_WORD *)(v5 + 32);
  if ((v20 & 0x10) != 0)
  {
    *(_WORD *)(v5 + 32) = v20 & 0xFFEF;
    HTTPTransaction::_onqueue_invokeHandler((HTTPTransaction *)v5);
  }
LABEL_30:
  if (error)
    goto LABEL_31;
  v21 = *((_WORD *)this + 16) & 0xFBFF | (*((unsigned __int8 *)this + 34) << 16);
  *((_WORD *)this + 16) = *((_WORD *)this + 16) & 0xEBFF | 0x1000;
  *((_BYTE *)this + 34) = BYTE2(v21);
  *(_QWORD *)handler = 0;
  *(_QWORD *)&handler[8] = 0;
  v22 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
  if (!v22)
  {
    v23 = 0;
    goto LABEL_36;
  }
  v23 = std::__shared_weak_count::lock(v22);
  *(_QWORD *)&handler[8] = v23;
  if (!v23)
  {
LABEL_36:
    v24 = 0;
    goto LABEL_37;
  }
  v24 = *((_QWORD *)this + 5);
  *(_QWORD *)handler = v24;
LABEL_37:
  v26 = *((_QWORD *)this + 18);
  v25 = (std::__shared_weak_count *)*((_QWORD *)this + 19);
  v73 = v26;
  v74 = v25;
  if (v25)
  {
    p_shared_owners = (unint64_t *)&v25->__shared_owners_;
    do
      v28 = __ldxr(p_shared_owners);
    while (__stxr(v28 + 1, p_shared_owners));
  }
  v29 = MEMORY[0x1E0C809B0];
  v65[0] = MEMORY[0x1E0C809B0];
  v65[1] = 3321888768;
  v66 = ___ZN14HTTPConnection22_onqueue_requestFinishE13CFStreamError_block_invoke;
  v67 = &__block_descriptor_72_e8_40c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE56c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE_e5_v8__0l;
  v68 = this;
  v69 = v24;
  v70 = v23;
  if (v23)
  {
    v30 = (unint64_t *)&v23->__shared_owners_;
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  v71 = v26;
  v72 = v25;
  if (v25)
  {
    v32 = (unint64_t *)&v25->__shared_owners_;
    do
      v33 = __ldxr(v32);
    while (__stxr(v33 + 1, v32));
  }
  v63 = 0;
  v64 = 0;
  v34 = (std::__shared_weak_count *)*((_QWORD *)this + 11);
  if (v34 && (v64 = std::__shared_weak_count::lock(v34)) != 0 && (v35 = *((_QWORD *)this + 10), (v63 = v35) != 0))
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v61, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
    v59[0] = v29;
    v59[1] = 3321888768;
    v59[2] = ___ZN14HTTPConnection22_onqueue_requestFinishE13CFStreamError_block_invoke_23;
    v59[3] = &unk_1E14F2F40;
    v59[5] = v24;
    v60 = v23;
    if (v23)
    {
      v36 = (unint64_t *)&v23->__shared_owners_;
      do
        v37 = __ldxr(v36);
      while (__stxr(v37 + 1, v36));
    }
    v59[4] = v65;
    (*(void (**)(uint64_t, uint64_t *, _QWORD *))(*(_QWORD *)v35 + 16))(v35, &v61, v59);
    v38 = v62;
    if (v62)
    {
      v39 = (unint64_t *)&v62->__shared_owners_;
      do
        v40 = __ldaxr(v39);
      while (__stlxr(v40 - 1, v39));
      if (!v40)
      {
        ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
        std::__shared_weak_count::__release_weak(v38);
      }
    }
    v41 = v60;
    if (v60)
    {
      v42 = (unint64_t *)&v60->__shared_owners_;
      do
        v43 = __ldaxr(v42);
      while (__stlxr(v43 - 1, v42));
      if (!v43)
      {
        ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
        std::__shared_weak_count::__release_weak(v41);
      }
    }
  }
  else
  {
    v66((uint64_t)v65);
  }
  v44 = v64;
  if (v64)
  {
    v45 = (unint64_t *)&v64->__shared_owners_;
    do
      v46 = __ldaxr(v45);
    while (__stlxr(v46 - 1, v45));
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }
  v47 = v72;
  if (v72)
  {
    v48 = (unint64_t *)&v72->__shared_owners_;
    do
      v49 = __ldaxr(v48);
    while (__stlxr(v49 - 1, v48));
    if (!v49)
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
  }
  v50 = v70;
  if (v70)
  {
    v51 = (unint64_t *)&v70->__shared_owners_;
    do
      v52 = __ldaxr(v51);
    while (__stlxr(v52 - 1, v51));
    if (!v52)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }
  v53 = v74;
  if (v74)
  {
    v54 = (unint64_t *)&v74->__shared_owners_;
    do
      v55 = __ldaxr(v54);
    while (__stlxr(v55 - 1, v54));
    if (!v55)
    {
      ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
      std::__shared_weak_count::__release_weak(v53);
    }
  }
  v56 = *(std::__shared_weak_count **)&handler[8];
  if (*(_QWORD *)&handler[8])
  {
    v57 = (unint64_t *)(*(_QWORD *)&handler[8] + 8);
    do
      v58 = __ldaxr(v57);
    while (__stlxr(v58 - 1, v57));
    if (!v58)
    {
      ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
      std::__shared_weak_count::__release_weak(v56);
    }
  }
}

void sub_183F1BDF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;
  uint64_t v30;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v29);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a16);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a18);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a27);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a25);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a29);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v30 - 144);
  _Unwind_Resume(a1);
}

void HTTPConnectionCacheEntry::connCompletedRequest(_QWORD *a1, uint64_t *a2, uint64_t a3)
{
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  _QWORD v24[7];
  std::__shared_weak_count *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  std::__shared_weak_count *v29;

  v28 = 0;
  v29 = 0;
  v6 = (std::__shared_weak_count *)a1[6];
  if (v6 && (v6 = std::__shared_weak_count::lock(v6), (v29 = v6) != 0))
  {
    v7 = a1[5];
    v28 = v7;
  }
  else
  {
    v7 = 0;
  }
  v8 = a1[8];
  v24[0] = MEMORY[0x1E0C809B0];
  v24[1] = 3321888768;
  v24[2] = ___ZN24HTTPConnectionCacheEntry20connCompletedRequestENSt3__110shared_ptrI14HTTPConnectionEEU13block_pointerFvvE_block_invoke;
  v24[3] = &unk_1E14F45F8;
  v10 = *a2;
  v9 = (std::__shared_weak_count *)a2[1];
  v24[5] = a1;
  v24[6] = v10;
  v25 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v26 = v7;
  v27 = v6;
  if (v6)
  {
    v13 = (unint64_t *)&v6->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  v24[4] = a3;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v8 + 96))(v8, v24);
  v15 = v27;
  if (v27)
  {
    v16 = (unint64_t *)&v27->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v25;
  if (v25)
  {
    v19 = (unint64_t *)&v25->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = v29;
  if (v29)
  {
    v22 = (unint64_t *)&v29->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
}

void sub_183F1BFF0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3 - 48);
  _Unwind_Resume(a1);
}

CFMutableArrayRef HTTPCookieStorage::copyCookiesForURLWithMainDocumentURL(HTTPCookieStorage *this, const HTTPCookieStoragePolicy *a2, const __CFURL *a3)
{
  unsigned int v3;
  int v6;
  const __CFURL *v7;
  const __CFAllocator *v9;

  v3 = a3;
  v6 = *((_DWORD *)a2 + 10);
  if (v6 != 3)
  {
    if (v6 != -1)
      return HTTPCookieStorage::copyCookiesForURL(this, a2, v3);
    *((_DWORD *)a2 + 10) = 3;
  }
  v7 = (const __CFURL *)*((_QWORD *)a2 + 3);
  if (!v7 || HTTPCookieStorage::isURLInMainDocumentDomain(*((HTTPCookieStorage **)a2 + 2), v7, a3))
    return HTTPCookieStorage::copyCookiesForURL(this, a2, v3);
  v9 = CFGetAllocator((char *)this - 16);
  return CFArrayCreateMutable(v9, 0, MEMORY[0x1E0C9B378]);
}

uint64_t ___ZN11TubeManager22_onqueue_createNewTubeEP22HTTPConnectionCacheKey_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 32);
  if (a2)
    (*(void (**)(_QWORD))(*(_QWORD *)v2 + 56))(*(_QWORD *)(a1 + 32));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

void std::__shared_ptr_pointer<HTTPResponseMessage *,Deleter_release<HTTPResponseMessage>,std::allocator<HTTPResponseMessage>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
    CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t HTTPConnectionCacheEntry::_dispatchConnectionToProtocol(uint64_t a1, _QWORD *a2, HTTPConnectionCacheEntry::EnqueuedRequest **a3, unsigned int a4)
{
  HTTPConnectionCacheEntry::EnqueuedRequest *v7;
  uint64_t v8;
  BOOL v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  _QWORD *v22;
  HTTPConnectionCacheEntry::EnqueuedRequest *v23;
  uint64_t v24;
  os_unfair_lock_s *v25;
  BOOL v26;
  std::__shared_weak_count *v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  NSObject *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  HTTPRequestMessage *v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  std::__shared_weak_count *v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  _QWORD *v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  std::__shared_weak_count *shared_weak_owners;
  unint64_t v70;
  unint64_t *p_shared_weak_owners;
  unint64_t v72;
  unint64_t v73;
  unint64_t *v74;
  unint64_t v75;
  unint64_t v76;
  std::__shared_weak_count *v77;
  unint64_t *v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t *v81;
  unint64_t v82;
  uint64_t v83;
  std::__shared_weak_count *v84;
  unint64_t *v85;
  unint64_t v86;
  std::__shared_weak_count *v87;
  unint64_t *v88;
  unint64_t v89;
  __int128 v90;
  unint64_t *v91;
  unint64_t v92;
  std::__shared_weak_count *v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t *v96;
  unint64_t v97;
  std::__shared_weak_count *v98;
  unint64_t *v99;
  unint64_t v100;
  int v101;
  std::__shared_weak_count *v102;
  unint64_t *v103;
  unint64_t v104;
  std::__shared_weak_count *v105;
  unint64_t *v106;
  unint64_t v107;
  uint64_t v108;
  URLProtocol *v109;
  _QWORD *v110;
  _QWORD *v111;
  CFTypeID v112;
  std::__shared_weak_count *v113;
  uint64_t v114;
  unint64_t *v115;
  unint64_t v116;
  _BYTE *v117;
  void *v118;
  const void *v119;
  void *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  unint64_t *v124;
  unint64_t v125;
  BOOL v127;
  const char *v128;
  int v129;
  const char *v130;
  int v131;
  const char *v132;
  _QWORD *v134;
  HTTPConnectionCacheEntry::EnqueuedRequest **v135;
  uint64_t *v136;
  __int128 v137;
  uint64_t v138;
  __int128 v139;
  __int128 block;
  void *v141;
  void *v142;
  uint64_t v143;
  std::__shared_weak_count *v144;
  BOOL v145;
  __int128 v146;

  v7 = *a3;
  if (!*((_BYTE *)*a3 + 65))
  {
    *(_BYTE *)(a1 + 32) &= ~0x10u;
    v7 = *a3;
  }
  v8 = *a2;
  v9 = *((_BYTE *)v7 + 66) != 0;
  v10 = *(std::__shared_weak_count **)(*a2 + 48);
  if (v10)
  {
    v11 = std::__shared_weak_count::lock(v10);
    if (v11)
      v12 = *(_QWORD *)(v8 + 40);
    else
      v12 = 0;
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  v13 = *(NSObject **)(v8 + 56);
  v14 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&block = MEMORY[0x1E0C809B0];
  *((_QWORD *)&block + 1) = 3321888768;
  v141 = ___ZN14HTTPConnection26setShouldSkipPipelineProbeEb_block_invoke;
  v142 = &__block_descriptor_49_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e5_v8__0l;
  v143 = v12;
  v144 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  v145 = v9;
  dispatch_async(v13, &block);
  v17 = v144;
  if (v144)
  {
    v18 = (unint64_t *)&v144->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  if (v11)
  {
    v20 = (unint64_t *)&v11->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v22 = (_QWORD *)*a2;
  if ((*(_BYTE *)(a1 + 32) & 8) == 0
    || (*(_BYTE *)(a1 + 32) & 0x10) != 0 && (*(_BYTE *)(a1 + 32) & 0x60) != 0x20
    || (v23 = *a3, !*((_BYTE *)*a3 + 67)))
  {
    v26 = 0;
    goto LABEL_31;
  }
  v24 = *((_QWORD *)v23 + 5);
  if (!v24)
  {
    v25 = (os_unfair_lock_s *)*((_QWORD *)v23 + 4);
    if (v25)
      goto LABEL_182;
LABEL_183:
    v127 = 0;
    goto LABEL_184;
  }
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (*(_BYTE *)(v24 + 40))
    goto LABEL_183;
  v25 = (os_unfair_lock_s *)(v24 + 16);
LABEL_182:
  v127 = HTTPMessage::hasHeaderField(v25, 0x1470F3EAu) != 0;
LABEL_184:
  v26 = !v127;
LABEL_31:
  v27 = (std::__shared_weak_count *)v22[6];
  if (v27)
  {
    v28 = std::__shared_weak_count::lock(v27);
    if (v28)
      v29 = v22[5];
    else
      v29 = 0;
  }
  else
  {
    v29 = 0;
    v28 = 0;
  }
  v30 = v22[7];
  *(_QWORD *)&block = v14;
  *((_QWORD *)&block + 1) = 3321888768;
  v141 = ___ZN14HTTPConnection17setShouldPipelineEb_block_invoke;
  v142 = &__block_descriptor_49_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e5_v8__0l;
  v143 = v29;
  v144 = v28;
  if (v28)
  {
    v31 = (unint64_t *)&v28->__shared_owners_;
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
  }
  v145 = v26;
  dispatch_async(v30, &block);
  v33 = v144;
  if (v144)
  {
    v34 = (unint64_t *)&v144->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  if (v28)
  {
    v36 = (unint64_t *)&v28->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v38 = (*(uint64_t (**)(HTTPConnectionCacheEntry::EnqueuedRequest *))(*(_QWORD *)*a3 + 80))(*a3);
  v39 = HTTPConnectionCacheEntry::EnqueuedRequest::mutableRequest(*a3);
  if (v39)
  {
    v40 = v39;
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*(_BYTE *)(v40 + 40))
      v41 = 0;
    else
      v41 = (HTTPRequestMessage *)(v40 + 16);
  }
  else
  {
    v41 = 0;
  }
  AuthenticationCache::applyAuthenticationToRequest(v38, v41);
  v42 = *MEMORY[0x1E0C9AE00];
  v43 = (char *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 48, 0);
  *((_OWORD *)v43 + 1) = 0u;
  *((_OWORD *)v43 + 2) = 0u;
  *(_OWORD *)v43 = 0u;
  v44 = a2[1];
  *(_QWORD *)&v139 = *a2;
  *((_QWORD *)&v139 + 1) = v44;
  if (v44)
  {
    v45 = (unint64_t *)(v44 + 8);
    do
      v46 = __ldxr(v45);
    while (__stxr(v46 + 1, v45));
  }
  v47 = HTTPConnectionCacheEntry::EnqueuedRequest::mutableRequest(*a3);
  if (v47)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*(_BYTE *)(v47 + 40))
      v48 = 0;
    else
      v48 = v47 + 16;
  }
  else
  {
    v48 = 0;
  }
  v49 = (*(uint64_t (**)(HTTPConnectionCacheEntry::EnqueuedRequest *))(*(_QWORD *)*a3 + 80))(*a3);
  (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)*a3 + 96))(&v137);
  *(_QWORD *)v43 = off_1E14EF578;
  *((_QWORD *)v43 + 1) = v42;
  *((_DWORD *)v43 + 4) = 1;
  if (((unint64_t)(v43 + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  v134 = a2;
  v135 = a3;
  *((_QWORD *)v43 + 3) = &unk_1E14EC578;
  *(_QWORD *)v43 = off_1E14EC490;
  *((_QWORD *)v43 + 4) = 0;
  v136 = (uint64_t *)(v43 + 32);
  *((_QWORD *)v43 + 5) = 0;
  v50 = (std::__shared_weak_count *)operator new(0x148uLL);
  *(_OWORD *)&v50->__shared_owners_ = 0u;
  v51 = (unint64_t *)&v50->__shared_owners_;
  v50[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14E7948;
  v52 = v50 + 1;
  v50->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0AD0;
  *(_OWORD *)&v50[5].__shared_weak_owners_ = v137;
  v50[6].__shared_owners_ = v138;
  *(_OWORD *)&v50[1].__shared_owners_ = 0u;
  v50[2].__vftable = (std::__shared_weak_count_vtbl *)&unk_1E14E7A30;
  *(_OWORD *)&v50[6].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v50[7].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v50[8].__shared_owners_ = 0u;
  v50[9].std::__shared_count = 0u;
  *(_OWORD *)&v50[12].__shared_weak_owners_ = 0u;
  LOWORD(v50[2].__shared_owners_) = 0;
  v50[4].__shared_weak_owners_ = 0;
  LODWORD(v50[5].__vftable) = 0;
  v50[5].__shared_owners_ = 0;
  *(_OWORD *)((char *)&v50[3].__shared_weak_owners_ + 4) = 0u;
  *(_OWORD *)&v50[2].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v50[3].__shared_owners_ = 0u;
  block = 0u;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)&v50[6].__shared_weak_owners_, &block);
  v53 = (std::__shared_weak_count *)*((_QWORD *)&block + 1);
  if (*((_QWORD *)&block + 1))
  {
    v54 = (unint64_t *)(*((_QWORD *)&block + 1) + 8);
    do
      v55 = __ldaxr(v54);
    while (__stlxr(v55 - 1, v54));
    if (!v55)
    {
      ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
      std::__shared_weak_count::__release_weak(v53);
    }
  }
  v50[7].__shared_owners_ = 0;
  if (!v48)
  {
    v128 = "request";
    v129 = 62;
    goto LABEL_188;
  }
  CFRetain((CFTypeRef)(v48 - 16));
  *(_QWORD *)&block = v48;
  v56 = (_QWORD *)operator new();
  *v56 = &off_1E14F16D8;
  v56[1] = 0;
  v56[2] = 0;
  v56[3] = v48;
  *((_QWORD *)&block + 1) = v56;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)&v50[7].__shared_weak_owners_, &block);
  v57 = (std::__shared_weak_count *)*((_QWORD *)&block + 1);
  if (*((_QWORD *)&block + 1))
  {
    v58 = (unint64_t *)(*((_QWORD *)&block + 1) + 8);
    do
      v59 = __ldaxr(v58);
    while (__stlxr(v59 - 1, v58));
    if (!v59)
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
  }
  block = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)&v50[8].__shared_owners_, &block);
  v60 = (std::__shared_weak_count *)*((_QWORD *)&block + 1);
  if (*((_QWORD *)&block + 1))
  {
    v61 = (unint64_t *)(*((_QWORD *)&block + 1) + 8);
    do
      v62 = __ldaxr(v61);
    while (__stlxr(v62 - 1, v61));
    if (!v62)
    {
      ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
      std::__shared_weak_count::__release_weak(v60);
    }
  }
  block = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)&v50[9], &block);
  v63 = (std::__shared_weak_count *)*((_QWORD *)&block + 1);
  if (*((_QWORD *)&block + 1))
  {
    v64 = (unint64_t *)(*((_QWORD *)&block + 1) + 8);
    do
      v65 = __ldaxr(v64);
    while (__stlxr(v65 - 1, v64));
    if (!v65)
    {
      ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
      std::__shared_weak_count::__release_weak(v63);
    }
  }
  if (!v49)
  {
    v128 = "client";
    v129 = 70;
LABEL_188:
    __assert_rtn("HTTPTransaction", "HTTPTransaction.cpp", v129, v128);
  }
  v50[9].__shared_weak_owners_ = v49;
  (*(void (**)(uint64_t))(*(_QWORD *)v49 + 16))(v49);
  LOWORD(v50[11].__shared_owners_) = 0;
  v50[10].std::__shared_count = 0u;
  *(_OWORD *)&v50[10].__shared_weak_owners_ = 0u;
  v50[11].__shared_weak_owners_ = 0;
  v50[12].__vftable = 0;
  (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)v50[9].__shared_weak_owners_ + 72))(&block);
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)&v50[12].__shared_weak_owners_, &block);
  v66 = (std::__shared_weak_count *)*((_QWORD *)&block + 1);
  if (*((_QWORD *)&block + 1))
  {
    v67 = (unint64_t *)(*((_QWORD *)&block + 1) + 8);
    do
      v68 = __ldaxr(v67);
    while (__stlxr(v68 - 1, v67));
    if (!v68)
    {
      ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
      std::__shared_weak_count::__release_weak(v66);
    }
  }
  v50[13].__shared_owners_ = 0;
  *(_QWORD *)&v146 = v50 + 1;
  *((_QWORD *)&v146 + 1) = v50;
  shared_weak_owners = (std::__shared_weak_count *)v50[1].__shared_weak_owners_;
  if (shared_weak_owners)
  {
    if (shared_weak_owners->__shared_owners_ != -1)
      goto LABEL_107;
    do
      v70 = __ldxr(v51);
    while (__stxr(v70 + 1, v51));
    p_shared_weak_owners = (unint64_t *)&v50->__shared_weak_owners_;
    do
      v72 = __ldxr(p_shared_weak_owners);
    while (__stxr(v72 + 1, p_shared_weak_owners));
    v50[1].__shared_owners_ = (uint64_t)v52;
    v50[1].__shared_weak_owners_ = (uint64_t)v50;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  else
  {
    do
      v73 = __ldxr(v51);
    while (__stxr(v73 + 1, v51));
    v74 = (unint64_t *)&v50->__shared_weak_owners_;
    do
      v75 = __ldxr(v74);
    while (__stxr(v75 + 1, v74));
    v50[1].__shared_owners_ = (uint64_t)v52;
    v50[1].__shared_weak_owners_ = (uint64_t)v50;
  }
  do
    v76 = __ldaxr(v51);
  while (__stlxr(v76 - 1, v51));
  if (!v76)
  {
    ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
    std::__shared_weak_count::__release_weak(v50);
  }
LABEL_107:
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v136, &v146);
  v77 = (std::__shared_weak_count *)*((_QWORD *)&v146 + 1);
  if (*((_QWORD *)&v146 + 1))
  {
    v78 = (unint64_t *)(*((_QWORD *)&v146 + 1) + 8);
    do
      v79 = __ldaxr(v78);
    while (__stlxr(v79 - 1, v78));
    if (!v79)
    {
      ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
      std::__shared_weak_count::__release_weak(v77);
    }
  }
  v80 = *v136;
  v146 = v139;
  if (*((_QWORD *)&v139 + 1))
  {
    v81 = (unint64_t *)(*((_QWORD *)&v139 + 1) + 8);
    do
      v82 = __ldxr(v81);
    while (__stxr(v82 + 1, v81));
  }
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&block, *(_QWORD *)(v80 + 8), *(std::__shared_weak_count **)(v80 + 16));
  v84 = (std::__shared_weak_count *)*((_QWORD *)&block + 1);
  v83 = block;
  if (*((_QWORD *)&block + 1))
  {
    v85 = (unint64_t *)(*((_QWORD *)&block + 1) + 16);
    do
      v86 = __ldxr(v85);
    while (__stxr(v86 + 1, v85));
  }
  v87 = *(std::__shared_weak_count **)(v80 + 48);
  *(_QWORD *)(v80 + 40) = v83;
  *(_QWORD *)(v80 + 48) = v84;
  if (v87)
  {
    std::__shared_weak_count::__release_weak(v87);
    v84 = (std::__shared_weak_count *)*((_QWORD *)&block + 1);
  }
  if (v84)
  {
    v88 = (unint64_t *)&v84->__shared_owners_;
    do
      v89 = __ldaxr(v88);
    while (__stlxr(v89 - 1, v88));
    if (!v89)
    {
      ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
      std::__shared_weak_count::__release_weak(v84);
    }
  }
  v90 = v146;
  if (*((_QWORD *)&v146 + 1))
  {
    v91 = (unint64_t *)(*((_QWORD *)&v146 + 1) + 16);
    do
      v92 = __ldxr(v91);
    while (__stxr(v92 + 1, v91));
  }
  v93 = *(std::__shared_weak_count **)(v80 + 64);
  *(_OWORD *)(v80 + 56) = v90;
  if (v93)
    std::__shared_weak_count::__release_weak(v93);
  v94 = *(_QWORD *)(v90 + 56);
  if (!v94)
  {
    *(_QWORD *)(v80 + 72) = 0;
    v130 = "_workQueue";
    v131 = 142;
    v132 = "initialize";
    goto LABEL_190;
  }
  dispatch_retain(*(dispatch_object_t *)(v90 + 56));
  *(_QWORD *)(v80 + 72) = v94;
  *(_WORD *)(v80 + 32) |= 0x20u;
  v95 = *(_QWORD *)(v90 + 112);
  *(_QWORD *)&block = *(_QWORD *)(v90 + 104);
  *((_QWORD *)&block + 1) = v95;
  if (v95)
  {
    v96 = (unint64_t *)(v95 + 8);
    do
      v97 = __ldxr(v96);
    while (__stxr(v97 + 1, v96));
  }
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v80 + 136, &block);
  v98 = (std::__shared_weak_count *)*((_QWORD *)&block + 1);
  if (*((_QWORD *)&block + 1))
  {
    v99 = (unint64_t *)(*((_QWORD *)&block + 1) + 8);
    do
      v100 = __ldaxr(v99);
    while (__stlxr(v100 - 1, v99));
    if (!v100)
    {
      ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
      std::__shared_weak_count::__release_weak(v98);
    }
  }
  v101 = *(_DWORD *)(v80 + 80);
  if (v101 != 11)
  {
    if (v101 < 2)
    {
      *(_DWORD *)(v80 + 80) = 1;
      goto LABEL_142;
    }
    v130 = "newState >= _state";
    v131 = 1664;
    v132 = "_onqueue_changeState";
LABEL_190:
    __assert_rtn(v132, "HTTPTransaction.cpp", v131, v130);
  }
LABEL_142:
  v102 = (std::__shared_weak_count *)*((_QWORD *)&v146 + 1);
  if (*((_QWORD *)&v146 + 1))
  {
    v103 = (unint64_t *)(*((_QWORD *)&v146 + 1) + 8);
    do
      v104 = __ldaxr(v103);
    while (__stlxr(v104 - 1, v103));
    if (!v104)
    {
      ((void (*)(std::__shared_weak_count *))v102->__on_zero_shared)(v102);
      std::__shared_weak_count::__release_weak(v102);
    }
  }
  v105 = (std::__shared_weak_count *)*((_QWORD *)&v139 + 1);
  if (*((_QWORD *)&v139 + 1))
  {
    v106 = (unint64_t *)(*((_QWORD *)&v139 + 1) + 8);
    do
      v107 = __ldaxr(v106);
    while (__stlxr(v107 - 1, v106));
    if (!v107)
    {
      ((void (*)(std::__shared_weak_count *))v105->__on_zero_shared)(v105);
      std::__shared_weak_count::__release_weak(v105);
    }
  }
  v108 = (*(uint64_t (**)(HTTPConnectionCacheEntry::EnqueuedRequest *))(*(_QWORD *)*v135 + 80))(*v135);
  if (v108)
    v109 = (URLProtocol *)(v108 - 176);
  else
    v109 = 0;
  if (objc_msgSend(*((id *)v109 + 10), "_preconnect", &v50[6].__shared_weak_owners_))
  {
    block = 0uLL;
    v110 = (_QWORD *)(*(uint64_t (**)(char *, uint64_t))(*(_QWORD *)v43 + 56))(v43, 26);
    v111 = v110;
    if (!v110)
      goto LABEL_171;
    v112 = CFGetTypeID(v110);
    if (TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::sOnce != -1)
      dispatch_once(&TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::sOnce, &__block_literal_global_59);
    if (v112 == *(_QWORD *)(TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::clazz + 96))
    {
      v114 = v111[3];
      v113 = (std::__shared_weak_count *)v111[4];
      if (v113)
      {
        v115 = (unint64_t *)&v113->__shared_owners_;
        do
          v116 = __ldxr(v115);
        while (__stxr(v116 + 1, v115));
      }
      *(_QWORD *)&block = v114;
      *((_QWORD *)&block + 1) = v113;
      if (v114)
      {
        v117 = (_BYTE *)(*(uint64_t (**)(URLProtocol *))(*(_QWORD *)v109 + 744))(v109);
        v118 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v114 + 248))(v114);
        -[__CFN_TransactionMetrics linkWithConnection:](v117, v118);
        v119 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v114 + 216))(v114, 0x1EDCFAD40);
        v120 = (void *)*((_QWORD *)v109 + 10);
        if (v120)
          objc_msgSend(v120, "set_TCPConnectionMetadata:", v119);
        if (v119)
          CFRelease(v119);
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v114 + 88))(v114, 1);
      }
    }
    else
    {
LABEL_171:
      v113 = 0;
    }
    URLProtocol::sendDidFinishLoading(v109);
    if (v111)
      CFRelease(v111);
    if (v113)
    {
      v124 = (unint64_t *)&v113->__shared_owners_;
      do
        v125 = __ldaxr(v124);
      while (__stlxr(v125 - 1, v124));
      if (!v125)
      {
        ((void (*)(std::__shared_weak_count *))v113->__on_zero_shared)(v113);
        std::__shared_weak_count::__release_weak(v113);
      }
    }
    goto LABEL_179;
  }
  v121 = (*(uint64_t (**)(HTTPConnectionCacheEntry::EnqueuedRequest *))(*(_QWORD *)*v135 + 80))(*v135);
  v122 = (*(uint64_t (**)(HTTPConnectionCacheEntry::EnqueuedRequest *))(*(_QWORD *)*v135 + 88))(*v135);
  if (!(*(unsigned int (**)(uint64_t, char *, uint64_t, _QWORD))(*(_QWORD *)v121 + 80))(v121, v43 + 24, v122, a4))
  {
LABEL_179:
    v123 = 0;
    goto LABEL_180;
  }
  *(_DWORD *)(*v134 + 240) = *((_DWORD *)*v135 + 12);
  v123 = 1;
LABEL_180:
  (*(void (**)(char *))(*(_QWORD *)v43 + 48))(v43);
  return v123;
}

void sub_183F1CD10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,char a21)
{
  const void *v21;
  const void *v22;

  if (v22)
    CFRelease(v22);
  CFRelease(v21);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a21);
  _Unwind_Resume(a1);
}

uint64_t HTTPConnectionCacheEntry::EnqueuedRequest::mutableRequest(HTTPConnectionCacheEntry::EnqueuedRequest *this)
{
  uint64_t result;
  uint64_t v3;

  result = *((_QWORD *)this + 5);
  if (!result)
  {
    v3 = *((_QWORD *)this + 4);
    if (v3)
    {
      *((_QWORD *)this + 5) = CFHTTPMessageCreateCopy(*((CFAllocatorRef *)this + 1), (CFHTTPMessageRef)(v3 - 16));
      CFRelease((CFTypeRef)(*((_QWORD *)this + 4) - 16));
      *((_QWORD *)this + 4) = 0;
      return *((_QWORD *)this + 5);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void AuthenticationCache::applyAuthenticationToRequest(uint64_t a1, HTTPRequestMessage *a2)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  AuthenticationState *v6;
  std::__shared_weak_count *v7;

  (*(void (**)(AuthenticationState **__return_ptr))(*(_QWORD *)a1 + 88))(&v6);
  if (v6 && AuthenticationState::canApplyHeadersToRequest(v6, a2))
    (*(void (**)(AuthenticationState *, HTTPRequestMessage *, _QWORD, _QWORD))(*(_QWORD *)v6 + 24))(v6, a2, 0, 0);
  v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_183F1CF10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL AuthenticationState::canApplyHeadersToRequest(AuthenticationState *this, HTTPRequestMessage *a2)
{
  _QWORD *v4;
  uint64_t v5;
  int v6;
  unsigned __int8 v8;
  _QWORD v9[3];
  _QWORD *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (this)
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  v8 = 0;
  if (a2 && AuthenticationState::_isValid((uint64_t)this, 0))
  {
    v9[0] = &off_1E14F0558;
    v9[1] = a2;
    v9[2] = &v8;
    v10 = v9;
    AuthenticationState::_foreachAuthenticationInfo((uint64_t)this, (uint64_t)v9);
    v4 = v10;
    if (v10 == v9)
    {
      v5 = 4;
      v4 = v9;
    }
    else
    {
      if (!v10)
        goto LABEL_10;
      v5 = 5;
    }
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
LABEL_10:
  v6 = v8;
  if (this)
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
  return v6 != 0;
}

void sub_183F1D008(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == &a10)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  if (v13)
    pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8));
  _Unwind_Resume(exception_object);
}

BOOL AuthenticationState::_isValid(uint64_t a1, int a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;
  std::__shared_weak_count *v11;
  BOOL isValid;
  _QWORD v13[3];
  _QWORD *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 104) && !*(_QWORD *)(a1 + 128))
    return 0;
  isValid = 1;
  if (a2)
  {
    if (AuthenticationState::_haveAuthenticationInfo(a1, a2))
    {
      AuthenticationState::_authForType(&v10, a1, a2);
      isValid = AuthenticationInfo::isValid(*(_QWORD *)(v10 + 8));
      v4 = v11;
      if (v11)
      {
        p_shared_owners = (unint64_t *)&v11->__shared_owners_;
        do
          v6 = __ldaxr(p_shared_owners);
        while (__stlxr(v6 - 1, p_shared_owners));
        if (!v6)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
    }
    return isValid;
  }
  v13[0] = &off_1E14F05A0;
  v13[1] = a1;
  v13[2] = &isValid;
  v14 = v13;
  AuthenticationState::_foreachAuthenticationInfo(a1, (uint64_t)v13);
  v7 = v14;
  if (v14 == v13)
  {
    v8 = 4;
    v7 = v13;
    goto LABEL_15;
  }
  if (v14)
  {
    v8 = 5;
LABEL_15:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return isValid;
}

void sub_183F1D198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL `non-virtual thunk to'HTTPProtocol::useNetStreamInfoForRequest(HTTPProtocol *this, MetaNetStreamInfo *a2, const HTTPRequestMessage *a3, int a4)
{
  return HTTPProtocol::useNetStreamInfoForRequest((HTTPProtocol *)((char *)this - 176), a2, a3, a4);
}

HTTPProtocol *`non-virtual thunk to'HTTPProtocol::copyTaskLoggableDescription@<X0>(HTTPProtocol *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *((_QWORD *)this + 78);
  *a2 = *((_QWORD *)this + 77);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

__n128 HTTPConnectionCacheEntry::EnqueuedRequest::getOptions@<Q0>(__n128 *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result;

  result = this[3];
  *a2 = result;
  a2[1].n128_u64[0] = this[4].n128_u64[0];
  return result;
}

void sub_183F1D3E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::closeAndClearHandler(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 96))(*((_QWORD *)this + 1));
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::rawBytesReceived(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 120))(*((_QWORD *)this + 1));
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::_meta_release(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(char *))(*((_QWORD *)this - 3) + 48))((char *)this - 24);
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::rawBytesSent(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 112))(*((_QWORD *)this + 1));
}

uint64_t std::__shared_ptr_emplace<HTTPTransaction>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void HTTPTransactionWrapper::~HTTPTransactionWrapper(HTTPTransactionWrapper *this)
{
  *(_QWORD *)this = off_1E14EC490;
  *((_QWORD *)this + 3) = &unk_1E14EC578;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 32);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

{
  *(_QWORD *)this = off_1E14EC490;
  *((_QWORD *)this + 3) = &unk_1E14EC578;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 32);
}

void CapturedProperties::~CapturedProperties(CapturedProperties *this)
{
  const void *v2;

  v2 = (const void *)*((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1E14E91C8;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    CFRelease(v2);
  JUMPOUT(0x186DB748CLL);
}

{
  const void *v2;

  v2 = (const void *)*((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1E14E91C8;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    CFRelease(v2);
}

void HTTPTransaction::closeAndClearHandler(HTTPTransaction *this)
{
  __int16 v2;
  const void *v3;
  const void *v4;
  const void *v5;
  int v6;
  CFStreamError v7;

  *((_BYTE *)this + 249) = 0;
  v2 = *((_WORD *)this + 16);
  if ((v2 & 4) != 0)
  {
    *((_WORD *)this + 16) = v2 & 0xFFFB;
    v3 = (const void *)*((_QWORD *)this + 28);
    if (v3)
    {
      _Block_release(v3);
      *((_QWORD *)this + 28) = 0;
    }
    v4 = (const void *)*((_QWORD *)this + 30);
    if (v4)
    {
      _Block_release(v4);
      *((_QWORD *)this + 30) = 0;
    }
    HTTPTransaction::_onqueue_updateScheduling(this, 0, 0);
  }
  v5 = (const void *)*((_QWORD *)this + 19);
  if (v5)
  {
    _Block_release(v5);
    *((_QWORD *)this + 19) = 0;
  }
  v6 = *((_DWORD *)this + 20);
  if (v6 < 8)
  {
    v7.domain = 1;
    *(_QWORD *)&v7.error = 89;
    HTTPTransaction::_onqueue_handleError(this, v7);
LABEL_11:
    HTTPTransaction::_onqueue_closeAndCleanup(this);
    return;
  }
  if (v6 != 10)
  {
    if (v6 != 11)
    {
      if (v6 >= 0xA)
        __assert_rtn("_onqueue_changeState", "HTTPTransaction.cpp", 1664, "newState >= _state");
      *((_DWORD *)this + 20) = 9;
    }
    goto LABEL_11;
  }
}

uint64_t HTTPTransaction::rawBytesReceived(HTTPTransaction *this)
{
  uint64_t v1;
  _QWORD v3[3];
  uint64_t v4;

  v3[0] = 0;
  v3[1] = v3;
  v3[2] = 0x2020000000;
  v4 = *((_QWORD *)this + 33);
  v1 = v4;
  _Block_object_dispose(v3, 8);
  return v1;
}

uint64_t HTTPTransaction::rawBytesSent(HTTPTransaction *this)
{
  uint64_t v1;
  _QWORD v3[3];
  uint64_t v4;

  v3[0] = 0;
  v3[1] = v3;
  v3[2] = 0x2020000000;
  v4 = *((_QWORD *)this + 32);
  v1 = v4;
  _Block_object_dispose(v3, 8);
  return v1;
}

void HTTPEngine::_readBodyFinish(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  const void *v14;
  void (**v15)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  __int128 v16;

  HTTPEngine::_updateBytesTransferred((HTTPEngine *)a1);
  if ((_DWORD)a5)
  {
    if (!(_DWORD)a4)
    {
      v10 = *(_DWORD *)(a1 + 32);
      if ((v10 & 0x10) != 0)
        *(_DWORD *)(a1 + 32) = v10 | 0x40;
    }
  }
  v16 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 144, &v16);
  v11 = (std::__shared_weak_count *)*((_QWORD *)&v16 + 1);
  if (*((_QWORD *)&v16 + 1))
  {
    v12 = (unint64_t *)(*((_QWORD *)&v16 + 1) + 8);
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = *(const void **)(a1 + 160);
  if (v14)
  {
    _Block_release(v14);
    *(_QWORD *)(a1 + 160) = 0;
  }
  v15 = *(void (***)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 208);
  if (v15)
  {
    *(_QWORD *)(a1 + 208) = 0;
    v15[2](v15, a2, a3, a4, a5);
    _Block_release(v15);
  }
  if ((_DWORD)a4)
  {
    if (!*(_QWORD *)(a1 + 96) && !*(_DWORD *)(a1 + 104))
    {
      *(_QWORD *)(a1 + 96) = a3;
      *(_QWORD *)(a1 + 104) = a4;
    }
    HTTPEngine::_cleanupConnection((HTTPEngine *)a1, 0);
  }
}

void CFURLRequestSetShouldPipelineHTTP(void *a1, char a2, char a3)
{
  uint64_t v5;
  HTTPRequest *fHTTPRequest;
  URLRequest *v7;
  void (**v8)(StringSerializable *__hidden);
  CFTypeRef cf;

  v5 = objc_msgSend(a1, "_inner");
  *(_WORD *)(v5 + 64) |= 0x200u;
  fHTTPRequest = *(HTTPRequest **)(v5 + 56);
  if (!fHTTPRequest)
  {
    v7 = (URLRequest *)v5;
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v8);
    URLRequest::createHTTPRequest(v7, (CFTypeRef *)&v8);
    v8 = &off_1E14E9A00;
    if (cf)
      CFRelease(cf);
    fHTTPRequest = v7->fHTTPRequest;
  }
  *((_BYTE *)fHTTPRequest + 216) = a2;
  *((_BYTE *)fHTTPRequest + 217) = a3;
}

void sub_183F1D8E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void MetaConnectionCache::MetaConnectionCache(MetaConnectionCache *this, const __CFAllocator *a2)
{
  *(_QWORD *)this = off_1E14EF578;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = 1;
  if ((((unint64_t)this + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)this = off_1E14EA0F0;
  *((_QWORD *)this + 3) = objc_alloc_init(MEMORY[0x1E0C99DE8]);
}

BOOL IsCFURLCache(_BOOL8 result)
{
  const void *v1;
  uint64_t TypeID;

  if (result)
  {
    v1 = (const void *)result;
    TypeID = CFURLCacheGetTypeID();
    return TypeID == CFGetTypeID(v1);
  }
  return result;
}

void ___ZN14HTTPConnection22_onqueue_responseStartEv_block_invoke(uint64_t a1, HTTPMessage **a2, CFStreamError a3)
{
  uint64_t v3;
  CFIndex domain;
  HTTPConnection *v7;
  HTTPMessage *v8;
  HTTPMessage *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  HTTPMessage *v14[2];
  CFStreamError v15;

  v3 = *(_QWORD *)&a3.error;
  domain = a3.domain;
  if (!a3.error)
    HTTPConnection::_onqueue_checkAndUpdateLargeDownload(*(_QWORD *)(a1 + 32));
  v7 = *(HTTPConnection **)(a1 + 32);
  v8 = *a2;
  v9 = a2[1];
  v14[0] = v8;
  v14[1] = v9;
  if (v9)
  {
    v10 = (unint64_t *)((char *)v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  v15.domain = domain;
  *(_QWORD *)&v15.error = v3;
  HTTPConnection::_onqueue_responseHeadersArrived(v7, v14, v15);
  if (v9)
  {
    v12 = (unint64_t *)((char *)v9 + 8);
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      (*(void (**)(HTTPMessage *))(*(_QWORD *)v9 + 16))(v9);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v9);
    }
  }
}

void sub_183F1DA80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void HTTPConnection::_onqueue_responseHeadersArrived(HTTPConnection *this, HTTPMessage **a2, CFStreamError a3)
{
  uint64_t v3;
  CFIndex domain;
  std::__shared_weak_count *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  HTTPResponseMessage *v14;
  unint64_t *v15;
  unint64_t v16;
  HTTPResponseMessage **v17;
  const void *v18;
  __CFHTTPMessage *v19;
  CFIndex ResponseStatusCode;
  uint64_t v21;
  const void *v22;
  std::__shared_weak_count *v23;
  std::__shared_weak_count *v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  CFIndex v27;
  _BOOL4 v29;
  unint64_t *v30;
  unint64_t v31;
  int v32;
  NSObject *v33;
  uint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  CFIndex v37;
  CFStringRef v38;
  CFStringRef v39;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const __CFString *v45;
  const __CFAllocator *v46;
  const __CFArray *ArrayBySeparatingStrings;
  CFIndex Count;
  CFIndex v49;
  const __CFString *ValueAtIndex;
  const __CFArray *v51;
  CFIndex v52;
  const __CFString *v53;
  CFMutableStringRef v54;
  int v55;
  CFMutableStringRef MutableCopy;
  SInt32 IntValue;
  char v58;
  const __CFString *v59;
  CFMutableStringRef v60;
  SInt32 v61;
  SInt32 v62;
  SInt32 v63;
  std::__shared_weak_count *v64;
  unint64_t *v65;
  unint64_t v66;
  const char *v67;
  int v68;
  const __CFString *v69;
  SInt32 v70;
  std::__shared_weak_count *v71;
  uint64_t v72;
  std::__shared_weak_count *v73;
  uint64_t v74;
  std::__shared_weak_count *v75;
  _BYTE cf[12];
  __int16 v77;
  CFIndex v78;
  __int16 v79;
  int v80;
  uint64_t v81;
  CFStreamError v82;
  CFStreamError v83;
  CFStreamError v84;

  v3 = *(_QWORD *)&a3.error;
  domain = a3.domain;
  v81 = *MEMORY[0x1E0C80C00];
  v74 = 0;
  v75 = 0;
  v7 = (std::__shared_weak_count *)*((_QWORD *)this + 11);
  if (!v7)
    goto LABEL_8;
  v75 = std::__shared_weak_count::lock(v7);
  if (!v75)
    goto LABEL_8;
  v8 = *((_QWORD *)this + 10);
  v74 = v8;
  if (!v8)
    goto LABEL_8;
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v72, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v8 + 32))(v8, &v72);
  v9 = v73;
  if (!v73)
    goto LABEL_8;
  p_shared_owners = (unint64_t *)&v73->__shared_owners_;
  do
    v11 = __ldaxr(p_shared_owners);
  while (__stlxr(v11 - 1, p_shared_owners));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if ((_DWORD)v3)
      goto LABEL_9;
  }
  else
  {
LABEL_8:
    if ((_DWORD)v3)
    {
LABEL_9:
      v82.domain = domain;
      *(_QWORD *)&v82.error = v3;
      HTTPConnection::_onqueue_errorOccurred(this, v82, 0);
      goto LABEL_104;
    }
  }
  if (!*((_QWORD *)this + 20))
  {
    v67 = "_currentResponse";
    v68 = 1424;
    goto LABEL_114;
  }
  if (!*a2)
  {
    v67 = "headers";
    v68 = 1427;
LABEL_114:
    __assert_rtn("_onqueue_responseHeadersArrived", "HTTPConnection.cpp", v68, v67);
  }
  (*(void (**)(_QWORD, HTTPMessage *, HTTPConnection *))(**((_QWORD **)this + 22) + 16))(*((_QWORD *)this + 22), *a2, this);
  v12 = *((_QWORD *)this + 20);
  v14 = *a2;
  v13 = (uint64_t)a2[1];
  v71 = (std::__shared_weak_count *)v13;
  if (v13)
  {
    v15 = (unint64_t *)(v13 + 8);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  if (*(int *)(v12 + 80) >= 7)
    __assert_rtn("consumeResponseHeaders", "HTTPTransaction.cpp", 407, "_state < State::ReceivingResponse");
  *(_DWORD *)(v12 + 80) = 7;
  v17 = (HTTPResponseMessage **)(v12 + 176);
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v12 + 176), (uint64_t)v14, v13);
  HTTPTransaction::stopStallTimer((HTTPTransaction *)v12);
  HTTPTransaction::captureStreamProperties((HTTPTransaction *)v12);
  v18 = (const void *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*(_QWORD *)(v12 + 160) + 128));
  HTTPResponseMessage::setResponseURL(v14, v18, 0);
  if (*(_QWORD *)(v12 + 176))
    v19 = (HTTPResponseMessage *)((char *)*v17 - 16);
  else
    v19 = 0;
  ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v19);
  if (ResponseStatusCode == 407)
  {
    v21 = *(_QWORD *)(v12 + 136);
    if (v21)
    {
      (*(void (**)(_BYTE *__return_ptr))(*(_QWORD *)v21 + 48))(cf);
      HTTPResponseMessage::setResponseURL(*v17, *(CFTypeRef *)cf, 1);
      v22 = *(const void **)cf;
      *(_QWORD *)cf = 0;
      if (v22)
        CFRelease(v22);
    }
  }
  v23 = *(std::__shared_weak_count **)(v12 + 64);
  if (v23)
  {
    v24 = std::__shared_weak_count::lock(v23);
    if (v24)
    {
      v25 = v24;
      v26 = *(_QWORD *)(v12 + 56);
      if (v26
        && ((*(unsigned __int16 *)(v26 + 32) | (*(unsigned __int8 *)(v26 + 34) << 16)) & 0x20000) == 0
        && *(_QWORD *)(v12 + 192)
        && *v17)
      {
        v27 = CFHTTPMessageGetResponseStatusCode((HTTPResponseMessage *)((char *)*v17 - 16));
        v29 = v27 != 407 && (unint64_t)(v27 - 400) < 0xC8;
      }
      else
      {
        v29 = 0;
      }
      v30 = (unint64_t *)&v25->__shared_owners_;
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (v31)
      {
        if (!v29)
          goto LABEL_42;
        goto LABEL_41;
      }
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
      if (v29)
LABEL_41:
        *(_WORD *)(v12 + 32) &= ~0x20u;
    }
  }
LABEL_42:
  if (HTTPMessage::hasHeaderField((os_unfair_lock_s *)*v17, 0x11D1D2CFu))
  {
    v32 = 75;
  }
  else if (*((_BYTE *)*v17 + 296))
  {
    v32 = 67;
  }
  else
  {
    v32 = 85;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v33 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v34 = *(_QWORD *)(v12 + 280);
    *(_DWORD *)cf = 138543874;
    *(_QWORD *)&cf[4] = v34;
    v77 = 2048;
    v78 = ResponseStatusCode;
    v79 = 1024;
    v80 = v32;
    _os_log_impl(&dword_183ECA000, v33, OS_LOG_TYPE_DEFAULT, "%{public}@ received response, status %ld content %c", cf, 0x1Cu);
  }
  if (v71)
  {
    v35 = (unint64_t *)&v71->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
      std::__shared_weak_count::__release_weak(v71);
    }
  }
  v37 = CFHTTPMessageGetResponseStatusCode((HTTPMessage *)((char *)*a2 - 16));
  v38 = HTTPMessage::copyHeaderFieldValue(*a2, 0x1470F3EAu);
  v39 = v38;
  if (v37 != 101 || v38 == 0)
  {
    v41 = *((_QWORD *)this + 20);
    v42 = *(_QWORD *)(v41 + 160);
    if (v42)
    {
      v43 = *(_QWORD *)(v41 + 176);
      if (v43)
      {
        if (!canKeepAlive((__CFHTTPMessage *)(v43 - 16), (__CFHTTPMessage *)(v42 - 16)))
        {
          v84.domain = 4;
          *(_QWORD *)&v84.error = 4294967292;
          HTTPConnection::_onqueue_doNotAllowMoreRequests(this, v84, 0);
          goto LABEL_102;
        }
        v41 = *((_QWORD *)this + 20);
      }
    }
    v44 = *(_QWORD *)(v41 + 176);
    if (!v44
      || (v45 = CFHTTPMessageCopyHeaderFieldValue((CFHTTPMessageRef)(v44 - 16), (CFStringRef)&unk_1EDCFD190)) == 0)
    {
LABEL_102:
      if (!v39)
        goto LABEL_104;
      goto LABEL_103;
    }
    v46 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v69 = v45;
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v45, CFSTR(","));
    Count = CFArrayGetCount(ArrayBySeparatingStrings);
    if (Count < 1)
    {
LABEL_97:
      v63 = 0;
      if (ArrayBySeparatingStrings)
        goto LABEL_98;
      goto LABEL_99;
    }
    v49 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v49);
      v51 = CFStringCreateArrayBySeparatingStrings(v46, ValueAtIndex, CFSTR("="));
      v52 = CFArrayGetCount(v51);
      if (v52 == 1)
      {
        MutableCopy = CFStringCreateMutableCopy(v46, 0, ValueAtIndex);
        CFStringTrimWhitespace(MutableCopy);
        IntValue = CFStringGetIntValue(MutableCopy);
        if (MutableCopy)
          CFRelease(MutableCopy);
        if (IntValue < 1)
        {
LABEL_88:
          v58 = 1;
          if (!v51)
            goto LABEL_90;
LABEL_89:
          CFRelease(v51);
          goto LABEL_90;
        }
        v58 = 0;
        v70 = IntValue;
        if (v51)
          goto LABEL_89;
      }
      else
      {
        if (v52 != 2)
          goto LABEL_88;
        v53 = (const __CFString *)CFArrayGetValueAtIndex(v51, 0);
        v54 = CFStringCreateMutableCopy(v46, 0, v53);
        CFStringTrimWhitespace(v54);
        if (CFStringCompare(v54, CFSTR("timeout"), 1uLL))
        {
          v55 = 5;
        }
        else
        {
          v59 = (const __CFString *)CFArrayGetValueAtIndex(v51, 1);
          v60 = CFStringCreateMutableCopy(v46, 0, v59);
          CFStringTrimWhitespace(v60);
          v61 = CFStringGetIntValue(v60);
          v62 = v70;
          if (v61 > 0)
            v62 = v61;
          v70 = v62;
          if (v61 > 0)
            v55 = 1;
          else
            v55 = 5;
          if (v60)
            CFRelease(v60);
        }
        if (v54)
          CFRelease(v54);
        if (v55 == 5)
          goto LABEL_88;
        v58 = 0;
        if (v51)
          goto LABEL_89;
      }
LABEL_90:
      if ((v58 & 1) == 0)
      {
        v63 = v70;
        if (!ArrayBySeparatingStrings)
          goto LABEL_99;
LABEL_98:
        CFRelease(ArrayBySeparatingStrings);
LABEL_99:
        CFRelease(v69);
        if (v63)
          *((_DWORD *)this + 56) = v63;
        goto LABEL_102;
      }
      if (Count == ++v49)
        goto LABEL_97;
    }
  }
  *((_WORD *)this + 16) |= 0x8000u;
  v83.domain = 4;
  *(_QWORD *)&v83.error = 4294967292;
  HTTPConnection::_onqueue_doNotAllowMoreRequests(this, v83, 0);
LABEL_103:
  CFRelease(v39);
LABEL_104:
  v64 = v75;
  if (v75)
  {
    v65 = (unint64_t *)&v75->__shared_owners_;
    do
      v66 = __ldaxr(v65);
    while (__stlxr(v66 - 1, v65));
    if (!v66)
    {
      ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
      std::__shared_weak_count::__release_weak(v64);
    }
  }
}

void sub_183F1E178(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, CFTypeRef a19)
{
  const void *v19;
  const void *v20;

  if (v20)
    CFRelease(v20);
  CFRelease(cf);
  if (v19)
    CFRelease(v19);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  _Unwind_Resume(a1);
}

CFTypeRef HTTPResponseMessage::setResponseURL(HTTPResponseMessage *this, CFTypeRef cf, int a3)
{
  uint64_t v4;
  CFTypeRef result;

  if (a3)
    v4 = 152;
  else
    v4 = 144;
  result = *(CFTypeRef *)((char *)this + v4);
  if (result != cf)
  {
    if (result)
      CFRelease(result);
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *(_QWORD *)((char *)this + v4) = result;
  }
  return result;
}

void HTTPConnection::_onqueue_doNotAllowMoreRequests(HTTPConnection *this, CFStreamError a2, unsigned int a3)
{
  int v3;
  uint64_t v4;
  CFIndex domain;
  unsigned int v7;
  HTTPEngine *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t *v19;
  unint64_t v20;
  _QWORD *TransactionItr;
  _QWORD *v22;
  _QWORD *v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  NSObject *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  uint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  uint64_t *v46;
  unint64_t v47;
  uint64_t v49;
  std::__shared_weak_count *v50;
  _QWORD block[6];
  std::__shared_weak_count *v52;
  CFIndex v53;
  uint64_t v54;
  uint64_t v55;
  std::__shared_weak_count *v56;
  uint64_t v57;
  __n128 (*v58)(__n128 *, __n128 *);
  uint64_t (*v59)(uint64_t);
  void *v60;
  uint64_t v61;
  std::__shared_weak_count *v62;
  uint64_t v63;
  std::__shared_weak_count *v64;

  v3 = *((unsigned __int16 *)this + 16);
  if ((v3 & 0x10) == 0)
  {
    v4 = *(_QWORD *)&a2.error;
    domain = a2.domain;
    v7 = v3 & 0xFFFFFFFE | (*((unsigned __int8 *)this + 34) << 16);
    *((_BYTE *)this + 34) = BYTE2(v7);
    *((_WORD *)this + 16) = v7 | 0x10;
    v8 = (HTTPEngine *)*((_QWORD *)this + 8);
    if (v8)
      HTTPEngine::setProperty(v8, CFSTR("__kCFStreamPropertyDoNotReuse"), (const void *)*MEMORY[0x1E0C9AE50]);
    v9 = *((_QWORD *)this + 20);
    if (v9)
    {
      if ((*((_WORD *)this + 16) & 0x8000) != 0)
      {
        v10 = (_QWORD *)*((_QWORD *)this + 8);
        v11 = v10[7];
        v12 = (std::__shared_weak_count *)v10[8];
        v55 = v11;
        v56 = v12;
        if (v12)
        {
          p_shared_owners = (unint64_t *)&v12->__shared_owners_;
          do
            v14 = __ldxr(p_shared_owners);
          while (__stxr(v14 + 1, p_shared_owners));
          v9 = *((_QWORD *)this + 20);
          v64 = v12;
          do
            v15 = __ldxr(p_shared_owners);
          while (__stxr(v15 + 1, p_shared_owners));
          v10 = (_QWORD *)*((_QWORD *)this + 8);
        }
        else
        {
          v64 = 0;
        }
        v63 = v11;
        (*(void (**)(uint64_t, uint64_t *, _QWORD))(*(_QWORD *)v9 + 184))(v9, &v63, v10[24]);
        v16 = v64;
        if (v64)
        {
          v17 = (unint64_t *)&v64->__shared_owners_;
          do
            v18 = __ldaxr(v17);
          while (__stlxr(v18 - 1, v17));
          if (!v18)
          {
            ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
            std::__shared_weak_count::__release_weak(v16);
          }
        }
        if (v56)
        {
          v19 = &v56->__shared_owners_;
          do
            v20 = __ldaxr((unint64_t *)v19);
          while (__stlxr(v20 - 1, (unint64_t *)v19));
          if (!v20)
          {
            ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
            std::__shared_weak_count::__release_weak(v56);
          }
        }
        v9 = *((_QWORD *)this + 20);
      }
      TransactionItr = HTTPConnection::_onqueue_getTransactionItr(*((_QWORD **)this + 15), *((_QWORD **)this + 16), v9);
      v22 = TransactionItr + 2;
      if (TransactionItr + 2 != *((_QWORD **)this + 16))
      {
        v23 = TransactionItr;
        do
        {
          v24 = (std::__shared_weak_count *)v23[3];
          v23 = v22;
          v25 = *v22;
          if (v24)
          {
            v26 = (unint64_t *)&v24->__shared_owners_;
            do
              v27 = __ldxr(v26);
            while (__stxr(v27 + 1, v26));
          }
          if (v25 == *((_QWORD *)this + 18))
            *((_WORD *)this + 16) |= 0x800u;
          v55 = 0;
          v56 = (std::__shared_weak_count *)&v55;
          v57 = 0x4012000000;
          v58 = __Block_byref_object_copy__12;
          v59 = __Block_byref_object_dispose__13;
          v60 = &unk_18422E08D;
          v61 = 0;
          v62 = 0;
          v28 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
          if (v28)
          {
            v62 = std::__shared_weak_count::lock(v28);
            if (v62)
              v61 = *((_QWORD *)this + 5);
          }
          v29 = *((_QWORD *)this + 7);
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 3321888768;
          block[2] = ___ZN14HTTPConnection31_onqueue_doNotAllowMoreRequestsE13CFStreamErrorb_block_invoke;
          block[3] = &unk_1E14F4340;
          block[5] = v25;
          v52 = v24;
          if (v24)
          {
            v30 = (unint64_t *)&v24->__shared_owners_;
            do
              v31 = __ldxr(v30);
            while (__stxr(v31 + 1, v30));
          }
          v53 = domain;
          v54 = v4;
          block[4] = &v55;
          dispatch_async(v29, block);
          v32 = v52;
          if (v52)
          {
            v33 = (unint64_t *)&v52->__shared_owners_;
            do
              v34 = __ldaxr(v33);
            while (__stlxr(v34 - 1, v33));
            if (!v34)
            {
              ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
              std::__shared_weak_count::__release_weak(v32);
            }
          }
          _Block_object_dispose(&v55, 8);
          v35 = v62;
          if (!v62)
            goto LABEL_46;
          v36 = (unint64_t *)&v62->__shared_owners_;
          do
            v37 = __ldaxr(v36);
          while (__stlxr(v37 - 1, v36));
          if (!v37)
          {
            ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
            std::__shared_weak_count::__release_weak(v35);
            if (v24)
            {
LABEL_47:
              v38 = (unint64_t *)&v24->__shared_owners_;
              do
                v39 = __ldaxr(v38);
              while (__stlxr(v39 - 1, v38));
              if (!v39)
              {
                ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
                std::__shared_weak_count::__release_weak(v24);
              }
            }
          }
          else
          {
LABEL_46:
            if (v24)
              goto LABEL_47;
          }
          v22 = v23 + 2;
        }
        while (v23 + 2 != *((_QWORD **)this + 16));
      }
    }
    HTTPConnection::_onqueue_cleanupEngineWhenPossible(this, a3);
    v55 = 0;
    v56 = 0;
    v40 = (std::__shared_weak_count *)*((_QWORD *)this + 11);
    if (v40)
    {
      v56 = std::__shared_weak_count::lock(v40);
      if (v56)
      {
        v41 = *((_QWORD *)this + 10);
        v55 = v41;
        if (v41)
        {
          std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v49, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
          (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v41 + 40))(v41, &v49);
          v42 = v50;
          if (v50)
          {
            v43 = (unint64_t *)&v50->__shared_owners_;
            do
              v44 = __ldaxr(v43);
            while (__stlxr(v44 - 1, v43));
            if (!v44)
            {
              ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
              std::__shared_weak_count::__release_weak(v42);
            }
          }
        }
      }
    }
    v45 = v56;
    if (v56)
    {
      v46 = &v56->__shared_owners_;
      do
        v47 = __ldaxr((unint64_t *)v46);
      while (__stlxr(v47 - 1, (unint64_t *)v46));
      if (!v47)
      {
        ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
        std::__shared_weak_count::__release_weak(v45);
      }
    }
  }
}

void sub_183F1E710(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void HTTPTransaction::captureStreamProperties(HTTPTransaction *this)
{
  uint64_t v2;
  CFMutableDictionaryRef Mutable;
  const void *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t i;
  const void *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  _QWORD v18[2];
  uint64_t (*v19)(uint64_t);
  void *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;

  if (!*((_QWORD *)this + 13))
  {
    v2 = operator new();
    *(_QWORD *)v2 = &off_1E14E91C8;
    *(_QWORD *)(v2 + 8) = 0;
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v4 = *(const void **)(v2 + 8);
    *(_QWORD *)(v2 + 8) = Mutable;
    if (v4)
      CFRelease(v4);
    v5 = *((_QWORD *)this + 13);
    *((_QWORD *)this + 13) = v2;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      v2 = *((_QWORD *)this + 13);
    }
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v16, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3321888768;
    v19 = ___ZN18CapturedProperties7captureENSt3__110shared_ptrI15HTTPTransactionEE_block_invoke;
    v20 = &__block_descriptor_48_e8_32c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE_e22__v16__0____CFString__8l;
    v21 = v16;
    v22 = v17;
    if (v17)
    {
      p_shared_owners = (unint64_t *)&v17->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
    {
      CapturedProperties::capture(void const*({block_pointer})(__CFString const*))::keys[0] = 0x1EDCFAD40;
      *(_QWORD *)algn_1ECDBEF18 = &unk_1EDCFC048;
      qword_1ECDBEF20 = 0x1EDCFAB48;
      unk_1ECDBEF28 = &unk_1EDCFBFD8;
      qword_1ECDBEF30 = 0x1EDCFABF0;
      unk_1ECDBEF38 = 0x1EDCF9E98;
    }
    for (i = 0; i != 6; ++i)
    {
      if (!CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 8), (const void *)CapturedProperties::capture(void const*({block_pointer})(__CFString const*))::keys[i]))
      {
        v9 = (const void *)((uint64_t (*)(_QWORD *, uint64_t))v19)(v18, CapturedProperties::capture(void const*({block_pointer})(__CFString const*))::keys[i]);
        if (v9)
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v2 + 8), (const void *)CapturedProperties::capture(void const*({block_pointer})(__CFString const*))::keys[i], v9);
          CFRelease(v9);
        }
      }
    }
    v10 = v22;
    if (v22)
    {
      v11 = (unint64_t *)&v22->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    v13 = v17;
    if (v17)
    {
      v14 = (unint64_t *)&v17->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }
}

void sub_183F1E99C(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  *(_QWORD *)(v1 + 8) = 0;
  if (v3)
    CFRelease(v3);
  MEMORY[0x186DB748C](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

uint64_t ___ZN18CapturedProperties7captureENSt3__110shared_ptrI15HTTPTransactionEE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 200))(*(_QWORD *)(a1 + 32));
}

void HTTPTransaction::stopStallTimer(HTTPTransaction *this)
{
  NSObject *v2;

  v2 = *((_QWORD *)this + 37);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 37));
    *((_QWORD *)this + 37) = 0;
  }
}

unint64_t canKeepAlive(__CFHTTPMessage *a1, __CFHTTPMessage *a2)
{
  CFStringRef v4;
  unint64_t v5;
  CFStringRef v6;
  const __CFString *v7;
  CFStringRef v8;
  CFIndex Length;
  CFIndex v11;
  const __CFAllocator *v12;
  const __CFString *v13;
  CFRange v14;

  if (!a1)
    return 0;
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v4 = HTTPMessage::copyHeaderFieldValue((__CFHTTPMessage *)((char *)a1 + 16), 0x13721369u);
  if (!v4)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v4 = HTTPMessage::copyHeaderFieldValue((__CFHTTPMessage *)((char *)a1 + 16), 0x119152ADu);
    if (!v4)
    {
      v6 = CFHTTPMessageCopyVersion(a1);
      if (v6)
      {
        v7 = v6;
        v8 = CFHTTPMessageCopyVersion(a2);
        if (!v8)
        {
          v5 = 0;
          v4 = v7;
          goto LABEL_14;
        }
        v4 = v8;
        if (!CFEqual(v7, &unk_1EDCFE8F8) && !CFEqual(v4, &unk_1EDCFE8F8))
        {
          if (CFEqual(v7, &unk_1EDCFE930))
          {
            v5 = 1;
            goto LABEL_20;
          }
          Length = CFStringGetLength(v7);
          if (Length >= 7)
          {
            v11 = Length;
            v12 = CFGetAllocator(v7);
            v14.length = v11 - 5;
            v14.location = 5;
            v13 = CFStringCreateWithSubstring(v12, v7, v14);
            v5 = CFStringGetDoubleValue(v13) > 1.1;
            CFRelease(v13);
            goto LABEL_20;
          }
        }
        v5 = 0;
LABEL_20:
        CFRelease(v7);
        goto LABEL_14;
      }
      return 0;
    }
  }
  if (CFStringCompare(v4, (CFStringRef)&unk_1EDCFDC10, 1uLL) == kCFCompareEqualTo)
  {
LABEL_13:
    v5 = 0;
    goto LABEL_14;
  }
  v5 = 1;
  if (CFStringCompare(v4, (CFStringRef)&unk_1EDCFDD60, 1uLL))
  {
    if (CFStringCompare(v4, (CFStringRef)&unk_1EDCFDFC8, 1uLL)
      && CFStringFind(v4, CFSTR(","), 0).location != -1
      && !hasTokenInList(v4, (const __CFString *)&unk_1EDCFDC10))
    {
      v5 = hasTokenInList(v4, (const __CFString *)&unk_1EDCFDD60);
      goto LABEL_14;
    }
    goto LABEL_13;
  }
LABEL_14:
  CFRelease(v4);
  return v5;
}

void HTTPTransaction::_onqueue_closeAndCleanup(HTTPTransaction *this)
{
  uint64_t v2;
  char *v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  __int128 *TransactionItr;
  __int128 *v15;
  __int128 *v16;
  uint64_t v17;
  BOOL v18;
  int v19;
  _BOOL4 v20;
  _BOOL4 v21;
  uint64_t v22;
  __int16 v23;
  int v24;
  int v25;
  uint64_t v26;
  __int128 *v27;
  uint64_t v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  int v42;
  int v43;
  HTTPEngine *v44;
  HTTPEngine *v45;
  CFTypeRef v46;
  const void *v47;
  CFTypeID v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  uint64_t *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t *v61;
  unint64_t v62;
  NSObject *v63;
  std::__shared_weak_count *v64;
  unint64_t *v65;
  unint64_t v66;
  std::__shared_weak_count *v67;
  unint64_t *v68;
  unint64_t v69;
  int v70;
  HTTPEngine *v71;
  CFTypeRef v72;
  const void *v73;
  CFTypeID v74;
  _QWORD block[6];
  std::__shared_weak_count *v76;
  __int128 v77;
  uint64_t v78;
  __n128 (*v79)(__n128 *, __n128 *);
  uint64_t (*v80)(uint64_t);
  void *v81;
  uint64_t v82;
  std::__shared_weak_count *v83;
  uint64_t v84;
  std::__shared_weak_count *v85;
  __int128 buf;
  uint64_t v87;
  std::__shared_weak_count *v88;
  CFStreamError v89;
  CFStreamError v90;
  CFStreamError v91;
  CFStreamError v92;

  v3 = (char *)this + 192;
  v2 = *((_QWORD *)this + 24);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 64))(v2);
    v77 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v3, &v77);
    v4 = (std::__shared_weak_count *)*((_QWORD *)&v77 + 1);
    if (*((_QWORD *)&v77 + 1))
    {
      v5 = (unint64_t *)(*((_QWORD *)&v77 + 1) + 8);
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
  if ((*((_WORD *)this + 16) & 2) != 0)
  {
    v84 = 0;
    v85 = 0;
    v7 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
    if (v7 && (v85 = std::__shared_weak_count::lock(v7)) != 0)
    {
      v8 = *((_QWORD *)this + 7);
      v84 = v8;
    }
    else
    {
      v8 = 0;
    }
    *(_QWORD *)&v77 = 0;
    *((_QWORD *)&v77 + 1) = &v77;
    v78 = 0x4012000000;
    v79 = __Block_byref_object_copy__21;
    v80 = __Block_byref_object_dispose__22;
    v82 = 0;
    v83 = 0;
    v81 = &unk_18422E08D;
    v9 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
    if (v9)
    {
      v83 = std::__shared_weak_count::lock(v9);
      if (v83)
        v82 = *((_QWORD *)this + 5);
    }
    if (!v8)
      goto LABEL_131;
    v10 = *(_QWORD *)(*((_QWORD *)&v77 + 1) + 48);
    if (!v10)
      goto LABEL_131;
    v11 = *(std::__shared_weak_count **)(*((_QWORD *)&v77 + 1) + 56);
    block[5] = *(_QWORD *)(*((_QWORD *)&v77 + 1) + 48);
    v76 = v11;
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }
    v87 = 0;
    v88 = 0;
    TransactionItr = (__int128 *)HTTPConnection::_onqueue_getTransactionItr(*(_QWORD **)(v8 + 120), *(_QWORD **)(v8 + 128), v10);
    v15 = *(__int128 **)(v8 + 120);
    v16 = *(__int128 **)(v8 + 128);
    if (v15 == v16)
    {
      v16 = *(__int128 **)(v8 + 120);
      goto LABEL_62;
    }
    v17 = *(_QWORD *)(v8 + 144);
    v18 = v10 == *(_QWORD *)v15 && v10 == v17;
    v19 = v18;
    if (v18)
    {
      v20 = 0;
      v21 = 0;
    }
    else
    {
      v21 = 0;
      if (v17 && v16 != TransactionItr)
      {
        v21 = HTTPConnection::_onqueue_getTransactionItr(v15, *(_QWORD **)(v8 + 128), v17) < (_QWORD *)TransactionItr;
        v16 = *(__int128 **)(v8 + 128);
      }
      v22 = *(_QWORD *)(v8 + 160);
      if (v22)
      {
        if (v16 == TransactionItr)
          goto LABEL_51;
        v20 = HTTPConnection::_onqueue_getTransactionItr(*(_QWORD **)(v8 + 120), v16, v22) < (_QWORD *)TransactionItr;
        v16 = *(__int128 **)(v8 + 128);
      }
      else
      {
        v20 = 0;
      }
    }
    if (v16 != TransactionItr)
    {
      if ((v20 | v19) == 1)
      {
        v23 = *(_WORD *)(v8 + 32);
        if ((v23 & 0x10) != 0 || ((v21 | ((v23 & 0x20) >> 5)) & 1) != 0)
          goto LABEL_55;
        if ((v23 & 8) == 0 && (*(_WORD *)(v8 + 32) & 0x1400) == 0 && v10 == *(_QWORD *)(v8 + 144))
        {
          HTTPConnection::_onqueue_advanceCurrentRequest((HTTPConnection *)v8);
          v24 = *(unsigned __int16 *)(v8 + 32);
          v25 = v24 | (*(unsigned __int8 *)(v8 + 34) << 16);
          if ((v24 & 0x1000) != 0 && (v24 & 0x4000) != 0 && v10 == *(_QWORD *)(v8 + 160))
          {
            *(_WORD *)(v8 + 32) = v24 & 0xBFFF;
            *(_BYTE *)(v8 + 34) = (v25 & 0xFFFFBFFF) >> 16;
            if ((v25 & 0x40) != 0)
              HTTPConnection::_onqueue_cleanupEngine((HTTPConnection *)v8);
            HTTPConnection::_onqueue_advanceCurrentResponse((HTTPConnection *)v8);
          }
          goto LABEL_55;
        }
      }
      else if (v10 != *(_QWORD *)(v8 + 160))
      {
LABEL_55:
        std::shared_ptr<__CFString const>::operator=[abi:nn180100](&v87, v10, (uint64_t)v11);
        v26 = (uint64_t)(TransactionItr + 1);
        v27 = *(__int128 **)(v8 + 128);
        if (TransactionItr + 1 != v27)
        {
          do
            v28 = (uint64_t)TransactionItr++;
          while ((__int128 *)(std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v28, TransactionItr) + 32) != v27);
          v26 = *(_QWORD *)(v8 + 128);
        }
        v16 = TransactionItr;
        while ((__int128 *)v26 != TransactionItr)
          v26 = std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v26 - 16);
        *(_QWORD *)(v8 + 128) = TransactionItr;
        goto LABEL_62;
      }
      if (TransactionItr + 1 == v16)
      {
        v89.domain = 4;
        *(_QWORD *)&v89.error = 4294967292;
        HTTPConnection::_onqueue_errorOccurred((HTTPConnection *)v8, v89, 0);
        goto LABEL_55;
      }
LABEL_62:
      v29 = v87;
      if (v87)
      {
        if (*(__int128 **)(v8 + 120) == v16)
        {
          *(CFAbsoluteTime *)(v8 + 208) = CFAbsoluteTimeGetCurrent();
          buf = 0uLL;
          std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v8 + 144, &buf);
          v30 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
          if (*((_QWORD *)&buf + 1))
          {
            v31 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
            do
              v32 = __ldaxr(v31);
            while (__stlxr(v32 - 1, v31));
            if (!v32)
            {
              ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
              std::__shared_weak_count::__release_weak(v30);
            }
          }
          buf = 0uLL;
          std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v8 + 160, &buf);
          v33 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
          if (*((_QWORD *)&buf + 1))
          {
            v34 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
            do
              v35 = __ldaxr(v34);
            while (__stlxr(v35 - 1, v34));
            if (!v35)
            {
              ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
              std::__shared_weak_count::__release_weak(v33);
            }
          }
          v29 = v87;
        }
        if (v29 == *(_QWORD *)(v8 + 144))
        {
          buf = 0uLL;
          std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v8 + 144, &buf);
          v36 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
          if (*((_QWORD *)&buf + 1))
          {
            v37 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
            do
              v38 = __ldaxr(v37);
            while (__stlxr(v38 - 1, v37));
            if (!v38)
            {
              ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
              std::__shared_weak_count::__release_weak(v36);
            }
          }
          v29 = v87;
        }
        if (v29 == *(_QWORD *)(v8 + 160))
        {
          buf = 0uLL;
          std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v8 + 160, &buf);
          v39 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
          if (*((_QWORD *)&buf + 1))
          {
            v40 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
            do
              v41 = __ldaxr(v40);
            while (__stlxr(v41 - 1, v40));
            if (!v41)
            {
              ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
              std::__shared_weak_count::__release_weak(v39);
            }
          }
          v42 = *(unsigned __int16 *)(v8 + 32);
          v43 = v42 | (*(unsigned __int8 *)(v8 + 34) << 16);
          if ((v42 & 0x40) != 0 && (v42 & 0x100) == 0)
          {
            v44 = *(HTTPEngine **)(v8 + 64);
            if (v44)
            {
              *(_BYTE *)(v8 + 34) = BYTE2(v43);
              *(_WORD *)(v8 + 32) = v43 | 0x100;
              HTTPEngine::_cleanupConnection(v44, 0);
            }
          }
        }
      }
      v45 = *(HTTPEngine **)(v8 + 64);
      if (v45)
      {
        v46 = HTTPEngine::copyProperty(v45, CFSTR("__kCFStreamPropertyDoNotReuse"));
        v47 = v46;
        if (v46)
        {
          v48 = CFGetTypeID(v46);
          if (v48 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            LOWORD(buf) = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&buf, 2u);
          }
          if ((const void *)*MEMORY[0x1E0C9AE50] == v47)
          {
            v90.domain = 4;
            *(_QWORD *)&v90.error = 4294967292;
            HTTPConnection::_onqueue_doNotAllowMoreRequests((HTTPConnection *)v8, v90, 0);
          }
          CFRelease(v47);
        }
      }
      if (*(_QWORD *)(v8 + 120) == *(_QWORD *)(v8 + 128))
      {
        v70 = *(unsigned __int16 *)(v8 + 32) | (*(unsigned __int8 *)(v8 + 34) << 16);
        v71 = *(HTTPEngine **)(v8 + 64);
        if ((*(_WORD *)(v8 + 32) & 0x81) == 1)
        {
          if (v71)
          {
            v72 = HTTPEngine::copyProperty(v71, (CFStringRef)&unk_1EDCFE2D8);
            v73 = v72;
            if (v72)
            {
              v74 = CFGetTypeID(v72);
              if (v74 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
              {
                LOWORD(buf) = 0;
                _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&buf, 2u);
              }
              if ((const void *)*MEMORY[0x1E0C9AE50] == v73)
              {
                v92.domain = 4;
                *(_QWORD *)&v92.error = 4294967292;
                HTTPConnection::_onqueue_doNotAllowMoreRequests((HTTPConnection *)v8, v92, 0);
              }
              CFRelease(v73);
            }
          }
        }
        else if ((*(_WORD *)(v8 + 32) & 0x100) == 0 && v71)
        {
          *(_BYTE *)(v8 + 34) = BYTE2(v70);
          *(_WORD *)(v8 + 32) = v70 | 0x100;
          HTTPEngine::_cleanupConnection(v71, 0);
        }
      }
      if (!v87)
      {
        v91.domain = 4;
        *(_QWORD *)&v91.error = 4294967292;
        HTTPConnection::_onqueue_errorOccurred((HTTPConnection *)v8, v91, 0);
      }
      v49 = v88;
      if (v88)
      {
        v50 = (unint64_t *)&v88->__shared_owners_;
        do
          v51 = __ldaxr(v50);
        while (__stlxr(v51 - 1, v50));
        if (!v51)
        {
          ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
          std::__shared_weak_count::__release_weak(v49);
        }
      }
      if (v76)
      {
        v52 = &v76->__shared_owners_;
        do
          v53 = __ldaxr((unint64_t *)v52);
        while (__stlxr(v53 - 1, (unint64_t *)v52));
        if (!v53)
        {
          ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
          std::__shared_weak_count::__release_weak(v76);
        }
      }
      *((_WORD *)this + 16) &= ~2u;
      v54 = *((_QWORD *)this + 26);
      if (v54)
      {
        v55 = *(_QWORD *)(v84 + 64);
        if (v55)
        {
          v56 = *(_QWORD *)(v55 + 56);
          v57 = *(std::__shared_weak_count **)(v55 + 64);
          v87 = v56;
          v88 = v57;
          if (v57)
          {
            v58 = (unint64_t *)&v57->__shared_owners_;
            do
              v59 = __ldxr(v58);
            while (__stxr(v59 + 1, v58));
            v54 = *((_QWORD *)this + 26);
          }
          if (v54)
            v60 = v54 - 176;
          else
            v60 = 0;
          if (v56 && *(_QWORD *)(v60 + 80))
            (*(void (**)(uint64_t))(*(_QWORD *)v56 + 280))(v56);
          if (v57)
          {
            v61 = (unint64_t *)&v57->__shared_owners_;
            do
              v62 = __ldaxr(v61);
            while (__stlxr(v62 - 1, v61));
            if (!v62)
            {
              ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
              std::__shared_weak_count::__release_weak(v57);
            }
          }
        }
      }
      v63 = *((_QWORD *)this + 9);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ___ZN15HTTPTransaction24_onqueue_closeAndCleanupEv_block_invoke;
      block[3] = &unk_1E14FD3D8;
      block[4] = &v77;
      dispatch_async(v63, block);
LABEL_131:
      _Block_object_dispose(&v77, 8);
      v64 = v83;
      if (v83)
      {
        v65 = (unint64_t *)&v83->__shared_owners_;
        do
          v66 = __ldaxr(v65);
        while (__stlxr(v66 - 1, v65));
        if (!v66)
        {
          ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
          std::__shared_weak_count::__release_weak(v64);
        }
      }
      v67 = v85;
      if (v85)
      {
        v68 = (unint64_t *)&v85->__shared_owners_;
        do
          v69 = __ldaxr(v68);
        while (__stlxr(v69 - 1, v68));
        if (!v69)
        {
          ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
          std::__shared_weak_count::__release_weak(v67);
        }
      }
      return;
    }
LABEL_51:
    v16 = TransactionItr;
    goto LABEL_62;
  }
}

void sub_183F1F4CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  va_list va1;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  va_list va2;

  va_start(va2, a7);
  va_start(va1, a7);
  va_start(va, a7);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v13 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  v19 = va_arg(va2, _QWORD);
  v20 = va_arg(va2, _QWORD);
  v21 = va_arg(va2, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v8 - 96);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Block_object_dispose(va1, 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v7 + 48);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  _Unwind_Resume(a1);
}

void HTTPMessage::appendToBodyData(HTTPMessage *this, const char *a2, CFIndex a3)
{
  void *v6;
  const __CFAllocator *v7;
  CFAllocatorRef v8;
  __CFData *MutableCopy;
  const char *v10;
  const __CFAllocator *v11;
  const __CFData *v12;
  const void *v13;

  if (a3 >= 1)
  {
    v6 = (void *)*((_QWORD *)this + 6);
    if (!v6)
    {
      v7 = CFGetAllocator((char *)this - 16);
      v6 = CFAllocatorAllocate(v7, 32, 0);
      *(_OWORD *)v6 = 0u;
      *((_OWORD *)v6 + 1) = 0u;
      v8 = CFGetAllocator((char *)this - 16);
      *(_QWORD *)v6 = off_1E14E5A48;
      *((_QWORD *)v6 + 1) = v8;
      *((_QWORD *)this + 6) = v6;
    }
    HTTPBodyData::logit((HTTPBodyData *)v6, a2);
    MutableCopy = (__CFData *)*((_QWORD *)v6 + 3);
    if (!MutableCopy)
    {
      v11 = (const __CFAllocator *)*((_QWORD *)v6 + 1);
      v12 = (const __CFData *)*((_QWORD *)v6 + 2);
      if (v12)
      {
        MutableCopy = CFDataCreateMutableCopy(v11, 0, v12);
        v13 = (const void *)*((_QWORD *)v6 + 2);
        *((_QWORD *)v6 + 2) = 0;
        *((_QWORD *)v6 + 3) = MutableCopy;
        if (v13)
        {
          CFRelease(v13);
          MutableCopy = (__CFData *)*((_QWORD *)v6 + 3);
        }
      }
      else
      {
        MutableCopy = CFDataCreateMutable(v11, 0);
        *((_QWORD *)v6 + 3) = MutableCopy;
      }
    }
    CFDataAppendBytes(MutableCopy, (const UInt8 *)a2, a3);
    HTTPBodyData::logit((HTTPBodyData *)v6, v10);
  }
}

void AwaitingTube::~AwaitingTube(AwaitingTube *this)
{
  uint64_t v2;

  AwaitingTube::~AwaitingTube(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E14E56D8;
  *((_QWORD *)this + 3) = &unk_1E14E5770;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 4) + 48))(*((_QWORD *)this + 4));
  *((_QWORD *)this + 4) = 0;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 6) + 24))(*((_QWORD *)this + 6));
  *((_QWORD *)this + 6) = 0;
  v2 = *((_QWORD *)this + 10);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    *((_QWORD *)this + 10) = 0;
  }
  CFRelease((CFTypeRef)(*((_QWORD *)this + 5) - 16));
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

void HTTPMessage::~HTTPMessage(HTTPMessage *this)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  const void *v5;
  uint64_t v6;
  uint64_t v7;
  const void *v8;
  const void *v9;

  *(_QWORD *)this = &off_1E14E50B0;
  *((_QWORD *)this + 1) = &unk_1E14E5120;
  *((_QWORD *)this + 2) = &unk_1E14E5140;
  v2 = *((_QWORD *)this + 11);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 6);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = (const void *)*((_QWORD *)this + 9);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 10);
  if (v5)
    CFRelease(v5);
  v6 = *((_QWORD *)this + 12);
  if (v6)
  {
    CFRelease((CFTypeRef)(v6 - 16));
    *((_QWORD *)this + 12) = 0;
  }
  v7 = *((_QWORD *)this + 13);
  if (v7)
  {
    CFRelease((CFTypeRef)(v7 - 16));
    *((_QWORD *)this + 13) = 0;
  }
  v8 = (const void *)*((_QWORD *)this + 14);
  if (v8)
    CFRelease(v8);
  *((_QWORD *)this + 4) = &off_1E14E9A00;
  v9 = (const void *)*((_QWORD *)this + 5);
  if (v9)
    CFRelease(v9);
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

void sub_183F1F708(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  const void *v3;

  v1[4] = &off_1E14E9A00;
  v3 = (const void *)v1[5];
  if (v3)
    CFRelease(v3);
  v1[1] = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

void HTTPBodyData::~HTTPBodyData(CFAllocatorRef *this, const char *a2)
{
  *this = (CFAllocatorRef)off_1E14E5A48;
  HTTPBodyData::becomeEmpty((HTTPBodyData *)this, a2);
  CFAllocatorDeallocate(this[1], this);
}

void HTTPBodyData::becomeEmpty(HTTPBodyData *this, const char *a2)
{
  const void *v3;
  const void *v4;

  HTTPBodyData::logit(this, a2);
  v3 = (const void *)*((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v4)
    CFRelease(v4);
}

void HTTPBodyData::logit(HTTPBodyData *this, const char *a2)
{
  uint8_t v2[16];

  if (*((_QWORD *)this + 2) && *((_QWORD *)this + 3) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v2 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "mutability consistency failure", v2, 2u);
  }
}

void sub_183F1F8B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void HTTPEngine::_writeHeadersStart(HTTPEngine *this)
{
  int v2;
  uint64_t v3;
  NSObject *v4;
  int64_t v5;
  uint64_t v6;
  unsigned int v7;
  const __CFString *v8;
  const __CFString *v9;
  __CFString *MutableCopy;
  int v11;
  uint64_t *v12;
  __CFData *v13;
  const __CFData *v14;
  const UInt8 *BytePtr;
  size_t Length;
  int64_t size;
  int64_t v18;
  double Current;
  uint64_t v20;
  double v21;
  double v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  uint64_t *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t *p_shared_owners;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  _QWORD v40[8];
  std::__shared_weak_count *v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  _QWORD destructor[5];
  _QWORD v45[2];
  void (*v46)(uint64_t);
  void *v47;
  uint64_t *v48;
  uint64_t *v49;
  HTTPEngine *v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  __n128 (*v54)(__n128 *, __n128 *);
  uint64_t (*v55)();
  void *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  char v62;
  CFRange v63;

  v59 = 0;
  v60 = &v59;
  v61 = 0x2020000000;
  v62 = 1;
  v51 = 0;
  v52 = &v51;
  v53 = 0x4012000000;
  v54 = __Block_byref_object_copy__15809;
  v55 = __Block_byref_object_dispose__15810;
  v57 = 0;
  v58 = 0;
  v56 = &unk_18422E08D;
  v2 = *((_DWORD *)this + 8);
  if ((v2 & 0x2000000) == 0)
  {
    v3 = MEMORY[0x1E0C809B0];
    v45[0] = MEMORY[0x1E0C809B0];
    v45[1] = 3221225472;
    v46 = ___ZN10HTTPEngine18_writeHeadersStartEv_block_invoke;
    v47 = &unk_1E14FD138;
    v49 = &v51;
    v50 = this;
    v48 = &v59;
    if ((v2 & 0x800000) == 0)
    {
      v4 = *((_QWORD *)this + 38);
      if (v4)
      {
        v5 = *((_QWORD *)this + 37);
      }
      else
      {
        v6 = HTTPEngine::_expectedSizeFromHeaders(this, *((HTTPMessage **)this + 30));
        if (v6 == -1)
        {
          v8 = HTTPMessage::copyHeaderFieldValue(*((HTTPMessage **)this + 30), 0x146233E1u);
          v9 = v8;
          if (v8)
          {
            v63.length = CFStringGetLength(v8);
            v63.location = 0;
            if (!CFStringFindWithOptions(v9, (CFStringRef)&unk_1EDCFDBA0, v63, 1uLL, 0))
            {
              MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v9);
              CFStringAppend(MutableCopy, (CFStringRef)&unk_1EDCFDA50);
              HTTPMessage::setHeaderFieldStringValue(*((HTTPMessage **)this + 30), 0x146233E1u, MutableCopy);
              if (MutableCopy)
                CFRelease(MutableCopy);
            }
            CFRelease(v9);
          }
          else if ((*((_BYTE *)this + 32) & 8) == 0)
          {
            v11 = dyld_program_sdk_at_least();
            v12 = &kCFHTTPHeaderValueChunked;
            if (!v11)
              v12 = &kCFHTTPHeaderValueChunkedCapitalized;
            HTTPMessage::setHeaderFieldStringValue(*((HTTPMessage **)this + 30), 0x146233E1u, (const void *)*v12);
          }
          v7 = *((_DWORD *)this + 8) | 0x8000000;
          *((_DWORD *)this + 8) = v7;
          *((_QWORD *)this + 36) = 0;
        }
        else
        {
          *((_QWORD *)this + 36) = v6;
          v7 = *((_DWORD *)this + 8);
        }
        v13 = HTTPMessage::copySerializedHeaders(*((HTTPMessage **)this + 30), (v7 >> 2) & 1);
        v14 = v13;
        if (v13)
        {
          BytePtr = CFDataGetBytePtr(v13);
          Length = CFDataGetLength(v14);
          destructor[0] = v3;
          destructor[1] = 3221225472;
          destructor[2] = ___ZN10HTTPEngine18_writeHeadersStartEv_block_invoke_2;
          destructor[3] = &__block_descriptor_40_e5_v8__0l;
          destructor[4] = v14;
          v4 = dispatch_data_create(BytePtr, Length, 0, destructor);
          *((_QWORD *)this + 38) = v4;
        }
        else
        {
          v4 = *((_QWORD *)this + 38);
        }
        v5 = 0;
        *((_QWORD *)this + 37) = 0;
        if (!v4)
        {
          v28 = v52;
          v52[6] = 4;
          v29 = -1;
          goto LABEL_34;
        }
      }
      size = dispatch_data_get_size(v4);
      if (v5 < size)
      {
        v18 = size;
        (*(void (**)(_QWORD))(**((_QWORD **)this + 7) + 248))(*((_QWORD *)this + 7));
        Current = CFAbsoluteTimeGetCurrent();
        v20 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 7) + 248))(*((_QWORD *)this + 7));
        if (v20)
          v21 = *(double *)(v20 + 176);
        else
          v21 = 0.0;
        v22 = Current - v21;
        v23 = *((_QWORD *)this + 42);
        v24 = (void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 7) + 248))(*((_QWORD *)this + 7));
        -[__CFN_TransactionMetrics requestBeginOnConnection:reusedAfterTime:](v23, v24, v22);
        if ((*((_BYTE *)this + 32) & 1) == 0)
        {
          *((_QWORD *)this + 35) += v18;
          HTTPEngine::_updateBytesTransferred(this);
          v25 = *((_QWORD *)this + 42);
          if (v25)
            *(_QWORD *)(v25 + 96) += v18;
          v42 = 0;
          v43 = 0;
          v26 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
          if (v26 && (v26 = std::__shared_weak_count::lock(v26), (v43 = v26) != 0))
          {
            v27 = *((_QWORD *)this + 5);
            v42 = v27;
          }
          else
          {
            v27 = 0;
          }
          v30 = *((_QWORD *)this + 7);
          v31 = *((_QWORD *)this + 38);
          v40[0] = v3;
          v40[1] = 3321888768;
          v40[2] = ___ZN10HTTPEngine18_writeHeadersStartEv_block_invoke_3;
          v40[3] = &unk_1E14F4378;
          v40[4] = &v51;
          v40[5] = this;
          v40[6] = v18;
          v40[7] = v27;
          v41 = v26;
          if (v26)
          {
            p_shared_owners = (unint64_t *)&v26->__shared_owners_;
            do
              v33 = __ldxr(p_shared_owners);
            while (__stxr(v33 + 1, p_shared_owners));
          }
          (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v30 + 48))(v30, v31, v40);
          *((_BYTE *)v60 + 24) = 0;
          v34 = v41;
          if (v41)
          {
            v35 = (unint64_t *)&v41->__shared_owners_;
            do
              v36 = __ldaxr(v35);
            while (__stlxr(v36 - 1, v35));
            if (!v36)
            {
              ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
              std::__shared_weak_count::__release_weak(v34);
            }
          }
          v37 = v43;
          if (v43)
          {
            v38 = (unint64_t *)&v43->__shared_owners_;
            do
              v39 = __ldaxr(v38);
            while (__stlxr(v39 - 1, v38));
            if (!v39)
            {
              ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
              std::__shared_weak_count::__release_weak(v37);
            }
          }
          goto LABEL_49;
        }
        v28 = v52;
        *((_OWORD *)v52 + 3) = *((_OWORD *)this + 6);
        if (!*((_DWORD *)v28 + 14))
        {
          v28[6] = 4;
          v29 = -4;
LABEL_34:
          *((_DWORD *)v28 + 14) = v29;
        }
      }
    }
LABEL_49:
    v46((uint64_t)v45);
    goto LABEL_50;
  }
  *((_DWORD *)this + 8) = v2 | 0x4000000;
LABEL_50:
  _Block_object_dispose(&v51, 8);
  _Block_object_dispose(&v59, 8);
}

void sub_183F1FD58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,void (*a28)(char *))
{
  uint64_t v28;

  a28(&a26);
  _Block_object_dispose((const void *)(v28 - 160), 8);
  _Block_object_dispose((const void *)(v28 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_183F1FE78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t HTTPEngine::_expectedSizeFromHeaders(HTTPEngine *this, HTTPMessage *a2)
{
  const __CFString *v4;
  const __CFString *v5;
  int v6;
  CFIndex ResponseStatusCode;
  CFIndex v8;
  uint64_t v9;
  const __CFString *HeaderFieldValue;
  const __CFString *v12;
  CFIndex Length;
  CFIndex v14;
  int CharacterAtIndex;
  BOOL v16;
  uint64_t v17;
  CFIndex v18;
  unsigned int v19;
  uint64_t v20;
  NSObject *v21;
  uint8_t v22[16];
  uint8_t v23[16];
  uint8_t buf[16];

  if (!*((_BYTE *)a2 + 24))
  {
    v4 = (const __CFString *)*((_QWORD *)a2 + 19);
    if (!v4)
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        goto LABEL_50;
      *(_WORD *)v23 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", v23, 2u);
      v4 = (const __CFString *)*((_QWORD *)a2 + 19);
      if (!v4)
        goto LABEL_50;
    }
    if (CFStringCompare(v4, (CFStringRef)&gConstantCFStringValueTable[2590], 0) == kCFCompareEqualTo)
      return 0;
    v5 = (const __CFString *)*((_QWORD *)a2 + 19);
    if (!v5)
    {
LABEL_50:
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        goto LABEL_9;
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u);
      v5 = (const __CFString *)*((_QWORD *)a2 + 19);
      if (!v5)
        goto LABEL_9;
    }
    if (CFStringCompare(v5, (CFStringRef)&gConstantCFStringValueTable[2597], 0))
      goto LABEL_9;
    return 0;
  }
LABEL_9:
  v6 = *((unsigned __int8 *)a2 + 24);
  ResponseStatusCode = CFHTTPMessageGetResponseStatusCode((HTTPMessage *)((char *)a2 - 16));
  v8 = ResponseStatusCode;
  if (v6 && ResponseStatusCode == 304)
    return 0;
  HeaderFieldValue = HTTPMessage::copyLastHeaderFieldValue(a2, 0x11D1D2CFu);
  if (HeaderFieldValue)
  {
    v12 = HeaderFieldValue;
    Length = CFStringGetLength(HeaderFieldValue);
    if (Length < 1)
    {
      v14 = 0;
    }
    else
    {
      v14 = 0;
      while (1)
      {
        CharacterAtIndex = CFStringGetCharacterAtIndex(v12, v14);
        if (CharacterAtIndex != 32 && CharacterAtIndex != 9)
          break;
        if (Length == ++v14)
        {
          v14 = Length;
          break;
        }
      }
    }
    v9 = 0;
    if (Length <= v14)
      v18 = v14;
    else
      v18 = Length;
    while (v18 != v14)
    {
      v19 = CFStringGetCharacterAtIndex(v12, v14);
      if (v19 - 48 > 9)
        break;
      ++v14;
      v20 = 10 * v9 + v19;
      v9 = v20 - 48;
      if (v14 < Length && v20 >= 0xCCCCCCCCCCCCCF3)
      {
        v9 = -1;
        break;
      }
    }
    CFRelease(v12);
    if (v6 && v8 == 204)
    {
      if (v9 >= 1)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v21 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)v22 = 0;
          _os_log_error_impl(&dword_183ECA000, v21, OS_LOG_TYPE_ERROR, "Got 204 with non-zero Content-Length, stop reusing connection", v22, 2u);
        }
        HTTPEngine::_connectionLost(this);
      }
      return 0;
    }
  }
  else
  {
    if (v6)
      v16 = v8 == 204;
    else
      v16 = 0;
    v17 = !v16;
    return v17 << 63 >> 63;
  }
  return v9;
}

void ___ZN10HTTPEngine18_writeHeadersStartEv_block_invoke(uint64_t a1)
{
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    HTTPEngine::_writeHeadersFinish(*(HTTPEngine **)(a1 + 48), *(CFStreamError *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48));
}

__CFData *HTTPMessage::copySerializedHeaders(HTTPMessage *this, uint64_t a2)
{
  const char *v4;
  const char *v5;
  size_t v6;
  HTTPHeaderDict *v7;
  CFIndex v8;
  const __CFAllocator *v9;
  UInt8 *MutableBytePtr;
  uint64_t v11;
  __CFData *v12;
  CFTypeRef v13;
  CFTypeRef cf;
  UInt8 *v16;
  UInt8 *v17;
  UInt8 *v18;
  _QWORD v19[6];

  HTTPMessage::ensureParserFinished(this);
  v4 = (const char *)(*(uint64_t (**)(HTTPMessage *, uint64_t))(*(_QWORD *)this + 88))(this, a2);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = strlen(v4);
  v7 = (HTTPHeaderDict *)HTTPMessage::headers((os_unfair_lock_s *)this);
  v8 = v6 + HTTPHeaderDict::sizeHeaders(v7) + 4;
  v9 = CFGetAllocator((char *)this - 16);
  cf = CFDataCreateMutable(v9, v8);
  CFDataSetLength((CFMutableDataRef)cf, v8);
  MutableBytePtr = CFDataGetMutableBytePtr((CFMutableDataRef)cf);
  v16 = MutableBytePtr;
  v17 = &MutableBytePtr[v8];
  memcpy(MutableBytePtr, v5, v6);
  *(_WORD *)&MutableBytePtr[v6] = 2573;
  v18 = &MutableBytePtr[v6 + 2];
  v11 = HTTPMessage::headers((os_unfair_lock_s *)this);
  v19[0] = MEMORY[0x1E0C809B0];
  v19[1] = 3221225472;
  v19[2] = ___ZNK14HTTPHeaderDict16serializeHeadersEPNS_6BufferE_block_invoke;
  v19[3] = &__block_descriptor_48_e36_v24__0____CFString__8____CFArray__16l;
  v19[4] = v11;
  v19[5] = &cf;
  HTTPHeaderDict::visitHeaders(v11, 1, (uint64_t)v19);
  *(_WORD *)v18 = 2573;
  v12 = (__CFData *)cf;
  v18 += 2;
  cf = 0;
  CFDataSetLength(v12, v18 - v16);
  v13 = cf;
  cf = 0;
  if (v13)
    CFRelease(v13);
  return v12;
}

void sub_183F202D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void HTTPHeaderDict::visitHeaders(uint64_t a1, int a2, uint64_t a3)
{
  CFIndex Count;
  const void **v7;
  const void **v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  const void *v12;
  const void *v13;
  const void **v14;
  CFIndex v15;

  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 8));
  v7 = (const void **)malloc_type_malloc(16 * Count, 0x80040B8603338uLL);
  v8 = &v7[Count];
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 8), v7, v8);
  if (a2 && Count > 1)
  {
    v9 = 1;
    while (1)
    {
      v10 = (uint64_t)v7[v9];
      v11 = v10 >= (uint64_t)&gConstantCFStringValueTable[1897] && v10 < (uint64_t)&gConstantCFStringValueTable[2373];
      if (v11 && *(_DWORD *)(v10 + 32) == 309367554)
        break;
      if (Count == ++v9)
        goto LABEL_13;
    }
    v12 = *v7;
    *v7 = (const void *)v10;
    v7[v9] = v12;
    v13 = *v8;
    *v8 = v8[v9];
    v8[v9] = v13;
  }
LABEL_13:
  if (Count >= 1)
  {
    v14 = v7;
    v15 = Count;
    do
    {
      (*(void (**)(uint64_t, const void *, const void *))(a3 + 16))(a3, *v14, v14[Count]);
      ++v14;
      --v15;
    }
    while (v15);
  }
  free(v7);
}

void ___ZNK14HTTPHeaderDict16serializeHeadersEPNS_6BufferE_block_invoke(uint64_t a1, const __CFString *a2, const __CFArray *a3)
{
  uint64_t v5;
  uint64_t v6;
  const __CFAllocator *v7;
  const __CFString *v8;
  uint64_t v9;

  v5 = *(_QWORD *)(a1 + 32);
  HTTPHeaderDict::Buffer::addString(*(HTTPHeaderDict::Buffer **)(a1 + 40), a2);
  v6 = *(_QWORD *)(a1 + 40);
  **(_WORD **)(v6 + 24) = 8250;
  *(_QWORD *)(v6 + 24) += 2;
  v7 = CFGetAllocator((CFTypeRef)(v5 - 16));
  v8 = CFStringCreateByCombiningStrings(v7, a3, CFSTR(", "));
  HTTPHeaderDict::Buffer::addString(*(HTTPHeaderDict::Buffer **)(a1 + 40), v8);
  if (v8)
    CFRelease(v8);
  v9 = *(_QWORD *)(a1 + 40);
  **(_WORD **)(v9 + 24) = 2573;
  *(_QWORD *)(v9 + 24) += 2;
}

CFIndex HTTPHeaderDict::Buffer::addString(HTTPHeaderDict::Buffer *this, CFStringRef theString)
{
  UInt8 *v4;
  CFIndex result;
  CFIndex usedBufLen;
  CFRange v7;

  v7.length = CFStringGetLength(theString);
  v4 = (UInt8 *)*((_QWORD *)this + 3);
  usedBufLen = 0;
  v7.location = 0;
  result = CFStringGetBytes(theString, v7, 0x201u, 0, 0, v4, v7.length, &usedBufLen);
  *((_QWORD *)this + 3) += usedBufLen;
  return result;
}

void ___ZNK14HTTPHeaderDict11sizeHeadersEv_block_invoke(uint64_t a1, CFStringRef theString, const __CFArray *a3)
{
  uint64_t v5;
  const __CFAllocator *v6;
  const __CFString *v7;

  v5 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += CFStringGetLength(theString);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += 2;
  v6 = CFGetAllocator((CFTypeRef)(v5 - 16));
  v7 = CFStringCreateByCombiningStrings(v6, a3, CFSTR(", "));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += CFStringGetLength(v7);
  if (v7)
    CFRelease(v7);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += 2;
}

uint64_t HTTPHeaderDict::sizeHeaders(HTTPHeaderDict *this)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZNK14HTTPHeaderDict11sizeHeadersEv_block_invoke;
  v3[3] = &unk_1E14FC858;
  v3[4] = &v4;
  v3[5] = this;
  HTTPHeaderDict::visitHeaders((uint64_t)this, 0, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_183F20654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

char *HTTPRequestMessage::firstLineForSerialization(HTTPRequestMessage *this, int a2)
{
  char **v2;
  HTTPRequestParserClient *v6;
  uint64_t v7;
  uint64_t v8;
  const __CFString *v9;
  const __CFString *v10;
  unsigned __int8 *v11;
  int v12;
  const void *v13;
  const __CFString *v14;
  const __CFAllocator *v15;
  UInt8 *v16;
  const __CFAllocator *v17;
  const __CFURL *v18;
  CFAllocatorRef allocator;
  uint64_t v20;
  void *ptr;
  const char *v22;
  CFAllocatorRef v23;
  uint64_t v24;
  void *v25;
  UInt8 v26[1024];
  unsigned __int8 __dst[128];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = (char **)((char *)this + 176);
  if (!*((_QWORD *)this + 22))
  {
    v6 = (HTTPRequestMessage *)((char *)this + 128);
    v7 = HTTPRequestParserClient::requestURL((HTTPRequestMessage *)((char *)this + 128));
    if (*((_QWORD *)this + 19))
    {
      v8 = v7;
      v9 = (const __CFString *)*((_QWORD *)this + 5);
      if (v9)
      {
        if (v8)
        {
          v10 = StringSerializable::maximumSerializedLength(v9);
          if ((unint64_t)v10 >= 0x80)
            v11 = (unsigned __int8 *)malloc_type_malloc((size_t)v10, 0x92F286A4uLL);
          else
            v11 = __dst;
          v12 = StringSerializable::serialize((HTTPRequestMessage *)((char *)this + 32), v11);
          CFGetAllocator((char *)this - 16);
          v13 = (const void *)*((_QWORD *)this + 19);
          if (v13)
            v14 = (const __CFString *)CFRetain(v13);
          else
            v14 = 0;
          v15 = CFGetAllocator((char *)this - 16);
          v23 = v15;
          v24 = 1023;
          if (v14)
          {
            v16 = _CFStringGetOrCreateCString(v15, v14, v26, &v24, 0x201u);
          }
          else
          {
            v26[0] = 0;
            v24 = 0;
            v16 = v26;
          }
          v25 = v16;
          v17 = CFGetAllocator((char *)this - 16);
          v18 = (const __CFURL *)HTTPRequestParserClient::requestURL(v6);
          URLPortion::URLPortion((URLPortion *)&allocator, v17, v18, a2);
          asprintf(v2, "%s %s %.*s", (const char *)v16, v22, v12, (const char *)v11);
          if (ptr != &v20)
            CFAllocatorDeallocate(allocator, ptr);
          if (v14)
            CFRelease(v14);
          if (v11 != __dst)
            free(v11);
          if (v25 && v26 != v25)
            CFAllocatorDeallocate(v23, v25);
        }
      }
    }
  }
  return *v2;
}

void sub_183F20858(_Unwind_Exception *a1)
{
  void *v1;
  void *v3;

  v3 = (void *)STACK[0x250];
  if (STACK[0x250])
  {
    if (v1 != v3)
      CFAllocatorDeallocate((CFAllocatorRef)STACK[0x240], v3);
  }
  _Unwind_Resume(a1);
}

size_t StringSerializable::serialize(StringSerializable *this, unsigned __int8 *__dst)
{
  uint64_t v3;
  BOOL v4;
  unsigned int v5;
  UInt8 *CString;
  size_t v7;
  BOOL v8;
  const __CFAllocator *allocator;
  uint64_t v11[2];
  UInt8 v12[1024];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (!__dst)
    return 0;
  v3 = *((_QWORD *)this + 1);
  if (!v3)
    return 0;
  v4 = v3 >= (uint64_t)gConstantCFStringValueTable && v3 < (uint64_t)&gConstantCFStringValueTable[3969];
  if (v4 && (v5 = *(_DWORD *)(v3 + 32), v5 != 568))
  {
    v7 = (v5 >> 13) & 0x7F;
    memcpy(__dst, &gStringValueTable[2 * (v5 & 0x1FFF)], v7);
  }
  else
  {
    allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v11[0] = 1023;
    CString = _CFStringGetOrCreateCString(allocator, (CFStringRef)v3, v12, v11, 0x201u);
    v11[1] = (uint64_t)CString;
    v7 = v11[0];
    memcpy(__dst, CString, v11[0]);
    if (CString)
      v8 = v12 == CString;
    else
      v8 = 1;
    if (!v8)
      CFAllocatorDeallocate(allocator, CString);
  }
  return v7;
}

const __CFString *StringSerializable::maximumSerializedLength(const __CFString *this)
{
  CFIndex Length;

  if (this)
  {
    Length = CFStringGetLength(this);
    return (const __CFString *)CFStringGetMaximumSizeForEncoding(Length, 0x201u);
  }
  return this;
}

void HTTPUtilities::createPathStringFromURL(HTTPUtilities *this, CFURLRef anURL)
{
  const __CFAllocator *v3;
  char *v4;
  CFAllocatorRef allocator;
  uint64_t v6;
  void *ptr;
  char *cStr;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  URLPortion::URLPortion((URLPortion *)&allocator, (const __CFAllocator *)*MEMORY[0x1E0C9AE00], anURL, 0);
  v4 = cStr;
  *(_QWORD *)this = 0;
  if (v4)
    *(_QWORD *)this = CFStringCreateWithCString(v3, v4, 0x600u);
  if (ptr != &v6)
    CFAllocatorDeallocate(allocator, ptr);
}

void sub_183F20AAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const __CFAllocator *allocator, uint64_t a10)
{
  _QWORD *v10;

  *v10 = 0;
  if ((uint64_t *)STACK[0x208] != &a10)
    CFAllocatorDeallocate(allocator, (void *)STACK[0x208]);
  _Unwind_Resume(a1);
}

void URLPortion::URLPortion(URLPortion *this, const __CFAllocator *a2, CFURLRef anURL, int a4)
{
  const __CFAllocator *v5;
  CFStringRef v7;
  CFStringRef v8;
  CFStringRef v9;
  CFStringRef v10;
  CFStringRef v11;
  CFStringRef v12;
  CFStringRef v13;
  const __CFString *v14;
  const __CFString *v15;
  const __CFString *v16;
  const __CFString *v17;
  const __CFAllocator *v18;
  const __CFString *v19;
  const __CFURL *v20;
  const __CFURL *v21;
  CFIndex v22;
  UInt8 *v23;
  uint64_t v24;
  unsigned int v25;
  CFIndex location;
  CFRange v27;
  CFIndex v28;
  CFIndex v29;
  uint64_t v30;
  const __CFAllocator *v31;
  CFRange rangeIncludingSeparators;

  v5 = a2;
  *(_QWORD *)this = a2;
  v7 = CFURLCopyScheme(anURL);
  v8 = CFURLCopyHostName(anURL);
  v9 = CFURLCopyPath(anURL);
  v10 = CFURLCopyUserName(anURL);
  v11 = CFURLCopyPassword(anURL);
  v12 = CFURLCopyResourceSpecifier(anURL);
  v13 = v12;
  if ((unint64_t)v10 | (unint64_t)v11 && v7 && (unint64_t)v9 | (unint64_t)v8)
  {
    v14 = &stru_1E1500C68;
    if (v8)
      v15 = v8;
    else
      v15 = &stru_1E1500C68;
    if (v9)
      v16 = v9;
    else
      v16 = &stru_1E1500C68;
    if (v12)
      v14 = v12;
    v17 = CFStringCreateWithFormat(v5, 0, CFSTR("%@://%@%@%@"), v7, v15, v16, v14);
    v18 = v5;
    v19 = v17;
    v31 = v18;
    v20 = CFURLCreateWithString(v18, v17, 0);
    if (v19)
      CFRelease(v19);
    v5 = v31;
    if (v20)
      goto LABEL_17;
  }
  if (anURL)
  {
    v20 = (const __CFURL *)CFRetain(anURL);
    if (!v7)
      goto LABEL_18;
    goto LABEL_17;
  }
  v20 = 0;
  if (v7)
LABEL_17:
    CFRelease(v7);
LABEL_18:
  if (v8)
    CFRelease(v8);
  if (v9)
    CFRelease(v9);
  if (v13)
    CFRelease(v13);
  if (v10)
    CFRelease(v10);
  if (v11)
    CFRelease(v11);
  v21 = CFURLCopyAbsoluteURL(v20);
  *((_QWORD *)this + 65) = (char *)this + 8;
  v22 = CFURLGetBytes(v21, (UInt8 *)this + 9, 510);
  if (v22 == -1)
  {
    v22 = CFURLGetBytes(v21, 0, 0);
    v23 = (UInt8 *)CFAllocatorAllocate(v5, v22 + 2, 0);
    *((_QWORD *)this + 65) = v23;
    CFURLGetBytes(v21, v23 + 1, v22);
  }
  v24 = *((_QWORD *)this + 65) + 1;
  if (a4)
    goto LABEL_31;
  v27 = CFURLGetByteRangeForComponent(v21, kCFURLComponentPath, &rangeIncludingSeparators);
  if (v27.location == -1 || !v27.length)
  {
    location = rangeIncludingSeparators.location;
    if (rangeIncludingSeparators.location == -1)
    {
LABEL_31:
      v25 = 0;
      location = 0;
      goto LABEL_39;
    }
    *(_BYTE *)(v24 + rangeIncludingSeparators.location - 1) = 47;
    v25 = 1;
  }
  else
  {
    location = v27.location;
    v25 = 0;
  }
LABEL_39:
  v28 = CFURLGetByteRangeForComponent(v21, kCFURLComponentFragment, 0).location;
  v29 = v22 - location;
  if (v28 != -1)
    v29 = v28 + ~location;
  v30 = v24 + location;
  *(_BYTE *)(v30 + v29) = 0;
  if (v21)
    CFRelease(v21);
  *((_QWORD *)this + 66) = v30 - v25;
  if (v20)
    CFRelease(v20);
}

CFArrayRef CFHTTPCookieCreateWithResponseHeaderFields(const __CFAllocator *a1, CFDictionaryRef theDict, const __CFURL *a3)
{
  const void *Value;
  __CFArray *Array;
  __CFArray *CookiesWithCookieStrings;

  Value = CFDictionaryGetValue(theDict, &unk_1EDCFD660);
  if (!Value)
    return CFArrayCreate(a1, 0, 0, MEMORY[0x1E0C9B378]);
  Array = cfTypeCreateArray(a1, Value, 0, 0, 0);
  CookiesWithCookieStrings = _createCookiesWithCookieStrings(a1, Array, a3, 0, 0);
  if (Array)
    CFRelease(Array);
  if (CookiesWithCookieStrings)
    return CookiesWithCookieStrings;
  else
    return CFArrayCreate(a1, 0, 0, MEMORY[0x1E0C9B378]);
}

void sub_183F20E30(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_pointer<TubeManager *,TubeManager::_onqueue_createNewTube(HTTPConnectionCacheKey *)::$_0,std::allocator<TubeManager>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

void TubeManager::addNewFastPathCache(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v7;
  CFIndex Count;
  uint64_t v9;
  double Current;
  double v11;
  uint64_t v12;
  void *v13;
  int v15;
  void *v16;
  void *v17;
  _NSHTTPAlternativeServiceEntry *v18;

  v5 = *(_QWORD *)(a1 + 152);
  if (!v5)
  {
    v5 = operator new();
    *(_QWORD *)v5 = &off_1E14ED218;
    *(_QWORD *)(v5 + 8) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    v7 = *(_QWORD *)(a1 + 152);
    *(_QWORD *)(a1 + 152) = v5;
    if (v7)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
      v5 = *(_QWORD *)(a1 + 152);
    }
  }
  if (a2)
  {
    *(CFAbsoluteTime *)(a2 + 144) = CFAbsoluteTimeGetCurrent();
    Count = CFArrayGetCount(*(CFArrayRef *)(v5 + 8));
    if (Count == 200)
    {
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v5 + 8), 0);
      v9 = 199;
      Current = CFAbsoluteTimeGetCurrent();
    }
    else
    {
      v9 = Count;
      Current = CFAbsoluteTimeGetCurrent();
      if (v9 < 1)
      {
LABEL_11:
        CFArrayAppendValue(*(CFMutableArrayRef *)(v5 + 8), (const void *)a2);
        goto LABEL_12;
      }
    }
    v11 = Current;
    v12 = v9 + 1;
    do
    {
      if (*((double *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v5 + 8), 0) + 18) + 1800.0 >= v11)
        break;
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v5 + 8), 0);
      --v12;
    }
    while (v12 > 1);
    goto LABEL_11;
  }
LABEL_12:
  v13 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 72))(a2);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a2 + 88))(a2) == 1 && v13 != 0)
  {
    v15 = objc_msgSend(v13, "hasSuffix:", CFSTR(".apple.com"));
    if (a3 && v15)
    {
      v18 = objc_alloc_init(_NSHTTPAlternativeServiceEntry);
      -[_NSHTTPAlternativeServiceEntry setServiceType:](v18, "setServiceType:", -1);
      -[_NSHTTPAlternativeServiceEntry setHost:](v18, "setHost:", v13);
      -[_NSHTTPAlternativeServiceEntry setPort:](v18, "setPort:", (*(int (**)(uint64_t))(*(_QWORD *)a2 + 80))(a2));
      -[_NSHTTPAlternativeServiceEntry setAlternateHost:](v18, "setAlternateHost:", -[_NSHTTPAlternativeServiceEntry host](v18, "host"));
      -[_NSHTTPAlternativeServiceEntry setAlternatePort:](v18, "setAlternatePort:", -[_NSHTTPAlternativeServiceEntry port](v18, "port"));
      -[_NSHTTPAlternativeServiceEntry setPartition:](v18, "setPartition:", *(_QWORD *)(a2 + 48));
      v16 = (void *)objc_msgSend(MEMORY[0x1E0C99D48], "currentCalendar");
      -[_NSHTTPAlternativeServiceEntry setExpirationDate:](v18, "setExpirationDate:", objc_msgSend(v16, "nextDateAfterDate:matchingUnit:value:options:", objc_msgSend(MEMORY[0x1E0C99D68], "date"), 32, 0, 1024));
      v17 = (void *)objc_msgSend((id)objc_msgSend(*(id *)(a3 - 96), "_effectiveConfiguration"), "_alternativeServicesStorage");
      if (v17)
        objc_msgSend(v17, "storeHTTPServiceEntry:", v18);

    }
  }
}

void sub_183F210CC(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  MEMORY[0x186DB748C](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

void HTTPEngine::_cleanupConnection(HTTPEngine *this, uint64_t a2)
{
  TransportConnection *v4;
  int v5;
  uint64_t v6;
  const void *v7;
  uint64_t v8;
  unint64_t v9;
  const void *v10;
  void (**v11)(_QWORD, _QWORD, _QWORD, _QWORD);
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  void (**v15)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  const void *v16;
  uint64_t v17;
  int v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  void (**v22)(_QWORD, _QWORD, _QWORD);
  __int128 v23;
  uint64_t v24;
  std::__shared_weak_count *v25;

  HTTPEngine::_100ContinueTimerCancel(this);
  v4 = (TransportConnection *)*((_QWORD *)this + 7);
  if (v4)
  {
    v5 = *((_DWORD *)this + 8);
    if ((v5 & 1) == 0)
    {
      *((_DWORD *)this + 8) = v5 | 1;
      if ((v5 & 0x200) == 0)
      {
        TransportConnection::rstConnectionDelegate(v4);
        (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 7) + 152))(*((_QWORD *)this + 7), a2);
        v6 = *((_QWORD *)this + 14);
        if (*(_DWORD *)(v6 + 72) == 1)
          dispatch_source_set_timer(*(dispatch_source_t *)(v6 + 64), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
        *(_DWORD *)(v6 + 72) = 0;
        v7 = *(const void **)(v6 + 96);
        if (v7)
        {
          _Block_release(v7);
          *(_QWORD *)(v6 + 96) = 0;
        }
      }
      if (*((_QWORD *)this + 12) | *((_QWORD *)this + 13))
        v8 = *((_QWORD *)this + 12);
      else
        v8 = 4;
      if (*((_QWORD *)this + 12) | *((_QWORD *)this + 13))
        v9 = *((_QWORD *)this + 13);
      else
        v9 = *((_QWORD *)this + 13) & 0xFFFFFFFF00000000 | 0xFFFFFFFC;
      v10 = (const void *)*((_QWORD *)this + 20);
      if (v10)
      {
        _Block_release(v10);
        *((_QWORD *)this + 20) = 0;
      }
      v11 = (void (**)(_QWORD, _QWORD, _QWORD, _QWORD))*((_QWORD *)this + 25);
      if (v11)
      {
        *((_QWORD *)this + 25) = 0;
        v24 = 0;
        v25 = 0;
        ((void (**)(_QWORD, uint64_t *, uint64_t, unint64_t))v11)[2](v11, &v24, v8, v9);
        v12 = v25;
        if (v25)
        {
          p_shared_owners = (unint64_t *)&v25->__shared_owners_;
          do
            v14 = __ldaxr(p_shared_owners);
          while (__stlxr(v14 - 1, p_shared_owners));
          if (!v14)
          {
            ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
            std::__shared_weak_count::__release_weak(v12);
          }
        }
        _Block_release(v11);
      }
      v15 = (void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))*((_QWORD *)this + 26);
      if (v15)
      {
        *((_QWORD *)this + 26) = 0;
        v15[2](v15, 0, v8, v9, 0);
        _Block_release(v15);
      }
      v16 = (const void *)*((_QWORD *)this + 27);
      if (v16)
      {
        _Block_release(v16);
        *((_QWORD *)this + 27) = 0;
      }
      v17 = *((_QWORD *)this + 32);
      if (v17)
      {
        v18 = *((_DWORD *)this + 8);
        if ((v18 & 0x10000000) != 0)
        {
          *((_DWORD *)this + 8) = v18 & 0xEFFFFFFF;
          (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
        }
        v23 = 0uLL;
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 256, &v23);
        v19 = (std::__shared_weak_count *)*((_QWORD *)&v23 + 1);
        if (*((_QWORD *)&v23 + 1))
        {
          v20 = (unint64_t *)(*((_QWORD *)&v23 + 1) + 8);
          do
            v21 = __ldaxr(v20);
          while (__stlxr(v21 - 1, v20));
          if (!v21)
          {
            ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
            std::__shared_weak_count::__release_weak(v19);
          }
        }
      }
      v22 = (void (**)(_QWORD, _QWORD, _QWORD))*((_QWORD *)this + 39);
      if (v22)
      {
        *((_QWORD *)this + 39) = 0;
        v22[2](v22, v8, v9);
        _Block_release(v22);
      }
    }
  }
}

void sub_183F21318(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void HTTPEngine::_100ContinueTimerCancel(HTTPEngine *this)
{
  NSObject *v2;

  v2 = *((_QWORD *)this + 40);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 40));
    *((_QWORD *)this + 40) = 0;
  }
}

void RequestBodyStream::updateScheduling(RequestBody *this, const CoreSchedulingSet *a2)
{
  RequestBody::updateScheduling(this, a2);
  if ((*((_BYTE *)this + 192) & 0x21) == 0x20)
    RequestBodyStream::_onqueue_setupStream((RequestBodyStream *)this);
  if (*((_QWORD *)this + 8) && *((_QWORD *)this + 15) && (*((_BYTE *)this + 192) & 1) != 0)
    RequestBodyStream::_onqueue_resume((RequestBodyStream *)this);
}

void RequestBody::updateScheduling(RequestBody *this, const CoreSchedulingSet *a2)
{
  _QWORD *v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  __int128 v8;

  if (a2)
    (*(void (**)(const CoreSchedulingSet *))(*(_QWORD *)a2 + 40))(a2);
  *(_QWORD *)&v8 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_1E14F1668;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  *((_QWORD *)&v8 + 1) = v4;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 64, &v8);
  v5 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
  if (*((_QWORD *)&v8 + 1))
  {
    v6 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

uint64_t `non-virtual thunk to'HTTP2StreamBridge::getProxy(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 120))(*((_QWORD *)this + 2));
}

uint64_t `non-virtual thunk to'HTTP2StreamBridge::canScheduleAndOpenWithHandlerAsync(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 32))(*((_QWORD *)this + 2));
}

uint64_t `non-virtual thunk to'HTTP2StreamBridge::setBodyStreamBeforeOpening(HTTP2StreamBridge *this, __CFReadStream *a2)
{
  return (*(uint64_t (**)(_QWORD, __CFReadStream *))(**((_QWORD **)this + 2) + 64))(*((_QWORD *)this + 2), a2);
}

uint64_t `non-virtual thunk to'HTTP2StreamBridge::scheduleAndOpenWithHandler(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

uint64_t `non-virtual thunk to'HTTP2StreamBridge::setTransactionMetrics(HTTP2StreamBridge *this, __CFN_TransactionMetrics *a2)
{
  return (*(uint64_t (**)(_QWORD, __CFN_TransactionMetrics *))(**((_QWORD **)this + 2) + 16))(*((_QWORD *)this + 2), a2);
}

uint64_t `non-virtual thunk to'HTTP2StreamBridge::setPriorityHint(HTTP2StreamBridge *this, float a2)
{
  return (*(uint64_t (**)(_QWORD, float))(**((_QWORD **)this + 2) + 128))(*((_QWORD *)this + 2), a2);
}

CFTypeRef `non-virtual thunk to'HTTP2StreamBridge::_meta_retain(HTTP2StreamBridge *this)
{
  return CFRetain((char *)this - 24);
}

BOOL HTTPBodyData::captureData(HTTPBodyData *this, const char *a2)
{
  const char *v3;
  char *v4;
  uint64_t v5;
  _BOOL8 v6;

  HTTPBodyData::logit(this, a2);
  v4 = (char *)this + 24;
  v5 = *((_QWORD *)this + 3);
  if (!v5)
    v4 = (char *)this + 16;
  v6 = v5 != 0;
  *(_QWORD *)v4 = 0;
  HTTPBodyData::logit(this, v3);
  return v6;
}

void HTTP2Stream::getProxy(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t HTTP2Stream::canScheduleAndOpenWithHandlerAsync(HTTP2Stream *this)
{
  return 1;
}

void HTTP2Stream::setBodyStreamBeforeOpening(HTTP2Stream *this, CFTypeRef cf, uint64_t a3)
{
  std::__shared_weak_count_vtbl *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  const __CFData *v13;
  std::__shared_weak_count_vtbl *v14;
  _QWORD *v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  _QWORD *v23;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(uint64_t);
  void *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  __int128 v36;
  std::__shared_weak_count_vtbl *v37;
  std::__shared_weak_count *v38;

  if (cf)
  {
    v5 = (std::__shared_weak_count_vtbl *)CFRetain(cf);
    v6 = *((_QWORD *)this + 35);
    v7 = (std::__shared_weak_count *)*((_QWORD *)this + 36);
    v8 = MEMORY[0x1E0C809B0];
    if (v7)
    {
      p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
      do
        v10 = __ldxr(p_shared_weak_owners);
      while (__stxr(v10 + 1, p_shared_weak_owners));
      v30 = v8;
      v31 = 3321888768;
      v32 = ___ZN11HTTP2Stream26setBodyStreamBeforeOpeningEP14__CFReadStreamx_block_invoke;
      v33 = &__block_descriptor_48_e8_32c36_ZTSNSt3__18weak_ptrI11HTTP2StreamEE_e5_v8__0l;
      v34 = v6;
      v35 = v7;
      v11 = (unint64_t *)&v7->__shared_weak_owners_;
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }
    else
    {
      v30 = MEMORY[0x1E0C809B0];
      v31 = 3321888768;
      v32 = ___ZN11HTTP2Stream26setBodyStreamBeforeOpeningEP14__CFReadStreamx_block_invoke;
      v33 = &__block_descriptor_48_e8_32c36_ZTSNSt3__18weak_ptrI11HTTP2StreamEE_e5_v8__0l;
      v34 = v6;
      v35 = 0;
    }
    v23 = operator new(0xE0uLL);
    v23[1] = 0;
    v23[2] = 0;
    *v23 = &off_1E14F0BE8;
    v37 = v5;
    if (v5)
    {
      v24 = (std::__shared_weak_count *)operator new();
      v24->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F15C0;
      v24->__shared_owners_ = 0;
      v24->__shared_weak_owners_ = 0;
      v24[1].__vftable = v5;
    }
    else
    {
      v24 = 0;
    }
    v38 = v24;
    RequestBodyStream::RequestBodyStream((uint64_t)(v23 + 3), (uint64_t *)&v37, *((dispatch_object_t *)this + 9), *((_QWORD *)this + 2), a3, 1, &v30);
    if (v24)
    {
      p_shared_owners = (unint64_t *)&v24->__shared_owners_;
      do
        v26 = __ldaxr(p_shared_owners);
      while (__stlxr(v26 - 1, p_shared_owners));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
    *(_QWORD *)&v36 = v23 + 3;
    *((_QWORD *)&v36 + 1) = v23;
    std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&v36, v23 + 4, (uint64_t)(v23 + 3));
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 264, &v36);
    v27 = (std::__shared_weak_count *)*((_QWORD *)&v36 + 1);
    if (*((_QWORD *)&v36 + 1))
    {
      v28 = (unint64_t *)(*((_QWORD *)&v36 + 1) + 8);
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    if (v35)
      std::__shared_weak_count::__release_weak(v35);
    if (v7)
    {
      v22 = v7;
      goto LABEL_37;
    }
  }
  else
  {
    v13 = CFHTTPMessageCopyBody((CFHTTPMessageRef)(*((_QWORD *)this + 5) - 16));
    if (v13)
    {
      v14 = (std::__shared_weak_count_vtbl *)v13;
      if (CFDataGetLength(v13) < 1)
      {
        CFRelease(v14);
        return;
      }
      v15 = operator new(0x98uLL);
      v15[1] = 0;
      v15[2] = 0;
      *v15 = &off_1E14F0B08;
      v37 = v14;
      v16 = (std::__shared_weak_count *)operator new();
      v16->__shared_owners_ = 0;
      v17 = (unint64_t *)&v16->__shared_owners_;
      v16->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1A90;
      v16->__shared_weak_owners_ = 0;
      v16[1].__vftable = v14;
      v38 = v16;
      RequestBody::RequestBody((uint64_t)(v15 + 3), *((dispatch_object_t *)this + 9), *((_QWORD *)this + 2), a3);
      v15[17] = 0;
      v15[3] = &off_1E14E7BE8;
      v15[6] = &unk_1E14E7C58;
      v15[18] = 0;
      std::shared_ptr<__CFString const>::operator=[abi:nn180100](v15 + 17, (uint64_t)v14, (uint64_t)v16);
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
      *(_QWORD *)&v36 = v15 + 3;
      *((_QWORD *)&v36 + 1) = v15;
      std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&v36, v15 + 4, (uint64_t)(v15 + 3));
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 264, &v36);
      v19 = (std::__shared_weak_count *)*((_QWORD *)&v36 + 1);
      if (*((_QWORD *)&v36 + 1))
      {
        v20 = (unint64_t *)(*((_QWORD *)&v36 + 1) + 8);
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          v22 = v19;
LABEL_37:
          std::__shared_weak_count::__release_weak(v22);
        }
      }
    }
  }
}

void sub_183F218A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, char a17)
{
  std::__shared_weak_count *v17;
  void *v19;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  std::__shared_weak_count::~__shared_weak_count(v17);
  operator delete(v19);
  _Unwind_Resume(a1);
}

uint64_t HTTP2Stream::scheduleAndOpenWithHandler(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  uint64_t v11;
  BOOL v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  BOOL v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  HTTPMessage *v43;
  HTTPMessage *v44;
  const __CFString *v45;
  const __CFString *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  const __CFAllocator *v50;
  uint64_t v51;
  id *v52;
  uint64_t v53;
  int v54;
  double v55;
  void *v56;
  UInt8 *v57;
  const __CFString *v58;
  UInt8 *v59;
  _DWORD *v60;
  _DWORD *v61;
  uint64_t v62;
  uint64_t v63;
  const __CFDictionary *v64;
  unint64_t v65;
  char *v66;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  char *v70;
  uint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  __int128 v75;
  __int128 v76;
  uint64_t v77;
  unint64_t v78;
  const __CFString *v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  char *v87;
  char *v88;
  __int128 v89;
  __int128 v90;
  unint64_t v91;
  uint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  unint64_t v98;
  char *v99;
  char *v100;
  __int128 v101;
  __int128 v102;
  unint64_t v103;
  const __CFURL *v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  unint64_t v110;
  char *v111;
  char *v112;
  __int128 v113;
  __int128 v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  unint64_t v118;
  uint64_t v119;
  unint64_t v120;
  unint64_t v121;
  char *v122;
  char *v123;
  __int128 v124;
  __int128 v125;
  uint64_t v126;
  void *v127;
  void *v128;
  void *v129;
  unint64_t v130;
  _QWORD *v131;
  std::__shared_weak_count *v132;
  HTTP2Stream *v133;
  unint64_t *v134;
  unint64_t v135;
  __int128 *v136;
  unint64_t *v137;
  unint64_t v138;
  unint64_t *v139;
  unint64_t v140;
  HTTP2Stream *v141;
  void **v142;
  void **v143;
  void *v144;
  UInt8 *v145;
  CFIndex v146;
  CFIndex v147;
  UInt8 *v148;
  UInt8 *v149;
  CFIndex v150;
  CFIndex Length;
  UInt8 *CStringFromCFString;
  const __CFString *cf;
  const __CFString *v154;
  const __CFURL *v155;
  const __CFString *v156;
  uint64_t v157;
  const __CFDictionary *theDict;
  _QWORD v159[5];
  HTTP2Stream *v160;
  std::__shared_weak_count *v161;
  uint64_t v162;
  std::__shared_weak_count *v163;
  uint64_t context;
  uint64_t v165;
  void *v166;
  void *v167;
  uint64_t *v168;
  __int128 *v169;
  _QWORD *v170;
  uint64_t v171;
  HTTP2Stream *v172;
  std::__shared_weak_count *v173;
  void *v174;
  __int128 *v175;
  _QWORD *v176;
  int v177;
  uint64_t v178;
  void **v179;
  void **v180;
  uint64_t v181;
  uint64_t v182;
  _QWORD v183[3];
  int v184;
  uint64_t v185;
  uint64_t *v186;
  uint64_t v187;
  char v188;
  __int128 v189;
  char *v190;
  const __CFString *v191;
  CFStreamError v192;
  CFStreamError v193;

  if (*(_QWORD *)(a1 + 24))
    __assert_rtn("scheduleAndOpenWithHandler", "HTTP2Stream.cpp", 412, "fProtocolHandler == NULL");
  if (*(_BYTE *)(a1 + 320))
  {
    v5 = *(_QWORD *)(a1 + 64);
    if (v5 && (v6 = *(_QWORD *)(v5 + 56)) != 0 && *(_DWORD *)v6 == 1)
    {
      v7 = *(_QWORD *)(v6 + 8);
      v8 = *(std::__shared_weak_count **)(v6 + 16);
      context = v7;
      v165 = (uint64_t)v8;
      if (v8)
      {
        p_shared_owners = (unint64_t *)&v8->__shared_owners_;
        do
          v10 = __ldxr(p_shared_owners);
        while (__stxr(v10 + 1, p_shared_owners));
      }
      v11 = *(_QWORD *)(a1 + 16);
      if (v11)
        v12 = v7 == 0;
      else
        v12 = 1;
      if (!v12)
      {
        (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD))(*(_QWORD *)v7 + 280))(v7, *(_QWORD *)(v11 - 96), 5, 0);
        *(_BYTE *)(a1 + 232) = 1;
      }
    }
    else
    {
      v8 = 0;
      context = 0;
      v165 = 0;
    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 312) + 16))();
    if (v8)
    {
      v13 = (unint64_t *)&v8->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        v15 = v8;
LABEL_56:
        std::__shared_weak_count::__release_weak(v15);
        return 1;
      }
    }
    return 1;
  }
  *(_QWORD *)(a1 + 32) = a2;
  (*(void (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
  *(_QWORD *)(a1 + 24) = _Block_copy(a3);
  v162 = 0;
  v163 = 0;
  v18 = *(std::__shared_weak_count **)(a1 + 288);
  if (v18 && (v19 = std::__shared_weak_count::lock(v18), (v163 = v19) != 0))
  {
    v20 = a1 + 64;
    v21 = *(_QWORD *)(a1 + 64);
    v22 = *(_QWORD *)(a1 + 280);
    v161 = v19;
    v162 = v22;
    v160 = (HTTP2Stream *)v22;
    v23 = (unint64_t *)&v19->__shared_owners_;
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }
  else
  {
    v22 = 0;
    v20 = a1 + 64;
    v21 = *(_QWORD *)(a1 + 64);
    v160 = 0;
    v161 = 0;
  }
  v25 = MEMORY[0x1E0C809B0];
  v159[0] = MEMORY[0x1E0C809B0];
  v159[1] = 3221225472;
  v159[2] = ___ZN11HTTP2Stream26scheduleAndOpenWithHandlerEPK17CoreSchedulingSetU13block_pointerFvP15__CFHTTPMessagePU27objcproto16OS_dispatch_data8NSObjectPK13CFStreamErrorEU13block_pointerFvhE_block_invoke;
  v159[3] = &__block_descriptor_40_e5_v8__0l;
  v159[4] = a1;
  if (*(_QWORD *)(v22 + 184) || *(_DWORD *)(v22 + 192))
  {
    v26 = 0;
  }
  else
  {
    v43 = *(HTTPMessage **)(v22 + 40);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*((_BYTE *)v43 + 24))
      v44 = 0;
    else
      v44 = v43;
    v45 = HTTPMessage::copyHeaderFieldValue(v44, 0x1171B29Fu);
    v46 = v45;
    if (v45)
    {
      if (CFStringHasPrefix(v45, CFSTR("NTLM"))
        || CFStringHasPrefix(v46, CFSTR("Kerberos"))
        || CFStringHasPrefix(v46, CFSTR("Negotiate"))
        || CFStringHasPrefix(v46, CFSTR("Nego2")))
      {
        CFRelease(v46);
        HTTP2Stream::handle_HTTP_1_1_REQUIRED_error((HTTP2Stream *)v22);
        v192.domain = 4;
        *(_QWORD *)&v192.error = 4294965096;
        HTTP2Stream::setError((HTTP2Stream *)v22, v192);
        v26 = 1;
        *(_BYTE *)(v22 + 131) = 1;
        HTTP2Stream::closeStreamWithErrorCode((HTTP2Stream *)v22);
        goto LABEL_29;
      }
      CFRelease(v46);
    }
    v185 = 0;
    v186 = &v185;
    v187 = 0x2020000000;
    v188 = 1;
    v183[0] = 0;
    v183[1] = v183;
    v183[2] = 0x2020000000;
    v184 = -1;
    v178 = 2048;
    v179 = 0;
    v180 = 0;
    v181 = 0;
    v182 = 0;
    v47 = *(_QWORD *)(v22 + 40);
    v48 = *(_QWORD *)(v22 + 264);
    if (v48)
      v49 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v48 + 56))(v48);
    else
      v49 = 0;
    v50 = (const __CFAllocator *)(v47 - 16);
    v51 = *(_QWORD *)(v22 + 16);
    if (v51)
      v52 = (id *)(v51 - 176);
    else
      v52 = 0;
    cleanUpRequest((__CFHTTPMessage *)(v47 - 16), v49, 1, 0, v52);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    HTTPMessage::setVersion(v47, 0x1981173Du);
    v53 = *(_QWORD *)(v22 + 16);
    if (v53)
    {
      v54 = objc_msgSend(*(id *)(v53 - 96), "_cachePolicy");
      objc_msgSend(*(id *)(v53 - 96), "_timeoutInterval");
    }
    else
    {
      v54 = 0;
      v55 = 0.0;
    }
    v56 = (void *)_constructRequestFromParts(v50, 0, (const __CFArray *)v54, NSURLRequestUseProtocolCachePolicy, v55, 0);
    -[__CFN_TransactionMetrics setTransferredRequest:](*(_QWORD *)(v22 + 304), v56);
    if (v56)
      CFRelease(v56);
    v156 = CFHTTPMessageCopyRequestMethod(v50);
    CStringFromCFString = http2CreateCStringFromCFString(v156, (MemPool *)&v178);
    Length = CFStringGetLength(v156);
    v155 = CFHTTPMessageCopyRequestURL(v50);
    v154 = CFURLCopyScheme(v155);
    v57 = http2CreateCStringFromCFString(v154, (MemPool *)&v178);
    v150 = CFStringGetLength(v154);
    HTTPUtilities::createPathStringFromURL((HTTPUtilities *)&v191, v155);
    v58 = v191;
    v148 = http2CreateCStringFromCFString(v191, (MemPool *)&v178);
    v149 = v57;
    v147 = CFStringGetLength(v58);
    cf = CFHTTPMessageCopyHeaderFieldValue(v50, (CFStringRef)&gConstantCFStringValueTable[2065]);
    v59 = http2CreateCStringFromCFString(cf, (MemPool *)&v178);
    v146 = CFStringGetLength(cf);
    v145 = v59;
    v60 = (_DWORD *)MemPool::malloc((MemPool *)&v178, 7);
    *(_DWORD *)((char *)v60 + 3) = 1685022836;
    *v60 = 1952804154;
    v61 = (_DWORD *)MemPool::malloc((MemPool *)&v178, 7);
    *(_DWORD *)((char *)v61 + 3) = 1701668200;
    *v61 = 1751348026;
    v62 = MemPool::malloc((MemPool *)&v178, 5);
    *(_BYTE *)(v62 + 4) = 104;
    *(_DWORD *)v62 = 1952542778;
    v63 = MemPool::malloc((MemPool *)&v178, 10);
    *(_WORD *)(v63 + 8) = 31092;
    v157 = v63;
    *(_QWORD *)v63 = *(_QWORD *)":authority";
    v64 = CFHTTPMessageCopyAllHeaderFields(v50);
    v189 = 0uLL;
    v190 = 0;
    theDict = v64;
    v65 = CFDictionaryGetCount(v64) + 4;
    v66 = v190;
    v67 = v189;
    if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v190[-v189] >> 3) < v65)
    {
      if (v65 > 0x666666666666666)
        abort();
      v68 = *((_QWORD *)&v189 + 1);
      v69 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<nghttp2_nv>>(v65);
      v70 = &v69[40 * ((v68 - v67) / 40)];
      v66 = &v69[40 * v71];
      v72 = (char *)*((_QWORD *)&v189 + 1);
      v73 = (char *)v189;
      v74 = v70;
      if (*((_QWORD *)&v189 + 1) != (_QWORD)v189)
      {
        do
        {
          v75 = *(_OWORD *)(v72 - 40);
          v76 = *(_OWORD *)(v72 - 24);
          *((_QWORD *)v74 - 1) = *((_QWORD *)v72 - 1);
          *(_OWORD *)(v74 - 24) = v76;
          *(_OWORD *)(v74 - 40) = v75;
          v74 -= 40;
          v72 -= 40;
        }
        while (v72 != v73);
        v72 = v73;
      }
      *(_QWORD *)&v189 = v74;
      *((_QWORD *)&v189 + 1) = v70;
      v190 = v66;
      if (v72)
      {
        operator delete(v72);
        v66 = v190;
      }
    }
    v77 = *((_QWORD *)&v189 + 1);
    if (*((_QWORD *)&v189 + 1) >= (unint64_t)v66)
    {
      v80 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((_QWORD *)&v189 + 1) - v189) >> 3);
      v81 = v80 + 1;
      if (v80 + 1 > 0x666666666666666)
        abort();
      v82 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v66[-v189] >> 3);
      if (2 * v82 > v81)
        v81 = 2 * v82;
      if (v82 >= 0x333333333333333)
        v83 = 0x666666666666666;
      else
        v83 = v81;
      v79 = v154;
      if (v83)
        v83 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<nghttp2_nv>>(v83);
      else
        v84 = 0;
      v85 = v83 + 40 * v80;
      v86 = v83 + 40 * v84;
      *(_QWORD *)v85 = v60;
      *(_QWORD *)(v85 + 8) = CStringFromCFString;
      *(_QWORD *)(v85 + 16) = 7;
      *(_QWORD *)(v85 + 24) = Length;
      *(_BYTE *)(v85 + 32) = 0;
      v78 = v85 + 40;
      v87 = (char *)*((_QWORD *)&v189 + 1);
      v88 = (char *)v189;
      if (*((_QWORD *)&v189 + 1) != (_QWORD)v189)
      {
        do
        {
          v89 = *(_OWORD *)(v87 - 40);
          v90 = *(_OWORD *)(v87 - 24);
          *(_QWORD *)(v85 - 8) = *((_QWORD *)v87 - 1);
          *(_OWORD *)(v85 - 24) = v90;
          *(_OWORD *)(v85 - 40) = v89;
          v85 -= 40;
          v87 -= 40;
        }
        while (v87 != v88);
        v87 = v88;
      }
      *(_QWORD *)&v189 = v85;
      *((_QWORD *)&v189 + 1) = v78;
      v190 = (char *)v86;
      if (v87)
        operator delete(v87);
    }
    else
    {
      **((_QWORD **)&v189 + 1) = v60;
      *(_QWORD *)(v77 + 8) = CStringFromCFString;
      *(_QWORD *)(v77 + 16) = 7;
      *(_QWORD *)(v77 + 24) = Length;
      v78 = v77 + 40;
      *(_BYTE *)(v77 + 32) = 0;
      v79 = v154;
    }
    *((_QWORD *)&v189 + 1) = v78;
    if (v78 >= (unint64_t)v190)
    {
      v93 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v78 - v189) >> 3);
      if (v93 + 1 > 0x666666666666666)
        abort();
      v94 = 0x999999999999999ALL * ((uint64_t)&v190[-v189] >> 3);
      if (v94 <= v93 + 1)
        v94 = v93 + 1;
      if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v190[-v189] >> 3) >= 0x333333333333333)
        v95 = 0x666666666666666;
      else
        v95 = v94;
      if (v95)
        v95 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<nghttp2_nv>>(v95);
      else
        v96 = 0;
      v97 = v95 + 40 * v93;
      v98 = v95 + 40 * v96;
      *(_QWORD *)v97 = v61;
      *(_QWORD *)(v97 + 8) = v149;
      *(_QWORD *)(v97 + 16) = 7;
      *(_QWORD *)(v97 + 24) = v150;
      *(_BYTE *)(v97 + 32) = 0;
      v91 = v97 + 40;
      v99 = (char *)*((_QWORD *)&v189 + 1);
      v100 = (char *)v189;
      if (*((_QWORD *)&v189 + 1) != (_QWORD)v189)
      {
        do
        {
          v101 = *(_OWORD *)(v99 - 40);
          v102 = *(_OWORD *)(v99 - 24);
          *(_QWORD *)(v97 - 8) = *((_QWORD *)v99 - 1);
          *(_OWORD *)(v97 - 24) = v102;
          *(_OWORD *)(v97 - 40) = v101;
          v97 -= 40;
          v99 -= 40;
        }
        while (v99 != v100);
        v99 = v100;
      }
      *(_QWORD *)&v189 = v97;
      *((_QWORD *)&v189 + 1) = v91;
      v190 = (char *)v98;
      if (v99)
        operator delete(v99);
      v92 = v157;
    }
    else
    {
      *(_QWORD *)v78 = v61;
      *(_QWORD *)(v78 + 8) = v149;
      *(_QWORD *)(v78 + 16) = 7;
      *(_QWORD *)(v78 + 24) = v150;
      v91 = v78 + 40;
      *(_BYTE *)(v78 + 32) = 0;
      v92 = v157;
    }
    *((_QWORD *)&v189 + 1) = v91;
    if (v91 >= (unint64_t)v190)
    {
      v105 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v91 - v189) >> 3);
      if (v105 + 1 > 0x666666666666666)
        abort();
      v106 = 0x999999999999999ALL * ((uint64_t)&v190[-v189] >> 3);
      if (v106 <= v105 + 1)
        v106 = v105 + 1;
      if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v190[-v189] >> 3) >= 0x333333333333333)
        v107 = 0x666666666666666;
      else
        v107 = v106;
      v104 = v155;
      if (v107)
        v107 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<nghttp2_nv>>(v107);
      else
        v108 = 0;
      v109 = v107 + 40 * v105;
      v110 = v107 + 40 * v108;
      *(_QWORD *)v109 = v62;
      *(_QWORD *)(v109 + 8) = v148;
      *(_QWORD *)(v109 + 16) = 5;
      *(_QWORD *)(v109 + 24) = v147;
      *(_BYTE *)(v109 + 32) = 0;
      v103 = v109 + 40;
      v111 = (char *)*((_QWORD *)&v189 + 1);
      v112 = (char *)v189;
      if (*((_QWORD *)&v189 + 1) != (_QWORD)v189)
      {
        do
        {
          v113 = *(_OWORD *)(v111 - 40);
          v114 = *(_OWORD *)(v111 - 24);
          *(_QWORD *)(v109 - 8) = *((_QWORD *)v111 - 1);
          *(_OWORD *)(v109 - 24) = v114;
          *(_OWORD *)(v109 - 40) = v113;
          v109 -= 40;
          v111 -= 40;
        }
        while (v111 != v112);
        v111 = v112;
      }
      *(_QWORD *)&v189 = v109;
      *((_QWORD *)&v189 + 1) = v103;
      v190 = (char *)v110;
      if (v111)
        operator delete(v111);
      v92 = v157;
    }
    else
    {
      *(_QWORD *)v91 = v62;
      *(_QWORD *)(v91 + 8) = v148;
      *(_QWORD *)(v91 + 16) = 5;
      *(_QWORD *)(v91 + 24) = v147;
      v103 = v91 + 40;
      *(_BYTE *)(v91 + 32) = 0;
      v104 = v155;
    }
    *((_QWORD *)&v189 + 1) = v103;
    if (v103 >= (unint64_t)v190)
    {
      v116 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v103 - v189) >> 3);
      if (v116 + 1 > 0x666666666666666)
        abort();
      v117 = 0x999999999999999ALL * ((uint64_t)&v190[-v189] >> 3);
      if (v117 <= v116 + 1)
        v117 = v116 + 1;
      if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v190[-v189] >> 3) >= 0x333333333333333)
        v118 = 0x666666666666666;
      else
        v118 = v117;
      if (v118)
        v118 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<nghttp2_nv>>(v118);
      else
        v119 = 0;
      v120 = v118 + 40 * v116;
      v121 = v118 + 40 * v119;
      *(_QWORD *)v120 = v157;
      *(_QWORD *)(v120 + 8) = v145;
      *(_QWORD *)(v120 + 16) = 10;
      *(_QWORD *)(v120 + 24) = v146;
      *(_BYTE *)(v120 + 32) = 0;
      v115 = v120 + 40;
      v122 = (char *)*((_QWORD *)&v189 + 1);
      v123 = (char *)v189;
      if (*((_QWORD *)&v189 + 1) != (_QWORD)v189)
      {
        do
        {
          v124 = *(_OWORD *)(v122 - 40);
          v125 = *(_OWORD *)(v122 - 24);
          *(_QWORD *)(v120 - 8) = *((_QWORD *)v122 - 1);
          *(_OWORD *)(v120 - 24) = v125;
          *(_OWORD *)(v120 - 40) = v124;
          v120 -= 40;
          v122 -= 40;
        }
        while (v122 != v123);
        v122 = v123;
      }
      *(_QWORD *)&v189 = v120;
      *((_QWORD *)&v189 + 1) = v115;
      v190 = (char *)v121;
      if (v122)
        operator delete(v122);
    }
    else
    {
      *(_QWORD *)v103 = v92;
      *(_QWORD *)(v103 + 8) = v145;
      *(_QWORD *)(v103 + 16) = 10;
      *(_QWORD *)(v103 + 24) = v146;
      v115 = v103 + 40;
      *(_BYTE *)(v103 + 32) = 0;
    }
    *((_QWORD *)&v189 + 1) = v115;
    context = v25;
    v165 = 3221225472;
    v166 = ___ZN11HTTP2Stream17buildHTTP2HeadersEPP10nghttp2_nvPjP7MemPool_block_invoke;
    v167 = &__block_descriptor_48_e25_v24__0____CFString__8_v16l;
    v168 = &v178;
    v169 = &v189;
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)_apply_block, &context);
    v126 = *((_QWORD *)&v189 + 1) - v189;
    v127 = (void *)MemPool::malloc((MemPool *)&v178, *((_QWORD *)&v189 + 1) - v189);
    v128 = v127;
    v129 = (void *)v189;
    if (v127)
    {
      v130 = 0xCCCCCCCCCCCCCCCDLL * (v126 >> 3);
      if (*((_QWORD *)&v189 + 1) != (_QWORD)v189)
      {
        memmove(v127, (const void *)v189, *((_QWORD *)&v189 + 1) - v189);
        v129 = (void *)v189;
      }
    }
    else
    {
      LODWORD(v130) = 0;
    }
    if (v129)
    {
      *((_QWORD *)&v189 + 1) = v129;
      operator delete(v129);
    }
    if (theDict)
      CFRelease(theDict);
    if (cf)
      CFRelease(cf);
    if (v191)
      CFRelease(v191);
    if (v79)
      CFRelease(v79);
    if (v104)
      CFRelease(v104);
    if (v156)
      CFRelease(v156);
    v131 = (_QWORD *)operator new();
    v133 = v160;
    v132 = v161;
    *v131 = v160;
    v131[1] = v132;
    if (v132)
    {
      v134 = (unint64_t *)&v132->__shared_owners_;
      do
        v135 = __ldxr(v134);
      while (__stxr(v135 + 1, v134));
    }
    HTTP2Stream::breakStreamUserDataCycle((uint64_t)v133);
    *((_QWORD *)v133 + 37) = v131;
    v189 = xmmword_1E14F72A0;
    v136 = &v189;
    if (!*((_QWORD *)v133 + 33))
      v136 = 0;
    context = v25;
    v165 = 3321888768;
    v166 = ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke;
    v167 = &unk_1E14F2248;
    v171 = v21;
    v172 = v133;
    v173 = v132;
    if (v132)
    {
      v137 = (unint64_t *)&v132->__shared_owners_;
      do
        v138 = __ldxr(v137);
      while (__stxr(v138 + 1, v137));
    }
    v177 = v130;
    v174 = v128;
    v175 = v136;
    v169 = (__int128 *)&v185;
    v170 = v183;
    v176 = v131;
    v168 = v159;
    ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke((uint64_t)&context);
    if (v132)
    {
      v139 = (unint64_t *)&v132->__shared_owners_;
      do
        v140 = __ldaxr(v139);
      while (__stlxr(v140 - 1, v139));
      if (!v140)
      {
        ((void (*)(std::__shared_weak_count *))v132->__on_zero_shared)(v132);
        std::__shared_weak_count::__release_weak(v132);
      }
    }
    v26 = *((unsigned __int8 *)v186 + 24);
    if (!*((_BYTE *)v186 + 24))
    {
      v141 = v160;
      v193.domain = 4;
      *(_QWORD *)&v193.error = 4294965096;
      HTTP2Stream::setError(v160, v193);
      HTTP2Stream::closeStreamWithErrorCode(v141);
      HTTP2Stream::breakStreamUserDataCycle((uint64_t)v141);
      v26 = 1;
      *((_BYTE *)v186 + 24) = 1;
    }
    v142 = v179;
    v143 = v180;
    if (v179 != v180)
    {
      do
      {
        v144 = *v142;
        v142 += 2;
        free(v144);
      }
      while (v142 != v143);
      v142 = v179;
    }
    if (v142)
    {
      v180 = v142;
      operator delete(v142);
    }
    _Block_object_dispose(v183, 8);
    _Block_object_dispose(&v185, 8);
  }
LABEL_29:
  v27 = v161;
  if (!v161)
    goto LABEL_33;
  v28 = (unint64_t *)&v161->__shared_owners_;
  do
    v29 = __ldaxr(v28);
  while (__stlxr(v29 - 1, v28));
  if (!v29)
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
    if (!(_DWORD)v26)
      goto LABEL_51;
  }
  else
  {
LABEL_33:
    if (!(_DWORD)v26)
      goto LABEL_51;
  }
  if (*(_QWORD *)v20)
  {
    v30 = *(_QWORD *)(*(_QWORD *)v20 + 56);
    if (v30)
    {
      if (*(_DWORD *)v30 == 1)
      {
        v31 = *(_QWORD *)(v30 + 8);
        v32 = *(std::__shared_weak_count **)(v30 + 16);
        context = v31;
        v165 = (uint64_t)v32;
        if (v32)
        {
          v33 = (unint64_t *)&v32->__shared_owners_;
          do
            v34 = __ldxr(v33);
          while (__stxr(v34 + 1, v33));
        }
        v35 = *(_QWORD *)(a1 + 16);
        if (v35)
          v36 = v31 == 0;
        else
          v36 = 1;
        if (!v36)
        {
          (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD))(*(_QWORD *)v31 + 280))(v31, *(_QWORD *)(v35 - 96), 7, *(_QWORD *)(a1 + 304));
          *(_BYTE *)(a1 + 232) = 1;
        }
        if (v32)
        {
          v37 = (unint64_t *)&v32->__shared_owners_;
          do
            v38 = __ldaxr(v37);
          while (__stlxr(v38 - 1, v37));
          if (!v38)
          {
            ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
            std::__shared_weak_count::__release_weak(v32);
          }
        }
      }
    }
  }
LABEL_51:
  (*(void (**)(uint64_t, uint64_t))(a4 + 16))(a4, v26);
  v39 = v163;
  if (v163)
  {
    v40 = (unint64_t *)&v163->__shared_owners_;
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      v15 = v39;
      goto LABEL_56;
    }
  }
  return 1;
}

void sub_183F22794(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, CFTypeRef a18, CFTypeRef a19, CFTypeRef a20,CFTypeRef a21,uint64_t a22,CFTypeRef cf,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,char a31,uint64_t a32,char a33)
{
  uint64_t v33;

  MemPool::~MemPool((MemPool *)(v33 - 256));
  _Block_object_dispose((const void *)(v33 - 208), 8);
  _Block_object_dispose((const void *)(v33 - 176), 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a29);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a31);
  _Unwind_Resume(a1);
}

void ___ZN11HTTP2Stream17buildHTTP2HeadersEPP10nghttp2_nvPjP7MemPool_block_invoke(uint64_t a1, HTTPUtilities *this, const __CFString *a3)
{
  UInt8 *CStringFromCFString;
  UInt8 *v7;
  void **v8;
  size_t v9;
  size_t v10;
  size_t v11;
  UInt8 **v12;
  UInt8 **v13;
  void *v14;
  UInt8 *i;
  void **v16;
  size_t v17;
  size_t v18;
  int64_t v19;
  char *v20;
  char *v21;
  void *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  char *v30;
  char *v31;
  __int128 v32;
  __int128 v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  char *v42;
  __int128 v43;
  __int128 v44;

  if (!HTTPUtilities::isHeaderAllowed(this, (const __CFString *)this))
    return;
  CStringFromCFString = http2CreateCStringFromCFString((const __CFString *)this, *(MemPool **)(a1 + 32));
  v7 = http2CreateCStringFromCFString(a3, *(MemPool **)(a1 + 32));
  if (strcasecmp((const char *)CStringFromCFString, "cookie"))
  {
    v8 = *(void ***)(a1 + 40);
    v9 = strlen((const char *)CStringFromCFString);
    v10 = strlen((const char *)v7);
    v11 = v10;
    v12 = (UInt8 **)v8[1];
    v13 = (UInt8 **)v8[2];
    if (v12 < v13)
    {
      *v12 = CStringFromCFString;
      v12[1] = v7;
      v12[2] = (UInt8 *)v9;
      v12[3] = (UInt8 *)v10;
      v14 = v12 + 5;
      *((_BYTE *)v12 + 32) = 0;
LABEL_43:
      v8[1] = v14;
      return;
    }
    v34 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v12 - (_BYTE *)*v8) >> 3);
    v35 = v34 + 1;
    if (v34 + 1 <= 0x666666666666666)
    {
      v36 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v13 - (_BYTE *)*v8) >> 3);
      if (2 * v36 > v35)
        v35 = 2 * v36;
      if (v36 >= 0x333333333333333)
        v37 = 0x666666666666666;
      else
        v37 = v35;
      if (v37)
        v37 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<nghttp2_nv>>(v37);
      else
        v38 = 0;
      v39 = v37 + 40 * v34;
      v40 = v37 + 40 * v38;
      *(_QWORD *)v39 = CStringFromCFString;
      *(_QWORD *)(v39 + 8) = v7;
      *(_QWORD *)(v39 + 16) = v9;
      *(_QWORD *)(v39 + 24) = v11;
      *(_BYTE *)(v39 + 32) = 0;
      v14 = (void *)(v39 + 40);
      v42 = (char *)*v8;
      v41 = (char *)v8[1];
      if (v41 != *v8)
      {
        do
        {
          v43 = *(_OWORD *)(v41 - 40);
          v44 = *(_OWORD *)(v41 - 24);
          *(_QWORD *)(v39 - 8) = *((_QWORD *)v41 - 1);
          *(_OWORD *)(v39 - 24) = v44;
          *(_OWORD *)(v39 - 40) = v43;
          v39 -= 40;
          v41 -= 40;
        }
        while (v41 != v42);
        v41 = (char *)*v8;
      }
      *v8 = (void *)v39;
      v8[1] = v14;
      v8[2] = (void *)v40;
      if (v41)
        operator delete(v41);
      goto LABEL_43;
    }
LABEL_45:
    abort();
  }
  while (2)
  {
    for (i = v7; *i != 59; ++i)
    {
      if (!*i)
        goto LABEL_11;
LABEL_10:
      ;
    }
    if (i[1] != 32)
      goto LABEL_10;
LABEL_11:
    v16 = *(void ***)(a1 + 40);
    v17 = strlen((const char *)CStringFromCFString);
    v18 = v17;
    v19 = i - v7;
    v20 = (char *)v16[1];
    v21 = (char *)v16[2];
    if (v20 >= v21)
    {
      v23 = 0xCCCCCCCCCCCCCCCDLL * ((v20 - (_BYTE *)*v16) >> 3);
      v24 = v23 + 1;
      if (v23 + 1 <= 0x666666666666666)
      {
        v25 = 0xCCCCCCCCCCCCCCCDLL * ((v21 - (_BYTE *)*v16) >> 3);
        if (2 * v25 > v24)
          v24 = 2 * v25;
        if (v25 >= 0x333333333333333)
          v26 = 0x666666666666666;
        else
          v26 = v24;
        if (v26)
          v26 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<nghttp2_nv>>(v26);
        else
          v27 = 0;
        v28 = v26 + 40 * v23;
        *(_QWORD *)v28 = CStringFromCFString;
        *(_QWORD *)(v28 + 8) = v7;
        *(_QWORD *)(v28 + 16) = v18;
        *(_QWORD *)(v28 + 24) = v19;
        *(_BYTE *)(v28 + 32) = 0;
        v30 = (char *)*v16;
        v29 = (char *)v16[1];
        v31 = (char *)v28;
        if (v29 != *v16)
        {
          do
          {
            v32 = *(_OWORD *)(v29 - 40);
            v33 = *(_OWORD *)(v29 - 24);
            *((_QWORD *)v31 - 1) = *((_QWORD *)v29 - 1);
            *(_OWORD *)(v31 - 24) = v33;
            *(_OWORD *)(v31 - 40) = v32;
            v31 -= 40;
            v29 -= 40;
          }
          while (v29 != v30);
          v29 = (char *)*v16;
        }
        v22 = (void *)(v28 + 40);
        *v16 = v31;
        v16[1] = (void *)(v28 + 40);
        v16[2] = (void *)(v26 + 40 * v27);
        if (v29)
          operator delete(v29);
        goto LABEL_27;
      }
      goto LABEL_45;
    }
    *(_QWORD *)v20 = CStringFromCFString;
    *((_QWORD *)v20 + 1) = v7;
    *((_QWORD *)v20 + 2) = v17;
    *((_QWORD *)v20 + 3) = v19;
    v22 = v20 + 40;
    v20[32] = 0;
LABEL_27:
    v16[1] = v22;
    if (*i)
    {
      v7 = i + 2;
      continue;
    }
    break;
  }
}

UInt8 *http2CreateCStringFromCFString(const __CFString *a1, MemPool *a2)
{
  CFIndex Length;
  CFIndex v5;
  UInt8 *v6;
  UInt8 *v7;
  CFIndex v8;
  CFIndex usedBufLen;
  CFRange v11;

  Length = CFStringGetLength(a1);
  v5 = Length;
  usedBufLen = 0;
  if (a2)
    v6 = (UInt8 *)MemPool::malloc(a2, Length + 1);
  else
    v6 = (UInt8 *)malloc_type_malloc(Length + 1, 0x100004077774924uLL);
  v7 = v6;
  if (v6)
  {
    v11.location = 0;
    v11.length = v5;
    CFStringGetBytes(a1, v11, 0x201u, 0, 0, v6, v5, &usedBufLen);
    v8 = usedBufLen;
    if (usedBufLen >= v5)
      v8 = v5;
    v7[v8] = 0;
  }
  return v7;
}

uint64_t MemPool::malloc(MemPool *this, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  size_t v6;
  void *v7;
  void *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  uint64_t v21;
  uint64_t result;
  unint64_t v23;
  size_t v24;
  void *v25;
  void *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  char *v38;
  char *v39;

  v3 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
  *((_QWORD *)this + 4) = v3;
  v4 = *((_QWORD *)this + 2);
  if (*((_QWORD *)this + 1) == v4)
  {
    if (v3 <= *(_QWORD *)this)
      v6 = *(_QWORD *)this;
    else
      v6 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    v7 = malloc_type_malloc(v6, 0xA489C531uLL);
    v8 = v7;
    v10 = *((_QWORD *)this + 2);
    v9 = *((_QWORD *)this + 3);
    if (v10 >= v9)
    {
      v11 = *((_QWORD *)this + 1);
      v12 = (uint64_t)(v10 - v11) >> 4;
      v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 60)
        goto LABEL_51;
      v14 = v9 - v11;
      if (v14 >> 3 > v13)
        v13 = v14 >> 3;
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
        v15 = 0xFFFFFFFFFFFFFFFLL;
      else
        v15 = v13;
      if (v15)
        v15 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<HTTP3Stream>>>(v15);
      else
        v16 = 0;
      v17 = v15 + 16 * v12;
      v18 = v15 + 16 * v16;
      *(_QWORD *)v17 = v8;
      *(_DWORD *)(v17 + 8) = v6;
      v4 = v17 + 16;
      v20 = (char *)*((_QWORD *)this + 1);
      v19 = (char *)*((_QWORD *)this + 2);
      if (v19 != v20)
      {
        do
        {
          *(_OWORD *)(v17 - 16) = *((_OWORD *)v19 - 1);
          v17 -= 16;
          v19 -= 16;
        }
        while (v19 != v20);
        v19 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v17;
      *((_QWORD *)this + 2) = v4;
      *((_QWORD *)this + 3) = v18;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *(_QWORD *)v10 = v7;
      *(_DWORD *)(v10 + 8) = v6;
      v4 = v10 + 16;
    }
    *((_QWORD *)this + 2) = v4;
    v5 = *((_QWORD *)this + 4);
  }
  else
  {
    v5 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
  }
  v21 = *((_QWORD *)this + 5);
  if (v21)
    result = *((_QWORD *)this + 5);
  else
    result = *(_QWORD *)(v4 - 16);
  if (v21)
    v23 = *(_QWORD *)(v4 - 16) + *(int *)(v4 - 8) - v21;
  else
    v23 = *(int *)(v4 - 8);
  if (v3 > v23)
  {
    *((_QWORD *)this + 5) = 0;
    if (v5 <= *(_QWORD *)this)
      v24 = *(_QWORD *)this;
    else
      v24 = v5;
    v25 = malloc_type_malloc(v24, 0xA489C531uLL);
    v26 = v25;
    v28 = *((_QWORD *)this + 2);
    v27 = *((_QWORD *)this + 3);
    if (v28 < v27)
    {
      *(_QWORD *)v28 = v25;
      *(_DWORD *)(v28 + 8) = v24;
      v29 = v28 + 16;
LABEL_49:
      *((_QWORD *)this + 2) = v29;
      result = *(_QWORD *)(v29 - 16);
      v5 = *((_QWORD *)this + 4);
      goto LABEL_50;
    }
    v30 = *((_QWORD *)this + 1);
    v31 = (uint64_t)(v28 - v30) >> 4;
    v32 = v31 + 1;
    if (!((unint64_t)(v31 + 1) >> 60))
    {
      v33 = v27 - v30;
      if (v33 >> 3 > v32)
        v32 = v33 >> 3;
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF0)
        v34 = 0xFFFFFFFFFFFFFFFLL;
      else
        v34 = v32;
      if (v34)
        v34 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<HTTP3Stream>>>(v34);
      else
        v35 = 0;
      v36 = v34 + 16 * v31;
      v37 = v34 + 16 * v35;
      *(_QWORD *)v36 = v26;
      *(_DWORD *)(v36 + 8) = v24;
      v29 = v36 + 16;
      v39 = (char *)*((_QWORD *)this + 1);
      v38 = (char *)*((_QWORD *)this + 2);
      if (v38 != v39)
      {
        do
        {
          *(_OWORD *)(v36 - 16) = *((_OWORD *)v38 - 1);
          v36 -= 16;
          v38 -= 16;
        }
        while (v38 != v39);
        v38 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v36;
      *((_QWORD *)this + 2) = v29;
      *((_QWORD *)this + 3) = v37;
      if (v38)
        operator delete(v38);
      goto LABEL_49;
    }
LABEL_51:
    abort();
  }
LABEL_50:
  *((_QWORD *)this + 5) = result + v5;
  return result;
}

uint64_t HTTPUtilities::isHeaderAllowed(HTTPUtilities *this, const __CFString *a2)
{
  if (HTTPUtilities::isHeaderAllowed(__CFString const*)::onceToken != -1)
    dispatch_once(&HTTPUtilities::isHeaderAllowed(__CFString const*)::onceToken, &__block_literal_global_10766);
  return objc_msgSend((id)HTTPUtilities::isHeaderAllowed(__CFString const*)::disallowed, "containsObject:", this) ^ 1;
}

CFTypeRef HTTPMessage::setVersion(uint64_t a1, unsigned int a2)
{
  const void *v4;
  CFTypeRef result;

  v4 = *(const void **)(a1 + 40);
  *(_QWORD *)(a1 + 40) = 0;
  if (v4)
    CFRelease(v4);
  result = CFRetain(&gConstantCFStringValueTable[7 * ((a2 >> 20) & 0x3FF)]);
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void HTTPTransaction::_onqueue_prepareRequest(HTTPTransaction *this, int a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  id *v9;
  uint64_t v10;
  int v11;
  double v12;
  const __CFArray *v13;
  void *v14;

  v6 = *((_QWORD *)this + 24);
  if (v6)
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 56))(v6);
  else
    v7 = 0;
  v8 = *((_QWORD *)this + 26);
  if (v8)
    v9 = (id *)(v8 - 176);
  else
    v9 = 0;
  cleanUpRequest((__CFHTTPMessage *)(*((_QWORD *)this + 20) - 16), v7, a2, a3, v9);
  v10 = *((_QWORD *)this + 26);
  if (v10)
  {
    v11 = objc_msgSend(*(id *)(v10 - 96), "_cachePolicy");
    objc_msgSend(*(id *)(v10 - 96), "_timeoutInterval");
    v13 = (const __CFArray *)v11;
  }
  else
  {
    v13 = 0;
    v12 = 0.0;
  }
  v14 = (void *)_constructRequestFromParts((const __CFAllocator *)(*((_QWORD *)this + 20) - 16), 0, v13, NSURLRequestUseProtocolCachePolicy, v12, 0);
  -[__CFN_TransactionMetrics setTransferredRequest:](*((_QWORD *)this + 34), v14);
  if (v14)
    CFRelease(v14);
}

uint64_t _constructRequestFromParts(const __CFAllocator *a1, __CFHTTPMessage *a2, const __CFArray *a3, NSURLRequestCachePolicy a4, double a5, const __CFURL *a6)
{
  int v6;
  id v7;
  __objc2_class **v8;
  uint64_t v9;

  v6 = (int)a6;
  v7 = -[NSURLRequestInternal _initWithMessage:bodyParts:cachePolicy:timeout:mainDocumentURL:mutable:]([NSURLRequestInternal alloc], "_initWithMessage:bodyParts:cachePolicy:timeout:mainDocumentURL:mutable:", a1, a2, a3, a4, a6, a5);
  v8 = off_1E14E1730;
  if (v6)
    v8 = off_1E14E1648;
  v9 = objc_msgSend(objc_alloc(*v8), "_initWithInternal:", v7);

  return v9;
}

void sub_183F23378(_Unwind_Exception *a1)
{
  HTTPRequestMessage *v1;

  HTTPRequestMessage::~HTTPRequestMessage(v1);
  _Unwind_Resume(a1);
}

void cleanUpRequest(__CFHTTPMessage *this, uint64_t a2, int a3, int a4, id *a5)
{
  __CFHTTPMessage *v9;
  void *v10;
  void *v11;
  const __CFString *v12;
  const __CFString *v13;
  unsigned int v14;
  HTTPMessage *v15;
  unsigned int v16;
  const __CFURL *v17;
  const void *v18;
  const void *v19;
  uint8_t v20[16];
  uint8_t buf[16];

  v9 = this;
  if (this)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*((_BYTE *)v9 + 40))
      v9 = 0;
    else
      v9 = (__CFHTTPMessage *)((char *)v9 + 16);
  }
  if (!HTTPMessage::hasHeaderField((os_unfair_lock_s *)v9, 0x14C15415u)
    && (!a5
     || (v10 = (void *)objc_msgSend(a5[10], "_effectiveConfiguration")) == 0
     || (v11 = (void *)objc_msgSend(v10, "_suppressedAutoAddedHTTPHeaders")) == 0
     || (objc_msgSend(v11, "containsObject:", 0x1EDCFD8C8) & 1) == 0))
  {
    pthread_once(&initControl, initializeUserAgentString);
    HTTPMessage::setHeaderFieldStringValue(v9, 0x14C15415u, (const void *)sUserAgentString);
  }
  if ((a2 & 0x8000000000000000) == 0)
  {
    v12 = (const __CFString *)*((_QWORD *)v9 + 19);
    if (!v12)
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        goto LABEL_39;
      *(_WORD *)v20 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", v20, 2u);
      v12 = (const __CFString *)*((_QWORD *)v9 + 19);
      if (!v12)
        goto LABEL_39;
    }
    if (CFStringCompare(v12, (CFStringRef)&gConstantCFStringValueTable[2590], 0) == kCFCompareEqualTo)
      goto LABEL_22;
    v13 = (const __CFString *)*((_QWORD *)v9 + 19);
    if (!v13)
    {
LABEL_39:
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        goto LABEL_21;
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u);
      v13 = (const __CFString *)*((_QWORD *)v9 + 19);
      if (!v13)
        goto LABEL_21;
    }
    if (CFStringCompare(v13, (CFStringRef)&gConstantCFStringValueTable[2597], 0))
LABEL_21:
      HTTPMessage::setHeaderFieldScalarValue(v9, a2);
  }
LABEL_22:
  if (a3)
  {
    if (HTTPMessage::hasHeaderField((os_unfair_lock_s *)v9, 0x119152ADu))
      goto LABEL_28;
    v14 = 370234505;
    v15 = v9;
    v16 = 370234505;
  }
  else
  {
    v14 = 363902060;
    v15 = v9;
    v16 = 363902060;
  }
  HTTPMessage::setHeaderFieldStringValue(v15, 0x119152ADu, v16);
  if (a4)
    HTTPMessage::setHeaderFieldStringValue(v9, 0x13721369u, v14);
LABEL_28:
  if (!HTTPMessage::hasHeaderField((os_unfair_lock_s *)v9, 0x12709302u))
  {
    v17 = (const __CFURL *)HTTPRequestParserClient::requestURL((__CFHTTPMessage *)((char *)v9 + 128));
    if (v17)
    {
      HTTPUtilities::createAuthorityStringFromURL((HTTPUtilities *)&v19, v17);
      v18 = v19;
      if (v19)
      {
        HTTPMessage::setHeaderFieldStringValue(v9, 0x12709302u, v19);
        CFRelease(v18);
      }
    }
  }
}

void sub_183F23630(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void HTTPUtilities::createAuthorityStringFromURL(HTTPUtilities *this, CFURLRef url)
{
  CFRange v4;
  int64_t v6;
  CFIndex v7;
  UInt8 *v8;
  CFRange v9;
  CFIndex length;
  CFStringRef v11;
  const __CFString *v12;
  uint64_t v13;
  const __CFAllocator *v14;
  CFStringRef v15;
  CFStringRef v16;
  const __CFString *v17;
  CFRange v18;
  CFRange v19;
  const __CFAllocator *v20;
  __CFString *MutableCopy;
  const __CFString *v22;
  const void *v23;
  UInt8 buffer[512];
  uint64_t v25;
  CFRange v26;

  v25 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = 0;
  v4 = CFURLGetByteRangeForComponent(url, kCFURLComponentHost, 0);
  if (v4.location == -1 || v4.length < 1)
    goto LABEL_18;
  v6 = CFURLGetBytes(url, 0, 0);
  v7 = v6;
  if (v6 < 1)
    goto LABEL_18;
  if ((unint64_t)v6 >= 0x201)
  {
    v8 = (UInt8 *)malloc_type_malloc(v6, 0x32BC5F4FuLL);
    if (!v8)
      goto LABEL_18;
  }
  else
  {
    v8 = buffer;
  }
  if (CFURLGetBytes(url, v8, v7) < 1)
  {
    v11 = 0;
  }
  else
  {
    v9 = CFURLGetByteRangeForComponent(url, kCFURLComponentPort, 0);
    if (v9.location == -1)
      length = v4.length;
    else
      length = v9.length - v4.location + v9.location;
    v11 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &v8[v4.location], length, 0x201u, 0);
  }
  if (v8 != buffer)
    free(v8);
  if (v11)
    goto LABEL_32;
LABEL_18:
  v12 = CFURLCopyHostName(url);
  if (v12)
  {
    v13 = CFURLGetPortNumber(url);
    v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v15 = CFURLCreateStringByAddingPercentEscapes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v12, 0, 0, 0x8000100u);
    if (v15 || (v15 = CFURLCreateStringByAddingPercentEscapes(v14, v12, 0, 0, 0x201u)) != 0)
    {
      if (_isIPAddress(v12, 0))
        v16 = (_DWORD)v13 == -1
            ? CFStringCreateWithFormat(v14, 0, CFSTR("[%@]"), v15)
            : CFStringCreateWithFormat(v14, 0, CFSTR("[%@]:%d"), v15, v13);
      else
        v16 = (_DWORD)v13 == -1
            ? (CFStringRef)CFRetain(v15)
            : CFStringCreateWithFormat(v14, 0, CFSTR("%@:%d"), v15, v13);
      v11 = v16;
      CFRelease(v15);
    }
    else
    {
      v11 = 0;
    }
    CFRelease(v12);
    if (v11)
    {
LABEL_32:
      if (CFStringGetLength(v11) < 1
        || CFStringGetCharacterAtIndex(v11, 0) != 91
        || (v18 = CFStringFind(v11, CFSTR("%25"), 0), v17 = (const __CFString *)v18.length, v18.location == -1)
        || (v19 = CFStringFind(v11, CFSTR("]"), 0), v17 = (const __CFString *)v19.length, v19.location == -1)
        || v19.location <= v18.location
        || (v20 = CFGetAllocator(v11), MutableCopy = CFStringCreateMutableCopy(v20, 0, v11),
                                       (v22 = MutableCopy) == 0))
      {
        v22 = v11;
      }
      else
      {
        v26.location = v18.location;
        v26.length = v19.location - v18.location;
        CFStringDelete(MutableCopy, v26);
        CFRelease(v11);
      }
      if (HTTPHeaderValue::isValid(v22, v17))
      {
        v23 = *(const void **)this;
        *(_QWORD *)this = v22;
        if (v23)
          CFRelease(v23);
      }
      else
      {
        CFRelease(v22);
      }
    }
  }
}

void sub_183F23954(_Unwind_Exception *exception_object)
{
  const void **v1;
  const void *v3;

  v3 = *v1;
  *v1 = 0;
  if (v3)
    CFRelease(v3);
  _Unwind_Resume(exception_object);
}

void HTTPMessage::setHeaderFieldStringValue(HTTPMessage *a1, unsigned int a2, unsigned int a3)
{
  HTTPHeaderDict *v5;
  CFTypeRef v6;
  _QWORD v7[2];
  void (**v8)(StringSerializable *__hidden);
  CFTypeRef cf;

  v5 = HTTPMessage::mutableHeaders(a1);
  HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(&v8, a2);
  v7[0] = &off_1E14ED488;
  v6 = CFRetain(&gConstantCFStringValueTable[7 * ((a3 >> 20) & 0x3FF)]);
  v7[1] = v6;
  HTTPHeaderDict::setValue((uint64_t)v5, (uint64_t)&v8, (uint64_t)v7);
  if (v6)
    CFRelease(v6);
  v8 = &off_1E14E9A00;
  if (cf)
    CFRelease(cf);
}

void sub_183F23A38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf)
{
  const void *v12;

  if (v12)
    CFRelease(v12);
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t RequestBodyStream::getExpectedLength(RequestBodyStream *this)
{
  return -1;
}

uint64_t HTTP2Stream::setTransactionMetrics(uint64_t this, __CFN_TransactionMetrics *a2)
{
  *(_QWORD *)(this + 304) = a2;
  return this;
}

void HTTP2Stream::setPriorityHint(HTTP2Stream *this, float a2)
{
  std::__shared_weak_count *v2;
  uint64_t v4;
  unint64_t *p_shared_weak_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  float v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  std::__shared_weak_count *v26;
  _QWORD block[6];
  std::__shared_weak_count *v28;
  uint64_t v29;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 36);
  if (v2)
  {
    v4 = *((_QWORD *)this + 35);
    p_shared_weak_owners = (unint64_t *)&v2->__shared_weak_owners_;
    do
      v6 = __ldxr(p_shared_weak_owners);
    while (__stxr(v6 + 1, p_shared_weak_owners));
    v7 = std::__shared_weak_count::lock(v2);
    if (!v7)
      goto LABEL_39;
    v8 = v7;
    if (!v4 || a2 < 0.0 || a2 > 1.0)
      goto LABEL_35;
    if (a2 < 0.0 || a2 > 0.75)
    {
      v9 = 16;
      if (a2 > 0.75 && a2 <= 1.0)
      {
        v10 = (a2 + -0.75) * 231.0 * 4.0;
        v9 = (uint64_t)(float)(floorf(v10) + 24.0);
      }
    }
    else
    {
      v9 = vcvtms_s32_f32(a2 * 32.0);
    }
    if (v9 == *(unsigned __int8 *)(v4 + 233) || (*(_BYTE *)(v4 + 233) = v9, *(int *)(v4 + 80) < 1))
    {
LABEL_35:
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v25 = __ldaxr(p_shared_owners);
      while (__stlxr(v25 - 1, p_shared_owners));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
LABEL_39:
      std::__shared_weak_count::__release_weak(v2);
      return;
    }
    v11 = *(_QWORD *)(v4 + 64);
    v26 = 0;
    v12 = *(std::__shared_weak_count **)(v4 + 288);
    if (v12)
    {
      v13 = std::__shared_weak_count::lock(v12);
      v26 = v13;
      if (v13)
      {
        v14 = *(_QWORD *)(v4 + 280);
LABEL_22:
        v15 = *(unsigned __int8 *)(v4 + 233);
        CFRetain((CFTypeRef)(v11 - 16));
        v16 = *(NSObject **)(v11 + 168);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3321888768;
        block[2] = ___ZN15HTTP2Connection20changeStreamPriorityENSt3__110shared_ptrI11HTTP2StreamEEl_block_invoke;
        block[3] = &__block_descriptor_64_e8_40c40_ZTSKNSt3__110shared_ptrI11HTTP2StreamEE_e5_v8__0l;
        block[4] = v11;
        block[5] = v14;
        v28 = v13;
        if (v13)
        {
          v17 = (unint64_t *)&v13->__shared_owners_;
          do
            v18 = __ldxr(v17);
          while (__stxr(v18 + 1, v17));
        }
        v29 = v15;
        dispatch_async(v16, block);
        v19 = v28;
        if (v28)
        {
          v20 = (unint64_t *)&v28->__shared_owners_;
          do
            v21 = __ldaxr(v20);
          while (__stlxr(v21 - 1, v20));
          if (!v21)
          {
            ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
            std::__shared_weak_count::__release_weak(v19);
          }
        }
        if (v26)
        {
          v22 = (unint64_t *)&v26->__shared_owners_;
          do
            v23 = __ldaxr(v22);
          while (__stlxr(v23 - 1, v22));
          if (!v23)
          {
            ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
            std::__shared_weak_count::__release_weak(v26);
          }
        }
        goto LABEL_35;
      }
    }
    else
    {
      v13 = 0;
    }
    v14 = 0;
    goto LABEL_22;
  }
}

void sub_183F23D08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::__shared_weak_count *v11;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::__shared_weak_count::__release_weak(v11);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<NSObject  {objcproto17OS_dispatch_queue}*,Deleter_DispatchRelease<NSObject  {objcproto17OS_dispatch_queue}*>,std::allocator<NSObject  {objcproto17OS_dispatch_queue}>>::__on_zero_shared(uint64_t a1)
{
  NSObject *v1;

  v1 = *(NSObject **)(a1 + 24);
  if (v1)
    dispatch_release(v1);
}

void std::__shared_ptr_pointer<NSObject  {objcproto16OS_nw_connection}*,Deleter_NWRelease<NSObject  {objcproto16OS_nw_connection}*>,std::allocator<NSObject  {objcproto16OS_nw_connection}>>::__on_zero_shared(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 24);
  if (v1)
    nw_release(v1);
}

uint64_t std::__shared_ptr_emplace<NWIOConnection>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *HTTPConnectionCache::enqueueRequestForProtocol(__CFDictionary *a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __CFDictionary *v6;
  uint64_t v7;
  const void *v8;
  _QWORD *Value;
  _QWORD *v10;
  const HTTPConnectionCacheKey *v11;
  _QWORD *result;
  uint64_t v13;
  const void *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  __int128 v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  _OWORD *v31;
  unint64_t v32;
  _QWORD *v33;
  unint64_t v34;
  _OWORD *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  char *v41;
  std::__shared_weak_count *v42;
  char *v43;
  unint64_t *v44;
  unint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  char *v48;
  __int128 v49;
  uint64_t v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  __int128 v56;
  __int128 v57;
  unint64_t *v58;
  unint64_t v59;
  int v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  unint64_t *v64;
  unint64_t v65;
  const __CFArray *v66;
  uint64_t v67;
  uint64_t *v68;
  __CFDictionary *v69;
  std::__shared_weak_count *v70;
  uint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  std::__shared_weak_count *v77;
  unint64_t *v78;
  unint64_t v79;
  std::__shared_weak_count *v80;
  std::__shared_weak_count *v81;
  _QWORD *v82;
  __int128 v83;
  uint64_t v84;
  std::__shared_weak_count *v85;
  unint64_t *v86;
  unint64_t v87;
  __int128 v88;
  unint64_t *v89;
  unint64_t v90;
  unint64_t *v91;
  unint64_t v92;
  unint64_t *v93;
  unint64_t v94;
  unint64_t *v95;
  unint64_t v96;
  NSObject *v97;
  std::__shared_weak_count *v98;
  unint64_t *v99;
  unint64_t v100;
  unint64_t *v101;
  unint64_t v102;
  unint64_t *v103;
  unint64_t v104;
  std::__shared_weak_count *v105;
  unint64_t *v106;
  unint64_t v107;
  unint64_t *v108;
  unint64_t v109;
  __CFDictionary *v110;
  __int128 v111;
  _QWORD *v112;
  __int128 v113;
  __int128 v114;
  uint64_t v115;
  uint64_t v116;
  std::__shared_weak_count *v117;
  __int128 context;
  _QWORD *(*v119)(_QWORD *, uint64_t);
  void *v120;
  uint64_t *v121;
  uint64_t *v122;
  uint64_t *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t *v130;
  uint64_t v131;
  BOOL v132;
  uint64_t v133;
  uint64_t *v134;
  uint64_t v135;
  char v136;
  __int128 v137;
  int v138;
  __int128 v139;
  uint64_t v140;
  __int128 v141;
  uint8_t buf[4];
  uint64_t v143;
  uint64_t v144;
  CFRange v145;

  v6 = a1;
  v144 = *MEMORY[0x1E0C80C00];
  v114 = *a4;
  v115 = *((_QWORD *)a4 + 2);
  HTTPConnectionCache::ensureEntries(a1);
  v7 = *((_QWORD *)v6 + 5);
  v8 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v7 + 32), v8);
  if (Value)
  {
    v10 = Value;
    (*(void (**)(_QWORD *))(*Value + 40))(Value);
  }
  else
  {
    v11 = (const HTTPConnectionCacheKey *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
    result = HTTPConnectionCache::createEmptyCacheEntry((CFSetRef *)v6, v11);
    if (!result)
      return result;
    v10 = result;
    v13 = *((_QWORD *)v6 + 5);
    v14 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v13 + 32), v14, v10);
  }
  v15 = v10[3];
  v16 = (std::__shared_weak_count *)v10[4];
  v112 = v10;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v18 = __ldxr(p_shared_owners);
    while (__stxr(v18 + 1, p_shared_owners));
  }
  v139 = v114;
  v140 = v115;
  HTTPConnectionCacheEntry::_prepareNewRequest((HTTPConnectionCacheEntry::EnqueuedRequest **)&v141, v15, a2, a3, (uint64_t)&v139);
  v19 = *(unsigned int *)(v141 + 48);
  v113 = 0u;
  if ((v19 & 0x80000000) == 0)
  {
    v20 = *(_QWORD *)(v15 + 104);
    v21 = *(_QWORD *)(v20 + 8);
    if (v19 <= (*(_QWORD *)(v20 + 16) - v21) >> 4)
    {
      v22 = *(_OWORD *)(v21 + 16 * v19);
      v113 = v22;
      v23 = *(std::__shared_weak_count **)(v21 + 16 * v19 + 8);
      if (*((_QWORD *)&v22 + 1))
      {
        v24 = (unint64_t *)(*((_QWORD *)&v22 + 1) + 8);
        do
          v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
      }
      if (!(_QWORD)v22)
      {
        v81 = v16;
        v82 = operator new(0x40uLL);
        v82[1] = 0;
        v82[2] = 0;
        v82[3] = &off_1E14F0100;
        *v82 = &off_1E14F0F68;
        *((_DWORD *)v82 + 8) = v19;
        v82[6] = 0;
        v82[7] = 0;
        v82[5] = 0;
        *(_QWORD *)&v83 = v82 + 3;
        *((_QWORD *)&v83 + 1) = v82;
        v84 = *(_QWORD *)(v20 + 8) + 16 * v19;
        v85 = *(std::__shared_weak_count **)(v84 + 8);
        *(_OWORD *)v84 = v83;
        if (v85)
        {
          v86 = (unint64_t *)&v85->__shared_owners_;
          do
            v87 = __ldaxr(v86);
          while (__stlxr(v87 - 1, v86));
          if (!v87)
          {
            ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
            std::__shared_weak_count::__release_weak(v85);
          }
        }
        v88 = *(_OWORD *)(*(_QWORD *)(v20 + 8) + 16 * v19);
        v113 = v88;
        if (*((_QWORD *)&v88 + 1))
        {
          v89 = (unint64_t *)(*((_QWORD *)&v88 + 1) + 8);
          do
            v90 = __ldxr(v89);
          while (__stxr(v90 + 1, v89));
        }
        v16 = v81;
        if (v23)
        {
          v91 = (unint64_t *)&v23->__shared_owners_;
          do
            v92 = __ldaxr(v91);
          while (__stlxr(v92 - 1, v91));
          if (!v92)
          {
            ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
            std::__shared_weak_count::__release_weak(v23);
          }
        }
      }
    }
  }
  v26 = v15;
  v27 = v141;
  v28 = (std::__shared_weak_count *)*((_QWORD *)&v141 + 1);
  if (*((_QWORD *)&v141 + 1))
  {
    v29 = (unint64_t *)(*((_QWORD *)&v141 + 1) + 8);
    do
      v30 = __ldxr(v29);
    while (__stxr(v30 + 1, v29));
    v31 = *(_OWORD **)(v113 + 24);
    v32 = *(_QWORD *)(v113 + 32);
    v33 = (_QWORD *)(v113 + 24);
    if ((unint64_t)v31 < v32)
    {
      *v31 = v27;
      do
        v34 = __ldxr(v29);
      while (__stxr(v34 + 1, v29));
      goto LABEL_23;
    }
  }
  else
  {
    v31 = *(_OWORD **)(v113 + 24);
    v32 = *(_QWORD *)(v113 + 32);
    v33 = (_QWORD *)(v113 + 24);
    if ((unint64_t)v31 < v32)
    {
      *v31 = (unint64_t)v141;
LABEL_23:
      v35 = v31 + 1;
      goto LABEL_44;
    }
  }
  v36 = *(_QWORD *)(v113 + 16);
  v37 = ((uint64_t)v31 - v36) >> 4;
  v38 = v37 + 1;
  if ((unint64_t)(v37 + 1) >> 60)
    abort();
  v111 = v27;
  v39 = v32 - v36;
  if (v39 >> 3 > v38)
    v38 = v39 >> 3;
  if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF0)
    v40 = 0xFFFFFFFFFFFFFFFLL;
  else
    v40 = v38;
  if (v40 >> 60)
    std::__throw_bad_array_new_length[abi:nn180100]();
  v110 = v6;
  v41 = (char *)operator new(16 * v40);
  v42 = v16;
  v43 = &v41[16 * v37];
  *(_OWORD *)v43 = v111;
  if (v28)
  {
    v44 = (unint64_t *)&v28->__shared_owners_;
    do
      v45 = __ldxr(v44);
    while (__stxr(v45 + 1, v44));
  }
  v46 = *(_QWORD **)(v113 + 16);
  v47 = *(_QWORD **)(v113 + 24);
  if (v47 == v46)
  {
    v35 = v43 + 16;
    *(_QWORD *)(v113 + 16) = v43;
    *(_QWORD *)(v113 + 24) = v43 + 16;
    *(_QWORD *)(v113 + 32) = &v41[16 * v40];
  }
  else
  {
    v48 = &v41[16 * v37];
    do
    {
      v49 = *((_OWORD *)v47 - 1);
      v47 -= 2;
      *((_OWORD *)v48 - 1) = v49;
      v48 -= 16;
      *v47 = 0;
      v47[1] = 0;
    }
    while (v47 != v46);
    v47 = *(_QWORD **)(v113 + 16);
    v50 = *(_QWORD *)(v113 + 24);
    v35 = v43 + 16;
    *(_QWORD *)(v113 + 16) = v48;
    *(_QWORD *)(v113 + 24) = v43 + 16;
    *(_QWORD *)(v113 + 32) = &v41[16 * v40];
    while ((_QWORD *)v50 != v47)
    {
      v50 -= 16;
      std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v50);
    }
  }
  if (v47)
    operator delete(v47);
  v16 = v42;
  v6 = v110;
LABEL_44:
  *v33 = v35;
  if (v28)
  {
    v51 = (unint64_t *)&v28->__shared_owners_;
    do
      v52 = __ldaxr(v51);
    while (__stlxr(v52 - 1, v51));
    if (!v52)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v138 = 0;
  v53 = (std::__shared_weak_count *)*((_QWORD *)&v141 + 1);
  v137 = v141;
  if (*((_QWORD *)&v141 + 1))
  {
    v54 = (unint64_t *)(*((_QWORD *)&v141 + 1) + 8);
    do
      v55 = __ldxr(v54);
    while (__stxr(v55 + 1, v54));
  }
  HTTPConnectionCacheEntry::_findOrCreateEmptyConnection(&context, v26, (const __CFString *)&v137, &v138);
  v56 = context;
  context = 0uLL;
  v57 = v56;
  if (!v53)
    goto LABEL_56;
  v58 = (unint64_t *)&v53->__shared_owners_;
  do
    v59 = __ldaxr(v58);
  while (__stlxr(v59 - 1, v58));
  if (!v59)
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
    *((_QWORD *)&v56 + 1) = *((_QWORD *)&v57 + 1);
    if ((_QWORD)v57)
      goto LABEL_57;
  }
  else
  {
LABEL_56:
    if ((_QWORD)v56)
    {
LABEL_57:
      v60 = v138;
      if (v138 == 1)
        *(_QWORD *)(v57 + 216) = 0;
      *(_QWORD *)&context = v57;
      v61 = (std::__shared_weak_count *)*((_QWORD *)&v56 + 1);
      *((_QWORD *)&context + 1) = *((_QWORD *)&v56 + 1);
      if (*((_QWORD *)&v56 + 1))
      {
        v62 = (unint64_t *)(*((_QWORD *)&v56 + 1) + 8);
        do
          v63 = __ldxr(v62);
        while (__stxr(v63 + 1, v62));
      }
      HTTPConnectionCacheEntry::_notifyNextProtocolOfOpenConnection(v26, &context, v60 == 2);
      if (!v61)
        goto LABEL_123;
      v64 = (unint64_t *)&v61->__shared_owners_;
      do
        v65 = __ldaxr(v64);
      while (__stlxr(v65 - 1, v64));
      if (!v65)
      {
        ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
        std::__shared_weak_count::__release_weak(v61);
      }
      goto LABEL_119;
    }
  }
  v133 = 0;
  v134 = &v133;
  v135 = 0x2020000000;
  v136 = 0;
  v129 = 0;
  v130 = &v129;
  v131 = 0x2020000000;
  v132 = v138 == 0;
  v125 = 0;
  v126 = &v125;
  v127 = 0x2020000000;
  v128 = 0;
  *(_QWORD *)&context = MEMORY[0x1E0C809B0];
  *((_QWORD *)&context + 1) = 3221225472;
  v119 = ___ZN24HTTPConnectionCacheEntry25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke;
  v120 = &unk_1E14FA000;
  v121 = &v133;
  v122 = &v125;
  v123 = &v129;
  v124 = a2;
  v66 = *(const __CFArray **)(v26 + 80);
  v145.length = CFArrayGetCount(v66);
  v145.location = 0;
  CFArrayApplyFunction(v66, v145, (CFArrayApplierFunction)RetainableTypedArray<Tube *>::_invoke, &context);
  if (*((_BYTE *)v134 + 24) && (*(unsigned int (**)(uint64_t))(*(_QWORD *)a2 + 232))(a2))
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 240))(a2, v126[3]);
  if (!*((_BYTE *)v130 + 24))
    goto LABEL_118;
  v67 = *(_QWORD *)(v26 + 96);
  v68 = *(uint64_t **)(v67 + 8);
  if ((uint64_t)(*(_QWORD *)(v67 + 16) - (_QWORD)v68) < 1)
  {
LABEL_109:
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)a2 + 72))(&v116, a2);
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v97 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 138543362;
      v143 = v116;
      _os_log_fault_impl(&dword_183ECA000, v97, OS_LOG_TYPE_FAULT, "%{public}@ not allowed to create a new connection but no existing connection", buf, 0xCu);
    }
    v98 = v117;
    if (v117)
    {
      v99 = (unint64_t *)&v117->__shared_owners_;
      do
        v100 = __ldaxr(v99);
      while (__stlxr(v100 - 1, v99));
      if (!v100)
      {
        ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
        std::__shared_weak_count::__release_weak(v98);
      }
    }
    goto LABEL_118;
  }
  v69 = v6;
  v70 = v16;
  v71 = *v68;
  v72 = (std::__shared_weak_count *)v68[1];
  if (v72)
  {
    v73 = (unint64_t *)&v72->__shared_owners_;
    do
      v74 = __ldxr(v73);
    while (__stxr(v74 + 1, v73));
  }
  if (v71)
  {
    v75 = *(_QWORD *)(v71 + 64);
    if (v75)
    {
      v76 = *(_QWORD *)(v75 + 56);
      v77 = *(std::__shared_weak_count **)(v75 + 64);
      if (v77)
      {
        v78 = (unint64_t *)&v77->__shared_owners_;
        do
          v79 = __ldxr(v78);
        while (__stxr(v79 + 1, v78));
        v80 = v77;
        if (!v76)
        {
LABEL_98:
          if (v80)
          {
            v93 = (unint64_t *)&v80->__shared_owners_;
            do
              v94 = __ldaxr(v93);
            while (__stlxr(v94 - 1, v93));
            if (!v94)
            {
              ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
              std::__shared_weak_count::__release_weak(v80);
            }
          }
          goto LABEL_103;
        }
      }
      else
      {
        v80 = 0;
        if (!v76)
          goto LABEL_98;
      }
      (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD))(*(_QWORD *)v76 + 280))(v76, *(_QWORD *)(a2 - 96), 4, 0);
      *((_BYTE *)v130 + 24) = 0;
      goto LABEL_98;
    }
  }
LABEL_103:
  v16 = v70;
  if (v72)
  {
    v95 = (unint64_t *)&v72->__shared_owners_;
    do
      v96 = __ldaxr(v95);
    while (__stlxr(v96 - 1, v95));
    if (!v96)
    {
      ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
      std::__shared_weak_count::__release_weak(v72);
    }
  }
  v6 = v69;
  if (*((_BYTE *)v130 + 24))
    goto LABEL_109;
LABEL_118:
  _Block_object_dispose(&v125, 8);
  _Block_object_dispose(&v129, 8);
  _Block_object_dispose(&v133, 8);
  v61 = (std::__shared_weak_count *)*((_QWORD *)&v57 + 1);
  if (*((_QWORD *)&v57 + 1))
  {
LABEL_119:
    v101 = (unint64_t *)&v61->__shared_owners_;
    do
      v102 = __ldaxr(v101);
    while (__stlxr(v102 - 1, v101));
    if (!v102)
    {
      ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
      std::__shared_weak_count::__release_weak(v61);
    }
  }
LABEL_123:
  if (*((_QWORD *)&v113 + 1))
  {
    v103 = (unint64_t *)(*((_QWORD *)&v113 + 1) + 8);
    do
      v104 = __ldaxr(v103);
    while (__stlxr(v104 - 1, v103));
    if (!v104)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v113 + 1) + 16))(*((_QWORD *)&v113 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v113 + 1));
    }
  }
  v105 = (std::__shared_weak_count *)*((_QWORD *)&v141 + 1);
  if (*((_QWORD *)&v141 + 1))
  {
    v106 = (unint64_t *)(*((_QWORD *)&v141 + 1) + 8);
    do
      v107 = __ldaxr(v106);
    while (__stlxr(v107 - 1, v106));
    if (!v107)
    {
      ((void (*)(std::__shared_weak_count *))v105->__on_zero_shared)(v105);
      std::__shared_weak_count::__release_weak(v105);
    }
  }
  if (v16)
  {
    v108 = (unint64_t *)&v16->__shared_owners_;
    do
      v109 = __ldaxr(v108);
    while (__stlxr(v109 - 1, v108));
    if (!v109)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  HTTPConnectionCache::purgeExcessiveConnections(v6);
  HTTPConnectionCache::enableTimer(v6);
  (*(void (**)(__CFDictionary *))(*(_QWORD *)v6 + 152))(v6);
  return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v112 + 48))(v112);
}

void sub_183F24698(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
  std::__shared_weak_count *v36;
  std::__shared_weak_count *v37;
  std::__shared_weak_count *v38;
  uint64_t v39;
  unint64_t *p_shared_owners;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t *v52;
  unint64_t v53;

  if (v38)
  {
    p_shared_owners = (unint64_t *)&v38->__shared_owners_;
    do
      v42 = __ldaxr(p_shared_owners);
    while (__stlxr(v42 - 1, p_shared_owners));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  if (v37)
  {
    v43 = (unint64_t *)&v37->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
  _Block_object_dispose(&a32, 8);
  _Block_object_dispose(&a36, 8);
  _Block_object_dispose((const void *)(v39 - 216), 8);
  if (a12)
  {
    v45 = (unint64_t *)&a12->__shared_owners_;
    do
      v46 = __ldaxr(v45);
    while (__stlxr(v46 - 1, v45));
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
    }
  }
  if (a16)
  {
    v47 = (unint64_t *)&a16->__shared_owners_;
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))a16->__on_zero_shared)(a16);
      std::__shared_weak_count::__release_weak(a16);
    }
  }
  v49 = *(std::__shared_weak_count **)(v39 - 120);
  if (v49)
  {
    v50 = (unint64_t *)&v49->__shared_owners_;
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
  if (v36)
  {
    v52 = (unint64_t *)&v36->__shared_owners_;
    do
      v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  _Unwind_Resume(a1);
}

void HTTPConnectionCache::purgeExcessiveConnections(HTTPConnectionCache *this)
{
  __CFArray *Mutable;
  uint64_t v3;
  const void **v4;
  const void **v5;
  const void *v6;
  unint64_t Count;
  const void **v8;
  uint64_t v9;
  double v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  CFIndex v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  double v25;
  double v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  CFIndex i;
  HTTPConnectionCacheEntry **ValueAtIndex;
  HTTPConnectionCacheEntry **v32;
  HTTPConnectionCacheEntry *v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t *v37;
  unint64_t v38;

  if (!*((_QWORD *)this + 5))
    return;
  Mutable = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
  v3 = *((_QWORD *)this + 5);
  v4 = (const void **)operator new();
  v5 = v4;
  v6 = *(const void **)(v3 + 32);
  if (v6)
  {
    *v4 = CFRetain(v6);
    Count = CFDictionaryGetCount((CFDictionaryRef)v6);
    v5[1] = (const void *)Count;
    if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      v5[2] = 0;
    }
    else
    {
      if (Count <= 0x1E)
      {
        v8 = v5 + 3;
        v5[2] = v5 + 3;
LABEL_10:
        CFDictionaryGetKeysAndValues((CFDictionaryRef)v6, 0, v8);
        goto LABEL_11;
      }
      v8 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
      v5[2] = v8;
      if (v8)
        goto LABEL_10;
    }
  }
  else
  {
    *v4 = 0;
    v4[1] = 0;
    v4[2] = v4 + 3;
  }
LABEL_11:
  v9 = (uint64_t)v5[1];
  v10 = 0.0;
  if (v9 >= 19)
  {
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = *((_QWORD *)v5[2] + v11);
      v15 = *(_QWORD *)(v13 + 24);
      v14 = *(std::__shared_weak_count **)(v13 + 32);
      if (v14)
      {
        p_shared_owners = (unint64_t *)&v14->__shared_owners_;
        do
          v17 = __ldxr(p_shared_owners);
        while (__stxr(v17 + 1, p_shared_owners));
      }
      v18 = CFArrayGetCount(*(CFArrayRef *)(v15 + 80));
      v20 = *(_QWORD *)(v15 + 88);
      v19 = *(_QWORD *)(v15 + 96);
      v22 = *(_QWORD *)(v19 + 8);
      v21 = *(_QWORD *)(v19 + 16);
      if (v14)
      {
        v23 = (unint64_t *)&v14->__shared_owners_;
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
      }
      v12 += v20 + v18 + ((v21 - v22) >> 4);
      ++v11;
    }
    while (v11 != v9);
    if ((uint64_t)v12 > 72)
    {
      v25 = 0.5;
      v26 = 2.0;
      if (v12 > 0x90)
        v26 = 1.0;
      if (v12 <= 0x120)
        v25 = v26;
      if (v12 <= 0x240)
        v27 = v25;
      else
        v27 = 0.1;
      v28 = 0;
      v10 = CFAbsoluteTimeGetCurrent() - v27;
      do
        CFArrayAppendValue(Mutable, *((const void **)v5[2] + v28++));
      while (v9 != v28);
    }
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v5);
  MEMORY[0x186DB748C](v29, 0x10C0C40A1FC37EELL);
  for (i = 0; i < CFArrayGetCount(Mutable); ++i)
  {
    ValueAtIndex = (HTTPConnectionCacheEntry **)CFArrayGetValueAtIndex(Mutable, i);
    v32 = ValueAtIndex;
    if (ValueAtIndex)
    {
      v33 = ValueAtIndex[3];
      v34 = (std::__shared_weak_count *)v32[4];
      if (v34)
      {
        v35 = (unint64_t *)&v34->__shared_owners_;
        do
          v36 = __ldxr(v35);
        while (__stxr(v36 + 1, v35));
      }
      HTTPConnectionCacheEntry::purgeIdleConnections(v33, v10, v10);
      if (v34)
      {
        v37 = (unint64_t *)&v34->__shared_owners_;
        do
          v38 = __ldaxr(v37);
        while (__stlxr(v38 - 1, v37));
        if (!v38)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }
    }
  }
  CFRelease(Mutable);
}

void sub_183F24BF0(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t HTTPConnectionCache::ingestTube(HTTPConnectionCache *this, Tube *a2, int a3)
{
  const void *v6;
  _QWORD *Value;
  _QWORD *EmptyCacheEntry;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  const __CFArray *v13;
  CFIndex FirstIndexOfValue;
  int v15;
  uint64_t v16;
  int v17;
  unint64_t *v18;
  unint64_t v19;
  char *v21;
  unint64_t *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  const void *v42;
  std::__shared_weak_count *v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t *v48;
  unint64_t v49;
  unint64_t v50;
  std::__shared_weak_count *v51;
  std::__shared_weak_count *v52;
  std::__shared_weak_count *v53;
  uint64_t v54;
  unint64_t *p_shared_weak_owners;
  unint64_t v56;
  unint64_t *v57;
  unint64_t v58;
  uint64_t v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t *v67;
  unint64_t v68;
  std::__shared_weak_count *v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  _QWORD *v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t *v77;
  unint64_t v78;
  std::__shared_weak_count *v79;
  uint64_t v80;
  std::__shared_weak_count *v81;
  std::__shared_weak_count *v82;
  uint64_t v83;
  unint64_t *v84;
  unint64_t v85;
  unint64_t *v86;
  unint64_t v87;
  std::__shared_weak_count *v88;
  unint64_t *v89;
  unint64_t v90;
  std::__shared_weak_count *v91;
  unint64_t *v92;
  unint64_t v93;
  std::__shared_weak_count *v94;
  std::__shared_weak_count *v95;
  uint64_t v96;
  char v97;
  NSObject *v98;
  unint64_t *v99;
  unint64_t v100;
  std::__shared_weak_count *v101;
  unint64_t *v102;
  unint64_t v103;
  const __CFString *v104;
  const __CFString *v105;
  const void *v106;
  std::__shared_weak_count *v107;
  unint64_t *v108;
  unint64_t v109;
  unint64_t *v110;
  unint64_t v111;
  std::__shared_weak_count *v112;
  unint64_t *v113;
  unint64_t v114;
  __int128 v115;
  _QWORD *v116;
  unint64_t v117;
  unint64_t v118;
  __int128 *v119;
  unint64_t v120;
  _OWORD *v121;
  uint64_t v122;
  unint64_t v123;
  std::__shared_weak_count *v124;
  unint64_t *v125;
  unint64_t v126;
  std::__shared_weak_count *v127;
  unint64_t *v128;
  unint64_t v129;
  char v130;
  unint64_t *v131;
  unint64_t v132;
  std::__shared_weak_count *v133;
  unint64_t *v134;
  unint64_t v135;
  std::__shared_weak_count *v136;
  unint64_t *v137;
  unint64_t v138;
  unint64_t *v139;
  unint64_t v140;
  unint64_t *v141;
  unint64_t v142;
  unint64_t *v143;
  unint64_t v144;
  unint64_t *v145;
  unint64_t *v146;
  unint64_t v147;
  uint64_t v148;
  uint64_t v149;
  unint64_t v150;
  uint64_t v151;
  unint64_t v152;
  char *v153;
  uint64_t v154;
  __int128 *v155;
  unint64_t v156;
  _QWORD *v157;
  _QWORD *v158;
  char *v159;
  __int128 v160;
  int64x2_t v161;
  __n128 (*v162)(__n128 *, __n128 *);
  unint64_t v163;
  const char *v164;
  int v165;
  int v166;
  uint64_t *v167;
  std::__shared_weak_count_vtbl **v168;
  _WORD *v169;
  int v170;
  std::__shared_weak_count *v171;
  uint64_t v172;
  char *v173;
  __int128 v174;
  uint64_t v175;
  uint64_t v176;
  _QWORD v177[2];
  uint64_t (*v178)(uint64_t);
  void *v179;
  uint64_t *v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t *v183;
  uint64_t v184;
  uint64_t v185;
  __int128 block;
  uint64_t (*v187)(uint64_t);
  void *v188;
  char *v189;
  uint64_t v190;
  std::__shared_weak_count *v191;
  int v192;
  __int128 v193;
  __int128 v194;
  void (*v195)(_QWORD *);
  void *v196;
  _BYTE *v197;
  char *v198;
  Tube *v199;
  _BYTE v200[24];
  __n128 (*v201)(__n128 *, __n128 *);
  uint64_t (*v202)(uint64_t);
  void *v203;
  uint64_t v204;
  std::__shared_weak_count *v205;
  __int128 v206[2];
  CFRange v207;

  HTTPConnectionCache::ensureEntries(this);
  v6 = (const void *)Tube::copyKey(*((Tube **)a2 + 13));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*((_QWORD *)this + 5) + 32), v6);
  if (Value)
  {
    EmptyCacheEntry = Value;
    (*(void (**)(_QWORD *))(*Value + 40))(Value);
  }
  else
  {
    EmptyCacheEntry = HTTPConnectionCache::createEmptyCacheEntry((CFSetRef *)this, (const HTTPConnectionCacheKey *)v6);
    if (EmptyCacheEntry)
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*((_QWORD *)this + 5) + 32), v6, EmptyCacheEntry);
  }
  (*(void (**)(const void *))(*(_QWORD *)v6 + 48))(v6);
  if (EmptyCacheEntry)
  {
    v10 = EmptyCacheEntry[3];
    v9 = (std::__shared_weak_count *)EmptyCacheEntry[4];
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
    }
    v13 = *(const __CFArray **)(v10 + 80);
    v207.length = CFArrayGetCount(v13);
    v207.location = 0;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v13, v207, a2);
    if (FirstIndexOfValue == -1)
    {
      if (*(_QWORD *)(v10 + 88) != 1)
        __assert_rtn("ingestTube", "HTTPConnectionCacheEntry.cpp", 247, "_initialTubeWidthPlaceholder == 1");
      *(_QWORD *)(v10 + 88) = 0;
    }
    else
    {
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v10 + 80), FirstIndexOfValue);
    }
    v182 = 0;
    v183 = &v182;
    v184 = 0x2020000000;
    v185 = 0;
    v185 = Tube::copyWaiter(*((Tube **)a2 + 14));
    v181 = 0;
    v181 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v183[3] + 80))(v183[3]);
    v177[0] = MEMORY[0x1E0C809B0];
    v177[1] = 3221225472;
    v178 = ___ZN24HTTPConnectionCacheEntry10ingestTubeEP4Tubeb_block_invoke;
    v179 = &unk_1E14FD3D8;
    v180 = &v182;
    *(_QWORD *)v200 = 0;
    *(_QWORD *)&v200[8] = v200;
    *(_QWORD *)&v200[16] = 0x2020000000;
    v15 = *((_DWORD *)a2 + 55);
    LOBYTE(v201) = v15 == 10;
    _Block_object_dispose(v200, 8);
    if (v15 == 10
      || (v16 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v183[3] + 80))(v183[3]),
          (*(unsigned int (**)(uint64_t))(*(_QWORD *)v16 + 176))(v16)))
    {
      if (a3)
      {
        *(_QWORD *)v200 = 0;
        *(_QWORD *)&v200[8] = v200;
        *(_QWORD *)&v200[16] = 0x2020000000;
        v17 = *((_DWORD *)a2 + 55);
        LOBYTE(v201) = v17 == 10;
        _Block_object_dispose(v200, 8);
        if (v17 == 10 && !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v181 + 176))(v181))
          (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v181 + 64))(v181, 1, 89, 0);
      }
      *(_QWORD *)v200 = 0;
      *(_QWORD *)&v200[8] = 0;
      HTTPConnectionCacheEntry::_connectionWasLost((HTTPConnectionCacheEntry *)v10, (uint64_t *)v200);
      goto LABEL_20;
    }
    v175 = Tube::copyKey(*((Tube **)a2 + 13));
    v21 = (char *)operator new(0x118uLL);
    *(_OWORD *)(v21 + 8) = 0u;
    v22 = (unint64_t *)(v21 + 8);
    *(_QWORD *)v21 = &off_1E14F0980;
    *((_QWORD *)v21 + 3) = &off_1E14E6D20;
    v173 = v21 + 24;
    *((_OWORD *)v21 + 2) = 0u;
    *((_QWORD *)v21 + 6) = &unk_1E14E6D58;
    *((_OWORD *)v21 + 4) = 0u;
    v167 = (uint64_t *)(v21 + 64);
    *((_OWORD *)v21 + 8) = 0u;
    *((_OWORD *)v21 + 9) = 0u;
    *((_WORD *)v21 + 28) = 0;
    v169 = v21 + 56;
    *((_QWORD *)v21 + 34) = 0;
    v21[58] = 0;
    *((_OWORD *)v21 + 5) = 0u;
    *((_OWORD *)v21 + 6) = 0u;
    *((_OWORD *)v21 + 7) = 0u;
    *((_OWORD *)v21 + 10) = 0u;
    *((_OWORD *)v21 + 11) = 0u;
    *((_OWORD *)v21 + 12) = 0u;
    *((_OWORD *)v21 + 13) = 0u;
    *((_QWORD *)v21 + 28) = 0;
    *(_OWORD *)v200 = 0u;
    v168 = (std::__shared_weak_count_vtbl **)(v21 + 88);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v21 + 88), (__int128 *)v200);
    v23 = *(std::__shared_weak_count **)&v200[8];
    if (*(_QWORD *)&v200[8])
    {
      v24 = (unint64_t *)(*(_QWORD *)&v200[8] + 8);
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    v170 = a3;
    v26 = *((_QWORD *)v21 + 15);
    *((_QWORD *)v21 + 15) = 0;
    if (v26)
      (*(void (**)(uint64_t))(*(_QWORD *)v26 + 48))(v26);
    *(_QWORD *)v200 = 0;
    *(_QWORD *)&v200[8] = 0;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v21 + 128), (__int128 *)v200);
    v27 = *(std::__shared_weak_count **)&v200[8];
    if (*(_QWORD *)&v200[8])
    {
      v28 = (unint64_t *)(*(_QWORD *)&v200[8] + 8);
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    v172 = (uint64_t)(v21 + 200);
    *(_QWORD *)v200 = 0;
    *(_QWORD *)&v200[8] = 0;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v21 + 168), (__int128 *)v200);
    v30 = *(std::__shared_weak_count **)&v200[8];
    if (*(_QWORD *)&v200[8])
    {
      v31 = (unint64_t *)(*(_QWORD *)&v200[8] + 8);
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
    *(_QWORD *)v200 = 0;
    *(_QWORD *)&v200[8] = 0;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v21 + 184), (__int128 *)v200);
    v33 = *(std::__shared_weak_count **)&v200[8];
    if (*(_QWORD *)&v200[8])
    {
      v34 = (unint64_t *)(*(_QWORD *)&v200[8] + 8);
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }
    *(_QWORD *)v200 = 0;
    *(_QWORD *)&v200[8] = 0;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v172, (__int128 *)v200);
    v36 = *(std::__shared_weak_count **)&v200[8];
    if (*(_QWORD *)&v200[8])
    {
      v37 = (unint64_t *)(*(_QWORD *)&v200[8] + 8);
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }
    *(_QWORD *)v200 = 0;
    *(_QWORD *)&v200[8] = 0;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v21 + 216), (__int128 *)v200);
    v39 = *(std::__shared_weak_count **)&v200[8];
    if (*(_QWORD *)&v200[8])
    {
      v40 = (unint64_t *)(*(_QWORD *)&v200[8] + 8);
      do
        v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
    *((CFAbsoluteTime *)v21 + 29) = CFAbsoluteTimeGetCurrent();
    *((_QWORD *)v21 + 30) = 0;
    *((_DWORD *)v21 + 62) = 30;
    *((_QWORD *)v21 + 32) = 0;
    *((_DWORD *)v21 + 66) = 0;
    v42 = (const void *)*((_QWORD *)v21 + 34);
    *((_QWORD *)v21 + 34) = 0;
    if (v42)
      CFRelease(v42);
    v43 = (std::__shared_weak_count *)*((_QWORD *)v21 + 5);
    if (v43)
    {
      if (v43->__shared_owners_ != -1)
        goto LABEL_74;
      do
        v44 = __ldxr(v22);
      while (__stxr(v44 + 1, v22));
      v45 = (unint64_t *)(v21 + 16);
      do
        v46 = __ldxr(v45);
      while (__stxr(v46 + 1, v45));
      *((_QWORD *)v21 + 4) = v173;
      *((_QWORD *)v21 + 5) = v21;
      std::__shared_weak_count::__release_weak(v43);
    }
    else
    {
      do
        v47 = __ldxr(v22);
      while (__stxr(v47 + 1, v22));
      v48 = (unint64_t *)(v21 + 16);
      do
        v49 = __ldxr(v48);
      while (__stxr(v49 + 1, v48));
      *((_QWORD *)v21 + 4) = v173;
      *((_QWORD *)v21 + 5) = v21;
    }
    do
      v50 = __ldaxr(v22);
    while (__stlxr(v50 - 1, v22));
    if (!v50)
    {
      (*(void (**)(char *))(*(_QWORD *)v21 + 16))(v21);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v21);
    }
LABEL_74:
    v51 = *(std::__shared_weak_count **)(v10 + 48);
    if (v51)
    {
      v52 = std::__shared_weak_count::lock(v51);
      v53 = v52;
      if (v52)
      {
        v54 = *(_QWORD *)(v10 + 40);
        p_shared_weak_owners = (unint64_t *)&v52->__shared_weak_owners_;
        do
          v56 = __ldxr(p_shared_weak_owners);
        while (__stxr(v56 + 1, p_shared_weak_owners));
        v57 = (unint64_t *)&v52->__shared_owners_;
        do
          v58 = __ldaxr(v57);
        while (__stlxr(v58 - 1, v57));
        if (!v58)
        {
          ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
          std::__shared_weak_count::__release_weak(v53);
        }
      }
      else
      {
        v54 = 0;
      }
    }
    else
    {
      v54 = 0;
      v53 = 0;
    }
    v171 = v53;
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(v200, *((_QWORD *)v21 + 4), *((std::__shared_weak_count **)v21 + 5));
    v59 = *(_QWORD *)v200;
    v60 = *(std::__shared_weak_count **)&v200[8];
    if (*(_QWORD *)&v200[8])
    {
      v61 = (unint64_t *)(*(_QWORD *)&v200[8] + 16);
      do
        v62 = __ldxr(v61);
      while (__stxr(v62 + 1, v61));
    }
    v63 = (std::__shared_weak_count *)*((_QWORD *)v21 + 9);
    *((_QWORD *)v21 + 8) = v59;
    *((_QWORD *)v21 + 9) = v60;
    if (v63)
    {
      std::__shared_weak_count::__release_weak(v63);
      v60 = *(std::__shared_weak_count **)&v200[8];
    }
    if (v60)
    {
      v64 = (unint64_t *)&v60->__shared_owners_;
      do
        v65 = __ldaxr(v64);
      while (__stlxr(v65 - 1, v64));
      if (!v65)
      {
        ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
        std::__shared_weak_count::__release_weak(v60);
      }
    }
    if (v175)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v175 + 40))(v175);
      v66 = *((_QWORD *)v21 + 15);
      *((_QWORD *)v21 + 15) = v175;
      if (v66)
        (*(void (**)(uint64_t))(*(_QWORD *)v66 + 48))(v66);
      if (v53)
      {
        v67 = (unint64_t *)&v53->__shared_weak_owners_;
        do
          v68 = __ldxr(v67);
        while (__stxr(v68 + 1, v67));
      }
      v69 = (std::__shared_weak_count *)*((_QWORD *)v21 + 14);
      *((_QWORD *)v21 + 13) = v54;
      *((_QWORD *)v21 + 14) = v53;
      if (v69)
        std::__shared_weak_count::__release_weak(v69);
      v70 = *((_QWORD *)a2 + 20);
      v71 = MEMORY[0x1E0C809B0];
      if (v70)
      {
        dispatch_retain(*((dispatch_object_t *)a2 + 20));
        *((_QWORD *)v21 + 10) = v70;
        *(_QWORD *)v200 = 0;
        *(_QWORD *)&v200[8] = v200;
        *(_QWORD *)&v200[16] = 0x4012000000;
        v201 = __Block_byref_object_copy__11566;
        v202 = __Block_byref_object_dispose__11567;
        v204 = 0;
        v205 = 0;
        v203 = &unk_18422E08D;
        *(_QWORD *)&v194 = v71;
        *((_QWORD *)&v194 + 1) = 3221225472;
        v195 = ___ZN14HTTPConnection10initializeEP22HTTPConnectionCacheKeyP4TubeNSt3__18weak_ptrINS_20HTTPActivityDelegateEEE_block_invoke;
        v196 = &unk_1E14FD7A8;
        v197 = v200;
        v198 = v21 + 24;
        v199 = a2;
        ___ZN14HTTPConnection10initializeEP22HTTPConnectionCacheKeyP4TubeNSt3__18weak_ptrINS_20HTTPActivityDelegateEEE_block_invoke(&v194);
        if (!*(_QWORD *)(*(_QWORD *)&v200[8] + 48))
          goto LABEL_134;
        v72 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v175 + 88))(v175);
        if (v72 == 2)
          *v169 |= 0x200u;
        v73 = *(_QWORD *)&v200[8];
        v74 = operator new(0x178uLL);
        v166 = v72;
        v74[1] = 0;
        v74[2] = 0;
        *v74 = &off_1E14F0750;
        v75 = (uint64_t)(v74 + 3);
        v76 = *(_QWORD *)(v73 + 56);
        *(_QWORD *)&block = *(_QWORD *)(v73 + 48);
        *((_QWORD *)&block + 1) = v76;
        if (v76)
        {
          v77 = (unint64_t *)(v76 + 8);
          do
            v78 = __ldxr(v77);
          while (__stxr(v78 + 1, v77));
        }
        v206[0] = 0uLL;
        v79 = (std::__shared_weak_count *)*((_QWORD *)v21 + 9);
        v80 = MEMORY[0x1E0C809B0];
        if (v79)
        {
          v81 = std::__shared_weak_count::lock(v79);
          if (v81)
          {
            v82 = v81;
            v83 = *v167;
            v84 = (unint64_t *)&v81->__shared_weak_owners_;
            do
              v85 = __ldxr(v84);
            while (__stxr(v85 + 1, v84));
            *(_QWORD *)&v206[0] = v83;
            *((_QWORD *)&v206[0] + 1) = v81;
            v86 = (unint64_t *)&v81->__shared_owners_;
            do
              v87 = __ldaxr(v86);
            while (__stlxr(v87 - 1, v86));
            if (!v87)
            {
              ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
              std::__shared_weak_count::__release_weak(v82);
            }
          }
          else
          {
            v206[0] = 0uLL;
          }
        }
        HTTPEngine::HTTPEngine(v75, (uint64_t *)&block, (uint64_t *)v206);
        if (*((_QWORD *)&v206[0] + 1))
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v206[0] + 1));
        v88 = (std::__shared_weak_count *)*((_QWORD *)&block + 1);
        if (*((_QWORD *)&block + 1))
        {
          v89 = (unint64_t *)(*((_QWORD *)&block + 1) + 8);
          do
            v90 = __ldaxr(v89);
          while (__stlxr(v90 - 1, v89));
          if (!v90)
          {
            ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
            std::__shared_weak_count::__release_weak(v88);
          }
        }
        *(_QWORD *)&v193 = v74 + 3;
        *((_QWORD *)&v193 + 1) = v74;
        std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&v193, v74 + 4, v75);
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v168, &v193);
        v91 = (std::__shared_weak_count *)*((_QWORD *)&v193 + 1);
        v53 = v171;
        if (*((_QWORD *)&v193 + 1))
        {
          v92 = (unint64_t *)(*((_QWORD *)&v193 + 1) + 8);
          do
            v93 = __ldaxr(v92);
          while (__stlxr(v93 - 1, v92));
          if (!v93)
          {
            ((void (*)(std::__shared_weak_count *))v91->__on_zero_shared)(v91);
            std::__shared_weak_count::__release_weak(v91);
          }
        }
        if (!*v168)
        {
LABEL_134:
          v97 = 0;
          goto LABEL_161;
        }
        v94 = (std::__shared_weak_count *)*((_QWORD *)v21 + 9);
        if (v94)
        {
          v95 = std::__shared_weak_count::lock(v94);
          if (v95)
          {
            v96 = *v167;
LABEL_137:
            v98 = *((_QWORD *)v21 + 10);
            *(_QWORD *)&block = v80;
            *((_QWORD *)&block + 1) = 3321888768;
            v187 = ___ZN14HTTPConnection10initializeEP22HTTPConnectionCacheKeyP4TubeNSt3__18weak_ptrINS_20HTTPActivityDelegateEEE_block_invoke_2;
            v188 = &__block_descriptor_60_e8_40c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e5_v8__0l;
            v189 = v21 + 24;
            v190 = v96;
            v191 = v95;
            if (v95)
            {
              v99 = (unint64_t *)&v95->__shared_owners_;
              do
                v100 = __ldxr(v99);
              while (__stxr(v100 + 1, v99));
            }
            v192 = v166;
            dispatch_async(v98, &block);
            std::allocate_shared[abi:nn180100]<HTTPConnectionAuthenticator,std::allocator<HTTPConnectionAuthenticator>,std::weak_ptr<HTTPConnection> &,std::shared_ptr<HTTPEngine> &,void>((std::__shared_weak_count_vtbl **)v206, *((_QWORD *)v21 + 8), *((std::__shared_weak_count **)v21 + 9), v168);
            std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v172, v206);
            v101 = (std::__shared_weak_count *)*((_QWORD *)&v206[0] + 1);
            if (*((_QWORD *)&v206[0] + 1))
            {
              v102 = (unint64_t *)(*((_QWORD *)&v206[0] + 1) + 8);
              do
                v103 = __ldaxr(v102);
              while (__stlxr(v103 - 1, v102));
              if (!v103)
              {
                ((void (*)(std::__shared_weak_count *))v101->__on_zero_shared)(v101);
                std::__shared_weak_count::__release_weak(v101);
              }
            }
            v104 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v175 + 72))(v175);
            v105 = v104;
            if (v104)
              CFRetain(v104);
            else
              v105 = &stru_1E1500C68;
            v106 = (const void *)*((_QWORD *)v21 + 34);
            *((_QWORD *)v21 + 34) = v105;
            if (v106)
              CFRelease(v106);
            *v169 |= 1u;
            v107 = v191;
            if (v191)
            {
              v108 = (unint64_t *)&v191->__shared_owners_;
              do
                v109 = __ldaxr(v108);
              while (__stlxr(v109 - 1, v108));
              if (!v109)
              {
                ((void (*)(std::__shared_weak_count *))v107->__on_zero_shared)(v107);
                std::__shared_weak_count::__release_weak(v107);
              }
            }
            if (v95)
            {
              v110 = (unint64_t *)&v95->__shared_owners_;
              do
                v111 = __ldaxr(v110);
              while (__stlxr(v111 - 1, v110));
              if (!v111)
              {
                ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
                std::__shared_weak_count::__release_weak(v95);
              }
            }
            v97 = 1;
            v53 = v171;
LABEL_161:
            _Block_object_dispose(v200, 8);
            v112 = v205;
            if (v205)
            {
              v113 = (unint64_t *)&v205->__shared_owners_;
              do
                v114 = __ldaxr(v113);
              while (__stlxr(v114 - 1, v113));
              if (!v114)
              {
                ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
                std::__shared_weak_count::__release_weak(v112);
              }
            }
            if (v53)
              std::__shared_weak_count::__release_weak(v53);
            if ((v97 & 1) != 0)
            {
              *(_QWORD *)&v115 = v21 + 24;
              *((_QWORD *)&v115 + 1) = v21;
              v174 = v115;
              v116 = *(_QWORD **)(v10 + 96);
              do
                v117 = __ldxr(v22);
              while (__stxr(v117 + 1, v22));
              v118 = v116[3];
              v119 = (__int128 *)v116[2];
              if ((unint64_t)v119 >= v118)
              {
                v148 = v116[1];
                v149 = ((uint64_t)v119 - v148) >> 4;
                v150 = v149 + 1;
                if ((unint64_t)(v149 + 1) >> 60)
                  abort();
                v151 = v118 - v148;
                if (v151 >> 3 > v150)
                  v150 = v151 >> 3;
                if ((unint64_t)v151 >= 0x7FFFFFFFFFFFFFF0)
                  v152 = 0xFFFFFFFFFFFFFFFLL;
                else
                  v152 = v150;
                v202 = (uint64_t (*)(uint64_t))(v116 + 3);
                v153 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<HTTP3Stream>>>(v152);
                v155 = (__int128 *)&v153[16 * v149];
                *v155 = v174;
                do
                  v156 = __ldxr(v22);
                while (__stxr(v156 + 1, v22));
                v158 = (_QWORD *)v116[1];
                v157 = (_QWORD *)v116[2];
                if (v157 == v158)
                {
                  v161 = vdupq_n_s64((unint64_t)v157);
                  v159 = &v153[16 * v149];
                }
                else
                {
                  v159 = &v153[16 * v149];
                  do
                  {
                    v160 = *((_OWORD *)v157 - 1);
                    v157 -= 2;
                    *((_OWORD *)v159 - 1) = v160;
                    v159 -= 16;
                    *v157 = 0;
                    v157[1] = 0;
                  }
                  while (v157 != v158);
                  v161 = *(int64x2_t *)(v116 + 1);
                }
                v121 = v155 + 1;
                v116[1] = v159;
                v116[2] = v155 + 1;
                *(int64x2_t *)&v200[8] = v161;
                v162 = (__n128 (*)(__n128 *, __n128 *))v116[3];
                v116[3] = &v153[16 * v154];
                v201 = v162;
                *(_QWORD *)v200 = v161.i64[0];
                std::__split_buffer<std::shared_ptr<HTTPConnection>>::~__split_buffer((uint64_t)v200);
              }
              else
              {
                *v119 = v115;
                do
                  v120 = __ldxr(v22);
                while (__stxr(v120 + 1, v22));
                v121 = v119 + 1;
              }
              v116[2] = v121;
              do
                v163 = __ldaxr(v22);
              while (__stlxr(v163 - 1, v22));
              v122 = v175;
              if (!v163)
                goto LABEL_178;
            }
            else
            {
              v122 = v175;
              do
                v123 = __ldaxr(v22);
              while (__stlxr(v123 - 1, v22));
              v174 = 0u;
              if (!v123)
              {
LABEL_178:
                (*(void (**)(char *))(*(_QWORD *)v21 + 16))(v21);
                std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v21);
              }
            }
            (*(void (**)(uint64_t))(*(_QWORD *)v122 + 48))(v122);
            if ((_QWORD)v174)
            {
              if ((v170 & 1) != 0)
              {
                v176 = 0;
                *(_QWORD *)v200 = 0x3F000000FFFFFFFFLL;
                *(_QWORD *)&v200[8] = 0;
                *(_DWORD *)&v200[16] = 0;
                (*(void (**)(uint64_t, uint64_t *, uint64_t *, _BYTE *))(*(_QWORD *)v183[3] + 104))(v183[3], &v181, &v176, v200);
                block = *(_OWORD *)v200;
                v187 = *(uint64_t (**)(uint64_t))&v200[16];
                HTTPConnectionCacheEntry::_prepareNewRequest((HTTPConnectionCacheEntry::EnqueuedRequest **)&v194, v10, v181, v176, (uint64_t)&block);
                v206[0] = v174;
                v124 = (std::__shared_weak_count *)*((_QWORD *)&v174 + 1);
                if (*((_QWORD *)&v174 + 1))
                {
                  v125 = (unint64_t *)(*((_QWORD *)&v174 + 1) + 8);
                  do
                    v126 = __ldxr(v125);
                  while (__stxr(v126 + 1, v125));
                }
                v127 = (std::__shared_weak_count *)*((_QWORD *)&v194 + 1);
                v193 = v194;
                if (*((_QWORD *)&v194 + 1))
                {
                  v128 = (unint64_t *)(*((_QWORD *)&v194 + 1) + 8);
                  do
                    v129 = __ldxr(v128);
                  while (__stxr(v129 + 1, v128));
                }
                v130 = HTTPConnectionCacheEntry::_dispatchConnectionToProtocol(v10, v206, (HTTPConnectionCacheEntry::EnqueuedRequest **)&v193, 1u);
                if (v127)
                {
                  v131 = (unint64_t *)&v127->__shared_owners_;
                  do
                    v132 = __ldaxr(v131);
                  while (__stlxr(v132 - 1, v131));
                  if (!v132)
                  {
                    ((void (*)(std::__shared_weak_count *))v127->__on_zero_shared)(v127);
                    std::__shared_weak_count::__release_weak(v127);
                  }
                }
                v133 = (std::__shared_weak_count *)*((_QWORD *)&v206[0] + 1);
                if (*((_QWORD *)&v206[0] + 1))
                {
                  v134 = (unint64_t *)(*((_QWORD *)&v206[0] + 1) + 8);
                  do
                    v135 = __ldaxr(v134);
                  while (__stlxr(v135 - 1, v134));
                  if (!v135)
                  {
                    ((void (*)(std::__shared_weak_count *))v133->__on_zero_shared)(v133);
                    std::__shared_weak_count::__release_weak(v133);
                  }
                }
                v136 = (std::__shared_weak_count *)*((_QWORD *)&v194 + 1);
                if (*((_QWORD *)&v194 + 1))
                {
                  v137 = (unint64_t *)(*((_QWORD *)&v194 + 1) + 8);
                  do
                    v138 = __ldaxr(v137);
                  while (__stlxr(v138 - 1, v137));
                  if (!v138)
                  {
                    ((void (*)(std::__shared_weak_count *))v136->__on_zero_shared)(v136);
                    std::__shared_weak_count::__release_weak(v136);
                  }
                }
                if ((v130 & 1) != 0)
                {
                  if (!*((_QWORD *)&v174 + 1))
                  {
LABEL_20:
                    v178((uint64_t)v177);
                    _Block_object_dispose(&v182, 8);
                    if (v9)
                    {
                      v18 = (unint64_t *)&v9->__shared_owners_;
                      do
                        v19 = __ldaxr(v18);
                      while (__stlxr(v19 - 1, v18));
                      if (!v19)
                      {
                        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
                        std::__shared_weak_count::__release_weak(v9);
                      }
                    }
                    (*(void (**)(_QWORD *))(*EmptyCacheEntry + 48))(EmptyCacheEntry);
                    goto LABEL_26;
                  }
LABEL_223:
                  v146 = (unint64_t *)&v124->__shared_owners_;
                  do
                    v147 = __ldaxr(v146);
                  while (__stlxr(v147 - 1, v146));
                  if (!v147)
                  {
                    ((void (*)(std::__shared_weak_count *))v124->__on_zero_shared)(v124);
                    std::__shared_weak_count::__release_weak(v124);
                  }
                  goto LABEL_20;
                }
              }
              else
              {
                v124 = (std::__shared_weak_count *)*((_QWORD *)&v174 + 1);
              }
              *(_QWORD *)v200 = v174;
              *(_QWORD *)&v200[8] = v124;
              if (v124)
              {
                v143 = (unint64_t *)&v124->__shared_owners_;
                do
                  v144 = __ldxr(v143);
                while (__stxr(v144 + 1, v143));
              }
              HTTPConnectionCacheEntry::_notifyNextProtocolOfOpenConnection(v10, v200, 1u);
              if (!v124)
                goto LABEL_20;
              v145 = (unint64_t *)&v124->__shared_owners_;
              do
                v142 = __ldaxr(v145);
              while (__stlxr(v142 - 1, v145));
            }
            else
            {
              if (v170)
                (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v181 + 64))(v181, 1, 57, 0);
              *(_QWORD *)v200 = 0;
              v124 = (std::__shared_weak_count *)*((_QWORD *)&v174 + 1);
              *(_QWORD *)&v200[8] = *((_QWORD *)&v174 + 1);
              if (*((_QWORD *)&v174 + 1))
              {
                v139 = (unint64_t *)(*((_QWORD *)&v174 + 1) + 8);
                do
                  v140 = __ldxr(v139);
                while (__stxr(v140 + 1, v139));
              }
              HTTPConnectionCacheEntry::_connectionWasLost((HTTPConnectionCacheEntry *)v10, (uint64_t *)v200);
              if (!*((_QWORD *)&v174 + 1))
                goto LABEL_20;
              v141 = (unint64_t *)(*((_QWORD *)&v174 + 1) + 8);
              do
                v142 = __ldaxr(v141);
              while (__stlxr(v142 - 1, v141));
            }
            if (!v142)
            {
              ((void (*)(std::__shared_weak_count *))v124->__on_zero_shared)(v124);
              std::__shared_weak_count::__release_weak(v124);
            }
            goto LABEL_223;
          }
        }
        else
        {
          v95 = 0;
        }
        v96 = 0;
        goto LABEL_137;
      }
      *((_QWORD *)v21 + 10) = 0;
      v164 = "_workQueue";
      v165 = 104;
    }
    else
    {
      v164 = "key";
      v165 = 90;
    }
    __assert_rtn("initialize", "HTTPConnection.cpp", v165, v164);
  }
LABEL_26:
  HTTPConnectionCache::enableTimer(this);
  return (*(uint64_t (**)(HTTPConnectionCache *))(*(_QWORD *)this + 152))(this);
}

void sub_183F25C54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, __int128 a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,void (*a22)(char *),uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36)
{
  std::__shared_weak_count *v36;
  unint64_t *v38;
  unint64_t v39;
  unint64_t *p_shared_owners;
  unint64_t v41;

  if (*((_QWORD *)&a17 + 1))
  {
    v38 = (unint64_t *)(*((_QWORD *)&a17 + 1) + 8);
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&a17 + 1) + 16))(*((_QWORD *)&a17 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&a17 + 1));
    }
  }
  a22(&a20);
  _Block_object_dispose(&a26, 8);
  if (v36)
  {
    p_shared_owners = (unint64_t *)&v36->__shared_owners_;
    do
      v41 = __ldaxr(p_shared_owners);
    while (__stlxr(v41 - 1, p_shared_owners));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  _Unwind_Resume(a1);
}

void HTTPConnectionCache::enableTimer(HTTPConnectionCache *this)
{
  NSObject *v2;
  double v3;
  dispatch_time_t v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  _QWORD v8[5];
  _QWORD handler[5];

  if (!*((_QWORD *)this + 14))
  {
    v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 12) + 80))(*((_QWORD *)this + 12));
    v3 = (double)*((int *)this + 20);
    *((_QWORD *)this + 14) = v2;
    v4 = dispatch_time(0, (uint64_t)(v3 * 1000000000.0));
    dispatch_source_set_timer(v2, v4, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    (*(void (**)(HTTPConnectionCache *))(*(_QWORD *)this + 40))(this);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 13) + 40))(*((_QWORD *)this + 13));
    v5 = MEMORY[0x1E0C809B0];
    v6 = *((_QWORD *)this + 14);
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 3221225472;
    handler[2] = ___ZN19HTTPConnectionCache11enableTimerEv_block_invoke;
    handler[3] = &__block_descriptor_40_e5_v8__0l;
    handler[4] = this;
    dispatch_source_set_event_handler(v6, handler);
    v7 = *((_QWORD *)this + 14);
    v8[0] = v5;
    v8[1] = 3221225472;
    v8[2] = ___ZN19HTTPConnectionCache11enableTimerEv_block_invoke_2;
    v8[3] = &__block_descriptor_40_e5_v8__0l;
    v8[4] = this;
    dispatch_source_set_cancel_handler(v7, v8);
    dispatch_resume(*((dispatch_object_t *)this + 14));
  }
}

CFMutableDictionaryRef HTTPConnectionCache::ensureEntries(CFMutableDictionaryRef this)
{
  CFMutableDictionaryRef v1;
  const __CFAllocator *v2;
  _QWORD *v3;

  if (!*((_QWORD *)this + 5))
  {
    v1 = this;
    v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v3 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 40, 0);
    *v3 = off_1E14EEC90;
    v3[1] = v2;
    v3[2] = &unk_1E14EECB0;
    v3[3] = &off_1E14EA4E8;
    v3[4] = 0;
    this = CFDictionaryCreateMutable(v2, 0, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
    v3[4] = this;
    *((_QWORD *)v1 + 5) = v3;
  }
  return this;
}

void sub_183F26210(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 16) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void ___ZN14HTTPConnection10initializeEP22HTTPConnectionCacheKeyP4TubeNSt3__18weak_ptrINS_20HTTPActivityDelegateEEE_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  __int128 v19;

  v3 = a1[5];
  v2 = a1[6];
  v4 = *(_QWORD *)(v2 + 136);
  if (v4)
    *(_BYTE *)(v2 + 240) = 0;
  v5 = *(_QWORD *)(v2 + 144);
  *(_QWORD *)&v19 = v4;
  *((_QWORD *)&v19 + 1) = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(_QWORD *)(a1[4] + 8) + 48, &v19);
  v8 = (std::__shared_weak_count *)*((_QWORD *)&v19 + 1);
  if (*((_QWORD *)&v19 + 1))
  {
    v9 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = a1[6];
  v13 = *(_QWORD *)(v11 + 264);
  v12 = *(_QWORD *)(v11 + 272);
  *(_QWORD *)&v19 = v13;
  *((_QWORD *)&v19 + 1) = v12;
  if (v12)
  {
    v14 = (unint64_t *)(v12 + 8);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v3 + 104, &v19);
  v16 = (std::__shared_weak_count *)*((_QWORD *)&v19 + 1);
  if (*((_QWORD *)&v19 + 1))
  {
    v17 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
}

void AwaitingTube::getRequestToEnqueue(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4)
{
  __int128 v4;

  *a3 = *(_QWORD *)(a1 + 40);
  *a2 = *(_QWORD *)(a1 + 48);
  v4 = *(_OWORD *)(a1 + 56);
  *(_QWORD *)(a4 + 16) = *(_QWORD *)(a1 + 72);
  *(_OWORD *)a4 = v4;
  *(CFAbsoluteTime *)(a1 + 96) = CFAbsoluteTimeGetCurrent();
}

uint64_t HTTPEngine::HTTPEngine(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  char *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  __int128 v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *p_shared_owners;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  __int128 v41;
  __int128 v42;

  *(_QWORD *)a1 = &off_1E14E4970;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = &unk_1E14E49C0;
  *(_OWORD *)(a1 + 56) = 0u;
  v5 = (uint64_t *)(a1 + 56);
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  v6 = a1 + 128;
  *(_OWORD *)(a1 + 144) = 0u;
  v7 = a1 + 144;
  *(_OWORD *)(a1 + 240) = 0u;
  v8 = a1 + 240;
  v9 = a1 + 256;
  *(_DWORD *)(a1 + 344) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(a1 + 56), *a2, a2[1]);
  v10 = *v5;
  if (!*v5)
    __assert_rtn("HTTPEngine", "HTTPEngine.cpp", 86, "_ioConn");
  v11 = *(_QWORD *)(v10 + 120);
  if (v11)
    dispatch_retain(*(dispatch_object_t *)(v10 + 120));
  *(_QWORD *)(a1 + 72) = v11;
  v13 = *a3;
  v12 = a3[1];
  if (v12)
  {
    v14 = (unint64_t *)(v12 + 16);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  v16 = *(std::__shared_weak_count **)(a1 + 88);
  *(_QWORD *)(a1 + 80) = v13;
  *(_QWORD *)(a1 + 88) = v12;
  if (v16)
    std::__shared_weak_count::__release_weak(v16);
  *(_QWORD *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  v17 = (char *)operator new(0x98uLL);
  v18 = (std::__shared_weak_count *)v17;
  *(_OWORD *)(v17 + 8) = 0u;
  v19 = (unint64_t *)(v17 + 8);
  *(_QWORD *)v17 = &off_1E14F0D70;
  *((_QWORD *)v17 + 3) = &off_1E14ECD38;
  *((_QWORD *)v17 + 4) = 0;
  *(_OWORD *)(v17 + 40) = 0u;
  *((_QWORD *)v17 + 17) = 0;
  *((_DWORD *)v17 + 36) = 0;
  *(_OWORD *)(v17 + 56) = 0u;
  *((_QWORD *)v17 + 10) = 0;
  *(_OWORD *)(v17 + 88) = 0u;
  *((_DWORD *)v17 + 26) = 0;
  *((_OWORD *)v17 + 7) = 0u;
  *((_WORD *)v17 + 64) = 0;
  *(_QWORD *)&v20 = v17 + 24;
  *((_QWORD *)&v20 + 1) = v17;
  do
    v21 = __ldxr(v19);
  while (__stxr(v21 + 1, v19));
  v22 = (unint64_t *)(v17 + 16);
  do
    v23 = __ldxr(v22);
  while (__stxr(v23 + 1, v22));
  *((_QWORD *)v17 + 4) = v17 + 24;
  *((_QWORD *)v17 + 5) = v17;
  do
    v24 = __ldaxr(v19);
  while (__stlxr(v24 - 1, v19));
  if (!v24)
  {
    v41 = v20;
    (*(void (**)(char *))(*(_QWORD *)v17 + 16))(v17);
    std::__shared_weak_count::__release_weak(v18);
    v20 = v41;
  }
  v25 = *(std::__shared_weak_count **)(a1 + 120);
  *(_OWORD *)(a1 + 112) = v20;
  if (v25)
  {
    p_shared_owners = (unint64_t *)&v25->__shared_owners_;
    do
      v27 = __ldaxr(p_shared_owners);
    while (__stlxr(v27 - 1, p_shared_owners));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  v42 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v6, &v42);
  v28 = (std::__shared_weak_count *)*((_QWORD *)&v42 + 1);
  if (*((_QWORD *)&v42 + 1))
  {
    v29 = (unint64_t *)(*((_QWORD *)&v42 + 1) + 8);
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v42 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v7, &v42);
  v31 = (std::__shared_weak_count *)*((_QWORD *)&v42 + 1);
  if (*((_QWORD *)&v42 + 1))
  {
    v32 = (unint64_t *)(*((_QWORD *)&v42 + 1) + 8);
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_DWORD *)(a1 + 224) = 0x10000;
  *(_QWORD *)(a1 + 232) = 0x3FB999999999999ALL;
  v42 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v8, &v42);
  v34 = (std::__shared_weak_count *)*((_QWORD *)&v42 + 1);
  if (*((_QWORD *)&v42 + 1))
  {
    v35 = (unint64_t *)(*((_QWORD *)&v42 + 1) + 8);
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v42 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v9, &v42);
  v37 = (std::__shared_weak_count *)*((_QWORD *)&v42 + 1);
  if (*((_QWORD *)&v42 + 1))
  {
    v38 = (unint64_t *)(*((_QWORD *)&v42 + 1) + 8);
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
  *(_QWORD *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  return a1;
}

void sub_183F26700(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v4);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v7);
  v9 = (std::__shared_weak_count *)v1[11];
  if (v9)
    std::__shared_weak_count::__release_weak(v9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v6);
  v10 = (std::__shared_weak_count *)v1[6];
  if (v10)
    std::__shared_weak_count::__release_weak(v10);
  v1[3] = &off_1E14E5838;
  v11 = (std::__shared_weak_count *)v1[2];
  if (v11)
    std::__shared_weak_count::__release_weak(v11);
  _Unwind_Resume(a1);
}

void NWIOConnection::~NWIOConnection(NWIOConnection *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  void *v14;
  const void *v15;
  uint64_t v16;
  const void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  std::__shared_weak_count *v25;
  std::__shared_weak_count *v26;

  *(_QWORD *)this = &off_1E14E7088;
  *((_QWORD *)this + 14) = &unk_1E14E7268;
  NWIOConnection::_cleanupConnection((CFMutableDictionaryRef *)this, 0);
  v2 = (const void *)*((_QWORD *)this + 77);
  if (v2)
  {
    _Block_release(v2);
    *((_QWORD *)this + 77) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 78);
  if (v3)
  {
    _Block_release(v3);
    *((_QWORD *)this + 78) = 0;
  }
  v4 = (const void *)*((_QWORD *)this + 79);
  if (v4)
  {
    _Block_release(v4);
    *((_QWORD *)this + 79) = 0;
  }
  v5 = (const void *)*((_QWORD *)this + 80);
  if (v5)
  {
    _Block_release(v5);
    *((_QWORD *)this + 80) = 0;
  }
  v6 = (const void *)*((_QWORD *)this + 81);
  if (v6)
  {
    _Block_release(v6);
    *((_QWORD *)this + 81) = 0;
  }
  v7 = (const void *)*((_QWORD *)this + 82);
  if (v7)
  {
    _Block_release(v7);
    *((_QWORD *)this + 82) = 0;
  }
  v8 = (const void *)*((_QWORD *)this + 84);
  *((_QWORD *)this + 84) = 0;
  if (v8)
    CFRelease(v8);
  v9 = (const void *)*((_QWORD *)this + 83);
  *((_QWORD *)this + 83) = 0;
  if (v9)
    CFRelease(v9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 600);
  v10 = (const void *)*((_QWORD *)this + 73);
  *((_QWORD *)this + 73) = 0;
  if (v10)
    CFRelease(v10);
  v11 = *((_QWORD *)this + 71);
  *((_QWORD *)this + 71) = 0;
  if (v11)
    dispatch_release(v11);
  v12 = *((_QWORD *)this + 70);
  *((_QWORD *)this + 70) = 0;
  if (v12)
    dispatch_release(v12);
  v13 = *((_QWORD *)this + 68);
  *((_QWORD *)this + 68) = 0;
  if (v13)
    dispatch_release(v13);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 512);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 496);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 480);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 464);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 448);
  v14 = (void *)*((_QWORD *)this + 55);
  *((_QWORD *)this + 55) = 0;
  if (v14)
    sec_release(v14);
  v15 = (const void *)*((_QWORD *)this + 54);
  *((_QWORD *)this + 54) = 0;
  if (v15)
    CFRelease(v15);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 416);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 400);
  v16 = *((_QWORD *)this + 49);
  *((_QWORD *)this + 49) = 0;
  if (v16)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
  v17 = (const void *)*((_QWORD *)this + 46);
  *((_QWORD *)this + 46) = 0;
  if (v17)
    CFRelease(v17);
  v18 = (void *)*((_QWORD *)this + 45);
  *((_QWORD *)this + 45) = 0;
  if (v18)
    nw_release(v18);
  v19 = (void *)*((_QWORD *)this + 44);
  *((_QWORD *)this + 44) = 0;
  if (v19)
    nw_release(v19);
  v20 = (void *)*((_QWORD *)this + 43);
  *((_QWORD *)this + 43) = 0;
  if (v20)
    nw_release(v20);
  v21 = (void *)*((_QWORD *)this + 42);
  *((_QWORD *)this + 42) = 0;
  if (v21)
    nw_release(v21);
  v22 = (void *)*((_QWORD *)this + 41);
  *((_QWORD *)this + 41) = 0;
  if (v22)
    nw_release(v22);
  v23 = (void *)*((_QWORD *)this + 38);
  *((_QWORD *)this + 38) = 0;
  if (v23)
    nw_release(v23);
  v24 = (void *)*((_QWORD *)this + 37);
  *((_QWORD *)this + 37) = 0;
  if (v24)
    nw_release(v24);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 272);
  v25 = (std::__shared_weak_count *)*((_QWORD *)this + 33);
  if (v25)
    std::__shared_weak_count::__release_weak(v25);
  TransportConnection::~TransportConnection((TransportConnection *)this);
  v26 = (std::__shared_weak_count *)*((_QWORD *)this + 30);
  if (v26)
    std::__shared_weak_count::__release_weak(v26);
}

{
  NWIOConnection::~NWIOConnection(this);
  JUMPOUT(0x186DB748CLL);
}

void sub_183F2698C(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;
  const void *v4;
  const void *v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  void *v9;
  const void *v10;
  uint64_t v11;
  const void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  std::__shared_weak_count *v20;
  std::__shared_weak_count *v21;

  v3 = *(const void **)(v1 + 672);
  *(_QWORD *)(v1 + 672) = 0;
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(v1 + 664);
  *(_QWORD *)(v1 + 664) = 0;
  if (v4)
    CFRelease(v4);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 600);
  v5 = *(const void **)(v1 + 584);
  *(_QWORD *)(v1 + 584) = 0;
  if (v5)
    CFRelease(v5);
  v6 = *(NSObject **)(v1 + 568);
  *(_QWORD *)(v1 + 568) = 0;
  if (v6)
    dispatch_release(v6);
  v7 = *(NSObject **)(v1 + 560);
  *(_QWORD *)(v1 + 560) = 0;
  if (v7)
    dispatch_release(v7);
  v8 = *(NSObject **)(v1 + 544);
  *(_QWORD *)(v1 + 544) = 0;
  if (v8)
    dispatch_release(v8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 512);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 496);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 480);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 464);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 448);
  v9 = *(void **)(v1 + 440);
  *(_QWORD *)(v1 + 440) = 0;
  if (v9)
    sec_release(v9);
  v10 = *(const void **)(v1 + 432);
  *(_QWORD *)(v1 + 432) = 0;
  if (v10)
    CFRelease(v10);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 416);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 400);
  v11 = *(_QWORD *)(v1 + 392);
  *(_QWORD *)(v1 + 392) = 0;
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
  v12 = *(const void **)(v1 + 368);
  *(_QWORD *)(v1 + 368) = 0;
  if (v12)
    CFRelease(v12);
  v13 = *(void **)(v1 + 360);
  *(_QWORD *)(v1 + 360) = 0;
  if (v13)
    nw_release(v13);
  v14 = *(void **)(v1 + 352);
  *(_QWORD *)(v1 + 352) = 0;
  if (v14)
    nw_release(v14);
  v15 = *(void **)(v1 + 344);
  *(_QWORD *)(v1 + 344) = 0;
  if (v15)
    nw_release(v15);
  v16 = *(void **)(v1 + 336);
  *(_QWORD *)(v1 + 336) = 0;
  if (v16)
    nw_release(v16);
  v17 = *(void **)(v1 + 328);
  *(_QWORD *)(v1 + 328) = 0;
  if (v17)
    nw_release(v17);
  v18 = *(void **)(v1 + 304);
  *(_QWORD *)(v1 + 304) = 0;
  if (v18)
    nw_release(v18);
  v19 = *(void **)(v1 + 296);
  *(_QWORD *)(v1 + 296) = 0;
  if (v19)
    nw_release(v19);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 272);
  v20 = *(std::__shared_weak_count **)(v1 + 264);
  if (v20)
    std::__shared_weak_count::__release_weak(v20);
  TransportConnection::~TransportConnection((TransportConnection *)v1);
  v21 = *(std::__shared_weak_count **)(v1 + 240);
  if (v21)
    std::__shared_weak_count::__release_weak(v21);
  _Unwind_Resume(a1);
}

void TransportConnection::~TransportConnection(TransportConnection *this)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = off_1E14EA660;
  *((_QWORD *)this + 14) = &unk_1E14EA840;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 27);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  v3 = *((_QWORD *)this + 24);
  *((_QWORD *)this + 24) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 176);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 160);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 144);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 120);
  v4 = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = 0;
  if (v4)
    (*((void (**)(void))this + 12))();
  std::mutex::~mutex((std::mutex *)((char *)this + 24));
  std::unique_ptr<std::map<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>,CFStringRefComp,std::allocator<std::pair<std::unique_ptr<__CFString const,void (*)(__CFString const*)> const,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>>::reset[abi:nn180100]((uint64_t *)this + 2, 0);
  WeakTracker<TransportConnection>::~WeakTracker((unint64_t *)this + 1);
  *(_QWORD *)this = &off_1E14E5838;
}

void sub_183F26BE0(_Unwind_Exception *a1)
{
  _QWORD *v1;
  std::__shared_weak_count *v3;
  uint64_t v4;

  v3 = (std::__shared_weak_count *)v1[27];
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  v4 = v1[24];
  v1[24] = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 22));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 20));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 18));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 15));
  NotificationStation::~NotificationStation((NotificationStation *)(v1 + 2));
  WeakTracker<TransportConnection>::~WeakTracker(v1 + 1);
  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void ConnectionEPTManager::~ConnectionEPTManager(ConnectionEPTManager *this)
{
  ConnectionEPTManager::~ConnectionEPTManager(this);
  JUMPOUT(0x186DB748CLL);
}

{
  const void *v2;

  *(_QWORD *)this = &off_1E14EB358;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
  {
    _Block_release(v2);
    *((_QWORD *)this + 1) = 0;
  }

  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E14E5838;
}

void sub_183F26CC8(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

unint64_t *WeakTracker<TransportConnection>::~WeakTracker(unint64_t *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;

  os_unfair_lock_lock((os_unfair_lock_t)&WeakTracker<TransportConnection>::_lock);
  if (WeakTracker<TransportConnection>::_trackedObjects(void)::onceToken != -1)
    dispatch_once(&WeakTracker<TransportConnection>::_trackedObjects(void)::onceToken, &__block_literal_global_3530);
  v2 = (_QWORD *)WeakTracker<TransportConnection>::_trackedObjects(void)::trackedObjects;
  v3 = std::__hash_table<std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>>>::find<unsigned long long>((_QWORD *)WeakTracker<TransportConnection>::_trackedObjects(void)::trackedObjects, *a1);
  if (v3)
  {
    v4 = (int8x8_t)v2[1];
    v5 = v3[1];
    v6 = (uint8x8_t)vcnt_s8(v4);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      if (v5 >= *(_QWORD *)&v4)
        v5 %= *(_QWORD *)&v4;
    }
    else
    {
      v5 &= *(_QWORD *)&v4 - 1;
    }
    v7 = *(_QWORD **)(*v2 + 8 * v5);
    do
    {
      v8 = v7;
      v7 = (_QWORD *)*v7;
    }
    while (v7 != v3);
    if (v8 == v2 + 2)
      goto LABEL_21;
    v9 = v8[1];
    if (v6.u32[0] > 1uLL)
    {
      if (v9 >= *(_QWORD *)&v4)
        v9 %= *(_QWORD *)&v4;
    }
    else
    {
      v9 &= *(_QWORD *)&v4 - 1;
    }
    if (v9 != v5)
    {
LABEL_21:
      if (!*v3)
        goto LABEL_22;
      v10 = *(_QWORD *)(*v3 + 8);
      if (v6.u32[0] > 1uLL)
      {
        if (v10 >= *(_QWORD *)&v4)
          v10 %= *(_QWORD *)&v4;
      }
      else
      {
        v10 &= *(_QWORD *)&v4 - 1;
      }
      if (v10 != v5)
LABEL_22:
        *(_QWORD *)(*v2 + 8 * v5) = 0;
    }
    v11 = *v3;
    if (*v3)
    {
      v12 = *(_QWORD *)(v11 + 8);
      if (v6.u32[0] > 1uLL)
      {
        if (v12 >= *(_QWORD *)&v4)
          v12 %= *(_QWORD *)&v4;
      }
      else
      {
        v12 &= *(_QWORD *)&v4 - 1;
      }
      if (v12 != v5)
      {
        *(_QWORD *)(*v2 + 8 * v12) = v8;
        v11 = *v3;
      }
    }
    *v8 = v11;
    *v3 = 0;
    --v2[3];
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::weak_ptr<TransportConnection>>,void *>>>::operator()[abi:nn180100](1, v3);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&WeakTracker<TransportConnection>::_lock);
  return a1;
}

void CFTypeRefRelease<__CFSet const*>(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

double URLResponse::getLastModifiedDate(URLResponse *this)
{
  HTTPResponse *fHTTP;
  const __CFString *v3;
  HTTPResponse *v4;
  int v5;
  unsigned int v6;
  const __CFString *v7;
  double *p_fCreationTime;
  unsigned __int8 v10;

  fHTTP = this->fHTTP;
  if (fHTTP)
  {
    if ((*(_WORD *)((char *)fHTTP + 297) & 0x40) == 0)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v3 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)fHTTP, 0x12C1B320u);
      *(_WORD *)((char *)this->fHTTP + 297) |= 0x40u;
      v4 = this->fHTTP;
      v5 = *(unsigned __int16 *)((char *)v4 + 297);
      v6 = v5 & 0xFFFFFFFB | (*((unsigned __int8 *)v4 + 299) << 16);
      *(_WORD *)((char *)v4 + 297) = v5 & 0xFFFB;
      *((_BYTE *)v4 + 299) = BYTE2(v6);
      fHTTP = this->fHTTP;
      if (v3)
      {
        v7 = v3;
        v10 = 0;
        *((double *)fHTTP + 38) = dateFromString(v3, &v10);
        CFRelease(v7);
        if (v10)
          *(_WORD *)((char *)this->fHTTP + 297) |= 4u;
        fHTTP = this->fHTTP;
      }
    }
    p_fCreationTime = (double *)((char *)fHTTP + 304);
  }
  else
  {
    p_fCreationTime = &this->fCreationTime;
  }
  return *p_fCreationTime;
}

void std::__shared_ptr_pointer<__CFArray const*,Deleter_CFRelease,std::allocator<__CFArray const>>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 24);
  if (v1)
    CFRelease(v1);
}

__CFDictionary *HTTPProtocol::copyVaryState(HTTPProtocol *this, const __CFString *a2, void *cf, const _CFURLRequest *a4)
{
  const __CFAllocator *v6;
  __CFDictionary *Mutable;
  const __CFAllocator *v8;
  CFArrayRef ArrayBySeparatingStrings;
  const __CFArray *v10;
  unint64_t Count;
  CFRange v12;
  const void **v13;
  CFIndex v14;
  const __CFString *v15;
  const __CFAllocator *v16;
  CFMutableStringRef MutableCopy;
  HTTPMessage *v18;
  CFStringRef v19;
  NSURLSessionTask *v20;
  uint64_t v21;
  NSObject *v22;
  dispatch_time_t v23;
  const __CFDictionary *v24;
  const void *Value;
  CFTypeRef v28;
  CFIndex range;
  const void **v30;
  _BYTE v31[248];
  CFIndex v32;
  _QWORD v33[6];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  CFRange v38;
  CFRange v39;

  v6 = CFGetAllocator(cf);
  Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v8 = CFGetAllocator(cf);
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v8, a2, CFSTR(","));
  if (!ArrayBySeparatingStrings)
    return Mutable;
  v10 = ArrayBySeparatingStrings;
  v28 = CFRetain(ArrayBySeparatingStrings);
  Count = CFArrayGetCount(v10);
  v12.length = Count;
  range = Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v30 = 0;
  }
  else
  {
    if (Count <= 0x1E)
    {
      v13 = (const void **)v31;
      v30 = (const void **)v31;
LABEL_7:
      v12.location = 0;
      CFArrayGetValues(v10, v12, v13);
      v12.length = range;
      goto LABEL_8;
    }
    v13 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
    v30 = v13;
    v12.length = range;
    if (v13)
      goto LABEL_7;
  }
LABEL_8:
  v32 = 0;
  if (v12.length >= 1)
  {
    v14 = 0;
    do
    {
      v32 = v14 + 1;
      v15 = (const __CFString *)v30[v14];
      v16 = CFGetAllocator(v15);
      MutableCopy = CFStringCreateMutableCopy(v16, 0, v15);
      CFStringTrimWhitespace(MutableCopy);
      v18 = *(HTTPMessage **)(objc_msgSend(cf, "_inner") + 56);
      if (v18 && (v19 = HTTPMessage::copyHeaderFieldValue(v18, MutableCopy)) != 0)
      {
        CFDictionarySetValue(Mutable, MutableCopy, v19);
        CFRelease(v19);
      }
      else
      {
        v38.length = CFStringGetLength(MutableCopy);
        v38.location = 0;
        if (CFStringCompareWithOptions(MutableCopy, (CFStringRef)&unk_1EDCFCF28, v38, 1uLL))
        {
          v39.length = CFStringGetLength(MutableCopy);
          v39.location = 0;
          if (CFStringCompareWithOptions(MutableCopy, (CFStringRef)&unk_1EDCFCBA8, v39, 1uLL) == kCFCompareEqualTo)
            CFDictionarySetValue(Mutable, MutableCopy, CFSTR("gzip, deflate"));
        }
        else
        {
          v20 = -[NSURLSessionTask initWithOriginalRequest:ident:taskGroup:]([NSURLSessionTask alloc], "initWithOriginalRequest:ident:taskGroup:", cf, 0, -[HTTPProtocol defaultTaskGroup](this, "defaultTaskGroup"));
          v21 = -[NSURLSessionTask session](v20, "session");
          v34 = 0;
          v35 = &v34;
          v36 = 0x2020000000;
          v37 = 0;
          if (v21)
          {
            v22 = dispatch_semaphore_create(0);
            v33[0] = MEMORY[0x1E0C809B0];
            v33[1] = 3221225472;
            v33[2] = ___ZN12HTTPProtocol22copyCookiesForThisTaskEP16NSURLSessionTask_block_invoke;
            v33[3] = &unk_1E14F9D30;
            v33[4] = v22;
            v33[5] = &v34;
            -[__NSURLSessionLocal _getCookieHeadersForTask:completionHandler:](v21, v20, (uint64_t)v33);
            v23 = dispatch_time(0, 2000000000);
            dispatch_semaphore_wait(v22, v23);
            dispatch_release(v22);
            v24 = (const __CFDictionary *)v35[3];
          }
          else
          {
            v24 = 0;
          }
          _Block_object_dispose(&v34, 8);

          if (v24)
          {
            Value = CFDictionaryGetValue(v24, &unk_1EDCFCF28);
            if (Value)
              CFDictionarySetValue(Mutable, &unk_1EDCFCF28, Value);
            CFRelease(v24);
          }
        }
      }
      if (MutableCopy)
        CFRelease(MutableCopy);
      v14 = v32;
    }
    while (v32 < range);
  }
  CFRelease(v10);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v28);
  return Mutable;
}

void sub_183F272F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

void NWIOConnection::close(TransportConnection *this, char a2)
{
  TransportConnection::rstConnectionEstablishmentDelegate(this);
  TransportConnection::rstConnectionDelegate(this);
  if ((*((_DWORD *)this + 34) - 3) <= 1 && !NWIOConnection::_isQUICTransport((NWIOConnection *)this))
    (*(void (**)(TransportConnection *))(*(_QWORD *)this + 144))(this);
  NWIOConnection::_cleanupConnection((CFMutableDictionaryRef *)this, a2);
}

BOOL StrictSecurityPolicy::isATSCompliantCipher(StrictSecurityPolicy *this)
{
  unsigned int v1;
  unint64_t v2;
  uint8x8_t v3;
  unint64_t v4;
  uint64_t **i;
  unint64_t v6;

  v1 = this;
  if (StrictSecurityPolicy::isATSCompliantCipher(unsigned short)::onceToken != -1)
    dispatch_once(&StrictSecurityPolicy::isATSCompliantCipher(unsigned short)::onceToken, &__block_literal_global_38);
  v2 = *(_QWORD *)(StrictSecurityPolicy::isATSCompliantCipher(unsigned short)::compliantCiphers + 8);
  if (v2)
  {
    v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      v4 = v1;
      if (v2 <= v1)
        v4 = v1 % v2;
    }
    else
    {
      v4 = ((_DWORD)v2 - 1) & v1;
    }
    i = *(uint64_t ***)(*(_QWORD *)StrictSecurityPolicy::isATSCompliantCipher(unsigned short)::compliantCiphers + 8 * v4);
    if (i)
    {
      for (i = (uint64_t **)*i; i; i = (uint64_t **)*i)
      {
        v6 = (unint64_t)i[1];
        if (v6 == v1)
        {
          if (*((unsigned __int16 *)i + 8) == v1)
            return i != 0;
        }
        else
        {
          if (v3.u32[0] > 1uLL)
          {
            if (v6 >= v2)
              v6 %= v2;
          }
          else
          {
            v6 &= v2 - 1;
          }
          if (v6 != v4)
            goto LABEL_20;
        }
      }
    }
  }
  else
  {
LABEL_20:
    i = 0;
  }
  return i != 0;
}

uint64_t HTTPEngine::_readUpdateLargeDownloadSettings(uint64_t this)
{
  int v1;
  _QWORD *v2;

  v1 = *(_DWORD *)(this + 32);
  if ((v1 & 0x80000) == 0)
  {
    *(_DWORD *)(this + 32) = v1 & 0xFFEFFFFF;
    this = *(_QWORD *)(this + 56);
    if (!this)
      return this;
    v2 = (_QWORD *)MEMORY[0x1E0C9AE40];
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)this + 200))(this, 0x1EDCFA5D0, *v2);
  }
  if ((v1 & 0x2000) == 0 && (v1 & 0x100000) == 0 && *(uint64_t *)(this + 176) > 0x4000)
  {
    *(_DWORD *)(this + 32) = v1 | 0x100000;
    this = *(_QWORD *)(this + 56);
    if (this)
    {
      v2 = (_QWORD *)MEMORY[0x1E0C9AE50];
      return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)this + 200))(this, 0x1EDCFA5D0, *v2);
    }
  }
  return this;
}

__int128 *HTTPConnectionCacheEntry::RequestQueue::removeRequest(HTTPConnectionCacheEntry::RequestQueue *this, uint64_t a2)
{
  __int128 *v3;
  __int128 *v4;
  __int128 *result;
  uint64_t v6;

  v3 = (__int128 *)*((_QWORD *)this + 3);
  v4 = (__int128 *)(*((_QWORD *)this + 2) + 16 * a2);
  result = v4 + 1;
  if (v4 + 1 != v3)
  {
    do
      v6 = (uint64_t)v4++;
    while ((__int128 *)(std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v6, v4) + 32) != v3);
    result = (__int128 *)*((_QWORD *)this + 3);
  }
  while (result != v4)
    result = (__int128 *)std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(result - 1));
  *((_QWORD *)this + 3) = v4;
  return result;
}

void sub_183F27A8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;

  _Unwind_Resume(a1);
}

void ___ZN11HTTP3Framer10writeFrameEN2H39FrameTypeEPU27objcproto16OS_dispatch_data8NSObjectbU13block_pointerFvm13CFStreamErrorE_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v5;
  NSObject *v7;
  nw_protocol_metadata_t v8;
  void *v9;
  uint64_t id;
  uint64_t v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  if (*(_BYTE *)(a1 + 64))
  {
    v5 = *(NSObject **)(a1 + 32);
    if (v5 && a3 == 0)
    {
      v7 = nw_protocol_copy_quic_connection_definition();
      v8 = nw_content_context_copy_protocol_metadata(v5, v7);

      v9 = (void *)nw_quic_connection_copy_stream_metadata();
      id = nw_quic_stream_get_id();
      if ((id & 3) != 2 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        v11 = *(_QWORD *)(a1 + 56);
        v12 = 134218240;
        v13 = v11;
        v14 = 2048;
        v15 = id;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Connection %llu: Not unidirectional outbound stream %llu", (uint8_t *)&v12, 0x16u);
      }

    }
  }
}

void sub_183F27CDC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZN12__CFURLCache23CreateAndStoreCacheNodeEP16__CFURLCacheNodePK20_CFCachedURLResponsePK10__CFStringPK13_CFURLRequestPKvbRb_block_invoke(uint64_t a1)
{
  uint64_t v2;
  CFAllocatorRef *v3;
  uint64_t v4;
  void *v5;
  os_unfair_lock_s *v6;
  const char *v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  id v18;
  const __CFString *v19;
  BOOL v20;
  const char *v21;
  _QWORD *v22;
  uint64_t v23;
  const __CFData *v24;
  const __CFData *v25;
  const void *v26;
  void *v27;
  CFDictionaryRef v28;
  const __CFData *Data;
  const __CFData *v30;
  char *v31;
  uint64_t v32;
  os_unfair_lock_s *v33;
  void *v34;
  const char *v35;
  URLRequest *v36;
  void **v37;
  const void *v38;
  const void *v39;
  CFIndex v40;
  CFIndex v41;
  unint64_t v42;
  CFArrayRef v43;
  __CFString *v44;
  CFDictionaryRef v45;
  const __CFData *v46;
  const __CFData *v47;
  CFURLCacheFS *v48;
  const __CFData *v49;
  const __CFData *v50;
  const __CFString *Value;
  sqlite3_stmt *v52;
  CFURLCacheFS *v53;
  const char *v54;
  void *v55;
  unint64_t v56;
  char *CStringfromCFStringRef;
  int v58;
  sqlite3_int64 insert_rowid;
  sqlite3_stmt *v60;
  int v61;
  int v62;
  int v63;
  CFURLCacheFS *v64;
  _BOOL4 v65;
  const char *v66;
  sqlite3_stmt *v67;
  const UInt8 *v68;
  _BYTE *v69;
  sqlite3_stmt *v70;
  char *v71;
  int v72;
  id v73;
  void *v74;
  const __CFUUID *v75;
  uint64_t v76;
  const __CFString *v77;
  sqlite3_stmt *v78;
  const UInt8 *v79;
  const UInt8 *v80;
  _BOOL4 v81;
  sqlite3_stmt *v82;
  BOOL v83;
  _BOOL4 v84;
  int v85;
  uint64_t v86;
  void *v87;
  char *v88;
  uint64_t v89;
  CFTypeRef v90;
  dispatch_block_t v91;
  dispatch_time_t v92;
  char *v93;
  uint64_t v94;
  sqlite3_stmt *v95;
  const char *v96;
  const __CFString *v97;
  __CFString *v98;
  CFURLCacheFS *FS2;
  uint64_t v100;
  const __CFString *v101;
  int v102;
  id v103;
  void *v104;
  const UInt8 *v105;
  sqlite3_stmt *v106;
  const UInt8 *v107;
  uint64_t v108;
  const __CFUUID *v109;
  const __CFString *v110;
  const __CFString *v111;
  uint64_t v112;
  uint64_t v113;
  const __CFString *v114;
  char *v115;
  sqlite3_stmt *v116;
  int v117;
  sqlite3_stmt *v118;
  int v119;
  int v120;
  sqlite3_stmt *v121;
  int v122;
  uint64_t v123;
  uint64_t v124;
  os_unfair_lock_s *v125;
  CFURLCacheFS *v126;
  id Property;
  const __CFAllocator *contentsDeallocator;
  uint64_t v129;
  const UInt8 *v130;
  int Length;
  const UInt8 *v132;
  const UInt8 *v133;
  const UInt8 *BytePtr;
  uint64_t v135;
  CFIndex v136;
  int v137;
  sqlite3_int64 v138;
  CFIndex v139;
  _CFCachedURLResponse *FS3;
  int n[2];
  CFStringRef na;
  _CFCachedURLResponse *nb;
  char *cf;
  CFStringRef cfa;
  const char *v146;
  char *v147;
  const __CFData *theData;
  const __CFAllocator *allocator;
  CFURLCacheFS *v150;
  uint64_t v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  CFPropertyListRef plist;
  BOOL v157;
  uint64_t valuePtr;
  void **values;
  CFIndex numValues;
  _BYTE v161[128];
  void *v162[2];
  void *keys;
  uint64_t v164;
  void (*v165)(_QWORD *);
  void *v166;
  uint64_t v167;
  uint64_t v168;
  CFTypeRef v169;
  uint64_t v170;

  v170 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 16);
  v3 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (v2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 552));
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 16);
    v5 = *(void **)(v4 + 536);
    *(_QWORD *)(v4 + 544) = v5;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 16) + 536) = CFDictionaryCreateMutable(*v3, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    pthread_mutex_unlock((pthread_mutex_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 16) + 552));
  }
  else
  {
    v5 = 0;
  }
  if (objc_msgSend(v5, "count"))
  {
    __retainStorageAssertion(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 16) + 136));
    v6 = *(os_unfair_lock_s **)(a1 + 32);
    if (v6)
    {
      os_unfair_lock_lock(v6 + 7);
      v8 = *(_QWORD *)(a1 + 32);
      if (v8)
      {
        -[NSURLStorageURLCacheDB openAndPrepareWriteCacheDB_NoLock](*(id *)(a1 + 32), v7);
        -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:](v8, "BEGIN IMMEDIATE TRANSACTION;",
          *(sqlite3 **)(v8 + 16),
          1);
      }
    }
    v154 = 0u;
    v155 = 0u;
    v152 = 0u;
    v153 = 0u;
    v10 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v152, v161, 16);
    if (v10)
    {
      v151 = *(_QWORD *)v153;
      allocator = *v3;
      contentsDeallocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
      do
      {
        v12 = 0;
        v129 = v10;
        do
        {
          if (*(_QWORD *)v153 != v151)
            objc_enumerationMutation(v5);
          v13 = *(void **)(*((_QWORD *)&v152 + 1) + 8 * v12);
          v14 = *(_QWORD *)(a1 + 32);
          v15 = objc_msgSend(v5, "objectForKeyedSubscript:", v13, v126, Property);
          v16 = *(_QWORD *)(a1 + 40);
          v18 = v13;
          if (v14)
          {
            v157 = 0;
            if (*(uint64_t *)(v14 + 176) >= 1)
            {
              if (-[NSURLStorageURLCacheDB openAndPrepareWriteCacheDB_NoLock]((id)v14, v17))
              {
                v19 = (const __CFString *)v18;
                v150 = (CFURLCacheFS *)v19;
                if (!v15 || (v19 ? (v20 = *(_QWORD *)(v15 + 16) == 0) : (v20 = 1), v20))
                {
                  v21 = 0;
                  v22 = 0;
                  goto LABEL_84;
                }
                v135 = v16;
                v146 = _ExtractCStringfromCFStringRef(v19, &v157);
                v23 = *(_QWORD *)(v15 + 16);
                v138 = *(_QWORD *)(v23 + 64);
                v137 = *(_DWORD *)(v23 + 56);
                v24 = *(const __CFData **)(v23 + 48);
                if (v24)
                {
                  Length = CFDataGetLength(v24);
                  v23 = *(_QWORD *)(v15 + 16);
                  v25 = *(const __CFData **)(v23 + 48);
                  if (v25)
                  {
                    BytePtr = CFDataGetBytePtr(v25);
                    v23 = *(_QWORD *)(v15 + 16);
                    goto LABEL_28;
                  }
                }
                else
                {
                  Length = 0;
                }
                BytePtr = 0;
LABEL_28:
                os_unfair_lock_lock((os_unfair_lock_t)(v23 + 88));
                v26 = *(const void **)(v23 + 72);
                if (v26)
                  theData = (const __CFData *)CFRetain(v26);
                else
                  theData = CopyAllDataFromDataArray(*(const __CFArray **)(v23 + 80));
                os_unfair_lock_unlock((os_unfair_lock_t)(v23 + 88));
                if (theData)
                {
                  cf = (char *)CFDataGetLength(theData);
                  CFAutorelease(theData);
                }
                else
                {
                  cf = 0;
                }
                v27 = *(void **)(*(_QWORD *)(v15 + 16) + 32);
                if (v27)
                {
                  v28 = URLResponse::copyPropertyList((URLResponse *)objc_msgSend(v27, "_inner"), allocator);
                  Data = CFPropertyListCreateData(allocator, v28, kCFPropertyListBinaryFormat_v1_0, 0, 0);
                  v30 = Data;
                  if (Data)
                  {
                    v133 = CFDataGetBytePtr(Data);
                    *(_QWORD *)n = CFDataGetLength(v30);
                    CFAutorelease(v30);
                    v31 = &cf[*(_QWORD *)n];
                  }
                  else
                  {
                    v133 = 0;
                    n[0] = 0;
                    v31 = cf;
                  }
                  v147 = v31;
                  if (v28)
                    CFRelease(v28);
                }
                else
                {
                  v133 = 0;
                  n[0] = 0;
                  v147 = cf;
                }
                v32 = *(_QWORD *)(v15 + 16);
                v33 = (os_unfair_lock_s *)(v32 + 88);
                os_unfair_lock_lock((os_unfair_lock_t)(v32 + 88));
                v34 = *(void **)(v32 + 112);
                os_unfair_lock_unlock(v33);
                plist = 0;
                if (v34)
                {
                  v36 = (URLRequest *)objc_msgSend(v34, "_inner");
                  values = 0;
                  numValues = 0;
                  valuePtr = 0;
                  URLRequest::createArchiveList(v36, allocator, &valuePtr, (const void ***)&values, &numValues, (const __CFDictionary **)&plist);
                  v37 = values;
                  v38 = values[1];
                  if (v38)
                  {
                    v37[1] = (void *)_CFURLCopyPropertyListRepresentation();
                    CFRelease(v38);
                  }
                  v39 = v37[4];
                  if (v39)
                  {
                    v37[4] = (void *)_CFURLCopyPropertyListRepresentation();
                    CFRelease(v39);
                  }
                  v40 = numValues;
                  v41 = numValues - 1;
                  if (numValues < 1)
                  {
                    v43 = CFArrayCreate(allocator, (const void **)v37, numValues, MEMORY[0x1E0C9B378]);
                  }
                  else
                  {
                    do
                    {
                      if (!v37[v41])
                        v37[v41] = CFSTR("__CFURLRequestNullTokenString__");
                      v42 = v41-- + 1;
                    }
                    while (v42 > 1);
                    v43 = CFArrayCreate(allocator, (const void **)v37, v40, MEMORY[0x1E0C9B378]);
                    do
                    {
                      v44 = (__CFString *)v37[v40 - 1];
                      if (v44 != CFSTR("__CFURLRequestNullTokenString__"))
                        CFRelease(v44);
                      --v40;
                    }
                    while ((unint64_t)(v40 + 1) > 1);
                    v10 = v129;
                  }
                  CFAllocatorDeallocate(allocator, v37);
                  if (CFPropertyListIsValid(v43, kCFPropertyListXMLFormat_v1_0))
                  {
                    if (v43)
                    {
                      keys = CFSTR("Version");
                      v164 = (uint64_t)CFSTR("Array");
                      v162[0] = CFNumberCreate(allocator, kCFNumberCFIndexType, &valuePtr);
                      v162[1] = v43;
                      v45 = CFDictionaryCreate(allocator, (const void **)&keys, (const void **)v162, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                      CFRelease(v162[0]);
                      CFRelease(v43);
                      goto LABEL_62;
                    }
                  }
                  else
                  {
                    CFRelease(v43);
                  }
                  v45 = 0;
LABEL_62:
                  v46 = CFPropertyListCreateData(allocator, v45, kCFPropertyListBinaryFormat_v1_0, 0, 0);
                  v47 = v46;
                  if (v46)
                  {
                    v132 = CFDataGetBytePtr(v46);
                    v139 = CFDataGetLength(v47);
                    CFAutorelease(v47);
                    v147 += v139;
                    if (!v45)
                    {
LABEL_67:
                      v48 = (CFURLCacheFS *)plist;
                      if (plist)
                      {
                        if (!CFPropertyListIsValid(plist, kCFPropertyListBinaryFormat_v1_0))
                        {
                          v126 = v48;
                          CFLog();
                          goto LABEL_82;
                        }
                        v49 = CFPropertyListCreateData(allocator, v48, kCFPropertyListBinaryFormat_v1_0, 0, 0);
                        v50 = v49;
                        if (v49)
                        {
                          v130 = CFDataGetBytePtr(v49);
                          v136 = CFDataGetLength(v50);
                          CFAutorelease(v50);
                          v147 += v136;
                        }
                        else
                        {
                          v130 = 0;
                          v136 = 0;
                        }
                        Value = (const __CFString *)CFDictionaryGetValue(v48, CFSTR("_kCFURLCachePartitionKey"));
                        CFRelease(v48);
LABEL_75:
                        v52 = *(sqlite3_stmt **)(v14 + 40);
                        if (!v52)
                        {
                          v126 = *(CFURLCacheFS **)(v14 + 16);
                          Property = objc_getProperty((id)v14, v35, 160, 1);
                          CFLog();
                          goto LABEL_82;
                        }
                        v53 = (CFURLCacheFS *)sqlite3_bind_int(v52, 1, 0);
                        if ((_DWORD)v53)
                        {
                          v126 = v53;
                          Property = v150;
                          CFLog();
                          goto LABEL_82;
                        }
                        if (sqlite3_bind_int64(*(sqlite3_stmt **)(v14 + 40), 2, v138)
                          || sqlite3_bind_int(*(sqlite3_stmt **)(v14 + 40), 3, v137)
                          || !v146
                          || sqlite3_bind_text(*(sqlite3_stmt **)(v14 + 40), 4, v146, -1, 0))
                        {
LABEL_81:
                          v126 = v150;
                          CFLog();
                          goto LABEL_82;
                        }
                        if (Value)
                        {
                          LOBYTE(keys) = 0;
                          CStringfromCFStringRef = _ExtractCStringfromCFStringRef(Value, (BOOL *)&keys);
                          if (CStringfromCFStringRef)
                          {
                            if (sqlite3_bind_text(*(sqlite3_stmt **)(v14 + 40), 5, CStringfromCFStringRef, -1, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL))
                            {
                              if ((_BYTE)keys)
                                MEMORY[0x186DB7474](CStringfromCFStringRef, 0x1000C8077774924);
                              goto LABEL_81;
                            }
                            if ((_BYTE)keys)
                              MEMORY[0x186DB7474](CStringfromCFStringRef, 0x1000C8077774924);
                          }
                        }
                        else if (sqlite3_bind_text(*(sqlite3_stmt **)(v14 + 40), 5, 0, 0, 0))
                        {
                          goto LABEL_81;
                        }
                        v58 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]((void *)v14, *(sqlite3_stmt **)(v14 + 40));
                        sqlite3_reset(*(sqlite3_stmt **)(v14 + 40));
                        if (v58)
                        {
                          if (v58 != 19)
                          {
                            if (v58 == 101)
                              goto LABEL_113;
LABEL_82:
                            v22 = 0;
LABEL_83:
                            v21 = v146;
LABEL_84:
                            sqlite3_reset(*(sqlite3_stmt **)(v14 + 40));
                            sqlite3_reset(*(sqlite3_stmt **)(v14 + 48));
                            sqlite3_reset(*(sqlite3_stmt **)(v14 + 56));
                            sqlite3_reset(*(sqlite3_stmt **)(v14 + 72));
                            sqlite3_reset(*(sqlite3_stmt **)(v14 + 32));
                            sqlite3_reset(*(sqlite3_stmt **)(v14 + 64));
                            if (v21 && v157)
                              MEMORY[0x186DB7474](v21, 0x1000C8077774924);
                            if (v150)

                            if (v22)
                            {
                              v55 = (void *)v22[1];
                              if (v55)
                                free(v55);
                              free(v22);
                            }
                            v56 = *(_QWORD *)(v14 + 144) + 1;
                            *(_QWORD *)(v14 + 144) = v56;
                            if (v56 >= 0xBB9)
                            {
                              *(_QWORD *)(v14 + 144) = 0;
                              -[NSURLStorageURLCacheDB updateFSBackedCacheUsageOnDisk]((_QWORD *)v14, v54);
                              -[NSURLStorageURLCacheDB updateSQLiteDBCacheUsageOnDisk]((_QWORD *)v14);
                            }
                            goto LABEL_95;
                          }
                          v69 = -[NSURLStorageURLCacheDB getEntryIDandReceiverDataForRequestKey:]((sqlite3_stmt **)v14, v146);
                          v22 = v69;
                          if (!v69 || !*(_QWORD *)v69)
                            goto LABEL_83;
                          v70 = *(sqlite3_stmt **)(v14 + 64);
                          if (v70)
                          {
                            if (sqlite3_bind_int(v70, 1, 0)
                              || sqlite3_bind_int(*(sqlite3_stmt **)(v14 + 64), 2, v138)
                              || sqlite3_bind_int(*(sqlite3_stmt **)(v14 + 64), 3, v137))
                            {
                              goto LABEL_83;
                            }
                            if (Value)
                            {
                              LOBYTE(keys) = 0;
                              v71 = _ExtractCStringfromCFStringRef(Value, (BOOL *)&keys);
                              if (v71)
                              {
                                if (sqlite3_bind_text(*(sqlite3_stmt **)(v14 + 64), 4, v71, -1, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL))
                                {
                                  if ((_BYTE)keys)
                                    MEMORY[0x186DB7474](v71, 0x1000C8077774924);
                                  goto LABEL_83;
                                }
                                if ((_BYTE)keys)
                                  MEMORY[0x186DB7474](v71, 0x1000C8077774924);
                              }
                            }
                            else if (sqlite3_bind_text(*(sqlite3_stmt **)(v14 + 64), 4, 0, 0, 0))
                            {
                              goto LABEL_83;
                            }
                            if (sqlite3_bind_int64(*(sqlite3_stmt **)(v14 + 64), 5, *v22))
                              goto LABEL_83;
                            v94 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]((void *)v14, *(sqlite3_stmt **)(v14 + 64));
                            sqlite3_reset(*(sqlite3_stmt **)(v14 + 64));
                            if ((_DWORD)v94)
                            {
                              v126 = v150;
                              Property = (id)v94;
                              CFLog();
                              goto LABEL_83;
                            }
                            v95 = *(sqlite3_stmt **)(v14 + 72);
                            if (!v95
                              || !*(_QWORD *)(v14 + 32)
                              || sqlite3_bind_blob(v95, 1, v133, n[0], 0)
                              || sqlite3_bind_blob(*(sqlite3_stmt **)(v14 + 72), 2, v132, v139, 0))
                            {
LABEL_194:
                              v10 = v129;
                              goto LABEL_83;
                            }
                            if (theData)
                            {
                              if (CFDataGetLength(theData) < *(_QWORD *)(v14 + 208))
                              {
                                if (*((_BYTE *)v22 + 20))
                                {
                                  v97 = (const __CFString *)objc_getProperty((id)v14, v96, 160, 1);
                                  if (v97)
                                  {
                                    v98 = (__CFString *)v97;
                                    FS2 = _CFURLCacheCreateFS2(v97);
                                    v100 = (uint64_t)FS2;
                                    if (FS2)
                                    {
                                      v101 = _CFURLCacheFSGetItemSize((uint64_t)FS2);
                                      _CFURLCacheFSPurgeItemFromFileSystemStore(v100, (char *)v22[1]);
                                      v147 -= (uint64_t)v101;
                                      (*(void (**)(uint64_t))(*(_QWORD *)v100 + 8))(v100);
                                    }

                                  }
                                }
                                else
                                {
                                  v147 -= *((int *)v22 + 4);
                                }
                                v106 = *(sqlite3_stmt **)(v14 + 32);
                                v107 = CFDataGetBytePtr(theData);
                                if (sqlite3_bind_blob(v106, 1, v107, (int)cf, 0))
                                  goto LABEL_194;
                                v102 = sqlite3_bind_int64(*(sqlite3_stmt **)(v14 + 32), 2, 0);
                                goto LABEL_211;
                              }
                              v103 = objc_getProperty((id)v14, v96, 160, 1);
                              if (v103)
                              {
                                v104 = v103;
                                if (*((_BYTE *)v22 + 20))
                                {
                                  v105 = (const UInt8 *)v22[1];
                                  if (v105)
                                  {
                                    cfa = CFStringCreateWithBytesNoCopy(allocator, v105, *((int *)v22 + 4), 0x8000100u, 0, contentsDeallocator);
LABEL_215:
                                    if (cfa)
                                    {
                                      nb = (_CFCachedURLResponse *)_CFURLCacheCreateFS3(v104, theData, cfa);
                                      v110 = _CFURLCacheFSGetItemSize((uint64_t)nb);
                                      v111 = v110;
                                      v112 = *(_QWORD *)(v15 + 16);
                                      if (!v112 || (v113 = (uint64_t)v110, !*(_BYTE *)(v112 + 24)))
                                        v113 = _CFURLCacheFSWriteCachedResponseToFS((uint64_t)nb);
                                      if (v113 != CFDataGetLength(theData)
                                        || (*(_QWORD *)(v14 + 184) += v113,
                                            sqlite3_bind_int64(*(sqlite3_stmt **)(v14 + 32), 2, v113 != 0)))
                                      {

                                        v10 = v129;
                                        (*(void (**)(_CFCachedURLResponse *))(nb->var0.var0 + 8))(nb);
                                        CFRelease(cfa);
                                        goto LABEL_83;
                                      }
                                      LOBYTE(keys) = 0;
                                      v115 = _ExtractCStringfromCFStringRef(cfa, (BOOL *)&keys);
                                      if (v115)
                                      {
                                        if (sqlite3_bind_text(*(sqlite3_stmt **)(v14 + 32), 1, v115, -1, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL))
                                        {
                                          if ((_BYTE)keys)
                                            MEMORY[0x186DB7474](v115, 0x1000C8077774924);

                                          (*(void (**)(_CFCachedURLResponse *))(nb->var0.var0 + 8))(nb);
                                          CFRelease(cfa);
                                          goto LABEL_194;
                                        }
                                        if ((_BYTE)keys)
                                          MEMORY[0x186DB7474](v115, 0x1000C8077774924);
                                      }
                                      __CFURLCache::ReplaceDataInMemoryCacheResponseWithMMappedData(*(__CFURLCache **)(v135 + 16), nb, v150, v114);
                                      (*(void (**)(_CFCachedURLResponse *))(nb->var0.var0 + 8))(nb);
                                      CFRelease(cfa);
                                      v147 -= (uint64_t)v111;
                                    }
                                  }
                                }
                                else
                                {
                                  v108 = *((int *)v22 + 4);
                                  v109 = CFUUIDCreate(allocator);
                                  v147 -= v108;
                                  if (v109)
                                  {
                                    cfa = CFUUIDCreateString(allocator, v109);
                                    CFRelease(v109);
                                    goto LABEL_215;
                                  }
                                }

                              }
                            }
                            else
                            {
                              if (sqlite3_bind_blob(*(sqlite3_stmt **)(v14 + 32), 1, 0, 0, 0))
                                goto LABEL_194;
                              v102 = sqlite3_bind_blob(*(sqlite3_stmt **)(v14 + 32), 2, 0, 0, 0);
LABEL_211:
                              if (v102)
                                goto LABEL_194;
                            }
                            v116 = *(sqlite3_stmt **)(v14 + 72);
                            if (v136 < 1)
                              v117 = sqlite3_bind_blob(v116, 3, 0, 0, 0);
                            else
                              v117 = sqlite3_bind_blob(v116, 3, v130, v136, 0);
                            if (v117)
                              goto LABEL_194;
                            v118 = *(sqlite3_stmt **)(v14 + 72);
                            v119 = BytePtr
                                 ? sqlite3_bind_blob(v118, 4, BytePtr, Length, 0)
                                 : sqlite3_bind_blob(v118, 4, 0, 0, 0);
                            if (v119
                              || sqlite3_bind_int64(*(sqlite3_stmt **)(v14 + 72), 5, *v22)
                              || sqlite3_bind_int64(*(sqlite3_stmt **)(v14 + 32), 3, *v22))
                            {
                              goto LABEL_194;
                            }
                            v120 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]((void *)v14, *(sqlite3_stmt **)(v14 + 72));
                            v121 = *(sqlite3_stmt **)(v14 + 72);
                            if (v120
                              || (sqlite3_reset(v121),
                                  v122 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]((void *)v14, *(sqlite3_stmt **)(v14 + 32)), v121 = *(sqlite3_stmt **)(v14 + 32), v122))
                            {
                              sqlite3_reset(v121);
                              v10 = v129;
                              goto LABEL_83;
                            }
                            sqlite3_reset(v121);
                            v10 = v129;
                          }
LABEL_173:
                          v88 = &v147[*(_QWORD *)(v14 + 200)];
                          *(_QWORD *)(v14 + 200) = v88;
                          if ((unint64_t)v88 > *(_QWORD *)(v14 + 176))
                          {
                            v89 = *(_QWORD *)(v135 + 16);
                            if (!*(_BYTE *)(v89 + 121))
                            {
                              *(_BYTE *)(v89 + 121) = 1;
                              v90 = CFRetain(*(CFTypeRef *)(v89 + 440));
                              keys = (void *)MEMORY[0x1E0C809B0];
                              v164 = 3221225472;
                              v165 = ___ZN12__CFURLCache6ShrinkEP22NSURLStorageURLCacheDB_block_invoke;
                              v166 = &unk_1E14FB048;
                              v168 = v89;
                              v169 = v90;
                              v167 = v14;
                              v91 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, QOS_CLASS_UTILITY, 0, &keys);
                              v92 = dispatch_time(0, 1000000000);
                              dispatch_after(v92, *(dispatch_queue_t *)(v89 + 136), v91);
                              _Block_release(v91);
                            }
                          }
                          goto LABEL_83;
                        }
LABEL_113:
                        insert_rowid = sqlite3_last_insert_rowid(*(sqlite3 **)(v14 + 16));
                        if (!insert_rowid)
                          goto LABEL_82;
                        if (*(_QWORD *)(v14 + 48))
                        {
                          v60 = *(sqlite3_stmt **)(v14 + 56);
                          if (v60)
                          {
                            v61 = sqlite3_bind_int64(v60, 1, insert_rowid);
                            v62 = sqlite3_bind_int64(*(sqlite3_stmt **)(v14 + 48), 1, insert_rowid);
                            v63 = sqlite3_bind_blob(*(sqlite3_stmt **)(v14 + 48), 2, v133, n[0], 0);
                            v64 = (CFURLCacheFS *)sqlite3_bind_blob(*(sqlite3_stmt **)(v14 + 48), 3, v132, v139, 0);
                            v65 = (v64 | v63 | v62 | v61) == 0;
                            if (theData)
                            {
                              if (CFDataGetLength(theData) >= *(_QWORD *)(v14 + 208))
                              {
                                v73 = objc_getProperty((id)v14, v66, 160, 1);
                                if (v73)
                                {
                                  v74 = v73;
                                  v75 = CFUUIDCreate(allocator);
                                  if (v75)
                                  {
                                    na = CFUUIDCreateString(allocator, v75);
                                    CFRelease(v75);
                                    if (na)
                                    {
                                      FS3 = (_CFCachedURLResponse *)_CFURLCacheCreateFS3(v74, theData, na);
                                      v76 = _CFURLCacheFSWriteCachedResponseToFS((uint64_t)FS3);
                                      if (v76)
                                      {
                                        *(_QWORD *)(v14 + 184) += v76;
                                        if (sqlite3_bind_int64(*(sqlite3_stmt **)(v14 + 56), 2, 1)
                                          || (LOBYTE(keys) = 0,
                                              (v93 = _ExtractCStringfromCFStringRef(na, (BOOL *)&keys)) == 0))
                                        {
                                          v65 = 0;
                                        }
                                        else
                                        {
                                          if (sqlite3_bind_text(*(sqlite3_stmt **)(v14 + 56), 3, v93, -1, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL))
                                          {
                                            v126 = v64;
                                            CFLog();
                                            v65 = 0;
                                          }
                                          if ((_BYTE)keys)
                                            MEMORY[0x186DB7474](v93, 0x1000C8077774924);
                                        }
                                        __CFURLCache::ReplaceDataInMemoryCacheResponseWithMMappedData(*(__CFURLCache **)(v135 + 16), FS3, v150, v77);
                                      }
                                      else
                                      {
                                        v126 = (CFURLCacheFS *)v74;
                                        CFLog();
                                        if (sqlite3_bind_int64(*(sqlite3_stmt **)(v14 + 56), 2, 0))
                                        {
                                          v126 = v64;
                                          CFLog();
                                          v65 = 0;
                                        }
                                        v78 = *(sqlite3_stmt **)(v14 + 56);
                                        v79 = CFDataGetBytePtr(theData);
                                        if (sqlite3_bind_blob(v78, 3, v79, (int)cf, 0))
                                        {
                                          v126 = v64;
                                          CFLog();
                                          v65 = 0;
                                        }
                                      }
                                      (*(void (**)(_CFCachedURLResponse *))(FS3->var0.var0 + 8))(FS3);
                                      CFRelease(na);
                                    }
                                  }

                                }
                                else
                                {
                                  CFLog();
LABEL_144:
                                  v65 = 0;
                                }
                              }
                              else
                              {
                                if (sqlite3_bind_int64(*(sqlite3_stmt **)(v14 + 56), 2, 0))
                                {
                                  v126 = v64;
                                  CFLog();
                                  v65 = 0;
                                }
                                v67 = *(sqlite3_stmt **)(v14 + 56);
                                v68 = CFDataGetBytePtr(theData);
                                if (sqlite3_bind_blob(v67, 3, v68, (int)cf, 0))
                                {
                                  v126 = v64;
                                  CFLog();
                                  goto LABEL_144;
                                }
                              }
                            }
                            else
                            {
                              v72 = sqlite3_bind_int64(*(sqlite3_stmt **)(v14 + 56), 2, 0);
                              if (sqlite3_bind_blob(*(sqlite3_stmt **)(v14 + 56), 3, 0, 0, 0) | v72)
                                v65 = 0;
                            }
                            if (v136 <= 0)
                              v80 = 0;
                            else
                              v80 = v130;
                            if (sqlite3_bind_blob(*(sqlite3_stmt **)(v14 + 48), 4, v80, v136 & ~(v136 >> 63), 0))
                            {
                              v81 = 0;
                            }
                            else
                            {
                              v81 = v65;
                            }
                            v82 = *(sqlite3_stmt **)(v14 + 48);
                            if (BytePtr)
                            {
                              if (sqlite3_bind_blob(v82, 5, BytePtr, Length, 0))
                                v83 = 0;
                              else
                                v83 = v81;
                              if (!v83)
                                goto LABEL_172;
                            }
                            else
                            {
                              if (sqlite3_bind_blob(v82, 5, 0, 0, 0))
                                v84 = 0;
                              else
                                v84 = v81;
                              if (!v84)
                                goto LABEL_172;
                            }
                            v85 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]((void *)v14, *(sqlite3_stmt **)(v14 + 48));
                            if (v85 && v85 != 101)
                            {
                              sqlite3_reset(*(sqlite3_stmt **)(v14 + 48));
                              goto LABEL_82;
                            }
                            sqlite3_reset(*(sqlite3_stmt **)(v14 + 48));
                            v86 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]((void *)v14, *(sqlite3_stmt **)(v14 + 56));
                            v87 = (void *)v86;
                            if ((_DWORD)v86 && (_DWORD)v86 != 101)
                            {
                              sqlite3_reset(*(sqlite3_stmt **)(v14 + 56));
                              v126 = v150;
                              Property = v87;
                              CFLog();
                              goto LABEL_82;
                            }
                            sqlite3_reset(*(sqlite3_stmt **)(v14 + 56));
                          }
                        }
LABEL_172:
                        v22 = 0;
                        goto LABEL_173;
                      }
LABEL_71:
                      v130 = 0;
                      v136 = 0;
                      Value = 0;
                      goto LABEL_75;
                    }
                  }
                  else
                  {
                    v132 = 0;
                    LODWORD(v139) = 0;
                    if (!v45)
                      goto LABEL_67;
                  }
                  CFRelease(v45);
                  goto LABEL_67;
                }
                LODWORD(v139) = 0;
                v132 = 0;
                goto LABEL_71;
              }
            }
          }
LABEL_95:

          ++v12;
        }
        while (v12 != v10);
        v123 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v152, v161, 16);
        v10 = v123;
      }
      while (v123);
    }
    v124 = *(_QWORD *)(a1 + 32);
    if (v124)
    {
      -[NSURLStorageURLCacheDB openAndPrepareWriteCacheDB_NoLock](*(id *)(a1 + 32), v9);
      -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:](v124, "COMMIT TRANSACTION;",
        *(sqlite3 **)(v124 + 16),
        1);
      v125 = *(os_unfair_lock_s **)(a1 + 32);
      if (v125)
        os_unfair_lock_unlock(v125 + 7);
    }
    __releaseStorageAssertion(v11);
  }
  if (v5)
  {
    pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 16) + 552));
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 16) + 544) = 0;
    pthread_mutex_unlock((pthread_mutex_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 16) + 552));

  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void sub_183F290E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29)
{

  _Unwind_Resume(a1);
}

void CFXURLCache::getResponseForTask(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v7;

  v7 = (void *)MEMORY[0x186DB8C8C]();
  __CFURLCacheCopyResponseForRequestWithCompletionHandler(*(_QWORD *)(a1 + 8), (_CFURLRequest *)objc_msgSend(a2, "currentRequest"), *(_CFURLRequest **)(a1 + 16), a4);
  objc_autoreleasePoolPop(v7);
}

void __CFURLCacheCopyResponseForRequestWithCompletionHandler(uint64_t a1, _CFURLRequest *cf, _CFURLRequest *a3, uint64_t a4)
{
  uint64_t v7;
  _CFURLRequest *v8;
  uint64_t v9;
  uint64_t v10;
  NSURL *v11;
  BOOL v12;
  __CFURLCache **v13;
  __CFString *v14;
  __CFString *v15;
  __CFString *CacheKeyForRequest;
  __CFString *v17;
  pthread_mutex_t *v18;
  CFHashCode v19;
  _QWORD *NodeFromHashMap;
  _QWORD *v21;
  pthread_mutex_t *v22;
  void *Value;
  NSURLSession *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  CFIndex v28;
  pthread_mutex_t *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  CFIndex *v33;
  NSURLSession *v34;
  const __CFDictionary *v35;
  uint64_t v36;
  id v37;
  void *v38;
  _QWORD *v39;
  _CFURLRequest *v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  CFStringRef v45;
  CFStringRef v46;
  const __CFString *v47;
  int CachedResponseDataFromFS;
  CFIndex v49;
  _QWORD *v50;
  const void *v51;
  const __CFAllocator *v52;
  const __CFAllocator *v53;
  UInt8 *v54;
  const __CFData *v55;
  __CFCachedURLResponse *v56;
  int v57;
  unint64_t v58;
  uint64_t v59;
  CFIndex v60;
  pthread_mutex_t *v61;
  void *v62;
  CFIndex *v63;
  NSObject *v64;
  __CFCachedURLResponse *v65;
  const __CFSet *v66;
  __CFData *ReceiverData;
  const UInt8 *BytePtr;
  uint64_t v69;
  void *v70;
  void *v71;
  void *v72;
  char v73;
  uint64_t v74;
  const void *v75;
  uint64_t v76;
  void *v77;
  const __CFAllocator *alloc;
  char **v79;
  _QWORD *v80;
  _QWORD v81[2];
  void (*v82)(uint64_t, uint64_t);
  void *v83;
  NSURL *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  UInt8 *bytes;
  CFAllocatorContext context;

  if (!a1 || !cf || (v7 = *(_QWORD *)(a1 + 16)) == 0)
  {
    (*(void (**)(uint64_t, _QWORD))(a4 + 16))(a4, 0);
    return;
  }
  v8 = a3;
  if (!a3)
  {
    v9 = +[NSURLSession _sharedSessionForConnection]();
    v7 = *(_QWORD *)(a1 + 16);
    if (v9)
    {
      v8 = (_CFURLRequest *)v9;
    }
    else
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        LOWORD(context.version) = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Should not be null - at least the default session should be here", (uint8_t *)&context, 2u);
      }
      v8 = 0;
    }
  }
  __CFURLCache::logCacheEvent(v7, 1, cf);
  v10 = -[_CFURLRequest _inner](cf, "_inner");
  v11 = *(NSURL **)(v10 + 8);
  if (*(_BYTE *)(v7 + 632))
    v12 = v11 == 0;
  else
    v12 = 1;
  if (v12)
  {
    v15 = 0;
  }
  else
  {
    v13 = *(__CFURLCache ***)(v7 + 440);
    v14 = (__CFString *)CFURLGetString(*(CFURLRef *)(v10 + 8));
    v15 = (__CFString *)__CFURLCacheVaryStateForURL(v13, v14);
  }
  CacheKeyForRequest = _createCacheKeyForRequest(cf, 1, v15);
  if (!CacheKeyForRequest)
  {
    __CFURLCache::logCacheEvent(v7, 14, cf);
    (*(void (**)(uint64_t, _QWORD))(a4 + 16))(a4, 0);
    return;
  }
  v17 = CacheKeyForRequest;
  v18 = (pthread_mutex_t *)(v7 + 312);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 312));
  v19 = CFHash(v17);
  NodeFromHashMap = __CFURLCache::GetNodeFromHashMap((__CFURLCache *)v7, v19);
  if (NodeFromHashMap)
  {
    v21 = NodeFromHashMap;
    __CFURLCache::logCacheEvent(v7, 2, cf);
    v22 = (pthread_mutex_t *)(v21 + 1);
    pthread_mutex_lock((pthread_mutex_t *)(v21 + 1));
    Value = (void *)v21[9];
    pthread_mutex_unlock(v22);
    if (Value)
    {
      CFRetain(Value);
      if (__CFURLCache::checkCacheEquivalency((__CFURLCache *)Value, (const _CFCachedURLResponse *)cf, v8, v24))
      {
        v25 = *(_QWORD *)(v7 + 272);
        v26 = *(_QWORD *)(v7 + 296);
        v27 = v26 >> 9;
        v28 = *(_QWORD *)(*(_QWORD *)(v25 + 8 * (v26 >> 9)) + 8 * (v26 & 0x1FF));
        context.version = v28;
        if (!v28)
        {
LABEL_24:
          v79 = (char **)(v7 + 264);
          v31 = v25 + 8 * v27;
          v32 = *(_QWORD *)(v7 + 280);
          if (v32 == v25)
            v33 = 0;
          else
            v33 = (CFIndex *)(*(_QWORD *)v31 + 8 * (v26 & 0x1FF));
          while (1)
          {
            if (v32 == v25)
            {
              v59 = 0;
            }
            else
            {
              v58 = *(_QWORD *)(v7 + 304) + *(_QWORD *)(v7 + 296);
              v59 = *(_QWORD *)(v25 + ((v58 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v58 & 0x1FF);
            }
            if (v33 == (CFIndex *)v59)
              goto LABEL_66;
            v60 = *v33;
            v61 = (pthread_mutex_t *)(*v33 + 8);
            pthread_mutex_lock(v61);
            v62 = *(void **)(v60 + 72);
            pthread_mutex_unlock(v61);
            if (v62 == Value)
            {
              context.version = *v33;
              std::deque<__CFURLCacheNode *>::erase((uint64_t)v79, (char *)v31, (char *)v33);
              std::deque<__CFURLCacheNode *>::push_front(v79, &context);
              goto LABEL_66;
            }
            if ((CFIndex *)((char *)++v33 - *(_QWORD *)v31) == (CFIndex *)4096)
            {
              v63 = *(CFIndex **)(v31 + 8);
              v31 += 8;
              v33 = v63;
            }
            v25 = *(_QWORD *)(v7 + 272);
            v32 = *(_QWORD *)(v7 + 280);
          }
        }
        v29 = (pthread_mutex_t *)(v28 + 8);
        pthread_mutex_lock((pthread_mutex_t *)(v28 + 8));
        v30 = *(void **)(v28 + 72);
        pthread_mutex_unlock(v29);
        if (v30 != Value)
        {
          v25 = *(_QWORD *)(v7 + 272);
          v26 = *(_QWORD *)(v7 + 296);
          v27 = v26 >> 9;
          goto LABEL_24;
        }
LABEL_66:
        pthread_mutex_unlock(v18);
        if (!requestURLIsBlocked(v11))
        {
          (*(void (**)(uint64_t, void *))(a4 + 16))(a4, Value);
          CFRelease(Value);
          goto LABEL_104;
        }
        CFRelease(Value);
        goto LABEL_68;
      }
      CFRelease(Value);
    }
    else
    {
      __CFURLCache::logCacheEvent(v7, 4, cf);
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 312));
  v18 = (pthread_mutex_t *)(v7 + 552);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 552));
  Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(v7 + 536), v17);
  if (Value
    || (v35 = *(const __CFDictionary **)(v7 + 544)) != 0 && (Value = (void *)CFDictionaryGetValue(v35, v17)) != 0)
  {
    CFRetain(Value);
    if (__CFURLCache::checkCacheEquivalency((__CFURLCache *)Value, (const _CFCachedURLResponse *)cf, v8, v34))goto LABEL_66;
    CFRelease(Value);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 552));
  if (*(uint64_t *)(v7 + 176) < 5242880)
  {
LABEL_68:
    (*(void (**)(uint64_t, _QWORD))(a4 + 16))(a4, 0);
    goto LABEL_104;
  }
  v36 = *(_QWORD *)(v7 + 440);
  if (v36)
    CFRetain(*(CFTypeRef *)(v7 + 440));
  v81[0] = MEMORY[0x1E0C809B0];
  v81[1] = 3221225472;
  v82 = ___ZN12__CFURLCache43CopyResponseForRequestWithCompletionHandlerEPK13_CFURLRequestbP12NSURLSessionU13block_pointerFvPK20_CFCachedURLResponseE_block_invoke;
  v83 = &unk_1E14F71C8;
  v84 = v11;
  v85 = a4;
  v86 = v36;
  __CFURLCache::logCacheEvent(v7, 7, cf);
  v37 = __CFURLCache::createAndOpenCacheDB((__CFURLCache *)v7);
  if (v37)
  {
    v38 = v37;
    CFRetain(cf);
    v39 = *(_QWORD **)(v7 + 440);
    if (v39)
      CFRetain(*(CFTypeRef *)(v7 + 440));
    v40 = v8;
    CFRetain(v17);
    v87 = 0;
    v88 = 0;
    v41 = -[NSURLStorageURLCacheDB createCachedResponseForKey:cacheDataPath:cacheDataFile:caller:]((uint64_t)v38, v17, &v88, &v87);
    if (v41)
    {
      v80 = v39;
      v42 = v88;
      if (!v88)
        goto LABEL_83;
      v43 = v87;
      if (!v87)
        goto LABEL_83;
      v77 = v38;
      v44 = operator new();
      *(_QWORD *)v44 = &off_1E14E6990;
      pthread_mutex_init((pthread_mutex_t *)(v44 + 8), 0);
      *(_QWORD *)v44 = &off_1E14E5790;
      *(_OWORD *)(v44 + 72) = 0u;
      *(_OWORD *)(v44 + 88) = 0u;
      *(_OWORD *)(v44 + 104) = 0u;
      *(_BYTE *)(v44 + 120) = 0;
      alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v45 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@/%s/%@"), v42, "fsCachedData", v43);
      v46 = v45;
      if (v45)
      {
        *(_QWORD *)(v44 + 72) = CFRetain(v45);
        CFRelease(v46);
      }
      *(_QWORD *)(v44 + 96) = 0;
      *(_QWORD *)(v44 + 80) = CFStringCreateWithFormat(alloc, 0, CFSTR("%@/%s"), v42, "fsCachedData");
      v47 = *(const __CFString **)(v44 + 72);
      if (v47)
        *(_QWORD *)(v44 + 112) = _ExtractCStringfromCFStringRef(v47, (BOOL *)(v44 + 120));
      v89 = 0;
      bytes = 0;
      CachedResponseDataFromFS = CFURLCacheFS::getCachedResponseDataFromFS((CFURLCacheFS *)v44, (void **)&bytes, &v89);
      (*(void (**)(uint64_t))(*(_QWORD *)v44 + 8))(v44);
      if (!CachedResponseDataFromFS)
        goto LABEL_91;
      v49 = v89;
      if (v89 <= 0)
        goto LABEL_91;
      v50 = (_QWORD *)operator new();
      *v50 = v7;
      v50[1] = v49;
      v51 = *(const void **)(v7 + 440);
      if (v51)
        CFRetain(v51);
      context.version = 0;
      context.info = v50;
      memset(&context.retain, 0, 40);
      context.deallocate = (CFAllocatorDeallocateCallBack)mmapFileDeallocate;
      context.preferredSize = 0;
      v52 = CFAllocatorCreate(alloc, &context);
      if (v52)
      {
        v53 = v52;
        v54 = bytes;
        v55 = CFDataCreateWithBytesNoCopy(alloc, bytes, v49, v52);
        __CFURLCache::addMMappedDataToSet((__CFURLCache *)v7, v54);
        CFRelease(v53);
        if (v55)
        {
          v56 = (__CFCachedURLResponse *)v41[2];
          v38 = v77;
          if (v56)
          {
            __CFCachedURLResponse::SetReceiverData(v56, v55);
            v57 = 1;
          }
          else
          {
            v57 = 0;
          }
          CFRelease(v55);
        }
        else
        {
          v57 = 0;
          v38 = v77;
        }
      }
      else
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v38 = v77;
        v64 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          LOWORD(context.version) = 0;
          _os_log_error_impl(&dword_183ECA000, v64, OS_LOG_TYPE_ERROR, "ERROR: failed to allocate a mem-map deallocator.", (uint8_t *)&context, 2u);
        }
        v57 = 0;
      }
      pthread_mutex_lock((pthread_mutex_t *)(v7 + 376));
      v65 = (__CFCachedURLResponse *)v41[2];
      if (v65)
      {
        v66 = *(const __CFSet **)(v7 + 448);
        ReceiverData = __CFCachedURLResponse::GetReceiverData(v65);
        BytePtr = CFDataGetBytePtr(ReceiverData);
        if (CFSetContainsValue(v66, BytePtr))
          *(_BYTE *)(v41[2] + 120) = 1;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v7 + 376));
      if (!v57)
      {
LABEL_91:
        CFRelease(v41);
        v41 = 0;
        v39 = v80;
      }
      else
      {
LABEL_83:
        v69 = v41[2];
        os_unfair_lock_lock((os_unfair_lock_t)(v69 + 88));
        v70 = *(void **)(v69 + 112);
        os_unfair_lock_unlock((os_unfair_lock_t)(v69 + 88));
        v71 = -[__NSURLSessionLocal _protocolClassForRequest:]((uint64_t)v8, (uint64_t)v70);
        v39 = v80;
        if (v71)
        {
          if (!v70)
            goto LABEL_98;
          v72 = v71;
          if (!objc_msgSend(v71, "canInitWithRequest:", v70)
            || !objc_msgSend(v72, "canInitWithRequest:", cf))
          {
            goto LABEL_98;
          }
          if (v80 && *(_BYTE *)(v80[2] + 528))
          {
            _CFURLRequestSetProtocolProperty(v70, CFSTR("__SKIP_USER_AGENT_IN_REQUEST_EQUIVALENCY_CHECK__"), (CFStringRef)*MEMORY[0x1E0C9AE50]);
            v73 = objc_msgSend(v72, "requestIsCacheEquivalent:toRequest:", v70, cf);
            _CFURLRequestSetProtocolProperty(v70, CFSTR("__SKIP_USER_AGENT_IN_REQUEST_EQUIVALENCY_CHECK__"), 0);
            if ((v73 & 1) == 0)
              goto LABEL_98;
          }
          else if (!objc_msgSend(v72, "requestIsCacheEquivalent:toRequest:", v70, cf))
          {
LABEL_98:
            v82((uint64_t)v81, 0);
            CFRelease(v41);
            __CFURLCache::logCacheEvent(v7, 12, cf);
            v41 = 0;
            goto LABEL_99;
          }
        }
        else
        {
          if (!v8)
            goto LABEL_98;
          v74 = v41[2];
          os_unfair_lock_lock((os_unfair_lock_t)(v74 + 88));
          v75 = *(const void **)(v74 + 112);
          os_unfair_lock_unlock((os_unfair_lock_t)(v74 + 88));
          if ((-[__NSURLSessionLocal _cfurlRequest:isCacheEquivalentTo:]((uint64_t)v8, v75, cf) & 1) == 0)
            goto LABEL_98;
        }
        v76 = operator new();
        __CFURLCacheNode::__CFURLCacheNode(v76, v41, v17, cf, 3);
        context.version = v76;
        __CFURLCache::AddCacheTask(v7, &context.version);
        if (context.version)
          (*(void (**)(CFIndex))(*(_QWORD *)context.version + 8))(context.version);
      }
    }
    v82((uint64_t)v81, (uint64_t)v41);
LABEL_99:
    if (v39)
      CFRelease(v39);
    CFRelease(cf);

    CFRelease(v17);
    if (v41)
      CFRelease(v41);

    goto LABEL_104;
  }
  v82((uint64_t)v81, 0);
LABEL_104:
  CFRelease(v17);
}

void sub_183F2A054(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  if (a27)
    (*(void (**)(uint64_t))(*(_QWORD *)a27 + 8))(a27);
  _Unwind_Resume(exception_object);
}

_QWORD *__CFURLCache::GetNodeFromHashMap(__CFURLCache *this, uint64_t a2)
{
  _QWORD *result;

  if (!*((_QWORD *)this + 31))
    return 0;
  result = std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::find<unsigned long>((_QWORD *)this + 28, a2);
  if (!result)
    return result;
  if (result[2])
    return (_QWORD *)result[3];
  else
    return 0;
}

id __CFURLCache::createAndOpenCacheDB(__CFURLCache *this)
{
  os_unfair_lock_s *v2;
  double v3;
  __CFString *PathToCacheDirectory;
  CFStringRef *v5;
  sqlite3 **v6;
  const char *v7;
  double v8;
  const char *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v13;
  char buffer[1024];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v2 = (os_unfair_lock_s *)((char *)this + 124);
  os_unfair_lock_lock((os_unfair_lock_t)this + 31);
  if (!*((_BYTE *)this + 120)
    && *((uint64_t *)this + 22) >= 5242880
    && (int)MKBDeviceUnlockedSinceBoot_delayInitStub(v3) >= 1)
  {
    PathToCacheDirectory = (__CFString *)*((_QWORD *)this + 27);
    if (!PathToCacheDirectory)
    {
      PathToCacheDirectory = __CreatePathToCacheDirectory(0, 0);
      *((_QWORD *)this + 27) = PathToCacheDirectory;
      if (!PathToCacheDirectory)
      {
        os_unfair_lock_unlock(v2);
        return 0;
      }
    }
    if (CFStringGetFileSystemRepresentation(PathToCacheDirectory, buffer, 1024))
      __BuildPath(buffer);
    v5 = (CFStringRef *)operator new();
    CFURLCacheFS::CFURLCacheFS((CFURLCacheFS *)v5, *((const __CFString **)this + 27));
    if (CFStringGetFileSystemRepresentation(v5[10], buffer, 1024))
    {
      __BuildPath(buffer);
      v13 = 73733;
      fsctl(buffer, 0xC0084A44uLL, &v13, 0);
    }
    __retainStorageAssertion(*((void **)this + 17));
    v6 = (sqlite3 **)-[NSURLStorageURLCacheDB initWithDBPath:maxSize:]([NSURLStorageURLCacheDB alloc], *((void **)this + 27), *((_QWORD *)this + 22));
    *((_QWORD *)this + 16) = v6;
    if (v6)
    {
      if ((-[NSURLStorageURLCacheDB isSchemaCurrent](v6, v7) & 1) == 0)
        -[NSURLStorageURLCacheDB updateToCurrentSchema](*((_QWORD *)this + 16), v9);
      -[NSURLStorageURLCacheDB updateFSBackedCacheUsageOnDisk](*((_QWORD **)this + 16), v9);
      -[NSURLStorageURLCacheDB updateSQLiteDBCacheUsageOnDisk](*((_QWORD **)this + 16));
      v11 = *((_QWORD *)this + 16);
      if (v11)
      {
        if (-[NSURLStorageURLCacheDB _openDBReadConnections](*((_QWORD *)this + 16), v10))
          -[NSURLStorageURLCacheDB _prepareDBSelectStatements](v11);
      }
    }
    __releaseStorageAssertion(v8);
    *((_BYTE *)this + 120) = 1;
    ((void (*)(CFStringRef *))(*v5)->info)(v5);
  }
  os_unfair_lock_unlock(v2);
  return *((id *)this + 16);
}

void sub_183F2A2E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10F1C4059CE80F0);
  _Unwind_Resume(a1);
}

void __CFURLCache::AddCacheTask(uint64_t a1, uint64_t *a2)
{
  const void *v4;
  uint64_t v5;
  pthread_mutex_t *v6;
  uint64_t v7;
  uint64_t v8;
  pthread_mutex_t *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  pthread_mutex_t *v18;
  uint64_t v19;
  uint64_t v20;
  pthread_mutex_t *v21;
  uint64_t v22;
  uint64_t v23;
  pthread_mutex_t *v24;
  _CFCachedURLResponse *v25;
  uint64_t v26;
  const void *v27;
  void *v28;
  pthread_mutex_t *v29;
  uint64_t v30;
  __CFCachedURLResponse *var1;
  uint64_t v32;
  uint64_t v33;
  os_unfair_lock_s *v34;
  const void *v35;
  const __CFString *v36;
  uint64_t v37;
  __CFCachedURLResponse *v38;
  const void *v39;
  const void *v40;
  int v41;
  const void *v42;
  const void *v43;
  CFHashCode v44;
  _QWORD *NodeFromHashMap;
  uint64_t v46;
  const _CFCachedURLResponse *v47;
  const __CFString *v48;
  id v49;
  void *v50;
  void *v51;
  uint64_t v52;
  dispatch_block_t v53;
  const void *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  const void *v59;
  const _CFCachedURLResponse *v60;
  const _CFCachedURLResponse *v61;
  const __CFString *v62;
  int v63;
  CFHashCode v64;
  _QWORD *v65;
  char v66;
  uint64_t v67;
  uint64_t v68;
  const _CFCachedURLResponse *v69;
  const __CFString *v70;
  CFHashCode v71;
  char v72;
  uint64_t v73;
  CFTypeID v74;
  uint64_t v75;
  char v76;
  id v77;
  void *v78;
  CFIndex Count;
  CFTypeRef v80;
  dispatch_block_t v81;
  BOOL v82;
  void *key;
  _CFCachedURLResponse *v84;
  CFTypeRef cf;
  uint64_t v86;
  uint64_t block;
  uint64_t v88;
  void (*v89)(uint64_t);
  void *v90;
  void *v91;
  id v92;
  uint64_t v93;
  _QWORD v94[6];

  v4 = *(const void **)(a1 + 440);
  CFRetain(v4);
  v5 = *a2;
  if (!*a2)
    goto LABEL_70;
  v6 = (pthread_mutex_t *)(v5 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 8));
  v7 = *(_QWORD *)(v5 + 72);
  pthread_mutex_unlock(v6);
  if (v7)
  {
    v8 = *a2;
    v9 = (pthread_mutex_t *)(*a2 + 8);
    pthread_mutex_lock(v9);
    v10 = *(_QWORD *)(v8 + 72);
    pthread_mutex_unlock(v9);
    v11 = *(_DWORD *)(*(_QWORD *)(v10 + 16) + 56);
  }
  else
  {
    v11 = 2;
  }
  v12 = *a2;
  v13 = *(_DWORD *)(*a2 + 96);
  if (v13 == 3)
    goto LABEL_10;
  if (v13 == 1)
  {
    v42 = *(const void **)(v12 + 88);
    if (v42)
    {
      v43 = *(const void **)(v12 + 80);
      v44 = CFHash(*(CFTypeRef *)(v12 + 88));
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 312));
      NodeFromHashMap = __CFURLCache::GetNodeFromHashMap((__CFURLCache *)a1, v44);
      v46 = (uint64_t)NodeFromHashMap;
      if (NodeFromHashMap)
      {
        pthread_mutex_lock((pthread_mutex_t *)(NodeFromHashMap + 1));
        v47 = *(const _CFCachedURLResponse **)(v46 + 72);
        pthread_mutex_unlock((pthread_mutex_t *)(v46 + 8));
        v46 = __CFURLCache::RemoveResponseFromCacheContainers((int8x8_t *)a1, (__CFURLCacheNode *)v46, v47, v48);
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 312));
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 552));
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 536), v42);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 552));
      __CFURLCache::logCacheEvent(a1, 20, v43);
    }
    else
    {
      v46 = 0;
    }
    *(_QWORD *)(v12 + 104) = v46;
    v49 = __CFURLCache::createAndOpenCacheDB((__CFURLCache *)a1);
    if (v49)
    {
      v50 = v49;
      v51 = *(void **)(a1 + 136);
      v52 = *(_QWORD *)(*a2 + 88);
      block = MEMORY[0x1E0C809B0];
      v88 = 3221225472;
      v89 = ___ZN12__CFURLCache13AddCacheTask0ERNSt3__110unique_ptrI16__CFURLCacheNodeNS0_14default_deleteIS2_EEEE_block_invoke;
      v90 = &unk_1E14FE1E0;
      v91 = v51;
      v92 = v49;
      v93 = v52;
      v53 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, QOS_CLASS_UTILITY, 0, &block);
      dispatch_async(*(dispatch_queue_t *)(a1 + 136), v53);
      _Block_release(v53);

    }
    goto LABEL_70;
  }
  if (v13)
    goto LABEL_70;
  if ((v11 & 1) != 0)
LABEL_10:
    v14 = 0;
  else
    v14 = *(_QWORD *)(a1 + 176) > 0;
  if (v11 > 1)
    goto LABEL_70;
  pthread_mutex_lock((pthread_mutex_t *)(v12 + 8));
  v15 = *(_QWORD *)(v12 + 72);
  pthread_mutex_unlock((pthread_mutex_t *)(v12 + 8));
  v16 = *(_QWORD *)(v15 + 16);
  *(_QWORD *)(v16 + 64) = CFHash(*(CFTypeRef *)(*a2 + 88));
  v17 = *a2;
  v18 = (pthread_mutex_t *)(*a2 + 8);
  pthread_mutex_lock(v18);
  v19 = *(_QWORD *)(v17 + 72);
  pthread_mutex_unlock(v18);
  __CFCachedURLResponse::SetKey(*(__CFCachedURLResponse **)(v19 + 16), *(const __CFString **)(*a2 + 88));
  v20 = *a2;
  v21 = (pthread_mutex_t *)(*a2 + 8);
  pthread_mutex_lock(v21);
  v22 = *(_QWORD *)(v20 + 72);
  pthread_mutex_unlock(v21);
  __CFCachedURLResponse::SetRequest(*(__CFCachedURLResponse **)(v22 + 16), *(const _CFURLRequest **)(*a2 + 80));
  v23 = *a2;
  v24 = (pthread_mutex_t *)(*a2 + 8);
  pthread_mutex_lock(v24);
  v25 = *(_CFCachedURLResponse **)(v23 + 72);
  pthread_mutex_unlock(v24);
  v26 = *a2;
  v27 = *(const void **)(*a2 + 80);
  v28 = *(void **)(*a2 + 88);
  v29 = (pthread_mutex_t *)(*a2 + 8);
  pthread_mutex_lock(v29);
  v30 = *(_QWORD *)(v26 + 72);
  pthread_mutex_unlock(v29);
  __CFCachedURLResponse::GetNSCachedURLResponse(*(__CFCachedURLResponse **)(v30 + 16));
  if (!v25 || !v28)
    goto LABEL_70;
  cf = v27;
  v86 = v23;
  var1 = v25->var1;
  v32 = *((_QWORD *)var1 + 12);
  v33 = v32 + 512;
  key = v28;
  if (v32 + 512 > *(_QWORD *)(a1 + 184))
  {
    v34 = (os_unfair_lock_s *)((char *)var1 + 88);
    os_unfair_lock_lock((os_unfair_lock_t)var1 + 22);
    v35 = (const void *)*((_QWORD *)var1 + 14);
    os_unfair_lock_unlock(v34);
    __CFURLCache::logCacheEvent(a1, 16, v35);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 312));
    __CFURLCache::RemoveResponseFromCacheContainers((int8x8_t *)a1, 0, v25, v36);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 312));
    v37 = v86;
LABEL_16:
    v38 = v25->var1;
    os_unfair_lock_lock((os_unfair_lock_t)v38 + 22);
    v39 = (const void *)*((_QWORD *)v38 + 14);
    os_unfair_lock_unlock((os_unfair_lock_t)v38 + 22);
    v40 = v39;
    v23 = v86;
    __CFURLCache::logCacheEvent(a1, 15, v40);
    v41 = 0;
    goto LABEL_56;
  }
  v37 = v23;
  v84 = v25;
  v82 = v14;
  if (*(_QWORD *)(a1 + 144) + v33 <= *(_QWORD *)(a1 + 168))
    goto LABEL_49;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 312));
  if (v32 < -511)
  {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 312));
    v37 = v23;
    goto LABEL_49;
  }
  v54 = 0;
  v55 = 0;
  v56 = 0;
  while (1)
  {
    v57 = *(_QWORD *)(a1 + 304);
    if (!v57
      || (v58 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 272)
                                      + (((unint64_t)(v57 + *(_QWORD *)(a1 + 296) - 1) >> 6) & 0x3FFFFFFFFFFFFF8))
                          + 8 * ((v57 + *(_QWORD *)(a1 + 296) - 1) & 0x1FF)),
          v58 == v23))
    {
      v63 = 0;
      goto LABEL_42;
    }
    v59 = *(const void **)(v58 + 88);
    if (v59)
    {
      v54 = *(const void **)(v58 + 80);
      if (!v54 || (CFRetain(*(CFTypeRef *)(v58 + 80)), (v59 = *(const void **)(v58 + 88)) != 0))
      {
        CFRetain(v59);
        pthread_mutex_lock((pthread_mutex_t *)(v58 + 8));
        v60 = *(const _CFCachedURLResponse **)(v58 + 72);
        pthread_mutex_unlock((pthread_mutex_t *)(v58 + 8));
        v61 = v60;
        v23 = v86;
        v55 = __CFURLCache::RemoveResponseFromCacheContainers((int8x8_t *)a1, (__CFURLCacheNode *)v58, v61, v62);
      }
    }
    if (!v55)
      break;
    __CFURLCache::logCacheEvent(a1, 20, v54);
    if (v54)
      CFRelease(v54);
    if (v59)
      CFRelease(v59);
    v56 += v55;
    v25 = v84;
    if (v56 >= v33)
    {
      v63 = 1;
LABEL_42:
      v14 = v82;
      goto LABEL_46;
    }
  }
  if (v59)
    CFRelease(v59);
  v63 = 0;
  v14 = v82;
  v25 = v84;
LABEL_46:
  v28 = key;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 312));
  v37 = v23;
  if (!v23)
  {
    v37 = operator new();
    __CFURLCacheNode::__CFURLCacheNode(v37, v25, key, cf, 0);
  }
  if (!v63)
    goto LABEL_16;
LABEL_49:
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 312));
  v94[0] = v37;
  v64 = CFHash(v28);
  v65 = std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::__emplace_unique_key_args<unsigned long,std::pair<unsigned long,__CFURLCacheNode *>>((float *)(a1 + 224), v64, v64, v37);
  if (v66)
  {
    std::deque<__CFURLCacheNode *>::push_front((char **)(a1 + 264), v94);
    pthread_mutex_lock((pthread_mutex_t *)(v37 + 8));
    v67 = *(_QWORD *)(v37 + 72);
    pthread_mutex_unlock((pthread_mutex_t *)(v37 + 8));
    *(_QWORD *)(a1 + 144) += *(_QWORD *)(*(_QWORD *)(v67 + 16) + 96);
    v41 = 1;
    *(_BYTE *)(v37 + 113) = 1;
    __CFURLCache::logCacheEvent(a1, 5, *(CFTypeRef *)(v37 + 80));
  }
  else
  {
    v68 = v65[3];
    pthread_mutex_lock((pthread_mutex_t *)(v68 + 8));
    v69 = *(const _CFCachedURLResponse **)(v68 + 72);
    pthread_mutex_unlock((pthread_mutex_t *)(v68 + 8));
    __CFURLCache::RemoveResponseFromCacheContainers((int8x8_t *)a1, (__CFURLCacheNode *)v68, v69, v70);
    v71 = CFHash(v28);
    std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::__emplace_unique_key_args<unsigned long,std::pair<unsigned long,__CFURLCacheNode *>>((float *)(a1 + 224), v71, v71, v37);
    if (v72)
    {
      std::deque<__CFURLCacheNode *>::push_front((char **)(a1 + 264), v94);
      pthread_mutex_lock((pthread_mutex_t *)(v37 + 8));
      v73 = *(_QWORD *)(v37 + 72);
      pthread_mutex_unlock((pthread_mutex_t *)(v37 + 8));
      *(_QWORD *)(a1 + 144) += *(_QWORD *)(*(_QWORD *)(v73 + 16) + 96) + 512;
      v41 = 1;
      *(_BYTE *)(v37 + 113) = 1;
    }
    else
    {
      __CFURLCache::logCacheEvent(a1, 22, *(CFTypeRef *)(v37 + 80));
      v41 = 0;
    }
    v25 = v84;
    v23 = v86;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 312));
  v14 = v82;
LABEL_56:
  if (!v23 && (v41 & 1) == 0)
    (*(void (**)(uint64_t))(*(_QWORD *)v37 + 8))(v37);
  v74 = CFGetTypeID(v25);
  v75 = MEMORY[0x1E0C809B0];
  v94[0] = MEMORY[0x1E0C809B0];
  v94[1] = 3221225472;
  v94[2] = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_2382;
  v94[3] = &__block_descriptor_40_e5_v8__0l;
  v94[4] = _CachedURLResponseRegisterClass;
  if (_CFCachedURLResponseClassRegistration != -1)
    dispatch_once(&_CFCachedURLResponseClassRegistration, v94);
  v76 = !v14;
  if (v74 != kCFCachedURLResponseTypeID)
    v76 = 1;
  if ((v76 & 1) == 0)
  {
    __CFURLCache::logCacheEvent(a1, 10, cf);
    v77 = __CFURLCache::createAndOpenCacheDB((__CFURLCache *)a1);
    if (v77)
    {
      v78 = v77;
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 552));
      Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 536));
      CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 536), key, v25);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 552));
      if (!Count)
      {
        v80 = CFRetain(*(CFTypeRef *)(a1 + 440));
        block = v75;
        v88 = 3221225472;
        v89 = ___ZN12__CFURLCache23CreateAndStoreCacheNodeEP16__CFURLCacheNodePK20_CFCachedURLResponsePK10__CFStringPK13_CFURLRequestPKvbRb_block_invoke;
        v90 = &unk_1E14FE140;
        v91 = v78;
        v92 = (id)v80;
        v81 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, QOS_CLASS_UTILITY, 0, &block);
        dispatch_async(*(dispatch_queue_t *)(a1 + 136), v81);
        _Block_release(v81);
      }

    }
  }
  if (v41)
    *a2 = 0;
LABEL_70:
  CFRelease(v4);
}

void sub_183F2AAE8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10E1C401F6CB577);
  _Unwind_Resume(a1);
}

void __CFURLCache::logCacheEvent(uint64_t a1, int a2, CFTypeRef cf)
{
  NSObject *v6;
  uint64_t v7;
  _QWORD v8[7];
  int v9;

  if (*(_QWORD *)(a1 + 32))
  {
    if (*(_QWORD *)(a1 + 24))
      v6 = *(NSObject **)(a1 + 24);
    else
      v6 = MEMORY[0x1E0C80D38];
    v7 = *(_QWORD *)(a1 + 440);
    if (v7)
      CFRetain(*(CFTypeRef *)(a1 + 440));
    if (cf)
      CFRetain(cf);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = ___ZN12__CFURLCache13logCacheEventE19CFURLCacheEventTypePK13_CFURLRequest_block_invoke;
    v8[3] = &__block_descriptor_60_e5_v8__0l;
    v9 = a2;
    v8[4] = a1;
    v8[5] = v7;
    v8[6] = cf;
    dispatch_async(v6, v8);
  }
}

void __CFCachedURLResponse::SetRequest(__CFCachedURLResponse *this, const _CFURLRequest *a2)
{
  os_unfair_lock_s *v4;

  v4 = (os_unfair_lock_s *)((char *)this + 88);
  os_unfair_lock_lock((os_unfair_lock_t)this + 22);
  if (a2 && !*((_QWORD *)this + 14))
    *((_QWORD *)this + 14) = CFRetain(a2);
  os_unfair_lock_unlock(v4);
}

id __CFCachedURLResponse::GetNSCachedURLResponse(__CFCachedURLResponse *this)
{
  id v2;
  _QWORD v4[5];

  os_unfair_lock_lock((os_unfair_lock_t)this + 22);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN21__CFCachedURLResponse22GetNSCachedURLResponseEv_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = this;
  v2 = *((id *)this + 13);
  ___ZN21__CFCachedURLResponse22GetNSCachedURLResponseEv_block_invoke((uint64_t)v4);
  return v2;
}

void sub_183F2AC90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  a12(&a10);
  _Unwind_Resume(a1);
}

void ___ZN21__CFCachedURLResponse22GetNSCachedURLResponseEv_block_invoke(uint64_t a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 88));
}

void __CFCachedURLResponse::SetKey(__CFCachedURLResponse *this, const __CFString *a2)
{
  os_unfair_lock_s *v4;
  const void *v5;
  CFTypeRef v6;

  v4 = (os_unfair_lock_s *)((char *)this + 88);
  os_unfair_lock_lock((os_unfair_lock_t)this + 22);
  v5 = (const void *)*((_QWORD *)this + 16);
  if (a2)
  {
    if (v5)
      CFRelease(v5);
    v6 = CFRetain(a2);
    goto LABEL_7;
  }
  if (v5)
  {
    CFRelease(v5);
    v6 = 0;
LABEL_7:
    *((_QWORD *)this + 16) = v6;
  }
  os_unfair_lock_unlock(v4);
}

void ___ZN12__CFURLCache43CopyResponseForRequestWithCompletionHandlerEPK13_CFURLRequestbP12NSURLSessionU13block_pointerFvPK20_CFCachedURLResponseE_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
    requestURLIsBlocked(*(NSURL **)(a1 + 32));
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  v3 = *(const void **)(a1 + 48);
  if (v3)
    CFRelease(v3);
}

void sub_183F2B0EC(void *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_unfair_lock_t lock, uint64_t a16, uint64_t a17, uint64_t a18)
{
  id v18;

  if (a2 == 2)
  {
    v18 = objc_retainAutorelease(objc_begin_catch(exc_buf));
    objc_exception_throw(v18);
  }
  objc_begin_catch(exc_buf);
  os_unfair_lock_unlock(lock);
  objc_exception_rethrow();
}

void sub_183F2B174()
{
  objc_end_catch();
  JUMPOUT(0x183F2B17CLL);
}

char *_ExtractCStringfromCFStringRef(const __CFString *a1, BOOL *a2)
{
  char *CStringPtr;
  CFIndex Length;
  CFIndex v6;

  *a2 = 0;
  if (!a1)
    return 0;
  CStringPtr = (char *)CFStringGetCStringPtr(a1, 0x8000100u);
  if (!CStringPtr)
  {
    Length = CFStringGetLength(a1);
    v6 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    CStringPtr = (char *)operator new[]();
    if (CFStringGetCString(a1, CStringPtr, v6, 0x8000100u))
    {
      *a2 = 1;
      return CStringPtr;
    }
    MEMORY[0x186DB7474](CStringPtr, 0x1000C8077774924);
    return 0;
  }
  return CStringPtr;
}

uint64_t __CFURLCache::RemoveResponseFromCacheContainers(int8x8_t *this, __CFURLCacheNode *NodeFromHashMap, const _CFCachedURLResponse *a3, const __CFString *a4)
{
  __CFCachedURLResponse *var1;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int8x8_t v9;
  int8x8_t v10;
  int8x8_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  int8x8_t *v17;
  int8x8_t *v18;
  int8x8_t v19;
  unint64_t v20;
  uint8x8_t v21;
  int8x8_t *v22;
  int8x8_t *v23;
  unint64_t v24;
  unint64_t v25;
  int8x8_t v26;
  unint64_t v27;

  if (!a3)
    return 0;
  var1 = a3->var1;
  v6 = *((_QWORD *)var1 + 12);
  v7 = *((_QWORD *)var1 + 8);
  if (!NodeFromHashMap)
  {
    NodeFromHashMap = (__CFURLCacheNode *)__CFURLCache::GetNodeFromHashMap((__CFURLCache *)this, *((_QWORD *)var1 + 8));
    if (!NodeFromHashMap)
      return 0;
  }
  v8 = v6 + 512;
  v9 = this[37];
  v10 = this[34];
  v11 = this[35];
  v12 = *(_QWORD *)&v10 + 8 * (*(_QWORD *)&v9 >> 9);
  if (*(_QWORD *)&v11 == *(_QWORD *)&v10)
    v13 = 0;
  else
    v13 = (char *)(*(_QWORD *)v12 + 8 * (*(_QWORD *)&this[37] & 0x1FFLL));
LABEL_8:
  v14 = v13 - 4096;
  while (1)
  {
    v15 = *(_QWORD *)&v11 == *(_QWORD *)&v10
        ? 0
        : *(_QWORD *)(*(_QWORD *)&v10 + (((*(_QWORD *)&this[38] + *(_QWORD *)&v9) >> 6) & 0x3FFFFFFFFFFFFF8))
        + 8 * ((*(_QWORD *)&this[38] + *(_QWORD *)&v9) & 0x1FFLL);
    if (v13 == (char *)v15)
      break;
    if (NodeFromHashMap == *(__CFURLCacheNode **)v13)
    {
      *((_BYTE *)NodeFromHashMap + 113) = 0;
      (*(void (**)(__CFURLCacheNode *))(*(_QWORD *)NodeFromHashMap + 8))(NodeFromHashMap);
      std::deque<__CFURLCacheNode *>::erase((uint64_t)&this[33], (char *)v12, v13);
      break;
    }
    v13 += 8;
    v14 += 8;
    if (*(char **)v12 == v14)
    {
      v16 = *(char **)(v12 + 8);
      v12 += 8;
      v13 = v16;
      goto LABEL_8;
    }
  }
  v17 = this + 28;
  v18 = (int8x8_t *)std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::find<unsigned long>(&this[28], v7);
  if (v18)
  {
    v19 = this[29];
    v20 = (unint64_t)v18[1];
    v21 = (uint8x8_t)vcnt_s8(v19);
    v21.i16[0] = vaddlv_u8(v21);
    if (v21.u32[0] > 1uLL)
    {
      if (v20 >= *(_QWORD *)&v19)
        v20 %= *(_QWORD *)&v19;
    }
    else
    {
      v20 &= *(_QWORD *)&v19 - 1;
    }
    v22 = *(int8x8_t **)(*(_QWORD *)v17 + 8 * v20);
    do
    {
      v23 = v22;
      v22 = (int8x8_t *)*v22;
    }
    while (v22 != v18);
    if (v23 == &this[30])
      goto LABEL_35;
    v24 = (unint64_t)v23[1];
    if (v21.u32[0] > 1uLL)
    {
      if (v24 >= *(_QWORD *)&v19)
        v24 %= *(_QWORD *)&v19;
    }
    else
    {
      v24 &= *(_QWORD *)&v19 - 1;
    }
    if (v24 != v20)
    {
LABEL_35:
      if (!*(_QWORD *)v18)
        goto LABEL_36;
      v25 = *(_QWORD *)(*(_QWORD *)v18 + 8);
      if (v21.u32[0] > 1uLL)
      {
        if (v25 >= *(_QWORD *)&v19)
          v25 %= *(_QWORD *)&v19;
      }
      else
      {
        v25 &= *(_QWORD *)&v19 - 1;
      }
      if (v25 != v20)
LABEL_36:
        *(_QWORD *)(*(_QWORD *)v17 + 8 * v20) = 0;
    }
    v26 = *v18;
    if (*v18)
    {
      v27 = *(_QWORD *)(*(_QWORD *)&v26 + 8);
      if (v21.u32[0] > 1uLL)
      {
        if (v27 >= *(_QWORD *)&v19)
          v27 %= *(_QWORD *)&v19;
      }
      else
      {
        v27 &= *(_QWORD *)&v19 - 1;
      }
      if (v27 != v20)
      {
        *(_QWORD *)(*(_QWORD *)v17 + 8 * v27) = v23;
        v26 = *v18;
      }
    }
    *v23 = v26;
    *v18 = 0;
    --*(_QWORD *)&this[31];
    operator delete(v18);
  }
  *(_QWORD *)&this[18] -= v8;
  return v8;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::__emplace_unique_key_args<unsigned long,std::pair<unsigned long,__CFURLCacheNode *>>(float *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  int8x8_t prime;
  void *v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;
  uint8x8_t v25;
  unint64_t v26;
  uint8x8_t v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  _QWORD *v35;

  v8 = (int)a2;
  v9 = *((_QWORD *)a1 + 1);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v4 = (int)a2;
      if ((int)a2 >= v9)
        v4 = (int)a2 % v9;
    }
    else
    {
      v4 = (v9 - 1) & (int)a2;
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == (int)a2)
        {
          if (i[2] == a2)
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v4)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v8;
  i[2] = a3;
  i[3] = a4;
  v14 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v15 = a1[8];
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    v16 = 1;
    if (v9 >= 3)
      v16 = (v9 & (v9 - 1)) != 0;
    v17 = v16 | (2 * v9);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      prime = (int8x8_t)v18;
    else
      prime = (int8x8_t)v17;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v9 = *((_QWORD *)a1 + 1);
    }
    if (*(_QWORD *)&prime > v9)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v9)
    {
      v26 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v9 < 3 || (v27 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        v26 = std::__next_prime(v26);
      }
      else
      {
        v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2)
          v26 = v28;
      }
      if (*(_QWORD *)&prime <= v26)
        prime = (int8x8_t)v26;
      if (*(_QWORD *)&prime >= v9)
      {
        v9 = *((_QWORD *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v20 = operator new(8 * *(_QWORD *)&prime);
          v21 = *(_QWORD **)a1;
          *(_QWORD *)a1 = v20;
          if (v21)
            operator delete(v21);
          v22 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v22++) = 0;
          while (*(_QWORD *)&prime != v22);
          v23 = (_QWORD *)*((_QWORD *)a1 + 2);
          if (v23)
          {
            v24 = v23[1];
            v25 = (uint8x8_t)vcnt_s8(prime);
            v25.i16[0] = vaddlv_u8(v25);
            if (v25.u32[0] > 1uLL)
            {
              if (v24 >= *(_QWORD *)&prime)
                v24 %= *(_QWORD *)&prime;
            }
            else
            {
              v24 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = a1 + 4;
            v29 = (_QWORD *)*v23;
            if (*v23)
            {
              do
              {
                v30 = v29[1];
                if (v25.u32[0] > 1uLL)
                {
                  if (v30 >= *(_QWORD *)&prime)
                    v30 %= *(_QWORD *)&prime;
                }
                else
                {
                  v30 &= *(_QWORD *)&prime - 1;
                }
                if (v30 != v24)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v30))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v30) = v23;
                    goto LABEL_55;
                  }
                  *v23 = *v29;
                  *v29 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v30);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v30) = v29;
                  v29 = v23;
                }
                v30 = v24;
LABEL_55:
                v23 = v29;
                v29 = (_QWORD *)*v29;
                v24 = v30;
              }
              while (v29);
            }
          }
          v9 = (unint64_t)prime;
          goto LABEL_59;
        }
        v35 = *(_QWORD **)a1;
        *(_QWORD *)a1 = 0;
        if (v35)
          operator delete(v35);
        v9 = 0;
        *((_QWORD *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v4 = v8 % v9;
      else
        v4 = v8;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
  }
  v31 = *(_QWORD **)a1;
  v32 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v32)
  {
    *i = *v32;
LABEL_72:
    *v32 = i;
    goto LABEL_73;
  }
  *i = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = i;
  v31[v4] = a1 + 4;
  if (*i)
  {
    v33 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v33 >= v9)
        v33 %= v9;
    }
    else
    {
      v33 &= v9 - 1;
    }
    v32 = (_QWORD *)(*(_QWORD *)a1 + 8 * v33);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
  return i;
}

void sub_183F2B8A0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void CFURLCacheFS::~CFURLCacheFS(CFURLCacheFS *this)
{
  CFURLCacheFS::~CFURLCacheFS(this);
  JUMPOUT(0x186DB748CLL);
}

{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  *(_QWORD *)this = &off_1E14E5790;
  v2 = (const void *)*((_QWORD *)this + 9);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 11);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 13);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 10);
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 12);
  if (v6)
    CFRelease(v6);
  if (*((_QWORD *)this + 14) && *((_BYTE *)this + 120))
    MEMORY[0x186DB7474]();
  *(_QWORD *)this = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
}

void sub_183F2B978(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)v1 = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(a1);
}

void ___ZN19URLConnectionLoader19initiateCacheLookupEP12NSURLRequestPK9XURLCache23NSURLRequestCachePolicy_block_invoke(_QWORD *a1, CFTypeRef cf)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  _QWORD v7[8];

  v4 = a1[5];
  if (cf)
    CFRetain(cf);
  v5 = *(NSObject **)(v4 + 40);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN19URLConnectionLoader19initiateCacheLookupEP12NSURLRequestPK9XURLCache23NSURLRequestCachePolicy_block_invoke_2;
  v7[3] = &unk_1E14FAF58;
  v7[4] = a1[4];
  v7[5] = v4;
  v6 = a1[6];
  v7[6] = cf;
  v7[7] = v6;
  dispatch_async(v5, v7);
}

void __CFURLCacheNode::~__CFURLCacheNode(__CFURLCacheNode *this)
{
  __CFURLCacheNode::~__CFURLCacheNode(this);
  JUMPOUT(0x186DB748CLL);
}

{
  const void *v2;
  const void *v3;
  const void *v4;

  *(_QWORD *)this = &off_1E14E83D0;
  *((_BYTE *)this + 112) = 0;
  v2 = (const void *)*((_QWORD *)this + 9);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 9) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 10);
  if (v3)
  {
    CFRelease(v3);
    *((_QWORD *)this + 10) = 0;
  }
  v4 = (const void *)*((_QWORD *)this + 11);
  if (v4)
  {
    CFRelease(v4);
    *((_QWORD *)this + 11) = 0;
  }
  *(_QWORD *)this = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
}

void sub_183F2BD00(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)v1 = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(a1);
}

void __CFURLCacheAddCachedResponseForRequestWithSession(_CFURLCache *a1, HTTPProtocol *a2, _CFCachedURLResponse *a3, _CFURLRequest *a4, const void *a5)
{
  id v10;
  void *v11;
  HTTPMessage *v12;
  __CFString *v13;
  const _CFURLRequest *v14;
  __CFString *v15;
  uint64_t TypeID;
  __CFDictionary *v17;
  __CFDictionary *v18;
  uint64_t v19;
  uint64_t v20;
  const __CFAllocator *v21;
  __CFString *v22;
  __CFString *CacheKeyForRequest;
  uint64_t v24;
  void (**v25)(AutoString *__hidden);
  CFStringRef v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (a3 && a4)
  {
    v10 = *((id *)a3->var1 + 4);
    v11 = v10;
    if (v10 && (v12 = *(HTTPMessage **)(objc_msgSend(v10, "_inner") + 88)) != 0)
    {
      v13 = (__CFString *)HTTPMessage::copyHeaderFieldValue(v12, (const __CFString *)&unk_1EDCFD900);
      if (v13)
      {
        if (__CFURLCacheIsVaryHeaderSupportEnabled(a1))
        {
          v15 = (__CFString *)CFURLGetString(*(CFURLRef *)(-[_CFURLRequest _inner](a4, "_inner") + 8));
          TypeID = CFURLCacheGetTypeID();
          if (TypeID == CFGetTypeID(a1))
          {
            __CFURLCache::_updateVaryStateForURL(*((__CFURLCache **)a1 + 2), v13, v15);
          }
          else if ((objc_opt_respondsToSelector() & 1) != 0)
          {
            -[_CFURLCache performSelector:withObject:withObject:](a1, "performSelector:withObject:withObject:", sel__updateVaryState_forURL_, v13, v15);
          }
        }
        v17 = HTTPProtocol::copyVaryState(a2, v13, a4, v14);
        if (v17)
        {
          v18 = v17;
          v19 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_55, 1);
          if (v19)
          {
            v20 = v19;
            if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v19 + 16))(v19, "Vary Persistence", 0))
            {
              v21 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
              (*(void (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v20 + 40))(v20, "Request", *(_QWORD *)(-[_CFURLRequest _inner](a4, "_inner") + 8));
              v25 = &off_1E14E4818;
              v27 = 0;
              v28 = 0;
              v26 = CFStringCreateWithCString(v21, "VaryHeader", 0x8000100u);
              (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(_QWORD *)v20 + 64))(v20, v26, v13);
              AutoString::~AutoString((AutoString *)&v25);
              if (__CFNCanLogSensitiveContent::onceToken != -1)
                dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_26_4798);
              if (__CFNCanLogSensitiveContent::ok)
                (*(void (**)(uint64_t, const char *, __CFDictionary *))(*(_QWORD *)v20 + 96))(v20, "VaryState", v18);
              (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
            }
          }
          URLRequest::setProtocolProperty((URLRequest *)-[_CFURLRequest _inner](a4, "_inner", v25), v13, v18);
          CFRelease(v18);
        }
      }
    }
    else
    {
      v13 = 0;
    }

    if (__CFURLCacheIsVaryHeaderSupportEnabled(a1))
      v22 = v13;
    else
      v22 = 0;
    CacheKeyForRequest = _createCacheKeyForRequest(a4, 0, v22);
    if (v13)
      CFRelease(v13);
    v24 = operator new();
    __CFURLCacheNode::__CFURLCacheNode(v24, a3, CacheKeyForRequest, a4, 0);
    v25 = (void (**)(AutoString *__hidden))v24;
    CFCachedURLResponseSetNSCachedURLResponse(a3, a5);
    __CFURLCache::AddCacheTask(*((_QWORD *)a1 + 2), (uint64_t *)&v25);
    if (v25)
      (*((void (**)(_QWORD))*v25 + 1))(v25);
    if (CacheKeyForRequest)
      CFRelease(CacheKeyForRequest);
  }
}

void sub_183F2C044(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  AutoString::~AutoString((AutoString *)&a9);
  _Unwind_Resume(a1);
}

uint64_t __CFURLCacheNode::__CFURLCacheNode(uint64_t a1, _QWORD *a2, const void *a3, const void *a4, int a5)
{
  CFTypeRef v10;
  uint8_t v12[16];

  *(_QWORD *)a1 = &off_1E14E6990;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 8), 0);
  *(_QWORD *)a1 = &off_1E14E83D0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 4;
  *(_QWORD *)(a1 + 72) = 0;
  *(_WORD *)(a1 + 112) = 1;
  if (a3)
  {
    if (a2)
    {
      if (!a2[2] && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v12 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "CFURLCacheNode: malformed cachedResponse encountered", v12, 2u);
      }
      *(_QWORD *)(a1 + 72) = CFRetain(a2);
    }
    if (a4)
      v10 = CFRetain(a4);
    else
      v10 = 0;
    *(_QWORD *)(a1 + 80) = v10;
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 88) = CFRetain(a3);
    *(_DWORD *)(a1 + 96) = a5;
  }
  return a1;
}

void sub_183F2C298(_Unwind_Exception *a1)
{
  _QWORD *v1;
  pthread_mutex_t *v2;
  uint64_t v3;

  *v1 = v3;
  pthread_mutex_destroy(v2);
  _Unwind_Resume(a1);
}

_QWORD *__CFURLCacheIsVaryHeaderSupportEnabled(_QWORD *result)
{
  _QWORD *v1;
  uint64_t TypeID;
  const char *v3;

  if (result)
  {
    v1 = result;
    TypeID = CFURLCacheGetTypeID();
    if (TypeID == CFGetTypeID(v1))
    {
      return (_QWORD *)(*(_BYTE *)(v1[2] + 632) != 0);
    }
    else if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      v3 = (const char *)__CFURLCacheIsVaryHeaderSupportEnabled::s;
      if (!__CFURLCacheIsVaryHeaderSupportEnabled::s)
      {
        v3 = sel_registerName("_isVaryHeaderSupportEnabled");
        __CFURLCacheIsVaryHeaderSupportEnabled::s = (uint64_t)v3;
      }
      return objc_msgSend(v1, v3);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void std::deque<__CFURLCacheNode *>::push_front(char **a1, _QWORD *a2)
{
  unint64_t v4;
  char *v5;
  char *v6;
  uint64_t v7;
  char *v8;
  char *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  char *v19;
  unint64_t v20;
  char *v21;
  uint64_t v22;
  char *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  char *v29;
  char *v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  char *v53;
  uint64_t v54;
  char *v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;

  v4 = (unint64_t)a1[4];
  if (!v4)
  {
    v6 = a1[1];
    v5 = a1[2];
    v7 = ((v5 - v6) << 6) - 1;
    if (v5 == v6)
      v7 = 0;
    if ((unint64_t)(v7 - (_QWORD)a1[5]) < 0x200)
    {
      v8 = a1[3];
      v9 = *a1;
      v10 = v8 - *a1;
      if (v5 - v6 >= (unint64_t)v10)
      {
        if (v8 == v9)
          v14 = 1;
        else
          v14 = v10 >> 2;
        v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v14);
        v17 = v16;
        v18 = operator new(0x1000uLL);
        if (v17)
        {
          v19 = &v15[8 * v17];
        }
        else
        {
          v32 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(1uLL);
          v19 = &v32[8 * v33];
          if (v15)
            operator delete(v15);
          v15 = v32;
        }
        *(_QWORD *)v15 = v18;
        v34 = v15 + 8;
        v35 = a1[1];
        if (v35 == a1[2])
        {
          v38 = v15;
          v36 = v15;
          v52 = v15 + 8;
        }
        else
        {
          v36 = v15;
          do
          {
            if (v34 == v19)
            {
              if (v15 <= v36)
              {
                if (v34 == v36)
                  v43 = 1;
                else
                  v43 = (v34 - v36) >> 2;
                v44 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v43);
                v46 = v44;
                v38 = &v44[8 * (v43 >> 2)];
                v37 = v38;
                v47 = v34 - v15;
                if (v34 != v15)
                {
                  v37 = &v38[v47 & 0xFFFFFFFFFFFFFFF8];
                  v48 = 8 * (v47 >> 3);
                  v49 = v38;
                  do
                  {
                    v50 = *(_QWORD *)v15;
                    v15 += 8;
                    *(_QWORD *)v49 = v50;
                    v49 += 8;
                    v48 -= 8;
                  }
                  while (v48);
                }
                v34 = &v44[8 * v45];
                if (v36)
                  operator delete(v36);
                v36 = v46;
              }
              else
              {
                v39 = (v15 - v36) >> 3;
                if (v39 >= -1)
                  v40 = v39 + 1;
                else
                  v40 = v39 + 2;
                v41 = v34;
                if (v34 != v15)
                {
                  memmove(&v15[-8 * (v40 >> 1)], v15, v34 - v15);
                  v41 = v15;
                }
                v42 = -(v40 >> 1);
                v37 = &v34[-8 * (v40 >> 1)];
                v38 = &v41[8 * v42];
              }
            }
            else
            {
              v37 = v34;
              v38 = v15;
              v34 = v19;
            }
            v19 = v34;
            v51 = *(_QWORD *)v35;
            v35 += 8;
            *(_QWORD *)v37 = v51;
            v52 = v37 + 8;
            v34 = v52;
            v15 = v38;
          }
          while (v35 != a1[2]);
        }
        v53 = *a1;
        *a1 = v36;
        a1[1] = v38;
        a1[2] = v52;
        a1[3] = v19;
        if (v52 - v38 == 8)
          v54 = 256;
        else
          v54 = (uint64_t)(a1[4] + 512);
        a1[4] = (char *)v54;
        if (v53)
          operator delete(v53);
      }
      else
      {
        v11 = operator new(0x1000uLL);
        v12 = v11;
        if (v6 == v9)
        {
          if (v5 == v8)
          {
            if (v5 == v6)
              v20 = 1;
            else
              v20 = (v5 - v9) >> 2;
            v21 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v20);
            v23 = &v21[8 * (v20 >> 2)];
            v24 = a1[1];
            v5 = v23;
            v25 = a1[2] - v24;
            if (v25)
            {
              v5 = &v23[v25 & 0xFFFFFFFFFFFFFFF8];
              v26 = 8 * (v25 >> 3);
              v27 = v23;
              do
              {
                v28 = *(_QWORD *)v24;
                v24 += 8;
                *(_QWORD *)v27 = v28;
                v27 += 8;
                v26 -= 8;
              }
              while (v26);
            }
            v29 = *a1;
            *a1 = v21;
            a1[1] = v23;
            a1[2] = v5;
            a1[3] = &v21[8 * v22];
            if (v29)
            {
              operator delete(v29);
              v5 = a1[2];
            }
          }
          *(_QWORD *)v5 = v12;
          v30 = a1[2];
          a1[2] = v30 + 8;
          v59 = *(_QWORD *)v30;
          a1[2] = v30;
          std::__split_buffer<__CFURLCacheNode **>::push_front((uint64_t)a1, &v59);
          v13 = (uint64_t)a1[1];
        }
        else
        {
          *((_QWORD *)v6 - 1) = v11;
          v13 = (uint64_t)(a1[1] - 8);
          a1[1] = (char *)v13;
        }
        if (&a1[2][-v13] == (char *)8)
          v31 = 256;
        else
          v31 = (uint64_t)(a1[4] + 512);
        a1[4] = (char *)v31;
      }
    }
    else
    {
      a1[4] = (char *)512;
      v59 = *((_QWORD *)v5 - 1);
      a1[2] = v5 - 8;
      std::__split_buffer<__CFURLCacheNode **>::push_front((uint64_t)a1, &v59);
    }
    v4 = (unint64_t)a1[4];
  }
  v55 = a1[1];
  v56 = &v55[8 * (v4 >> 9)];
  if (a1[2] == v55)
    v57 = 0;
  else
    v57 = *(_QWORD *)v56 + 8 * (v4 & 0x1FF);
  if (v57 == *(_QWORD *)v56)
    v57 = *((_QWORD *)v56 - 1) + 4096;
  *(_QWORD *)(v57 - 8) = *a2;
  v58 = (uint64_t)(a1[5] + 1);
  a1[4] = (char *)(v4 - 1);
  a1[5] = (char *)v58;
}

void sub_183F2C6D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v1);
  if (v2)
    operator delete(v2);
  _Unwind_Resume(a1);
}

const char *requestURLIsBlocked(NSURL *a1)
{
  const char *result;
  const char *v2;
  NSObject *v3;
  int v4;
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  result = -[NSString UTF8String](-[NSURL host](a1, "host"), "UTF8String");
  if (result)
  {
    v2 = result;
    if (ne_tracker_check_is_hostname_blocked() == 1)
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v3 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v4 = 136315138;
        v5 = v2;
        _os_log_impl(&dword_183ECA000, v3, OS_LOG_TYPE_DEFAULT, "Ignoring cached response of blocked tracker: %s", (uint8_t *)&v4, 0xCu);
      }
      return (const char *)1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t __createCachedResponseFromParts(int a1, const UInt8 *a2, CFIndex a3, UInt8 *bytes, CFIndex length, const UInt8 *a6, CFIndex a7, const UInt8 *a8, CFIndex a9, const UInt8 *a10, CFIndex a11)
{
  const __CFAllocator *v15;
  const __CFAllocator *v16;
  CFReadStreamRef v17;
  unint64_t v18;
  CFPropertyListFormat *v19;
  const __CFString **v20;
  __CFDictionary *v21;
  BOOL v22;
  const __CFData *v23;
  const __CFData *v24;
  const __CFAllocator *v25;
  const void *v26;
  const __CFAllocator *v27;
  const _CFURLRequest *v28;
  const __CFData *v29;
  const __CFData *v30;
  const __CFData *v31;
  const __CFData *v32;
  NSURLRequestInternal *v33;
  CFTypeID v34;
  const __CFNumber *Value;
  CFPropertyListFormat v36;
  const __CFArray *v37;
  const __CFArray *v38;
  CFIndex Count;
  const void **v40;
  const void **v41;
  uint64_t v42;
  CFTypeID v43;
  int v44;
  const void *v45;
  const void *v46;
  const _CFURLRequest *v47;
  uint64_t v48;
  CFErrorRef v49;
  CFDataRef v50;
  __CFReadStream *v51;
  unint64_t v52;
  CFPropertyListFormat *v53;
  const __CFString **v54;
  CFPropertyListRef v55;
  uint64_t v57;
  NSURLRequestInternal *v58;
  int v59;
  __CFDictionary *v60;
  uint64_t v61;
  URLRequest *v62;
  CFTypeRef cf;
  CFErrorRef v66;
  CFErrorRef error;
  CFPropertyListFormat format;
  CFRange v69;

  cf = 0;
  v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v16 = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
  if (!bytes)
    goto LABEL_10;
  v17 = CFReadStreamCreateWithBytesNoCopy(v15, bytes, length, v16);
  if (!CFReadStreamOpen(v17))
  {
    CFRelease(v17);
LABEL_10:
    v21 = 0;
    goto LABEL_11;
  }
  v21 = (__CFDictionary *)dep_CFPropertyListCreateFromStream(v15, v17, (CFStringRef *)&cf, v18, v19, v20);
  if (v21)
    v22 = 1;
  else
    v22 = cf == 0;
  if (!v22)
    CFRelease(cf);
  CFReadStreamClose(v17);
  CFRelease(v17);
LABEL_11:
  format = kCFPropertyListXMLFormat_v1_0;
  v23 = CFDataCreateWithBytesNoCopy(v15, a2, a3, v16);
  if (v23)
  {
    v24 = v23;
    error = 0;
    v25 = (const __CFAllocator *)CFPropertyListCreateWithData(v15, v23, 0, &format, &error);
    if (v25)
    {
      v27 = v25;
      v28 = (const _CFURLRequest *)_CFURLResponseCreateFromPropertyList(v25, v26);
      CFRelease(v24);
      v24 = v27;
    }
    else
    {
      v28 = 0;
    }
    CFRelease(v24);
  }
  else
  {
    v28 = 0;
  }
  error = (CFErrorRef)100;
  v29 = CFDataCreateWithBytesNoCopy(v15, a8, a9, v16);
  if (!v29)
  {
    v48 = 0;
    if (v28)
    {
LABEL_72:
      CFRelease(v28);
      goto LABEL_73;
    }
    goto LABEL_73;
  }
  v30 = v29;
  v66 = 0;
  v31 = (const __CFData *)CFPropertyListCreateWithData(v15, v29, 0, (CFPropertyListFormat *)&error, &v66);
  if (!v31)
  {
    v47 = 0;
    v49 = v66;
    v32 = v30;
    if (!v66)
      goto LABEL_49;
    goto LABEL_48;
  }
  v32 = v31;
  v33 = objc_alloc_init(NSURLRequestInternal);
  v62 = -[NSURLRequestInternal _inner](v33, "_inner");
  v34 = CFGetTypeID(v32);
  if (v34 != CFDictionaryGetTypeID())
    goto LABEL_44;
  Value = (const __CFNumber *)CFDictionaryGetValue(v32, CFSTR("Version"));
  if (!Value)
    goto LABEL_44;
  format = 0;
  v36 = CFNumberGetValue(Value, kCFNumberCFIndexType, &format) ? format : 0;
  v37 = (const __CFArray *)CFDictionaryGetValue(v32, CFSTR("Array"));
  if (!v37)
    goto LABEL_44;
  v38 = v37;
  v57 = v36;
  v58 = v33;
  v59 = a1;
  v60 = v21;
  Count = CFArrayGetCount(v37);
  v40 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
  v69.location = 0;
  v69.length = Count;
  CFArrayGetValues(v38, v69, v40);
  v61 = Count;
  if (Count >= 2)
  {
    v41 = v40 - 1;
    v42 = v61;
    do
    {
      v43 = CFGetTypeID(v41[v42]);
      if (v43 == CFStringGetTypeID() && CFEqual(CFSTR("__CFURLRequestNullTokenString__"), v41[v42]))
        v41[v42] = 0;
      --v42;
    }
    while ((unint64_t)(v42 + 1) > 2);
  }
  if (v40[1])
    v40[1] = (const void *)_CFURLCreateFromPropertyListRepresentation();
  v21 = v60;
  if (v40[4])
    v40[4] = (const void *)_CFURLCreateFromPropertyListRepresentation();
  v44 = URLRequest::initialize(v62, v57, v40, v61, v60);
  v45 = v40[1];
  a1 = v59;
  if (v45)
    CFRelease(v45);
  v46 = v40[4];
  if (v46)
    CFRelease(v46);
  free(v40);
  v33 = v58;
  if (!v44)
  {
LABEL_44:

    goto LABEL_45;
  }
  if (!v58)
  {
LABEL_45:
    v47 = 0;
    goto LABEL_46;
  }
  v47 = -[NSURLRequest _initWithInternal:]([NSMutableURLRequest alloc], "_initWithInternal:", v58);

LABEL_46:
  v49 = v30;
LABEL_48:
  CFRelease(v49);
  v30 = v32;
LABEL_49:
  CFRelease(v30);
  if (v28 && v47)
  {
    if (a6)
    {
      v50 = CFDataCreate(v15, a6, a7);
      if (!a10)
        goto LABEL_66;
    }
    else
    {
      v50 = 0;
      if (!a10)
        goto LABEL_66;
    }
    v51 = CFReadStreamCreateWithBytesNoCopy(v15, a10, a11, v16);
    if (CFReadStreamOpen(v51))
    {
      v55 = dep_CFPropertyListCreateFromStream(v15, v51, (CFStringRef *)&cf, v52, v53, v54);
      if (!v55 && cf)
        CFRelease(cf);
      CFReadStreamClose(v51);
      CFRelease(v51);
      v48 = CFCachedURLResponseCreateWithUserInfo((uint64_t)v15, v28, v50, v55, a1);
      if (v55)
        CFRelease(v55);
      goto LABEL_67;
    }
    CFRelease(v51);
LABEL_66:
    v48 = CFCachedURLResponseCreateWithUserInfo((uint64_t)v15, v28, v50, 0, a1);
LABEL_67:
    if (v50)
      CFRelease(v50);
    if (v48)
      __CFCachedURLResponse::SetRequest(*(__CFCachedURLResponse **)(v48 + 16), v47);
    CFRelease(v28);
    v28 = v47;
    goto LABEL_72;
  }
  if (v28)
    CFRelease(v28);
  v48 = 0;
  v28 = v47;
  if (v47)
    goto LABEL_72;
LABEL_73:
  if (v21)
    CFRelease(v21);
  return v48;
}

uint64_t _CFURLResponseCreateFromPropertyList(const __CFAllocator *a1, const void *a2)
{
  NSURLResponseInternal *v3;
  URLResponse *v4;
  CFTypeID v5;
  const __CFNumber *Value;
  const __CFArray *v7;
  const __CFArray *v8;
  CFIndex Count;
  const void **v10;
  const void **v11;
  CFIndex v12;
  CFTypeID v13;
  HTTPMessage *fHTTP;
  uint64_t v15;
  uint64_t valuePtr;
  CFRange v18;

  v3 = objc_alloc_init(NSURLResponseInternal);
  v4 = -[NSURLResponseInternal _inner](v3, "_inner");
  v5 = CFGetTypeID(a1);
  if (v5 == CFDictionaryGetTypeID())
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("Version"));
    if (Value)
    {
      valuePtr = 0;
      CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr);
      v7 = (const __CFArray *)CFDictionaryGetValue(a1, CFSTR("Array"));
      if (v7)
      {
        v8 = v7;
        Count = CFArrayGetCount(v7);
        v10 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
        v18.location = 0;
        v18.length = Count;
        CFArrayGetValues(v8, v18, v10);
        if (Count >= 2)
        {
          v11 = v10 - 1;
          v12 = Count;
          do
          {
            v13 = CFGetTypeID(v11[v12]);
            if (v13 == CFStringGetTypeID() && CFEqual(CFSTR("__CFURLResponseNullTokenString__"), v11[v12]))
              v11[v12] = 0;
            --v12;
          }
          while ((unint64_t)(v12 + 1) > 2);
        }
        *v10 = (const void *)_CFURLCreateFromPropertyListRepresentation();
        URLResponse::initialize(v4, valuePtr, v10, Count);
        if (*v10)
          CFRelease(*v10);
        free(v10);
        fHTTP = (HTTPMessage *)v4->fHTTP;
        if (fHTTP)
          HTTPMessage::ensureParserFinished(fHTTP);
      }
    }
  }
  -[NSURLResponseInternal _inner](v3, "_inner");
  v15 = objc_msgSend(objc_alloc((Class)objc_opt_class()), "_initWithInternal:", v3);

  return v15;
}

uint64_t URLResponse::initialize(URLResponse *this, uint64_t a2, const void **a3, uint64_t a4)
{
  CFTypeID v8;
  uint64_t result;
  CFTypeID v10;
  CFTypeID v11;
  CFTypeID v12;
  const void *v13;
  CFTypeID v14;
  const void *v15;
  CFTypeID v16;
  const void *v17;
  CFTypeID v18;
  CFTypeID TypeID;
  CFTypeID v20;
  const void *v21;
  CFTypeID v22;
  CFTypeID v23;
  void *v24;
  const __CFDictionary *MutableCopy;
  const __CFAllocator *v26;
  char *ResponseNoParser;
  char v28;
  __CFString *v29;
  __CFString *v30;
  uint64_t Instance;
  uint64_t v32;
  const char **v33;
  HTTPResponse **p_fHTTP;
  HTTPResponse *v35;
  __CFString *v36;
  uint64_t v37;
  int valuePtr;

  if (a2)
  {
    if (a2 != 1 || (a4 & 0xFFFFFFFFFFFFFFFDLL) != 5)
      return 0;
  }
  else if (a4 != 7)
  {
    return 0;
  }
  if (*a3)
  {
    v8 = CFGetTypeID(*a3);
    if (v8 != CFURLGetTypeID())
      return 0;
  }
  result = (uint64_t)a3[1];
  if (!result)
    return result;
  v10 = CFGetTypeID((CFTypeRef)result);
  if (v10 != CFNumberGetTypeID())
    return 0;
  result = (uint64_t)a3[2];
  if (!result)
    return result;
  v11 = CFGetTypeID((CFTypeRef)result);
  if (v11 != CFNumberGetTypeID())
    return 0;
  result = (uint64_t)a3[3];
  if (a2 != 1)
  {
    if (result)
    {
      v20 = CFGetTypeID((CFTypeRef)result);
      if (v20 != CFStringGetTypeID())
        return 0;
    }
    v21 = a3[4];
    if (v21)
    {
      v22 = CFGetTypeID(v21);
      if (v22 != CFStringGetTypeID())
        return 0;
    }
    result = (uint64_t)a3[5];
    if (!result)
      return result;
    v23 = CFGetTypeID((CFTypeRef)result);
    if (v23 != CFNumberGetTypeID())
      return 0;
    result = (uint64_t)a3[6];
    if (!result)
      return result;
    v18 = CFGetTypeID((CFTypeRef)result);
    TypeID = CFNumberGetTypeID();
LABEL_31:
    if (v18 == TypeID)
      goto LABEL_32;
    return 0;
  }
  if (!result)
    return result;
  v12 = CFGetTypeID((CFTypeRef)result);
  if (v12 != CFNumberGetTypeID())
    return 0;
  v13 = a3[4];
  if (v13)
  {
    v14 = CFGetTypeID(v13);
    if (v14 != CFDictionaryGetTypeID())
      return 0;
  }
  if (a4 == 7)
  {
    v15 = a3[5];
    if (v15)
    {
      v16 = CFGetTypeID(v15);
      if (v16 != CFNumberGetTypeID())
        return 0;
    }
    v17 = a3[6];
    if (!v17 || CFEqual(v17, (CFTypeRef)*MEMORY[0x1E0C9AE40]))
      goto LABEL_32;
    v18 = CFGetTypeID(a3[6]);
    TypeID = CFStringGetTypeID();
    goto LABEL_31;
  }
LABEL_32:
  v24 = (void *)*a3;
  if (*a3)
    v24 = (void *)CFRetain(v24);
  this->fURL = (__CFURL *)v24;
  CFNumberGetValue((CFNumberRef)a3[1], kCFNumberDoubleType, &this->fCreationTime);
  valuePtr = 0;
  CFNumberGetValue((CFNumberRef)a3[2], kCFNumberIntType, &valuePtr);
  this->fRecommendedPolicy = valuePtr;
  if (a2 == 1)
  {
    v37 = 0;
    CFNumberGetValue((CFNumberRef)a3[3], kCFNumberCFIndexType, &v37);
    MutableCopy = (const __CFDictionary *)a3[4];
    v26 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    ResponseNoParser = _CFHTTPMessageCreateResponseNoParser(*MEMORY[0x1E0C9AE00], v37, 0, CFSTR("HTTP/1.1"));
    if (MutableCopy && CFDictionaryContainsKey(MutableCopy, &unk_1EDCFD9E0))
    {
      MutableCopy = CFDictionaryCreateMutableCopy(v26, 0, MutableCopy);
      CFDictionaryRemoveValue(MutableCopy, &unk_1EDCFD9E0);
      v28 = 0;
    }
    else
    {
      v28 = 1;
    }
    _CFHTTPMessageSetMultipleHeaderFields((__CFHTTPMessage *)ResponseNoParser, MutableCopy);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    Instance = _CFRuntimeCreateInstance();
    v32 = Instance;
    if (Instance)
    {
      *(_OWORD *)(Instance + 16) = 0u;
      v32 = Instance + 16;
      *(_QWORD *)(Instance + 352) = 0;
      *(_OWORD *)(Instance + 320) = 0u;
      *(_OWORD *)(Instance + 336) = 0u;
      *(_OWORD *)(Instance + 288) = 0u;
      *(_OWORD *)(Instance + 304) = 0u;
      *(_OWORD *)(Instance + 256) = 0u;
      *(_OWORD *)(Instance + 272) = 0u;
      *(_OWORD *)(Instance + 224) = 0u;
      *(_OWORD *)(Instance + 240) = 0u;
      *(_OWORD *)(Instance + 192) = 0u;
      *(_OWORD *)(Instance + 208) = 0u;
      *(_OWORD *)(Instance + 160) = 0u;
      *(_OWORD *)(Instance + 176) = 0u;
      *(_OWORD *)(Instance + 128) = 0u;
      *(_OWORD *)(Instance + 144) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(_OWORD *)(Instance + 48) = 0u;
    }
    if (ResponseNoParser)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (ResponseNoParser[40])
        v33 = (const char **)(ResponseNoParser + 16);
      else
        v33 = 0;
      HTTPResponseMessage::HTTPResponseMessage((HTTPResponseMessage *)v32, v33);
      *(_QWORD *)v32 = &off_1E14E6048;
      *(_QWORD *)(v32 + 8) = &unk_1E14E60B8;
      *(_QWORD *)(v32 + 16) = &unk_1E14E60D8;
      *(_WORD *)(v32 + 297) = 0;
      *(_BYTE *)(v32 + 299) = 0;
      this->fHTTP = (HTTPResponse *)v32;
      p_fHTTP = &this->fHTTP;
      CFRelease(ResponseNoParser);
    }
    else
    {
      HTTPResponseMessage::HTTPResponseMessage((HTTPResponseMessage *)v32, 0);
      *(_QWORD *)v32 = &off_1E14E6048;
      *(_QWORD *)(v32 + 8) = &unk_1E14E60B8;
      *(_QWORD *)(v32 + 16) = &unk_1E14E60D8;
      *(_WORD *)(v32 + 297) = 0;
      *(_BYTE *)(v32 + 299) = 0;
      this->fHTTP = (HTTPResponse *)v32;
      p_fHTTP = &this->fHTTP;
    }
    if ((v28 & 1) == 0)
    {
      if (MutableCopy)
        CFRelease(MutableCopy);
      *((_BYTE *)*p_fHTTP + 299) |= 1u;
    }
    v35 = *p_fHTTP;
    *((_QWORD *)*p_fHTTP + 38) = 0;
    if (a4 == 7)
    {
      if (a3[5])
      {
        *(_WORD *)((char *)v35 + 297) |= 0x2000u;
        *(_WORD *)((char *)this->fHTTP + 297) |= 0x100u;
        CFNumberGetValue((CFNumberRef)a3[5], kCFNumberLongLongType, &this->fExpectedContentLength);
      }
      if (a3[6])
      {
        *(_WORD *)((char *)*p_fHTTP + 297) |= 0x4000u;
        *(_WORD *)((char *)*p_fHTTP + 297) |= 0x200u;
        if (CFEqual(a3[6], (CFTypeRef)*MEMORY[0x1E0C9AE40]))
        {
          v36 = 0;
        }
        else
        {
          v36 = (__CFString *)a3[6];
          if (v36)
            v36 = (__CFString *)CFRetain(v36);
        }
        this->fMIMEType = v36;
      }
    }
  }
  else
  {
    v29 = (__CFString *)a3[3];
    if (v29)
      v29 = (__CFString *)CFRetain(v29);
    this->fMIMEType = v29;
    v30 = (__CFString *)a3[4];
    if (v30)
      v30 = (__CFString *)CFRetain(v30);
    this->fTextEncodingName = v30;
    CFNumberGetValue((CFNumberRef)a3[5], kCFNumberLongLongType, &this->fExpectedContentLength);
    CFNumberGetValue((CFNumberRef)a3[6], kCFNumberDoubleType, &this->fExpiration);
  }
  return 1;
}

void _CFHTTPMessageSetMultipleHeaderFields(__CFHTTPMessage *a1, CFDictionaryRef theDict)
{
  HTTPMessage *v4;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (a1)
    v4 = (__CFHTTPMessage *)((char *)a1 + 16);
  else
    v4 = 0;
  HTTPMessage::setMultipleHeaderFields(v4, theDict);
}

char *_CFHTTPMessageCreateResponseNoParser(uint64_t a1, __int16 a2, const void *a3, const __CFString *a4)
{
  _OWORD *Instance;
  HTTPMessage *v8;
  void (**v10)(StringSerializable *__hidden);
  CFTypeRef cf;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v8 = (HTTPMessage *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v8 = (HTTPMessage *)(Instance + 1);
    Instance[18] = 0u;
    Instance[19] = 0u;
    Instance[16] = 0u;
    Instance[17] = 0u;
    Instance[14] = 0u;
    Instance[15] = 0u;
    Instance[12] = 0u;
    Instance[13] = 0u;
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&v10, a4);
  HTTPResponseMessage::HTTPResponseMessage((uint64_t)v8, a2 & 0x3FF, a3, cf);
  v10 = &off_1E14E9A00;
  if (cf)
    CFRelease(cf);
  if (!v8)
    return 0;
  HTTPMessage::ensureParserFinished(v8);
  return (char *)v8 - 16;
}

void sub_183F2D4B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void HTTPVersionMixedValue::HTTPVersionMixedValue(HTTPVersionMixedValue *this, CFStringRef theString)
{
  CFStringRef v2;
  unsigned int CanonicalString;
  CFTypeRef v5;

  v2 = theString;
  *(_QWORD *)this = &off_1E14EBF58;
  *((_QWORD *)this + 1) = 0;
  CanonicalString = _findCanonicalString(theString, 8u);
  if (CanonicalString != 568)
  {
    v2 = (CFStringRef)&gConstantCFStringValueTable[7 * ((CanonicalString >> 20) & 0x3FF)];
    goto LABEL_5;
  }
  if (v2)
  {
LABEL_5:
    v5 = CFRetain(v2);
    goto LABEL_6;
  }
  v5 = 0;
LABEL_6:
  *((_QWORD *)this + 1) = v5;
}

void sub_183F2D548(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  const void *v3;

  *v1 = &off_1E14E9A00;
  v3 = (const void *)v1[1];
  if (v3)
    CFRelease(v3);
  _Unwind_Resume(exception_object);
}

uint64_t HTTPResponseMessage::HTTPResponseMessage(uint64_t a1, int a2, const void *a3, CFTypeRef cf)
{
  uint64_t v7;
  CFTypeRef v8;

  HTTPMessage::HTTPMessage((HTTPMessage *)a1, "httpresponse", cf);
  *(_QWORD *)v7 = &off_1E14E9F38;
  *(_QWORD *)(v7 + 8) = &unk_1E14E9FA8;
  *(_QWORD *)(v7 + 16) = &unk_1E14E9FC8;
  *(_DWORD *)(v7 + 128) = a2;
  if (a3)
    v8 = CFRetain(a3);
  else
    v8 = 0;
  *(_QWORD *)(a1 + 136) = v8;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_BYTE *)(a1 + 296) = 0;
  return a1;
}

void sub_183F2D5F8(_Unwind_Exception *a1)
{
  HTTPMessage *v1;

  HTTPMessage::~HTTPMessage(v1);
  _Unwind_Resume(a1);
}

CFDictionaryRef URLResponse::copyPropertyList(URLResponse *this, const __CFAllocator *a2)
{
  const void **v3;
  void *v4;
  CFIndex v5;
  CFIndex v6;
  unint64_t v7;
  CFArrayRef v8;
  __CFString *v9;
  CFDictionaryRef v10;
  uint64_t valuePtr;
  void **v13;
  CFIndex numValues;
  void *values[2];
  void *keys[4];

  keys[3] = *(void **)MEMORY[0x1E0C80C00];
  v13 = 0;
  numValues = 0;
  valuePtr = 0;
  URLResponse::createArchiveList(this, a2, &valuePtr, (const void ***)&v13, &numValues);
  v3 = (const void **)v13;
  v4 = *v13;
  *v3 = (const void *)_CFURLCopyPropertyListRepresentation();
  if (v4)
    CFRelease(v4);
  v5 = numValues;
  v6 = numValues - 1;
  if (numValues < 1)
  {
    v8 = CFArrayCreate(a2, v3, numValues, MEMORY[0x1E0C9B378]);
  }
  else
  {
    do
    {
      if (!v3[v6])
        v3[v6] = CFSTR("__CFURLResponseNullTokenString__");
      v7 = v6-- + 1;
    }
    while (v7 > 1);
    v8 = CFArrayCreate(a2, v3, v5, MEMORY[0x1E0C9B378]);
    do
    {
      v9 = (__CFString *)v3[v5 - 1];
      if (v9 != CFSTR("__CFURLResponseNullTokenString__"))
        CFRelease(v9);
      --v5;
    }
    while ((unint64_t)(v5 + 1) > 1);
  }
  CFAllocatorDeallocate(a2, v3);
  if (!CFPropertyListIsValid(v8, kCFPropertyListXMLFormat_v1_0)
    && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(keys[0]) = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "URLResponseCopyPropertyList(): Invalid property list produced!", (uint8_t *)keys, 2u);
  }
  keys[0] = CFSTR("Version");
  keys[1] = CFSTR("Array");
  values[0] = CFNumberCreate(a2, kCFNumberCFIndexType, &valuePtr);
  values[1] = v8;
  v10 = CFDictionaryCreate(a2, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFRelease(values[0]);
  CFRelease(v8);
  return v10;
}

uint64_t CFURLCacheFS::getCachedResponseDataFromFS(CFURLCacheFS *this, void **a2, uint64_t *a3)
{
  pthread_mutex_t *v6;
  const __CFString *v7;
  int v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v13;
  int v14;
  void *v15;
  NSObject *v16;
  int v17;
  int v18;
  char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  off_t st_size;
  stat v24;
  char buffer[1024];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v6 = (pthread_mutex_t *)((char *)this + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  v7 = (const __CFString *)*((_QWORD *)this + 9);
  if (!v7 || !CFStringGetFileSystemRepresentation(v7, buffer, 1024))
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v11 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24.st_dev) = 0;
      _os_log_error_impl(&dword_183ECA000, v11, OS_LOG_TYPE_ERROR, "ERROR: unable to obtain path to the cache data to read. Path is NULL.", (uint8_t *)&v24, 2u);
    }
    v10 = 0;
    goto LABEL_12;
  }
  v8 = open(buffer, 256);
  if (v8 == -1)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v13 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_INFO))
    {
      v14 = *__error();
      v24.st_dev = 136315394;
      *(_QWORD *)&v24.st_mode = buffer;
      WORD2(v24.st_ino) = 1024;
      *(_DWORD *)((char *)&v24.st_ino + 6) = v14;
      _os_log_impl(&dword_183ECA000, v13, OS_LOG_TYPE_INFO, "INFO: fetch-response is unable to open the file %s. Errno: %{errno}d", (uint8_t *)&v24, 0x12u);
    }
    v10 = 0;
    *a2 = 0;
    *a3 = 0;
    goto LABEL_12;
  }
  v9 = v8;
  if (!fstat(v8, &v24))
  {
    if (v24.st_size <= 0)
    {
      close(v9);
    }
    else
    {
      v15 = mmap(0, v24.st_size, 1, 2, v9, 0);
      close(v9);
      if (v15 != (void *)-1)
      {
        *a2 = v15;
        *a3 = v24.st_size;
        v10 = 1;
LABEL_12:
        pthread_mutex_unlock(v6);
        return v10;
      }
    }
    *a2 = 0;
    *a3 = 0;
    if (v24.st_size >= 1)
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v16 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        v17 = *__error();
        v18 = 136315650;
        v19 = buffer;
        v20 = 1024;
        v21 = v17;
        v22 = 2048;
        st_size = v24.st_size;
        _os_log_error_impl(&dword_183ECA000, v16, OS_LOG_TYPE_ERROR, "ERROR: failed to mmap cache data from FS: %s, errno:%{errno}d, len:%lld", (uint8_t *)&v18, 0x1Cu);
      }
    }
    goto LABEL_6;
  }
  *a2 = 0;
  *a3 = 0;
  close(v9);
LABEL_6:
  pthread_mutex_unlock(v6);
  return 0;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::find<unsigned long>(_QWORD *a1, uint64_t a2)
{
  unint64_t v2;
  uint8x8_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *result;
  unint64_t v7;

  v2 = a1[1];
  if (!v2)
    return 0;
  v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = (int)a2;
    if ((int)a2 >= v2)
      v4 = (int)a2 % v2;
  }
  else
  {
    v4 = (v2 - 1) & (int)a2;
  }
  v5 = *(_QWORD **)(*a1 + 8 * v4);
  if (!v5)
    return 0;
  result = (_QWORD *)*v5;
  if (*v5)
  {
    do
    {
      v7 = result[1];
      if (v7 == (int)a2)
      {
        if (result[2] == a2)
          return result;
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= v2)
            v7 %= v2;
        }
        else
        {
          v7 &= v2 - 1;
        }
        if (v7 != v4)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

void __retainStorageAssertion(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  double v4;
  id v5;
  void *v6;
  id v7;
  void *v8;
  int v9;
  NSObject *v10;
  void **v11;
  void *v12;
  void *v13;
  uint64_t v14;
  id v15;
  id v16;
  id v17;
  void *v18;
  double v19;
  double Helper_x8__OBJC_CLASS___RBSProcessHandle;
  uint64_t v21;
  void *v22;
  void *v23;
  double v24;
  double v25;
  double v26;
  uint64_t v27;
  dispatch_time_t v29;
  id v30;
  uint8_t buf[4];
  void *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  gotLoadHelper_x20__OBJC_CLASS___RBSAssertion(v4);
  if (objc_opt_class())
  {
    os_unfair_lock_lock((os_unfair_lock_t)&lock);
    ++assertionCount;
    if (!assertion)
    {
      if (acquireAssertion_onceToken != -1)
        dispatch_once(&acquireAssertion_onceToken, &__block_literal_global_4);
      v5 = objc_alloc(*(Class *)(v1 + 3216));
      v6 = (void *)objc_msgSend(v5, "initWithExplanation:target:attributes:", CFSTR("com.apple.CFNetwork.StorageDB"), acquireAssertion_target, acquireAssertion_attributes);
      v30 = 0;
      objc_msgSend(v6, "acquireWithError:", &v30);
      v7 = v30;
      if (v7)
      {
        v8 = v7;
        v9 = 3;
        v10 = MEMORY[0x1E0C81028];
        gotLoadHelper_x23__RBSAssertionErrorDomain(COERCE_DOUBLE(138412290));
        v11 = *(void ***)(v2 + 3624);
        while (1)
        {
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            v32 = v8;
            _os_log_error_impl(&dword_183ECA000, v10, OS_LOG_TYPE_ERROR, "Failed to acquire assertion: %@", buf, 0xCu);
          }
          if (!--v9)
            break;
          v12 = *v11;
          objc_msgSend(v8, "domain");
          v13 = (void *)objc_claimAutoreleasedReturnValue();
          if (!objc_msgSend(v12, "isEqualToString:", v13))
          {

LABEL_17:
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Unhandled assertion acquisition failure, bailing out", buf, 2u);
            }
            goto LABEL_19;
          }
          v14 = objc_msgSend(v8, "code");

          if (v14 != 2)
            goto LABEL_17;
          sleep(1u);
          v30 = 0;
          objc_msgSend(v6, "acquireWithError:", &v30);
          v15 = v30;

          v8 = v15;
          if (!v15)
            goto LABEL_13;
        }
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Failed to acquire assertion after 3 attempts", buf, 2u);
        }
LABEL_19:
        v17 = v6;

      }
      else
      {
LABEL_13:
        v16 = v6;
      }

      v18 = (void *)assertion;
      assertion = (uint64_t)v6;

      Helper_x8__OBJC_CLASS___RBSProcessHandle = gotLoadHelper_x8__OBJC_CLASS___RBSProcessHandle(v19);
      objc_msgSend(*(id *)(v21 + 3424), "currentProcess", Helper_x8__OBJC_CLASS___RBSProcessHandle);
      v22 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v22, "activeLimitations");
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v23, "runTime");
      v25 = v24;

      gotLoadHelper_x8__RBSProcessTimeLimitationNone(v26);
      if (v25 > 15.0 || v25 == **(double **)(v27 + 3640))
      {
        shouldHold = 1;
        v29 = dispatch_time(0x8000000000000000, 1000000000);
        dispatch_after(v29, v3, &__block_literal_global_2177);
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&lock);
  }

}

void __releaseStorageAssertion(double a1)
{
  void *v1;

  gotLoadHelper_x8__OBJC_CLASS___RBSAssertion(a1);
  if (objc_opt_class())
  {
    os_unfair_lock_lock((os_unfair_lock_t)&lock);
    if (!assertionCount)
      __assert_rtn("__releaseStorageAssertion", "AssertionManager.m", 92, "assertionCount > 0");
    if (!--assertionCount && (shouldHold & 1) == 0)
    {
      objc_msgSend((id)assertion, "invalidate");
      v1 = (void *)assertion;
      assertion = 0;

    }
    os_unfair_lock_unlock((os_unfair_lock_t)&lock);
  }
}

void __CFCachedURLResponse::SetReceiverData(__CFCachedURLResponse *this, const __CFData *a2)
{
  os_unfair_lock_s *v3;
  const void *v4;
  const void *v5;
  void *values;

  values = a2;
  v3 = (os_unfair_lock_s *)((char *)this + 88);
  os_unfair_lock_lock((os_unfair_lock_t)this + 22);
  v4 = (const void *)*((_QWORD *)this + 9);
  if (v4)
  {
    *((_QWORD *)this + 9) = 0;
    CFRelease(v4);
  }
  v5 = (const void *)*((_QWORD *)this + 10);
  if (v5)
  {
    *((_QWORD *)this + 10) = 0;
    CFRelease(v5);
  }
  *((_QWORD *)this + 10) = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, MEMORY[0x1E0C9B378]);
  __CFCachedURLResponse::EncodeReceiverData(this);
  os_unfair_lock_unlock(v3);
}

uint64_t __CFURLCache::addMMappedDataToSet(__CFURLCache *this, void *a2)
{
  pthread_mutex_t *v4;
  __CFSet *v5;

  v4 = (pthread_mutex_t *)((char *)this + 376);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
  if (a2)
  {
    v5 = (__CFSet *)*((_QWORD *)this + 56);
    if (v5)
      CFSetAddValue(v5, a2);
  }
  return pthread_mutex_unlock(v4);
}

__CFData *__CFCachedURLResponse::GetReceiverData(__CFCachedURLResponse *this)
{
  os_unfair_lock_s *v2;
  __CFData *v3;
  const __CFArray *v4;

  v2 = (os_unfair_lock_s *)((char *)this + 88);
  os_unfair_lock_lock((os_unfair_lock_t)this + 22);
  v3 = (__CFData *)*((_QWORD *)this + 9);
  if (!v3)
  {
    v4 = (const __CFArray *)*((_QWORD *)this + 10);
    if (v4)
    {
      v3 = CopyAllDataFromDataArray(v4);
      *((_QWORD *)this + 9) = v3;
    }
    else
    {
      v3 = 0;
    }
  }
  os_unfair_lock_unlock(v2);
  return v3;
}

__CFData *CopyAllDataFromDataArray(const __CFArray *a1)
{
  CFIndex Count;
  const void *ValueAtIndex;
  CFIndex v5;
  CFIndex v6;
  CFIndex v7;
  const __CFData *v8;
  const __CFAllocator *v9;
  CFMutableDataRef Mutable;
  __CFData *v11;
  CFIndex v12;
  const __CFData *v13;
  const UInt8 *BytePtr;
  CFIndex Length;
  NSObject *v16;
  int v17;
  CFIndex v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    Count = CFArrayGetCount(a1);
    if (Count == 1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, 0);
      return (__CFData *)CFRetain(ValueAtIndex);
    }
    v5 = Count;
    if (Count >= 2)
    {
      v6 = 0;
      v7 = 0;
      do
      {
        v8 = (const __CFData *)CFArrayGetValueAtIndex(a1, v6);
        v7 += CFDataGetLength(v8);
        ++v6;
      }
      while (v5 != v6);
      if (v7 > 0)
      {
        v9 = CFGetAllocator(a1);
        Mutable = CFDataCreateMutable(v9, v7);
        if (Mutable)
        {
          v11 = Mutable;
          v12 = 0;
          do
          {
            v13 = (const __CFData *)CFArrayGetValueAtIndex(a1, v12);
            BytePtr = CFDataGetBytePtr(v13);
            Length = CFDataGetLength(v13);
            CFDataAppendBytes(v11, BytePtr, Length);
            ++v12;
          }
          while (v5 != v12);
          return v11;
        }
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v16 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          v17 = 134217984;
          v18 = v7;
          _os_log_error_impl(&dword_183ECA000, v16, OS_LOG_TYPE_ERROR, "CopyAllDataFromDataArray:  ERROR.  Failed to allocate a CFDataRef of size %ld.", (uint8_t *)&v17, 0xCu);
        }
      }
    }
  }
  return 0;
}

{
  CFIndex Count;
  const void *ValueAtIndex;
  CFIndex v5;
  CFIndex v6;
  CFIndex v7;
  const __CFData *v8;
  const __CFAllocator *v9;
  __CFData *Mutable;
  CFIndex v11;
  const __CFData *v12;
  const UInt8 *BytePtr;
  CFIndex Length;

  if (a1)
  {
    Count = CFArrayGetCount(a1);
    if (Count == 1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, 0);
      if (ValueAtIndex)
        return (__CFData *)CFRetain(ValueAtIndex);
    }
    else
    {
      v5 = Count;
      if (Count >= 2)
      {
        v6 = 0;
        v7 = 0;
        do
        {
          v8 = (const __CFData *)CFArrayGetValueAtIndex(a1, v6);
          v7 += CFDataGetLength(v8);
          ++v6;
        }
        while (v5 != v6);
        if (v7 > 0)
        {
          v9 = CFGetAllocator(a1);
          Mutable = CFDataCreateMutable(v9, v7);
          if (Mutable)
          {
            v11 = 0;
            do
            {
              v12 = (const __CFData *)CFArrayGetValueAtIndex(a1, v11);
              BytePtr = CFDataGetBytePtr(v12);
              Length = CFDataGetLength(v12);
              CFDataAppendBytes(Mutable, BytePtr, Length);
              ++v11;
            }
            while (v5 != v11);
          }
          else
          {
            CFLog();
          }
          return Mutable;
        }
      }
    }
  }
  return 0;
}

CFPropertyListRef dep_CFPropertyListCreateFromStream(const __CFAllocator *a1, __CFReadStream *a2, CFStringRef *a3, unint64_t a4, CFPropertyListFormat *a5, const __CFString **a6)
{
  CFPropertyListRef v7;
  CFErrorRef v8;
  CFErrorRef error;

  error = 0;
  v7 = CFPropertyListCreateWithStream(a1, a2, 0, 0, 0, &error);
  if (!v7)
  {
    v8 = error;
    if (error)
    {
      if (a3)
      {
        *a3 = CFErrorCopyDescription(error);
        v8 = error;
      }
      CFRelease(v8);
    }
  }
  return v7;
}

uint64_t _CFURLCacheCreateFS3(const void *a1, const void *a2, const void *a3)
{
  uint64_t v6;
  CFTypeRef *v7;
  const __CFAllocator *v8;
  const __CFString *v9;
  const __CFString *v10;
  __CFString *MutableCopy;
  uint64_t v12;
  CFTypeRef v13;
  uint64_t v14;
  const char *v15;
  NSObject *v16;
  uint32_t v17;
  uint64_t v18;
  uint64_t v20;
  uint64_t v21;
  uint8_t buf[4];
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v6 = operator new();
  *(_QWORD *)v6 = &off_1E14E6990;
  pthread_mutex_init((pthread_mutex_t *)(v6 + 8), 0);
  *(_QWORD *)v6 = &off_1E14E5790;
  *(_OWORD *)(v6 + 72) = 0u;
  v7 = (CFTypeRef *)(v6 + 72);
  *(_OWORD *)(v6 + 88) = 0u;
  *(_OWORD *)(v6 + 104) = 0u;
  *(_BYTE *)(v6 + 120) = 0;
  *(_QWORD *)(v6 + 72) = CFRetain(a1);
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *(_QWORD *)(v6 + 80) = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@/%s"), a1, "fsCachedData");
  *(_QWORD *)(v6 + 96) = CFRetain(a3);
  *(_QWORD *)(v6 + 88) = CFRetain(a2);
  v9 = *(const __CFString **)(v6 + 72);
  if (!v9
    || (*(_QWORD *)(v6 + 112) = _ExtractCStringfromCFStringRef(v9, (BOOL *)(v6 + 120)),
        (v10 = *(const __CFString **)(v6 + 72)) == 0))
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v14 = CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      return v6;
    *(_WORD *)buf = 0;
    v15 = "ERROR: Unable to generate the path to the cache file as the path is NULL.";
    v16 = v14;
    v17 = 2;
LABEL_19:
    _os_log_error_impl(&dword_183ECA000, v16, OS_LOG_TYPE_ERROR, v15, buf, v17);
    return v6;
  }
  MutableCopy = CFStringCreateMutableCopy(v8, 0, v10);
  *(_QWORD *)(v6 + 104) = MutableCopy;
  if (MutableCopy)
  {
    v12 = *(_QWORD *)(v6 + 96);
    if (v12)
    {
      CFStringAppendFormat(MutableCopy, 0, CFSTR("/%@/%@"), CFSTR("fsCachedData"), v12);
      if (*v7)
        CFRelease(*v7);
      v13 = *(CFTypeRef *)(v6 + 104);
      if (v13)
        v13 = CFRetain(v13);
      *v7 = v13;
      return v6;
    }
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v18 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    v21 = *(_QWORD *)(v6 + 96);
    v20 = *(_QWORD *)(v6 + 104);
    *(_DWORD *)buf = 138412546;
    v23 = v20;
    v24 = 2112;
    v25 = v21;
    v15 = "ERROR: The path to the FS cached directory (%@) or the UUID (%@) is wrong.";
    v16 = v18;
    v17 = 22;
    goto LABEL_19;
  }
  return v6;
}

void sub_183F2E880(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10F1C4059CE80F0);
  _Unwind_Resume(a1);
}

uint64_t __CFURLCache::ReplaceDataInMemoryCacheResponseWithMMappedData(__CFURLCache *this, _CFCachedURLResponse *a2, CFURLCacheFS *a3, const __CFString *a4)
{
  pthread_mutex_t *v7;
  const __CFDictionary *v8;
  __CFCachedURLResponse **Value;
  __CFCachedURLResponse **v10;
  _QWORD *v11;
  CFIndex v12;
  const void *v13;
  const __CFAllocator *v14;
  const __CFAllocator *v15;
  const __CFAllocator *v16;
  UInt8 *v17;
  const __CFData *v18;
  __CFCachedURLResponse *v19;
  NSObject *v20;
  NSObject *v21;
  uint64_t v23;
  UInt8 *bytes;
  CFAllocatorContext context;

  v7 = (pthread_mutex_t *)((char *)this + 312);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 312));
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 456));
  v8 = (const __CFDictionary *)*((_QWORD *)this + 65);
  if (v8
    && CFDictionaryGetCount(v8) >= 1
    && (Value = (__CFCachedURLResponse **)CFDictionaryGetValue(*((CFDictionaryRef *)this + 65), a3)) != 0)
  {
    v10 = Value;
    CFRetain(Value);
    CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 65), a3);
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 456));
    v23 = 0;
    bytes = 0;
    if (CFURLCacheFS::getCachedResponseDataFromFS((CFURLCacheFS *)a2, (void **)&bytes, &v23))
    {
      v11 = (_QWORD *)operator new();
      v12 = v23;
      *v11 = this;
      v11[1] = v12;
      v13 = (const void *)*((_QWORD *)this + 55);
      if (v13)
        CFRetain(v13);
      context.version = 0;
      context.info = v11;
      memset(&context.retain, 0, 40);
      context.deallocate = (CFAllocatorDeallocateCallBack)mmapFileDeallocate;
      context.preferredSize = 0;
      v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v15 = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &context);
      if (v15)
      {
        v16 = v15;
        v17 = bytes;
        v18 = CFDataCreateWithBytesNoCopy(v14, bytes, v12, v15);
        __CFURLCache::addMMappedDataToSet(this, v17);
        CFRelease(v16);
        if (v18)
        {
          __CFCachedURLResponse::SetReceiverData(v10[2], v18);
          v19 = v10[2];
          *((_BYTE *)v19 + 120) = 1;
          if (*((_QWORD *)v19 + 2))
          {
            v20 = *((_QWORD *)v19 + 1);
            if (v20)
              v21 = v20;
            else
              v21 = MEMORY[0x1E0C80D38];
            CFRetain(v10);
            context.version = MEMORY[0x1E0C809B0];
            context.info = (void *)3221225472;
            context.retain = (CFAllocatorRetainCallBack)___ZL39notifyCachedURLResponseBecameFileBackedPK20_CFCachedURLResponse_block_invoke;
            context.release = (CFAllocatorReleaseCallBack)&__block_descriptor_40_e5_v8__0l;
            context.copyDescription = (CFAllocatorCopyDescriptionCallBack)v10;
            dispatch_async(v21, &context);
          }
          CFRelease(v18);
        }
      }
    }
    CFRelease(v10);
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 456));
  }
  return pthread_mutex_unlock(v7);
}

void sub_183F2EAAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x1020C40EDED9539);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'HTTPProtocol::reportsDataStalls(HTTPProtocol *this)
{
  void *v1;

  v1 = (void *)objc_msgSend(*((id *)this - 12), "_effectiveConfiguration");
  if (v1)
    return objc_msgSend(v1, "_reportsDataStalls");
  else
    return 1;
}

void sub_183F2F3B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_183F2F9BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void ___ZN24HTTPConnectionCacheEntry28_findOrCreateEmptyConnectionENSt3__110shared_ptrINS_15EnqueuedRequestEEEPNS_22ConnectionSearchStatusE_block_invoke(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  _QWORD aBlock[6];
  std::__shared_weak_count *v12;
  _QWORD block[6];

  v4 = a1[4];
  v5 = a2[20];
  v6 = MEMORY[0x1E0C809B0];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN4Tube24overrideAllowedProtocolsEm_block_invoke;
  block[3] = &__block_descriptor_48_e5_v8__0l;
  block[4] = a2;
  block[5] = 1;
  dispatch_async(v5, block);
  aBlock[0] = v6;
  aBlock[1] = 3321888768;
  aBlock[2] = ___ZN24HTTPConnectionCacheEntry28_findOrCreateEmptyConnectionENSt3__110shared_ptrINS_15EnqueuedRequestEEEPNS_22ConnectionSearchStatusE_block_invoke_2;
  aBlock[3] = &__block_descriptor_56_e8_40c49_ZTSNSt3__18weak_ptrI24HTTPConnectionCacheEntryEE_e8_v16__0q8l;
  v8 = a1[5];
  v7 = (std::__shared_weak_count *)a1[6];
  aBlock[4] = a2;
  aBlock[5] = v8;
  v12 = v7;
  if (v7)
  {
    p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
    do
      v10 = __ldxr(p_shared_weak_owners);
    while (__stxr(v10 + 1, p_shared_weak_owners));
  }
  Tube::setWaitingForConnectivityCallback((uint64_t)a2, aBlock);
  CFArrayAppendValue(*(CFMutableArrayRef *)(v4 + 80), a2);
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
}

void sub_183F2FFB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16)
    std::__shared_weak_count::__release_weak(a16);
  _Unwind_Resume(exception_object);
}

void ___ZN15HTTP3Connection29_requestNewServerStreamHandleEv_block_invoke(uint64_t a1, void *a2, void *a3, uint64_t a4, CFIndex a5, uint64_t a6)
{
  id v12;
  id v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  size_t size;
  size_t v19;
  uint64_t v20;
  dispatch_data_t subrange;
  HTTP3Connection *v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  NSObject *v28;
  nw_protocol_metadata_t v29;
  void *v30;
  unint64_t *p_shared_owners;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  int v39;
  NSObject *v40;
  uint64_t v41;
  int v42;
  NSObject *v43;
  nw_protocol_metadata_t v44;
  void *v45;
  uint64_t v46;
  std::__shared_weak_count *v47;
  _QWORD applier[5];
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  char v52;
  _BYTE buf[24];
  void *v54;
  NSObject *v55;
  uint64_t v56;
  uint64_t v57;
  std::__shared_weak_count *v58;
  uint64_t v59;
  CFStreamError v60;

  v59 = *MEMORY[0x1E0C80C00];
  v12 = a2;
  v13 = a3;
  if (v12 && !(_DWORD)a6)
  {
    v14 = *(_QWORD *)(a1 + 32);
    v15 = v12;
    v16 = v13;
    v17 = v16;
    if (v16 && (size = dispatch_data_get_size(v16)) != 0)
    {
      v19 = size;
      if (*(_QWORD *)(v14 + 992))
        HTTP3Connection::_stopStallRecovery((HTTP3Connection *)v14);
      v49 = 0;
      v50 = &v49;
      v51 = 0x2020000000;
      v20 = MEMORY[0x1E0C809B0];
      v52 = 0;
      applier[0] = MEMORY[0x1E0C809B0];
      applier[1] = 3221225472;
      applier[2] = ___ZN15HTTP3Connection20_setupIncomingStreamEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_b_block_invoke;
      applier[3] = &unk_1E14FD188;
      applier[4] = &v49;
      dispatch_data_apply(v17, applier);
      subrange = dispatch_data_create_subrange(v17, 1uLL, v19);
      switch(*((_BYTE *)v50 + 24))
      {
        case 0:
          if (!HTTP3Framer::setReadHandleBeforeReading(*(_QWORD *)(v14 + 1024), v15, subrange, 0))
          {
            *(_QWORD *)(v14 + 1160) = 4;
            *(_DWORD *)(v14 + 1168) = -1;
            HTTP3Connection::_cleanupConnection((HTTP3Connection *)v14, 259, 0);
            v39 = 1;
            goto LABEL_41;
          }
          HTTP3Connection::_readControlStream((HTTP3Connection *)v14);
          break;
        case 1:
          std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v46, *(_QWORD *)(v14 + 8), *(std::__shared_weak_count **)(v14 + 16));
          *(_QWORD *)buf = v20;
          *(_QWORD *)&buf[8] = 3321888768;
          *(_QWORD *)&buf[16] = ___ZN15HTTP3Connection20_setupIncomingStreamEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_b_block_invoke_2;
          v54 = &unk_1E14F4118;
          v56 = v14;
          v57 = v46;
          v58 = v47;
          if (v47)
          {
            p_shared_owners = (unint64_t *)&v47->__shared_owners_;
            do
              v32 = __ldxr(p_shared_owners);
            while (__stxr(v32 + 1, p_shared_owners));
          }
          v55 = v15;
          HTTP3Connection::_readPushID(v14, v55, subrange, a4, buf);

          v33 = v58;
          if (v58)
          {
            v34 = (unint64_t *)&v58->__shared_owners_;
            do
              v35 = __ldaxr(v34);
            while (__stlxr(v35 - 1, v34));
            if (!v35)
            {
              ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
              std::__shared_weak_count::__release_weak(v33);
            }
          }
          v36 = v47;
          if (v47)
          {
            v37 = (unint64_t *)&v47->__shared_owners_;
            do
              v38 = __ldaxr(v37);
            while (__stlxr(v38 - 1, v37));
            if (!v38)
            {
              ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
              std::__shared_weak_count::__release_weak(v36);
            }
          }
          break;
        case 2:
          if (*(_QWORD *)(v14 + 1048))
          {
            *(_QWORD *)(v14 + 1160) = 4;
            *(_DWORD *)(v14 + 1168) = -1;
            HTTP3Connection::_cleanupConnection((HTTP3Connection *)v14, 259, 0);
            v39 = 17;
            goto LABEL_41;
          }
          objc_storeStrong((id *)(v14 + 1048), a2);
          HTTP3Connection::_readEncoderStream(v14, subrange);
          break;
        case 3:
          if (*(_QWORD *)(v14 + 1064))
          {
            *(_QWORD *)(v14 + 1160) = 4;
            *(_DWORD *)(v14 + 1168) = -1;
            HTTP3Connection::_cleanupConnection((HTTP3Connection *)v14, 259, 0);
            v39 = 33;
LABEL_41:
            HTTP3Connection::reportServerProtocolViolation(v14, v39, -1);
          }
          else
          {
            objc_storeStrong((id *)(v14 + 1064), a2);
            HTTP3Connection::_readDecoderStream(v14, subrange);
          }
          break;
        default:
          CFN_LOG_h3connection();
          v40 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
          {
            v41 = *(_QWORD *)(v14 + 1216);
            v42 = *((unsigned __int8 *)v50 + 24);
            *(_DWORD *)buf = 134218496;
            *(_QWORD *)&buf[4] = v14;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v41;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v54) = v42;
            _os_log_impl(&dword_183ECA000, v40, OS_LOG_TYPE_INFO, "%p %llu unknown incoming stream type (0x%02x)", buf, 0x1Cu);
          }

          v43 = nw_protocol_copy_quic_connection_definition();
          v44 = nw_content_context_copy_protocol_metadata(v15, v43);

          v45 = (void *)nw_quic_connection_copy_stream_metadata();
          nw_quic_stream_set_application_error();
          (*(void (**)(_QWORD, NSObject *))(**(_QWORD **)(v14 + 1008) + 80))(*(_QWORD *)(v14 + 1008), v15);

          break;
      }

      _Block_object_dispose(&v49, 8);
    }
    else
    {
      CFN_LOG_h3connection();
      v26 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
      {
        v27 = *(_QWORD *)(v14 + 1216);
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = v14;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v27;
        _os_log_impl(&dword_183ECA000, v26, OS_LOG_TYPE_INFO, "%p %llu ignore empty incoming stream", buf, 0x16u);
      }

      v28 = nw_protocol_copy_quic_connection_definition();
      v29 = nw_content_context_copy_protocol_metadata(v15, v28);

      v30 = (void *)nw_quic_connection_copy_stream_metadata();
      nw_quic_stream_set_application_error();
      (*(void (**)(_QWORD, NSObject *))(**(_QWORD **)(v14 + 1008) + 80))(*(_QWORD *)(v14 + 1008), v15);

    }
    v22 = *(HTTP3Connection **)(a1 + 32);
    goto LABEL_44;
  }
  v22 = *(HTTP3Connection **)(a1 + 32);
  if (a5 == 1 && (_DWORD)a6 == 54)
  {
LABEL_44:
    HTTP3Connection::_requestNewServerStreamHandle(v22);
    goto LABEL_45;
  }
  v60.domain = a5;
  *(_QWORD *)&v60.error = a6;
  if (HTTP3Connection::checkAndPerformFallback(v22, v60))
  {
    CFN_LOG_h3connection();
    v23 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      v24 = *(_QWORD *)(a1 + 32);
      v25 = *(_QWORD *)(v24 + 1216);
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)&buf[4] = v24;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v25;
      _os_log_impl(&dword_183ECA000, v23, OS_LOG_TYPE_DEFAULT, "%p %llu New stream fallback triggered", buf, 0x16u);
    }

  }
  else
  {
    HTTP3Connection::_cleanupConnection(*(HTTP3Connection **)(a1 + 32), -1, 0);
  }
LABEL_45:

}

void sub_183F30558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  va_list va;

  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void HTTP3Connection::_requestNewServerStreamHandle(HTTP3Connection *this)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  _QWORD v12[5];
  std::__shared_weak_count *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;

  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v14, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
  v2 = *((_QWORD *)this + 126);
  if (v2 && (*((_BYTE *)this + 920) & 4) == 0)
  {
    v3 = *MEMORY[0x1E0CCED00];
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3321888768;
    v12[2] = ___ZN15HTTP3Connection29_requestNewServerStreamHandleEv_block_invoke;
    v12[3] = &__block_descriptor_48_ea8_32c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e83_v44__0__NSObject_OS_nw_content_context__8__NSObject_OS_dispatch_data__16B24___qi_28l;
    v12[4] = v14;
    v13 = v15;
    if (v15)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        v5 = __ldxr(p_shared_owners);
      while (__stxr(v5 + 1, p_shared_owners));
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v2 + 56))(v2, v3, 1, 132000, v12);
    v6 = v13;
    if (v13)
    {
      v7 = (unint64_t *)&v13->__shared_owners_;
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  v9 = v15;
  if (v15)
  {
    v10 = (unint64_t *)&v15->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void sub_183F30738(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32);
  _Unwind_Resume(a1);
}

uint64_t ___ZN15HTTP3Connection20_setupIncomingStreamEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_b_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a4;
  return 0;
}

void ___ZN15HTTP2Connection14didCloseStreamENSt3__110shared_ptrI11HTTP2StreamEEb_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  const __CFArray *v11;
  CFIndex Count;
  CFIndex v13;
  BOOL v14;
  const void *ValueAtIndex;
  std::__shared_weak_count *v16;
  HTTP2Stream *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  NSObject *v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  unint64_t v29;
  __uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  HTTP2Stream *v34;
  _BYTE buf[24];
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 40);
  v4 = *(std::__shared_weak_count **)(a1 + 48);
  v34 = (HTTP2Stream *)v2;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    if (!v2)
    {
      v14 = 0;
      goto LABEL_38;
    }
    *(_QWORD *)buf = v2;
    *(_QWORD *)&buf[8] = v4;
    v7 = (unint64_t *)&v4->__shared_owners_;
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  else
  {
    if (!v2)
    {
      v14 = 0;
      goto LABEL_42;
    }
    *(_QWORD *)buf = *(_QWORD *)(a1 + 40);
    *(_QWORD *)&buf[8] = 0;
  }
  HTTP2Connection::streamExitedStallableState(v3, v2, v4);
  if (v4)
  {
    v9 = (unint64_t *)&v4->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  v11 = *(const __CFArray **)(v3 + 232);
  Count = CFArrayGetCount(v11);
  if (Count < 1)
  {
    v14 = 0;
    goto LABEL_35;
  }
  v13 = 0;
  v14 = 1;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v11, v13);
    v17 = (HTTP2Stream *)*((_QWORD *)ValueAtIndex + 3);
    v16 = (std::__shared_weak_count *)*((_QWORD *)ValueAtIndex + 4);
    if (v16)
      break;
    if (v17 == v34)
      goto LABEL_30;
LABEL_26:
    v14 = ++v13 < Count;
    if (v13 == Count)
      goto LABEL_35;
  }
  v18 = (unint64_t *)&v16->__shared_owners_;
  do
    v19 = __ldxr(v18);
  while (__stxr(v19 + 1, v18));
  do
    v20 = __ldaxr(v18);
  while (__stlxr(v20 - 1, v18));
  if (!v20)
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  if (v17 != v34)
    goto LABEL_26;
LABEL_30:
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v3 + 232), v13);
  v21 = *(int *)(v3 + 304);
  if (!(CFArrayGetCount(*(CFArrayRef *)(v3 + 232)) + v21))
  {
    if (*(_QWORD *)(v3 + 720))
      HTTP2Connection::stopStallRecovery((dispatch_source_t *)v3);
    *(CFAbsoluteTime *)(v3 + 248) = CFAbsoluteTimeGetCurrent();
    *(_BYTE *)(v3 + 641) = 1;
    if (*(_BYTE *)(v3 + 264))
    {
      HTTP2Connection::stop((HTTP2Connection *)v3, 0);
    }
    else
    {
      v28 = *(_QWORD *)(v3 + 56);
      if (v28 && *(_DWORD *)v28 == 1)
        (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v28 + 8) + 88))(*(_QWORD *)(v28 + 8), 1);
    }
  }
LABEL_35:
  HTTP2Stream::breakStreamUserDataCycle((uint64_t)v34);
  if (*(_QWORD *)(v3 + 160))
    nghttp2_session_set_stream_user_data();
  if (v4)
  {
LABEL_38:
    v22 = (unint64_t *)&v4->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
LABEL_42:
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v24 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    v25 = *(_QWORD *)(v3 + 72);
    v26 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 80);
    v27 = *(unsigned __int8 *)(a1 + 56);
    *(_DWORD *)buf = 134218496;
    *(_QWORD *)&buf[4] = v25;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v26;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v27;
    _os_log_debug_impl(&dword_183ECA000, v24, OS_LOG_TYPE_DEBUG, "HTTP/2 Connection %llu Stream %d ended. Connection considered operational %{BOOL}d", buf, 0x18u);
    if (v14)
    {
LABEL_46:
      if (!*(_BYTE *)(v3 + 264) && (*(_DWORD *)(v3 + 176) - 3) >= 2)
      {
        if (*(_BYTE *)(a1 + 56))
        {
          *(_QWORD *)(v3 + 728) = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX);
          *(_QWORD *)(v3 + 736) = 0;
        }
        else
        {
          v29 = *(_QWORD *)(v3 + 736) + 1;
          *(_QWORD *)(v3 + 736) = v29;
          if (v29 >= 0xB)
          {
            v30 = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX) - *(_QWORD *)(v3 + 728);
            if (v30 >= 0xDF8475801)
            {
              if (CFNLog::onceToken != -1)
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
              v31 = CFNLog::logger;
              if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
              {
                v32 = *(_QWORD *)(v3 + 72);
                v33 = *(_QWORD *)(v3 + 736);
                *(_DWORD *)buf = 134218496;
                *(_QWORD *)&buf[4] = v32;
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = v30 / 0x3B9ACA00;
                *(_WORD *)&buf[22] = 2048;
                v36 = v33;
                _os_log_error_impl(&dword_183ECA000, v31, OS_LOG_TYPE_ERROR, "HTTP/2 terminating broken Connection %llu, last success %llus ago, consecutive failures %llu", buf, 0x20u);
              }
              *(_BYTE *)(v3 + 264) = 1;
              HTTP2Connection::stopIfNoOutstandingRequests((HTTP2Connection *)v3);
            }
          }
        }
      }
    }
  }
  else if (v14)
  {
    goto LABEL_46;
  }
  CFRelease((CFTypeRef)(v3 - 16));
}

void sub_183F30BCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t HTTP2Stream::breakStreamUserDataCycle(uint64_t this)
{
  _QWORD *v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v6;

  v1 = *(_QWORD **)(this + 296);
  if (v1)
  {
    v2 = this;
    v3 = (std::__shared_weak_count *)v1[1];
    *v1 = 0;
    v1[1] = 0;
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v5 = __ldaxr(p_shared_owners);
      while (__stlxr(v5 - 1, p_shared_owners));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    this = *(_QWORD *)(v2 + 296);
    if (this)
    {
      v6 = std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](this);
      this = MEMORY[0x186DB748C](v6, 0x20C40A4A59CD2);
    }
    *(_QWORD *)(v2 + 296) = 0;
  }
  return this;
}

void HTTP2Connection::streamExitedStallableState(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  _QWORD *v3;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8[2];

  if (a2)
  {
    v3 = *(_QWORD **)(a1 + 648);
    if (v3)
    {
      v8[0] = a2;
      v8[1] = (uint64_t)a3;
      if (a3)
      {
        p_shared_owners = (unint64_t *)&a3->__shared_owners_;
        do
          v6 = __ldxr(p_shared_owners);
        while (__stxr(v6 + 1, p_shared_owners));
        HTTPStallTimer::remove(v3, v8);
        do
          v7 = __ldaxr(p_shared_owners);
        while (__stlxr(v7 - 1, p_shared_owners));
        if (!v7)
        {
          ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
          std::__shared_weak_count::__release_weak(a3);
        }
      }
      else
      {
        HTTPStallTimer::remove(v3, v8);
      }
    }
  }
}

void HTTPStallTimer::remove(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_weak_owners;
  unint64_t v5;
  NSObject *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD v15[5];
  std::__shared_weak_count *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;

  v2 = a1[1];
  v3 = (std::__shared_weak_count *)a1[2];
  if (v3)
  {
    p_shared_weak_owners = (unint64_t *)&v3->__shared_weak_owners_;
    do
      v5 = __ldxr(p_shared_weak_owners);
    while (__stxr(v5 + 1, p_shared_weak_owners));
  }
  v6 = a1[3];
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3321888768;
  v15[2] = ___ZN14HTTPStallTimer6removeENSt3__110shared_ptrIvEE_block_invoke;
  v15[3] = &__block_descriptor_64_e8_32c39_ZTSNSt3__18weak_ptrI14HTTPStallTimerEE48c27_ZTSNSt3__110shared_ptrIvEE_e5_v8__0l;
  v15[4] = v2;
  v16 = v3;
  if (v3)
  {
    v7 = (unint64_t *)&v3->__shared_weak_owners_;
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v9 = (std::__shared_weak_count *)a2[1];
  v17 = *a2;
  v18 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  dispatch_async(v6, v15);
  v12 = v18;
  if (v18)
  {
    v13 = (unint64_t *)&v18->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  if (v16)
    std::__shared_weak_count::__release_weak(v16);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

uint64_t `non-virtual thunk to'HTTP2StreamBridge::closeAndClearHandler(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 48))(*((_QWORD *)this + 2));
}

uint64_t `non-virtual thunk to'HTTP2StreamBridge::rawBytesReceived(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 80))(*((_QWORD *)this + 2));
}

void `non-virtual thunk to'HTTP2StreamBridge::_meta_release(HTTP2StreamBridge *this)
{
  CFRelease((char *)this - 24);
}

uint64_t `non-virtual thunk to'HTTP2StreamBridge::rawBytesSent(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 72))(*((_QWORD *)this + 2));
}

uint64_t std::__shared_ptr_pointer<HTTP2Stream *,std::shared_ptr<HTTP2Stream>::__shared_ptr_default_delete<HTTP2Stream,HTTP2Stream>,std::allocator<HTTP2Stream>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t HTTPConnectionCacheEntry::EnqueuedRequest::isValid(HTTPConnectionCacheEntry::EnqueuedRequest *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 3);
  if (result)
    return (*(unsigned int (**)(uint64_t))(*(_QWORD *)result + 184))(result) != 0;
  return result;
}

void HTTP2Stream::~HTTP2Stream(HTTP2Stream *this)
{
  HTTP2Stream::~HTTP2Stream(this);
  JUMPOUT(0x186DB748CLL);
}

{
  char *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  NSObject *v10;
  const void *v11;
  const void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void *v16;
  NSObject *v17;
  const void *v18;
  const void *v19;
  std::__shared_weak_count *v20;
  const void *v21;
  const void *v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  __int128 v25;

  *(_QWORD *)this = &off_1E14E4F38;
  *((_QWORD *)this + 1) = &unk_1E14E4FE8;
  v2 = (char *)this + 264;
  v3 = *((_QWORD *)this + 33);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 64))(v3);
    v25 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v2, &v25);
    v4 = (std::__shared_weak_count *)*((_QWORD *)&v25 + 1);
    if (*((_QWORD *)&v25 + 1))
    {
      v5 = (unint64_t *)(*((_QWORD *)&v25 + 1) + 8);
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
  v7 = *((_QWORD *)this + 8);
  if (v7)
    CFRelease((CFTypeRef)(v7 - 16));
  v8 = *((_QWORD *)this + 4);
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 48))(v8);
  v9 = (const void *)*((_QWORD *)this + 3);
  if (v9)
    _Block_release(v9);
  v10 = *((_QWORD *)this + 9);
  if (v10)
    dispatch_release(v10);
  v11 = (const void *)*((_QWORD *)this + 15);
  if (v11)
    CFRelease(v11);
  v12 = (const void *)*((_QWORD *)this + 18);
  if (v12)
    CFRelease(v12);
  v13 = *((_QWORD *)this + 17);
  if (v13)
    CFRelease((CFTypeRef)(v13 - 16));
  v14 = *((_QWORD *)this + 2);
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
  v15 = *((_QWORD *)this + 5);
  if (v15)
    CFRelease((CFTypeRef)(v15 - 16));
  v16 = (const void *)*((_QWORD *)this + 6);
  if (v16)
  {
    *((_QWORD *)this + 6) = 0;
    CFRelease(v16);
  }
  v17 = *((_QWORD *)this + 21);
  if (v17)
    dispatch_release(v17);
  v18 = (const void *)*((_QWORD *)this + 39);
  if (v18)
    _Block_release(v18);
  v19 = (const void *)*((_QWORD *)this + 54);
  *((_QWORD *)this + 54) = 0;
  if (v19)
    CFRelease(v19);
  DataBuffer::~DataBuffer((HTTP2Stream *)((char *)this + 360));
  if (*((char *)this + 351) < 0)
    operator delete(*((void **)this + 41));
  v20 = (std::__shared_weak_count *)*((_QWORD *)this + 36);
  if (v20)
    std::__shared_weak_count::__release_weak(v20);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v2);
  v21 = (const void *)*((_QWORD *)this + 31);
  *((_QWORD *)this + 31) = 0;
  if (v21)
    CFRelease(v21);
  v22 = (const void *)*((_QWORD *)this + 30);
  *((_QWORD *)this + 30) = 0;
  if (v22)
    CFRelease(v22);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 216);
  v23 = *((_QWORD *)this + 20);
  *((_QWORD *)this + 20) = 0;
  if (v23)
    CFRelease((CFTypeRef)(v23 - 16));
  v24 = (std::__shared_weak_count *)*((_QWORD *)this + 12);
  if (v24)
    std::__shared_weak_count::__release_weak(v24);
  *(_QWORD *)this = &off_1E14E5838;
}

void sub_183F31094(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  const void *v4;
  std::__shared_weak_count *v5;
  const void *v6;
  const void *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  v4 = *(const void **)(v1 + 432);
  *(_QWORD *)(v1 + 432) = 0;
  if (v4)
    CFRelease(v4);
  DataBuffer::~DataBuffer((DataBuffer *)(v1 + 360));
  if (*(char *)(v1 + 351) < 0)
    operator delete(*(void **)(v1 + 328));
  v5 = *(std::__shared_weak_count **)(v1 + 288);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  v6 = *(const void **)(v1 + 248);
  *(_QWORD *)(v1 + 248) = 0;
  if (v6)
    CFRelease(v6);
  v7 = *(const void **)(v1 + 240);
  *(_QWORD *)(v1 + 240) = 0;
  if (v7)
    CFRelease(v7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 216);
  v8 = *(_QWORD *)(v1 + 160);
  *(_QWORD *)(v1 + 160) = 0;
  if (v8)
    CFRelease((CFTypeRef)(v8 - 16));
  v9 = *(std::__shared_weak_count **)(v1 + 96);
  if (v9)
    std::__shared_weak_count::__release_weak(v9);
  *(_QWORD *)v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void HTTP2Stream::closeAndClearHandler(HTTP2Stream *this)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34[2];
  __int128 v35;
  uint64_t v36;
  std::__shared_weak_count *v37;

  v36 = 0;
  v37 = 0;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 36);
  if (v2 && (v37 = std::__shared_weak_count::lock(v2)) != 0)
  {
    v3 = *((_QWORD *)this + 35);
    v36 = v3;
  }
  else
  {
    v3 = 0;
  }
  v4 = *(_QWORD *)(v3 + 264);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 64))(v4);
    v35 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v3 + 264, &v35);
    v5 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
    if (*((_QWORD *)&v35 + 1))
    {
      v6 = (unint64_t *)(*((_QWORD *)&v35 + 1) + 8);
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    v3 = v36;
  }
  *(_BYTE *)(v3 + 176) = 1;
  if (*((_DWORD *)this + 20) != -1)
  {
    if (*((_DWORD *)this + 14) == 3)
      goto LABEL_53;
    v8 = *((_QWORD *)this + 8);
    v9 = (std::__shared_weak_count *)*((_QWORD *)this + 36);
    if (v9)
    {
      v10 = std::__shared_weak_count::lock(v9);
      if (v10)
      {
        v11 = *((_QWORD *)this + 35);
        goto LABEL_47;
      }
    }
    else
    {
      v10 = 0;
    }
    v11 = 0;
LABEL_47:
    HTTP2Connection::cancelStream(v8, v11, v10);
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v30 = __ldaxr(p_shared_owners);
      while (__stlxr(v30 - 1, p_shared_owners));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    *((_DWORD *)this + 14) = 2;
    goto LABEL_53;
  }
  *((_DWORD *)this + 14) = 2;
  v12 = *((_QWORD *)this + 8);
  v13 = v37;
  v34[0] = v3;
  v34[1] = (uint64_t)v37;
  if (v37)
  {
    v14 = (unint64_t *)&v37->__shared_owners_;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  HTTP2Connection::didCloseStream(v12, v34, 0);
  if (v13)
  {
    v16 = (unint64_t *)&v13->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (*((_BYTE *)this + 232))
  {
    v18 = *((_QWORD *)this + 8);
    if (v18)
    {
      v19 = *(_QWORD *)(v18 + 56);
      if (v19)
      {
        if (*(_DWORD *)v19 == 1)
        {
          v20 = *(_QWORD *)(v19 + 8);
          v21 = *(std::__shared_weak_count **)(v19 + 16);
          *(_QWORD *)&v35 = v20;
          *((_QWORD *)&v35 + 1) = v21;
          if (v21)
          {
            v22 = (unint64_t *)&v21->__shared_owners_;
            do
              v23 = __ldxr(v22);
            while (__stxr(v23 + 1, v22));
          }
          v24 = *((_QWORD *)this + 2);
          if (v24)
            v25 = v20 == 0;
          else
            v25 = 1;
          if (!v25)
          {
            if (*((_BYTE *)this + 320))
              v26 = 6;
            else
              v26 = 8;
            (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD))(*(_QWORD *)v20 + 280))(v20, *(_QWORD *)(v24 - 96), v26, *((_QWORD *)this + 38));
            *((_BYTE *)this + 232) = 0;
          }
          if (v21)
          {
            v27 = (unint64_t *)&v21->__shared_owners_;
            do
              v28 = __ldaxr(v27);
            while (__stlxr(v28 - 1, v27));
            if (!v28)
            {
              ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
              std::__shared_weak_count::__release_weak(v21);
            }
          }
        }
      }
    }
  }
LABEL_53:
  v31 = v37;
  if (v37)
  {
    v32 = (unint64_t *)&v37->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
}

void sub_183F313EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v6;
  va_list va;
  uint64_t v8;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t HTTP2Stream::rawBytesReceived(HTTP2Stream *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 38);
  if (v1)
    return *(_QWORD *)(v1 + 136) + *(_QWORD *)(v1 + 120);
  else
    return 0;
}

uint64_t HTTP2Stream::rawBytesSent(HTTP2Stream *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 38);
  if (v1)
    return *(_QWORD *)(v1 + 112) + *(_QWORD *)(v1 + 96);
  else
    return 0;
}

void DataBuffer::~DataBuffer(DataBuffer *this)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;

  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 5));
  }
  v3 = *((_QWORD *)this + 6);
  if (v3)
    dispatch_release(v3);
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  v5 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v5)
    (*((void (**)(void))this + 4))();
}

void sub_183F31548(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void logAppleATSViolation(int a1, const void *a2, unsigned int a3, int a4)
{
  CFTypeID v8;
  const char *v9;
  const __CFString *v10;
  const __CFURL *v11;
  CFTypeID v12;
  const void *v13;
  const char **v14;
  CFStringRef v15;
  const char *v16;
  const __CFString *v17;
  const __CFString *v18;
  const __CFString *v19;
  UInt8 *v20;
  char v21;
  xpc_object_t v22;
  NSObject *v23;
  NSObject *v24;
  _QWORD block[5];
  uint8_t buf[4];
  char *v27;
  CFAllocatorRef allocator;
  uint64_t v29;
  char *string;
  UInt8 v31[1024];
  char __str[16];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (logAppleATSViolation::onceToken != -1)
    dispatch_once(&logAppleATSViolation::onceToken, &__block_literal_global_8973);
  if (os_variant_has_internal_diagnostics() && (logAppleATSViolation::loggingHalted & 1) == 0)
  {
    if (a2)
    {
      v8 = CFGetTypeID(a2);
      if (v8 == CFStringGetTypeID())
      {
        v9 = "https";
        if (!a3)
          v9 = "http";
        v10 = CFStringCreateWithFormat(0, 0, CFSTR("%s://%@/"), v9, a2);
        v11 = CFURLCreateWithString(0, v10, 0);
        if (v10)
          CFRelease(v10);
        if (!v11)
          goto LABEL_16;
LABEL_15:
        v13 = CFURLCopyHostName(v11);
        CFRelease(v11);
        goto LABEL_17;
      }
      v12 = CFGetTypeID(a2);
      if (v12 == CFURLGetTypeID())
      {
        v11 = (const __CFURL *)CFRetain(a2);
        if (v11)
          goto LABEL_15;
      }
    }
LABEL_16:
    v13 = CFRetain(CFSTR("none"));
LABEL_17:
    pthread_mutex_lock(&logAppleATSViolation::tableLock);
    if (CFDictionaryGetValue((CFDictionaryRef)logAppleATSViolation::reportedDomains, v13))
    {
      pthread_mutex_unlock(&logAppleATSViolation::tableLock);
LABEL_56:
      if (v13)
        CFRelease(v13);
      return;
    }
    CFDictionaryAddValue((CFMutableDictionaryRef)logAppleATSViolation::reportedDomains, v13, (const void *)*MEMORY[0x1E0C9AE50]);
    if (CFDictionaryGetCount((CFDictionaryRef)logAppleATSViolation::reportedDomains) >= 65)
      logAppleATSViolation::loggingHalted = 1;
    pthread_mutex_unlock(&logAppleATSViolation::tableLock);
    v14 = (const char **)_CFGetProgname();
    if (v14 && *v14)
      v15 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *v14, 0x8000100u);
    else
      v15 = 0;
    if (a3 > 0xA)
      v16 = "unknown";
    else
      v16 = off_1E14FA590[a3];
    snprintf(__str, 0x10uLL, "0x%04x", a4);
    if (a1)
    {
      if (a1 != 1)
      {
        allocator = 0;
        v29 = 1023;
        goto LABEL_39;
      }
      v17 = CFStringCreateWithFormat(0, 0, CFSTR("%@:%@:%@:%s:%s"), v13, v15, CFSTR("BuiltinException"), v16, __str);
    }
    else
    {
      if (getBundleId(void)::onceToken != -1)
        dispatch_once(&getBundleId(void)::onceToken, &__block_literal_global_81_8983);
      v18 = (const __CFString *)getBundleId(void)::bundleID;
      if (!getBundleId(void)::bundleID)
        v18 = CFSTR("none");
      v17 = CFStringCreateWithFormat(0, 0, CFSTR("%@:%@:%@:%s:%s"), v13, v18, CFSTR("BundleException"), v16, __str);
    }
    v19 = v17;
    allocator = 0;
    v29 = 1023;
    if (v17)
    {
      v20 = _CFStringGetOrCreateCString(0, v17, v31, &v29, 0x8000100u);
      v21 = 0;
LABEL_40:
      string = (char *)v20;
      v22 = xpc_dictionary_create(0, 0, 0);
      if (v22)
      {
        if (getMetricsQueue(void)::onceToken != -1)
          dispatch_once(&getMetricsQueue(void)::onceToken, &__block_literal_global_82_8985);
        v23 = getMetricsQueue(void)::metricsQueue;
        if (getMetricsQueue(void)::metricsQueue)
        {
          xpc_dictionary_set_string(v22, "domain", string);
          xpc_dictionary_set_string(v22, "protocol", v16);
          xpc_dictionary_set_string(v22, "ciphersuite", __str);
          if (ATSLog(void)::onceToken != -1)
            dispatch_once(&ATSLog(void)::onceToken, &__block_literal_global_84_8989);
          v24 = ATSLog(void)::atsLog;
          if (os_log_type_enabled((os_log_t)ATSLog(void)::atsLog, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315138;
            v27 = string;
            _os_log_debug_impl(&dword_183ECA000, v24, OS_LOG_TYPE_DEBUG, "Uploading Apple Internal exception usage for domain: %s", buf, 0xCu);
          }
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 3221225472;
          block[2] = __logAppleATSViolation_block_invoke_22;
          block[3] = &unk_1E14FE118;
          block[4] = v22;
          dispatch_async(v23, block);
        }
      }
      if (string && v31 != (UInt8 *)string)
        CFAllocatorDeallocate(allocator, string);
      if (v15)
        CFRelease(v15);
      if ((v21 & 1) == 0)
        CFRelease(v19);
      goto LABEL_56;
    }
LABEL_39:
    v19 = 0;
    v31[0] = 0;
    v29 = 0;
    v21 = 1;
    v20 = v31;
    goto LABEL_40;
  }
}

void sub_183F31A44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,CFAllocatorRef allocator,uint64_t a22,void *ptr)
{
  const void *v23;
  const void *v24;

  if (v24)
    CFRelease(v24);
  if (v23)
    CFRelease(v23);
  _Unwind_Resume(exception_object);
}

void StrictSecurityPolicy::reportATSExceptionEvent(const __CFString *this, const __CFString *a2)
{
  NSObject *v3;
  xpc_object_t v4;
  void *v5;
  const char *v6;
  const char *ExceptionString;
  const char *v8;
  const char *v9;
  const char *v10;
  NSObject *v11;
  NSObject *v12;
  const char *v13;
  NSObject *v14;
  _QWORD block[5];
  uint8_t buf[4];
  const char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (getMetricsQueue(void)::onceToken != -1)
    dispatch_once(&getMetricsQueue(void)::onceToken, &__block_literal_global_82_8985);
  v3 = getMetricsQueue(void)::metricsQueue;
  if (!getMetricsQueue(void)::metricsQueue)
  {
    if (ATSLog(void)::onceToken != -1)
      dispatch_once(&ATSLog(void)::onceToken, &__block_literal_global_84_8989);
    v12 = ATSLog(void)::atsLog;
    if (!os_log_type_enabled((os_log_t)ATSLog(void)::atsLog, OS_LOG_TYPE_DEBUG))
      return;
    *(_WORD *)buf = 0;
    v13 = "reportATSExceptionEvent: getMetricsQueue failed";
LABEL_31:
    _os_log_debug_impl(&dword_183ECA000, v12, OS_LOG_TYPE_DEBUG, v13, buf, 2u);
    return;
  }
  if (this)
  {
    v4 = xpc_dictionary_create(0, 0, 0);
    if (v4)
    {
      v5 = v4;
      if (getBundleIdString(void)::onceToken != -1)
        dispatch_once(&getBundleIdString(void)::onceToken, &__block_literal_global_144);
      v6 = (const char *)getBundleIdString(void)::bundleIdString;
      if (getBundleIdString(void)::bundleIdString)
      {
        ExceptionString = getExceptionString(this);
        if (ExceptionString)
        {
          v8 = ExceptionString;
          xpc_dictionary_set_string(v5, "BundleID", v6);
          xpc_dictionary_set_string(v5, "Exception", v8);
          v9 = getExceptionString(this);
          if (v9)
          {
            v10 = v9;
            if (ATSLog(void)::onceToken != -1)
              dispatch_once(&ATSLog(void)::onceToken, &__block_literal_global_84_8989);
            v11 = ATSLog(void)::atsLog;
            if (os_log_type_enabled((os_log_t)ATSLog(void)::atsLog, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136315138;
              v17 = v10;
              _os_log_debug_impl(&dword_183ECA000, v11, OS_LOG_TYPE_DEBUG, "Uploading ATS exception %s", buf, 0xCu);
            }
            block[0] = MEMORY[0x1E0C809B0];
            block[1] = 3221225472;
            block[2] = ___ZNK20StrictSecurityPolicy23reportATSExceptionEventEPK10__CFString_block_invoke;
            block[3] = &unk_1E14FE118;
            block[4] = v5;
            dispatch_async(v3, block);
          }
          else
          {
            if (ATSLog(void)::onceToken != -1)
              dispatch_once(&ATSLog(void)::onceToken, &__block_literal_global_84_8989);
            v14 = ATSLog(void)::atsLog;
            if (os_log_type_enabled((os_log_t)ATSLog(void)::atsLog, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)buf = 0;
              _os_log_debug_impl(&dword_183ECA000, v14, OS_LOG_TYPE_DEBUG, "reportATSExceptionEvent: getExceptionString failed", buf, 2u);
            }
            xpc_release(v5);
          }
          return;
        }
      }
      xpc_release(v5);
    }
  }
  if (ATSLog(void)::onceToken != -1)
    dispatch_once(&ATSLog(void)::onceToken, &__block_literal_global_84_8989);
  v12 = ATSLog(void)::atsLog;
  if (os_log_type_enabled((os_log_t)ATSLog(void)::atsLog, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    v13 = "reportATSExceptionEvent: createATSExceptionEventMetadata failed";
    goto LABEL_31;
  }
}

const char *getExceptionString(const __CFString *a1)
{
  if (CFEqual(a1, CFSTR("NSAllowsArbitraryLoadsInWebContent")))
    return "ATSAllowsArbitraryLoadsInWebContent";
  if (CFEqual(a1, CFSTR("NSAllowsArbitraryLoads")))
    return "ATSAllowsArbitraryLoads";
  if (CFEqual(a1, CFSTR("NSAllowsArbitraryLoadsForMedia")))
    return "ATSAllowsArbitraryLoadsForMedia";
  if (CFEqual(a1, CFSTR("NSAllowsLocalNetworking")))
    return "ATSAllowsLocalNetworking";
  if (CFEqual(a1, CFSTR("NSExceptionDomains")))
    return "ATSExceptionDomains";
  return 0;
}

void ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v1;
  const __CFString *v2;
  _BOOL4 v3;
  uint64_t v4;
  unint64_t v5;
  std::string *v6;
  std::string *p_dst;
  uint64_t hasPromised;
  uint64_t v9;
  int v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  CFMutableSetRef Mutable;
  const __CFAllocator *v29;
  const void *v30;
  void *v31;
  int data;
  void *v33;
  uint64_t v34;
  const char *v35;
  void *v36;
  void **v37;
  void *v38;
  SEL v39;
  void *v40;
  SEL v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t i;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const __CFAllocator *v51;
  CFNumberRef v52;
  uint64_t v53;
  void *v54;
  void *v55;
  CFURLRef v56;
  void *v57;
  uint64_t v58;
  _QWORD *v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  void *v63;
  uint64_t v64;
  void *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  void *v70;
  uint64_t v71;
  void *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  NSObject *v79;
  std::__shared_weak_count *v80;
  unint64_t *v81;
  unint64_t v82;
  void *v83;
  __NSURLSessionTaskDependencyResourceIdentifier *v84;
  const char *v85;
  __NSURLSessionTaskDependencyResourceIdentifier *v86;
  uint64_t v87;
  uint64_t v88;
  void *v89;
  void *v90;
  __NSURLSessionTaskDependencyResourceIdentifier *v91;
  const char *v92;
  __NSURLSessionTaskDependencyResourceIdentifier *v93;
  uint64_t v94;
  uint64_t v95;
  void *v96;
  uint64_t v97;
  void *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  int v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  void *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  int v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  char v118;
  int v119;
  uint64_t v120;
  void *v121;
  void *v122;
  uint64_t v123;
  _QWORD v125[2];
  uint64_t (*v126)();
  void *v127;
  uint64_t v128;
  uint64_t v129;
  std::__shared_weak_count *v130;
  _QWORD v131[2];
  uint64_t (*v132)(uint64_t, int);
  void *v133;
  uint64_t v134;
  uint64_t v135;
  std::__shared_weak_count *v136;
  uint64_t v137;
  int v138;
  void *__p[2];
  uint64_t v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  std::string __dst;
  void *v146;
  std::string *v147;
  __int128 *v148;
  std::string v149;
  __int128 v150;
  uint64_t v151;
  uint64_t v152;

  v152 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 64);
  v123 = *(_QWORD *)(a1 + 56);
  v2 = CFHTTPMessageCopyRequestMethod((CFHTTPMessageRef)(*(_QWORD *)(v1 + 40) - 16));
  if (CFStringCompare(v2, CFSTR("GET"), 1uLL) == kCFCompareEqualTo)
  {
    v3 = *(_QWORD *)(v1 + 264) == 0;
    if (!v2)
      goto LABEL_4;
    goto LABEL_3;
  }
  v3 = 0;
  if (v2)
LABEL_3:
    CFRelease(v2);
LABEL_4:
  if (v3 && *(_QWORD *)(v123 + 312) != *(_QWORD *)(v123 + 320))
  {
    v141 = 0u;
    v142 = 0u;
    LODWORD(v143) = 1065353216;
    v4 = a1;
    if (*(_DWORD *)(a1 + 104))
    {
      v5 = 0;
      do
      {
        std::string::basic_string[abi:nn180100](&__dst, *(void **)(*(_QWORD *)(v4 + 80) + 40 * v5), *(_QWORD *)(*(_QWORD *)(v4 + 80) + 40 * v5 + 16));
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v6 = (std::string *)((char *)&__dst + HIBYTE(__dst.__r_.__value_.__r.__words[2]));
        else
          v6 = (std::string *)(__dst.__r_.__value_.__r.__words[0] + __dst.__r_.__value_.__l.__size_);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_dst = &__dst;
        else
          p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
        while (p_dst != v6)
        {
          p_dst->__r_.__value_.__s.__data_[0] = __tolower(p_dst->__r_.__value_.__s.__data_[0]);
          p_dst = (std::string *)((char *)p_dst + 1);
        }
        std::string::basic_string[abi:nn180100](__p, *(void **)(*(_QWORD *)(a1 + 80) + 40 * v5 + 8), *(_QWORD *)(*(_QWORD *)(a1 + 80) + 40 * v5 + 24));
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          std::string::__init_copy_ctor_external(&v149, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        else
          v149 = __dst;
        v150 = *(_OWORD *)__p;
        v151 = v140;
        __p[1] = 0;
        v140 = 0;
        __p[0] = 0;
        std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::pair<std::string,std::string>>((uint64_t)&v141, (uint64_t)&v149, (uint64_t)&v149);
        if (SHIBYTE(v151) < 0)
          operator delete((void *)v150);
        if (SHIBYTE(v149.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v149.__r_.__value_.__l.__data_);
        if (SHIBYTE(v140) < 0)
          operator delete(__p[0]);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__dst.__r_.__value_.__l.__data_);
        ++v5;
        v4 = a1;
      }
      while (v5 < *(unsigned int *)(a1 + 104));
    }
    hasPromised = HTTP2ServerPush::hasPromised((int8x8_t *)(v123 + 288), &v141);
    v9 = hasPromised;
    if (hasPromised)
    {
      v10 = *(_DWORD *)(hasPromised + 172);
      if (v10 <= 0)
        __assert_rtn("setStreamID", "HTTP2Stream.cpp", 693, "streamID > 0");
      v11 = *(_DWORD **)(a1 + 64);
      v11[20] = v10;
      v11[14] = 0;
      v12 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v11 + 24))(v11);
      v13 = v12;
      if (v12)
        *(_BYTE *)(v12 + 10) = 1;
      v14 = *(_QWORD *)(v123 + 56);
      if (*(_DWORD *)v14 == 1)
        v15 = (void *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v14 + 8) + 248))(*(_QWORD *)(v14 + 8));
      else
        v15 = 0;
      -[__CFN_TransactionMetrics requestBeginOnConnection:reusedAfterTime:](v13, v15, *(double *)(*(_QWORD *)(a1 + 64) + 440));
      if (v13)
      {
        *(CFAbsoluteTime *)(v13 + 184) = CFAbsoluteTimeGetCurrent();
        *(_QWORD *)(v13 + 200) = 0x7FF8000000000000;
      }
      v131[0] = MEMORY[0x1E0C809B0];
      v131[1] = 3321888768;
      v132 = ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_2;
      v133 = &__block_descriptor_68_e8_40c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE_e8_v12__0B8l;
      v17 = *(_QWORD *)(a1 + 64);
      v16 = *(std::__shared_weak_count **)(a1 + 72);
      v134 = v123;
      v135 = v17;
      v136 = v16;
      if (v16)
      {
        p_shared_owners = (unint64_t *)&v16->__shared_owners_;
        do
          v19 = __ldxr(p_shared_owners);
        while (__stxr(v19 + 1, p_shared_owners));
      }
      v137 = v9;
      v138 = v10;
      if (*(_BYTE *)(v9 + 168))
      {
        v20 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_21_2490, 2);
        v21 = v20;
        if (v20
          && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v20 + 16))(v20, "h2 info push promise", 0))
        {
          HTTP2ServerPushStream::_getFullURL(v9 + 8, v9 + 224);
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v21 + 72))(v21, "h2 psps", CFSTR("[%llu] found complete push promise stream<stream_id=%d> url: %s"));
          (*(void (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
        }
        v132((uint64_t)v131, 1);
      }
      else
      {
        v77 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_25, 2);
        v78 = v77;
        if (v77
          && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v77 + 16))(v77, "h2 info push promise", 0))
        {
          v79 = *(NSObject **)(v9 + 152);
          if (v79)
            dispatch_data_get_size(v79);
          HTTP2ServerPushStream::_getFullURL(v9 + 8, v9 + 224);
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v78 + 72))(v78, "h2 psps", CFSTR("[%llu] found incomplete push promise stream<stream_id=%d data_received=%lu> url: %s"));
          (*(void (**)(uint64_t))(*(_QWORD *)v78 + 8))(v78);
        }
        SmartBlockWithArgs<BOOL>::SmartBlockWithArgs(&v129, v131);
        std::vector<SmartBlockWithArgs<BOOL>>::push_back[abi:nn180100]((char **)(v9 + 176), v129, (uint64_t)v130);
        ++*(_DWORD *)(*(_QWORD *)v9 + 16);
        v80 = v130;
        if (v130)
        {
          v81 = (unint64_t *)&v130->__shared_owners_;
          do
            v82 = __ldaxr(v81);
          while (__stlxr(v82 - 1, v81));
          if (!v82)
          {
            ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
            std::__shared_weak_count::__release_weak(v80);
          }
        }
      }
      v22 = *(void **)(v123 + 128);
      if (v22)
        dispatch_async(*(dispatch_queue_t *)(v123 + 168), v22);
      v23 = v136;
      if (v136)
      {
        v24 = (unint64_t *)&v136->__shared_owners_;
        do
          v25 = __ldaxr(v24);
        while (__stlxr(v25 - 1, v24));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
      }
      std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&v141);
      return;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&v141);
  }
  if (*(_BYTE *)(v123 + 264)
    || (*(_DWORD *)(v123 + 176) - 3) < 2
    || *(_QWORD *)(v123 + 144) | *(unsigned int *)(v123 + 152))
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
    return;
  }
  v26 = *(_QWORD *)(a1 + 64);
  if (*(_QWORD *)(v26 + 432))
  {
    LODWORD(__p[0]) = 0;
    LODWORD(__p[0]) = nghttp2_session_get_next_stream_id();
    v27 = v123;
    Mutable = *(CFMutableSetRef *)(v123 + 584);
    if (!Mutable)
    {
      v29 = CFGetAllocator((CFTypeRef)(v123 - 16));
      Mutable = CFSetCreateMutable(v29, 0, MEMORY[0x1E0C9B3B0]);
      v27 = v123;
      v30 = *(const void **)(v123 + 584);
      *(_QWORD *)(v123 + 584) = Mutable;
      if (v30)
      {
        CFRelease(v30);
        Mutable = *(CFMutableSetRef *)(v123 + 584);
      }
    }
    v31 = *(void **)(*(_QWORD *)(a1 + 64) + 432);
    data = (int)__p[0];
    v125[0] = MEMORY[0x1E0C809B0];
    v125[1] = 3221225472;
    v126 = ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_3_28;
    v127 = &__block_descriptor_40_e17_v24__0i8i12i16B20l;
    v128 = v27;
    v33 = (void *)objc_msgSend(v31, "objectForKeyedSubscript:", CFSTR("MainDocumentTaskIdentifier"));
    if (v33)
    {
      v34 = objc_msgSend(v31, "objectForKeyedSubscript:", CFSTR("DependencyTree"));
      if (v34)
      {
        if ((-[__CFSet containsObject:](Mutable, "containsObject:", v33) & 1) == 0)
        {
          -[__CFSet addObject:](Mutable, "addObject:", v33);
          LODWORD(__dst.__r_.__value_.__l.__data_) = data;
          v36 = *(void **)(v34 + 24);
          if (v36 && (objc_setProperty_nonatomic(v36, v35, v33, 32), (v37 = *(void ***)(v34 + 24)) != 0))
          {
            if (!v37[5])
            {
              v38 = (void *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
              objc_setProperty_nonatomic(v37, v39, v38, 40);
            }
            if (!v37[6])
            {
              v40 = (void *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
              objc_setProperty_nonatomic(v37, v41, v40, 48);
            }
            v42 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
            -[__NSCFURLSessionTaskDependencyTreeNode makePriorityInfoStartingFromStreamID:parentStream:priorityInfo:dependentToParentStreamIDs:parentToParentStreamIDs:]((uint64_t)v37, (unsigned int *)&__dst, 0, v42, v37[5], v37[6]);
          }
          else
          {
            v42 = 0;
          }
          v143 = 0u;
          v144 = 0u;
          v141 = 0u;
          v142 = 0u;
          v43 = objc_msgSend(v42, "countByEnumeratingWithState:objects:count:", &v141, &v149, 16);
          if (v43)
          {
            v44 = *(_QWORD *)v142;
            do
            {
              for (i = 0; i != v43; ++i)
              {
                if (*(_QWORD *)v142 != v44)
                  objc_enumerationMutation(v42);
                v46 = *(void **)(*((_QWORD *)&v141 + 1) + 8 * i);
                v47 = objc_msgSend((id)objc_msgSend(v46, "objectForKeyedSubscript:", CFSTR("streamID")), "intValue");
                v48 = objc_msgSend((id)objc_msgSend(v46, "objectForKeyedSubscript:", CFSTR("parentStreamID")), "intValue");
                v49 = objc_msgSend((id)objc_msgSend(v46, "objectForKeyedSubscript:", CFSTR("weight")), "intValue");
                v50 = objc_msgSend((id)objc_msgSend(v46, "objectForKeyedSubscript:", CFSTR("exclusive")), "BOOLValue");
                ((void (*)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))v126)(v125, v47, v48, v49, v50);
              }
              v43 = objc_msgSend(v42, "countByEnumeratingWithState:objects:count:", &v141, &v149, 16);
            }
            while (v43);
          }
          if (objc_msgSend(v42, "count"))
            data = LODWORD(__dst.__r_.__value_.__l.__data_) + 2;
          else
            data = (int)__dst.__r_.__value_.__l.__data_;
        }
      }
    }
    LODWORD(__p[0]) = data;
    nghttp2_session_set_next_stream_id();
    v51 = CFGetAllocator((CFTypeRef)(v123 - 16));
    v52 = CFNumberCreate(v51, kCFNumberSInt32Type, __p);
    v53 = *(_QWORD *)(a1 + 64);
    v54 = *(void **)(v53 + 432);
    v55 = *(void **)(v123 + 40);
    v56 = CFHTTPMessageCopyRequestURL((CFHTTPMessageRef)(*(_QWORD *)(v53 + 40) - 16));
    v57 = (void *)objc_msgSend(v55, "objectForKeyedSubscript:", CFSTR("TaskIDs"));
    v58 = objc_msgSend(v54, "objectForKeyedSubscript:", CFSTR("ParentTaskIdentifier"));
    if (v58)
    {
      v59 = (_QWORD *)objc_msgSend(v57, "objectForKeyedSubscript:", v58);
      if (v59)
        v59 = (_QWORD *)v59[1];
      v60 = objc_msgSend(v59, "intValue");
      if (v60)
        goto LABEL_155;
    }
    v61 = objc_msgSend(v54, "objectForKeyedSubscript:", CFSTR("DependencyTree"));
    v62 = objc_msgSend(v54, "objectForKeyedSubscript:", CFSTR("MainDocumentTaskIdentifier"));
    if (!v62)
      goto LABEL_154;
    v149.__r_.__value_.__r.__words[0] = 0;
    v149.__r_.__value_.__l.__size_ = (std::string::size_type)&v149;
    v149.__r_.__value_.__r.__words[2] = 0x3052000000;
    *(_QWORD *)&v150 = __Block_byref_object_copy__12296;
    *((_QWORD *)&v150 + 1) = __Block_byref_object_dispose__12297;
    v151 = 0;
    *(_QWORD *)&v141 = 0;
    *((_QWORD *)&v141 + 1) = &v141;
    *(_QWORD *)&v142 = 0x3052000000;
    *((_QWORD *)&v142 + 1) = __Block_byref_object_copy__12296;
    *(_QWORD *)&v143 = __Block_byref_object_dispose__12297;
    *((_QWORD *)&v143 + 1) = 0;
    __dst.__r_.__value_.__r.__words[0] = MEMORY[0x1E0C809B0];
    __dst.__r_.__value_.__l.__size_ = 3221225472;
    __dst.__r_.__value_.__r.__words[2] = (std::string::size_type)____NSURLSessionTaskDependency_FindParentStreamID_block_invoke;
    v146 = &unk_1E14FBB58;
    v147 = &v149;
    v148 = &v141;
    v63 = (void *)objc_msgSend(MEMORY[0x1E0CB3998], "componentsWithURL:resolvingAgainstBaseURL:", v56, 1);
    v64 = objc_msgSend(v63, "rangeOfPath");
    v65 = (void *)objc_msgSend(v63, "string");
    v66 = objc_msgSend(v65, "substringWithRange:", 0, v64);
    v67 = objc_msgSend(v65, "substringWithRange:", v64, objc_msgSend(v65, "length") - v64);
    ((void (*)(std::string *, uint64_t, uint64_t))__dst.__r_.__value_.__r.__words[2])(&__dst, v66, v67);
    v68 = objc_msgSend(v54, "objectForKeyedSubscript:", CFSTR("DependencyDescription"));
    if (v68)
    {
      if (v61 && (v69 = *(_QWORD *)(v61 + 24)) != 0)
        v70 = *(void **)(v69 + 48);
      else
        v70 = 0;
      v60 = objc_msgSend((id)objc_msgSend(v70, "objectForKeyedSubscript:", *(_QWORD *)(v68 + 24)), "intValue");
      if (v60)
        goto LABEL_152;
      v71 = *(_QWORD *)(v68 + 24);
      if (!v71)
        goto LABEL_135;
      if (*(_QWORD *)(v71 + 8))
      {
        v72 = (void *)objc_msgSend(MEMORY[0x1E0CB37A0], "stringWithString:", *(_QWORD *)(v149.__r_.__value_.__l.__size_ + 40));
        v73 = (uint64_t)v72;
        v74 = *(_QWORD *)(v68 + 24);
        if (v74)
          v75 = *(_QWORD *)(v74 + 8);
        else
          v75 = 0;
        objc_msgSend(v72, "appendString:", v75);
        v76 = -[__NSCFURLSessionTaskActiveStreamDependencyInfo parentStreamIDForURLString:](objc_msgSend(v57, "objectForKeyedSubscript:", v62), v73);
      }
      else
      {
        if (!*(_QWORD *)(v71 + 16))
          goto LABEL_135;
        v103 = objc_msgSend(v57, "objectForKeyedSubscript:", v62);
        v104 = *(_QWORD *)(v68 + 24);
        if (v104)
          v105 = *(_QWORD *)(v104 + 16);
        else
          v105 = 0;
        v76 = -[__NSCFURLSessionTaskActiveStreamDependencyInfo parentStreamIDForMimeType:](v103, v105);
      }
      v60 = v76;
      if (v76)
      {
LABEL_152:
        v118 = 0;
        goto LABEL_153;
      }
LABEL_135:
      v60 = 0;
      goto LABEL_152;
    }
    if (!v61)
      goto LABEL_173;
    v83 = *(void **)(*((_QWORD *)&v141 + 1) + 40);
    v84 = objc_alloc_init(__NSURLSessionTaskDependencyResourceIdentifier);
    v86 = v84;
    if (v84)
      objc_setProperty_nonatomic(v84, v85, v83, 8);
    v87 = objc_msgSend(*(id *)(v61 + 16), "objectForKey:", v86);
    if (v87)
    {
      v88 = *(_QWORD *)(v61 + 24);
      v89 = v88 ? *(void **)(v88 + 40) : 0;
      v60 = objc_msgSend((id)objc_msgSend(v89, "objectForKeyedSubscript:", *(_QWORD *)(v87 + 16)), "intValue");
      if (v60)
        goto LABEL_152;
    }
    v90 = (void *)+[NSURLSessionTaskDependencyTree mimeTypeForURLString:]((uint64_t)NSURLSessionTaskDependencyTree, *(_QWORD *)(*((_QWORD *)&v141 + 1) + 40));
    v91 = objc_alloc_init(__NSURLSessionTaskDependencyResourceIdentifier);
    v93 = v91;
    if (v91)
      objc_setProperty_nonatomic(v91, v92, v90, 16);
    v94 = objc_msgSend(*(id *)(v61 + 16), "objectForKey:", v93);
    if (v94)
    {
      v95 = *(_QWORD *)(v61 + 24);
      v96 = v95 ? *(void **)(v95 + 40) : 0;
      v60 = objc_msgSend((id)objc_msgSend(v96, "objectForKeyedSubscript:", *(_QWORD *)(v94 + 16)), "intValue");
      if (v60)
        goto LABEL_152;
    }
    if (v87)
    {
      v97 = *(_QWORD *)(v87 + 24);
      if (v97)
      {
        if (*(_QWORD *)(v97 + 8))
        {
          v98 = (void *)objc_msgSend(MEMORY[0x1E0CB37A0], "stringWithString:", *(_QWORD *)(v149.__r_.__value_.__l.__size_ + 40));
          v99 = (uint64_t)v98;
          v100 = *(_QWORD *)(v87 + 24);
          if (v100)
            v101 = *(_QWORD *)(v100 + 8);
          else
            v101 = 0;
          objc_msgSend(v98, "appendString:", v101);
          v102 = -[__NSCFURLSessionTaskActiveStreamDependencyInfo parentStreamIDForURLString:](objc_msgSend(v57, "objectForKeyedSubscript:", v62), v99);
        }
        else
        {
          if (!*(_QWORD *)(v97 + 16))
            goto LABEL_141;
          v106 = objc_msgSend(v57, "objectForKeyedSubscript:", v62);
          v107 = *(_QWORD *)(v87 + 24);
          if (v107)
            v108 = *(_QWORD *)(v107 + 16);
          else
            v108 = 0;
          v102 = -[__NSCFURLSessionTaskActiveStreamDependencyInfo parentStreamIDForMimeType:](v106, v108);
        }
        v60 = v102;
        if (v102)
          goto LABEL_152;
      }
    }
LABEL_141:
    if (v94)
    {
      v109 = *(_QWORD *)(v94 + 24);
      if (v109)
      {
        if (*(_QWORD *)(v109 + 8))
        {
          v110 = (void *)objc_msgSend(MEMORY[0x1E0CB37A0], "stringWithString:", *(_QWORD *)(v149.__r_.__value_.__l.__size_ + 40));
          v111 = (uint64_t)v110;
          v112 = *(_QWORD *)(v94 + 24);
          if (v112)
            v113 = *(_QWORD *)(v112 + 8);
          else
            v113 = 0;
          objc_msgSend(v110, "appendString:", v113);
          v114 = -[__NSCFURLSessionTaskActiveStreamDependencyInfo parentStreamIDForURLString:](objc_msgSend(v57, "objectForKeyedSubscript:", v62), v111);
          goto LABEL_151;
        }
        if (*(_QWORD *)(v109 + 16))
        {
          v115 = objc_msgSend(v57, "objectForKeyedSubscript:", v62);
          v116 = *(_QWORD *)(v94 + 24);
          if (v116)
            v117 = *(_QWORD *)(v116 + 16);
          else
            v117 = 0;
          v114 = -[__NSCFURLSessionTaskActiveStreamDependencyInfo parentStreamIDForMimeType:](v115, v117);
LABEL_151:
          v60 = v114;
          if (v114)
            goto LABEL_152;
LABEL_174:
          v118 = 1;
LABEL_153:
          _Block_object_dispose(&v141, 8);
          _Block_object_dispose(&v149, 8);
          if ((v118 & 1) == 0)
          {
LABEL_155:
            if (v56)
              CFRelease(v56);
            v26 = *(_QWORD *)(a1 + 64);
            goto LABEL_158;
          }
LABEL_154:
          v60 = 0;
          goto LABEL_155;
        }
      }
    }
LABEL_173:
    v60 = 0;
    goto LABEL_174;
  }
  v52 = 0;
  v60 = 0;
LABEL_158:
  LODWORD(v149.__r_.__value_.__r.__words[1]) = 0;
  v149.__r_.__value_.__r.__words[0] = 0;
  if (*(_BYTE *)(v26 + 233) != 16 || v60)
    nghttp2_priority_spec_init();
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = nghttp2_submit_request();
  v119 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
  if (v119 == -509 || v119 == -901)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  }
  else
  {
    if (!*(_DWORD *)(v123 + 600))
    {
      *(_DWORD *)(v123 + 600) = v119;
      v119 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
    }
    if (v119 <= 0)
      __assert_rtn("setStreamID", "HTTP2Stream.cpp", 693, "streamID > 0");
    v120 = *(_QWORD *)(a1 + 64);
    *(_DWORD *)(v120 + 80) = v119;
    *(_DWORD *)(v120 + 56) = 0;
    v121 = *(void **)(v120 + 432);
    if (v121)
      __NSURLSessionTaskDependency_AddNewRequest(v121, v52, *(void **)(v123 + 40), *(_QWORD *)(v120 + 48));
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    v122 = *(void **)(v123 + 128);
    if (v122)
      dispatch_async(*(dispatch_queue_t *)(v123 + 168), v122);
  }
  if (v52)
    CFRelease(v52);
}

void sub_183F32D04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  const void *v51;
  const void *v52;
  uint64_t v53;

  _Block_object_dispose(&a38, 8);
  _Block_object_dispose((const void *)(v53 - 256), 8);
  if (v52)
    CFRelease(v52);
  if (v51)
    CFRelease(v51);
  _Unwind_Resume(a1);
}

uint64_t __NSURLSessionTaskDependency_AddNewRequest(void *a1, void *a2, void *a3, uint64_t a4)
{
  void *v8;
  __NSCFURLSessionTaskActiveStreamDependencyInfo *v9;
  _QWORD *v10;
  const char *v11;
  _QWORD *v12;
  uint64_t v13;
  id v14;
  id v15;
  uint64_t result;
  uint64_t v17;
  __NSCFURLSessionTaskActiveStreamDependencyInfo *v18;
  NSMutableDictionary *mainDocumentTaskURLs;
  uint64_t v20;
  NSMutableDictionary *v21;
  NSMutableDictionary *v22;
  uint64_t v23;
  objc_super v24;

  v8 = (void *)objc_msgSend(a3, "objectForKeyedSubscript:", CFSTR("TaskIDs"));
  if (!v8)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
    objc_msgSend(a3, "setObject:forKeyedSubscript:", v8, CFSTR("TaskIDs"));
  }
  v9 = [__NSCFURLSessionTaskActiveStreamDependencyInfo alloc];
  if (v9)
  {
    v24.receiver = v9;
    v24.super_class = (Class)__NSCFURLSessionTaskActiveStreamDependencyInfo;
    v10 = objc_msgSendSuper2(&v24, sel_init);
    v12 = v10;
    if (v10)
    {
      objc_setProperty_nonatomic(v10, v11, a2, 8);
      v13 = objc_msgSend(MEMORY[0x1E0C99DE8], "array");
      v14 = (id)v12[2];
      if (!v14)
      {
        v14 = objc_alloc_init(MEMORY[0x1E0C99E08]);
        v12[2] = v14;
      }
      objc_msgSend(v14, "setObject:forKeyedSubscript:", v13, a4);
      v15 = (id)v12[2];
      if (!v15)
      {
        v15 = objc_alloc_init(MEMORY[0x1E0C99E08]);
        v12[2] = v15;
      }
      objc_msgSend((id)objc_msgSend(v15, "objectForKeyedSubscript:", a4), "setObject:atIndexedSubscript:", a2, 0);
    }
  }
  else
  {
    v12 = 0;
  }
  objc_msgSend(v8, "setObject:forKeyedSubscript:", v12, objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("TaskIdentifier")));
  result = objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("MainDocumentTaskIdentifier"));
  if (result)
  {
    v17 = result;
    v18 = (__NSCFURLSessionTaskActiveStreamDependencyInfo *)objc_msgSend(v8, "objectForKeyedSubscript:", result);
    if (v18
      || (v18 = objc_alloc_init(__NSCFURLSessionTaskActiveStreamDependencyInfo),
          result = objc_msgSend(v8, "setObject:forKeyedSubscript:", v18, v17),
          v18))
    {
      mainDocumentTaskURLs = v18->_mainDocumentTaskURLs;
      if (!mainDocumentTaskURLs)
      {
        mainDocumentTaskURLs = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x1E0C99E08]);
        v18->_mainDocumentTaskURLs = mainDocumentTaskURLs;
      }
      if (!-[NSMutableDictionary objectForKeyedSubscript:](mainDocumentTaskURLs, "objectForKeyedSubscript:", a4))
      {
        v20 = objc_msgSend(MEMORY[0x1E0C99DE8], "array");
        v21 = v18->_mainDocumentTaskURLs;
        if (!v21)
        {
          v21 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x1E0C99E08]);
          v18->_mainDocumentTaskURLs = v21;
        }
        -[NSMutableDictionary setObject:forKeyedSubscript:](v21, "setObject:forKeyedSubscript:", v20, a4);
      }
      v22 = v18->_mainDocumentTaskURLs;
      if (!v22)
      {
        v22 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x1E0C99E08]);
        v18->_mainDocumentTaskURLs = v22;
      }
      result = objc_msgSend((id)-[NSMutableDictionary objectForKeyedSubscript:](v22, "objectForKeyedSubscript:", a4), "addObject:", a2);
      if (v18->_mainDocumentTaskMimeTypes)
      {
        result = +[NSURLSessionTaskDependencyTree mimeTypeForURLString:]((uint64_t)NSURLSessionTaskDependencyTree, a4);
        if (result)
        {
          v23 = result;
          if (!-[NSMutableDictionary objectForKeyedSubscript:](v18->_mainDocumentTaskMimeTypes, "objectForKeyedSubscript:", result))-[NSMutableDictionary setObject:forKeyedSubscript:](v18->_mainDocumentTaskMimeTypes, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x1E0C99DE8], "array"), v23);
          return objc_msgSend((id)-[NSMutableDictionary objectForKeyedSubscript:](v18->_mainDocumentTaskMimeTypes, "objectForKeyedSubscript:", v23), "addObject:", a2);
        }
      }
    }
  }
  return result;
}

uint64_t ___ZN11TubeManager14requestNewTubeEP16BaseAwaitingTubeU13block_pointerFvP4TubeE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 32);
  if (a2)
    (*(void (**)(_QWORD))(*(_QWORD *)v2 + 56))(*(_QWORD *)(a1 + 32));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

uint64_t ___ZN11HTTP2Stream26scheduleAndOpenWithHandlerEPK17CoreSchedulingSetU13block_pointerFvP15__CFHTTPMessagePU27objcproto16OS_dispatch_data8NSObjectPK13CFStreamErrorEU13block_pointerFvhE_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 32);
  result = *(_QWORD *)(v1 + 264);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)result + 40))(result, *(_QWORD *)(v1 + 32), 0);
  return result;
}

double dateFromString(CFStringRef theString, unsigned __int8 *a2)
{
  uint64_t v3;
  double AbsoluteTime;
  CFTimeZoneRef tz;
  CFGregorianDate v7;

  tz = 0;
  v3 = _CFGregorianDateCreateWithString(0, theString, (uint64_t)&v7, (CFTypeRef *)&tz);
  if (a2)
    *a2 = 0;
  if (v3 < 1)
  {
    AbsoluteTime = 0.0;
  }
  else
  {
    AbsoluteTime = CFGregorianDateGetAbsoluteTime(v7, tz);
    if (a2)
      *a2 = 1;
  }
  if (tz)
    CFRelease(tz);
  return AbsoluteTime;
}

uint64_t _CFGregorianDateCreateWithString(const __CFAllocator *a1, CFStringRef theString, uint64_t a3, CFTypeRef *a4)
{
  uint64_t result;
  CFIndex usedBufLen;
  UInt8 buffer[256];
  uint64_t v11;
  CFRange v12;

  v11 = *MEMORY[0x1E0C80C00];
  v12.length = CFStringGetLength(theString);
  usedBufLen = v12.length;
  v12.location = 0;
  CFStringGetBytes(theString, v12, 0x600u, 0, 0, buffer, 256, &usedBufLen);
  if (usedBufLen)
    return _CFGregorianDateCreateWithBytes(a1, (char *)buffer, usedBufLen, (CFGregorianDate *)a3, a4) - (char *)buffer;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  result = 0;
  if (a4)
    *a4 = 0;
  return result;
}

char *_CFGregorianDateCreateWithBytes(const __CFAllocator *a1, char *a2, uint64_t a3, CFGregorianDate *a4, CFTypeRef *a5)
{
  char *v7;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v20;
  const char *v21;
  size_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  SInt8 day;
  uint64_t v27;
  char v28;
  char v29;
  uint64_t v30;
  int i;
  SInt8 hour;
  char v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  SInt8 minute;
  char v38;
  char v39;
  uint64_t v40;
  unsigned __int8 v41;
  uint64_t v42;
  int v43;
  double second;
  char v45;
  char v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  const char *v50;
  size_t v51;
  SInt8 v52;
  char v53;
  char *v54;
  uint64_t v55;
  char v56;
  uint64_t v57;
  int v58;
  unsigned int v59;
  uint64_t v60;
  unsigned int v61;
  double v62;
  double v63;
  unsigned __int8 v64;
  int j;
  uint64_t v66;
  uint64_t v67;
  int year;
  uint64_t v69;
  BOOL v70;
  uint64_t v71;
  uint64_t v72;
  double v73;
  char v74;
  uint64_t v75;
  int v76;
  char v77;
  char *v78;
  char v79;
  char v80;
  unsigned int v81;
  double v82;
  double v83;
  int v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  const char *v89;
  size_t v90;
  char __dst[256];
  uint64_t v93;

  v7 = a2;
  v93 = *MEMORY[0x1E0C80C00];
  if (a3 >= 255)
    v8 = 255;
  else
    v8 = a3;
  memcpy(__dst, a2, v8);
  __dst[v8] = 0;
  *(_QWORD *)&a4->year = 0;
  a4->second = 0.0;
  if (a5)
    *a5 = 0;
  v9 = 0;
  v10 = MEMORY[0x1E0C80978];
  while (1)
  {
    v11 = __dst[v9];
    v12 = __dst[v9];
    if (v11 < 0)
      break;
    if ((*(_DWORD *)(v10 + 4 * v12 + 60) & 0x4000) == 0)
      goto LABEL_12;
LABEL_11:
    ++v9;
  }
  if (__maskrune(__dst[v9], 0x4000uLL))
    goto LABEL_11;
LABEL_12:
  if ((*(_DWORD *)(v10 + 4 * v12 + 60) & 0x400) != 0)
  {
    LOBYTE(v15) = v11;
    goto LABEL_38;
  }
  v13 = 0;
  while (1)
  {
    v14 = strlen(kDayStrs[v13]);
    if (!memcmp(kDayStrs[v13], &__dst[v9], v14))
      break;
    if (++v13 == 14)
      goto LABEL_142;
  }
  v16 = v14 + v9;
  do
  {
    v9 = v16;
    LODWORD(v15) = __dst[v16];
    v17 = __dst[v16];
    if ((v15 & 0x80000000) != 0)
      v18 = __maskrune(__dst[v16], 0x4000uLL);
    else
      v18 = *(_DWORD *)(v10 + 4 * v17 + 60) & 0x4000;
    v16 = v9 + 1;
  }
  while ((_DWORD)v15 == 44 || v18 != 0);
  if ((*(_DWORD *)(v10 + 4 * v17 + 60) & 0x400) != 0)
    goto LABEL_38;
  v20 = 0;
  while (1)
  {
    v21 = kMonthStrs[v20];
    v22 = strlen(v21);
    if (!memcmp(v21, &__dst[v9], v22))
      break;
    if (++v20 == 36)
      goto LABEL_142;
  }
  a4->month = v20 % 0xCu + 1;
  v23 = strlen(v21) + v9;
  do
  {
    v9 = v23;
    LODWORD(v15) = __dst[v23];
    v24 = __dst[v23];
    if ((v15 & 0x80000000) != 0)
      v25 = __maskrune(__dst[v23], 0x4000uLL);
    else
      v25 = *(_DWORD *)(v10 + 4 * v24 + 60) & 0x4000;
    v23 = v9 + 1;
  }
  while (v25);
  if ((*(_DWORD *)(v10 + 4 * v24 + 60) & 0x400) != 0)
  {
LABEL_38:
    day = a4->day;
    v27 = v9 + 1;
    v28 = 1;
    do
    {
      v29 = v28;
      v30 = v27;
      day = v15 + 10 * day - 48;
      v15 = __dst[v27++];
      if ((*(_DWORD *)(v10 + 4 * v15 + 60) & 0x400) == 0)
        break;
      v28 = 0;
    }
    while ((v29 & 1) != 0);
    a4->day = day;
    if ((v15 & 0x80) != 0)
      goto LABEL_43;
    while (1)
    {
      for (i = *(_DWORD *)(v10 + 4 * v15 + 60) & 0x4000;
            ;
            i = __maskrune(v15, 0x4000uLL))
      {
        if (v15 != 45 && !i)
        {
          if (!a4->month)
          {
            if ((*(_DWORD *)(v10 + 4 * v15 + 60) & 0x400) != 0)
            {
              v52 = 0;
              v53 = 1;
              v54 = __dst;
              LOBYTE(v55) = v15;
              do
              {
                v56 = v53;
                v52 = v55 + 10 * v52 - 48;
                ++v30;
                v55 = v54[v27];
                if ((*(_DWORD *)(v10 + 4 * v55 + 60) & 0x400) == 0)
                  break;
                v53 = 0;
                ++v54;
              }
              while ((v56 & 1) != 0);
              a4->month = v52;
            }
            else
            {
              v49 = 0;
              while (1)
              {
                v50 = kMonthStrs[v49];
                v51 = strlen(v50);
                if (!memcmp(v50, &__dst[v30], v51))
                  break;
                if (++v49 == 36)
                  goto LABEL_142;
              }
              a4->month = v49 % 0xCu + 1;
              v30 += strlen(v50);
              LOBYTE(v55) = __dst[v30];
            }
            v64 = v55;
            if ((v55 & 0x80) != 0)
              goto LABEL_104;
LABEL_103:
            for (j = *(_DWORD *)(v10 + 4 * v64 + 60) & 0x4000; v64 == 45 || j; j = __maskrune(v64, 0x4000uLL))
            {
              v64 = __dst[++v30];
              if ((v64 & 0x80) == 0)
                goto LABEL_103;
LABEL_104:
              ;
            }
            if ((*(_DWORD *)(v10 + 4 * v64 + 60) & 0x400) != 0)
            {
              v67 = 0;
              year = a4->year;
              LOBYTE(v66) = v64;
              do
              {
                year = 10 * year + v66 - 48;
                a4->year = year;
                v66 = __dst[v67 + 1 + v30];
                v69 = v67 + 1;
                if ((*(_DWORD *)(v10 + 4 * v66 + 60) & 0x400) == 0)
                  break;
                v70 = v67++ >= 3;
              }
              while (!v70);
              v30 += v69;
            }
            else
            {
              LOBYTE(v66) = v64;
            }
            LOBYTE(v15) = v66;
            if ((v66 & 0x80) != 0)
              goto LABEL_119;
            while ((*(_DWORD *)(v10 + 4 * v15 + 60) & 0x4000) != 0)
            {
              while (1)
              {
                LOBYTE(v15) = __dst[++v30];
                if ((v15 & 0x80) == 0)
                  break;
LABEL_119:
                if (!__maskrune(v15, 0x4000uLL))
                  goto LABEL_49;
              }
            }
          }
LABEL_49:
          if ((*(_DWORD *)(v10 + 4 * v15 + 60) & 0x400) != 0)
          {
            hour = a4->hour;
            v33 = 1;
            do
            {
              v34 = v33;
              hour = v15 + 10 * hour - 48;
              v15 = __dst[++v30];
              if ((*(_DWORD *)(v10 + 4 * v15 + 60) & 0x400) == 0)
                break;
              v33 = 0;
            }
            while ((v34 & 1) != 0);
            a4->hour = hour;
          }
          if (v15 != 58)
            goto LABEL_142;
          v35 = v30 + 1;
          v36 = __dst[v30 + 1];
          if ((*(_DWORD *)(v10 + 4 * v36 + 60) & 0x400) != 0)
          {
            minute = a4->minute;
            v38 = 1;
            do
            {
              v39 = v38;
              v40 = v30;
              minute = v36 + 10 * minute - 48;
              v36 = __dst[v30++ + 2];
              if ((*(_DWORD *)(v10 + 4 * v36 + 60) & 0x400) == 0)
                break;
              v38 = 0;
            }
            while ((v39 & 1) != 0);
            v35 = v40 + 2;
            a4->minute = minute;
          }
          v41 = v36;
          if ((_DWORD)v36 == 58)
          {
            v42 = v30 + 2;
            v43 = __dst[v30 + 2];
            if ((*(_DWORD *)(v10 + 4 * __dst[v30 + 2] + 60) & 0x400) != 0)
            {
              second = a4->second;
              v45 = 1;
              do
              {
                v46 = v45;
                v47 = v30;
                second = second * 10.0 + (double)(v43 - 48);
                v43 = __dst[v30 + 3];
                if ((*(_DWORD *)(v10 + 4 * __dst[v30 + 3] + 60) & 0x400) == 0)
                  break;
                v45 = 0;
                ++v30;
              }
              while ((v46 & 1) != 0);
              v42 = v47 + 3;
              a4->second = second;
            }
            v35 = v42 + 1;
            v41 = __dst[v42 + 1];
          }
          v48 = a4->year;
          if (a4->year)
            goto LABEL_84;
          if ((v41 & 0x80) != 0)
            goto LABEL_71;
          while ((*(_DWORD *)(v10 + 4 * v41 + 60) & 0x4000) != 0)
          {
            while (1)
            {
              v41 = __dst[++v35];
              if ((v41 & 0x80) == 0)
                break;
LABEL_71:
              if (!__maskrune(v41, 0x4000uLL))
                goto LABEL_83;
            }
          }
LABEL_83:
          v48 = a4->year;
          if ((*(_DWORD *)(v10 + 4 * v41 + 60) & 0x400) != 0)
          {
            v71 = 0;
            LOBYTE(v57) = v41;
            do
            {
              v48 = 10 * v48 + v57 - 48;
              a4->year = v48;
              v57 = __dst[v71 + 1 + v35];
              v72 = v71 + 1;
              if ((*(_DWORD *)(v10 + 4 * v57 + 60) & 0x400) == 0)
                break;
              v70 = v71++ >= 3;
            }
            while (!v70);
            v35 += v72;
            if (!v48)
              goto LABEL_90;
          }
          else
          {
LABEL_84:
            LOBYTE(v57) = v41;
            if (!v48)
              goto LABEL_90;
          }
          if (v48 <= 99)
          {
            if (v48 >= 70)
              v58 = 1900;
            else
              v58 = 2000;
            a4->year = v48 + v58;
          }
          while (1)
          {
LABEL_90:
            v59 = v57;
            if ((v57 & 0x80) != 0)
            {
              if (!__maskrune(v57, 0x4000uLL))
              {
LABEL_95:
                if (a5 && v59)
                {
                  if (v59 == 45 || v59 == 43)
                  {
                    v60 = v35 + 1;
                    v61 = __dst[v35 + 1];
                    if ((*(_DWORD *)(v10 + 4 * __dst[v35 + 1] + 60) & 0x400) != 0)
                    {
                      v73 = 0.0;
                      v74 = 1;
                      do
                      {
                        v75 = v35;
                        v73 = v73 * 10.0 + (double)(int)(v61 - 48);
                        v61 = __dst[v35 + 2];
                        v76 = *(_DWORD *)(v10 + 4 * __dst[v35++ + 2] + 60);
                        if ((v76 & 0x400) == 0)
                          break;
                        v77 = v74;
                        v74 = 0;
                      }
                      while ((v77 & 1) != 0);
                      v60 = v75 + 2;
                      v62 = v73 * 60.0;
                      v63 = 0.0;
                      if ((v76 & 0x400) != 0)
                      {
                        v78 = &__dst[v35 + 2];
                        v79 = 1;
                        do
                        {
                          v80 = v79;
                          v63 = v63 * 10.0 + (double)(int)(v61 - 48);
                          ++v60;
                          v81 = *v78++;
                          v61 = v81;
                          if ((*(_DWORD *)(v10 + 4 * v81 + 60) & 0x400) == 0)
                            break;
                          v79 = 0;
                        }
                        while ((v80 & 1) != 0);
                      }
                    }
                    else
                    {
                      v62 = 0.0;
                      v63 = 0.0;
                    }
                    v82 = v62 + v63;
                    v83 = 60.0;
                    if (v59 == 45)
                      v83 = -60.0;
                    *a5 = CFTimeZoneCreateWithTimeIntervalFromGMT(a1, v83 * v82);
                    v35 = v60;
                  }
                  else if (__dst[v35] == 85)
                  {
                    *a5 = CFTimeZoneCreateWithTimeIntervalFromGMT(a1, 0.0);
                    ++v35;
                  }
                  else if (!strncmp(&__dst[v35], "UT", 2uLL))
                  {
                    *a5 = CFTimeZoneCreateWithTimeIntervalFromGMT(a1, 0.0);
                    v35 += 2;
                  }
                  else if (!strncmp(&__dst[v35], "GMT", 3uLL))
                  {
                    *a5 = CFTimeZoneCreateWithTimeIntervalFromGMT(a1, 0.0);
                    v35 += 3;
                  }
                  else
                  {
                    if ((v59 & 0x80) != 0)
                      v85 = __maskrune(v59, 0x100uLL);
                    else
                      v85 = *(_DWORD *)(v10 + 4 * v59 + 60) & 0x100;
                    if (v85)
                    {
                      if (v59 != 74
                        && ((v86 = __dst[v35 + 1], !__dst[v35 + 1])
                         || ((v86 & 0x80) != 0
                           ? (v87 = __maskrune(__dst[v35 + 1], 0x4000uLL))
                           : (v87 = *(_DWORD *)(v10 + 4 * v86 + 60) & 0x4000),
                             v87 || (_DWORD)v86 == 42)))
                      {
                        *a5 = CFTimeZoneCreateWithTimeIntervalFromGMT(a1, 0.0);
                      }
                      else
                      {
                        v88 = 0;
                        while (1)
                        {
                          v89 = kUSTimeZones[v88];
                          v90 = strlen(v89);
                          if (!memcmp(v89, &__dst[v35], v90))
                            break;
                          if (++v88 == 8)
                            goto LABEL_140;
                        }
                        *a5 = CFTimeZoneCreateWithTimeIntervalFromGMT(a1, (double)(int)(3600 * ((v88 & 1) + (v88 >> 1)) - 28800));
                        v35 += strlen(v89);
                      }
                    }
                  }
                }
LABEL_140:
                if (CFGregorianDateIsValid(*a4, 0xFFFFFFuLL))
                {
                  v7 += v35;
                  return v7;
                }
                goto LABEL_142;
              }
            }
            else if ((*(_DWORD *)(v10 + 4 * v57 + 60) & 0x4000) == 0)
            {
              goto LABEL_95;
            }
            LOBYTE(v57) = __dst[++v35];
          }
        }
        LOBYTE(v15) = __dst[++v30];
        ++v27;
        if ((v15 & 0x80) == 0)
          break;
LABEL_43:
        ;
      }
    }
  }
LABEL_142:
  *(_QWORD *)&a4->year = 0;
  a4->second = 0.0;
  if (a5)
  {
    if (*a5)
      CFRelease(*a5);
    *a5 = 0;
  }
  return v7;
}

void ___ZN11HTTP3Framer11_readHeaderEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvN2H313FrameMetadataES2_b13CFStreamErrorE_block_invoke_2(uint64_t a1, void *a2, void *a3, int a4, uint64_t a5, uint64_t a6)
{
  id v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  dispatch_data_t concat;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  _QWORD v20[3];

  v11 = a2;
  v12 = a3;
  v13 = v12;
  v14 = *(_QWORD *)(a1 + 40);
  if ((_DWORD)a6)
  {
    *(_QWORD *)(v14 + 144) = a5;
    *(_QWORD *)(v14 + 152) = a6;
  }
  else if (a4)
  {
    *(_QWORD *)(v14 + 144) = 4;
    *(_DWORD *)(v14 + 152) = -2300;
  }
  if (v12)
  {
    v15 = *(NSObject **)(v14 + 136);
    if (v15)
      concat = dispatch_data_create_concat(v15, v13);
    else
      concat = v13;
    v18 = *(void **)(v14 + 136);
    *(_QWORD *)(v14 + 136) = concat;

    HTTP3Framer::_readHeader(v14, v13, *(_QWORD *)(a1 + 32));
  }
  else
  {
    if (*(_DWORD *)(v14 + 152))
    {
      v17 = *(_QWORD *)(v14 + 144);
    }
    else
    {
      v17 = 4;
      *(_QWORD *)(v14 + 144) = 4;
      *(_DWORD *)(v14 + 152) = -1;
    }
    v19 = *(_QWORD *)(a1 + 32);
    memset(v20, 0, sizeof(v20));
    (*(void (**)(uint64_t, _QWORD *, _QWORD, BOOL, uint64_t, _QWORD))(v19 + 16))(v19, v20, 0, *(_BYTE *)(v14 + 128) == 0, v17, *(_QWORD *)(v14 + 152));
  }

}

void sub_183F33DAC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t CFURLCacheSetSharedURLCache(const void *a1)
{
  pthread_mutex_lock(&gSharedInstanceLock);
  if ((const void *)gSharedInstance != a1)
  {
    if (gSharedInstance)
      CFRelease((CFTypeRef)gSharedInstance);
    if (a1)
      CFRetain(a1);
    gSharedInstance = (uint64_t)a1;
  }
  return pthread_mutex_unlock(&gSharedInstanceLock);
}

CFTypeRef ___ZN12HTTPProtocol30_createMutableCanonicalRequestEPK13__CFAllocatorPK13_CFURLRequestP16NSURLSessionTaskPKv_block_invoke_4()
{
  return CFRetain(CFSTR("application/x-www-form-urlencoded"));
}

const __CFString *_CFURLCacheFSGetItemSize(uint64_t a1)
{
  const __CFString *result;
  stat v2;
  char buffer[1024];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  result = *(const __CFString **)(a1 + 72);
  if (result)
  {
    if (CFStringGetFileSystemRepresentation(result, buffer, 1024))
    {
      if (lstat(buffer, &v2))
        return 0;
      else
        return (const __CFString *)v2.st_size;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void RequestBody::~RequestBody(RequestBody *this)
{
  const void *v2;
  uint64_t v3;
  NSObject *v4;
  std::__shared_weak_count *v5;

  *(_QWORD *)this = off_1E14E5300;
  *((_QWORD *)this + 3) = &unk_1E14E5370;
  v2 = (const void *)*((_QWORD *)this + 10);
  if (v2)
  {
    _Block_release(v2);
    *((_QWORD *)this + 10) = 0;
  }
  v3 = *((_QWORD *)this + 7);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
    *((_QWORD *)this + 7) = 0;
  }
  v4 = *((_QWORD *)this + 6);
  if (v4)
  {
    dispatch_release(v4);
    *((_QWORD *)this + 6) = 0;
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 64);
  *((_QWORD *)this + 3) = &off_1E14E5838;
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

void sub_183F33F34(_Unwind_Exception *a1)
{
  uint64_t v1;
  std::__shared_weak_count *v3;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 64);
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  _Unwind_Resume(a1);
}

void sub_183F3410C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183F341B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<__SecTrust *,Deleter_CFRelease,std::allocator<__SecTrust>>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 24);
  if (v1)
    CFRelease(v1);
}

uint64_t std::__shared_ptr_emplace<RequestBodyStream>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t std::__shared_ptr_emplace<HTTPConnection>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void RequestBodyStream::~RequestBodyStream(RequestBodyStream *this)
{
  *(_QWORD *)this = &off_1E14E90A8;
  *((_QWORD *)this + 3) = &unk_1E14E9118;
  RequestBodyStream::cleanup(this);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 136);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 120);
  RequestBody::~RequestBody((RequestBody *)this);
}

{
  RequestBodyStream::~RequestBodyStream(this);
  JUMPOUT(0x186DB748CLL);
}

void sub_183F342DC(_Unwind_Exception *a1)
{
  RequestBody *v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v1 + 136);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v1 + 120);
  RequestBody::~RequestBody(v1);
  _Unwind_Resume(a1);
}

void RequestBodyStream::cleanup(RequestBodyStream *this)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  char v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  NSObject *v11;
  const void *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  _QWORD v19[5];
  std::__shared_weak_count *v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  std::__shared_weak_count *v24;

  v2 = *((_QWORD *)this + 14);
  v3 = *((_QWORD *)this + 15);
  *((_QWORD *)this + 14) = 0;
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 16);
  v23 = v3;
  v24 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = *((_BYTE *)this + 192);
  *((_BYTE *)this + 192) = v7 | 1;
  v19[0] = MEMORY[0x1E0C809B0];
  v19[1] = 3321888768;
  v19[2] = ___ZN17RequestBodyStream7cleanupEv_block_invoke;
  v19[3] = &__block_descriptor_57_e8_32c42_ZTSNSt3__110shared_ptrI14__CFReadStreamEE_e5_v8__0l;
  v22 = (v7 & 2) != 0;
  v19[4] = v3;
  v20 = v4;
  if (v4)
  {
    v8 = (unint64_t *)&v4->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v21 = v2;
  v10 = *((_QWORD *)this + 17);
  if (v10)
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v10 + 96))(v10, v19);
  else
    ___ZN17RequestBodyStream7cleanupEv_block_invoke((uint64_t)v19);
  *((_BYTE *)this + 192) &= ~0x10u;
  v11 = *((_QWORD *)this + 20);
  if (v11)
  {
    dispatch_release(v11);
    *((_QWORD *)this + 20) = 0;
  }
  v12 = (const void *)*((_QWORD *)this + 19);
  if (v12)
  {
    _Block_release(v12);
    *((_QWORD *)this + 19) = 0;
  }
  v13 = v20;
  if (v20)
  {
    v14 = (unint64_t *)&v20->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = v24;
  if (v24)
  {
    v17 = (unint64_t *)&v24->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
}

void sub_183F34474(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32);
  _Unwind_Resume(a1);
}

void ___ZN17RequestBodyStream7cleanupEv_block_invoke(uint64_t a1)
{
  CFStreamStatus Status;
  uint64_t v4;
  std::__shared_weak_count *v5;

  if (*(_BYTE *)(a1 + 56))
    CFReadStreamSetClient(*(CFReadStreamRef *)(a1 + 32), 0, 0, 0);
  Status = CFReadStreamGetStatus(*(CFReadStreamRef *)(a1 + 32));
  if (Status >= kCFStreamStatusOpening && Status != kCFStreamStatusClosed)
    CFReadStreamClose(*(CFReadStreamRef *)(a1 + 32));
  v4 = *(_QWORD *)(a1 + 48);
  if (v4)
  {
    v5 = *(std::__shared_weak_count **)(v4 + 8);
    if (v5)
      std::__shared_weak_count::__release_weak(v5);
    JUMPOUT(0x186DB748CLL);
  }
}

void HTTPConnection::~HTTPConnection(HTTPConnection *this)
{
  HTTPEngine *v2;
  char *v3;
  int v4;
  int v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  NSObject *v9;
  const void *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  __int128 v15;

  *(_QWORD *)this = &off_1E14E6D20;
  *((_QWORD *)this + 3) = &unk_1E14E6D58;
  v3 = (char *)this + 64;
  v2 = (HTTPEngine *)*((_QWORD *)this + 8);
  if (v2)
  {
    v4 = *((unsigned __int16 *)this + 16);
    v5 = v4 | (*((unsigned __int8 *)this + 34) << 16);
    if ((v4 & 0x100) == 0)
    {
      *((_BYTE *)this + 34) = BYTE2(v5);
      *((_WORD *)this + 16) = v5 | 0x100;
      HTTPEngine::_cleanupConnection(v2, 0);
    }
  }
  v15 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v3, &v15);
  v6 = (std::__shared_weak_count *)*((_QWORD *)&v15 + 1);
  if (*((_QWORD *)&v15 + 1))
  {
    v7 = (unint64_t *)(*((_QWORD *)&v15 + 1) + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  v9 = *((_QWORD *)this + 7);
  if (v9)
  {
    dispatch_release(v9);
    *((_QWORD *)this + 7) = 0;
  }
  v10 = (const void *)*((_QWORD *)this + 31);
  *((_QWORD *)this + 31) = 0;
  if (v10)
    CFRelease(v10);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 192);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 176);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 160);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 144);
  *(_QWORD *)&v15 = (char *)this + 120;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v15);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 104);
  v11 = *((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = 0;
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 48))(v11);
  v12 = (std::__shared_weak_count *)*((_QWORD *)this + 11);
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v3);
  v13 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
  if (v13)
    std::__shared_weak_count::__release_weak(v13);
  *((_QWORD *)this + 3) = &off_1E14E5838;
  v14 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v14)
    std::__shared_weak_count::__release_weak(v14);
}

{
  HTTPConnection::~HTTPConnection(this);
  JUMPOUT(0x186DB748CLL);
}

void sub_183F34684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;
  const void *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;

  v12 = *(const void **)(v9 + 248);
  *(_QWORD *)(v9 + 248) = 0;
  if (v12)
    CFRelease(v12);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 + 192);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 + 176);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 + 160);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 + 144);
  a9 = (void **)(v9 + 120);
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 + 104);
  v13 = *(_QWORD *)(v9 + 96);
  *(_QWORD *)(v9 + 96) = 0;
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 48))(v13);
  v14 = *(std::__shared_weak_count **)(v9 + 88);
  if (v14)
    std::__shared_weak_count::__release_weak(v14);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v10);
  v15 = *(std::__shared_weak_count **)(v9 + 48);
  if (v15)
    std::__shared_weak_count::__release_weak(v15);
  *(_QWORD *)(v9 + 24) = &off_1E14E5838;
  v16 = *(std::__shared_weak_count **)(v9 + 16);
  if (v16)
    std::__shared_weak_count::__release_weak(v16);
  _Unwind_Resume(a1);
}

uint64_t NotificationStation::registerForPropertyUpdates(uint64_t a1, const __CFString *value, _QWORD *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t result;
  _QWORD *v10;
  uint64_t v11;
  uint64_t **v12;
  uint64_t v13;
  _OWORD *v14;
  uint64_t v15;
  uint64_t *v16;
  void **v17;
  char *v18;
  uint64_t v19;
  uint64_t *v20;
  char **v21;
  __int128 v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  __int128 v38;
  char *v39;
  std::__shared_weak_count *v40;
  const void *v41;
  __int128 v42;
  std::mutex *v43;
  void **v44;
  __int128 v45;
  void **v46;

  if (!*(_BYTE *)(a1 + 88))
  {
    result = *(_QWORD *)(a1 + 72);
    if (!result)
      return result;
    result = CFSetContainsValue((CFSetRef)result, value);
    if (!(_DWORD)result)
      return result;
  }
  v43 = (std::mutex *)(a1 + 8);
  std::mutex::lock((std::mutex *)(a1 + 8));
  v8 = *(_QWORD *)a1;
  if (!*(_QWORD *)a1)
  {
    v10 = (_QWORD *)operator new();
    v10[2] = 0;
    v10[1] = 0;
    *v10 = v10 + 1;
    *(_QWORD *)&v45 = 0;
    std::unique_ptr<std::map<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>,CFStringRefComp,std::allocator<std::pair<std::unique_ptr<__CFString const,void (*)(__CFString const*)> const,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>>::reset[abi:nn180100]((uint64_t *)a1, (uint64_t)v10);
    std::unique_ptr<std::map<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>,CFStringRefComp,std::allocator<std::pair<std::unique_ptr<__CFString const,void (*)(__CFString const*)> const,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>>::reset[abi:nn180100]((uint64_t *)&v45, 0);
    v8 = *(_QWORD *)a1;
    if (!value)
      goto LABEL_10;
    goto LABEL_9;
  }
  if (value)
LABEL_9:
    CFRetain(value);
LABEL_10:
  *(_QWORD *)&v45 = value;
  *((_QWORD *)&v45 + 1) = CFTypeRefRelease<__CFString const*>;
  v11 = std::__tree<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,std::__map_value_compare<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,CFStringRefComp,true>,std::allocator<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>::find<std::unique_ptr<__CFString const,void (*)(__CFString const*)>>(v8, (CFStringRef *)&v45);
  v12 = (uint64_t **)v11;
  if (value)
  {
    CFTypeRefRelease<__CFString const*>(value);
    v13 = *(_QWORD *)a1;
    v14 = v12;
    if ((uint64_t **)(*(_QWORD *)a1 + 8) == v12)
    {
      CFRetain(value);
      goto LABEL_14;
    }
  }
  else
  {
    v13 = *(_QWORD *)a1;
    v14 = (_OWORD *)v11;
    if (*(_QWORD *)a1 + 8 == v11)
    {
LABEL_14:
      v15 = operator new();
      *(_QWORD *)v15 = 0;
      *(_QWORD *)(v15 + 8) = 0;
      *(_QWORD *)(v15 + 16) = 0;
      *(_QWORD *)&v45 = value;
      *((_QWORD *)&v45 + 1) = CFTypeRefRelease<__CFString const*>;
      v44 = 0;
      v46 = (void **)v15;
      v16 = *v12;
      if (*v12)
      {
        v17 = (void **)v12;
        while (1)
        {
          while (1)
          {
            v18 = (char *)v16;
            if (CFStringCompare(value, (CFStringRef)v16[4], 0) != kCFCompareLessThan)
              break;
            v16 = *(uint64_t **)v18;
            v17 = (void **)v18;
            if (!*(_QWORD *)v18)
              goto LABEL_23;
          }
          if (CFStringCompare(*((CFStringRef *)v18 + 4), value, 0) != kCFCompareLessThan)
            break;
          v17 = (void **)(v18 + 8);
          v16 = (uint64_t *)*((_QWORD *)v18 + 1);
          if (!v16)
            goto LABEL_23;
        }
        v14 = *v17;
        if (*v17)
          goto LABEL_26;
      }
      else
      {
        v17 = (void **)v12;
        v18 = (char *)v12;
      }
LABEL_23:
      v14 = operator new(0x38uLL);
      v14[2] = v45;
      *(_QWORD *)&v45 = 0;
      v46 = 0;
      *((_QWORD *)v14 + 6) = v15;
      *(_QWORD *)v14 = 0;
      *((_QWORD *)v14 + 1) = 0;
      *((_QWORD *)v14 + 2) = v18;
      *v17 = v14;
      v19 = **(_QWORD **)v13;
      v20 = (uint64_t *)v14;
      if (v19)
      {
        *(_QWORD *)v13 = v19;
        v20 = (uint64_t *)*v17;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*v12, v20);
      ++*(_QWORD *)(v13 + 16);
LABEL_26:
      std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>::reset[abi:nn180100](&v46);
      if ((_QWORD)v45)
        (*((void (**)(void))&v45 + 1))();
      std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>::reset[abi:nn180100](&v44);
    }
  }
  v21 = (char **)*((_QWORD *)v14 + 6);
  v22 = *(_OWORD *)a3;
  v23 = a3[1];
  if (v23)
  {
    v24 = (unint64_t *)(v23 + 16);
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
  }
  v27 = v21[1];
  v26 = (unint64_t)v21[2];
  if ((unint64_t)v27 >= v26)
  {
    v29 = (v27 - *v21) >> 4;
    if ((unint64_t)(v29 + 1) >> 60)
      abort();
    v42 = v22;
    v30 = v26 - (_QWORD)*v21;
    v31 = v30 >> 3;
    if (v30 >> 3 <= (unint64_t)(v29 + 1))
      v31 = v29 + 1;
    if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF0)
      v32 = 0xFFFFFFFFFFFFFFFLL;
    else
      v32 = v31;
    if (v32 >> 60)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v33 = (char *)operator new(16 * v32);
    v34 = &v33[16 * v29];
    *(_OWORD *)v34 = v42;
    v35 = *v21;
    v36 = v21[1];
    if (v36 == *v21)
    {
      v28 = v34 + 16;
      *v21 = v34;
      v21[1] = v34 + 16;
      v21[2] = &v33[16 * v32];
    }
    else
    {
      v37 = &v33[16 * v29];
      do
      {
        v38 = *((_OWORD *)v36 - 1);
        v36 -= 16;
        *((_OWORD *)v37 - 1) = v38;
        v37 -= 16;
        *(_QWORD *)v36 = 0;
        *((_QWORD *)v36 + 1) = 0;
      }
      while (v36 != v35);
      v36 = *v21;
      v39 = v21[1];
      v28 = v34 + 16;
      *v21 = v37;
      v21[1] = v34 + 16;
      v21[2] = &v33[16 * v32];
      while (v39 != v36)
      {
        v40 = (std::__shared_weak_count *)*((_QWORD *)v39 - 1);
        if (v40)
          std::__shared_weak_count::__release_weak(v40);
        v39 -= 16;
      }
    }
    if (v36)
      operator delete(v36);
  }
  else
  {
    *(_OWORD *)v27 = v22;
    v28 = v27 + 16;
  }
  v21[1] = v28;
  if (a4)
  {
    v41 = (const void *)(*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
    (*(void (**)(_QWORD, const __CFString *, const void *))(*(_QWORD *)*a3 + 16))(*a3, value, v41);
    if (v41)
      CFRelease(v41);
  }
  std::mutex::unlock(v43);
  return 1;
}

void sub_183F34AE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, char a12, uint64_t a13, uint64_t a14)
{
  std::mutex::unlock(a11);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,std::__map_value_compare<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,CFStringRefComp,true>,std::allocator<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>::destroy(void ***a1)
{
  void **v2;

  if (a1)
  {
    std::__tree<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,std::__map_value_compare<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,CFStringRefComp,true>,std::allocator<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,std::__map_value_compare<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,CFStringRefComp,true>,std::allocator<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>::destroy(a1[1]);
    std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>::reset[abi:nn180100](a1 + 6);
    v2 = a1[4];
    a1[4] = 0;
    if (v2)
      ((void (*)(void))a1[5])();
    operator delete(a1);
  }
}

void CFTypeRefRelease<__CFString const*>(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t std::__tree<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,std::__map_value_compare<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,CFStringRefComp,true>,std::allocator<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>::find<std::unique_ptr<__CFString const,void (*)(__CFString const*)>>(uint64_t a1, CFStringRef *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  CFComparisonResult v6;
  uint64_t *v7;

  v2 = a1 + 8;
  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 8;
  do
  {
    v6 = CFStringCompare(*(CFStringRef *)(v3 + 32), *a2, 0);
    v7 = (uint64_t *)(v3 + 8);
    if (v6 != kCFCompareLessThan)
    {
      v7 = (uint64_t *)v3;
      v5 = v3;
    }
    v3 = *v7;
  }
  while (*v7);
  if (v5 == v2 || CFStringCompare(*a2, *(CFStringRef *)(v5 + 32), 0) == kCFCompareLessThan)
    return v2;
  return v5;
}

uint64_t PropertyObserver::propertyChanged(PropertyObserver *this, const __CFString *a2, const void *a3)
{
  uint64_t result;

  result = *((_QWORD *)this + 1);
  if (result)
    return (*(uint64_t (**)(uint64_t, const __CFString *, const void *))(result + 16))(result, a2, a3);
  return result;
}

uint64_t RequestBodyStream::RequestBodyStream(uint64_t a1, uint64_t *a2, dispatch_object_t object, uint64_t a4, uint64_t a5, int a6, const void *a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  char v23;
  void *v24;
  __int128 v26;

  v11 = RequestBody::RequestBody(a1, object, a4, a5);
  *(_QWORD *)v11 = &off_1E14E90A8;
  *(_QWORD *)(v11 + 24) = &unk_1E14E9118;
  v12 = v11 + 136;
  *(_OWORD *)(v11 + 112) = 0u;
  *(_OWORD *)(v11 + 128) = 0u;
  *(_QWORD *)(v11 + 144) = 0;
  v14 = *a2;
  v13 = a2[1];
  if (v13)
  {
    v15 = (unint64_t *)(v13 + 8);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
    v17 = *(std::__shared_weak_count **)(a1 + 128);
    *(_QWORD *)(a1 + 120) = v14;
    *(_QWORD *)(a1 + 128) = v13;
    if (v17)
    {
      p_shared_owners = (unint64_t *)&v17->__shared_owners_;
      do
        v19 = __ldaxr(p_shared_owners);
      while (__stlxr(v19 - 1, p_shared_owners));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
  }
  else
  {
    *(_QWORD *)(a1 + 120) = v14;
    *(_QWORD *)(a1 + 128) = 0;
  }
  v26 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v12, &v26);
  v20 = (std::__shared_weak_count *)*((_QWORD *)&v26 + 1);
  if (*((_QWORD *)&v26 + 1))
  {
    v21 = (unint64_t *)(*((_QWORD *)&v26 + 1) + 8);
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  if (a6)
    v23 = 32;
  else
    v23 = 0;
  *(_BYTE *)(a1 + 192) = v23;
  if (a7)
    v24 = _Block_copy(a7);
  else
    v24 = 0;
  *(_QWORD *)(a1 + 152) = v24;
  return a1;
}

void sub_183F34DC8(_Unwind_Exception *a1)
{
  RequestBody *v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  RequestBody::~RequestBody(v1);
  _Unwind_Resume(a1);
}

uint64_t RequestBody::RequestBody(uint64_t a1, dispatch_object_t object, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  __int128 v13;

  *(_QWORD *)a1 = off_1E14E5300;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = &unk_1E14E5370;
  *(_QWORD *)(a1 + 64) = 0;
  v7 = a1 + 64;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 48) = object;
  dispatch_retain(object);
  *(_QWORD *)(a1 + 56) = a3;
  if (a3)
    (*(void (**)(uint64_t))(*(_QWORD *)a3 + 16))(a3);
  v13 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v7, &v13);
  v8 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
  if (*((_QWORD *)&v13 + 1))
  {
    v9 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  *(_BYTE *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 40) = 0;
  v11 = (unint64_t)a4 >> 2;
  if (a4 <= 0)
    v11 = 0x20000;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = v11;
  *(_QWORD *)(a1 + 96) = 0;
  return a1;
}

void sub_183F34ED4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  std::__shared_weak_count *v4;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  _Unwind_Resume(a1);
}

__n128 HTTPConnectionCacheEntry::EnqueuedRequest::getRequestToEnqueue(__n128 *a1, _QWORD *a2, _QWORD *a3, __n128 *a4)
{
  unint64_t v6;
  __n128 result;

  *a2 = a1[1].n128_u64[1];
  *a3 = (*(uint64_t (**)(__n128 *))(a1->n128_u64[0] + 88))(a1);
  v6 = a1[4].n128_u64[0];
  result = a1[3];
  *a4 = result;
  a4[1].n128_u64[0] = v6;
  return result;
}

void NWIOConnection::sendEOF(NWIOConnection *this)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD completion[6];
  std::__shared_weak_count *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;

  if ((*((_WORD *)this + 124) & 1) != 0 || *((_DWORD *)this + 34) != 4)
    return;
  if (!*((_QWORD *)this + 34))
    __assert_rtn("sendEOF", "NWIOConnection.cpp", 427, "_connection");
  v17 = 0;
  v18 = 0;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 33);
  if (!v2)
  {
    v3 = 0;
    goto LABEL_8;
  }
  v3 = std::__shared_weak_count::lock(v2);
  v18 = v3;
  if (!v3)
  {
LABEL_8:
    v4 = 0;
    goto LABEL_9;
  }
  v4 = *((_QWORD *)this + 32);
  v17 = v4;
LABEL_9:
  v5 = *((_QWORD *)this + 34);
  v6 = *MEMORY[0x1E0CCECF8];
  completion[0] = MEMORY[0x1E0C809B0];
  completion[1] = 3321888768;
  completion[2] = ___ZN14NWIOConnection7sendEOFEv_block_invoke;
  completion[3] = &__block_descriptor_56_e8_40c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE_e31_v16__0__NSObject_OS_nw_error__8l;
  completion[4] = this;
  completion[5] = v4;
  v16 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  nw_connection_send(v5, 0, v6, 1, completion);
  *((_WORD *)this + 124) |= 1u;
  v9 = v16;
  if (v16)
  {
    v10 = (unint64_t *)&v16->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = v18;
  if (v18)
  {
    v13 = (unint64_t *)&v18->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

void sub_183F350DC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32);
  _Unwind_Resume(a1);
}

void __BuildPath(const char *a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  BOOL v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x1E0C80C00];
  mkpath_np(a1, 0x1FFu);
  if (a1)
  {
    v8 = *MEMORY[0x1E0CB2AD8];
    v9[0] = *MEMORY[0x1E0CB2AC0];
    v2 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v9, &v8, 1);
    v3 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithUTF8String:", a1);
    v4 = (void *)objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
    v7 = 0;
    if (objc_msgSend(v4, "fileExistsAtPath:isDirectory:", v3, &v7))
      v5 = v7 == 0;
    else
      v5 = 1;
    if (!v5)
    {
      v6 = 0;
      objc_msgSend(v4, "setAttributes:ofItemAtPath:error:", v2, v3, &v6);
    }

  }
}

_QWORD *HTTPConnectionCache::createEmptyCacheEntry(CFSetRef *this, const HTTPConnectionCacheKey *a2)
{
  int v4;
  _QWORD *v5;
  CFSetRef v6;
  std::__shared_weak_count_vtbl *v7;
  CFSetRef v8;
  _QWORD *v9;
  std::__shared_weak_count *v10;
  char *v11;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v13;
  CFMutableArrayRef Mutable;
  uint64_t *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t shared_owners;
  _QWORD *v19;
  uint64_t shared_weak_owners;
  __int128 v21;
  std::__shared_weak_count *v22;
  unint64_t v23;
  unint64_t *p_shared_weak_owners;
  unint64_t v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  uint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  _QWORD *v50;
  uint64_t v51;
  unint64_t *v52;
  unint64_t v53;
  _QWORD *result;
  const char *v55;
  int v56;
  __int128 v57;
  __int128 v58;

  v4 = CFSetContainsValue(this[6], a2);
  if (v4)
    CFSetRemoveValue(this[6], a2);
  v5 = CFAllocatorAllocate(this[1], 40, 0);
  v5[4] = 0;
  *(_OWORD *)v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  v6 = this[1];
  v8 = this[12];
  v7 = (std::__shared_weak_count_vtbl *)this[13];
  *v5 = off_1E14EF578;
  v5[1] = v6;
  *((_DWORD *)v5 + 4) = 1;
  if (((unint64_t)(v5 + 2) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  v9 = v5;
  *v5 = off_1E14EF280;
  v5[3] = 0;
  v5[4] = 0;
  v10 = (std::__shared_weak_count *)operator new(0x98uLL);
  v11 = (char *)(this + 7);
  *(_OWORD *)&v10->__shared_owners_ = 0u;
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  v10->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0DA8;
  v10[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14ECDE0;
  v13 = v10 + 1;
  *(_OWORD *)&v10[1].__shared_owners_ = 0u;
  v10[2].__vftable = (std::__shared_weak_count_vtbl *)&unk_1E14ECE28;
  *(_OWORD *)&v10[2].__shared_weak_owners_ = 0u;
  v10[3].__shared_owners_ = (uint64_t)v11;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
  v10[5].__vftable = 0;
  v15 = (uint64_t *)&v10[5];
  v10[4].__shared_owners_ = (uint64_t)Mutable;
  LOBYTE(v10[2].__shared_owners_) = 0;
  v10[5].__shared_owners_ = 0;
  v10[5].__shared_weak_owners_ = 0;
  v10[3].__shared_weak_owners_ = (uint64_t)v8;
  if (!v8)
  {
    v55 = "_schedulingSet";
    v56 = 57;
    goto LABEL_59;
  }
  (*(void (**)(CFSetRef))(*(_QWORD *)v8 + 40))(v8);
  v10[4].__vftable = v7;
  if (!v7)
  {
    v55 = "_tubeManager";
    v56 = 61;
LABEL_59:
    __assert_rtn("HTTPConnectionCacheEntry", "HTTPConnectionCacheEntry.cpp", v56, v55);
  }
  (*((void (**)(std::__shared_weak_count_vtbl *))v7->~__shared_weak_count + 5))(v7);
  v10[4].__shared_weak_owners_ = v4 == 0;
  v16 = (_QWORD *)operator new();
  *v16 = &off_1E14F0140;
  v16[1] = 0;
  v16[2] = 0;
  v16[3] = 0;
  v17 = *v15;
  *v15 = (uint64_t)v16;
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
  shared_owners = v10[5].__shared_owners_;
  v10[5].__shared_owners_ = 0;
  if (shared_owners)
    (*(void (**)(uint64_t))(*(_QWORD *)shared_owners + 8))(shared_owners);
  v19 = (_QWORD *)operator new();
  *v19 = &off_1E14E9AC8;
  v19[1] = v19 + 1;
  v19[2] = v19 + 1;
  v19[3] = 0;
  shared_weak_owners = v10[5].__shared_weak_owners_;
  v10[5].__shared_weak_owners_ = (uint64_t)v19;
  if (shared_weak_owners)
    (*(void (**)(uint64_t))(*(_QWORD *)shared_weak_owners + 8))(shared_weak_owners);
  LODWORD(v10[6].__vftable) = 0;
  *(_QWORD *)&v21 = v10 + 1;
  *((_QWORD *)&v21 + 1) = v10;
  v22 = (std::__shared_weak_count *)v10[1].__shared_weak_owners_;
  if (v22)
  {
    if (v22->__shared_owners_ != -1)
      goto LABEL_25;
    do
      v23 = __ldxr(p_shared_owners);
    while (__stxr(v23 + 1, p_shared_owners));
    v57 = v21;
    p_shared_weak_owners = (unint64_t *)&v10->__shared_weak_owners_;
    do
      v25 = __ldxr(p_shared_weak_owners);
    while (__stxr(v25 + 1, p_shared_weak_owners));
    v10[1].__shared_owners_ = (uint64_t)v13;
    v10[1].__shared_weak_owners_ = (uint64_t)v10;
    std::__shared_weak_count::__release_weak(v22);
    v21 = v57;
  }
  else
  {
    do
      v26 = __ldxr(p_shared_owners);
    while (__stxr(v26 + 1, p_shared_owners));
    v27 = (unint64_t *)&v10->__shared_weak_owners_;
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
    v10[1].__shared_owners_ = (uint64_t)v13;
    v10[1].__shared_weak_owners_ = (uint64_t)v10;
  }
  do
    v29 = __ldaxr(p_shared_owners);
  while (__stlxr(v29 - 1, p_shared_owners));
  if (!v29)
  {
    v58 = v21;
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    v21 = v58;
  }
LABEL_25:
  v30 = (std::__shared_weak_count *)v9[4];
  *(_OWORD *)(v9 + 3) = v21;
  if (v30)
  {
    v31 = (unint64_t *)&v30->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  v34 = v9[3];
  v33 = (std::__shared_weak_count *)v9[4];
  if (v33)
  {
    v35 = (unint64_t *)&v33->__shared_owners_;
    do
      v36 = __ldxr(v35);
    while (__stxr(v36 + 1, v35));
  }
  v37 = *(std::__shared_weak_count **)(v34 + 16);
  if (v37 && (v38 = *(_QWORD *)(v34 + 8), (v39 = std::__shared_weak_count::lock(v37)) != 0))
  {
    v40 = v39;
    v41 = (unint64_t *)&v39->__shared_weak_owners_;
    do
      v42 = __ldxr(v41);
    while (__stxr(v42 + 1, v41));
    v43 = *(std::__shared_weak_count **)(v34 + 48);
    *(_QWORD *)(v34 + 40) = v38;
    *(_QWORD *)(v34 + 48) = v40;
    if (v43)
      std::__shared_weak_count::__release_weak(v43);
    v44 = (unint64_t *)&v40->__shared_owners_;
    do
      v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
    *(_BYTE *)(v34 + 32) |= 0x10u;
    *(_DWORD *)(v34 + 120) = *(_DWORD *)(*(_QWORD *)(v34 + 56) + 12);
    v46 = (_QWORD *)operator new();
    v47 = *(int *)(v34 + 120);
    *v46 = &off_1E14F0120;
    v46[1] = 0;
    v46[2] = 0;
    v46[3] = 0;
    if ((_DWORD)v47)
    {
      if ((v47 & 0x80000000) != 0)
        abort();
      v48 = 16 * v47;
      v49 = operator new(16 * v47);
      v46[1] = v49;
      v46[2] = v49;
      v50 = &v49[2 * v47];
      v46[3] = v50;
      do
      {
        *v49 = 0;
        v49[1] = 0;
        v49 += 2;
        v48 -= 16;
      }
      while (v48);
      v46[2] = v50;
    }
    v51 = *(_QWORD *)(v34 + 104);
    *(_QWORD *)(v34 + 104) = v46;
    if (v51)
      (*(void (**)(uint64_t))(*(_QWORD *)v51 + 8))(v51);
    if (v33)
    {
      v52 = (unint64_t *)&v33->__shared_owners_;
      do
        v53 = __ldaxr(v52);
      while (__stlxr(v53 - 1, v52));
      if (!v53)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }
    return v9;
  }
  else
  {
    result = (_QWORD *)std::__throw_bad_weak_ptr[abi:nn180100]();
    __break(1u);
  }
  return result;
}

void sub_183F356CC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  void *v10;

  v5 = *(_QWORD *)(v1 + 136);
  *(_QWORD *)(v1 + 136) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = *(_QWORD *)(v1 + 128);
  *(_QWORD *)(v1 + 128) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  v7 = *v3;
  *v3 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  CFRelease(*(CFTypeRef *)(v1 + 104));
  v8 = *(std::__shared_weak_count **)(v1 + 72);
  if (v8)
    std::__shared_weak_count::__release_weak(v8);
  *(_QWORD *)(v1 + 48) = &off_1E14E5838;
  v9 = *(std::__shared_weak_count **)(v1 + 40);
  if (v9)
    std::__shared_weak_count::__release_weak(v9);
  std::__shared_weak_count::~__shared_weak_count((std::__shared_weak_count *)v1);
  operator delete(v10);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  _Unwind_Resume(a1);
}

BOOL CFURLProtectionSpaceIsProxy(uint64_t a1)
{
  uint64_t v2;

  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  return (*(_DWORD *)(v2 + 44) - 5) < 4;
}

uint64_t std::__shared_ptr_pointer<BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>> *,SmartBlockWithArgs<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::Deleter,std::allocator<BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void (*v3)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *);
  BOOL v4;
  int v5;
  uint64_t *v7;
  void (*v8)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *);
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v13;
  std::__shared_weak_count *v14;

  v1 = *(_QWORD *)(a1 + 24);
  v3 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(v1 + 8);
  v2 = *(_QWORD *)(v1 + 16);
  if (v2)
    v4 = (*(_QWORD *)(v1 + 16) & 1 | (unint64_t)v3) == 0;
  else
    v4 = 1;
  v5 = v4;
  if (v3 == BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::invoke_initial
    && v5 != 0)
  {
    v7 = (uint64_t *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0)
      v8 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(*v7
                                                                                           + BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::invoke_initial);
    else
      v8 = BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::invoke_initial;
    v13 = 0;
    v14 = 0;
    v8(v7, 0, 0, 0, 0, &v13);
    v9 = v14;
    if (v14)
    {
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
  _Block_release(*(const void **)v1);
  return MEMORY[0x186DB748C](v1, 0x80C40D6874129);
}

void sub_183F35904(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  unint64_t *p_shared_owners;
  unint64_t v12;

  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t CFHTTPCookieStorageGetCookieAcceptPolicy(char *a1)
{
  char *v3;
  PrivateHTTPCookieStorage *v4;

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
    return objc_msgSend(a1, "cookieAcceptPolicy");
  if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
    dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
  v3 = a1 + 16;
  if (!a1)
    v3 = 0;
  v4 = (PrivateHTTPCookieStorage *)*((_QWORD *)v3 + 2);
  if (v4)
    return PrivateHTTPCookieStorage::getCookieAcceptPolicy(v4);
  else
    return 2;
}

void std::__shared_ptr_emplace<HTTP3Framer>::__on_zero_shared(uint64_t a1)
{
  std::__shared_weak_count *v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
  v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

CFStringRef _cfnCreateRegistrableDomain(const __CFString *a1)
{
  CFStringRef IDNAEncodedDomain;
  size_t v2;
  uint64_t v3;
  char *TopLevelDomain;
  CFStringRef v5;
  char *v6;
  char *v7;
  char buffer[256];
  _BYTE v10[263];

  *(_QWORD *)&v10[255] = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  IDNAEncodedDomain = createIDNAEncodedDomain(a1);
  if (!CFStringGetCString(IDNAEncodedDomain, buffer, 256, 0x600u))
  {
    v5 = 0;
    if (!IDNAEncodedDomain)
      return v5;
LABEL_16:
    CFRelease(IDNAEncodedDomain);
    return v5;
  }
  v2 = strlen(buffer);
  v3 = v2;
  if (v2 && buffer[v2 - 1] == 46)
  {
    buffer[v2 - 1] = 0;
    v3 = v2 - 1;
  }
  TopLevelDomain = _CFHostGetTopLevelDomain((unint64_t)buffer, v3, 1);
  v5 = 0;
  if (TopLevelDomain && TopLevelDomain > v10)
  {
    v6 = TopLevelDomain - 2;
    do
    {
      v7 = v6;
      if (v6 < buffer)
        break;
      --v6;
    }
    while (*v7 != 46);
    v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v7 + 1, 0x600u);
  }
  if (IDNAEncodedDomain)
    goto LABEL_16;
  return v5;
}

void sub_183F35BDC(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t CFURLCredentialCreateWithTrust(uint64_t a1, const void *a2)
{
  uint64_t Instance;
  CFTypeRef v4;

  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_QWORD *)(Instance + 16) = &off_1E14ED238;
  *(_QWORD *)(Instance + 24) = &unk_1E14ED2B8;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_BYTE *)(Instance + 64) = 0;
  *(_QWORD *)(Instance + 72) = 0;
  *(_QWORD *)(Instance + 80) = 0;
  *(_QWORD *)(Instance + 56) = 0;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3752];
  *(_QWORD *)(Instance + 40) = &unk_1E14ED2E8;
  *(_QWORD *)(Instance + 48) = 0x200000001;
  if (a2)
    v4 = CFRetain(a2);
  else
    v4 = 0;
  *(_QWORD *)(Instance + 80) = v4;
  return Instance;
}

void RequestBodyStream::_onqueue_setupStream(RequestBodyStream *this)
{
  CFIndex v2;
  _QWORD *v3;
  std::__shared_weak_count *info;
  unint64_t *v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  _QWORD *v12;
  std::__shared_weak_count *v13;
  CFIndex v14;
  unint64_t *p_shared_weak_owners;
  unint64_t v16;
  int v17;
  char v18;
  char v19;
  uint64_t v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  _QWORD v29[6];
  std::__shared_weak_count *v30;
  CFStreamClientContext clientContext;
  CFIndex version;
  std::__shared_weak_count *v33;

  *((_BYTE *)this + 192) |= 1u;
  v2 = CoreSchedulingSet::copyRunloopEmulationSet((CoreSchedulingSet *)this);
  clientContext.version = v2;
  v3 = (_QWORD *)operator new();
  *v3 = &off_1E14F1668;
  v3[1] = 0;
  v3[2] = 0;
  v3[3] = v2;
  clientContext.info = v3;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 136, (__int128 *)&clientContext.version);
  info = (std::__shared_weak_count *)clientContext.info;
  if (clientContext.info)
  {
    v5 = (unint64_t *)((char *)clientContext.info + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))info->__on_zero_shared)(info);
      std::__shared_weak_count::__release_weak(info);
    }
  }
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&clientContext, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
  version = clientContext.version;
  v33 = (std::__shared_weak_count *)clientContext.info;
  if (clientContext.info)
  {
    v7 = (unint64_t *)((char *)clientContext.info + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
    v9 = (std::__shared_weak_count *)clientContext.info;
    if (clientContext.info)
    {
      v10 = (unint64_t *)((char *)clientContext.info + 8);
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
  v12 = (_QWORD *)operator new();
  v14 = version;
  v13 = v33;
  *v12 = version;
  v12[1] = v13;
  if (v13)
  {
    p_shared_weak_owners = (unint64_t *)&v13->__shared_weak_owners_;
    do
      v16 = __ldxr(p_shared_weak_owners);
    while (__stxr(v16 + 1, p_shared_weak_owners));
  }
  *((_QWORD *)this + 14) = v12;
  clientContext.version = 0;
  clientContext.info = v12;
  memset(&clientContext.retain, 0, 24);
  v17 = CFReadStreamSetClient(*((CFReadStreamRef *)this + 15), 0x1AuLL, (CFReadStreamClientCallBack)RequestBodyStream::_bodyStreamCallback_offqueue, &clientContext);
  v18 = *((_BYTE *)this + 192);
  if (v17)
  {
    *((_BYTE *)this + 192) = v18 | 2;
    CoreSchedulingSet::scheduleStream(*((CoreSchedulingSet **)this + 17), *((__CFReadStream **)this + 15));
    v19 = *((_BYTE *)this + 192) | 4;
  }
  else
  {
    v19 = v18 & 0xF9 | 4;
    *((_BYTE *)this + 192) = v19;
  }
  *((_BYTE *)this + 192) = v19;
  v20 = *((_QWORD *)this + 17);
  v29[0] = MEMORY[0x1E0C809B0];
  v29[1] = 3321888768;
  v29[2] = ___ZN17RequestBodyStream20_onqueue_setupStreamEv_block_invoke;
  v29[3] = &__block_descriptor_56_e8_40c45_ZTSNSt3__110shared_ptrI17RequestBodyStreamEE_e5_v8__0l;
  v29[4] = this;
  v29[5] = v14;
  v30 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v22 = __ldxr(p_shared_owners);
    while (__stxr(v22 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v20 + 96))(v20, v29);
  v23 = v30;
  if (v30)
  {
    v24 = (unint64_t *)&v30->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  v26 = v33;
  if (v33)
  {
    v27 = (unint64_t *)&v33->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
}

void sub_183F35F54(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 48);
  _Unwind_Resume(a1);
}

void RequestBodyStream::_bodyStreamCallback_offqueue(RequestBodyStream *this, __CFReadStream *a2, uint64_t a3, void *a4)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  if (a3)
  {
    v5 = *(std::__shared_weak_count **)(a3 + 8);
    if (v5)
    {
      v6 = std::__shared_weak_count::lock(v5);
      if (v6)
      {
        v7 = v6;
        if (*(_QWORD *)a3)
          RequestBodyStream::_bodyStreamEventOccurred_offqueue(*(RequestBodyStream **)a3);
        p_shared_owners = (unint64_t *)&v7->__shared_owners_;
        do
          v9 = __ldaxr(p_shared_owners);
        while (__stlxr(v9 - 1, p_shared_owners));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
    }
  }
}

void sub_183F36008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void RequestBodyStream::_onqueue_provideRequestBodyFromBuffer(RequestBodyStream *this)
{
  uint64_t v2;
  NSObject *v3;
  size_t size;
  uint64_t v5;
  _BOOL4 v6;

  if ((*(unsigned int (**)(RequestBodyStream *))(*(_QWORD *)this + 48))(this))
  {
    v2 = *((_QWORD *)this + 10);
    if (v2)
    {
      if (*((_BYTE *)this + 104))
        return;
      v3 = *((_QWORD *)this + 20);
      *((_QWORD *)this + 20) = 0;
      if (v3)
        size = dispatch_data_get_size(v3);
      else
        size = 0;
      (*(void (**)(uint64_t, NSObject *, _QWORD, _QWORD, _QWORD))(v2 + 16))(v2, v3, *((_QWORD *)this + 21), *((_QWORD *)this + 22), *((unsigned __int8 *)this + 184));
      if (*((_DWORD *)this + 44) || *((_BYTE *)this + 184))
      {
        v6 = 1;
        *((_BYTE *)this + 104) = 1;
      }
      else
      {
        v6 = *((_BYTE *)this + 104) != 0;
      }
      RequestBody::_onqueue_updateUploadStatus((RequestBody *)this, size, v6);
      if (v3)
        dispatch_release(v3);
    }
    else
    {
      v5 = *((_QWORD *)this + 19);
      if (v5)
        (*(void (**)(void))(v5 + 16))();
    }
    if ((*((_BYTE *)this + 192) & 4) != 0
      && !*((_QWORD *)this + 20)
      && !*((_DWORD *)this + 44)
      && !*((_BYTE *)this + 184))
    {
      RequestBodyStream::_onqueue_pollStream(this);
    }
  }
}

void RequestBodyStream::_onqueue_resume(RequestBodyStream *this)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD v10[4];
  _QWORD v11[2];
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[2];

  if (!(*(unsigned int (**)(RequestBodyStream *))(*(_QWORD *)this + 48))(this))
    return;
  if (!*((_QWORD *)this + 10))
  {
    if ((*((_BYTE *)this + 192) & 0x20) == 0)
      return;
    v2 = *((_QWORD *)this + 20);
    if (!v2)
      goto LABEL_9;
    if (dispatch_data_get_size(v2) >= 4 * *((_QWORD *)this + 11))
      return;
LABEL_11:
    RequestBodyStream::_onqueue_provideRequestBodyFromBuffer(this);
    return;
  }
  if (*((_QWORD *)this + 20))
    goto LABEL_11;
LABEL_9:
  if (*((_DWORD *)this + 44) || *((_BYTE *)this + 184))
    goto LABEL_11;
  if ((*((_BYTE *)this + 192) & 0x10) != 0)
  {
    *((_BYTE *)this + 192) &= ~0x10u;
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v12, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
    v4 = v12;
    v3 = v13;
    v14[0] = v12;
    v14[1] = v13;
    if (v13)
    {
      v5 = (unint64_t *)(v13 + 8);
      do
        v6 = __ldxr(v5);
      while (__stxr(v6 + 1, v5));
    }
    std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&v12);
    v7 = *((_QWORD *)this + 17);
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 3321888768;
    v10[2] = ___ZN17RequestBodyStream15_onqueue_resumeEv_block_invoke;
    v10[3] = &__block_descriptor_48_e8_32c45_ZTSNSt3__110shared_ptrI17RequestBodyStreamEE_e5_v8__0l;
    v11[0] = v4;
    v11[1] = v3;
    if (v3)
    {
      v8 = (unint64_t *)(v3 + 8);
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v7 + 96))(v7, v10);
    std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v11);
    std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v14);
  }
  else if ((*((_BYTE *)this + 192) & 4) != 0)
  {
    RequestBodyStream::_onqueue_pollStream(this);
  }
}

void sub_183F36290(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 48);
  _Unwind_Resume(a1);
}

BOOL RequestBody::isScheduled(RequestBody *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 8);
  return v1 && *(_DWORD *)(v1 + 40) != 0;
}

void RunLoopSchedulingSet::performAsync(uint64_t a1, void *a2)
{
  uint64_t v3;
  os_unfair_lock_s *v5;
  const __CFAllocator *v6;
  _OWORD *v7;
  _QWORD *v8;
  const void *v9;
  const __CFAllocator *v10;
  dispatch_block_t v11;
  CFArrayCallBacks v12;

  v3 = *(_QWORD *)(a1 + 104);
  if (!v3)
  {
    v5 = (os_unfair_lock_s *)(a1 + 112);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
    if (!*(_QWORD *)(a1 + 104))
    {
      v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v7 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 72, 0);
      *v7 = 0u;
      v7[1] = 0u;
      v7[3] = 0u;
      *((_QWORD *)v7 + 8) = 0;
      v7[2] = 0u;
      CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject((CFAllocatedReferenceCountedObject *)v7, v6);
      *v8 = off_1E14EA5A8;
      v8[3] = &unk_1E14EA608;
      *((_QWORD *)v7 + 4) = &unk_1E14EA628;
      if (RunloopBlockContext::RunloopBlockContext(CoreSchedulingSet const*)::sOnce != -1)
        dispatch_once(&RunloopBlockContext::RunloopBlockContext(CoreSchedulingSet const*)::sOnce, &__block_literal_global_68);
      v9 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1);
      *((_QWORD *)v7 + 6) = v9;
      *((_QWORD *)v7 + 7) = 0;
      *((_BYTE *)v7 + 64) = 0;
      RunLoopMultiplexer::schedule(gMuxer, v9, v7 + 2);
      *(_QWORD *)(a1 + 104) = v7;
      if (*(_BYTE *)(a1 + 116))
        *((_BYTE *)v7 + 64) = 1;
    }
    os_unfair_lock_unlock(v5);
    v3 = *(_QWORD *)(a1 + 104);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(v3 + 40));
  if (!*(_QWORD *)(v3 + 56))
  {
    v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    *(_OWORD *)&v12.version = xmmword_1E14FD5B0;
    *(_OWORD *)&v12.release = *(_OWORD *)&off_1E14FD5C0;
    v12.equal = 0;
    *(_QWORD *)(v3 + 56) = CFArrayCreateMutable(v10, 0, &v12);
  }
  v11 = dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, a2);
  CFArrayAppendValue(*(CFMutableArrayRef *)(v3 + 56), v11);
  _Block_release(v11);
  if (!*(_BYTE *)(v3 + 45))
  {
    *(_BYTE *)(v3 + 45) = 1;
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    RunLoopMultiplexer::signal(gMuxer, *(const void **)(v3 + 48), (const void *)(v3 + 32));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 40));
}

void sub_183F36494(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void RunLoopMultiplexer::signal(uint64_t a1, const void *a2, const void *a3)
{
  os_unfair_lock_s *v6;
  os_unfair_lock_s *Value;
  os_unfair_lock_s *v8;
  os_unfair_lock_s *v9;
  __CFRunLoopSource *v10;
  void (*v11)(_QWORD, _QWORD, _QWORD);
  void (*v12[5])(_QWORD, _QWORD, _QWORD);
  void (*v13[5])(_QWORD, _QWORD, _QWORD);
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  __n128 (*v17)(__n128 *, __n128 *);
  uint64_t (*v18)();
  void *v19;
  char v20;
  uint64_t v21;

  v6 = (os_unfair_lock_s *)(a1 + 8);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 8));
  Value = (os_unfair_lock_s *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (Value)
  {
    v8 = Value;
    v9 = Value + 2;
    os_unfair_lock_lock(Value + 2);
    if (!CFSetContainsValue(*(CFSetRef *)&v8[16]._os_unfair_lock_opaque, a3))
    {
      CFSetAddValue(*(CFMutableSetRef *)&v8[16]._os_unfair_lock_opaque, a3);
      CFArrayAppendValue(*(CFMutableArrayRef *)&v8[18]._os_unfair_lock_opaque, a3);
    }
    v10 = *(__CFRunLoopSource **)&v8[14]._os_unfair_lock_opaque;
    if (v10)
      CFRunLoopSourceSignal(v10);
    ++*(_QWORD *)&v8[10]._os_unfair_lock_opaque;
    if (a2)
    {
      v14 = 0;
      v15 = &v14;
      v16 = 0x4812000000;
      v17 = __Block_byref_object_copy__17001;
      v18 = __Block_byref_object_dispose__17002;
      v19 = &unk_18422E08D;
      v20 = 0;
      v11 = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
      v21 = 0;
      v13[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
      v13[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
      v13[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN17MultiplexerSource6signalEPK17CoreSchedulingSetP17MultiplexerClient_block_invoke;
      v13[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E14FD900;
      v13[4] = (void (*)(_QWORD, _QWORD, _QWORD))&v14;
      CoreSchedulingSet::applyBlock((uint64_t)a2, v13);
      v15[8] = 1;
      v12[0] = v11;
      v12[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
      v12[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN17MultiplexerSource6signalEPK17CoreSchedulingSetP17MultiplexerClient_block_invoke_2;
      v12[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E14FD900;
      v12[4] = (void (*)(_QWORD, _QWORD, _QWORD))&v14;
      CoreSchedulingSet::applyBlock((uint64_t)a2, v12);
      _Block_object_dispose(&v14, 8);
    }
    os_unfair_lock_unlock(v9);
  }
  os_unfair_lock_unlock(v6);
}

void sub_183F36618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void CoreSchedulingSet::applyBlock(uint64_t a1, void (**a2)(_QWORD, _QWORD, _QWORD))
{
  int v3;
  CFTypeID TypeID;
  int v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v3 = *(_DWORD *)(a1 + 40);
  switch(v3)
  {
    case 3:
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        v6 = 134217984;
        v7 = a1;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "%p: can't do this with a dispatch based scheduling set", (uint8_t *)&v6, 0xCu);
      }
      break;
    case 2:
      if (!*(_QWORD *)(a1 + 48) || (TypeID = CFSetGetTypeID(), TypeID != CFGetTypeID(*(CFTypeRef *)(a1 + 48))))
        __assert_rtn("applyBlock", "CoreSchedulingSet.mm", 975, "fSet && CFSetGetTypeID() == CFGetTypeID(fSet)");
      CFSetApplyFunction(*(CFSetRef *)(a1 + 48), (CFSetApplierFunction)_applyRunloopBlock, a2);
      break;
    case 1:
      a2[2](a2, *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80));
      break;
  }
}

void ___ZN17MultiplexerSource6signalEPK17CoreSchedulingSetP17MultiplexerClient_block_invoke_2(uint64_t a1, CFRunLoopRef rl, const void *a3)
{
  uint64_t v3;
  CFRunLoopMode v6;
  CFRunLoopMode v7;

  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (!*(_BYTE *)(v3 + 48))
  {
    if (*(_QWORD *)(v3 + 64) == *(_QWORD *)(v3 + 56))
    {
      CFRunLoopWakeUp(rl);
    }
    else if (CFRunLoopIsWaiting(rl))
    {
      v6 = CFRunLoopCopyCurrentMode(rl);
      if (v6)
      {
        v7 = v6;
        if (CFEqual(a3, v6))
        {
          CFRunLoopWakeUp(rl);
          *(_BYTE *)(v3 + 48) = 1;
        }
        CFRelease(v7);
      }
    }
    ++*(_QWORD *)(v3 + 64);
  }
}

uint64_t ___ZN17MultiplexerSource6signalEPK17CoreSchedulingSetP17MultiplexerClient_block_invoke(uint64_t result)
{
  ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 56);
  return result;
}

void RequestBodyStream::_bodyStreamEventOccurred_offqueue(RequestBodyStream *this)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  NSObject *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD block[6];
  std::__shared_weak_count *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;

  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v19, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
  v3 = v19;
  v2 = v20;
  if (v20)
  {
    p_shared_owners = (unint64_t *)&v20->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
    v6 = v20;
    if (v20)
    {
      v7 = (unint64_t *)&v20->__shared_owners_;
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  v9 = *((_QWORD *)this + 6);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN17RequestBodyStream33_bodyStreamEventOccurred_offqueueEv_block_invoke;
  block[3] = &__block_descriptor_56_e8_40c45_ZTSNSt3__110shared_ptrI17RequestBodyStreamEE_e5_v8__0l;
  block[4] = this;
  block[5] = v3;
  v18 = v2;
  if (v2)
  {
    v10 = (unint64_t *)&v2->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  dispatch_async(v9, block);
  v12 = v18;
  if (!v18)
    goto LABEL_16;
  v13 = (unint64_t *)&v18->__shared_owners_;
  do
    v14 = __ldaxr(v13);
  while (__stlxr(v14 - 1, v13));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
    if (!v2)
      return;
  }
  else
  {
LABEL_16:
    if (!v2)
      return;
  }
  v15 = (unint64_t *)&v2->__shared_owners_;
  do
    v16 = __ldaxr(v15);
  while (__stlxr(v16 - 1, v15));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
}

void ___ZN17RequestBodyStream15_onqueue_resumeEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  int HasBytesAvailable;
  UInt8 *v3;
  CFIndex v4;
  NSObject *alloc;
  size_t v6;
  size_t v7;
  CFStreamError Error;
  CFIndex domain;
  BOOL v10;
  dispatch_data_t subrange;
  CFStreamStatus Status;
  CFStreamError v13;
  std::__shared_weak_count *v14;
  UInt8 *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  NSObject *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  UInt8 *buffer;
  uint64_t v30;
  void (*v31)(uint64_t);
  void *v32;
  dispatch_data_t v33;
  UInt8 *v34;
  std::__shared_weak_count *v35;
  CFIndex v36;
  size_t v37;
  BOOL v38;
  _QWORD v39[2];
  void (*v40)(uint64_t);
  void *v41;
  NSObject *v42;

  v1 = *(_QWORD *)(a1 + 32);
  HasBytesAvailable = CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)(v1 + 120));
  v3 = (UInt8 *)MEMORY[0x1E0C809B0];
  if (HasBytesAvailable)
  {
    v4 = *(_QWORD *)(v1 + 88);
    buffer = 0;
    alloc = dispatch_data_create_alloc();
    v39[0] = v3;
    v39[1] = 3221225472;
    v40 = ___ZN17RequestBodyStream37_bufferRequestBodyFromStream_offqueueEv_block_invoke;
    v41 = &unk_1E14FE118;
    v42 = alloc;
    v6 = CFReadStreamRead(*(CFReadStreamRef *)(v1 + 120), 0, v4);
    v7 = v6;
    if (v6)
    {
      if (v6 == -1)
      {
        Error = CFReadStreamGetError((CFReadStreamRef)*(_QWORD *)(v1 + 120));
        domain = Error.domain;
        v7 = *(_QWORD *)&Error.error;
        v10 = 0;
        subrange = 0;
      }
      else
      {
        subrange = dispatch_data_create_subrange(alloc, 0, v6);
        v7 = 0;
        domain = 0;
        v10 = CFReadStreamGetStatus(*(CFReadStreamRef *)(v1 + 120)) == kCFStreamStatusAtEnd;
      }
    }
    else
    {
      subrange = 0;
      v10 = 1;
      domain = 0;
    }
    v40((uint64_t)v39);
  }
  else
  {
    Status = CFReadStreamGetStatus(*(CFReadStreamRef *)(v1 + 120));
    if (Status == kCFStreamStatusAtEnd)
    {
      v7 = 0;
      domain = 0;
      subrange = 0;
      v10 = 1;
    }
    else
    {
      if (Status == kCFStreamStatusError)
      {
        v13 = CFReadStreamGetError((CFReadStreamRef)*(_QWORD *)(v1 + 120));
        domain = v13.domain;
        v7 = *(_QWORD *)&v13.error;
        v10 = 0;
      }
      else
      {
        v10 = 0;
        v7 = 0;
        domain = 0;
      }
      subrange = 0;
    }
  }
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&buffer, *(_QWORD *)(v1 + 8), *(std::__shared_weak_count **)(v1 + 16));
  v15 = buffer;
  v14 = (std::__shared_weak_count *)v30;
  if (v30)
  {
    v16 = (unint64_t *)(v30 + 8);
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
    v18 = (std::__shared_weak_count *)v30;
    if (v30)
    {
      v19 = (unint64_t *)(v30 + 8);
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
  }
  v21 = *(NSObject **)(v1 + 48);
  buffer = v3;
  v30 = 3321888768;
  v31 = ___ZN17RequestBodyStream37_bufferRequestBodyFromStream_offqueueEv_block_invoke_2;
  v32 = &unk_1E14F44E0;
  v34 = v15;
  v35 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v23 = __ldxr(p_shared_owners);
    while (__stxr(v23 + 1, p_shared_owners));
  }
  v33 = subrange;
  v36 = domain;
  v37 = v7;
  v38 = v10;
  dispatch_async(v21, &buffer);
  v24 = v35;
  if (v35)
  {
    v25 = (unint64_t *)&v35->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  if (v14)
  {
    v27 = (unint64_t *)&v14->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

void sub_183F36C54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,void (*a22)(char *))
{
  a22(&a20);
  _Unwind_Resume(a1);
}

uint64_t ___ZNK17CoreSchedulingSet15_scheduleStreamEPvPFvS0_PU28objcproto17OS_dispatch_queue8NSObjectEPFvS0_P11__CFRunLoopPK10__CFStringE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40));
}

void ___ZN11HTTP2Stream26setBodyStreamBeforeOpeningEP14__CFReadStreamx_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  HTTP2Stream *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(HTTP2Stream **)(a1 + 32);
      if (v5)
        HTTP2Stream::resumeData(v5);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_183F36D00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void HTTP2Stream::resumeData(HTTP2Stream *this)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  NSObject *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  _QWORD block[6];
  std::__shared_weak_count *v16;

  v2 = *((_QWORD *)this + 8);
  v14 = 0;
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 36);
  if (v3)
  {
    v4 = std::__shared_weak_count::lock(v3);
    v14 = v4;
    if (v4)
    {
      v5 = *((_QWORD *)this + 35);
      goto LABEL_6;
    }
  }
  else
  {
    v4 = 0;
  }
  v5 = 0;
LABEL_6:
  CFRetain((CFTypeRef)(v2 - 16));
  v6 = *(NSObject **)(v2 + 168);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN15HTTP2Connection19resumeDataForStreamENSt3__110shared_ptrI11HTTP2StreamEE_block_invoke;
  block[3] = &__block_descriptor_56_e8_40c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE_e5_v8__0l;
  block[4] = v2;
  block[5] = v5;
  v16 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  dispatch_async(v6, block);
  v9 = v16;
  if (v16)
  {
    v10 = (unint64_t *)&v16->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  if (v14)
  {
    v12 = (unint64_t *)&v14->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

void sub_183F36E44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN17RequestBodyStream37_bufferRequestBodyFromStream_offqueueEv_block_invoke(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

uint64_t formSchedule(__CFReadStream *a1, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode, _QWORD *a4)
{
  __CFReadStream *v7;
  uint64_t result;

  v7 = (__CFReadStream *)a4[2];
  if (v7)
    CFReadStreamScheduleWithRunLoop(v7, runLoop, runLoopMode);
  result = (*(uint64_t (**)(_QWORD, CFRunLoopRef, CFRunLoopMode))(*(_QWORD *)*a4 + 56))(*a4, runLoop, runLoopMode);
  *a4 = result;
  return result;
}

uint64_t CoreSchedulingSet::copyRunloopEmulationSet(CoreSchedulingSet *this)
{
  if (CoreSchedulingSet::copyRunloopEmulationSet(void)::sOnce != -1)
    dispatch_once(&CoreSchedulingSet::copyRunloopEmulationSet(void)::sOnce, &__block_literal_global_12_16876);
  (*(void (**)(uint64_t))(*(_QWORD *)CoreSchedulingSet::copyRunloopEmulationSet(void)::sEmulationSet + 40))(CoreSchedulingSet::copyRunloopEmulationSet(void)::sEmulationSet);
  return CoreSchedulingSet::copyRunloopEmulationSet(void)::sEmulationSet;
}

_OWORD *EmptyCoreSchedulingSet::copyWithAdditionReleaseSelf(EmptyCoreSchedulingSet *this, CoreSchedulingSet *a2, const __CFString *cf1)
{
  return CoreSchedulingSet::create(a2, cf1, cf1);
}

_OWORD *CoreSchedulingSet::create(CoreSchedulingSet *this, const __CFString *cf1, const __CFString *a3)
{
  const void *v5;
  int v6;
  const void *v7;
  const void *v8;
  const void *v9;
  CoreSchedulingSet *v10;
  _OWORD *Value;
  _OWORD *v13;

  v5 = (const void *)*MEMORY[0x1E0C9B280];
  if (cf1)
  {
    v6 = CFEqual(cf1, (CFTypeRef)*MEMORY[0x1E0C9B280]);
    if (this)
    {
      if (v6)
      {
        v7 = (const void *)_coreSchedulingSet_RLM();
        v9 = v8;
        if (CFEqual(this, v7))
        {
          v10 = (CoreSchedulingSet *)CFEqual(cf1, v9);
          if ((_DWORD)v10)
            return (_OWORD *)CoreSchedulingSet::copyRunloopEmulationSet(v10);
        }
      }
    }
  }
  if (!CFEqual(cf1, v5))
    goto LABEL_12;
  os_unfair_lock_lock((os_unfair_lock_t)&sLoaderSetLock);
  if (!sDict || (Value = CFDictionaryGetValue(*(CFDictionaryRef *)(sDict + 8), this)) == 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&sLoaderSetLock);
LABEL_12:
    v13 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 120, 0);
    *v13 = 0u;
    v13[1] = 0u;
    v13[2] = 0u;
    v13[3] = 0u;
    v13[4] = 0u;
    v13[5] = 0u;
    v13[6] = 0u;
    *((_QWORD *)v13 + 14) = 0;
    RunLoopSchedulingSet::RunLoopSchedulingSet((RunLoopSchedulingSet *)v13, (__CFRunLoop *)this, cf1, "other");
    return v13;
  }
  v13 = Value;
  (*(void (**)(_OWORD *))(*(_QWORD *)Value + 40))(Value);
  os_unfair_lock_unlock((os_unfair_lock_t)&sLoaderSetLock);
  return v13;
}

uint64_t _coreSchedulingSet_RLM(void)
{
  if (_coreSchedulingSet_RLM(void)::sOnce != -1)
    dispatch_once(&_coreSchedulingSet_RLM(void)::sOnce, &__block_literal_global_78_16878);
  return _coreSchedulingSet_RLM(void)::sLoaderRunLoop;
}

void RequestBody::_onqueue_updateUploadStatus(RequestBody *this, uint64_t a2, int a3)
{
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  dispatch_time_t v13;
  _QWORD v14[5];
  std::__shared_weak_count *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;

  *((_QWORD *)this + 12) += a2;
  *((_QWORD *)this + 4) += a2;
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v16, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 3321888768;
  v14[2] = ___ZN11RequestBody27_onqueue_updateUploadStatusElb_block_invoke;
  v14[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__110shared_ptrI11RequestBodyEE_e5_v8__0l;
  v14[4] = v16;
  v15 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  if (a3)
  {
    ___ZN11RequestBody27_onqueue_updateUploadStatusElb_block_invoke((uint64_t)v14);
  }
  else if (!*((_BYTE *)this + 40)
         && *((_QWORD *)this + 7)
         && (*(unsigned int (**)(RequestBody *))(*(_QWORD *)this + 48))(this))
  {
    *((_BYTE *)this + 40) = 1;
    v13 = dispatch_time(0, 100000000);
    dispatch_after(v13, *((dispatch_queue_t *)this + 6), v14);
  }
  v7 = v15;
  if (v15)
  {
    v8 = (unint64_t *)&v15->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v10 = v17;
  if (v17)
  {
    v11 = (unint64_t *)&v17->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_183F37218(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN11RequestBody27_onqueue_updateUploadStatusElb_block_invoke(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[7];

  result = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(result + 40) = 0;
  if (*(uint64_t *)(result + 32) >= 1)
  {
    if (*(_QWORD *)(result + 56))
    {
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
      if ((_DWORD)result)
      {
        v3 = *(_QWORD *)(a1 + 32);
        v4 = *(_QWORD *)(v3 + 32);
        *(_QWORD *)(v3 + 32) = 0;
        v5 = *(_QWORD *)(v3 + 56);
        if (v5)
          v6 = v5 - 176;
        else
          v6 = 0;
        CFRetain((CFTypeRef)(v6 - 16));
        v7 = *(_QWORD *)(a1 + 32);
        v8 = *(_QWORD *)(v7 + 96);
        v9 = *(_QWORD *)(v7 + 64);
        v10[0] = MEMORY[0x1E0C809B0];
        v10[1] = 3221225472;
        v10[2] = ___ZN11RequestBody27_onqueue_updateUploadStatusElb_block_invoke_2;
        v10[3] = &__block_descriptor_56_e5_v8__0l;
        v10[4] = v6;
        v10[5] = v4;
        v10[6] = v8;
        return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v9 + 96))(v9, v10);
      }
    }
  }
  return result;
}

void std::__shared_ptr_pointer<NSObject  {objcproto13OS_nw_context}*,Deleter_NWRelease<NSObject  {objcproto13OS_nw_context}*>,std::allocator<NSObject  {objcproto13OS_nw_context}>>::__on_zero_shared(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 24);
  if (v1)
    nw_release(v1);
}

uint64_t std::__shared_ptr_emplace<HTTPConnectionAuthenticator>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t std::__shared_ptr_emplace<ConnectionReadAggregator>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t std::__shared_ptr_emplace<HTTPEngine>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t std::__split_buffer<std::shared_ptr<HTTPConnection>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 16;
    std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](i - 16);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t HTTPRequestParserClient::isGetMethod(HTTPRequestParserClient *this)
{
  uint64_t result;
  uint8_t v3[16];

  result = *((_QWORD *)this + 3);
  if (result)
    return CFStringCompare((CFStringRef)result, (CFStringRef)&gConstantCFStringValueTable[2590], 0) == kCFCompareEqualTo;
  result = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT);
  if ((_DWORD)result)
  {
    *(_WORD *)v3 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", v3, 2u);
    result = *((_QWORD *)this + 3);
    if (result)
      return CFStringCompare((CFStringRef)result, (CFStringRef)&gConstantCFStringValueTable[2590], 0) == kCFCompareEqualTo;
  }
  return result;
}

void HTTPConnectionAuthenticator::~HTTPConnectionAuthenticator(HTTPConnectionAuthenticator *this)
{
  std::__shared_weak_count *v2;

  *(_QWORD *)this = &off_1E14EDD90;
  *((_QWORD *)this + 11) = &unk_1E14EDDC0;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 232);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 216);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 200);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 184);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 168);
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 20);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  AuthenticationState::~AuthenticationState(this);
}

{
  HTTPConnectionAuthenticator::~HTTPConnectionAuthenticator(this);
  JUMPOUT(0x186DB748CLL);
}

void HTTPConnectionCacheEntry::connLostConnection(_QWORD *a1, _QWORD *a2)
{
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  _QWORD v21[5];
  std::__shared_weak_count *v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;

  v25 = 0;
  v26 = 0;
  v4 = (std::__shared_weak_count *)a1[6];
  if (v4 && (v4 = std::__shared_weak_count::lock(v4), (v26 = v4) != 0))
  {
    v5 = a1[5];
    v25 = v5;
  }
  else
  {
    v5 = 0;
  }
  v6 = a1[8];
  v21[0] = MEMORY[0x1E0C809B0];
  v21[1] = 3321888768;
  v21[2] = ___ZN24HTTPConnectionCacheEntry18connLostConnectionENSt3__110shared_ptrI14HTTPConnectionEE_block_invoke;
  v21[3] = &__block_descriptor_64_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE48c52_ZTSNSt3__110shared_ptrI24HTTPConnectionCacheEntryEE_e5_v8__0l;
  v7 = (std::__shared_weak_count *)a2[1];
  v21[4] = *a2;
  v22 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v23 = v5;
  v24 = v4;
  if (v4)
  {
    v10 = (unint64_t *)&v4->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v21);
  v12 = v24;
  if (v24)
  {
    v13 = (unint64_t *)&v24->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = v22;
  if (v22)
  {
    v16 = (unint64_t *)&v22->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v26;
  if (v26)
  {
    v19 = (unint64_t *)&v26->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
}

void sub_183F3761C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3 - 48);
  _Unwind_Resume(a1);
}

void ConnectionReadAggregator::~ConnectionReadAggregator(ConnectionReadAggregator *this)
{
  const void *v2;
  NSObject *v3;
  NSObject *v4;
  const void *v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;

  *(_QWORD *)this = &off_1E14ECD38;
  v2 = (const void *)*((_QWORD *)this + 6);
  if (v2)
  {
    _Block_release(v2);
    *((_QWORD *)this + 6) = 0;
  }
  v3 = *((_QWORD *)this + 8);
  if (v3)
  {
    dispatch_source_cancel(v3);
    v4 = *((_QWORD *)this + 8);
    *((_QWORD *)this + 8) = 0;
    if (v4)
      dispatch_release(v4);
  }
  v5 = (const void *)*((_QWORD *)this + 12);
  if (v5)
  {
    _Block_release(v5);
    *((_QWORD *)this + 12) = 0;
  }
  v6 = *((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = 0;
  if (v6)
    dispatch_release(v6);
  v7 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (v7)
    dispatch_release(v7);
  v8 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v8)
    dispatch_release(v8);
  v9 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
  if (v9)
    std::__shared_weak_count::__release_weak(v9);
  *(_QWORD *)this = &off_1E14E5838;
  v10 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v10)
    std::__shared_weak_count::__release_weak(v10);
}

{
  ConnectionReadAggregator::~ConnectionReadAggregator(this);
  JUMPOUT(0x186DB748CLL);
}

void sub_183F376FC(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;

  v3 = v1[8];
  v1[8] = 0;
  if (v3)
    dispatch_release(v3);
  v4 = v1[7];
  v1[7] = 0;
  if (v4)
    dispatch_release(v4);
  v5 = v1[5];
  v1[5] = 0;
  if (v5)
    dispatch_release(v5);
  v6 = (std::__shared_weak_count *)v1[4];
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
  *v1 = &off_1E14E5838;
  v7 = (std::__shared_weak_count *)v1[2];
  if (v7)
    std::__shared_weak_count::__release_weak(v7);
  _Unwind_Resume(exception_object);
}

void HTTPConnection::_onqueue_cleanupEngineWhenPossible(HTTPConnection *this, uint64_t a2)
{
  HTTPEngine *v2;
  int v3;
  int v4;

  if (*((_QWORD *)this + 20))
  {
    *((_WORD *)this + 16) |= 0x40u;
  }
  else
  {
    v2 = (HTTPEngine *)*((_QWORD *)this + 8);
    if (v2)
    {
      v3 = *((unsigned __int16 *)this + 16);
      v4 = v3 | (*((unsigned __int8 *)this + 34) << 16);
      if ((v3 & 0x100) == 0)
      {
        *((_BYTE *)this + 34) = BYTE2(v4);
        *((_WORD *)this + 16) = v4 | 0x100;
        HTTPEngine::_cleanupConnection(v2, a2);
      }
    }
  }
}

void HTTPEngine::~HTTPEngine(HTTPEngine *this)
{
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  NSObject *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  NSObject *v10;
  const void *v11;
  NSObject *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  __int128 v16;

  *(_QWORD *)this = &off_1E14E4970;
  *((_QWORD *)this + 3) = &unk_1E14E49C0;
  HTTPEngine::_cleanupConnection(this, 0);
  v16 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 56, &v16);
  v2 = (std::__shared_weak_count *)*((_QWORD *)&v16 + 1);
  if (*((_QWORD *)&v16 + 1))
  {
    v3 = (unint64_t *)(*((_QWORD *)&v16 + 1) + 8);
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v5 = *((_QWORD *)this + 24);
  if (v5)
  {
    dispatch_release(v5);
    *((_QWORD *)this + 24) = 0;
  }
  v6 = (const void *)*((_QWORD *)this + 25);
  if (v6)
  {
    _Block_release(v6);
    *((_QWORD *)this + 25) = 0;
  }
  v7 = (const void *)*((_QWORD *)this + 26);
  if (v7)
  {
    _Block_release(v7);
    *((_QWORD *)this + 26) = 0;
  }
  v8 = (const void *)*((_QWORD *)this + 27);
  if (v8)
  {
    _Block_release(v8);
    *((_QWORD *)this + 27) = 0;
  }
  v9 = (const void *)*((_QWORD *)this + 20);
  if (v9)
  {
    _Block_release(v9);
    *((_QWORD *)this + 20) = 0;
  }
  v10 = *((_QWORD *)this + 38);
  if (v10)
  {
    dispatch_release(v10);
    *((_QWORD *)this + 38) = 0;
  }
  v11 = (const void *)*((_QWORD *)this + 39);
  if (v11)
  {
    _Block_release(v11);
    *((_QWORD *)this + 39) = 0;
  }

  v12 = *((_QWORD *)this + 9);
  if (v12)
  {
    dispatch_release(v12);
    *((_QWORD *)this + 9) = 0;
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 256);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 240);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 144);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 128);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 112);
  v13 = (std::__shared_weak_count *)*((_QWORD *)this + 11);
  if (v13)
    std::__shared_weak_count::__release_weak(v13);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 56);
  v14 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
  if (v14)
    std::__shared_weak_count::__release_weak(v14);
  *((_QWORD *)this + 3) = &off_1E14E5838;
  v15 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v15)
    std::__shared_weak_count::__release_weak(v15);
}

{
  HTTPEngine::~HTTPEngine(this);
  JUMPOUT(0x186DB748CLL);
}

void sub_183F37930(_Unwind_Exception *a1)
{
  _QWORD *v1;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 32));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 30));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 18));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 16));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 14));
  v3 = (std::__shared_weak_count *)v1[11];
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 7));
  v4 = (std::__shared_weak_count *)v1[6];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  v1[3] = &off_1E14E5838;
  v5 = (std::__shared_weak_count *)v1[2];
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
  _Unwind_Resume(a1);
}

void checkCertAndStore(_NSHTTPAlternativeServicesStorage *a1, _NSHTTPAlternativeServiceEntry *a2, const __CFArray *a3)
{
  _NSHTTPAlternativeServicesStorage *v5;
  _NSHTTPAlternativeServiceEntry *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  char v13;
  void *v14;
  char v15;
  NSObject *v16;
  uint8_t v17[16];

  v5 = a1;
  v6 = a2;
  -[_NSHTTPAlternativeServiceEntry host](v6, "host");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (v7)
  {
    -[_NSHTTPAlternativeServiceEntry alternateHost](v6, "alternateHost");
    v8 = (void *)objc_claimAutoreleasedReturnValue();

    if (v8)
    {
      -[_NSHTTPAlternativeServiceEntry host](v6, "host");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      -[_NSHTTPAlternativeServiceEntry alternateHost](v6, "alternateHost");
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      if (v9 == v10)
      {
        -[_NSHTTPAlternativeServiceEntry host](v6, "host");
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        -[_NSHTTPAlternativeServiceEntry alternateHost](v6, "alternateHost");
        v12 = (void *)objc_claimAutoreleasedReturnValue();
        v13 = objc_msgSend(v11, "isEqualToString:", v12);

        if ((v13 & 1) != 0)
        {
LABEL_7:
          -[_NSHTTPAlternativeServicesStorage storeHTTPServiceEntry:](v5, "storeHTTPServiceEntry:", v6);
          goto LABEL_13;
        }
      }
      else
      {

      }
      -[_NSHTTPAlternativeServiceEntry alternateHost](v6, "alternateHost");
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      v15 = __NSURLSession_CoalescingHelperIsOnDNSNameList(a3, v14);

      if ((v15 & 1) != 0)
        goto LABEL_7;
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v16 = (id)CFNLog::logger;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v17 = 0;
        _os_log_impl(&dword_183ECA000, v16, OS_LOG_TYPE_DEFAULT, "Ignoring the alternative service header since it is not covered under the setting origin's certificate", v17, 2u);
      }

    }
  }
LABEL_13:

}

void sub_183F37B44(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

uint64_t CFCachedURLResponseCopyWrappedRequest(const _CFCachedURLResponse *a1)
{
  __CFCachedURLResponse *var1;
  os_unfair_lock_s *v2;
  void *v3;

  if (!a1)
    return 0;
  var1 = a1->var1;
  v2 = (os_unfair_lock_s *)((char *)var1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)var1 + 22);
  v3 = (void *)*((_QWORD *)var1 + 14);
  os_unfair_lock_unlock(v2);
  if (!v3)
    return 0;
  CFGetAllocator(v3);
  return objc_msgSend(v3, "copy");
}

uint64_t _CFURLCacheFSWriteCachedResponseToFS(uint64_t a1)
{
  pthread_mutex_t *v2;
  const __CFData *v3;
  const UInt8 *BytePtr;
  const UInt8 *v5;
  const __CFString *v6;
  int v7;
  CFIndex Length;
  unint64_t v9;
  uint64_t v10;
  size_t v11;
  unint64_t v12;
  std::__fs::filesystem::path *v13;
  uint64_t v14;
  const char *v15;
  std::__fs::filesystem::path *v16;
  NSObject *v18;
  std::error_code *v19;
  unsigned int v20;
  char *v21;
  char *v22;
  int v23;
  NSObject *v25;
  uint64_t v26;
  int v27;
  NSObject *v28;
  uint32_t v29;
  std::__fs::filesystem::path *v30;
  BOOL v31;
  uint8_t buf[4];
  std::__fs::filesystem::path *v33;
  __int16 v34;
  size_t v35;
  std::__fs::filesystem::path __dst[42];
  std::__fs::filesystem::path buffer[43];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v2 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  v3 = *(const __CFData **)(a1 + 88);
  if (!v3)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v14 = CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      goto LABEL_28;
    LOWORD(buffer[0].__pn_.__r_.__value_.__l.__data_) = 0;
    v15 = "ERROR: no cached response was provided. Unable to get the data to cache.";
LABEL_57:
    v16 = buffer;
LABEL_58:
    v28 = v14;
    v29 = 2;
LABEL_59:
    _os_log_error_impl(&dword_183ECA000, v28, OS_LOG_TYPE_ERROR, v15, (uint8_t *)v16, v29);
LABEL_28:
    v10 = 0;
    goto LABEL_29;
  }
  BytePtr = CFDataGetBytePtr(v3);
  if (!BytePtr)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v14 = CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      goto LABEL_28;
    LOWORD(buffer[0].__pn_.__r_.__value_.__l.__data_) = 0;
    v15 = "ERROR: unable to get the pointer to the raw cache data.";
    goto LABEL_57;
  }
  v5 = BytePtr;
  v6 = *(const __CFString **)(a1 + 72);
  if (!v6 || !CFStringGetFileSystemRepresentation(v6, (char *)buffer, 1024))
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v14 = CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      goto LABEL_28;
    LOWORD(__dst[0].__pn_.__r_.__value_.__l.__data_) = 0;
    v15 = "ERROR: unable to obtain the path to the FS cache location.";
    v16 = __dst;
    goto LABEL_58;
  }
  unlink((const char *)buffer);
  strlcpy((char *)__dst, (const char *)buffer, 0x400uLL);
  strlcat((char *)buffer, ".tmp", 0x400uLL);
  v7 = open((const char *)buffer, 769, 438);
  if (v7 == -1)
  {
    v20 = 0;
    while (*__error() == 4 || *__error() == 2 || *__error() == 20)
    {
      v31 = 0;
      v21 = _ExtractCStringfromCFStringRef(*(const __CFString **)(a1 + 80), &v31);
      if (!v21)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v25 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          v30 = *(std::__fs::filesystem::path **)(a1 + 80);
          *(_DWORD *)buf = 138412290;
          v33 = v30;
          _os_log_error_impl(&dword_183ECA000, v25, OS_LOG_TYPE_ERROR, "ERROR: unable to get the raw bytes of the cache directory path %@", buf, 0xCu);
        }
        break;
      }
      v22 = v21;
      __BuildPath(v21);
      if (v31)
        MEMORY[0x186DB7474](v22, 0x1000C8077774924);
      v23 = open((const char *)buffer, 769, 438);
      v7 = v23;
      if (v23 == -1 && v20++ < 9)
        continue;
      if (v23 != -1)
        goto LABEL_6;
      break;
    }
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v26 = CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      goto LABEL_28;
    v27 = *__error();
    *(_DWORD *)buf = 136315394;
    v33 = buffer;
    v34 = 1024;
    LODWORD(v35) = v27;
    v15 = "ERROR: write-response is unable to open the file %s.  Errno: %{errno}d";
    v16 = (std::__fs::filesystem::path *)buf;
    v28 = v26;
    v29 = 18;
    goto LABEL_59;
  }
LABEL_6:
  Length = CFDataGetLength(*(CFDataRef *)(a1 + 88));
  if (Length)
  {
    v9 = Length;
    v10 = 0;
    while (2)
    {
      if (v9 >= 0x7FFFFFFF)
        v11 = 0x7FFFFFFFLL;
      else
        v11 = v9;
      while (1)
      {
        v12 = write(v7, v5, v11);
        v13 = (std::__fs::filesystem::path *)v12;
        v10 += v12;
        if ((v12 & 0x8000000000000000) == 0)
          break;
        if (*__error() != 4)
          goto LABEL_30;
      }
      if (v12 < v11)
      {
LABEL_30:
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v18 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218240;
          v33 = v13;
          v34 = 2048;
          v35 = v11;
          _os_log_error_impl(&dword_183ECA000, v18, OS_LOG_TYPE_ERROR, "ERROR: number of bytes written %ld was less than the requested amount %ld.", buf, 0x16u);
        }
        goto LABEL_34;
      }
      v5 += v12;
      v9 -= v12;
      if (v9)
        continue;
      break;
    }
  }
  else
  {
LABEL_34:
    v10 = 0;
  }
  close(v7);
  rename(buffer, __dst, v19);
LABEL_29:
  pthread_mutex_unlock(v2);
  return v10;
}

void EmptyXCookieStorage::~EmptyXCookieStorage(EmptyXCookieStorage *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E14E9DD8;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

{
  uint64_t v1;

  *(_QWORD *)this = off_1E14E9DD8;
  v1 = *((_QWORD *)this + 3);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

void HTTP3Connection::_readEncoderStream(uint64_t a1, dispatch_data_t data)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *p_buffer;
  char *v14;
  FILE *v15;
  dispatch_data_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  _QWORD v27[6];
  std::__shared_weak_count *v28;
  uint64_t buffer;
  std::__shared_weak_count *v30;
  _QWORD applier[5];

  v3 = MEMORY[0x1E0C809B0];
  applier[0] = MEMORY[0x1E0C809B0];
  applier[1] = 3221225472;
  applier[2] = ___ZN15HTTP3Connection18_readEncoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke;
  applier[3] = &__block_descriptor_40_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
  applier[4] = a1;
  dispatch_data_apply(data, applier);
  v4 = *(_DWORD *)(a1 + 304);
  v5 = v4 - *(_DWORD *)(a1 + 308);
  if (!v5)
    goto LABEL_15;
  v6 = *(_DWORD *)(a1 + 292);
  if (!v6)
  {
    LODWORD(v7) = 0;
    goto LABEL_10;
  }
  v7 = (v5 + 2 * v6) % (2 * v6);
  if (v7 <= 0x3E)
  {
LABEL_10:
    v14 = (char *)&buffer + 1;
    LOBYTE(buffer) = v7;
    goto LABEL_11;
  }
  LOBYTE(buffer) = 63;
  v8 = v7 - 63;
  v9 = 1;
  if ((unint64_t)(v7 - 63) >= 0x80)
  {
    while (v9 != 6)
    {
      v10 = v9;
      *((_BYTE *)&buffer + v9) = v8 | 0x80;
      v11 = v8 >> 7;
      ++v9;
      v12 = v8 >> 14;
      v8 >>= 7;
      if (!v12)
      {
        if (v10 > 4)
          goto LABEL_15;
        p_buffer = (char *)&buffer + v10;
        LOBYTE(v8) = v11;
        goto LABEL_32;
      }
    }
    goto LABEL_15;
  }
  p_buffer = (char *)&buffer;
LABEL_32:
  v14 = p_buffer + 2;
  *((_BYTE *)&buffer + v9) = v8;
  if (p_buffer + 2 > (char *)&buffer)
  {
LABEL_11:
    v15 = *(FILE **)(a1 + 320);
    if (v15)
    {
      fwrite("qdec: debug: ", 0xDuLL, 1uLL, v15);
      fprintf(*(FILE **)(a1 + 320), "wrote ICI: count=%u", v7);
      fputc(10, *(FILE **)(a1 + 320));
      v4 = *(_DWORD *)(a1 + 304);
    }
    *(_DWORD *)(a1 + 308) = v4;
    *(_DWORD *)(a1 + 296) += v14 - (char *)&buffer;
    if (v14 - (char *)&buffer >= 1)
    {
      v16 = dispatch_data_create(&buffer, v14 - (char *)&buffer, 0, 0);
      HTTP3Connection::writeDecoderStream(a1, v16);

    }
  }
LABEL_15:
  if (*(_QWORD *)(a1 + 1008) && (*(_BYTE *)(a1 + 920) & 4) == 0)
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&buffer, *(_QWORD *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
    v17 = *(_QWORD *)(a1 + 1008);
    v18 = *(_QWORD *)(a1 + 1048);
    v27[0] = v3;
    v27[1] = 3321888768;
    v27[2] = ___ZN15HTTP3Connection18_readEncoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke_2;
    v27[3] = &__block_descriptor_56_ea8_40c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e83_v44__0__NSObject_OS_nw_content_context__8__NSObject_OS_dispatch_data__16B24___qi_28l;
    v27[4] = a1;
    v27[5] = buffer;
    v28 = v30;
    if (v30)
    {
      p_shared_owners = (unint64_t *)&v30->__shared_owners_;
      do
        v20 = __ldxr(p_shared_owners);
      while (__stxr(v20 + 1, p_shared_owners));
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v17 + 56))(v17, v18, 1, 132000, v27);
    v21 = v28;
    if (v28)
    {
      v22 = (unint64_t *)&v28->__shared_owners_;
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
    v24 = v30;
    if (v30)
    {
      v25 = (unint64_t *)&v30->__shared_owners_;
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
  }
}

void sub_183F383C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  v2 = v1;

  _Unwind_Resume(a1);
}

char *XCookieStorage::createEmptyXCookieStorage(XCookieStorage *this, const XCookieStorage *a2)
{
  uint64_t v2;
  char *result;

  v2 = *MEMORY[0x1E0C9AE00];
  result = (char *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 32, 0);
  *(_QWORD *)(result + 20) = 0;
  *((_DWORD *)result + 7) = 0;
  *(_QWORD *)result = off_1E14EF578;
  *((_QWORD *)result + 1) = v2;
  *((_DWORD *)result + 4) = 1;
  if (((unint64_t)(result + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)result = off_1E14E9DD8;
  *((_QWORD *)result + 3) = 0;
  return result;
}

void sub_183F385C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

CFTypeRef _CFURLRequestSetContentDispositionEncodingFallbackArray(void *a1, CFTypeRef a2)
{
  uint64_t v3;
  CFTypeRef result;

  v3 = objc_msgSend(a1, "_inner");
  result = *(CFTypeRef *)(v3 + 80);
  if (result != a2)
  {
    if (result)
      CFRelease(result);
    if (a2)
      result = CFRetain(a2);
    else
      result = 0;
    *(_QWORD *)(v3 + 80) = result;
  }
  return result;
}

CFTypeRef CFURLCredentialStorageCreate(char *a1)
{
  uint64_t v1;

  v1 = _CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault;
  if (!_CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault)
  {
    a1 = StorageSession::copyProcessDefault((StorageSession *)a1);
    v1 = (uint64_t)(a1 - 16);
    _CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault = (uint64_t)(a1 - 16);
  }
  return _CFURLStorageSessionCopyCredentialStorage((uint64_t)a1, v1);
}

CFTypeRef _CFURLStorageSessionCopyCredentialStorage(uint64_t a1, uint64_t a2)
{
  StorageSession *v3;

  if (StorageSession::Class(void)::sOnce_StorageSession != -1)
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_16297);
  if (a2)
    v3 = (StorageSession *)(a2 + 16);
  else
    v3 = 0;
  return StorageSession::copyCredStorage(v3);
}

void URLRequest::setProtocolProperty(URLRequest *this, const __CFString *key, const void *value)
{
  __CFDictionary *fProtocolProperties;

  fProtocolProperties = this->fProtocolProperties;
  if (!fProtocolProperties)
  {
    fProtocolProperties = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    this->fProtocolProperties = fProtocolProperties;
  }
  if (value)
    CFDictionarySetValue(fProtocolProperties, key, value);
  else
    CFDictionaryRemoveValue(fProtocolProperties, key);
}

void sub_183F389D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);

  _Unwind_Resume(a1);
}

void sub_183F38A48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_183F38C50(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183F38D10(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t BrotliDataDecoderHolder::decoder(BrotliDataDecoderHolder *this)
{
  return (uint64_t)this + 8;
}

uint64_t HTTPConnectionCache::initWithSchedulingSet(HTTPConnectionCache *a1, uint64_t a2, uint64_t a3)
{
  if (!a2)
    __assert_rtn("initWithSchedulingSet", "HTTPConnectionCache.cpp", 101, "schedulingSet");
  *((_QWORD *)a1 + 12) = a2;
  (*(void (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
  *((_QWORD *)a1 + 13) = a3;
  *((_QWORD *)a1 + 5) = 0;
  HTTPConnectionCache::enableTimer(a1);
  return (*(uint64_t (**)(HTTPConnectionCache *))(*(_QWORD *)a1 + 152))(a1);
}

uint64_t ___ZN11HTTP3Stream26scheduleAndOpenWithHandlerEPK17CoreSchedulingSetU13block_pointerFvP15__CFHTTPMessagePU27objcproto16OS_dispatch_data8NSObjectPK13CFStreamErrorEU13block_pointerFvhE_block_invoke_1(uint64_t a1, uint64_t a2, CFIndex a3, uint64_t a4)
{
  HTTP3Stream *v4;
  uint64_t v5;
  CFStreamError v7;

  v4 = *(HTTP3Stream **)(a1 + 32);
  v5 = *((_QWORD *)v4 + 43);
  if (v5)
    *(_QWORD *)(v5 + 96) = a2;
  v7.domain = a3;
  *(_QWORD *)&v7.error = a4;
  return HTTP3Stream::_handleSendError(v4, v7, *((_QWORD *)v4 + 12) == 0);
}

void __NSURLSession_CoalescingAddConnectionEntry(void *a1, uint64_t a2, void *a3, void *a4, const void *a5, const void *a6, std::string *a7)
{
  void *v13;
  __CFN_CoalescingDomainHolder *v14;
  void **v15;
  uint64_t v16;
  const char *v17;
  NSObject *v18;
  uint32_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t i;
  _OWORD *v23;
  __int128 v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  __int128 v34;
  int64x2_t v35;
  unint64_t v36;
  std::string *v37;
  std::string *v38;
  unint64_t *p_size;
  int end_high;
  CFTypeRef v41;
  CFTypeRef v42;
  CFTypeRef v43;
  NSObject *v44;
  std::__shared_weak_count *v45;
  unint64_t *p_shared_owners;
  unint64_t v47;
  uint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t v52;
  std::__shared_weak_count *begin;
  unint64_t *v54;
  unint64_t v55;
  std::string *v56;
  std::string *v57;
  void *v58;
  __CFN_CoalescingDomainHolder *v59;
  std::string *v60;
  const void *v61;
  void *v62;
  void **v63;
  std::__shared_weak_count *v64;
  void *__p[2];
  std::string *v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  int64x2_t v71;
  _QWORD v72[3];
  std::__shared_weak_count *v73;
  uint8_t buf[4];
  void *v75;
  __int16 v76;
  void **v77;
  __int16 v78;
  void *v79;
  std::__split_buffer<std::string> v80;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  if (!a4)
    return;
  v13 = a1;
  v14 = (__CFN_CoalescingDomainHolder *)objc_msgSend(a1, "objectForKeyedSubscript:", a2);
  if (!v14)
  {
    v14 = objc_alloc_init(__CFN_CoalescingDomainHolder);
    objc_msgSend(v13, "setObject:forKeyedSubscript:", v14, a2);
  }
  -[__CFN_CoalescingDomainHolder coalescingCoalescingConnectionHost:ipAddrs:](&v63, (uint64_t)v14, a3, a4);
  v15 = v63;
  if (v63)
  {
    if (H2CoalescingLog(void)::onceToken != -1)
      dispatch_once(&H2CoalescingLog(void)::onceToken, &__block_literal_global_6187);
    v16 = H2CoalescingLog(void)::onceLog;
    if (!os_log_type_enabled((os_log_t)H2CoalescingLog(void)::onceLog, OS_LOG_TYPE_DEBUG))
      goto LABEL_71;
    if (*((char *)v15 + 23) < 0)
      v15 = (void **)*v15;
    *(_DWORD *)buf = 138412802;
    v75 = a3;
    v76 = 2080;
    v77 = v15;
    v78 = 2048;
    v79 = v13;
    v17 = "new connection to %@ ip address already exists at %s config %p";
    v18 = v16;
    v19 = 32;
  }
  else
  {
    if (v14)
    {
      v61 = a5;
      v59 = v14;
      v60 = a7;
      v62 = a3;
      v58 = v13;
      v71 = 0uLL;
      v72[0] = 0;
      v67 = 0u;
      v68 = 0u;
      v69 = 0u;
      v70 = 0u;
      v20 = objc_msgSend(a4, "countByEnumeratingWithState:objects:count:", &v67, buf, 16);
      if (v20)
      {
        v21 = *(_QWORD *)v68;
        do
        {
          for (i = 0; i != v20; ++i)
          {
            if (*(_QWORD *)v68 != v21)
              objc_enumerationMutation(a4);
            std::string::basic_string[abi:nn180100]<0>(__p, (char *)objc_msgSend(*(id *)(*((_QWORD *)&v67 + 1) + 8 * i), "UTF8String"));
            v23 = (_OWORD *)v71.i64[1];
            if (v71.i64[1] >= v72[0])
            {
              v25 = 0xAAAAAAAAAAAAAAABLL * ((v71.i64[1] - v71.i64[0]) >> 3);
              v26 = v25 + 1;
              if (v25 + 1 > 0xAAAAAAAAAAAAAAALL)
                abort();
              if (0x5555555555555556 * ((v72[0] - v71.i64[0]) >> 3) > v26)
                v26 = 0x5555555555555556 * ((v72[0] - v71.i64[0]) >> 3);
              if (0xAAAAAAAAAAAAAAABLL * ((v72[0] - v71.i64[0]) >> 3) >= 0x555555555555555)
                v27 = 0xAAAAAAAAAAAAAAALL;
              else
                v27 = v26;
              v80.__end_cap_.__value_ = (std::allocator<std::string> *)v72;
              if (v27)
                v27 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v27);
              else
                v28 = 0;
              v29 = v27 + 24 * v25;
              v30 = *(_OWORD *)__p;
              *(_QWORD *)(v29 + 16) = v66;
              *(_OWORD *)v29 = v30;
              __p[1] = 0;
              v66 = 0;
              __p[0] = 0;
              v31 = v71.i64[1];
              v32 = v71.i64[0];
              if (v71.i64[1] == v71.i64[0])
              {
                v35 = vdupq_n_s64(v71.u64[1]);
                v33 = v27 + 24 * v25;
              }
              else
              {
                v33 = v27 + 24 * v25;
                do
                {
                  v34 = *(_OWORD *)(v31 - 24);
                  *(_QWORD *)(v33 - 8) = *(_QWORD *)(v31 - 8);
                  *(_OWORD *)(v33 - 24) = v34;
                  v33 -= 24;
                  *(_QWORD *)(v31 - 16) = 0;
                  *(_QWORD *)(v31 - 8) = 0;
                  *(_QWORD *)(v31 - 24) = 0;
                  v31 -= 24;
                }
                while (v31 != v32);
                v35 = v71;
              }
              v36 = v29 + 24;
              v71.i64[0] = v33;
              v71.i64[1] = v29 + 24;
              *(int64x2_t *)&v80.__begin_ = v35;
              v37 = (std::string *)v72[0];
              v72[0] = v27 + 24 * v28;
              v80.__end_cap_.__value_ = v37;
              v80.__first_ = (std::__split_buffer<std::string>::pointer)v35.i64[0];
              std::__split_buffer<std::string>::~__split_buffer(&v80);
              v71.i64[1] = v36;
              if (SHIBYTE(v66) < 0)
                operator delete(__p[0]);
            }
            else
            {
              v24 = *(_OWORD *)__p;
              *(_QWORD *)(v71.i64[1] + 16) = v66;
              *v23 = v24;
              v71.i64[1] = (uint64_t)v23 + 24;
            }
          }
          v20 = objc_msgSend(a4, "countByEnumeratingWithState:objects:count:", &v67, buf, 16);
        }
        while (v20);
      }
      a3 = v62;
      std::string::basic_string[abi:nn180100]<0>(__p, (char *)objc_msgSend(v62, "UTF8String"));
      v38 = (std::string *)operator new(0x48uLL);
      v38->__r_.__value_.__l.__size_ = 0;
      p_size = &v38->__r_.__value_.__l.__size_;
      v38->__r_.__value_.__r.__words[2] = 0;
      v38->__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E14F0E50;
      if (SHIBYTE(v66) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)&v80, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
      }
      else
      {
        *(_OWORD *)&v80.__first_ = *(_OWORD *)__p;
        v80.__end_ = v66;
      }
      end_high = SHIBYTE(v80.__end_);
      if (SHIBYTE(v80.__end_) < 0)
      {
        std::string::__init_copy_ctor_external(v38 + 1, (const std::string::value_type *)v80.__first_, (std::string::size_type)v80.__begin_);
      }
      else
      {
        *(_OWORD *)&v38[1].__r_.__value_.__l.__data_ = *(_OWORD *)&v80.__first_;
        v38[1].__r_.__value_.__r.__words[2] = (std::string::size_type)v80.__end_;
      }
      if (v61)
        v41 = CFRetain(v61);
      else
        v41 = 0;
      v38[2].__r_.__value_.__r.__words[0] = (std::string::size_type)v41;
      if (a6)
        v42 = CFRetain(a6);
      else
        v42 = 0;
      v38[2].__r_.__value_.__l.__size_ = (std::string::size_type)v42;
      if (v60)
        v43 = CFRetain(v60);
      else
        v43 = 0;
      v38[2].__r_.__value_.__r.__words[2] = (std::string::size_type)v43;
      if (end_high < 0)
        operator delete(v80.__first_);
      v72[2] = v38 + 1;
      v73 = (std::__shared_weak_count *)v38;
      if (std::__tree<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,std::__map_value_compare<std::shared_ptr<__CoalescingConnectionKey>,std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,CoalescingConnectionKeyComparator,true>,std::allocator<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>>>::__count_unique<std::shared_ptr<__CoalescingConnectionKey>>((_QWORD *)v14->_coalescingDomain._connectionKeyToAllIPAddresses.__tree_.__pair1_.__value_.__left_, v38[1].__r_.__value_.__r.__words)|| std::__tree<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>>>::__count_unique<std::string>((_QWORD *)v14->_coalescingDomain._requestHostToConnectionKey.__tree_.__pair1_.__value_.__left_, __p))
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v44 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
        {
          v56 = (std::string *)std::__tree<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,std::__map_value_compare<std::shared_ptr<__CoalescingConnectionKey>,std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,CoalescingConnectionKeyComparator,true>,std::allocator<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>>>::__count_unique<std::shared_ptr<__CoalescingConnectionKey>>((_QWORD *)v59->_coalescingDomain._connectionKeyToAllIPAddresses.__tree_.__pair1_.__value_.__left_, v38[1].__r_.__value_.__r.__words);
          v57 = (std::string *)std::__tree<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>>>::__count_unique<std::string>((_QWORD *)v59->_coalescingDomain._requestHostToConnectionKey.__tree_.__pair1_.__value_.__left_, __p);
          LODWORD(v80.__first_) = 134218498;
          *(std::__split_buffer<std::string>::pointer *)((char *)&v80.__first_ + 4) = v56;
          WORD2(v80.__begin_) = 2048;
          *(std::__split_buffer<std::string>::pointer *)((char *)&v80.__begin_ + 6) = v57;
          HIWORD(v80.__end_) = 2112;
          v80.__end_cap_.__value_ = v60;
          _os_log_fault_impl(&dword_183ECA000, v44, OS_LOG_TYPE_FAULT, "Invalid coalescing state (%lu, %lu) %@", (uint8_t *)&v80, 0x20u);
        }
      }
      else
      {
        v80.__first_ = v38 + 1;
        v80.__begin_ = v38;
        do
          v52 = __ldxr(p_size);
        while (__stxr(v52 + 1, p_size));
        CoalescingDomain::_update_internal_mappings((uint64_t **)&v14->_coalescingDomain, (uint64_t *)&v80, (uint64_t)__p, (__int128 **)&v71);
        begin = (std::__shared_weak_count *)v80.__begin_;
        if (v80.__begin_)
        {
          v54 = &v80.__begin_->__r_.__value_.__l.__size_;
          do
            v55 = __ldaxr(v54);
          while (__stlxr(v55 - 1, v54));
          if (!v55)
          {
            ((void (*)(std::__shared_weak_count *))begin->__on_zero_shared)(begin);
            std::__shared_weak_count::__release_weak(begin);
          }
        }
      }
      v45 = v73;
      v13 = v58;
      if (v73)
      {
        p_shared_owners = (unint64_t *)&v73->__shared_owners_;
        do
          v47 = __ldaxr(p_shared_owners);
        while (__stlxr(v47 - 1, p_shared_owners));
        if (!v47)
        {
          ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
          std::__shared_weak_count::__release_weak(v45);
        }
      }
      if (SHIBYTE(v66) < 0)
        operator delete(__p[0]);
      v80.__first_ = (std::__split_buffer<std::string>::pointer)&v71;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v80);
    }
    if (H2CoalescingLog(void)::onceToken != -1)
      dispatch_once(&H2CoalescingLog(void)::onceToken, &__block_literal_global_6187);
    v48 = H2CoalescingLog(void)::onceLog;
    if (!os_log_type_enabled((os_log_t)H2CoalescingLog(void)::onceLog, OS_LOG_TYPE_DEBUG))
      goto LABEL_71;
    *(_DWORD *)buf = 138412546;
    v75 = a3;
    v76 = 2048;
    v77 = (void **)v13;
    v17 = "new connection to %@ config %p";
    v18 = v48;
    v19 = 22;
  }
  _os_log_debug_impl(&dword_183ECA000, v18, OS_LOG_TYPE_DEBUG, v17, buf, v19);
LABEL_71:
  v49 = v64;
  if (v64)
  {
    v50 = (unint64_t *)&v64->__shared_owners_;
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
}

void sub_183F39488(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, char *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
  uint64_t v36;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v36 - 144);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a36);
  if (a23 < 0)
    operator delete(__p);
  __p = &a32;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'HTTP3StreamWrapper::getProxy(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 128))(*((_QWORD *)this + 1));
}

uint64_t `non-virtual thunk to'HTTP3StreamWrapper::canScheduleAndOpenWithHandlerAsync(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 40))(*((_QWORD *)this + 1));
}

uint64_t `non-virtual thunk to'HTTP3StreamWrapper::setBodyStreamBeforeOpening(HTTP3StreamWrapper *this, __CFReadStream *a2)
{
  return (*(uint64_t (**)(_QWORD, __CFReadStream *))(**((_QWORD **)this + 1) + 32))(*((_QWORD *)this + 1), a2);
}

uint64_t `non-virtual thunk to'HTTP3StreamWrapper::scheduleAndOpenWithHandler(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 48))(*(_QWORD *)(a1 + 8));
}

uint64_t `non-virtual thunk to'HTTP3StreamWrapper::setTransactionMetrics(HTTP3StreamWrapper *this, __CFN_TransactionMetrics *a2)
{
  return (*(uint64_t (**)(_QWORD, __CFN_TransactionMetrics *))(**((_QWORD **)this + 1) + 136))(*((_QWORD *)this + 1), a2);
}

uint64_t `non-virtual thunk to'HTTP3StreamWrapper::closeAndClearHandler(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 56))(*((_QWORD *)this + 1));
}

uint64_t `non-virtual thunk to'HTTP3StreamWrapper::rawBytesReceived(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 88))(*((_QWORD *)this + 1));
}

uint64_t `non-virtual thunk to'HTTP3StreamWrapper::setPriorityHint(HTTP3StreamWrapper *this, float a2)
{
  return (*(uint64_t (**)(_QWORD, float))(**((_QWORD **)this + 1) + 72))(*((_QWORD *)this + 1), a2);
}

uint64_t `non-virtual thunk to'HTTP3StreamWrapper::rawBytesSent(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 80))(*((_QWORD *)this + 1));
}

uint64_t `non-virtual thunk to'HTTP3StreamWrapper::_meta_retain(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(char *))(*((_QWORD *)this - 3) + 40))((char *)this - 24);
}

uint64_t std::__tree<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>>>::__count_unique<std::string>(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;

  if (a1)
  {
    v3 = a1;
    v4 = 1;
    do
    {
      if (!std::less<std::string>::operator()[abi:nn180100](a2, v3 + 4))
      {
        if (!std::less<std::string>::operator()[abi:nn180100](v3 + 4, a2))
          return v4;
        ++v3;
      }
      v3 = (_QWORD *)*v3;
    }
    while (v3);
  }
  return 0;
}

uint64_t std::__tree<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,std::__map_value_compare<std::shared_ptr<__CoalescingConnectionKey>,std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,CoalescingConnectionKeyComparator,true>,std::allocator<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>>>::__count_unique<std::shared_ptr<__CoalescingConnectionKey>>(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;

  if (a1)
  {
    v3 = a1;
    v4 = 1;
    do
    {
      v5 = (_QWORD *)v3[4];
      if (!std::less<std::string>::operator()[abi:nn180100](a2, v5))
      {
        if (!std::less<std::string>::operator()[abi:nn180100](v5, a2))
          return v4;
        ++v3;
      }
      v3 = (_QWORD *)*v3;
    }
    while (v3);
  }
  return 0;
}

CFTypeRef NWIOConnection::copyTrustCloneData(NWIOConnection *this)
{
  CFTypeRef result;

  result = (CFTypeRef)*((_QWORD *)this + 58);
  if (result)
    return CFRetain(result);
  return result;
}

CFStringRef NWIOConnection::copyTICDescription(NWIOConnection *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("Connection %llu"), *((_QWORD *)this + 36));
}

uint64_t NWIOConnection::isProxyConfigured(NWIOConnection *this)
{
  return *((unsigned __int16 *)this + 124) >> 15;
}

CFTypeRef NWIOConnection::copyPeerCerts(NWIOConnection *this)
{
  CFTypeRef result;

  result = (CFTypeRef)*((_QWORD *)this + 60);
  if (result)
    return CFRetain(result);
  return result;
}

uint64_t HTTP2ConnectionCache::ingestTube(CFDictionaryRef *this, Tube **a2, int a3)
{
  const HTTPConnectionCacheKey *v6;
  char *HTTP2ConnectionCacheEntry;
  const __CFArray *v8;
  int v9;
  uint64_t Instance;
  char *v11;
  const __CFAllocator *v12;
  CFMutableDictionaryRef Mutable;
  char *v14;
  std::__shared_weak_count *v15;
  Tube **v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  Tube *v20;
  BOOL v21;
  uint64_t v22;
  int v24;
  const HTTPConnectionCacheKey *v25;
  __int128 context;
  void (__cdecl *v27)(CFAllocatorRef, const void *);
  void *v28;
  CFArrayCallBacks *p_callBacks;
  char *v30;
  Tube **v31;
  CFArrayCallBacks callBacks;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  CFRange v38;

  v6 = (const HTTPConnectionCacheKey *)Tube::copyKey(a2[13]);
  HTTP2ConnectionCacheEntry = (char *)HTTP2ConnectionCache::_onqueue_findOrCreateHTTP2ConnectionCacheEntry(this, v6);
  callBacks.version = 0;
  callBacks.retain = (CFArrayRetainCallBack)&callBacks;
  callBacks.release = (CFArrayReleaseCallBack)0x2020000000;
  LOBYTE(callBacks.copyDescription) = 0;
  *(_QWORD *)&context = MEMORY[0x1E0C809B0];
  *((_QWORD *)&context + 1) = 3221225472;
  v27 = (void (__cdecl *)(CFAllocatorRef, const void *))___ZN25HTTP2ConnectionCacheEntry23shouldOpenNewConnectionEv_block_invoke;
  v28 = &unk_1E14FC540;
  p_callBacks = &callBacks;
  v8 = (const __CFArray *)*((_QWORD *)HTTP2ConnectionCacheEntry + 11);
  v38.length = CFArrayGetCount(v8);
  v38.location = 0;
  CFArrayApplyFunction(v8, v38, (CFArrayApplierFunction)RetainableTypedArray<HTTP2Connection *>::_invoke, &context);
  v9 = *((unsigned __int8 *)callBacks.retain + 24);
  _Block_object_dispose(&callBacks, 8);
  if (v9)
    __assert_rtn("ingestTube", "HTTP2ConnectionCacheEntry.cpp", 235, "shouldOpenNewConnection()");
  CFGetAllocator(HTTP2ConnectionCacheEntry - 16);
  if (HTTP2Connection::Class(void)::sOnce_HTTP2Connection != -1)
    dispatch_once(&HTTP2Connection::Class(void)::sOnce_HTTP2Connection, &__block_literal_global_1);
  v24 = a3;
  v25 = v6;
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v11 = (char *)(Instance + 16);
    bzero((void *)(Instance + 16), 0x2F0uLL);
  }
  else
  {
    v11 = 0;
  }
  v12 = CFGetAllocator(HTTP2ConnectionCacheEntry - 16);
  *(_QWORD *)v11 = &off_1E14E77C8;
  *((_QWORD *)v11 + 1) = &unk_1E14E7840;
  *((_QWORD *)v11 + 2) = &unk_1E14E7860;
  *((_QWORD *)v11 + 3) = &unk_1E14E78B0;
  *((_QWORD *)v11 + 4) = &off_1E14EA428;
  Mutable = CFDictionaryCreateMutable(v12, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *((_QWORD *)v11 + 7) = 0;
  *((_QWORD *)v11 + 5) = Mutable;
  *((_DWORD *)v11 + 27) = 0;
  v11[136] = 0;
  *((_QWORD *)v11 + 32) = 0;
  *((_QWORD *)v11 + 34) = 0;
  *((_QWORD *)v11 + 35) = 0;
  *((_OWORD *)v11 + 18) = xmmword_1841E3970;
  *((_QWORD *)v11 + 8) = 0;
  *((_QWORD *)v11 + 9) = 0;
  *((_WORD *)v11 + 40) = 0;
  *((_QWORD *)v11 + 11) = 0;
  *((_QWORD *)v11 + 12) = 0;
  v11[104] = 0;
  *((_DWORD *)v11 + 76) = 0;
  *((_QWORD *)v11 + 45) = 0;
  *(_OWORD *)(v11 + 312) = 0u;
  *(_OWORD *)(v11 + 328) = 0u;
  *(_OWORD *)(v11 + 344) = 0u;
  *((_DWORD *)v11 + 92) = 1065353216;
  *(_OWORD *)(v11 + 376) = 0u;
  *(_OWORD *)(v11 + 392) = 0u;
  *((_DWORD *)v11 + 102) = 1065353216;
  *((_OWORD *)v11 + 26) = 0u;
  *((_OWORD *)v11 + 27) = 0u;
  *((_DWORD *)v11 + 112) = 1065353216;
  *((_DWORD *)v11 + 114) = 100;
  *(_OWORD *)(v11 + 460) = 0u;
  *(_OWORD *)(v11 + 476) = 0u;
  *(_QWORD *)(v11 + 492) = 0x3F80000000000000;
  *(_OWORD *)(v11 + 504) = 0u;
  *(_OWORD *)(v11 + 520) = 0u;
  *((_DWORD *)v11 + 134) = 1065353216;
  *((_OWORD *)v11 + 34) = 0u;
  *((_OWORD *)v11 + 35) = 0u;
  *((_DWORD *)v11 + 144) = 1065353216;
  *((_DWORD *)v11 + 150) = 0;
  *((_QWORD *)v11 + 77) = 0;
  *((_QWORD *)v11 + 78) = 0;
  *(_QWORD *)(v11 + 591) = 0;
  *((_QWORD *)v11 + 73) = 0;
  *((_QWORD *)v11 + 79) = HTTP2Connection::HTTP2Connection(__CFAllocator const*)::$_0::__invoke;
  *((_QWORD *)v11 + 76) = v11 + 616;
  *((_WORD *)v11 + 320) = 0;
  v11[642] = 1;
  *((_QWORD *)v11 + 87) = 0;
  *(_OWORD *)(v11 + 664) = 0u;
  *(_OWORD *)(v11 + 680) = 0u;
  *(_OWORD *)(v11 + 648) = 0u;
  *((_DWORD *)v11 + 176) = 1065353216;
  *((_QWORD *)v11 + 29) = 0;
  v11[228] = 0;
  v11[264] = 0;
  v11[744] = 0;
  *(_OWORD *)(v11 + 712) = 0u;
  *(_OWORD *)(v11 + 728) = 0u;
  v14 = (char *)operator new(0x30uLL);
  *(_OWORD *)(v14 + 8) = 0u;
  *(_QWORD *)v14 = &off_1E14F08D8;
  *((_DWORD *)v14 + 6) = 1;
  *((_OWORD *)v14 + 2) = 0u;
  *(_QWORD *)&context = v14 + 24;
  *((_QWORD *)&context + 1) = v14;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v11 + 56), &context);
  v15 = (std::__shared_weak_count *)*((_QWORD *)&context + 1);
  v16 = a2;
  if (*((_QWORD *)&context + 1))
  {
    v17 = (unint64_t *)(*((_QWORD *)&context + 1) + 8);
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v33 = 0;
  v34 = &v33;
  v35 = 0x2020000000;
  v36 = 1;
  v19 = Tube::copyKey(a2[13]);
  *((_DWORD *)v11 + 148) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v19 + 88))(v19);
  *(_OWORD *)&callBacks.version = xmmword_1E14F7250;
  *(_OWORD *)&callBacks.release = *(_OWORD *)&off_1E14F7260;
  callBacks.equal = (CFArrayEqualCallBack)HTTP2StreamEqualCallBack;
  *((_QWORD *)v11 + 29) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &callBacks);
  *((CFAbsoluteTime *)v11 + 31) = CFAbsoluteTimeGetCurrent();
  *((_QWORD *)v11 + 30) = HTTP2ConnectionCacheEntry;
  CFRetain(HTTP2ConnectionCacheEntry - 16);
  *(_OWORD *)(v11 + 204) = defaultLocalSettings;
  *(_QWORD *)(v11 + 220) = 0x7FFFFFFF00FFFFFFLL;
  v20 = v16[20];
  if (v20)
  {
    dispatch_retain((dispatch_object_t)v16[20]);
    *((_QWORD *)v11 + 21) = v20;
    *(_QWORD *)&context = MEMORY[0x1E0C809B0];
    *((_QWORD *)&context + 1) = 3221225472;
    v27 = (void (__cdecl *)(CFAllocatorRef, const void *))___ZN15HTTP2Connection10initializeEP4TubeiP25HTTP2ConnectionCacheEntry_block_invoke;
    v28 = &unk_1E14FD7A8;
    v30 = v11;
    v31 = v16;
    p_callBacks = (CFArrayCallBacks *)&v33;
    ___ZN15HTTP2Connection10initializeEP4TubeiP25HTTP2ConnectionCacheEntry_block_invoke(&context);
    v21 = *((_BYTE *)v34 + 24) != 0;
  }
  else
  {
    *((_QWORD *)v11 + 21) = 0;
    v21 = *((_BYTE *)v34 + 24) == 0;
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v19 + 48))(v19);
  _Block_object_dispose(&v33, 8);
  if (v21)
  {
    CFArrayAppendValue(*((CFMutableArrayRef *)HTTP2ConnectionCacheEntry + 11), v11);
    CFRelease(v11 - 16);
    HTTP2ConnectionCacheEntry[104] = 1;
  }
  else
  {
    CFRelease(v11 - 16);
  }
  if (v24)
  {
    v33 = 0;
    v37 = 0;
    context = 0x3F000000FFFFFFFFuLL;
    LODWORD(v27) = 0;
    v22 = Tube::copyWaiter(v16[14]);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, __int128 *))(*(_QWORD *)v22 + 104))(v22, &v33, &v37, &context);
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v22 + 56))(v22, 0);
    *(_OWORD *)&callBacks.version = context;
    callBacks.release = v27;
    HTTP2ConnectionCacheEntry::enqueueRequestForProtocol((uint64_t)HTTP2ConnectionCacheEntry, v33, v37, (int *)&callBacks);
    (*(void (**)(uint64_t))(*(_QWORD *)v22 + 48))(v22);
  }
  return (*(uint64_t (**)(const HTTPConnectionCacheKey *))(*(_QWORD *)v25 + 48))(v25);
}

void sub_183F39CA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  uint64_t v27;

  (*(void (**)(uint64_t))(*(_QWORD *)v27 + 48))(v27);
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

uint64_t HTTP2ConnectionCache::enqueueRequestForProtocol(CFDictionaryRef *a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  const HTTPConnectionCacheKey *v8;
  const void *HTTP2ConnectionCacheEntry;
  __int128 v11;
  uint64_t v12;

  v8 = (const HTTPConnectionCacheKey *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
  HTTP2ConnectionCacheEntry = HTTP2ConnectionCache::_onqueue_findOrCreateHTTP2ConnectionCacheEntry(a1, v8);
  v11 = *a4;
  v12 = *((_QWORD *)a4 + 2);
  return HTTP2ConnectionCacheEntry::enqueueRequestForProtocol((uint64_t)HTTP2ConnectionCacheEntry, a2, a3, (int *)&v11);
}

const void *HTTP2ConnectionCache::_onqueue_findOrCreateHTTP2ConnectionCacheEntry(CFDictionaryRef *this, const HTTPConnectionCacheKey *a2)
{
  const void *Value;
  uint64_t Instance;
  CFDictionaryRef v6;
  CFDictionaryRef v7;
  const __CFAllocator *v8;
  _QWORD *v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  dispatch_time_t v13;
  NSObject *v14;
  dispatch_time_t v15;

  Value = CFDictionaryGetValue(this[12], a2);
  if (!Value)
  {
    if (HTTP2ConnectionCacheEntry::Class(void)::sOnce_HTTP2ConnectionCacheEntry != -1)
      dispatch_once(&HTTP2ConnectionCacheEntry::Class(void)::sOnce_HTTP2ConnectionCacheEntry, &__block_literal_global_6336);
    Instance = _CFRuntimeCreateInstance();
    *(_OWORD *)(Instance + 16) = 0u;
    Value = (const void *)(Instance + 16);
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 48) = xmmword_1841E37E0;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    v6 = this[10];
    v7 = this[13];
    *(_QWORD *)(Instance + 16) = &off_1E14ED400;
    *(_QWORD *)(Instance + 24) = &unk_1E14ED448;
    *(_OWORD *)(Instance + 64) = xmmword_1841E37F0;
    *(_QWORD *)(Instance + 80) = 0x7800000078;
    v8 = CFGetAllocator((CFTypeRef)Instance);
    *(_QWORD *)(Instance + 104) = CFArrayCreateMutable(v8, 0, &CFObject::skCFTypeArrayCallBacks);
    *(_QWORD *)(Instance + 112) = 0;
    *(_QWORD *)(Instance + 32) = this;
    (*((void (**)(CFDictionaryRef *))*this + 5))(this);
    *(_QWORD *)(Instance + 88) = v6;
    *(_QWORD *)(Instance + 96) = v7;
    (*(void (**)(CFDictionaryRef))(*(_QWORD *)v6 + 40))(v6);
    *(_WORD *)(Instance + 120) = 0;
    v9 = (_QWORD *)operator new();
    *v9 = &off_1E14E9AC8;
    v9[1] = v9 + 1;
    v9[2] = v9 + 1;
    v9[3] = 0;
    v10 = *(_QWORD *)(Instance + 112);
    *(_QWORD *)(Instance + 112) = v9;
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
    if (!a2)
      __assert_rtn("initialize", "HTTP2ConnectionCacheEntry.cpp", 110, "key");
    v11 = *((_DWORD *)this + 13);
    *(_QWORD *)(Instance + 40) = a2;
    (*(void (**)(const HTTPConnectionCacheKey *))(*(_QWORD *)a2 + 40))(a2);
    *(_DWORD *)(Instance + 124) = v11;
    CFDictionarySetValue(this[12], a2, Value);
    CFRelease((CFTypeRef)Instance);
    if (CFDictionaryGetCount(this[12]) == 1)
    {
      v12 = this[14];
      v13 = dispatch_time(0x8000000000000000, (uint64_t)((double)*((int *)this + 18) * 1000000000.0));
      dispatch_source_set_timer(v12, v13, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
      v14 = this[15];
      v15 = dispatch_time(0, (uint64_t)((double)*((int *)this + 19) * 1000000000.0));
      dispatch_source_set_timer(v14, v15, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    }
  }
  return Value;
}

void sub_183F3A02C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 112);
  *(_QWORD *)(v1 + 112) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  CFRelease(*(CFTypeRef *)(v1 + 104));
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t HTTP2ConnectionCacheEntry::enqueueRequestForProtocol(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  const __CFAllocator *v8;
  CFHTTPMessageRef Copy;
  const __CFURL *v10;
  URLProtocol *v11;
  _QWORD *v12;
  HTTPRequestMessage *v13;
  HTTPRequestMessage *v14;
  CFIndex v15;
  char *v16;
  CFIndex Count;
  const __CFArray *v18;
  _BYTE *ValueAtIndex;
  _BYTE *v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  CFArrayRef *v24;
  uint64_t v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  _BYTE *v31;
  void *v32;
  int v33;
  double v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  double Current;
  uint64_t v39;
  double v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const void *v44;
  IOConnWrapper *v45;
  void *v46;
  id *v47;
  uint64_t v48;
  void *v49;
  unint64_t *v50;
  unint64_t v51;
  const __CFURL *cf;
  _QWORD v53[2];
  void (*v54)(uint64_t);
  void *v55;
  CFHTTPMessageRef v56;
  __int128 v57;
  void (*v58)(_QWORD *);
  void *v59;
  uint64_t *v60;
  _BYTE *v61;
  char *v62;
  uint64_t v63;
  double v64;
  int v65;
  uint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t v69;

  v8 = CFGetAllocator((CFTypeRef)(a1 - 16));
  Copy = CFHTTPMessageCreateCopy(v8, (CFHTTPMessageRef)(a3 - 16));
  v53[0] = MEMORY[0x1E0C809B0];
  v53[1] = 3221225472;
  v54 = ___ZN25HTTP2ConnectionCacheEntry25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke;
  v55 = &__block_descriptor_40_e5_v8__0l;
  v56 = Copy;
  v10 = CFHTTPMessageCopyRequestURL(Copy);
  if (a2)
    v11 = (URLProtocol *)(a2 - 176);
  else
    v11 = 0;
  cf = v10;
  if ((HTTPProtocol::canUseH2WithCurrentAuthScheme((HTTPProtocol *)v11, v10) & 1) != 0)
  {
    v12 = *(_QWORD **)(a1 + 96);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*((_BYTE *)Copy + 40))
      v13 = 0;
    else
      v13 = (CFHTTPMessageRef)((char *)Copy + 16);
    AuthenticationCache::processRequest(v12, a2, v13);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*((_BYTE *)Copy + 40))
      v14 = 0;
    else
      v14 = (CFHTTPMessageRef)((char *)Copy + 16);
    AuthenticationCache::applyAuthenticationToRequest(a2, v14);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v15 = 0;
    if (*((_BYTE *)Copy + 40))
      v16 = 0;
    else
      v16 = (char *)Copy + 16;
    while (1)
    {
      Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 88));
      v18 = *(const __CFArray **)(a1 + 88);
      if (v15 >= Count)
      {
        CFArrayGetCount(v18);
        v21 = *(_QWORD *)(a1 + 80);
        v22 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
        TubeManager::invalidateKey(v21, v22, 1, 1u);
        v23 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
        if (CFStringCompare(*(CFStringRef *)(v23 + 32), *(CFStringRef *)(v23 + 136), 0))
        {
          (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a2 - 176) + 280))(a2 - 176, 4, 4294965096, 0);
        }
        else
        {
          v24 = *(CFArrayRef **)(a1 + 80);
          v57 = *(_OWORD *)a4;
          v58 = (void (*)(_QWORD *))*((_QWORD *)a4 + 2);
          TubeManager::_onqueue_enqueueRequestForProtocol(v24, a2, a3, &v57, 0);
        }
        goto LABEL_29;
      }
      ValueAtIndex = CFArrayGetValueAtIndex(v18, v15);
      v20 = ValueAtIndex;
      if (ValueAtIndex)
      {
        if (!ValueAtIndex[264]
          && (*((_DWORD *)ValueAtIndex + 44) - 3) >= 2
          && !(*((_QWORD *)ValueAtIndex + 18) | *((unsigned int *)ValueAtIndex + 38)))
        {
          break;
        }
      }
      ++v15;
    }
    *(_BYTE *)(a1 + 104) = 0;
    if (objc_msgSend(*((id *)v11 + 10), "_preconnect"))
    {
      v26 = *((_QWORD *)v20 + 7);
      if (v26)
      {
        if (*(_DWORD *)v26 == 1)
        {
          v28 = *(_QWORD *)(v26 + 8);
          v27 = *(std::__shared_weak_count **)(v26 + 16);
          *(_QWORD *)&v57 = v28;
          *((_QWORD *)&v57 + 1) = v27;
          if (v27)
          {
            p_shared_owners = (unint64_t *)&v27->__shared_owners_;
            do
              v30 = __ldxr(p_shared_owners);
            while (__stxr(v30 + 1, p_shared_owners));
          }
          if (v28)
          {
            v31 = (_BYTE *)(*(uint64_t (**)(URLProtocol *))(*(_QWORD *)v11 + 744))(v11);
            v32 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 248))(v28);
            -[__CFN_TransactionMetrics linkWithConnection:](v31, v32);
            (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v28 + 88))(v28, 1);
          }
        }
        else
        {
          v27 = 0;
          v57 = 0uLL;
        }
        v45 = (IOConnWrapper *)*((_QWORD *)v20 + 7);
        if (v45)
          v44 = (const void *)IOConnWrapper::copyProperty(v45, (const __CFString *)&unk_1EDCFAD40);
        else
          v44 = 0;
      }
      else
      {
        v27 = 0;
        v44 = 0;
        v57 = 0uLL;
      }
      v46 = (void *)*((_QWORD *)v11 + 10);
      if (v46)
        objc_msgSend(v46, "set_TCPConnectionMetadata:", v44);
      if (v44)
        CFRelease(v44);
      v47 = (id *)*((_QWORD *)v20 + 89);
      if (!v47)
      {
        v47 = -[_NSHTTPConnectionInfo initWithHTTPConnectionInfo:queue:]((id *)[_NSHTTPConnectionInfo alloc], v20 + 24, *((void **)v20 + 21));
        *((_QWORD *)v20 + 89) = v47;
      }
      if (v47)
      {
        v48 = *((_QWORD *)v11 + 110);
        if (v48)
          (*(void (**)(void))(v48 + 16))();
      }
      URLProtocol::sendDidFinishLoading(v11);
      v49 = (void *)*((_QWORD *)v20 + 16);
      if (v49)
        dispatch_async(*((dispatch_queue_t *)v20 + 21), v49);
      if (v27)
      {
        v50 = (unint64_t *)&v27->__shared_owners_;
        do
          v51 = __ldaxr(v50);
        while (__stlxr(v51 - 1, v50));
        if (!v51)
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
      }
    }
    else
    {
      v33 = *a4;
      v34 = 0.0;
      if (*((_QWORD *)v20 + 7))
      {
        v35 = *((int *)v20 + 76);
        if (!(CFArrayGetCount(*((CFArrayRef *)v20 + 29)) + v35))
        {
          v36 = *((_QWORD *)v20 + 7);
          if (*(_DWORD *)v36 == 1)
          {
            (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v36 + 8) + 88))(*(_QWORD *)(v36 + 8), 0);
            v37 = *((_QWORD *)v20 + 7);
            if (*(_DWORD *)v37 == 1)
              (*(void (**)(_QWORD))(**(_QWORD **)(v37 + 8) + 248))(*(_QWORD *)(v37 + 8));
          }
          Current = CFAbsoluteTimeGetCurrent();
          v39 = *((_QWORD *)v20 + 7);
          v40 = 0.0;
          if (*(_DWORD *)v39 == 1)
          {
            v41 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v39 + 8) + 248))(*(_QWORD *)(v39 + 8));
            if (v41)
              v40 = *(double *)(v41 + 176);
          }
          v34 = Current - v40;
        }
      }
      v66 = 0;
      v67 = &v66;
      v68 = 0x2020000000;
      v69 = 0;
      *(_QWORD *)&v57 = MEMORY[0x1E0C809B0];
      *((_QWORD *)&v57 + 1) = 3221225472;
      v58 = ___ZN15HTTP2Connection22createStreamAndEnqueueEPK18HTTPRequestMessageP25MetaConnectionCacheClientif_block_invoke;
      v59 = &unk_1E14F7280;
      v60 = &v66;
      v61 = v20;
      v62 = v16;
      v63 = a2;
      v65 = v33;
      v64 = v34;
      ___ZN15HTTP2Connection22createStreamAndEnqueueEPK18HTTPRequestMessageP25MetaConnectionCacheClientif_block_invoke(&v57);
      v42 = v67[3];
      _Block_object_dispose(&v66, 8);
      if (v42)
        v43 = v42 + 8;
      else
        v43 = 0;
      (*(void (**)(uint64_t, uint64_t, char *, _QWORD))(*(_QWORD *)a2 + 80))(a2, v43, v16, *(unsigned __int8 *)(a1 + 104));
      CFRelease((CFTypeRef)(v42 - 16));
    }
  }
LABEL_29:
  if (cf)
    CFRelease(cf);
  return ((uint64_t (*)(_QWORD *))v54)(v53);
}

void sub_183F3A5B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf, char a10, uint64_t a11, void (*a12)(char *), uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a15);
  if (cf)
    CFRelease(cf);
  a12(&a10);
  _Unwind_Resume(a1);
}

uint64_t HTTPProtocol::canUseH2WithCurrentAuthScheme(HTTPProtocol *this, const __CFURL *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  uint64_t v8;

  v4 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 472))(this);
  if (!v4)
    return 1;
  v5 = v4;
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  v6 = *(_QWORD *)(v5 + 40);
  if (!v6)
    return 1;
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  if ((*(_DWORD *)(v6 + 72) - 5) > 1)
    return 1;
  v7 = (__CFString *)CFURLCopyHostName(a2);
  v8 = *((_QWORD *)this + 93);
  if (v8)
    -[NSURLSession addToHTTPFallbackHosts:forbiddenProtocols:](v8, v7, 80);
  (*(void (**)(HTTPProtocol *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)this + 280))(this, 4, 4294965096, 0);
  if (v7)
    CFRelease(v7);
  return 0;
}

void sub_183F3A72C(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t HTTPProtocol::challenge(HTTPProtocol *this)
{
  return *((_QWORD *)this + 47);
}

void ___ZN25HTTP2ConnectionCacheEntry25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN15HTTP2Connection22createStreamAndEnqueueEPK18HTTPRequestMessageP25MetaConnectionCacheClientif_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t Instance;
  _QWORD *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_weak_owners;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  const __CFURL *v16;
  CFStringRef v17;
  NSObject *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  const void *v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  __int128 v35;

  v2 = a1[5];
  if (HTTP2StreamBridge::Class(void)::sOnce_HTTP2StreamBridge != -1)
    dispatch_once(&HTTP2StreamBridge::Class(void)::sOnce_HTTP2StreamBridge, &__block_literal_global_41_8501);
  Instance = _CFRuntimeCreateInstance();
  v4 = (_QWORD *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    v4 = (_QWORD *)(Instance + 16);
    *(_QWORD *)(Instance + 48) = 0;
    *(_OWORD *)(Instance + 32) = 0u;
  }
  v6 = *(_QWORD *)(v2 + 56);
  v5 = *(std::__shared_weak_count **)(v2 + 64);
  if (v5)
  {
    p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
    do
      v8 = __ldxr(p_shared_weak_owners);
    while (__stxr(v8 + 1, p_shared_weak_owners));
  }
  v10 = a1[6];
  v9 = a1[7];
  v11 = a1[8];
  *v4 = &off_1E14E86B0;
  v4[1] = &unk_1E14E8798;
  v4[2] = &unk_1E14E8868;
  v12 = operator new();
  v13 = v12;
  if (v5)
  {
    v14 = (unint64_t *)&v5->__shared_weak_owners_;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  *(_QWORD *)v12 = &off_1E14E4F38;
  *(_QWORD *)(v12 + 8) = &unk_1E14E4FE8;
  *(_QWORD *)(v12 + 88) = 0;
  *(_QWORD *)(v12 + 96) = 0;
  *(_QWORD *)(v12 + 160) = 0;
  *(_QWORD *)(v12 + 184) = 0;
  *(_QWORD *)(v12 + 192) = 0;
  *(_QWORD *)(v12 + 216) = 0;
  *(_QWORD *)(v12 + 224) = 0;
  *(_QWORD *)(v12 + 240) = 0;
  *(_OWORD *)(v12 + 360) = 0u;
  *(_OWORD *)(v12 + 376) = 0u;
  *(_QWORD *)(v12 + 248) = 0;
  *(_OWORD *)(v12 + 264) = 0u;
  *(_OWORD *)(v12 + 280) = 0u;
  *(_QWORD *)(v12 + 328) = 0;
  *(_QWORD *)(v12 + 336) = 0;
  *(_WORD *)(v12 + 352) = 0;
  *(_QWORD *)(v12 + 344) = 0;
  *(_QWORD *)(v12 + 392) = _release_dispatch_safe<NSObject  {objcproto18OS_dispatch_object}*>;
  *(_OWORD *)(v12 + 400) = 0u;
  *(_OWORD *)(v12 + 416) = 0u;
  *(_QWORD *)(v12 + 432) = 0;
  *(_QWORD *)(v12 + 40) = v10;
  CFRetain((CFTypeRef)(v10 - 16));
  v16 = CFHTTPMessageCopyRequestURL((CFHTTPMessageRef)(*(_QWORD *)(v13 + 40) - 16));
  v17 = CFURLGetString(v16);
  CFRetain(v17);
  CFRelease(v16);
  *(_QWORD *)(v13 + 48) = v17;
  *(_QWORD *)(v13 + 16) = v9;
  (*(void (**)(uint64_t))(*(_QWORD *)v9 + 16))(v9);
  *(_DWORD *)(v13 + 56) = 0;
  v18 = *(NSObject **)(v2 + 168);
  *(_QWORD *)(v13 + 72) = v18;
  dispatch_retain(v18);
  *(_QWORD *)(v13 + 64) = v2;
  CFRetain((CFTypeRef)(v2 - 16));
  if (v5)
  {
    v19 = (unint64_t *)&v5->__shared_weak_owners_;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  v21 = *(std::__shared_weak_count **)(v13 + 96);
  *(_QWORD *)(v13 + 88) = v6;
  *(_QWORD *)(v13 + 96) = v5;
  if (v21)
    std::__shared_weak_count::__release_weak(v21);
  *(_QWORD *)(v13 + 208) = 0;
  *(_QWORD *)(v13 + 168) = 0;
  *(_QWORD *)(v13 + 120) = 0;
  *(_QWORD *)(v13 + 136) = 0;
  v22 = *(const void **)(v13 + 240);
  *(_QWORD *)(v13 + 240) = 0;
  if (v22)
    CFRelease(v22);
  *(_QWORD *)(v13 + 144) = 0;
  *(_WORD *)(v13 + 152) = 0;
  *(_BYTE *)(v13 + 176) = 0;
  *(_DWORD *)(v13 + 128) = 0;
  v23 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v13 + 16) + 168))(*(_QWORD *)(v13 + 16));
  *(_QWORD *)(v13 + 104) = v23;
  *(_QWORD *)(v13 + 112) = v23;
  *(_DWORD *)(v13 + 80) = -1;
  *(_WORD *)(v13 + 233) = 16;
  *(_BYTE *)(v13 + 256) = 0;
  *(_DWORD *)(v13 + 200) = 0;
  *(_QWORD *)(v13 + 296) = 0;
  *(_QWORD *)(v13 + 24) = 0;
  *(_QWORD *)(v13 + 32) = 0;
  (*(void (**)(__int128 *__return_ptr))(**(_QWORD **)(v13 + 16) + 72))(&v35);
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v13 + 216, &v35);
  v24 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
  if (*((_QWORD *)&v35 + 1))
  {
    v25 = (unint64_t *)(*((_QWORD *)&v35 + 1) + 8);
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  *(_BYTE *)(v13 + 232) = 0;
  *(_QWORD *)(v13 + 312) = 0;
  *(_BYTE *)(v13 + 320) = 0;
  v35 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v13 + 264, &v35);
  v27 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
  if (*((_QWORD *)&v35 + 1))
  {
    v28 = (unint64_t *)(*((_QWORD *)&v35 + 1) + 8);
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  *(_QWORD *)(v13 + 440) = v11;
  v4[3] = v13;
  v30 = (_QWORD *)operator new();
  *v30 = &off_1E14F1080;
  v30[1] = 0;
  v30[2] = 0;
  v30[3] = v13;
  v4[4] = v30;
  if (v5)
  {
    std::__shared_weak_count::__release_weak(v5);
    v31 = v4[3];
    v30 = (_QWORD *)v4[4];
    if (!v30)
      goto LABEL_34;
  }
  else
  {
    v31 = v4[3];
  }
  v32 = v30 + 2;
  do
    v33 = __ldxr(v32);
  while (__stxr(v33 + 1, v32));
LABEL_34:
  v34 = *(std::__shared_weak_count **)(v31 + 288);
  *(_QWORD *)(v31 + 280) = v31;
  *(_QWORD *)(v31 + 288) = v30;
  if (v34)
    std::__shared_weak_count::__release_weak(v34);
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v4;
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
  CFArrayAppendValue(*(CFMutableArrayRef *)(v2 + 232), *(const void **)(*(_QWORD *)(a1[4] + 8) + 24));
}

void sub_183F3AB3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, DataBuffer *a10, uint64_t a11)
{
  uint64_t v11;
  std::__shared_weak_count *v12;
  uint64_t v13;

  (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
  *(_QWORD *)(v11 + 16) = &off_1E14E5838;
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'HTTPProtocol::getSuspensionThreshold(HTTPProtocol *this)
{
  return objc_msgSend(*((id *)this - 12), "_suspensionThreshhold");
}

void CoalescingDomain::_update_internal_mappings(uint64_t **a1, uint64_t *a2, uint64_t a3, __int128 **a4)
{
  char *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  char *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t *v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  __int128 *v20;
  __int128 *v21;
  uint64_t **v22;
  _QWORD **v23;
  uint64_t **v24;
  uint64_t **v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  uint64_t *v31;
  _QWORD *v32;
  uint64_t *v33;
  __int128 *v34;
  __int128 *v35;
  uint64_t *v36;
  uint64_t **v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *p_shared_owners;
  unint64_t v44;
  uint64_t *v45;
  uint64_t *v46;
  uint64_t *v47;
  uint64_t **v48;
  uint64_t **v49;
  _QWORD *v50;
  _QWORD *v51;
  std::string *v52;
  uint64_t *v53;
  uint64_t *v54;
  void **v55;
  __int128 *v56;
  __int128 *v57;
  unint64_t v58;
  uint64_t v59;
  std::string *v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  std::string *v64;
  uint64_t v65;
  std::string *v66;
  std::string *v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  const std::string *v71;
  __int128 **v72;
  uint64_t **v73;
  char *v74;
  uint64_t **v75;
  uint64_t *v76;
  uint64_t v77;
  _QWORD *v78;
  uint64_t **v79;
  char v80;
  uint64_t *v81;
  char *v82[3];

  v82[2] = *(char **)MEMORY[0x1E0C80C00];
  v8 = (char *)a2[1];
  v81 = (uint64_t *)*a2;
  v82[0] = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v76 = 0;
  v77 = 0;
  v75 = &v76;
  v73 = &v76;
  v11 = (uint64_t *)operator new(0x30uLL);
  v12 = v11;
  v79 = &v76;
  v13 = v82[0];
  v11[4] = (uint64_t)v81;
  v11[5] = (uint64_t)v13;
  if (v13)
  {
    v14 = (unint64_t *)(v13 + 8);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  v80 = 1;
  v16 = (uint64_t *)v73;
  *v11 = 0;
  v11[1] = 0;
  v11[2] = (uint64_t)v16;
  v76 = v11;
  if (*v75)
  {
    v75 = (uint64_t **)*v75;
    v12 = v76;
  }
  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v76, v12);
  ++v77;
  v78 = 0;
  std::unique_ptr<std::__tree_node<std::shared_ptr<__CoalescingConnectionKey>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<__CoalescingConnectionKey>,void *>>>>::reset[abi:nn180100]((uint64_t)&v78);
  v17 = (std::__shared_weak_count *)v82[0];
  if (v82[0])
  {
    v18 = (unint64_t *)(v82[0] + 8);
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = *a4;
  v21 = a4[1];
  v72 = a4;
  if (*a4 != v21)
  {
    do
    {
      v22 = std::__tree<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 3, v20, (uint64_t)v20);
      v23 = v22 + 7;
      v24 = (uint64_t **)std::__tree<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>::__find_equal<std::shared_ptr<__CoalescingConnectionKey>>((uint64_t)(v22 + 7), &v81, (_QWORD *)*a2);
      if (!*v24)
      {
        v25 = v24;
        v26 = (uint64_t *)operator new(0x30uLL);
        v27 = v26;
        v79 = v22 + 8;
        v28 = a2[1];
        v26[4] = *a2;
        v26[5] = v28;
        if (v28)
        {
          v29 = (unint64_t *)(v28 + 8);
          do
            v30 = __ldxr(v29);
          while (__stxr(v30 + 1, v29));
        }
        v80 = 1;
        v31 = v81;
        *v26 = 0;
        v26[1] = 0;
        v26[2] = (uint64_t)v31;
        *v25 = v26;
        v32 = (_QWORD *)**v23;
        if (v32)
        {
          *v23 = v32;
          v27 = *v25;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v22[8], v27);
        v22[9] = (uint64_t *)((char *)v22[9] + 1);
        v78 = 0;
        std::unique_ptr<std::__tree_node<std::shared_ptr<__CoalescingConnectionKey>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<__CoalescingConnectionKey>,void *>>>>::reset[abi:nn180100]((uint64_t)&v78);
      }
      v20 = (__int128 *)((char *)v20 + 24);
    }
    while (v20 != v21);
  }
  v33 = std::__tree<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,std::__map_value_compare<std::shared_ptr<__CoalescingConnectionKey>,std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,CoalescingConnectionKeyComparator,true>,std::allocator<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>>>::__emplace_unique_key_args<std::shared_ptr<__CoalescingConnectionKey>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<__CoalescingConnectionKey> const&>,std::tuple<>>(a1 + 6, (_QWORD *)*a2, a2);
  std::set<std::string>::set[abi:nn180100]((uint64_t)&v81, v33 + 6);
  v35 = *a4;
  v34 = v72[1];
  while (v35 != v34)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(&v81, v35, (uint64_t)v35);
    v35 = (__int128 *)((char *)v35 + 24);
  }
  v36 = std::__tree<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,std::__map_value_compare<std::shared_ptr<__CoalescingConnectionKey>,std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,CoalescingConnectionKeyComparator,true>,std::allocator<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>>>::__emplace_unique_key_args<std::shared_ptr<__CoalescingConnectionKey>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<__CoalescingConnectionKey> const&>,std::tuple<>>(a1 + 6, (_QWORD *)*a2, a2)+ 6;
  if (v36 != (uint64_t *)&v81)
    std::__tree<std::string>::__assign_multi<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>>(v36, v81, v82);
  v37 = std::__tree<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 9, (_QWORD *)a3, a3);
  v39 = *a2;
  v38 = a2[1];
  if (v38)
  {
    v40 = (unint64_t *)(v38 + 8);
    do
      v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
  }
  v42 = (std::__shared_weak_count *)v37[8];
  v37[7] = (uint64_t *)v39;
  v37[8] = (uint64_t *)v38;
  if (v42)
  {
    p_shared_owners = (unint64_t *)&v42->__shared_owners_;
    do
      v44 = __ldaxr(p_shared_owners);
    while (__stlxr(v44 - 1, p_shared_owners));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }
  v45 = std::__tree<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,std::__map_value_compare<std::shared_ptr<__CoalescingConnectionKey>,std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,CoalescingConnectionKeyComparator,true>,std::allocator<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>>>::__emplace_unique_key_args<std::shared_ptr<__CoalescingConnectionKey>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<__CoalescingConnectionKey> const&>,std::tuple<>>(a1 + 12, (_QWORD *)*a2, a2);
  std::set<std::string>::set[abi:nn180100]((uint64_t)&v73, v45 + 6);
  std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)&v73, (_QWORD *)a3, a3);
  v46 = std::__tree<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,std::__map_value_compare<std::shared_ptr<__CoalescingConnectionKey>,std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,CoalescingConnectionKeyComparator,true>,std::allocator<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>>>::__emplace_unique_key_args<std::shared_ptr<__CoalescingConnectionKey>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<__CoalescingConnectionKey> const&>,std::tuple<>>(a1 + 12, (_QWORD *)*a2, a2)+ 6;
  if (v46 != (uint64_t *)&v73)
    std::__tree<std::string>::__assign_multi<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>>(v46, v73, &v74);
  v47 = a1[1];
  v48 = a1 + 1;
  v49 = a1 + 1;
  if (v47)
  {
    while (1)
    {
      while (1)
      {
        v48 = (uint64_t **)v47;
        v50 = v47 + 4;
        if (!std::less<std::string>::operator()[abi:nn180100]((_QWORD *)a3, v47 + 4))
          break;
        v47 = *v48;
        v49 = v48;
        if (!*v48)
          goto LABEL_44;
      }
      if (!std::less<std::string>::operator()[abi:nn180100](v50, (_QWORD *)a3))
        break;
      v49 = v48 + 1;
      v47 = v48[1];
      if (!v47)
        goto LABEL_44;
    }
    v51 = v48;
  }
  else
  {
LABEL_44:
    v51 = operator new(0x50uLL);
    v78 = v51;
    v79 = a1 + 1;
    v80 = 0;
    v52 = (std::string *)(v51 + 4);
    if (*(char *)(a3 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v52, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)&v52->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
      v51[6] = *(_QWORD *)(a3 + 16);
    }
    v51[8] = 0;
    v51[9] = 0;
    v51[7] = 0;
    v80 = 1;
    *v51 = 0;
    v51[1] = 0;
    v51[2] = v48;
    *v49 = v51;
    v53 = (uint64_t *)**a1;
    v54 = v51;
    if (v53)
    {
      *a1 = v53;
      v54 = *v49;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v54);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    v78 = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::vector<std::string>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::vector<std::string>>,void *>>>>::reset[abi:nn180100]((uint64_t)&v78);
  }
  v55 = (void **)(v51 + 7);
  if (v51 + 7 != v72)
  {
    v57 = *v72;
    v56 = v72[1];
    v58 = 0xAAAAAAAAAAAAAAABLL * (((char *)v56 - (char *)*v72) >> 3);
    v59 = v51[9];
    v60 = (std::string *)v51[7];
    if (0xAAAAAAAAAAAAAAABLL * ((v59 - (uint64_t)v60) >> 3) < v58)
    {
      if (v60)
      {
        std::vector<std::string>::__clear[abi:nn180100](v51 + 7);
        operator delete(*v55);
        v59 = 0;
        *v55 = 0;
        v51[8] = 0;
        v51[9] = 0;
      }
      if (v58 > 0xAAAAAAAAAAAAAAALL)
        goto LABEL_79;
      v61 = 0xAAAAAAAAAAAAAAABLL * (v59 >> 3);
      v62 = 2 * v61;
      if (2 * v61 <= v58)
        v62 = v58;
      v63 = v61 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v62;
      if (v63 > 0xAAAAAAAAAAAAAAALL)
LABEL_79:
        abort();
      v64 = (std::string *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v63);
      v51[7] = v64;
      v51[8] = v64;
      v51[9] = &v64[v65];
      v66 = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(v57, v56, v64);
LABEL_69:
      v51[8] = v66;
      goto LABEL_78;
    }
    v67 = (std::string *)v51[8];
    v68 = ((char *)v67 - (char *)v60) >> 3;
    v69 = 0xAAAAAAAAAAAAAAABLL * v68;
    if (0xAAAAAAAAAAAAAAABLL * v68 < v58)
    {
      if (v67 != v60)
      {
        v70 = 8 * v68;
        v71 = (const std::string *)*v72;
        do
        {
          std::string::operator=(v60++, v71++);
          v70 -= 24;
        }
        while (v70);
        v60 = (std::string *)v51[8];
      }
      v66 = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>((__int128 *)((char *)v57 + 24 * v69), v56, v60);
      goto LABEL_69;
    }
    if (v57 != v56)
    {
      do
      {
        std::string::operator=(v60, (const std::string *)v57);
        v57 = (__int128 *)((char *)v57 + 24);
        ++v60;
      }
      while (v57 != v56);
      v67 = (std::string *)v51[8];
    }
    while (v67 != v60)
    {
      if (SHIBYTE(v67[-1].__r_.__value_.__r.__words[2]) < 0)
        operator delete(v67[-1].__r_.__value_.__l.__data_);
      --v67;
    }
    v51[8] = v60;
  }
LABEL_78:
  std::__tree<std::string>::destroy(v74);
  std::__tree<std::string>::destroy(v82[0]);
  std::__tree<std::shared_ptr<void>>::destroy(v76);
}

void sub_183F3B254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char *a11, uint64_t a12, uint64_t a13, _QWORD *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char *a20)
{
  uint64_t v20;
  uint64_t v21;

  *(_QWORD *)(v21 + 64) = v20;
  std::__tree<std::string>::destroy(a11);
  std::__tree<std::string>::destroy(a20);
  std::__tree<std::shared_ptr<void>>::destroy(a14);
  _Unwind_Resume(a1);
}

void std::__tree<std::string>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::string>::destroy(*(_QWORD *)a1);
    std::__tree<std::string>::destroy(*((_QWORD *)a1 + 1));
    if (a1[55] < 0)
      operator delete(*((void **)a1 + 4));
    operator delete(a1);
  }
}

uint64_t *std::__tree<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,std::__map_value_compare<std::shared_ptr<__CoalescingConnectionKey>,std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,CoalescingConnectionKeyComparator,true>,std::allocator<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>>>::__emplace_unique_key_args<std::shared_ptr<__CoalescingConnectionKey>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<__CoalescingConnectionKey> const&>,std::tuple<>>(uint64_t **a1, _QWORD *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  _QWORD *v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t *v16;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v6 = (uint64_t **)v5;
        v8 = (_QWORD *)v5[4];
        if (!std::less<std::string>::operator()[abi:nn180100](a2, v8))
          break;
        v5 = *v6;
        v9 = v6;
        if (!*v6)
          goto LABEL_9;
      }
      if (!std::less<std::string>::operator()[abi:nn180100](v8, a2))
        return (uint64_t *)v6;
      v9 = v6 + 1;
      v5 = v6[1];
      if (!v5)
        goto LABEL_9;
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_9:
    v10 = (uint64_t *)operator new(0x48uLL);
    v11 = v10;
    v12 = a3[1];
    v10[4] = *a3;
    v10[5] = v12;
    if (v12)
    {
      v13 = (unint64_t *)(v12 + 8);
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    v10[8] = 0;
    v10[7] = 0;
    v10[6] = (uint64_t)(v10 + 7);
    *v10 = 0;
    v10[1] = 0;
    v10[2] = (uint64_t)v6;
    *v9 = v10;
    v15 = (uint64_t *)**a1;
    v16 = v10;
    if (v15)
    {
      *a1 = v15;
      v16 = *v9;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v16);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v11;
}

BOOL std::less<std::string>::operator()[abi:nn180100](_QWORD *a1, _QWORD *a2)
{
  int v2;
  int v3;
  size_t v4;
  size_t v5;
  size_t v6;
  int v7;

  v2 = *((char *)a2 + 23);
  v3 = *((char *)a1 + 23);
  if (v3 >= 0)
    v4 = *((unsigned __int8 *)a1 + 23);
  else
    v4 = a1[1];
  if (v3 < 0)
    a1 = (_QWORD *)*a1;
  if (v2 >= 0)
    v5 = *((unsigned __int8 *)a2 + 23);
  else
    v5 = a2[1];
  if (v2 < 0)
    a2 = (_QWORD *)*a2;
  if (v5 >= v4)
    v6 = v4;
  else
    v6 = v5;
  v7 = memcmp(a1, a2, v6);
  if (v7)
    return v7 < 0;
  else
    return v4 < v5;
}

void std::__tree<std::shared_ptr<void>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::shared_ptr<void>>::destroy(*a1);
    std::__tree<std::shared_ptr<void>>::destroy(a1[1]);
    std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void HTTP2Connection::flushBatchedDataForStream(uint64_t **this, HTTP2Stream *a2)
{
  uint64_t **v3;
  NSObject *v4;
  uint64_t *v5;
  uint64_t *v6;
  int v7;
  uint64_t **v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  BOOL v12;
  int v13[2];
  uint64_t *v14;

  v3 = this + 76;
  *(_QWORD *)v13 = a2;
  v14 = (uint64_t *)v13;
  v4 = std::__tree<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,std::__map_value_compare<HTTP2Stream *,std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,BOOL (*)(HTTP2Stream const*,HTTP2Stream const*),false>,std::allocator<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>>>::__emplace_unique_key_args<HTTP2Stream *,std::piecewise_construct_t const&,std::tuple<HTTP2Stream * const&>,std::tuple<>>(this + 76, v13, &v14)[5];
  v5 = this[77];
  if (v5)
  {
    v6 = (uint64_t *)(this + 77);
    do
    {
      v7 = ((uint64_t (*)(uint64_t, _QWORD))this[79])(v5[4], *(_QWORD *)v13);
      v8 = (uint64_t **)(v5 + 1);
      if (!v7)
      {
        v8 = (uint64_t **)v5;
        v6 = v5;
      }
      v5 = *v8;
    }
    while (*v8);
    if (v6 != (uint64_t *)(this + 77)
      && (((uint64_t (*)(_QWORD, uint64_t))this[79])(*(_QWORD *)v13, v6[4]) & 1) == 0)
    {
      v9 = (uint64_t *)v6[1];
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = (uint64_t *)*v9;
        }
        while (v9);
      }
      else
      {
        v11 = v6;
        do
        {
          v10 = (uint64_t *)v11[2];
          v12 = *v10 == (_QWORD)v11;
          v11 = v10;
        }
        while (!v12);
      }
      if (*v3 == v6)
        *v3 = v10;
      this[78] = (uint64_t *)((char *)this[78] - 1);
      std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(this[77], v6);
      operator delete(v6);
    }
  }
  HTTP2Stream::bufferDataFromDataFrame(*(uint64_t *)v13, v4, 1);
  if (v4)
    dispatch_release(v4);
}

uint64_t cf_nghttp2_on_data_chunk_recv_callback(int a1, int a2, int a3, unint64_t a4, size_t length, uint64_t a6)
{
  int v7;
  NSObject *v9;
  unint64_t v10;
  BOOL v11;
  BOOL v12;
  uint64_t *subrange;
  uint64_t appended;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  NSObject *v18;
  uint64_t *stream_user_data;
  uint64_t *v20;
  NSObject *v21;
  dispatch_data_t concat;
  uint64_t *block;
  uint64_t v25;
  void (*v26)(uint64_t);
  void *v27;
  uint64_t v28;
  int v29;
  unsigned int v30;
  uint64_t v31;

  v7 = length;
  v9 = *(NSObject **)(a6 + 88);
  if (!v9
    || ((v10 = *(_QWORD *)(a6 + 96), v10 <= a4) ? (v11 = length == 0) : (v11 = 1),
        !v11 ? (v12 = v10 == 0) : (v12 = 1),
        v12))
  {
    subrange = 0;
    if (!a3)
      goto LABEL_22;
  }
  else
  {
    subrange = (uint64_t *)dispatch_data_create_subrange(v9, a4 - v10, length);
    if (!a3)
      goto LABEL_22;
  }
  if ((a3 & 1) == 0)
  {
    block = subrange;
    v25 = (uint64_t)HTTP2ServerPushStream::safe_data_deleter;
    appended = HTTP2ServerPush::appendDataForStream((uint64_t *)(a6 + 288), (uint64_t)&block, a3, 0);
    if (block)
      ((void (*)(void))v25)();
    HTTP2Connection::_onqueue_manageConnectionWindow((HTTP2Connection *)a6);
    if (appended)
    {
      v15 = *(_DWORD *)(appended + 200);
      v16 = *(_DWORD *)(appended + 204) - v7;
      *(_DWORD *)(appended + 204) = v16;
      if ((double)v15 * 0.7 >= (double)v16)
      {
        if (v15 != 10485760)
          *(_DWORD *)(appended + 200) = 10485760;
        *(_DWORD *)(appended + 204) = 10485760;
        if (v16 != 10485760)
        {
          v17 = 10485760 - v16;
          CFRetain((CFTypeRef)(a6 - 16));
          v18 = *(NSObject **)(a6 + 168);
          block = (uint64_t *)MEMORY[0x1E0C809B0];
          v25 = 3221225472;
          v26 = ___ZN15HTTP2Connection31submitWindowUpdateForPushStreamEii_block_invoke;
          v27 = &__block_descriptor_48_e5_v8__0l;
          v28 = a6;
          v29 = a3;
          v30 = v17;
          dispatch_async(v18, &block);
        }
      }
    }
    return 0;
  }
LABEL_22:
  stream_user_data = (uint64_t *)nghttp2_session_get_stream_user_data();
  if (stream_user_data && *stream_user_data)
  {
    v31 = *stream_user_data;
    block = &v31;
    v20 = std::__tree<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,std::__map_value_compare<HTTP2Stream *,std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,BOOL (*)(HTTP2Stream const*,HTTP2Stream const*),false>,std::allocator<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>>>::__emplace_unique_key_args<HTTP2Stream *,std::piecewise_construct_t const&,std::tuple<HTTP2Stream * const&>,std::tuple<>>((uint64_t **)(a6 + 608), &v31, &block);
    v21 = v20[5];
    if (v21)
    {
      concat = dispatch_data_create_concat((dispatch_data_t)v20[5], (dispatch_data_t)subrange);
      block = &v31;
      std::__tree<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,std::__map_value_compare<HTTP2Stream *,std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,BOOL (*)(HTTP2Stream const*,HTTP2Stream const*),false>,std::allocator<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>>>::__emplace_unique_key_args<HTTP2Stream *,std::piecewise_construct_t const&,std::tuple<HTTP2Stream * const&>,std::tuple<>>((uint64_t **)(a6 + 608), &v31, &block)[5] = (uint64_t)concat;
      dispatch_release(v21);
      dispatch_release((dispatch_object_t)subrange);
    }
    else
    {
      block = &v31;
      std::__tree<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,std::__map_value_compare<HTTP2Stream *,std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,BOOL (*)(HTTP2Stream const*,HTTP2Stream const*),false>,std::allocator<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>>>::__emplace_unique_key_args<HTTP2Stream *,std::piecewise_construct_t const&,std::tuple<HTTP2Stream * const&>,std::tuple<>>((uint64_t **)(a6 + 608), &v31, &block)[5] = (uint64_t)subrange;
    }
  }
  HTTP2Connection::_onqueue_manageConnectionWindow((HTTP2Connection *)a6);
  return 0;
}

void sub_183F3B7FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void (*a11)(void))
{
  if (a10)
    a11();
  _Unwind_Resume(exception_object);
}

uint64_t *std::__tree<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,std::__map_value_compare<HTTP2Stream *,std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,BOOL (*)(HTTP2Stream const*,HTTP2Stream const*),false>,std::allocator<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>>>::__emplace_unique_key_args<HTTP2Stream *,std::piecewise_construct_t const&,std::tuple<HTTP2Stream * const&>,std::tuple<>>(uint64_t **a1, _QWORD *a2, uint64_t **a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = a1[1];
  if (!v5)
  {
    v8 = a1 + 1;
LABEL_10:
    v9 = (uint64_t *)operator new(0x30uLL);
    v9[4] = **a3;
    v9[5] = 0;
    *v9 = 0;
    v9[1] = 0;
    v9[2] = (uint64_t)v8;
    *v6 = v9;
    v10 = (uint64_t *)**a1;
    v11 = v9;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    return v9;
  }
  while (1)
  {
    while (1)
    {
      v8 = (uint64_t **)v5;
      if (!((unsigned int (*)(_QWORD, uint64_t))a1[3])(*a2, v5[4]))
        break;
      v5 = *v8;
      v6 = v8;
      if (!*v8)
        goto LABEL_10;
    }
    if (!((unsigned int (*)(uint64_t *, _QWORD))a1[3])(v8[4], *a2))
      break;
    v6 = v8 + 1;
    v5 = v8[1];
    if (!v5)
      goto LABEL_10;
  }
  v9 = *v6;
  if (!*v6)
    goto LABEL_10;
  return v9;
}

BOOL HTTP2Connection::HTTP2Connection(__CFAllocator const*)::$_0::__invoke(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 80) < *(_DWORD *)(a2 + 80);
}

void HTTP2Connection::_onqueue_manageConnectionWindow(HTTP2Connection *this)
{
  if (*((_QWORD *)this + 20))
  {
    nghttp2_session_consume_connection();
    if (!*((_BYTE *)this + 81))
      HTTP2Connection::_onqueue_scheduleIO(this);
  }
}

void HTTP2Stream::bufferDataFromDataFrame(uint64_t a1, dispatch_object_t object, int a3)
{
  _QWORD *v6;
  unint64_t v7;
  NSObject *v8;
  dispatch_data_t concat;
  uint64_t v10;
  NSObject *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *p_shared_weak_owners;
  unint64_t v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  char v23;
  uint64_t v24;
  NSObject *v25;
  dispatch_time_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  NSObject *v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t handler;
  uint64_t v42;
  void (*v43)(_QWORD *);
  void *v44;
  _QWORD *v45;
  uint64_t v46;
  std::__shared_weak_count *v47;

  v6 = (_QWORD *)(a1 + 360);
  v7 = *(_QWORD *)(a1 + 368);
  if (!object)
  {
LABEL_4:
    if (v7 < 0x10000)
      goto LABEL_6;
    goto LABEL_5;
  }
  if (!(v7 >> 16))
  {
    v7 += dispatch_data_get_size(object);
    *(_QWORD *)(a1 + 368) = v7;
    goto LABEL_4;
  }
LABEL_5:
  if (!*(_QWORD *)(a1 + 400) && *(double *)(a1 + 376) != 0.0 && *v6)
  {
    v11 = *(NSObject **)(a1 + 72);
    v12 = *(std::__shared_weak_count **)(a1 + 288);
    if (v12 && (v13 = std::__shared_weak_count::lock(v12)) != 0)
    {
      v14 = v13;
      v15 = *(_QWORD *)(a1 + 280);
      if (v15)
        v16 = v15 + 8;
      else
        v16 = 0;
      p_shared_weak_owners = (unint64_t *)&v13->__shared_weak_owners_;
      do
        v18 = __ldxr(p_shared_weak_owners);
      while (__stxr(v18 + 1, p_shared_weak_owners));
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        v20 = __ldaxr(p_shared_owners);
      while (__stlxr(v20 - 1, p_shared_owners));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v14);
      }
      *(_QWORD *)(a1 + 408) = v11;
      dispatch_retain(v11);
      v21 = (unint64_t *)&v14->__shared_weak_owners_;
      do
        v22 = __ldxr(v21);
      while (__stxr(v22 + 1, v21));
      v23 = 0;
    }
    else
    {
      *(_QWORD *)(a1 + 408) = v11;
      dispatch_retain(v11);
      v14 = 0;
      v16 = 0;
      v23 = 1;
    }
    v33 = *(std::__shared_weak_count **)(a1 + 424);
    *(_QWORD *)(a1 + 416) = v16;
    *(_QWORD *)(a1 + 424) = v14;
    if (v33)
      std::__shared_weak_count::__release_weak(v33);
    v34 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(a1 + 408));
    *(_QWORD *)(a1 + 400) = v34;
    v35 = *(_QWORD *)(a1 + 416);
    v36 = *(std::__shared_weak_count **)(a1 + 424);
    if (v36)
    {
      v37 = (unint64_t *)&v36->__shared_weak_owners_;
      do
        v38 = __ldxr(v37);
      while (__stxr(v38 + 1, v37));
      v34 = *(NSObject **)(a1 + 400);
    }
    handler = MEMORY[0x1E0C809B0];
    v42 = 3321888768;
    v43 = ___ZN10DataBuffer19initializeBufferingEPU28objcproto17OS_dispatch_queue8NSObjectNSt3__18weak_ptrI18DataBufferDelegateEE_block_invoke;
    v44 = &__block_descriptor_56_e8_40c43_ZTSNSt3__18weak_ptrI18DataBufferDelegateEE_e5_v8__0l;
    v45 = v6;
    v46 = v35;
    v47 = v36;
    if (v36)
    {
      v39 = (unint64_t *)&v36->__shared_weak_owners_;
      do
        v40 = __ldxr(v39);
      while (__stxr(v40 + 1, v39));
    }
    dispatch_source_set_event_handler(v34, &handler);
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 400), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_resume(*(dispatch_object_t *)(a1 + 400));
    if (v47)
      std::__shared_weak_count::__release_weak(v47);
    if (v36)
      std::__shared_weak_count::__release_weak(v36);
    if ((v23 & 1) == 0)
      std::__shared_weak_count::__release_weak(v14);
  }
LABEL_6:
  if (*(_QWORD *)(a1 + 400))
  {
    if (object)
    {
      v8 = *(NSObject **)(a1 + 384);
      if (v8)
      {
        concat = dispatch_data_create_concat(v8, object);
        v10 = *(_QWORD *)(a1 + 384);
        *(_QWORD *)(a1 + 384) = concat;
        if (v10)
          (*(void (**)(void))(a1 + 392))();
        *(_QWORD *)(a1 + 392) = _release_dispatch_safe<NSObject  {objcproto18OS_dispatch_object}*>;
      }
      else
      {
        dispatch_retain(object);
        v24 = *(_QWORD *)(a1 + 384);
        *(_QWORD *)(a1 + 384) = object;
        if (v24)
          (*(void (**)(void))(a1 + 392))();
        *(_QWORD *)(a1 + 392) = _release_dispatch_safe<NSObject  {objcproto18OS_dispatch_object}*>;
        v25 = *(NSObject **)(a1 + 400);
        v26 = dispatch_time(0x8000000000000000, (uint64_t)(*(double *)(a1 + 376) * 1000000000.0));
        dispatch_source_set_timer(v25, v26, 0xFFFFFFFFFFFFFFFFLL, 0x3E8uLL);
      }
      if (dispatch_data_get_size(*(dispatch_data_t *)(a1 + 384)) >= *(_QWORD *)(a1 + 360))
      {
        dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 400), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
        v27 = *(std::__shared_weak_count **)(a1 + 424);
        handler = *(_QWORD *)(a1 + 416);
        v42 = (uint64_t)v27;
        if (v27)
        {
          v28 = (unint64_t *)&v27->__shared_weak_owners_;
          do
            v29 = __ldxr(v28);
          while (__stxr(v29 + 1, v28));
        }
        DataBuffer::_flushData(&handler, (uint64_t)v6);
        if (v27)
          std::__shared_weak_count::__release_weak(v27);
      }
    }
    if (a3)
    {
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 400), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
      v30 = *(std::__shared_weak_count **)(a1 + 424);
      handler = *(_QWORD *)(a1 + 416);
      v42 = (uint64_t)v30;
      if (v30)
      {
        v31 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          v32 = __ldxr(v31);
        while (__stxr(v32 + 1, v31));
      }
      DataBuffer::_flushData(&handler, (uint64_t)v6);
      if (v30)
        std::__shared_weak_count::__release_weak(v30);
    }
  }
  else if (object)
  {
    (*(void (**)(uint64_t, dispatch_object_t))(*(_QWORD *)a1 + 152))(a1, object);
  }
}

void sub_183F3BCF8(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;

  if (v1)
    std::__shared_weak_count::__release_weak(v1);
  _Unwind_Resume(exception_object);
}

uint64_t *std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(uint64_t **a1, _QWORD *a2, uint64_t a3)
{
  uint64_t *result;
  uint64_t **v6;
  uint64_t *v7;
  uint64_t v8;

  result = std::__tree<std::string>::__find_equal<std::string>((uint64_t)a1, &v8, a2);
  if (!*result)
  {
    v6 = (uint64_t **)result;
    std::__tree<std::string>::__construct_node<std::string const&>((uint64_t)&v7, (uint64_t)a1, a3);
    return std::__tree<std::string>::__insert_node_at(a1, v8, v6, v7);
  }
  return result;
}

_QWORD *std::__tree<std::string>::__assign_multi<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>>(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t **v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t *v11;
  uint64_t **v12;
  uint64_t **v13;
  _QWORD *v14;
  BOOL v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t **v18;
  uint64_t **v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t *v24;

  v5 = (uint64_t)result;
  if (result[2])
  {
    v6 = *result;
    v8 = (uint64_t **)(result + 1);
    v7 = result[1];
    *result = result + 1;
    *(_QWORD *)(v7 + 16) = 0;
    result[1] = 0;
    result[2] = 0;
    if (*(_QWORD *)(v6 + 8))
      v9 = *(uint64_t **)(v6 + 8);
    else
      v9 = (uint64_t *)v6;
    v22 = result;
    v23 = v9;
    v24 = v9;
    if (v9)
    {
      v23 = std::__tree<std::string>::_DetachedTreeCache::__detach_next((uint64_t)v9);
      if (a2 != a3)
      {
        v10 = a2;
        do
        {
          std::string::operator=((std::string *)(v9 + 4), (const std::string *)(v10 + 4));
          v11 = *v8;
          v12 = (uint64_t **)(v5 + 8);
          v13 = (uint64_t **)(v5 + 8);
          if (*v8)
          {
            do
            {
              while (1)
              {
                v12 = (uint64_t **)v11;
                if (!std::less<std::string>::operator()[abi:nn180100](v24 + 4, v11 + 4))
                  break;
                v11 = *v12;
                v13 = v12;
                if (!*v12)
                  goto LABEL_14;
              }
              v11 = v12[1];
            }
            while (v11);
            v13 = v12 + 1;
          }
LABEL_14:
          std::__tree<std::string>::__insert_node_at((uint64_t **)v5, (uint64_t)v12, v13, v24);
          v9 = v23;
          v24 = v23;
          if (v23)
            v23 = std::__tree<std::string>::_DetachedTreeCache::__detach_next((uint64_t)v23);
          v14 = (_QWORD *)v10[1];
          if (v14)
          {
            do
            {
              a2 = v14;
              v14 = (_QWORD *)*v14;
            }
            while (v14);
          }
          else
          {
            do
            {
              a2 = (_QWORD *)v10[2];
              v15 = *a2 == (_QWORD)v10;
              v10 = a2;
            }
            while (!v15);
          }
          if (!v9)
            break;
          v10 = a2;
        }
        while (a2 != a3);
      }
    }
    result = (_QWORD *)std::__tree<std::string>::_DetachedTreeCache::~_DetachedTreeCache[abi:nn180100]((uint64_t)&v22);
  }
  if (a2 != a3)
  {
    do
    {
      std::__tree<std::string>::__construct_node<std::string const&>((uint64_t)&v22, v5, (uint64_t)(a2 + 4));
      v16 = v22;
      v17 = *(uint64_t **)(v5 + 8);
      v18 = (uint64_t **)(v5 + 8);
      v19 = (uint64_t **)(v5 + 8);
      if (v17)
      {
        do
        {
          while (1)
          {
            v18 = (uint64_t **)v17;
            if (!std::less<std::string>::operator()[abi:nn180100](v16 + 4, v17 + 4))
              break;
            v17 = *v18;
            v19 = v18;
            if (!*v18)
              goto LABEL_31;
          }
          v17 = v18[1];
        }
        while (v17);
        v19 = v18 + 1;
      }
LABEL_31:
      result = std::__tree<std::string>::__insert_node_at((uint64_t **)v5, (uint64_t)v18, v19, v16);
      v20 = (_QWORD *)a2[1];
      if (v20)
      {
        do
        {
          v21 = v20;
          v20 = (_QWORD *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          v21 = (_QWORD *)a2[2];
          v15 = *v21 == (_QWORD)a2;
          a2 = v21;
        }
        while (!v15);
      }
      a2 = v21;
    }
    while (v21 != a3);
  }
  return result;
}

void sub_183F3BF84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__tree<std::string>::_DetachedTreeCache::~_DetachedTreeCache[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::string>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void std::__tree<std::string>::__construct_node<std::string const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  char *v6;
  std::string *v7;

  v5 = a2 + 8;
  v6 = (char *)operator new(0x38uLL);
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + 8) = v5;
  *(_BYTE *)(a1 + 16) = 0;
  v7 = (std::string *)(v6 + 32);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v7->__r_.__value_.__r.__words[2] = *(_QWORD *)(a3 + 16);
  }
  *(_BYTE *)(a1 + 16) = 1;
}

void sub_183F3C05C(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::string,void *>>>::operator()[abi:nn180100](0, v2);
  _Unwind_Resume(a1);
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      abort();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

_QWORD *std::__tree<std::string>::__find_equal<std::string>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v7;
  _QWORD *v8;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v7 = v4;
        v8 = v4 + 4;
        if (!std::less<std::string>::operator()[abi:nn180100](a3, v4 + 4))
          break;
        v4 = (_QWORD *)*v7;
        v5 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (!std::less<std::string>::operator()[abi:nn180100](v8, a3))
        break;
      v5 = v7 + 1;
      v4 = (_QWORD *)v7[1];
    }
    while (v4);
  }
  else
  {
    v7 = (_QWORD *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t **std::__tree<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, _QWORD *a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t **v8;
  _QWORD *v10;
  _QWORD *v11;
  std::string *v12;
  uint64_t *v13;
  uint64_t *v14;
  _QWORD v16[2];
  char v17;

  v6 = a1 + 1;
  v5 = a1[1];
  v7 = a1 + 1;
  v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v10 = v5 + 4;
        if (!std::less<std::string>::operator()[abi:nn180100](a2, v5 + 4))
          break;
        v5 = *v7;
        v8 = v7;
        if (!*v7)
          goto LABEL_7;
      }
      if (!std::less<std::string>::operator()[abi:nn180100](v10, a2))
        return v7;
      v8 = v7 + 1;
      v5 = v7[1];
      if (!v5)
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    v11 = operator new(0x50uLL);
    v16[0] = v11;
    v16[1] = v6;
    v17 = 0;
    v12 = (std::string *)(v11 + 4);
    if (*(char *)(a3 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v12, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)&v12->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
      v11[6] = *(_QWORD *)(a3 + 16);
    }
    v11[9] = 0;
    v11[8] = 0;
    v11[7] = v11 + 8;
    v17 = 1;
    *v11 = 0;
    v11[1] = 0;
    v11[2] = v7;
    *v8 = v11;
    v13 = (uint64_t *)**a1;
    v14 = v11;
    if (v13)
    {
      *a1 = v13;
      v14 = *v8;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v14);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    v16[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,void *>>>>::reset[abi:nn180100]((uint64_t)v16);
  }
  return (uint64_t **)v11;
}

void sub_183F3C2C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,void *>>>>::reset[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, _QWORD *a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t **v8;
  _QWORD *v10;
  _QWORD *v11;
  std::string *v12;
  uint64_t *v13;
  uint64_t *v14;
  _QWORD v16[2];
  char v17;

  v6 = a1 + 1;
  v5 = a1[1];
  v7 = a1 + 1;
  v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v10 = v5 + 4;
        if (!std::less<std::string>::operator()[abi:nn180100](a2, v5 + 4))
          break;
        v5 = *v7;
        v8 = v7;
        if (!*v7)
          goto LABEL_7;
      }
      if (!std::less<std::string>::operator()[abi:nn180100](v10, a2))
        return v7;
      v8 = v7 + 1;
      v5 = v7[1];
      if (!v5)
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    v11 = operator new(0x48uLL);
    v16[0] = v11;
    v16[1] = v6;
    v17 = 0;
    v12 = (std::string *)(v11 + 4);
    if (*(char *)(a3 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v12, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)&v12->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
      v11[6] = *(_QWORD *)(a3 + 16);
    }
    v11[7] = 0;
    v11[8] = 0;
    v17 = 1;
    *v11 = 0;
    v11[1] = 0;
    v11[2] = v7;
    *v8 = v11;
    v13 = (uint64_t *)**a1;
    v14 = v11;
    if (v13)
    {
      *a1 = v13;
      v14 = *v8;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v14);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    v16[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,void *>>>>::reset[abi:nn180100]((uint64_t)v16);
  }
  return (uint64_t **)v11;
}

void sub_183F3C408(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,void *>>>>::reset[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *std::__tree<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>::__find_equal<std::shared_ptr<__CoalescingConnectionKey>>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v7;
  _QWORD *v8;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v7 = v4;
        v8 = (_QWORD *)v4[4];
        if (!std::less<std::string>::operator()[abi:nn180100](a3, v8))
          break;
        v4 = (_QWORD *)*v7;
        v5 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (!std::less<std::string>::operator()[abi:nn180100](v8, a3))
        break;
      v5 = v7 + 1;
      v4 = (_QWORD *)v7[1];
    }
    while (v4);
  }
  else
  {
    v7 = (_QWORD *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

CFArrayRef NWIOConnection::copyIPAddresses(NWIOConnection *this)
{
  const void *v1;
  const void *v2;
  CFArrayRef v3;
  const void *v5[2];

  v5[1] = *(const void **)MEMORY[0x1E0C80C00];
  v1 = (const void *)(*(uint64_t (**)(NWIOConnection *, uint64_t))(*(_QWORD *)this + 216))(this, 0x1EDCF93A8);
  v5[0] = v1;
  if (!v1)
    return 0;
  v2 = v1;
  v3 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v5, 1, MEMORY[0x1E0C9B378]);
  CFRelease(v2);
  return v3;
}

void sub_183F3C554(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t HTTP3Stream::getProxy@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(this + 288);
  *a2 = *(_QWORD *)(this + 280);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

uint64_t HTTP3Stream::canScheduleAndOpenWithHandlerAsync(HTTP3Stream *this)
{
  return 1;
}

void HTTP3Stream::setBodyStreamBeforeOpening(HTTP3Stream *this, CFTypeRef cf, uint64_t a3)
{
  std::__shared_weak_count_vtbl *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  const __CFData *v18;
  std::__shared_weak_count_vtbl *v19;
  uint64_t v20;
  _QWORD *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  __int128 v29;
  std::__shared_weak_count_vtbl *v30;
  std::__shared_weak_count *v31;
  std::__shared_weak_count_vtbl *v32;
  std::__shared_weak_count *v33;

  if (cf)
    v5 = (std::__shared_weak_count_vtbl *)CFRetain(cf);
  else
    v5 = 0;
  v30 = v5;
  v6 = (std::__shared_weak_count *)operator new();
  v6->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F15C0;
  v6->__shared_weak_owners_ = 0;
  v6[1].__vftable = v5;
  v31 = v6;
  if (v5)
  {
    v8 = v6;
    v9 = *((_QWORD *)this + 37);
    v10 = operator new(0xE0uLL);
    v11 = v10;
    v10[1] = 0;
    v10[2] = 0;
    *v10 = &off_1E14F0BE8;
    v12 = (uint64_t)(v10 + 3);
    v32 = v5;
    v33 = v8;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    RequestBodyStream::RequestBodyStream((uint64_t)(v10 + 3), (uint64_t *)&v32, *((dispatch_object_t *)this + 5), v9, a3, 0, 0);
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    *(_QWORD *)&v29 = v12;
    *((_QWORD *)&v29 + 1) = v11;
    std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&v29, v11 + 4, v12);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 96, &v29);
    v15 = (std::__shared_weak_count *)*((_QWORD *)&v29 + 1);
    if (*((_QWORD *)&v29 + 1))
    {
      v16 = (unint64_t *)(*((_QWORD *)&v29 + 1) + 8);
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      goto LABEL_14;
    }
  }
  else
  {
    v18 = CFHTTPMessageCopyBody((CFHTTPMessageRef)(*((_QWORD *)this + 8) - 16));
    v19 = (std::__shared_weak_count_vtbl *)v18;
    if (!v18)
      goto LABEL_27;
    if (CFDataGetLength(v18) < 1)
    {
      CFRelease(v19);
      goto LABEL_27;
    }
    v20 = *((_QWORD *)this + 37);
    v21 = operator new(0x98uLL);
    v21[1] = 0;
    v21[2] = 0;
    *v21 = &off_1E14F0B08;
    v32 = v19;
    v22 = (std::__shared_weak_count *)operator new();
    v22->__shared_owners_ = 0;
    v23 = (unint64_t *)&v22->__shared_owners_;
    v22->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1A90;
    v22->__shared_weak_owners_ = 0;
    v22[1].__vftable = v19;
    v33 = v22;
    RequestBody::RequestBody((uint64_t)(v21 + 3), *((dispatch_object_t *)this + 5), v20, a3);
    v21[17] = 0;
    v21[3] = &off_1E14E7BE8;
    v21[6] = &unk_1E14E7C58;
    v21[18] = 0;
    std::shared_ptr<__CFString const>::operator=[abi:nn180100](v21 + 17, (uint64_t)v19, (uint64_t)v22);
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
    *(_QWORD *)&v29 = v21 + 3;
    *((_QWORD *)&v29 + 1) = v21;
    std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&v29, v21 + 4, (uint64_t)(v21 + 3));
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 96, &v29);
    v15 = (std::__shared_weak_count *)*((_QWORD *)&v29 + 1);
    if (*((_QWORD *)&v29 + 1))
    {
      v25 = (unint64_t *)(*((_QWORD *)&v29 + 1) + 8);
      do
        v17 = __ldaxr(v25);
      while (__stlxr(v17 - 1, v25));
LABEL_14:
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
LABEL_27:
  v26 = v31;
  if (v31)
  {
    v27 = (unint64_t *)&v31->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
}

void sub_183F3C894(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  std::__shared_weak_count *v3;
  void *v5;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::__shared_weak_count::~__shared_weak_count(v3);
  operator delete(v5);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HTTP3Stream::scheduleAndOpenWithHandler(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  void (**v9)(_QWORD, _QWORD);
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  id v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  _QWORD *v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  void *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  const __CFAllocator *v31;
  uint64_t v32;
  id *v33;
  char v34;
  int v35;
  char v36;
  unint64_t *v37;
  unint64_t v38;
  uint64_t v39;
  int v40;
  double v41;
  void *v42;
  const void *v43;
  NSString *v44;
  const __CFURL *v45;
  __CFString *v46;
  __CFString *v47;
  NSString *v48;
  CFDictionaryRef v49;
  uint64_t v50;
  _BYTE *v51;
  _BYTE *v52;
  size_t v53;
  char *v54;
  char *v55;
  std::__shared_weak_count *v56;
  std::__shared_weak_count *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  void *v61;
  unint64_t *v62;
  unint64_t v63;
  uint64_t v64;
  std::__shared_weak_count *v65;
  unint64_t *v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  id v70;
  unint64_t *v71;
  unint64_t v72;
  void *v73;
  size_t v74;
  _QWORD *v75;
  __int128 *v76;
  unint64_t *v77;
  unint64_t v78;
  uint64_t hasPromised;
  uint64_t v80;
  int v81;
  uint64_t v82;
  uint64_t *v83;
  uint64_t v84;
  unint64_t *v85;
  unint64_t v86;
  int v87;
  uint64_t v88;
  std::__shared_weak_count *v89;
  unint64_t *v90;
  unint64_t v91;
  std::__shared_weak_count *v92;
  unint64_t *v93;
  unint64_t v94;
  std::__shared_weak_count *v95;
  unint64_t *v96;
  unint64_t v97;
  std::__shared_weak_count *v98;
  unint64_t *v99;
  unint64_t v100;
  std::__shared_weak_count *v101;
  unint64_t *v102;
  unint64_t v103;
  uint64_t v104;
  void *v105;
  void *v106;
  std::__shared_weak_count *v107;
  unint64_t *v108;
  unint64_t v109;
  std::__shared_weak_count *v110;
  unint64_t *v111;
  unint64_t v112;
  std::__shared_weak_count *v113;
  unint64_t *v114;
  unint64_t v115;
  std::__shared_weak_count *v117;
  unint64_t *v118;
  unint64_t v119;
  unint64_t *v120;
  void *v121;
  id v122;
  id v123;
  _QWORD v124[7];
  std::__shared_weak_count *v125;
  void *v126;
  char *v127;
  char *v128;
  void *v129[4];
  uint64_t v130;
  std::__shared_weak_count *v131;
  uint64_t v132;
  uint64_t *v133;
  uint64_t v134;
  char v135;
  uint64_t v136;
  std::__shared_weak_count *v137;
  uint64_t v138;
  std::__shared_weak_count *v139;
  void *v140;
  char *v141;
  char *v142;
  void *v143;
  int *v144;
  uint64_t v145;
  __int128 v146;
  uint64_t v147;
  void *v148;
  void *v149;
  __int128 v150;
  __int128 v151;
  void *__p;
  void *v153;
  uint64_t v154;
  uint64_t v155;
  void (*v156)(uint64_t *, __int128 *, uint64_t);
  void *v157;
  __int128 *v158;
  uint64_t v159;
  uint64_t v160;
  std::__shared_weak_count *v161;
  uint64_t v162;
  std::__shared_weak_count *v163;
  NSString *v164;
  uint64_t v165;
  void (*v166)(uint64_t);
  void *v167;
  uint64_t *v168;
  uint64_t v169;
  int v170;
  uint64_t v171;
  std::__shared_weak_count *v172;
  _QWORD v173[6];

  v7 = a3;
  v8 = a4;
  v9 = (void (**)(_QWORD, _QWORD))v8;
  if (*(_BYTE *)(a1 + 369))
  {
    v10 = *(std::__shared_weak_count **)(a1 + 56);
    if (v10)
    {
      v11 = std::__shared_weak_count::lock(v10);
      *((_QWORD *)&v146 + 1) = v11;
      if (v11)
      {
        v12 = *(_QWORD *)(a1 + 48);
        *(_QWORD *)&v146 = v12;
        if (v12)
        {
          v13 = *(_QWORD *)(v12 + 1008);
          v14 = *(std::__shared_weak_count **)(v12 + 1016);
          v154 = v13;
          v155 = (uint64_t)v14;
          if (v14)
          {
            p_shared_owners = (unint64_t *)&v14->__shared_owners_;
            do
              v16 = __ldxr(p_shared_owners);
            while (__stxr(v16 + 1, p_shared_owners));
          }
          if (v13)
          {
            v17 = *(_QWORD *)(a1 + 296);
            if (v17)
              v18 = v17 - 176;
            else
              v18 = 0;
            v19 = *(id *)(v18 + 80);
            (*(void (**)(uint64_t, id, uint64_t, _QWORD))(*(_QWORD *)v13 + 280))(v13, v19, 5, 0);
            *(_BYTE *)(a1 + 368) = 1;

          }
          if (v14)
          {
            v20 = (unint64_t *)&v14->__shared_owners_;
            do
              v21 = __ldaxr(v20);
            while (__stlxr(v21 - 1, v20));
            if (!v21)
            {
              ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
              std::__shared_weak_count::__release_weak(v14);
            }
          }
          v22 = (std::__shared_weak_count *)*((_QWORD *)&v146 + 1);
          if (!*((_QWORD *)&v146 + 1))
            goto LABEL_41;
        }
        else
        {
          v22 = v11;
        }
        v37 = (unint64_t *)&v22->__shared_owners_;
        do
          v38 = __ldaxr(v37);
        while (__stlxr(v38 - 1, v37));
        if (!v38)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
    }
LABEL_41:
    (*(void (**)(void))(*(_QWORD *)(a1 + 376) + 16))();
    goto LABEL_154;
  }
  v122 = v7;
  v123 = v8;
  if (a2)
    (*(void (**)(void *))(*(_QWORD *)a2 + 40))(a2);
  *(_QWORD *)&v146 = a2;
  v23 = (_QWORD *)operator new();
  *v23 = &off_1E14F1668;
  v23[1] = 0;
  v23[2] = 0;
  v23[3] = a2;
  *((_QWORD *)&v146 + 1) = v23;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 312, &v146);
  v24 = (std::__shared_weak_count *)*((_QWORD *)&v146 + 1);
  if (*((_QWORD *)&v146 + 1))
  {
    v25 = (unint64_t *)(*((_QWORD *)&v146 + 1) + 8);
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  v27 = _Block_copy(v7);
  v28 = *(void **)(a1 + 328);
  *(_QWORD *)(a1 + 328) = v27;

  *(_QWORD *)&v146 = 0;
  *((_QWORD *)&v146 + 1) = &v146;
  v147 = 0x6012000000;
  v148 = __Block_byref_object_copy__5408;
  v149 = __Block_byref_object_dispose__5409;
  *(_QWORD *)&v150 = &unk_18422E08D;
  HTTP3Fields::HTTP3Fields((HTTP3Fields *)((char *)&v150 + 8));
  v29 = *(_QWORD *)(a1 + 96);
  if (v29)
    v30 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v29 + 56))(v29);
  else
    v30 = 0;
  v31 = (const __CFAllocator *)(*(_QWORD *)(a1 + 64) - 16);
  v32 = *(_QWORD *)(a1 + 296);
  if (v32)
    v33 = (id *)(v32 - 176);
  else
    v33 = 0;
  cleanUpRequest((__CFHTTPMessage *)(*(_QWORD *)(a1 + 64) - 16), v30, 1, 0, v33);
  if (!HTTPMessage::hasHeaderField(*(os_unfair_lock_s **)(a1 + 64), 0x13311343u))
  {
    v34 = *(_BYTE *)(a1 + 124);
    v35 = *(unsigned __int8 *)(a1 + 125);
    LOWORD(v154) = 15733;
    BYTE2(v154) = v34 + 48;
    if (v35)
    {
      WORD2(v154) = 26912;
      BYTE6(v154) = 0;
      v36 = 44;
    }
    else
    {
      v36 = 0;
    }
    BYTE3(v154) = v36;
    HTTPMessage::setHeaderFieldStringValue(*(HTTPMessage **)(a1 + 64), 0x13311343u, (const void *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", &v154, (char *)&v150 + 8));
  }
  HTTPMessage::setVersion(*(_QWORD *)(a1 + 64), 0x19911742u);
  v121 = a2;
  v39 = *(_QWORD *)(a1 + 296);
  if (v39)
  {
    v40 = objc_msgSend(*(id *)(v39 - 96), "_cachePolicy");
    objc_msgSend(*(id *)(v39 - 96), "_timeoutInterval");
  }
  else
  {
    v40 = 0;
    v41 = 0.0;
  }
  v42 = (void *)_constructRequestFromParts(v31, 0, (const __CFArray *)v40, NSURLRequestUseProtocolCachePolicy, v41, 0);
  -[__CFN_TransactionMetrics setTransferredRequest:](*(_QWORD *)(a1 + 344), v42);

  v43 = *(const void **)(*(_QWORD *)(a1 + 64) + 152);
  if (v43)
    v44 = (NSString *)CFRetain(v43);
  else
    v44 = 0;
  HTTP3Fields::appendField((std::vector<char> *)(*((_QWORD *)&v146 + 1) + 48), ":method", v44);
  v45 = (const __CFURL *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*(_QWORD *)(a1 + 64) + 128));
  v46 = (__CFString *)CFURLCopyScheme(v45);
  HTTP3Fields::appendField((std::vector<char> *)(*((_QWORD *)&v146 + 1) + 48), ":scheme", &v46->isa);
  v47 = (__CFString *)CFHTTPMessageCopyHeaderFieldValue(v31, (CFStringRef)&gConstantCFStringValueTable[2065]);
  HTTP3Fields::appendField((std::vector<char> *)(*((_QWORD *)&v146 + 1) + 48), ":authority", &v47->isa);
  HTTPUtilities::createPathStringFromURL((HTTPUtilities *)&v164, v45);
  v48 = v164;
  HTTP3Fields::appendField((std::vector<char> *)(*((_QWORD *)&v146 + 1) + 48), ":path", v164);
  v49 = HTTPMessage::copyAsMultiValueDict(*(HTTPMessage **)(a1 + 64));
  v154 = MEMORY[0x1E0C809B0];
  v155 = 3221225472;
  v156 = (void (*)(uint64_t *, __int128 *, uint64_t))___ZN11HTTP3Stream20_buildRequestHeadersEv_block_invoke;
  v157 = &unk_1E14F9060;
  v158 = &v146;
  -[__CFDictionary enumerateKeysAndObjectsUsingBlock:](v49, "enumerateKeysAndObjectsUsingBlock:", &v154);
  v50 = *((_QWORD *)&v146 + 1);
  v141 = 0;
  v142 = 0;
  v140 = 0;
  v52 = *(_BYTE **)(*((_QWORD *)&v146 + 1) + 48);
  v51 = *(_BYTE **)(*((_QWORD *)&v146 + 1) + 56);
  v53 = v51 - v52;
  if (v51 != v52)
  {
    if (v51 - v52 < 0)
      abort();
    v54 = (char *)operator new(v51 - v52);
    v55 = &v54[v53];
    v140 = v54;
    v142 = &v54[v53];
    memmove(v54, v52, v53);
    v141 = v55;
  }
  v143 = 0;
  v144 = 0;
  v145 = 0;
  std::vector<std::pair<unsigned short,unsigned short>>::__init_with_size[abi:nn180100]<std::pair<unsigned short,unsigned short>*,std::pair<unsigned short,unsigned short>*>(&v143, *(int **)(v50 + 72), *(int **)(v50 + 80), (uint64_t)(*(_QWORD *)(v50 + 80) - *(_QWORD *)(v50 + 72)) >> 2);

  if (v48)
    CFRelease(v48);

  _Block_object_dispose(&v146, 8);
  v7 = v122;
  if (__p)
  {
    v153 = __p;
    operator delete(__p);
  }
  v9 = (void (**)(_QWORD, _QWORD))v123;
  if (*((_QWORD *)&v150 + 1))
  {
    *(_QWORD *)&v151 = *((_QWORD *)&v150 + 1);
    operator delete(*((void **)&v150 + 1));
  }
  v138 = 0;
  v139 = 0;
  v56 = *(std::__shared_weak_count **)(a1 + 56);
  if (v56)
  {
    v57 = std::__shared_weak_count::lock(v56);
    v139 = v57;
    if (v57)
    {
      v58 = *(_QWORD *)(a1 + 48);
      v138 = v58;
      if (v58)
      {
        v59 = *(_QWORD *)(a1 + 344);
        v60 = *(_QWORD *)(v58 + 1008);
        if (v60)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v60 + 248))(v60);
          v61 = (void *)objc_claimAutoreleasedReturnValue();
        }
        else
        {
          v61 = 0;
        }
        -[__CFN_TransactionMetrics requestBeginOnConnection:reusedAfterTime:](v59, v61, *(double *)(a1 + 384));

        v64 = *(_QWORD *)(v58 + 1008);
        v65 = *(std::__shared_weak_count **)(v58 + 1016);
        v136 = v64;
        v137 = v65;
        if (v65)
        {
          v66 = (unint64_t *)&v65->__shared_owners_;
          do
            v67 = __ldxr(v66);
          while (__stxr(v67 + 1, v66));
        }
        if (v64)
        {
          v68 = *(_QWORD *)(a1 + 296);
          if (v68)
            v69 = v68 - 176;
          else
            v69 = 0;
          v70 = *(id *)(v69 + 80);
          (*(void (**)(uint64_t, id, uint64_t, _QWORD))(*(_QWORD *)v64 + 280))(v64, v70, 7, *(_QWORD *)(a1 + 344));
          *(_BYTE *)(a1 + 368) = 1;

        }
        v132 = 0;
        v133 = &v132;
        v134 = 0x2020000000;
        v135 = 1;
        std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v130, *(_QWORD *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
        v124[0] = MEMORY[0x1E0C809B0];
        v124[1] = 3321888768;
        v124[2] = ___ZN11HTTP3Stream26scheduleAndOpenWithHandlerEPK17CoreSchedulingSetU13block_pointerFvP15__CFHTTPMessagePU27objcproto16OS_dispatch_data8NSObjectPK13CFStreamErrorEU13block_pointerFvhE_block_invoke;
        v124[3] = &unk_1E14F2320;
        v124[5] = a1;
        v124[6] = v130;
        v125 = v131;
        if (v131)
        {
          v71 = (unint64_t *)&v131->__shared_owners_;
          do
            v72 = __ldxr(v71);
          while (__stxr(v72 + 1, v71));
        }
        v124[4] = &v132;
        v126 = 0;
        v127 = 0;
        v128 = 0;
        v73 = v140;
        v74 = v141 - (_BYTE *)v140;
        if (v141 != v140)
        {
          if (v141 - (_BYTE *)v140 < 0)
            abort();
          v126 = operator new(v141 - (_BYTE *)v140);
          v128 = (char *)v126 + v74;
          memmove(v126, v73, v74);
          v127 = (char *)v126 + v74;
        }
        memset(v129, 0, 24);
        std::vector<std::pair<unsigned short,unsigned short>>::__init_with_size[abi:nn180100]<std::pair<unsigned short,unsigned short>*,std::pair<unsigned short,unsigned short>*>(v129, (int *)v143, v144, ((char *)v144 - (_BYTE *)v143) >> 2);
        v129[3] = v121;
        v75 = v124;
        std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v162, *(_QWORD *)(v58 + 8), *(std::__shared_weak_count **)(v58 + 16));
        v154 = MEMORY[0x1E0C809B0];
        v155 = 3321888768;
        v156 = (void (*)(uint64_t *, __int128 *, uint64_t))___ZN15HTTP3Connection21createFramerForStreamERK11HTTP3FieldsU13block_pointerFvNSt3__110shared_ptrI11HTTP3FramerEEybE_block_invoke;
        v157 = &unk_1E14F4080;
        v159 = v58;
        v76 = v75;
        v158 = v76;
        v160 = v162;
        v161 = v163;
        if (v163)
        {
          v77 = (unint64_t *)&v163->__shared_owners_;
          do
            v78 = __ldxr(v77);
          while (__stxr(v78 + 1, v77));
        }
        if (*(_QWORD *)(v58 + 648) == *(_QWORD *)(v58 + 656))
        {
          v146 = 0uLL;
          v156(&v154, &v146, 0);
          v89 = (std::__shared_weak_count *)*((_QWORD *)&v146 + 1);
          if (*((_QWORD *)&v146 + 1))
          {
            v90 = (unint64_t *)(*((_QWORD *)&v146 + 1) + 8);
            do
              v91 = __ldaxr(v90);
            while (__stlxr(v91 - 1, v90));
            if (!v91)
            {
              ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
              std::__shared_weak_count::__release_weak(v89);
            }
          }
          v82 = -1;
LABEL_117:
          v98 = v161;
          if (v161)
          {
            v99 = (unint64_t *)&v161->__shared_owners_;
            do
              v100 = __ldaxr(v99);
            while (__stlxr(v100 - 1, v99));
            if (!v100)
            {
              ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
              std::__shared_weak_count::__release_weak(v98);
            }
          }

          v101 = v163;
          if (v163)
          {
            v102 = (unint64_t *)&v163->__shared_owners_;
            do
              v103 = __ldaxr(v102);
            while (__stlxr(v103 - 1, v102));
            if (!v103)
            {
              ((void (*)(std::__shared_weak_count *))v101->__on_zero_shared)(v101);
              std::__shared_weak_count::__release_weak(v101);
            }
          }

          *(_QWORD *)(a1 + 168) = v82;
          if (v82 != -1)
          {
            *(_BYTE *)(a1 + 126) = 1;
            v104 = *(_QWORD *)(a1 + 344);
            if (v104)
              *(_BYTE *)(v104 + 10) = 1;
          }
          v9[2](v9, *((unsigned __int8 *)v133 + 24));
          v105 = v129[0];
          if (v129[0])
          {
            *((void **)v76 + 12) = v129[0];
            operator delete(v105);
          }
          v106 = v126;
          if (v126)
          {
            *((_QWORD *)v76 + 9) = v126;
            operator delete(v106);
          }
          v107 = v125;
          if (v125)
          {
            v108 = (unint64_t *)&v125->__shared_owners_;
            do
              v109 = __ldaxr(v108);
            while (__stlxr(v109 - 1, v108));
            if (!v109)
            {
              ((void (*)(std::__shared_weak_count *))v107->__on_zero_shared)(v107);
              std::__shared_weak_count::__release_weak(v107);
            }
          }
          v110 = v131;
          if (v131)
          {
            v111 = (unint64_t *)&v131->__shared_owners_;
            do
              v112 = __ldaxr(v111);
            while (__stlxr(v112 - 1, v111));
            if (!v112)
            {
              ((void (*)(std::__shared_weak_count *))v110->__on_zero_shared)(v110);
              std::__shared_weak_count::__release_weak(v110);
            }
          }
          _Block_object_dispose(&v132, 8);
          v113 = v137;
          if (v137)
          {
            v114 = (unint64_t *)&v137->__shared_owners_;
            do
              v115 = __ldaxr(v114);
            while (__stlxr(v115 - 1, v114));
            if (!v115)
            {
              ((void (*)(std::__shared_weak_count *))v113->__on_zero_shared)(v113);
              std::__shared_weak_count::__release_weak(v113);
            }
          }
          v57 = v139;
          if (!v139)
            goto LABEL_150;
          goto LABEL_66;
        }
        *(_QWORD *)&v146 = 0;
        *((_QWORD *)&v146 + 1) = &v146;
        v147 = 0x5812000000;
        v148 = __Block_byref_object_copy__39;
        v149 = __Block_byref_object_dispose__40;
        v150 = 0u;
        v151 = 0u;
        __p = 0;
        LODWORD(v153) = 1065353216;
        v173[0] = MEMORY[0x1E0C809B0];
        v173[1] = 3221225472;
        v173[2] = ___ZN15HTTP2ServerPush24getFramerForHTTP3RequestERK11HTTP3FieldsU13block_pointerFvNSt3__110shared_ptrI11HTTP3FramerEEbE_block_invoke;
        v173[3] = &unk_1E14FDD58;
        v173[4] = &v146;
        HTTP3Fields::enumerateFields(&v140, v173);
        hasPromised = HTTP2ServerPush::hasPromised((int8x8_t *)(v58 + 624), (_QWORD *)(*((_QWORD *)&v146 + 1) + 48));
        v80 = hasPromised;
        if (!hasPromised)
        {
          v164 = 0;
          v165 = 0;
          v156(&v154, (__int128 *)&v164, 0);
          v92 = (std::__shared_weak_count *)v165;
          v9 = (void (**)(_QWORD, _QWORD))v123;
          if (v165)
          {
            v93 = (unint64_t *)(v165 + 8);
            do
              v94 = __ldaxr(v93);
            while (__stlxr(v94 - 1, v93));
            if (!v94)
            {
              ((void (*)(std::__shared_weak_count *))v92->__on_zero_shared)(v92);
              std::__shared_weak_count::__release_weak(v92);
            }
          }
          v82 = -1;
          goto LABEL_116;
        }
        v81 = *(_DWORD *)(hasPromised + 172);
        v82 = v81;
        v83 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>((_QWORD *)(v58 + 880), v81);
        if (v83)
        {
          v84 = v83[4];
          v164 = (NSString *)v83[3];
          v165 = v84;
          if (v84)
          {
            v85 = (unint64_t *)(v84 + 8);
            do
              v86 = __ldxr(v85);
            while (__stxr(v86 + 1, v85));
          }
          v87 = *(_DWORD *)(v58 + 792);
          if (v87 > 2147483597 || v87 - *(_DWORD *)(v58 + 796) + *(_DWORD *)(v58 + 824) + *(_DWORD *)(v58 + 696) > 49)
          {
            v88 = 0;
          }
          else
          {
            *(_DWORD *)(v58 + 792) = v87 + 50;
            v88 = 1;
          }
          v156(&v154, (__int128 *)&v164, v88);
          v95 = (std::__shared_weak_count *)v165;
          if (v165)
          {
            v96 = (unint64_t *)(v165 + 8);
            do
              v97 = __ldaxr(v96);
            while (__stlxr(v97 - 1, v96));
            if (!v97)
            {
              ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
              std::__shared_weak_count::__release_weak(v95);
            }
          }
          std::__hash_table<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>>>::__erase_unique<int>((_QWORD *)(v58 + 880), v81);
          HTTP2ServerPush::_removeStream((HTTP2ServerPush *)(v58 + 624), v81, 1);
          v7 = v122;
          v9 = (void (**)(_QWORD, _QWORD))v123;
          goto LABEL_116;
        }
        if (*(_QWORD *)(v80 + 184) == *(_QWORD *)(v80 + 176))
        {
          v164 = (NSString *)MEMORY[0x1E0C809B0];
          v165 = 3221225472;
          v166 = ___ZN15HTTP2ServerPush24getFramerForHTTP3RequestERK11HTTP3FieldsU13block_pointerFvNSt3__110shared_ptrI11HTTP3FramerEEbE_block_invoke_2;
          v167 = &unk_1E14FDD80;
          v170 = v81;
          v168 = &v154;
          v169 = v58 + 624;
          SmartBlockWithArgs<BOOL>::SmartBlockWithArgs(&v171, &v164);
          std::vector<SmartBlockWithArgs<BOOL>>::push_back[abi:nn180100]((char **)(v80 + 176), v171, (uint64_t)v172);
          ++*(_DWORD *)(*(_QWORD *)v80 + 16);
          v117 = v172;
          v7 = v122;
          v9 = (void (**)(_QWORD, _QWORD))v123;
          if (v172)
          {
            v120 = (unint64_t *)&v172->__shared_owners_;
            do
              v119 = __ldaxr(v120);
            while (__stlxr(v119 - 1, v120));
LABEL_163:
            if (!v119)
            {
              ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
              std::__shared_weak_count::__release_weak(v117);
            }
          }
        }
        else
        {
          v164 = 0;
          v165 = 0;
          v156(&v154, (__int128 *)&v164, 0);
          v117 = (std::__shared_weak_count *)v165;
          v7 = v122;
          v9 = (void (**)(_QWORD, _QWORD))v123;
          if (v165)
          {
            v118 = (unint64_t *)(v165 + 8);
            do
              v119 = __ldaxr(v118);
            while (__stlxr(v119 - 1, v118));
            goto LABEL_163;
          }
        }
LABEL_116:
        _Block_object_dispose(&v146, 8);
        std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&v150 + 8);
        goto LABEL_117;
      }
    }
  }
  else
  {
    v57 = 0;
  }
  (*((void (**)(id, _QWORD))v123 + 2))(v123, 0);
  if (v57)
  {
LABEL_66:
    v62 = (unint64_t *)&v57->__shared_owners_;
    do
      v63 = __ldaxr(v62);
    while (__stlxr(v63 - 1, v62));
    if (!v63)
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
  }
LABEL_150:
  if (v143)
    operator delete(v143);
  if (v140)
    operator delete(v140);
LABEL_154:

  return 1;
}

void sub_183F3D5D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, HTTP3Fields *a9, uint64_t a10, void *a11, void *a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,char a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56,uint64_t a57,uint64_t a58,uint64_t a59,void *a60,uint64_t a61,uint64_t a62)
{
  HTTP3Fields *v62;
  void *v63;
  uint64_t v64;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v64 - 160);
  _Block_object_dispose(&a44, 8);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(a10);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a62);

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v64 - 232);
  HTTP3Fields::~HTTP3Fields(v62);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a19);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a28);
  _Block_object_dispose(&a30, 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a34);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a36);
  HTTP3Fields::~HTTP3Fields((HTTP3Fields *)&a38);

  _Unwind_Resume(a1);
}

void ___ZN15HTTP3Connection21createFramerForStreamERK11HTTP3FieldsU13block_pointerFvNSt3__110shared_ptrI11HTTP3FramerEEybE_block_invoke(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  uint64_t StreamID;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  BOOL v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  int64_t v35;
  char *v36;
  uint64_t v37;
  char *v38;
  char *v39;
  void *v40;
  void *v41;
  unint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  __int128 v47;
  void *v48;
  __int128 v49;
  uint64_t v50;
  __int128 v51;
  uint64_t v52;
  unint64_t v53;
  BOOL v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  char *v58;
  uint64_t v59;
  char *v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;
  void *v66;
  unint64_t v67;
  void **v68;
  HTTP3Connection *v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t *v72;
  size_t v73;
  uint64_t v74;
  dispatch_data_t v75;
  unint64_t v76;
  uint64_t v77;
  char *v78;
  uint64_t v79;
  uint64_t *v80;
  char *v81;
  uint64_t v82;
  uint64_t v83;
  char *v84;
  uint64_t v85;
  void *v86;
  char *v87;
  uint64_t v88;
  char *v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  char *v97;
  int64_t v98;
  void *v99;
  uint64_t v100;
  unint64_t v101;
  char *v102;
  uint64_t v103;
  uint64_t v104;
  _QWORD *v105;
  char *v106;
  _BYTE *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  unint64_t v112;
  char *v113;
  uint64_t v114;
  char *v115;
  uint64_t v116;
  uint64_t v117;
  char *v118;
  uint64_t *v119;
  uint64_t v120;
  uint64_t v121;
  void *v122;
  uint64_t v123;
  uint64_t v124;
  unint64_t v125;
  char *v126;
  uint64_t v127;
  char *v128;
  uint64_t *v129;
  uint64_t v130;
  uint64_t v131;
  char *v132;
  uint64_t v133;
  void *v134;
  uint64_t v135;
  __int128 v136;
  __int128 v137;
  uint64_t v138;
  __int128 v139;
  __int128 v140;
  uint64_t v141;
  __int128 v142;
  uint64_t v143;
  std::__shared_weak_count *v144;
  unint64_t __src;
  char __dst[8];
  uint64_t v147;

  v147 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a1 + 40);
  v6 = *a2;
  if (*a2)
  {
    v7 = *(_QWORD *)(a1 + 32);
    v8 = (std::__shared_weak_count *)a2[1];
    v143 = *a2;
    v144 = v8;
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v10 = __ldxr(p_shared_owners);
      while (__stxr(v10 + 1, p_shared_owners));
      v6 = *a2;
    }
    StreamID = HTTP3Framer::getStreamID(*(NSObject **)(v6 + 48));
    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(v7 + 16))(v7, &v143, StreamID, 1);
    v12 = v144;
    if (v144)
    {
      v13 = (unint64_t *)&v144->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    goto LABEL_54;
  }
  v15 = *(_QWORD **)(a1 + 48);
  v16 = (char *)v15[136];
  v17 = (char *)v15[135];
  v18 = v16 - v17;
  if (v16 == v17)
    v19 = 0;
  else
    v19 = ((v16 - v17) << 6) - 1;
  v20 = v15[138];
  if (v19 == v15[139] + v20)
  {
    v21 = v20 >= 0x200;
    v22 = v20 - 512;
    if (v21)
    {
      v15[138] = v22;
      v25 = *(_QWORD *)v17;
      v23 = v17 + 8;
      v24 = v25;
      v15[135] = v23;
      if (v16 == (char *)v15[137])
      {
        v26 = v15[134];
        v27 = (uint64_t)&v23[-v26];
        if ((unint64_t)v23 <= v26)
        {
          v55 = (uint64_t)&v16[-v26];
          v54 = v55 == 0;
          v56 = v55 >> 2;
          if (v54)
            v57 = 1;
          else
            v57 = v56;
          v58 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v57);
          v60 = &v58[8 * (v57 >> 2)];
          v61 = (uint64_t *)v15[135];
          v16 = v60;
          v62 = v15[136] - (_QWORD)v61;
          if (v62)
          {
            v16 = &v60[v62 & 0xFFFFFFFFFFFFFFF8];
            v63 = 8 * (v62 >> 3);
            v64 = &v58[8 * (v57 >> 2)];
            do
            {
              v65 = *v61++;
              *(_QWORD *)v64 = v65;
              v64 += 8;
              v63 -= 8;
            }
            while (v63);
          }
          v66 = (void *)v15[134];
          v15[134] = v58;
          v15[135] = v60;
          v15[136] = v16;
          v15[137] = &v58[8 * v59];
          if (v66)
          {
            operator delete(v66);
            v16 = (char *)v15[136];
          }
        }
        else
        {
          v28 = v27 >> 3;
          v29 = v27 >> 3 < -1;
          v30 = (v27 >> 3) + 2;
          if (v29)
            v31 = v30;
          else
            v31 = v28 + 1;
          v32 = -(v31 >> 1);
          v33 = v31 >> 1;
          v34 = &v23[-8 * v33];
          v35 = v16 - v23;
          if (v16 != v23)
          {
            memmove(&v23[-8 * v33], v23, v16 - v23);
            v16 = (char *)v15[135];
          }
          v36 = &v16[8 * v32];
          v16 = &v34[v35];
          v15[136] = &v34[v35];
          v15[135] = v36;
        }
      }
      *(_QWORD *)v16 = v24;
    }
    else
    {
      v37 = v18 >> 3;
      v38 = (char *)v15[137];
      v39 = (char *)v15[134];
      if (v18 >> 3 >= (unint64_t)((v38 - v39) >> 3))
      {
        v135 = *(_QWORD *)(a1 + 40);
        if (v38 == v39)
          v42 = 1;
        else
          v42 = (v38 - v39) >> 2;
        v43 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v42);
        v45 = v44;
        v46 = &v43[8 * v37];
        *(_QWORD *)&v47 = v43;
        *((_QWORD *)&v47 + 1) = v46;
        v139 = v47;
        v48 = operator new(0x1000uLL);
        *(_QWORD *)&v49 = v46;
        *((_QWORD *)&v49 + 1) = &v43[8 * v45];
        if (v37 == v45)
        {
          v50 = 8 * v37;
          *(_QWORD *)&v51 = v139;
          if (v18 < 1)
          {
            v99 = v48;
            v100 = v50 >> 2;
            if (v16 == v17)
              v101 = 1;
            else
              v101 = v100;
            v102 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v101);
            v46 = &v102[8 * (v101 >> 2)];
            *(_QWORD *)&v51 = v102;
            *((_QWORD *)&v51 + 1) = v46;
            *(_QWORD *)&v49 = v46;
            *((_QWORD *)&v49 + 1) = &v102[8 * v103];
            if (v43)
            {
              v136 = v49;
              v140 = v51;
              operator delete(v43);
              v49 = v136;
              v51 = v140;
            }
            v48 = v99;
          }
          else
          {
            v52 = v50 >> 3;
            if (v52 >= -1)
              v53 = v52 + 1;
            else
              v53 = v52 + 2;
            v46 -= 8 * (v53 >> 1);
            *(_QWORD *)&v49 = v46;
            *((_QWORD *)&v51 + 1) = v46;
          }
        }
        else
        {
          v51 = v139;
        }
        *(_QWORD *)v46 = v48;
        *(_QWORD *)&v49 = v49 + 8;
        v104 = v15[136];
        v5 = v135;
        while (v104 != v15[135])
        {
          v105 = (_QWORD *)*((_QWORD *)&v51 + 1);
          if (*((_QWORD *)&v51 + 1) == (_QWORD)v51)
          {
            v107 = (_BYTE *)v49;
            if ((unint64_t)v49 >= *((_QWORD *)&v49 + 1))
            {
              if (*((_QWORD *)&v49 + 1) == *((_QWORD *)&v51 + 1))
                v112 = 1;
              else
                v112 = (uint64_t)(*((_QWORD *)&v49 + 1) - *((_QWORD *)&v51 + 1)) >> 2;
              v113 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v112);
              v106 = &v113[(2 * v112 + 6) & 0xFFFFFFFFFFFFFFF8];
              v115 = v106;
              v116 = v107 - (_BYTE *)v105;
              if (v107 != (_BYTE *)v105)
              {
                v115 = &v106[v116 & 0xFFFFFFFFFFFFFFF8];
                v117 = 8 * (v116 >> 3);
                v118 = v106;
                v119 = v105;
                do
                {
                  v120 = *v119++;
                  *(_QWORD *)v118 = v120;
                  v118 += 8;
                  v117 -= 8;
                }
                while (v117);
              }
              *(_QWORD *)&v51 = v113;
              *((_QWORD *)&v51 + 1) = v106;
              *(_QWORD *)&v49 = v115;
              *((_QWORD *)&v49 + 1) = &v113[8 * v114];
              if (v105)
              {
                v137 = v49;
                v142 = v51;
                operator delete(v105);
                v49 = v137;
                v51 = v142;
              }
            }
            else
            {
              v108 = (uint64_t)(*((_QWORD *)&v49 + 1) - v49) >> 3;
              if (v108 >= -1)
                v109 = v108 + 1;
              else
                v109 = v108 + 2;
              v110 = v109 >> 1;
              v111 = v49 + 8 * (v109 >> 1);
              v106 = (char *)(v111 - (v49 - *((_QWORD *)&v51 + 1)));
              if ((_QWORD)v49 == *((_QWORD *)&v51 + 1))
              {
                v107 = (_BYTE *)*((_QWORD *)&v51 + 1);
              }
              else
              {
                v138 = *((_QWORD *)&v49 + 1);
                v141 = v51;
                memmove((void *)(v111 - (v49 - *((_QWORD *)&v51 + 1))), *((const void **)&v51 + 1), v49 - *((_QWORD *)&v51 + 1));
                *((_QWORD *)&v49 + 1) = v138;
                *(_QWORD *)&v51 = v141;
              }
              *((_QWORD *)&v51 + 1) = v106;
              *(_QWORD *)&v49 = &v107[8 * v110];
            }
          }
          else
          {
            v106 = (char *)*((_QWORD *)&v51 + 1);
          }
          v121 = *(_QWORD *)(v104 - 8);
          v104 -= 8;
          *((_QWORD *)v106 - 1) = v121;
          *((_QWORD *)&v51 + 1) -= 8;
        }
        v122 = (void *)v15[134];
        *((_OWORD *)v15 + 67) = v51;
        *((_OWORD *)v15 + 68) = v49;
        if (v122)
        {
          operator delete(v122);
          v16 = (char *)v15[136];
        }
        else
        {
          v16 = (char *)v49;
        }
        goto LABEL_48;
      }
      v40 = operator new(0x1000uLL);
      v41 = v40;
      if (v38 == v16)
      {
        if (v17 == v39)
        {
          if (v16 == v17)
            v76 = 1;
          else
            v76 = (v38 - v17) >> 2;
          v77 = 2 * v76;
          v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v76);
          v17 = &v78[(v77 + 6) & 0xFFFFFFFFFFFFFFF8];
          v80 = (uint64_t *)v15[135];
          v81 = v17;
          v82 = v15[136] - (_QWORD)v80;
          if (v82)
          {
            v81 = &v17[v82 & 0xFFFFFFFFFFFFFFF8];
            v83 = 8 * (v82 >> 3);
            v84 = v17;
            do
            {
              v85 = *v80++;
              *(_QWORD *)v84 = v85;
              v84 += 8;
              v83 -= 8;
            }
            while (v83);
          }
          v86 = (void *)v15[134];
          v15[134] = v78;
          v15[135] = v17;
          v15[136] = v81;
          v15[137] = &v78[8 * v79];
          if (v86)
          {
            operator delete(v86);
            v17 = (char *)v15[135];
          }
        }
        *((_QWORD *)v17 - 1) = v41;
        v87 = (char *)v15[135];
        v15[135] = v87 - 8;
        v88 = *((_QWORD *)v87 - 1);
        v15[135] = v87;
        v89 = (char *)v15[136];
        if (v89 == (char *)v15[137])
        {
          v90 = v15[134];
          v91 = (uint64_t)&v87[-v90];
          if ((unint64_t)v87 <= v90)
          {
            v123 = (uint64_t)&v89[-v90];
            v54 = v123 == 0;
            v124 = v123 >> 2;
            if (v54)
              v125 = 1;
            else
              v125 = v124;
            v126 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v125);
            v128 = &v126[8 * (v125 >> 2)];
            v129 = (uint64_t *)v15[135];
            v89 = v128;
            v130 = v15[136] - (_QWORD)v129;
            if (v130)
            {
              v89 = &v128[v130 & 0xFFFFFFFFFFFFFFF8];
              v131 = 8 * (v130 >> 3);
              v132 = &v126[8 * (v125 >> 2)];
              do
              {
                v133 = *v129++;
                *(_QWORD *)v132 = v133;
                v132 += 8;
                v131 -= 8;
              }
              while (v131);
            }
            v134 = (void *)v15[134];
            v15[134] = v126;
            v15[135] = v128;
            v15[136] = v89;
            v15[137] = &v126[8 * v127];
            if (v134)
            {
              operator delete(v134);
              v89 = (char *)v15[136];
            }
          }
          else
          {
            v92 = v91 >> 3;
            v29 = v91 >> 3 < -1;
            v93 = (v91 >> 3) + 2;
            if (v29)
              v94 = v93;
            else
              v94 = v92 + 1;
            v95 = -(v94 >> 1);
            v96 = v94 >> 1;
            v97 = &v87[-8 * v96];
            v98 = v89 - v87;
            if (v89 != v87)
            {
              memmove(&v87[-8 * v96], v87, v89 - v87);
              v87 = (char *)v15[135];
            }
            v89 = &v97[v98];
            v15[136] = &v97[v98];
            v15[135] = &v87[8 * v95];
          }
        }
        *(_QWORD *)v89 = v88;
      }
      else
      {
        *(_QWORD *)v16 = v40;
      }
    }
    v16 = (char *)(v15[136] + 8);
    v15[136] = v16;
LABEL_48:
    v17 = (char *)v15[135];
  }
  if (v16 == v17)
  {
    v68 = 0;
  }
  else
  {
    v67 = v15[139] + v15[138];
    v68 = (void **)(*(_QWORD *)&v17[(v67 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v67 & 0x1FF));
  }
  *v68 = _Block_copy(*(const void **)(a1 + 32));
  ++v15[139];
  v69 = *(HTTP3Connection **)(a1 + 48);
  if (*((_QWORD *)v69 + 139) == 1)
    HTTP3Connection::_tryCreateBidirectionalStreams(v69);
LABEL_54:
  if (a3)
  {
    v70 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 1008);
    if (v70)
    {
      if ((*(_BYTE *)(v5 + 920) & 4) == 0)
      {
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v70 + 96))(v70, *(int *)(v5 + 792) + 3);
        v71 = *(_QWORD *)(a1 + 48);
        __src = 0;
        v73 = QUICUtilities::quic_vle_encode(*(int *)(v71 + 792) - 1, &__src, v72);
        memcpy(__dst, &__src, v73);
        v74 = *(_QWORD *)(v71 + 1024);
        v75 = dispatch_data_create(__dst, v73, 0, 0);
        HTTP3Framer::writeFrame(v74, 0xDuLL, v75, 0, &__block_literal_global_25_5264);

      }
    }
  }
}

void sub_183F3DF00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, __int128 a13, uint64_t a14, char a15)
{
  void *v15;

  operator delete(v15);
  if ((_QWORD)a13)
    operator delete((void *)a13);
  _Unwind_Resume(a1);
}

void HTTP3Stream::setTransactionMetrics(id *this, __CFN_TransactionMetrics *a2)
{
  objc_storeStrong(this + 43, a2);
}

void HTTP3Stream::closeAndClearHandler(HTTP3Stream *this)
{
  uint64_t v2;
  char *v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  void *v7;
  __int128 v8;

  v3 = (char *)this + 96;
  v2 = *((_QWORD *)this + 12);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 64))(v2);
    v8 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v3, &v8);
    v4 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
    if (*((_QWORD *)&v8 + 1))
    {
      v5 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
  *((_QWORD *)this + 14) = 0x900000004;
  v7 = (void *)*((_QWORD *)this + 41);
  *((_QWORD *)this + 41) = 0;

  HTTP3Stream::_cleanupStream((uint64_t)this, 268, 0);
}

uint64_t HTTP3Stream::rawBytesReceived(HTTP3Stream *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 43);
  if (v1)
    return *(_QWORD *)(v1 + 136) + *(_QWORD *)(v1 + 120);
  else
    return 0;
}

void HTTP3Stream::setPriorityHint(HTTP3Stream *this, float a2, int a3)
{
  float v5;
  int v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  size_t v15;
  _BYTE *v16;
  char v17;
  uint64_t v18;
  dispatch_data_t v19;
  unint64_t v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  unint64_t __src;
  _BYTE __dst[15];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (a2 >= 0.5)
    v5 = (float)((float)(1.0 - a2) * 20.0) / 3.0;
  else
    v5 = ceilf((float)(0.7 - a2) * 10.0);
  v6 = (int)v5;
  if (*((unsigned __int8 *)this + 124) != (int)v5 || *((unsigned __int8 *)this + 125) != a3)
  {
    *((_BYTE *)this + 124) = v6;
    *((_BYTE *)this + 125) = a3;
    if (!*((_BYTE *)this + 129) && (*((_BYTE *)this + 126) || *((_QWORD *)this + 42) != -1))
    {
      v7 = (std::__shared_weak_count *)*((_QWORD *)this + 7);
      if (v7)
      {
        v8 = std::__shared_weak_count::lock(v7);
        if (v8)
        {
          v10 = v8;
          v11 = *((_QWORD *)this + 6);
          if (v11)
          {
            v12 = *((unsigned __int8 *)this + 126);
            v13 = 168;
            if (!*((_BYTE *)this + 126))
              v13 = 336;
            v14 = *(_QWORD *)((char *)this + v13);
            __src = 0;
            v15 = QUICUtilities::quic_vle_encode(v14, &__src, v9);
            memcpy(__dst, &__src, v15);
            v16 = &__dst[v15];
            *(_WORD *)v16 = 15733;
            v16[2] = v6 + 48;
            if (a3)
            {
              strcpy(v16 + 4, " i");
              v17 = 44;
              v18 = 6;
            }
            else
            {
              v17 = 0;
              v18 = 3;
            }
            v16[3] = v17;
            v19 = dispatch_data_create(__dst, v18 + v15, 0, 0);
            if (v12)
              v20 = 984833;
            else
              v20 = 984832;
            HTTP3Framer::writeFrame(*(_QWORD *)(v11 + 1024), v20, v19, 0, &__block_literal_global_17_5267);

          }
          p_shared_owners = (unint64_t *)&v10->__shared_owners_;
          do
            v22 = __ldaxr(p_shared_owners);
          while (__stlxr(v22 - 1, p_shared_owners));
          if (!v22)
          {
            ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
            std::__shared_weak_count::__release_weak(v10);
          }
        }
      }
    }
  }
}

void sub_183F3E22C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v9;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t HTTP3Stream::rawBytesSent(HTTP3Stream *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 43);
  if (v1)
    return *(_QWORD *)(v1 + 112) + *(_QWORD *)(v1 + 96);
  else
    return 0;
}

void HTTP3Fields::HTTP3Fields(HTTP3Fields *this)
{
  char *v2;

  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  v2 = (char *)operator new(0x4000uLL);
  *(_QWORD *)this = v2;
  *((_QWORD *)this + 1) = v2;
  *((_QWORD *)this + 2) = v2 + 0x4000;
}

uint64_t DataDecoder::isFinishedDecoding(DataDecoder *this)
{
  return 1;
}

uint64_t CFURLDataDecoderIsFinishedDecoding(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  if (URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder != -1)
    dispatch_once(&URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder, &__block_literal_global_2558);
  if (a1)
    v2 = a1 + 16;
  else
    v2 = 0;
  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 56))(v2);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 32))(v3);
}

void sub_183F3E5F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  __p = &a26;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  std::__split_buffer<std::string>::pointer end;
  std::__split_buffer<std::string>::pointer begin;
  std::__split_buffer<std::string>::pointer v4;

  begin = this->__begin_;
  end = this->__end_;
  if (end != begin)
  {
    do
    {
      v4 = end - 1;
      this->__end_ = end - 1;
      if (SHIBYTE(end[-1].__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v4->__r_.__value_.__l.__data_);
        v4 = this->__end_;
      }
      end = v4;
    }
    while (v4 != begin);
  }
  if (this->__first_)
    operator delete(this->__first_);
}

void CoalescingDomain::_find_coalescing_connection_key(_QWORD *a1, uint64_t a2, uint64_t a3, _QWORD *a4, _QWORD *a5)
{
  _QWORD *v6;
  uint64_t v8;
  _QWORD *v9;
  const __CFAllocator *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  const char *v15;
  __CFString *v16;
  int v17;
  _QWORD *v18;
  _QWORD *v19;
  BOOL v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;

  if (a4 == a5)
  {
LABEL_18:
    *a1 = 0;
    a1[1] = 0;
  }
  else
  {
    v6 = a4;
    v8 = a2 + 24;
    v9 = (_QWORD *)(a2 + 32);
    v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    while (1)
    {
      v11 = std::__tree<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>>>::find<std::string>(v8, v6);
      if (v9 != v11)
      {
        v12 = (_QWORD *)v11[7];
        v13 = v11 + 8;
        if (v12 != v11 + 8)
          break;
      }
LABEL_17:
      v6 += 3;
      if (v6 == a5)
        goto LABEL_18;
    }
    while (1)
    {
      v14 = *(void **)(v12[4] + 24);
      if (*(char *)(a3 + 23) >= 0)
        v15 = (const char *)a3;
      else
        v15 = *(const char **)a3;
      v16 = (__CFString *)CFStringCreateWithCString(v10, v15, 0);
      v17 = __NSURLSession_CoalescingHelperIsOnDNSNameList(v14, v16);
      if (v16)
        CFRelease(v16);
      if (v17)
        break;
      v18 = (_QWORD *)v12[1];
      if (v18)
      {
        do
        {
          v19 = v18;
          v18 = (_QWORD *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          v19 = (_QWORD *)v12[2];
          v20 = *v19 == (_QWORD)v12;
          v12 = v19;
        }
        while (!v20);
      }
      v12 = v19;
      if (v19 == v13)
        goto LABEL_17;
    }
    *a1 = v12[4];
    v21 = v12[5];
    a1[1] = v21;
    if (v21)
    {
      v22 = (unint64_t *)(v21 + 8);
      do
        v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }
  }
}

void sub_183F3E808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *std::__tree<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>>>::find<std::string>(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v5;
  _BOOL4 v6;
  _QWORD *v7;

  v2 = (_QWORD *)(a1 + 8);
  v3 = *(_QWORD **)(a1 + 8);
  if (!v3)
    return v2;
  v5 = (_QWORD *)(a1 + 8);
  do
  {
    v6 = std::less<std::string>::operator()[abi:nn180100](v3 + 4, a2);
    v7 = v3 + 1;
    if (!v6)
    {
      v7 = v3;
      v5 = v3;
    }
    v3 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v5 == v2 || std::less<std::string>::operator()[abi:nn180100](a2, v5 + 4))
    return v2;
  return v5;
}

void sub_183F3EBD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

NSHTTPCookieStorage *_CFHTTPCookieStorageGetDefault()
{
  const void *v1;
  const void *v2;

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
    return +[NSHTTPCookieStorage sharedHTTPCookieStorage](NSHTTPCookieStorageToCookie2Storage, "sharedHTTPCookieStorage");
  v1 = (const void *)CFHTTPCookieStorageCopySharedHTTPCookieStorage();
  v2 = v1;
  if (v1)
    CFRelease(v1);
  return (NSHTTPCookieStorage *)v2;
}

void std::deque<__CFURLCacheNode *>::erase(uint64_t a1, char *a2, char *a3)
{
  char *v3;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char **v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  char **v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int16 v19;
  char **v20;
  uint64_t v21;
  unint64_t v22;
  char **v23;
  char *v24;
  unint64_t v25;
  char **v26;
  char *v27;
  char **v28;
  char *v29;
  char *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  int64x2_t v38;
  unint64_t v39;
  char *v40;
  unint64_t v41;
  char **v42;
  uint64_t v43;
  char **v44;
  char *v45;
  char **v46;
  char *v47;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  char *v53;
  _BYTE *v54;
  char **v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char **v63;
  char *v64;

  v3 = a3;
  v5 = *(_QWORD *)(a1 + 32);
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(_QWORD *)(a1 + 16);
  v8 = (char **)(v6 + 8 * (v5 >> 9));
  if (v7 == v6)
    v9 = 0;
  else
    v9 = (uint64_t)&(*v8)[8 * (*(_QWORD *)(a1 + 32) & 0x1FFLL)];
  if ((char *)v9 == a3)
  {
    v11 = *v8;
LABEL_10:
    v14 = (char **)(v6 + 8 * (v5 >> 9));
    goto LABEL_15;
  }
  v10 = ((uint64_t)&a3[-*(_QWORD *)a2] >> 3) + ((a2 - (char *)v8) << 6);
  v11 = *v8;
  v12 = v9 - (_QWORD)*v8;
  v13 = v10 - (v12 >> 3);
  if (v10 == v12 >> 3)
  {
    v3 = (char *)v9;
    goto LABEL_10;
  }
  if (v10 < 1)
  {
    v16 = 511 - v10;
    v14 = &v8[-(v16 >> 9)];
    v11 = *v14;
    v15 = ~(_DWORD)v16 & 0x1FFLL;
  }
  else
  {
    v14 = &v8[(unint64_t)v10 >> 9];
    v11 = *v14;
    v15 = v10 & 0x1FF;
  }
  v3 = &v11[8 * v15];
  v17 = *(_QWORD *)(a1 + 40);
  if (v13 > (unint64_t)(v17 - 1) >> 1)
  {
    v18 = (v3 - v11) >> 3;
    if (v3 - v11 < -7)
    {
      v39 = 510 - v18;
      v19 = ~(_WORD)v39;
      v20 = &v14[-(v39 >> 9)];
    }
    else
    {
      v19 = v18 + 1;
      v20 = &v14[(unint64_t)(v18 + 1) >> 9];
    }
    v40 = &(*v20)[8 * (v19 & 0x1FF)];
    v41 = v5 + v17;
    v42 = (char **)(v6 + 8 * (v41 >> 9));
    if (v7 == v6)
      v43 = 0;
    else
      v43 = (uint64_t)&(*v42)[8 * (v41 & 0x1FF)];
    if (v20 == v42)
    {
      v54 = (_BYTE *)v43;
      v55 = v14;
      v56 = v3;
    }
    else
    {
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,__CFURLCacheNode **,__CFURLCacheNode **,std::__deque_iterator<__CFURLCacheNode *,__CFURLCacheNode **,__CFURLCacheNode *&,__CFURLCacheNode ***,long,512l>,0>(&v62, v40, *v20 + 4096, v14, v3);
      v44 = v63;
      v45 = v64;
      v46 = v20 + 1;
      if (v46 != v42)
      {
        v47 = *v63;
        do
        {
          v48 = 0;
          v49 = *v46;
          while (1)
          {
            v50 = v47 - v45 + 4096;
            if ((4096 - 8 * v48) >> 3 >= v50 >> 3)
              v51 = v50 >> 3;
            else
              v51 = (4096 - 8 * v48) >> 3;
            if (v51)
              memmove(v45, &v49[8 * v48], 8 * v51);
            v48 += v51;
            if (v48 == 512)
              break;
            v52 = v44[1];
            ++v44;
            v47 = v52;
            v45 = v52;
          }
          v45 += 8 * v51;
          v47 = *v44;
          if (*v44 + 4096 == v45)
          {
            v53 = v44[1];
            ++v44;
            v47 = v53;
            v45 = v53;
          }
          ++v46;
        }
        while (v46 != v42);
      }
      v40 = *v42;
      v54 = (_BYTE *)v43;
      v55 = v44;
      v56 = v45;
    }
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,__CFURLCacheNode **,__CFURLCacheNode **,std::__deque_iterator<__CFURLCacheNode *,__CFURLCacheNode **,__CFURLCacheNode *&,__CFURLCacheNode ***,long,512l>,0>(&v62, v40, v54, v55, v56);
    v58 = *(_QWORD *)(a1 + 8);
    v57 = *(_QWORD *)(a1 + 16);
    if (v57 == v58)
      v59 = 0;
    else
      v59 = ((v57 - v58) << 6) - 1;
    v60 = *(_QWORD *)(a1 + 32);
    v61 = *(_QWORD *)(a1 + 40) - 1;
    *(_QWORD *)(a1 + 40) = v61;
    if ((unint64_t)(v59 - (v61 + v60)) >= 0x400)
    {
      operator delete(*(void **)(v57 - 8));
      *(_QWORD *)(a1 + 16) -= 8;
    }
    return;
  }
LABEL_15:
  v21 = (v3 - v11) >> 3;
  if (v3 - v11 < -7)
  {
    v25 = 510 - v21;
    v23 = &v14[-(v25 >> 9)];
    v24 = &(*v23)[8 * (~(_WORD)v25 & 0x1FF)];
  }
  else
  {
    v22 = v21 + 1;
    v23 = &v14[v22 >> 9];
    v24 = &(*v23)[8 * (v22 & 0x1FF)];
  }
  if (v14 == v8)
  {
    v37 = (char *)v9;
    v36 = v3;
  }
  else
  {
    std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<__CFURLCacheNode **,std::__deque_iterator<__CFURLCacheNode *,__CFURLCacheNode **,__CFURLCacheNode *&,__CFURLCacheNode ***,long,512l>,0>(&v62, v11, v3, v23, v24);
    v26 = v63;
    v27 = v64;
    v28 = v14 - 1;
    if (v14 - 1 != v8)
    {
      v29 = *v63;
      do
      {
        v30 = *v28;
        v31 = *v28 + 4096;
        while (1)
        {
          v32 = v27 - v29;
          if ((v31 - v30) >> 3 >= v32 >> 3)
            v33 = v32 >> 3;
          else
            v33 = (v31 - v30) >> 3;
          v31 -= 8 * v33;
          v27 -= 8 * v33;
          if (v33)
            memmove(v27, v31, 8 * v33);
          if (v31 == v30)
            break;
          v34 = *--v26;
          v29 = v34;
          v27 = v34 + 4096;
        }
        v29 = *v26;
        if (*v26 + 4096 == v27)
        {
          v35 = v26[1];
          ++v26;
          v29 = v35;
          v27 = v35;
        }
        --v28;
      }
      while (v28 != v8);
    }
    v36 = *v8 + 4096;
    v37 = (char *)v9;
    v23 = v26;
    v24 = v27;
  }
  std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<__CFURLCacheNode **,std::__deque_iterator<__CFURLCacheNode *,__CFURLCacheNode **,__CFURLCacheNode *&,__CFURLCacheNode ***,long,512l>,0>(&v62, v37, v36, v23, v24);
  v38 = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_1841E3870);
  *(int64x2_t *)(a1 + 32) = v38;
  if (v38.i64[0] >= 0x400uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(_QWORD *)(a1 + 8) += 8;
    *(_QWORD *)(a1 + 32) -= 512;
  }
}

void HTTPProtocol::updateHTTPMessageWithCondtionalHeaders(HTTPProtocol *this, const _CFCachedURLResponse *a2, _CFCachedURLResponse *a3, const _CFURLRequest *a4)
{
  int v7;
  HTTPMessage *v8;
  CFStringRef v9;
  void *v10;
  void *v11;
  double LastModifiedDate;
  HTTPMessage *v13;
  CFStringRef v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  CFGregorianDate GregorianDate;

  if (a2)
    v7 = *((_DWORD *)a2->var1 + 14);
  else
    v7 = 2;
  v8 = *(HTTPMessage **)(-[_CFCachedURLResponse _inner](a3, "_inner", a3, a4) + 56);
  if (v8)
  {
    v9 = HTTPMessage::copyHeaderFieldValue(v8, 0x12823305u);
    if (v9)
      goto LABEL_12;
  }
  else
  {
    v9 = 0;
  }
  if (v7 != 2)
  {
    v10 = (void *)CFCachedURLResponseCopyWrappedResponse(a2);
    if (!v10)
      goto LABEL_18;
    v11 = v10;
    LastModifiedDate = URLResponse::getLastModifiedDate((URLResponse *)objc_msgSend(v10, "_inner"));

    if (LastModifiedDate == 0.0)
      goto LABEL_18;
    GregorianDate = CFAbsoluteTimeGetGregorianDate(LastModifiedDate, 0);
    v9 = _CFStringCreateRFC2616DateStringWithGregorianDate((const __CFAllocator *)*MEMORY[0x1E0C9AE00], &GregorianDate, 0);
  }
LABEL_12:
  if (v9)
  {
    if (CFStringGetLength(v9) >= 1)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      HTTPMessage::setHeaderFieldStringValue((HTTPMessage *)((char *)this + 16), 0x12823305u, v9);
    }
    CFRelease(v9);
  }
LABEL_18:
  v13 = *(HTTPMessage **)(-[_CFCachedURLResponse _inner](a3, "_inner") + 56);
  if (v13)
  {
    v14 = HTTPMessage::copyHeaderFieldValue(v13, 0x1291B30Eu);
    if (v14)
      goto LABEL_32;
  }
  else
  {
    v14 = 0;
  }
  if (v7 != 2)
  {
    v15 = (void *)CFCachedURLResponseCopyWrappedResponse(a2);
    v16 = *(_QWORD *)(objc_msgSend(v15, "_inner") + 88);
    if (v16)
      v17 = v16 - 16;
    else
      v17 = 0;
    if (v16)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v14 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)(v17 + 16), 0x124092F7u);
    }
    else
    {
      v14 = 0;
    }

  }
LABEL_32:
  if (v14)
  {
    if (CFStringGetLength(v14) >= 1)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      HTTPMessage::setHeaderFieldStringValue((HTTPMessage *)((char *)this + 16), 0x1291B30Eu, v14);
    }
    CFRelease(v14);
  }
}

uint64_t coreSchedulingSetEqual(const void *a1, const void *a2)
{
  return (*(uint64_t (**)(const void *, const void *))(*(_QWORD *)a1 + 24))(a1, a2);
}

BOOL CoreSchedulingSet::equals(CoreSchedulingSet *this, const CoreSchedulingSet *a2)
{
  return CoreSchedulingSet::isEqualTo(this, a2) != 0;
}

uint64_t CoreSchedulingSet::isEqualTo(CoreSchedulingSet *this, const CoreSchedulingSet *a2)
{
  int v2;

  if (this == a2)
    return 1;
  v2 = *((_DWORD *)this + 10);
  if (v2 != *((_DWORD *)a2 + 10))
    return 0;
  if (v2 == 3)
    return *((_QWORD *)this + 7) == *((_QWORD *)a2 + 7);
  if (v2 == 2)
    return CFEqual(*((CFTypeRef *)this + 6), *((CFTypeRef *)a2 + 6));
  if (v2 != 1)
    return 1;
  if (*((_QWORD *)this + 9) != *((_QWORD *)a2 + 9))
    return 0;
  return CFEqual(*((CFTypeRef *)this + 10), *((CFTypeRef *)a2 + 10)) != 0;
}

void ___ZN15HTTP2Connection20initializeConnectionEv_block_invoke(uint64_t a1, int a2, CFTypeRef cf)
{
  HTTP2Connection *v5;
  CFTypeID v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  __int128 v11;

  if (cf)
  {
    v5 = *(HTTP2Connection **)(a1 + 32);
    v6 = CFGetTypeID(cf);
    if (v6 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v11) = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&v11, 2u);
    }
    if ((CFTypeRef)*MEMORY[0x1E0C9AE50] == cf)
    {
      v11 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(_QWORD *)(a1 + 40) + 272, &v11);
      v7 = (std::__shared_weak_count *)*((_QWORD *)&v11 + 1);
      if (*((_QWORD *)&v11 + 1))
      {
        v8 = (unint64_t *)(*((_QWORD *)&v11 + 1) + 8);
        do
          v9 = __ldaxr(v8);
        while (__stlxr(v9 - 1, v8));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
      v10 = *(_QWORD *)(a1 + 40);
      if (!*(_BYTE *)(v10 + 264))
      {
        *(_BYTE *)(v10 + 264) = 1;
        HTTP2Connection::stopIfNoOutstandingRequests(v5);
      }
    }
  }
}

uint64_t `non-virtual thunk to'HTTP3StreamWrapper::_meta_release(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(char *))(*((_QWORD *)this - 3) + 48))((char *)this - 24);
}

uint64_t std::__shared_ptr_pointer<MetaConnectionCacheClient *,Deleter_meta_release<MetaConnectionCacheClient>,std::allocator<MetaConnectionCacheClient>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

uint64_t std::__shared_ptr_emplace<HTTP3Stream>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t EmptyXCookieStorage::getCookiesForTask(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a4 + 16))(a4, 0);
}

uint64_t HTTP2ConnectionCache::initWithSchedulingSet(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  dispatch_time_t v11;
  _QWORD v13[5];
  _QWORD v14[5];
  _QWORD v15[5];
  _QWORD handler[5];

  if (!a2)
  {
    *(_QWORD *)(a1 + 80) = CoreSchedulingSet::copyLoaderQueueSet((CoreSchedulingSet *)a1);
    if (a3)
      goto LABEL_3;
LABEL_5:
    __assert_rtn("initWithSchedulingSet", "HTTP2ConnectionCache.cpp", 76, "manager");
  }
  *(_QWORD *)(a1 + 80) = a2;
  (*(void (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
  if (!a3)
    goto LABEL_5;
LABEL_3:
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  *(_QWORD *)(a1 + 104) = a3;
  (*(void (**)(uint64_t))(*(_QWORD *)a3 + 40))(a3);
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 104) + 40))(*(_QWORD *)(a1 + 104));
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 80) + 80))(*(_QWORD *)(a1 + 80));
  v6 = MEMORY[0x1E0C809B0];
  *(_QWORD *)(a1 + 112) = v5;
  handler[0] = v6;
  handler[1] = 3221225472;
  handler[2] = ___ZN20HTTP2ConnectionCache15initCacheTimersEv_block_invoke;
  handler[3] = &__block_descriptor_40_e5_v8__0l;
  handler[4] = a1;
  dispatch_source_set_event_handler(v5, handler);
  v7 = *(NSObject **)(a1 + 112);
  v15[0] = v6;
  v15[1] = 3221225472;
  v15[2] = ___ZN20HTTP2ConnectionCache15initCacheTimersEv_block_invoke_2;
  v15[3] = &__block_descriptor_40_e5_v8__0l;
  v15[4] = a1;
  dispatch_source_set_cancel_handler(v7, v15);
  v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 80) + 80))(*(_QWORD *)(a1 + 80));
  *(_QWORD *)(a1 + 120) = v8;
  v14[0] = v6;
  v14[1] = 3221225472;
  v14[2] = ___ZN20HTTP2ConnectionCache15initCacheTimersEv_block_invoke_3;
  v14[3] = &__block_descriptor_40_e5_v8__0l;
  v14[4] = a1;
  dispatch_source_set_event_handler(v8, v14);
  v9 = *(NSObject **)(a1 + 120);
  v13[0] = v6;
  v13[1] = 3221225472;
  v13[2] = ___ZN20HTTP2ConnectionCache15initCacheTimersEv_block_invoke_4;
  v13[3] = &__block_descriptor_40_e5_v8__0l;
  v13[4] = a1;
  dispatch_source_set_cancel_handler(v9, v13);
  v10 = *(NSObject **)(a1 + 112);
  v11 = dispatch_time(0x8000000000000000, (uint64_t)((double)*(int *)(a1 + 72) * 1000000000.0));
  dispatch_source_set_timer(v10, v11, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
  dispatch_resume(*(dispatch_object_t *)(a1 + 112));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 152))(a1);
}

void HTTP3StreamWrapper::~HTTP3StreamWrapper(HTTP3StreamWrapper *this)
{
  *(_QWORD *)this = off_1E14E94A8;
  *((_QWORD *)this + 3) = &unk_1E14E9580;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 32);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

{
  *(_QWORD *)this = off_1E14E94A8;
  *((_QWORD *)this + 3) = &unk_1E14E9580;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 32);
}

uint64_t IOConnWrapper::copyProperty(IOConnWrapper *this, const __CFString *a2)
{
  if (*(_DWORD *)this == 2)
    return 0;
  if (*(_DWORD *)this != 1)
    __assert_rtn("copyProperty", "TCPIOConnectionTest.hpp", 217, "false");
  return (*(uint64_t (**)(_QWORD, const __CFString *))(**((_QWORD **)this + 1) + 216))(*((_QWORD *)this + 1), a2);
}

void HTTP3Stream::~HTTP3Stream(id *this)
{
  char *v2;
  id v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;

  *this = &off_1E14E5010;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 44));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 39));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 37));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 35));
  v2 = (char *)this[32];
  this[32] = 0;
  if (v2)
    CFRelease(v2 - 16);
  v3 = this[23];
  if (v3)
  {
    this[24] = v3;
    operator delete(v3);
  }

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 12));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 10));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 8));
  v4 = (std::__shared_weak_count *)this[7];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 3));
  *this = &off_1E14E5838;
  v5 = (std::__shared_weak_count *)this[2];
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

{
  HTTP3Stream::~HTTP3Stream(this);
  JUMPOUT(0x186DB748CLL);
}

void HTTP3Stream::_cleanupStream(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t *v8;
  unint64_t v9;
  _BYTE *v10;
  FILE *v11;
  FILE **v12;
  FILE *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *p_buffer;
  size_t v20;
  dispatch_data_t v21;
  __int128 *v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  NSObject *v26;
  unint64_t v27;
  __uint64_t v28;
  NSObject *v29;
  std::__shared_weak_count *v30;
  unint64_t *p_shared_owners;
  unint64_t v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  id v39;
  uint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  std::__shared_weak_count *v51;
  char buffer;
  _BYTE v53[5];
  uint64_t v54;
  std::__shared_weak_count *v55;
  _BYTE buf[22];
  __int16 v57;
  unint64_t v58;
  __int16 v59;
  uint64_t v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 129))
  {
    v5 = *(_QWORD *)(a1 + 24);
    if (v5 && (a3 & 1) == 0)
      HTTP3Framer::cancelStream(v5, a2);
    *(_BYTE *)(a1 + 129) = 1;
    v54 = 0;
    v55 = 0;
    v6 = *(std::__shared_weak_count **)(a1 + 56);
    if (v6)
    {
      v55 = std::__shared_weak_count::lock(v6);
      if (v55)
      {
        v7 = *(_QWORD *)(a1 + 48);
        v54 = v7;
        if (v7)
        {
          if ((a3 & 1) == 0)
          {
            v8 = (uint64_t *)(v7 + 352);
            while (1)
            {
              v8 = (uint64_t *)*v8;
              if (!v8)
                break;
              if (v8[4] == a1)
              {
                v9 = v8[5];
                if (v9 <= 0x3E)
                {
                  v10 = v53;
                  buffer = v9 | 0x40;
                  v11 = *(FILE **)(v7 + 320);
                  if (v11)
                  {
                    v12 = (FILE **)(v7 + 320);
                    goto LABEL_26;
                  }
LABEL_27:
                  v20 = v10 - &buffer;
                  goto LABEL_28;
                }
                buffer = 127;
                v14 = v9 - 63;
                v15 = 1;
                if (v9 - 63 >= 0x80)
                {
                  while (v15 != 6)
                  {
                    v16 = v15;
                    v53[v15 - 1] = v14 | 0x80;
                    v17 = v14 >> 7;
                    ++v15;
                    v18 = v14 >> 14;
                    v14 >>= 7;
                    if (!v18)
                    {
                      if (v16 < 5)
                      {
                        p_buffer = &v53[v16 - 1];
                        LOBYTE(v14) = v17;
                        goto LABEL_24;
                      }
                      break;
                    }
                  }
                  v11 = *(FILE **)(v7 + 320);
                  if (v11)
                  {
                    v12 = (FILE **)(v7 + 320);
                    goto LABEL_33;
                  }
                  goto LABEL_34;
                }
                p_buffer = &buffer;
LABEL_24:
                v10 = p_buffer + 2;
                v53[v15 - 1] = v14;
                v12 = (FILE **)(v7 + 320);
                v11 = *(FILE **)(v7 + 320);
                if (p_buffer + 2 <= &buffer)
                {
                  if (v11)
                  {
LABEL_33:
                    fwrite("qdec: warn: ", 0xCuLL, 1uLL, v11);
                    fprintf(*v12, "cannot generate Cancel Stream instruction for stream %llu; buf size=%zu",
                      v8[5],
                      6uLL);
                    fputc(10, *v12);
                  }
LABEL_34:
                  v20 = -1;
                }
                else
                {
                  if (!v11)
                    goto LABEL_27;
LABEL_26:
                  fwrite("qdec: debug: ", 0xDuLL, 1uLL, v11);
                  v20 = v10 - &buffer;
                  fprintf(*v12, "cancelled stream %llu; generate instruction of %u bytes", v8[5], v20);
                  fputc(10, *v12);
LABEL_28:
                  destroy_header_block_read_ctx(v7 + 272, v8);
                  *(_DWORD *)(v7 + 296) += v20;
                  if (!v20)
                    goto LABEL_36;
                }
                v21 = dispatch_data_create(&buffer, v20, 0, 0);
                HTTP3Connection::writeDecoderStream(v7, v21);

                goto LABEL_36;
              }
            }
            v13 = *(FILE **)(v7 + 320);
            if (v13)
            {
              fwrite("qdec: info: ", 0xCuLL, 1uLL, v13);
              fwrite("could not find stream to cancel", 0x1FuLL, 1uLL, *(FILE **)(v7 + 320));
              fputc(10, *(FILE **)(v7 + 320));
            }
LABEL_36:
            std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v50, *(_QWORD *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
            v22 = *(__int128 **)(v7 + 1136);
            v23 = *(_QWORD *)(v7 + 1144);
            if (v22 != (__int128 *)v23)
            {
              while (*(_QWORD *)v22 != v50)
              {
                if (++v22 == (__int128 *)v23)
                {
                  v22 = *(__int128 **)(v7 + 1144);
                  break;
                }
              }
            }
            if (v22 != (__int128 *)v23)
            {
              v24 = *(unsigned __int8 *)(a1 + 132);
              if (v22 + 1 != (__int128 *)v23)
              {
                do
                  v25 = (uint64_t)v22++;
                while (std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v25, v22) + 32 != v23);
                v23 = *(_QWORD *)(v7 + 1144);
              }
              while ((__int128 *)v23 != v22)
              {
                v23 -= 16;
                std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v23);
              }
              *(_QWORD *)(v7 + 1144) = v22;
              if (*(__int128 **)(v7 + 1136) == v22)
              {
                *(_QWORD *)(v7 + 1176) = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX);
                if (*(_QWORD *)(v7 + 992))
                  HTTP3Connection::_stopStallRecovery((HTTP3Connection *)v7);
                if ((*(_BYTE *)(v7 + 920) & 2) != 0)
                {
                  HTTP3Connection::_cleanupConnection((HTTP3Connection *)v7);
                }
                else
                {
                  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v7 + 1008) + 88))(*(_QWORD *)(v7 + 1008), 1);
                  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v7 + 1008) + 136))(*(_QWORD *)(v7 + 1008), 1, 0);
                }
              }
              CFN_LOG_h3connection();
              v26 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
              {
                v46 = *(_QWORD *)(v50 + 336);
                v47 = *(_QWORD *)(v7 + 1216);
                *(_DWORD *)buf = 134218752;
                *(_QWORD *)&buf[4] = v7;
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = v47;
                v57 = 2048;
                v58 = v46;
                v59 = 1024;
                LODWORD(v60) = v24;
                _os_log_debug_impl(&dword_183ECA000, v26, OS_LOG_TYPE_DEBUG, "%p %llu Stream %llu ended successfully %{BOOL}d", buf, 0x26u);
              }

              if ((*(_BYTE *)(v7 + 920) & 6) == 0)
              {
                if (v24)
                {
                  *(_QWORD *)(v7 + 1224) = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX);
                  *(_QWORD *)(v7 + 1232) = 0;
                }
                else
                {
                  v27 = *(_QWORD *)(v7 + 1232) + 1;
                  *(_QWORD *)(v7 + 1232) = v27;
                  if (v27 >= 0xB)
                  {
                    v28 = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX) - *(_QWORD *)(v7 + 1224);
                    if (v28 >= 0xDF8475801)
                    {
                      CFN_LOG_h3connection();
                      v29 = objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
                      {
                        v48 = *(_QWORD *)(v7 + 1216);
                        v49 = *(_QWORD *)(v7 + 1232);
                        *(_DWORD *)buf = 134218752;
                        *(_QWORD *)&buf[4] = v7;
                        *(_WORD *)&buf[12] = 2048;
                        *(_QWORD *)&buf[14] = v48;
                        v57 = 2048;
                        v58 = v28 / 0x3B9ACA00;
                        v59 = 2048;
                        v60 = v49;
                        _os_log_error_impl(&dword_183ECA000, v29, OS_LOG_TYPE_ERROR, "%p %llu Terminating broken connection, last success %llus ago, consecutive failures %llu", buf, 0x2Au);
                      }

                      HTTP3Connection::_cleanupIfNoStreams(v7);
                    }
                  }
                }
              }
            }
            v30 = v51;
            if (v51)
            {
              p_shared_owners = (unint64_t *)&v51->__shared_owners_;
              do
                v32 = __ldaxr(p_shared_owners);
              while (__stlxr(v32 - 1, p_shared_owners));
              if (!v32)
              {
                ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
                std::__shared_weak_count::__release_weak(v30);
              }
            }
          }
          if (*(_BYTE *)(a1 + 368))
          {
            v33 = *(_QWORD *)(v54 + 1008);
            v34 = *(std::__shared_weak_count **)(v54 + 1016);
            *(_QWORD *)buf = v33;
            *(_QWORD *)&buf[8] = v34;
            if (v34)
            {
              v35 = (unint64_t *)&v34->__shared_owners_;
              do
                v36 = __ldxr(v35);
              while (__stxr(v36 + 1, v35));
            }
            if (v33)
            {
              v37 = *(_QWORD *)(a1 + 296);
              if (v37)
                v38 = v37 - 176;
              else
                v38 = 0;
              v39 = *(id *)(v38 + 80);
              if (*(_BYTE *)(a1 + 369))
                v40 = 6;
              else
                v40 = 8;
              (*(void (**)(uint64_t, id, uint64_t, _QWORD))(*(_QWORD *)v33 + 280))(v33, v39, v40, *(_QWORD *)(a1 + 344));
              *(_BYTE *)(a1 + 368) = 0;

            }
            if (v34)
            {
              v41 = (unint64_t *)&v34->__shared_owners_;
              do
                v42 = __ldaxr(v41);
              while (__stlxr(v42 - 1, v41));
              if (!v42)
              {
                ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
                std::__shared_weak_count::__release_weak(v34);
              }
            }
          }
        }
      }
    }
    v43 = v55;
    if (v55)
    {
      v44 = (unint64_t *)&v55->__shared_owners_;
      do
        v45 = __ldaxr(v44);
      while (__stlxr(v45 - 1, v44));
      if (!v45)
      {
        ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
        std::__shared_weak_count::__release_weak(v43);
      }
    }
  }
}

void sub_183F3FEBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  va_list va;

  va_start(va, a7);

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

id CFN_LOG_h3connection(void)
{
  if (CFN_LOG_h3connection(void)::once != -1)
    dispatch_once(&CFN_LOG_h3connection(void)::once, &__block_literal_global_39);
  return (id)CFN_LOG_h3connection(void)::log;
}

uint64_t `non-virtual thunk to'NWIOConnection::unregisterContext()
{
  return nw_connection_unregister_context();
}

uint64_t HTTP3Framer::cancelStream(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  NSObject *v4;
  nw_protocol_metadata_t v5;
  void *v6;

  if (a2 != -1)
  {
    v3 = *(NSObject **)(a1 + 48);
    v4 = nw_protocol_copy_quic_connection_definition();
    v5 = nw_content_context_copy_protocol_metadata(v3, v4);

    v6 = (void *)nw_quic_connection_copy_stream_metadata();
    nw_quic_stream_set_application_error();

  }
  return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 48));
}

void sub_183F3FFCC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

_OWORD *CFURLDataDecoderCreateWithContentEncoding(const __CFAllocator *a1, int a2)
{
  uint64_t v2;
  _OWORD *v3;
  uint64_t (**v4)(CFObject *__hidden, const CFObject *);
  _OWORD *Instance;
  uint64_t v6;
  int v7;
  _OWORD *result;

  if (a2 == 6)
  {
    if (URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder != -1)
      dispatch_once(&URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder, &__block_literal_global_2558);
    Instance = (_OWORD *)_CFRuntimeCreateInstance();
    v3 = Instance;
    if (Instance)
    {
      Instance[1] = 0u;
      v3 = Instance + 1;
      Instance[3] = 0u;
      Instance[4] = 0u;
      Instance[2] = 0u;
    }
    v3[2] = 0u;
    v3[3] = 0u;
    v3[1] = 0u;
    *(_QWORD *)v3 = &off_1E14EBCD8;
    *((_QWORD *)v3 + 1) = &off_1E14E83F0;
    *((_BYTE *)v3 + 56) = compression_stream_init((compression_stream *)(v3 + 1), COMPRESSION_STREAM_DECODE, COMPRESSION_BROTLI) == COMPRESSION_STATUS_OK;
    v4 = &off_1E14EC9A8;
    *(_QWORD *)v3 = &off_1E14EC9A8;
    *((_QWORD *)v3 + 1) = &unk_1E14EC9F8;
  }
  else
  {
    if (a2 == 5)
    {
      if (URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder != -1)
        dispatch_once(&URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder, &__block_literal_global_2558);
      v2 = _CFRuntimeCreateInstance();
      *(_OWORD *)(v2 + 16) = 0u;
      v3 = (_OWORD *)(v2 + 16);
      *(_QWORD *)(v2 + 144) = 0;
      *(_QWORD *)(v2 + 16) = &off_1E14EBCD8;
      *(_QWORD *)(v2 + 24) = &off_1E14E9450;
      *(_OWORD *)(v2 + 48) = 0u;
      *(_OWORD *)(v2 + 64) = 0u;
      *(_OWORD *)(v2 + 80) = 0u;
      *(_OWORD *)(v2 + 96) = 0u;
      *(_OWORD *)(v2 + 112) = 0u;
      *(_OWORD *)(v2 + 128) = 0u;
      *(_OWORD *)(v2 + 32) = 0u;
      *(_BYTE *)(v2 + 144) = inflateInit_((z_streamp)(v2 + 32), "1.2.12", 112) == 0;
      v4 = &off_1E14ECD58;
    }
    else
    {
      if (a2 != 3)
        return 0;
      if (URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder != -1)
        dispatch_once(&URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder, &__block_literal_global_2558);
      v2 = _CFRuntimeCreateInstance();
      *(_OWORD *)(v2 + 16) = 0u;
      v3 = (_OWORD *)(v2 + 16);
      *(_QWORD *)(v2 + 144) = 0;
      *(_QWORD *)(v2 + 16) = &off_1E14EBCD8;
      *(_QWORD *)(v2 + 24) = &off_1E14E7728;
      *(_OWORD *)(v2 + 48) = 0u;
      *(_OWORD *)(v2 + 64) = 0u;
      *(_OWORD *)(v2 + 80) = 0u;
      *(_OWORD *)(v2 + 96) = 0u;
      *(_OWORD *)(v2 + 112) = 0u;
      *(_OWORD *)(v2 + 128) = 0u;
      *(_OWORD *)(v2 + 32) = 0u;
      *(_BYTE *)(v2 + 144) = inflateInit2_((z_streamp)(v2 + 32), -15, "1.2.12", 112) == 0;
      *(_WORD *)(v2 + 145) = 0;
      v4 = &off_1E14EBD78;
    }
    *(_QWORD *)(v2 + 16) = v4;
    *(_QWORD *)(v2 + 24) = v4 + 10;
  }
  v6 = ((uint64_t (*)(GZIPDataDecoderHolder *))v4[7])((GZIPDataDecoderHolder *)v3);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
  result = v3 - 1;
  if (v7)
    return result;
  CFRelease(result);
  return 0;
}

void sub_183F40274(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

void sub_183F40F78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  void *v21;

  objc_sync_exit(v21);
  _Unwind_Resume(a1);
}

void sub_183F41264(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  *(_QWORD *)(v1 + 24) = v3;
  CFRelease(*(CFTypeRef *)(v1 + 32));
  _Unwind_Resume(a1);
}

CFAllocatorRef *RunLoopSchedulingSet::createCopy(CFAllocatorRef *this)
{
  CFAllocatorRef *v1;
  _OWORD *v2;
  uint64_t v3;
  _OWORD *v4;

  v1 = this;
  if (*((_DWORD *)this + 10) == 2)
  {
    v2 = CFAllocatorAllocate(this[1], 120, 0);
    *v2 = 0u;
    v2[1] = 0u;
    v2[2] = 0u;
    v2[3] = 0u;
    v2[4] = 0u;
    v2[5] = 0u;
    v2[6] = 0u;
    *((_QWORD *)v2 + 14) = 0;
    RunLoopSchedulingSet::RunLoopSchedulingSet((RunLoopSchedulingSet *)v2, v1[6]);
    return (CFAllocatorRef *)v3;
  }
  if (!*((_BYTE *)this + 116))
  {
    v4 = CFAllocatorAllocate(this[1], 120, 0);
    *v4 = 0u;
    v4[1] = 0u;
    v4[2] = 0u;
    v4[3] = 0u;
    v4[4] = 0u;
    v4[5] = 0u;
    v4[6] = 0u;
    *((_QWORD *)v4 + 14) = 0;
    RunLoopSchedulingSet::RunLoopSchedulingSet((RunLoopSchedulingSet *)v4, v1[9], (const __CFString *)v1[10], (const char *)v1[12]);
    return (CFAllocatorRef *)v3;
  }
  (*((void (**)(CFAllocatorRef *))*this + 5))(this);
  return v1;
}

void HTTPEngine::_chunkedParseHeader(HTTPEngine *this, CFStreamError a2)
{
  int v3;
  NSObject *v4;
  size_t size;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int64_t v10;
  int64_t v11;
  NSObject *subrange;
  NSObject *v13;
  int64_t v14;
  uint64_t v15;
  uint64_t *v16;
  int v17;
  int64_t v18;
  int64_t v19;
  int64_t v21;
  int64_t v22;
  uint64_t v23;
  size_t v24;
  NSObject *v25;
  uint64_t v26;
  NSObject *v27;
  _QWORD v28[5];
  _QWORD applier[6];
  unsigned __int8 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  HTTPEngine *v40;
  uint64_t *v41;
  uint64_t *v42;
  _QWORD v43[3];
  char v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  int64_t v48;

  if (a2.error)
  {
    HTTPEngine::_readBodyFinish((uint64_t)this, 0, a2.domain, *(uint64_t *)&a2.error, 0);
    return;
  }
  v3 = *((_DWORD *)this + 8);
  if ((v3 & 0x8000) != 0)
  {
    HTTPEngine::_chunkedReadTrailer(this);
    return;
  }
  v4 = *((_QWORD *)this + 24);
  if (!v4 || !dispatch_data_get_size(*((dispatch_data_t *)this + 24)))
  {
    HTTPEngine::_chunkedReadHeader(this);
    return;
  }
  v32 = 0;
  v33 = &v32;
  v34 = 0x2020000000;
  v35 = 0;
  size = dispatch_data_get_size(v4);
  v31 = 0;
  v30 = 0;
  if ((v3 & 0x4000) != 0)
  {
    v10 = 0;
  }
  else
  {
    v36 = 0;
    v37 = (uint64_t)&v36;
    v38 = 0x2020000000;
    LOBYTE(v39) = 1;
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3221225472;
    applier[2] = ___ZN10HTTPEngine19_chunkedParseHeaderE13CFStreamError_block_invoke;
    applier[3] = &unk_1E14FD160;
    applier[4] = &v36;
    applier[5] = &v32;
    dispatch_data_apply(v4, applier);
    if (v33[3] == size)
    {
      v6 = -3;
      goto LABEL_9;
    }
    _Block_object_dispose(&v36, 8);
    v10 = v33[3];
    v4 = *((_QWORD *)this + 24);
  }
  v45 = 0;
  v46 = &v45;
  v47 = 0x2020000000;
  v48 = v10;
  v11 = dispatch_data_get_size(v4);
  if (v11 > v10)
  {
    subrange = dispatch_data_create_subrange(v4, v10, v11 - v10);
    v43[0] = 0;
    v43[1] = v43;
    v43[2] = 0x2020000000;
    v44 = 1;
    v36 = MEMORY[0x1E0C809B0];
    v37 = 3221225472;
    v38 = (uint64_t)___ZN10HTTPEngine31_chunkedParseHeader_parseDigitsElPl_block_invoke;
    v39 = &unk_1E14FD0C8;
    v41 = &v45;
    v42 = &v31;
    v40 = (HTTPEngine *)v43;
    dispatch_data_apply(subrange, &v36);
    dispatch_release(subrange);
    v10 = v46[3];
    _Block_object_dispose(v43, 8);
  }
  _Block_object_dispose(&v45, 8);
  v33[3] = v10;
  if (v10 == size)
    goto LABEL_28;
  v13 = *((_QWORD *)this + 24);
  v14 = v10;
LABEL_32:
  v15 = HTTPEngine::_chunkedParseHeader_skipLWS(v13, v14, &v30);
  v16 = v33;
  v33[3] = v15;
  if (v15 == size)
  {
LABEL_28:
    v31 = -3;
    goto LABEL_29;
  }
  v17 = v30;
  while (v17 == 59)
  {
    v18 = v16[3] + 1;
    v16[3] = v18;
    v19 = HTTPEngine::_chunkedParseHeader_skipLWS(*((NSObject **)this + 24), v18, &v30);
    v16 = v33;
    v33[3] = v19;
    if (v19 == size)
      goto LABEL_28;
    v17 = v30;
    if (v30 == 10 || v30 == 13)
      break;
    v21 = HTTPEngine::_chunkedParseHeader_skipToken(*((NSObject **)this + 24), v19);
    v33[3] = v21;
    v22 = HTTPEngine::_chunkedParseHeader_skipLWS(*((NSObject **)this + 24), v21, &v30);
    v16 = v33;
    v33[3] = v22;
    if (v22 == size)
      goto LABEL_28;
    v17 = v30;
    if (v30 == 61)
    {
      v23 = HTTPEngine::_chunkedParseHeader_skipLWS(*((NSObject **)this + 24), v22, &v30);
      v33[3] = v23;
      if (v23 == size)
        goto LABEL_28;
      v24 = v23;
      v25 = *((_QWORD *)this + 24);
      if (v30 == 34)
        v26 = HTTPEngine::_chunkedParseHeader_skipQuotedString(v25, v24);
      else
        v26 = HTTPEngine::_chunkedParseHeader_skipToken(v25, v24);
      v14 = v26;
      v33[3] = v26;
      v13 = *((_QWORD *)this + 24);
      goto LABEL_32;
    }
  }
  if (v17 != 13)
  {
    v7 = -1;
    v31 = -1;
    goto LABEL_10;
  }
  if (v16[3] + 1 == size)
    goto LABEL_28;
  v36 = 0;
  v37 = (uint64_t)&v36;
  v38 = 0x2020000000;
  LOBYTE(v39) = 0;
  v27 = dispatch_data_create_subrange(*((dispatch_data_t *)this + 24), v16[3] + 1, 1uLL);
  v28[0] = MEMORY[0x1E0C809B0];
  v28[1] = 3221225472;
  v28[2] = ___ZN10HTTPEngine19_chunkedParseHeaderE13CFStreamError_block_invoke_2;
  v28[3] = &unk_1E14FD188;
  v28[4] = &v36;
  dispatch_data_apply(v27, v28);
  if (v27)
    dispatch_release(v27);
  if (*(_BYTE *)(v37 + 24) == 10)
  {
    v6 = v31;
    if (v31 < 0)
      v6 = -1;
    v33[3] += 2;
  }
  else
  {
    v6 = -1;
  }
LABEL_9:
  v31 = v6;
  _Block_object_dispose(&v36, 8);
  v7 = v31;
LABEL_10:
  v8 = *((_DWORD *)this + 8);
  if ((v8 & 0x4000) != 0 && v7 != -3)
  {
    v8 &= ~0x4000u;
    *((_DWORD *)this + 8) = v8;
  }
  if (v7 == -1)
  {
    HTTPEngine::_readBodyFinish((uint64_t)this, 0, 4, 0xFFFFFFFFLL, 0);
    goto LABEL_30;
  }
  if (v7 != -3)
  {
    *((_QWORD *)this + 22) = v7;
    *((_QWORD *)this + 23) = 0;
    if (!v7)
      *((_DWORD *)this + 8) = v8 | 0x8000;
    HTTPEngine::_readBufferConsume(this, v33[3]);
    v9 = *((_QWORD *)this + 41);
    if (v9)
      *(_QWORD *)(v9 + 136) += v33[3];
    if ((*((_BYTE *)this + 33) & 0x80) != 0)
    {
      HTTPEngine::_chunkedReadTrailer(this);
    }
    else
    {
      v36 = MEMORY[0x1E0C809B0];
      v37 = 3221225472;
      v38 = (uint64_t)___ZN10HTTPEngine16_chunkedReadBodyEv_block_invoke;
      v39 = &__block_descriptor_40_e47_v36__0__NSObject_OS_dispatch_data__8___qi_16B32l;
      v40 = this;
      HTTPEngine::_getBodyIntelligently((uint64_t)this, (uint64_t)&v36);
    }
    goto LABEL_30;
  }
LABEL_29:
  HTTPEngine::_chunkedReadHeader(this);
LABEL_30:
  _Block_object_dispose(&v32, 8);
}

void sub_183F41C94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN10HTTPEngine31_chunkedParseHeader_parseDigitsElPl_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unsigned int v5;
  unint64_t v6;
  uint64_t v7;
  int v8;

  if (a5)
  {
    v5 = 0;
    v6 = 0;
    while (1)
    {
      v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      if (!*(_BYTE *)(v7 + 24))
        goto LABEL_15;
      v8 = *(unsigned __int8 *)(a4 + v6);
      if ((v8 - 48) <= 9)
        break;
      if ((v8 - 65) <= 5)
      {
        v5 = v8 - 55;
        goto LABEL_11;
      }
      if ((v8 - 97) <= 5)
      {
        v5 = v8 - 87;
        goto LABEL_11;
      }
      *(_BYTE *)(v7 + 24) = 0;
      if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
        goto LABEL_11;
LABEL_12:
      if (v6 >= a5)
        goto LABEL_15;
    }
    v5 = v8 - 48;
LABEL_11:
    **(_QWORD **)(a1 + 48) = 16 * **(_QWORD **)(a1 + 48) + v5;
    ++v6;
    goto LABEL_12;
  }
  v6 = 0;
LABEL_15:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v6;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

uint64_t ___ZN10HTTPEngine19_chunkedParseHeaderE13CFStreamError_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a4;
  return 0;
}

uint64_t HTTPEngine::_chunkedParseHeader_skipLWS(NSObject *this, int64_t a2, unsigned __int8 *a3)
{
  int64_t v4;
  int64_t size;
  NSObject *subrange;
  _QWORD applier[7];
  _QWORD v10[3];
  char v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  int64_t v15;

  v4 = a2;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = a2;
  size = dispatch_data_get_size(this);
  if (size > v4)
  {
    subrange = dispatch_data_create_subrange(this, v4, size - v4);
    v10[0] = 0;
    v10[1] = v10;
    v10[2] = 0x2020000000;
    v11 = 1;
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3221225472;
    applier[2] = ___ZN10HTTPEngine27_chunkedParseHeader_skipLWSElPh_block_invoke;
    applier[3] = &unk_1E14FD0C8;
    applier[5] = &v12;
    applier[6] = a3;
    applier[4] = v10;
    dispatch_data_apply(subrange, applier);
    if (subrange)
      dispatch_release(subrange);
    v4 = v13[3];
    _Block_object_dispose(v10, 8);
  }
  _Block_object_dispose(&v12, 8);
  return v4;
}

uint64_t ___ZN10HTTPEngine27_chunkedParseHeader_skipLWSElPh_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v5;
  uint64_t v6;
  int v7;

  v5 = 0;
  while (v5 < a5)
  {
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (!*(_BYTE *)(v6 + 24))
      break;
    v7 = *(unsigned __int8 *)(a4 + v5);
    if (v7 == 9 || v7 == 32)
    {
      ++v5;
    }
    else
    {
      *(_BYTE *)(v6 + 24) = 0;
      **(_BYTE **)(a1 + 48) = v7;
    }
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v5;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

void ___ZN15HTTP3Connection10initializeEv_block_invoke_3(uint64_t a1, int a2, CFTypeRef cf)
{
  CFTypeID v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD v12[2];

  if (cf)
  {
    v5 = CFGetTypeID(cf);
    if (v5 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v12[0]) = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)v12, 2u);
    }
    if ((CFTypeRef)*MEMORY[0x1E0C9AE50] == cf)
    {
      v6 = *(std::__shared_weak_count **)(a1 + 40);
      if (v6)
      {
        v7 = std::__shared_weak_count::lock(v6);
        v12[1] = v7;
        if (v7)
        {
          v8 = v7;
          v9 = *(_QWORD *)(a1 + 32);
          v12[0] = v9;
          if (v9)
          {
            *(_BYTE *)(v9 + 920) |= 2u;
            if (*(_QWORD *)(v9 + 1136) == *(_QWORD *)(v9 + 1144))
              HTTP3Connection::_cleanupConnection((HTTP3Connection *)v9, 256, 0);
          }
          p_shared_owners = (unint64_t *)&v8->__shared_owners_;
          do
            v11 = __ldaxr(p_shared_owners);
          while (__stlxr(v11 - 1, p_shared_owners));
          if (!v11)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
      }
    }
  }
}

void sub_183F42008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN10HTTPEngine16_chunkedReadBodyEv_block_invoke(uint64_t a1, dispatch_data_t data, uint64_t a3, uint64_t a4, uint64_t a5)
{
  HTTPEngine *v9;
  uint64_t v10;
  size_t size;

  v9 = *(HTTPEngine **)(a1 + 32);
  v10 = *((_QWORD *)v9 + 41);
  if (!data)
  {
    size = 0;
    if (!v10)
      goto LABEL_4;
    goto LABEL_3;
  }
  size = dispatch_data_get_size(data);
  if (v10)
LABEL_3:
    *(_QWORD *)(v10 + 136) += size;
LABEL_4:
  HTTPEngine::_deliverBodyBytes(v9, (uint64_t)data, a3, a4, a5);
}

void std::__shared_ptr_pointer<NSObject  {objcproto24OS_sec_protocol_metadata}*,Deleter_SecRelease<NSObject  {objcproto24OS_sec_protocol_metadata}*>,std::allocator<NSObject  {objcproto24OS_sec_protocol_metadata}>>::__on_zero_shared(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 24);
  if (v1)
    sec_release(v1);
}

void std::__shared_ptr_pointer<BlockHolderVar<> *,SmartBlockWithArgs<>::Deleter,std::allocator<BlockHolderVar<>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  BOOL v4;
  int v5;
  _QWORD *v7;

  v1 = *(_QWORD *)(a1 + 24);
  v3 = *(_QWORD *)(v1 + 8);
  v2 = *(_QWORD *)(v1 + 16);
  if (v2)
    v4 = (*(_QWORD *)(v1 + 16) & 1 | v3) == 0;
  else
    v4 = 1;
  v5 = v4;
  if ((uint64_t (*)(_QWORD *))v3 == BlockHolderVar<>::invoke_initial && v5 != 0)
  {
    v7 = (_QWORD *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0)
      (*(void (**)(_QWORD *))(*v7 + BlockHolderVar<>::invoke_initial))(v7);
    else
      BlockHolderVar<>::invoke_initial(v7);
  }
  _Block_release(*(const void **)v1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_emplace<TLSCallbackServerTrust>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t std::__shared_ptr_emplace<TLSCallbackQueue>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t std::__shared_ptr_emplace<PropertyObserver>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t std::__shared_ptr_emplace<HTTPStallTimer>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void HTTP3ConnectionCacheWrapper::initWithSchedulingSet(HTTP3ConnectionCacheWrapper *this, const CoreSchedulingSet *a2, TubeManager *a3)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_weak_owners;
  unint64_t v8;
  uint64_t v9;
  void *v10;
  NSObject *v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  NSObject *v15;
  _QWORD v16[5];
  _QWORD handler[5];
  std::__shared_weak_count *v18;

  v4 = *((_QWORD *)this + 4);
  *(_QWORD *)(v4 + 64) = a2;
  (*(void (**)(const CoreSchedulingSet *))(*(_QWORD *)a2 + 40))(a2);
  *(_QWORD *)(v4 + 72) = a3;
  v6 = *(_QWORD *)(v4 + 8);
  v5 = *(std::__shared_weak_count **)(v4 + 16);
  if (v5)
  {
    p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
    do
      v8 = __ldxr(p_shared_weak_owners);
    while (__stxr(v8 + 1, p_shared_weak_owners));
    a3 = *(TubeManager **)(v4 + 72);
  }
  v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 64) + 80))(*(_QWORD *)(v4 + 64));
  v10 = *(void **)(v4 + 104);
  *(_QWORD *)(v4 + 104) = v9;

  v11 = *(NSObject **)(v4 + 104);
  v12 = MEMORY[0x1E0C809B0];
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3321888768;
  handler[2] = ___ZN20HTTP3ConnectionCache17_timersInitializeEv_block_invoke;
  handler[3] = &__block_descriptor_48_ea8_32c45_ZTSNSt3__18weak_ptrI20HTTP3ConnectionCacheEE_e5_v8__0l;
  handler[4] = v6;
  v18 = v5;
  if (v5)
  {
    v13 = (unint64_t *)&v5->__shared_weak_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  dispatch_source_set_event_handler(v11, handler);
  (*(void (**)(TubeManager *))(*(_QWORD *)a3 + 40))(a3);
  v15 = *(NSObject **)(v4 + 104);
  v16[0] = v12;
  v16[1] = 3221225472;
  v16[2] = ___ZN20HTTP3ConnectionCache17_timersInitializeEv_block_invoke_2;
  v16[3] = &__block_descriptor_40_e5_v8__0l;
  v16[4] = a3;
  dispatch_source_set_cancel_handler(v15, v16);
  dispatch_source_set_timer(*(dispatch_source_t *)(v4 + 104), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_resume(*(dispatch_object_t *)(v4 + 104));
  HTTP3ConnectionCache::enableCellTimer((HTTP3ConnectionCache *)v4);
  if (v18)
    std::__shared_weak_count::__release_weak(v18);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

void sub_183F422C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  std::__shared_weak_count *v20;

  if (v20)
    std::__shared_weak_count::__release_weak(v20);
  _Unwind_Resume(exception_object);
}

uint64_t HTTP3ConnectionCacheWrapper::ingestTube(HTTP3ConnectionCacheWrapper *this, Tube **a2, int a3)
{
  const HTTPConnectionCacheKey *v3;
  const void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _BOOL4 v8;
  HTTP3Connection *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  __int128 v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t *v21;
  HTTPStallTimer **v22;
  char *v23;
  unint64_t *p_shared_weak_owners;
  unint64_t v25;
  std::__shared_weak_count *v26;
  Tube *v27;
  _QWORD *v28;
  Tube *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  Tube *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  __int128 v42;
  unsigned int v43;
  uint64_t v44;
  int v45;
  double *v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t *v57;
  unint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  uint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  unint64_t v66;
  void *v67;
  _QWORD *v68;
  NSObject *v69;
  std::__shared_weak_count *v70;
  unint64_t *v71;
  unint64_t v72;
  std::__shared_weak_count *v73;
  unint64_t *v74;
  unint64_t v75;
  unint64_t *v76;
  unint64_t v77;
  void *v78;
  _QWORD *v79;
  std::__shared_weak_count *v80;
  unint64_t *v81;
  unint64_t v82;
  uint64_t v83;
  std::__shared_weak_count *v84;
  unint64_t *v85;
  unint64_t v86;
  unint64_t *v87;
  unint64_t v88;
  const char *v89;
  unint64_t *v90;
  unint64_t v91;
  void *v92;
  _QWORD *v93;
  _QWORD *v94;
  _QWORD *v95;
  uint64_t v96;
  uint64_t v97;
  std::__shared_weak_count *v98;
  unint64_t *v99;
  unint64_t v100;
  unint64_t *v101;
  unint64_t v102;
  unint64_t *v103;
  std::__shared_weak_count *v104;
  unint64_t *v105;
  unint64_t v106;
  unsigned int v107;
  unint64_t *v108;
  uint64_t v109;
  size_t v110;
  uint32_t v111;
  size_t v112;
  unint64_t *v113;
  size_t v114;
  uint32_t v115;
  size_t v116;
  unint64_t *v117;
  size_t v118;
  uint64_t v119;
  dispatch_data_t v120;
  _QWORD *v121;
  unint64_t *v122;
  unint64_t v123;
  HTTPStallTimer ***v124;
  unint64_t v125;
  unint64_t v126;
  _QWORD *v127;
  uint64_t v128;
  uint64_t v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  char *v133;
  __int128 v134;
  char *v135;
  unint64_t v136;
  _QWORD *v137;
  _QWORD *v138;
  char *v139;
  __int128 v140;
  int64x2_t v141;
  uint64_t v142;
  void *v143;
  uint64_t v144;
  unint64_t v145;
  std::__shared_weak_count *v146;
  unint64_t *v147;
  unint64_t v148;
  uint64_t *v150;
  HTTP3ConnectionCache *v151;
  _QWORD *v153;
  __int128 v155;
  std::__shared_weak_count *v156;
  uint64_t v157;
  std::__shared_weak_count *v158;
  _QWORD v159[2];
  uint64_t (*v160)(uint64_t);
  void *v161;
  const void *v162;
  uint64_t v163[5];
  std::__shared_weak_count *v164;
  _QWORD v165[2];
  __int128 v166;
  void (*v167)(uint64_t, int, CFTypeRef);
  void *v168;
  uint64_t v169;
  std::__shared_weak_count *v170;
  __int128 aBlock;
  void (*v172)(uint64_t);
  void *v173;
  uint64_t v174;
  std::__shared_weak_count *v175;
  __int128 v176;
  __int128 __src;
  __int128 buffer;
  uint64_t (*v179)(uint64_t);
  void *v180;
  uint64_t v181;
  uint64_t v182;

  v182 = *MEMORY[0x1E0C80C00];
  v3 = (const HTTPConnectionCacheKey *)*((_QWORD *)this + 4);
  v4 = (const void *)Tube::copyKey(a2[13]);
  v159[0] = MEMORY[0x1E0C809B0];
  v159[1] = 3221225472;
  v160 = ___ZN20HTTP3ConnectionCache10ingestTubeEP4Tubeb_block_invoke;
  v161 = &__block_descriptor_40_e5_v8__0l;
  v162 = v4;
  v151 = v3;
  HTTP3ConnectionCache::_entryFindOrCreate((HTTP3ConnectionCache *)&v157, v3, v4);
  v5 = v157;
  v6 = *(_QWORD *)(v157 + 104);
  v7 = *(_QWORD *)(v157 + 112);
  if (v6 == v7)
    goto LABEL_16;
  LOBYTE(v8) = 0;
  do
  {
    v9 = *(HTTP3Connection **)v6;
    v10 = *(std::__shared_weak_count **)(v6 + 8);
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
    }
    if (v8)
    {
      v8 = 1;
      if (!v10)
        goto LABEL_14;
    }
    else
    {
      v8 = HTTP3Connection::willEnqueueRequests(v9);
      if (!v10)
        goto LABEL_14;
    }
    v13 = (unint64_t *)&v10->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
LABEL_14:
    v6 += 16;
  }
  while (v6 != v7);
  if (v8)
    __assert_rtn("ingestTube", "HTTP3ConnectionCacheEntry.mm", 155, "!_willEnqueueRequests()");
LABEL_16:
  v15 = *(_OWORD *)(v5 + 8);
  v155 = v15;
  v16 = *(std::__shared_weak_count **)(v5 + 16);
  if (*((_QWORD *)&v15 + 1))
  {
    v17 = (unint64_t *)(*((_QWORD *)&v15 + 1) + 16);
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  v19 = (char *)operator new(0x4F0uLL);
  v20 = v19;
  *(_OWORD *)(v19 + 8) = 0u;
  v21 = (unint64_t *)(v19 + 8);
  *(_QWORD *)v19 = &off_1E14F0A98;
  *((_QWORD *)v19 + 3) = &off_1E14E78D8;
  v22 = (HTTPStallTimer **)(v19 + 24);
  *((_OWORD *)v19 + 2) = 0u;
  *((_QWORD *)v19 + 6) = &unk_1E14E7928;
  *((_QWORD *)v19 + 81) = 0x200000;
  v23 = v19 + 952;
  *((_QWORD *)v19 + 82) = 0;
  *((_DWORD *)v19 + 166) = 0;
  *((_OWORD *)v19 + 42) = 0u;
  *((_OWORD *)v19 + 43) = 0u;
  *((_OWORD *)v19 + 44) = 0u;
  *((_QWORD *)v19 + 90) = 0;
  *((_DWORD *)v19 + 182) = 1065353216;
  *((_OWORD *)v19 + 46) = 0u;
  *((_OWORD *)v19 + 47) = 0u;
  *((_DWORD *)v19 + 192) = 1065353216;
  *(_OWORD *)(v19 + 776) = 0u;
  *(_OWORD *)(v19 + 792) = 0u;
  *((_DWORD *)v19 + 202) = 1065353216;
  *((_DWORD *)v19 + 204) = 100;
  *(_OWORD *)(v19 + 820) = 0u;
  *(_OWORD *)(v19 + 836) = 0u;
  *(_QWORD *)(v19 + 852) = 0x3F80000000000000;
  *((_OWORD *)v19 + 54) = 0u;
  *((_OWORD *)v19 + 55) = 0u;
  *((_DWORD *)v19 + 224) = 1065353216;
  *(_OWORD *)(v19 + 904) = 0u;
  *(_OWORD *)(v19 + 920) = 0u;
  *((_DWORD *)v19 + 234) = 1065353216;
  *(_OWORD *)(v19 + 952) = xmmword_1841E38D0;
  v19[944] = 0;
  *(_OWORD *)(v19 + 968) = 0u;
  *(_OWORD *)(v19 + 984) = 0u;
  *(_OWORD *)(v19 + 1000) = 0u;
  *(_OWORD *)(v19 + 1016) = 0u;
  *(_OWORD *)(v19 + 1032) = 0u;
  *(_OWORD *)(v19 + 1048) = 0u;
  *(_OWORD *)(v19 + 1064) = 0u;
  *(_OWORD *)(v19 + 1080) = 0u;
  *(_OWORD *)(v19 + 1096) = 0u;
  *(_OWORD *)(v19 + 1112) = 0u;
  *(_OWORD *)(v19 + 1128) = 0u;
  *(_OWORD *)(v19 + 1144) = 0u;
  *(_OWORD *)(v19 + 1160) = 0u;
  *((_QWORD *)v19 + 147) = 0;
  *((_OWORD *)v19 + 78) = 0u;
  *((_OWORD *)v19 + 77) = 0u;
  *((_OWORD *)v19 + 76) = 0u;
  if (v16)
  {
    p_shared_weak_owners = (unint64_t *)&v16->__shared_weak_owners_;
    do
      v25 = __ldxr(p_shared_weak_owners);
    while (__stxr(v25 + 1, p_shared_weak_owners));
    v26 = (std::__shared_weak_count *)*((_QWORD *)v19 + 124);
    *((_OWORD *)v23 + 2) = v155;
    if (v26)
      std::__shared_weak_count::__release_weak(v26);
  }
  else
  {
    *(_OWORD *)(v19 + 984) = (unint64_t)v155;
  }
  v153 = (_QWORD *)v5;
  v27 = a2[17];
  if (v27)
    *((_BYTE *)a2 + 240) = 0;
  v28 = v22 + 126;
  v29 = a2[18];
  *(_QWORD *)&buffer = v27;
  *((_QWORD *)&buffer + 1) = v29;
  if (v29)
  {
    v30 = (unint64_t *)((char *)v29 + 8);
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v22 + 126), &buffer);
  v32 = (std::__shared_weak_count *)*((_QWORD *)&buffer + 1);
  if (*((_QWORD *)&buffer + 1))
  {
    v33 = (unint64_t *)(*((_QWORD *)&buffer + 1) + 8);
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  v150 = (uint64_t *)(v22 + 128);
  v35 = a2[14];
  if (!v35
    || (v36 = (*(uint64_t (**)(Tube *))(*(_QWORD *)v35 + 80))(v35)) == 0
    || (*(unsigned int (**)(uint64_t))(*(_QWORD *)(v36 - 176) + 424))(v36 - 176))
  {
    v20[944] |= 8u;
  }
  *((_QWORD *)v20 + 155) = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v28 + 256))(*v28);
  v37 = *((_QWORD *)v20 + 129);
  v38 = *(_QWORD *)(v37 + 120);
  if (v38)
    dispatch_retain(*(dispatch_object_t *)(v37 + 120));
  v39 = (void *)*((_QWORD *)v20 + 128);
  *((_QWORD *)v20 + 128) = v38;

  *((_QWORD *)v20 + 150) = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX);
  v40 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)v20 + 129) + 104))(*((_QWORD *)v20 + 129));
  v41 = 0;
  v42 = 0uLL;
  *(_OWORD *)(v20 + 168) = 0u;
  *((_QWORD *)v20 + 151) = 1000000 * v40;
  *(_OWORD *)(v20 + 104) = 0u;
  *(_OWORD *)(v20 + 120) = 0u;
  *(_OWORD *)(v20 + 152) = 0u;
  *(_OWORD *)(v20 + 136) = 0u;
  *(_OWORD *)(v20 + 264) = 0u;
  *(_OWORD *)(v20 + 280) = 0u;
  *((_QWORD *)v20 + 15) = v20 + 112;
  *((_QWORD *)v20 + 148) = 0;
  *((_DWORD *)v20 + 298) = 0;
  *(_OWORD *)(v20 + 56) = 0u;
  *(_OWORD *)(v20 + 72) = 0u;
  *(_OWORD *)(v20 + 88) = 0u;
  *(_OWORD *)(v20 + 184) = 0u;
  *(_OWORD *)(v20 + 200) = 0u;
  *(_OWORD *)(v20 + 216) = 0u;
  *(_OWORD *)(v20 + 232) = 0u;
  *(_OWORD *)(v20 + 248) = 0u;
  *((_QWORD *)v20 + 18) = v20 + 136;
  *((_QWORD *)v20 + 20) = v20 + 152;
  *((_QWORD *)v20 + 22) = v20 + 168;
  v43 = *((_DWORD *)v20 + 238);
  v44 = *((_QWORD *)v20 + 120);
  *(_OWORD *)(v20 + 616) = 0u;
  *(_OWORD *)(v20 + 632) = 0u;
  *(_OWORD *)(v20 + 584) = 0u;
  *(_OWORD *)(v20 + 600) = 0u;
  *(_OWORD *)(v20 + 552) = 0u;
  *(_OWORD *)(v20 + 568) = 0u;
  *(_OWORD *)(v20 + 520) = 0u;
  *(_OWORD *)(v20 + 536) = 0u;
  *(_OWORD *)(v20 + 488) = 0u;
  *(_OWORD *)(v20 + 504) = 0u;
  *(_OWORD *)(v20 + 456) = 0u;
  *(_OWORD *)(v20 + 472) = 0u;
  *(_OWORD *)(v20 + 424) = 0u;
  *(_OWORD *)(v20 + 440) = 0u;
  *(_OWORD *)(v20 + 392) = 0u;
  *(_OWORD *)(v20 + 408) = 0u;
  *(_OWORD *)(v20 + 360) = 0u;
  *(_OWORD *)(v20 + 376) = 0u;
  *(_OWORD *)(v20 + 328) = 0u;
  *(_OWORD *)(v20 + 344) = 0u;
  *(_OWORD *)(v20 + 296) = 0u;
  *(_OWORD *)(v20 + 312) = 0u;
  *((_DWORD *)v20 + 75) = v43;
  *((_DWORD *)v20 + 76) = v43;
  v43 >>= 5;
  v45 = 2 * v43 - 1;
  *((_DWORD *)v20 + 82) = v45;
  *((_DWORD *)v20 + 83) = v45;
  *((_DWORD *)v20 + 78) = v44;
  *((_DWORD *)v20 + 79) = v43;
  *((_QWORD *)v20 + 42) = &HTTP3Connection::HTTP3Connection(Tube *,std::weak_ptr<HTTP3ConnectionCacheEntry>)::callbacks;
  *((_QWORD *)v20 + 48) = v20 + 376;
  do
  {
    v46 = (double *)&v20[v41 + 392];
    v47 = (uint64_t)&v20[v41 + 408];
    vst2q_f64(v46, *(float64x2x2_t *)&v42);
    v41 += 32;
  }
  while (v41 != 128);
  if (v16)
    std::__shared_weak_count::__release_weak(v16);
  v48 = (std::__shared_weak_count *)*((_QWORD *)v20 + 5);
  if (!v48)
  {
    do
      v52 = __ldxr(v21);
    while (__stxr(v52 + 1, v21));
    v53 = (unint64_t *)(v20 + 16);
    do
      v54 = __ldxr(v53);
    while (__stxr(v54 + 1, v53));
    *((_QWORD *)v20 + 4) = v22;
    *((_QWORD *)v20 + 5) = v20;
    goto LABEL_55;
  }
  if (v48->__shared_owners_ == -1)
  {
    do
      v49 = __ldxr(v21);
    while (__stxr(v49 + 1, v21));
    v50 = (unint64_t *)(v20 + 16);
    do
      v51 = __ldxr(v50);
    while (__stxr(v51 + 1, v50));
    *((_QWORD *)v20 + 4) = v22;
    *((_QWORD *)v20 + 5) = v20;
    std::__shared_weak_count::__release_weak(v48);
    do
LABEL_55:
      v55 = __ldaxr(v21);
    while (__stlxr(v55 - 1, v21));
    if (!v55)
    {
      (*(void (**)(char *))(*(_QWORD *)v20 + 16))(v20);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v20);
    }
  }
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&buffer, *((_QWORD *)v20 + 4), *((std::__shared_weak_count **)v20 + 5));
  v56 = *v28;
  v176 = buffer;
  v156 = (std::__shared_weak_count *)*((_QWORD *)&buffer + 1);
  if (*((_QWORD *)&buffer + 1))
  {
    v57 = (unint64_t *)(*((_QWORD *)&buffer + 1) + 8);
    do
      v58 = __ldxr(v57);
    while (__stxr(v58 + 1, v57));
  }
  (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)v56 + 184))(v56, &v176);
  v59 = (std::__shared_weak_count *)*((_QWORD *)&v176 + 1);
  if (*((_QWORD *)&v176 + 1))
  {
    v60 = (unint64_t *)(*((_QWORD *)&v176 + 1) + 8);
    do
      v61 = __ldaxr(v60);
    while (__stlxr(v61 - 1, v60));
    if (!v61)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
  }
  v62 = *((_QWORD *)v20 + 4);
  v63 = (std::__shared_weak_count *)*((_QWORD *)v20 + 5);
  if (v63)
  {
    v64 = (unint64_t *)&v63->__shared_weak_owners_;
    do
      v65 = __ldxr(v64);
    while (__stxr(v65 + 1, v64));
    v172 = ___ZN15HTTP3Connection10initializeEv_block_invoke;
    v173 = &__block_descriptor_48_ea8_32c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE_e5_v8__0l;
    v174 = v62;
    v175 = v63;
    do
      v66 = __ldxr(v64);
    while (__stxr(v66 + 1, v64));
  }
  else
  {
    v172 = ___ZN15HTTP3Connection10initializeEv_block_invoke;
    v173 = &__block_descriptor_48_ea8_32c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE_e5_v8__0l;
    v174 = v62;
    v175 = 0;
  }
  *(_QWORD *)&aBlock = MEMORY[0x1E0C809B0];
  *((_QWORD *)&aBlock + 1) = 3321888768;
  v67 = _Block_copy(&aBlock);
  v68 = operator new(0x58uLL);
  v68[1] = 0;
  v68[2] = 0;
  *v68 = &off_1E14F09B8;
  v69 = *((_QWORD *)v20 + 128);
  SmartBlockWithArgs<>::SmartBlockWithArgs((uint64_t *)&buffer, v67);
  HTTPStallTimer::HTTPStallTimer((uint64_t)(v68 + 3), v69, (uint64_t *)&buffer);
  v70 = (std::__shared_weak_count *)*((_QWORD *)&buffer + 1);
  if (*((_QWORD *)&buffer + 1))
  {
    v71 = (unint64_t *)(*((_QWORD *)&buffer + 1) + 8);
    do
      v72 = __ldaxr(v71);
    while (__stlxr(v72 - 1, v71));
    if (!v72)
    {
      ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
      std::__shared_weak_count::__release_weak(v70);
    }
  }
  *(_QWORD *)&v166 = v68 + 3;
  *((_QWORD *)&v166 + 1) = v68;
  std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&v166, v68 + 4, (uint64_t)(v68 + 3));
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v22 + 122), &v166);
  v73 = (std::__shared_weak_count *)*((_QWORD *)&v166 + 1);
  if (*((_QWORD *)&v166 + 1))
  {
    v74 = (unint64_t *)(*((_QWORD *)&v166 + 1) + 8);
    do
      v75 = __ldaxr(v74);
    while (__stlxr(v75 - 1, v74));
    if (!v75)
    {
      ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
      std::__shared_weak_count::__release_weak(v73);
    }
  }

  HTTPStallTimer::setup(v22[122]);
  *(_QWORD *)&v166 = MEMORY[0x1E0C809B0];
  *((_QWORD *)&v166 + 1) = 3321888768;
  v167 = ___ZN15HTTP3Connection10initializeEv_block_invoke_3;
  v168 = &__block_descriptor_48_ea8_32c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE_e25_v24__0____CFString__8_v16l;
  v169 = v62;
  v170 = v63;
  if (v63)
  {
    v76 = (unint64_t *)&v63->__shared_weak_owners_;
    do
      v77 = __ldxr(v76);
    while (__stxr(v77 + 1, v76));
  }
  v78 = _Block_copy(&v166);
  v79 = operator new(0x28uLL);
  v79[1] = 0;
  v79[2] = 0;
  *v79 = &off_1E14F0B78;
  v79[3] = &off_1E14E81C8;
  v79[4] = 0;
  if (v78)
    v79[4] = _Block_copy(v78);
  *(_QWORD *)&buffer = v79 + 3;
  *((_QWORD *)&buffer + 1) = v79;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v20 + 1216), &buffer);
  v80 = (std::__shared_weak_count *)*((_QWORD *)&buffer + 1);
  if (*((_QWORD *)&buffer + 1))
  {
    v81 = (unint64_t *)(*((_QWORD *)&buffer + 1) + 8);
    do
      v82 = __ldaxr(v81);
    while (__stlxr(v82 - 1, v81));
    if (!v82)
    {
      ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
      std::__shared_weak_count::__release_weak(v80);
    }
  }

  v83 = *((_QWORD *)v20 + 129) + 16;
  v84 = (std::__shared_weak_count *)*((_QWORD *)v20 + 153);
  v165[0] = *((_QWORD *)v20 + 152);
  v165[1] = v84;
  if (v84)
  {
    v85 = (unint64_t *)&v84->__shared_owners_;
    do
      v86 = __ldxr(v85);
    while (__stxr(v86 + 1, v85));
  }
  v163[0] = MEMORY[0x1E0C809B0];
  v163[1] = 3321888768;
  v163[2] = (uint64_t)___ZN15HTTP3Connection10initializeEv_block_invoke_6;
  v163[3] = (uint64_t)&__block_descriptor_48_ea8_32c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE_e6__v8__0l;
  v163[4] = v62;
  v164 = v63;
  if (v63)
  {
    v87 = (unint64_t *)&v63->__shared_weak_owners_;
    do
      v88 = __ldxr(v87);
    while (__stxr(v88 + 1, v87));
  }
  NotificationStation::registerForPropertyUpdates(v83, CFSTR("__kCFStreamPropertyDoNotReuse"), v165, (uint64_t)v163);
  if (v84)
  {
    v90 = (unint64_t *)&v84->__shared_owners_;
    do
      v91 = __ldaxr(v90);
    while (__stlxr(v91 - 1, v90));
    if (!v91)
    {
      ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
      std::__shared_weak_count::__release_weak(v84);
    }
  }
  HTTP3Connection::_newClientUnidirectionalStreamHandle((HTTP3Connection *)"outbound control", v89);
  v92 = (void *)objc_claimAutoreleasedReturnValue();
  v93 = operator new(0xB8uLL);
  v94 = v93;
  v93[1] = 0;
  v93[2] = 0;
  *v93 = &off_1E14F07C0;
  v95 = v93 + 3;
  v96 = *((_QWORD *)v20 + 129);
  if (v96)
    v97 = v96 + 112;
  else
    v97 = 0;
  v98 = (std::__shared_weak_count *)*((_QWORD *)v20 + 130);
  *(_QWORD *)&buffer = v97;
  *((_QWORD *)&buffer + 1) = v98;
  if (v98)
  {
    v99 = (unint64_t *)&v98->__shared_owners_;
    do
      v100 = __ldxr(v99);
    while (__stxr(v100 + 1, v99));
  }
  HTTP3Framer::HTTP3Framer((uint64_t)(v93 + 3), (uint64_t *)&buffer, v92, 0, 1);
  if (v98)
  {
    v101 = (unint64_t *)&v98->__shared_owners_;
    do
      v102 = __ldaxr(v101);
    while (__stlxr(v102 - 1, v101));
    if (!v102)
    {
      ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
      std::__shared_weak_count::__release_weak(v98);
    }
  }
  *(_QWORD *)&__src = v95;
  *((_QWORD *)&__src + 1) = v94;
  std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&__src, v95, (uint64_t)v95);
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v150, &__src);
  v104 = (std::__shared_weak_count *)*((_QWORD *)&__src + 1);
  if (*((_QWORD *)&__src + 1))
  {
    v105 = (unint64_t *)(*((_QWORD *)&__src + 1) + 8);
    do
      v106 = __ldaxr(v105);
    while (__stlxr(v106 - 1, v105));
    if (!v106)
    {
      ((void (*)(std::__shared_weak_count *))v104->__on_zero_shared)(v104);
      std::__shared_weak_count::__release_weak(v104);
    }
  }
  *(_QWORD *)&__src = 1;
  LOBYTE(buffer) = 1;
  v107 = QUICUtilities::quic_vle_encode(*((_QWORD *)v20 + 119), (unint64_t *)&__src, v103);
  memcpy((char *)&buffer + 1, &__src, v107);
  *(_QWORD *)&__src = 7;
  *((_BYTE *)&buffer + v107 + 1) = 7;
  v109 = v107 + 2;
  v110 = QUICUtilities::quic_vle_encode(*((_QWORD *)v20 + 120), (unint64_t *)&__src, v108);
  memcpy((char *)&buffer + v109, &__src, v110);
  v111 = arc4random();
  v112 = v109 + v110;
  v114 = QUICUtilities::quic_vle_encode(31 * v111 + 33, (unint64_t *)&__src, v113);
  memcpy((char *)&buffer + v112, &__src, v114);
  v115 = arc4random();
  v116 = v112 + v114;
  LODWORD(v114) = QUICUtilities::quic_vle_encode(v115, (unint64_t *)&__src, v117);
  memcpy((char *)&buffer + v116, &__src, v114);
  v118 = v116 + v114;
  v119 = *v150;
  v120 = dispatch_data_create(&buffer, v118, 0, 0);
  HTTP3Framer::writeFrame(v119, 4uLL, v120, 0, &__block_literal_global_24);

  HTTP3Connection::_requestNewServerStreamHandle((HTTP3Connection *)v22);
  if (v164)
    std::__shared_weak_count::__release_weak(v164);
  if (v170)
    std::__shared_weak_count::__release_weak(v170);
  if (v175)
    std::__shared_weak_count::__release_weak(v175);
  if (v63)
    std::__shared_weak_count::__release_weak(v63);
  v121 = v153;
  if (v156)
  {
    v122 = (unint64_t *)&v156->__shared_owners_;
    do
      v123 = __ldaxr(v122);
    while (__stlxr(v123 - 1, v122));
    if (!v123)
    {
      ((void (*)(std::__shared_weak_count *))v156->__on_zero_shared)(v156);
      std::__shared_weak_count::__release_weak(v156);
    }
  }
  v124 = (HTTPStallTimer ***)v153[14];
  v125 = v153[15];
  if ((unint64_t)v124 >= v125)
  {
    v128 = v153[13];
    v129 = ((uint64_t)v124 - v128) >> 4;
    v130 = v129 + 1;
    if ((unint64_t)(v129 + 1) >> 60)
      abort();
    v131 = v125 - v128;
    if (v131 >> 3 > v130)
      v130 = v131 >> 3;
    if ((unint64_t)v131 >= 0x7FFFFFFFFFFFFFF0)
      v132 = 0xFFFFFFFFFFFFFFFLL;
    else
      v132 = v130;
    if (v132 >> 60)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v133 = (char *)operator new(16 * v132);
    *(_QWORD *)&v134 = v22;
    *((_QWORD *)&v134 + 1) = v20;
    v135 = &v133[16 * v129];
    *(_OWORD *)v135 = v134;
    do
      v136 = __ldxr(v21);
    while (__stxr(v136 + 1, v21));
    v121 = v153;
    v138 = (_QWORD *)v153[13];
    v137 = (_QWORD *)v153[14];
    if (v137 == v138)
    {
      v141 = vdupq_n_s64((unint64_t)v137);
      v139 = v135;
    }
    else
    {
      v139 = v135;
      do
      {
        v140 = *((_OWORD *)v137 - 1);
        v137 -= 2;
        *((_OWORD *)v139 - 1) = v140;
        v139 -= 16;
        *v137 = 0;
        v137[1] = 0;
      }
      while (v137 != v138);
      v141 = *(int64x2_t *)(v153 + 13);
    }
    v127 = v135 + 16;
    v153[13] = v139;
    v153[14] = v135 + 16;
    v153[15] = &v133[16 * v132];
    v142 = v141.i64[1];
    v143 = (void *)v141.i64[0];
    while ((void *)v142 != v143)
      v142 = std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v142 - 16);
    if (v143)
      operator delete(v143);
  }
  else
  {
    *v124 = v22;
    v124[1] = (HTTPStallTimer **)v20;
    do
      v126 = __ldxr(v21);
    while (__stxr(v126 + 1, v21));
    v127 = v124 + 2;
  }
  v121[14] = v127;
  *((_BYTE *)v121 + 136) = 1;
  if (a3)
  {
    v144 = Tube::copyWaiter(a2[14]);
    *(_QWORD *)&buffer = MEMORY[0x1E0C809B0];
    *((_QWORD *)&buffer + 1) = 3221225472;
    v179 = ___ZN25HTTP3ConnectionCacheEntry10ingestTubeEP4Tubeb_block_invoke;
    v180 = &__block_descriptor_40_e5_v8__0l;
    v181 = v144;
    v163[0] = 0;
    *(_QWORD *)&__src = 0;
    aBlock = 0x3F000000FFFFFFFFuLL;
    LODWORD(v172) = 0;
    (*(void (**)(uint64_t, uint64_t *, __int128 *, __int128 *))(*(_QWORD *)v144 + 104))(v144, v163, &__src, &aBlock);
    v166 = aBlock;
    v167 = (void (*)(uint64_t, int, CFTypeRef))v172;
    HTTP3ConnectionCacheEntry::enqueueRequestForProtocol(v121, v163[0], __src, (uint64_t)&v166);
    v179((uint64_t)&buffer);
  }
  do
    v145 = __ldaxr(v21);
  while (__stlxr(v145 - 1, v21));
  if (!v145)
  {
    (*(void (**)(char *))(*(_QWORD *)v20 + 16))(v20);
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v20);
  }
  HTTP3ConnectionCache::_timersStart(v151);
  v146 = v158;
  if (v158)
  {
    v147 = (unint64_t *)&v158->__shared_owners_;
    do
      v148 = __ldaxr(v147);
    while (__stlxr(v148 - 1, v147));
    if (!v148)
    {
      ((void (*)(std::__shared_weak_count *))v146->__on_zero_shared)(v146);
      std::__shared_weak_count::__release_weak(v146);
    }
  }
  return v160((uint64_t)v159);
}

void sub_183F430AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, HTTP2ServerPush *a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, char a20,uint64_t a21,void (*a22)(char *),uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,std::__shared_weak_count *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,std::__shared_weak_count *a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,std::__shared_weak_count *a44)
{
  unint64_t *v44;
  std::__shared_weak_count *v45;
  unint64_t v47;
  unint64_t *p_shared_owners;
  unint64_t v49;

  do
    v47 = __ldaxr(v44);
  while (__stlxr(v47 - 1, v44));
  if (!v47)
  {
    ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
    std::__shared_weak_count::__release_weak(v45);
  }
  if (a19)
  {
    p_shared_owners = (unint64_t *)&a19->__shared_owners_;
    do
      v49 = __ldaxr(p_shared_owners);
    while (__stlxr(v49 - 1, p_shared_owners));
    if (!v49)
    {
      ((void (*)(std::__shared_weak_count *))a19->__on_zero_shared)(a19);
      std::__shared_weak_count::__release_weak(a19);
    }
  }
  a22(&a20);
  _Unwind_Resume(a1);
}

void HTTP3Framer::writeFrame(uint64_t a1, unint64_t a2, void *a3, int a4, void *a5)
{
  NSObject *v9;
  id v10;
  unint64_t *v11;
  unsigned int v12;
  size_t size;
  unint64_t *v14;
  size_t v15;
  size_t v16;
  unint64_t *v17;
  NSObject *v18;
  char v19;
  unint64_t v20;
  unsigned int v21;
  NSObject *v22;
  dispatch_data_t concat;
  uint64_t v24;
  id v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  dispatch_data_t v29;
  id v30;
  void (*v31)(uint64_t, uint64_t, uint64_t, dispatch_data_t, _QWORD *);
  id v32;
  void *v33;
  NSObject *data2;
  _QWORD v35[4];
  id v36;
  id v37;
  size_t v38;
  uint64_t v39;
  char v40;
  unint64_t buffer;
  unint64_t __src;
  _BYTE __dst[16];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v9 = a3;
  v10 = a5;
  if (!v9)
    __assert_rtn("writeFrame", "HTTP3Frame.mm", 254, "data");
  v33 = v10;
  __src = 0;
  v12 = QUICUtilities::quic_vle_encode(a2, &__src, v11);
  memcpy(__dst, &__src, v12);
  size = dispatch_data_get_size(v9);
  v15 = QUICUtilities::quic_vle_encode(size, &__src, v14);
  memcpy(&__dst[v12], &__src, v15);
  v16 = v15 + v12;
  v18 = dispatch_data_create(__dst, v16, 0, 0);
  v19 = *(_BYTE *)(a1 + 40);
  if (v19)
  {
    v20 = *(_QWORD *)(a1 + 32);
    buffer = 0;
    v21 = QUICUtilities::quic_vle_encode(v20, &buffer, v17);
    v22 = dispatch_data_create(&buffer, v21, 0, 0);
    concat = dispatch_data_create_concat(v22, v18);

    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 40) = 0;

    v18 = concat;
  }
  data2 = v9;
  v24 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
  v25 = *(id *)(a1 + 56);
  v26 = *(_QWORD *)(a1 + 16);
  v27 = *(_QWORD *)(a1 + 56);
  v28 = a4 ^ 1u;
  v29 = dispatch_data_create_concat(v18, data2);
  v35[0] = MEMORY[0x1E0C809B0];
  v35[1] = 3221225472;
  v35[2] = ___ZN11HTTP3Framer10writeFrameEN2H39FrameTypeEPU27objcproto16OS_dispatch_data8NSObjectbU13block_pointerFvm13CFStreamErrorE_block_invoke;
  v35[3] = &unk_1E14F6DF0;
  v30 = v33;
  v40 = v19;
  v36 = v25;
  v37 = v30;
  v38 = v16;
  v39 = v24;
  v31 = *(void (**)(uint64_t, uint64_t, uint64_t, dispatch_data_t, _QWORD *))(*(_QWORD *)v26 + 32);
  v32 = v25;
  v31(v26, v27, v28, v29, v35);

}

void sub_183F43684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t QUICUtilities::quic_vle_encode(unint64_t this, unint64_t *a2, unint64_t *a3)
{
  uint64_t result;
  int v5;
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (this > 0x3F)
  {
    if (this >> 14)
    {
      if (this >> 30)
      {
        if (this >> 62)
        {
          result = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT);
          if ((_DWORD)result)
          {
            v5 = 134217984;
            v6 = this;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "unable to encode quic vle value: %llu", (uint8_t *)&v5, 0xCu);
            return 0;
          }
        }
        else
        {
          *a2 = bswap64(this | 0xC000000000000000);
          return 8;
        }
      }
      else
      {
        *a2 = bswap32(this | 0x80000000);
        return 4;
      }
    }
    else
    {
      *a2 = bswap32(this | 0x4000) >> 16;
      return 2;
    }
  }
  else
  {
    *a2 = this;
    return 1;
  }
  return result;
}

uint64_t `non-virtual thunk to'NWIOConnection::getConnectionID(NWIOConnection *this)
{
  return *((_QWORD *)this + 22);
}

void `non-virtual thunk to'NWIOConnection::writeWithContext(uint64_t a1, NSObject *a2, int a3, NSObject *a4, uint64_t a5)
{
  NWIOConnection::writeWithContext((NWIOConnection *)(a1 - 112), a2, a3, a4, a5);
}

NSObject *HTTP3Connection::_newClientUnidirectionalStreamHandle(HTTP3Connection *this, const char *a2)
{
  NSObject *connection_metadata;
  NSObject *v4;

  if (HTTP3Connection::_newClientUnidirectionalStreamHandle(char const*)::onceToken != -1)
    dispatch_once(&HTTP3Connection::_newClientUnidirectionalStreamHandle(char const*)::onceToken, &__block_literal_global_33);
  connection_metadata = nw_quic_create_connection_metadata();
  nw_quic_connection_metadata_set_stream_options();
  v4 = nw_content_context_create((const char *)this);
  nw_content_context_set_metadata_for_protocol(v4, connection_metadata);

  return v4;
}

void sub_183F43870(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void HTTP3ConnectionCacheEntry::enqueueRequestForProtocol(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __CFHTTPMessage *v8;
  const __CFURL *v9;
  uint64_t v10;
  const __CFAllocator *v11;
  CFHTTPMessageRef Copy;
  _QWORD *v13;
  HTTPRequestMessage *v14;
  HTTPRequestMessage *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  HTTP3Connection *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  int64x2_t *v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  _BYTE *v34;
  void *v35;
  unint64_t *v36;
  unint64_t v37;
  uint64_t v38;
  const void *v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  float v43;
  int v44;
  double v45;
  void *v46;
  double Current;
  double *v48;
  double v49;
  _OWORD *v50;
  void *v51;
  std::__shared_weak_count *v52;
  std::__shared_weak_count_vtbl *v53;
  unint64_t *p_shared_weak_owners;
  unint64_t v55;
  BOOL v56;
  id v57;
  void *v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t *v61;
  unint64_t v62;
  id v63;
  unint64_t *v64;
  unint64_t v65;
  std::__shared_weak_count_vtbl *v66;
  _QWORD *v67;
  std::__shared_weak_count *v68;
  float v69;
  std::__shared_weak_count *shared_weak_owners;
  unint64_t v71;
  unint64_t *v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t *v75;
  unint64_t v76;
  unint64_t v77;
  std::__shared_weak_count *v78;
  unint64_t *v79;
  unint64_t v80;
  __int128 v81;
  unint64_t *v82;
  unint64_t v83;
  __int128 *v84;
  unint64_t v85;
  _OWORD *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  char *v92;
  uint64_t v93;
  char *v94;
  _QWORD *v95;
  _QWORD *v96;
  char *v97;
  __int128 v98;
  int64x2_t v99;
  CFArrayRef *v100;
  void *v101;
  uint64_t v102;
  void *v103;
  std::__shared_weak_count *v104;
  unint64_t *v105;
  unint64_t v106;
  BOOL v107;
  id v108;
  __int128 *v109;
  int v110;
  std::__shared_weak_count *v111[2];
  uint64_t v112;
  const __CFURL *v113;
  _QWORD *v114;
  _QWORD v115[2];
  uint64_t (*v116)(uint64_t);
  void *v117;
  _OWORD *v118;
  HTTP3Connection *v119;
  std::__shared_weak_count *v120;
  _QWORD v121[2];
  void (*v122)(uint64_t);
  void *v123;
  CFHTTPMessageRef v124;
  __int128 v125;
  uint64_t v126;

  v8 = (__CFHTTPMessage *)(a3 - 16);
  v9 = CFHTTPMessageCopyRequestURL((CFHTTPMessageRef)(a3 - 16));
  if (a2)
    v10 = a2 - 176;
  else
    v10 = 0;
  if ((HTTPProtocol::canUseH2WithCurrentAuthScheme((HTTPProtocol *)v10, v9) & 1) == 0)
    goto LABEL_136;
  v113 = v9;
  v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Copy = CFHTTPMessageCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v8);
  v121[0] = MEMORY[0x1E0C809B0];
  v121[1] = 3221225472;
  v122 = ___ZN25HTTP3ConnectionCacheEntry25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke;
  v123 = &__block_descriptor_40_e5_v8__0l;
  v124 = Copy;
  v13 = (_QWORD *)a1[16];
  v114 = a1;
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (*((_BYTE *)Copy + 40))
    v14 = 0;
  else
    v14 = (CFHTTPMessageRef)((char *)Copy + 16);
  AuthenticationCache::processRequest(v13, a2, v14);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (*((_BYTE *)Copy + 40))
    v15 = 0;
  else
    v15 = (CFHTTPMessageRef)((char *)Copy + 16);
  AuthenticationCache::applyAuthenticationToRequest(a2, v15);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v110 = *((unsigned __int8 *)Copy + 40);
  if (*((_BYTE *)Copy + 40))
    v16 = 0;
  else
    v16 = (char *)Copy + 16;
  v112 = (uint64_t)v16;
  v119 = 0;
  v120 = 0;
  v17 = a1[13];
  v18 = a1[14];
  while (v17 != v18)
  {
    v20 = *(HTTP3Connection **)v17;
    v19 = *(std::__shared_weak_count **)(v17 + 8);
    *(_QWORD *)&v125 = *(_QWORD *)v17;
    *((_QWORD *)&v125 + 1) = v19;
    if (v19)
    {
      p_shared_owners = (unint64_t *)&v19->__shared_owners_;
      do
        v22 = __ldxr(p_shared_owners);
      while (__stxr(v22 + 1, p_shared_owners));
    }
    if (HTTP3Connection::willEnqueueRequests(v20))
    {
      if (v19)
      {
        v25 = (unint64_t *)&v19->__shared_owners_;
        do
          v26 = __ldxr(v25);
        while (__stxr(v26 + 1, v25));
      }
      v119 = v20;
      v120 = v19;
      if (*((_QWORD *)&v125 + 1))
      {
        v27 = (unint64_t *)(*((_QWORD *)&v125 + 1) + 8);
        do
          v28 = __ldaxr(v27);
        while (__stlxr(v28 - 1, v27));
        if (!v28)
        {
          (*(void (**)(_QWORD))(**((_QWORD **)&v125 + 1) + 16))(*((_QWORD *)&v125 + 1));
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v125 + 1));
        }
      }
      break;
    }
    if (v19)
    {
      v23 = (unint64_t *)&v19->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
    v17 += 16;
  }
  v29 = (int64x2_t *)v119;
  if (v119)
  {
    if (objc_msgSend(*(id *)(v10 + 80), "_preconnect"))
    {
      v30 = *((_QWORD *)v119 + 126);
      v31 = (std::__shared_weak_count *)*((_QWORD *)v119 + 127);
      *(_QWORD *)&v125 = v30;
      *((_QWORD *)&v125 + 1) = v31;
      if (v31)
      {
        v32 = (unint64_t *)&v31->__shared_owners_;
        do
          v33 = __ldxr(v32);
        while (__stxr(v33 + 1, v32));
      }
      v9 = v113;
      if (v30)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v10 + 744))(v10);
        v34 = (_BYTE *)objc_claimAutoreleasedReturnValue();
        (*(void (**)(uint64_t))(*(_QWORD *)v30 + 248))(v30);
        v35 = (void *)objc_claimAutoreleasedReturnValue();
        -[__CFN_TransactionMetrics linkWithConnection:](v34, v35);

        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v30 + 88))(v30, 1);
      }
      if (v31)
      {
        v36 = (unint64_t *)&v31->__shared_owners_;
        do
          v37 = __ldaxr(v36);
        while (__stlxr(v37 - 1, v36));
        if (!v37)
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
        }
      }
      v38 = *((_QWORD *)v119 + 126);
      if (v38)
        v39 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v38 + 216))(v38, 0x1EDCFAD40);
      else
        v39 = 0;
      v101 = *(void **)(v10 + 80);
      if (v101)
        objc_msgSend(v101, "set_TCPConnectionMetadata:", v39);
      if (v39)
        CFRelease(v39);
      URLProtocol::sendDidFinishLoading((URLProtocol *)v10);
      goto LABEL_130;
    }
    v43 = *(float *)(a4 + 4);
    v44 = *(unsigned __int8 *)(a4 + 16);
    v45 = 0.0;
    if (*((_QWORD *)v119 + 142) == *((_QWORD *)v119 + 143))
    {
      (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)v119 + 126) + 88))(*((_QWORD *)v119 + 126), 0);
      (*(void (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)v119 + 126) + 136))(*((_QWORD *)v119 + 126), 0, 0);
      (*(void (**)(_QWORD))(**((_QWORD **)v119 + 126) + 248))(*((_QWORD *)v119 + 126));
      v46 = (void *)objc_claimAutoreleasedReturnValue();
      Current = CFAbsoluteTimeGetCurrent();
      (*(void (**)(_QWORD))(**((_QWORD **)v119 + 126) + 248))(*((_QWORD *)v119 + 126));
      v48 = (double *)objc_claimAutoreleasedReturnValue();
      if (v48)
        v49 = v48[22];
      else
        v49 = 0.0;
      v45 = Current - v49;

    }
    v50 = CFAllocatorAllocate(v11, 48, 0);
    v50[1] = 0u;
    v50[2] = 0u;
    *v50 = 0u;
    v51 = (void *)v29[62].i64[1];
    v53 = (std::__shared_weak_count_vtbl *)v29->i64[1];
    v52 = (std::__shared_weak_count *)v29[1].i64[0];
    if (v52)
    {
      p_shared_weak_owners = (unint64_t *)&v52->__shared_weak_owners_;
      do
        v55 = __ldxr(p_shared_weak_owners);
      while (__stxr(v55 + 1, p_shared_weak_owners));
    }
    v56 = v44 != 0;
    v57 = v51;
    *(_QWORD *)v50 = off_1E14EF578;
    *((_QWORD *)v50 + 1) = v11;
    *((_DWORD *)v50 + 4) = 1;
    if (((unint64_t)(v50 + 1) & 3) != 0)
      __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
    v58 = v57;
    v107 = v56;
    *((_QWORD *)v50 + 3) = &unk_1E14E9580;
    *(_QWORD *)v50 = off_1E14E94A8;
    *((_QWORD *)v50 + 4) = 0;
    v109 = v50 + 2;
    *((_QWORD *)v50 + 5) = 0;
    v59 = (std::__shared_weak_count *)operator new(0x1A0uLL);
    v59->__shared_owners_ = 0;
    v60 = (unint64_t *)&v59->__shared_owners_;
    v59->__shared_weak_owners_ = 0;
    v59->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F07F8;
    if (v52)
    {
      v61 = (unint64_t *)&v52->__shared_weak_owners_;
      do
        v62 = __ldxr(v61);
      while (__stxr(v62 + 1, v61));
    }
    v63 = v58;
    v59[2].__vftable = 0;
    v59[1].__shared_owners_ = 0;
    v59[1].__shared_weak_owners_ = 0;
    v59[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14E5010;
    v59[2].__shared_owners_ = 0;
    v108 = v63;
    v59[2].__shared_weak_owners_ = (uint64_t)v108;
    v59[3].__vftable = v53;
    v59[3].__shared_owners_ = (uint64_t)v52;
    if (v52)
    {
      v64 = (unint64_t *)&v52->__shared_weak_owners_;
      do
        v65 = __ldxr(v64);
      while (__stxr(v65 + 1, v64));
    }
    if (!v110)
      CFRetain((CFTypeRef)(v112 - 16));
    v59[3].__shared_weak_owners_ = v112;
    v66 = (std::__shared_weak_count_vtbl *)operator new();
    v66->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))&off_1E14F16D8;
    v66->~__shared_weak_count_0 = 0;
    v66->__on_zero_shared = 0;
    v66->__get_deleter = (const void *(__cdecl *)(const std::__shared_weak_count *__hidden, const std::type_info *))v112;
    v59[8].__shared_weak_owners_ = 0;
    *(_OWORD *)&v59[4].__shared_owners_ = 0u;
    v59[5].std::__shared_count = 0u;
    v59[4].__vftable = v66;
    *(_OWORD *)((char *)&v59[5].__shared_owners_ + 4) = 0u;
    *(_DWORD *)((char *)&v59[6].__vftable + 6) = 0;
    WORD1(v59[6].__shared_owners_) = 1;
    BYTE4(v59[6].__shared_owners_) = 0;
    *(_OWORD *)&v59[6].__shared_weak_owners_ = 0u;
    *(_OWORD *)&v59[7].__shared_owners_ = 0u;
    v59[8].__vftable = (std::__shared_weak_count_vtbl *)-1;
    BYTE1(v59[8].__shared_owners_) = 0;
    v59[9].__vftable = 0;
    v59[9].__shared_owners_ = 0;
    v59[12].__shared_weak_owners_ = 0;
    v59[13].__vftable = 0;
    LODWORD(v59[12].__shared_owners_) = 0;
    v59[11].__shared_weak_owners_ = 0;
    v59[12].__vftable = 0;
    if (a2)
      (*(void (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v59[13].__shared_owners_ = a2;
    v67 = (_QWORD *)operator new();
    *v67 = &off_1E14F1828;
    v67[1] = 0;
    v67[2] = 0;
    v67[3] = a2;
    v59[14].__shared_owners_ = 0;
    v59[14].__shared_weak_owners_ = 0;
    v59[13].__shared_weak_owners_ = (uint64_t)v67;
    v59[14].__vftable = 0;
    v59[15].__vftable = (std::__shared_weak_count_vtbl *)-1;
    v59[15].__shared_owners_ = 0;
    (*(void (**)(uint64_t))(*(_QWORD *)v59[13].__shared_owners_ + 72))(v59[13].__shared_owners_);
    v68 = v59 + 1;
    LOWORD(v59[16].__shared_owners_) = 0;
    v59[16].__shared_weak_owners_ = 0;
    if (v43 >= 0.5)
      v69 = (float)((float)(1.0 - v43) * 20.0) / 3.0;
    else
      v69 = ceilf((float)(0.7 - v43) * 10.0);
    BYTE4(v59[6].__vftable) = (int)v69;
    BYTE5(v59[6].__vftable) = v107;
    *(double *)&v59[17].__vftable = v45;

    if (v52)
      std::__shared_weak_count::__release_weak(v52);
    *(_QWORD *)&v125 = v59 + 1;
    *((_QWORD *)&v125 + 1) = v59;
    shared_weak_owners = (std::__shared_weak_count *)v59[1].__shared_weak_owners_;
    if (shared_weak_owners)
    {
      if (shared_weak_owners->__shared_owners_ != -1)
      {
LABEL_92:
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v109, &v125);
        v78 = (std::__shared_weak_count *)*((_QWORD *)&v125 + 1);
        if (*((_QWORD *)&v125 + 1))
        {
          v79 = (unint64_t *)(*((_QWORD *)&v125 + 1) + 8);
          do
            v80 = __ldaxr(v79);
          while (__stlxr(v80 - 1, v79));
          if (!v80)
          {
            ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
            std::__shared_weak_count::__release_weak(v78);
          }
        }

        if (v52)
          std::__shared_weak_count::__release_weak(v52);
        v125 = *v109;
        v81 = v125;
        if (*((_QWORD *)&v125 + 1))
        {
          v82 = (unint64_t *)(*((_QWORD *)&v125 + 1) + 8);
          do
            v83 = __ldxr(v82);
          while (__stxr(v83 + 1, v82));
        }
        v84 = (__int128 *)v29[71].i64[1];
        v85 = v29[72].u64[0];
        if ((unint64_t)v84 >= v85)
        {
          *(_OWORD *)v111 = v81;
          v87 = v29[71].i64[0];
          v88 = ((uint64_t)v84 - v87) >> 4;
          if ((unint64_t)(v88 + 1) >> 60)
            abort();
          v89 = v85 - v87;
          v90 = v89 >> 3;
          if (v89 >> 3 <= (unint64_t)(v88 + 1))
            v90 = v88 + 1;
          if ((unint64_t)v89 >= 0x7FFFFFFFFFFFFFF0)
            v91 = 0xFFFFFFFFFFFFFFFLL;
          else
            v91 = v90;
          v92 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<HTTP3Stream>>>(v91);
          v94 = &v92[16 * v88];
          *(_OWORD *)v94 = *(_OWORD *)v111;
          v95 = (_QWORD *)v29[71].i64[1];
          v96 = (_QWORD *)v29[71].i64[0];
          if (v95 == v96)
          {
            v99 = vdupq_n_s64((unint64_t)v95);
            v97 = &v92[16 * v88];
          }
          else
          {
            v97 = &v92[16 * v88];
            do
            {
              v98 = *((_OWORD *)v95 - 1);
              v95 -= 2;
              *((_OWORD *)v97 - 1) = v98;
              v97 -= 16;
              *v95 = 0;
              v95[1] = 0;
            }
            while (v95 != v96);
            v99 = v29[71];
          }
          v86 = v94 + 16;
          v29[71].i64[0] = (uint64_t)v97;
          v29[71].i64[1] = (uint64_t)(v94 + 16);
          v29[72].i64[0] = (uint64_t)&v92[16 * v93];
          v102 = v99.i64[1];
          v103 = (void *)v99.i64[0];
          while ((void *)v102 != v103)
            v102 = std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v102 - 16);
          if (v103)
            operator delete(v103);
        }
        else
        {
          *v84 = v81;
          v86 = v84 + 1;
        }
        v29[71].i64[1] = (uint64_t)v86;
        v115[0] = MEMORY[0x1E0C809B0];
        v115[1] = 3221225472;
        v116 = ___ZN25HTTP3ConnectionCacheEntry25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke_2;
        v117 = &__block_descriptor_40_e5_v8__0l;
        v118 = v50;
        v9 = v113;
        if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a2 + 80))(a2, (uint64_t)v50 + 24, v112, *((unsigned __int8 *)v114 + 136)))
        {
          *((_BYTE *)v114 + 136) = 0;
        }
        v116((uint64_t)v115);
        goto LABEL_130;
      }
      do
        v71 = __ldxr(v60);
      while (__stxr(v71 + 1, v60));
      v72 = (unint64_t *)&v59->__shared_weak_owners_;
      do
        v73 = __ldxr(v72);
      while (__stxr(v73 + 1, v72));
      v59[1].__shared_owners_ = (uint64_t)v68;
      v59[1].__shared_weak_owners_ = (uint64_t)v59;
      std::__shared_weak_count::__release_weak(shared_weak_owners);
    }
    else
    {
      do
        v74 = __ldxr(v60);
      while (__stxr(v74 + 1, v60));
      v75 = (unint64_t *)&v59->__shared_weak_owners_;
      do
        v76 = __ldxr(v75);
      while (__stxr(v76 + 1, v75));
      v59[1].__shared_owners_ = (uint64_t)v68;
      v59[1].__shared_weak_owners_ = (uint64_t)v59;
    }
    do
      v77 = __ldaxr(v60);
    while (__stlxr(v77 - 1, v60));
    if (!v77)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
    goto LABEL_92;
  }
  v9 = v113;
  v40 = v114[12];
  v41 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
  TubeManager::invalidateKey(v40, v41, 1, 2u);
  v42 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
  if (CFStringCompare(*(CFStringRef *)(v42 + 32), *(CFStringRef *)(v42 + 136), 0))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a2 - 176) + 280))(a2 - 176, 4, 4294965096, 0);
  }
  else
  {
    v100 = (CFArrayRef *)v114[12];
    v125 = *(_OWORD *)a4;
    v126 = *(_QWORD *)(a4 + 16);
    TubeManager::_onqueue_enqueueRequestForProtocol(v100, a2, a3, &v125, 0);
  }
LABEL_130:
  v104 = v120;
  if (v120)
  {
    v105 = (unint64_t *)&v120->__shared_owners_;
    do
      v106 = __ldaxr(v105);
    while (__stlxr(v106 - 1, v105));
    if (!v106)
    {
      ((void (*)(std::__shared_weak_count *))v104->__on_zero_shared)(v104);
      std::__shared_weak_count::__release_weak(v104);
    }
  }
  v122((uint64_t)v121);
LABEL_136:
  if (v9)
    CFRelease(v9);
}

void sub_183F44324(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,CFTypeRef cf,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,char a30,uint64_t a31,void (*a32)(char *))
{
  const void *v32;

  if (v32)
    CFRelease(v32);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a28);
  a32(&a30);
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(a1);
}

void ___ZN25HTTP3ConnectionCacheEntry25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

BOOL HTTP3Connection::willEnqueueRequests(HTTP3Connection *this)
{
  uint64_t v2;
  __uint64_t v3;

  if (*((_DWORD *)this + 292) || (*((_BYTE *)this + 920) & 6) != 0)
    return 0;
  if (*((_QWORD *)this + 142) != *((_QWORD *)this + 143))
    return 1;
  v2 = *((_QWORD *)this + 148);
  if (!v2)
    return 1;
  v3 = v2 + *((_QWORD *)this + 147) - 1000000000;
  return v3 > clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX);
}

void HTTP3ConnectionCache::_entryFindOrCreate(HTTP3ConnectionCache *this, const HTTPConnectionCacheKey *a2, const void *a3)
{
  _QWORD *Value;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  std::__shared_weak_count_vtbl *v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_weak_owners;
  unint64_t v19;
  std::__shared_weak_count_vtbl *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t *v25;
  unint64_t v26;
  __int128 v27;
  std::__shared_weak_count_vtbl *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *shared_owners;
  _QWORD *v32;
  std::__shared_weak_count *v33;
  uint64_t v34;
  std::__shared_weak_count *shared_weak_owners;
  unint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  uint64_t v52;
  _QWORD v53[2];
  uint64_t (*v54)(uint64_t);
  void *v55;
  _QWORD *v56;
  __int128 v57;

  Value = CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 11), a3);
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  if (Value)
  {
    v7 = Value[4];
    *(_QWORD *)&v57 = Value[3];
    *((_QWORD *)&v57 + 1) = v7;
    if (v7)
    {
      v8 = (unint64_t *)(v7 + 8);
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this, &v57);
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v57 + 1);
    if (*((_QWORD *)&v57 + 1))
    {
      v11 = (unint64_t *)(*((_QWORD *)&v57 + 1) + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    return;
  }
  v13 = *MEMORY[0x1E0C9AE00];
  v14 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 48, 0);
  v15 = v14;
  *((_OWORD *)v14 + 1) = 0u;
  *((_OWORD *)v14 + 2) = 0u;
  *(_OWORD *)v14 = 0u;
  v16 = (std::__shared_weak_count_vtbl *)*((_QWORD *)a2 + 1);
  v17 = (std::__shared_weak_count *)*((_QWORD *)a2 + 2);
  if (v17)
  {
    p_shared_weak_owners = (unint64_t *)&v17->__shared_weak_owners_;
    do
      v19 = __ldxr(p_shared_weak_owners);
    while (__stxr(v19 + 1, p_shared_weak_owners));
  }
  v21 = *((_QWORD *)a2 + 8);
  v20 = (std::__shared_weak_count_vtbl *)*((_QWORD *)a2 + 9);
  *v14 = off_1E14EF578;
  v14[1] = v13;
  *((_DWORD *)v14 + 4) = 1;
  if (((unint64_t)(v14 + 2) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *v14 = off_1E14EF530;
  v14[3] = 0;
  v52 = (uint64_t)(v14 + 3);
  v14[4] = 0;
  v22 = (std::__shared_weak_count *)operator new(0xA8uLL);
  v23 = v22;
  v22->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v22->__shared_owners_;
  v22->__shared_weak_owners_ = 0;
  v22->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0DE0;
  if (v17)
  {
    v25 = (unint64_t *)&v17->__shared_weak_owners_;
    do
      v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
  }
  *(_OWORD *)&v22[5].__shared_owners_ = 0u;
  v22[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14ED468;
  v22[1].__shared_owners_ = 0;
  v22[2].__vftable = 0;
  v22[2].__shared_owners_ = 0;
  v22[1].__shared_weak_owners_ = 0;
  v27 = *(_OWORD *)((char *)a2 + 40);
  *(_OWORD *)&v22[2].__shared_weak_owners_ = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)&v22[3].__shared_owners_ = v27;
  v28 = (std::__shared_weak_count_vtbl *)*((_QWORD *)a2 + 7);
  *(_OWORD *)&v22[4].__shared_weak_owners_ = 0u;
  v22[6].std::__shared_count = 0u;
  LOBYTE(v22[6].__shared_weak_owners_) = 0;
  v22[4].__vftable = v28;
  v22[4].__shared_owners_ = (uint64_t)a3;
  (*(void (**)(const void *))(*(_QWORD *)a3 + 40))(a3);
  if (v17)
  {
    v29 = (unint64_t *)&v17->__shared_weak_owners_;
    do
      v30 = __ldxr(v29);
    while (__stxr(v30 + 1, v29));
  }
  shared_owners = (std::__shared_weak_count *)v23[2].__shared_owners_;
  v23[2].__vftable = v16;
  v23[2].__shared_owners_ = (uint64_t)v17;
  if (shared_owners)
    std::__shared_weak_count::__release_weak(shared_owners);
  v23[4].__shared_weak_owners_ = v21;
  (*(void (**)(uint64_t))(*(_QWORD *)v21 + 40))(v21);
  v23[5].__vftable = v20;
  v32 = (_QWORD *)operator new();
  v33 = v23 + 1;
  *v32 = &off_1E14E9AC8;
  v32[1] = v32 + 1;
  v32[2] = v32 + 1;
  v32[3] = 0;
  v34 = v23[6].__shared_owners_;
  v23[6].__shared_owners_ = (uint64_t)v32;
  if (v34)
    (*(void (**)(uint64_t))(*(_QWORD *)v34 + 8))(v34);
  if (v17)
    std::__shared_weak_count::__release_weak(v17);
  *(_QWORD *)&v57 = v23 + 1;
  *((_QWORD *)&v57 + 1) = v23;
  shared_weak_owners = (std::__shared_weak_count *)v23[1].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    do
      v39 = __ldxr(p_shared_owners);
    while (__stxr(v39 + 1, p_shared_owners));
    v40 = (unint64_t *)&v23->__shared_weak_owners_;
    do
      v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
    v23[1].__shared_owners_ = (uint64_t)v33;
    v23[1].__shared_weak_owners_ = (uint64_t)v23;
    do
LABEL_36:
      v42 = __ldaxr(p_shared_owners);
    while (__stlxr(v42 - 1, p_shared_owners));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
    goto LABEL_39;
  }
  if (shared_weak_owners->__shared_owners_ == -1)
  {
    do
      v36 = __ldxr(p_shared_owners);
    while (__stxr(v36 + 1, p_shared_owners));
    v37 = (unint64_t *)&v23->__shared_weak_owners_;
    do
      v38 = __ldxr(v37);
    while (__stxr(v38 + 1, v37));
    v23[1].__shared_owners_ = (uint64_t)v33;
    v23[1].__shared_weak_owners_ = (uint64_t)v23;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
    goto LABEL_36;
  }
LABEL_39:
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v52, &v57);
  v43 = (std::__shared_weak_count *)*((_QWORD *)&v57 + 1);
  if (*((_QWORD *)&v57 + 1))
  {
    v44 = (unint64_t *)(*((_QWORD *)&v57 + 1) + 8);
    do
      v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }
  v15[5] = a3;
  (*(void (**)(const void *))(*(_QWORD *)a3 + 40))(a3);
  if (v17)
    std::__shared_weak_count::__release_weak(v17);
  CFDictionarySetValue(*((CFMutableDictionaryRef *)a2 + 11), a3, v15);
  v53[0] = MEMORY[0x1E0C809B0];
  v53[1] = 3221225472;
  v54 = ___ZN20HTTP3ConnectionCache18_entryFindOrCreateEPK22HTTPConnectionCacheKey_block_invoke;
  v55 = &__block_descriptor_40_e5_v8__0l;
  v56 = v15;
  v46 = v15[4];
  *(_QWORD *)&v57 = v15[3];
  *((_QWORD *)&v57 + 1) = v46;
  if (v46)
  {
    v47 = (unint64_t *)(v46 + 8);
    do
      v48 = __ldxr(v47);
    while (__stxr(v48 + 1, v47));
  }
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this, &v57);
  v49 = (std::__shared_weak_count *)*((_QWORD *)&v57 + 1);
  if (*((_QWORD *)&v57 + 1))
  {
    v50 = (unint64_t *)(*((_QWORD *)&v57 + 1) + 8);
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
  v54((uint64_t)v53);
}

void sub_183F449F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  std::__shared_weak_count *v12;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a12);
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a11);
  _Unwind_Resume(a1);
}

void HTTP3ConnectionCache::_timersStart(HTTP3ConnectionCache *this)
{
  NSObject *v2;
  dispatch_time_t v3;
  NSObject *v4;
  dispatch_time_t v5;

  if (!*((_BYTE *)this + 96))
  {
    *((_BYTE *)this + 96) = 1;
    v2 = *((_QWORD *)this + 13);
    v3 = dispatch_time(0, 1000000000 * *((int *)this + 14));
    dispatch_source_set_timer(v2, v3, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    v4 = *((_QWORD *)this + 14);
    v5 = dispatch_time(0, 1000000000 * *((int *)this + 15));
    dispatch_source_set_timer(v4, v5, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
  }
}

void NWIOConnection::setQUICKeepalive(uint64_t a1)
{
  NSObject *v2;
  nw_protocol_metadata_t v3;

  if (*(_QWORD *)(a1 + 272))
  {
    v2 = nw_protocol_copy_quic_connection_definition();
    v3 = nw_connection_copy_protocol_metadata(*(nw_connection_t *)(a1 + 272), v2);
    if (v3)
    {
      nw_quic_connection_set_keepalive();
      nw_release(v3);
    }
    if (v2)
      nw_release(v2);
  }
}

void sub_183F44BD0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  nw_release(v2);
  if (v1)
    nw_release(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN25HTTP3ConnectionCacheEntry25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

void HTTP3Connection::_tryCreateBidirectionalStreams(HTTP3Connection *this)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *connection_metadata;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t StreamID;
  uint64_t v19;
  void (**v20)(void *, uint64_t *, uint64_t, _QWORD);
  int64x2_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  __int128 v38;
  uint64_t v39;
  std::__shared_weak_count *v40;

  if (*((_QWORD *)this + 139))
  {
    v2 = (uint64_t *)((char *)this + 1120);
    do
    {
      v3 = *v2;
      if (!*v2)
      {
        if (HTTP3Connection::_newClientBidirectionalStreamHandle(char const*)::onceToken != -1)
          dispatch_once(&HTTP3Connection::_newClientBidirectionalStreamHandle(char const*)::onceToken, &__block_literal_global_34);
        connection_metadata = nw_quic_create_connection_metadata();
        nw_quic_connection_metadata_set_stream_options();
        v5 = nw_content_context_create("request");
        nw_content_context_set_metadata_for_protocol(v5, connection_metadata);

        v6 = operator new(0xB8uLL);
        v7 = v6;
        v6[1] = 0;
        v6[2] = 0;
        *v6 = &off_1E14F07C0;
        v8 = *((_QWORD *)this + 126);
        if (v8)
          v9 = v8 + 112;
        else
          v9 = 0;
        v10 = (std::__shared_weak_count *)*((_QWORD *)this + 127);
        v39 = v9;
        v40 = v10;
        if (v10)
        {
          p_shared_owners = (unint64_t *)&v10->__shared_owners_;
          do
            v12 = __ldxr(p_shared_owners);
          while (__stxr(v12 + 1, p_shared_owners));
        }
        HTTP3Framer::HTTP3Framer((uint64_t)(v6 + 3), &v39, v5, 0, 0);
        if (v10)
        {
          v13 = (unint64_t *)&v10->__shared_owners_;
          do
            v14 = __ldaxr(v13);
          while (__stlxr(v14 - 1, v13));
          if (!v14)
          {
            ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
            std::__shared_weak_count::__release_weak(v10);
          }
        }
        *(_QWORD *)&v38 = v7 + 3;
        *((_QWORD *)&v38 + 1) = v7;
        std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&v38, v7 + 3, (uint64_t)(v7 + 3));
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v2, &v38);
        v15 = (std::__shared_weak_count *)*((_QWORD *)&v38 + 1);
        if (*((_QWORD *)&v38 + 1))
        {
          v16 = (unint64_t *)(*((_QWORD *)&v38 + 1) + 8);
          do
            v17 = __ldaxr(v16);
          while (__stlxr(v17 - 1, v16));
          if (!v17)
          {
            ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
            std::__shared_weak_count::__release_weak(v15);
          }
        }

        v3 = *v2;
      }
      StreamID = HTTP3Framer::getStreamID(*(NSObject **)(v3 + 48));
      if (StreamID == -1)
        break;
      v19 = StreamID;
      v20 = (void (**)(void *, uint64_t *, uint64_t, _QWORD))_Block_copy(*(const void **)(*(_QWORD *)(*((_QWORD *)this + 135) + ((*((_QWORD *)this + 138) >> 6) & 0x3FFFFFFFFFFFFF8))
                                                                                                 + 8
                                                                                                 * (*((_QWORD *)this + 138) & 0x1FFLL)));
      objc_release(*(id *)(*(_QWORD *)(*((_QWORD *)this + 135) + ((*((_QWORD *)this + 138) >> 6) & 0x3FFFFFFFFFFFFF8))
                         + 8 * (*((_QWORD *)this + 138) & 0x1FFLL)));
      v21 = vaddq_s64(*((int64x2_t *)this + 69), (int64x2_t)xmmword_1841E3870);
      *((int64x2_t *)this + 69) = v21;
      if (v21.i64[0] >= 0x400uLL)
      {
        operator delete(**((void ***)this + 135));
        *((_QWORD *)this + 135) += 8;
        *((_QWORD *)this + 138) -= 512;
      }
      v22 = (std::__shared_weak_count *)*((_QWORD *)this + 141);
      v39 = *((_QWORD *)this + 140);
      v40 = v22;
      if (v22)
      {
        v23 = (unint64_t *)&v22->__shared_owners_;
        do
          v24 = __ldxr(v23);
        while (__stxr(v24 + 1, v23));
      }
      v38 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v2, &v38);
      v25 = (std::__shared_weak_count *)*((_QWORD *)&v38 + 1);
      if (*((_QWORD *)&v38 + 1))
      {
        v26 = (unint64_t *)(*((_QWORD *)&v38 + 1) + 8);
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
      v36 = v39;
      v37 = v40;
      if (v40)
      {
        v28 = (unint64_t *)&v40->__shared_owners_;
        do
          v29 = __ldxr(v28);
        while (__stxr(v29 + 1, v28));
      }
      v20[2](v20, &v36, v19, 0);
      v30 = v37;
      if (v37)
      {
        v31 = (unint64_t *)&v37->__shared_owners_;
        do
          v32 = __ldaxr(v31);
        while (__stlxr(v32 - 1, v31));
        if (!v32)
        {
          ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
          std::__shared_weak_count::__release_weak(v30);
        }
      }
      v33 = v40;
      if (v40)
      {
        v34 = (unint64_t *)&v40->__shared_owners_;
        do
          v35 = __ldaxr(v34);
        while (__stlxr(v35 - 1, v34));
        if (!v35)
        {
          ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
          std::__shared_weak_count::__release_weak(v33);
        }
      }

    }
    while (*((_QWORD *)this + 139));
  }
}

void sub_183F44F80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  std::__shared_weak_count *v7;
  void *v8;
  void *v10;
  va_list va;

  va_start(va, a7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::__shared_weak_count::~__shared_weak_count(v7);
  operator delete(v10);

  _Unwind_Resume(a1);
}

uint64_t HTTP3Framer::HTTP3Framer(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, char a5)
{
  id v10;
  void **v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  id v19;
  void *v20;

  v10 = a3;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_BYTE *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  v11 = (void **)(a1 + 48);
  *(_QWORD *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 128) = 0;
  *(_OWORD *)a1 = 0u;
  *(_BYTE *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 76) = 0u;
  *(_OWORD *)(a1 + 92) = 0u;
  *(_DWORD *)(a1 + 108) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  v13 = *a2;
  v12 = a2[1];
  if (v12)
  {
    v14 = (unint64_t *)(v12 + 8);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
    v16 = *(std::__shared_weak_count **)(a1 + 24);
    *(_QWORD *)(a1 + 16) = v13;
    *(_QWORD *)(a1 + 24) = v12;
    if (v16)
    {
      p_shared_owners = (unint64_t *)&v16->__shared_owners_;
      do
        v18 = __ldaxr(p_shared_owners);
      while (__stlxr(v18 - 1, p_shared_owners));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
  else
  {
    *(_QWORD *)(a1 + 16) = v13;
    *(_QWORD *)(a1 + 24) = 0;
  }
  *(_QWORD *)(a1 + 32) = a4;
  *(_BYTE *)(a1 + 40) = a5;
  objc_storeStrong((id *)(a1 + 56), a3);
  if (a5)
    v19 = 0;
  else
    v19 = v10;
  v20 = *v11;
  *v11 = v19;

  if (v10)
    (*(void (**)(_QWORD, id))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16), v10);

  return a1;
}

void sub_183F45130(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v5;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  v5 = *(std::__shared_weak_count **)(v2 + 8);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);

  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'NWIOConnection::registerContext()
{
  return nw_connection_register_context();
}

void ___ZN11HTTP3Stream26scheduleAndOpenWithHandlerEPK17CoreSchedulingSetU13block_pointerFvP15__CFHTTPMessagePU27objcproto16OS_dispatch_data8NSObjectPK13CFStreamErrorEU13block_pointerFvhE_block_invoke(uint64_t a1, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  std::__shared_weak_count_vtbl *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  uint64_t v31;
  __CFString *v32;
  __CFString *v33;
  uint64_t v34;
  uint64_t v35;
  dispatch_source_t v36;
  void *v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *p_shared_weak_owners;
  unint64_t v41;
  NSObject *v42;
  unint64_t *v43;
  unint64_t v44;
  NSObject *v45;
  dispatch_time_t v46;
  NSObject *v47;
  HTTP3Stream *v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  uint64_t v52;
  void *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t (*v56)(uint64_t, uint64_t, CFIndex, uint64_t);
  void *v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  _BYTE handler[24];
  void *v61;
  uint64_t v62;
  std::__shared_weak_count *v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD *)(a1 + 40);
  v8 = *(_QWORD *)(a1 + 48);
  v11 = *a2;
  v10 = a2[1];
  if (v10)
  {
    v12 = (unint64_t *)(v10 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v14 = *(std::__shared_weak_count **)(v8 + 32);
  *(_QWORD *)(v8 + 24) = v11;
  *(_QWORD *)(v8 + 32) = v10;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = *a2;
  v18 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 296);
  if (v18)
    v19 = v18 - 176;
  else
    v19 = 0;
  v20 = *(std::__shared_weak_count_vtbl **)(v19 + 64);
  if (v20)
  {
    Throttler::getByteHeadroomInfoBlock(v20);
    v21 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v21 = 0;
  }
  v22 = _Block_copy(v21);

  v23 = _Block_copy(v22);
  v24 = *(void **)(v17 + 64);
  *(_QWORD *)(v17 + 64) = v23;

  v25 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(v25 + 336) = a3;
  *(_BYTE *)(v25 + 126) = a4;
  v26 = *(_QWORD *)(v25 + 344);
  if (v26)
  {
    *(_BYTE *)(v26 + 10) = a4;
    if ((a4 & 1) != 0)
    {
      *(CFAbsoluteTime *)(v26 + 184) = CFAbsoluteTimeGetCurrent();
      v25 = *(_QWORD *)(a1 + 48);
LABEL_18:
      *(_DWORD *)(v25 + 112) = 4;
LABEL_19:
      HTTP3Stream::_read(*(HTTP3Stream **)(a1 + 48), 0);
      return;
    }
  }
  else if ((a4 & 1) != 0)
  {
    goto LABEL_18;
  }
  if (a3 != -1)
  {
    v27 = MEMORY[0x1E0C809B0];
    v54 = MEMORY[0x1E0C809B0];
    v55 = 3321888768;
    v56 = ___ZN11HTTP3Stream26scheduleAndOpenWithHandlerEPK17CoreSchedulingSetU13block_pointerFvP15__CFHTTPMessagePU27objcproto16OS_dispatch_data8NSObjectPK13CFStreamErrorEU13block_pointerFvhE_block_invoke_1;
    v57 = &__block_descriptor_48_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE_e16_v32__0Q8___qi_16l;
    v28 = *(std::__shared_weak_count **)(a1 + 56);
    v58 = v25;
    v59 = v28;
    if (v28)
    {
      v29 = (unint64_t *)&v28->__shared_owners_;
      do
        v30 = __ldxr(v29);
      while (__stxr(v30 + 1, v29));
    }
    HTTP3Stream::_sendHEADERS((_QWORD *)v25, (_QWORD *)(a1 + 64), 0, &v54);
    v31 = *(_QWORD *)(a1 + 48);
    if (*(_QWORD *)(v31 + 96))
    {
      v32 = (__CFString *)HTTPMessage::copyHeaderFieldValue(*(HTTPMessage **)(v31 + 64), (const __CFString *)&unk_1EDCFD040);
      v33 = v32;
      if (v32
        && (-[__CFString rangeOfString:options:](v32, "rangeOfString:options:", 0x1EDCFDAC0, 1, v54, v55, v56, v57, v58), v34))
      {
        v35 = *(_QWORD *)(a1 + 48);
        *(_DWORD *)(v35 + 112) = 1;
        v36 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(v35 + 40));
        v37 = *(void **)(v35 + 136);
        *(_QWORD *)(v35 + 136) = v36;

        v38 = *(_QWORD *)(v35 + 8);
        v39 = *(std::__shared_weak_count **)(v35 + 16);
        if (v39)
        {
          p_shared_weak_owners = (unint64_t *)&v39->__shared_weak_owners_;
          do
            v41 = __ldxr(p_shared_weak_owners);
          while (__stxr(v41 + 1, p_shared_weak_owners));
        }
        v42 = *(NSObject **)(v35 + 136);
        *(_QWORD *)handler = v27;
        *(_QWORD *)&handler[8] = 3321888768;
        *(_QWORD *)&handler[16] = ___ZN11HTTP3Stream22_start100ContinueTimerEv_block_invoke;
        v61 = &__block_descriptor_48_ea8_32c36_ZTSNSt3__18weak_ptrI11HTTP3StreamEE_e5_v8__0l;
        v62 = v38;
        v63 = v39;
        if (v39)
        {
          v43 = (unint64_t *)&v39->__shared_weak_owners_;
          do
            v44 = __ldxr(v43);
          while (__stxr(v44 + 1, v43));
        }
        dispatch_source_set_event_handler(v42, handler);
        v45 = *(NSObject **)(v35 + 136);
        v46 = dispatch_time(0, 5000000000);
        dispatch_source_set_timer(v45, v46, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
        dispatch_resume(*(dispatch_object_t *)(v35 + 136));
        if (v63)
          std::__shared_weak_count::__release_weak(v63);
        if (v39)
          std::__shared_weak_count::__release_weak(v39);
      }
      else
      {
        v48 = *(HTTP3Stream **)(a1 + 48);
        *((_DWORD *)v48 + 28) = 2;
        HTTP3Stream::_resumeRequestBody(v48);
        (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 48) + 96) + 40))(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 96), *(_QWORD *)(a1 + 112), 0);
      }

    }
    v49 = v59;
    if (v59)
    {
      v50 = (unint64_t *)&v59->__shared_owners_;
      do
        v51 = __ldaxr(v50);
      while (__stlxr(v51 - 1, v50));
      if (!v51)
      {
        ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
        std::__shared_weak_count::__release_weak(v49);
      }
    }
    goto LABEL_19;
  }
  CFN_LOG_h3stream();
  v47 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
  {
    v52 = *(_QWORD *)(v9 + 352);
    v53 = *(void **)(v9 + 336);
    *(_DWORD *)handler = 138543874;
    *(_QWORD *)&handler[4] = v52;
    *(_WORD *)&handler[12] = 2048;
    *(_QWORD *)&handler[14] = v9;
    *(_WORD *)&handler[22] = 2048;
    v61 = v53;
    _os_log_error_impl(&dword_183ECA000, v47, OS_LOG_TYPE_ERROR, "%{public}@ %p ID=%llu failed to create quic stream", handler, 0x20u);
  }

  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
}

void sub_183F45568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void *v5;
  va_list va;

  va_start(va, a5);

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void HTTP3Stream::_sendHEADERS(_QWORD *a1, _QWORD *a2, int a3, void *a4)
{
  void (**v7)(id, _QWORD, uint64_t, uint64_t);
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  FILE *v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  int v22;
  uint64_t v23;
  FILE *v24;
  uint64_t v25;
  unint64_t *p_shared_owners;
  unint64_t v27;
  float v28;
  float v29;
  FILE *v30;
  float v31;
  float v32;
  unint64_t v33;
  unsigned int v34;
  uint64_t v35;
  int v36;
  FILE *v37;
  uint64_t v38;
  FILE *v39;
  FILE *v40;
  int64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  char *v47;
  unsigned int v48;
  unsigned int v49;
  BOOL v50;
  unsigned int v51;
  char v52;
  unsigned int v53;
  unint64_t v54;
  char *v55;
  char *v56;
  unint64_t *v57;
  uint64_t v58;
  unsigned int v59;
  FILE *v60;
  FILE *v61;
  dispatch_data_t subrange;
  size_t v63;
  dispatch_data_t v64;
  uint64_t v65;
  int v66;
  NSObject *v67;
  std::__shared_weak_count *v68;
  unint64_t *v69;
  unint64_t v70;
  uint64_t v71;
  _QWORD v72[4];
  NSObject *v73;
  void (**v74)(id, _QWORD, uint64_t, uint64_t);
  uint64_t *v75;
  _QWORD v76[13];
  std::__shared_weak_count *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t *v81;
  uint64_t v82;
  uint64_t (*v83)(uint64_t, uint64_t);
  void (*v84)(uint64_t);
  id v85;
  uint64_t v86;
  uint64_t *v87;
  uint64_t v88;
  uint64_t (*v89)(uint64_t, uint64_t);
  void (*v90)(uint64_t);
  id alloc;
  _QWORD v92[4];
  _QWORD v93[4];
  uint64_t v94;
  uint64_t *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t *v99;
  uint64_t v100;
  uint64_t v101;
  _QWORD v102[4];
  _QWORD v103[4];
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  std::__shared_weak_count *v107;
  _WORD __src[11];
  _QWORD v109[2];

  v109[0] = *MEMORY[0x1E0C80C00];
  v7 = a4;
  v106 = 0;
  v107 = 0;
  v8 = (std::__shared_weak_count *)a1[7];
  if (!v8)
  {
    v9 = 0;
    goto LABEL_12;
  }
  v9 = std::__shared_weak_count::lock(v8);
  v107 = v9;
  if (!v9 || (v10 = a1[6], (v106 = v10) == 0))
  {
LABEL_12:
    v7[2](v7, 0, 4, 4294967292);
    if (!v9)
      goto LABEL_90;
    goto LABEL_13;
  }
  v104 = 0;
  v105 = 0;
  v103[0] = 0;
  v103[1] = v103;
  v103[2] = 0x2020000000;
  v103[3] = 0;
  v102[0] = 0;
  v102[1] = v102;
  v102[2] = 0x2020000000;
  v102[3] = 0;
  v98 = 0;
  v99 = &v98;
  v100 = 0x2020000000;
  v101 = 22;
  v94 = 0;
  v95 = &v94;
  v96 = 0x2020000000;
  v97 = 0;
  v93[0] = 0;
  v93[1] = v93;
  v93[2] = 0x2020000000;
  v93[3] = 512;
  v92[0] = 0;
  v92[1] = v92;
  v92[2] = 0x2020000000;
  v92[3] = 512;
  v86 = 0;
  v87 = &v86;
  v88 = 0x3032000000;
  v89 = __Block_byref_object_copy__17;
  v90 = __Block_byref_object_dispose__18;
  alloc = (id)dispatch_data_create_alloc();
  v80 = 0;
  v81 = &v80;
  v82 = 0x3032000000;
  v83 = __Block_byref_object_copy__17;
  v84 = __Block_byref_object_dispose__18;
  v85 = (id)dispatch_data_create_alloc();
  if ((*(_BYTE *)(v10 + 44) & 1) != 0)
    __assert_rtn("_sendHEADERS", "HTTP3Stream.mm", 694, "status == 0");
  v11 = v105;
  v12 = a1[42];
  v13 = *(FILE **)(v10 + 232);
  if (v13)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v13);
    fprintf(*(FILE **)(v10 + 232), "Start header for stream %llu", v12);
    fputc(10, *(FILE **)(v10 + 232));
  }
  v14 = (_QWORD *)(v10 + 112);
  while (1)
  {
    v14 = (_QWORD *)*v14;
    if (!v14)
      break;
    v15 = v14[1];
    if (v15 != -1)
      goto LABEL_21;
  }
  if ((*(_BYTE *)(v10 + 44) & 4) != 0
    || 4112 * (unint64_t)*(unsigned int *)(v10 + 76) < *(unsigned int *)(v10 + 52))
  {
    v14 = malloc_type_malloc(0x1010uLL, 0x10A0040497EC00CuLL);
    if (v14)
    {
      v15 = 0;
      *v14 = 0;
      v14[1] = 0;
      **(_QWORD **)(v10 + 120) = v14;
      *(_QWORD *)(v10 + 120) = v14;
      ++*(_DWORD *)(v10 + 76);
LABEL_21:
      v18 = __clz(__rbit64(~v15));
      v14[1] = (1 << v18) | v15;
      v19 = &v14[8 * v18];
      v19[2] = 0;
      v19 += 2;
      *(_OWORD *)(v19 + 3) = 0u;
      *(_OWORD *)(v19 + 5) = 0u;
      v19[7] = 0;
      *(_OWORD *)(v19 + 1) = 0u;
      v19[4] = v19;
      v20 = *(_QWORD **)(v10 + 136);
      v19[1] = v20;
      *v20 = v19;
      *(_QWORD *)(v10 + 136) = v19;
      *(_QWORD *)(v10 + 160) = v19;
      v21 = (_QWORD *)(v10 + 160);
      v19[5] = v12;
      *((_DWORD *)v19 + 12) = a3;
      goto LABEL_22;
    }
  }
  *(_QWORD *)(v10 + 160) = 0;
  v21 = (_QWORD *)(v10 + 160);
  v24 = *(FILE **)(v10 + 232);
  if (v24)
  {
    fwrite("qenc: info: ", 0xCuLL, 1uLL, v24);
    fprintf(*(FILE **)(v10 + 232), "could not allocate hinfo for stream %llu", v12);
    fputc(10, *(FILE **)(v10 + 232));
  }
LABEL_22:
  *(_QWORD *)(v10 + 168) = 0;
  *(_DWORD *)(v10 + 176) = 0;
  v22 = *(_DWORD *)(v10 + 32);
  *(_DWORD *)(v10 + 184) = 0;
  *(_DWORD *)(v10 + 188) = v22;
  if (a3)
  {
    if (*v21)
    {
      v23 = *(_QWORD *)(v10 + 144);
      if (v23)
      {
        while (*(_QWORD *)(v23 + 40) != v12)
        {
          v23 = *(_QWORD *)(v23 + 16);
          if (!v23)
            goto LABEL_31;
        }
        *(_QWORD *)(v10 + 168) = v23;
      }
    }
  }
LABEL_31:
  *(_DWORD *)(v10 + 44) |= 1u;
  v25 = MEMORY[0x1E0C809B0];
  v76[0] = MEMORY[0x1E0C809B0];
  v76[2] = ___ZN11HTTP3Stream12_sendHEADERSERK11HTTP3FieldsbU13block_pointerFvm13CFStreamErrorE_block_invoke;
  v76[3] = &unk_1E14F2358;
  v76[4] = v103;
  v76[5] = v93;
  v76[6] = &v98;
  v76[7] = v102;
  v76[8] = v92;
  v76[9] = &v94;
  v76[12] = v10;
  v77 = v9;
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  v76[1] = 3321888768;
  do
    v27 = __ldxr(p_shared_owners);
  while (__stxr(v27 + 1, p_shared_owners));
  v78 = v104;
  v79 = v105;
  v76[10] = &v80;
  v76[11] = &v86;
  HTTP3Fields::enumerateFields(a2, v76);
  if ((*(_BYTE *)(v10 + 44) & 1) == 0)
LABEL_93:
    __assert_rtn("_sendHEADERS", "HTTP3Stream.mm", 738, "prefixBufferSize >= 0");
  if (*(_QWORD *)(v10 + 248))
  {
    v28 = *(float *)(v10 + 244);
    v29 = (float)*(unsigned int *)(v10 + 176);
    if (v28 != 0.0)
      v29 = v28 + (float)(v29 - v28) * 0.4;
    *(float *)(v10 + 244) = v29;
    v30 = *(FILE **)(v10 + 232);
    if (v30)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v30);
      fprintf(*(FILE **)(v10 + 232), "header count actual: %u; exponential moving average: %.3f",
        *(_DWORD *)(v10 + 176),
        *(float *)(v10 + 244));
      fputc(10, *(FILE **)(v10 + 232));
    }
    v31 = *(float *)(v10 + 240);
    if (v31 != 0.0 && v31 > *(float *)(v10 + 244))
    {
      v32 = vabds_f32((float)*(unsigned int *)(v10 + 260), v31);
      if (v32 >= 1.5 || (float)(v32 / v31) >= 0.1)
        qenc_hist_update_size(v10 + 32, vcvtas_u32_f32(v31));
    }
  }
  v33 = *(_QWORD *)(v10 + 160);
  if (!v33)
  {
    __src[0] = 0;
    v39 = *(FILE **)(v10 + 232);
    if (v39)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v39);
      fwrite("ended header; hinfo absent", 0x1AuLL, 1uLL, *(FILE **)(v10 + 232));
      fputc(10, *(FILE **)(v10 + 232));
    }
    goto LABEL_55;
  }
  v34 = *(_DWORD *)(v33 + 60);
  if (!v34)
  {
    __src[0] = 0;
    v40 = *(FILE **)(v10 + 232);
    if (v40)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v40);
      fprintf(*(FILE **)(v10 + 232), "ended header for stream %llu; dynamic table not referenced",
        *(_QWORD *)(*(_QWORD *)(v10 + 160) + 40));
      fputc(10, *(FILE **)(v10 + 232));
      v33 = *(_QWORD *)(v10 + 160);
    }
    enc_free_hinfo(v10 + 32, v33);
    *(_QWORD *)(v10 + 160) = 0;
LABEL_55:
    *(_DWORD *)(v10 + 44) &= ~1u;
    *(_DWORD *)(v10 + 228) += 2;
    v41 = 2;
    goto LABEL_79;
  }
  LOBYTE(__src[0]) = 0;
  v35 = v34 % (2 * *(_DWORD *)(v10 + 60));
  v36 = v35 + 1;
  v37 = *(FILE **)(v10 + 232);
  if (v37)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v37);
    fprintf(*(FILE **)(v10 + 232), "LargestRef for stream %llu is encoded as %u", *(_QWORD *)(v33 + 40), v35 + 1);
    fputc(10, *(FILE **)(v10 + 232));
  }
  if (v35 > 0xFD)
  {
    LOBYTE(__src[0]) = -1;
    v42 = v35 - 254;
    if ((unint64_t)(v35 - 254) < 0x80)
    {
      v71 = v11;
      HIBYTE(__src[0]) = v35 + 2;
      v38 = 2;
    }
    else
    {
      v43 = 1;
      do
      {
        if (v43 == 22)
          goto LABEL_62;
        v44 = v43;
        *((_BYTE *)__src + v43) = v42 | 0x80;
        v45 = v42 >> 7;
        ++v43;
        v46 = v42 >> 14;
        v42 >>= 7;
      }
      while (v46);
      if (v44 > 0x14 || (*((_BYTE *)__src + v43) = v45, v44 == 20))
      {
LABEL_62:
        v41 = 0;
LABEL_72:
        v25 = MEMORY[0x1E0C809B0];
        goto LABEL_79;
      }
      v71 = v11;
      v38 = v44 + 2;
    }
  }
  else
  {
    v71 = v11;
    LOBYTE(__src[0]) |= v36;
    v38 = 1;
  }
  v47 = (char *)__src + v38;
  v48 = *(_DWORD *)(v10 + 188);
  v49 = *(_DWORD *)(v33 + 60);
  v50 = v48 >= v49;
  v51 = v48 - v49;
  v52 = v48 < v49;
  v53 = v49 + ~v48;
  if (v50)
    v54 = v51;
  else
    v54 = v53;
  *v47 = v52 << 7;
  v55 = lsqpack_enc_int(v47, (unint64_t)v109, v54, 7);
  if (v55 <= v47)
  {
    v41 = 0;
    v11 = v71;
    goto LABEL_72;
  }
  v56 = v55;
  if (*(_DWORD *)(v33 + 60) > *(_DWORD *)(v10 + 36))
  {
    *(_QWORD *)(v33 + 16) = 0;
    v57 = *(unint64_t **)(v10 + 152);
    *(_QWORD *)(v33 + 24) = v57;
    *v57 = v33;
    *(_QWORD *)(v10 + 152) = v33 + 16;
    v58 = *(_QWORD *)(v10 + 168);
    if (v58)
    {
      *(_QWORD *)(v33 + 32) = *(_QWORD *)(v58 + 32);
      *(_QWORD *)(v58 + 32) = v33;
    }
    else
    {
      v59 = *(_DWORD *)(v10 + 72) + 1;
      *(_DWORD *)(v10 + 72) = v59;
      v60 = *(FILE **)(v10 + 232);
      if (v60)
      {
        fwrite("qenc: debug: ", 0xDuLL, 1uLL, v60);
        fprintf(*(FILE **)(v10 + 232), "streams at risk: %u", *(_DWORD *)(v10 + 72));
        fputc(10, *(FILE **)(v10 + 232));
        v59 = *(_DWORD *)(v10 + 72);
      }
      if (v59 > *(_DWORD *)(v10 + 68))
        __assert_rtn("qenc_add_to_risked_list", "lsqpack.c", 1156, "enc->qpe_cur_streams_at_risk <= enc->qpe_max_risked_streams");
    }
  }
  v61 = *(FILE **)(v10 + 232);
  if (v61)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v61);
    fprintf(*(FILE **)(v10 + 232), "ended header for stream %llu; max ref: %u encoded as %u; risked: %d",
      *(_QWORD *)(v33 + 40),
      *(_DWORD *)(v33 + 60),
      v36,
      *(_DWORD *)(v33 + 60) > *(_DWORD *)(v10 + 36));
    fputc(10, *(FILE **)(v10 + 232));
  }
  *(_QWORD *)(v10 + 160) = 0;
  *(_DWORD *)(v10 + 44) &= ~1u;
  v41 = v56 - (char *)v109 + 22;
  *(_DWORD *)(v10 + 228) += v41;
  v11 = v71;
  v25 = MEMORY[0x1E0C809B0];
  if (v41 < 0)
    goto LABEL_93;
LABEL_79:
  memcpy((void *)(v11 - v41 + 22), __src, v41);
  subrange = dispatch_data_create_subrange((dispatch_data_t)v87[5], 22 - v41, v41 + v99[3] - 22);
  v63 = v95[3];
  if (v63)
  {
    v64 = dispatch_data_create_subrange((dispatch_data_t)v81[5], 0, v63);
    HTTP3Connection::writeEncoderStream(v10, v64);

  }
  v65 = a1[3];
  v66 = (a3 & 1) != 0 || a1[12] == 0;
  v72[0] = v25;
  v72[1] = 3221225472;
  v72[2] = ___ZN11HTTP3Stream12_sendHEADERSERK11HTTP3FieldsbU13block_pointerFvm13CFStreamErrorE_block_invoke_22;
  v72[3] = &unk_1E14F9088;
  v74 = v7;
  v67 = subrange;
  v73 = v67;
  v75 = &v94;
  HTTP3Framer::writeFrame(v65, 1uLL, v67, v66, v72);

  v68 = v77;
  if (v77)
  {
    v69 = (unint64_t *)&v77->__shared_owners_;
    do
      v70 = __ldaxr(v69);
    while (__stlxr(v70 - 1, v69));
    if (!v70)
    {
      ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
      std::__shared_weak_count::__release_weak(v68);
    }
  }
  _Block_object_dispose(&v80, 8);

  _Block_object_dispose(&v86, 8);
  _Block_object_dispose(v92, 8);
  _Block_object_dispose(v93, 8);
  _Block_object_dispose(&v94, 8);
  _Block_object_dispose(&v98, 8);
  _Block_object_dispose(v102, 8);
  _Block_object_dispose(v103, 8);
  v9 = v107;
  if (v107)
  {
LABEL_13:
    v16 = (unint64_t *)&v9->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
LABEL_90:

}

void sub_183F4600C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,id a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,id a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62)
{
  void *v62;
  void *v63;
  void *v64;
  uint64_t v65;
  uint64_t v66;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v65);
  _Block_object_dispose(&a38, 8);

  _Block_object_dispose(&a44, 8);
  _Block_object_dispose(&a50, 8);
  _Block_object_dispose(&a54, 8);
  _Block_object_dispose(&a58, 8);
  _Block_object_dispose(&a62, 8);
  _Block_object_dispose((const void *)(v66 - 232), 8);
  _Block_object_dispose((const void *)(v66 - 200), 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v66 - 152);

  _Unwind_Resume(a1);
}

void HTTP3Fields::enumerateFields(_QWORD *a1, void *a2)
{
  unsigned __int16 *v3;
  unsigned __int16 *v4;
  int v5;
  id v6;

  v6 = a2;
  v3 = (unsigned __int16 *)a1[3];
  v4 = (unsigned __int16 *)a1[4];
  if (v3 != v4)
  {
    v5 = 0;
    do
    {
      (*((void (**)(id, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v6 + 2))(v6, *a1 + (unsigned __int16)v5, 0, *v3, *v3, v3[1]);
      v5 += *v3 + v3[1];
      v3 += 2;
    }
    while (v3 != v4);
  }

}

void sub_183F46164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void ___ZN11HTTP3Stream12_sendHEADERSERK11HTTP3FieldsbU13block_pointerFvm13CFStreamErrorE_block_invoke(_QWORD *a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  FILE *v17;
  size_t v18;
  uint64_t v19;
  uint64_t v20;
  dispatch_data_t v21;
  uint64_t v22;
  void *v23;
  NSObject *alloc;
  dispatch_data_t v25;
  uint64_t v26;
  void *v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned int v31;
  unint64_t v32;
  char *v33;
  int v34;
  int v35;
  int v36;
  int v37;
  unint64_t v38;
  int v39;
  unint64_t v40;
  int v41;
  int v42;
  int v43;
  unint64_t v44;
  int v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  int v52;
  int v53;
  FILE *v54;
  unsigned int v55;
  unsigned int v56;
  int v57;
  unsigned int v58;
  char **v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  size_t v63;
  unint64_t v64;
  unint64_t v65;
  _BOOL4 v66;
  _BOOL4 v67;
  unsigned int v68;
  _DWORD *v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  unsigned int v74;
  uint64_t v75;
  unsigned int v76;
  unsigned int v77;
  unint64_t v79;
  float v80;
  int can_evict_at_least;
  uint64_t v82;
  int v83;
  int v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t v90;
  int v91;
  int v92;
  BOOL v93;
  unsigned int v94;
  unsigned int *v95;
  uint64_t v96;
  _BOOL8 v97;
  uint64_t v98;
  unint64_t v99;
  unint64_t v100;
  int v101;
  BOOL v102;
  unsigned int v103;
  unsigned int *v104;
  uint64_t v105;
  int *v106;
  unint64_t v107;
  int v108;
  unsigned int v109;
  char *v110;
  int v111;
  unsigned int v112;
  unsigned int v113;
  _BOOL4 v114;
  char *v115;
  int v116;
  unsigned int v117;
  FILE *v118;
  FILE *v119;
  uint64_t v120;
  uint64_t v121;
  int v122;
  _BYTE *v123;
  unint64_t v124;
  unsigned int v125;
  _BYTE *v126;
  unsigned __int16 *v127;
  _BYTE *v128;
  _BYTE *v129;
  unint64_t v130;
  _BYTE *v131;
  int v132;
  _BYTE *v133;
  size_t v134;
  uint64_t v135;
  uint64_t v136;
  dispatch_data_t subrange;
  uint64_t v138;
  void *v139;
  dispatch_data_t concat;
  uint64_t v141;
  unint64_t v142;
  unsigned int v143;
  _BYTE *v144;
  unint64_t v145;
  char v146;
  unint64_t v147;
  unsigned int v148;
  _BYTE *v149;
  unint64_t v150;
  char v151;
  int v152;
  _BYTE *v153;
  _BYTE *v154;
  int v155;
  _BYTE *v156;
  uint64_t v157;
  uint64_t v158;
  unint64_t v159;
  unint64_t v160;
  int v161;
  _BYTE *v162;
  unsigned int v163;
  _DWORD *v164;
  unsigned int v165;
  unsigned int v166;
  int v167;
  unsigned int v168;
  uint64_t v169;
  unsigned int v170;
  _DWORD *v171;
  unsigned int v172;
  unsigned int v173;
  uint64_t v174;
  unsigned int v175;
  unsigned int v176;
  int64_t v177;
  uint64_t v178;
  unsigned int v179;
  unsigned int v180;
  int64_t v181;
  _DWORD *v182;
  float v183;
  uint64_t v184;
  uint64_t *v185;
  _DWORD *v186;
  int64_t v187;
  uint64_t *v188;
  int v189;
  uint64_t v190;
  size_t v191;
  uint64_t v192;
  uint64_t v193;
  unint64_t v194;
  unint64_t v195;
  int v196;
  FILE *v197;
  _BYTE *v198;
  int v199;
  unsigned int v200;
  unsigned int v201;
  FILE *v202;
  FILE *v203;
  unsigned int v204;
  float v205;
  unint64_t v206;
  unint64_t v207;
  uint64_t v208;
  unint64_t v209;
  unsigned int v210;
  unsigned int v211;
  _QWORD *v212;
  _QWORD *v213;
  _BOOL4 v214;
  unint64_t v216;
  _QWORD *v217;
  _QWORD *v218;
  _BYTE *v219;
  unint64_t v220;
  unint64_t v221;
  size_t __n;
  _BYTE *v223;
  int v224;
  int v225;
  int64_t v226;
  _DWORD *v228;
  uint64_t v229;
  unsigned int v230;
  uint64_t v231;
  int v232;
  uint64_t v233;
  uint64_t v234;
  unsigned int v235;
  char *v236;
  size_t v237;
  char *v239;
  char *v240;
  uint64_t v241;
  char *v242;
  _BYTE *v243;
  _DWORD *v244;
  _DWORD *v245;
  uint64_t v246;

  v6 = a1;
  v246 = *MEMORY[0x1E0C80C00];
  v217 = a1 + 4;
  v218 = a1 + 6;
  v212 = a1 + 7;
  v213 = a1 + 9;
  v211 = a4 + 414139866;
  v237 = a4;
  v207 = a4 & 0xF;
  __n = a6;
  v236 = (char *)(a2 + a5);
  v240 = &v236[a6];
  v210 = a6 + a4;
  v209 = a6 + a4 + 32;
  v206 = a4 + 32;
  if (a4)
    v7 = (char *)(a2 + a3);
  else
    v7 = 0;
  v242 = v7;
  v239 = &v7[a4];
  while (2)
  {
    v8 = *(_QWORD *)(*(_QWORD *)(v6[4] + 8) + 24);
    v9 = *(_QWORD *)(*(_QWORD *)(v6[5] + 8) + 24);
    v10 = *(_QWORD *)(*(_QWORD *)(v6[6] + 8) + 24);
    v11 = *(_QWORD *)(*(_QWORD *)(v6[7] + 8) + 24);
    v12 = *(_QWORD *)(*(_QWORD *)(v6[8] + 8) + 24);
    v13 = *(_QWORD *)(*(_QWORD *)(v6[9] + 8) + 24);
    v14 = v6[12];
    v16 = v6[14];
    v15 = v6[15];
    v244 = 0;
    v245 = 0;
    v17 = *(FILE **)(v14 + 232);
    if (v17)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v17);
      fputc(10, *(FILE **)(v14 + 232));
    }
    if (v9 + v8 == v10)
      goto LABEL_8;
    v30 = v16;
    v234 = v9 + v8;
    v229 = v14;
    v31 = 414139866;
    if (v242)
    {
      v32 = v237;
      v31 = v211;
      v33 = v242;
      if (a4 >= 0x10)
      {
        v34 = 1679910008;
        v35 = 39378473;
        v36 = -2008766304;
        v37 = 645669457;
        v33 = v242;
        do
        {
          HIDWORD(v38) = v37 - 2048144777 * *(_DWORD *)v33;
          LODWORD(v38) = HIDWORD(v38);
          v37 = -1640531535 * (v38 >> 19);
          HIDWORD(v38) = v36 - 2048144777 * *((_DWORD *)v33 + 1);
          LODWORD(v38) = HIDWORD(v38);
          v36 = -1640531535 * (v38 >> 19);
          HIDWORD(v38) = v35 - 2048144777 * *((_DWORD *)v33 + 2);
          LODWORD(v38) = HIDWORD(v38);
          v35 = -1640531535 * (v38 >> 19);
          HIDWORD(v38) = v34 - 2048144777 * *((_DWORD *)v33 + 3);
          LODWORD(v38) = HIDWORD(v38);
          v34 = -1640531535 * (v38 >> 19);
          v33 += 16;
        }
        while (v33 < v239 - 15);
        HIDWORD(v40) = v37;
        LODWORD(v40) = v37;
        v39 = v40 >> 31;
        HIDWORD(v40) = v36;
        LODWORD(v40) = v36;
        v41 = v40 >> 25;
        HIDWORD(v40) = v35;
        LODWORD(v40) = v35;
        v42 = v40 >> 20;
        HIDWORD(v40) = v34;
        LODWORD(v40) = v34;
        v31 = v39 + a4 + v41 + v42 + (v40 >> 14);
        v32 = v207;
      }
      if (v32 >= 4)
      {
        do
        {
          v43 = *(_DWORD *)v33;
          v33 += 4;
          HIDWORD(v44) = v31 - 1028477379 * v43;
          LODWORD(v44) = HIDWORD(v44);
          v31 = 668265263 * (v44 >> 15);
          v32 -= 4;
        }
        while (v32 > 3);
      }
      for (; v32; --v32)
      {
        v45 = *v33++;
        HIDWORD(v46) = v31 + 374761393 * v45;
        LODWORD(v46) = HIDWORD(v46);
        v31 = -1640531535 * (v46 >> 21);
      }
    }
    v47 = v10;
    v48 = v8;
    v49 = v30;
    v50 = v15;
    v51 = -1028477379 * ((-2048144777 * (v31 ^ (v31 >> 15))) ^ ((-2048144777 * (v31 ^ (v31 >> 15))) >> 13));
    v52 = v51 ^ HIWORD(v51);
    v53 = XXH_INLINE_XXH32((int *)v236, __n, v52);
    v54 = *(FILE **)(v229 + 232);
    if (v54)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v54);
      fprintf(*(FILE **)(v229 + 232), "name hash: 0x%X; nameval hash: 0x%X", v52, v53);
      fputc(10, *(FILE **)(v229 + 232));
    }
    v224 = v52;
    v228 = (_DWORD *)(v229 + 32);
    v223 = (_BYTE *)(v49 + v13 - v11);
    v226 = v12 + v11 - v13;
    v221 = (unint64_t)&v223[v226];
    v216 = v234 - v47;
    v219 = (_BYTE *)(v50 + v47 - v48);
    v220 = v50 - v48 + v234;
    v55 = a6;
    v56 = a4;
    v57 = v53;
    if (nameval2id_plus_one[v53 & 0x1FF])
    {
      v58 = nameval2id_plus_one[v53 & 0x1FF] - 1;
      v59 = &(&static_table)[3 * v58];
      if (*((_DWORD *)v59 + 4) == a4
        && *((_DWORD *)&static_table + 6 * v58 + 5) == a6
        && !memcmp(*v59, v242, v237)
        && !memcmp((&static_table)[3 * v58 + 1], v236, __n))
      {
        v233 = 0;
        v214 = 0;
        v232 = 0;
        v235 = 0;
        v66 = 0;
        v71 = 0;
        v72 = 0;
        v73 = 0;
        v69 = 0;
        v74 = v58;
        v75 = 1;
        v63 = v237;
        v65 = (unint64_t)v239;
        v64 = (unint64_t)v240;
        v61 = v224;
        v6 = a1;
        v60 = v229;
        goto LABEL_151;
      }
    }
    v60 = v229;
    v61 = v224;
    if (*(_DWORD *)(v229 + 60))
    {
      v62 = *(_QWORD *)(v229 + 160);
      v63 = v237;
      v65 = (unint64_t)v239;
      v64 = (unint64_t)v240;
      v6 = a1;
      if (v62 && *(_DWORD *)(v62 + 52) < *(_DWORD *)(v229 + 52) >> 1)
      {
        v66 = *v228 != -1;
        v232 = 1;
      }
      else
      {
        v232 = 0;
        v66 = 0;
      }
    }
    else
    {
      v232 = 0;
      v66 = 0;
      v63 = v237;
      v65 = (unint64_t)v239;
      v64 = (unint64_t)v240;
      v6 = a1;
    }
    if (*(_QWORD *)(v229 + 168) || *(_DWORD *)(v229 + 72) < *(_DWORD *)(v229 + 68))
    {
      v67 = 1;
LABEL_36:
      v235 = v67;
      goto LABEL_37;
    }
    v70 = *(_QWORD *)(v229 + 160);
    if (v70)
    {
      v67 = *(_DWORD *)(v70 + 60) > *(_DWORD *)(v229 + 36);
      goto LABEL_36;
    }
    v235 = 0;
LABEL_37:
    v233 = 0;
    v68 = 0;
    v69 = 0;
    v214 = *(_QWORD *)(v229 + 248) != 0;
    while (2)
    {
      v230 = v68;
      if (!v232)
        goto LABEL_77;
      v69 = *(_DWORD **)(*(_QWORD *)(v60 + 104) + 32 * (v57 & ~(-1 << *(_DWORD *)(v60 + 84))) + 16);
      if (!v69)
      {
        v233 = 0;
        v69 = 0;
        goto LABEL_77;
      }
      v233 = 0;
      while (1)
      {
        if (v57 != v69[10] || v69[12] != v56 || v69[13] != v55)
          goto LABEL_51;
        if (!memcmp(v242, v69 + 14, v63) && !memcmp(v236, (char *)v69 + v63 + 56, __n))
          break;
        v65 = (unint64_t)v239;
        v64 = (unint64_t)v240;
LABEL_51:
        v69 = *(_DWORD **)v69;
        if (!v69)
        {
          if (v233 != 1)
            goto LABEL_77;
          v69 = v244;
          v76 = v244[6];
          v230 = v76;
          if (v235)
          {
            if (!v66)
              goto LABEL_76;
          }
          else
          {
            v77 = *(_DWORD *)(v60 + 36);
            if (v76 > v77 || !v66)
              goto LABEL_73;
          }
          if ((*(_BYTE *)(v60 + 44) & 2) != 0)
          {
            v79 = (v244[12] + v244[13] + 32);
            v80 = (float)*(unsigned int *)(v60 + 52);
            if ((float)((float)(v79 + *(_DWORD *)(v60 + 48)) / v80) >= 0.8
              && (float)((float)(v244[7] - *(_DWORD *)(v60 + 64) + v244[8]) / v80) < 0.2)
            {
              can_evict_at_least = qenc_has_or_can_evict_at_least((uint64_t)v228, v79);
              v65 = (unint64_t)v239;
              v64 = (unint64_t)v240;
              if (can_evict_at_least)
              {
                v71 = 6;
                v233 = 1;
                if (v235)
                {
                  v75 = 0;
                  v74 = v230;
                  v232 = 1;
                  v235 = 1;
                  goto LABEL_70;
                }
                v167 = *(_DWORD *)(v60 + 48);
                v166 = *(_DWORD *)(v60 + 52);
                if (v69[7] - *(_DWORD *)(v60 + 64) + v69[8] + v166 - v167 >= v166 >> 2)
                {
                  v235 = 0;
                  v168 = v167 + v69[12] + v69[13] + 32;
                  v75 = 2;
                  v233 = 1;
                  v232 = 1;
                  if (v168 <= v166)
                  {
                    v71 = 2;
                    v74 = v230;
                  }
                  else
                  {
                    v169 = *(_QWORD *)(v60 + 88);
                    v75 = 2;
                    if ((_DWORD *)v169 == v69)
                    {
                      v72 = 0;
                      v71 = 2;
                      v233 = 1;
                      v232 = 1;
                      v235 = 0;
                      v74 = v230;
                      goto LABEL_148;
                    }
                    while (1)
                    {
                      v168 = v168 - (*(_DWORD *)(v169 + 48) + *(_DWORD *)(v169 + 52)) - 32;
                      if (v168 <= v166)
                        break;
                      v169 = *(_QWORD *)(v169 + 16);
                      v71 = 2;
                      if ((_DWORD *)v169 == v69)
                      {
                        v233 = 1;
                        v235 = 0;
                        v72 = 0;
                        v73 = 0;
                        v74 = v230;
                        v232 = 1;
                        v75 = 2;
                        goto LABEL_151;
                      }
                    }
                    v235 = 0;
                    v75 = 2;
                    v233 = 1;
                    v74 = v230;
                    v232 = 1;
                    v71 = 2;
                  }
LABEL_70:
                  v72 = 1;
                  v73 = 1;
                  goto LABEL_151;
                }
LABEL_74:
                v82 = 1;
                goto LABEL_75;
              }
            }
          }
          if (v235)
          {
LABEL_76:
            v75 = 2;
            v233 = 1;
            if ((v69[7] - *(_DWORD *)(v60 + 64) + v69[8] + *(_DWORD *)(v60 + 52) - *(_DWORD *)(v60 + 48)) < *(_DWORD *)(v60 + 52) >> 2)
              goto LABEL_77;
            v72 = 0;
            v71 = 2;
            v74 = v230;
            v232 = 1;
            goto LABEL_148;
          }
          v76 = v69[6];
          v77 = *(_DWORD *)(v60 + 36);
LABEL_73:
          if (v76 > v77)
            goto LABEL_74;
          goto LABEL_76;
        }
      }
      (&v244)[v233] = v69;
      v65 = (unint64_t)v239;
      v64 = (unint64_t)v240;
      if (!v233)
      {
        v233 = 1;
        goto LABEL_51;
      }
      v74 = v245[6];
      v165 = v244[6];
      if (v74 <= v165)
        __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 1767, "candidates[1]->ete_id > candidates[0]->ete_id");
      v71 = 2;
      if (v235)
      {
        v72 = 0;
        v233 = 2;
        v232 = 1;
        v235 = 1;
LABEL_243:
        v75 = 2;
        v73 = 0;
        v69 = v245;
        goto LABEL_151;
      }
      v170 = *(_DWORD *)(v60 + 36);
      if (v74 <= v170)
      {
        v72 = 0;
        v71 = 2;
        v233 = 2;
        v235 = 0;
        v232 = 1;
        goto LABEL_243;
      }
      if (v165 <= v170)
      {
        v233 = 2;
        if ((v244[7] - *(_DWORD *)(v60 + 64) + v244[8] + *(_DWORD *)(v60 + 52) - *(_DWORD *)(v60 + 48)) >= *(_DWORD *)(v60 + 52) >> 2)
        {
          v72 = 0;
          v71 = 2;
          v235 = 0;
          v74 = v244[6];
          v232 = 1;
          v75 = 2;
          v73 = 0;
          v69 = v244;
          goto LABEL_151;
        }
      }
      else
      {
        v82 = 2;
LABEL_75:
        v233 = v82;
      }
LABEL_77:
      v83 = name2id_plus_one[v61 & 0x1FF];
      if (name2id_plus_one[v61 & 0x1FF])
      {
        v74 = v83 - 1;
        if (LODWORD((&static_table)[3 * (v83 - 1) + 2]) == a4)
        {
          v84 = memcmp((&static_table)[3 * v74], v242, v63);
          v65 = (unint64_t)v239;
          v64 = (unint64_t)v240;
          if (!v84)
          {
            if (v66)
            {
              v66 = 1;
              if (qenc_has_or_can_evict_at_least((uint64_t)v228, v209))
              {
                v96 = *(_QWORD *)(v60 + 248);
                v97 = 1;
                v65 = (unint64_t)v239;
                v64 = (unint64_t)v240;
                if (v96)
                {
                  v98 = 260;
                  if (!*(_DWORD *)(v60 + 264))
                    v98 = 256;
                  v99 = v96 + 8 * *(unsigned int *)(v60 + v98);
                  *(_DWORD *)(v99 + 4) = v57;
                  v100 = v96 - 8;
                  do
                  {
                    v101 = *(_DWORD *)(v100 + 12);
                    v100 += 8;
                  }
                  while (v101 != v57);
                  v97 = v100 < v99;
                }
                if (v232)
                  v102 = v233 == 0;
                else
                  v102 = 1;
                v103 = !v102;
                v104 = (unsigned int *)((char *)&lsqpack_enc_encode_programs + 64 * v97 + 32 * v235 + 16 * v103);
                v73 = *v104;
                v75 = v104[1];
                v72 = v104[2];
                v71 = v104[3];
                v66 = 1;
                goto LABEL_151;
              }
              v72 = 0;
              v71 = 0;
              v75 = 3;
LABEL_150:
              v73 = 0;
              v65 = (unint64_t)v239;
              v64 = (unint64_t)v240;
              goto LABEL_151;
            }
            v72 = 0;
            v71 = 0;
            v66 = 0;
            v75 = 3;
LABEL_148:
            v73 = 0;
            goto LABEL_151;
          }
        }
      }
      v85 = -1;
      if (!v232
        || (v69 = 0,
            v86 = *(_QWORD *)(v60 + 104),
            !*(_QWORD *)(v86 + 32 * (v61 & ~(-1 << *(_DWORD *)(v60 + 84))))))
      {
LABEL_99:
        if (!v66)
        {
          v72 = 0;
          v71 = 0;
          v74 = v230;
          v66 = 0;
          v75 = 6;
          v73 = 0;
          goto LABEL_110;
        }
        v87 = *(_QWORD *)(v60 + 248);
        if (!v87)
          goto LABEL_106;
        v88 = 260;
        if (!*(_DWORD *)(v60 + 264))
          v88 = 256;
        v89 = v87 + 8 * *(unsigned int *)(v60 + v88);
        *(_DWORD *)(v89 + 4) = v57;
        v90 = v87 - 8;
        do
        {
          v91 = *(_DWORD *)(v90 + 12);
          v90 += 8;
        }
        while (v91 != v57);
        if (v90 < v89)
        {
LABEL_106:
          if ((v85 & 0x80000000) == 0)
          {
            if (!v85)
              goto LABEL_136;
LABEL_112:
            if (v232)
              v93 = v233 == 0;
            else
              v93 = 1;
            v94 = !v93;
            v95 = (unsigned int *)((char *)&lsqpack_enc_encode_programs_20 + 32 * v235 + 16 * v94);
            v73 = *v95;
            v72 = v95[2];
            v63 = v237;
LABEL_144:
            v75 = v95[1];
            v71 = v95[3];
            v66 = 1;
            v74 = v230;
            goto LABEL_151;
          }
          v92 = qenc_has_or_can_evict_at_least((uint64_t)v228, v209);
          v65 = (unint64_t)v239;
          v64 = (unint64_t)v240;
          if (v92)
            goto LABEL_112;
          v87 = *(_QWORD *)(v60 + 248);
        }
LABEL_136:
        v63 = v237;
        if (v87)
        {
          v105 = 260;
          if (!*(_DWORD *)(v60 + 264))
            v105 = 256;
          v106 = (int *)(v87 + 8 * *(unsigned int *)(v60 + v105));
          *v106 = v61;
          v107 = v87 - 8;
          do
          {
            v108 = *(_DWORD *)(v107 + 8);
            v107 += 8;
          }
          while (v108 != v61);
          v66 = 1;
          if (v107 >= (unint64_t)v106)
          {
            v72 = 0;
            v71 = 0;
            v74 = v230;
            v75 = 6;
            goto LABEL_148;
          }
        }
        v66 = 1;
        if (!qenc_has_or_can_evict_at_least((uint64_t)v228, v206))
        {
          v72 = 0;
          v71 = 0;
          v74 = v230;
          v75 = 6;
          goto LABEL_150;
        }
        v95 = (unsigned int *)((char *)&lsqpack_enc_encode_programs_21 + 16 * v235);
        v72 = 2;
        v73 = 5;
        v65 = (unint64_t)v239;
        v64 = (unint64_t)v240;
        goto LABEL_144;
      }
      v69 = *(_DWORD **)(v86 + 32 * (v61 & ~(-1 << *(_DWORD *)(v60 + 84))));
      while (2)
      {
        if (v61 != v69[11]
          || (v69[7] - *(_DWORD *)(v60 + 64) + v69[8] + *(_DWORD *)(v60 + 52) - *(_DWORD *)(v60 + 48)) < *(_DWORD *)(v60 + 52) >> 2
          || v69[12] != a4
          || !v235 && v69[6] > *(_DWORD *)(v60 + 36))
        {
LABEL_96:
          v69 = (_DWORD *)*((_QWORD *)v69 + 1);
          if (!v69)
            goto LABEL_99;
          continue;
        }
        break;
      }
      if (v66)
      {
        if (v85 < 0)
        {
          if (!qenc_has_or_can_evict_at_least((uint64_t)v228, v209))
          {
            v85 = 0;
            goto LABEL_95;
          }
        }
        else if (!v85)
        {
LABEL_95:
          v65 = (unint64_t)v239;
          v64 = (unint64_t)v240;
          goto LABEL_96;
        }
        v85 = 1;
      }
      if (memcmp(v242, v69 + 14, v237))
        goto LABEL_95;
      v74 = v69[6];
      v65 = (unint64_t)v239;
      v64 = (unint64_t)v240;
      if (!v235 || !v66 || !v85)
        goto LABEL_229;
      v157 = *(_QWORD *)(v60 + 248);
      v71 = 6;
      v72 = 1;
      if (!v157)
        goto LABEL_218;
      v158 = 260;
      if (!*(_DWORD *)(v60 + 264))
        v158 = 256;
      v159 = v157 + 8 * *(unsigned int *)(v60 + v158);
      *(_DWORD *)(v159 + 4) = v57;
      v160 = v157 - 8;
      do
      {
        v161 = *(_DWORD *)(v160 + 12);
        v160 += 8;
      }
      while (v161 != v57);
      v71 = 6;
      v72 = 1;
      if (v160 < v159)
      {
LABEL_218:
        v75 = 0;
        v232 = 1;
        v235 = 1;
        v66 = 1;
        v73 = 3;
      }
      else
      {
LABEL_229:
        v72 = 0;
        v73 = 0;
        v71 = 2;
        v232 = 1;
        v75 = 4;
      }
LABEL_110:
      v63 = v237;
LABEL_151:
      if (((1 << v73) & 0x3C) != 0 && ((1 << v75) & 0x78) != 0)
      {
        v109 = 0;
        if (a4)
        {
          v109 = 0;
          v110 = v242;
          do
          {
            v111 = *v110++;
            v109 += encode_table[2 * v111 + 1];
          }
          while ((unint64_t)v110 < v65);
        }
        v112 = 0;
        v113 = v109 >> 3;
        v114 = (v109 & 7) != 0;
        if (v55)
        {
          v112 = 0;
          v115 = v236;
          do
          {
            v116 = *v115++;
            v112 += encode_table[2 * v116 + 1];
          }
          while ((unint64_t)v115 < v64);
        }
        v117 = v113 + *(_DWORD *)(v60 + 228) + v114 + (v112 >> 3);
        if ((v112 & 7) != 0)
          ++v117;
        if ((float)((float)v117 / (float)(v210 + *(_DWORD *)(v60 + 224))) > 0.95)
        {
          if (!v66)
            __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 1917, "index");
          v118 = *(FILE **)(v60 + 232);
          if (v118)
          {
            fwrite("qenc: debug: ", 0xDuLL, 1uLL, v118);
            fwrite("double lit would result in ratio > 0.95, reset", 0x2EuLL, 1uLL, *(FILE **)(v60 + 232));
            fputc(10, *(FILE **)(v60 + 232));
          }
          v66 = 0;
          v68 = v74;
          v56 = a4;
LABEL_228:
          v65 = (unint64_t)v239;
          v64 = (unint64_t)v240;
          continue;
        }
      }
      break;
    }
    v231 = v72;
    v225 = v71;
    v119 = *(FILE **)(v60 + 232);
    if (v119)
    {
      v120 = v73;
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v119);
      fprintf(*(FILE **)(v60 + 232), "program: %s; %s; %s; flags: 0x%X",
        (&eea2str)[v120],
        (&eha2str)[v75],
        (&eta2str)[v231],
        v225);
      fputc(10, *(FILE **)(v60 + 232));
      v73 = v120;
    }
    switch(v73)
    {
      case 0:
        goto LABEL_186;
      case 1:
        if (v226 < 1)
          goto LABEL_188;
        *v223 = 0;
        v128 = lsqpack_enc_int(v223, v221, *v228 - v74, 5);
        v73 = v128 - v223;
        if (v128 <= v223)
          goto LABEL_188;
        goto LABEL_186;
      case 2:
        if (v226 < 1)
          goto LABEL_188;
        v129 = v223;
        *v223 = -64;
        v130 = v74;
        goto LABEL_182;
      case 3:
        if (v226 < 1)
          goto LABEL_188;
        v129 = v223;
        *v223 = 0x80;
        v130 = *v228 - v74;
LABEL_182:
        v131 = lsqpack_enc_int(v129, v221, v130, 6);
        if (v131 <= v129)
          goto LABEL_188;
        v123 = v131;
        v124 = v221 - (_QWORD)v131;
        v126 = v131;
        v127 = (unsigned __int16 *)v236;
        v125 = v55;
LABEL_184:
        v132 = lsqpack_enc_enc_str(7, v126, v124, v127, v125);
        if (v132 < 0)
        {
LABEL_188:
          v134 = *(_QWORD *)(*(_QWORD *)(v6[9] + 8) + 24);
          v135 = *(_QWORD *)(v6[8] + 8);
          v136 = *(_QWORD *)(v135 + 24);
          if (v134 < v136 + *(_QWORD *)(*(_QWORD *)(v6[7] + 8) + 24))
          {
            subrange = dispatch_data_create_subrange(*(dispatch_data_t *)(*(_QWORD *)(v6[10] + 8) + 40), 0, v134);
            v138 = *(_QWORD *)(v6[10] + 8);
            v139 = *(void **)(v138 + 40);
            *(_QWORD *)(v138 + 40) = subrange;

            v135 = *(_QWORD *)(v6[8] + 8);
            v136 = *(_QWORD *)(v135 + 24);
          }
          *(_QWORD *)(v135 + 24) = v136 + 512;
          alloc = dispatch_data_create_alloc();
          concat = dispatch_data_create_concat(*(dispatch_data_t *)(*(_QWORD *)(v6[10] + 8) + 40), alloc);
          v141 = *(_QWORD *)(v6[10] + 8);
          v27 = *(void **)(v141 + 40);
          *(_QWORD *)(v141 + 40) = concat;
          v28 = v212;
          v29 = v213;
LABEL_191:

          *(_QWORD *)(*(_QWORD *)(*v28 + 8) + 24) = *(_QWORD *)(*(_QWORD *)(*v29 + 8) + 24);
          continue;
        }
        v73 = &v123[v132] - v223;
LABEL_186:
        v208 = v73;
        switch(v75)
        {
          case 0:
            v74 = *v228 + 1;
            v133 = v219;
            goto LABEL_194;
          case 1:
            v133 = v219;
            *v219 = -64;
            v142 = v74;
            goto LABEL_220;
          case 2:
            v133 = v219;
            if (v74 <= *(_DWORD *)(v60 + 188))
            {
              *v219 = 0x80;
              v142 = *(_DWORD *)(v60 + 188) - v74;
LABEL_220:
              v144 = v133;
              v145 = v220;
              v146 = 6;
            }
            else
            {
LABEL_194:
              *v133 = 16;
              v143 = *(_DWORD *)(v60 + 188);
              if (v74 <= v143)
                __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2008, "id > enc->qpe_cur_header.base_idx");
              v142 = v74 + ~v143;
              v144 = v133;
              v145 = v220;
              v146 = 4;
            }
            v156 = lsqpack_enc_int(v144, v145, v142, v146);
            if (v156 > v133)
              goto LABEL_222;
            goto LABEL_8;
          case 3:
            v133 = v219;
            *v219 = 80;
            v147 = v74;
            goto LABEL_204;
          case 4:
            v133 = v219;
            if (v74 > *(_DWORD *)(v60 + 188))
              goto LABEL_199;
            *v219 = 64;
            v147 = *(_DWORD *)(v60 + 188) - v74;
LABEL_204:
            v149 = v133;
            v150 = v220;
            v151 = 4;
            goto LABEL_205;
          case 5:
            v74 = *v228 + 1;
            v133 = v219;
LABEL_199:
            *v133 = 0;
            v148 = *(_DWORD *)(v60 + 188);
            if (v74 <= v148)
              __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2045, "id > enc->qpe_cur_header.base_idx");
            v147 = v74 + ~v148;
            v149 = v133;
            v150 = v220;
            v151 = 3;
LABEL_205:
            v154 = lsqpack_enc_int(v149, v150, v147, v151);
            if (v154 <= v133)
              goto LABEL_8;
            v153 = v154;
            break;
          case 6:
            v133 = v219;
            *v219 = 32;
            v152 = lsqpack_enc_enc_str(3, v219, v216, (unsigned __int16 *)v242, a4);
            if (v152 < 0)
              goto LABEL_8;
            v153 = &v219[v152];
            break;
          default:
            __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2075, "prog.ep_hea_action == EHA_LIT_WITH_NAME_STAT");
        }
        v155 = lsqpack_enc_enc_str(7, v153, v220 - (_QWORD)v153, (unsigned __int16 *)v236, a6);
        if (v155 < 0)
        {
LABEL_8:
          v18 = *(_QWORD *)(*(_QWORD *)(v6[6] + 8) + 24);
          v19 = *(_QWORD *)(v6[5] + 8);
          v20 = *(_QWORD *)(v19 + 24);
          if (v18 < v20 + *(_QWORD *)(*(_QWORD *)(v6[4] + 8) + 24))
          {
            v21 = dispatch_data_create_subrange(*(dispatch_data_t *)(*(_QWORD *)(v6[11] + 8) + 40), 0, v18);
            v22 = *(_QWORD *)(v6[11] + 8);
            v23 = *(void **)(v22 + 40);
            *(_QWORD *)(v22 + 40) = v21;

            v19 = *(_QWORD *)(v6[5] + 8);
            v20 = *(_QWORD *)(v19 + 24);
          }
          *(_QWORD *)(v19 + 24) = v20 + 512;
          alloc = dispatch_data_create_alloc();
          v25 = dispatch_data_create_concat(*(dispatch_data_t *)(*(_QWORD *)(v6[11] + 8) + 40), alloc);
          v26 = *(_QWORD *)(v6[11] + 8);
          v27 = *(void **)(v26 + 40);
          *(_QWORD *)(v26 + 40) = v25;
          v28 = v217;
          v29 = v218;
          goto LABEL_191;
        }
        v156 = &v153[v155];
LABEL_222:
        if ((unint64_t)(v231 - 1) > 1)
        {
          if (v231)
            __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2117, "prog.ep_tab_action == ETA_NOOP");
          v241 = v156 - v133;
          if ((v225 & 2) == 0)
            goto LABEL_263;
        }
        else
        {
          v162 = v156;
          v55 = a6;
          if (v231 == 1)
            v163 = a6;
          else
            v163 = 0;
          v56 = a4;
          v164 = lsqpack_enc_push_entry((uint64_t)v228, v61, v57, v242, a4, v236, v163);
          if (!v164)
          {
            v66 = 0;
            v68 = v74;
            v63 = v237;
            goto LABEL_228;
          }
          v241 = v162 - v219;
          v171 = *(_DWORD **)(v60 + 160);
          v171[13] += v164[12] + v164[13] + 32;
          if ((v225 & 4) != 0)
          {
            ++v164[9];
            *(_DWORD *)(v60 + 184) |= 2u;
            v172 = v171[15];
            v173 = v164[6];
            if (v172)
            {
              if (v173 <= v172)
                __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2111, "new_entry->ete_id > enc->qpe_cur_header.hinfo->qhi_max_id");
              v171[15] = v173;
              goto LABEL_256;
            }
            v171[14] = v173;
            v171[15] = v173;
            if ((v225 & 2) == 0)
              goto LABEL_263;
          }
          else
          {
LABEL_256:
            if ((v225 & 2) == 0)
              goto LABEL_263;
          }
        }
        ++v69[9];
        v174 = *(_QWORD *)(v60 + 160);
        v175 = v69[6];
        v176 = *(_DWORD *)(v174 + 60);
        if (!v176)
        {
          *(_DWORD *)(v174 + 60) = v175;
LABEL_262:
          *(_DWORD *)(v174 + 56) = v175;
          goto LABEL_263;
        }
        if (v176 < v175)
        {
          *(_DWORD *)(v174 + 60) = v175;
          goto LABEL_263;
        }
        if (*(_DWORD *)(v174 + 56) > v175)
          goto LABEL_262;
LABEL_263:
        qenc_remove_overflow_entries((uint64_t)v228);
        v177 = v208;
        if (v214)
        {
          v178 = *(_QWORD *)(v60 + 248);
          if (!v178)
            __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2132, "enc->qpe_hist_els");
          v179 = *(_DWORD *)(v60 + 260);
          if (*(_DWORD *)(v60 + 176) < v179)
          {
LABEL_268:
            *(_DWORD *)(v178 + 8 * *(unsigned int *)(v60 + 256)) = v61;
            *(_DWORD *)(v178 + 8 * *(unsigned int *)(v60 + 256) + 4) = v57;
            v180 = (*(_DWORD *)(v60 + 256) + 1) % *(_DWORD *)(v60 + 260);
            *(_DWORD *)(v60 + 256) = v180;
            *(_DWORD *)(v60 + 264) |= v180 == 0;
          }
          else
          {
            qenc_hist_update_size((uint64_t)v228, v179 + 4);
            v177 = v208;
            if (*(_DWORD *)(v60 + 260))
            {
              v178 = *(_QWORD *)(v60 + 248);
              goto LABEL_268;
            }
          }
          ++*(_DWORD *)(v60 + 176);
        }
        v181 = v226;
        if (v226 != v177)
        {
          v182 = v228;
          while (1)
          {
            if ((*(_BYTE *)(v60 + 44) & 2) == 0 || *v182 == -1)
              goto LABEL_312;
            v183 = *(float *)(v60 + 240);
            if ((v183 != 0.0
               || *(_QWORD *)(v60 + 168)
               || *(_DWORD *)(v60 + 72) < *(_DWORD *)(v60 + 68)
               || (v184 = *(_QWORD *)(v60 + 160)) != 0 && *(_DWORD *)(v184 + 60) > *(_DWORD *)(v60 + 36))
              && v183 < *(float *)(v60 + 244))
            {
              goto LABEL_312;
            }
            v185 = *(uint64_t **)(v60 + 88);
            if (!v185)
              goto LABEL_312;
            v186 = 0;
            v243 = &v223[v177];
            v187 = v177;
            do
            {
              if ((*((_DWORD *)v185 + 7)
                                - *(_DWORD *)(v60 + 64)
                                + *((_DWORD *)v185 + 8)
                                + *(_DWORD *)(v60 + 52)
                                - *(_DWORD *)(v60 + 48)) >= *(_DWORD *)(v60 + 52) >> 2)
                break;
              if (!v186
                || *((_DWORD *)v185 + 12) + *((_DWORD *)v185 + 13) + 32 >= (v186[12] + v186[13] + 32))
              {
                v188 = (uint64_t *)*v185;
                v189 = *((_DWORD *)v185 + 10);
                if (*v185)
                {
                  while (1)
                  {
                    if (*((_DWORD *)v188 + 10) == v189)
                    {
                      v190 = *((unsigned int *)v188 + 12);
                      if ((_DWORD)v190 == *((_DWORD *)v185 + 12))
                      {
                        v191 = *((unsigned int *)v188 + 13);
                        if ((_DWORD)v191 == *((_DWORD *)v185 + 13)
                          && !memcmp(v188 + 7, v185 + 7, *((unsigned int *)v188 + 12))
                          && !memcmp((char *)v188 + v190 + 56, (char *)v185 + v190 + 56, v191))
                        {
                          break;
                        }
                      }
                    }
                    v188 = (uint64_t *)*v188;
                    if (!v188)
                      goto LABEL_292;
                  }
                  v182 = v228;
                }
                else
                {
LABEL_292:
                  v192 = *(_QWORD *)(v60 + 248);
                  v182 = v228;
                  if (!v192)
                    goto LABEL_335;
                  v193 = 260;
                  if (!*(_DWORD *)(v60 + 264))
                    v193 = 256;
                  v194 = v192 + 8 * *(unsigned int *)(v60 + v193);
                  *(_DWORD *)(v194 + 4) = v189;
                  v195 = v192 - 8;
                  do
                  {
                    v196 = *(_DWORD *)(v195 + 12);
                    v195 += 8;
                  }
                  while (v196 != v189);
                  if (v195 < v194)
                  {
LABEL_335:
                    if (qenc_has_or_can_evict_at_least((uint64_t)v228, (*((_DWORD *)v185 + 12) + *((_DWORD *)v185 + 13) + 32)))v186 = v185;
                  }
                }
                v177 = v187;
              }
              v185 = (uint64_t *)v185[2];
            }
            while (v185);
            if (!v186)
            {
LABEL_312:
              v181 = v177;
              goto LABEL_314;
            }
            v197 = *(FILE **)(v60 + 232);
            if (v197)
            {
              fwrite("qenc: debug: ", 0xDuLL, 1uLL, v197);
              fwrite("dup draining", 0xCuLL, 1uLL, *(FILE **)(v60 + 232));
              fputc(10, *(FILE **)(v60 + 232));
            }
            *v243 = 0;
            v198 = lsqpack_enc_int(v243, v221, (*v182 - v186[6]), 5);
            if (v198 <= v243)
              break;
            v199 = (int)v198;
            if (!lsqpack_enc_push_entry((uint64_t)v182, v186[11], v186[10], v186 + 14, v186[12], (char *)v186 + v186[12] + 56, v186[13])|| v199 == (_DWORD)v243)
            {
              break;
            }
            qenc_remove_overflow_entries((uint64_t)v182);
            v177 = (v199 - (_DWORD)v243) + v187;
            if (v226 == v177)
              goto LABEL_314;
          }
          v181 = v187;
        }
LABEL_314:
        v200 = v210 + *(_DWORD *)(v60 + 224);
        v201 = *(_DWORD *)(v60 + 228) + v181 + v241;
        *(_DWORD *)(v60 + 224) = v200;
        *(_DWORD *)(v60 + 228) = v201;
        if (v201 >= 0x80000001)
        {
          *(_DWORD *)(v60 + 224) = (int)(float)((float)((float)v200 / (float)v201) * 1000.0);
          *(_DWORD *)(v60 + 228) = 1000;
          v202 = *(FILE **)(v60 + 232);
          if (v202)
          {
            fwrite("qenc: debug: ", 0xDuLL, 1uLL, v202);
            v203 = *(FILE **)(v60 + 232);
            v204 = *(_DWORD *)(v60 + 224);
            if (v204)
            {
              v205 = (float)*(unsigned int *)(v60 + 228) / (float)v204;
              if (v203)
              {
                fwrite("qenc: debug: ", 0xDuLL, 1uLL, *(FILE **)(v60 + 232));
                fprintf(*(FILE **)(v60 + 232), "bytes out: %u; bytes in: %u, ratio: %.3f",
                  *(_DWORD *)(v60 + 228),
                  *(_DWORD *)(v60 + 224),
                  v205);
                fputc(10, *(FILE **)(v60 + 232));
              }
            }
            else
            {
              v205 = 0.0;
            }
            fprintf(v203, "reset bytes in/out counters, ratio: %.3f", v205);
            fputc(10, *(FILE **)(v60 + 232));
          }
        }
        *(_QWORD *)(*(_QWORD *)(*v218 + 8) + 24) += v241;
        *(_QWORD *)(*(_QWORD *)(*v213 + 8) + 24) += v181;
        return;
      case 4:
      case 5:
        if (v226 < 1)
          goto LABEL_188;
        *v223 = 64;
        v121 = v73;
        v122 = lsqpack_enc_enc_str(5, v223, v226, (unsigned __int16 *)v242, a4);
        if (v122 < 0)
          goto LABEL_188;
        v123 = &v223[v122];
        v124 = v221 - (_QWORD)v123;
        if (v121 == 4)
          v125 = v55;
        else
          v125 = 0;
        v126 = &v223[v122];
        v127 = (unsigned __int16 *)v236;
        goto LABEL_184;
      default:
        __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 1989, "EEA_NONE == prog.ep_enc_action");
    }
  }
}

_BYTE *lsqpack_enc_int(_BYTE *result, unint64_t a2, unint64_t a3, char a4)
{
  _BYTE *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _BYTE *v8;

  if ((unint64_t)result >= a2)
    __assert_rtn("lsqpack_enc_int", "lsqpack.c", 759, "dst < end");
  if (~(-1 << a4) <= a3)
  {
    *result |= ~(-1 << a4);
    v4 = result + 1;
    v5 = a3 - ~(-1 << a4);
    if (v5 < 0x80)
    {
      v8 = result;
      LODWORD(v6) = a3 + (-1 << a4) + 1;
LABEL_9:
      if ((unint64_t)v4 < a2)
      {
        result = v8 + 2;
        *v4 = v6;
      }
    }
    else
    {
      while ((unint64_t)v4 < a2)
      {
        *v4++ = v5 | 0x80;
        v6 = v5 >> 7;
        v7 = v5 >> 14;
        v5 >>= 7;
        if (!v7)
        {
          v8 = v4 - 1;
          goto LABEL_9;
        }
      }
    }
  }
  else
  {
    *result++ |= a3;
  }
  return result;
}

uint64_t XXH_INLINE_XXH32(int *a1, unint64_t a2, int a3)
{
  unint64_t v3;
  int v4;
  int v5;
  int v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  unsigned int v17;

  if (a1)
  {
    if (a2 < 0x10)
    {
      v12 = a3 + 374761393 + a2;
    }
    else
    {
      v3 = (unint64_t)a1 + a2 - 15;
      v4 = a3 + 606290984;
      v5 = a3 - 2048144777;
      v6 = a3 + 1640531535;
      do
      {
        HIDWORD(v7) = v4 - 2048144777 * *a1;
        LODWORD(v7) = HIDWORD(v7);
        v4 = -1640531535 * (v7 >> 19);
        HIDWORD(v7) = v5 - 2048144777 * a1[1];
        LODWORD(v7) = HIDWORD(v7);
        v5 = -1640531535 * (v7 >> 19);
        HIDWORD(v7) = a3 - 2048144777 * a1[2];
        LODWORD(v7) = HIDWORD(v7);
        a3 = -1640531535 * (v7 >> 19);
        HIDWORD(v7) = v6 - 2048144777 * a1[3];
        LODWORD(v7) = HIDWORD(v7);
        v6 = -1640531535 * (v7 >> 19);
        a1 += 4;
      }
      while ((unint64_t)a1 < v3);
      HIDWORD(v9) = v4;
      LODWORD(v9) = v4;
      v8 = v9 >> 31;
      HIDWORD(v9) = v5;
      LODWORD(v9) = v5;
      v10 = v9 >> 25;
      HIDWORD(v9) = a3;
      LODWORD(v9) = a3;
      v11 = v9 >> 20;
      HIDWORD(v9) = v6;
      LODWORD(v9) = v6;
      v12 = v8 + a2 + v10 + v11 + (v9 >> 14);
      a2 &= 0xFu;
    }
    if (a2 >= 4)
    {
      do
      {
        v13 = *a1++;
        HIDWORD(v14) = v12 - 1028477379 * v13;
        LODWORD(v14) = HIDWORD(v14);
        v12 = 668265263 * (v14 >> 15);
        a2 -= 4;
      }
      while (a2 > 3);
    }
    for (; a2; --a2)
    {
      v15 = *(unsigned __int8 *)a1;
      a1 = (int *)((char *)a1 + 1);
      HIDWORD(v16) = v12 + 374761393 * v15;
      LODWORD(v16) = HIDWORD(v16);
      v12 = -1640531535 * (v16 >> 21);
    }
  }
  else
  {
    v12 = a3 + 374761393;
  }
  v17 = -1028477379 * ((-2048144777 * (v12 ^ (v12 >> 15))) ^ ((-2048144777 * (v12 ^ (v12 >> 15))) >> 13));
  return v17 ^ HIWORD(v17);
}

void qenc_remove_overflow_entries(uint64_t a1)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  void **v5;
  char *v6;
  FILE *v7;
  _QWORD *v8;
  void *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  char *v15;
  uint64_t v16;
  void **v17;
  void *v18;
  int v19;
  FILE *v20;
  BOOL v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  float v25;
  float v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  _DWORD *v31;
  int v32;
  uint64_t v33;
  int v34;
  float v35;
  float v36;
  FILE *v37;
  FILE *v38;
  unsigned int v39;

  v2 = *(_DWORD *)(a1 + 16);
  v3 = *(_DWORD *)(a1 + 20);
  v4 = v3;
  if (v2 > v3)
  {
    v5 = (void **)(a1 + 56);
    do
    {
      v6 = (char *)*v5;
      if (!*v5)
        __assert_rtn("qenc_drop_oldest_entry", "lsqpack.c", 852, "entry");
      v7 = *(FILE **)(a1 + 200);
      v8 = *v5;
      if (v7)
      {
        fwrite("qenc: debug: ", 0xDuLL, 1uLL, v7);
          *((_DWORD *)v6 + 6),
          *((_DWORD *)v6 + 12),
          v6 + 56,
          *((_DWORD *)v6 + 13),
          &v6[*((unsigned int *)v6 + 12) + 56],
          *(_DWORD *)(a1 + 48) - 1,
          *(_DWORD *)(a1 + 16) - (*((_DWORD *)v6 + 12) + *((_DWORD *)v6 + 13)) - 32);
        fputc(10, *(FILE **)(a1 + 200));
        v8 = *(_QWORD **)(a1 + 56);
      }
      v9 = (void *)v8[2];
      *v5 = v9;
      if (!v9)
        *(_QWORD *)(a1 + 64) = v5;
      v10 = -1 << *(_DWORD *)(a1 + 52);
      v11 = *((_DWORD *)v6 + 10) & ~v10;
      v12 = *(_QWORD *)(a1 + 72);
      v13 = v12 + 32 * v11;
      v15 = *(char **)(v13 + 16);
      v14 = (_QWORD *)(v13 + 16);
      if (v6 != v15)
        __assert_rtn("qenc_drop_oldest_entry", "lsqpack.c", 859, "entry == STAILQ_FIRST(&enc->qpe_buckets[buckno].by_nameval)");
      v16 = *(_QWORD *)v6;
      *v14 = *(_QWORD *)v6;
      if (!v16)
        *(_QWORD *)(v12 + 32 * v11 + 24) = v14;
      v17 = (void **)(v12 + 32 * (*((_DWORD *)v6 + 11) & ~v10));
      if (v6 != *v17)
        __assert_rtn("qenc_drop_oldest_entry", "lsqpack.c", 862, "entry == STAILQ_FIRST(&enc->qpe_buckets[buckno].by_name)");
      v18 = (void *)*((_QWORD *)v6 + 1);
      *v17 = v18;
      if (!v18)
        v17[1] = v17;
      v19 = *((_DWORD *)v6 + 12) + *((_DWORD *)v6 + 13) + 32;
      *(_DWORD *)(a1 + 32) += v19;
      *(_DWORD *)(a1 + 16) -= v19;
      --*(_DWORD *)(a1 + 48);
      free(v6);
      v4 = *(_DWORD *)(a1 + 20);
    }
    while (*(_DWORD *)(a1 + 16) > v4);
  }
  v20 = *(FILE **)(a1 + 200);
  if (v4)
    v21 = v20 == 0;
  else
    v21 = 1;
  if (!v21)
  {
    v22 = *(_DWORD *)(a1 + 12);
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v20);
    v24 = *(_DWORD *)(a1 + 16);
    v23 = *(_DWORD *)(a1 + 20);
    v25 = (float)v23;
    v26 = (float)v24 / (float)v23;
    v27 = v26;
    if ((v22 & 2) != 0)
    {
      if (!v23)
        __assert_rtn("qenc_effective_fill", "lsqpack.c", 878, "enc->qpe_cur_max_capacity");
      v28 = *(_QWORD *)(a1 + 56);
      v39 = v2;
      v38 = *(FILE **)(a1 + 200);
      if (v28 && (v29 = *(_QWORD *)(v28 + 16)) != 0)
      {
        v30 = 0;
        do
        {
          v31 = (_DWORD *)v28;
          v28 = v29;
          v32 = v31[12];
          v33 = v29;
          while (1)
          {
            if (*(_DWORD *)(v33 + 48) == v32)
            {
              v34 = *(_DWORD *)(v33 + 52);
              if (v34 == v31[13] && !memcmp((const void *)(v33 + 56), v31 + 14, (v34 + v32)))
                break;
            }
            v33 = *(_QWORD *)(v33 + 16);
            if (!v33)
              goto LABEL_32;
          }
          v30 += v32 + v34 + 32;
LABEL_32:
          v29 = *(_QWORD *)(v28 + 16);
        }
        while (v29);
      }
      else
      {
        v30 = 0;
      }
      fprintf(v38, "fill: %.2f; effective fill: %.2f", v27, (float)((float)(v24 - v30) / v25));
      v2 = v39;
    }
    else
    {
      fprintf(*(FILE **)(a1 + 200), "fill: %.2f", v26);
    }
    fputc(10, *(FILE **)(a1 + 200));
  }
  if (v2 > v3 && *(_QWORD *)(a1 + 216))
  {
    v35 = *(float *)(a1 + 208);
    v36 = (float)*(unsigned int *)(a1 + 48);
    if (v35 != 0.0)
      v36 = v35 + (float)(v36 - v35) * 0.4;
    *(float *)(a1 + 208) = v36;
    v37 = *(FILE **)(a1 + 200);
    if (v37)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v37);
      fprintf(*(FILE **)(a1 + 200), "table size actual: %u; exponential moving average: %.3f",
        *(_DWORD *)(a1 + 48),
        *(float *)(a1 + 208));
      fputc(10, *(FILE **)(a1 + 200));
    }
  }
}

uint64_t lsqpack_enc_enc_str(char a1, _BYTE *a2, unint64_t a3, unsigned __int16 *a4, unsigned int a5)
{
  unsigned __int16 *v6;
  unint64_t v8;
  unsigned int v9;
  unsigned __int16 *v10;
  unsigned int v11;
  unsigned int v12;
  unint64_t v13;
  int v14;
  int64x2_t v15;
  uint64x2_t v16;
  int16x8_t v17;
  __int32 v18;
  unint64_t v19;
  _BYTE *v20;
  unsigned int v21;
  uint64_t v22;
  _BYTE *v23;
  uint64_t v24;
  unsigned __int16 *v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  unsigned __int16 *v31;
  uint64_t v32;
  int v33;
  size_t v34;
  int v35;
  int64x2_t v36;
  uint64x2_t v37;
  int16x8_t v38;
  __int32 v39;
  unint64_t v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int *v43;
  unsigned int v44;
  unsigned int v45;
  uint64_t v46;
  _BYTE *v47;
  unsigned int v48;
  char v49;
  uint64_t v50;
  int v51;

  v6 = a4;
  v8 = (unint64_t)a4 + a5;
  v9 = 0;
  if (a5)
  {
    v10 = a4;
    do
    {
      v11 = *(unsigned __int8 *)v10;
      v10 = (unsigned __int16 *)((char *)v10 + 1);
      v9 += encode_table[2 * v11 + 1];
    }
    while ((unint64_t)v10 < v8);
  }
  v12 = v9 >> 3;
  if ((v9 & 7) != 0)
    v13 = v12 + 1;
  else
    v13 = v12;
  if (v13 >= a5)
  {
    v34 = a5;
    if (~(-1 << a1) > (unint64_t)a5)
      v35 = 1;
    else
      v35 = 2;
    v36 = vdupq_n_s64(-1 << a1);
    v37 = (uint64x2_t)vdupq_n_s64(a5);
    v38 = (int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_u64(v37, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_1841E3990, v36)), (int32x4_t)vcgeq_u64(v37, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_1841E39A0, v36))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_u64(v37, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_1841E39B0, v36)), (int32x4_t)vcgeq_u64(v37, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_1841E39C0, v36)))), (int8x16_t)xmmword_1841E39D0);
    v38.i32[0] = vaddvq_s16(v38);
    *(int8x8_t *)v38.i8 = vcnt_s8(*(int8x8_t *)v38.i8);
    v38.i16[0] = vaddlv_u8(*(uint8x8_t *)v38.i8);
    v39 = v35 + v38.i32[0];
    v40 = v35 + v38.i32[0] + a5;
    if (v40 <= a3)
    {
      *a2 &= -2 << a1;
      lsqpack_enc_int_nocheck(a2, a5, a1);
      memcpy(&a2[v39], v6, v34);
      return v40;
    }
    return 0xFFFFFFFFLL;
  }
  if (~(-1 << a1) > (unint64_t)v13)
    v14 = 1;
  else
    v14 = 2;
  v15 = vdupq_n_s64(-1 << a1);
  v16 = (uint64x2_t)vdupq_n_s64(v13);
  v17 = (int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_u64(v16, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_1841E3990, v15)), (int32x4_t)vcgeq_u64(v16, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_1841E39A0, v15))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_u64(v16, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_1841E39B0, v15)), (int32x4_t)vcgeq_u64(v16, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_1841E39C0, v15)))), (int8x16_t)xmmword_1841E39D0);
  v17.i32[0] = vaddvq_s16(v17);
  *(int8x8_t *)v17.i8 = vcnt_s8(*(int8x8_t *)v17.i8);
  v17.i16[0] = vaddlv_u8(*(uint8x8_t *)v17.i8);
  v18 = v14 + v17.i32[0];
  v19 = (v14 + v17.i32[0] + v13);
  if (v19 > a3)
    return 0xFFFFFFFFLL;
  *a2 = *a2 & (-2 << a1) | (1 << a1);
  lsqpack_enc_int_nocheck(a2, v13, a1);
  v20 = &a2[v18];
  if (a5 < 0xF)
  {
    v22 = 0;
    v21 = 0;
  }
  else
  {
    v21 = 0;
    v22 = 0;
    v23 = &a2[v18];
    while (1)
    {
      v25 = v6 + 1;
      v24 = *v6;
      v26 = hencs[2 * v24];
      v27 = v26 + v21;
      if (v26 + v21 > 0x3F)
      {
        v31 = v6;
      }
      else
      {
        do
        {
          v21 = v27;
          v28 = v22 << v26;
          v29 = hencs[2 * v24 + 1];
          v30 = *v25++;
          v24 = v30;
          v22 = v28 | v29;
          v26 = hencs[2 * v30];
          v27 += v26;
        }
        while (v27 < 0x40);
        v31 = v25 - 1;
      }
      v6 = v25;
      if (v26 > 0x3F)
        break;
      v32 = v22 << -(char)v21;
      v22 = hencs[2 * v24 + 1];
      v21 = v26 - (64 - v21);
      *v23 = HIBYTE(v32);
      v23[1] = BYTE6(v32);
      v23[2] = BYTE5(v32);
      v23[3] = BYTE4(v32);
      v33 = v32 | (v22 >> v21);
      v23[4] = HIBYTE(v33);
      v23[5] = BYTE2(v33);
      v23[6] = BYTE1(v33);
      v20 = v23 + 8;
      v23[7] = v33;
      v23 += 8;
      if ((unint64_t)(v6 + 7) >= v8)
        goto LABEL_29;
    }
    v20 = v23;
    v6 = v31;
  }
LABEL_29:
  if (v6 != (unsigned __int16 *)v8)
  {
    do
    {
      v41 = v22;
      while (1)
      {
        v42 = *(unsigned __int8 *)v6;
        v6 = (unsigned __int16 *)((char *)v6 + 1);
        v43 = &encode_table[2 * v42];
        v22 = *v43;
        v44 = v43[1];
        v45 = v44 + v21;
        if (v44 + v21 > 0x3F)
          break;
        v41 = (v41 << v44) | v22;
        v21 += v44;
        if (v6 == (unsigned __int16 *)v8)
        {
          v47 = v20;
          v22 = v41;
          v21 = v45;
          goto LABEL_35;
        }
      }
      v46 = v41 << -(char)v21;
      v21 = v44 - (64 - v21);
      *v20 = HIBYTE(v46);
      v20[1] = BYTE6(v46);
      v20[2] = BYTE5(v46);
      v20[3] = BYTE4(v46);
      LODWORD(v46) = v46 | (v22 >> v21);
      v20[4] = BYTE3(v46);
      v20[5] = BYTE2(v46);
      v20[6] = BYTE1(v46);
      v47 = v20 + 8;
      v20[7] = v46;
      v20 += 8;
    }
    while (v6 != (unsigned __int16 *)v8);
LABEL_35:
    if (!v21)
      goto LABEL_47;
    goto LABEL_38;
  }
  v47 = v20;
  if (v21)
  {
LABEL_38:
    v48 = v21 + 7;
    v49 = ((v21 + 7) & 0xF8) - v21;
    v50 = v22 << v49;
    v51 = (v22 << v49) | ~(-1 << v49);
    switch(v48 >> 3)
    {
      case 2u:
        goto LABEL_45;
      case 3u:
        goto LABEL_44;
      case 4u:
        goto LABEL_43;
      case 5u:
        goto LABEL_42;
      case 6u:
        goto LABEL_41;
      case 7u:
        goto LABEL_40;
      case 8u:
        *v47++ = HIBYTE(v50);
LABEL_40:
        *v47++ = BYTE6(v50);
LABEL_41:
        *v47++ = BYTE5(v50);
LABEL_42:
        *v47++ = BYTE4(v50);
LABEL_43:
        *v47++ = HIBYTE(v51);
LABEL_44:
        *v47++ = BYTE2(v51);
LABEL_45:
        *v47++ = BYTE1(v51);
        break;
      default:
        break;
    }
    *v47 = v51;
    LODWORD(v47) = (_DWORD)v47 + 1;
  }
LABEL_47:
  if ((_DWORD)v19 != (_DWORD)v47 - (_DWORD)a2)
    __assert_rtn("lsqpack_enc_enc_str", "lsqpack.c", 823, "(unsigned) (p - dst) == len_size + enc_size_bytes");
  return v19;
}

_BYTE *lsqpack_enc_int_nocheck(_BYTE *result, unint64_t a2, char a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;

  if (~(-1 << a3) <= a2)
  {
    *result++ |= ~(-1 << a3);
    v3 = a2 - ~(-1 << a3);
    if (v3 < 0x80)
    {
      LODWORD(v4) = a2 + (-1 << a3) + 1;
    }
    else
    {
      do
      {
        *result++ = v3 | 0x80;
        v4 = v3 >> 7;
        v5 = v3 >> 14;
        v3 >>= 7;
      }
      while (v5);
    }
    *result = v4;
  }
  else
  {
    *result |= a2;
  }
  return result;
}

uint64_t qenc_has_or_can_evict_at_least(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  int v3;
  uint64_t *v4;
  unsigned int v5;
  unsigned int v6;
  BOOL v7;
  uint64_t v8;
  unsigned int v9;
  BOOL v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;

  v2 = (*(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 16));
  if (v2 >= a2)
    return 1;
  v3 = *(_DWORD *)(a1 + 152);
  if ((v3 & 4) != 0)
  {
    v5 = *(_DWORD *)(a1 + 148);
  }
  else
  {
    v4 = *(uint64_t **)(a1 + 96);
    if (v4)
    {
      v5 = 0;
      do
      {
        v6 = *((_DWORD *)v4 + 14);
        if (!v5 || (v6 ? (v7 = v6 >= v5) : (v7 = 1), !v7))
          v5 = *((_DWORD *)v4 + 14);
        v4 = (uint64_t *)*v4;
      }
      while (v4);
    }
    else
    {
      v5 = 0;
    }
    *(_DWORD *)(a1 + 148) = v5;
    *(_DWORD *)(a1 + 152) = v3 | 4;
  }
  v8 = *(_QWORD *)(a1 + 128);
  if (v8)
  {
    v9 = *(_DWORD *)(v8 + 56);
    if (!v5 || (v9 ? (v10 = v9 >= v5) : (v10 = 1), !v10))
      v5 = v9;
  }
  v11 = *(_QWORD *)(a1 + 56);
  if (v11)
  {
    v12 = v5 - 1;
    do
    {
      v13 = *(_DWORD *)(v11 + 24);
      if (v12 < v13 || v13 > *(_DWORD *)(a1 + 4))
        break;
      v2 += (*(_DWORD *)(v11 + 48) + *(_DWORD *)(v11 + 52) + 32);
      if (v2 >= a2)
        return 1;
      v11 = *(_QWORD *)(v11 + 16);
    }
    while (v11);
  }
  return 0;
}

_QWORD *lsqpack_enc_push_entry(uint64_t a1, int a2, int a3, const void *a4, unsigned int a5, const void *a6, unsigned int a7)
{
  const void *v8;
  int v13;
  uint64_t v14;
  _QWORD *v16;
  uint64_t v17;
  int v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  char *v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t *v33;
  _DWORD *v34;
  int v35;
  _DWORD *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  FILE *v41;
  _QWORD v44[3];

  v8 = a6;
  v44[2] = *MEMORY[0x1E0C80C00];
  v13 = *(_DWORD *)(a1 + 52);
  v14 = 1 << v13;
  if (*(_DWORD *)(a1 + 48) >= (1 << v13) >> 1)
  {
    v16 = malloc_type_malloc(32 * (1 << (v13 + 1)), 0xA004088793A40uLL);
    if (!v16)
      return v16;
    v17 = 0;
    v18 = (1 << (v13 + 1)) - 1;
    v19 = *(_QWORD **)(a1 + 72);
    v8 = a6;
    do
    {
      v20 = &v16[4 * v17];
      v21 = &v16[4 * (v14 + v17)];
      v44[0] = v20;
      v44[1] = v21;
      *v20 = 0;
      v20[1] = v20;
      *v21 = 0;
      v21[1] = v21;
      v20[2] = 0;
      v20[3] = v20 + 2;
      v21[2] = 0;
      v21[3] = v21 + 2;
      while (1)
      {
        v22 = &v19[4 * v17];
        v23 = *v22;
        if (!*v22)
          break;
        v24 = *(_QWORD *)(v23 + 8);
        *v22 = v24;
        if (!v24)
          v22[1] = (uint64_t)v22;
        v25 = ((*(_DWORD *)(v23 + 44) & v18) >> v13) & 1;
        *(_QWORD *)(v23 + 8) = 0;
        v26 = v44[v25];
        **(_QWORD **)(v26 + 8) = v23;
        *(_QWORD *)(v26 + 8) = v23 + 8;
        v19 = *(_QWORD **)(a1 + 72);
      }
      while (1)
      {
        v30 = (char *)&v19[4 * v17];
        v33 = (uint64_t *)*((_QWORD *)v30 + 2);
        v32 = (uint64_t *)(v30 + 16);
        v31 = v33;
        if (!v33)
          break;
        v27 = *v31;
        *v32 = *v31;
        if (!v27)
          v19[4 * v17 + 3] = v32;
        v28 = (((_DWORD)v31[5] & v18) >> v13) & 1;
        *v31 = 0;
        v29 = v44[v28];
        **(_QWORD **)(v29 + 24) = v31;
        *(_QWORD *)(v29 + 24) = v31;
        v19 = *(_QWORD **)(a1 + 72);
      }
      ++v17;
    }
    while (v17 != v14);
    free(v19);
    *(_DWORD *)(a1 + 52) = v13 + 1;
    *(_QWORD *)(a1 + 72) = v16;
  }
  v34 = malloc_type_malloc(a5 + (unint64_t)a7 + 56, 0x5A4B1079uLL);
  v16 = v34;
  if (v34)
  {
    v34[10] = a3;
    v34[11] = a2;
    v34[12] = a5;
    v34[13] = a7;
    v34[7] = *(_DWORD *)(a1 + 16);
    v34[8] = *(_DWORD *)(a1 + 32);
    v35 = *(_DWORD *)a1 + 1;
    *(_DWORD *)a1 = v35;
    v34[6] = v35;
    v36 = v34 + 14;
    memcpy(v34 + 14, a4, a5);
    memcpy((char *)v36 + a5, v8, a7);
    v16[2] = 0;
    **(_QWORD **)(a1 + 64) = v16;
    *(_QWORD *)(a1 + 64) = v16 + 2;
    v37 = -1 << *(_DWORD *)(a1 + 52);
    v38 = a3 & ~v37;
    *v16 = 0;
    **(_QWORD **)(*(_QWORD *)(a1 + 72) + 32 * v38 + 24) = v16;
    v39 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(v39 + 32 * v38 + 24) = v16;
    v40 = a2 & ~v37;
    v16[1] = 0;
    **(_QWORD **)(v39 + 32 * v40 + 8) = v16;
    *(_QWORD *)(*(_QWORD *)(a1 + 72) + 32 * v40 + 8) = v16 + 1;
    *(_DWORD *)(a1 + 16) += a5 + a7 + 32;
    ++*(_DWORD *)(a1 + 48);
    v41 = *(FILE **)(a1 + 200);
    if (v41)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v41);
        *((_DWORD *)v16 + 6),
        *((_DWORD *)v16 + 12),
        (const char *)v16 + 56,
        *((_DWORD *)v16 + 13),
        (const char *)v16 + *((unsigned int *)v16 + 12) + 56,
        *(_DWORD *)(a1 + 48),
        *(_DWORD *)(a1 + 16));
      fputc(10, *(FILE **)(a1 + 200));
    }
  }
  return v16;
}

uint64_t HTTP3Framer::getStreamID(NSObject *this)
{
  NSObject *v2;
  nw_protocol_metadata_t v3;
  void *v4;
  uint64_t id;

  v2 = nw_protocol_copy_quic_connection_definition();
  v3 = nw_content_context_copy_protocol_metadata(this, v2);

  v4 = (void *)nw_quic_connection_copy_stream_metadata();
  if (v4)
    id = nw_quic_stream_get_id();
  else
    id = -1;

  return id;
}

void sub_183F48B40(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZN15HTTP2Connection10initializeEP4TubeiP25HTTP2ConnectionCacheEntry_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  int v18;
  NSObject *v19;
  const char *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  _BYTE *v26;
  char v27;
  _BYTE *v28;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int *v37;
  int v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t v42;
  NSObject *v43;
  const __CFString *v44;
  char *v45;
  BOOL v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  const void *v51;
  unint64_t *v52;
  unint64_t v53;
  CFTypeID v54;
  BOOL v55;
  uint64_t v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  const void *v60;
  unint64_t *v61;
  unint64_t v62;
  CFTypeID v63;
  std::__shared_weak_count *v64;
  unint64_t *v65;
  unint64_t v66;
  unint64_t v67;
  std::__shared_weak_count *v68;
  std::__shared_weak_count *v69;
  unint64_t *v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  std::__shared_weak_count *v76;
  unint64_t *v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  std::__shared_weak_count *v81;
  unint64_t *v82;
  unint64_t v83;
  std::__shared_weak_count *v84;
  unint64_t *v85;
  unint64_t v86;
  std::__shared_weak_count *v87;
  uint64_t v88;
  unint64_t *v89;
  unint64_t v90;
  unint64_t *v91;
  unint64_t v92;
  std::__shared_weak_count *v93;
  unint64_t *v94;
  unint64_t v95;
  std::__shared_weak_count *v96;
  unint64_t *v97;
  unint64_t v98;
  std::__shared_weak_count *v99;
  uint64_t v100;
  unint64_t *v101;
  unint64_t v102;
  unint64_t *v103;
  unint64_t v104;
  std::__shared_weak_count *v105;
  unint64_t *v106;
  unint64_t v107;
  std::__shared_weak_count *v108;
  unint64_t *v109;
  unint64_t v110;
  unint64_t *v111;
  unint64_t v112;
  _QWORD *v113;
  std::__shared_weak_count *v114;
  unint64_t *v115;
  unint64_t v116;
  uint64_t v117;
  uint64_t v118;
  std::__shared_weak_count *v119;
  unint64_t *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t *v123;
  unint64_t v124;
  unint64_t *v125;
  unint64_t v126;
  unint64_t *v127;
  unint64_t v128;
  uint64_t *v129;
  unint64_t v130;
  std::__shared_weak_count *v131;
  unint64_t *v132;
  unint64_t v133;
  std::__shared_weak_count *v134;
  unint64_t *v135;
  unint64_t v136;
  std::__shared_weak_count *v137;
  unint64_t *v138;
  unint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char v142;
  _QWORD *v143;
  NSObject *v144;
  std::__shared_weak_count *v145;
  unint64_t *v146;
  unint64_t v147;
  HTTPStallTimer **v148;
  std::__shared_weak_count *v149;
  unint64_t *v150;
  unint64_t v151;
  _QWORD v152[6];
  std::__shared_weak_count *v153;
  __int128 aBlock;
  void (*v155)(__int128 *);
  void *v156;
  uint64_t v157;
  std::__shared_weak_count *v158;
  std::__shared_weak_count *v159;
  std::__shared_weak_count *v160;
  std::__shared_weak_count *v161;
  std::__shared_weak_count *v162;
  std::__shared_weak_count *v163;
  uint64_t v164;
  std::__shared_weak_count *v165;
  uint64_t v166;
  std::__shared_weak_count *v167;
  std::__shared_weak_count *v168;
  std::__shared_weak_count *v169;
  _QWORD v170[2];
  _BYTE buf[24];
  void *v172;
  uint64_t v173;
  uint64_t v174;

  v174 = *MEMORY[0x1E0C80C00];
  v2 = a1[5];
  v3 = a1[6];
  v4 = *(_QWORD *)(v2 + 56);
  if (*(_DWORD *)v4 == 1)
  {
    v5 = *(_QWORD *)(v3 + 136);
    if (v5)
      *(_BYTE *)(v3 + 240) = 0;
    v6 = *(std::__shared_weak_count **)(v3 + 144);
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
      if (*(_DWORD *)v4 == 1)
        std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v4 + 8), v5, (uint64_t)v6);
      v9 = (unint64_t *)&v6->__shared_owners_;
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    else
    {
      std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v4 + 8), v5, 0);
    }
    v11 = *(_QWORD *)(v2 + 56);
    v12 = *(_QWORD *)(v11 + 8);
    v13 = *(std::__shared_weak_count **)(v11 + 16);
    *(_QWORD *)&aBlock = v12;
    *((_QWORD *)&aBlock + 1) = v13;
    if (v13)
    {
      v14 = (unint64_t *)&v13->__shared_owners_;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    *(_QWORD *)(v2 + 72) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 256))(v12);
    if (v13)
    {
      v16 = (unint64_t *)&v13->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    if (!*(_QWORD *)(v2 + 56))
      goto LABEL_35;
    v3 = a1[6];
  }
  v170[0] = 0;
  v18 = nghttp2_option_new();
  if (v18)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v19 = CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
      goto LABEL_35;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v18;
    v20 = "Failed to create http2 option %d";
LABEL_61:
    _os_log_fault_impl(&dword_183ECA000, v19, OS_LOG_TYPE_FAULT, v20, buf, 8u);
LABEL_35:
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 0;
    return;
  }
  nghttp2_option_set_no_auto_window_update();
  nghttp2_option_set_no_rfc9113_leading_and_trailing_ws_validation();
  *(_DWORD *)(v2 + 180) = 4096;
  *(_BYTE *)(v2 + 184) = 1;
  *(_OWORD *)(v2 + 188) = xmmword_1841E3890;
  if (sessionCallbacks(void)::onceToken != -1)
    dispatch_once(&sessionCallbacks(void)::onceToken, &__block_literal_global_60);
  v21 = nghttp2_session_client_new2();
  MEMORY[0x186DB7D44](v170[0]);
  if (v21)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v19 = CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
      goto LABEL_35;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v21;
    v20 = "Failed to create http2 session %d";
    goto LABEL_61;
  }
  v22 = Tube::copyWaiter(*(Tube **)(v3 + 112));
  v23 = MEMORY[0x1E0C809B0];
  if (v22)
  {
    *(_QWORD *)&aBlock = MEMORY[0x1E0C809B0];
    *((_QWORD *)&aBlock + 1) = 3221225472;
    v155 = (void (*)(__int128 *))___ZN15HTTP2Connection15initializeHTTP2EP4Tube_block_invoke;
    v156 = &__block_descriptor_40_e5_v8__0l;
    v157 = v22;
    v24 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v22 + 80))(v22);
    if (v24)
      *(_DWORD *)(v2 + 216) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v24 + 168))(v24);
    v155(&aBlock);
  }
  v25 = getenv("CFN_USE_HTTP2_SERVER_PUSH");
  if (!v25)
    goto LABEL_75;
  v26 = buf;
  std::string::basic_string[abi:nn180100]<0>(buf, v25);
  v27 = buf[23];
  if (buf[23] >= 0)
    v28 = &buf[buf[23]];
  else
    v28 = (_BYTE *)(*(_QWORD *)buf + *(_QWORD *)&buf[8]);
  if (buf[23] < 0)
    v26 = *(_BYTE **)buf;
  if (v26 != v28)
  {
    do
    {
      *v26 = __tolower((char)*v26);
      ++v26;
    }
    while (v26 != v28);
    v27 = buf[23];
  }
  if (v27 < 0)
  {
    if (*(_QWORD *)&buf[8] == 1)
    {
      if (**(_BYTE **)buf == 49)
      {
LABEL_77:
        operator delete(*(void **)buf);
        goto LABEL_78;
      }
    }
    else if (*(_QWORD *)&buf[8] == 3)
    {
      if (**(_WORD **)buf == 25977 && *(_BYTE *)(*(_QWORD *)buf + 2) == 115)
        goto LABEL_77;
    }
    else if (*(_QWORD *)&buf[8] == 4 && **(_DWORD **)buf == 1702195828)
    {
      goto LABEL_77;
    }
    operator delete(*(void **)buf);
    goto LABEL_75;
  }
  if (v27 != 1)
  {
    if (v27 == 3)
    {
      if (*(unsigned __int16 *)buf == 25977 && buf[2] == 115)
        goto LABEL_78;
    }
    else if (v27 == 4 && *(_DWORD *)buf == 1702195828)
    {
      goto LABEL_78;
    }
LABEL_75:
    *(_QWORD *)buf = 2;
    v32 = *(_DWORD *)(v2 + 212);
    v31 = *(_DWORD *)(v2 + 216);
    *(_DWORD *)&buf[8] = 4;
    *(_DWORD *)&buf[12] = v31;
    *(_DWORD *)&buf[16] = 3;
    *(_DWORD *)&buf[20] = v32;
    v33 = nghttp2_submit_settings();
    goto LABEL_79;
  }
  if (buf[0] != 49)
    goto LABEL_75;
LABEL_78:
  v35 = *(_DWORD *)(v2 + 212);
  v34 = *(_DWORD *)(v2 + 216);
  *(_DWORD *)buf = 4;
  *(_DWORD *)&buf[4] = v34;
  *(_DWORD *)&buf[8] = 3;
  *(_DWORD *)&buf[12] = v35;
  v33 = nghttp2_submit_settings();
LABEL_79:
  *(_BYTE *)(v2 + 596) = v33 == 0;
  v36 = nghttp2_submit_window_update();
  if (v36 < 0)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v43 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v44 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
      v45 = _cfnAutoreleaseInDebug(v44);
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v45;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v36;
      _os_log_error_impl(&dword_183ECA000, v43, OS_LOG_TYPE_ERROR, "Could not submit window update on [%s], error code: %d", buf, 0x12u);
    }
    goto LABEL_35;
  }
  *(_DWORD *)(v2 + 176) = 0;
  v37 = *(int **)(v2 + 56);
  if (!v37)
  {
    v46 = 0;
    *(_BYTE *)(v2 + 597) = 0;
    goto LABEL_133;
  }
  v38 = *v37;
  if (*v37 == 1)
  {
    v47 = *((_QWORD *)v37 + 1);
    v48 = (std::__shared_weak_count *)*((_QWORD *)v37 + 2);
    *(_QWORD *)&aBlock = v47;
    *((_QWORD *)&aBlock + 1) = v48;
    if (v48)
    {
      v49 = (unint64_t *)&v48->__shared_owners_;
      do
        v50 = __ldxr(v49);
      while (__stxr(v50 + 1, v49));
    }
    v51 = (const void *)(*(uint64_t (**)(uint64_t, __CFString *))(*(_QWORD *)v47 + 216))(v47, CFSTR("kCFStreamPropertyConnectionIsCellular"));
    if (v48)
    {
      v52 = (unint64_t *)&v48->__shared_owners_;
      do
        v53 = __ldaxr(v52);
      while (__stlxr(v53 - 1, v52));
      if (!v53)
      {
        ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
        std::__shared_weak_count::__release_weak(v48);
      }
    }
    if (v51)
    {
      v54 = CFGetTypeID(v51);
      if (v54 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        LOWORD(aBlock) = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&aBlock, 2u);
      }
      v55 = *MEMORY[0x1E0C9AE50] == (_QWORD)v51;
      CFRelease(v51);
      goto LABEL_108;
    }
  }
  else
  {
    if (v38 != 2)
    {
      *(_BYTE *)(v2 + 597) = 0;
      goto LABEL_111;
    }
    v39 = (std::__shared_weak_count *)*((_QWORD *)v37 + 2);
    if (v39)
    {
      v40 = (unint64_t *)&v39->__shared_owners_;
      do
        v41 = __ldxr(v40);
      while (__stxr(v41 + 1, v40));
      do
        v42 = __ldaxr(v40);
      while (__stlxr(v42 - 1, v40));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
  }
  v55 = 0;
LABEL_108:
  v37 = *(int **)(v2 + 56);
  *(_BYTE *)(v2 + 597) = v55;
  if (!v37)
    goto LABEL_132;
  v38 = *v37;
LABEL_111:
  if (v38 == 2)
  {
    v64 = (std::__shared_weak_count *)*((_QWORD *)v37 + 2);
    if (v64)
    {
      v65 = (unint64_t *)&v64->__shared_owners_;
      do
        v66 = __ldxr(v65);
      while (__stxr(v66 + 1, v65));
      do
        v67 = __ldaxr(v65);
      while (__stlxr(v67 - 1, v65));
      if (!v67)
      {
        ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
        std::__shared_weak_count::__release_weak(v64);
      }
    }
    goto LABEL_132;
  }
  if (v38 != 1)
    goto LABEL_132;
  v56 = *((_QWORD *)v37 + 1);
  v57 = (std::__shared_weak_count *)*((_QWORD *)v37 + 2);
  *(_QWORD *)&aBlock = v56;
  *((_QWORD *)&aBlock + 1) = v57;
  if (v57)
  {
    v58 = (unint64_t *)&v57->__shared_owners_;
    do
      v59 = __ldxr(v58);
    while (__stxr(v59 + 1, v58));
  }
  v60 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v56 + 216))(v56, 0x1EDCF9648);
  if (v57)
  {
    v61 = (unint64_t *)&v57->__shared_owners_;
    do
      v62 = __ldaxr(v61);
    while (__stlxr(v62 - 1, v61));
    if (!v62)
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
  }
  if (!v60)
  {
LABEL_132:
    v46 = 0;
    goto LABEL_133;
  }
  v63 = CFGetTypeID(v60);
  if (v63 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(aBlock) = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&aBlock, 2u);
  }
  v46 = *MEMORY[0x1E0C9AE50] == (_QWORD)v60;
  CFRelease(v60);
LABEL_133:
  *(_BYTE *)(v2 + 598) = v46;
  CFRetain((CFTypeRef)(v2 - 16));
  CFRetain((CFTypeRef)(v2 - 16));
  v168 = (std::__shared_weak_count *)v2;
  v68 = (std::__shared_weak_count *)operator new();
  v69 = v68;
  v68->__shared_owners_ = 0;
  v70 = (unint64_t *)&v68->__shared_owners_;
  v68->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F15F8;
  v68->__shared_weak_owners_ = 0;
  v68[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
  v169 = v68;
  v71 = v2 + 16;
  if (!v2)
    v71 = 0;
  v166 = v71;
  v167 = v68;
  do
    v72 = __ldxr(v70);
  while (__stxr(v72 + 1, v70));
  v73 = *(_QWORD *)(v2 + 56);
  if (*(_DWORD *)v73 != 2)
  {
    if (*(_DWORD *)v73 != 1)
      __assert_rtn("setConnectionDelegate", "TCPIOConnectionTest.hpp", 196, "false");
    v74 = *(_QWORD *)(v73 + 8);
    *(_QWORD *)&aBlock = v71;
    *((_QWORD *)&aBlock + 1) = v69;
    do
      v75 = __ldxr(v70);
    while (__stxr(v75 + 1, v70));
    (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)v74 + 184))(v74, &aBlock);
    v76 = (std::__shared_weak_count *)*((_QWORD *)&aBlock + 1);
    if (*((_QWORD *)&aBlock + 1))
    {
      v77 = (unint64_t *)(*((_QWORD *)&aBlock + 1) + 8);
      do
        v78 = __ldaxr(v77);
      while (__stlxr(v78 - 1, v77));
      if (!v78)
      {
        ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
        std::__shared_weak_count::__release_weak(v76);
      }
    }
  }
  v164 = v2;
  v165 = v69;
  do
    v79 = __ldxr(v70);
  while (__stxr(v79 + 1, v70));
  *(_QWORD *)&aBlock = v23;
  *((_QWORD *)&aBlock + 1) = 3321888768;
  v155 = (void (*)(__int128 *))___ZN15HTTP2Connection25setupWriteCompletionBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke;
  v156 = &__block_descriptor_48_e8_32c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE_e13_v24__0___qi_8l;
  v157 = v2;
  v158 = v69;
  do
    v80 = __ldxr(v70);
  while (__stxr(v80 + 1, v70));
  *(_QWORD *)(v2 + 112) = _Block_copy(&aBlock);
  v81 = v158;
  if (v158)
  {
    v82 = (unint64_t *)&v158->__shared_owners_;
    do
      v83 = __ldaxr(v82);
    while (__stlxr(v83 - 1, v82));
    if (!v83)
    {
      ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
      std::__shared_weak_count::__release_weak(v81);
    }
  }
  v84 = v165;
  if (v165)
  {
    v85 = (unint64_t *)&v165->__shared_owners_;
    do
      v86 = __ldaxr(v85);
    while (__stlxr(v86 - 1, v85));
    if (!v86)
    {
      ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
      std::__shared_weak_count::__release_weak(v84);
    }
  }
  v88 = (uint64_t)v168;
  v87 = v169;
  v162 = v168;
  v163 = v169;
  if (v169)
  {
    v89 = (unint64_t *)&v169->__shared_owners_;
    do
      v90 = __ldxr(v89);
    while (__stxr(v90 + 1, v89));
    *(_QWORD *)&aBlock = v23;
    *((_QWORD *)&aBlock + 1) = 3321888768;
    v155 = (void (*)(__int128 *))___ZN15HTTP2Connection24setupReadCompletionBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke;
    v156 = &__block_descriptor_48_e8_32c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE_e47_v36__0__NSObject_OS_dispatch_data__8B16___qi_20l;
    v157 = v88;
    v158 = v87;
    v91 = (unint64_t *)&v87->__shared_owners_;
    do
      v92 = __ldxr(v91);
    while (__stxr(v92 + 1, v91));
  }
  else
  {
    *(_QWORD *)&aBlock = v23;
    *((_QWORD *)&aBlock + 1) = 3321888768;
    v155 = (void (*)(__int128 *))___ZN15HTTP2Connection24setupReadCompletionBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke;
    v156 = &__block_descriptor_48_e8_32c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE_e47_v36__0__NSObject_OS_dispatch_data__8B16___qi_20l;
    v157 = (uint64_t)v168;
    v158 = 0;
  }
  *(_QWORD *)(v88 + 120) = _Block_copy(&aBlock);
  v93 = v158;
  if (v158)
  {
    v94 = (unint64_t *)&v158->__shared_owners_;
    do
      v95 = __ldaxr(v94);
    while (__stlxr(v95 - 1, v94));
    if (!v95)
    {
      ((void (*)(std::__shared_weak_count *))v93->__on_zero_shared)(v93);
      std::__shared_weak_count::__release_weak(v93);
    }
  }
  v96 = v163;
  if (v163)
  {
    v97 = (unint64_t *)&v163->__shared_owners_;
    do
      v98 = __ldaxr(v97);
    while (__stlxr(v98 - 1, v97));
    if (!v98)
    {
      ((void (*)(std::__shared_weak_count *))v96->__on_zero_shared)(v96);
      std::__shared_weak_count::__release_weak(v96);
    }
  }
  v100 = (uint64_t)v168;
  v99 = v169;
  v160 = v168;
  v161 = v169;
  if (v169)
  {
    v101 = (unint64_t *)&v169->__shared_owners_;
    do
      v102 = __ldxr(v101);
    while (__stxr(v102 + 1, v101));
    *(_QWORD *)&aBlock = v23;
    *((_QWORD *)&aBlock + 1) = 3321888768;
    v155 = (void (*)(__int128 *))___ZN15HTTP2Connection20setupScheduleIOBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke;
    v156 = &__block_descriptor_48_e8_32c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE_e5_v8__0l;
    v157 = v100;
    v158 = v99;
    v103 = (unint64_t *)&v99->__shared_owners_;
    do
      v104 = __ldxr(v103);
    while (__stxr(v104 + 1, v103));
  }
  else
  {
    *(_QWORD *)&aBlock = v23;
    *((_QWORD *)&aBlock + 1) = 3321888768;
    v155 = (void (*)(__int128 *))___ZN15HTTP2Connection20setupScheduleIOBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke;
    v156 = &__block_descriptor_48_e8_32c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE_e5_v8__0l;
    v157 = (uint64_t)v168;
    v158 = 0;
  }
  *(_QWORD *)(v100 + 128) = _Block_copy(&aBlock);
  v105 = v158;
  if (v158)
  {
    v106 = (unint64_t *)&v158->__shared_owners_;
    do
      v107 = __ldaxr(v106);
    while (__stlxr(v107 - 1, v106));
    if (!v107)
    {
      ((void (*)(std::__shared_weak_count *))v105->__on_zero_shared)(v105);
      std::__shared_weak_count::__release_weak(v105);
    }
  }
  v108 = v161;
  if (v161)
  {
    v109 = (unint64_t *)&v161->__shared_owners_;
    do
      v110 = __ldaxr(v109);
    while (__stlxr(v110 - 1, v109));
    if (!v110)
    {
      ((void (*)(std::__shared_weak_count *))v108->__on_zero_shared)(v108);
      std::__shared_weak_count::__release_weak(v108);
    }
  }
  *(_QWORD *)&aBlock = v23;
  *((_QWORD *)&aBlock + 1) = 3321888768;
  v155 = (void (*)(__int128 *))___ZN15HTTP2Connection20initializeConnectionEv_block_invoke;
  v156 = &__block_descriptor_56_e8_40c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE_e25_v24__0____CFString__8_v16l;
  v157 = v2;
  v158 = v168;
  v159 = v169;
  if (v169)
  {
    v111 = (unint64_t *)&v169->__shared_owners_;
    do
      v112 = __ldxr(v111);
    while (__stxr(v112 + 1, v111));
  }
  v113 = operator new(0x28uLL);
  v113[1] = 0;
  v113[2] = 0;
  *v113 = &off_1E14F0B78;
  v113[3] = &off_1E14E81C8;
  v113[4] = 0;
  v113[4] = _Block_copy(&aBlock);
  *(_QWORD *)buf = v113 + 3;
  *(_QWORD *)&buf[8] = v113;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v2 + 272, (__int128 *)buf);
  v114 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v115 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v116 = __ldaxr(v115);
    while (__stlxr(v116 - 1, v115));
    if (!v116)
    {
      ((void (*)(std::__shared_weak_count *))v114->__on_zero_shared)(v114);
      std::__shared_weak_count::__release_weak(v114);
    }
  }
  v117 = *(_QWORD *)(v2 + 56);
  v118 = *(_QWORD *)(v2 + 272);
  v119 = *(std::__shared_weak_count **)(v2 + 280);
  v152[5] = v118;
  v153 = v119;
  if (v119)
  {
    v120 = (unint64_t *)&v119->__shared_owners_;
    do
      v121 = __ldxr(v120);
    while (__stxr(v121 + 1, v120));
  }
  *(_QWORD *)buf = v23;
  *(_QWORD *)&buf[8] = 3221225472;
  *(_QWORD *)&buf[16] = ___ZN15HTTP2Connection20initializeConnectionEv_block_invoke_34;
  v172 = &__block_descriptor_40_e6__v8__0l;
  v173 = v2;
  if (*(_DWORD *)v117 != 2)
  {
    if (*(_DWORD *)v117 != 1)
      __assert_rtn("registerForPropertyUpdates", "TCPIOConnectionTest.hpp", 206, "false");
    v122 = *(_QWORD *)(v117 + 8) + 16;
    v170[0] = v118;
    v170[1] = v119;
    if (v119)
    {
      v123 = (unint64_t *)&v119->__shared_owners_;
      do
        v124 = __ldxr(v123);
      while (__stxr(v124 + 1, v123));
    }
    NotificationStation::registerForPropertyUpdates(v122, CFSTR("__kCFStreamPropertyDoNotReuse"), v170, (uint64_t)buf);
    if (!v119)
      goto LABEL_220;
    v125 = (unint64_t *)&v119->__shared_owners_;
    do
      v126 = __ldaxr(v125);
    while (__stlxr(v126 - 1, v125));
LABEL_218:
    if (!v126)
    {
      ((void (*)(std::__shared_weak_count *))v119->__on_zero_shared)(v119);
      std::__shared_weak_count::__release_weak(v119);
    }
LABEL_220:
    if (v153)
    {
      v129 = &v153->__shared_owners_;
      do
        v130 = __ldaxr((unint64_t *)v129);
      while (__stlxr(v130 - 1, (unint64_t *)v129));
      if (!v130)
      {
        ((void (*)(std::__shared_weak_count *))v153->__on_zero_shared)(v153);
        std::__shared_weak_count::__release_weak(v153);
      }
    }
    goto LABEL_225;
  }
  if (v119)
  {
    v127 = (unint64_t *)&v119->__shared_owners_;
    do
      v128 = __ldxr(v127);
    while (__stxr(v128 + 1, v127));
    do
      v126 = __ldaxr(v127);
    while (__stlxr(v126 - 1, v127));
    goto LABEL_218;
  }
LABEL_225:
  v131 = v159;
  if (v159)
  {
    v132 = (unint64_t *)&v159->__shared_owners_;
    do
      v133 = __ldaxr(v132);
    while (__stlxr(v133 - 1, v132));
    if (!v133)
    {
      ((void (*)(std::__shared_weak_count *))v131->__on_zero_shared)(v131);
      std::__shared_weak_count::__release_weak(v131);
    }
  }
  v134 = v167;
  if (v167)
  {
    v135 = (unint64_t *)&v167->__shared_owners_;
    do
      v136 = __ldaxr(v135);
    while (__stlxr(v136 - 1, v135));
    if (!v136)
    {
      ((void (*)(std::__shared_weak_count *))v134->__on_zero_shared)(v134);
      std::__shared_weak_count::__release_weak(v134);
    }
  }
  v137 = v169;
  if (v169)
  {
    v138 = (unint64_t *)&v169->__shared_owners_;
    do
      v139 = __ldaxr(v138);
    while (__stlxr(v139 - 1, v138));
    if (!v139)
    {
      ((void (*)(std::__shared_weak_count *))v137->__on_zero_shared)(v137);
      std::__shared_weak_count::__release_weak(v137);
    }
  }
  v140 = *(_QWORD *)(a1[6] + 112);
  if (v140 && (v141 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v140 + 80))(v140)) != 0)
    v142 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v141 - 176) + 424))(v141 - 176);
  else
    v142 = 1;
  *(_BYTE *)(v2 + 642) = v142;
  v152[0] = v23;
  v152[1] = 3221225472;
  v152[2] = ___ZN15HTTP2Connection10initializeEP4TubeiP25HTTP2ConnectionCacheEntry_block_invoke_2;
  v152[3] = &__block_descriptor_40_e5_v8__0l;
  v152[4] = v2;
  v143 = operator new(0x58uLL);
  v143[1] = 0;
  v143[2] = 0;
  *v143 = &off_1E14F09B8;
  v144 = *(NSObject **)(v2 + 168);
  SmartBlockWithArgs<>::SmartBlockWithArgs((uint64_t *)&aBlock, v152);
  HTTPStallTimer::HTTPStallTimer((uint64_t)(v143 + 3), v144, (uint64_t *)&aBlock);
  v145 = (std::__shared_weak_count *)*((_QWORD *)&aBlock + 1);
  if (*((_QWORD *)&aBlock + 1))
  {
    v146 = (unint64_t *)(*((_QWORD *)&aBlock + 1) + 8);
    do
      v147 = __ldaxr(v146);
    while (__stlxr(v147 - 1, v146));
    if (!v147)
    {
      ((void (*)(std::__shared_weak_count *))v145->__on_zero_shared)(v145);
      std::__shared_weak_count::__release_weak(v145);
    }
  }
  *(_QWORD *)&aBlock = v143 + 3;
  *((_QWORD *)&aBlock + 1) = v143;
  std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&aBlock, v143 + 4, (uint64_t)(v143 + 3));
  v148 = (HTTPStallTimer **)(v2 + 648);
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v2 + 648, &aBlock);
  v149 = (std::__shared_weak_count *)*((_QWORD *)&aBlock + 1);
  if (*((_QWORD *)&aBlock + 1))
  {
    v150 = (unint64_t *)(*((_QWORD *)&aBlock + 1) + 8);
    do
      v151 = __ldaxr(v150);
    while (__stlxr(v151 - 1, v150));
    if (!v151)
    {
      ((void (*)(std::__shared_weak_count *))v149->__on_zero_shared)(v149);
      std::__shared_weak_count::__release_weak(v149);
    }
  }
  HTTPStallTimer::setup(*v148);
}

void sub_183F49BD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *SmartBlockWithArgs<>::SmartBlockWithArgs(uint64_t *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  v4 = (_QWORD *)operator new();
  v4[1] = BlockHolderVar<>::invoke_initial;
  v4[2] = 0;
  *v4 = _Block_copy(a2);
  *a1 = (uint64_t)v4;
  v5 = (_QWORD *)operator new();
  *v5 = &off_1E14F1198;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a1[1] = (uint64_t)v5;
  if (!a2)
  {
    v6 = *a1;
    *(_QWORD *)(v6 + 8) = BlockHolderVar<>::invoke_reseted;
    *(_QWORD *)(v6 + 16) = 0;
  }
  return a1;
}

void sub_183F49DA4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

uint64_t HTTPStallTimer::HTTPStallTimer(uint64_t a1, dispatch_object_t object, uint64_t *a3)
{
  NSObject **v6;
  uint64_t *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  _QWORD *v16;
  uint64_t v18;

  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = &off_1E14E7068;
  *(_OWORD *)(a1 + 24) = 0u;
  v6 = (NSObject **)(a1 + 24);
  *(_OWORD *)(a1 + 40) = 0u;
  v7 = (uint64_t *)(a1 + 40);
  *(_QWORD *)(a1 + 56) = 0;
  dispatch_retain(object);
  v8 = *v6;
  *v6 = object;
  if (v8)
    dispatch_release(v8);
  v9 = *a3;
  v10 = a3[1];
  if (v10)
  {
    v11 = (unint64_t *)(v10 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v13 = *(std::__shared_weak_count **)(a1 + 56);
  *(_QWORD *)(a1 + 48) = v9;
  *(_QWORD *)(a1 + 56) = v10;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
    v9 = *(_QWORD *)(a1 + 48);
  }
  if (v9)
  {
    *(_QWORD *)(v9 + 8) = BlockHolderVar<>::invoke_normal;
    *(_QWORD *)(v9 + 16) = 0;
  }
  v16 = (_QWORD *)operator new();
  v16[2] = 0;
  v16[1] = 0;
  *v16 = v16 + 1;
  v18 = 0;
  std::unique_ptr<std::set<std::shared_ptr<void>>>::reset[abi:nn180100](v7, (uint64_t)v16);
  std::unique_ptr<std::set<std::shared_ptr<void>>>::reset[abi:nn180100](&v18, 0);
  return a1;
}

void sub_183F49EFC(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t *v2;
  uint64_t v3;
  NSObject **v4;
  NSObject *v6;
  NSObject *v7;
  std::__shared_weak_count *v8;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::unique_ptr<std::set<std::shared_ptr<void>>>::reset[abi:nn180100](v2, 0);
  v6 = v1[4];
  v1[4] = 0;
  if (v6)
    dispatch_release(v6);
  v7 = *v4;
  *v4 = 0;
  if (v7)
    dispatch_release(v7);
  *v1 = &off_1E14E5838;
  v8 = (std::__shared_weak_count *)v1[2];
  if (v8)
    std::__shared_weak_count::__release_weak(v8);
  _Unwind_Resume(a1);
}

void HTTPStallTimer::setup(HTTPStallTimer *this)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  unint64_t *p_shared_weak_owners;
  unint64_t v5;
  NSObject *v6;
  NSObject *v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD v10[5];
  std::__shared_weak_count *v11;

  v3 = *((_QWORD *)this + 1);
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v2)
  {
    p_shared_weak_owners = (unint64_t *)&v2->__shared_weak_owners_;
    do
      v5 = __ldxr(p_shared_weak_owners);
    while (__stxr(v5 + 1, p_shared_weak_owners));
  }
  v6 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *((dispatch_queue_t *)this + 3));
  v7 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = v6;
  if (v7)
  {
    dispatch_release(v7);
    v6 = *((_QWORD *)this + 4);
  }
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3321888768;
  v10[2] = ___ZN14HTTPStallTimer5setupEv_block_invoke;
  v10[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14HTTPStallTimerEE_e5_v8__0l;
  v10[4] = v3;
  v11 = v2;
  if (v2)
  {
    v8 = (unint64_t *)&v2->__shared_weak_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  dispatch_source_set_event_handler(v6, v10);
  dispatch_source_set_timer(v6, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_resume(v6);
  if (v11)
    std::__shared_weak_count::__release_weak(v11);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

uint64_t HTTPProtocol::reportsDataStalls(HTTPProtocol *this)
{
  void *v1;

  v1 = (void *)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration");
  if (v1)
    return objc_msgSend(v1, "_reportsDataStalls");
  else
    return 1;
}

uint64_t ___ZN15HTTP2Connection15initializeHTTP2EP4Tube_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

uint64_t ___ZN25HTTP3ConnectionCacheEntry10ingestTubeEP4Tubeb_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (result)
  {
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)result + 56))(result, 0);
    return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
  }
  return result;
}

uint64_t ___ZN20HTTP3ConnectionCache18_entryFindOrCreateEPK22HTTPConnectionCacheKey_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

uint64_t ___ZN20HTTP3ConnectionCache10ingestTubeEP4Tubeb_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

void TLSCallbackServerTrust::~TLSCallbackServerTrust(TLSCallbackServerTrust *this)
{
  const void *v2;
  const void *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;

  *(_QWORD *)this = &off_1E14EC6B0;
  v2 = (const void *)*((_QWORD *)this + 7);
  if (v2)
  {
    _Block_release(v2);
    *((_QWORD *)this + 7) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 8);
  if (v3)
  {
    _Block_release(v3);
    *((_QWORD *)this + 8) = 0;
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 96);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 80);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 40);
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  *(_QWORD *)this = &off_1E14E5838;
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

{
  TLSCallbackServerTrust::~TLSCallbackServerTrust(this);
  JUMPOUT(0x186DB748CLL);
}

void sub_183F4A180(_Unwind_Exception *a1)
{
  _QWORD *v1;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 12));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 10));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 5));
  v3 = (std::__shared_weak_count *)v1[4];
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  *v1 = &off_1E14E5838;
  v4 = (std::__shared_weak_count *)v1[2];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  _Unwind_Resume(a1);
}

void HTTP3ConnectionCache::enableCellTimer(HTTP3ConnectionCache *this)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  unint64_t *p_shared_weak_owners;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  NSObject *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  NSObject *v13;
  _QWORD v14[5];
  _QWORD handler[5];
  std::__shared_weak_count *v16;

  v3 = *((_QWORD *)this + 1);
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v2)
  {
    p_shared_weak_owners = (unint64_t *)&v2->__shared_weak_owners_;
    do
      v5 = __ldxr(p_shared_weak_owners);
    while (__stxr(v5 + 1, p_shared_weak_owners));
  }
  v6 = *((_QWORD *)this + 9);
  v7 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 8) + 80))(*((_QWORD *)this + 8));
  v8 = (void *)*((_QWORD *)this + 14);
  *((_QWORD *)this + 14) = v7;

  v9 = *((_QWORD *)this + 14);
  v10 = MEMORY[0x1E0C809B0];
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3321888768;
  handler[2] = ___ZN20HTTP3ConnectionCache15enableCellTimerEv_block_invoke;
  handler[3] = &__block_descriptor_48_ea8_32c45_ZTSNSt3__18weak_ptrI20HTTP3ConnectionCacheEE_e5_v8__0l;
  handler[4] = v3;
  v16 = v2;
  if (v2)
  {
    v11 = (unint64_t *)&v2->__shared_weak_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  dispatch_source_set_event_handler(v9, handler);
  (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
  v13 = *((_QWORD *)this + 14);
  v14[0] = v10;
  v14[1] = 3221225472;
  v14[2] = ___ZN20HTTP3ConnectionCache15enableCellTimerEv_block_invoke_7;
  v14[3] = &__block_descriptor_40_e5_v8__0l;
  v14[4] = v6;
  dispatch_source_set_cancel_handler(v13, v14);
  dispatch_source_set_timer(*((dispatch_source_t *)this + 14), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_resume(*((dispatch_object_t *)this + 14));
  if (v16)
    std::__shared_weak_count::__release_weak(v16);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

void sub_183F4A308(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  std::__shared_weak_count *v20;

  if (a20)
    std::__shared_weak_count::__release_weak(a20);
  if (v20)
    std::__shared_weak_count::__release_weak(v20);
  _Unwind_Resume(exception_object);
}

NSXCredentialStorage *XCredentialStorage::createEmptyXCredentialStorage(XCredentialStorage *this)
{
  __NSCFMemoryURLCredentialStorage *v1;
  NSXCredentialStorage *v2;

  v1 = objc_alloc_init(__NSCFMemoryURLCredentialStorage);
  v2 = (NSXCredentialStorage *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 32, 0);
  *(_OWORD *)v2 = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  NSXCredentialStorage::NSXCredentialStorage(v2, v1);

  return v2;
}

_QWORD *_CFURLCredentialStorageCreateWithProperties(const __CFAllocator *a1, const __CFString *a2, CFDictionaryRef theDict)
{
  _BOOL4 v4;
  uint64_t Instance;
  _QWORD *v6;
  int v7;
  _QWORD *result;

  if (theDict)
    v4 = CFDictionaryGetValue(theDict, CFSTR("kCFURLStorageSessionIsPrivate")) == (const void *)*MEMORY[0x1E0C9AE40];
  else
    v4 = 1;
  if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1)
    dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_2_1169);
  Instance = _CFRuntimeCreateInstance();
  v6 = (_QWORD *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    v6 = (_QWORD *)(Instance + 16);
    *(_QWORD *)(Instance + 128) = 0;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }
  *v6 = &off_1E14EBBE0;
  v6[1] = &unk_1E14EBC30;
  v6[3] = &unk_1E14EBCB8;
  v6[2] = &off_1E14E5838;
  _CoreLockable::_CoreLockable((_CoreLockable *)(v6 + 3), 1);
  *v6 = &off_1E14EC860;
  v6[1] = &unk_1E14EC900;
  v6[2] = &unk_1E14EC968;
  v6[3] = &unk_1E14EC988;
  v7 = ActualCredentialStorage::initialize((ActualCredentialStorage *)v6, a2, v4);
  result = v6 - 2;
  if (!v7)
  {
    CFRelease(result);
    return 0;
  }
  return result;
}

void sub_183F4A5F4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 16) = v2;
  _Unwind_Resume(a1);
}

void _CoreLockable::_CoreLockable(_CoreLockable *this, int a2)
{
  pthread_mutexattr_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E14E6990;
  if (a2)
  {
    pthread_mutexattr_init(&v3);
    pthread_mutexattr_settype(&v3, 2);
    pthread_mutex_init((pthread_mutex_t *)((char *)this + 8), &v3);
    pthread_mutexattr_destroy(&v3);
  }
  else
  {
    pthread_mutex_init((pthread_mutex_t *)((char *)this + 8), 0);
  }
}

uint64_t ActualCredentialStorage::initialize(ActualCredentialStorage *this, const __CFString *a2, int a3)
{
  char *v6;
  const __CFAllocator *v7;
  _OWORD *v8;
  const __CFAllocator *v9;
  const __CFAllocator *v10;
  _OWORD *v11;
  CFAllocatorRef v12;
  int v13;
  uint64_t result;
  CFTypeRef v15;

  v6 = (char *)this - 16;
  v7 = CFGetAllocator((char *)this - 16);
  v8 = CFAllocatorAllocate(v7, 64, 0);
  *v8 = 0u;
  v8[1] = 0u;
  v8[2] = 0u;
  v8[3] = 0u;
  v9 = CFGetAllocator(v6);
  *(_QWORD *)v8 = off_1E14ECBE0;
  *((_QWORD *)v8 + 1) = v9;
  *((_QWORD *)v8 + 2) = &unk_1E14ECC38;
  *((_QWORD *)v8 + 3) = &unk_1E14ECCA0;
  *((_QWORD *)v8 + 4) = &off_1E14EA3E8;
  *((_QWORD *)v8 + 5) = CFDictionaryCreateMutable(v9, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *((_QWORD *)v8 + 6) = &off_1E14EA408;
  *((_QWORD *)v8 + 7) = CFDictionaryCreateMutable(v9, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *((_QWORD *)this + 13) = v8;
  if (!a3)
  {
LABEL_4:
    if (a2)
      v15 = CFRetain(a2);
    else
      v15 = 0;
    *((_QWORD *)this + 12) = v15;
    return 1;
  }
  v10 = CFGetAllocator(v6);
  v11 = CFAllocatorAllocate(v10, 48, 0);
  *v11 = 0u;
  v11[1] = 0u;
  v11[2] = 0u;
  v12 = CFGetAllocator(v6);
  *(_QWORD *)v11 = off_1E14EDDE0;
  *((_QWORD *)v11 + 1) = v12;
  *((_QWORD *)v11 + 2) = &unk_1E14EDE50;
  *((_QWORD *)v11 + 3) = &unk_1E14EDEB8;
  *((_BYTE *)v11 + 40) = 0;
  *((_QWORD *)this + 14) = v11;
  v13 = PersistentCredentialStorage::initialize((PersistentCredentialStorage *)v11, a2);
  result = *((_QWORD *)this + 14);
  if (v13)
  {
    if (!result)
      return result;
    goto LABEL_4;
  }
  if (result)
    (*(void (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  result = 0;
  *((_QWORD *)this + 14) = 0;
  return result;
}

void sub_183F4A818(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 32) = v2;
  CFRelease(*(CFTypeRef *)(v1 + 40));
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void TLSCallbackQueue::~TLSCallbackQueue(uint64_t **this)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;

  *this = (uint64_t *)&off_1E14E8328;
  std::unique_ptr<std::list<std::shared_ptr<TLSCallbackClientCertificate>>>::reset[abi:nn180100](this + 8, 0);
  std::unique_ptr<std::list<std::shared_ptr<TLSCallbackServerTrust>>>::reset[abi:nn180100](this + 7, 0);
  std::unique_ptr<std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>>::reset[abi:nn180100](this + 6, 0);
  v2 = (std::__shared_weak_count *)this[4];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  *this = (uint64_t *)&off_1E14E5838;
  v3 = (std::__shared_weak_count *)this[2];
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

{
  TLSCallbackQueue::~TLSCallbackQueue(this);
  JUMPOUT(0x186DB748CLL);
}

void PropertyObserver::~PropertyObserver(PropertyObserver *this)
{
  const void *v1;

  *(_QWORD *)this = &off_1E14E81C8;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    _Block_release(v1);
}

{
  const void *v1;

  *(_QWORD *)this = &off_1E14E81C8;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    _Block_release(v1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t NWIOConnection::getQUICPeerIdleTimeout(nw_connection_t *this)
{
  NSObject *v2;
  nw_protocol_metadata_t v3;
  uint64_t peer_idle_timeout;

  v2 = nw_protocol_copy_quic_connection_definition();
  v3 = nw_connection_copy_protocol_metadata(this[34], v2);
  if (!v3)
  {
    peer_idle_timeout = 0;
    if (!v2)
      return peer_idle_timeout;
    goto LABEL_3;
  }
  peer_idle_timeout = nw_quic_connection_get_peer_idle_timeout();
  nw_release(v3);
  if (v2)
LABEL_3:
    nw_release(v2);
  return peer_idle_timeout;
}

void sub_183F4A960(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  nw_release(v2);
  if (v1)
    nw_release(v1);
  _Unwind_Resume(a1);
}

void HTTPStallTimer::~HTTPStallTimer(HTTPStallTimer *this)
{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  *(_QWORD *)this = &off_1E14E7068;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 48);
  std::unique_ptr<std::set<std::shared_ptr<void>>>::reset[abi:nn180100]((uint64_t *)this + 5, 0);
  v2 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
    dispatch_release(v2);
  v3 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v3)
    dispatch_release(v3);
  *(_QWORD *)this = &off_1E14E5838;
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
}

{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  *(_QWORD *)this = &off_1E14E7068;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 48);
  std::unique_ptr<std::set<std::shared_ptr<void>>>::reset[abi:nn180100]((uint64_t *)this + 5, 0);
  v2 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
    dispatch_release(v2);
  v3 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v3)
    dispatch_release(v3);
  *(_QWORD *)this = &off_1E14E5838;
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  JUMPOUT(0x186DB748CLL);
}

void Tube::_onqueue_cleanupConnection(Tube *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  TransportConnection *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  if (*((_BYTE *)this + 120) && *((_QWORD *)this + 17))
  {
    v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 14) + 80))(*((_QWORD *)this + 14));
    v3 = *((_QWORD *)this + 17);
    if (v3)
    {
      if (v2)
        v4 = v2 - 176;
      else
        v4 = 0;
      (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD))(*(_QWORD *)v3 + 280))(v3, *(_QWORD *)(v4 + 80), 1, 0);
    }
    *((_BYTE *)this + 120) = 0;
  }
  if (!*((_BYTE *)this + 296))
  {
    v5 = (TransportConnection *)*((_QWORD *)this + 17);
    if (v5)
    {
      if (*((_BYTE *)this + 240))
      {
        (*(void (**)(TransportConnection *, _QWORD))(*(_QWORD *)v5 + 152))(v5, 0);
        v5 = (TransportConnection *)*((_QWORD *)this + 17);
      }
      TransportConnection::rstConnectionEstablishmentDelegate(v5);
      v6 = (std::__shared_weak_count *)*((_QWORD *)this + 18);
      *((_QWORD *)this + 17) = 0;
      *((_QWORD *)this + 18) = 0;
      if (v6)
      {
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          v8 = __ldaxr(p_shared_owners);
        while (__stlxr(v8 - 1, p_shared_owners));
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
    }
  }
}

void HTTP3Connection::_readDecoderStream(uint64_t a1, dispatch_data_t data)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD v14[6];
  std::__shared_weak_count *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  _QWORD applier[5];

  v3 = MEMORY[0x1E0C809B0];
  applier[0] = MEMORY[0x1E0C809B0];
  applier[1] = 3221225472;
  applier[2] = ___ZN15HTTP3Connection18_readDecoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke;
  applier[3] = &__block_descriptor_40_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
  applier[4] = a1;
  dispatch_data_apply(data, applier);
  if (*(_QWORD *)(a1 + 1008) && (*(_BYTE *)(a1 + 920) & 4) == 0)
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v16, *(_QWORD *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
    v4 = *(_QWORD *)(a1 + 1008);
    v5 = *(_QWORD *)(a1 + 1064);
    v14[0] = v3;
    v14[1] = 3321888768;
    v14[2] = ___ZN15HTTP3Connection18_readDecoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke_2;
    v14[3] = &__block_descriptor_56_ea8_40c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e83_v44__0__NSObject_OS_nw_content_context__8__NSObject_OS_dispatch_data__16B24___qi_28l;
    v14[4] = a1;
    v14[5] = v16;
    v15 = v17;
    if (v17)
    {
      p_shared_owners = (unint64_t *)&v17->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v4 + 56))(v4, v5, 1, 132000, v14);
    v8 = v15;
    if (v15)
    {
      v9 = (unint64_t *)&v15->__shared_owners_;
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    v11 = v17;
    if (v17)
    {
      v12 = (unint64_t *)&v17->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }
}

void sub_183F4AC44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  va_list va;

  va_start(va, a8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t AwaitingTube::getKey(AwaitingTube *this)
{
  return *((_QWORD *)this + 4);
}

void HTTPMessage::setTrailerFields(HTTPMessage *this, CFTypeRef cf)
{
  const void *v4;

  if (cf)
    CFRetain(cf);
  v4 = (const void *)*((_QWORD *)this + 14);
  if (v4)
    CFRelease(v4);
  *((_QWORD *)this + 14) = cf;
}

CFTypeRef CFHostGetInfo(uint64_t a1, int a2, BOOL *a3)
{
  const void *v5;
  uint64_t v6;
  const void *Value;
  CFTypeRef v8;
  CFTypeID v9;
  __CFDictionary *Mutable;
  const __CFAllocator *v11;

  v5 = (const void *)infoToString(a2);
  if (HostBase::Class(void)::sOnce_HostBase != -1)
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
  if (a1)
    v6 = a1 + 16;
  else
    v6 = 0;
  CFRetain((CFTypeRef)(v6 - 16));
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 32));
  ++*(_QWORD *)(v6 + 16);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v6 + 96), v5);
  if (Value)
    v8 = CFRetain(Value);
  else
    v8 = 0;
  HostBase::unlock((HostBase *)v6);
  if (a3)
    *a3 = v8 != 0;
  if (v8)
  {
    if (v8 == (CFTypeRef)*MEMORY[0x1E0C9B0D0]
      || (v9 = CFGetTypeID(v8), v9 == CFErrorGetTypeID())
      || v8 == (CFTypeRef)*MEMORY[0x1E0C9AE40])
    {
      CFRelease(v8);
      return 0;
    }
    else
    {
      if (HostBase::Class(void)::sOnce_HostBase != -1)
        dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
      CFRetain((CFTypeRef)(v6 - 16));
      pthread_mutex_lock((pthread_mutex_t *)(v6 + 32));
      ++*(_QWORD *)(v6 + 16);
      Mutable = *(__CFDictionary **)(v6 + 128);
      if (!Mutable)
      {
        v11 = CFGetAllocator((CFTypeRef)(v6 - 16));
        Mutable = CFDictionaryCreateMutable(v11, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        *(_QWORD *)(v6 + 128) = Mutable;
      }
      CFDictionarySetValue(Mutable, v5, v8);
      CFRelease(v8);
      HostBase::unlock((HostBase *)v6);
    }
  }
  return v8;
}

void HostBase::unlock(HostBase *this)
{
  uint64_t v2;
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  void (**ValueAtIndex)(void);

  v2 = *((_QWORD *)this + 2) - 1;
  *((_QWORD *)this + 2) = v2;
  if (v2)
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 32));
  }
  else
  {
    v3 = (const __CFArray *)*((_QWORD *)this + 14);
    *((_QWORD *)this + 14) = 0;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 32));
    if (v3)
    {
      Count = CFArrayGetCount(v3);
      if (Count >= 1)
      {
        v5 = Count;
        for (i = 0; i != v5; ++i)
        {
          ValueAtIndex = (void (**)(void))CFArrayGetValueAtIndex(v3, i);
          ValueAtIndex[2]();
        }
      }
      CFRelease(v3);
    }
  }
  CFRelease((char *)this - 16);
}

void ___ZN15HTTP3Connection18_readControlStreamEv_block_invoke(uint64_t a1, void **a2, void *a3, CFIndex a4, uint64_t a5)
{
  NSObject *v9;
  uint64_t v10;
  dispatch_data_t map;
  unsigned __int8 *v12;
  char v13;
  char v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  _QWORD *v21;
  void *v22;
  uint64_t v23;
  int v24;
  NSObject *v25;
  uint64_t v26;
  unsigned __int8 *v27;
  dispatch_data_t v28;
  HTTP3Connection *v29;
  unsigned __int8 *v30;
  dispatch_data_t v31;
  unsigned __int8 *v32;
  char v33;
  char v34;
  uint64_t v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *i;
  std::__shared_weak_count *v43;
  void **v44;
  unint64_t *p_shared_owners;
  unint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t *v52;
  _QWORD *v53;
  void *v54;
  void *v55;
  void *v56;
  void **v57[2];
  size_t size_ptr;
  void *v59;
  size_t v60;
  void *v61;
  void *buffer_ptr[4];
  CFStreamError v63;

  buffer_ptr[3] = *(void **)MEMORY[0x1E0C80C00];
  v9 = a3;
  if (!v9 || (_DWORD)a5)
  {
    if (a4 != 4)
      goto LABEL_20;
    if ((_DWORD)a5 != -2300)
      goto LABEL_20;
    v18 = *(_QWORD *)(a1 + 40);
    if ((*(_BYTE *)(v18 + 920) & 4) != 0)
      goto LABEL_20;
    v19 = *(_QWORD *)(v18 + 1008);
    if (v19)
    {
      if ((*(uint64_t (**)(_QWORD))(*(_QWORD *)v19 + 120))(*(_QWORD *)(v18 + 1008)) != -1)
      {
LABEL_20:
        v63.domain = a4;
        *(_QWORD *)&v63.error = a5;
        if (!HTTP3Connection::checkAndPerformFallback(*(HTTP3Connection **)(a1 + 40), v63))
        {
          v23 = *(_QWORD *)(a1 + 40);
          *(_BYTE *)(v23 + 920) |= 2u;
          if (*(_QWORD *)(v23 + 1136) == *(_QWORD *)(v23 + 1144))
            HTTP3Connection::_cleanupConnection((HTTP3Connection *)v23, 256, 0);
          goto LABEL_30;
        }
        CFN_LOG_h3connection();
        v20 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          v21 = *(_QWORD **)(a1 + 40);
          v22 = (void *)v21[152];
          LODWORD(buffer_ptr[0]) = 134218240;
          *(void **)((char *)buffer_ptr + 4) = v21;
          WORD2(buffer_ptr[1]) = 2048;
          *(void **)((char *)&buffer_ptr[1] + 6) = v22;
          _os_log_impl(&dword_183ECA000, v20, OS_LOG_TYPE_DEFAULT, "%p %llu Control stream fallback triggered", (uint8_t *)buffer_ptr, 0x16u);
        }
LABEL_23:

        goto LABEL_30;
      }
      v18 = *(_QWORD *)(a1 + 40);
    }
    *(_QWORD *)(v18 + 1160) = 4;
    *(_DWORD *)(v18 + 1168) = -1;
    HTTP3Connection::_cleanupConnection((HTTP3Connection *)v18, 260, 0);
    HTTP3Connection::reportServerProtocolViolation(*(_QWORD *)(a1 + 40), 2, -1);
    CFN_LOG_h3connection();
    v20 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
    {
      v53 = *(_QWORD **)(a1 + 40);
      v54 = (void *)v53[152];
      LODWORD(buffer_ptr[0]) = 134218240;
      *(void **)((char *)buffer_ptr + 4) = v53;
      WORD2(buffer_ptr[1]) = 2048;
      *(void **)((char *)&buffer_ptr[1] + 6) = v54;
      _os_log_fault_impl(&dword_183ECA000, v20, OS_LOG_TYPE_FAULT, "%p %llu Control stream closed but connection is alive", (uint8_t *)buffer_ptr, 0x16u);
    }
    goto LABEL_23;
  }
  v10 = *(_QWORD *)(a1 + 40);
  if ((*(_BYTE *)(v10 + 920) & 1) != 0 || *a2 == (void *)4)
  {
    if (*(_QWORD *)(v10 + 992))
      HTTP3Connection::_stopStallRecovery((HTTP3Connection *)v10);
    switch((unint64_t)*a2)
    {
      case 0uLL:
      case 1uLL:
      case 5uLL:
        goto LABEL_28;
      case 2uLL:
      case 6uLL:
        goto LABEL_31;
      case 3uLL:
        buffer_ptr[0] = 0;
        v57[0] = 0;
        map = dispatch_data_create_map(v9, (const void **)buffer_ptr, (size_t *)v57);
        v60 = 0;
        v61 = buffer_ptr[0];
        v13 = QUICUtilities::quic_vle_decode((QUICUtilities *)&v61, (const unsigned __int8 **)v57, &v60, 0, v12);
        if (v57[0])
          v14 = 0;
        else
          v14 = v13;
        v15 = *(_QWORD *)(a1 + 40);
        if ((v14 & 1) != 0)
        {
          v16 = v60;
          if (*(_DWORD *)(v15 + 792) > (int)v60)
          {
            v17 = *(_DWORD *)(v15 + 796);
            if (v17 <= (int)v60)
            {
              if (v17 < (int)v60)
              {
                do
                {
                  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(v15 + 800, v17, v17);
                  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(v15 + 840, v17, v17);
                  ++v17;
                }
                while (v16 != v17);
              }
              *(_DWORD *)(v15 + 796) = v16 + 1;
            }
            else
            {
              std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__erase_unique<int>((uint64_t *)(v15 + 800), v60);
              std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__erase_unique<int>((uint64_t *)(v15 + 840), v16);
            }
            v49 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>((_QWORD *)(v15 + 672), v16);
            if (v49)
            {
              v50 = v49[3];
              if (v50)
              {
                HTTP2ServerPushStream::_invokeCompletionHadlers(v50, 0);
                HTTP2ServerPush::_removeStream((HTTP2ServerPush *)(v15 + 624), v16, 1);
              }
            }
            v51 = (_QWORD *)(v15 + 880);
            v52 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>(v51, v16);
            if (v52)
            {
              HTTP3Framer::cancelStream(v52[3], 268);
              std::__hash_table<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>>>::__erase_unique<int>(v51, v16);
            }

LABEL_34:
            HTTP3Connection::_readControlStream(*(HTTP3Connection **)(a1 + 40));
            goto LABEL_30;
          }
          *(_QWORD *)(v15 + 1160) = 4;
          *(_DWORD *)(v15 + 1168) = -1;
          HTTP3Connection::_cleanupConnection((HTTP3Connection *)v15, 264, 0);
          v37 = 177;
        }
        else
        {
          *(_QWORD *)(v15 + 1160) = 4;
          *(_DWORD *)(v15 + 1168) = -1;
          HTTP3Connection::_cleanupConnection((HTTP3Connection *)v15, 262, 0);
          v37 = 176;
        }
        HTTP3Connection::reportServerProtocolViolation(*(_QWORD *)(a1 + 40), v37, -1);

        goto LABEL_30;
      case 4uLL:
        v26 = *(_QWORD *)(a1 + 40);
        if ((*(_BYTE *)(v26 + 920) & 1) != 0)
        {
          *(_QWORD *)(v26 + 1160) = 4;
          *(_DWORD *)(v26 + 1168) = -1;
          HTTP3Connection::_cleanupConnection((HTTP3Connection *)v26, 261, 0);
          v24 = 145;
          goto LABEL_29;
        }
        *(_BYTE *)(v26 + 920) |= 1u;
        size_ptr = 0;
        v59 = 0;
        v28 = dispatch_data_create_map(v9, (const void **)&v59, &size_ptr);
        v29 = *(HTTP3Connection **)(a1 + 40);
        buffer_ptr[0] = (void *)size_ptr;
        v57[0] = (void **)v59;
        if (!size_ptr)
        {
LABEL_47:
          HTTP3Connection::_settingsReceived(v29);

          goto LABEL_34;
        }
        while (1)
        {
          v60 = 0;
          v61 = 0;
          if (!QUICUtilities::quic_vle_decode((QUICUtilities *)v57, (const unsigned __int8 **)buffer_ptr, (unint64_t *)&v61, 0, v27)|| !QUICUtilities::quic_vle_decode((QUICUtilities *)v57, (const unsigned __int8 **)buffer_ptr, &v60, 0, v30))
          {
            break;
          }
          if ((unsigned __int16)v61 == 1)
          {
            *((_QWORD *)v29 + 118) = v60;
          }
          else if ((unsigned __int16)v61 == 7)
          {
            *((_QWORD *)v29 + 119) = v60;
          }
          else if ((unsigned __int16)v61 - 2 < 4)
          {
            break;
          }
          if (!buffer_ptr[0])
          {
            v29 = *(HTTP3Connection **)(a1 + 40);
            goto LABEL_47;
          }
        }
        v39 = *(_QWORD *)(a1 + 40);
        *(_QWORD *)(v39 + 1160) = 4;
        *(_DWORD *)(v39 + 1168) = -1;
        HTTP3Connection::_cleanupConnection((HTTP3Connection *)v39, 265, 0);
        HTTP3Connection::reportServerProtocolViolation(*(_QWORD *)(a1 + 40), 144, -1);

        goto LABEL_30;
      case 7uLL:
        v60 = 0;
        v61 = 0;
        v31 = dispatch_data_create_map(v9, (const void **)&v61, &v60);
        size_ptr = 0;
        v59 = v61;
        v33 = QUICUtilities::quic_vle_decode((QUICUtilities *)&v59, (const unsigned __int8 **)&v60, &size_ptr, 0, v32);
        if (v60)
          v34 = 0;
        else
          v34 = v33;
        if ((v34 & 1) != 0)
        {
          if ((size_ptr & 3) == 0)
          {
            v40 = *(_QWORD *)(a1 + 40);
            memset(buffer_ptr, 0, 24);
            std::vector<std::shared_ptr<HTTP3Stream>>::__init_with_size[abi:nn180100]<std::shared_ptr<HTTP3Stream>*,std::shared_ptr<HTTP3Stream>*>(buffer_ptr, *(_QWORD **)(v40 + 1136), *(_QWORD **)(v40 + 1144), (uint64_t)(*(_QWORD *)(v40 + 1144) - *(_QWORD *)(v40 + 1136)) >> 4);
            v41 = (char *)buffer_ptr[0];
            for (i = (char *)buffer_ptr[1]; v41 != i; v41 += 16)
            {
              v44 = *(void ***)v41;
              v43 = (std::__shared_weak_count *)*((_QWORD *)v41 + 1);
              v57[0] = *(void ***)v41;
              v57[1] = (void **)&v43->__vftable;
              if (v43)
              {
                p_shared_owners = (unint64_t *)&v43->__shared_owners_;
                do
                  v46 = __ldxr(p_shared_owners);
                while (__stxr(v46 + 1, p_shared_owners));
              }
              if ((unint64_t)v44[42] >= size_ptr)
              {
                HTTP3Stream::_cleanupStream((uint64_t)v44, 256, 0);
                v44[33] = (void *)4;
                v44[34] = (void *)4294965096;
                HTTP3Stream::_protocolCallback((HTTP3Stream *)v44);
              }
              if (v43)
              {
                v47 = (unint64_t *)&v43->__shared_owners_;
                do
                  v48 = __ldaxr(v47);
                while (__stlxr(v48 - 1, v47));
                if (!v48)
                {
                  ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
                  std::__shared_weak_count::__release_weak(v43);
                }
              }
            }
            HTTP3Connection::_cleanupIfNoStreams(*(_QWORD *)(a1 + 40));
            v57[0] = buffer_ptr;
            std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](v57);

            goto LABEL_34;
          }
          v35 = *(_QWORD *)(a1 + 40);
          *(_QWORD *)(v35 + 1160) = 4;
          *(_DWORD *)(v35 + 1168) = -1;
          HTTP3Connection::_cleanupConnection((HTTP3Connection *)v35, 264, 0);
          v36 = 161;
        }
        else
        {
          v38 = *(_QWORD *)(a1 + 40);
          *(_QWORD *)(v38 + 1160) = 4;
          *(_DWORD *)(v38 + 1168) = -1;
          HTTP3Connection::_cleanupConnection((HTTP3Connection *)v38, 262, 0);
          v36 = 160;
        }
        HTTP3Connection::reportServerProtocolViolation(*(_QWORD *)(a1 + 40), v36, -1);

        goto LABEL_30;
      default:
        if ((char *)*a2 - 984832 < (char *)2)
        {
LABEL_28:
          HTTP3Connection::_cleanupConnection(*(HTTP3Connection **)(a1 + 40), 261, 0);
          v24 = 0;
          goto LABEL_29;
        }
LABEL_31:
        CFN_LOG_h3connection();
        v25 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
        {
          v55 = *(void **)(*(_QWORD *)(a1 + 40) + 1216);
          v56 = *a2;
          LODWORD(buffer_ptr[0]) = 134218240;
          *(void **)((char *)buffer_ptr + 4) = v55;
          WORD2(buffer_ptr[1]) = 2048;
          *(void **)((char *)&buffer_ptr[1] + 6) = v56;
          _os_log_debug_impl(&dword_183ECA000, v25, OS_LOG_TYPE_DEBUG, "%llu unsupported frame type %llu", (uint8_t *)buffer_ptr, 0x16u);
        }

        goto LABEL_34;
    }
  }
  *(_QWORD *)(v10 + 1160) = 4;
  *(_DWORD *)(v10 + 1168) = -1;
  HTTP3Connection::_cleanupConnection((HTTP3Connection *)v10, 266, 0);
  v24 = 146;
LABEL_29:
  HTTP3Connection::reportServerProtocolViolation(*(_QWORD *)(a1 + 40), v24, -1);
LABEL_30:

}

void sub_183F4B658(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  void *v15;
  void *v16;

  a9 = (void **)&a15;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&a9);

  _Unwind_Resume(a1);
}

BOOL ___ZN11HTTP3Framer11_readHeaderEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvN2H313FrameMetadataES2_b13CFStreamErrorE_block_invoke(uint64_t a1, int a2, int a3, void *__src, unint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  unsigned __int8 v9;
  unsigned __int8 *v10;
  int v11;
  unsigned __int8 *v12;
  char v13;
  unint64_t v15;
  _BYTE v16[9];
  uint64_t v17;

  v6 = *(_QWORD *)(a1 + 40);
  v7 = *(unsigned __int8 *)(v6 + 128);
  if (16 - v7 >= a5)
    v8 = a5;
  else
    v8 = 16 - v7;
  memcpy((void *)(v6 + 112 + v7), __src, v8);
  v9 = *(_BYTE *)(v6 + 128) + v8;
  *(_BYTE *)(v6 + 128) = v9;
  *(_QWORD *)(v6 + 96) = 0;
  *(_QWORD *)&v16[1] = v9;
  v17 = v6 + 112;
  v16[0] = 0;
  v15 = 0;
  v11 = QUICUtilities::quic_vle_decode((QUICUtilities *)&v17, (const unsigned __int8 **)&v16[1], &v15, (unint64_t *)v16, v10);
  v13 = 0;
  if (v11)
  {
    *(_QWORD *)(v6 + 80) = v15;
    *(_QWORD *)(v6 + 96) += v16[0];
    if (QUICUtilities::quic_vle_decode((QUICUtilities *)&v17, (const unsigned __int8 **)&v16[1], (unint64_t *)(v6 + 88), (unint64_t *)v16, v12))
    {
      *(_QWORD *)(v6 + 96) += v16[0];
      *(_BYTE *)(v6 + 128) = 0;
      v13 = 1;
    }
    else
    {
      v13 = 0;
    }
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v13;
  return *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t QUICUtilities::quic_vle_decode(QUICUtilities *this, const unsigned __int8 **a2, unint64_t *a3, unint64_t *a4, unsigned __int8 *a5)
{
  _DWORD *v5;
  unint64_t v6;
  unint64_t v7;
  unsigned int v8;
  unsigned int v10;

  if (!this)
    __assert_rtn("quic_vle_decode", "QUICUtilities.cpp", 48, "buffer");
  v5 = *(_DWORD **)this;
  if (!*(_QWORD *)this)
    __assert_rtn("quic_vle_decode", "QUICUtilities.cpp", 49, "*buffer");
  if (!a2)
    __assert_rtn("quic_vle_decode", "QUICUtilities.cpp", 50, "remaining_p");
  if (!a3)
    __assert_rtn("quic_vle_decode", "QUICUtilities.cpp", 51, "decoded_val");
  v6 = (unint64_t)*a2;
  if (!*a2)
    return 0;
  v7 = *(unsigned __int8 *)v5;
  if (v7 > 0x3F)
  {
    v10 = v7 >> 6;
    if (v10 == 2)
    {
      if (v6 >= 4)
      {
        v7 = bswap32(*v5 & 0xFFFFFF7F);
        v8 = 4;
        goto LABEL_8;
      }
    }
    else if (v10 == 1)
    {
      if (v6 >= 2)
      {
        v7 = bswap32(*(_WORD *)v5 & 0xFFBF) >> 16;
        v8 = 2;
        goto LABEL_8;
      }
    }
    else if (v6 >= 8)
    {
      v7 = bswap64(*(_QWORD *)v5 & 0xFFFFFFFFFFFFFF3FLL);
      v8 = 8;
      goto LABEL_8;
    }
    return 0;
  }
  v8 = 1;
LABEL_8:
  *a3 = v7;
  *(_QWORD *)this = (char *)v5 + v8;
  *a2 = (const unsigned __int8 *)(v6 - v8);
  if (a4)
    *(_BYTE *)a4 = v8;
  return 1;
}

void HTTP3Connection::_readControlStream(HTTP3Connection *this)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  _QWORD *v6;
  unint64_t *v7;
  unint64_t v8;
  _QWORD *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  const char *v22;
  int v23;
  _QWORD v24[6];
  std::__shared_weak_count *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  _QWORD v28[4];
  id v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;

  if (!*((_QWORD *)this + 126) || (*((_BYTE *)this + 920) & 4) != 0)
    return;
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v26, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
  v2 = *((_QWORD *)this + 128);
  v3 = MEMORY[0x1E0C809B0];
  v24[0] = MEMORY[0x1E0C809B0];
  v24[1] = 3321888768;
  v24[2] = ___ZN15HTTP3Connection18_readControlStreamEv_block_invoke;
  v24[3] = &__block_descriptor_56_ea8_40c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e65_v56__0_FrameMetadata_QQQ_8__NSObject_OS_dispatch_data__32___qi_40l;
  v24[4] = this;
  v24[5] = v26;
  v25 = v27;
  if (v27)
  {
    p_shared_owners = (unint64_t *)&v27->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v6 = v24;
  if (*(_DWORD *)(v2 + 76))
  {
    v22 = "_state == State::ReadingHeader";
    v23 = 241;
    goto LABEL_34;
  }
  if (*(_BYTE *)(v2 + 72))
  {
    v22 = "!_processingReadCall";
    v23 = 242;
LABEL_34:
    __assert_rtn("readFrame", "HTTP3Frame.mm", v23, v22);
  }
  *(_BYTE *)(v2 + 72) = 1;
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v32, *(_QWORD *)v2, *(std::__shared_weak_count **)(v2 + 8));
  v28[0] = v3;
  v28[1] = 3321888768;
  v28[2] = ___ZN11HTTP3Framer9readFrameEmU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorE_block_invoke;
  v28[3] = &unk_1E14F38A8;
  v30 = v32;
  v31 = v33;
  if (v33)
  {
    v7 = (unint64_t *)&v33->__shared_owners_;
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v9 = v6;
  v29 = v9;
  HTTP3Framer::_readFrame(v2, 1024, MEMORY[0x1E0C80D00], v28);

  v10 = v31;
  if (v31)
  {
    v11 = (unint64_t *)&v31->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = v33;
  if (v33)
  {
    v14 = (unint64_t *)&v33->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

  v16 = v25;
  if (v25)
  {
    v17 = (unint64_t *)&v25->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = v27;
  if (v27)
  {
    v20 = (unint64_t *)&v27->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
}

void sub_183F4BB78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  void *v22;
  uint64_t v23;
  uint64_t v24;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v23);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v24 - 64);

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a14);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void HTTP3Framer::_readFrame(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id v10;
  _QWORD v11[4];
  id v12;
  id v13;
  uint64_t v14;
  uint64_t v15;

  v7 = a3;
  v8 = a4;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = ___ZN11HTTP3Framer10_readFrameEmPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvN2H313FrameMetadataES2_13CFStreamErrorE_block_invoke;
  v11[3] = &unk_1E14F6DC8;
  v12 = v7;
  v13 = v8;
  v14 = a1;
  v15 = a2;
  v9 = v7;
  v10 = v8;
  HTTP3Framer::_read(a1, v11);

}

void sub_183F4BC70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

uint64_t HTTP3Stream::_handleSendError(HTTP3Stream *this, CFStreamError a2, int a3)
{
  uint64_t v4;
  CFIndex domain;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  id v23;
  void *v24;
  void *v25;
  std::__shared_weak_count *v27;
  uint64_t v28;
  _QWORD *v29;
  std::__shared_weak_count *v30;
  unint64_t *p_shared_owners;
  unint64_t v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  uint64_t v40;
  std::__shared_weak_count *v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  _BYTE buf[22];
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  int v48;
  __int16 v49;
  uint64_t v50;
  uint64_t v51;

  v4 = *(_QWORD *)&a2.error;
  domain = a2.domain;
  v51 = *MEMORY[0x1E0C80C00];
  switch(HTTP3Stream::_translateError(this, a2, 1))
  {
    case 0u:
      if (a3)
        goto LABEL_3;
      return 0;
    case 1u:
LABEL_3:
      v7 = *((_QWORD *)this + 43);
      if (v7)
        *(CFAbsoluteTime *)(v7 + 184) = CFAbsoluteTimeGetCurrent();
      *((_DWORD *)this + 28) = 4;
      CFN_LOG_h3stream();
      v8 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *((_QWORD *)this + 42);
        v10 = *((_QWORD *)this + 44);
        v11 = *((_QWORD *)this + 12);
        if (v11)
        {
          if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 56))(v11) < 0)
            v12 = 83;
          else
            v12 = 68;
          v13 = *((_QWORD *)this + 12);
          if (v13)
            v13 = *(_QWORD *)(v13 + 96);
        }
        else
        {
          v13 = 0;
          v12 = 78;
        }
        *(_DWORD *)buf = 134219010;
        *(_QWORD *)&buf[4] = this;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v9;
        v45 = 2114;
        v46 = v10;
        v47 = 1024;
        v48 = v12;
        v49 = 2048;
        v50 = v13;
        _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_DEFAULT, "%p ID=%llu %{public}@ sent request, body %c %lld", buf, 0x30u);
      }

      if (*((int *)this + 29) <= 2)
      {
        v42 = 0;
        v43 = 0;
        v27 = (std::__shared_weak_count *)*((_QWORD *)this + 7);
        if (v27)
        {
          v43 = std::__shared_weak_count::lock(v27);
          if (v43)
          {
            v28 = *((_QWORD *)this + 6);
            v42 = v28;
            if (v28)
            {
              std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v40, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
              if (v40)
              {
                v29 = *(_QWORD **)(v28 + 976);
                if (v29)
                {
                  v30 = v41;
                  *(_QWORD *)buf = v40;
                  *(_QWORD *)&buf[8] = v41;
                  if (v41)
                  {
                    p_shared_owners = (unint64_t *)&v41->__shared_owners_;
                    do
                      v32 = __ldxr(p_shared_owners);
                    while (__stxr(v32 + 1, p_shared_owners));
                    HTTPStallTimer::add(v29, (uint64_t *)buf);
                    do
                      v33 = __ldaxr(p_shared_owners);
                    while (__stlxr(v33 - 1, p_shared_owners));
                    if (!v33)
                    {
                      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
                      std::__shared_weak_count::__release_weak(v30);
                    }
                  }
                  else
                  {
                    HTTPStallTimer::add(v29, (uint64_t *)buf);
                  }
                }
              }
              v34 = v41;
              if (v41)
              {
                v35 = (unint64_t *)&v41->__shared_owners_;
                do
                  v36 = __ldaxr(v35);
                while (__stlxr(v36 - 1, v35));
                if (!v36)
                {
                  ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
                  std::__shared_weak_count::__release_weak(v34);
                }
              }
            }
          }
        }
        v37 = v43;
        if (v43)
        {
          v38 = (unint64_t *)&v43->__shared_owners_;
          do
            v39 = __ldaxr(v38);
          while (__stlxr(v39 - 1, v38));
          if (!v39)
          {
            ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
            std::__shared_weak_count::__release_weak(v37);
          }
        }
      }
      break;
    case 2u:
      *((_QWORD *)this + 33) = domain;
      *((_QWORD *)this + 34) = v4;
      break;
    case 3u:
      *((_QWORD *)this + 33) = 4;
      v14 = -4;
      goto LABEL_32;
    case 4u:
      goto LABEL_24;
    case 5u:
      *((_QWORD *)this + 33) = 4;
      v14 = -2205;
      goto LABEL_32;
    case 6u:
      if (!*((_DWORD *)this + 29))
        goto LABEL_31;
      v15 = (std::__shared_weak_count *)*((_QWORD *)this + 7);
      if (v15)
      {
        v16 = std::__shared_weak_count::lock(v15);
        *(_QWORD *)&buf[8] = v16;
        if (v16)
        {
          v17 = v16;
          v18 = *((_QWORD *)this + 6);
          *(_QWORD *)buf = v18;
          if (v18)
          {
            *(_QWORD *)(v18 + 1160) = 4;
            *(_DWORD *)(v18 + 1168) = -1;
            HTTP3Connection::_cleanupConnection((HTTP3Connection *)v18, 257, 0);
            HTTP3Connection::reportServerProtocolViolation(v18, 50, *((_QWORD *)this + 42));
          }
          v19 = (unint64_t *)&v17->__shared_owners_;
          do
            v20 = __ldaxr(v19);
          while (__stlxr(v20 - 1, v19));
          if (!v20)
          {
            ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
            std::__shared_weak_count::__release_weak(v17);
          }
        }
      }
LABEL_24:
      *((_QWORD *)this + 33) = 4;
      v14 = -1;
      goto LABEL_32;
    case 7u:
      v21 = *((_QWORD *)this + 37);
      if (v21)
        v22 = v21 - 176;
      else
        v22 = 0;
      v23 = *(id *)(v22 + 80);
      objc_msgSend(v23, "session");
      v24 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend((id)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*((_QWORD *)this + 8) + 128)), "host");
      v25 = (void *)objc_claimAutoreleasedReturnValue();
      if (v24)
        -[NSURLSession addToHTTPFallbackHosts:forbiddenProtocols:]((uint64_t)v24, v25, 80);

LABEL_31:
      *((_QWORD *)this + 33) = 4;
      v14 = -2200;
LABEL_32:
      *((_DWORD *)this + 68) = v14;
      break;
    default:
      break;
  }
  HTTP3Stream::_protocolCallback(this);
  return 1;
}

void sub_183F4C068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void HTTP3Stream::_read(HTTP3Stream *this, char a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  _QWORD *v9;
  unint64_t *v10;
  unint64_t v11;
  _QWORD *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  int v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  _QWORD v26[8];
  std::__shared_weak_count *v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  char v39;
  uint64_t v40;
  std::__shared_weak_count *v41;
  _QWORD v42[4];
  id v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  uint64_t v46;
  std::__shared_weak_count *v47;

  v3 = *((_QWORD *)this + 39);
  if (v3 && *(_DWORD *)(v3 + 40))
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v40, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
    v36 = 0;
    v37 = &v36;
    v38 = 0x2020000000;
    v39 = a2;
    v5 = MEMORY[0x1E0C809B0];
    do
    {
      v32 = 0;
      v33 = &v32;
      v34 = 0x2020000000;
      v35 = 1;
      v28 = 0;
      v29 = &v28;
      v30 = 0x2020000000;
      v31 = 1;
      v6 = *((_QWORD *)this + 3);
      v26[0] = v5;
      v26[1] = 3321888768;
      v26[2] = ___ZN11HTTP3Stream5_readEb_block_invoke;
      v26[3] = &unk_1E14F4470;
      v26[7] = v40;
      v27 = v41;
      if (v41)
      {
        p_shared_owners = (unint64_t *)&v41->__shared_owners_;
        do
          v8 = __ldxr(p_shared_owners);
        while (__stxr(v8 + 1, p_shared_owners));
      }
      v26[4] = &v32;
      v26[5] = &v36;
      v26[6] = &v28;
      v9 = v26;
      if (*(_BYTE *)(v6 + 72))
        __assert_rtn("read", "HTTP3Frame.mm", 210, "!_processingReadCall");
      *(_BYTE *)(v6 + 72) = 1;
      std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v46, *(_QWORD *)v6, *(std::__shared_weak_count **)(v6 + 8));
      v42[0] = v5;
      v42[1] = 3321888768;
      v42[2] = ___ZN11HTTP3Framer4readEU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorE_block_invoke;
      v42[3] = &unk_1E14F38E0;
      v44 = v46;
      v45 = v47;
      if (v47)
      {
        v10 = (unint64_t *)&v47->__shared_owners_;
        do
          v11 = __ldxr(v10);
        while (__stxr(v11 + 1, v10));
      }
      v12 = v9;
      v43 = v12;
      HTTP3Framer::_read(v6, v42);

      v13 = v45;
      if (v45)
      {
        v14 = (unint64_t *)&v45->__shared_owners_;
        do
          v15 = __ldaxr(v14);
        while (__stlxr(v15 - 1, v14));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
      }
      v16 = v47;
      if (v47)
      {
        v17 = (unint64_t *)&v47->__shared_owners_;
        do
          v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }

      *((_BYTE *)v33 + 24) = 0;
      v19 = *((unsigned __int8 *)v29 + 24);
      v20 = v27;
      if (v27)
      {
        v21 = (unint64_t *)&v27->__shared_owners_;
        do
          v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
      _Block_object_dispose(&v28, 8);
      _Block_object_dispose(&v32, 8);
    }
    while (!v19);
    if (*((_BYTE *)v37 + 24))
      HTTP3Stream::_protocolCallback(this);
    _Block_object_dispose(&v36, 8);
    v23 = v41;
    if (v41)
    {
      v24 = (unint64_t *)&v41->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
  }
  else
  {
    *((_BYTE *)this + 127) = 1;
  }
}

void sub_183F4C3B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Block_object_dispose(&a29, 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a33);
  _Unwind_Resume(a1);
}

void HTTP3Framer::_read(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  const char *v12;
  int v13;
  _QWORD v14[4];
  id v15;
  uint64_t v16;
  _QWORD v17[3];

  v3 = a2;
  v4 = v3;
  v5 = *(_DWORD *)(a1 + 76);
  if (v5 == 1)
  {
    if (!*(_QWORD *)(a1 + 104))
    {
      v12 = "_waitingBodySize > 0";
      v13 = 167;
      goto LABEL_19;
    }
    if (*(_QWORD *)(a1 + 136))
    {
      v12 = "_pendingData == nullptr";
      v13 = 168;
      goto LABEL_19;
    }
    if (*(_DWORD *)(a1 + 152))
    {
      memset(v17, 0, sizeof(v17));
      (*((void (**)(id, _QWORD *, _QWORD, _QWORD, _QWORD, _QWORD))v3 + 2))(v3, v17, 0, 0, *(_QWORD *)(a1 + 144), *(_QWORD *)(a1 + 152));
    }
    else
    {
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_QWORD *)(a1 + 48);
      v8 = *(_QWORD *)(a1 + 64);
      if (v8)
      {
        v9 = (*(uint64_t (**)(void))(v8 + 16))();
        v10 = 132001;
        if (v9 > 132001)
          v10 = v9;
        v11 = (v10 - 1);
      }
      else
      {
        v11 = 132000;
      }
      v14[0] = MEMORY[0x1E0C809B0];
      v14[1] = 3221225472;
      v14[2] = ___ZN11HTTP3Framer5_readEU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorE_block_invoke;
      v14[3] = &unk_1E14F6DA0;
      v16 = a1;
      v15 = v4;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v6 + 24))(v6, v7, 1, v11, v14);

    }
  }
  else if (!v5)
  {
    if (!*(_QWORD *)(a1 + 104))
    {
      HTTP3Framer::_readHeader(a1, *(void **)(a1 + 136), v3);
      goto LABEL_15;
    }
    v12 = "_waitingBodySize == 0";
    v13 = 162;
LABEL_19:
    __assert_rtn("_read", "HTTP3Frame.mm", v13, v12);
  }
LABEL_15:

}

void sub_183F4C5A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void HTTP3Framer::_readHeader(uint64_t a1, void *a2, void *a3)
{
  NSObject *v5;
  void (**v6)(id, __int128 *, dispatch_data_t, uint64_t, uint64_t, uint64_t);
  NSObject *v7;
  size_t v8;
  size_t size;
  size_t v10;
  __int128 *v11;
  size_t v12;
  dispatch_data_t subrange;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  dispatch_data_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD v26[4];
  NSObject *v27;
  uint64_t v28;
  _QWORD v29[3];
  __int128 v30;
  uint64_t v31;
  __int128 v32;
  uint64_t v33;
  _QWORD applier[6];
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  char v38;

  v5 = a2;
  v6 = a3;
  v35 = 0;
  v36 = &v35;
  v37 = 0x2020000000;
  v38 = 0;
  if (v5)
  {
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3221225472;
    applier[2] = ___ZN11HTTP3Framer11_readHeaderEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvN2H313FrameMetadataES2_b13CFStreamErrorE_block_invoke;
    applier[3] = &unk_1E14F9100;
    applier[4] = &v35;
    applier[5] = a1;
    dispatch_data_apply(v5, applier);
    if (*((_BYTE *)v36 + 24))
    {
      v7 = *(NSObject **)(a1 + 136);
      if (!v7)
        __assert_rtn("_readHeader", "HTTP3Frame.mm", 114, "_pendingData");
      v8 = *(_QWORD *)(a1 + 96);
      size = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 136));
      v10 = size - v8;
      if (size < v8)
        __assert_rtn("_readHeader", "HTTP3Frame.mm", 117, "pendingSize >= headerSize");
      v11 = (__int128 *)(a1 + 80);
      v12 = *(_QWORD *)(a1 + 88);
      if (v10 >= v12)
      {
        subrange = dispatch_data_create_subrange(v7, v8, v12);
        v21 = *(_QWORD *)(a1 + 88);
        v22 = *(NSObject **)(a1 + 136);
        if (v10 == v21)
        {
          v23 = 0;
        }
        else
        {
          v23 = dispatch_data_create_subrange(v22, v21 + v8, v10 - v21);
          v22 = *(NSObject **)(a1 + 136);
        }
        *(_QWORD *)(a1 + 136) = v23;

        v32 = *v11;
        v33 = *(_QWORD *)(a1 + 96);
        if (*(_QWORD *)(a1 + 136))
        {
          v24 = 0;
          v25 = 0;
        }
        else
        {
          v25 = *(_QWORD *)(a1 + 144);
          v24 = *(_QWORD *)(a1 + 152);
        }
        v6[2](v6, &v32, subrange, 1, v25, v24);
      }
      else
      {
        subrange = dispatch_data_create_subrange(v7, v8, v10);
        *(_DWORD *)(a1 + 76) = 1;
        *(_QWORD *)(a1 + 104) = *(_QWORD *)(a1 + 88) - v10;
        v14 = *(void **)(a1 + 136);
        *(_QWORD *)(a1 + 136) = 0;

        v31 = *(_QWORD *)(a1 + 96);
        v30 = *v11;
        v6[2](v6, &v30, subrange, 0, *(_QWORD *)(a1 + 144), *(_QWORD *)(a1 + 152));
      }
LABEL_22:

      goto LABEL_23;
    }
  }
  if (!*(_DWORD *)(a1 + 152))
  {
    v15 = *(_QWORD *)(a1 + 16);
    v16 = *(_QWORD *)(a1 + 48);
    v17 = *(_QWORD *)(a1 + 64);
    if (v17)
    {
      v18 = (*(uint64_t (**)(void))(v17 + 16))();
      v19 = 132001;
      if (v18 > 132001)
        v19 = v18;
      v20 = (v19 - 1);
    }
    else
    {
      v20 = 132000;
    }
    v26[0] = MEMORY[0x1E0C809B0];
    v26[1] = 3221225472;
    v26[2] = ___ZN11HTTP3Framer11_readHeaderEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvN2H313FrameMetadataES2_b13CFStreamErrorE_block_invoke_2;
    v26[3] = &unk_1E14F6DA0;
    v28 = a1;
    v27 = v6;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v15 + 24))(v15, v16, 1, v20, v26);
    subrange = v27;
    goto LABEL_22;
  }
  memset(v29, 0, sizeof(v29));
  v6[2](v6, (__int128 *)v29, 0, *(_BYTE *)(a1 + 128) == 0, *(_QWORD *)(a1 + 144), *(_QWORD *)(a1 + 152));
LABEL_23:
  _Block_object_dispose(&v35, 8);

}

